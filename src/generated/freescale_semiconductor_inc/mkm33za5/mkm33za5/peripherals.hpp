/// Auto-generated code for MKM33ZA5
/// Generated by Alloy Code Generator
/// Source: nxp_mkm33.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:51
#ifndef ALLOY_GENERATED_MKM33ZA5_PERIPHERALS_HPP
#define ALLOY_GENERATED_MKM33ZA5_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mkm33za5 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 2;
    constexpr bool has_aips = true;
    constexpr uint32_t num_aips_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 5;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 3;
    constexpr bool has_afe = true;
    constexpr uint32_t num_afe_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_lcd = true;
    constexpr uint32_t num_lcd_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 18;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_wdog = true;
    constexpr uint32_t num_wdog_instances = 1;
    constexpr bool has_xbar = true;
    constexpr uint32_t num_xbar_instances = 1;
    constexpr bool has_tmr0 = true;
    constexpr uint32_t num_tmr0_instances = 1;
    constexpr bool has_tmr1 = true;
    constexpr uint32_t num_tmr1_instances = 1;
    constexpr bool has_tmr2 = true;
    constexpr uint32_t num_tmr2_instances = 1;
    constexpr bool has_tmr3 = true;
    constexpr uint32_t num_tmr3_instances = 1;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_osc = true;
    constexpr uint32_t num_osc_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 4;
    constexpr bool has_vref = true;
    constexpr uint32_t num_vref_instances = 1;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_llwu = true;
    constexpr uint32_t num_llwu_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_mtb = true;
    constexpr uint32_t num_mtb_instances = 1;
    constexpr bool has_mtbdwt = true;
    constexpr uint32_t num_mtbdwt_instances = 1;
    constexpr bool has_rom = true;
    constexpr uint32_t num_rom_instances = 1;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct aips_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct afe_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lcd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 18;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct xbar_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tmr0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tmr1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tmr2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tmr3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct vref_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct llwu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtbdwt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rom_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 18;
    constexpr uint32_t max_gpio_pins = 288;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
    constexpr bool has_uart3 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFA_FlashConfig_BASE = 0x00000400;
    constexpr uint32_t FTFA_BASE = 0x40020000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
    };

    /// Peripheral instances
    inline Registers* FTFA_FlashConfig = reinterpret_cast<Registers*>(FTFA_FlashConfig_BASE);
    inline Registers* FTFA = reinterpret_cast<Registers*>(FTFA_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT = (1U << 0);  ///< no description available
        constexpr uint32_t NMI_EN = (1U << 2);  ///< no description available
        constexpr uint32_t EXE_MODE = (1U << 3);  ///< no description available
        constexpr uint32_t CLK_SRC = (1U << 5);  ///< no description available
    }

}

// ============================================================================
// AIPS Peripheral
// ============================================================================

namespace aips {
    /// Base addresses
    constexpr uint32_t AIPS_BASE = 0x40000000;

    /// AIPS Register structure
    struct Registers {
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS = reinterpret_cast<Registers*>(AIPS_BASE);

    // Bit definitions
    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t AC7 = (3 << 0);  ///< Attribute Check
        constexpr uint32_t RO7 = (1U << 3);  ///< Read Only
        constexpr uint32_t AC6 = (3 << 4);  ///< Attribute Check
        constexpr uint32_t RO6 = (1U << 7);  ///< Read Only
        constexpr uint32_t AC5 = (3 << 8);  ///< Attribute Check
        constexpr uint32_t RO5 = (1U << 11);  ///< Read Only
        constexpr uint32_t AC4 = (3 << 12);  ///< Attribute Check
        constexpr uint32_t RO4 = (1U << 15);  ///< Read Only
        constexpr uint32_t AC3 = (3 << 16);  ///< Attribute Check
        constexpr uint32_t RO3 = (1U << 19);  ///< Read Only
        constexpr uint32_t AC2 = (3 << 20);  ///< Attribute Check
        constexpr uint32_t RO2 = (1U << 23);  ///< Read Only
        constexpr uint32_t AC1 = (3 << 24);  ///< Attribute Check
        constexpr uint32_t RO1 = (1U << 27);  ///< Read Only
        constexpr uint32_t AC0 = (3 << 28);  ///< Attribute Check
        constexpr uint32_t RO0 = (1U << 31);  ///< Read Only
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX0_BASE = 0x40021000;
    constexpr uint32_t DMAMUX1_BASE = 0x40022000;
    constexpr uint32_t DMAMUX2_BASE = 0x40023000;
    constexpr uint32_t DMAMUX3_BASE = 0x40024000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t SAR0;  ///< Offset: 0x100 - Source Address Register
        volatile uint32_t DAR0;  ///< Offset: 0x104 - Destination Address Register
        volatile uint32_t DSR_BCR0;  ///< Offset: 0x108 - DMA Status Register / Byte Count Register
        volatile uint32_t DSR0;  ///< Offset: 0x10B - DMA_DSR0 register.
        volatile uint32_t DCR0;  ///< Offset: 0x10C - DMA Control Register
        volatile uint32_t SAR1;  ///< Offset: 0x110 - Source Address Register
        volatile uint32_t DAR1;  ///< Offset: 0x114 - Destination Address Register
        volatile uint32_t DSR_BCR1;  ///< Offset: 0x118 - DMA Status Register / Byte Count Register
        volatile uint32_t DSR1;  ///< Offset: 0x11B - DMA_DSR1 register.
        volatile uint32_t DCR1;  ///< Offset: 0x11C - DMA Control Register
        volatile uint32_t SAR2;  ///< Offset: 0x120 - Source Address Register
        volatile uint32_t DAR2;  ///< Offset: 0x124 - Destination Address Register
        volatile uint32_t DSR_BCR2;  ///< Offset: 0x128 - DMA Status Register / Byte Count Register
        volatile uint32_t DSR2;  ///< Offset: 0x12B - DMA_DSR2 register.
        volatile uint32_t DCR2;  ///< Offset: 0x12C - DMA Control Register
        volatile uint32_t SAR3;  ///< Offset: 0x130 - Source Address Register
        volatile uint32_t DAR3;  ///< Offset: 0x134 - Destination Address Register
        volatile uint32_t DSR_BCR3;  ///< Offset: 0x138 - DMA Status Register / Byte Count Register
        volatile uint32_t DSR3;  ///< Offset: 0x13B - DMA_DSR3 register.
        volatile uint32_t DCR3;  ///< Offset: 0x13C - DMA Control Register
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX0 = reinterpret_cast<Registers*>(DMAMUX0_BASE);
    inline Registers* DMAMUX1 = reinterpret_cast<Registers*>(DMAMUX1_BASE);
    inline Registers* DMAMUX2 = reinterpret_cast<Registers*>(DMAMUX2_BASE);
    inline Registers* DMAMUX3 = reinterpret_cast<Registers*>(DMAMUX3_BASE);

    // Bit definitions
    /// SAR0 Register bits
    namespace sar0_bits {
        constexpr uint32_t SAR = (32 << 0);  ///< SAR
    }

    /// DAR0 Register bits
    namespace dar0_bits {
        constexpr uint32_t DAR = (32 << 0);  ///< DAR
    }

    /// DSR_BCR0 Register bits
    namespace dsr_bcr0_bits {
        constexpr uint32_t BCR = (24 << 0);  ///< BCR
        constexpr uint32_t DONE = (1U << 24);  ///< Transactions Done
        constexpr uint32_t BSY = (1U << 25);  ///< Busy
        constexpr uint32_t REQ = (1U << 26);  ///< Request
        constexpr uint32_t BED = (1U << 28);  ///< Bus Error on Destination
        constexpr uint32_t BES = (1U << 29);  ///< Bus Error on Source
        constexpr uint32_t CE = (1U << 30);  ///< Configuration Error
    }

    /// DCR0 Register bits
    namespace dcr0_bits {
        constexpr uint32_t LCH2 = (2 << 0);  ///< Link Channel 2
        constexpr uint32_t LCH1 = (2 << 2);  ///< Link Channel 1
        constexpr uint32_t LINKCC = (2 << 4);  ///< Link Channel Control
        constexpr uint32_t D_REQ = (1U << 7);  ///< Disable Request
        constexpr uint32_t DMOD = (4 << 8);  ///< Destination Address Modulo
        constexpr uint32_t SMOD = (4 << 12);  ///< Source Address Modulo
        constexpr uint32_t START = (1U << 16);  ///< Start Transfer
        constexpr uint32_t DSIZE = (2 << 17);  ///< Destination Size
        constexpr uint32_t DINC = (1U << 19);  ///< Destination Increment
        constexpr uint32_t SSIZE = (2 << 20);  ///< Source Size
        constexpr uint32_t SINC = (1U << 22);  ///< Source Increment
        constexpr uint32_t EADREQ = (1U << 23);  ///< Enable asynchronous DMA requests
        constexpr uint32_t UMNSM = (2 << 24);  ///< User Mode, Nonsecure Mode
        constexpr uint32_t CHACR = (2 << 26);  ///< Channel Access Control
        constexpr uint32_t AA = (1U << 28);  ///< Auto-align
        constexpr uint32_t CS = (1U << 29);  ///< Cycle Steal
        constexpr uint32_t ERQ = (1U << 30);  ///< Enable Peripheral Request
        constexpr uint32_t EINT = (1U << 31);  ///< Enable Interrupt on Completion of Transfer
    }

    /// SAR1 Register bits
    namespace sar1_bits {
        constexpr uint32_t SAR = (32 << 0);  ///< SAR
    }

    /// DAR1 Register bits
    namespace dar1_bits {
        constexpr uint32_t DAR = (32 << 0);  ///< DAR
    }

    /// DSR_BCR1 Register bits
    namespace dsr_bcr1_bits {
        constexpr uint32_t BCR = (24 << 0);  ///< BCR
        constexpr uint32_t DONE = (1U << 24);  ///< Transactions Done
        constexpr uint32_t BSY = (1U << 25);  ///< Busy
        constexpr uint32_t REQ = (1U << 26);  ///< Request
        constexpr uint32_t BED = (1U << 28);  ///< Bus Error on Destination
        constexpr uint32_t BES = (1U << 29);  ///< Bus Error on Source
        constexpr uint32_t CE = (1U << 30);  ///< Configuration Error
    }

    /// DCR1 Register bits
    namespace dcr1_bits {
        constexpr uint32_t LCH2 = (2 << 0);  ///< Link Channel 2
        constexpr uint32_t LCH1 = (2 << 2);  ///< Link Channel 1
        constexpr uint32_t LINKCC = (2 << 4);  ///< Link Channel Control
        constexpr uint32_t D_REQ = (1U << 7);  ///< Disable Request
        constexpr uint32_t DMOD = (4 << 8);  ///< Destination Address Modulo
        constexpr uint32_t SMOD = (4 << 12);  ///< Source Address Modulo
        constexpr uint32_t START = (1U << 16);  ///< Start Transfer
        constexpr uint32_t DSIZE = (2 << 17);  ///< Destination Size
        constexpr uint32_t DINC = (1U << 19);  ///< Destination Increment
        constexpr uint32_t SSIZE = (2 << 20);  ///< Source Size
        constexpr uint32_t SINC = (1U << 22);  ///< Source Increment
        constexpr uint32_t EADREQ = (1U << 23);  ///< Enable asynchronous DMA requests
        constexpr uint32_t UMNSM = (2 << 24);  ///< User Mode, Nonsecure Mode
        constexpr uint32_t CHACR = (2 << 26);  ///< Channel Access Control
        constexpr uint32_t AA = (1U << 28);  ///< Auto-align
        constexpr uint32_t CS = (1U << 29);  ///< Cycle Steal
        constexpr uint32_t ERQ = (1U << 30);  ///< Enable Peripheral Request
        constexpr uint32_t EINT = (1U << 31);  ///< Enable Interrupt on Completion of Transfer
    }

    /// SAR2 Register bits
    namespace sar2_bits {
        constexpr uint32_t SAR = (32 << 0);  ///< SAR
    }

    /// DAR2 Register bits
    namespace dar2_bits {
        constexpr uint32_t DAR = (32 << 0);  ///< DAR
    }

    /// DSR_BCR2 Register bits
    namespace dsr_bcr2_bits {
        constexpr uint32_t BCR = (24 << 0);  ///< BCR
        constexpr uint32_t DONE = (1U << 24);  ///< Transactions Done
        constexpr uint32_t BSY = (1U << 25);  ///< Busy
        constexpr uint32_t REQ = (1U << 26);  ///< Request
        constexpr uint32_t BED = (1U << 28);  ///< Bus Error on Destination
        constexpr uint32_t BES = (1U << 29);  ///< Bus Error on Source
        constexpr uint32_t CE = (1U << 30);  ///< Configuration Error
    }

    /// DCR2 Register bits
    namespace dcr2_bits {
        constexpr uint32_t LCH2 = (2 << 0);  ///< Link Channel 2
        constexpr uint32_t LCH1 = (2 << 2);  ///< Link Channel 1
        constexpr uint32_t LINKCC = (2 << 4);  ///< Link Channel Control
        constexpr uint32_t D_REQ = (1U << 7);  ///< Disable Request
        constexpr uint32_t DMOD = (4 << 8);  ///< Destination Address Modulo
        constexpr uint32_t SMOD = (4 << 12);  ///< Source Address Modulo
        constexpr uint32_t START = (1U << 16);  ///< Start Transfer
        constexpr uint32_t DSIZE = (2 << 17);  ///< Destination Size
        constexpr uint32_t DINC = (1U << 19);  ///< Destination Increment
        constexpr uint32_t SSIZE = (2 << 20);  ///< Source Size
        constexpr uint32_t SINC = (1U << 22);  ///< Source Increment
        constexpr uint32_t EADREQ = (1U << 23);  ///< Enable asynchronous DMA requests
        constexpr uint32_t UMNSM = (2 << 24);  ///< User Mode, Nonsecure Mode
        constexpr uint32_t CHACR = (2 << 26);  ///< Channel Access Control
        constexpr uint32_t AA = (1U << 28);  ///< Auto-align
        constexpr uint32_t CS = (1U << 29);  ///< Cycle Steal
        constexpr uint32_t ERQ = (1U << 30);  ///< Enable Peripheral Request
        constexpr uint32_t EINT = (1U << 31);  ///< Enable Interrupt on Completion of Transfer
    }

    /// SAR3 Register bits
    namespace sar3_bits {
        constexpr uint32_t SAR = (32 << 0);  ///< SAR
    }

    /// DAR3 Register bits
    namespace dar3_bits {
        constexpr uint32_t DAR = (32 << 0);  ///< DAR
    }

    /// DSR_BCR3 Register bits
    namespace dsr_bcr3_bits {
        constexpr uint32_t BCR = (24 << 0);  ///< BCR
        constexpr uint32_t DONE = (1U << 24);  ///< Transactions Done
        constexpr uint32_t BSY = (1U << 25);  ///< Busy
        constexpr uint32_t REQ = (1U << 26);  ///< Request
        constexpr uint32_t BED = (1U << 28);  ///< Bus Error on Destination
        constexpr uint32_t BES = (1U << 29);  ///< Bus Error on Source
        constexpr uint32_t CE = (1U << 30);  ///< Configuration Error
    }

    /// DCR3 Register bits
    namespace dcr3_bits {
        constexpr uint32_t LCH2 = (2 << 0);  ///< Link Channel 2
        constexpr uint32_t LCH1 = (2 << 2);  ///< Link Channel 1
        constexpr uint32_t LINKCC = (2 << 4);  ///< Link Channel Control
        constexpr uint32_t D_REQ = (1U << 7);  ///< Disable Request
        constexpr uint32_t DMOD = (4 << 8);  ///< Destination Address Modulo
        constexpr uint32_t SMOD = (4 << 12);  ///< Source Address Modulo
        constexpr uint32_t START = (1U << 16);  ///< Start Transfer
        constexpr uint32_t DSIZE = (2 << 17);  ///< Destination Size
        constexpr uint32_t DINC = (1U << 19);  ///< Destination Increment
        constexpr uint32_t SSIZE = (2 << 20);  ///< Source Size
        constexpr uint32_t SINC = (1U << 22);  ///< Source Increment
        constexpr uint32_t EADREQ = (1U << 23);  ///< Enable asynchronous DMA requests
        constexpr uint32_t UMNSM = (2 << 24);  ///< User Mode, Nonsecure Mode
        constexpr uint32_t CHACR = (2 << 26);  ///< Channel Access Control
        constexpr uint32_t AA = (1U << 28);  ///< Auto-align
        constexpr uint32_t CS = (1U << 29);  ///< Cycle Steal
        constexpr uint32_t ERQ = (1U << 30);  ///< Enable Peripheral Request
        constexpr uint32_t EINT = (1U << 31);  ///< Enable Interrupt on Completion of Transfer
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0x4000A000;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t CESR;  ///< Offset: 0x00 - Control/Error Status Register
        volatile uint32_t EAR%s;  ///< Offset: 0x10 - Error Address Register, slave port n
        volatile uint32_t EDR%s;  ///< Offset: 0x14 - Error Detail Register, slave port n
        volatile uint32_t RGD%s_WORD0;  ///< Offset: 0x400 - Region Descriptor n, Word 0
        volatile uint32_t RGD%s_WORD1;  ///< Offset: 0x404 - Region Descriptor n, Word 1
        volatile uint32_t RGD%s_WORD2;  ///< Offset: 0x408 - Region Descriptor n, Word 2
        volatile uint32_t RGD%s_WORD3;  ///< Offset: 0x40C - Region Descriptor n, Word 3
        volatile uint32_t RGDAAC%s;  ///< Offset: 0x800 - Region Descriptor Alternate Access Control n
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// CESR Register bits
    namespace cesr_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t NRGD = (4 << 8);  ///< Number Of Region Descriptors
        constexpr uint32_t NSP = (4 << 12);  ///< Number Of Slave Ports
        constexpr uint32_t HRL = (4 << 16);  ///< Hardware Revision Level
        constexpr uint32_t SPERR = (2 << 30);  ///< Slave Port n Error
    }

    /// EAR%s Register bits
    namespace ear%s_bits {
        constexpr uint32_t EADDR = (32 << 0);  ///< Error Address
    }

    /// EDR%s Register bits
    namespace edr%s_bits {
        constexpr uint32_t ERW = (1U << 0);  ///< Error Read/Write
        constexpr uint32_t EATTR = (3 << 1);  ///< Error Attributes
        constexpr uint32_t EMN = (4 << 4);  ///< Error Master Number
        constexpr uint32_t EPID = (8 << 8);  ///< Error Process Identification
        constexpr uint32_t EACD = (16 << 16);  ///< Error Access Control Detail
    }

    /// RGD%s_WORD0 Register bits
    namespace rgd%s_word0_bits {
        constexpr uint32_t SRTADDR = (27 << 5);  ///< Start Address
    }

    /// RGD%s_WORD1 Register bits
    namespace rgd%s_word1_bits {
        constexpr uint32_t ENDADDR = (27 << 5);  ///< End Address
    }

    /// RGD%s_WORD2 Register bits
    namespace rgd%s_word2_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus Master 0 Process Identifier enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus Master 1 Process Identifier enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus Master 2 Process Identifier Enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus Master 3 Process Identifier Enable
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

    /// RGD%s_WORD3 Register bits
    namespace rgd%s_word3_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t PIDMASK = (8 << 16);  ///< Process Identifier Mask
        constexpr uint32_t PID = (8 << 24);  ///< Process Identifier
    }

    /// RGDAAC%s Register bits
    namespace rgdaac%s_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus Master 0 Process Identifier Enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus Master 1 Process Identifier Enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access Control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus Master 2 Process Identifier Enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus Master 3 Process Identifier Enable
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x40029000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - RNGA Control Register
        volatile uint32_t SR;  ///< Offset: 0x04 - RNGA Status Register
        volatile uint32_t ER;  ///< Offset: 0x08 - RNGA Entropy Register
        volatile uint32_t OR;  ///< Offset: 0x0C - RNGA Output Register
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t GO = (1U << 0);  ///< Go
        constexpr uint32_t HA = (1U << 1);  ///< High Assurance
        constexpr uint32_t INTM = (1U << 2);  ///< Interrupt Mask
        constexpr uint32_t CLRI = (1U << 3);  ///< Clear Interrupt
        constexpr uint32_t SLP = (1U << 4);  ///< Sleep
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t SECV = (1U << 0);  ///< Security Violation
        constexpr uint32_t LRS = (1U << 1);  ///< Last Read Status
        constexpr uint32_t ORU = (1U << 2);  ///< Output Register Underflow
        constexpr uint32_t ERRI = (1U << 3);  ///< Error Interrupt
        constexpr uint32_t SLP = (1U << 4);  ///< Sleep
        constexpr uint32_t OREG_LVL = (8 << 8);  ///< Output Register Level
        constexpr uint32_t OREG_SIZE = (8 << 16);  ///< Output Register Size
    }

    /// ER Register bits
    namespace er_bits {
        constexpr uint32_t EXT_ENT = (32 << 0);  ///< External Entropy
    }

    /// OR Register bits
    namespace or_bits {
        constexpr uint32_t RANDOUT = (32 << 0);  ///< Random Output
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x4002B000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1%s;  ///< Offset: 0x00 - ADC Status and Control Registers 1
        volatile uint32_t CFG1;  ///< Offset: 0x10 - ADC Configuration Register 1
        volatile uint32_t CFG2;  ///< Offset: 0x14 - ADC Configuration Register 2
        volatile uint32_t R%s;  ///< Offset: 0x18 - ADC Data Result Register
        volatile uint32_t CV%s;  ///< Offset: 0x28 - Compare Value Registers
        volatile uint32_t SC2;  ///< Offset: 0x30 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x34 - Status and Control Register 3
        volatile uint32_t OFS;  ///< Offset: 0x38 - ADC Offset Correction Register
        volatile uint32_t PG;  ///< Offset: 0x3C - ADC Plus-Side Gain Register
        volatile uint32_t CLPD;  ///< Offset: 0x44 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPS;  ///< Offset: 0x48 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP4;  ///< Offset: 0x4C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP3;  ///< Offset: 0x50 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2;  ///< Offset: 0x54 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1;  ///< Offset: 0x58 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0;  ///< Offset: 0x5C - ADC Plus-Side General Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// SC1%s Register bits
    namespace sc1%s_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Sample Time Configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-Power Configuration
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t ADLSTS = (2 << 0);  ///< Long Sample Time Select
        constexpr uint32_t ADHSC = (1U << 2);  ///< High-Speed Configuration
        constexpr uint32_t ADACKEN = (1U << 3);  ///< Asynchronous Clock Output Enable
        constexpr uint32_t MUXSEL = (1U << 4);  ///< ADC Mux Select
    }

    /// R%s Register bits
    namespace r%s_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data result
    }

    /// CV%s Register bits
    namespace cv%s_bits {
        constexpr uint32_t CV = (16 << 0);  ///< Compare Value.
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage Reference Selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA Enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare Function Range Enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware Average Select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware Average Enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous Conversion Enable
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration Failed Flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset Error Correction Value
    }

    /// PG Register bits
    namespace pg_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Plus-Side Gain
    }

    /// CLPD Register bits
    namespace clpd_bits {
        constexpr uint32_t CLPD = (6 << 0);  ///< Calibration Value
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (6 << 0);  ///< Calibration Value
    }

    /// CLP4 Register bits
    namespace clp4_bits {
        constexpr uint32_t CLP4 = (10 << 0);  ///< Calibration Value
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (9 << 0);  ///< Calibration Value
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (8 << 0);  ///< Calibration Value
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (7 << 0);  ///< Calibration Value
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (6 << 0);  ///< Calibration Value
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT0_BASE = 0x4002D000;
    constexpr uint32_t PIT1_BASE = 0x4002E000;
    constexpr uint32_t LPTMR_BASE = 0x4003C000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LDVAL%s;  ///< Offset: 0x100 - Timer Load Value Register
        volatile uint32_t CVAL%s;  ///< Offset: 0x104 - Current Timer Value Register
        volatile uint32_t TCTRL%s;  ///< Offset: 0x108 - Timer Control Register
        volatile uint32_t TFLG%s;  ///< Offset: 0x10C - Timer Flag Register
    };

    /// Peripheral instances
    inline Registers* PIT0 = reinterpret_cast<Registers*>(PIT0_BASE);
    inline Registers* PIT1 = reinterpret_cast<Registers*>(PIT1_BASE);
    inline Registers* LPTMR = reinterpret_cast<Registers*>(LPTMR_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable - (PIT section)
    }

    /// LDVAL%s Register bits
    namespace ldval%s_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value
    }

    /// CVAL%s Register bits
    namespace cval%s_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL%s Register bits
    namespace tctrl%s_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable
        constexpr uint32_t CHN = (1U << 2);  ///< Chain Mode
    }

    /// TFLG%s Register bits
    namespace tflg%s_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag
    }

}

// ============================================================================
// AFE Peripheral
// ============================================================================

namespace afe {
    /// Base addresses
    constexpr uint32_t AFE_BASE = 0x40030000;

    /// AFE Register structure
    struct Registers {
        volatile uint32_t CH0_CFR;  ///< Offset: 0x00 - Channel0 Configuration Register
        volatile uint32_t CH1_CFR;  ///< Offset: 0x04 - Channel1 Configuration Register
        volatile uint32_t CH2_CFR;  ///< Offset: 0x08 - Channel2 Configuration Register
        volatile uint32_t CH3_CFR;  ///< Offset: 0x0C - Channel3 Configuration Register
        volatile uint32_t CR;  ///< Offset: 0x18 - Control Register
        volatile uint32_t CKR;  ///< Offset: 0x1C - Clock Configuration Register
        volatile uint32_t DI;  ///< Offset: 0x20 - DMA and Interrupt Register
        volatile uint32_t CH0_DR;  ///< Offset: 0x2C - Channel0 Delay Register
        volatile uint32_t CH1_DR;  ///< Offset: 0x30 - Channel1 Delay Register
        volatile uint32_t CH2_DR;  ///< Offset: 0x34 - Channel2 Delay Register
        volatile uint32_t CH3_DR;  ///< Offset: 0x38 - Channel3 Delay Register
        volatile uint32_t CH0_RR;  ///< Offset: 0x44 - Channel0 Result Register
        volatile uint32_t CH1_RR;  ///< Offset: 0x48 - Channel1 Result Register
        volatile uint32_t CH2_RR;  ///< Offset: 0x4C - Channel2 Result Register
        volatile uint32_t CH3_RR;  ///< Offset: 0x50 - Channel3 Result Register
        volatile uint32_t SR;  ///< Offset: 0x5C - Status Register
    };

    /// Peripheral instances
    inline Registers* AFE = reinterpret_cast<Registers*>(AFE_BASE);

    // Bit definitions
    /// CH0_CFR Register bits
    namespace ch0_cfr_bits {
        constexpr uint32_t HW_TRG = (1U << 9);  ///< Hardware Trigger Select
        constexpr uint32_t DEC_CLK_INP_SEL = (1U << 10);  ///< Decimator Clock Input Select
        constexpr uint32_t DEC_CLK_EDGE_SEL = (1U << 11);  ///< Decimator Clock Edge Select
        constexpr uint32_t CC = (1U << 12);  ///< Continuous Conversion/Single Conversion Mode Select
        constexpr uint32_t DEC_EN = (1U << 13);  ///< Decimation Filter enable
        constexpr uint32_t SD_MOD_EN = (1U << 14);  ///< Sigma Delta Modulator enable
        constexpr uint32_t BYP_MODE = (1U << 17);  ///< AFE Channel bypass mode
        constexpr uint32_t PGA_GAIN_SEL = (3 << 19);  ///< PGA Gain Select
        constexpr uint32_t PGA_EN = (1U << 24);  ///< PGA enable
        constexpr uint32_t DEC_OSR = (3 << 29);  ///< Decimator OverSampling Ratio select
    }

    /// CH1_CFR Register bits
    namespace ch1_cfr_bits {
        constexpr uint32_t HW_TRG = (1U << 9);  ///< Hardware Trigger Select
        constexpr uint32_t DEC_CLK_INP_SEL = (1U << 10);  ///< Decimator Clock Input Select
        constexpr uint32_t DEC_CLK_EDGE_SEL = (1U << 11);  ///< Decimator Clock Edge Select
        constexpr uint32_t CC = (1U << 12);  ///< Continuous Conversion/Single Conversion Mode Select
        constexpr uint32_t DEC_EN = (1U << 13);  ///< Decimation Filter enable
        constexpr uint32_t SD_MOD_EN = (1U << 14);  ///< Sigma Delta Modulator enable
        constexpr uint32_t BYP_MODE = (1U << 17);  ///< AFE Channel bypass mode
        constexpr uint32_t PGA_GAIN_SEL = (3 << 19);  ///< PGA Gain Select
        constexpr uint32_t PGA_EN = (1U << 24);  ///< PGA enable
        constexpr uint32_t DEC_OSR = (3 << 29);  ///< Decimator OverSampling Ratio select
    }

    /// CH2_CFR Register bits
    namespace ch2_cfr_bits {
        constexpr uint32_t HW_TRG = (1U << 9);  ///< Hardware Trigger Select
        constexpr uint32_t DEC_CLK_INP_SEL = (1U << 10);  ///< Decimator Clock Input Select
        constexpr uint32_t DEC_CLK_EDGE_SEL = (1U << 11);  ///< Decimator Clock Edge Select
        constexpr uint32_t CC = (1U << 12);  ///< Continuous Conversion/Single Conversion Mode Select
        constexpr uint32_t DEC_EN = (1U << 13);  ///< Decimation Filter enable
        constexpr uint32_t SD_MOD_EN = (1U << 14);  ///< Sigma Delta Modulator enable
        constexpr uint32_t BYP_MODE = (1U << 17);  ///< AFE Channel bypass mode
        constexpr uint32_t DEC_OSR = (3 << 29);  ///< Decimator OverSampling Ratio select
    }

    /// CH3_CFR Register bits
    namespace ch3_cfr_bits {
        constexpr uint32_t HW_TRG = (1U << 9);  ///< Hardware Trigger Select
        constexpr uint32_t DEC_CLK_INP_SEL = (1U << 10);  ///< Decimator Clock Input Select
        constexpr uint32_t DEC_CLK_EDGE_SEL = (1U << 11);  ///< Decimator Clock Edge Select
        constexpr uint32_t CC = (1U << 12);  ///< Continuous Conversion/Single Conversion Mode Select
        constexpr uint32_t DEC_EN = (1U << 13);  ///< Decimation Filter enable
        constexpr uint32_t SD_MOD_EN = (1U << 14);  ///< Sigma Delta Modulator enable
        constexpr uint32_t BYP_MODE = (1U << 17);  ///< AFE Channel bypass mode
        constexpr uint32_t DEC_OSR = (3 << 29);  ///< Decimator OverSampling Ratio select
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t STRTUP_CNT = (7 << 9);  ///< Start up count
        constexpr uint32_t RESULT_FORMAT = (1U << 18);  ///< Result Format
        constexpr uint32_t DLY_OK = (1U << 21);  ///< Delay OK
        constexpr uint32_t RST_B = (1U << 22);  ///< Software Reset
        constexpr uint32_t LPM_EN = (1U << 25);  ///< Low power Mode enable
        constexpr uint32_t SOFT_TRG3 = (1U << 27);  ///< Software Trigger3
        constexpr uint32_t SOFT_TRG2 = (1U << 28);  ///< Software Trigger2
        constexpr uint32_t SOFT_TRG1 = (1U << 29);  ///< Software Trigger1
        constexpr uint32_t SOFT_TRG0 = (1U << 30);  ///< Software Trigger0
        constexpr uint32_t MSTR_EN = (1U << 31);  ///< AFE Master Enable
    }

    /// CKR Register bits
    namespace ckr_bits {
        constexpr uint32_t CLS = (2 << 21);  ///< Clock Source Select
        constexpr uint32_t DIV = (4 << 28);  ///< Clock Divider Select
    }

    /// DI Register bits
    namespace di_bits {
        constexpr uint32_t INTEN3 = (1U << 23);  ///< Interrupt Enable 3
        constexpr uint32_t INTEN2 = (1U << 24);  ///< Interrupt Enable 2
        constexpr uint32_t INTEN1 = (1U << 25);  ///< Interrupt Enable 1
        constexpr uint32_t INTEN0 = (1U << 26);  ///< Interrupt Enable 0
        constexpr uint32_t DMAEN3 = (1U << 28);  ///< DMA Enable3
        constexpr uint32_t DMAEN2 = (1U << 29);  ///< DMA Enable2
        constexpr uint32_t DMAEN1 = (1U << 30);  ///< DMA Enable1
        constexpr uint32_t DMAEN0 = (1U << 31);  ///< DMA Enable0
    }

    /// CH0_DR Register bits
    namespace ch0_dr_bits {
        constexpr uint32_t DLY = (11 << 0);  ///< Delay
    }

    /// CH1_DR Register bits
    namespace ch1_dr_bits {
        constexpr uint32_t DLY = (11 << 0);  ///< Delay
    }

    /// CH2_DR Register bits
    namespace ch2_dr_bits {
        constexpr uint32_t DLY = (11 << 0);  ///< Delay
    }

    /// CH3_DR Register bits
    namespace ch3_dr_bits {
        constexpr uint32_t DLY = (11 << 0);  ///< Delay
    }

    /// CH0_RR Register bits
    namespace ch0_rr_bits {
        constexpr uint32_t SDR = (23 << 0);  ///< Sample Data Result
        constexpr uint32_t SIGN_BITS = (9 << 23);  ///< Sign Bits
    }

    /// CH1_RR Register bits
    namespace ch1_rr_bits {
        constexpr uint32_t SDR = (23 << 0);  ///< Sample Data Result
        constexpr uint32_t SIGN_BITS = (9 << 23);  ///< Sign Bits
    }

    /// CH2_RR Register bits
    namespace ch2_rr_bits {
        constexpr uint32_t SDR = (23 << 0);  ///< Sample Data Result
        constexpr uint32_t SIGN_BITS = (9 << 23);  ///< Sign Bits
    }

    /// CH3_RR Register bits
    namespace ch3_rr_bits {
        constexpr uint32_t SDR = (23 << 0);  ///< Sample Data Result
        constexpr uint32_t SIGN_BITS = (9 << 23);  ///< Sign Bits
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RDY3 = (1U << 16);  ///< AFE Ready4
        constexpr uint32_t RDY2 = (1U << 17);  ///< AFE Ready3
        constexpr uint32_t RDY1 = (1U << 18);  ///< AFE Ready2
        constexpr uint32_t RDY0 = (1U << 19);  ///< AFE Ready1
        constexpr uint32_t OVR3 = (1U << 21);  ///< Overflow Flag
        constexpr uint32_t OVR2 = (1U << 22);  ///< Overflow Flag
        constexpr uint32_t OVR1 = (1U << 23);  ///< Overflow Flag
        constexpr uint32_t OVR0 = (1U << 24);  ///< Overflow Flag
        constexpr uint32_t COC3 = (1U << 28);  ///< Conversion Complete
        constexpr uint32_t COC2 = (1U << 29);  ///< Conversion Complete
        constexpr uint32_t COC1 = (1U << 30);  ///< Conversion Complete
        constexpr uint32_t COC0 = (1U << 31);  ///< Conversion Complete
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40034000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x00 - CRC Data register
        volatile uint32_t DATAL;  ///< Offset: 0x00 - CRC_DATAL register.
        volatile uint32_t DATALL;  ///< Offset: 0x00 - CRC_DATALL register.
        volatile uint32_t DATALU;  ///< Offset: 0x01 - CRC_DATALU register.
        volatile uint32_t DATAH;  ///< Offset: 0x02 - CRC_DATAH register.
        volatile uint32_t DATAHL;  ///< Offset: 0x02 - CRC_DATAHL register.
        volatile uint32_t DATAHU;  ///< Offset: 0x03 - CRC_DATAHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial register
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// DATAL Register bits
    namespace datal_bits {
        constexpr uint32_t DATAL = (16 << 0);  ///< DATAL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// DATALL Register bits
    namespace datall_bits {
        constexpr uint32_t DATALL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit DATA
    }

    /// DATALU Register bits
    namespace datalu_bits {
        constexpr uint32_t DATALU = (8 << 0);  ///< DATALL stores the second 8 bits of the 32 bit CRC
    }

    /// DATAH Register bits
    namespace datah_bits {
        constexpr uint32_t DATAH = (16 << 0);  ///< DATAH stores the high 16 bits of the 16/32 bit CRC
    }

    /// DATAHL Register bits
    namespace datahl_bits {
        constexpr uint32_t DATAHL = (8 << 0);  ///< DATAHL stores the third 8 bits of the 32 bit CRC
    }

    /// DATAHU Register bits
    namespace datahu_bits {
        constexpr uint32_t DATAHU = (8 << 0);  ///< DATAHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low Polynominal Half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High Polynominal Half-word
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TCRC = (1U << 24);  ///< no description available
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC Data Register As Seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read Of CRC Data Register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type Of Transpose For Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type Of Transpose For Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x4003E000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT1;  ///< Offset: 0x00 - System Options Register 1
        volatile uint32_t SOPT1_CFG;  ///< Offset: 0x04 - SOPT1 Configuration Register
        volatile uint32_t CTRL_REG;  ///< Offset: 0x1004 - System Control Register
        volatile uint32_t SDID;  ///< Offset: 0x1024 - System Device Identification Register
        volatile uint32_t SCGC4;  ///< Offset: 0x1034 - System Clock Gating Control Register 4
        volatile uint32_t SCGC5;  ///< Offset: 0x1038 - System Clock Gating Control Register 5
        volatile uint32_t SCGC6;  ///< Offset: 0x103C - System Clock Gating Control Register 6
        volatile uint32_t SCGC7;  ///< Offset: 0x1040 - System Clock Gating Control Register 7
        volatile uint32_t CLKDIV1;  ///< Offset: 0x1044 - System Clock Divider Register 1
        volatile uint32_t FCFG1;  ///< Offset: 0x104C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x1050 - Flash Configuration Register 2
        volatile uint32_t UID0;  ///< Offset: 0x1054 - Unique Identification Register 0
        volatile uint32_t UID1;  ///< Offset: 0x1058 - Unique Identification Register 1
        volatile uint32_t UID2;  ///< Offset: 0x105C - Unique Identification Register 2
        volatile uint32_t UID3;  ///< Offset: 0x1060 - Unique Identification Register 3
        volatile uint32_t MISC_CTL;  ///< Offset: 0x106C - Miscellaneous Control Register
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t SRAMSIZE = (4 << 12);  ///< Returns the size of the system RAM
        constexpr uint32_t OSC32KSEL = (2 << 18);  ///< 32K oscillator clock select
    }

    /// SOPT1_CFG Register bits
    namespace sopt1_cfg_bits {
        constexpr uint32_t LPTMR1SEL = (2 << 0);  ///< LP timer Channel1 Select
        constexpr uint32_t LPTMR2SEL = (2 << 2);  ///< LP timer Channel2 Select
        constexpr uint32_t LPTMR3SEL = (2 << 4);  ///< LP timer Channel3 Select
        constexpr uint32_t CMPOLPTMR0SEL = (1U << 6);  ///< Comparator output selection for LPTMR channel0
        constexpr uint32_t RAMSBDIS = (1U << 8);  ///< no description available
        constexpr uint32_t RAMBPEN = (1U << 9);  ///< RAM Bitline Precharge Enable
    }

    /// CTRL_REG Register bits
    namespace ctrl_reg_bits {
        constexpr uint32_t NMIDIS = (1U << 0);  ///< NMI Disable
        constexpr uint32_t PLL_VLP_EN = (1U << 1);  ///< PLL VLP Enable
        constexpr uint32_t PTC2_HD_EN = (1U << 2);  ///< PTC2 HighDrive Enable
        constexpr uint32_t SAR_TRG_CLK_SEL = (2 << 3);  ///< SAR ADC Trigger Clk Select
        constexpr uint32_t CLKOUTSEL = (3 << 5);  ///< Clock out Select
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (4 << 0);  ///< Pincount identification
        constexpr uint32_t DIEID = (4 << 4);  ///< Die ID
        constexpr uint32_t REVID = (4 << 8);  ///< Revision ID
        constexpr uint32_t SRAMSIZE = (4 << 12);  ///< SRAM Size
        constexpr uint32_t ATTR = (4 << 16);  ///< Attribute ID
        constexpr uint32_t SERIESID = (4 << 20);  ///< Series ID
        constexpr uint32_t SUBFAMID = (4 << 24);  ///< Sub-Family ID
        constexpr uint32_t FAMID = (4 << 28);  ///< Metering family ID
    }

    /// SCGC4 Register bits
    namespace scgc4_bits {
        constexpr uint32_t EWM = (1U << 1);  ///< External Watchdog Monitor Clock gate control
        constexpr uint32_t MCG = (1U << 4);  ///< MCG clock gate control.
        constexpr uint32_t OSC = (1U << 6);  ///< Oscillator (Mhz) Clock Gate Control
        constexpr uint32_t I2C0 = (1U << 7);  ///< I2C0 Clock Gate Control
        constexpr uint32_t I2C1 = (1U << 8);  ///< I2C1 Clock Gate Control
        constexpr uint32_t UART0 = (1U << 10);  ///< UART0 Clock Gate Control
        constexpr uint32_t UART1 = (1U << 11);  ///< UART1 Clock Gate Control
        constexpr uint32_t UART2 = (1U << 12);  ///< UART2 Clock Gate Control
        constexpr uint32_t UART3 = (1U << 13);  ///< UART3 Clock Gate Control
        constexpr uint32_t VREF = (1U << 15);  ///< VREF Clock Gate Control
        constexpr uint32_t CMP0 = (1U << 18);  ///< High Speed Comparator0 Clock Gate Control.
        constexpr uint32_t CMP1 = (1U << 19);  ///< High Speed Comparator1 Clock Gate Control.
        constexpr uint32_t SPI0 = (1U << 21);  ///< SPI0 Clock Gate Control
        constexpr uint32_t SPI1 = (1U << 22);  ///< SPI1 Clock Gate Control
    }

    /// SCGC5 Register bits
    namespace scgc5_bits {
        constexpr uint32_t SLCD = (1U << 3);  ///< Segmented LCD Clock Gate Control
        constexpr uint32_t PORTA = (1U << 6);  ///< PCTLA Clock Gate Control
        constexpr uint32_t PORTB = (1U << 7);  ///< PCTLB Clock Gate Control
        constexpr uint32_t PORTC = (1U << 8);  ///< PCTLC Clock Gate Control
        constexpr uint32_t PORTD = (1U << 9);  ///< PCTLD Clock Gate Control
        constexpr uint32_t PORTE = (1U << 10);  ///< PCTLE Clock Gate Control
        constexpr uint32_t PORTF = (1U << 11);  ///< PCTLF Clock Gate Control
        constexpr uint32_t PORTG = (1U << 12);  ///< PCTLG Clock Gate Control
        constexpr uint32_t PORTH = (1U << 13);  ///< PCTLH Clock Gate Control
        constexpr uint32_t PORTI = (1U << 14);  ///< PCTLI Clock Gate Control
        constexpr uint32_t IRTC = (1U << 16);  ///< IRTC Clock Gate Control
        constexpr uint32_t IRTCREGFILE = (1U << 17);  ///< IRTC_REG_FILE Clock Gate Control
        constexpr uint32_t WDOG = (1U << 19);  ///< Watchdog Clock Gate Control
        constexpr uint32_t XBAR = (1U << 21);  ///< Peripheral Crossbar Clock Gate Control
        constexpr uint32_t TMR0 = (1U << 23);  ///< Quadtimer0 Clock Gate Control
        constexpr uint32_t TMR1 = (1U << 24);  ///< Quadtimer1 Clock Gate Control
        constexpr uint32_t TMR2 = (1U << 25);  ///< Quadtimer2 Clock Gate Control
        constexpr uint32_t TMR3 = (1U << 26);  ///< Quadtimer3 Clock Gate Control
    }

    /// SCGC6 Register bits
    namespace scgc6_bits {
        constexpr uint32_t FTFA = (1U << 0);  ///< FTFA Clock Gate Control
        constexpr uint32_t DMAMUX0 = (1U << 1);  ///< DMA MUX0 Clock Gate Control
        constexpr uint32_t DMAMUX1 = (1U << 2);  ///< DMA MUX1 Clock Gate Control
        constexpr uint32_t DMAMUX2 = (1U << 3);  ///< DMA MUX2 Clock Gate Control
        constexpr uint32_t DMAMUX3 = (1U << 4);  ///< DMA MUX3 Clock Gate Control
        constexpr uint32_t RNGA = (1U << 9);  ///< RNGA Clock Gate Control
        constexpr uint32_t ADC = (1U << 11);  ///< SAR ADC Clock Gate Control
        constexpr uint32_t PIT0 = (1U << 13);  ///< PIT0 Clock Gate Control
        constexpr uint32_t PIT1 = (1U << 14);  ///< PIT1 Clock Gate Control
        constexpr uint32_t AFE = (1U << 16);  ///< AFE Clock Gate Control
        constexpr uint32_t CRC = (1U << 20);  ///< Programmable CRC Clock Gate Control
        constexpr uint32_t LPTMR = (1U << 28);  ///< LPTMR Clock Gate Control
        constexpr uint32_t SIM_LP = (1U << 30);  ///< SIM_LP Clock Gate Control
        constexpr uint32_t SIM_HP = (1U << 31);  ///< SIM_HP Clock Gate Control
    }

    /// SCGC7 Register bits
    namespace scgc7_bits {
        constexpr uint32_t MPU = (1U << 0);  ///< MPU Clock Gate control.
        constexpr uint32_t DMA = (1U << 1);  ///< DMA Clock Gate control.
    }

    /// CLKDIV1 Register bits
    namespace clkdiv1_bits {
        constexpr uint32_t SYSCLKMODE = (1U << 27);  ///< System Clock Mode
        constexpr uint32_t SYSDIV = (4 << 28);  ///< System Clock divider
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FLASHDIS = (1U << 0);  ///< Flash Disable
        constexpr uint32_t FLASHDOZE = (1U << 1);  ///< Flash Doze
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program flash size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR = (7 << 24);  ///< Max address block
    }

    /// UID0 Register bits
    namespace uid0_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UID1 Register bits
    namespace uid1_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UID2 Register bits
    namespace uid2_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UID3 Register bits
    namespace uid3_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// MISC_CTL Register bits
    namespace misc_ctl_bits {
        constexpr uint32_t XBARAFEMODOUTSEL = (2 << 0);  ///< XBAR AFE Modulator Output Select
        constexpr uint32_t DMADONESEL = (2 << 2);  ///< DMA Done select
        constexpr uint32_t AFECLKSEL = (2 << 4);  ///< AFE Clock Source Select
        constexpr uint32_t AFECLKPADDIR = (1U << 6);  ///< AFE Clock Pad Direction
        constexpr uint32_t UARTMODTYPE = (1U << 7);  ///< UART Modulation Type
        constexpr uint32_t UART0IRSEL = (1U << 8);  ///< UART0 IRDA Select
        constexpr uint32_t UART1IRSEL = (1U << 9);  ///< UART1 IRDA Select
        constexpr uint32_t UART2IRSEL = (1U << 10);  ///< UART2 IRDA Select
        constexpr uint32_t UART3IRSEL = (1U << 11);  ///< UART3 IRDA Select
        constexpr uint32_t XBARPITOUTSEL = (2 << 12);  ///< XBAR PIT Output select
        constexpr uint32_t EWMINSEL = (1U << 14);  ///< External Watchdog Monitor Input Select
        constexpr uint32_t TMR0PLLCLKSEL = (1U << 15);  ///< Timer CH0 PLL clock select
        constexpr uint32_t TMR0SCSSEL = (1U << 16);  ///< Quadtimer Channel0 Secondary Count Source Select
        constexpr uint32_t TMR1SCSSEL = (1U << 17);  ///< Quadtimer Channel1 Secondary Count Source Select
        constexpr uint32_t TMR2SCSSEL = (1U << 18);  ///< Quadtimer Channel2 Secondary Count Source Select
        constexpr uint32_t TMR3SCSSEL = (1U << 19);  ///< Quadtimer Channel3 Secondary Count Source Select
        constexpr uint32_t TMR0PCSSEL = (2 << 20);  ///< Quadtimer Channel0 Primary Count Source Select
        constexpr uint32_t TMR1PCSSEL = (2 << 22);  ///< Quadtimer Channel1 Primary Count Source Select
        constexpr uint32_t TMR2PCSSEL = (2 << 24);  ///< Quadtimer Channel2 Primary Count Source Select
        constexpr uint32_t TMR3PCSSEL = (2 << 26);  ///< Quadtimer Channel3 Primary Count Source Select
        constexpr uint32_t RTCCLKSEL = (1U << 28);  ///< RTC Clock select
        constexpr uint32_t VREFBUFOUTEN = (1U << 29);  ///< VrefBuffer Output Enable
        constexpr uint32_t VREFBUFINSEL = (1U << 30);  ///< VrefBuffer Input Select
        constexpr uint32_t VREFBUFPD = (1U << 31);  ///< VrefBuffer Power Down
    }

}

// ============================================================================
// LCD Peripheral
// ============================================================================

namespace lcd {
    /// Base addresses
    constexpr uint32_t LCD_BASE = 0x40043000;

    /// LCD Register structure
    struct Registers {
        volatile uint32_t GCR;  ///< Offset: 0x00 - LCD General Control Register
        volatile uint32_t AR;  ///< Offset: 0x04 - LCD Auxiliary Register
        volatile uint32_t FDCR;  ///< Offset: 0x08 - LCD Fault Detect Control Register
        volatile uint32_t FDSR;  ///< Offset: 0x0C - LCD Fault Detect Status Register
        volatile uint32_t PEN%s;  ///< Offset: 0x10 - LCD Pin Enable register
        volatile uint32_t BPEN%s;  ///< Offset: 0x18 - LCD Back Plane Enable register
        volatile uint32_t WF3TO0;  ///< Offset: 0x20 - LCD Waveform register
        volatile uint32_t WF0;  ///< Offset: 0x20 - LCD Waveform Register 0.
        volatile uint32_t WF1;  ///< Offset: 0x21 - LCD Waveform Register 1.
        volatile uint32_t WF2;  ///< Offset: 0x22 - LCD Waveform Register 2.
        volatile uint32_t WF3;  ///< Offset: 0x23 - LCD Waveform Register 3.
        volatile uint32_t WF7TO4;  ///< Offset: 0x24 - LCD Waveform register
        volatile uint32_t WF4;  ///< Offset: 0x24 - LCD Waveform Register 4.
        volatile uint32_t WF5;  ///< Offset: 0x25 - LCD Waveform Register 5.
        volatile uint32_t WF6;  ///< Offset: 0x26 - LCD Waveform Register 6.
        volatile uint32_t WF7;  ///< Offset: 0x27 - LCD Waveform Register 7.
        volatile uint32_t WF11TO8;  ///< Offset: 0x28 - LCD Waveform register
        volatile uint32_t WF8;  ///< Offset: 0x28 - LCD Waveform Register 8.
        volatile uint32_t WF9;  ///< Offset: 0x29 - LCD Waveform Register 9.
        volatile uint32_t WF10;  ///< Offset: 0x2A - LCD Waveform Register 10.
        volatile uint32_t WF11;  ///< Offset: 0x2B - LCD Waveform Register 11.
        volatile uint32_t WF15TO12;  ///< Offset: 0x2C - LCD Waveform register
        volatile uint32_t WF12;  ///< Offset: 0x2C - LCD Waveform Register 12.
        volatile uint32_t WF13;  ///< Offset: 0x2D - LCD Waveform Register 13.
        volatile uint32_t WF14;  ///< Offset: 0x2E - LCD Waveform Register 14.
        volatile uint32_t WF15;  ///< Offset: 0x2F - LCD Waveform Register 15.
        volatile uint32_t WF19TO16;  ///< Offset: 0x30 - LCD Waveform register
        volatile uint32_t WF16;  ///< Offset: 0x30 - LCD Waveform Register 16.
        volatile uint32_t WF17;  ///< Offset: 0x31 - LCD Waveform Register 17.
        volatile uint32_t WF18;  ///< Offset: 0x32 - LCD Waveform Register 18.
        volatile uint32_t WF19;  ///< Offset: 0x33 - LCD Waveform Register 19.
        volatile uint32_t WF23TO20;  ///< Offset: 0x34 - LCD Waveform register
        volatile uint32_t WF20;  ///< Offset: 0x34 - LCD Waveform Register 20.
        volatile uint32_t WF21;  ///< Offset: 0x35 - LCD Waveform Register 21.
        volatile uint32_t WF22;  ///< Offset: 0x36 - LCD Waveform Register 22.
        volatile uint32_t WF23;  ///< Offset: 0x37 - LCD Waveform Register 23.
        volatile uint32_t WF27TO24;  ///< Offset: 0x38 - LCD Waveform register
        volatile uint32_t WF24;  ///< Offset: 0x38 - LCD Waveform Register 24.
        volatile uint32_t WF25;  ///< Offset: 0x39 - LCD Waveform Register 25.
        volatile uint32_t WF26;  ///< Offset: 0x3A - LCD Waveform Register 26.
        volatile uint32_t WF27;  ///< Offset: 0x3B - LCD Waveform Register 27.
        volatile uint32_t WF31TO28;  ///< Offset: 0x3C - LCD Waveform register
        volatile uint32_t WF28;  ///< Offset: 0x3C - LCD Waveform Register 28.
        volatile uint32_t WF29;  ///< Offset: 0x3D - LCD Waveform Register 29.
        volatile uint32_t WF30;  ///< Offset: 0x3E - LCD Waveform Register 30.
        volatile uint32_t WF31;  ///< Offset: 0x3F - LCD Waveform Register 31.
        volatile uint32_t WF35TO32;  ///< Offset: 0x40 - LCD Waveform register
        volatile uint32_t WF32;  ///< Offset: 0x40 - LCD Waveform Register 32.
        volatile uint32_t WF33;  ///< Offset: 0x41 - LCD Waveform Register 33.
        volatile uint32_t WF34;  ///< Offset: 0x42 - LCD Waveform Register 34.
        volatile uint32_t WF35;  ///< Offset: 0x43 - LCD Waveform Register 35.
        volatile uint32_t WF39TO36;  ///< Offset: 0x44 - LCD Waveform register
        volatile uint32_t WF36;  ///< Offset: 0x44 - LCD Waveform Register 36.
        volatile uint32_t WF37;  ///< Offset: 0x45 - LCD Waveform Register 37.
        volatile uint32_t WF38;  ///< Offset: 0x46 - LCD Waveform Register 38.
        volatile uint32_t WF39;  ///< Offset: 0x47 - LCD Waveform Register 39.
        volatile uint32_t WF43TO40;  ///< Offset: 0x48 - LCD Waveform register
        volatile uint32_t WF40;  ///< Offset: 0x48 - LCD Waveform Register 40.
        volatile uint32_t WF41;  ///< Offset: 0x49 - LCD Waveform Register 41.
        volatile uint32_t WF42;  ///< Offset: 0x4A - LCD Waveform Register 42.
        volatile uint32_t WF43;  ///< Offset: 0x4B - LCD Waveform Register 43.
        volatile uint32_t WF47TO44;  ///< Offset: 0x4C - LCD Waveform register
        volatile uint32_t WF44;  ///< Offset: 0x4C - LCD Waveform Register 44.
        volatile uint32_t WF45;  ///< Offset: 0x4D - LCD Waveform Register 45.
        volatile uint32_t WF46;  ///< Offset: 0x4E - LCD Waveform Register 46.
        volatile uint32_t WF47;  ///< Offset: 0x4F - LCD Waveform Register 47.
        volatile uint32_t WF51TO48;  ///< Offset: 0x50 - LCD Waveform register
        volatile uint32_t WF48;  ///< Offset: 0x50 - LCD Waveform Register 48.
        volatile uint32_t WF49;  ///< Offset: 0x51 - LCD Waveform Register 49.
        volatile uint32_t WF50;  ///< Offset: 0x52 - LCD Waveform Register 50.
        volatile uint32_t WF51;  ///< Offset: 0x53 - LCD Waveform Register 51.
        volatile uint32_t WF55TO52;  ///< Offset: 0x54 - LCD Waveform register
        volatile uint32_t WF52;  ///< Offset: 0x54 - LCD Waveform Register 52.
        volatile uint32_t WF53;  ///< Offset: 0x55 - LCD Waveform Register 53.
        volatile uint32_t WF54;  ///< Offset: 0x56 - LCD Waveform Register 54.
        volatile uint32_t WF55;  ///< Offset: 0x57 - LCD Waveform Register 55.
        volatile uint32_t WF59TO56;  ///< Offset: 0x58 - LCD Waveform register
        volatile uint32_t WF56;  ///< Offset: 0x58 - LCD Waveform Register 56.
        volatile uint32_t WF57;  ///< Offset: 0x59 - LCD Waveform Register 57.
        volatile uint32_t WF58;  ///< Offset: 0x5A - LCD Waveform Register 58.
        volatile uint32_t WF59;  ///< Offset: 0x5B - LCD Waveform Register 59.
        volatile uint32_t WF63TO60;  ///< Offset: 0x5C - LCD Waveform register
        volatile uint32_t WF60;  ///< Offset: 0x5C - LCD Waveform Register 60.
        volatile uint32_t WF61;  ///< Offset: 0x5D - LCD Waveform Register 61.
        volatile uint32_t WF62;  ///< Offset: 0x5E - LCD Waveform Register 62.
        volatile uint32_t WF63;  ///< Offset: 0x5F - LCD Waveform Register 63.
    };

    /// Peripheral instances
    inline Registers* LCD = reinterpret_cast<Registers*>(LCD_BASE);

    // Bit definitions
    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t DUTY = (3 << 0);  ///< LCD duty select
        constexpr uint32_t LCLK = (3 << 3);  ///< LCD Clock Prescaler
        constexpr uint32_t SOURCE = (1U << 6);  ///< LCD Clock Source Select
        constexpr uint32_t LCDEN = (1U << 7);  ///< LCD Driver Enable
        constexpr uint32_t LCDSTP = (1U << 8);  ///< LCD Stop
        constexpr uint32_t LCDDOZE = (1U << 9);  ///< LCD Doze enable
        constexpr uint32_t ALTDIV = (2 << 12);  ///< LCD AlternateClock Divider
        constexpr uint32_t FDCIEN = (1U << 14);  ///< LCD Fault Detection Complete Interrupt Enable
        constexpr uint32_t LCDIEN = (1U << 15);  ///< LCD Frame Frequency Interrupt Enable
        constexpr uint32_t VSUPPLY = (1U << 17);  ///< Voltage Supply Control
        constexpr uint32_t LADJ = (2 << 20);  ///< Load Adjust
        constexpr uint32_t CPSEL = (1U << 23);  ///< Charge Pump or Resistor Bias Select
        constexpr uint32_t RVTRIM = (4 << 24);  ///< Regulated Voltage Trim
        constexpr uint32_t RVEN = (1U << 31);  ///< Regulated Voltage Enable
    }

    /// AR Register bits
    namespace ar_bits {
        constexpr uint32_t BRATE = (3 << 0);  ///< Blink-rate configuration
        constexpr uint32_t BMODE = (1U << 3);  ///< Blink mode
        constexpr uint32_t BLANK = (1U << 5);  ///< Blank display mode
        constexpr uint32_t ALT = (1U << 6);  ///< Alternate display mode
        constexpr uint32_t BLINK = (1U << 7);  ///< Blink command
        constexpr uint32_t LCDIF = (1U << 15);  ///< LCD Frame Frequency Interrupt flag
    }

    /// FDCR Register bits
    namespace fdcr_bits {
        constexpr uint32_t FDPINID = (6 << 0);  ///< Fault Detect Pin ID
        constexpr uint32_t FDBPEN = (1U << 6);  ///< Fault Detect Back Plane Enable
        constexpr uint32_t FDEN = (1U << 7);  ///< Fault Detect Enable
        constexpr uint32_t FDSWW = (3 << 9);  ///< Fault Detect Sample Window Width
        constexpr uint32_t FDPRS = (3 << 12);  ///< Fault Detect Clock Prescaler
    }

    /// FDSR Register bits
    namespace fdsr_bits {
        constexpr uint32_t FDCNT = (8 << 0);  ///< Fault Detect Counter
        constexpr uint32_t FDCF = (1U << 15);  ///< Fault Detection Complete Flag
    }

    /// PEN%s Register bits
    namespace pen%s_bits {
        constexpr uint32_t PEN = (32 << 0);  ///< LCD Pin Enable
    }

    /// BPEN%s Register bits
    namespace bpen%s_bits {
        constexpr uint32_t BPEN = (32 << 0);  ///< Back Plane Enable
    }

    /// WF3TO0 Register bits
    namespace wf3to0_bits {
        constexpr uint32_t WF0 = (8 << 0);  ///< no description available
        constexpr uint32_t WF1 = (8 << 8);  ///< no description available
        constexpr uint32_t WF2 = (8 << 16);  ///< no description available
        constexpr uint32_t WF3 = (8 << 24);  ///< no description available
    }

    /// WF0 Register bits
    namespace wf0_bits {
        constexpr uint32_t BPALCD0 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD0 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD0 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD0 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD0 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD0 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD0 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD0 = (1U << 7);  ///< no description available
    }

    /// WF1 Register bits
    namespace wf1_bits {
        constexpr uint32_t BPALCD1 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD1 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD1 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD1 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD1 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD1 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD1 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD1 = (1U << 7);  ///< no description available
    }

    /// WF2 Register bits
    namespace wf2_bits {
        constexpr uint32_t BPALCD2 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD2 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD2 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD2 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD2 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD2 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD2 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD2 = (1U << 7);  ///< no description available
    }

    /// WF3 Register bits
    namespace wf3_bits {
        constexpr uint32_t BPALCD3 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD3 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD3 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD3 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD3 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD3 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD3 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD3 = (1U << 7);  ///< no description available
    }

    /// WF7TO4 Register bits
    namespace wf7to4_bits {
        constexpr uint32_t WF4 = (8 << 0);  ///< no description available
        constexpr uint32_t WF5 = (8 << 8);  ///< no description available
        constexpr uint32_t WF6 = (8 << 16);  ///< no description available
        constexpr uint32_t WF7 = (8 << 24);  ///< no description available
    }

    /// WF4 Register bits
    namespace wf4_bits {
        constexpr uint32_t BPALCD4 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD4 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD4 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD4 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD4 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD4 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD4 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD4 = (1U << 7);  ///< no description available
    }

    /// WF5 Register bits
    namespace wf5_bits {
        constexpr uint32_t BPALCD5 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD5 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD5 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD5 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD5 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD5 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD5 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD5 = (1U << 7);  ///< no description available
    }

    /// WF6 Register bits
    namespace wf6_bits {
        constexpr uint32_t BPALCD6 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD6 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD6 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD6 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD6 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD6 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD6 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD6 = (1U << 7);  ///< no description available
    }

    /// WF7 Register bits
    namespace wf7_bits {
        constexpr uint32_t BPALCD7 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD7 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD7 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD7 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD7 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD7 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD7 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD7 = (1U << 7);  ///< no description available
    }

    /// WF11TO8 Register bits
    namespace wf11to8_bits {
        constexpr uint32_t WF8 = (8 << 0);  ///< no description available
        constexpr uint32_t WF9 = (8 << 8);  ///< no description available
        constexpr uint32_t WF10 = (8 << 16);  ///< no description available
        constexpr uint32_t WF11 = (8 << 24);  ///< no description available
    }

    /// WF8 Register bits
    namespace wf8_bits {
        constexpr uint32_t BPALCD8 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD8 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD8 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD8 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD8 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD8 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD8 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD8 = (1U << 7);  ///< no description available
    }

    /// WF9 Register bits
    namespace wf9_bits {
        constexpr uint32_t BPALCD9 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD9 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD9 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD9 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD9 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD9 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD9 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD9 = (1U << 7);  ///< no description available
    }

    /// WF10 Register bits
    namespace wf10_bits {
        constexpr uint32_t BPALCD10 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD10 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD10 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD10 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD10 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD10 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD10 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD10 = (1U << 7);  ///< no description available
    }

    /// WF11 Register bits
    namespace wf11_bits {
        constexpr uint32_t BPALCD11 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD11 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD11 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD11 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD11 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD11 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD11 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD11 = (1U << 7);  ///< no description available
    }

    /// WF15TO12 Register bits
    namespace wf15to12_bits {
        constexpr uint32_t WF12 = (8 << 0);  ///< no description available
        constexpr uint32_t WF13 = (8 << 8);  ///< no description available
        constexpr uint32_t WF14 = (8 << 16);  ///< no description available
        constexpr uint32_t WF15 = (8 << 24);  ///< no description available
    }

    /// WF12 Register bits
    namespace wf12_bits {
        constexpr uint32_t BPALCD12 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD12 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD12 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD12 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD12 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD12 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD12 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD12 = (1U << 7);  ///< no description available
    }

    /// WF13 Register bits
    namespace wf13_bits {
        constexpr uint32_t BPALCD13 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD13 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD13 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD13 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD13 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD13 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD13 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD13 = (1U << 7);  ///< no description available
    }

    /// WF14 Register bits
    namespace wf14_bits {
        constexpr uint32_t BPALCD14 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD14 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD14 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD14 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD14 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD14 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD14 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD14 = (1U << 7);  ///< no description available
    }

    /// WF15 Register bits
    namespace wf15_bits {
        constexpr uint32_t BPALCD15 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD15 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD15 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD15 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD15 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD15 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD15 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD15 = (1U << 7);  ///< no description available
    }

    /// WF19TO16 Register bits
    namespace wf19to16_bits {
        constexpr uint32_t WF16 = (8 << 0);  ///< no description available
        constexpr uint32_t WF17 = (8 << 8);  ///< no description available
        constexpr uint32_t WF18 = (8 << 16);  ///< no description available
        constexpr uint32_t WF19 = (8 << 24);  ///< no description available
    }

    /// WF16 Register bits
    namespace wf16_bits {
        constexpr uint32_t BPALCD16 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD16 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD16 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD16 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD16 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD16 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD16 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD16 = (1U << 7);  ///< no description available
    }

    /// WF17 Register bits
    namespace wf17_bits {
        constexpr uint32_t BPALCD17 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD17 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD17 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD17 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD17 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD17 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD17 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD17 = (1U << 7);  ///< no description available
    }

    /// WF18 Register bits
    namespace wf18_bits {
        constexpr uint32_t BPALCD18 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD18 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD18 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD18 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD18 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD18 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD18 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD18 = (1U << 7);  ///< no description available
    }

    /// WF19 Register bits
    namespace wf19_bits {
        constexpr uint32_t BPALCD19 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD19 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD19 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD19 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD19 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD19 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD19 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD19 = (1U << 7);  ///< no description available
    }

    /// WF23TO20 Register bits
    namespace wf23to20_bits {
        constexpr uint32_t WF20 = (8 << 0);  ///< no description available
        constexpr uint32_t WF21 = (8 << 8);  ///< no description available
        constexpr uint32_t WF22 = (8 << 16);  ///< no description available
        constexpr uint32_t WF23 = (8 << 24);  ///< no description available
    }

    /// WF20 Register bits
    namespace wf20_bits {
        constexpr uint32_t BPALCD20 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD20 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD20 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD20 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD20 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD20 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD20 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD20 = (1U << 7);  ///< no description available
    }

    /// WF21 Register bits
    namespace wf21_bits {
        constexpr uint32_t BPALCD21 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD21 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD21 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD21 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD21 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD21 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD21 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD21 = (1U << 7);  ///< no description available
    }

    /// WF22 Register bits
    namespace wf22_bits {
        constexpr uint32_t BPALCD22 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD22 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD22 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD22 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD22 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD22 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD22 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD22 = (1U << 7);  ///< no description available
    }

    /// WF23 Register bits
    namespace wf23_bits {
        constexpr uint32_t BPALCD23 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD23 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD23 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD23 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD23 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD23 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD23 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD23 = (1U << 7);  ///< no description available
    }

    /// WF27TO24 Register bits
    namespace wf27to24_bits {
        constexpr uint32_t WF24 = (8 << 0);  ///< no description available
        constexpr uint32_t WF25 = (8 << 8);  ///< no description available
        constexpr uint32_t WF26 = (8 << 16);  ///< no description available
        constexpr uint32_t WF27 = (8 << 24);  ///< no description available
    }

    /// WF24 Register bits
    namespace wf24_bits {
        constexpr uint32_t BPALCD24 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD24 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD24 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD24 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD24 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD24 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD24 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD24 = (1U << 7);  ///< no description available
    }

    /// WF25 Register bits
    namespace wf25_bits {
        constexpr uint32_t BPALCD25 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD25 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD25 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD25 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD25 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD25 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD25 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD25 = (1U << 7);  ///< no description available
    }

    /// WF26 Register bits
    namespace wf26_bits {
        constexpr uint32_t BPALCD26 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD26 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD26 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD26 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD26 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD26 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD26 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD26 = (1U << 7);  ///< no description available
    }

    /// WF27 Register bits
    namespace wf27_bits {
        constexpr uint32_t BPALCD27 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD27 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD27 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD27 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD27 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD27 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD27 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD27 = (1U << 7);  ///< no description available
    }

    /// WF31TO28 Register bits
    namespace wf31to28_bits {
        constexpr uint32_t WF28 = (8 << 0);  ///< no description available
        constexpr uint32_t WF29 = (8 << 8);  ///< no description available
        constexpr uint32_t WF30 = (8 << 16);  ///< no description available
        constexpr uint32_t WF31 = (8 << 24);  ///< no description available
    }

    /// WF28 Register bits
    namespace wf28_bits {
        constexpr uint32_t BPALCD28 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD28 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD28 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD28 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD28 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD28 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD28 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD28 = (1U << 7);  ///< no description available
    }

    /// WF29 Register bits
    namespace wf29_bits {
        constexpr uint32_t BPALCD29 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD29 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD29 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD29 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD29 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD29 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD29 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD29 = (1U << 7);  ///< no description available
    }

    /// WF30 Register bits
    namespace wf30_bits {
        constexpr uint32_t BPALCD30 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD30 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD30 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD30 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD30 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD30 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD30 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD30 = (1U << 7);  ///< no description available
    }

    /// WF31 Register bits
    namespace wf31_bits {
        constexpr uint32_t BPALCD31 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD31 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD31 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD31 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD31 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD31 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD31 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD31 = (1U << 7);  ///< no description available
    }

    /// WF35TO32 Register bits
    namespace wf35to32_bits {
        constexpr uint32_t WF32 = (8 << 0);  ///< no description available
        constexpr uint32_t WF33 = (8 << 8);  ///< no description available
        constexpr uint32_t WF34 = (8 << 16);  ///< no description available
        constexpr uint32_t WF35 = (8 << 24);  ///< no description available
    }

    /// WF32 Register bits
    namespace wf32_bits {
        constexpr uint32_t BPALCD32 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD32 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD32 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD32 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD32 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD32 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD32 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD32 = (1U << 7);  ///< no description available
    }

    /// WF33 Register bits
    namespace wf33_bits {
        constexpr uint32_t BPALCD33 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD33 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD33 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD33 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD33 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD33 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD33 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD33 = (1U << 7);  ///< no description available
    }

    /// WF34 Register bits
    namespace wf34_bits {
        constexpr uint32_t BPALCD34 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD34 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD34 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD34 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD34 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD34 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD34 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD34 = (1U << 7);  ///< no description available
    }

    /// WF35 Register bits
    namespace wf35_bits {
        constexpr uint32_t BPALCD35 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD35 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD35 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD35 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD35 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD35 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD35 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD35 = (1U << 7);  ///< no description available
    }

    /// WF39TO36 Register bits
    namespace wf39to36_bits {
        constexpr uint32_t WF36 = (8 << 0);  ///< no description available
        constexpr uint32_t WF37 = (8 << 8);  ///< no description available
        constexpr uint32_t WF38 = (8 << 16);  ///< no description available
        constexpr uint32_t WF39 = (8 << 24);  ///< no description available
    }

    /// WF36 Register bits
    namespace wf36_bits {
        constexpr uint32_t BPALCD36 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD36 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD36 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD36 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD36 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD36 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD36 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD36 = (1U << 7);  ///< no description available
    }

    /// WF37 Register bits
    namespace wf37_bits {
        constexpr uint32_t BPALCD37 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD37 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD37 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD37 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD37 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD37 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD37 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD37 = (1U << 7);  ///< no description available
    }

    /// WF38 Register bits
    namespace wf38_bits {
        constexpr uint32_t BPALCD38 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD38 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD38 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD38 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD38 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD38 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD38 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD38 = (1U << 7);  ///< no description available
    }

    /// WF39 Register bits
    namespace wf39_bits {
        constexpr uint32_t BPALCD39 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD39 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD39 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD39 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD39 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD39 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD39 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD39 = (1U << 7);  ///< no description available
    }

    /// WF43TO40 Register bits
    namespace wf43to40_bits {
        constexpr uint32_t WF40 = (8 << 0);  ///< no description available
        constexpr uint32_t WF41 = (8 << 8);  ///< no description available
        constexpr uint32_t WF42 = (8 << 16);  ///< no description available
        constexpr uint32_t WF43 = (8 << 24);  ///< no description available
    }

    /// WF40 Register bits
    namespace wf40_bits {
        constexpr uint32_t BPALCD40 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD40 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD40 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD40 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD40 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD40 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD40 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD40 = (1U << 7);  ///< no description available
    }

    /// WF41 Register bits
    namespace wf41_bits {
        constexpr uint32_t BPALCD41 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD41 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD41 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD41 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD41 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD41 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD41 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD41 = (1U << 7);  ///< no description available
    }

    /// WF42 Register bits
    namespace wf42_bits {
        constexpr uint32_t BPALCD42 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD42 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD42 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD42 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD42 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD42 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD42 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD42 = (1U << 7);  ///< no description available
    }

    /// WF43 Register bits
    namespace wf43_bits {
        constexpr uint32_t BPALCD43 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD43 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD43 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD43 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD43 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD43 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD43 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD43 = (1U << 7);  ///< no description available
    }

    /// WF47TO44 Register bits
    namespace wf47to44_bits {
        constexpr uint32_t WF44 = (8 << 0);  ///< no description available
        constexpr uint32_t WF45 = (8 << 8);  ///< no description available
        constexpr uint32_t WF46 = (8 << 16);  ///< no description available
        constexpr uint32_t WF47 = (8 << 24);  ///< no description available
    }

    /// WF44 Register bits
    namespace wf44_bits {
        constexpr uint32_t BPALCD44 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD44 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD44 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD44 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD44 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD44 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD44 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD44 = (1U << 7);  ///< no description available
    }

    /// WF45 Register bits
    namespace wf45_bits {
        constexpr uint32_t BPALCD45 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD45 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD45 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD45 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD45 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD45 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD45 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD45 = (1U << 7);  ///< no description available
    }

    /// WF46 Register bits
    namespace wf46_bits {
        constexpr uint32_t BPALCD46 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD46 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD46 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD46 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD46 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD46 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD46 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD46 = (1U << 7);  ///< no description available
    }

    /// WF47 Register bits
    namespace wf47_bits {
        constexpr uint32_t BPALCD47 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD47 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD47 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD47 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD47 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD47 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD47 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD47 = (1U << 7);  ///< no description available
    }

    /// WF51TO48 Register bits
    namespace wf51to48_bits {
        constexpr uint32_t WF48 = (8 << 0);  ///< no description available
        constexpr uint32_t WF49 = (8 << 8);  ///< no description available
        constexpr uint32_t WF50 = (8 << 16);  ///< no description available
        constexpr uint32_t WF51 = (8 << 24);  ///< no description available
    }

    /// WF48 Register bits
    namespace wf48_bits {
        constexpr uint32_t BPALCD48 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD48 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD48 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD48 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD48 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD48 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD48 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD48 = (1U << 7);  ///< no description available
    }

    /// WF49 Register bits
    namespace wf49_bits {
        constexpr uint32_t BPALCD49 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD49 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD49 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD49 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD49 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD49 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD49 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD49 = (1U << 7);  ///< no description available
    }

    /// WF50 Register bits
    namespace wf50_bits {
        constexpr uint32_t BPALCD50 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD50 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD50 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD50 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD50 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD50 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD50 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD50 = (1U << 7);  ///< no description available
    }

    /// WF51 Register bits
    namespace wf51_bits {
        constexpr uint32_t BPALCD51 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD51 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD51 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD51 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD51 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD51 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD51 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD51 = (1U << 7);  ///< no description available
    }

    /// WF55TO52 Register bits
    namespace wf55to52_bits {
        constexpr uint32_t WF52 = (8 << 0);  ///< no description available
        constexpr uint32_t WF53 = (8 << 8);  ///< no description available
        constexpr uint32_t WF54 = (8 << 16);  ///< no description available
        constexpr uint32_t WF55 = (8 << 24);  ///< no description available
    }

    /// WF52 Register bits
    namespace wf52_bits {
        constexpr uint32_t BPALCD52 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD52 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD52 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD52 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD52 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD52 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD52 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD52 = (1U << 7);  ///< no description available
    }

    /// WF53 Register bits
    namespace wf53_bits {
        constexpr uint32_t BPALCD53 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD53 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD53 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD53 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD53 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD53 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD53 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD53 = (1U << 7);  ///< no description available
    }

    /// WF54 Register bits
    namespace wf54_bits {
        constexpr uint32_t BPALCD54 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD54 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD54 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD54 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD54 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD54 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD54 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD54 = (1U << 7);  ///< no description available
    }

    /// WF55 Register bits
    namespace wf55_bits {
        constexpr uint32_t BPALCD55 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD55 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD55 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD55 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD55 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD55 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD55 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD55 = (1U << 7);  ///< no description available
    }

    /// WF59TO56 Register bits
    namespace wf59to56_bits {
        constexpr uint32_t WF56 = (8 << 0);  ///< no description available
        constexpr uint32_t WF57 = (8 << 8);  ///< no description available
        constexpr uint32_t WF58 = (8 << 16);  ///< no description available
        constexpr uint32_t WF59 = (8 << 24);  ///< no description available
    }

    /// WF56 Register bits
    namespace wf56_bits {
        constexpr uint32_t BPALCD56 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD56 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD56 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD56 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD56 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD56 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD56 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD56 = (1U << 7);  ///< no description available
    }

    /// WF57 Register bits
    namespace wf57_bits {
        constexpr uint32_t BPALCD57 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD57 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD57 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD57 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD57 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD57 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD57 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD57 = (1U << 7);  ///< no description available
    }

    /// WF58 Register bits
    namespace wf58_bits {
        constexpr uint32_t BPALCD58 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD58 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD58 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD58 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD58 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD58 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD58 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD58 = (1U << 7);  ///< no description available
    }

    /// WF59 Register bits
    namespace wf59_bits {
        constexpr uint32_t BPALCD59 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD59 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD59 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD59 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD59 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD59 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD59 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD59 = (1U << 7);  ///< no description available
    }

    /// WF63TO60 Register bits
    namespace wf63to60_bits {
        constexpr uint32_t WF60 = (8 << 0);  ///< no description available
        constexpr uint32_t WF61 = (8 << 8);  ///< no description available
        constexpr uint32_t WF62 = (8 << 16);  ///< no description available
        constexpr uint32_t WF63 = (8 << 24);  ///< no description available
    }

    /// WF60 Register bits
    namespace wf60_bits {
        constexpr uint32_t BPALCD60 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD60 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD60 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD60 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD60 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD60 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD60 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD60 = (1U << 7);  ///< no description available
    }

    /// WF61 Register bits
    namespace wf61_bits {
        constexpr uint32_t BPALCD61 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD61 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD61 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD61 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD61 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD61 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD61 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD61 = (1U << 7);  ///< no description available
    }

    /// WF62 Register bits
    namespace wf62_bits {
        constexpr uint32_t BPALCD62 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD62 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD62 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD62 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD62 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD62 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD62 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD62 = (1U << 7);  ///< no description available
    }

    /// WF63 Register bits
    namespace wf63_bits {
        constexpr uint32_t BPALCD63 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD63 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD63 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD63 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD63 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD63 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD63 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD63 = (1U << 7);  ///< no description available
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40046000;
    constexpr uint32_t PORTB_BASE = 0x40047000;
    constexpr uint32_t PORTC_BASE = 0x40048000;
    constexpr uint32_t PORTD_BASE = 0x40049000;
    constexpr uint32_t PORTE_BASE = 0x4004A000;
    constexpr uint32_t PORTF_BASE = 0x4004B000;
    constexpr uint32_t PORTG_BASE = 0x4004C000;
    constexpr uint32_t PORTH_BASE = 0x4004D000;
    constexpr uint32_t PORTI_BASE = 0x4004E000;
    constexpr uint32_t GPIOA_BASE = 0x400FF000;
    constexpr uint32_t GPIOB_BASE = 0x400FF001;
    constexpr uint32_t GPIOC_BASE = 0x400FF002;
    constexpr uint32_t GPIOD_BASE = 0x400FF003;
    constexpr uint32_t GPIOE_BASE = 0x400FF040;
    constexpr uint32_t GPIOF_BASE = 0x400FF041;
    constexpr uint32_t GPIOG_BASE = 0x400FF042;
    constexpr uint32_t GPIOH_BASE = 0x400FF043;
    constexpr uint32_t GPIOI_BASE = 0x400FF080;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR%s;  ///< Offset: 0x00 - Pin Control Register n
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);
    inline Registers* PORTF = reinterpret_cast<Registers*>(PORTF_BASE);
    inline Registers* PORTG = reinterpret_cast<Registers*>(PORTG_BASE);
    inline Registers* PORTH = reinterpret_cast<Registers*>(PORTH_BASE);
    inline Registers* PORTI = reinterpret_cast<Registers*>(PORTI_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);
    inline Registers* GPIOG = reinterpret_cast<Registers*>(GPIOG_BASE);
    inline Registers* GPIOH = reinterpret_cast<Registers*>(GPIOH_BASE);
    inline Registers* GPIOI = reinterpret_cast<Registers*>(GPIOI_BASE);

    // Bit definitions
    /// PCR%s Register bits
    namespace pcr%s_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40050000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t YEARMON;  ///< Offset: 0x00 - RTC Year and Month Counters Register
        volatile uint32_t DAYS;  ///< Offset: 0x02 - RTC Days and Day-of-Week Counters Register
        volatile uint32_t HOURMIN;  ///< Offset: 0x04 - RTC Hours and Minutes Counters Register
        volatile uint32_t SECONDS;  ///< Offset: 0x06 - RTC Seconds Counters Register
        volatile uint32_t ALM_YEARMON;  ///< Offset: 0x08 - RTC Year and Months Alarm Register
        volatile uint32_t ALM_DAYS;  ///< Offset: 0x0A - RTC Days Alarm Register
        volatile uint32_t ALM_HOURMIN;  ///< Offset: 0x0C - RTC Hours and Minutes Alarm Register
        volatile uint32_t ALM_SECONDS;  ///< Offset: 0x0E - RTC Seconds Alarm Register
        volatile uint32_t CTRL;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t STATUS;  ///< Offset: 0x12 - RTC Status Register
        volatile uint32_t ISR;  ///< Offset: 0x14 - RTC Interrupt Status Register
        volatile uint32_t IER;  ///< Offset: 0x16 - RTC Interrupt Enable Register
        volatile uint32_t GP_DATA_REG;  ///< Offset: 0x20 - RTC General Purpose Data Register
        volatile uint32_t DST_HOUR;  ///< Offset: 0x22 - RTC Daylight Saving Hour Register
        volatile uint32_t DST_MONTH;  ///< Offset: 0x24 - RTC Daylight Saving Month Register
        volatile uint32_t DST_DAY;  ///< Offset: 0x26 - RTC Daylight Saving Day Register
        volatile uint32_t COMPEN;  ///< Offset: 0x28 - RTC Compensation Register
        volatile uint32_t TAMPER_DIRECTION;  ///< Offset: 0x2C - Tamper Direction Register
        volatile uint32_t TAMPER_QSCR;  ///< Offset: 0x2E - Tamper Queue Status and Control Register
        volatile uint32_t TAMPER_SCR;  ///< Offset: 0x32 - RTC Tamper Status and Control Register
        volatile uint32_t FILTER01_CFG;  ///< Offset: 0x34 - RTC Tamper 0 1 Filter Configuration Register
        volatile uint32_t FILTER2_CFG;  ///< Offset: 0x36 - RTC Tamper 2 Filter Configuration Register
        volatile uint32_t TAMPER_QUEUE;  ///< Offset: 0x40 - Tamper Queue Register
        volatile uint32_t CTRL2;  ///< Offset: 0x42 - RTC Control 2 Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// YEARMON Register bits
    namespace yearmon_bits {
        constexpr uint32_t MON_CNT = (4 << 0);  ///< no description available
        constexpr uint32_t YROFST = (8 << 8);  ///< Year Offset Count Value
    }

    /// DAYS Register bits
    namespace days_bits {
        constexpr uint32_t DAY_CNT = (5 << 0);  ///< Days Counter Value.
        constexpr uint32_t DOW = (3 << 8);  ///< Day of Week Counter Value.
    }

    /// HOURMIN Register bits
    namespace hourmin_bits {
        constexpr uint32_t MIN_CNT = (6 << 0);  ///< Minutes Counter Value.
        constexpr uint32_t HOUR_CNT = (5 << 8);  ///< Hours Counter Value.
    }

    /// SECONDS Register bits
    namespace seconds_bits {
        constexpr uint32_t SEC_CNT = (6 << 0);  ///< Seconds Counter Value.
    }

    /// ALM_YEARMON Register bits
    namespace alm_yearmon_bits {
        constexpr uint32_t ALM_MON = (4 << 0);  ///< Months Value for Alarm.
        constexpr uint32_t ALM_YEAR = (8 << 8);  ///< Year Value for Alarm.
    }

    /// ALM_DAYS Register bits
    namespace alm_days_bits {
        constexpr uint32_t ALM_DAY = (5 << 0);  ///< Days Value for Alarm.
    }

    /// ALM_HOURMIN Register bits
    namespace alm_hourmin_bits {
        constexpr uint32_t ALM_MIN = (6 << 0);  ///< Minutes Value for Alarm.
        constexpr uint32_t ALM_HOUR = (5 << 8);  ///< Hours Value for Alarm.
    }

    /// ALM_SECONDS Register bits
    namespace alm_seconds_bits {
        constexpr uint32_t ALM_SEC = (6 << 0);  ///< no description available
        constexpr uint32_t DEC_SEC = (1U << 8);  ///< Decrement Seconds Counter by 1.
        constexpr uint32_t INC_SEC = (1U << 9);  ///< Increment Seconds Counter by 1.
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t FINEEN = (1U << 0);  ///< Fine compensation enable bit
        constexpr uint32_t COMP_EN = (1U << 1);  ///< no description available
        constexpr uint32_t ALM_MATCH = (2 << 2);  ///< Alarm Match bits.
        constexpr uint32_t TIMER_STB_MASK = (1U << 4);  ///< Sampling timer clocks mask
        constexpr uint32_t DST_EN = (1U << 6);  ///< Daylight Saving Enable.
        constexpr uint32_t SWR = (1U << 8);  ///< Software Reset bit.
        constexpr uint32_t CLKOUT = (2 << 13);  ///< RTC Clock Output Selection.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t INVAL_BIT = (1U << 0);  ///< Invalidate CPU read/write access bit.
        constexpr uint32_t WRITE_PROT_EN = (1U << 1);  ///< Write Protect Enable status bit.
        constexpr uint32_t CPU_LOW_VOLT = (1U << 2);  ///< CPU Low Voltage Warning status bit.
        constexpr uint32_t RST_SRC = (1U << 3);  ///< Reset Source bit.
        constexpr uint32_t CMP_INT = (1U << 5);  ///< Compensation Interval bit.
        constexpr uint32_t WE = (2 << 6);  ///< Write Enable bits.
        constexpr uint32_t BUS_ERR = (1U << 8);  ///< Bus Error bit.
        constexpr uint32_t CMP_DONE = (1U << 11);  ///< Compensation Done bit.
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TAMPER_IS = (1U << 0);  ///< Tamper Interrupt Status bit.
        constexpr uint32_t ALM_IS = (1U << 2);  ///< Alarm Interrupt Status bit.
        constexpr uint32_t DAY_IS = (1U << 3);  ///< Days Interrupt Status bit.
        constexpr uint32_t HOUR_IS = (1U << 4);  ///< Hours Interrupt Status bit.
        constexpr uint32_t MIN_IS = (1U << 5);  ///< Minutes Interrupt Status bit.
        constexpr uint32_t IS_1HZ = (1U << 6);  ///< 1 Hz Interval Interrupt Status bit.
        constexpr uint32_t IS_2HZ = (1U << 7);  ///< 2 Hz Interval Interrupt Status bit.
        constexpr uint32_t IS_4HZ = (1U << 8);  ///< 4 Hz Interval Interrupt Status bit.
        constexpr uint32_t IS_8HZ = (1U << 9);  ///< 8 Hz Interval Interrupt Status bit.
        constexpr uint32_t IS_16HZ = (1U << 10);  ///< 16 Hz Interval Interrupt Status bit.
        constexpr uint32_t IS_32HZ = (1U << 11);  ///< 32 Hz Interval Interrupt Status bit.
        constexpr uint32_t IS_64HZ = (1U << 12);  ///< 64 Hz Interval Interrupt Status bit.
        constexpr uint32_t IS_128HZ = (1U << 13);  ///< 128 Hz Interval Interrupt Status bit.
        constexpr uint32_t IS_256HZ = (1U << 14);  ///< 256 Hz Interval Interrupt Status bit.
        constexpr uint32_t IS_512HZ = (1U << 15);  ///< 512 Hz Interval Interrupt Status bit.
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TAMPER_IE = (1U << 0);  ///< Tamper Interrupt Enable bit.
        constexpr uint32_t ALM_IE = (1U << 2);  ///< Alarm Interrupt Enable bit.
        constexpr uint32_t DAY_IE = (1U << 3);  ///< Days Interrupt Enable bit.
        constexpr uint32_t HOUR_IE = (1U << 4);  ///< Hours Interrupt Enable bit.
        constexpr uint32_t MIN_IE = (1U << 5);  ///< Minutes Interrupt Enable bit.
        constexpr uint32_t IE_1HZ = (1U << 6);  ///< 1 Hz Interval Interrupt Enable bit.
        constexpr uint32_t IE_2HZ = (1U << 7);  ///< 2 Hz Interval Interrupt Enable bit.
        constexpr uint32_t IE_4HZ = (1U << 8);  ///< 4 Hz Interval Interrupt Enable bit.
        constexpr uint32_t IE_8HZ = (1U << 9);  ///< 8 Hz Interval Interrupt Enable bit.
        constexpr uint32_t IE_16HZ = (1U << 10);  ///< 16 Hz Interval Interrupt Enable bit.
        constexpr uint32_t IE_32HZ = (1U << 11);  ///< 32 Hz Interval Interrupt Enable bit.
        constexpr uint32_t IE_64HZ = (1U << 12);  ///< 64 Hz Interval Interrupt Enable bit.
        constexpr uint32_t IE_128HZ = (1U << 13);  ///< 128 Hz Interval Interrupt Enable bit.
        constexpr uint32_t IE_256HZ = (1U << 14);  ///< 256 Hz Interval Interrupt Enable bit.
        constexpr uint32_t IE_512HZ = (1U << 15);  ///< 512 Hz Interval Interrupt Enable bit.
    }

    /// GP_DATA_REG Register bits
    namespace gp_data_reg_bits {
        constexpr uint32_t GP_DATA_REG = (16 << 0);  ///< no description available
    }

    /// DST_HOUR Register bits
    namespace dst_hour_bits {
        constexpr uint32_t DST_END_HOUR = (5 << 0);  ///< Daylight Saving Time (DST) Hours End Value.
        constexpr uint32_t DST_START_HOUR = (5 << 8);  ///< Daylight Saving Time (DST) Hours Start Value.
    }

    /// DST_MONTH Register bits
    namespace dst_month_bits {
        constexpr uint32_t DST_END_MONTH = (4 << 0);  ///< Daylight Saving Time (DST) Month End Value.
        constexpr uint32_t DST_START_MONTH = (4 << 8);  ///< Daylight Saving Time (DST) Month Start Value.
    }

    /// DST_DAY Register bits
    namespace dst_day_bits {
        constexpr uint32_t DST_END_DAY = (5 << 0);  ///< Daylight Saving Time (DST) Day End Value.
        constexpr uint32_t DST_START_DAY = (5 << 8);  ///< Daylight Saving Time (DST) Day Start Value.
    }

    /// COMPEN Register bits
    namespace compen_bits {
        constexpr uint32_t COMPEN_VAL = (16 << 0);  ///< Compensation Value
    }

    /// TAMPER_DIRECTION Register bits
    namespace tamper_direction_bits {
        constexpr uint32_t A_P_TAMP = (4 << 0);  ///< no description available
        constexpr uint32_t I_O_TAMP = (4 << 8);  ///< no description available
    }

    /// TAMPER_QSCR Register bits
    namespace tamper_qscr_bits {
        constexpr uint32_t Q_FULL = (1U << 0);  ///< no description available
        constexpr uint32_t Q_FULL_INT_EN = (1U << 1);  ///< no description available
        constexpr uint32_t Q_CLEAR = (1U << 2);  ///< no description available
        constexpr uint32_t LFSR_CLK_SEL = (3 << 8);  ///< no description available
        constexpr uint32_t LFSR_DURATION = (4 << 12);  ///< no description available
    }

    /// TAMPER_SCR Register bits
    namespace tamper_scr_bits {
        constexpr uint32_t TMPR_EN = (4 << 0);  ///< Tamper Control
        constexpr uint32_t TMPR_STS = (4 << 8);  ///< Tamper Status Bit
    }

    /// FILTER01_CFG Register bits
    namespace filter01_cfg_bits {
        constexpr uint32_t FIL_DUR1 = (4 << 0);  ///< Tamper Detect Bit 1 Filter Duration
        constexpr uint32_t CLK_SEL1 = (3 << 4);  ///< Tamper Filter 1 Clock Select
        constexpr uint32_t POL1 = (1U << 7);  ///< Tamper Detect Input Bit 1 Polarity Control
        constexpr uint32_t FIL_DUR0 = (4 << 8);  ///< Tamper Detect Bit 0 Filter Duration
        constexpr uint32_t CLK_SEL0 = (3 << 12);  ///< Tamper Filter 0 Clock Select
        constexpr uint32_t POL0 = (1U << 15);  ///< Tamper Detect Input Bit 0 Polarity Control
    }

    /// FILTER2_CFG Register bits
    namespace filter2_cfg_bits {
        constexpr uint32_t FIL_DUR2 = (4 << 8);  ///< Tamper Detect Bit 2 Filter Duration
        constexpr uint32_t CLK_SEL2 = (3 << 12);  ///< Tamper Filter 2 Clock Select
        constexpr uint32_t POL2 = (1U << 15);  ///< Tamper Detect Input Bit 2 Polarity Control
    }

    /// TAMPER_QUEUE Register bits
    namespace tamper_queue_bits {
        constexpr uint32_t TAMPER_DATA = (16 << 0);  ///< Tamper type stamp and pin number information register
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t TAMP_CFG_OVER = (1U << 0);  ///< Tamper Configuration Over
        constexpr uint32_t WAKEUP_STATUS = (2 << 5);  ///< Wakeup Status
        constexpr uint32_t WAKEUP_MODE = (1U << 7);  ///< Wakeup Mode
    }

}

// ============================================================================
// WDOG Peripheral
// ============================================================================

namespace wdog {
    /// Base addresses
    constexpr uint32_t WDOG_BASE = 0x40053000;

    /// WDOG Register structure
    struct Registers {
        volatile uint32_t STCTRLH;  ///< Offset: 0x00 - Watchdog Status and Control Register High
        volatile uint32_t STCTRLL;  ///< Offset: 0x02 - Watchdog Status and Control Register Low
        volatile uint32_t TOVALH;  ///< Offset: 0x04 - Watchdog Time-out Value Register High
        volatile uint32_t TOVALL;  ///< Offset: 0x06 - Watchdog Time-out Value Register Low
        volatile uint32_t WINH;  ///< Offset: 0x08 - Watchdog Window Register High
        volatile uint32_t WINL;  ///< Offset: 0x0A - Watchdog Window Register Low
        volatile uint32_t REFRESH;  ///< Offset: 0x0C - Watchdog Refresh register
        volatile uint32_t UNLOCK;  ///< Offset: 0x0E - Watchdog Unlock register
        volatile uint32_t TMROUTH;  ///< Offset: 0x10 - Watchdog Timer Output Register High
        volatile uint32_t TMROUTL;  ///< Offset: 0x12 - Watchdog Timer Output Register Low
        volatile uint32_t RSTCNT;  ///< Offset: 0x14 - Watchdog Reset Count register
        volatile uint32_t PRESC;  ///< Offset: 0x16 - Watchdog Prescaler register
    };

    /// Peripheral instances
    inline Registers* WDOG = reinterpret_cast<Registers*>(WDOG_BASE);

    // Bit definitions
    /// STCTRLH Register bits
    namespace stctrlh_bits {
        constexpr uint32_t WDOGEN = (1U << 0);  ///< no description available
        constexpr uint32_t CLKSRC = (1U << 1);  ///< no description available
        constexpr uint32_t IRQRSTEN = (1U << 2);  ///< no description available
        constexpr uint32_t WINEN = (1U << 3);  ///< no description available
        constexpr uint32_t ALLOWUPDATE = (1U << 4);  ///< no description available
        constexpr uint32_t DBGEN = (1U << 5);  ///< no description available
        constexpr uint32_t STOPEN = (1U << 6);  ///< no description available
        constexpr uint32_t TESTWDOG = (1U << 10);  ///< no description available
        constexpr uint32_t TESTSEL = (1U << 11);  ///< no description available
        constexpr uint32_t BYTESEL = (2 << 12);  ///< no description available
        constexpr uint32_t DISTESTWDOG = (1U << 14);  ///< no description available
    }

    /// STCTRLL Register bits
    namespace stctrll_bits {
        constexpr uint32_t INTFLG = (1U << 15);  ///< no description available
    }

    /// TOVALH Register bits
    namespace tovalh_bits {
        constexpr uint32_t TOVALHIGH = (16 << 0);  ///< no description available
    }

    /// TOVALL Register bits
    namespace tovall_bits {
        constexpr uint32_t TOVALLOW = (16 << 0);  ///< no description available
    }

    /// WINH Register bits
    namespace winh_bits {
        constexpr uint32_t WINHIGH = (16 << 0);  ///< no description available
    }

    /// WINL Register bits
    namespace winl_bits {
        constexpr uint32_t WINLOW = (16 << 0);  ///< no description available
    }

    /// REFRESH Register bits
    namespace refresh_bits {
        constexpr uint32_t WDOGREFRESH = (16 << 0);  ///< no description available
    }

    /// UNLOCK Register bits
    namespace unlock_bits {
        constexpr uint32_t WDOGUNLOCK = (16 << 0);  ///< no description available
    }

    /// TMROUTH Register bits
    namespace tmrouth_bits {
        constexpr uint32_t TIMEROUTHIGH = (16 << 0);  ///< no description available
    }

    /// TMROUTL Register bits
    namespace tmroutl_bits {
        constexpr uint32_t TIMEROUTLOW = (16 << 0);  ///< no description available
    }

    /// RSTCNT Register bits
    namespace rstcnt_bits {
        constexpr uint32_t RSTCNT = (16 << 0);  ///< no description available
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCVAL = (3 << 8);  ///< no description available
    }

}

// ============================================================================
// XBAR Peripheral
// ============================================================================

namespace xbar {
    /// Base addresses
    constexpr uint32_t XBAR_BASE = 0x40055000;

    /// XBAR Register structure
    struct Registers {
        volatile uint32_t SEL0;  ///< Offset: 0x00 - Crossbar Select Register 0
        volatile uint32_t SEL1;  ///< Offset: 0x02 - Crossbar Select Register 1
        volatile uint32_t SEL2;  ///< Offset: 0x04 - Crossbar Select Register 2
        volatile uint32_t SEL3;  ///< Offset: 0x06 - Crossbar Select Register 3
        volatile uint32_t SEL4;  ///< Offset: 0x08 - Crossbar Select Register 4
        volatile uint32_t SEL5;  ///< Offset: 0x0A - Crossbar Select Register 5
        volatile uint32_t SEL6;  ///< Offset: 0x0C - Crossbar Select Register 6
        volatile uint32_t SEL7;  ///< Offset: 0x0E - Crossbar Select Register 7
        volatile uint32_t SEL8;  ///< Offset: 0x10 - Crossbar Select Register 8
        volatile uint32_t SEL9;  ///< Offset: 0x12 - Crossbar Select Register 9
        volatile uint32_t SEL10;  ///< Offset: 0x14 - Crossbar Select Register 10
        volatile uint32_t SEL11;  ///< Offset: 0x16 - Crossbar Select Register 11
        volatile uint32_t SEL12;  ///< Offset: 0x18 - Crossbar Select Register 12
        volatile uint32_t SEL13;  ///< Offset: 0x1A - Crossbar Select Register 13
        volatile uint32_t SEL14;  ///< Offset: 0x1C - Crossbar Select Register 14
        volatile uint32_t SEL15;  ///< Offset: 0x1E - Crossbar Select Register 15
        volatile uint32_t SEL16;  ///< Offset: 0x20 - Crossbar Select Register 16
        volatile uint32_t CTRL0;  ///< Offset: 0x22 - Crossbar Control Register 0
    };

    /// Peripheral instances
    inline Registers* XBAR = reinterpret_cast<Registers*>(XBAR_BASE);

    // Bit definitions
    /// SEL0 Register bits
    namespace sel0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< no description available
        constexpr uint32_t SEL1 = (6 << 8);  ///< no description available
    }

    /// SEL1 Register bits
    namespace sel1_bits {
        constexpr uint32_t SEL2 = (6 << 0);  ///< no description available
        constexpr uint32_t SEL3 = (6 << 8);  ///< no description available
    }

    /// SEL2 Register bits
    namespace sel2_bits {
        constexpr uint32_t SEL4 = (6 << 0);  ///< no description available
        constexpr uint32_t SEL5 = (6 << 8);  ///< no description available
    }

    /// SEL3 Register bits
    namespace sel3_bits {
        constexpr uint32_t SEL6 = (6 << 0);  ///< no description available
        constexpr uint32_t SEL7 = (6 << 8);  ///< no description available
    }

    /// SEL4 Register bits
    namespace sel4_bits {
        constexpr uint32_t SEL8 = (6 << 0);  ///< no description available
        constexpr uint32_t SEL9 = (6 << 8);  ///< no description available
    }

    /// SEL5 Register bits
    namespace sel5_bits {
        constexpr uint32_t SEL10 = (6 << 0);  ///< no description available
        constexpr uint32_t SEL11 = (6 << 8);  ///< no description available
    }

    /// SEL6 Register bits
    namespace sel6_bits {
        constexpr uint32_t SEL12 = (6 << 0);  ///< no description available
        constexpr uint32_t SEL13 = (6 << 8);  ///< no description available
    }

    /// SEL7 Register bits
    namespace sel7_bits {
        constexpr uint32_t SEL14 = (6 << 0);  ///< no description available
        constexpr uint32_t SEL15 = (6 << 8);  ///< no description available
    }

    /// SEL8 Register bits
    namespace sel8_bits {
        constexpr uint32_t SEL16 = (6 << 0);  ///< no description available
        constexpr uint32_t SEL17 = (6 << 8);  ///< no description available
    }

    /// SEL9 Register bits
    namespace sel9_bits {
        constexpr uint32_t SEL18 = (6 << 0);  ///< no description available
        constexpr uint32_t SEL19 = (6 << 8);  ///< no description available
    }

    /// SEL10 Register bits
    namespace sel10_bits {
        constexpr uint32_t SEL20 = (5 << 0);  ///< no description available
        constexpr uint32_t SEL21 = (5 << 8);  ///< no description available
    }

    /// SEL11 Register bits
    namespace sel11_bits {
        constexpr uint32_t SEL22 = (6 << 0);  ///< no description available
        constexpr uint32_t SEL23 = (6 << 8);  ///< no description available
    }

    /// SEL12 Register bits
    namespace sel12_bits {
        constexpr uint32_t SEL24 = (5 << 0);  ///< no description available
        constexpr uint32_t SEL25 = (5 << 8);  ///< no description available
    }

    /// SEL13 Register bits
    namespace sel13_bits {
        constexpr uint32_t SEL26 = (6 << 0);  ///< no description available
        constexpr uint32_t SEL27 = (6 << 8);  ///< no description available
    }

    /// SEL14 Register bits
    namespace sel14_bits {
        constexpr uint32_t SEL28 = (6 << 0);  ///< no description available
        constexpr uint32_t SEL29 = (6 << 8);  ///< no description available
    }

    /// SEL15 Register bits
    namespace sel15_bits {
        constexpr uint32_t SEL30 = (5 << 0);  ///< no description available
        constexpr uint32_t SEL31 = (5 << 8);  ///< no description available
    }

    /// SEL16 Register bits
    namespace sel16_bits {
        constexpr uint32_t SEL32 = (6 << 0);  ///< no description available
    }

    /// CTRL0 Register bits
    namespace ctrl0_bits {
        constexpr uint32_t DEN0 = (1U << 0);  ///< DMA Enable for XBAR_OUT0
        constexpr uint32_t IEN0 = (1U << 1);  ///< Interrupt Enable for XBAR_OUT0
        constexpr uint32_t EDGE0 = (2 << 2);  ///< Active edge for edge detection on XBAR_OUT0
        constexpr uint32_t STS0 = (1U << 4);  ///< Edge detection status for XBAR_OUT0
    }

}

// ============================================================================
// TMR0 Peripheral
// ============================================================================

namespace tmr0 {
    /// Base addresses
    constexpr uint32_t TMR0_BASE = 0x40057000;

    /// TMR0 Register structure
    struct Registers {
        volatile uint32_t COMP1;  ///< Offset: 0x00 - Timer Channel Compare Register 1
        volatile uint32_t COMP2;  ///< Offset: 0x02 - Timer Channel Compare Register 2
        volatile uint32_t CAPT;  ///< Offset: 0x04 - Timer Channel Capture Register
        volatile uint32_t LOAD;  ///< Offset: 0x06 - Timer Channel Load Register
        volatile uint32_t HOLD;  ///< Offset: 0x08 - Timer Channel Hold Register
        volatile uint32_t CNTR;  ///< Offset: 0x0A - Timer Channel Counter Register
        volatile uint32_t CTRL;  ///< Offset: 0x0C - Timer Channel Control Register
        volatile uint32_t SCTRL;  ///< Offset: 0x0E - Timer Channel Status and Control Register
        volatile uint32_t CMPLD1;  ///< Offset: 0x10 - Timer Channel Comparator Load Register 1
        volatile uint32_t CMPLD2;  ///< Offset: 0x12 - Timer Channel Comparator Load Register 2
        volatile uint32_t CSCTRL;  ///< Offset: 0x14 - Timer Channel Comparator Status and Control Register
        volatile uint32_t FILT;  ///< Offset: 0x16 - Timer Channel Input Filter Register
        volatile uint32_t ENBL;  ///< Offset: 0x1E - Timer Channel Enable Register
    };

    /// Peripheral instances
    inline Registers* TMR0 = reinterpret_cast<Registers*>(TMR0_BASE);

    // Bit definitions
    /// COMP1 Register bits
    namespace comp1_bits {
        constexpr uint32_t COMPARISON_1 = (16 << 0);  ///< Comparison Value 1
    }

    /// COMP2 Register bits
    namespace comp2_bits {
        constexpr uint32_t COMPARISON_2 = (16 << 0);  ///< Comparison Value 2
    }

    /// CAPT Register bits
    namespace capt_bits {
        constexpr uint32_t CAPTURE = (16 << 0);  ///< Capture Value
    }

    /// LOAD Register bits
    namespace load_bits {
        constexpr uint32_t LOAD = (16 << 0);  ///< Timer Load Register
    }

    /// HOLD Register bits
    namespace hold_bits {
        constexpr uint32_t HOLD = (16 << 0);  ///< no description available
    }

    /// CNTR Register bits
    namespace cntr_bits {
        constexpr uint32_t COUNTER = (16 << 0);  ///< no description available
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t OUTMODE = (3 << 0);  ///< Output Mode
        constexpr uint32_t COINIT = (1U << 3);  ///< Co-Channel Initialization
        constexpr uint32_t DIR = (1U << 4);  ///< Count Direction
        constexpr uint32_t LENGTH = (1U << 5);  ///< Count Length
        constexpr uint32_t ONCE = (1U << 6);  ///< Count Once
        constexpr uint32_t SCS = (2 << 7);  ///< Secondary Count Source
        constexpr uint32_t PCS = (4 << 9);  ///< Primary Count Source
        constexpr uint32_t CM = (3 << 13);  ///< Count Mode
    }

    /// SCTRL Register bits
    namespace sctrl_bits {
        constexpr uint32_t OEN = (1U << 0);  ///< Output Enable
        constexpr uint32_t OPS = (1U << 1);  ///< Output Polarity Select
        constexpr uint32_t FORCE = (1U << 2);  ///< Force OFLAG Output
        constexpr uint32_t VAL = (1U << 3);  ///< Forced OFLAG Value
        constexpr uint32_t EEOF = (1U << 4);  ///< Enable External OFLAG Force
        constexpr uint32_t MSTR = (1U << 5);  ///< Master Mode
        constexpr uint32_t CAPTURE_MODE = (2 << 6);  ///< Input Capture Mode
        constexpr uint32_t INPUT = (1U << 8);  ///< External Input Signal
        constexpr uint32_t IPS = (1U << 9);  ///< Input Polarity Select
        constexpr uint32_t IEFIE = (1U << 10);  ///< Input Edge Flag Interrupt Enable
        constexpr uint32_t IEF = (1U << 11);  ///< Input Edge Flag
        constexpr uint32_t TOFIE = (1U << 12);  ///< Timer Overflow Flag Interrupt Enable
        constexpr uint32_t TOF = (1U << 13);  ///< Timer Overflow Flag
        constexpr uint32_t TCFIE = (1U << 14);  ///< Timer Compare Flag Interrupt Enable
        constexpr uint32_t TCF = (1U << 15);  ///< Timer Compare Flag
    }

    /// CMPLD1 Register bits
    namespace cmpld1_bits {
        constexpr uint32_t COMPARATOR_LOAD_1 = (16 << 0);  ///< no description available
    }

    /// CMPLD2 Register bits
    namespace cmpld2_bits {
        constexpr uint32_t COMPARATOR_LOAD_2 = (16 << 0);  ///< no description available
    }

    /// CSCTRL Register bits
    namespace csctrl_bits {
        constexpr uint32_t CL1 = (2 << 0);  ///< Compare Load Control 1
        constexpr uint32_t CL2 = (2 << 2);  ///< Compare Load Control 2
        constexpr uint32_t TCF1 = (1U << 4);  ///< Timer Compare 1 Interrupt Flag
        constexpr uint32_t TCF2 = (1U << 5);  ///< Timer Compare 2 Interrupt Flag
        constexpr uint32_t TCF1EN = (1U << 6);  ///< Timer Compare 1 Interrupt Enable
        constexpr uint32_t TCF2EN = (1U << 7);  ///< Timer Compare 2 Interrupt Enable
        constexpr uint32_t OFLAG = (1U << 8);  ///< Output flag
        constexpr uint32_t UP = (1U << 9);  ///< Counting Direction Indicator
        constexpr uint32_t TCI = (1U << 10);  ///< Triggered Count Initialization Control
        constexpr uint32_t ROC = (1U << 11);  ///< Reload on Capture
        constexpr uint32_t ALT_LOAD = (1U << 12);  ///< Alternative Load Enable
        constexpr uint32_t FAULT = (1U << 13);  ///< Fault Enable
        constexpr uint32_t DBG_EN = (2 << 14);  ///< Debug Actions Enable
    }

    /// FILT Register bits
    namespace filt_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Input Filter Sample Period
        constexpr uint32_t FILT_CNT = (3 << 8);  ///< Input Filter Sample Count
    }

    /// ENBL Register bits
    namespace enbl_bits {
        constexpr uint32_t ENBL = (4 << 0);  ///< Timer Channel Enable
    }

}

// ============================================================================
// TMR1 Peripheral
// ============================================================================

namespace tmr1 {
    /// Base addresses
    constexpr uint32_t TMR1_BASE = 0x40058000;

    /// TMR1 Register structure
    struct Registers {
        volatile uint32_t COMP1;  ///< Offset: 0x00 - Timer Channel Compare Register 1
        volatile uint32_t COMP2;  ///< Offset: 0x02 - Timer Channel Compare Register 2
        volatile uint32_t CAPT;  ///< Offset: 0x04 - Timer Channel Capture Register
        volatile uint32_t LOAD;  ///< Offset: 0x06 - Timer Channel Load Register
        volatile uint32_t HOLD;  ///< Offset: 0x08 - Timer Channel Hold Register
        volatile uint32_t CNTR;  ///< Offset: 0x0A - Timer Channel Counter Register
        volatile uint32_t CTRL;  ///< Offset: 0x0C - Timer Channel Control Register
        volatile uint32_t SCTRL;  ///< Offset: 0x0E - Timer Channel Status and Control Register
        volatile uint32_t CMPLD1;  ///< Offset: 0x10 - Timer Channel Comparator Load Register 1
        volatile uint32_t CMPLD2;  ///< Offset: 0x12 - Timer Channel Comparator Load Register 2
        volatile uint32_t CSCTRL;  ///< Offset: 0x14 - Timer Channel Comparator Status and Control Register
        volatile uint32_t FILT;  ///< Offset: 0x16 - Timer Channel Input Filter Register
    };

    /// Peripheral instances
    inline Registers* TMR1 = reinterpret_cast<Registers*>(TMR1_BASE);

    // Bit definitions
    /// COMP1 Register bits
    namespace comp1_bits {
        constexpr uint32_t COMPARISON_1 = (16 << 0);  ///< Comparison Value 1
    }

    /// COMP2 Register bits
    namespace comp2_bits {
        constexpr uint32_t COMPARISON_2 = (16 << 0);  ///< Comparison Value 2
    }

    /// CAPT Register bits
    namespace capt_bits {
        constexpr uint32_t CAPTURE = (16 << 0);  ///< Capture Value
    }

    /// LOAD Register bits
    namespace load_bits {
        constexpr uint32_t LOAD = (16 << 0);  ///< Timer Load Register
    }

    /// HOLD Register bits
    namespace hold_bits {
        constexpr uint32_t HOLD = (16 << 0);  ///< no description available
    }

    /// CNTR Register bits
    namespace cntr_bits {
        constexpr uint32_t COUNTER = (16 << 0);  ///< no description available
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t OUTMODE = (3 << 0);  ///< Output Mode
        constexpr uint32_t COINIT = (1U << 3);  ///< Co-Channel Initialization
        constexpr uint32_t DIR = (1U << 4);  ///< Count Direction
        constexpr uint32_t LENGTH = (1U << 5);  ///< Count Length
        constexpr uint32_t ONCE = (1U << 6);  ///< Count Once
        constexpr uint32_t SCS = (2 << 7);  ///< Secondary Count Source
        constexpr uint32_t PCS = (4 << 9);  ///< Primary Count Source
        constexpr uint32_t CM = (3 << 13);  ///< Count Mode
    }

    /// SCTRL Register bits
    namespace sctrl_bits {
        constexpr uint32_t OEN = (1U << 0);  ///< Output Enable
        constexpr uint32_t OPS = (1U << 1);  ///< Output Polarity Select
        constexpr uint32_t FORCE = (1U << 2);  ///< Force OFLAG Output
        constexpr uint32_t VAL = (1U << 3);  ///< Forced OFLAG Value
        constexpr uint32_t EEOF = (1U << 4);  ///< Enable External OFLAG Force
        constexpr uint32_t MSTR = (1U << 5);  ///< Master Mode
        constexpr uint32_t CAPTURE_MODE = (2 << 6);  ///< Input Capture Mode
        constexpr uint32_t INPUT = (1U << 8);  ///< External Input Signal
        constexpr uint32_t IPS = (1U << 9);  ///< Input Polarity Select
        constexpr uint32_t IEFIE = (1U << 10);  ///< Input Edge Flag Interrupt Enable
        constexpr uint32_t IEF = (1U << 11);  ///< Input Edge Flag
        constexpr uint32_t TOFIE = (1U << 12);  ///< Timer Overflow Flag Interrupt Enable
        constexpr uint32_t TOF = (1U << 13);  ///< Timer Overflow Flag
        constexpr uint32_t TCFIE = (1U << 14);  ///< Timer Compare Flag Interrupt Enable
        constexpr uint32_t TCF = (1U << 15);  ///< Timer Compare Flag
    }

    /// CMPLD1 Register bits
    namespace cmpld1_bits {
        constexpr uint32_t COMPARATOR_LOAD_1 = (16 << 0);  ///< no description available
    }

    /// CMPLD2 Register bits
    namespace cmpld2_bits {
        constexpr uint32_t COMPARATOR_LOAD_2 = (16 << 0);  ///< no description available
    }

    /// CSCTRL Register bits
    namespace csctrl_bits {
        constexpr uint32_t CL1 = (2 << 0);  ///< Compare Load Control 1
        constexpr uint32_t CL2 = (2 << 2);  ///< Compare Load Control 2
        constexpr uint32_t TCF1 = (1U << 4);  ///< Timer Compare 1 Interrupt Flag
        constexpr uint32_t TCF2 = (1U << 5);  ///< Timer Compare 2 Interrupt Flag
        constexpr uint32_t TCF1EN = (1U << 6);  ///< Timer Compare 1 Interrupt Enable
        constexpr uint32_t TCF2EN = (1U << 7);  ///< Timer Compare 2 Interrupt Enable
        constexpr uint32_t OFLAG = (1U << 8);  ///< Output flag
        constexpr uint32_t UP = (1U << 9);  ///< Counting Direction Indicator
        constexpr uint32_t TCI = (1U << 10);  ///< Triggered Count Initialization Control
        constexpr uint32_t ROC = (1U << 11);  ///< Reload on Capture
        constexpr uint32_t ALT_LOAD = (1U << 12);  ///< Alternative Load Enable
        constexpr uint32_t FAULT = (1U << 13);  ///< Fault Enable
        constexpr uint32_t DBG_EN = (2 << 14);  ///< Debug Actions Enable
    }

    /// FILT Register bits
    namespace filt_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Input Filter Sample Period
        constexpr uint32_t FILT_CNT = (3 << 8);  ///< Input Filter Sample Count
    }

}

// ============================================================================
// TMR2 Peripheral
// ============================================================================

namespace tmr2 {
    /// Base addresses
    constexpr uint32_t TMR2_BASE = 0x40059000;

    /// TMR2 Register structure
    struct Registers {
        volatile uint32_t COMP1;  ///< Offset: 0x00 - Timer Channel Compare Register 1
        volatile uint32_t COMP2;  ///< Offset: 0x02 - Timer Channel Compare Register 2
        volatile uint32_t CAPT;  ///< Offset: 0x04 - Timer Channel Capture Register
        volatile uint32_t LOAD;  ///< Offset: 0x06 - Timer Channel Load Register
        volatile uint32_t HOLD;  ///< Offset: 0x08 - Timer Channel Hold Register
        volatile uint32_t CNTR;  ///< Offset: 0x0A - Timer Channel Counter Register
        volatile uint32_t CTRL;  ///< Offset: 0x0C - Timer Channel Control Register
        volatile uint32_t SCTRL;  ///< Offset: 0x0E - Timer Channel Status and Control Register
        volatile uint32_t CMPLD1;  ///< Offset: 0x10 - Timer Channel Comparator Load Register 1
        volatile uint32_t CMPLD2;  ///< Offset: 0x12 - Timer Channel Comparator Load Register 2
        volatile uint32_t CSCTRL;  ///< Offset: 0x14 - Timer Channel Comparator Status and Control Register
        volatile uint32_t FILT;  ///< Offset: 0x16 - Timer Channel Input Filter Register
    };

    /// Peripheral instances
    inline Registers* TMR2 = reinterpret_cast<Registers*>(TMR2_BASE);

    // Bit definitions
    /// COMP1 Register bits
    namespace comp1_bits {
        constexpr uint32_t COMPARISON_1 = (16 << 0);  ///< Comparison Value 1
    }

    /// COMP2 Register bits
    namespace comp2_bits {
        constexpr uint32_t COMPARISON_2 = (16 << 0);  ///< Comparison Value 2
    }

    /// CAPT Register bits
    namespace capt_bits {
        constexpr uint32_t CAPTURE = (16 << 0);  ///< Capture Value
    }

    /// LOAD Register bits
    namespace load_bits {
        constexpr uint32_t LOAD = (16 << 0);  ///< Timer Load Register
    }

    /// HOLD Register bits
    namespace hold_bits {
        constexpr uint32_t HOLD = (16 << 0);  ///< no description available
    }

    /// CNTR Register bits
    namespace cntr_bits {
        constexpr uint32_t COUNTER = (16 << 0);  ///< no description available
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t OUTMODE = (3 << 0);  ///< Output Mode
        constexpr uint32_t COINIT = (1U << 3);  ///< Co-Channel Initialization
        constexpr uint32_t DIR = (1U << 4);  ///< Count Direction
        constexpr uint32_t LENGTH = (1U << 5);  ///< Count Length
        constexpr uint32_t ONCE = (1U << 6);  ///< Count Once
        constexpr uint32_t SCS = (2 << 7);  ///< Secondary Count Source
        constexpr uint32_t PCS = (4 << 9);  ///< Primary Count Source
        constexpr uint32_t CM = (3 << 13);  ///< Count Mode
    }

    /// SCTRL Register bits
    namespace sctrl_bits {
        constexpr uint32_t OEN = (1U << 0);  ///< Output Enable
        constexpr uint32_t OPS = (1U << 1);  ///< Output Polarity Select
        constexpr uint32_t FORCE = (1U << 2);  ///< Force OFLAG Output
        constexpr uint32_t VAL = (1U << 3);  ///< Forced OFLAG Value
        constexpr uint32_t EEOF = (1U << 4);  ///< Enable External OFLAG Force
        constexpr uint32_t MSTR = (1U << 5);  ///< Master Mode
        constexpr uint32_t CAPTURE_MODE = (2 << 6);  ///< Input Capture Mode
        constexpr uint32_t INPUT = (1U << 8);  ///< External Input Signal
        constexpr uint32_t IPS = (1U << 9);  ///< Input Polarity Select
        constexpr uint32_t IEFIE = (1U << 10);  ///< Input Edge Flag Interrupt Enable
        constexpr uint32_t IEF = (1U << 11);  ///< Input Edge Flag
        constexpr uint32_t TOFIE = (1U << 12);  ///< Timer Overflow Flag Interrupt Enable
        constexpr uint32_t TOF = (1U << 13);  ///< Timer Overflow Flag
        constexpr uint32_t TCFIE = (1U << 14);  ///< Timer Compare Flag Interrupt Enable
        constexpr uint32_t TCF = (1U << 15);  ///< Timer Compare Flag
    }

    /// CMPLD1 Register bits
    namespace cmpld1_bits {
        constexpr uint32_t COMPARATOR_LOAD_1 = (16 << 0);  ///< no description available
    }

    /// CMPLD2 Register bits
    namespace cmpld2_bits {
        constexpr uint32_t COMPARATOR_LOAD_2 = (16 << 0);  ///< no description available
    }

    /// CSCTRL Register bits
    namespace csctrl_bits {
        constexpr uint32_t CL1 = (2 << 0);  ///< Compare Load Control 1
        constexpr uint32_t CL2 = (2 << 2);  ///< Compare Load Control 2
        constexpr uint32_t TCF1 = (1U << 4);  ///< Timer Compare 1 Interrupt Flag
        constexpr uint32_t TCF2 = (1U << 5);  ///< Timer Compare 2 Interrupt Flag
        constexpr uint32_t TCF1EN = (1U << 6);  ///< Timer Compare 1 Interrupt Enable
        constexpr uint32_t TCF2EN = (1U << 7);  ///< Timer Compare 2 Interrupt Enable
        constexpr uint32_t OFLAG = (1U << 8);  ///< Output flag
        constexpr uint32_t UP = (1U << 9);  ///< Counting Direction Indicator
        constexpr uint32_t TCI = (1U << 10);  ///< Triggered Count Initialization Control
        constexpr uint32_t ROC = (1U << 11);  ///< Reload on Capture
        constexpr uint32_t ALT_LOAD = (1U << 12);  ///< Alternative Load Enable
        constexpr uint32_t FAULT = (1U << 13);  ///< Fault Enable
        constexpr uint32_t DBG_EN = (2 << 14);  ///< Debug Actions Enable
    }

    /// FILT Register bits
    namespace filt_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Input Filter Sample Period
        constexpr uint32_t FILT_CNT = (3 << 8);  ///< Input Filter Sample Count
    }

}

// ============================================================================
// TMR3 Peripheral
// ============================================================================

namespace tmr3 {
    /// Base addresses
    constexpr uint32_t TMR3_BASE = 0x4005A000;

    /// TMR3 Register structure
    struct Registers {
        volatile uint32_t COMP1;  ///< Offset: 0x00 - Timer Channel Compare Register 1
        volatile uint32_t COMP2;  ///< Offset: 0x02 - Timer Channel Compare Register 2
        volatile uint32_t CAPT;  ///< Offset: 0x04 - Timer Channel Capture Register
        volatile uint32_t LOAD;  ///< Offset: 0x06 - Timer Channel Load Register
        volatile uint32_t HOLD;  ///< Offset: 0x08 - Timer Channel Hold Register
        volatile uint32_t CNTR;  ///< Offset: 0x0A - Timer Channel Counter Register
        volatile uint32_t CTRL;  ///< Offset: 0x0C - Timer Channel Control Register
        volatile uint32_t SCTRL;  ///< Offset: 0x0E - Timer Channel Status and Control Register
        volatile uint32_t CMPLD1;  ///< Offset: 0x10 - Timer Channel Comparator Load Register 1
        volatile uint32_t CMPLD2;  ///< Offset: 0x12 - Timer Channel Comparator Load Register 2
        volatile uint32_t CSCTRL;  ///< Offset: 0x14 - Timer Channel Comparator Status and Control Register
        volatile uint32_t FILT;  ///< Offset: 0x16 - Timer Channel Input Filter Register
    };

    /// Peripheral instances
    inline Registers* TMR3 = reinterpret_cast<Registers*>(TMR3_BASE);

    // Bit definitions
    /// COMP1 Register bits
    namespace comp1_bits {
        constexpr uint32_t COMPARISON_1 = (16 << 0);  ///< Comparison Value 1
    }

    /// COMP2 Register bits
    namespace comp2_bits {
        constexpr uint32_t COMPARISON_2 = (16 << 0);  ///< Comparison Value 2
    }

    /// CAPT Register bits
    namespace capt_bits {
        constexpr uint32_t CAPTURE = (16 << 0);  ///< Capture Value
    }

    /// LOAD Register bits
    namespace load_bits {
        constexpr uint32_t LOAD = (16 << 0);  ///< Timer Load Register
    }

    /// HOLD Register bits
    namespace hold_bits {
        constexpr uint32_t HOLD = (16 << 0);  ///< no description available
    }

    /// CNTR Register bits
    namespace cntr_bits {
        constexpr uint32_t COUNTER = (16 << 0);  ///< no description available
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t OUTMODE = (3 << 0);  ///< Output Mode
        constexpr uint32_t COINIT = (1U << 3);  ///< Co-Channel Initialization
        constexpr uint32_t DIR = (1U << 4);  ///< Count Direction
        constexpr uint32_t LENGTH = (1U << 5);  ///< Count Length
        constexpr uint32_t ONCE = (1U << 6);  ///< Count Once
        constexpr uint32_t SCS = (2 << 7);  ///< Secondary Count Source
        constexpr uint32_t PCS = (4 << 9);  ///< Primary Count Source
        constexpr uint32_t CM = (3 << 13);  ///< Count Mode
    }

    /// SCTRL Register bits
    namespace sctrl_bits {
        constexpr uint32_t OEN = (1U << 0);  ///< Output Enable
        constexpr uint32_t OPS = (1U << 1);  ///< Output Polarity Select
        constexpr uint32_t FORCE = (1U << 2);  ///< Force OFLAG Output
        constexpr uint32_t VAL = (1U << 3);  ///< Forced OFLAG Value
        constexpr uint32_t EEOF = (1U << 4);  ///< Enable External OFLAG Force
        constexpr uint32_t MSTR = (1U << 5);  ///< Master Mode
        constexpr uint32_t CAPTURE_MODE = (2 << 6);  ///< Input Capture Mode
        constexpr uint32_t INPUT = (1U << 8);  ///< External Input Signal
        constexpr uint32_t IPS = (1U << 9);  ///< Input Polarity Select
        constexpr uint32_t IEFIE = (1U << 10);  ///< Input Edge Flag Interrupt Enable
        constexpr uint32_t IEF = (1U << 11);  ///< Input Edge Flag
        constexpr uint32_t TOFIE = (1U << 12);  ///< Timer Overflow Flag Interrupt Enable
        constexpr uint32_t TOF = (1U << 13);  ///< Timer Overflow Flag
        constexpr uint32_t TCFIE = (1U << 14);  ///< Timer Compare Flag Interrupt Enable
        constexpr uint32_t TCF = (1U << 15);  ///< Timer Compare Flag
    }

    /// CMPLD1 Register bits
    namespace cmpld1_bits {
        constexpr uint32_t COMPARATOR_LOAD_1 = (16 << 0);  ///< no description available
    }

    /// CMPLD2 Register bits
    namespace cmpld2_bits {
        constexpr uint32_t COMPARATOR_LOAD_2 = (16 << 0);  ///< no description available
    }

    /// CSCTRL Register bits
    namespace csctrl_bits {
        constexpr uint32_t CL1 = (2 << 0);  ///< Compare Load Control 1
        constexpr uint32_t CL2 = (2 << 2);  ///< Compare Load Control 2
        constexpr uint32_t TCF1 = (1U << 4);  ///< Timer Compare 1 Interrupt Flag
        constexpr uint32_t TCF2 = (1U << 5);  ///< Timer Compare 2 Interrupt Flag
        constexpr uint32_t TCF1EN = (1U << 6);  ///< Timer Compare 1 Interrupt Enable
        constexpr uint32_t TCF2EN = (1U << 7);  ///< Timer Compare 2 Interrupt Enable
        constexpr uint32_t OFLAG = (1U << 8);  ///< Output flag
        constexpr uint32_t UP = (1U << 9);  ///< Counting Direction Indicator
        constexpr uint32_t TCI = (1U << 10);  ///< Triggered Count Initialization Control
        constexpr uint32_t ROC = (1U << 11);  ///< Reload on Capture
        constexpr uint32_t ALT_LOAD = (1U << 12);  ///< Alternative Load Enable
        constexpr uint32_t FAULT = (1U << 13);  ///< Fault Enable
        constexpr uint32_t DBG_EN = (2 << 14);  ///< Debug Actions Enable
    }

    /// FILT Register bits
    namespace filt_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Input Filter Sample Period
        constexpr uint32_t FILT_CNT = (3 << 8);  ///< Input Filter Sample Count
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x40061000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
        constexpr uint32_t INTEN = (1U << 3);  ///< Interrupt Enable.
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< no description available
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< no description available
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< no description available
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t MCG_BASE = 0x40064000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - MCG Control 1 Register
        volatile uint32_t C2;  ///< Offset: 0x01 - MCG Control 2 Register
        volatile uint32_t C3;  ///< Offset: 0x02 - MCG Control 3 Register
        volatile uint32_t C4;  ///< Offset: 0x03 - MCG Control 4 Register
        volatile uint32_t C5;  ///< Offset: 0x04 - MCG Control 5 Register
        volatile uint32_t C6;  ///< Offset: 0x05 - MCG Control 6 Register
        volatile uint32_t S;  ///< Offset: 0x06 - MCG Status Register
        volatile uint32_t SC;  ///< Offset: 0x08 - MCG Status and Control Register
        volatile uint32_t ATCVH;  ///< Offset: 0x0A - MCG Auto Trim Compare Value High Register
        volatile uint32_t ATCVL;  ///< Offset: 0x0B - MCG Auto Trim Compare Value Low Register
        volatile uint32_t C7;  ///< Offset: 0x0C - MCG Control 7 Register
        volatile uint32_t C8;  ///< Offset: 0x0D - MCG Control 8 Register
        volatile uint32_t C9;  ///< Offset: 0x0E - MCG Control 9 Register
    };

    /// Peripheral instances
    inline Registers* MCG = reinterpret_cast<Registers*>(MCG_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t IREFS = (1U << 2);  ///< Internal Reference Select
        constexpr uint32_t FRDIV = (3 << 3);  ///< FLL External Reference Divider
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t IRCS = (1U << 0);  ///< Internal Reference Clock Select
        constexpr uint32_t LP = (1U << 1);  ///< Low Power Select
        constexpr uint32_t EREFS0 = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO0 = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE0 = (2 << 4);  ///< Frequency Range Select
        constexpr uint32_t LOCRE0 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t SCTRIM = (8 << 0);  ///< Slow Internal Reference Clock Trim Setting
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t SCFTRIM = (1U << 0);  ///< Slow Internal Reference Clock Fine Trim
        constexpr uint32_t FCTRIM = (4 << 1);  ///< Fast Internal Reference Clock Trim Setting
        constexpr uint32_t DRST_DRS = (2 << 5);  ///< DCO Range Select
        constexpr uint32_t DMX32 = (1U << 7);  ///< DCO Maximum Frequency with 32.768 kHz Reference
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t PLLSTEN0 = (1U << 5);  ///< PLL Stop Enable
        constexpr uint32_t PLLCLKEN0 = (1U << 6);  ///< PLL Clock Enable
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t CHGPMP_BIAS = (5 << 0);  ///< Directly controls the PLL Charge Pump Current. Appropiate selection of this value is imperative to ensure stable operation of the PLL closed loop system. The default value for this field is set to 5'b01000 out of reset which generates a nominal 750nA charge pump current (lcp).
        constexpr uint32_t CME0 = (1U << 5);  ///< Clock Monitor Enable
        constexpr uint32_t PLLS = (1U << 6);  ///< PLL Select
        constexpr uint32_t LOLIE0 = (1U << 7);  ///< Loss of Lock Interrrupt Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t IRCST = (1U << 0);  ///< Internal Reference Clock Status
        constexpr uint32_t OSCINIT0 = (1U << 1);  ///< OSC Initialization
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
        constexpr uint32_t IREFST = (1U << 4);  ///< Internal Reference Status
        constexpr uint32_t PLLST = (1U << 5);  ///< PLL Select Status
        constexpr uint32_t LOCK0 = (1U << 6);  ///< Lock Status
        constexpr uint32_t LOLS0 = (1U << 7);  ///< Loss of Lock Status
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LOCS0 = (1U << 0);  ///< OSC0 Loss of Clock Status
        constexpr uint32_t FCRDIV = (3 << 1);  ///< Fast Clock Internal Reference Divider
        constexpr uint32_t FLTPRSRV = (1U << 4);  ///< FLL Filter Preserve Enable
        constexpr uint32_t ATMF = (1U << 5);  ///< Automatic Trim Machine Fail Flag
        constexpr uint32_t ATMS = (1U << 6);  ///< Automatic Trim Machine Select
        constexpr uint32_t ATME = (1U << 7);  ///< Automatic Trim Machine Enable
    }

    /// ATCVH Register bits
    namespace atcvh_bits {
        constexpr uint32_t ATCVH = (8 << 0);  ///< ATM Compare Value High
    }

    /// ATCVL Register bits
    namespace atcvl_bits {
        constexpr uint32_t ATCVL = (8 << 0);  ///< ATM Compare Value Low
    }

    /// C7 Register bits
    namespace c7_bits {
        constexpr uint32_t OSCSEL = (1U << 0);  ///< MCG OSC Clock Select
        constexpr uint32_t PLL32KREFSEL = (2 << 6);  ///< MCG PLL 32Khz Reference Clock Select
    }

    /// C8 Register bits
    namespace c8_bits {
        constexpr uint32_t LOCS1 = (1U << 0);  ///< RTC Loss of Clock Status
        constexpr uint32_t COARSE_LOLIE = (1U << 4);  ///< Loss of Coarse Lock Interrrupt Enable
        constexpr uint32_t CME1 = (1U << 5);  ///< Clock Monitor Enable1
        constexpr uint32_t LOLRE = (1U << 6);  ///< PLL Loss of Lock Reset Enable
        constexpr uint32_t LOCRE1 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

    /// C9 Register bits
    namespace c9_bits {
        constexpr uint32_t COARSE_LOCK = (1U << 6);  ///< Coarse Lock Status
        constexpr uint32_t COARSE_LOLS = (1U << 7);  ///< Coarse Loss of Lock Status
    }

}

// ============================================================================
// OSC Peripheral
// ============================================================================

namespace osc {
    /// Base addresses
    constexpr uint32_t OSC_BASE = 0x40066000;

    /// OSC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OSC Control Register
    };

    /// Peripheral instances
    inline Registers* OSC = reinterpret_cast<Registers*>(OSC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SC16P = (1U << 0);  ///< Oscillator 16 pF Capacitor Load Configure
        constexpr uint32_t SC8P = (1U << 1);  ///< Oscillator 8 pF Capacitor Load Configure
        constexpr uint32_t SC4P = (1U << 2);  ///< Oscillator 4 pF Capacitor Load Configure
        constexpr uint32_t SC2P = (1U << 3);  ///< Oscillator 2 pF Capacitor Load Configure
        constexpr uint32_t EREFSTEN = (1U << 5);  ///< External Reference Stop Enable
        constexpr uint32_t ERCLKEN = (1U << 7);  ///< External Reference Enable
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40067000;
    constexpr uint32_t I2C1_BASE = 0x40068000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S;  ///< Offset: 0x03 - I2C Status register
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter Register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< ClockRate
        constexpr uint32_t MULT = (2 << 6);  ///< Multiplier Factor
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup Enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit Acknowledge Enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit Mode Select
        constexpr uint32_t MST = (1U << 5);  ///< Master Mode Select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C Interrupt Enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive Acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt Flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave Read/Write
        constexpr uint32_t RAM = (1U << 3);  ///< Range Address Match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration Lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus Busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed As A Slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer Complete Flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave Address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range Address Matching Enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave Baud Rate Control
        constexpr uint32_t HDRS = (1U << 5);  ///< High Drive Select
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address Extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General Call Address Enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (4 << 0);  ///< I2C Programmable Filter Factor
        constexpr uint32_t STARTF = (1U << 4);  ///< I2C Bus Start Detect Flag
        constexpr uint32_t SSIE = (1U << 5);  ///< I2C Bus Stop or Start Interrupt Enable
        constexpr uint32_t STOPF = (1U << 6);  ///< I2C Bus Stop Detect Flag
        constexpr uint32_t SHEN = (1U << 7);  ///< Stop Hold Enable
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RAD = (7 << 1);  ///< Range Slave Address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 Interrupt Enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL High Timeout Flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL High Timeout Flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL Low Timeout Flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout Counter Clock Select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C Address Enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus Alert Response Address Enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK Enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus Address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[15:8]
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[7:0]
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x4006A000;
    constexpr uint32_t UART1_BASE = 0x4006B000;
    constexpr uint32_t UART2_BASE = 0x4006C000;
    constexpr uint32_t UART3_BASE = 0x4006D000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BDH;  ///< Offset: 0x00 - UART Baud Rate Registers: High
        volatile uint32_t BDL;  ///< Offset: 0x01 - UART Baud Rate Registers: Low
        volatile uint32_t C1;  ///< Offset: 0x02 - UART Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x03 - UART Control Register 2
        volatile uint32_t S1;  ///< Offset: 0x04 - UART Status Register 1
        volatile uint32_t S2;  ///< Offset: 0x05 - UART Status Register 2
        volatile uint32_t C3;  ///< Offset: 0x06 - UART Control Register 3
        volatile uint32_t D;  ///< Offset: 0x07 - UART Data Register
        volatile uint32_t MA1;  ///< Offset: 0x08 - UART Match Address Registers 1
        volatile uint32_t MA2;  ///< Offset: 0x09 - UART Match Address Registers 2
        volatile uint32_t C4;  ///< Offset: 0x0A - UART Control Register 4
        volatile uint32_t C5;  ///< Offset: 0x0B - UART Control Register 5
        volatile uint32_t ED;  ///< Offset: 0x0C - UART Extended Data Register
        volatile uint32_t MODEM;  ///< Offset: 0x0D - UART Modem Register
        volatile uint32_t PFIFO;  ///< Offset: 0x10 - UART FIFO Parameters
        volatile uint32_t CFIFO;  ///< Offset: 0x11 - UART FIFO Control Register
        volatile uint32_t SFIFO;  ///< Offset: 0x12 - UART FIFO Status Register
        volatile uint32_t TWFIFO;  ///< Offset: 0x13 - UART FIFO Transmit Watermark
        volatile uint32_t TCFIFO;  ///< Offset: 0x14 - UART FIFO Transmit Count
        volatile uint32_t RWFIFO;  ///< Offset: 0x15 - UART FIFO Receive Watermark
        volatile uint32_t RCFIFO;  ///< Offset: 0x16 - UART FIFO Receive Count
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);

    // Bit definitions
    /// BDH Register bits
    namespace bdh_bits {
        constexpr uint32_t SBR = (5 << 0);  ///< UART Baud Rate Bits
        constexpr uint32_t RXEDGIE = (1U << 6);  ///< RxD Input Active Edge Interrupt Enable
    }

    /// BDL Register bits
    namespace bdl_bits {
        constexpr uint32_t SBR = (8 << 0);  ///< UART Baud Rate Bits
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-bit or 8-bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t SBK = (1U << 0);  ///< Send Break
        constexpr uint32_t RWU = (1U << 1);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 2);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 4);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receiver Full Interrupt or DMA Transfer Enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission Complete Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmitter Interrupt or DMA Transfer Enable.
    }

    /// S1 Register bits
    namespace s1_bits {
        constexpr uint32_t PF = (1U << 0);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 1);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 2);  ///< Noise Flag
        constexpr uint32_t OR = (1U << 3);  ///< Receiver Overrun Flag
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 6);  ///< Transmit Complete Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Register Empty Flag
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t RAF = (1U << 0);  ///< Receiver Active Flag
        constexpr uint32_t BRK13 = (1U << 2);  ///< Break Transmit Character Length
        constexpr uint32_t RWUID = (1U << 3);  ///< Receive Wakeup Idle Detect
        constexpr uint32_t RXINV = (1U << 4);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 5);  ///< Most Significant Bit First
        constexpr uint32_t RXEDGIF = (1U << 6);  ///< RxD Pin Active Edge Interrupt Flag
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t PEIE = (1U << 0);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 1);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 2);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 3);  ///< Overrun Error Interrupt Enable
        constexpr uint32_t TXINV = (1U << 4);  ///< Transmit Data Inversion.
        constexpr uint32_t TXDIR = (1U << 5);  ///< Transmitter Pin Data Direction in Single-Wire mode
        constexpr uint32_t T8 = (1U << 6);  ///< Transmit Bit 8
        constexpr uint32_t R8 = (1U << 7);  ///< Received Bit 8
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t RT = (8 << 0);  ///< no description available
    }

    /// MA1 Register bits
    namespace ma1_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// MA2 Register bits
    namespace ma2_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t BRFA = (5 << 0);  ///< Baud Rate Fine Adjust
        constexpr uint32_t M10 = (1U << 5);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 6);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 7);  ///< Match Address Mode Enable 1
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t RDMAS = (1U << 5);  ///< Receiver Full DMA Select
        constexpr uint32_t TDMAS = (1U << 7);  ///< Transmitter DMA Select
    }

    /// ED Register bits
    namespace ed_bits {
        constexpr uint32_t PARITYE = (1U << 6);  ///< no description available
        constexpr uint32_t NOISY = (1U << 7);  ///< no description available
    }

    /// MODEM Register bits
    namespace modem_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
    }

    /// PFIFO Register bits
    namespace pfifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO. Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO. Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
    }

    /// CFIFO Register bits
    namespace cfifo_bits {
        constexpr uint32_t RXUFE = (1U << 0);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 1);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXOFE = (1U << 2);  ///< Receive FIFO Overflow Interrupt Enable
        constexpr uint32_t RXFLUSH = (1U << 6);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 7);  ///< Transmit FIFO/Buffer Flush
    }

    /// SFIFO Register bits
    namespace sfifo_bits {
        constexpr uint32_t RXUF = (1U << 0);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 1);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXOF = (1U << 2);  ///< Receiver Buffer Overflow Flag
        constexpr uint32_t RXEMPT = (1U << 6);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 7);  ///< Transmit Buffer/FIFO Empty
    }

    /// TWFIFO Register bits
    namespace twfifo_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit Watermark
    }

    /// TCFIFO Register bits
    namespace tcfifo_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit Counter
    }

    /// RWFIFO Register bits
    namespace rwfifo_bits {
        constexpr uint32_t RXWATER = (8 << 0);  ///< Receive Watermark
    }

    /// RCFIFO Register bits
    namespace rcfifo_bits {
        constexpr uint32_t RXCOUNT = (8 << 0);  ///< Receive Counter
    }

}

// ============================================================================
// VREF Peripheral
// ============================================================================

namespace vref {
    /// Base addresses
    constexpr uint32_t VREF_BASE = 0x4006F000;

    /// VREF Register structure
    struct Registers {
        volatile uint32_t VREFH_TRM;  ///< Offset: 0x00 - VREF Trim Register
        volatile uint32_t VREFH_SC;  ///< Offset: 0x01 - VREF Status and Control Register
        volatile uint32_t VREFL_TRM;  ///< Offset: 0x05 - VREFL TRIM Register
    };

    /// Peripheral instances
    inline Registers* VREF = reinterpret_cast<Registers*>(VREF_BASE);

    // Bit definitions
    /// VREFH_TRM Register bits
    namespace vrefh_trm_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trim bits
        constexpr uint32_t CHOPEN = (1U << 6);  ///< Chop oscillator enable. When set, internal chopping operation is enabled and the internal analog offset will be minimized.
    }

    /// VREFH_SC Register bits
    namespace vrefh_sc_bits {
        constexpr uint32_t MODE_LV = (2 << 0);  ///< Buffer Mode selection
        constexpr uint32_t VREFST = (1U << 2);  ///< Internal Voltage Reference stable
        constexpr uint32_t ICOMPEN = (1U << 5);  ///< Second order curvature compensation enable
        constexpr uint32_t REGEN = (1U << 6);  ///< Regulator enable
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Voltage Reference enable
    }

    /// VREFL_TRM Register bits
    namespace vrefl_trm_bits {
        constexpr uint32_t VREFL_TRIM = (3 << 0);  ///< no description available
        constexpr uint32_t VREFL_EN = (1U << 3);  ///< no description available
        constexpr uint32_t VREFL_SEL = (1U << 4);  ///< no description available
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40072000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
    }

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x40072008;

    /// CMP1 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40075000;
    constexpr uint32_t SPI1_BASE = 0x40076000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t S;  ///< Offset: 0x00 - SPI Status Register
        volatile uint32_t BR;  ///< Offset: 0x01 - SPI Baud Rate Register
        volatile uint32_t C2;  ///< Offset: 0x02 - SPI Control Register 2
        volatile uint32_t C1;  ///< Offset: 0x03 - SPI Control Register 1
        volatile uint32_t ML;  ///< Offset: 0x04 - SPI Match Register low
        volatile uint32_t MH;  ///< Offset: 0x05 - SPI match register high
        volatile uint32_t DL;  ///< Offset: 0x06 - SPI Data Register low
        volatile uint32_t DH;  ///< Offset: 0x07 - SPI data register high
        volatile uint32_t CI;  ///< Offset: 0x0A - SPI clear interrupt register
        volatile uint32_t C3;  ///< Offset: 0x0B - SPI control register 3
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

    // Bit definitions
    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RFIFOEF = (1U << 0);  ///< SPI read FIFO empty flag
        constexpr uint32_t TXFULLF = (1U << 1);  ///< Transmit FIFO full flag
        constexpr uint32_t TNEAREF = (1U << 2);  ///< Transmit FIFO nearly empty flag
        constexpr uint32_t RNFULLF = (1U << 3);  ///< Receive FIFO nearly full flag
        constexpr uint32_t MODF = (1U << 4);  ///< Master Mode Fault Flag
        constexpr uint32_t SPTEF = (1U << 5);  ///< SPI Transmit Buffer Empty Flag (when FIFO is not supported or not enabled) or SPI transmit FIFO empty flag (when FIFO is supported and enabled)
        constexpr uint32_t SPMF = (1U << 6);  ///< SPI Match Flag
        constexpr uint32_t SPRF = (1U << 7);  ///< SPI Read Buffer Full Flag (when FIFO is not supported or not enabled) or SPI read FIFO FULL flag (when FIFO is supported and enabled)
    }

    /// BR Register bits
    namespace br_bits {
        constexpr uint32_t SPR = (4 << 0);  ///< SPI Baud Rate Divisor
        constexpr uint32_t SPPR = (3 << 4);  ///< SPI Baud Rate Prescale Divisor
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t SPC0 = (1U << 0);  ///< SPI Pin Control 0
        constexpr uint32_t SPISWAI = (1U << 1);  ///< SPI Stop in Wait Mode
        constexpr uint32_t RXDMAE = (1U << 2);  ///< Receive DMA enable
        constexpr uint32_t BIDIROE = (1U << 3);  ///< Bidirectional Mode Output Enable
        constexpr uint32_t MODFEN = (1U << 4);  ///< Master Mode-Fault Function Enable
        constexpr uint32_t TXDMAE = (1U << 5);  ///< Transmit DMA enable
        constexpr uint32_t SPIMODE = (1U << 6);  ///< SPI 8-bit or 16-bit mode
        constexpr uint32_t SPMIE = (1U << 7);  ///< SPI Match Interrupt Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t LSBFE = (1U << 0);  ///< LSB First (shifter direction)
        constexpr uint32_t SSOE = (1U << 1);  ///< Slave Select Output Enable
        constexpr uint32_t CPHA = (1U << 2);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 3);  ///< Clock Polarity
        constexpr uint32_t MSTR = (1U << 4);  ///< Master/Slave Mode Select
        constexpr uint32_t SPTIE = (1U << 5);  ///< SPI Transmit Interrupt Enable
        constexpr uint32_t SPE = (1U << 6);  ///< SPI System Enable
        constexpr uint32_t SPIE = (1U << 7);  ///< SPI Interrupt Enable: for SPRF and MODF (when FIFO is not supported or not enabled) or for read FIFO (when FIFO is supported and enabled)
    }

    /// ML Register bits
    namespace ml_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Hardware compare value (low byte)
    }

    /// MH Register bits
    namespace mh_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Hardware compare value (high byte)
    }

    /// DL Register bits
    namespace dl_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Data (low byte)
    }

    /// DH Register bits
    namespace dh_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Data (high byte)
    }

    /// CI Register bits
    namespace ci_bits {
        constexpr uint32_t SPRFCI = (1U << 0);  ///< Receive FIFO full flag clear interrupt
        constexpr uint32_t SPTEFCI = (1U << 1);  ///< Transmit FIFO empty flag clear interrupt
        constexpr uint32_t RNFULLFCI = (1U << 2);  ///< Receive FIFO nearly full flag clear interrupt
        constexpr uint32_t TNEAREFCI = (1U << 3);  ///< Transmit FIFO nearly empty flag clear interrupt
        constexpr uint32_t RXFOF = (1U << 4);  ///< Receive FIFO overflow flag
        constexpr uint32_t TXFOF = (1U << 5);  ///< Transmit FIFO overflow flag
        constexpr uint32_t RXFERR = (1U << 6);  ///< Receive FIFO error flag
        constexpr uint32_t TXFERR = (1U << 7);  ///< Transmit FIFO error flag
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t FIFOMODE = (1U << 0);  ///< FIFO mode enable
        constexpr uint32_t RNFULLIEN = (1U << 1);  ///< Receive FIFO nearly full interrupt enable
        constexpr uint32_t TNEARIEN = (1U << 2);  ///< Transmit FIFO nearly empty interrupt enable
        constexpr uint32_t INTCLR = (1U << 3);  ///< Interrupt clearing mechanism select
        constexpr uint32_t RNFULLF_MARK = (1U << 4);  ///< Receive FIFO nearly full watermark
        constexpr uint32_t TNEAREF_MARK = (1U << 5);  ///< Transmit FIFO nearly empty watermark
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007B000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t SRS0;  ///< Offset: 0x00 - System Reset Status Register 0
        volatile uint32_t SRS1;  ///< Offset: 0x01 - System Reset Status Register 1
        volatile uint32_t RPFC;  ///< Offset: 0x04 - Reset Pin Filter Control register
        volatile uint32_t RPFW;  ///< Offset: 0x05 - Reset Pin Filter Width register
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// SRS0 Register bits
    namespace srs0_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Low Leakage Wakeup Reset
        constexpr uint32_t LVD = (1U << 1);  ///< Low-Voltage Detect Reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-Clock Reset
        constexpr uint32_t LOL = (1U << 3);  ///< Loss-of-Lock Reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
    }

    /// SRS1 Register bits
    namespace srs1_bits {
        constexpr uint32_t LOCKUP = (1U << 1);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 2);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 3);  ///< MDM-AP System Reset Request
        constexpr uint32_t SACKERR = (1U << 5);  ///< Stop Mode Acknowledge Error Reset
    }

    /// RPFC Register bits
    namespace rpfc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset Pin Filter Select in Run and Wait Modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset Pin Filter Select in Stop Mode
    }

    /// RPFW Register bits
    namespace rpfw_bits {
        constexpr uint32_t RSTFLTSEL = (5 << 0);  ///< Reset Pin Filter Bus Clock Select
    }

}

// ============================================================================
// LLWU Peripheral
// ============================================================================

namespace llwu {
    /// Base addresses
    constexpr uint32_t LLWU_BASE = 0x4007C000;

    /// LLWU Register structure
    struct Registers {
        volatile uint32_t PE1;  ///< Offset: 0x00 - LLWU Pin Enable 1 register
        volatile uint32_t PE2;  ///< Offset: 0x01 - LLWU Pin Enable 2 register
        volatile uint32_t PE3;  ///< Offset: 0x02 - LLWU Pin Enable 3 register
        volatile uint32_t PE4;  ///< Offset: 0x03 - LLWU Pin Enable 4 register
        volatile uint32_t ME;  ///< Offset: 0x04 - LLWU Module Enable register
        volatile uint32_t F1;  ///< Offset: 0x05 - LLWU Flag 1 register
        volatile uint32_t F2;  ///< Offset: 0x06 - LLWU Flag 2 register
        volatile uint32_t F3;  ///< Offset: 0x07 - LLWU Flag 3 register
        volatile uint32_t FILT1;  ///< Offset: 0x08 - LLWU Pin Filter 1 register
        volatile uint32_t FILT2;  ///< Offset: 0x09 - LLWU Pin Filter 2 register
    };

    /// Peripheral instances
    inline Registers* LLWU = reinterpret_cast<Registers*>(LLWU_BASE);

    // Bit definitions
    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P3
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE4 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P7
    }

    /// PE3 Register bits
    namespace pe3_bits {
        constexpr uint32_t WUPE8 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P11
    }

    /// PE4 Register bits
    namespace pe4_bits {
        constexpr uint32_t WUPE12 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P15
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable For Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable For Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable For Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable For Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable For Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable For Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable For Module 7
    }

    /// F1 Register bits
    namespace f1_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag For LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag For LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag For LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag For LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag For LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag For LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag For LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag For LLWU_P7
    }

    /// F2 Register bits
    namespace f2_bits {
        constexpr uint32_t WUF8 = (1U << 0);  ///< Wakeup Flag For LLWU_P8
        constexpr uint32_t WUF9 = (1U << 1);  ///< Wakeup Flag For LLWU_P9
        constexpr uint32_t WUF10 = (1U << 2);  ///< Wakeup Flag For LLWU_P10
        constexpr uint32_t WUF11 = (1U << 3);  ///< Wakeup Flag For LLWU_P11
        constexpr uint32_t WUF12 = (1U << 4);  ///< Wakeup Flag For LLWU_P12
        constexpr uint32_t WUF13 = (1U << 5);  ///< Wakeup Flag For LLWU_P13
        constexpr uint32_t WUF14 = (1U << 6);  ///< Wakeup Flag For LLWU_P14
        constexpr uint32_t WUF15 = (1U << 7);  ///< Wakeup Flag For LLWU_P15
    }

    /// F3 Register bits
    namespace f3_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag For module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag For module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag For module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag For module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag For module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag For module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag For module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag For module 7
    }

    /// FILT1 Register bits
    namespace filt1_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT2 Register bits
    namespace filt2_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status And Control 1 register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status And Control 2 register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status And Control register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDV = (2 << 0);  ///< Low-Voltage Detect Voltage Select
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low-Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low-Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low-Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWV = (2 << 0);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t BGBDS = (1U << 1);  ///< Bandgap Buffer Drive Select
        constexpr uint32_t REGONS = (1U << 2);  ///< Regulator In Run Regulation Status
        constexpr uint32_t ACKISO = (1U << 3);  ///< Acknowledge Isolation
        constexpr uint32_t BGEN = (1U << 4);  ///< Bandgap Enable In VLPx Operation
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t PMPROT;  ///< Offset: 0x00 - Power Mode Protection register
        volatile uint32_t PMCTRL;  ///< Offset: 0x01 - Power Mode Control register
        volatile uint32_t STOPCTRL;  ///< Offset: 0x02 - Stop Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x03 - Power Mode Status register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLLS = (1U << 1);  ///< Allow Very-Low-Leakage Stop Mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very-Low-Power Modes
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
    }

    /// STOPCTRL Register bits
    namespace stopctrl_bits {
        constexpr uint32_t VLLSM = (3 << 0);  ///< VLLS Mode Control
        constexpr uint32_t PORPO = (1U << 5);  ///< POR Power Option
        constexpr uint32_t PSTOPO = (2 << 6);  ///< Partial Stop Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (7 << 0);  ///< Power Mode Status
    }

}

// ============================================================================
// MTB Peripheral
// ============================================================================

namespace mtb {
    /// Base addresses
    constexpr uint32_t MTB_BASE = 0xF0000000;

    /// MTB Register structure
    struct Registers {
        volatile uint32_t POSITION;  ///< Offset: 0x00 - MTB Position Register
        volatile uint32_t MASTER;  ///< Offset: 0x04 - MTB Master Register
        volatile uint32_t FLOW;  ///< Offset: 0x08 - MTB Flow Register
        volatile uint32_t BASE;  ///< Offset: 0x0C - MTB Base Register
        volatile uint32_t MODECTRL;  ///< Offset: 0xF00 - Integration Mode Control Register
        volatile uint32_t TAGSET;  ///< Offset: 0xFA0 - Claim TAG Set Register
        volatile uint32_t TAGCLEAR;  ///< Offset: 0xFA4 - Claim TAG Clear Register
        volatile uint32_t LOCKACCESS;  ///< Offset: 0xFB0 - Lock Access Register
        volatile uint32_t LOCKSTAT;  ///< Offset: 0xFB4 - Lock Status Register
        volatile uint32_t AUTHSTAT;  ///< Offset: 0xFB8 - Authentication Status Register
        volatile uint32_t DEVICEARCH;  ///< Offset: 0xFBC - Device Architecture Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID%s;  ///< Offset: 0xFD0 - Peripheral ID Register
        volatile uint32_t COMPID%s;  ///< Offset: 0xFF0 - Component ID Register
    };

    /// Peripheral instances
    inline Registers* MTB = reinterpret_cast<Registers*>(MTB_BASE);

    // Bit definitions
    /// POSITION Register bits
    namespace position_bits {
        constexpr uint32_t WRAP = (1U << 2);  ///< WRAP
        constexpr uint32_t POINTER = (29 << 3);  ///< Trace Packet Address Pointer[28:0]
    }

    /// MASTER Register bits
    namespace master_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< Mask
        constexpr uint32_t TSTARTEN = (1U << 5);  ///< Trace Start Input Enable
        constexpr uint32_t TSTOPEN = (1U << 6);  ///< Trace Stop Input Enable
        constexpr uint32_t SFRWPRIV = (1U << 7);  ///< Special Function Register Write Privilege
        constexpr uint32_t RAMPRIV = (1U << 8);  ///< RAM Privilege
        constexpr uint32_t HALTREQ = (1U << 9);  ///< Halt Request
        constexpr uint32_t EN = (1U << 31);  ///< Main Trace Enable
    }

    /// FLOW Register bits
    namespace flow_bits {
        constexpr uint32_t AUTOSTOP = (1U << 0);  ///< AUTOSTOP
        constexpr uint32_t AUTOHALT = (1U << 1);  ///< AUTOHALT
        constexpr uint32_t WATERMARK = (29 << 3);  ///< WATERMARK[28:0]
    }

    /// BASE Register bits
    namespace base_bits {
        constexpr uint32_t BASEADDR = (32 << 0);  ///< BASEADDR
    }

    /// MODECTRL Register bits
    namespace modectrl_bits {
        constexpr uint32_t MODECTRL = (32 << 0);  ///< MODECTRL
    }

    /// TAGSET Register bits
    namespace tagset_bits {
        constexpr uint32_t TAGSET = (32 << 0);  ///< TAGSET
    }

    /// TAGCLEAR Register bits
    namespace tagclear_bits {
        constexpr uint32_t TAGCLEAR = (32 << 0);  ///< TAGCLEAR
    }

    /// LOCKACCESS Register bits
    namespace lockaccess_bits {
        constexpr uint32_t LOCKACCESS = (32 << 0);  ///< no description available
    }

    /// LOCKSTAT Register bits
    namespace lockstat_bits {
        constexpr uint32_t LOCKSTAT = (32 << 0);  ///< LOCKSTAT
    }

    /// AUTHSTAT Register bits
    namespace authstat_bits {
        constexpr uint32_t BIT0 = (1U << 0);  ///< no description available
        constexpr uint32_t BIT1 = (1U << 1);  ///< BIT1
        constexpr uint32_t BIT2 = (1U << 2);  ///< BIT2
        constexpr uint32_t BIT3 = (1U << 3);  ///< BIT3
    }

    /// DEVICEARCH Register bits
    namespace devicearch_bits {
        constexpr uint32_t DEVICEARCH = (32 << 0);  ///< DEVICEARCH
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID%s Register bits
    namespace periphid%s_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID%s Register bits
    namespace compid%s_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MTBDWT Peripheral
// ============================================================================

namespace mtbdwt {
    /// Base addresses
    constexpr uint32_t MTBDWT_BASE = 0xF0001000;

    /// MTBDWT Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - MTB DWT Control Register
        volatile uint32_t COMP%s;  ///< Offset: 0x20 - MTB_DWT Comparator Register
        volatile uint32_t MASK%s;  ///< Offset: 0x24 - MTB_DWT Comparator Mask Register
        volatile uint32_t FCT0;  ///< Offset: 0x28 - MTB_DWT Comparator Function Register 0
        volatile uint32_t FCT1;  ///< Offset: 0x38 - MTB_DWT Comparator Function Register 1
        volatile uint32_t TBCTRL;  ///< Offset: 0x200 - MTB_DWT Trace Buffer Control Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID%s;  ///< Offset: 0xFD0 - Peripheral ID Register
        volatile uint32_t COMPID%s;  ///< Offset: 0xFF0 - Component ID Register
    };

    /// Peripheral instances
    inline Registers* MTBDWT = reinterpret_cast<Registers*>(MTBDWT_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t DWTCFGCTRL = (28 << 0);  ///< DWT configuration controls
        constexpr uint32_t NUMCMP = (4 << 28);  ///< Number of comparators
    }

    /// COMP%s Register bits
    namespace comp%s_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Reference value for comparison
    }

    /// MASK%s Register bits
    namespace mask%s_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< MASK
    }

    /// FCT0 Register bits
    namespace fct0_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< Data Value Match
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< Data Value Size
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< Data Value Address 0
        constexpr uint32_t MATCHED = (1U << 24);  ///< Comparator match
    }

    /// FCT1 Register bits
    namespace fct1_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function
        constexpr uint32_t MATCHED = (1U << 24);  ///< Comparator match
    }

    /// TBCTRL Register bits
    namespace tbctrl_bits {
        constexpr uint32_t ACOMP0 = (1U << 0);  ///< Action based on Comparator 0 match
        constexpr uint32_t ACOMP1 = (1U << 1);  ///< Action based on Comparator 1 match
        constexpr uint32_t NUMCOMP = (4 << 28);  ///< Number of Comparators
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID%s Register bits
    namespace periphid%s_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID%s Register bits
    namespace compid%s_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// ROM Peripheral
// ============================================================================

namespace rom {
    /// Base addresses
    constexpr uint32_t ROM_BASE = 0xF0002000;

    /// ROM Register structure
    struct Registers {
        volatile uint32_t ENTRY%s;  ///< Offset: 0x00 - Entry
        volatile uint32_t TABLEMARK;  ///< Offset: 0x0C - End of Table Marker Register
        volatile uint32_t SYSACCESS;  ///< Offset: 0xFCC - System Access Register
        volatile uint32_t PERIPHID%s;  ///< Offset: 0xFD0 - Peripheral ID Register
        volatile uint32_t COMPID%s;  ///< Offset: 0xFF0 - Component ID Register
    };

    /// Peripheral instances
    inline Registers* ROM = reinterpret_cast<Registers*>(ROM_BASE);

    // Bit definitions
    /// ENTRY%s Register bits
    namespace entry%s_bits {
        constexpr uint32_t ENTRY = (32 << 0);  ///< ENTRY
    }

    /// TABLEMARK Register bits
    namespace tablemark_bits {
        constexpr uint32_t MARK = (32 << 0);  ///< MARK
    }

    /// SYSACCESS Register bits
    namespace sysaccess_bits {
        constexpr uint32_t SYSACCESS = (32 << 0);  ///< SYSACCESS
    }

    /// PERIPHID%s Register bits
    namespace periphid%s_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID%s Register bits
    namespace compid%s_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xF0003000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t PLACR;  ///< Offset: 0x0C - Platform Control Register
        volatile uint32_t PID;  ///< Offset: 0x30 - Process ID register
        volatile uint32_t CPO;  ///< Offset: 0x40 - Compute Operation Control Register
        volatile uint32_t MATCR;  ///< Offset: 0x80 - Master Attribute Configuration Register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
    }

    /// PLACR Register bits
    namespace placr_bits {
        constexpr uint32_t ARB = (1U << 9);  ///< Arbitration select
        constexpr uint32_t CFCC = (1U << 10);  ///< Clear Flash Controller Cache
        constexpr uint32_t DFCDA = (1U << 11);  ///< Disable Flash Controller Data Caching
        constexpr uint32_t DFCIC = (1U << 12);  ///< Disable Flash Controller Instruction Caching
        constexpr uint32_t DFCC = (1U << 13);  ///< Disable Flash Controller Cache
        constexpr uint32_t EFDS = (1U << 14);  ///< Enable Flash Data Speculation
        constexpr uint32_t DFCS = (1U << 15);  ///< Disable Flash Controller Speculation
        constexpr uint32_t ESFC = (1U << 16);  ///< Enable Stalling Flash Controller
    }

    /// PID Register bits
    namespace pid_bits {
        constexpr uint32_t PID = (8 << 0);  ///< M0_PID For MPU
    }

    /// CPO Register bits
    namespace cpo_bits {
        constexpr uint32_t CPOREQ = (1U << 0);  ///< Compute Operation Request
        constexpr uint32_t CPOACK = (1U << 1);  ///< Compute Operation Acknowledge
        constexpr uint32_t CPOWOI = (1U << 2);  ///< Compute Operation Wake-up on Interrupt
    }

    /// MATCR Register bits
    namespace matcr_bits {
        constexpr uint32_t ATC0 = (3 << 0);  ///< Attribute Configuration Master n
        constexpr uint32_t RO0 = (1U << 7);  ///< Read-Only Master n
        constexpr uint32_t ATC2 = (3 << 16);  ///< Attribute Configuration Master n
        constexpr uint32_t RO2 = (1U << 23);  ///< Read-Only Master n
    }

}


} // namespace alloy::generated::mkm33za5

#endif // ALLOY_GENERATED_MKM33ZA5_PERIPHERALS_HPP