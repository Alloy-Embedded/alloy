/// Auto-generated code for MKV56F24
/// Generated by Alloy Code Generator
/// Source: nxp_mkv56.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:45
#ifndef ALLOY_GENERATED_MKV56F24_PERIPHERALS_HPP
#define ALLOY_GENERATED_MKV56F24_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mkv56f24 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_aips0 = true;
    constexpr uint32_t num_aips0_instances = 1;
    constexpr bool has_aips1 = true;
    constexpr uint32_t num_aips1_instances = 1;
    constexpr bool has_mscm = true;
    constexpr uint32_t num_mscm_instances = 1;
    constexpr bool has_axbs = true;
    constexpr uint32_t num_axbs_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_fb = true;
    constexpr uint32_t num_fb_instances = 1;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_ftfe = true;
    constexpr uint32_t num_ftfe_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 2;
    constexpr bool has_ftm0 = true;
    constexpr uint32_t num_ftm0_instances = 1;
    constexpr bool has_ftm1 = true;
    constexpr uint32_t num_ftm1_instances = 1;
    constexpr bool has_ftm2 = true;
    constexpr uint32_t num_ftm2_instances = 1;
    constexpr bool has_ftm3 = true;
    constexpr uint32_t num_ftm3_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_pdb0 = true;
    constexpr uint32_t num_pdb0_instances = 1;
    constexpr bool has_pdb1 = true;
    constexpr uint32_t num_pdb1_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 2;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 2;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 3;
    constexpr bool has_rfvbat = true;
    constexpr uint32_t num_rfvbat_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_rfsys = true;
    constexpr uint32_t num_rfsys_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 10;
    constexpr bool has_wdog = true;
    constexpr uint32_t num_wdog_instances = 1;
    constexpr bool has_enc = true;
    constexpr uint32_t num_enc_instances = 1;
    constexpr bool has_xbara = true;
    constexpr uint32_t num_xbara_instances = 1;
    constexpr bool has_xbarb = true;
    constexpr uint32_t num_xbarb_instances = 1;
    constexpr bool has_aoi0 = true;
    constexpr uint32_t num_aoi0_instances = 1;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_osc0 = true;
    constexpr uint32_t num_osc0_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 6;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_cmp2 = true;
    constexpr uint32_t num_cmp2_instances = 1;
    constexpr bool has_cmp3 = true;
    constexpr uint32_t num_cmp3_instances = 1;
    constexpr bool has_llwu = true;
    constexpr uint32_t num_llwu_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_systemcontrol = true;
    constexpr uint32_t num_systemcontrol_instances = 1;
    constexpr bool has_systick = true;
    constexpr uint32_t num_systick_instances = 1;
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 1;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;
    constexpr bool has_cau = true;
    constexpr uint32_t num_cau_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mscm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct axbs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct fb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftfe_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ftm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct pdb0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pdb1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct rfvbat_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 10;
    };
    template<>
    struct peripheral_count<struct wdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct enc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct xbara_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct xbarb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aoi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct llwu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systemcontrol_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systick_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cau_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 10;
    constexpr uint32_t max_gpio_pins = 160;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
    constexpr bool has_uart3 = true;
    constexpr bool has_uart4 = true;
    constexpr bool has_uart5 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFL_FlashConfig_BASE = 0x00000400;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
    };

    /// Peripheral instances
    inline Registers* FTFL_FlashConfig = reinterpret_cast<Registers*>(FTFL_FlashConfig_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT = (1U << 0);  ///< no description available
        constexpr uint32_t NMI_DIS = (1U << 2);  ///< no description available
        constexpr uint32_t FAST_INIT = (1U << 5);  ///< no description available
    }

}

// ============================================================================
// AIPS0 Peripheral
// ============================================================================

namespace aips0 {
    /// Base addresses
    constexpr uint32_t AIPS0_BASE = 0x40000000;

    /// AIPS0 Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS0 = reinterpret_cast<Registers*>(AIPS0_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t MPL3 = (1U << 16);  ///< Master 3 Privilege Level
        constexpr uint32_t MTW3 = (1U << 17);  ///< Master 3 Trusted For Writes
        constexpr uint32_t MTR3 = (1U << 18);  ///< Master 3 Trusted For Read
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master 2 Privilege Level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master 2 Trusted For Writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master 2 Trusted For Read
        constexpr uint32_t MPL1 = (1U << 24);  ///< Master 1 Privilege Level
        constexpr uint32_t MTW1 = (1U << 25);  ///< Master 1 Trusted for Writes
        constexpr uint32_t MTR1 = (1U << 26);  ///< Master 1 Trusted for Read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master 0 Privilege Level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master 0 Trusted For Writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master 0 Trusted For Read
    }

    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

}

// ============================================================================
// AIPS1 Peripheral
// ============================================================================

namespace aips1 {
    /// Base addresses
    constexpr uint32_t AIPS1_BASE = 0x40080000;

    /// AIPS1 Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS1 = reinterpret_cast<Registers*>(AIPS1_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t MPL3 = (1U << 16);  ///< Master 3 Privilege Level
        constexpr uint32_t MTW3 = (1U << 17);  ///< Master 3 Trusted For Writes
        constexpr uint32_t MTR3 = (1U << 18);  ///< Master 3 Trusted For Read
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master 2 Privilege Level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master 2 Trusted For Writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master 2 Trusted For Read
        constexpr uint32_t MPL1 = (1U << 24);  ///< Master 1 Privilege Level
        constexpr uint32_t MTW1 = (1U << 25);  ///< Master 1 Trusted for Writes
        constexpr uint32_t MTR1 = (1U << 26);  ///< Master 1 Trusted for Read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master 0 Privilege Level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master 0 Trusted For Writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master 0 Trusted For Read
    }

    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

}

// ============================================================================
// MSCM Peripheral
// ============================================================================

namespace mscm {
    /// Base addresses
    constexpr uint32_t MSCM_BASE = 0x40001000;

    /// MSCM Register structure
    struct Registers {
        volatile uint32_t CPxTYPE;  ///< Offset: 0x00 - Processor X Type Register
        volatile uint32_t CPxNUM;  ///< Offset: 0x04 - Processor X Number Register
        volatile uint32_t CPxMASTER;  ///< Offset: 0x08 - Processor X Master Register
        volatile uint32_t CPxCOUNT;  ///< Offset: 0x0C - Processor X Count Register
        volatile uint32_t CPxCFG1;  ///< Offset: 0x14 - Processor X Configuration 1 Register
        volatile uint32_t CPxCFG3;  ///< Offset: 0x1C - Processor X Configuration 3 Register
        volatile uint32_t CP0TYPE;  ///< Offset: 0x20 - Processor 0 Type Register
        volatile uint32_t CP0NUM;  ///< Offset: 0x24 - Processor 0 Number Register
        volatile uint32_t CP0MASTER;  ///< Offset: 0x28 - Processor 0 Master Register
        volatile uint32_t CP0COUNT;  ///< Offset: 0x2C - Processor 0 Count Register
        volatile uint32_t CP0CFG1;  ///< Offset: 0x34 - Processor 0 Configuration 1 Register
        volatile uint32_t CP0CFG3;  ///< Offset: 0x3C - Processor 0 Configuration 3 Register
        volatile uint32_t CP1TYPE;  ///< Offset: 0x40 - Processor 1 Type Register
        volatile uint32_t CP1NUM;  ///< Offset: 0x44 - Processor 1 Number Register
        volatile uint32_t CP1MASTER;  ///< Offset: 0x48 - Processor 1 Master Register
        volatile uint32_t CP1COUNT;  ///< Offset: 0x4C - Processor 1 Count Register
        volatile uint32_t CP1CFG1;  ///< Offset: 0x54 - Processor 1 Configuration 1 Register
        volatile uint32_t CP1CFG3;  ///< Offset: 0x5C - Processor 1 Configuration 3 Register
        volatile uint32_t OCMDR%s;  ///< Offset: 0x400 - On-Chip Memory Descriptor Register
    };

    /// Peripheral instances
    inline Registers* MSCM = reinterpret_cast<Registers*>(MSCM_BASE);

    // Bit definitions
    /// CPxTYPE Register bits
    namespace cpxtype_bits {
        constexpr uint32_t RYPZ = (8 << 0);  ///< Processor x Revision
        constexpr uint32_t PERSONALITY = (24 << 8);  ///< Processor x Personality
    }

    /// CPxNUM Register bits
    namespace cpxnum_bits {
        constexpr uint32_t CPN = (1U << 0);  ///< Processor x Number
    }

    /// CPxMASTER Register bits
    namespace cpxmaster_bits {
        constexpr uint32_t PPN = (6 << 0);  ///< Processor x Physical Port Number
    }

    /// CPxCOUNT Register bits
    namespace cpxcount_bits {
        constexpr uint32_t PCNT = (2 << 0);  ///< Processor Count
    }

    /// CPxCFG1 Register bits
    namespace cpxcfg1_bits {
        constexpr uint32_t L2WY = (8 << 16);  ///< Level 2 Cache Ways
        constexpr uint32_t L2SZ = (8 << 24);  ///< Level 2 Cache Size
    }

    /// CPxCFG3 Register bits
    namespace cpxcfg3_bits {
        constexpr uint32_t FPU = (1U << 0);  ///< Floating Point Unit
        constexpr uint32_t SIMD = (1U << 1);  ///< SIMD/NEON Instruction Support
        constexpr uint32_t JAZ = (1U << 2);  ///< Jazelle
        constexpr uint32_t MMU = (1U << 3);  ///< Memory Management Unit
        constexpr uint32_t TZ = (1U << 4);  ///< Trust Zone
        constexpr uint32_t CMP = (1U << 5);  ///< Core Memory Protection unit
        constexpr uint32_t BB = (1U << 6);  ///< Bit Banding
        constexpr uint32_t SBP = (2 << 8);  ///< System Bus Ports
    }

    /// CP0TYPE Register bits
    namespace cp0type_bits {
        constexpr uint32_t RYPZ = (8 << 0);  ///< Processor 0 Revision
        constexpr uint32_t PERSONALITY = (24 << 8);  ///< Processor 0 Personality
    }

    /// CP0NUM Register bits
    namespace cp0num_bits {
        constexpr uint32_t CPN = (1U << 0);  ///< Processor 0 Number
    }

    /// CP0MASTER Register bits
    namespace cp0master_bits {
        constexpr uint32_t PPN = (6 << 0);  ///< Processor 0 Physical Port Number
    }

    /// CP0COUNT Register bits
    namespace cp0count_bits {
        constexpr uint32_t PCNT = (2 << 0);  ///< Processor Count
    }

    /// CP0CFG1 Register bits
    namespace cp0cfg1_bits {
        constexpr uint32_t L2WY = (8 << 16);  ///< Level 2 Cache Ways
        constexpr uint32_t L2SZ = (8 << 24);  ///< Level 2 Cache Size
    }

    /// CP0CFG3 Register bits
    namespace cp0cfg3_bits {
        constexpr uint32_t FPU = (1U << 0);  ///< Floating Point Unit
        constexpr uint32_t SIMD = (1U << 1);  ///< SIMD/NEON Instruction Support
        constexpr uint32_t JAZ = (1U << 2);  ///< Jazelle
        constexpr uint32_t MMU = (1U << 3);  ///< Memory Management Unit
        constexpr uint32_t TZ = (1U << 4);  ///< Trust Zone
        constexpr uint32_t CMP = (1U << 5);  ///< Core Memory Protection unit
        constexpr uint32_t BB = (1U << 6);  ///< Bit Banding
        constexpr uint32_t SBP = (2 << 8);  ///< System Bus Ports
    }

    /// CP1TYPE Register bits
    namespace cp1type_bits {
        constexpr uint32_t RYPZ = (8 << 0);  ///< Processor 1 Revision
        constexpr uint32_t PERSONALITY = (24 << 8);  ///< Processor 1 Personality
    }

    /// CP1NUM Register bits
    namespace cp1num_bits {
        constexpr uint32_t CPN = (1U << 0);  ///< Processor 1 Number
    }

    /// CP1MASTER Register bits
    namespace cp1master_bits {
        constexpr uint32_t PPN = (6 << 0);  ///< Processor 1 Physical Port Number
    }

    /// CP1COUNT Register bits
    namespace cp1count_bits {
        constexpr uint32_t PCNT = (2 << 0);  ///< Processor Count
    }

    /// CP1CFG1 Register bits
    namespace cp1cfg1_bits {
        constexpr uint32_t L2WY = (8 << 16);  ///< Level 2 Cache Ways
        constexpr uint32_t L2SZ = (8 << 24);  ///< Level 2 Cache Size
    }

    /// CP1CFG3 Register bits
    namespace cp1cfg3_bits {
        constexpr uint32_t FPU = (1U << 0);  ///< Floating Point Unit
        constexpr uint32_t SIMD = (1U << 1);  ///< SIMD/NEON Instruction Support
        constexpr uint32_t JAZ = (1U << 2);  ///< Jazelle
        constexpr uint32_t MMU = (1U << 3);  ///< Memory Management Unit
        constexpr uint32_t TZ = (1U << 4);  ///< Trust Zone
        constexpr uint32_t CMP = (1U << 5);  ///< Core Memory Protection unit
        constexpr uint32_t BB = (1U << 6);  ///< Bit Banding
        constexpr uint32_t SBP = (2 << 8);  ///< System Bus Ports
    }

    /// OCMDR%s Register bits
    namespace ocmdr%s_bits {
        constexpr uint32_t OCMPU = (1U << 12);  ///< OCMEM Memory Protection Unit
        constexpr uint32_t OCMT = (3 << 13);  ///< OCMEM Type. This field defines the type of the on-chip memory:
        constexpr uint32_t OCMW = (3 << 17);  ///< OCMEM Datapath Width
        constexpr uint32_t OCMSZ = (4 << 24);  ///< OCMEM Size
        constexpr uint32_t OCMSZH = (1U << 28);  ///< OCMEM Size "Hole"
        constexpr uint32_t FMT = (1U << 30);  ///< Format
        constexpr uint32_t V = (1U << 31);  ///< OCMEM Valid Bit
    }

}

// ============================================================================
// AXBS Peripheral
// ============================================================================

namespace axbs {
    /// Base addresses
    constexpr uint32_t AXBS_BASE = 0x40004000;

    /// AXBS Register structure
    struct Registers {
        volatile uint32_t PRS%s;  ///< Offset: 0x00 - Priority Registers Slave
        volatile uint32_t CRS%s;  ///< Offset: 0x10 - Control Register
        volatile uint32_t MGPCR%s;  ///< Offset: 0x800 - Master General Purpose Control Register
    };

    /// Peripheral instances
    inline Registers* AXBS = reinterpret_cast<Registers*>(AXBS_BASE);

    // Bit definitions
    /// PRS%s Register bits
    namespace prs%s_bits {
        constexpr uint32_t M0 = (3 << 0);  ///< Master 0 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M1 = (3 << 4);  ///< Master 1 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M2 = (3 << 8);  ///< Master 2 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M3 = (3 << 12);  ///< Master 3 Priority. Sets the arbitration priority for this port on the associated slave port.
    }

    /// CRS%s Register bits
    namespace crs%s_bits {
        constexpr uint32_t PARK = (3 << 0);  ///< Park
        constexpr uint32_t PCTL = (2 << 4);  ///< Parking Control
        constexpr uint32_t ARB = (2 << 8);  ///< Arbitration Mode
        constexpr uint32_t HLP = (1U << 30);  ///< Halt Low Priority
        constexpr uint32_t RO = (1U << 31);  ///< Read Only
    }

    /// MGPCR%s Register bits
    namespace mgpcr%s_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates On Undefined Length Bursts
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX_BASE = 0x40021000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT;  ///< Offset: 0x24 - Interrupt Request Register
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t EARS;  ///< Offset: 0x44 - Enable Asynchronous Request in Stop Register
        volatile uint32_t DCHPRI%s;  ///< Offset: 0x100 - Channel n Priority Register
        volatile uint32_t TCD%s_SADDR;  ///< Offset: 0x1000 - TCD Source Address
        volatile uint32_t TCD%s_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset
        volatile uint32_t TCD%s_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes
        volatile uint32_t TCD%s_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD%s_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD%s_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD%s_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment
        volatile uint32_t TCD%s_DADDR;  ///< Offset: 0x1010 - TCD Destination Address
        volatile uint32_t TCD%s_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset
        volatile uint32_t TCD%s_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD%s_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD%s_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD%s_CSR;  ///< Offset: 0x101C - TCD Control and Status
        volatile uint32_t TCD%s_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD%s_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t ERGA = (1U << 3);  ///< Enable Round Robin Group Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t GRP0PRI = (1U << 8);  ///< Channel Group 0 Priority
        constexpr uint32_t GRP1PRI = (1U << 10);  ///< Channel Group 1 Priority
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (5 << 8);  ///< Error Channel Number or Canceled Channel Number
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t GPE = (1U << 15);  ///< Group Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Canceled
        constexpr uint32_t VLD = (1U << 31);  ///< Logical OR of all ERR status bits
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
        constexpr uint32_t ERQ4 = (1U << 4);  ///< Enable DMA Request 4
        constexpr uint32_t ERQ5 = (1U << 5);  ///< Enable DMA Request 5
        constexpr uint32_t ERQ6 = (1U << 6);  ///< Enable DMA Request 6
        constexpr uint32_t ERQ7 = (1U << 7);  ///< Enable DMA Request 7
        constexpr uint32_t ERQ8 = (1U << 8);  ///< Enable DMA Request 8
        constexpr uint32_t ERQ9 = (1U << 9);  ///< Enable DMA Request 9
        constexpr uint32_t ERQ10 = (1U << 10);  ///< Enable DMA Request 10
        constexpr uint32_t ERQ11 = (1U << 11);  ///< Enable DMA Request 11
        constexpr uint32_t ERQ12 = (1U << 12);  ///< Enable DMA Request 12
        constexpr uint32_t ERQ13 = (1U << 13);  ///< Enable DMA Request 13
        constexpr uint32_t ERQ14 = (1U << 14);  ///< Enable DMA Request 14
        constexpr uint32_t ERQ15 = (1U << 15);  ///< Enable DMA Request 15
        constexpr uint32_t ERQ16 = (1U << 16);  ///< Enable DMA Request 16
        constexpr uint32_t ERQ17 = (1U << 17);  ///< Enable DMA Request 17
        constexpr uint32_t ERQ18 = (1U << 18);  ///< Enable DMA Request 18
        constexpr uint32_t ERQ19 = (1U << 19);  ///< Enable DMA Request 19
        constexpr uint32_t ERQ20 = (1U << 20);  ///< Enable DMA Request 20
        constexpr uint32_t ERQ21 = (1U << 21);  ///< Enable DMA Request 21
        constexpr uint32_t ERQ22 = (1U << 22);  ///< Enable DMA Request 22
        constexpr uint32_t ERQ23 = (1U << 23);  ///< Enable DMA Request 23
        constexpr uint32_t ERQ24 = (1U << 24);  ///< Enable DMA Request 24
        constexpr uint32_t ERQ25 = (1U << 25);  ///< Enable DMA Request 25
        constexpr uint32_t ERQ26 = (1U << 26);  ///< Enable DMA Request 26
        constexpr uint32_t ERQ27 = (1U << 27);  ///< Enable DMA Request 27
        constexpr uint32_t ERQ28 = (1U << 28);  ///< Enable DMA Request 28
        constexpr uint32_t ERQ29 = (1U << 29);  ///< Enable DMA Request 29
        constexpr uint32_t ERQ30 = (1U << 30);  ///< Enable DMA Request 30
        constexpr uint32_t ERQ31 = (1U << 31);  ///< Enable DMA Request 31
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
        constexpr uint32_t EEI4 = (1U << 4);  ///< Enable Error Interrupt 4
        constexpr uint32_t EEI5 = (1U << 5);  ///< Enable Error Interrupt 5
        constexpr uint32_t EEI6 = (1U << 6);  ///< Enable Error Interrupt 6
        constexpr uint32_t EEI7 = (1U << 7);  ///< Enable Error Interrupt 7
        constexpr uint32_t EEI8 = (1U << 8);  ///< Enable Error Interrupt 8
        constexpr uint32_t EEI9 = (1U << 9);  ///< Enable Error Interrupt 9
        constexpr uint32_t EEI10 = (1U << 10);  ///< Enable Error Interrupt 10
        constexpr uint32_t EEI11 = (1U << 11);  ///< Enable Error Interrupt 11
        constexpr uint32_t EEI12 = (1U << 12);  ///< Enable Error Interrupt 12
        constexpr uint32_t EEI13 = (1U << 13);  ///< Enable Error Interrupt 13
        constexpr uint32_t EEI14 = (1U << 14);  ///< Enable Error Interrupt 14
        constexpr uint32_t EEI15 = (1U << 15);  ///< Enable Error Interrupt 15
        constexpr uint32_t EEI16 = (1U << 16);  ///< Enable Error Interrupt 16
        constexpr uint32_t EEI17 = (1U << 17);  ///< Enable Error Interrupt 17
        constexpr uint32_t EEI18 = (1U << 18);  ///< Enable Error Interrupt 18
        constexpr uint32_t EEI19 = (1U << 19);  ///< Enable Error Interrupt 19
        constexpr uint32_t EEI20 = (1U << 20);  ///< Enable Error Interrupt 20
        constexpr uint32_t EEI21 = (1U << 21);  ///< Enable Error Interrupt 21
        constexpr uint32_t EEI22 = (1U << 22);  ///< Enable Error Interrupt 22
        constexpr uint32_t EEI23 = (1U << 23);  ///< Enable Error Interrupt 23
        constexpr uint32_t EEI24 = (1U << 24);  ///< Enable Error Interrupt 24
        constexpr uint32_t EEI25 = (1U << 25);  ///< Enable Error Interrupt 25
        constexpr uint32_t EEI26 = (1U << 26);  ///< Enable Error Interrupt 26
        constexpr uint32_t EEI27 = (1U << 27);  ///< Enable Error Interrupt 27
        constexpr uint32_t EEI28 = (1U << 28);  ///< Enable Error Interrupt 28
        constexpr uint32_t EEI29 = (1U << 29);  ///< Enable Error Interrupt 29
        constexpr uint32_t EEI30 = (1U << 30);  ///< Enable Error Interrupt 30
        constexpr uint32_t EEI31 = (1U << 31);  ///< Enable Error Interrupt 31
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (5 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (5 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (5 << 0);  ///< Clear Enable Request
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (5 << 0);  ///< Set Enable Request
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (5 << 0);  ///< Clear DONE Bit
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (5 << 0);  ///< Set START Bit
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (5 << 0);  ///< Clear Error Indicator
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (5 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// INT Register bits
    namespace int_bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
        constexpr uint32_t INT4 = (1U << 4);  ///< Interrupt Request 4
        constexpr uint32_t INT5 = (1U << 5);  ///< Interrupt Request 5
        constexpr uint32_t INT6 = (1U << 6);  ///< Interrupt Request 6
        constexpr uint32_t INT7 = (1U << 7);  ///< Interrupt Request 7
        constexpr uint32_t INT8 = (1U << 8);  ///< Interrupt Request 8
        constexpr uint32_t INT9 = (1U << 9);  ///< Interrupt Request 9
        constexpr uint32_t INT10 = (1U << 10);  ///< Interrupt Request 10
        constexpr uint32_t INT11 = (1U << 11);  ///< Interrupt Request 11
        constexpr uint32_t INT12 = (1U << 12);  ///< Interrupt Request 12
        constexpr uint32_t INT13 = (1U << 13);  ///< Interrupt Request 13
        constexpr uint32_t INT14 = (1U << 14);  ///< Interrupt Request 14
        constexpr uint32_t INT15 = (1U << 15);  ///< Interrupt Request 15
        constexpr uint32_t INT16 = (1U << 16);  ///< Interrupt Request 16
        constexpr uint32_t INT17 = (1U << 17);  ///< Interrupt Request 17
        constexpr uint32_t INT18 = (1U << 18);  ///< Interrupt Request 18
        constexpr uint32_t INT19 = (1U << 19);  ///< Interrupt Request 19
        constexpr uint32_t INT20 = (1U << 20);  ///< Interrupt Request 20
        constexpr uint32_t INT21 = (1U << 21);  ///< Interrupt Request 21
        constexpr uint32_t INT22 = (1U << 22);  ///< Interrupt Request 22
        constexpr uint32_t INT23 = (1U << 23);  ///< Interrupt Request 23
        constexpr uint32_t INT24 = (1U << 24);  ///< Interrupt Request 24
        constexpr uint32_t INT25 = (1U << 25);  ///< Interrupt Request 25
        constexpr uint32_t INT26 = (1U << 26);  ///< Interrupt Request 26
        constexpr uint32_t INT27 = (1U << 27);  ///< Interrupt Request 27
        constexpr uint32_t INT28 = (1U << 28);  ///< Interrupt Request 28
        constexpr uint32_t INT29 = (1U << 29);  ///< Interrupt Request 29
        constexpr uint32_t INT30 = (1U << 30);  ///< Interrupt Request 30
        constexpr uint32_t INT31 = (1U << 31);  ///< Interrupt Request 31
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
        constexpr uint32_t ERR4 = (1U << 4);  ///< Error In Channel 4
        constexpr uint32_t ERR5 = (1U << 5);  ///< Error In Channel 5
        constexpr uint32_t ERR6 = (1U << 6);  ///< Error In Channel 6
        constexpr uint32_t ERR7 = (1U << 7);  ///< Error In Channel 7
        constexpr uint32_t ERR8 = (1U << 8);  ///< Error In Channel 8
        constexpr uint32_t ERR9 = (1U << 9);  ///< Error In Channel 9
        constexpr uint32_t ERR10 = (1U << 10);  ///< Error In Channel 10
        constexpr uint32_t ERR11 = (1U << 11);  ///< Error In Channel 11
        constexpr uint32_t ERR12 = (1U << 12);  ///< Error In Channel 12
        constexpr uint32_t ERR13 = (1U << 13);  ///< Error In Channel 13
        constexpr uint32_t ERR14 = (1U << 14);  ///< Error In Channel 14
        constexpr uint32_t ERR15 = (1U << 15);  ///< Error In Channel 15
        constexpr uint32_t ERR16 = (1U << 16);  ///< Error In Channel 16
        constexpr uint32_t ERR17 = (1U << 17);  ///< Error In Channel 17
        constexpr uint32_t ERR18 = (1U << 18);  ///< Error In Channel 18
        constexpr uint32_t ERR19 = (1U << 19);  ///< Error In Channel 19
        constexpr uint32_t ERR20 = (1U << 20);  ///< Error In Channel 20
        constexpr uint32_t ERR21 = (1U << 21);  ///< Error In Channel 21
        constexpr uint32_t ERR22 = (1U << 22);  ///< Error In Channel 22
        constexpr uint32_t ERR23 = (1U << 23);  ///< Error In Channel 23
        constexpr uint32_t ERR24 = (1U << 24);  ///< Error In Channel 24
        constexpr uint32_t ERR25 = (1U << 25);  ///< Error In Channel 25
        constexpr uint32_t ERR26 = (1U << 26);  ///< Error In Channel 26
        constexpr uint32_t ERR27 = (1U << 27);  ///< Error In Channel 27
        constexpr uint32_t ERR28 = (1U << 28);  ///< Error In Channel 28
        constexpr uint32_t ERR29 = (1U << 29);  ///< Error In Channel 29
        constexpr uint32_t ERR30 = (1U << 30);  ///< Error In Channel 30
        constexpr uint32_t ERR31 = (1U << 31);  ///< Error In Channel 31
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
        constexpr uint32_t HRS4 = (1U << 4);  ///< Hardware Request Status Channel 4
        constexpr uint32_t HRS5 = (1U << 5);  ///< Hardware Request Status Channel 5
        constexpr uint32_t HRS6 = (1U << 6);  ///< Hardware Request Status Channel 6
        constexpr uint32_t HRS7 = (1U << 7);  ///< Hardware Request Status Channel 7
        constexpr uint32_t HRS8 = (1U << 8);  ///< Hardware Request Status Channel 8
        constexpr uint32_t HRS9 = (1U << 9);  ///< Hardware Request Status Channel 9
        constexpr uint32_t HRS10 = (1U << 10);  ///< Hardware Request Status Channel 10
        constexpr uint32_t HRS11 = (1U << 11);  ///< Hardware Request Status Channel 11
        constexpr uint32_t HRS12 = (1U << 12);  ///< Hardware Request Status Channel 12
        constexpr uint32_t HRS13 = (1U << 13);  ///< Hardware Request Status Channel 13
        constexpr uint32_t HRS14 = (1U << 14);  ///< Hardware Request Status Channel 14
        constexpr uint32_t HRS15 = (1U << 15);  ///< Hardware Request Status Channel 15
        constexpr uint32_t HRS16 = (1U << 16);  ///< Hardware Request Status Channel 16
        constexpr uint32_t HRS17 = (1U << 17);  ///< Hardware Request Status Channel 17
        constexpr uint32_t HRS18 = (1U << 18);  ///< Hardware Request Status Channel 18
        constexpr uint32_t HRS19 = (1U << 19);  ///< Hardware Request Status Channel 19
        constexpr uint32_t HRS20 = (1U << 20);  ///< Hardware Request Status Channel 20
        constexpr uint32_t HRS21 = (1U << 21);  ///< Hardware Request Status Channel 21
        constexpr uint32_t HRS22 = (1U << 22);  ///< Hardware Request Status Channel 22
        constexpr uint32_t HRS23 = (1U << 23);  ///< Hardware Request Status Channel 23
        constexpr uint32_t HRS24 = (1U << 24);  ///< Hardware Request Status Channel 24
        constexpr uint32_t HRS25 = (1U << 25);  ///< Hardware Request Status Channel 25
        constexpr uint32_t HRS26 = (1U << 26);  ///< Hardware Request Status Channel 26
        constexpr uint32_t HRS27 = (1U << 27);  ///< Hardware Request Status Channel 27
        constexpr uint32_t HRS28 = (1U << 28);  ///< Hardware Request Status Channel 28
        constexpr uint32_t HRS29 = (1U << 29);  ///< Hardware Request Status Channel 29
        constexpr uint32_t HRS30 = (1U << 30);  ///< Hardware Request Status Channel 30
        constexpr uint32_t HRS31 = (1U << 31);  ///< Hardware Request Status Channel 31
    }

    /// EARS Register bits
    namespace ears_bits {
        constexpr uint32_t EDREQ_0 = (1U << 0);  ///< Enable asynchronous DMA request in stop mode for channel 0.
        constexpr uint32_t EDREQ_1 = (1U << 1);  ///< Enable asynchronous DMA request in stop mode for channel 1.
        constexpr uint32_t EDREQ_2 = (1U << 2);  ///< Enable asynchronous DMA request in stop mode for channel 2.
        constexpr uint32_t EDREQ_3 = (1U << 3);  ///< Enable asynchronous DMA request in stop mode for channel 3.
        constexpr uint32_t EDREQ_4 = (1U << 4);  ///< Enable asynchronous DMA request in stop mode for channel 4
        constexpr uint32_t EDREQ_5 = (1U << 5);  ///< Enable asynchronous DMA request in stop mode for channel 5
        constexpr uint32_t EDREQ_6 = (1U << 6);  ///< Enable asynchronous DMA request in stop mode for channel 6
        constexpr uint32_t EDREQ_7 = (1U << 7);  ///< Enable asynchronous DMA request in stop mode for channel 7
        constexpr uint32_t EDREQ_8 = (1U << 8);  ///< Enable asynchronous DMA request in stop mode for channel 8
        constexpr uint32_t EDREQ_9 = (1U << 9);  ///< Enable asynchronous DMA request in stop mode for channel 9
        constexpr uint32_t EDREQ_10 = (1U << 10);  ///< Enable asynchronous DMA request in stop mode for channel 10
        constexpr uint32_t EDREQ_11 = (1U << 11);  ///< Enable asynchronous DMA request in stop mode for channel 11
        constexpr uint32_t EDREQ_12 = (1U << 12);  ///< Enable asynchronous DMA request in stop mode for channel 12
        constexpr uint32_t EDREQ_13 = (1U << 13);  ///< Enable asynchronous DMA request in stop mode for channel 13
        constexpr uint32_t EDREQ_14 = (1U << 14);  ///< Enable asynchronous DMA request in stop mode for channel 14
        constexpr uint32_t EDREQ_15 = (1U << 15);  ///< Enable asynchronous DMA request in stop mode for channel 15
        constexpr uint32_t EDREQ_16 = (1U << 16);  ///< Enable asynchronous DMA request in stop mode for channel 16
        constexpr uint32_t EDREQ_17 = (1U << 17);  ///< Enable asynchronous DMA request in stop mode for channel 17
        constexpr uint32_t EDREQ_18 = (1U << 18);  ///< Enable asynchronous DMA request in stop mode for channel 18
        constexpr uint32_t EDREQ_19 = (1U << 19);  ///< Enable asynchronous DMA request in stop mode for channel 19
        constexpr uint32_t EDREQ_20 = (1U << 20);  ///< Enable asynchronous DMA request in stop mode for channel 20
        constexpr uint32_t EDREQ_21 = (1U << 21);  ///< Enable asynchronous DMA request in stop mode for channel 21
        constexpr uint32_t EDREQ_22 = (1U << 22);  ///< Enable asynchronous DMA request in stop mode for channel 22
        constexpr uint32_t EDREQ_23 = (1U << 23);  ///< Enable asynchronous DMA request in stop mode for channel 23
        constexpr uint32_t EDREQ_24 = (1U << 24);  ///< Enable asynchronous DMA request in stop mode for channel 24
        constexpr uint32_t EDREQ_25 = (1U << 25);  ///< Enable asynchronous DMA request in stop mode for channel 25
        constexpr uint32_t EDREQ_26 = (1U << 26);  ///< Enable asynchronous DMA request in stop mode for channel 26
        constexpr uint32_t EDREQ_27 = (1U << 27);  ///< Enable asynchronous DMA request in stop mode for channel 27
        constexpr uint32_t EDREQ_28 = (1U << 28);  ///< Enable asynchronous DMA request in stop mode for channel 28
        constexpr uint32_t EDREQ_29 = (1U << 29);  ///< Enable asynchronous DMA request in stop mode for channel 29
        constexpr uint32_t EDREQ_30 = (1U << 30);  ///< Enable asynchronous DMA request in stop mode for channel 30
        constexpr uint32_t EDREQ_31 = (1U << 31);  ///< Enable asynchronous DMA request in stop mode for channel 31
    }

    /// DCHPRI%s Register bits
    namespace dchpri%s_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption.
    }

    /// TCD%s_SADDR Register bits
    namespace tcd%s_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD%s_SOFF Register bits
    namespace tcd%s_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD%s_ATTR Register bits
    namespace tcd%s_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD%s_NBYTES_MLNO Register bits
    namespace tcd%s_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD%s_NBYTES_MLOFFNO Register bits
    namespace tcd%s_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD%s_NBYTES_MLOFFYES Register bits
    namespace tcd%s_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD%s_SLAST Register bits
    namespace tcd%s_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD%s_DADDR Register bits
    namespace tcd%s_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD%s_DOFF Register bits
    namespace tcd%s_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD%s_CITER_ELINKNO Register bits
    namespace tcd%s_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD%s_CITER_ELINKYES Register bits
    namespace tcd%s_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD%s_DLASTSGA Register bits
    namespace tcd%s_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather)
    }

    /// TCD%s_CSR Register bits
    namespace tcd%s_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD%s_BITER_ELINKNO Register bits
    namespace tcd%s_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD%s_BITER_ELINKYES Register bits
    namespace tcd%s_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// FB Peripheral
// ============================================================================

namespace fb {
    /// Base addresses
    constexpr uint32_t FB_BASE = 0x4000C000;

    /// FB Register structure
    struct Registers {
        volatile uint32_t CSAR%s;  ///< Offset: 0x00 - Chip Select Address Register
        volatile uint32_t CSMR%s;  ///< Offset: 0x04 - Chip Select Mask Register
        volatile uint32_t CSCR%s;  ///< Offset: 0x08 - Chip Select Control Register
        volatile uint32_t CSPMCR;  ///< Offset: 0x60 - Chip Select port Multiplexing Control Register
    };

    /// Peripheral instances
    inline Registers* FB = reinterpret_cast<Registers*>(FB_BASE);

    // Bit definitions
    /// CSAR%s Register bits
    namespace csar%s_bits {
        constexpr uint32_t BA = (16 << 16);  ///< Base Address
    }

    /// CSMR%s Register bits
    namespace csmr%s_bits {
        constexpr uint32_t V = (1U << 0);  ///< Valid
        constexpr uint32_t WP = (1U << 8);  ///< Write Protect
        constexpr uint32_t BAM = (16 << 16);  ///< Base Address Mask
    }

    /// CSCR%s Register bits
    namespace cscr%s_bits {
        constexpr uint32_t BSTW = (1U << 3);  ///< Burst-Write Enable
        constexpr uint32_t BSTR = (1U << 4);  ///< Burst-Read Enable
        constexpr uint32_t BEM = (1U << 5);  ///< Byte-Enable Mode
        constexpr uint32_t PS = (2 << 6);  ///< Port Size
        constexpr uint32_t AA = (1U << 8);  ///< Auto-Acknowledge Enable
        constexpr uint32_t BLS = (1U << 9);  ///< Byte-Lane Shift
        constexpr uint32_t WS = (6 << 10);  ///< Wait States
        constexpr uint32_t WRAH = (2 << 16);  ///< Write Address Hold or Deselect
        constexpr uint32_t RDAH = (2 << 18);  ///< Read Address Hold or Deselect
        constexpr uint32_t ASET = (2 << 20);  ///< Address Setup
        constexpr uint32_t EXTS = (1U << 22);  ///< Extended Transfer Start/Extended Address Latch Enable Controls how long FB_TS /FB_ALE is asserted.
        constexpr uint32_t SWSEN = (1U << 23);  ///< Secondary Wait State Enable
        constexpr uint32_t SWS = (6 << 26);  ///< Secondary Wait States
    }

    /// CSPMCR Register bits
    namespace cspmcr_bits {
        constexpr uint32_t GROUP5 = (4 << 12);  ///< FlexBus Signal Group 5 Multiplex control
        constexpr uint32_t GROUP4 = (4 << 16);  ///< FlexBus Signal Group 4 Multiplex control
        constexpr uint32_t GROUP3 = (4 << 20);  ///< FlexBus Signal Group 3 Multiplex control
        constexpr uint32_t GROUP2 = (4 << 24);  ///< FlexBus Signal Group 2 Multiplex control
        constexpr uint32_t GROUP1 = (4 << 28);  ///< FlexBus Signal Group 1 Multiplex control
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0x4000D000;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t CESR;  ///< Offset: 0x00 - Control/Error Status Register
        volatile uint32_t EAR%s;  ///< Offset: 0x10 - Error Address Register, slave port n
        volatile uint32_t EDR%s;  ///< Offset: 0x14 - Error Detail Register, slave port n
        volatile uint32_t RGD%s_WORD0;  ///< Offset: 0x400 - Region Descriptor n, Word 0
        volatile uint32_t RGD%s_WORD1;  ///< Offset: 0x404 - Region Descriptor n, Word 1
        volatile uint32_t RGD%s_WORD2;  ///< Offset: 0x408 - Region Descriptor n, Word 2
        volatile uint32_t RGD%s_WORD3;  ///< Offset: 0x40C - Region Descriptor n, Word 3
        volatile uint32_t RGDAAC%s;  ///< Offset: 0x800 - Region Descriptor Alternate Access Control n
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// CESR Register bits
    namespace cesr_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t NRGD = (4 << 8);  ///< Number Of Region Descriptors
        constexpr uint32_t NSP = (4 << 12);  ///< Number Of Slave Ports
        constexpr uint32_t HRL = (4 << 16);  ///< Hardware Revision Level
        constexpr uint32_t SPERR = (5 << 27);  ///< Slave Port n Error
    }

    /// EAR%s Register bits
    namespace ear%s_bits {
        constexpr uint32_t EADDR = (32 << 0);  ///< Error Address
    }

    /// EDR%s Register bits
    namespace edr%s_bits {
        constexpr uint32_t ERW = (1U << 0);  ///< Error Read/Write
        constexpr uint32_t EATTR = (3 << 1);  ///< Error Attributes
        constexpr uint32_t EMN = (4 << 4);  ///< Error Master Number
        constexpr uint32_t EPID = (8 << 8);  ///< Error Process Identification
        constexpr uint32_t EACD = (16 << 16);  ///< Error Access Control Detail
    }

    /// RGD%s_WORD0 Register bits
    namespace rgd%s_word0_bits {
        constexpr uint32_t SRTADDR = (27 << 5);  ///< Start Address
    }

    /// RGD%s_WORD1 Register bits
    namespace rgd%s_word1_bits {
        constexpr uint32_t ENDADDR = (27 << 5);  ///< End Address
    }

    /// RGD%s_WORD2 Register bits
    namespace rgd%s_word2_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus Master 0 Process Identifier enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus Master 1 Process Identifier enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus Master 2 Process Identifier Enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus Master 3 Process Identifier Enable
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

    /// RGD%s_WORD3 Register bits
    namespace rgd%s_word3_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t PIDMASK = (8 << 16);  ///< Process Identifier Mask
        constexpr uint32_t PID = (8 << 24);  ///< Process Identifier
    }

    /// RGDAAC%s Register bits
    namespace rgdaac%s_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus Master 0 Process Identifier Enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus Master 1 Process Identifier Enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access Control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus Master 2 Process Identifier Enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus Master 3 Process Identifier Enable
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x4001F000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t PFAPR;  ///< Offset: 0x00 - Flash Access Protection Register
        volatile uint32_t PFB0CR;  ///< Offset: 0x04 - Flash Bank 0 Control Register
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// PFAPR Register bits
    namespace pfapr_bits {
        constexpr uint32_t M0AP = (2 << 0);  ///< Master 0 Access Protection
        constexpr uint32_t M1AP = (2 << 2);  ///< Master 1 Access Protection
        constexpr uint32_t M2AP = (2 << 4);  ///< Master 2 Access Protection
        constexpr uint32_t M3AP = (2 << 6);  ///< Master 3 Access Protection
        constexpr uint32_t M0PFD = (1U << 16);  ///< Master 0 Prefetch Disable
        constexpr uint32_t M1PFD = (1U << 17);  ///< Master 1 Prefetch Disable
        constexpr uint32_t M2PFD = (1U << 18);  ///< Master 2 Prefetch Disable
        constexpr uint32_t M3PFD = (1U << 19);  ///< Master 3 Prefetch Disable
    }

    /// PFB0CR Register bits
    namespace pfb0cr_bits {
        constexpr uint32_t B0IPE = (1U << 1);  ///< Bank 0 Instruction Prefetch Enable
        constexpr uint32_t B0DPE = (1U << 2);  ///< Bank 0 Data Prefetch Enable
        constexpr uint32_t B0MW = (2 << 17);  ///< Bank 0 Memory Width
        constexpr uint32_t S_INV = (1U << 19);  ///< Invalidate Prefetch Speculation Buffer
        constexpr uint32_t B0RWSC = (4 << 28);  ///< Bank 0 Read Wait State Control
    }

}

// ============================================================================
// FTFE Peripheral
// ============================================================================

namespace ftfe {
    /// Base addresses
    constexpr uint32_t FTFE_BASE = 0x40020000;

    /// FTFE Register structure
    struct Registers {
        volatile uint32_t FSTAT;  ///< Offset: 0x00 - Flash Status Register
        volatile uint32_t FCNFG;  ///< Offset: 0x01 - Flash Configuration Register
        volatile uint32_t FSEC;  ///< Offset: 0x02 - Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x03 - Flash Option Register
        volatile uint32_t FCCOB%s;  ///< Offset: 0x04 - Flash Common Command Object Registers
        volatile uint32_t FPROT%s;  ///< Offset: 0x10 - Program Flash Protection Registers
    };

    /// Peripheral instances
    inline Registers* FTFE = reinterpret_cast<Registers*>(FTFE_BASE);

    // Bit definitions
    /// FSTAT Register bits
    namespace fstat_bits {
        constexpr uint32_t MGSTAT0 = (1U << 0);  ///< Memory Controller Command Completion Status Flag
        constexpr uint32_t FPVIOL = (1U << 4);  ///< Flash Protection Violation Flag
        constexpr uint32_t ACCERR = (1U << 5);  ///< Flash Access Error Flag
        constexpr uint32_t RDCOLERR = (1U << 6);  ///< FTFE Read Collision Error Flag
        constexpr uint32_t CCIF = (1U << 7);  ///< Command Complete Interrupt Flag
    }

    /// FCNFG Register bits
    namespace fcnfg_bits {
        constexpr uint32_t EEERDY = (1U << 0);  ///< This bit is reserved and always has the value 0.
        constexpr uint32_t RAMRDY = (1U << 1);  ///< RAM Ready
        constexpr uint32_t PFLSH = (1U << 2);  ///< This bit is reserved and always has the value 0.
        constexpr uint32_t ERSSUSP = (1U << 4);  ///< Erase Suspend
        constexpr uint32_t ERSAREQ = (1U << 5);  ///< Erase All Request
        constexpr uint32_t RDCOLLIE = (1U << 6);  ///< Read Collision Error Interrupt Enable
        constexpr uint32_t CCIE = (1U << 7);  ///< Command Complete Interrupt Enable
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Factory Security Level Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< Mass Erase Enable Bits
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t OPT = (8 << 0);  ///< Nonvolatile Option
    }

    /// FCCOB%s Register bits
    namespace fccob%s_bits {
        constexpr uint32_t CCOBn = (8 << 0);  ///< The FCCOB register provides a command code and relevant parameters to the memory controller
    }

    /// FPROT%s Register bits
    namespace fprot%s_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< Program Flash Region Protect
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN0_BASE = 0x40024000;
    constexpr uint32_t CAN1_BASE = 0x40025000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t CTRL1;  ///< Offset: 0x04 - Control 1 register
        volatile uint32_t TIMER;  ///< Offset: 0x08 - Free Running Timer
        volatile uint32_t RXMGMASK;  ///< Offset: 0x10 - Rx Mailboxes Global Mask Register
        volatile uint32_t RX14MASK;  ///< Offset: 0x14 - Rx 14 Mask register
        volatile uint32_t RX15MASK;  ///< Offset: 0x18 - Rx 15 Mask register
        volatile uint32_t ECR;  ///< Offset: 0x1C - Error Counter
        volatile uint32_t ESR1;  ///< Offset: 0x20 - Error and Status 1 register
        volatile uint32_t IMASK1;  ///< Offset: 0x28 - Interrupt Masks 1 register
        volatile uint32_t IFLAG1;  ///< Offset: 0x30 - Interrupt Flags 1 register
        volatile uint32_t CTRL2;  ///< Offset: 0x34 - Control 2 register
        volatile uint32_t ESR2;  ///< Offset: 0x38 - Error and Status 2 register
        volatile uint32_t CRCR;  ///< Offset: 0x44 - CRC Register
        volatile uint32_t RXFGMASK;  ///< Offset: 0x48 - Rx FIFO Global Mask register
        volatile uint32_t RXFIR;  ///< Offset: 0x4C - Rx FIFO Information Register
        volatile uint32_t CBT;  ///< Offset: 0x50 - CAN Bit Timing Register
        volatile uint32_t CS0;  ///< Offset: 0x80 - Message Buffer 0 CS Register
        volatile uint32_t ID0;  ///< Offset: 0x84 - Message Buffer 0 ID Register
        volatile uint32_t WORD00;  ///< Offset: 0x88 - Message Buffer 0 WORD0 Register
        volatile uint32_t WORD10;  ///< Offset: 0x8C - Message Buffer 0 WORD1 Register
        volatile uint32_t CS1;  ///< Offset: 0x90 - Message Buffer 1 CS Register
        volatile uint32_t ID1;  ///< Offset: 0x94 - Message Buffer 1 ID Register
        volatile uint32_t WORD01;  ///< Offset: 0x98 - Message Buffer 1 WORD0 Register
        volatile uint32_t WORD11;  ///< Offset: 0x9C - Message Buffer 1 WORD1 Register
        volatile uint32_t CS2;  ///< Offset: 0xA0 - Message Buffer 2 CS Register
        volatile uint32_t ID2;  ///< Offset: 0xA4 - Message Buffer 2 ID Register
        volatile uint32_t WORD02;  ///< Offset: 0xA8 - Message Buffer 2 WORD0 Register
        volatile uint32_t WORD12;  ///< Offset: 0xAC - Message Buffer 2 WORD1 Register
        volatile uint32_t CS3;  ///< Offset: 0xB0 - Message Buffer 3 CS Register
        volatile uint32_t ID3;  ///< Offset: 0xB4 - Message Buffer 3 ID Register
        volatile uint32_t WORD03;  ///< Offset: 0xB8 - Message Buffer 3 WORD0 Register
        volatile uint32_t WORD13;  ///< Offset: 0xBC - Message Buffer 3 WORD1 Register
        volatile uint32_t CS4;  ///< Offset: 0xC0 - Message Buffer 4 CS Register
        volatile uint32_t ID4;  ///< Offset: 0xC4 - Message Buffer 4 ID Register
        volatile uint32_t WORD04;  ///< Offset: 0xC8 - Message Buffer 4 WORD0 Register
        volatile uint32_t WORD14;  ///< Offset: 0xCC - Message Buffer 4 WORD1 Register
        volatile uint32_t CS5;  ///< Offset: 0xD0 - Message Buffer 5 CS Register
        volatile uint32_t ID5;  ///< Offset: 0xD4 - Message Buffer 5 ID Register
        volatile uint32_t WORD05;  ///< Offset: 0xD8 - Message Buffer 5 WORD0 Register
        volatile uint32_t WORD15;  ///< Offset: 0xDC - Message Buffer 5 WORD1 Register
        volatile uint32_t CS6;  ///< Offset: 0xE0 - Message Buffer 6 CS Register
        volatile uint32_t ID6;  ///< Offset: 0xE4 - Message Buffer 6 ID Register
        volatile uint32_t WORD06;  ///< Offset: 0xE8 - Message Buffer 6 WORD0 Register
        volatile uint32_t WORD16;  ///< Offset: 0xEC - Message Buffer 6 WORD1 Register
        volatile uint32_t CS7;  ///< Offset: 0xF0 - Message Buffer 7 CS Register
        volatile uint32_t ID7;  ///< Offset: 0xF4 - Message Buffer 7 ID Register
        volatile uint32_t WORD07;  ///< Offset: 0xF8 - Message Buffer 7 WORD0 Register
        volatile uint32_t WORD17;  ///< Offset: 0xFC - Message Buffer 7 WORD1 Register
        volatile uint32_t CS8;  ///< Offset: 0x100 - Message Buffer 8 CS Register
        volatile uint32_t ID8;  ///< Offset: 0x104 - Message Buffer 8 ID Register
        volatile uint32_t WORD08;  ///< Offset: 0x108 - Message Buffer 8 WORD0 Register
        volatile uint32_t WORD18;  ///< Offset: 0x10C - Message Buffer 8 WORD1 Register
        volatile uint32_t CS9;  ///< Offset: 0x110 - Message Buffer 9 CS Register
        volatile uint32_t ID9;  ///< Offset: 0x114 - Message Buffer 9 ID Register
        volatile uint32_t WORD09;  ///< Offset: 0x118 - Message Buffer 9 WORD0 Register
        volatile uint32_t WORD19;  ///< Offset: 0x11C - Message Buffer 9 WORD1 Register
        volatile uint32_t CS10;  ///< Offset: 0x120 - Message Buffer 10 CS Register
        volatile uint32_t ID10;  ///< Offset: 0x124 - Message Buffer 10 ID Register
        volatile uint32_t WORD010;  ///< Offset: 0x128 - Message Buffer 10 WORD0 Register
        volatile uint32_t WORD110;  ///< Offset: 0x12C - Message Buffer 10 WORD1 Register
        volatile uint32_t CS11;  ///< Offset: 0x130 - Message Buffer 11 CS Register
        volatile uint32_t ID11;  ///< Offset: 0x134 - Message Buffer 11 ID Register
        volatile uint32_t WORD011;  ///< Offset: 0x138 - Message Buffer 11 WORD0 Register
        volatile uint32_t WORD111;  ///< Offset: 0x13C - Message Buffer 11 WORD1 Register
        volatile uint32_t CS12;  ///< Offset: 0x140 - Message Buffer 12 CS Register
        volatile uint32_t ID12;  ///< Offset: 0x144 - Message Buffer 12 ID Register
        volatile uint32_t WORD012;  ///< Offset: 0x148 - Message Buffer 12 WORD0 Register
        volatile uint32_t WORD112;  ///< Offset: 0x14C - Message Buffer 12 WORD1 Register
        volatile uint32_t CS13;  ///< Offset: 0x150 - Message Buffer 13 CS Register
        volatile uint32_t ID13;  ///< Offset: 0x154 - Message Buffer 13 ID Register
        volatile uint32_t WORD013;  ///< Offset: 0x158 - Message Buffer 13 WORD0 Register
        volatile uint32_t WORD113;  ///< Offset: 0x15C - Message Buffer 13 WORD1 Register
        volatile uint32_t CS14;  ///< Offset: 0x160 - Message Buffer 14 CS Register
        volatile uint32_t ID14;  ///< Offset: 0x164 - Message Buffer 14 ID Register
        volatile uint32_t WORD014;  ///< Offset: 0x168 - Message Buffer 14 WORD0 Register
        volatile uint32_t WORD114;  ///< Offset: 0x16C - Message Buffer 14 WORD1 Register
        volatile uint32_t CS15;  ///< Offset: 0x170 - Message Buffer 15 CS Register
        volatile uint32_t ID15;  ///< Offset: 0x174 - Message Buffer 15 ID Register
        volatile uint32_t WORD015;  ///< Offset: 0x178 - Message Buffer 15 WORD0 Register
        volatile uint32_t WORD115;  ///< Offset: 0x17C - Message Buffer 15 WORD1 Register
        volatile uint32_t RXIMR%s;  ///< Offset: 0x880 - Rx Individual Mask Registers
    };

    /// Peripheral instances
    inline Registers* CAN0 = reinterpret_cast<Registers*>(CAN0_BASE);
    inline Registers* CAN1 = reinterpret_cast<Registers*>(CAN1_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MAXMB = (7 << 0);  ///< Number Of The Last Message Buffer
        constexpr uint32_t IDAM = (2 << 8);  ///< ID Acceptance Mode
        constexpr uint32_t AEN = (1U << 12);  ///< Abort Enable
        constexpr uint32_t LPRIOEN = (1U << 13);  ///< Local Priority Enable
        constexpr uint32_t DMA = (1U << 15);  ///< DMA Enable
        constexpr uint32_t IRMQ = (1U << 16);  ///< Individual Rx Masking And Queue Enable
        constexpr uint32_t SRXDIS = (1U << 17);  ///< Self Reception Disable
        constexpr uint32_t DOZE = (1U << 18);  ///< Doze Mode Enable
        constexpr uint32_t WAKSRC = (1U << 19);  ///< Wake Up Source
        constexpr uint32_t LPMACK = (1U << 20);  ///< Low-Power Mode Acknowledge
        constexpr uint32_t WRNEN = (1U << 21);  ///< Warning Interrupt Enable
        constexpr uint32_t SLFWAK = (1U << 22);  ///< Self Wake Up
        constexpr uint32_t SUPV = (1U << 23);  ///< Supervisor Mode
        constexpr uint32_t FRZACK = (1U << 24);  ///< Freeze Mode Acknowledge
        constexpr uint32_t SOFTRST = (1U << 25);  ///< Soft Reset
        constexpr uint32_t WAKMSK = (1U << 26);  ///< Wake Up Interrupt Mask
        constexpr uint32_t NOTRDY = (1U << 27);  ///< FlexCAN Not Ready
        constexpr uint32_t HALT = (1U << 28);  ///< Halt FlexCAN
        constexpr uint32_t RFEN = (1U << 29);  ///< Rx FIFO Enable
        constexpr uint32_t FRZ = (1U << 30);  ///< Freeze Enable
        constexpr uint32_t MDIS = (1U << 31);  ///< Module Disable
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t PROPSEG = (3 << 0);  ///< Propagation Segment
        constexpr uint32_t LOM = (1U << 3);  ///< Listen-Only Mode
        constexpr uint32_t LBUF = (1U << 4);  ///< Lowest Buffer Transmitted First
        constexpr uint32_t TSYN = (1U << 5);  ///< Timer Sync
        constexpr uint32_t BOFFREC = (1U << 6);  ///< Bus Off Recovery
        constexpr uint32_t SMP = (1U << 7);  ///< CAN Bit Sampling
        constexpr uint32_t RWRNMSK = (1U << 10);  ///< Rx Warning Interrupt Mask
        constexpr uint32_t TWRNMSK = (1U << 11);  ///< Tx Warning Interrupt Mask
        constexpr uint32_t LPB = (1U << 12);  ///< Loop Back Mode
        constexpr uint32_t CLKSRC = (1U << 13);  ///< CAN Engine Clock Source
        constexpr uint32_t ERRMSK = (1U << 14);  ///< Error Interrupt Mask
        constexpr uint32_t BOFFMSK = (1U << 15);  ///< Bus Off Interrupt Mask
        constexpr uint32_t PSEG2 = (3 << 16);  ///< Phase Segment 2
        constexpr uint32_t PSEG1 = (3 << 19);  ///< Phase Segment 1
        constexpr uint32_t RJW = (2 << 22);  ///< Resync Jump Width
        constexpr uint32_t PRESDIV = (8 << 24);  ///< Prescaler Division Factor
    }

    /// TIMER Register bits
    namespace timer_bits {
        constexpr uint32_t TIMER = (16 << 0);  ///< Timer Value
    }

    /// RXMGMASK Register bits
    namespace rxmgmask_bits {
        constexpr uint32_t MG = (32 << 0);  ///< Rx Mailboxes Global Mask Bits
    }

    /// RX14MASK Register bits
    namespace rx14mask_bits {
        constexpr uint32_t RX14M = (32 << 0);  ///< Rx Buffer 14 Mask Bits
    }

    /// RX15MASK Register bits
    namespace rx15mask_bits {
        constexpr uint32_t RX15M = (32 << 0);  ///< Rx Buffer 15 Mask Bits
    }

    /// ECR Register bits
    namespace ecr_bits {
        constexpr uint32_t TXERRCNT = (8 << 0);  ///< Transmit Error Counter
        constexpr uint32_t RXERRCNT = (8 << 8);  ///< Receive Error Counter
    }

    /// ESR1 Register bits
    namespace esr1_bits {
        constexpr uint32_t WAKINT = (1U << 0);  ///< Wake-Up Interrupt
        constexpr uint32_t ERRINT = (1U << 1);  ///< Error Interrupt
        constexpr uint32_t BOFFINT = (1U << 2);  ///< Bus Off Interrupt
        constexpr uint32_t RX = (1U << 3);  ///< FlexCAN In Reception
        constexpr uint32_t FLTCONF = (2 << 4);  ///< Fault Confinement State
        constexpr uint32_t TX = (1U << 6);  ///< FlexCAN In Transmission
        constexpr uint32_t IDLE = (1U << 7);  ///< This bit indicates when CAN bus is in IDLE state
        constexpr uint32_t RXWRN = (1U << 8);  ///< Rx Error Warning
        constexpr uint32_t TXWRN = (1U << 9);  ///< TX Error Warning
        constexpr uint32_t STFERR = (1U << 10);  ///< Stuffing Error
        constexpr uint32_t FRMERR = (1U << 11);  ///< Form Error
        constexpr uint32_t CRCERR = (1U << 12);  ///< Cyclic Redundancy Check Error
        constexpr uint32_t ACKERR = (1U << 13);  ///< Acknowledge Error
        constexpr uint32_t BIT0ERR = (1U << 14);  ///< Bit0 Error
        constexpr uint32_t BIT1ERR = (1U << 15);  ///< Bit1 Error
        constexpr uint32_t RWRNINT = (1U << 16);  ///< Rx Warning Interrupt Flag
        constexpr uint32_t TWRNINT = (1U << 17);  ///< Tx Warning Interrupt Flag
        constexpr uint32_t SYNCH = (1U << 18);  ///< CAN Synchronization Status
        constexpr uint32_t BOFFDONEINT = (1U << 19);  ///< Bus Off Done Interrupt
        constexpr uint32_t ERROVR = (1U << 21);  ///< Error Overrun bit
    }

    /// IMASK1 Register bits
    namespace imask1_bits {
        constexpr uint32_t BUF31TO0M = (32 << 0);  ///< Buffer MB i Mask
    }

    /// IFLAG1 Register bits
    namespace iflag1_bits {
        constexpr uint32_t BUF0I = (1U << 0);  ///< Buffer MB0 Interrupt Or Clear FIFO bit
        constexpr uint32_t BUF4TO1I = (4 << 1);  ///< Buffer MB i Interrupt Or "reserved"
        constexpr uint32_t BUF5I = (1U << 5);  ///< Buffer MB5 Interrupt Or "Frames available in Rx FIFO"
        constexpr uint32_t BUF6I = (1U << 6);  ///< Buffer MB6 Interrupt Or "Rx FIFO Warning"
        constexpr uint32_t BUF7I = (1U << 7);  ///< Buffer MB7 Interrupt Or "Rx FIFO Overflow"
        constexpr uint32_t BUF31TO8I = (24 << 8);  ///< Buffer MBi Interrupt
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t EACEN = (1U << 16);  ///< Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
        constexpr uint32_t RRS = (1U << 17);  ///< Remote Request Storing
        constexpr uint32_t MRP = (1U << 18);  ///< Mailboxes Reception Priority
        constexpr uint32_t TASD = (5 << 19);  ///< Tx Arbitration Start Delay
        constexpr uint32_t RFFN = (4 << 24);  ///< Number Of Rx FIFO Filters
        constexpr uint32_t BOFFDONEMSK = (1U << 30);  ///< Bus Off Done Interrupt Mask
    }

    /// ESR2 Register bits
    namespace esr2_bits {
        constexpr uint32_t IMB = (1U << 13);  ///< Inactive Mailbox
        constexpr uint32_t VPS = (1U << 14);  ///< Valid Priority Status
        constexpr uint32_t LPTM = (7 << 16);  ///< Lowest Priority Tx Mailbox
    }

    /// CRCR Register bits
    namespace crcr_bits {
        constexpr uint32_t TXCRC = (15 << 0);  ///< Transmitted CRC value
        constexpr uint32_t MBCRC = (7 << 16);  ///< CRC Mailbox
    }

    /// RXFGMASK Register bits
    namespace rxfgmask_bits {
        constexpr uint32_t FGM = (32 << 0);  ///< Rx FIFO Global Mask Bits
    }

    /// RXFIR Register bits
    namespace rxfir_bits {
        constexpr uint32_t IDHIT = (9 << 0);  ///< Identifier Acceptance Filter Hit Indicator
    }

    /// CBT Register bits
    namespace cbt_bits {
        constexpr uint32_t EPSEG2 = (5 << 0);  ///< Extended Phase Segment 2
        constexpr uint32_t EPSEG1 = (5 << 5);  ///< Extended Phase Segment 1
        constexpr uint32_t EPROPSEG = (6 << 10);  ///< Extended Propagation Segment
        constexpr uint32_t ERJW = (4 << 16);  ///< Extended Resync Jump Width
        constexpr uint32_t EPRESDIV = (10 << 21);  ///< Extended Prescaler Division Factor
        constexpr uint32_t BTF = (1U << 31);  ///< Bit Timing Format Enable
    }

    /// CS0 Register bits
    namespace cs0_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID0 Register bits
    namespace id0_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD00 Register bits
    namespace word00_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD10 Register bits
    namespace word10_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS1 Register bits
    namespace cs1_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID1 Register bits
    namespace id1_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD01 Register bits
    namespace word01_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD11 Register bits
    namespace word11_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS2 Register bits
    namespace cs2_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID2 Register bits
    namespace id2_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD02 Register bits
    namespace word02_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD12 Register bits
    namespace word12_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS3 Register bits
    namespace cs3_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID3 Register bits
    namespace id3_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD03 Register bits
    namespace word03_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD13 Register bits
    namespace word13_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS4 Register bits
    namespace cs4_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID4 Register bits
    namespace id4_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD04 Register bits
    namespace word04_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD14 Register bits
    namespace word14_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS5 Register bits
    namespace cs5_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID5 Register bits
    namespace id5_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD05 Register bits
    namespace word05_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD15 Register bits
    namespace word15_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS6 Register bits
    namespace cs6_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID6 Register bits
    namespace id6_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD06 Register bits
    namespace word06_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD16 Register bits
    namespace word16_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS7 Register bits
    namespace cs7_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID7 Register bits
    namespace id7_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD07 Register bits
    namespace word07_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD17 Register bits
    namespace word17_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS8 Register bits
    namespace cs8_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID8 Register bits
    namespace id8_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD08 Register bits
    namespace word08_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD18 Register bits
    namespace word18_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS9 Register bits
    namespace cs9_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID9 Register bits
    namespace id9_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD09 Register bits
    namespace word09_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD19 Register bits
    namespace word19_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS10 Register bits
    namespace cs10_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID10 Register bits
    namespace id10_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD010 Register bits
    namespace word010_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD110 Register bits
    namespace word110_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS11 Register bits
    namespace cs11_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID11 Register bits
    namespace id11_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD011 Register bits
    namespace word011_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD111 Register bits
    namespace word111_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS12 Register bits
    namespace cs12_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID12 Register bits
    namespace id12_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD012 Register bits
    namespace word012_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD112 Register bits
    namespace word112_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS13 Register bits
    namespace cs13_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID13 Register bits
    namespace id13_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD013 Register bits
    namespace word013_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD113 Register bits
    namespace word113_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS14 Register bits
    namespace cs14_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID14 Register bits
    namespace id14_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD014 Register bits
    namespace word014_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD114 Register bits
    namespace word114_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS15 Register bits
    namespace cs15_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
        constexpr uint32_t ESI = (1U << 29);  ///< Reserved
        constexpr uint32_t BRS = (1U << 30);  ///< Reserved
        constexpr uint32_t EDL = (1U << 31);  ///< Reserved
    }

    /// ID15 Register bits
    namespace id15_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD015 Register bits
    namespace word015_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD115 Register bits
    namespace word115_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// RXIMR%s Register bits
    namespace rximr%s_bits {
        constexpr uint32_t MI = (32 << 0);  ///< Individual Mask Bits
    }

}

// ============================================================================
// FTM0 Peripheral
// ============================================================================

namespace ftm0 {
    /// Base addresses
    constexpr uint32_t FTM0_BASE = 0x40038000;

    /// FTM0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status And Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM0 = reinterpret_cast<Registers*>(FTM0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM1 Peripheral
// ============================================================================

namespace ftm1 {
    /// Base addresses
    constexpr uint32_t FTM1_BASE = 0x40039000;

    /// FTM1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status And Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM1 = reinterpret_cast<Registers*>(FTM1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM2 Peripheral
// ============================================================================

namespace ftm2 {
    /// Base addresses
    constexpr uint32_t FTM2_BASE = 0x4003A000;

    /// FTM2 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status And Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM2 = reinterpret_cast<Registers*>(FTM2_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM3 Peripheral
// ============================================================================

namespace ftm3 {
    /// Base addresses
    constexpr uint32_t FTM3_BASE = 0x40026000;

    /// FTM3 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status And Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM3 = reinterpret_cast<Registers*>(FTM3_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x4002C000;
    constexpr uint32_t SPI1_BASE = 0x4002D000;
    constexpr uint32_t SPI2_BASE = 0x400AC000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t TCR;  ///< Offset: 0x08 - Transfer Count Register
        volatile uint32_t CTAR%s;  ///< Offset: 0x0C - Clock and Transfer Attributes Register (In Master Mode)
        volatile uint32_t CTAR_SLAVE;  ///< Offset: 0x0C - Clock and Transfer Attributes Register (In Slave Mode)
        volatile uint32_t SR;  ///< Offset: 0x2C - Status Register
        volatile uint32_t RSER;  ///< Offset: 0x30 - DMA/Interrupt Request Select and Enable Register
        volatile uint32_t PUSHR;  ///< Offset: 0x34 - PUSH TX FIFO Register In Master Mode
        volatile uint32_t PUSHR_SLAVE;  ///< Offset: 0x34 - PUSH TX FIFO Register In Slave Mode
        volatile uint32_t POPR;  ///< Offset: 0x38 - POP RX FIFO Register
        volatile uint32_t TXFR%s;  ///< Offset: 0x3C - Transmit FIFO Registers
        volatile uint32_t RXFR%s;  ///< Offset: 0x7C - Receive FIFO Registers
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t HALT = (1U << 0);  ///< Halt
        constexpr uint32_t SMPL_PT = (2 << 8);  ///< Sample Point
        constexpr uint32_t CLR_RXF = (1U << 10);  ///< CLR_RXF
        constexpr uint32_t CLR_TXF = (1U << 11);  ///< Clear TX FIFO
        constexpr uint32_t DIS_RXF = (1U << 12);  ///< Disable Receive FIFO
        constexpr uint32_t DIS_TXF = (1U << 13);  ///< Disable Transmit FIFO
        constexpr uint32_t MDIS = (1U << 14);  ///< Module Disable
        constexpr uint32_t DOZE = (1U << 15);  ///< Doze Enable
        constexpr uint32_t PCSIS = (6 << 16);  ///< Peripheral Chip Select x Inactive State
        constexpr uint32_t ROOE = (1U << 24);  ///< Receive FIFO Overflow Overwrite Enable
        constexpr uint32_t PCSSE = (1U << 25);  ///< Peripheral Chip Select Strobe Enable
        constexpr uint32_t MTFE = (1U << 26);  ///< Modified Transfer Format Enable
        constexpr uint32_t FRZ = (1U << 27);  ///< Freeze
        constexpr uint32_t DCONF = (2 << 28);  ///< SPI Configuration.
        constexpr uint32_t CONT_SCKE = (1U << 30);  ///< Continuous SCK Enable
        constexpr uint32_t MSTR = (1U << 31);  ///< Master/Slave Mode Select
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t SPI_TCNT = (16 << 16);  ///< SPI Transfer Counter
    }

    /// CTAR%s Register bits
    namespace ctar%s_bits {
        constexpr uint32_t BR = (4 << 0);  ///< Baud Rate Scaler
        constexpr uint32_t DT = (4 << 4);  ///< Delay After Transfer Scaler
        constexpr uint32_t ASC = (4 << 8);  ///< After SCK Delay Scaler
        constexpr uint32_t CSSCK = (4 << 12);  ///< PCS to SCK Delay Scaler
        constexpr uint32_t PBR = (2 << 16);  ///< Baud Rate Prescaler
        constexpr uint32_t PDT = (2 << 18);  ///< Delay after Transfer Prescaler
        constexpr uint32_t PASC = (2 << 20);  ///< After SCK Delay Prescaler
        constexpr uint32_t PCSSCK = (2 << 22);  ///< PCS to SCK Delay Prescaler
        constexpr uint32_t LSBFE = (1U << 24);  ///< LSB First
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
        constexpr uint32_t DBR = (1U << 31);  ///< Double Baud Rate
    }

    /// CTAR_SLAVE Register bits
    namespace ctar_slave_bits {
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t POPNXTPTR = (4 << 0);  ///< Pop Next Pointer
        constexpr uint32_t RXCTR = (4 << 4);  ///< RX FIFO Counter
        constexpr uint32_t TXNXTPTR = (4 << 8);  ///< Transmit Next Pointer
        constexpr uint32_t TXCTR = (4 << 12);  ///< TX FIFO Counter
        constexpr uint32_t RFDF = (1U << 17);  ///< Receive FIFO Drain Flag
        constexpr uint32_t RFOF = (1U << 19);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t TFFF = (1U << 25);  ///< Transmit FIFO Fill Flag
        constexpr uint32_t TFUF = (1U << 27);  ///< Transmit FIFO Underflow Flag
        constexpr uint32_t EOQF = (1U << 28);  ///< End of Queue Flag
        constexpr uint32_t TXRXS = (1U << 30);  ///< TX and RX Status
        constexpr uint32_t TCF = (1U << 31);  ///< Transfer Complete Flag
    }

    /// RSER Register bits
    namespace rser_bits {
        constexpr uint32_t RFDF_DIRS = (1U << 16);  ///< Receive FIFO Drain DMA or Interrupt Request Select
        constexpr uint32_t RFDF_RE = (1U << 17);  ///< Receive FIFO Drain Request Enable
        constexpr uint32_t RFOF_RE = (1U << 19);  ///< Receive FIFO Overflow Request Enable
        constexpr uint32_t TFFF_DIRS = (1U << 24);  ///< Transmit FIFO Fill DMA or Interrupt Request Select
        constexpr uint32_t TFFF_RE = (1U << 25);  ///< Transmit FIFO Fill Request Enable
        constexpr uint32_t TFUF_RE = (1U << 27);  ///< Transmit FIFO Underflow Request Enable
        constexpr uint32_t EOQF_RE = (1U << 28);  ///< Finished Request Enable
        constexpr uint32_t TCF_RE = (1U << 31);  ///< Transmission Complete Request Enable
    }

    /// PUSHR Register bits
    namespace pushr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t PCS = (6 << 16);  ///< Select which PCS signals are to be asserted for the transfer
        constexpr uint32_t CTCNT = (1U << 26);  ///< Clear Transfer Counter
        constexpr uint32_t EOQ = (1U << 27);  ///< End Of Queue
        constexpr uint32_t CTAS = (3 << 28);  ///< Clock and Transfer Attributes Select
        constexpr uint32_t CONT = (1U << 31);  ///< Continuous Peripheral Chip Select Enable
    }

    /// PUSHR_SLAVE Register bits
    namespace pushr_slave_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
    }

    /// POPR Register bits
    namespace popr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Received Data
    }

    /// TXFR%s Register bits
    namespace txfr%s_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t TXCMD_TXDATA = (16 << 16);  ///< Transmit Command or Transmit Data
    }

    /// RXFR%s Register bits
    namespace rxfr%s_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Receive Data
    }

}

// ============================================================================
// PDB0 Peripheral
// ============================================================================

namespace pdb0 {
    /// Base addresses
    constexpr uint32_t PDB0_BASE = 0x40036000;

    /// PDB0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay register
        volatile uint32_t CH%sC1;  ///< Offset: 0x10 - Channel n Control register 1
        volatile uint32_t CH%sS;  ///< Offset: 0x14 - Channel n Status register
        volatile uint32_t CH%sDLY0;  ///< Offset: 0x18 - Channel n Delay 0 register
        volatile uint32_t CH%sDLY1;  ///< Offset: 0x1C - Channel n Delay 1 register
        volatile uint32_t DACINTC;  ///< Offset: 0x150 - DAC Interval Trigger n Control register
        volatile uint32_t DACINT;  ///< Offset: 0x154 - DAC Interval n register
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable register
        volatile uint32_t PO%sDLY;  ///< Offset: 0x194 - Pulse-Out n Delay register
    };

    /// Peripheral instances
    inline Registers* PDB0 = reinterpret_cast<Registers*>(PDB0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
    }

    /// CH%sC1 Register bits
    namespace ch%sc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t BB = (8 << 16);  ///< PDB Channel Pre-Trigger Back-to-Back Operation Enable
    }

    /// CH%sS Register bits
    namespace ch%ss_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CH%sDLY0 Register bits
    namespace ch%sdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY1 Register bits
    namespace ch%sdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// DACINTC Register bits
    namespace dacintc_bits {
        constexpr uint32_t TOE = (1U << 0);  ///< DAC Interval Trigger Enable
        constexpr uint32_t EXT = (1U << 1);  ///< DAC External Trigger Input Enable
    }

    /// DACINT Register bits
    namespace dacint_bits {
        constexpr uint32_t INT = (16 << 0);  ///< DAC Interval
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
    }

    /// PO%sDLY Register bits
    namespace po%sdly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// PDB1 Peripheral
// ============================================================================

namespace pdb1 {
    /// Base addresses
    constexpr uint32_t PDB1_BASE = 0x40031000;

    /// PDB1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay register
        volatile uint32_t CH%sC1;  ///< Offset: 0x10 - Channel n Control register 1
        volatile uint32_t CH%sS;  ///< Offset: 0x14 - Channel n Status register
        volatile uint32_t CH%sDLY0;  ///< Offset: 0x18 - Channel n Delay 0 register
        volatile uint32_t CH%sDLY1;  ///< Offset: 0x1C - Channel n Delay 1 register
        volatile uint32_t DACINTC;  ///< Offset: 0x150 - DAC Interval Trigger n Control register
        volatile uint32_t DACINT;  ///< Offset: 0x154 - DAC Interval n register
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable register
        volatile uint32_t PO%sDLY;  ///< Offset: 0x194 - Pulse-Out n Delay register
    };

    /// Peripheral instances
    inline Registers* PDB1 = reinterpret_cast<Registers*>(PDB1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
    }

    /// CH%sC1 Register bits
    namespace ch%sc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t BB = (8 << 16);  ///< PDB Channel Pre-Trigger Back-to-Back Operation Enable
    }

    /// CH%sS Register bits
    namespace ch%ss_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CH%sDLY0 Register bits
    namespace ch%sdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY1 Register bits
    namespace ch%sdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// DACINTC Register bits
    namespace dacintc_bits {
        constexpr uint32_t TOE = (1U << 0);  ///< DAC Interval Trigger Enable
        constexpr uint32_t EXT = (1U << 1);  ///< DAC External Trigger Input Enable
    }

    /// DACINT Register bits
    namespace dacint_bits {
        constexpr uint32_t INT = (16 << 0);  ///< DAC Interval
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
    }

    /// PO%sDLY Register bits
    namespace po%sdly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40032000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x00 - CRC Data register
        volatile uint32_t DATAL;  ///< Offset: 0x00 - CRC_DATAL register.
        volatile uint32_t DATALL;  ///< Offset: 0x00 - CRC_DATALL register.
        volatile uint32_t DATALU;  ///< Offset: 0x01 - CRC_DATALU register.
        volatile uint32_t DATAH;  ///< Offset: 0x02 - CRC_DATAH register.
        volatile uint32_t DATAHL;  ///< Offset: 0x02 - CRC_DATAHL register.
        volatile uint32_t DATAHU;  ///< Offset: 0x03 - CRC_DATAHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial register
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// DATAL Register bits
    namespace datal_bits {
        constexpr uint32_t DATAL = (16 << 0);  ///< DATAL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// DATALL Register bits
    namespace datall_bits {
        constexpr uint32_t DATALL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit DATA
    }

    /// DATALU Register bits
    namespace datalu_bits {
        constexpr uint32_t DATALU = (8 << 0);  ///< DATALL stores the second 8 bits of the 32 bit CRC
    }

    /// DATAH Register bits
    namespace datah_bits {
        constexpr uint32_t DATAH = (16 << 0);  ///< DATAH stores the high 16 bits of the 16/32 bit CRC
    }

    /// DATAHL Register bits
    namespace datahl_bits {
        constexpr uint32_t DATAHL = (8 << 0);  ///< DATAHL stores the third 8 bits of the 32 bit CRC
    }

    /// DATAHU Register bits
    namespace datahu_bits {
        constexpr uint32_t DATAHU = (8 << 0);  ///< DATAHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low Polynominal Half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High Polynominal Half-word
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TCRC = (1U << 24);  ///< Width of CRC protocol.
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC Data Register As Seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read Of CRC Data Register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type Of Transpose For Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type Of Transpose For Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t PWM0_BASE = 0x40033000;
    constexpr uint32_t PWM1_BASE = 0x400B3000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t SM%sCNT;  ///< Offset: 0x00 - Counter Register
        volatile uint32_t SM%sINIT;  ///< Offset: 0x02 - Initial Count Register
        volatile uint32_t SM%sCTRL2;  ///< Offset: 0x04 - Control 2 Register
        volatile uint32_t SM%sCTRL;  ///< Offset: 0x06 - Control Register
        volatile uint32_t SM%sVAL0;  ///< Offset: 0x0A - Value Register 0
        volatile uint32_t SM%sFRACVAL1;  ///< Offset: 0x0C - Fractional Value Register 1
        volatile uint32_t SM%sVAL1;  ///< Offset: 0x0E - Value Register 1
        volatile uint32_t SM%sFRACVAL2;  ///< Offset: 0x10 - Fractional Value Register 2
        volatile uint32_t SM%sVAL2;  ///< Offset: 0x12 - Value Register 2
        volatile uint32_t SM%sFRACVAL3;  ///< Offset: 0x14 - Fractional Value Register 3
        volatile uint32_t SM%sVAL3;  ///< Offset: 0x16 - Value Register 3
        volatile uint32_t SM%sFRACVAL4;  ///< Offset: 0x18 - Fractional Value Register 4
        volatile uint32_t SM%sVAL4;  ///< Offset: 0x1A - Value Register 4
        volatile uint32_t SM%sFRACVAL5;  ///< Offset: 0x1C - Fractional Value Register 5
        volatile uint32_t SM%sVAL5;  ///< Offset: 0x1E - Value Register 5
        volatile uint32_t SM%sFRCTRL;  ///< Offset: 0x20 - Fractional Control Register
        volatile uint32_t SM%sOCTRL;  ///< Offset: 0x22 - Output Control Register
        volatile uint32_t SM%sSTS;  ///< Offset: 0x24 - Status Register
        volatile uint32_t SM%sINTEN;  ///< Offset: 0x26 - Interrupt Enable Register
        volatile uint32_t SM%sDMAEN;  ///< Offset: 0x28 - DMA Enable Register
        volatile uint32_t SM%sTCTRL;  ///< Offset: 0x2A - Output Trigger Control Register
        volatile uint32_t SM%sDISMAP0;  ///< Offset: 0x2C - Fault Disable Mapping Register 0
        volatile uint32_t SM%sDTCNT0;  ///< Offset: 0x30 - Deadtime Count Register 0
        volatile uint32_t SM%sDTCNT1;  ///< Offset: 0x32 - Deadtime Count Register 1
        volatile uint32_t SM%sCAPTCTRLA;  ///< Offset: 0x34 - Capture Control A Register
        volatile uint32_t SM%sCAPTCOMPA;  ///< Offset: 0x36 - Capture Compare A Register
        volatile uint32_t SM%sCAPTCTRLB;  ///< Offset: 0x38 - Capture Control B Register
        volatile uint32_t SM%sCAPTCOMPB;  ///< Offset: 0x3A - Capture Compare B Register
        volatile uint32_t SM%sCAPTCTRLX;  ///< Offset: 0x3C - Capture Control X Register
        volatile uint32_t SM%sCAPTCOMPX;  ///< Offset: 0x3E - Capture Compare X Register
        volatile uint32_t SM%sCVAL0;  ///< Offset: 0x40 - Capture Value 0 Register
        volatile uint32_t SM%sCVAL0CYC;  ///< Offset: 0x42 - Capture Value 0 Cycle Register
        volatile uint32_t SM%sCVAL1;  ///< Offset: 0x44 - Capture Value 1 Register
        volatile uint32_t SM%sCVAL1CYC;  ///< Offset: 0x46 - Capture Value 1 Cycle Register
        volatile uint32_t SM%sCVAL2;  ///< Offset: 0x48 - Capture Value 2 Register
        volatile uint32_t SM%sCVAL2CYC;  ///< Offset: 0x4A - Capture Value 2 Cycle Register
        volatile uint32_t SM%sCVAL3;  ///< Offset: 0x4C - Capture Value 3 Register
        volatile uint32_t SM%sCVAL3CYC;  ///< Offset: 0x4E - Capture Value 3 Cycle Register
        volatile uint32_t SM%sCVAL4;  ///< Offset: 0x50 - Capture Value 4 Register
        volatile uint32_t SM%sCVAL4CYC;  ///< Offset: 0x52 - Capture Value 4 Cycle Register
        volatile uint32_t SM%sCVAL5;  ///< Offset: 0x54 - Capture Value 5 Register
        volatile uint32_t SM%sCVAL5CYC;  ///< Offset: 0x56 - Capture Value 5 Cycle Register
        volatile uint32_t OUTEN;  ///< Offset: 0x180 - Output Enable Register
        volatile uint32_t MASK;  ///< Offset: 0x182 - Mask Register
        volatile uint32_t SWCOUT;  ///< Offset: 0x184 - Software Controlled Output Register
        volatile uint32_t DTSRCSEL;  ///< Offset: 0x186 - PWM Source Select Register
        volatile uint32_t MCTRL0;  ///< Offset: 0x188 - Master Control Register 0
        volatile uint32_t MCTRL1;  ///< Offset: 0x18A - Master Control Register 1
        volatile uint32_t FCTRL;  ///< Offset: 0x18C - Fault Control Register
        volatile uint32_t FSTS;  ///< Offset: 0x18E - Fault Status Register
        volatile uint32_t FFILT;  ///< Offset: 0x190 - Fault Filter Register
        volatile uint32_t FTST;  ///< Offset: 0x192 - Fault Test Register
        volatile uint32_t FCTRL2;  ///< Offset: 0x194 - Fault Control 2 Register
    };

    /// Peripheral instances
    inline Registers* PWM0 = reinterpret_cast<Registers*>(PWM0_BASE);
    inline Registers* PWM1 = reinterpret_cast<Registers*>(PWM1_BASE);

    // Bit definitions
    /// SM%sCNT Register bits
    namespace sm%scnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter Register Bits
    }

    /// SM%sINIT Register bits
    namespace sm%sinit_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Count Register Bits
    }

    /// SM%sCTRL2 Register bits
    namespace sm%sctrl2_bits {
        constexpr uint32_t CLK_SEL = (2 << 0);  ///< Clock Source Select
        constexpr uint32_t RELOAD_SEL = (1U << 2);  ///< Reload Source Select
        constexpr uint32_t FORCE_SEL = (3 << 3);  ///< This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
        constexpr uint32_t FORCE = (1U << 6);  ///< Force Initialization
        constexpr uint32_t FRCEN = (1U << 7);  ///< This bit allows the CTRL2[FORCE] signal to initialize the counter without regard to the signal selected by CTRL2[INIT_SEL]
        constexpr uint32_t INIT_SEL = (2 << 8);  ///< Initialization Control Select
        constexpr uint32_t PWMX_INIT = (1U << 10);  ///< PWM_X Initial Value
        constexpr uint32_t PWM45_INIT = (1U << 11);  ///< PWM45 Initial Value
        constexpr uint32_t PWM23_INIT = (1U << 12);  ///< PWM23 Initial Value
        constexpr uint32_t INDEP = (1U << 13);  ///< Independent or Complementary Pair Operation
        constexpr uint32_t WAITEN = (1U << 14);  ///< WAIT Enable
        constexpr uint32_t DBGEN = (1U << 15);  ///< Debug Enable
    }

    /// SM%sCTRL Register bits
    namespace sm%sctrl_bits {
        constexpr uint32_t DBLEN = (1U << 0);  ///< Double Switching Enable
        constexpr uint32_t DBLX = (1U << 1);  ///< PWMX Double Switching Enable
        constexpr uint32_t LDMOD = (1U << 2);  ///< Load Mode Select
        constexpr uint32_t PRSC = (3 << 4);  ///< Prescaler
        constexpr uint32_t DT = (2 << 8);  ///< Deadtime
        constexpr uint32_t FULL = (1U << 10);  ///< Full Cycle Reload
        constexpr uint32_t HALF = (1U << 11);  ///< Half Cycle Reload
        constexpr uint32_t LDFQ = (4 << 12);  ///< Load Frequency
    }

    /// SM%sVAL0 Register bits
    namespace sm%sval0_bits {
        constexpr uint32_t VAL0 = (16 << 0);  ///< Value Register 0
    }

    /// SM%sFRACVAL1 Register bits
    namespace sm%sfracval1_bits {
        constexpr uint32_t FRACVAL1 = (5 << 11);  ///< Fractional Value 1 Register
    }

    /// SM%sVAL1 Register bits
    namespace sm%sval1_bits {
        constexpr uint32_t VAL1 = (16 << 0);  ///< Value Register 1
    }

    /// SM%sFRACVAL2 Register bits
    namespace sm%sfracval2_bits {
        constexpr uint32_t FRACVAL2 = (5 << 11);  ///< Fractional Value 2
    }

    /// SM%sVAL2 Register bits
    namespace sm%sval2_bits {
        constexpr uint32_t VAL2 = (16 << 0);  ///< Value Register 2
    }

    /// SM%sFRACVAL3 Register bits
    namespace sm%sfracval3_bits {
        constexpr uint32_t FRACVAL3 = (5 << 11);  ///< Fractional Value 3
    }

    /// SM%sVAL3 Register bits
    namespace sm%sval3_bits {
        constexpr uint32_t VAL3 = (16 << 0);  ///< Value Register 3
    }

    /// SM%sFRACVAL4 Register bits
    namespace sm%sfracval4_bits {
        constexpr uint32_t FRACVAL4 = (5 << 11);  ///< Fractional Value 4
    }

    /// SM%sVAL4 Register bits
    namespace sm%sval4_bits {
        constexpr uint32_t VAL4 = (16 << 0);  ///< Value Register 4
    }

    /// SM%sFRACVAL5 Register bits
    namespace sm%sfracval5_bits {
        constexpr uint32_t FRACVAL5 = (5 << 11);  ///< Fractional Value 5
    }

    /// SM%sVAL5 Register bits
    namespace sm%sval5_bits {
        constexpr uint32_t VAL5 = (16 << 0);  ///< Value Register 5
    }

    /// SM%sFRCTRL Register bits
    namespace sm%sfrctrl_bits {
        constexpr uint32_t FRAC1_EN = (1U << 1);  ///< Fractional Cycle PWM Period Enable
        constexpr uint32_t FRAC23_EN = (1U << 2);  ///< Fractional Cycle Placement Enable for PWM_A
        constexpr uint32_t FRAC45_EN = (1U << 4);  ///< Fractional Cycle Placement Enable for PWM_B
        constexpr uint32_t FRAC_PU = (1U << 8);  ///< Fractional Delay Circuit Power Up
        constexpr uint32_t TEST = (1U << 15);  ///< Test Status Bit
    }

    /// SM%sOCTRL Register bits
    namespace sm%soctrl_bits {
        constexpr uint32_t PWMXFS = (2 << 0);  ///< PWM_X Fault State
        constexpr uint32_t PWMBFS = (2 << 2);  ///< PWM_B Fault State
        constexpr uint32_t PWMAFS = (2 << 4);  ///< PWM_A Fault State
        constexpr uint32_t POLX = (1U << 8);  ///< PWM_X Output Polarity
        constexpr uint32_t POLB = (1U << 9);  ///< PWM_B Output Polarity
        constexpr uint32_t POLA = (1U << 10);  ///< PWM_A Output Polarity
        constexpr uint32_t PWMX_IN = (1U << 13);  ///< PWM_X Input
        constexpr uint32_t PWMB_IN = (1U << 14);  ///< PWM_B Input
        constexpr uint32_t PWMA_IN = (1U << 15);  ///< PWM_A Input
    }

    /// SM%sSTS Register bits
    namespace sm%ssts_bits {
        constexpr uint32_t CMPF = (6 << 0);  ///< Compare Flags
        constexpr uint32_t CFX0 = (1U << 6);  ///< Capture Flag X0
        constexpr uint32_t CFX1 = (1U << 7);  ///< Capture Flag X1
        constexpr uint32_t CFB0 = (1U << 8);  ///< Capture Flag B0
        constexpr uint32_t CFB1 = (1U << 9);  ///< Capture Flag B1
        constexpr uint32_t CFA0 = (1U << 10);  ///< Capture Flag A0
        constexpr uint32_t CFA1 = (1U << 11);  ///< Capture Flag A1
        constexpr uint32_t RF = (1U << 12);  ///< Reload Flag
        constexpr uint32_t REF = (1U << 13);  ///< Reload Error Flag
        constexpr uint32_t RUF = (1U << 14);  ///< Registers Updated Flag
    }

    /// SM%sINTEN Register bits
    namespace sm%sinten_bits {
        constexpr uint32_t CMPIE = (6 << 0);  ///< Compare Interrupt Enables
        constexpr uint32_t CX0IE = (1U << 6);  ///< Capture X 0 Interrupt Enable
        constexpr uint32_t CX1IE = (1U << 7);  ///< Capture X 1 Interrupt Enable
        constexpr uint32_t CB0IE = (1U << 8);  ///< Capture B 0 Interrupt Enable
        constexpr uint32_t CB1IE = (1U << 9);  ///< Capture B 1 Interrupt Enable
        constexpr uint32_t CA0IE = (1U << 10);  ///< Capture A 0 Interrupt Enable
        constexpr uint32_t CA1IE = (1U << 11);  ///< Capture A 1 Interrupt Enable
        constexpr uint32_t RIE = (1U << 12);  ///< Reload Interrupt Enable
        constexpr uint32_t REIE = (1U << 13);  ///< Reload Error Interrupt Enable
    }

    /// SM%sDMAEN Register bits
    namespace sm%sdmaen_bits {
        constexpr uint32_t CX0DE = (1U << 0);  ///< Capture X0 FIFO DMA Enable
        constexpr uint32_t CX1DE = (1U << 1);  ///< Capture X1 FIFO DMA Enable
        constexpr uint32_t CB0DE = (1U << 2);  ///< Capture B0 FIFO DMA Enable
        constexpr uint32_t CB1DE = (1U << 3);  ///< Capture B1 FIFO DMA Enable
        constexpr uint32_t CA0DE = (1U << 4);  ///< Capture A0 FIFO DMA Enable
        constexpr uint32_t CA1DE = (1U << 5);  ///< Capture A1 FIFO DMA Enable
        constexpr uint32_t CAPTDE = (2 << 6);  ///< Capture DMA Enable Source Select
        constexpr uint32_t FAND = (1U << 8);  ///< FIFO Watermark AND Control
        constexpr uint32_t VALDE = (1U << 9);  ///< Value Registers DMA Enable
    }

    /// SM%sTCTRL Register bits
    namespace sm%stctrl_bits {
        constexpr uint32_t OUT_TRIG_EN = (6 << 0);  ///< Output Trigger Enables
        constexpr uint32_t TRGFRQ = (1U << 12);  ///< Trigger frequency
        constexpr uint32_t PWBOT1 = (1U << 14);  ///< Output Trigger 1 Source Select
        constexpr uint32_t PWAOT0 = (1U << 15);  ///< Output Trigger 0 Source Select
    }

    /// SM%sDISMAP0 Register bits
    namespace sm%sdismap0_bits {
        constexpr uint32_t DIS0A = (4 << 0);  ///< PWM_A Fault Disable Mask 0
        constexpr uint32_t DIS0B = (4 << 4);  ///< PWM_B Fault Disable Mask 0
        constexpr uint32_t DIS0X = (4 << 8);  ///< PWM_X Fault Disable Mask 0
    }

    /// SM%sDTCNT0 Register bits
    namespace sm%sdtcnt0_bits {
        constexpr uint32_t DTCNT0 = (16 << 0);  ///< The DTCNT0 field is interpreted differently depending on whether or not the fractional delays are being used (FRCNTRL[FRAC23_EN] is set)
    }

    /// SM%sDTCNT1 Register bits
    namespace sm%sdtcnt1_bits {
        constexpr uint32_t DTCNT1 = (16 << 0);  ///< The DTCNT1 field is interpreted differently depending on whether or not the fractional delays are being used (FRCNTRL[FRAC45_EN] is set)
    }

    /// SM%sCAPTCTRLA Register bits
    namespace sm%scaptctrla_bits {
        constexpr uint32_t ARMA = (1U << 0);  ///< Arm A
        constexpr uint32_t ONESHOTA = (1U << 1);  ///< One Shot Mode A
        constexpr uint32_t EDGA0 = (2 << 2);  ///< Edge A 0
        constexpr uint32_t EDGA1 = (2 << 4);  ///< Edge A 1
        constexpr uint32_t INP_SELA = (1U << 6);  ///< Input Select A
        constexpr uint32_t EDGCNTA_EN = (1U << 7);  ///< Edge Counter A Enable
        constexpr uint32_t CFAWM = (2 << 8);  ///< Capture A FIFOs Water Mark
        constexpr uint32_t CA0CNT = (3 << 10);  ///< Capture A0 FIFO Word Count
        constexpr uint32_t CA1CNT = (3 << 13);  ///< Capture A1 FIFO Word Count
    }

    /// SM%sCAPTCOMPA Register bits
    namespace sm%scaptcompa_bits {
        constexpr uint32_t EDGCMPA = (8 << 0);  ///< Edge Compare A
        constexpr uint32_t EDGCNTA = (8 << 8);  ///< Edge Counter A
    }

    /// SM%sCAPTCTRLB Register bits
    namespace sm%scaptctrlb_bits {
        constexpr uint32_t ARMB = (1U << 0);  ///< Arm B
        constexpr uint32_t ONESHOTB = (1U << 1);  ///< One Shot Mode B
        constexpr uint32_t EDGB0 = (2 << 2);  ///< Edge B 0
        constexpr uint32_t EDGB1 = (2 << 4);  ///< Edge B 1
        constexpr uint32_t INP_SELB = (1U << 6);  ///< Input Select B
        constexpr uint32_t EDGCNTB_EN = (1U << 7);  ///< Edge Counter B Enable
        constexpr uint32_t CFBWM = (2 << 8);  ///< Capture B FIFOs Water Mark
        constexpr uint32_t CB0CNT = (3 << 10);  ///< Capture B0 FIFO Word Count
        constexpr uint32_t CB1CNT = (3 << 13);  ///< Capture B1 FIFO Word Count
    }

    /// SM%sCAPTCOMPB Register bits
    namespace sm%scaptcompb_bits {
        constexpr uint32_t EDGCMPB = (8 << 0);  ///< Edge Compare B
        constexpr uint32_t EDGCNTB = (8 << 8);  ///< Edge Counter B
    }

    /// SM%sCAPTCTRLX Register bits
    namespace sm%scaptctrlx_bits {
        constexpr uint32_t ARMX = (1U << 0);  ///< Arm X
        constexpr uint32_t ONESHOTX = (1U << 1);  ///< One Shot Mode Aux
        constexpr uint32_t EDGX0 = (2 << 2);  ///< Edge X 0
        constexpr uint32_t EDGX1 = (2 << 4);  ///< Edge X 1
        constexpr uint32_t INP_SELX = (1U << 6);  ///< Input Select X
        constexpr uint32_t EDGCNTX_EN = (1U << 7);  ///< Edge Counter X Enable
        constexpr uint32_t CFXWM = (2 << 8);  ///< Capture X FIFOs Water Mark
        constexpr uint32_t CX0CNT = (3 << 10);  ///< Capture X0 FIFO Word Count
        constexpr uint32_t CX1CNT = (3 << 13);  ///< Capture X1 FIFO Word Count
    }

    /// SM%sCAPTCOMPX Register bits
    namespace sm%scaptcompx_bits {
        constexpr uint32_t EDGCMPX = (8 << 0);  ///< Edge Compare X
        constexpr uint32_t EDGCNTX = (8 << 8);  ///< Edge Counter X
    }

    /// SM%sCVAL0 Register bits
    namespace sm%scval0_bits {
        constexpr uint32_t CAPTVAL0 = (16 << 0);  ///< This read-only register stores the value captured from the submodule counter
    }

    /// SM%sCVAL0CYC Register bits
    namespace sm%scval0cyc_bits {
        constexpr uint32_t CVAL0CYC = (4 << 0);  ///< This read-only register stores the cycle number corresponding to the value captured in CVAL0
    }

    /// SM%sCVAL1 Register bits
    namespace sm%scval1_bits {
        constexpr uint32_t CAPTVAL1 = (16 << 0);  ///< This read-only register stores the value captured from the submodule counter
    }

    /// SM%sCVAL1CYC Register bits
    namespace sm%scval1cyc_bits {
        constexpr uint32_t CVAL1CYC = (4 << 0);  ///< This read-only register stores the cycle number corresponding to the value captured in CVAL1
    }

    /// SM%sCVAL2 Register bits
    namespace sm%scval2_bits {
        constexpr uint32_t CAPTVAL2 = (16 << 0);  ///< This read-only register stores the value captured from the submodule counter
    }

    /// SM%sCVAL2CYC Register bits
    namespace sm%scval2cyc_bits {
        constexpr uint32_t CVAL2CYC = (4 << 0);  ///< This read-only register stores the cycle number corresponding to the value captured in CVAL2
    }

    /// SM%sCVAL3 Register bits
    namespace sm%scval3_bits {
        constexpr uint32_t CAPTVAL3 = (16 << 0);  ///< This read-only register stores the value captured from the submodule counter
    }

    /// SM%sCVAL3CYC Register bits
    namespace sm%scval3cyc_bits {
        constexpr uint32_t CVAL3CYC = (4 << 0);  ///< This read-only register stores the cycle number corresponding to the value captured in CVAL3
    }

    /// SM%sCVAL4 Register bits
    namespace sm%scval4_bits {
        constexpr uint32_t CAPTVAL4 = (16 << 0);  ///< This read-only register stores the value captured from the submodule counter
    }

    /// SM%sCVAL4CYC Register bits
    namespace sm%scval4cyc_bits {
        constexpr uint32_t CVAL4CYC = (4 << 0);  ///< This read-only register stores the cycle number corresponding to the value captured in CVAL4
    }

    /// SM%sCVAL5 Register bits
    namespace sm%scval5_bits {
        constexpr uint32_t CAPTVAL5 = (16 << 0);  ///< This read-only register stores the value captured from the submodule counter
    }

    /// SM%sCVAL5CYC Register bits
    namespace sm%scval5cyc_bits {
        constexpr uint32_t CVAL5CYC = (4 << 0);  ///< This read-only register stores the cycle number corresponding to the value captured in CVAL5
    }

    /// OUTEN Register bits
    namespace outen_bits {
        constexpr uint32_t PWMX_EN = (4 << 0);  ///< PWM_X Output Enables
        constexpr uint32_t PWMB_EN = (4 << 4);  ///< PWM_B Output Enables
        constexpr uint32_t PWMA_EN = (4 << 8);  ///< PWM_A Output Enables
    }

    /// MASK Register bits
    namespace mask_bits {
        constexpr uint32_t MASKX = (4 << 0);  ///< PWM_X Masks
        constexpr uint32_t MASKB = (4 << 4);  ///< PWM_B Masks
        constexpr uint32_t MASKA = (4 << 8);  ///< PWM_A Masks
        constexpr uint32_t UPDATE_MASK = (4 << 12);  ///< Update Mask Bits Immediately
    }

    /// SWCOUT Register bits
    namespace swcout_bits {
        constexpr uint32_t SM0OUT45 = (1U << 0);  ///< Submodule 0 Software Controlled Output 45
        constexpr uint32_t SM0OUT23 = (1U << 1);  ///< Submodule 0 Software Controlled Output 23
        constexpr uint32_t SM1OUT45 = (1U << 2);  ///< Submodule 1 Software Controlled Output 45
        constexpr uint32_t SM1OUT23 = (1U << 3);  ///< Submodule 1 Software Controlled Output 23
        constexpr uint32_t SM2OUT45 = (1U << 4);  ///< Submodule 2 Software Controlled Output 45
        constexpr uint32_t SM2OUT23 = (1U << 5);  ///< Submodule 2 Software Controlled Output 23
        constexpr uint32_t SM3OUT45 = (1U << 6);  ///< Submodule 3 Software Controlled Output 45
        constexpr uint32_t SM3OUT23 = (1U << 7);  ///< Submodule 3 Software Controlled Output 23
    }

    /// DTSRCSEL Register bits
    namespace dtsrcsel_bits {
        constexpr uint32_t SM0SEL45 = (2 << 0);  ///< Submodule 0 PWM45 Control Select
        constexpr uint32_t SM0SEL23 = (2 << 2);  ///< Submodule 0 PWM23 Control Select
        constexpr uint32_t SM1SEL45 = (2 << 4);  ///< Submodule 1 PWM45 Control Select
        constexpr uint32_t SM1SEL23 = (2 << 6);  ///< Submodule 1 PWM23 Control Select
        constexpr uint32_t SM2SEL45 = (2 << 8);  ///< Submodule 2 PWM45 Control Select
        constexpr uint32_t SM2SEL23 = (2 << 10);  ///< Submodule 2 PWM23 Control Select
        constexpr uint32_t SM3SEL45 = (2 << 12);  ///< Submodule 3 PWM45 Control Select
        constexpr uint32_t SM3SEL23 = (2 << 14);  ///< Submodule 3 PWM23 Control Select
    }

    /// MCTRL0 Register bits
    namespace mctrl0_bits {
        constexpr uint32_t LDOK = (4 << 0);  ///< Load Okay
        constexpr uint32_t CLDOK = (4 << 4);  ///< Clear Load Okay
        constexpr uint32_t RUN = (4 << 8);  ///< Run
        constexpr uint32_t IPOL = (4 << 12);  ///< Current Polarity
    }

    /// MCTRL1 Register bits
    namespace mctrl1_bits {
        constexpr uint32_t MONPLL = (2 << 0);  ///< Monitor PLL State
    }

    /// FCTRL Register bits
    namespace fctrl_bits {
        constexpr uint32_t FIE = (4 << 0);  ///< Fault Interrupt Enables
        constexpr uint32_t FSAFE = (4 << 4);  ///< Fault Safety Mode
        constexpr uint32_t FAUTO = (4 << 8);  ///< Automatic Fault Clearing
        constexpr uint32_t FLVL = (4 << 12);  ///< Fault Level
    }

    /// FSTS Register bits
    namespace fsts_bits {
        constexpr uint32_t FFLAG = (4 << 0);  ///< Fault Flags
        constexpr uint32_t FFULL = (4 << 4);  ///< Full Cycle
        constexpr uint32_t FFPIN = (4 << 8);  ///< Filtered Fault Pins
        constexpr uint32_t FHALF = (4 << 12);  ///< Half Cycle Fault Recovery
    }

    /// FFILT Register bits
    namespace ffilt_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Fault Filter Period
        constexpr uint32_t FILT_CNT = (3 << 8);  ///< Fault Filter Count
        constexpr uint32_t GSTR = (1U << 15);  ///< Fault Glitch Stretch Enable
    }

    /// FTST Register bits
    namespace ftst_bits {
        constexpr uint32_t FTEST = (1U << 0);  ///< Fault Test
    }

    /// FCTRL2 Register bits
    namespace fctrl2_bits {
        constexpr uint32_t NOCOMB = (4 << 0);  ///< No Combinational Path From Fault Input To PWM Output
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT_BASE = 0x40037000;
    constexpr uint32_t LPTMR0_BASE = 0x40040000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LTMR64H;  ///< Offset: 0xE0 - PIT Upper Lifetime Timer Register
        volatile uint32_t LTMR64L;  ///< Offset: 0xE4 - PIT Lower Lifetime Timer Register
        volatile uint32_t LDVAL%s;  ///< Offset: 0x100 - Timer Load Value Register
        volatile uint32_t CVAL%s;  ///< Offset: 0x104 - Current Timer Value Register
        volatile uint32_t TCTRL%s;  ///< Offset: 0x108 - Timer Control Register
        volatile uint32_t TFLG%s;  ///< Offset: 0x10C - Timer Flag Register
    };

    /// Peripheral instances
    inline Registers* PIT = reinterpret_cast<Registers*>(PIT_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable - (PIT section)
    }

    /// LTMR64H Register bits
    namespace ltmr64h_bits {
        constexpr uint32_t LTH = (32 << 0);  ///< Life Timer value
    }

    /// LTMR64L Register bits
    namespace ltmr64l_bits {
        constexpr uint32_t LTL = (32 << 0);  ///< Life Timer value
    }

    /// LDVAL%s Register bits
    namespace ldval%s_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value
    }

    /// CVAL%s Register bits
    namespace cval%s_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL%s Register bits
    namespace tctrl%s_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable
        constexpr uint32_t CHN = (1U << 2);  ///< Chain Mode
    }

    /// TFLG%s Register bits
    namespace tflg%s_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;
    constexpr uint32_t HSADC0_BASE = 0x4005C000;
    constexpr uint32_t HSADC1_BASE = 0x400DC000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1%s;  ///< Offset: 0x00 - ADC Status and Control Registers 1
        volatile uint32_t CFG1;  ///< Offset: 0x08 - ADC Configuration Register 1
        volatile uint32_t CFG2;  ///< Offset: 0x0C - ADC Configuration Register 2
        volatile uint32_t R%s;  ///< Offset: 0x10 - ADC Data Result Register
        volatile uint32_t CV%s;  ///< Offset: 0x18 - Compare Value Registers
        volatile uint32_t SC2;  ///< Offset: 0x20 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x24 - Status and Control Register 3
        volatile uint32_t OFS;  ///< Offset: 0x28 - ADC Offset Correction Register
        volatile uint32_t PG;  ///< Offset: 0x2C - ADC Plus-Side Gain Register
        volatile uint32_t MG;  ///< Offset: 0x30 - ADC Minus-Side Gain Register
        volatile uint32_t CLPD;  ///< Offset: 0x34 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPS;  ///< Offset: 0x38 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP4;  ///< Offset: 0x3C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP3;  ///< Offset: 0x40 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2;  ///< Offset: 0x44 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1;  ///< Offset: 0x48 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0;  ///< Offset: 0x4C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLMD;  ///< Offset: 0x54 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLMS;  ///< Offset: 0x58 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM4;  ///< Offset: 0x5C - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM3;  ///< Offset: 0x60 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM2;  ///< Offset: 0x64 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM1;  ///< Offset: 0x68 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM0;  ///< Offset: 0x6C - ADC Minus-Side General Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* HSADC0 = reinterpret_cast<Registers*>(HSADC0_BASE);
    inline Registers* HSADC1 = reinterpret_cast<Registers*>(HSADC1_BASE);

    // Bit definitions
    /// SC1%s Register bits
    namespace sc1%s_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t DIFF = (1U << 5);  ///< Differential Mode Enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Sample Time Configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-Power Configuration
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t ADLSTS = (2 << 0);  ///< Long Sample Time Select
        constexpr uint32_t ADHSC = (1U << 2);  ///< High-Speed Configuration
        constexpr uint32_t ADACKEN = (1U << 3);  ///< Asynchronous Clock Output Enable
        constexpr uint32_t MUXSEL = (1U << 4);  ///< ADC Mux Select
    }

    /// R%s Register bits
    namespace r%s_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data result
    }

    /// CV%s Register bits
    namespace cv%s_bits {
        constexpr uint32_t CV = (16 << 0);  ///< Compare Value.
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage Reference Selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA Enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare Function Range Enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware Average Select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware Average Enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous Conversion Enable
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration Failed Flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset Error Correction Value
    }

    /// PG Register bits
    namespace pg_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Plus-Side Gain
    }

    /// MG Register bits
    namespace mg_bits {
        constexpr uint32_t MG = (16 << 0);  ///< Minus-Side Gain
    }

    /// CLPD Register bits
    namespace clpd_bits {
        constexpr uint32_t CLPD = (6 << 0);  ///< Calibration Value
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (6 << 0);  ///< Calibration Value
    }

    /// CLP4 Register bits
    namespace clp4_bits {
        constexpr uint32_t CLP4 = (10 << 0);  ///< Calibration Value
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (9 << 0);  ///< Calibration Value
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (8 << 0);  ///< Calibration Value
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (7 << 0);  ///< Calibration Value
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (6 << 0);  ///< Calibration Value
    }

    /// CLMD Register bits
    namespace clmd_bits {
        constexpr uint32_t CLMD = (6 << 0);  ///< Calibration Value
    }

    /// CLMS Register bits
    namespace clms_bits {
        constexpr uint32_t CLMS = (6 << 0);  ///< Calibration Value
    }

    /// CLM4 Register bits
    namespace clm4_bits {
        constexpr uint32_t CLM4 = (10 << 0);  ///< Calibration Value
    }

    /// CLM3 Register bits
    namespace clm3_bits {
        constexpr uint32_t CLM3 = (9 << 0);  ///< Calibration Value
    }

    /// CLM2 Register bits
    namespace clm2_bits {
        constexpr uint32_t CLM2 = (8 << 0);  ///< Calibration Value
    }

    /// CLM1 Register bits
    namespace clm1_bits {
        constexpr uint32_t CLM1 = (7 << 0);  ///< Calibration Value
    }

    /// CLM0 Register bits
    namespace clm0_bits {
        constexpr uint32_t CLM0 = (6 << 0);  ///< Calibration Value
    }

}

// ============================================================================
// RFVBAT Peripheral
// ============================================================================

namespace rfvbat {
    /// Base addresses
    constexpr uint32_t RFVBAT_BASE = 0x4003E000;

    /// RFVBAT Register structure
    struct Registers {
        volatile uint32_t REG%s;  ///< Offset: 0x00 - VBAT register file register
    };

    /// Peripheral instances
    inline Registers* RFVBAT = reinterpret_cast<Registers*>(RFVBAT_BASE);

    // Bit definitions
    /// REG%s Register bits
    namespace reg%s_bits {
        constexpr uint32_t LL = (8 << 0);  ///< Low lower byte
        constexpr uint32_t LH = (8 << 8);  ///< Low higher byte
        constexpr uint32_t HL = (8 << 16);  ///< High lower byte
        constexpr uint32_t HH = (8 << 24);  ///< High higher byte
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC0_BASE = 0x4003F000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DAT%sL;  ///< Offset: 0x00 - DAC Data Low Register
        volatile uint32_t DAT%sH;  ///< Offset: 0x01 - DAC Data High Register
        volatile uint32_t SR;  ///< Offset: 0x20 - DAC Status Register
        volatile uint32_t C0;  ///< Offset: 0x21 - DAC Control Register
        volatile uint32_t C1;  ///< Offset: 0x22 - DAC Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x23 - DAC Control Register 2
    };

    /// Peripheral instances
    inline Registers* DAC0 = reinterpret_cast<Registers*>(DAC0_BASE);

    // Bit definitions
    /// DAT%sL Register bits
    namespace dat%sl_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0
    }

    /// DAT%sH Register bits
    namespace dat%sh_bits {
        constexpr uint32_t DATA1 = (4 << 0);  ///< DATA1
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DACBFRPBF = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Position Flag
        constexpr uint32_t DACBFRPTF = (1U << 1);  ///< DAC Buffer Read Pointer Top Position Flag
        constexpr uint32_t DACBFWMF = (1U << 2);  ///< DAC Buffer Watermark Flag
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t DACBBIEN = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Flag Interrupt Enable
        constexpr uint32_t DACBTIEN = (1U << 1);  ///< DAC Buffer Read Pointer Top Flag Interrupt Enable
        constexpr uint32_t DACBWIEN = (1U << 2);  ///< DAC Buffer Watermark Interrupt Enable
        constexpr uint32_t LPEN = (1U << 3);  ///< DAC Low Power Control
        constexpr uint32_t DACSWTRG = (1U << 4);  ///< DAC Software Trigger
        constexpr uint32_t DACTRGSEL = (1U << 5);  ///< DAC Trigger Select
        constexpr uint32_t DACRFS = (1U << 6);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DACBFEN = (1U << 0);  ///< DAC Buffer Enable
        constexpr uint32_t DACBFMD = (2 << 1);  ///< DAC Buffer Work Mode Select
        constexpr uint32_t DACBFWM = (2 << 3);  ///< DAC Buffer Watermark Select
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA Enable Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t DACBFUP = (4 << 0);  ///< DAC Buffer Upper Limit
        constexpr uint32_t DACBFRP = (4 << 4);  ///< DAC Buffer Read Pointer
    }

}

// ============================================================================
// RFSYS Peripheral
// ============================================================================

namespace rfsys {
    /// Base addresses
    constexpr uint32_t RFSYS_BASE = 0x40041000;

    /// RFSYS Register structure
    struct Registers {
        volatile uint32_t REG%s;  ///< Offset: 0x00 - Register file register
    };

    /// Peripheral instances
    inline Registers* RFSYS = reinterpret_cast<Registers*>(RFSYS_BASE);

    // Bit definitions
    /// REG%s Register bits
    namespace reg%s_bits {
        constexpr uint32_t LL = (8 << 0);  ///< Low lower byte
        constexpr uint32_t LH = (8 << 8);  ///< Low higher byte
        constexpr uint32_t HL = (8 << 16);  ///< High lower byte
        constexpr uint32_t HH = (8 << 24);  ///< High higher byte
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40047000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT1;  ///< Offset: 0x00 - System Options Register 1
        volatile uint32_t SOPT2;  ///< Offset: 0x1004 - System Options Register 2
        volatile uint32_t SOPT4;  ///< Offset: 0x100C - System Options Register 4
        volatile uint32_t SOPT5;  ///< Offset: 0x1010 - System Options Register 5
        volatile uint32_t SOPT7;  ///< Offset: 0x1018 - System Options Register 7
        volatile uint32_t SOPT8;  ///< Offset: 0x101C - System Options Register 8
        volatile uint32_t SOPT9;  ///< Offset: 0x1020 - System Options Register 9
        volatile uint32_t SDID;  ///< Offset: 0x1024 - System Device Identification Register
        volatile uint32_t SCGC1;  ///< Offset: 0x1028 - System Clock Gating Control Register 1
        volatile uint32_t SCGC2;  ///< Offset: 0x102C - System Clock Gating Control Register 2
        volatile uint32_t SCGC3;  ///< Offset: 0x1030 - System Clock Gating Control Register 3
        volatile uint32_t SCGC4;  ///< Offset: 0x1034 - System Clock Gating Control Register 4
        volatile uint32_t SCGC5;  ///< Offset: 0x1038 - System Clock Gating Control Register 5
        volatile uint32_t SCGC6;  ///< Offset: 0x103C - System Clock Gating Control Register 6
        volatile uint32_t SCGC7;  ///< Offset: 0x1040 - System Clock Gating Control Register 7
        volatile uint32_t CLKDIV1;  ///< Offset: 0x1044 - System Clock Divider Register 1
        volatile uint32_t FCFG1;  ///< Offset: 0x104C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x1050 - Flash Configuration Register 2
        volatile uint32_t UIDH;  ///< Offset: 0x1054 - Unique Identification Register High
        volatile uint32_t UIDMH;  ///< Offset: 0x1058 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x105C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x1060 - Unique Identification Register Low
        volatile uint32_t CLKDIV4;  ///< Offset: 0x1068 - System Clock Divider Register 4
        volatile uint32_t MISCTRL0;  ///< Offset: 0x106C - Miscellaneous Control Register 0
        volatile uint32_t MISCTRL1;  ///< Offset: 0x1070 - Miscellaneous Control Register 1
        volatile uint32_t WDOGC;  ///< Offset: 0x1100 - WDOG Control Register
        volatile uint32_t PWRC;  ///< Offset: 0x1104 - Power Control Register
        volatile uint32_t ADCOPT;  ///< Offset: 0x1108 - ADC Additional Option Register
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t RAMSIZE = (4 << 12);  ///< RAM size
        constexpr uint32_t OSC32KSEL = (2 << 18);  ///< 32K oscillator clock select
    }

    /// SOPT2 Register bits
    namespace sopt2_bits {
        constexpr uint32_t CLKOUTSEL = (3 << 5);  ///< CLKOUT select
        constexpr uint32_t FBSL = (2 << 8);  ///< FlexBus security level
        constexpr uint32_t TRACECLKSEL = (1U << 12);  ///< Debug trace clock select
        constexpr uint32_t PLLFLLSEL = (2 << 16);  ///< PLL/FLL clock select
        constexpr uint32_t RMIISRC = (1U << 19);  ///< RMII clock source select
        constexpr uint32_t TIMESRC = (2 << 20);  ///< IEEE 1588 timestamp clock source select
    }

    /// SOPT4 Register bits
    namespace sopt4_bits {
        constexpr uint32_t FTM0FLT0 = (1U << 0);  ///< FTM0 Fault 0 Select
        constexpr uint32_t FTM0FLT1 = (1U << 1);  ///< FTM0 Fault 1 Select
        constexpr uint32_t FTM0FLT2 = (1U << 2);  ///< FTM0 Fault 2 Select
        constexpr uint32_t FTM0FLT3 = (1U << 3);  ///< Selects the source of FTM0 fault 3
        constexpr uint32_t FTM1FLT0 = (1U << 4);  ///< FTM1 Fault 0 Select
        constexpr uint32_t FTM2FLT0 = (1U << 8);  ///< FTM2 Fault 0 Select
        constexpr uint32_t FTM3FLT0 = (1U << 12);  ///< FTM3 Fault 0 Select
        constexpr uint32_t FTM0TRG0SRC = (1U << 16);  ///< FlexTimer 0 Hardware Trigger 0 Source Select
        constexpr uint32_t FTM0TRG1SRC = (1U << 17);  ///< FlexTimer 0 Hardware Trigger 1 Source Select
        constexpr uint32_t FTM0TRG2SRC = (1U << 18);  ///< FlexTimer 0 Hardware Trigger 2 Source Select
        constexpr uint32_t FTM1TRG0SRC = (1U << 20);  ///< FlexTimer 1 Hardware Trigger 0 Source Select
        constexpr uint32_t FTM1TRG2SRC = (1U << 22);  ///< FlexTimer 1 Hardware Trigger 2 Source Select
        constexpr uint32_t FTM2TRG0SRC = (1U << 24);  ///< FlexTimer 2 Hardware Trigger 0 Source Select
        constexpr uint32_t FTM2TRG2SRC = (1U << 26);  ///< FlexTimer 2 Hardware Trigger 2 Source Select
        constexpr uint32_t FTM3TRG0SRC = (1U << 28);  ///< FlexTimer 3 Hardware Trigger 0 Source Select
        constexpr uint32_t FTM3TRG1SRC = (1U << 29);  ///< FlexTimer 3 Hardware Trigger 1 Source Select
        constexpr uint32_t FTM3TRG2SRC = (1U << 30);  ///< FlexTimer 3 Hardware Trigger 2 Source Select
    }

    /// SOPT5 Register bits
    namespace sopt5_bits {
        constexpr uint32_t UART0TXSRC = (2 << 0);  ///< UART 0 transmit data source select
        constexpr uint32_t UART0RXSRC = (2 << 2);  ///< UART 0 receive data source select
        constexpr uint32_t UART1TXSRC = (2 << 4);  ///< UART 1 transmit data source select
        constexpr uint32_t UART1RXSRC = (2 << 6);  ///< UART 1 receive data source select
    }

    /// SOPT7 Register bits
    namespace sopt7_bits {
        constexpr uint32_t HSADC0ATRGSEL = (4 << 0);  ///< HSADC0A trigger select
        constexpr uint32_t HSADC0AALTTRGEN = (2 << 6);  ///< HSADC0A alternate trigger enable
        constexpr uint32_t HSADC0BTRGSEL = (4 << 8);  ///< HSADC0B trigger select
        constexpr uint32_t HSADC0BALTTRGEN = (2 << 14);  ///< HSADC0B alternate trigger enable
        constexpr uint32_t HSADC1ATRGSEL = (4 << 16);  ///< HSADC1A trigger select
        constexpr uint32_t HSADC1AALTTRGEN = (2 << 22);  ///< HSADC1A alternate trigger enable
        constexpr uint32_t HSADC1BTRGSEL = (4 << 24);  ///< HSADC1B trigger select
        constexpr uint32_t HSADC1BALTTRGEN = (2 << 30);  ///< HSADC1B alternate trigger enable
    }

    /// SOPT8 Register bits
    namespace sopt8_bits {
        constexpr uint32_t FTM0SYNCBIT = (1U << 0);  ///< FTM0 Hardware Trigger 0 Software Synchronization
        constexpr uint32_t FTM1SYNCBIT = (1U << 1);  ///< FTM1 Hardware Trigger 0 Software Synchronization
        constexpr uint32_t FTM2SYNCBIT = (1U << 2);  ///< FTM2 Hardware Trigger 0 Software Synchronization
        constexpr uint32_t FTM3SYNCBIT = (1U << 3);  ///< FTM3 Hardware Trigger 0 Software Synchronization
        constexpr uint32_t FTM0CFSEL = (1U << 8);  ///< Carrier frequency selection for FTM0 output channel
        constexpr uint32_t FTM3CFSEL = (1U << 9);  ///< Carrier frequency selection for FTM3 output channel
        constexpr uint32_t FTM0OCH0SRC = (1U << 16);  ///< FTM0 channel 0 output source
        constexpr uint32_t FTM0OCH1SRC = (1U << 17);  ///< FTM0 channel 1 output source
        constexpr uint32_t FTM0OCH2SRC = (1U << 18);  ///< FTM0 channel 2 output source
        constexpr uint32_t FTM0OCH3SRC = (1U << 19);  ///< FTM0 channel 3 output source
        constexpr uint32_t FTM0OCH4SRC = (1U << 20);  ///< FTM0 channel 4 output source
        constexpr uint32_t FTM0OCH5SRC = (1U << 21);  ///< FTM0 channel 5 output source
        constexpr uint32_t FTM0OCH6SRC = (1U << 22);  ///< FTM0 channel 6 output source
        constexpr uint32_t FTM0OCH7SRC = (1U << 23);  ///< FTM0 channel 7 output source
        constexpr uint32_t FTM3OCH0SRC = (1U << 24);  ///< FTM3 channel 0 output source
        constexpr uint32_t FTM3OCH1SRC = (1U << 25);  ///< FTM3 channel 1 output source
        constexpr uint32_t FTM3OCH2SRC = (1U << 26);  ///< FTM3 channel 2 output source
        constexpr uint32_t FTM3OCH3SRC = (1U << 27);  ///< FTM3 channel 3 output source
        constexpr uint32_t FTM3OCH4SRC = (1U << 28);  ///< FTM3 channel 4 output source
        constexpr uint32_t FTM3OCH5SRC = (1U << 29);  ///< FTM3 channel 5 output source
        constexpr uint32_t FTM3OCH6SRC = (1U << 30);  ///< FTM3 channel 6 output source
        constexpr uint32_t FTM3OCH7SRC = (1U << 31);  ///< FTM3 channel 7 output source
    }

    /// SOPT9 Register bits
    namespace sopt9_bits {
        constexpr uint32_t FTM1ICH0SRC = (2 << 4);  ///< FTM1 channel 0 input capture source select
        constexpr uint32_t FTM1ICH1SRC = (1U << 6);  ///< FTM1 channel 0 input capture source select
        constexpr uint32_t FTM2ICH0SRC = (2 << 8);  ///< FTM2 channel 0 input capture source select
        constexpr uint32_t FTM2ICH1SRC = (1U << 10);  ///< FTM2 channel 1 input capture source select
        constexpr uint32_t FTM0CLKSEL = (2 << 24);  ///< FlexTimer 0 External Clock Pin Select
        constexpr uint32_t FTM1CLKSEL = (2 << 26);  ///< FlexTimer 1 External Clock Pin Select
        constexpr uint32_t FTM2CLKSEL = (2 << 28);  ///< FlexTimer 2 External Clock Pin Select
        constexpr uint32_t FTM3CLKSEL = (2 << 30);  ///< FlexTimer 3 External Clock Pin Select
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (4 << 0);  ///< Pincount identification
        constexpr uint32_t DIEID = (5 << 7);  ///< Device die number
        constexpr uint32_t REVID = (4 << 12);  ///< Device revision number
        constexpr uint32_t SERIESID = (4 << 20);  ///< Kinetis Series ID
        constexpr uint32_t SUBFAMID = (4 << 24);  ///< Kinetis Sub-Family ID
        constexpr uint32_t FAMILYID = (4 << 28);  ///< Kinetis Family ID
    }

    /// SCGC1 Register bits
    namespace scgc1_bits {
        constexpr uint32_t UART4 = (1U << 10);  ///< UART4 Clock Gate Control
        constexpr uint32_t UART5 = (1U << 11);  ///< UART5 Clock Gate Control
        constexpr uint32_t PWM1_SM0 = (1U << 24);  ///< PWM1 submodule 0 Clock Gate Control
        constexpr uint32_t PWM1_SM1 = (1U << 25);  ///< PWM1 submodule 1 Clock Gate Control
        constexpr uint32_t PWM1_SM2 = (1U << 26);  ///< PWM1 submodule 2 Clock Gate Control
        constexpr uint32_t PWM1_SM3 = (1U << 27);  ///< PWM1 submodule 3 Clock Gate Control
    }

    /// SCGC2 Register bits
    namespace scgc2_bits {
        constexpr uint32_t ENET = (1U << 0);  ///< ENET Clock Gate Control
        constexpr uint32_t HSADC1 = (1U << 28);  ///< HSADC1 Clock Gate Control
    }

    /// SCGC3 Register bits
    namespace scgc3_bits {
        constexpr uint32_t TRNG = (1U << 0);  ///< TRNG Clock Gate Control
        constexpr uint32_t FLEXCAN2 = (1U << 4);  ///< FlexCAN2 Clock Gate Control
        constexpr uint32_t SPI2 = (1U << 12);  ///< SPI2 Clock Gate Control
    }

    /// SCGC4 Register bits
    namespace scgc4_bits {
        constexpr uint32_t EWM = (1U << 1);  ///< EWM Clock Gate Control
        constexpr uint32_t I2C0 = (1U << 6);  ///< I2C0 Clock Gate Control
        constexpr uint32_t I2C1 = (1U << 7);  ///< I2C1 Clock Gate Control
        constexpr uint32_t UART0 = (1U << 10);  ///< UART0 Clock Gate Control
        constexpr uint32_t UART1 = (1U << 11);  ///< UART1 Clock Gate Control
        constexpr uint32_t UART2 = (1U << 12);  ///< UART2 Clock Gate Control
        constexpr uint32_t UART3 = (1U << 13);  ///< UART3 Clock Gate Control
        constexpr uint32_t CMP = (1U << 19);  ///< Comparators Clock Gate Control
        constexpr uint32_t PWM0_SM0 = (1U << 24);  ///< PWM0 submodule 0 Clock Gate Control
        constexpr uint32_t PWM0_SM1 = (1U << 25);  ///< PWM0 submodule 1 Clock Gate Control
        constexpr uint32_t PWM0_SM2 = (1U << 26);  ///< PWM0 submodule 2 Clock Gate Control
        constexpr uint32_t PWM0_SM3 = (1U << 27);  ///< PWM0 submodule 3 Clock Gate Control
    }

    /// SCGC5 Register bits
    namespace scgc5_bits {
        constexpr uint32_t LPTMR = (1U << 0);  ///< Low Power Timer Access Control
        constexpr uint32_t PORTA = (1U << 9);  ///< Port A Clock Gate Control
        constexpr uint32_t PORTB = (1U << 10);  ///< Port B Clock Gate Control
        constexpr uint32_t PORTC = (1U << 11);  ///< Port C Clock Gate Control
        constexpr uint32_t PORTD = (1U << 12);  ///< Port D Clock Gate Control
        constexpr uint32_t PORTE = (1U << 13);  ///< Port E Clock Gate Control
        constexpr uint32_t ENC = (1U << 21);  ///< This bit controls the clock gate to the ENC module.
        constexpr uint32_t XBARA = (1U << 25);  ///< XBARA Clock Gate Control
        constexpr uint32_t XBARB = (1U << 26);  ///< XBARB Clock Gate Control
        constexpr uint32_t AOI = (1U << 27);  ///< AOI Clock Gate Control
        constexpr uint32_t HSADC0 = (1U << 28);  ///< HSADC0 Clock Gate Control
    }

    /// SCGC6 Register bits
    namespace scgc6_bits {
        constexpr uint32_t FTF = (1U << 0);  ///< Flash Memory Clock Gate Control
        constexpr uint32_t DMAMUX = (1U << 1);  ///< DMA Mux Clock Gate Control
        constexpr uint32_t FLEXCAN0 = (1U << 4);  ///< FlexCAN0 Clock Gate Control
        constexpr uint32_t FLEXCAN1 = (1U << 5);  ///< FlexCAN1 Clock Gate Control
        constexpr uint32_t FTM3 = (1U << 6);  ///< FTM3 Clock Gate Control
        constexpr uint32_t SPI0 = (1U << 12);  ///< SPI0 Clock Gate Control
        constexpr uint32_t SPI1 = (1U << 13);  ///< SPI1 Clock Gate Control
        constexpr uint32_t PDB1 = (1U << 17);  ///< PDB1 Clock Gate Control
        constexpr uint32_t CRC = (1U << 18);  ///< CRC Clock Gate Control
        constexpr uint32_t PDB0 = (1U << 22);  ///< PDB0 Clock Gate Control
        constexpr uint32_t PIT = (1U << 23);  ///< PIT Clock Gate Control
        constexpr uint32_t FTM0 = (1U << 24);  ///< FTM0 Clock Gate Control
        constexpr uint32_t FTM1 = (1U << 25);  ///< FTM1 Clock Gate Control
        constexpr uint32_t FTM2 = (1U << 26);  ///< FTM2 Clock Gate Control
        constexpr uint32_t ADC0 = (1U << 27);  ///< ADC0 Clock Gate Control
        constexpr uint32_t DAC0 = (1U << 31);  ///< DAC0 Clock Gate Control
    }

    /// SCGC7 Register bits
    namespace scgc7_bits {
        constexpr uint32_t FLEXBUS = (1U << 0);  ///< FlexBus Clock Gate Control
        constexpr uint32_t SMPU = (1U << 2);  ///< SMPU Clock Gate Control
        constexpr uint32_t DMA = (1U << 8);  ///< DMA Clock Gate Control
    }

    /// CLKDIV1 Register bits
    namespace clkdiv1_bits {
        constexpr uint32_t OUTDIV4 = (4 << 16);  ///< Clock 4 output divider value
        constexpr uint32_t OUTDIV3 = (4 << 20);  ///< Clock 3 output divider value
        constexpr uint32_t OUTDIV2 = (4 << 24);  ///< Clock 2 output divider value
        constexpr uint32_t OUTDIV1 = (4 << 28);  ///< Clock 1 output divider value
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FLASHDIS = (1U << 0);  ///< Flash Disable
        constexpr uint32_t FLASHDOZE = (1U << 1);  ///< Flash Doze
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program flash size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR0 = (7 << 24);  ///< Max address block 0
    }

    /// UIDH Register bits
    namespace uidh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// CLKDIV4 Register bits
    namespace clkdiv4_bits {
        constexpr uint32_t TRACEFRAC = (1U << 0);  ///< Trace clock divider fraction
        constexpr uint32_t TRACEDIV = (3 << 1);  ///< Trace clock divider divisor
        constexpr uint32_t TRACEDIVEN = (1U << 28);  ///< Debug Trace Divider Control
    }

    /// MISCTRL0 Register bits
    namespace misctrl0_bits {
        constexpr uint32_t CMPWIN0SRC = (2 << 8);  ///< CMP Sample/Window Input 0 Source
        constexpr uint32_t CMPWIN1SRC = (2 << 10);  ///< CMP Sample/Window Input 1 Source
        constexpr uint32_t CMPWIN2SRC = (2 << 12);  ///< CMP Sample/Window Input 2 Source
        constexpr uint32_t CMPWIN3SRC = (2 << 14);  ///< CMP Sample/Window Input 3 Source
        constexpr uint32_t EWMINSRC = (1U << 16);  ///< EWM_IN Source
        constexpr uint32_t DACTRIGSRC = (2 << 18);  ///< DAC0 Hardware Trigger Input Source
    }

    /// MISCTRL1 Register bits
    namespace misctrl1_bits {
        constexpr uint32_t SYNCXBARAPITTRIG0 = (1U << 8);  ///< Synchronize XBARA's Input PIT Trigger 0 with fast clock
        constexpr uint32_t SYNCXBARAPITTRIG1 = (1U << 9);  ///< Synchronize XBARA's Input PIT Trigger 1 with fast clock
        constexpr uint32_t SYNCXBARAPITTRIG2 = (1U << 10);  ///< Synchronize XBARA's Input PIT Trigger 2 with fast clock
        constexpr uint32_t SYNCXBARAPITTRIG3 = (1U << 11);  ///< Synchronize XBARA's Input PIT Trigger 3 with fast clock
        constexpr uint32_t SYNCXBARBPITTRIG0 = (1U << 12);  ///< Synchronize XBARB's Input PIT Trigger 0 with fast clock
        constexpr uint32_t SYNCXBARBPITTRIG1 = (1U << 13);  ///< Synchronize XBARB's Input PIT Trigger 1 with fast clock
        constexpr uint32_t SYNCDACHWTRIG = (1U << 16);  ///< Synchronize XBARA's output for DAC Hardware Trigger with flash/slow clock
        constexpr uint32_t SYNCEWMIN = (1U << 17);  ///< Synchronize XBARA's output for EWM's ewm_in with flash/slow clock
        constexpr uint32_t SYNCCMP0SAMPLEWIN = (1U << 20);  ///< Synchronize XBARA's output for CMP0's Sample/Window Input with flash/slow clock
        constexpr uint32_t SYNCCMP1SAMPLEWIN = (1U << 21);  ///< Synchronize XBARA's output for CMP1's Sample/Window Input with flash/slow clock
        constexpr uint32_t SYNCCMP2SAMPLEWIN = (1U << 22);  ///< Synchronize XBARA's output for CMP2's Sample/Window Input with flash/slow clock
        constexpr uint32_t SYNCCMP3SAMPLEWIN = (1U << 23);  ///< Synchronize XBARA's output for CMP3's Sample/Window Input with flash/slow clock
    }

    /// WDOGC Register bits
    namespace wdogc_bits {
        constexpr uint32_t WDOGCLKS = (1U << 1);  ///< WDOG Clock Select
    }

    /// PWRC Register bits
    namespace pwrc_bits {
        constexpr uint32_t SRPDN = (2 << 0);  ///< Nanoedge Regulator 2.7V and 1.2V Supply Powerdown Control
        constexpr uint32_t SR27STDBY = (2 << 2);  ///< Nanoedge Regulator 2.7 V Supply Standby Control
        constexpr uint32_t SR12STDBY = (2 << 6);  ///< Nanoedge Regulator 1.2 V Supply Standby Control
        constexpr uint32_t SRPWRDETEN = (1U << 8);  ///< Nanoedge PMC POWER Dectect Enable
        constexpr uint32_t SRPWRRDY = (1U << 9);  ///< Nanoedge PMC POWER Ready
        constexpr uint32_t SRPWROK = (1U << 16);  ///< Nanoedge PMC Status
    }

    /// ADCOPT Register bits
    namespace adcopt_bits {
        constexpr uint32_t ADC0TRGSEL = (4 << 16);  ///< ADC0 trigger select
        constexpr uint32_t ADC0PRETRGSEL = (1U << 20);  ///< ADC0 pretrigger select
        constexpr uint32_t ADC0ALTTRGEN = (2 << 22);  ///< ADC0 alternate trigger enable
        constexpr uint32_t HSADCIRCLK = (1U << 25);  ///< HSADC Clock Status
        constexpr uint32_t HSADCSTOPEN = (1U << 26);  ///< Enable HSADCs in STOP mode
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40049000;
    constexpr uint32_t PORTB_BASE = 0x4004A000;
    constexpr uint32_t PORTC_BASE = 0x4004B000;
    constexpr uint32_t PORTD_BASE = 0x4004C000;
    constexpr uint32_t PORTE_BASE = 0x4004D000;
    constexpr uint32_t GPIOA_BASE = 0x400FF000;
    constexpr uint32_t GPIOB_BASE = 0x400FF040;
    constexpr uint32_t GPIOC_BASE = 0x400FF080;
    constexpr uint32_t GPIOD_BASE = 0x400FF0C0;
    constexpr uint32_t GPIOE_BASE = 0x400FF100;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR0;  ///< Offset: 0x00 - Pin Control Register n
        volatile uint32_t PCR1;  ///< Offset: 0x04 - Pin Control Register n
        volatile uint32_t PCR2;  ///< Offset: 0x08 - Pin Control Register n
        volatile uint32_t PCR3;  ///< Offset: 0x0C - Pin Control Register n
        volatile uint32_t PCR4;  ///< Offset: 0x10 - Pin Control Register n
        volatile uint32_t PCR5;  ///< Offset: 0x14 - Pin Control Register n
        volatile uint32_t PCR6;  ///< Offset: 0x18 - Pin Control Register n
        volatile uint32_t PCR7;  ///< Offset: 0x1C - Pin Control Register n
        volatile uint32_t PCR8;  ///< Offset: 0x20 - Pin Control Register n
        volatile uint32_t PCR9;  ///< Offset: 0x24 - Pin Control Register n
        volatile uint32_t PCR10;  ///< Offset: 0x28 - Pin Control Register n
        volatile uint32_t PCR11;  ///< Offset: 0x2C - Pin Control Register n
        volatile uint32_t PCR12;  ///< Offset: 0x30 - Pin Control Register n
        volatile uint32_t PCR13;  ///< Offset: 0x34 - Pin Control Register n
        volatile uint32_t PCR14;  ///< Offset: 0x38 - Pin Control Register n
        volatile uint32_t PCR15;  ///< Offset: 0x3C - Pin Control Register n
        volatile uint32_t PCR16;  ///< Offset: 0x40 - Pin Control Register n
        volatile uint32_t PCR17;  ///< Offset: 0x44 - Pin Control Register n
        volatile uint32_t PCR18;  ///< Offset: 0x48 - Pin Control Register n
        volatile uint32_t PCR19;  ///< Offset: 0x4C - Pin Control Register n
        volatile uint32_t PCR20;  ///< Offset: 0x50 - Pin Control Register n
        volatile uint32_t PCR21;  ///< Offset: 0x54 - Pin Control Register n
        volatile uint32_t PCR22;  ///< Offset: 0x58 - Pin Control Register n
        volatile uint32_t PCR23;  ///< Offset: 0x5C - Pin Control Register n
        volatile uint32_t PCR24;  ///< Offset: 0x60 - Pin Control Register n
        volatile uint32_t PCR25;  ///< Offset: 0x64 - Pin Control Register n
        volatile uint32_t PCR26;  ///< Offset: 0x68 - Pin Control Register n
        volatile uint32_t PCR27;  ///< Offset: 0x6C - Pin Control Register n
        volatile uint32_t PCR28;  ///< Offset: 0x70 - Pin Control Register n
        volatile uint32_t PCR29;  ///< Offset: 0x74 - Pin Control Register n
        volatile uint32_t PCR30;  ///< Offset: 0x78 - Pin Control Register n
        volatile uint32_t PCR31;  ///< Offset: 0x7C - Pin Control Register n
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);

    // Bit definitions
    /// PCR0 Register bits
    namespace pcr0_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR1 Register bits
    namespace pcr1_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR2 Register bits
    namespace pcr2_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR3 Register bits
    namespace pcr3_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR4 Register bits
    namespace pcr4_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR5 Register bits
    namespace pcr5_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR6 Register bits
    namespace pcr6_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR7 Register bits
    namespace pcr7_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR8 Register bits
    namespace pcr8_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR9 Register bits
    namespace pcr9_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR10 Register bits
    namespace pcr10_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR11 Register bits
    namespace pcr11_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR12 Register bits
    namespace pcr12_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR13 Register bits
    namespace pcr13_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR14 Register bits
    namespace pcr14_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR15 Register bits
    namespace pcr15_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR16 Register bits
    namespace pcr16_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR17 Register bits
    namespace pcr17_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR18 Register bits
    namespace pcr18_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR19 Register bits
    namespace pcr19_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR20 Register bits
    namespace pcr20_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR21 Register bits
    namespace pcr21_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR22 Register bits
    namespace pcr22_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR23 Register bits
    namespace pcr23_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR24 Register bits
    namespace pcr24_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR25 Register bits
    namespace pcr25_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR26 Register bits
    namespace pcr26_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR27 Register bits
    namespace pcr27_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR28 Register bits
    namespace pcr28_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR29 Register bits
    namespace pcr29_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR30 Register bits
    namespace pcr30_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR31 Register bits
    namespace pcr31_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (4 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

}

// ============================================================================
// WDOG Peripheral
// ============================================================================

namespace wdog {
    /// Base addresses
    constexpr uint32_t WDOG_BASE = 0x40052000;

    /// WDOG Register structure
    struct Registers {
        volatile uint32_t STCTRLH;  ///< Offset: 0x00 - Watchdog Status and Control Register High
        volatile uint32_t STCTRLL;  ///< Offset: 0x02 - Watchdog Status and Control Register Low
        volatile uint32_t TOVALH;  ///< Offset: 0x04 - Watchdog Time-out Value Register High
        volatile uint32_t TOVALL;  ///< Offset: 0x06 - Watchdog Time-out Value Register Low
        volatile uint32_t WINH;  ///< Offset: 0x08 - Watchdog Window Register High
        volatile uint32_t WINL;  ///< Offset: 0x0A - Watchdog Window Register Low
        volatile uint32_t REFRESH;  ///< Offset: 0x0C - Watchdog Refresh register
        volatile uint32_t UNLOCK;  ///< Offset: 0x0E - Watchdog Unlock register
        volatile uint32_t TMROUTH;  ///< Offset: 0x10 - Watchdog Timer Output Register High
        volatile uint32_t TMROUTL;  ///< Offset: 0x12 - Watchdog Timer Output Register Low
        volatile uint32_t RSTCNT;  ///< Offset: 0x14 - Watchdog Reset Count register
        volatile uint32_t PRESC;  ///< Offset: 0x16 - Watchdog Prescaler register
    };

    /// Peripheral instances
    inline Registers* WDOG = reinterpret_cast<Registers*>(WDOG_BASE);

    // Bit definitions
    /// STCTRLH Register bits
    namespace stctrlh_bits {
        constexpr uint32_t WDOGEN = (1U << 0);  ///< Enables or disables the WDOG's operation
        constexpr uint32_t CLKSRC = (1U << 1);  ///< Selects clock source for the WDOG timer and other internal timing operations.
        constexpr uint32_t IRQRSTEN = (1U << 2);  ///< Used to enable the debug breadcrumbs feature
        constexpr uint32_t WINEN = (1U << 3);  ///< Enables Windowing mode.
        constexpr uint32_t ALLOWUPDATE = (1U << 4);  ///< Enables updates to watchdog write-once registers, after the reset-triggered initial configuration window (WCT) closes, through unlock sequence
        constexpr uint32_t DBGEN = (1U << 5);  ///< Enables or disables WDOG in Debug mode.
        constexpr uint32_t STOPEN = (1U << 6);  ///< Enables or disables WDOG in Stop mode.
        constexpr uint32_t WAITEN = (1U << 7);  ///< Enables or disables WDOG in Wait mode.
        constexpr uint32_t TESTWDOG = (1U << 10);  ///< Puts the watchdog in the functional test mode
        constexpr uint32_t TESTSEL = (1U << 11);  ///< Effective only if TESTWDOG is set. Selects the test to be run on the watchdog timer.
        constexpr uint32_t BYTESEL = (2 << 12);  ///< This 2-bit field selects the byte to be tested when the watchdog is in the byte test mode.
        constexpr uint32_t DISTESTWDOG = (1U << 14);  ///< Allows the WDOG's functional test mode to be disabled permanently
    }

    /// STCTRLL Register bits
    namespace stctrll_bits {
        constexpr uint32_t INTFLG = (1U << 15);  ///< Interrupt flag
    }

    /// TOVALH Register bits
    namespace tovalh_bits {
        constexpr uint32_t TOVALHIGH = (16 << 0);  ///< Defines the upper 16 bits of the 32-bit time-out value for the watchdog timer
    }

    /// TOVALL Register bits
    namespace tovall_bits {
        constexpr uint32_t TOVALLOW = (16 << 0);  ///< Defines the lower 16 bits of the 32-bit time-out value for the watchdog timer
    }

    /// WINH Register bits
    namespace winh_bits {
        constexpr uint32_t WINHIGH = (16 << 0);  ///< Defines the upper 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
    }

    /// WINL Register bits
    namespace winl_bits {
        constexpr uint32_t WINLOW = (16 << 0);  ///< Defines the lower 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
    }

    /// REFRESH Register bits
    namespace refresh_bits {
        constexpr uint32_t WDOGREFRESH = (16 << 0);  ///< Watchdog refresh register
    }

    /// UNLOCK Register bits
    namespace unlock_bits {
        constexpr uint32_t WDOGUNLOCK = (16 << 0);  ///< Writing the unlock sequence values to this register to makes the watchdog write-once registers writable again
    }

    /// TMROUTH Register bits
    namespace tmrouth_bits {
        constexpr uint32_t TIMEROUTHIGH = (16 << 0);  ///< Shows the value of the upper 16 bits of the watchdog timer.
    }

    /// TMROUTL Register bits
    namespace tmroutl_bits {
        constexpr uint32_t TIMEROUTLOW = (16 << 0);  ///< Shows the value of the lower 16 bits of the watchdog timer.
    }

    /// RSTCNT Register bits
    namespace rstcnt_bits {
        constexpr uint32_t RSTCNT = (16 << 0);  ///< Counts the number of times the watchdog resets the system
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCVAL = (3 << 8);  ///< 3-bit prescaler for the watchdog clock source
    }

}

// ============================================================================
// ENC Peripheral
// ============================================================================

namespace enc {
    /// Base addresses
    constexpr uint32_t ENC_BASE = 0x40055000;

    /// ENC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t FILT;  ///< Offset: 0x02 - Input Filter Register
        volatile uint32_t WTR;  ///< Offset: 0x04 - Watchdog Timeout Register
        volatile uint32_t POSD;  ///< Offset: 0x06 - Position Difference Counter Register
        volatile uint32_t POSDH;  ///< Offset: 0x08 - Position Difference Hold Register
        volatile uint32_t REV;  ///< Offset: 0x0A - Revolution Counter Register
        volatile uint32_t REVH;  ///< Offset: 0x0C - Revolution Hold Register
        volatile uint32_t UPOS;  ///< Offset: 0x0E - Upper Position Counter Register
        volatile uint32_t LPOS;  ///< Offset: 0x10 - Lower Position Counter Register
        volatile uint32_t UPOSH;  ///< Offset: 0x12 - Upper Position Hold Register
        volatile uint32_t LPOSH;  ///< Offset: 0x14 - Lower Position Hold Register
        volatile uint32_t UINIT;  ///< Offset: 0x16 - Upper Initialization Register
        volatile uint32_t LINIT;  ///< Offset: 0x18 - Lower Initialization Register
        volatile uint32_t IMR;  ///< Offset: 0x1A - Input Monitor Register
        volatile uint32_t TST;  ///< Offset: 0x1C - Test Register
        volatile uint32_t CTRL2;  ///< Offset: 0x1E - Control 2 Register
        volatile uint32_t UMOD;  ///< Offset: 0x20 - Upper Modulus Register
        volatile uint32_t LMOD;  ///< Offset: 0x22 - Lower Modulus Register
        volatile uint32_t UCOMP;  ///< Offset: 0x24 - Upper Position Compare Register
        volatile uint32_t LCOMP;  ///< Offset: 0x26 - Lower Position Compare Register
    };

    /// Peripheral instances
    inline Registers* ENC = reinterpret_cast<Registers*>(ENC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t CMPIE = (1U << 0);  ///< Compare Interrupt Enable
        constexpr uint32_t CMPIRQ = (1U << 1);  ///< Compare Interrupt Request
        constexpr uint32_t WDE = (1U << 2);  ///< Watchdog Enable
        constexpr uint32_t DIE = (1U << 3);  ///< Watchdog Timeout Interrupt Enable
        constexpr uint32_t DIRQ = (1U << 4);  ///< Watchdog Timeout Interrupt Request
        constexpr uint32_t XNE = (1U << 5);  ///< Use Negative Edge of INDEX Pulse
        constexpr uint32_t XIP = (1U << 6);  ///< INDEX Triggered Initialization of Position Counters UPOS and LPOS
        constexpr uint32_t XIE = (1U << 7);  ///< INDEX Pulse Interrupt Enable
        constexpr uint32_t XIRQ = (1U << 8);  ///< INDEX Pulse Interrupt Request
        constexpr uint32_t PH1 = (1U << 9);  ///< Enable Signal Phase Count Mode
        constexpr uint32_t REV = (1U << 10);  ///< Enable Reverse Direction Counting
        constexpr uint32_t SWIP = (1U << 11);  ///< Software Triggered Initialization of Position Counters UPOS and LPOS
        constexpr uint32_t HNE = (1U << 12);  ///< Use Negative Edge of HOME Input
        constexpr uint32_t HIP = (1U << 13);  ///< Enable HOME to Initialize Position Counters UPOS and LPOS
        constexpr uint32_t HIE = (1U << 14);  ///< HOME Interrupt Enable
        constexpr uint32_t HIRQ = (1U << 15);  ///< HOME Signal Transition Interrupt Request
    }

    /// FILT Register bits
    namespace filt_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Input Filter Sample Period
        constexpr uint32_t FILT_CNT = (3 << 8);  ///< Input Filter Sample Count
    }

    /// WTR Register bits
    namespace wtr_bits {
        constexpr uint32_t WDOG = (16 << 0);  ///< WDOG[15:0] is a binary representation of the number of clock cycles plus one that the watchdog timer counts before timing out and optionally generating an interrupt
    }

    /// POSD Register bits
    namespace posd_bits {
        constexpr uint32_t POSD = (16 << 0);  ///< This read/write register contains the position change in value occurring between each read of the position register
    }

    /// POSDH Register bits
    namespace posdh_bits {
        constexpr uint32_t POSDH = (16 << 0);  ///< This read-only register contains a snapshot of the value of the POSD register
    }

    /// REV Register bits
    namespace rev_bits {
        constexpr uint32_t REV = (16 << 0);  ///< This read/write register contains the current value of the revolution counter.
    }

    /// REVH Register bits
    namespace revh_bits {
        constexpr uint32_t REVH = (16 << 0);  ///< This read-only register contains a snapshot of the value of the REV register.
    }

    /// UPOS Register bits
    namespace upos_bits {
        constexpr uint32_t POS = (16 << 0);  ///< This read/write register contains the upper (most significant) half of the position counter
    }

    /// LPOS Register bits
    namespace lpos_bits {
        constexpr uint32_t POS = (16 << 0);  ///< This read/write register contains the lower (least significant) half of the position counter
    }

    /// UPOSH Register bits
    namespace uposh_bits {
        constexpr uint32_t POSH = (16 << 0);  ///< This read-only register contains a snapshot of the UPOS register.
    }

    /// LPOSH Register bits
    namespace lposh_bits {
        constexpr uint32_t POSH = (16 << 0);  ///< This read-only register contains a snapshot of the LPOS register.
    }

    /// UINIT Register bits
    namespace uinit_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< This read/write register contains the value to be used to initialize the upper half of the position counter (UPOS)
    }

    /// LINIT Register bits
    namespace linit_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< This read/write register contains the value to be used to initialize the lower half of the position counter (LPOS)
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t HOME = (1U << 0);  ///< This is the raw HOME input.
        constexpr uint32_t INDEX = (1U << 1);  ///< This is the raw INDEX input.
        constexpr uint32_t PHB = (1U << 2);  ///< This is the raw PHASEB input.
        constexpr uint32_t PHA = (1U << 3);  ///< This is the raw PHASEA input.
        constexpr uint32_t FHOM = (1U << 4);  ///< This is the filtered version of HOME input.
        constexpr uint32_t FIND = (1U << 5);  ///< This is the filtered version of INDEX input.
        constexpr uint32_t FPHB = (1U << 6);  ///< This is the filtered version of PHASEB input.
        constexpr uint32_t FPHA = (1U << 7);  ///< This is the filtered version of PHASEA input.
    }

    /// TST Register bits
    namespace tst_bits {
        constexpr uint32_t TEST_COUNT = (8 << 0);  ///< These bits hold the number of quadrature advances to generate.
        constexpr uint32_t TEST_PERIOD = (5 << 8);  ///< These bits hold the period of quadrature phase in IPBus clock cycles.
        constexpr uint32_t QDN = (1U << 13);  ///< Quadrature Decoder Negative Signal
        constexpr uint32_t TCE = (1U << 14);  ///< Test Counter Enable
        constexpr uint32_t TEN = (1U << 15);  ///< Test Mode Enable
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t UPDHLD = (1U << 0);  ///< Update Hold Registers
        constexpr uint32_t UPDPOS = (1U << 1);  ///< Update Position Registers
        constexpr uint32_t MOD = (1U << 2);  ///< Enable Modulo Counting
        constexpr uint32_t DIR = (1U << 3);  ///< Count Direction Flag
        constexpr uint32_t RUIE = (1U << 4);  ///< Roll-under Interrupt Enable
        constexpr uint32_t RUIRQ = (1U << 5);  ///< Roll-under Interrupt Request
        constexpr uint32_t ROIE = (1U << 6);  ///< Roll-over Interrupt Enable
        constexpr uint32_t ROIRQ = (1U << 7);  ///< Roll-over Interrupt Request
        constexpr uint32_t REVMOD = (1U << 8);  ///< Revolution Counter Modulus Enable
        constexpr uint32_t OUTCTL = (1U << 9);  ///< Output Control
        constexpr uint32_t SABIE = (1U << 10);  ///< Simultaneous PHASEA and PHASEB Change Interrupt Enable
        constexpr uint32_t SABIRQ = (1U << 11);  ///< Simultaneous PHASEA and PHASEB Change Interrupt Request
    }

    /// UMOD Register bits
    namespace umod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< This read/write register contains the upper (most significant) half of the modulus register
    }

    /// LMOD Register bits
    namespace lmod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< This read/write register contains the lower (least significant) half of the modulus register
    }

    /// UCOMP Register bits
    namespace ucomp_bits {
        constexpr uint32_t COMP = (16 << 0);  ///< This read/write register contains the upper (most significant) half of the position compare register
    }

    /// LCOMP Register bits
    namespace lcomp_bits {
        constexpr uint32_t COMP = (16 << 0);  ///< This read/write register contains the lower (least significant) half of the position compare register
    }

}

// ============================================================================
// XBARA Peripheral
// ============================================================================

namespace xbara {
    /// Base addresses
    constexpr uint32_t XBARA_BASE = 0x40059000;

    /// XBARA Register structure
    struct Registers {
        volatile uint32_t SEL0;  ///< Offset: 0x00 - Crossbar A Select Register 0
        volatile uint32_t SEL1;  ///< Offset: 0x02 - Crossbar A Select Register 1
        volatile uint32_t SEL2;  ///< Offset: 0x04 - Crossbar A Select Register 2
        volatile uint32_t SEL3;  ///< Offset: 0x06 - Crossbar A Select Register 3
        volatile uint32_t SEL4;  ///< Offset: 0x08 - Crossbar A Select Register 4
        volatile uint32_t SEL5;  ///< Offset: 0x0A - Crossbar A Select Register 5
        volatile uint32_t SEL6;  ///< Offset: 0x0C - Crossbar A Select Register 6
        volatile uint32_t SEL7;  ///< Offset: 0x0E - Crossbar A Select Register 7
        volatile uint32_t SEL8;  ///< Offset: 0x10 - Crossbar A Select Register 8
        volatile uint32_t SEL9;  ///< Offset: 0x12 - Crossbar A Select Register 9
        volatile uint32_t SEL10;  ///< Offset: 0x14 - Crossbar A Select Register 10
        volatile uint32_t SEL11;  ///< Offset: 0x16 - Crossbar A Select Register 11
        volatile uint32_t SEL12;  ///< Offset: 0x18 - Crossbar A Select Register 12
        volatile uint32_t SEL13;  ///< Offset: 0x1A - Crossbar A Select Register 13
        volatile uint32_t SEL14;  ///< Offset: 0x1C - Crossbar A Select Register 14
        volatile uint32_t SEL15;  ///< Offset: 0x1E - Crossbar A Select Register 15
        volatile uint32_t SEL16;  ///< Offset: 0x20 - Crossbar A Select Register 16
        volatile uint32_t SEL17;  ///< Offset: 0x22 - Crossbar A Select Register 17
        volatile uint32_t SEL18;  ///< Offset: 0x24 - Crossbar A Select Register 18
        volatile uint32_t SEL19;  ///< Offset: 0x26 - Crossbar A Select Register 19
        volatile uint32_t SEL20;  ///< Offset: 0x28 - Crossbar A Select Register 20
        volatile uint32_t SEL21;  ///< Offset: 0x2A - Crossbar A Select Register 21
        volatile uint32_t SEL22;  ///< Offset: 0x2C - Crossbar A Select Register 22
        volatile uint32_t SEL23;  ///< Offset: 0x2E - Crossbar A Select Register 23
        volatile uint32_t SEL24;  ///< Offset: 0x30 - Crossbar A Select Register 24
        volatile uint32_t SEL25;  ///< Offset: 0x32 - Crossbar A Select Register 25
        volatile uint32_t SEL26;  ///< Offset: 0x34 - Crossbar A Select Register 26
        volatile uint32_t SEL27;  ///< Offset: 0x36 - Crossbar A Select Register 27
        volatile uint32_t SEL28;  ///< Offset: 0x38 - Crossbar A Select Register 28
        volatile uint32_t SEL29;  ///< Offset: 0x3A - Crossbar A Select Register 29
        volatile uint32_t CTRL0;  ///< Offset: 0x3C - Crossbar A Control Register 0
        volatile uint32_t CTRL1;  ///< Offset: 0x3E - Crossbar A Control Register 1
    };

    /// Peripheral instances
    inline Registers* XBARA = reinterpret_cast<Registers*>(XBARA_BASE);

    // Bit definitions
    /// SEL0 Register bits
    namespace sel0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT0 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL1 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT1 (refer to Functional Description section for input/output assignment)
    }

    /// SEL1 Register bits
    namespace sel1_bits {
        constexpr uint32_t SEL2 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT2 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL3 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT3 (refer to Functional Description section for input/output assignment)
    }

    /// SEL2 Register bits
    namespace sel2_bits {
        constexpr uint32_t SEL4 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT4 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL5 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT5 (refer to Functional Description section for input/output assignment)
    }

    /// SEL3 Register bits
    namespace sel3_bits {
        constexpr uint32_t SEL6 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT6 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL7 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT7 (refer to Functional Description section for input/output assignment)
    }

    /// SEL4 Register bits
    namespace sel4_bits {
        constexpr uint32_t SEL8 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT8 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL9 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT9 (refer to Functional Description section for input/output assignment)
    }

    /// SEL5 Register bits
    namespace sel5_bits {
        constexpr uint32_t SEL10 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT10 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL11 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT11 (refer to Functional Description section for input/output assignment)
    }

    /// SEL6 Register bits
    namespace sel6_bits {
        constexpr uint32_t SEL12 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT12 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL13 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT13 (refer to Functional Description section for input/output assignment)
    }

    /// SEL7 Register bits
    namespace sel7_bits {
        constexpr uint32_t SEL14 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT14 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL15 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT15 (refer to Functional Description section for input/output assignment)
    }

    /// SEL8 Register bits
    namespace sel8_bits {
        constexpr uint32_t SEL16 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT16 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL17 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT17 (refer to Functional Description section for input/output assignment)
    }

    /// SEL9 Register bits
    namespace sel9_bits {
        constexpr uint32_t SEL18 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT18 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL19 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT19 (refer to Functional Description section for input/output assignment)
    }

    /// SEL10 Register bits
    namespace sel10_bits {
        constexpr uint32_t SEL20 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT20 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL21 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT21 (refer to Functional Description section for input/output assignment)
    }

    /// SEL11 Register bits
    namespace sel11_bits {
        constexpr uint32_t SEL22 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT22 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL23 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT23 (refer to Functional Description section for input/output assignment)
    }

    /// SEL12 Register bits
    namespace sel12_bits {
        constexpr uint32_t SEL24 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT24 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL25 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT25 (refer to Functional Description section for input/output assignment)
    }

    /// SEL13 Register bits
    namespace sel13_bits {
        constexpr uint32_t SEL26 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT26 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL27 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT27 (refer to Functional Description section for input/output assignment)
    }

    /// SEL14 Register bits
    namespace sel14_bits {
        constexpr uint32_t SEL28 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT28 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL29 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT29 (refer to Functional Description section for input/output assignment)
    }

    /// SEL15 Register bits
    namespace sel15_bits {
        constexpr uint32_t SEL30 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT30 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL31 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT31 (refer to Functional Description section for input/output assignment)
    }

    /// SEL16 Register bits
    namespace sel16_bits {
        constexpr uint32_t SEL32 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT32 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL33 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT33 (refer to Functional Description section for input/output assignment)
    }

    /// SEL17 Register bits
    namespace sel17_bits {
        constexpr uint32_t SEL34 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT34 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL35 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT35 (refer to Functional Description section for input/output assignment)
    }

    /// SEL18 Register bits
    namespace sel18_bits {
        constexpr uint32_t SEL36 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT36 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL37 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT37 (refer to Functional Description section for input/output assignment)
    }

    /// SEL19 Register bits
    namespace sel19_bits {
        constexpr uint32_t SEL38 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT38 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL39 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT39 (refer to Functional Description section for input/output assignment)
    }

    /// SEL20 Register bits
    namespace sel20_bits {
        constexpr uint32_t SEL40 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT40 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL41 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT41 (refer to Functional Description section for input/output assignment)
    }

    /// SEL21 Register bits
    namespace sel21_bits {
        constexpr uint32_t SEL42 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT42 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL43 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT43 (refer to Functional Description section for input/output assignment)
    }

    /// SEL22 Register bits
    namespace sel22_bits {
        constexpr uint32_t SEL44 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT44 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL45 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT45 (refer to Functional Description section for input/output assignment)
    }

    /// SEL23 Register bits
    namespace sel23_bits {
        constexpr uint32_t SEL46 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT46 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL47 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT47 (refer to Functional Description section for input/output assignment)
    }

    /// SEL24 Register bits
    namespace sel24_bits {
        constexpr uint32_t SEL48 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT48 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL49 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT49 (refer to Functional Description section for input/output assignment)
    }

    /// SEL25 Register bits
    namespace sel25_bits {
        constexpr uint32_t SEL50 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT50 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL51 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT51 (refer to Functional Description section for input/output assignment)
    }

    /// SEL26 Register bits
    namespace sel26_bits {
        constexpr uint32_t SEL52 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT52 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL53 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT53 (refer to Functional Description section for input/output assignment)
    }

    /// SEL27 Register bits
    namespace sel27_bits {
        constexpr uint32_t SEL54 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT54 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL55 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT55 (refer to Functional Description section for input/output assignment)
    }

    /// SEL28 Register bits
    namespace sel28_bits {
        constexpr uint32_t SEL56 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT56 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL57 = (6 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT57 (refer to Functional Description section for input/output assignment)
    }

    /// SEL29 Register bits
    namespace sel29_bits {
        constexpr uint32_t SEL58 = (6 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT58 (refer to Functional Description section for input/output assignment)
    }

    /// CTRL0 Register bits
    namespace ctrl0_bits {
        constexpr uint32_t DEN0 = (1U << 0);  ///< DMA Enable for XBAR_OUT0
        constexpr uint32_t IEN0 = (1U << 1);  ///< Interrupt Enable for XBAR_OUT0
        constexpr uint32_t EDGE0 = (2 << 2);  ///< Active edge for edge detection on XBAR_OUT0
        constexpr uint32_t STS0 = (1U << 4);  ///< Edge detection status for XBAR_OUT0
        constexpr uint32_t DEN1 = (1U << 8);  ///< DMA Enable for XBAR_OUT1
        constexpr uint32_t IEN1 = (1U << 9);  ///< Interrupt Enable for XBAR_OUT1
        constexpr uint32_t EDGE1 = (2 << 10);  ///< Active edge for edge detection on XBAR_OUT1
        constexpr uint32_t STS1 = (1U << 12);  ///< Edge detection status for XBAR_OUT1
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t DEN2 = (1U << 0);  ///< DMA Enable for XBAR_OUT2
        constexpr uint32_t IEN2 = (1U << 1);  ///< Interrupt Enable for XBAR_OUT2
        constexpr uint32_t EDGE2 = (2 << 2);  ///< Active edge for edge detection on XBAR_OUT2
        constexpr uint32_t STS2 = (1U << 4);  ///< Edge detection status for XBAR_OUT2
        constexpr uint32_t DEN3 = (1U << 8);  ///< DMA Enable for XBAR_OUT3
        constexpr uint32_t IEN3 = (1U << 9);  ///< Interrupt Enable for XBAR_OUT3
        constexpr uint32_t EDGE3 = (2 << 10);  ///< Active edge for edge detection on XBAR_OUT3
        constexpr uint32_t STS3 = (1U << 12);  ///< Edge detection status for XBAR_OUT3
    }

}

// ============================================================================
// XBARB Peripheral
// ============================================================================

namespace xbarb {
    /// Base addresses
    constexpr uint32_t XBARB_BASE = 0x4005A000;

    /// XBARB Register structure
    struct Registers {
        volatile uint32_t SEL0;  ///< Offset: 0x00 - Crossbar B Select Register 0
        volatile uint32_t SEL1;  ///< Offset: 0x02 - Crossbar B Select Register 1
        volatile uint32_t SEL2;  ///< Offset: 0x04 - Crossbar B Select Register 2
        volatile uint32_t SEL3;  ///< Offset: 0x06 - Crossbar B Select Register 3
        volatile uint32_t SEL4;  ///< Offset: 0x08 - Crossbar B Select Register 4
        volatile uint32_t SEL5;  ///< Offset: 0x0A - Crossbar B Select Register 5
        volatile uint32_t SEL6;  ///< Offset: 0x0C - Crossbar B Select Register 6
        volatile uint32_t SEL7;  ///< Offset: 0x0E - Crossbar B Select Register 7
    };

    /// Peripheral instances
    inline Registers* XBARB = reinterpret_cast<Registers*>(XBARB_BASE);

    // Bit definitions
    /// SEL0 Register bits
    namespace sel0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT0 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL1 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT1 (refer to Functional Description section for input/output assignment)
    }

    /// SEL1 Register bits
    namespace sel1_bits {
        constexpr uint32_t SEL2 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT2 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL3 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT3 (refer to Functional Description section for input/output assignment)
    }

    /// SEL2 Register bits
    namespace sel2_bits {
        constexpr uint32_t SEL4 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT4 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL5 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT5 (refer to Functional Description section for input/output assignment)
    }

    /// SEL3 Register bits
    namespace sel3_bits {
        constexpr uint32_t SEL6 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT6 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL7 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT7 (refer to Functional Description section for input/output assignment)
    }

    /// SEL4 Register bits
    namespace sel4_bits {
        constexpr uint32_t SEL8 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT8 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL9 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT9 (refer to Functional Description section for input/output assignment)
    }

    /// SEL5 Register bits
    namespace sel5_bits {
        constexpr uint32_t SEL10 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT10 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL11 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT11 (refer to Functional Description section for input/output assignment)
    }

    /// SEL6 Register bits
    namespace sel6_bits {
        constexpr uint32_t SEL12 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT12 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL13 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT13 (refer to Functional Description section for input/output assignment)
    }

    /// SEL7 Register bits
    namespace sel7_bits {
        constexpr uint32_t SEL14 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT14 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL15 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT15 (refer to Functional Description section for input/output assignment)
    }

}

// ============================================================================
// AOI0 Peripheral
// ============================================================================

namespace aoi0 {
    /// Base addresses
    constexpr uint32_t AOI0_BASE = 0x4005B000;

    /// AOI0 Register structure
    struct Registers {
        volatile uint32_t BFCRT01%s;  ///< Offset: 0x00 - Boolean Function Term 0 and 1 Configuration Register for EVENTn
        volatile uint32_t BFCRT23%s;  ///< Offset: 0x02 - Boolean Function Term 2 and 3 Configuration Register for EVENTn
    };

    /// Peripheral instances
    inline Registers* AOI0 = reinterpret_cast<Registers*>(AOI0_BASE);

    // Bit definitions
    /// BFCRT01%s Register bits
    namespace bfcrt01%s_bits {
        constexpr uint32_t PT1_DC = (2 << 0);  ///< Product term 1, D input configuration
        constexpr uint32_t PT1_CC = (2 << 2);  ///< Product term 1, C input configuration
        constexpr uint32_t PT1_BC = (2 << 4);  ///< Product term 1, B input configuration
        constexpr uint32_t PT1_AC = (2 << 6);  ///< Product term 1, A input configuration
        constexpr uint32_t PT0_DC = (2 << 8);  ///< Product term 0, D input configuration
        constexpr uint32_t PT0_CC = (2 << 10);  ///< Product term 0, C input configuration
        constexpr uint32_t PT0_BC = (2 << 12);  ///< Product term 0, B input configuration
        constexpr uint32_t PT0_AC = (2 << 14);  ///< Product term 0, A input configuration
    }

    /// BFCRT23%s Register bits
    namespace bfcrt23%s_bits {
        constexpr uint32_t PT3_DC = (2 << 0);  ///< Product term 3, D input configuration
        constexpr uint32_t PT3_CC = (2 << 2);  ///< Product term 3, C input configuration
        constexpr uint32_t PT3_BC = (2 << 4);  ///< Product term 3, B input configuration
        constexpr uint32_t PT3_AC = (2 << 6);  ///< Product term 3, A input configuration
        constexpr uint32_t PT2_DC = (2 << 8);  ///< Product term 2, D input configuration
        constexpr uint32_t PT2_CC = (2 << 10);  ///< Product term 2, C input configuration
        constexpr uint32_t PT2_BC = (2 << 12);  ///< Product term 2, B input configuration
        constexpr uint32_t PT2_AC = (2 << 14);  ///< Product term 2, A input configuration
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x40061000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
        volatile uint32_t CLKCTRL;  ///< Offset: 0x04 - Clock Control Register
        volatile uint32_t CLKPRESCALER;  ///< Offset: 0x05 - Clock Prescaler Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
        constexpr uint32_t INTEN = (1U << 3);  ///< Interrupt Enable.
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< The EWM refresh mechanism requires the CPU to write two values to the SERV register: a first data byte of 0xB4, followed by a second data byte of 0x2C
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) minimum refresh time is required
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) maximum refresh time is required
    }

    /// CLKCTRL Register bits
    namespace clkctrl_bits {
        constexpr uint32_t CLKSEL = (2 << 0);  ///< EWM has 4 possible low power clock sources for running EWM counter
    }

    /// CLKPRESCALER Register bits
    namespace clkprescaler_bits {
        constexpr uint32_t CLK_DIV = (8 << 0);  ///< Selected low power clock source for running the EWM counter can be prescaled as below
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t MCG_BASE = 0x40064000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - MCG Control 1 Register
        volatile uint32_t C2;  ///< Offset: 0x01 - MCG Control 2 Register
        volatile uint32_t C3;  ///< Offset: 0x02 - MCG Control 3 Register
        volatile uint32_t C4;  ///< Offset: 0x03 - MCG Control 4 Register
        volatile uint32_t C5;  ///< Offset: 0x04 - MCG Control 5 Register
        volatile uint32_t C6;  ///< Offset: 0x05 - MCG Control 6 Register
        volatile uint32_t S;  ///< Offset: 0x06 - MCG Status Register
        volatile uint32_t SC;  ///< Offset: 0x08 - MCG Status and Control Register
        volatile uint32_t ATCVH;  ///< Offset: 0x0A - MCG Auto Trim Compare Value High Register
        volatile uint32_t ATCVL;  ///< Offset: 0x0B - MCG Auto Trim Compare Value Low Register
        volatile uint32_t C8;  ///< Offset: 0x0D - MCG Control 8 Register
    };

    /// Peripheral instances
    inline Registers* MCG = reinterpret_cast<Registers*>(MCG_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t IREFS = (1U << 2);  ///< Internal Reference Select
        constexpr uint32_t FRDIV = (3 << 3);  ///< FLL External Reference Divider
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t IRCS = (1U << 0);  ///< Internal Reference Clock Select
        constexpr uint32_t LP = (1U << 1);  ///< Low Power Select
        constexpr uint32_t EREFS = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE = (2 << 4);  ///< Frequency Range Select
        constexpr uint32_t FCFTRIM = (1U << 6);  ///< Fast Internal Reference Clock Fine Trim
        constexpr uint32_t LOCRE0 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t SCTRIM = (8 << 0);  ///< Slow Internal Reference Clock Trim Setting
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t SCFTRIM = (1U << 0);  ///< Slow Internal Reference Clock Fine Trim
        constexpr uint32_t FCTRIM = (4 << 1);  ///< Fast Internal Reference Clock Trim Setting
        constexpr uint32_t DRST_DRS = (2 << 5);  ///< DCO Range Select
        constexpr uint32_t DMX32 = (1U << 7);  ///< DCO Maximum Frequency with 32.768 kHz Reference
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t PRDIV = (3 << 0);  ///< PLL External Reference Divider
        constexpr uint32_t PLLSTEN = (1U << 5);  ///< PLL Stop Enable
        constexpr uint32_t PLLCLKEN = (1U << 6);  ///< PLL Clock Enable
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t VDIV = (5 << 0);  ///< VCO Divider
        constexpr uint32_t CME0 = (1U << 5);  ///< Clock Monitor Enable
        constexpr uint32_t PLLS = (1U << 6);  ///< PLL Select
        constexpr uint32_t LOLIE0 = (1U << 7);  ///< Loss of Lock Interrrupt Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t IRCST = (1U << 0);  ///< Internal Reference Clock Status
        constexpr uint32_t OSCINIT0 = (1U << 1);  ///< OSC Initialization
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
        constexpr uint32_t IREFST = (1U << 4);  ///< Internal Reference Status
        constexpr uint32_t PLLST = (1U << 5);  ///< PLL Select Status
        constexpr uint32_t LOCK0 = (1U << 6);  ///< Lock Status
        constexpr uint32_t LOLS0 = (1U << 7);  ///< Loss of Lock Status
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LOCS0 = (1U << 0);  ///< OSC0 Loss of Clock Status
        constexpr uint32_t FCRDIV = (3 << 1);  ///< Fast Clock Internal Reference Divider
        constexpr uint32_t FLTPRSRV = (1U << 4);  ///< FLL Filter Preserve Enable
        constexpr uint32_t ATMF = (1U << 5);  ///< Automatic Trim Machine Fail Flag
        constexpr uint32_t ATMS = (1U << 6);  ///< Automatic Trim Machine Select
        constexpr uint32_t ATME = (1U << 7);  ///< Automatic Trim Machine Enable
    }

    /// ATCVH Register bits
    namespace atcvh_bits {
        constexpr uint32_t ATCVH = (8 << 0);  ///< ATM Compare Value High
    }

    /// ATCVL Register bits
    namespace atcvl_bits {
        constexpr uint32_t ATCVL = (8 << 0);  ///< ATM Compare Value Low
    }

    /// C8 Register bits
    namespace c8_bits {
        constexpr uint32_t LOLRE = (1U << 6);  ///< PLL Loss of Lock Reset Enable
    }

}

// ============================================================================
// OSC0 Peripheral
// ============================================================================

namespace osc0 {
    /// Base addresses
    constexpr uint32_t OSC0_BASE = 0x40065000;

    /// OSC0 Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OSC Control Register
        volatile uint32_t OSC_DIV;  ///< Offset: 0x02 - OSC_DIV
    };

    /// Peripheral instances
    inline Registers* OSC0 = reinterpret_cast<Registers*>(OSC0_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SC16P = (1U << 0);  ///< Oscillator 16 pF Capacitor Load Configure
        constexpr uint32_t SC8P = (1U << 1);  ///< Oscillator 8 pF Capacitor Load Configure
        constexpr uint32_t SC4P = (1U << 2);  ///< Oscillator 4 pF Capacitor Load Configure
        constexpr uint32_t SC2P = (1U << 3);  ///< Oscillator 2 pF Capacitor Load Configure
        constexpr uint32_t EREFSTEN = (1U << 5);  ///< External Reference Stop Enable
        constexpr uint32_t ERCLKEN = (1U << 7);  ///< External Reference Enable
    }

    /// OSC_DIV Register bits
    namespace osc_div_bits {
        constexpr uint32_t ERPS = (2 << 6);  ///< ERCLK prescaler
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40066000;
    constexpr uint32_t I2C1_BASE = 0x40067000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S;  ///< Offset: 0x03 - I2C Status register
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter Register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< ClockRate
        constexpr uint32_t MULT = (2 << 6);  ///< Multiplier Factor
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup Enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit Acknowledge Enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit Mode Select
        constexpr uint32_t MST = (1U << 5);  ///< Master Mode Select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C Interrupt Enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive Acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt Flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave Read/Write
        constexpr uint32_t RAM = (1U << 3);  ///< Range Address Match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration Lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus Busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed As A Slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer Complete Flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave Address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range Address Matching Enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave Baud Rate Control
        constexpr uint32_t HDRS = (1U << 5);  ///< High Drive Select
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address Extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General Call Address Enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (4 << 0);  ///< I2C Programmable Filter Factor
        constexpr uint32_t STARTF = (1U << 4);  ///< I2C Bus Start Detect Flag
        constexpr uint32_t SSIE = (1U << 5);  ///< I2C Bus Stop or Start Interrupt Enable
        constexpr uint32_t STOPF = (1U << 6);  ///< I2C Bus Stop Detect Flag
        constexpr uint32_t SHEN = (1U << 7);  ///< Stop Hold Enable
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RAD = (7 << 1);  ///< Range Slave Address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 Interrupt Enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL High Timeout Flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL High Timeout Flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL Low Timeout Flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout Counter Clock Select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C Address Enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus Alert Response Address Enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK Enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus Address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[15:8]
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[7:0]
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x4006A000;
    constexpr uint32_t UART1_BASE = 0x4006B000;
    constexpr uint32_t UART2_BASE = 0x4006C000;
    constexpr uint32_t UART3_BASE = 0x4006D000;
    constexpr uint32_t UART4_BASE = 0x400EA000;
    constexpr uint32_t UART5_BASE = 0x400EB000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BDH;  ///< Offset: 0x00 - UART Baud Rate Registers: High
        volatile uint32_t BDL;  ///< Offset: 0x01 - UART Baud Rate Registers: Low
        volatile uint32_t C1;  ///< Offset: 0x02 - UART Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x03 - UART Control Register 2
        volatile uint32_t S1;  ///< Offset: 0x04 - UART Status Register 1
        volatile uint32_t S2;  ///< Offset: 0x05 - UART Status Register 2
        volatile uint32_t C3;  ///< Offset: 0x06 - UART Control Register 3
        volatile uint32_t D;  ///< Offset: 0x07 - UART Data Register
        volatile uint32_t MA1;  ///< Offset: 0x08 - UART Match Address Registers 1
        volatile uint32_t MA2;  ///< Offset: 0x09 - UART Match Address Registers 2
        volatile uint32_t C4;  ///< Offset: 0x0A - UART Control Register 4
        volatile uint32_t C5;  ///< Offset: 0x0B - UART Control Register 5
        volatile uint32_t ED;  ///< Offset: 0x0C - UART Extended Data Register
        volatile uint32_t MODEM;  ///< Offset: 0x0D - UART Modem Register
        volatile uint32_t IR;  ///< Offset: 0x0E - UART Infrared Register
        volatile uint32_t PFIFO;  ///< Offset: 0x10 - UART FIFO Parameters
        volatile uint32_t CFIFO;  ///< Offset: 0x11 - UART FIFO Control Register
        volatile uint32_t SFIFO;  ///< Offset: 0x12 - UART FIFO Status Register
        volatile uint32_t TWFIFO;  ///< Offset: 0x13 - UART FIFO Transmit Watermark
        volatile uint32_t TCFIFO;  ///< Offset: 0x14 - UART FIFO Transmit Count
        volatile uint32_t RWFIFO;  ///< Offset: 0x15 - UART FIFO Receive Watermark
        volatile uint32_t RCFIFO;  ///< Offset: 0x16 - UART FIFO Receive Count
        volatile uint32_t C7816;  ///< Offset: 0x18 - UART 7816 Control Register
        volatile uint32_t IE7816;  ///< Offset: 0x19 - UART 7816 Interrupt Enable Register
        volatile uint32_t IS7816;  ///< Offset: 0x1A - UART 7816 Interrupt Status Register
        volatile uint32_t WP7816;  ///< Offset: 0x1B - UART 7816 Wait Parameter Register
        volatile uint32_t WN7816;  ///< Offset: 0x1C - UART 7816 Wait N Register
        volatile uint32_t WF7816;  ///< Offset: 0x1D - UART 7816 Wait FD Register
        volatile uint32_t ET7816;  ///< Offset: 0x1E - UART 7816 Error Threshold Register
        volatile uint32_t TL7816;  ///< Offset: 0x1F - UART 7816 Transmit Length Register
        volatile uint32_t AP7816A_T0;  ///< Offset: 0x3A - UART 7816 ATR Duration Timer Register A
        volatile uint32_t AP7816B_T0;  ///< Offset: 0x3B - UART 7816 ATR Duration Timer Register B
        volatile uint32_t WP7816A_T0;  ///< Offset: 0x3C - UART 7816 Wait Parameter Register A
        volatile uint32_t WP7816A_T1;  ///< Offset: 0x3C - UART 7816 Wait Parameter Register A
        volatile uint32_t WP7816B_T0;  ///< Offset: 0x3D - UART 7816 Wait Parameter Register B
        volatile uint32_t WP7816B_T1;  ///< Offset: 0x3D - UART 7816 Wait Parameter Register B
        volatile uint32_t WGP7816_T1;  ///< Offset: 0x3E - UART 7816 Wait and Guard Parameter Register
        volatile uint32_t WP7816C_T1;  ///< Offset: 0x3F - UART 7816 Wait Parameter Register C
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);

    // Bit definitions
    /// BDH Register bits
    namespace bdh_bits {
        constexpr uint32_t SBR = (5 << 0);  ///< UART Baud Rate Bits
        constexpr uint32_t SBNS = (1U << 5);  ///< Stop Bit Number Select
        constexpr uint32_t RXEDGIE = (1U << 6);  ///< RxD Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 7);  ///< LIN Break Detect Interrupt or DMA Request Enable
    }

    /// BDL Register bits
    namespace bdl_bits {
        constexpr uint32_t SBR = (8 << 0);  ///< UART Baud Rate Bits
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-bit or 8-bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t UARTSWAI = (1U << 6);  ///< UART Stops in Wait Mode
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t SBK = (1U << 0);  ///< Send Break
        constexpr uint32_t RWU = (1U << 1);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 2);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 4);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receiver Full Interrupt or DMA Transfer Enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission Complete Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmitter Interrupt or DMA Transfer Enable.
    }

    /// S1 Register bits
    namespace s1_bits {
        constexpr uint32_t PF = (1U << 0);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 1);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 2);  ///< Noise Flag
        constexpr uint32_t OR = (1U << 3);  ///< Receiver Overrun Flag
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 6);  ///< Transmit Complete Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Register Empty Flag
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t RAF = (1U << 0);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 1);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 2);  ///< Break Transmit Character Length
        constexpr uint32_t RWUID = (1U << 3);  ///< Receive Wakeup Idle Detect
        constexpr uint32_t RXINV = (1U << 4);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 5);  ///< Most Significant Bit First
        constexpr uint32_t RXEDGIF = (1U << 6);  ///< RxD Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 7);  ///< LIN Break Detect Interrupt Flag
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t PEIE = (1U << 0);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 1);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 2);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 3);  ///< Overrun Error Interrupt Enable
        constexpr uint32_t TXINV = (1U << 4);  ///< Transmit Data Inversion.
        constexpr uint32_t TXDIR = (1U << 5);  ///< Transmitter Pin Data Direction in Single-Wire mode
        constexpr uint32_t T8 = (1U << 6);  ///< Transmit Bit 8
        constexpr uint32_t R8 = (1U << 7);  ///< Received Bit 8
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t RT = (8 << 0);  ///< Reads return the contents of the read-only receive data register and writes go to the write-only transmit data register
    }

    /// MA1 Register bits
    namespace ma1_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// MA2 Register bits
    namespace ma2_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t BRFA = (5 << 0);  ///< Baud Rate Fine Adjust
        constexpr uint32_t M10 = (1U << 5);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 6);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 7);  ///< Match Address Mode Enable 1
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t LBKDDMAS = (1U << 3);  ///< LIN Break Detect DMA Select Bit
        constexpr uint32_t RDMAS = (1U << 5);  ///< Receiver Full DMA Select
        constexpr uint32_t TDMAS = (1U << 7);  ///< Transmitter DMA Select
    }

    /// ED Register bits
    namespace ed_bits {
        constexpr uint32_t PARITYE = (1U << 6);  ///< The current received dataword contained in D and C3[R8] was received with a parity error.
        constexpr uint32_t NOISY = (1U << 7);  ///< The current received dataword contained in D and C3[R8] was received with noise.
    }

    /// MODEM Register bits
    namespace modem_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
    }

    /// IR Register bits
    namespace ir_bits {
        constexpr uint32_t TNP = (2 << 0);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 2);  ///< Infrared enable
    }

    /// PFIFO Register bits
    namespace pfifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO. Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO. Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
    }

    /// CFIFO Register bits
    namespace cfifo_bits {
        constexpr uint32_t RXUFE = (1U << 0);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 1);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXOFE = (1U << 2);  ///< Receive FIFO Overflow Interrupt Enable
        constexpr uint32_t RXFLUSH = (1U << 6);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 7);  ///< Transmit FIFO/Buffer Flush
    }

    /// SFIFO Register bits
    namespace sfifo_bits {
        constexpr uint32_t RXUF = (1U << 0);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 1);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXOF = (1U << 2);  ///< Receiver Buffer Overflow Flag
        constexpr uint32_t RXEMPT = (1U << 6);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 7);  ///< Transmit Buffer/FIFO Empty
    }

    /// TWFIFO Register bits
    namespace twfifo_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit Watermark
    }

    /// TCFIFO Register bits
    namespace tcfifo_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit Counter
    }

    /// RWFIFO Register bits
    namespace rwfifo_bits {
        constexpr uint32_t RXWATER = (8 << 0);  ///< Receive Watermark
    }

    /// RCFIFO Register bits
    namespace rcfifo_bits {
        constexpr uint32_t RXCOUNT = (8 << 0);  ///< Receive Counter
    }

    /// C7816 Register bits
    namespace c7816_bits {
        constexpr uint32_t ISO_7816E = (1U << 0);  ///< ISO-7816 Functionality Enabled
        constexpr uint32_t TTYPE = (1U << 1);  ///< Transfer Type
        constexpr uint32_t INIT = (1U << 2);  ///< Detect Initial Character
        constexpr uint32_t ANACK = (1U << 3);  ///< Generate NACK on Error
        constexpr uint32_t ONACK = (1U << 4);  ///< Generate NACK on Overflow
    }

    /// IE7816 Register bits
    namespace ie7816_bits {
        constexpr uint32_t RXTE = (1U << 0);  ///< Receive Threshold Exceeded Interrupt Enable
        constexpr uint32_t TXTE = (1U << 1);  ///< Transmit Threshold Exceeded Interrupt Enable
        constexpr uint32_t GTVE = (1U << 2);  ///< Guard Timer Violated Interrupt Enable
        constexpr uint32_t ADTE = (1U << 3);  ///< ATR Duration Timer Interrupt Enable
        constexpr uint32_t INITDE = (1U << 4);  ///< Initial Character Detected Interrupt Enable
        constexpr uint32_t BWTE = (1U << 5);  ///< Block Wait Timer Interrupt Enable
        constexpr uint32_t CWTE = (1U << 6);  ///< Character Wait Timer Interrupt Enable
        constexpr uint32_t WTE = (1U << 7);  ///< Wait Timer Interrupt Enable
    }

    /// IS7816 Register bits
    namespace is7816_bits {
        constexpr uint32_t RXT = (1U << 0);  ///< Receive Threshold Exceeded Interrupt
        constexpr uint32_t TXT = (1U << 1);  ///< Transmit Threshold Exceeded Interrupt
        constexpr uint32_t GTV = (1U << 2);  ///< Guard Timer Violated Interrupt
        constexpr uint32_t ADT = (1U << 3);  ///< ATR Duration Time Interrupt
        constexpr uint32_t INITD = (1U << 4);  ///< Initial Character Detected Interrupt
        constexpr uint32_t BWT = (1U << 5);  ///< Block Wait Timer Interrupt
        constexpr uint32_t CWT = (1U << 6);  ///< Character Wait Timer Interrupt
        constexpr uint32_t WT = (1U << 7);  ///< Wait Timer Interrupt
    }

    /// WP7816 Register bits
    namespace wp7816_bits {
        constexpr uint32_t WTX = (8 << 0);  ///< Wait Time Multiplier (C7816[TTYPE] = 1)
    }

    /// WN7816 Register bits
    namespace wn7816_bits {
        constexpr uint32_t GTN = (8 << 0);  ///< Guard Band N
    }

    /// WF7816 Register bits
    namespace wf7816_bits {
        constexpr uint32_t GTFD = (8 << 0);  ///< FD Multiplier
    }

    /// ET7816 Register bits
    namespace et7816_bits {
        constexpr uint32_t RXTHRESHOLD = (4 << 0);  ///< Receive NACK Threshold
        constexpr uint32_t TXTHRESHOLD = (4 << 4);  ///< Transmit NACK Threshold
    }

    /// TL7816 Register bits
    namespace tl7816_bits {
        constexpr uint32_t TLEN = (8 << 0);  ///< Transmit Length
    }

    /// AP7816A_T0 Register bits
    namespace ap7816a_t0_bits {
        constexpr uint32_t ADTI_H = (8 << 0);  ///< ATR Duration Time Integer High (C7816[TTYPE] = 0)
    }

    /// AP7816B_T0 Register bits
    namespace ap7816b_t0_bits {
        constexpr uint32_t ADTI_L = (8 << 0);  ///< ATR Duration Time Integer Low (C7816[TTYPE] = 0)
    }

    /// WP7816A_T0 Register bits
    namespace wp7816a_t0_bits {
        constexpr uint32_t WI_H = (8 << 0);  ///< Wait Time Integer High (C7816[TTYPE] = 0)
    }

    /// WP7816A_T1 Register bits
    namespace wp7816a_t1_bits {
        constexpr uint32_t BWI_H = (8 << 0);  ///< Block Wait Time Integer High (C7816[TTYPE] = 1)
    }

    /// WP7816B_T0 Register bits
    namespace wp7816b_t0_bits {
        constexpr uint32_t WI_L = (8 << 0);  ///< Wait Time Integer Low (C7816[TTYPE] = 0)
    }

    /// WP7816B_T1 Register bits
    namespace wp7816b_t1_bits {
        constexpr uint32_t BWI_L = (8 << 0);  ///< Block Wait Time Integer Low (C7816[TTYPE] = 1)
    }

    /// WGP7816_T1 Register bits
    namespace wgp7816_t1_bits {
        constexpr uint32_t BGI = (4 << 0);  ///< Block Guard Time Integer (C7816[TTYPE] = 1)
        constexpr uint32_t CWI1 = (4 << 4);  ///< Character Wait Time Integer 1 (C7816[TTYPE] = 1)
    }

    /// WP7816C_T1 Register bits
    namespace wp7816c_t1_bits {
        constexpr uint32_t CWI2 = (5 << 0);  ///< Character Wait Time Integer 2 (C7816[TTYPE] = 1)
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40073000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
    }

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x40073008;

    /// CMP1 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
    }

}

// ============================================================================
// CMP2 Peripheral
// ============================================================================

namespace cmp2 {
    /// Base addresses
    constexpr uint32_t CMP2_BASE = 0x40073010;

    /// CMP2 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP2 = reinterpret_cast<Registers*>(CMP2_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
    }

}

// ============================================================================
// CMP3 Peripheral
// ============================================================================

namespace cmp3 {
    /// Base addresses
    constexpr uint32_t CMP3_BASE = 0x40073018;

    /// CMP3 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP3 = reinterpret_cast<Registers*>(CMP3_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
    }

}

// ============================================================================
// LLWU Peripheral
// ============================================================================

namespace llwu {
    /// Base addresses
    constexpr uint32_t LLWU_BASE = 0x4007C000;

    /// LLWU Register structure
    struct Registers {
        volatile uint32_t PE1;  ///< Offset: 0x00 - LLWU Pin Enable 1 register
        volatile uint32_t PE2;  ///< Offset: 0x01 - LLWU Pin Enable 2 register
        volatile uint32_t PE3;  ///< Offset: 0x02 - LLWU Pin Enable 3 register
        volatile uint32_t PE4;  ///< Offset: 0x03 - LLWU Pin Enable 4 register
        volatile uint32_t PE5;  ///< Offset: 0x04 - LLWU Pin Enable 5 register
        volatile uint32_t PE6;  ///< Offset: 0x05 - LLWU Pin Enable 6 register
        volatile uint32_t PE7;  ///< Offset: 0x06 - LLWU Pin Enable 7 register
        volatile uint32_t PE8;  ///< Offset: 0x07 - LLWU Pin Enable 8 register
        volatile uint32_t ME;  ///< Offset: 0x08 - LLWU Module Enable register
        volatile uint32_t PF1;  ///< Offset: 0x09 - LLWU Pin Flag 1 register
        volatile uint32_t PF2;  ///< Offset: 0x0A - LLWU Pin Flag 2 register
        volatile uint32_t PF3;  ///< Offset: 0x0B - LLWU Pin Flag 3 register
        volatile uint32_t PF4;  ///< Offset: 0x0C - LLWU Pin Flag 4 register
        volatile uint32_t MF5;  ///< Offset: 0x0D - LLWU Module Flag 5 register
        volatile uint32_t FILT1;  ///< Offset: 0x0E - LLWU Pin Filter 1 register
        volatile uint32_t FILT2;  ///< Offset: 0x0F - LLWU Pin Filter 2 register
    };

    /// Peripheral instances
    inline Registers* LLWU = reinterpret_cast<Registers*>(LLWU_BASE);

    // Bit definitions
    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P3
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE4 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P7
    }

    /// PE3 Register bits
    namespace pe3_bits {
        constexpr uint32_t WUPE8 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P11
    }

    /// PE4 Register bits
    namespace pe4_bits {
        constexpr uint32_t WUPE12 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P15
    }

    /// PE5 Register bits
    namespace pe5_bits {
        constexpr uint32_t WUPE16 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P16
        constexpr uint32_t WUPE17 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P17
        constexpr uint32_t WUPE18 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P18
        constexpr uint32_t WUPE19 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P19
    }

    /// PE6 Register bits
    namespace pe6_bits {
        constexpr uint32_t WUPE20 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P20
        constexpr uint32_t WUPE21 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P21
        constexpr uint32_t WUPE22 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P22
        constexpr uint32_t WUPE23 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P23
    }

    /// PE7 Register bits
    namespace pe7_bits {
        constexpr uint32_t WUPE24 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P24
        constexpr uint32_t WUPE25 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P25
        constexpr uint32_t WUPE26 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P26
        constexpr uint32_t WUPE27 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P27
    }

    /// PE8 Register bits
    namespace pe8_bits {
        constexpr uint32_t WUPE28 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P28
        constexpr uint32_t WUPE29 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P29
        constexpr uint32_t WUPE30 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P30
        constexpr uint32_t WUPE31 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P31
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable For Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable For Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable For Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable For Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable For Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable For Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable For Module 7
    }

    /// PF1 Register bits
    namespace pf1_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag For LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag For LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag For LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag For LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag For LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag For LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag For LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag For LLWU_P7
    }

    /// PF2 Register bits
    namespace pf2_bits {
        constexpr uint32_t WUF8 = (1U << 0);  ///< Wakeup Flag For LLWU_P8
        constexpr uint32_t WUF9 = (1U << 1);  ///< Wakeup Flag For LLWU_P9
        constexpr uint32_t WUF10 = (1U << 2);  ///< Wakeup Flag For LLWU_P10
        constexpr uint32_t WUF11 = (1U << 3);  ///< Wakeup Flag For LLWU_P11
        constexpr uint32_t WUF12 = (1U << 4);  ///< Wakeup Flag For LLWU_P12
        constexpr uint32_t WUF13 = (1U << 5);  ///< Wakeup Flag For LLWU_P13
        constexpr uint32_t WUF14 = (1U << 6);  ///< Wakeup Flag For LLWU_P14
        constexpr uint32_t WUF15 = (1U << 7);  ///< Wakeup Flag For LLWU_P15
    }

    /// PF3 Register bits
    namespace pf3_bits {
        constexpr uint32_t WUF16 = (1U << 0);  ///< Wakeup Flag For LLWU_P16
        constexpr uint32_t WUF17 = (1U << 1);  ///< Wakeup Flag For LLWU_P17
        constexpr uint32_t WUF18 = (1U << 2);  ///< Wakeup Flag For LLWU_P18
        constexpr uint32_t WUF19 = (1U << 3);  ///< Wakeup Flag For LLWU_P19
        constexpr uint32_t WUF20 = (1U << 4);  ///< Wakeup Flag For LLWU_P20
        constexpr uint32_t WUF21 = (1U << 5);  ///< Wakeup Flag For LLWU_P21
        constexpr uint32_t WUF22 = (1U << 6);  ///< Wakeup Flag For LLWU_P22
        constexpr uint32_t WUF23 = (1U << 7);  ///< Wakeup Flag For LLWU_P23
    }

    /// PF4 Register bits
    namespace pf4_bits {
        constexpr uint32_t WUF24 = (1U << 0);  ///< Wakeup Flag For LLWU_P24
        constexpr uint32_t WUF25 = (1U << 1);  ///< Wakeup Flag For LLWU_P25
        constexpr uint32_t WUF26 = (1U << 2);  ///< Wakeup Flag For LLWU_P26
        constexpr uint32_t WUF27 = (1U << 3);  ///< Wakeup Flag For LLWU_P27
        constexpr uint32_t WUF28 = (1U << 4);  ///< Wakeup Flag For LLWU_P28
        constexpr uint32_t WUF29 = (1U << 5);  ///< Wakeup Flag For LLWU_P29
        constexpr uint32_t WUF30 = (1U << 6);  ///< Wakeup Flag For LLWU_P30
        constexpr uint32_t WUF31 = (1U << 7);  ///< Wakeup Flag For LLWU_P31
    }

    /// MF5 Register bits
    namespace mf5_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag For module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag For module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag For module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag For module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag For module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag For module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag For module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag For module 7
    }

    /// FILT1 Register bits
    namespace filt1_bits {
        constexpr uint32_t FILTSEL = (5 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT2 Register bits
    namespace filt2_bits {
        constexpr uint32_t FILTSEL = (5 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status And Control 1 register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status And Control 2 register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status And Control register
        volatile uint32_t HVDSC1;  ///< Offset: 0x0B - High Voltage Detect Status And Control 1 register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDV = (2 << 0);  ///< Low-Voltage Detect Voltage Select
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low-Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low-Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low-Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWV = (2 << 0);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t REGONS = (1U << 2);  ///< Regulator In Run Regulation Status
        constexpr uint32_t ACKISO = (1U << 3);  ///< Acknowledge Isolation
        constexpr uint32_t BGEN = (1U << 4);  ///< Bandgap Enable In VLPx Operation
    }

    /// HVDSC1 Register bits
    namespace hvdsc1_bits {
        constexpr uint32_t HVDV = (1U << 0);  ///< High-Voltage Detect Voltage Select
        constexpr uint32_t HVDRE = (1U << 4);  ///< High-Voltage Detect Reset Enable
        constexpr uint32_t HVDIE = (1U << 5);  ///< High-Voltage Detect Interrupt Enable
        constexpr uint32_t HVDACK = (1U << 6);  ///< High-Voltage Detect Acknowledge
        constexpr uint32_t HVDF = (1U << 7);  ///< High-Voltage Detect Flag
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t PMPROT;  ///< Offset: 0x00 - Power Mode Protection register
        volatile uint32_t PMCTRL;  ///< Offset: 0x01 - Power Mode Control register
        volatile uint32_t STOPCTRL;  ///< Offset: 0x02 - Stop Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x03 - Power Mode Status register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLLS = (1U << 1);  ///< Allow Very-Low-Leakage Stop Mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very-Low-Power Modes
        constexpr uint32_t AHSRUN = (1U << 7);  ///< Allow High Speed Run mode
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
    }

    /// STOPCTRL Register bits
    namespace stopctrl_bits {
        constexpr uint32_t VLLSM = (3 << 0);  ///< VLLS Mode Control
        constexpr uint32_t LPOPO = (1U << 3);  ///< LPO Power Option
        constexpr uint32_t RAM2PO = (1U << 4);  ///< RAM2 Power Option
        constexpr uint32_t PORPO = (1U << 5);  ///< POR Power Option
        constexpr uint32_t PSTOPO = (2 << 6);  ///< Partial Stop Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (8 << 0);  ///< Power Mode Status
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007F000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t SRS0;  ///< Offset: 0x00 - System Reset Status Register 0
        volatile uint32_t SRS1;  ///< Offset: 0x01 - System Reset Status Register 1
        volatile uint32_t RPFC;  ///< Offset: 0x04 - Reset Pin Filter Control register
        volatile uint32_t RPFW;  ///< Offset: 0x05 - Reset Pin Filter Width register
        volatile uint32_t SSRS0;  ///< Offset: 0x08 - Sticky System Reset Status Register 0
        volatile uint32_t SSRS1;  ///< Offset: 0x09 - Sticky System Reset Status Register 1
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// SRS0 Register bits
    namespace srs0_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Low Leakage Wakeup Reset
        constexpr uint32_t LVD = (1U << 1);  ///< Low-Voltage Detect Reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-Clock Reset
        constexpr uint32_t LOL = (1U << 3);  ///< Loss-of-Lock Reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
    }

    /// SRS1 Register bits
    namespace srs1_bits {
        constexpr uint32_t JTAG = (1U << 0);  ///< JTAG Generated Reset
        constexpr uint32_t LOCKUP = (1U << 1);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 2);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 3);  ///< MDM-AP System Reset Request
        constexpr uint32_t SACKERR = (1U << 5);  ///< Stop Mode Acknowledge Error Reset
    }

    /// RPFC Register bits
    namespace rpfc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset Pin Filter Select in Run and Wait Modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset Pin Filter Select in Stop Mode
    }

    /// RPFW Register bits
    namespace rpfw_bits {
        constexpr uint32_t RSTFLTSEL = (5 << 0);  ///< Reset Pin Filter Bus Clock Select
    }

    /// SSRS0 Register bits
    namespace ssrs0_bits {
        constexpr uint32_t SWAKEUP = (1U << 0);  ///< Sticky Low Leakage Wakeup Reset
        constexpr uint32_t SLVD = (1U << 1);  ///< Sticky Low-Voltage Detect Reset
        constexpr uint32_t SLOC = (1U << 2);  ///< Sticky Loss-of-Clock Reset
        constexpr uint32_t SLOL = (1U << 3);  ///< Sticky Loss-of-Lock Reset
        constexpr uint32_t SWDOG = (1U << 5);  ///< Sticky Watchdog
        constexpr uint32_t SPIN = (1U << 6);  ///< Sticky External Reset Pin
        constexpr uint32_t SPOR = (1U << 7);  ///< Sticky Power-On Reset
    }

    /// SSRS1 Register bits
    namespace ssrs1_bits {
        constexpr uint32_t SJTAG = (1U << 0);  ///< Sticky JTAG Generated Reset
        constexpr uint32_t SLOCKUP = (1U << 1);  ///< Sticky Core Lockup
        constexpr uint32_t SSW = (1U << 2);  ///< Sticky Software
        constexpr uint32_t SMDM_AP = (1U << 3);  ///< Sticky MDM-AP System Reset Request
        constexpr uint32_t SSACKERR = (1U << 5);  ///< Sticky Stop Mode Acknowledge Error Reset
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t TRNG0_BASE = 0x400A0000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t TRNG0_MCTL;  ///< Offset: 0x00 - RNG Miscellaneous Control Register
        volatile uint32_t TRNG0_SCMISC;  ///< Offset: 0x04 - RNG Statistical Check Miscellaneous Register
        volatile uint32_t TRNG0_PKRRNG;  ///< Offset: 0x08 - RNG Poker Range Register
        volatile uint32_t TRNG0_PKRMAX;  ///< Offset: 0x0C - RNG Poker Maximum Limit Register
        volatile uint32_t TRNG0_PKRSQ;  ///< Offset: 0x0C - RNG Poker Square Calculation Result Register
        volatile uint32_t TRNG0_SDCTL;  ///< Offset: 0x10 - RNG Seed Control Register
        volatile uint32_t TRNG0_SBLIM;  ///< Offset: 0x14 - RNG Sparse Bit Limit Register
        volatile uint32_t TRNG0_TOTSAM;  ///< Offset: 0x14 - RNG Total Samples Register
        volatile uint32_t TRNG0_FRQMIN;  ///< Offset: 0x18 - RNG Frequency Count Minimum Limit Register
        volatile uint32_t TRNG0_FRQCNT;  ///< Offset: 0x1C - RNG Frequency Count Register
        volatile uint32_t TRNG0_FRQMAX;  ///< Offset: 0x1C - RNG Frequency Count Maximum Limit Register
        volatile uint32_t TRNG0_SCMC;  ///< Offset: 0x20 - RNG Statistical Check Monobit Count Register
        volatile uint32_t TRNG0_SCML;  ///< Offset: 0x20 - RNG Statistical Check Monobit Limit Register
        volatile uint32_t TRNG0_SCR1C;  ///< Offset: 0x24 - RNG Statistical Check Run Length 1 Count Register
        volatile uint32_t TRNG0_SCR1L;  ///< Offset: 0x24 - RNG Statistical Check Run Length 1 Limit Register
        volatile uint32_t TRNG0_SCR2C;  ///< Offset: 0x28 - RNG Statistical Check Run Length 2 Count Register
        volatile uint32_t TRNG0_SCR2L;  ///< Offset: 0x28 - RNG Statistical Check Run Length 2 Limit Register
        volatile uint32_t TRNG0_SCR3C;  ///< Offset: 0x2C - RNG Statistical Check Run Length 3 Count Register
        volatile uint32_t TRNG0_SCR3L;  ///< Offset: 0x2C - RNG Statistical Check Run Length 3 Limit Register
        volatile uint32_t TRNG0_SCR4C;  ///< Offset: 0x30 - RNG Statistical Check Run Length 4 Count Register
        volatile uint32_t TRNG0_SCR4L;  ///< Offset: 0x30 - RNG Statistical Check Run Length 4 Limit Register
        volatile uint32_t TRNG0_SCR5C;  ///< Offset: 0x34 - RNG Statistical Check Run Length 5 Count Register
        volatile uint32_t TRNG0_SCR5L;  ///< Offset: 0x34 - RNG Statistical Check Run Length 5 Limit Register
        volatile uint32_t TRNG0_SCR6PC;  ///< Offset: 0x38 - RNG Statistical Check Run Length 6+ Count Register
        volatile uint32_t TRNG0_SCR6PL;  ///< Offset: 0x38 - RNG Statistical Check Run Length 6+ Limit Register
        volatile uint32_t TRNG0_STATUS;  ///< Offset: 0x3C - RNG Status Register
        volatile uint32_t TRNG0_ENT0;  ///< Offset: 0x40 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT1;  ///< Offset: 0x44 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT2;  ///< Offset: 0x48 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT3;  ///< Offset: 0x4C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT4;  ///< Offset: 0x50 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT5;  ///< Offset: 0x54 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT6;  ///< Offset: 0x58 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT7;  ///< Offset: 0x5C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT8;  ///< Offset: 0x60 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT9;  ///< Offset: 0x64 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT10;  ///< Offset: 0x68 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT11;  ///< Offset: 0x6C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT12;  ///< Offset: 0x70 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT13;  ///< Offset: 0x74 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT14;  ///< Offset: 0x78 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT15;  ///< Offset: 0x7C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_PKRCNT10;  ///< Offset: 0x80 - RNG Statistical Check Poker Count 1 and 0 Register
        volatile uint32_t TRNG0_PKRCNT32;  ///< Offset: 0x84 - RNG Statistical Check Poker Count 3 and 2 Register
        volatile uint32_t TRNG0_PKRCNT54;  ///< Offset: 0x88 - RNG Statistical Check Poker Count 5 and 4 Register
        volatile uint32_t TRNG0_PKRCNT76;  ///< Offset: 0x8C - RNG Statistical Check Poker Count 7 and 6 Register
        volatile uint32_t TRNG0_PKRCNT98;  ///< Offset: 0x90 - RNG Statistical Check Poker Count 9 and 8 Register
        volatile uint32_t TRNG0_PKRCNTBA;  ///< Offset: 0x94 - RNG Statistical Check Poker Count B and A Register
        volatile uint32_t TRNG0_PKRCNTDC;  ///< Offset: 0x98 - RNG Statistical Check Poker Count D and C Register
        volatile uint32_t TRNG0_PKRCNTFE;  ///< Offset: 0x9C - RNG Statistical Check Poker Count F and E Register
        volatile uint32_t TRNG0_SEC_CFG;  ///< Offset: 0xB0 - RNG Security Configuration Register
        volatile uint32_t TRNG0_INT_CTRL;  ///< Offset: 0xB4 - RNG Interrupt Control Register
        volatile uint32_t TRNG0_INT_MASK;  ///< Offset: 0xB8 - RNG Mask Register
        volatile uint32_t TRNG0_INT_STATUS;  ///< Offset: 0xBC - RNG Interrupt Status Register
        volatile uint32_t TRNG0_VID1;  ///< Offset: 0xF0 - RNG Version ID Register (MS)
        volatile uint32_t TRNG0_VID2;  ///< Offset: 0xF4 - RNG Version ID Register (LS)
    };

    /// Peripheral instances
    inline Registers* TRNG0 = reinterpret_cast<Registers*>(TRNG0_BASE);

    // Bit definitions
    /// TRNG0_MCTL Register bits
    namespace trng0_mctl_bits {
        constexpr uint32_t SAMP_MODE = (2 << 0);  ///< Sample Mode
        constexpr uint32_t OSC_DIV = (2 << 2);  ///< Oscillator Divide
        constexpr uint32_t UNUSED = (1U << 4);  ///< This bit is unused but write-able. Must be left as zero.
        constexpr uint32_t TRNG_ACC = (1U << 5);  ///< TRNG Access Mode
        constexpr uint32_t RST_DEF = (1U << 6);  ///< Reset Defaults
        constexpr uint32_t FOR_SCLK = (1U << 7);  ///< Force System Clock
        constexpr uint32_t FCT_FAIL = (1U << 8);  ///< Read only: Frequency Count Fail
        constexpr uint32_t FCT_VAL = (1U << 9);  ///< Read only: Frequency Count Valid. Indicates that a valid frequency count may be read from FRQCNT.
        constexpr uint32_t ENT_VAL = (1U << 10);  ///< Read only: Entropy Valid
        constexpr uint32_t TST_OUT = (1U << 11);  ///< Read only: Test point inside ring oscillator.
        constexpr uint32_t ERR = (1U << 12);  ///< Read: Error status
        constexpr uint32_t TSTOP_OK = (1U << 13);  ///< TRNG_OK_TO_STOP
        constexpr uint32_t PRGM = (1U << 16);  ///< Programming Mode Select
    }

    /// TRNG0_SCMISC Register bits
    namespace trng0_scmisc_bits {
        constexpr uint32_t LRUN_MAX = (8 << 0);  ///< LONG RUN MAX LIMIT
        constexpr uint32_t RTY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// TRNG0_PKRRNG Register bits
    namespace trng0_pkrrng_bits {
        constexpr uint32_t PKR_RNG = (16 << 0);  ///< Poker Range
    }

    /// TRNG0_PKRMAX Register bits
    namespace trng0_pkrmax_bits {
        constexpr uint32_t PKR_MAX = (24 << 0);  ///< Poker Maximum Limit
    }

    /// TRNG0_PKRSQ Register bits
    namespace trng0_pkrsq_bits {
        constexpr uint32_t PKR_SQ = (24 << 0);  ///< Poker Square Calculation Result
    }

    /// TRNG0_SDCTL Register bits
    namespace trng0_sdctl_bits {
        constexpr uint32_t SAMP_SIZE = (16 << 0);  ///< Sample Size
        constexpr uint32_t ENT_DLY = (16 << 16);  ///< Entropy Delay
    }

    /// TRNG0_SBLIM Register bits
    namespace trng0_sblim_bits {
        constexpr uint32_t SB_LIM = (10 << 0);  ///< Sparse Bit Limit
    }

    /// TRNG0_TOTSAM Register bits
    namespace trng0_totsam_bits {
        constexpr uint32_t TOT_SAM = (20 << 0);  ///< Total Samples
    }

    /// TRNG0_FRQMIN Register bits
    namespace trng0_frqmin_bits {
        constexpr uint32_t FRQ_MIN = (22 << 0);  ///< Frequency Count Minimum Limit
    }

    /// TRNG0_FRQCNT Register bits
    namespace trng0_frqcnt_bits {
        constexpr uint32_t FRQ_CT = (22 << 0);  ///< Frequency Count
    }

    /// TRNG0_FRQMAX Register bits
    namespace trng0_frqmax_bits {
        constexpr uint32_t FRQ_MAX = (22 << 0);  ///< Frequency Counter Maximum Limit
    }

    /// TRNG0_SCMC Register bits
    namespace trng0_scmc_bits {
        constexpr uint32_t MONO_CT = (16 << 0);  ///< Monobit Count
    }

    /// TRNG0_SCML Register bits
    namespace trng0_scml_bits {
        constexpr uint32_t MONO_MAX = (16 << 0);  ///< Monobit Maximum Limit
        constexpr uint32_t MONO_RNG = (16 << 16);  ///< Monobit Range
    }

    /// TRNG0_SCR1C Register bits
    namespace trng0_scr1c_bits {
        constexpr uint32_t R1_0_CT = (15 << 0);  ///< Runs of Zero, Length 1 Count
        constexpr uint32_t R1_1_CT = (15 << 16);  ///< Runs of One, Length 1 Count
    }

    /// TRNG0_SCR1L Register bits
    namespace trng0_scr1l_bits {
        constexpr uint32_t RUN1_MAX = (15 << 0);  ///< Run Length 1 Maximum Limit
        constexpr uint32_t RUN1_RNG = (15 << 16);  ///< Run Length 1 Range
    }

    /// TRNG0_SCR2C Register bits
    namespace trng0_scr2c_bits {
        constexpr uint32_t R2_0_CT = (14 << 0);  ///< Runs of Zero, Length 2 Count
        constexpr uint32_t R2_1_CT = (14 << 16);  ///< Runs of One, Length 2 Count
    }

    /// TRNG0_SCR2L Register bits
    namespace trng0_scr2l_bits {
        constexpr uint32_t RUN2_MAX = (14 << 0);  ///< Run Length 2 Maximum Limit
        constexpr uint32_t RUN2_RNG = (14 << 16);  ///< Run Length 2 Range
    }

    /// TRNG0_SCR3C Register bits
    namespace trng0_scr3c_bits {
        constexpr uint32_t R3_0_CT = (13 << 0);  ///< Runs of Zeroes, Length 3 Count
        constexpr uint32_t R3_1_CT = (13 << 16);  ///< Runs of Ones, Length 3 Count
    }

    /// TRNG0_SCR3L Register bits
    namespace trng0_scr3l_bits {
        constexpr uint32_t RUN3_MAX = (13 << 0);  ///< Run Length 3 Maximum Limit
        constexpr uint32_t RUN3_RNG = (13 << 16);  ///< Run Length 3 Range
    }

    /// TRNG0_SCR4C Register bits
    namespace trng0_scr4c_bits {
        constexpr uint32_t R4_0_CT = (12 << 0);  ///< Runs of Zero, Length 4 Count
        constexpr uint32_t R4_1_CT = (12 << 16);  ///< Runs of One, Length 4 Count
    }

    /// TRNG0_SCR4L Register bits
    namespace trng0_scr4l_bits {
        constexpr uint32_t RUN4_MAX = (12 << 0);  ///< Run Length 4 Maximum Limit
        constexpr uint32_t RUN4_RNG = (12 << 16);  ///< Run Length 4 Range
    }

    /// TRNG0_SCR5C Register bits
    namespace trng0_scr5c_bits {
        constexpr uint32_t R5_0_CT = (11 << 0);  ///< Runs of Zero, Length 5 Count
        constexpr uint32_t R5_1_CT = (11 << 16);  ///< Runs of One, Length 5 Count
    }

    /// TRNG0_SCR5L Register bits
    namespace trng0_scr5l_bits {
        constexpr uint32_t RUN5_MAX = (11 << 0);  ///< Run Length 5 Maximum Limit
        constexpr uint32_t RUN5_RNG = (11 << 16);  ///< Run Length 5 Range
    }

    /// TRNG0_SCR6PC Register bits
    namespace trng0_scr6pc_bits {
        constexpr uint32_t R6P_0_CT = (11 << 0);  ///< Runs of Zero, Length 6+ Count
        constexpr uint32_t R6P_1_CT = (11 << 16);  ///< Runs of One, Length 6+ Count
    }

    /// TRNG0_SCR6PL Register bits
    namespace trng0_scr6pl_bits {
        constexpr uint32_t RUN6P_MAX = (11 << 0);  ///< Run Length 6+ Maximum Limit
        constexpr uint32_t RUN6P_RNG = (11 << 16);  ///< Run Length 6+ Range
    }

    /// TRNG0_STATUS Register bits
    namespace trng0_status_bits {
        constexpr uint32_t TF1BR0 = (1U << 0);  ///< Test Fail, 1-Bit Run, Sampling 0s. If TF1BR0=1, the 1-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF1BR1 = (1U << 1);  ///< Test Fail, 1-Bit Run, Sampling 1s. If TF1BR1=1, the 1-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF2BR0 = (1U << 2);  ///< Test Fail, 2-Bit Run, Sampling 0s. If TF2BR0=1, the 2-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF2BR1 = (1U << 3);  ///< Test Fail, 2-Bit Run, Sampling 1s. If TF2BR1=1, the 2-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF3BR0 = (1U << 4);  ///< Test Fail, 3-Bit Run, Sampling 0s. If TF3BR0=1, the 3-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF3BR1 = (1U << 5);  ///< Test Fail, 3-Bit Run, Sampling 1s. If TF3BR1=1, the 3-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF4BR0 = (1U << 6);  ///< Test Fail, 4-Bit Run, Sampling 0s. If TF4BR0=1, the 4-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF4BR1 = (1U << 7);  ///< Test Fail, 4-Bit Run, Sampling 1s. If TF4BR1=1, the 4-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF5BR0 = (1U << 8);  ///< Test Fail, 5-Bit Run, Sampling 0s. If TF5BR0=1, the 5-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF5BR1 = (1U << 9);  ///< Test Fail, 5-Bit Run, Sampling 1s. If TF5BR1=1, the 5-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF6PBR0 = (1U << 10);  ///< Test Fail, 6 Plus Bit Run, Sampling 0s
        constexpr uint32_t TF6PBR1 = (1U << 11);  ///< Test Fail, 6 Plus Bit Run, Sampling 1s
        constexpr uint32_t TFSB = (1U << 12);  ///< Test Fail, Sparse Bit. If TFSB=1, the Sparse Bit Test has failed.
        constexpr uint32_t TFLR = (1U << 13);  ///< Test Fail, Long Run. If TFLR=1, the Long Run Test has failed.
        constexpr uint32_t TFP = (1U << 14);  ///< Test Fail, Poker. If TFP=1, the Poker Test has failed.
        constexpr uint32_t TFMB = (1U << 15);  ///< Test Fail, Mono Bit. If TFMB=1, the Mono Bit Test has failed.
        constexpr uint32_t RETRY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// TRNG0_ENT0 Register bits
    namespace trng0_ent0_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT1 Register bits
    namespace trng0_ent1_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT2 Register bits
    namespace trng0_ent2_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT3 Register bits
    namespace trng0_ent3_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT4 Register bits
    namespace trng0_ent4_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT5 Register bits
    namespace trng0_ent5_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT6 Register bits
    namespace trng0_ent6_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT7 Register bits
    namespace trng0_ent7_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT8 Register bits
    namespace trng0_ent8_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT9 Register bits
    namespace trng0_ent9_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT10 Register bits
    namespace trng0_ent10_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT11 Register bits
    namespace trng0_ent11_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT12 Register bits
    namespace trng0_ent12_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT13 Register bits
    namespace trng0_ent13_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT14 Register bits
    namespace trng0_ent14_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT15 Register bits
    namespace trng0_ent15_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_PKRCNT10 Register bits
    namespace trng0_pkrcnt10_bits {
        constexpr uint32_t PKR_0_CT = (16 << 0);  ///< Poker 0h Count
        constexpr uint32_t PKR_1_CT = (16 << 16);  ///< Poker 1h Count
    }

    /// TRNG0_PKRCNT32 Register bits
    namespace trng0_pkrcnt32_bits {
        constexpr uint32_t PKR_2_CT = (16 << 0);  ///< Poker 2h Count
        constexpr uint32_t PKR_3_CT = (16 << 16);  ///< Poker 3h Count
    }

    /// TRNG0_PKRCNT54 Register bits
    namespace trng0_pkrcnt54_bits {
        constexpr uint32_t PKR_4_CT = (16 << 0);  ///< Poker 4h Count
        constexpr uint32_t PKR_5_CT = (16 << 16);  ///< Poker 5h Count
    }

    /// TRNG0_PKRCNT76 Register bits
    namespace trng0_pkrcnt76_bits {
        constexpr uint32_t PKR_6_CT = (16 << 0);  ///< Poker 6h Count
        constexpr uint32_t PKR_7_CT = (16 << 16);  ///< Poker 7h Count
    }

    /// TRNG0_PKRCNT98 Register bits
    namespace trng0_pkrcnt98_bits {
        constexpr uint32_t PKR_8_CT = (16 << 0);  ///< Poker 8h Count
        constexpr uint32_t PKR_9_CT = (16 << 16);  ///< Poker 9h Count
    }

    /// TRNG0_PKRCNTBA Register bits
    namespace trng0_pkrcntba_bits {
        constexpr uint32_t PKR_A_CT = (16 << 0);  ///< Poker Ah Count
        constexpr uint32_t PKR_B_CT = (16 << 16);  ///< Poker Bh Count
    }

    /// TRNG0_PKRCNTDC Register bits
    namespace trng0_pkrcntdc_bits {
        constexpr uint32_t PKR_C_CT = (16 << 0);  ///< Poker Ch Count
        constexpr uint32_t PKR_D_CT = (16 << 16);  ///< Poker Dh Count
    }

    /// TRNG0_PKRCNTFE Register bits
    namespace trng0_pkrcntfe_bits {
        constexpr uint32_t PKR_E_CT = (16 << 0);  ///< Poker Eh Count
        constexpr uint32_t PKR_F_CT = (16 << 16);  ///< Poker Fh Count
    }

    /// TRNG0_SEC_CFG Register bits
    namespace trng0_sec_cfg_bits {
        constexpr uint32_t SH0 = (1U << 0);  ///< Reserved. DRNG specific, not applicable to this version.
        constexpr uint32_t NO_PRGM = (1U << 1);  ///< If set the TRNG registers cannot be programmed
        constexpr uint32_t SK_VAL = (1U << 2);  ///< Reserved. DRNG-specific, not applicable to this version.
    }

    /// TRNG0_INT_CTRL Register bits
    namespace trng0_int_ctrl_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 above.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 above.
        constexpr uint32_t UNUSED = (29 << 3);  ///< Reserved but writeable.
    }

    /// TRNG0_INT_MASK Register bits
    namespace trng0_int_mask_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 above.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 above.
    }

    /// TRNG0_INT_STATUS Register bits
    namespace trng0_int_status_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Read: Error status
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Read only: Entropy Valid
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Read only: Frequency Count Fail
    }

    /// TRNG0_VID1 Register bits
    namespace trng0_vid1_bits {
        constexpr uint32_t RNG_MIN_REV = (8 << 0);  ///< Shows the Freescale IP's Minor revision of the TRNG.
        constexpr uint32_t RNG_MAJ_REV = (8 << 8);  ///< Shows the Freescale IP's Major revision of the TRNG.
        constexpr uint32_t RNG_IP_ID = (16 << 16);  ///< Shows the Freescale IP ID.
    }

    /// TRNG0_VID2 Register bits
    namespace trng0_vid2_bits {
        constexpr uint32_t RNG_CONFIG_OPT = (8 << 0);  ///< Shows the Freescale IP's Configuaration options for the TRNG.
        constexpr uint32_t RNG_ECO_REV = (8 << 8);  ///< Shows the Freescale IP's ECO revision of the TRNG.
        constexpr uint32_t RNG_INTG_OPT = (8 << 16);  ///< Shows the Freescale integration options for the TRNG.
        constexpr uint32_t RNG_ERA = (8 << 24);  ///< Shows the Freescale compile options for the TRNG.
    }

}

// ============================================================================
// SystemControl Peripheral
// ============================================================================

namespace systemcontrol {
    /// Base addresses
    constexpr uint32_t SystemControl_BASE = 0xE000E000;

    /// SystemControl Register structure
    struct Registers {
        volatile uint32_t ACTLR;  ///< Offset: 0x08 - Auxiliary Control Register,
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control and State Register
        volatile uint32_t VTOR;  ///< Offset: 0xD08 - Vector Table Offset Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt and Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration and Control Register
        volatile uint32_t SHPR1;  ///< Offset: 0xD18 - System Handler Priority Register 1
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
        volatile uint32_t CFSR;  ///< Offset: 0xD28 - Configurable Fault Status Register
        volatile uint32_t HFSR;  ///< Offset: 0xD2C - HardFault Status register
        volatile uint32_t DFSR;  ///< Offset: 0xD30 - Debug Fault Status Register
        volatile uint32_t MMFAR;  ///< Offset: 0xD34 - MemManage Fault Address Register
        volatile uint32_t BFAR;  ///< Offset: 0xD38 - BusFault Address Register
        volatile uint32_t AFSR;  ///< Offset: 0xD3C - Auxiliary Fault Status Register
        volatile uint32_t ID_PFR0;  ///< Offset: 0xD40 - Processor Feature Register 0
        volatile uint32_t ID_PFR1;  ///< Offset: 0xD44 - Processor Feature Register 1
        volatile uint32_t ID_DFR0;  ///< Offset: 0xD48 - Debug Feature Register
        volatile uint32_t ID_AFR0;  ///< Offset: 0xD4C - Auxiliary Feature Register
        volatile uint32_t ID_MMFR0;  ///< Offset: 0xD50 - Memory Model Feature Register 0
        volatile uint32_t ID_MMFR1;  ///< Offset: 0xD54 - Memory Model Feature Register 1
        volatile uint32_t ID_MMFR2;  ///< Offset: 0xD58 - Memory Model Feature Register 2
        volatile uint32_t ID_MMFR3;  ///< Offset: 0xD5C - Memory Model Feature Register 3
        volatile uint32_t ID_ISAR0;  ///< Offset: 0xD60 - Instruction Set Attributes Register 0
        volatile uint32_t ID_ISAR1;  ///< Offset: 0xD64 - Instruction Set Attributes Register 1
        volatile uint32_t ID_ISAR2;  ///< Offset: 0xD68 - Instruction Set Attributes Register 2
        volatile uint32_t ID_ISAR3;  ///< Offset: 0xD6C - Instruction Set Attributes Register 3
        volatile uint32_t ID_ISAR4;  ///< Offset: 0xD70 - Instruction Set Attributes Register 4
        volatile uint32_t CLIDR;  ///< Offset: 0xD78 - Cache Level ID register
        volatile uint32_t CTR;  ///< Offset: 0xD7C - Cache Type register
        volatile uint32_t CCSIDR;  ///< Offset: 0xD80 - Cache Size ID Register
        volatile uint32_t CSSELR;  ///< Offset: 0xD84 - Cache Size Selection Register
        volatile uint32_t CPACR;  ///< Offset: 0xD88 - Coprocessor Access Control Register
        volatile uint32_t STIR;  ///< Offset: 0xF00 - Software Triggered Interrupt Register
        volatile uint32_t MVFR0;  ///< Offset: 0xF40 - Media and FP Feature Register 0
        volatile uint32_t MVFR1;  ///< Offset: 0xF44 - Media and FP Feature Register 1
        volatile uint32_t MVFR2;  ///< Offset: 0xF48 - Media and FP Feature Register 2
        volatile uint32_t ICIALLU;  ///< Offset: 0xF50 - Instruction cache invalidate all to Point of Unification (PoU)
        volatile uint32_t ICIMVAU;  ///< Offset: 0xF58 - Instruction cache invalidate by address to PoU
        volatile uint32_t DCIMVAC;  ///< Offset: 0xF5C - Data cache invalidate by address to Point of Coherency (PoC)
        volatile uint32_t DCISW;  ///< Offset: 0xF60 - Data cache invalidate by set/way
        volatile uint32_t DCCMVAU;  ///< Offset: 0xF64 - Data cache by address to PoU
        volatile uint32_t DCCMVAC;  ///< Offset: 0xF68 - Data cache clean by address to PoC
        volatile uint32_t DCCSW;  ///< Offset: 0xF6C - Data cache clean by set/way
        volatile uint32_t DCCIMVAC;  ///< Offset: 0xF70 - Data cache clean and invalidate by address to PoC
        volatile uint32_t DCCISW;  ///< Offset: 0xF74 - Data cache clean and invalidate by set/way
        volatile uint32_t CM7_ITCMCR;  ///< Offset: 0xF90 - Instruction Tightly-Coupled Memory Control Register
        volatile uint32_t CM7_DTCMCR;  ///< Offset: 0xF94 - Data Tightly-Coupled Memory Control Register
        volatile uint32_t CM7_AHBPCR;  ///< Offset: 0xF98 - AHBP Control Register
        volatile uint32_t CM7_CACR;  ///< Offset: 0xF9C - L1 Cache Control Register
        volatile uint32_t CM7_AHBSCR;  ///< Offset: 0xFA0 - AHB Slave Control Register
        volatile uint32_t CM7_ABFSR;  ///< Offset: 0xFA8 - Auxiliary Bus Fault Status Register
    };

    /// Peripheral instances
    inline Registers* SystemControl = reinterpret_cast<Registers*>(SystemControl_BASE);

    // Bit definitions
    /// ACTLR Register bits
    namespace actlr_bits {
        constexpr uint32_t DISMCYCINT = (1U << 0);  ///< Disables interruption of multi-cycle instructions.
        constexpr uint32_t DISDEFWBUF = (1U << 1);  ///< Disables write buffer use during default memory map accesses.
        constexpr uint32_t DISFOLD = (1U << 2);  ///< Disables folding of IT instructions.
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t REVISION = (4 << 0);  ///< Indicates patch release: 0x0 = Patch 0
        constexpr uint32_t PARTNO = (12 << 4);  ///< Indicates part number
        constexpr uint32_t ARCHITECTURE = (4 << 16);  ///< ARCHITECTURE
        constexpr uint32_t VARIANT = (4 << 20);  ///< Indicates processor revision: 0x2 = Revision 2
        constexpr uint32_t IMPLEMENTER = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active exception number
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< Indicates whether there are preempted active exceptions
        constexpr uint32_t VECTPENDING = (9 << 12);  ///< Exception number of the highest priority pending enabled exception
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag, excluding NMI and Faults
        constexpr uint32_t ISRPREEMPT = (1U << 23);  ///< Indicates whether a pending exception will be serviced on exit from debug halt state
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick exception clear-pending bit
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick exception set-pending bit
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV clear-pending bit
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV set-pending bit
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI set-pending bit
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (25 << 7);  ///< Vector table base offset
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTRESET = (1U << 0);  ///< Writing 1 to this bit causes a local system reset
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< Writing 1 to this bit clears all active state information for fixed and configurable exceptions.
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< System reset request
        constexpr uint32_t PRIGROUP = (3 << 8);  ///< Interrupt priority grouping field. This field determines the split of group priority from subpriority.
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< Data endianness
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< Indicates sleep-on-exit when returning from Handler mode to Thread mode
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< Controls whether the processor uses sleep or deep sleep as its low power mode
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< Send Event on Pending bit
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< Indicates how the processor enters Thread mode
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< Enables unprivileged software access to the STIR
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Enables unaligned access traps
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions.
        constexpr uint32_t STKALIGN = (1U << 9);  ///< Indicates stack alignment on exception entry
    }

    /// SHPR1 Register bits
    namespace shpr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of system handler 4, MemManage
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of system handler 5, BusFault
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of system handler 6, UsageFault
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11, SVCall
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_12 = (8 << 0);  ///< Priority of system handler 12, Debug Monitor
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14, PendSV
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15, SysTick exception
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t MEMFAULTACT = (1U << 0);  ///< MemManage exception active bit
        constexpr uint32_t BUSFAULTACT = (1U << 1);  ///< BusFault exception active bit
        constexpr uint32_t USGFAULTACT = (1U << 3);  ///< UsageFault exception active bit
        constexpr uint32_t SVCALLACT = (1U << 7);  ///< SVCall active bit
        constexpr uint32_t MONITORACT = (1U << 8);  ///< Debug monitor active bit
        constexpr uint32_t PENDSVACT = (1U << 10);  ///< PendSV exception active bit
        constexpr uint32_t SYSTICKACT = (1U << 11);  ///< SysTick exception active bit
        constexpr uint32_t USGFAULTPENDED = (1U << 12);  ///< UsageFault exception pending bit
        constexpr uint32_t MEMFAULTPENDED = (1U << 13);  ///< MemManage exception pending bit
        constexpr uint32_t BUSFAULTPENDED = (1U << 14);  ///< BusFault exception pending bit
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVCall pending bit
        constexpr uint32_t MEMFAULTENA = (1U << 16);  ///< MemManage enable bit
        constexpr uint32_t BUSFAULTENA = (1U << 17);  ///< BusFault enable bit
        constexpr uint32_t USGFAULTENA = (1U << 18);  ///< UsageFault enable bit
    }

    /// CFSR Register bits
    namespace cfsr_bits {
        constexpr uint32_t IACCVIOL = (1U << 0);  ///< Instruction access violation flag
        constexpr uint32_t DACCVIOL = (1U << 1);  ///< Data access violation flag
        constexpr uint32_t MUNSTKERR = (1U << 3);  ///< MemManage fault on unstacking for a return from exception
        constexpr uint32_t MSTKERR = (1U << 4);  ///< MemManage fault on stacking for exception entry
        constexpr uint32_t MLSPERR = (1U << 5);  ///< MemManage fault occurred during floating-point lazy state preservation
        constexpr uint32_t MMARVALID = (1U << 7);  ///< MemManage Fault Address Register (MMFAR) valid flag
        constexpr uint32_t IBUSERR = (1U << 8);  ///< Instruction bus error
        constexpr uint32_t PRECISERR = (1U << 9);  ///< Precise data bus error
        constexpr uint32_t IMPRECISERR = (1U << 10);  ///< Imprecise data bus error
        constexpr uint32_t UNSTKERR = (1U << 11);  ///< BusFault on unstacking for a return from exception
        constexpr uint32_t STKERR = (1U << 12);  ///< BusFault on stacking for exception entry
        constexpr uint32_t LSPERR = (1U << 13);  ///< Bus fault occurred during floating-point lazy state preservation
        constexpr uint32_t BFARVALID = (1U << 15);  ///< BusFault Address Register (BFAR) valid flag
        constexpr uint32_t UNDEFINSTR = (1U << 16);  ///< Undefined instruction UsageFault
        constexpr uint32_t INVSTATE = (1U << 17);  ///< Invalid state UsageFault
        constexpr uint32_t INVPC = (1U << 18);  ///< Invalid PC load UsageFault, caused by an invalid PC load by EXC_RETURN
        constexpr uint32_t NOCP = (1U << 19);  ///< No coprocessor UsageFault
        constexpr uint32_t UNALIGNED = (1U << 24);  ///< Unaligned access UsageFault
        constexpr uint32_t DIVBYZERO = (1U << 25);  ///< Divide by zero UsageFault
    }

    /// HFSR Register bits
    namespace hfsr_bits {
        constexpr uint32_t VECTTBL = (1U << 1);  ///< Indicates a BusFault on a vector table read during exception processing.
        constexpr uint32_t FORCED = (1U << 30);  ///< Indicates a forced hard fault, generated by escalation of a fault with configurable priority that cannot be handles, either because of priority or because it is disabled.
        constexpr uint32_t DEBUGEVT = (1U << 31);  ///< Reserved for Debug use. When writing to the register you must write 0 to this bit, otherwise behavior is Unpredictable.
    }

    /// DFSR Register bits
    namespace dfsr_bits {
        constexpr uint32_t HALTED = (1U << 0);  ///< Indicates a debug event generated by either a C_HALT or C_STEP request, triggered by a write to the DHCSR or a step request triggered by setting DEMCR.MON_STEP to 1.
        constexpr uint32_t BKPT = (1U << 1);  ///< Debug event generated by BKPT instruction execution or a breakpoint match in FPB
        constexpr uint32_t DWTTRAP = (1U << 2);  ///< Debug event generated by the DWT
        constexpr uint32_t VCATCH = (1U << 3);  ///< Indicates triggering of a Vector catch
        constexpr uint32_t EXTERNAL = (1U << 4);  ///< Debug event generated because of the assertion of an external debug request
    }

    /// MMFAR Register bits
    namespace mmfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address of MemManage fault location
    }

    /// BFAR Register bits
    namespace bfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address of the BusFault location
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t AUXFAULT = (32 << 0);  ///< Latched version of the AUXFAULT inputs
    }

    /// ID_PFR0 Register bits
    namespace id_pfr0_bits {
        constexpr uint32_t STATE0 = (4 << 0);  ///< ARM instruction set support
        constexpr uint32_t STATE1 = (4 << 4);  ///< Thumb instruction set support
        constexpr uint32_t STATE2 = (4 << 8);  ///< ARMv7-M reserved
        constexpr uint32_t STATE3 = (4 << 12);  ///< ARMv7-M reserved
    }

    /// ID_PFR1 Register bits
    namespace id_pfr1_bits {
        constexpr uint32_t PROGMODEL = (4 << 8);  ///< M profile programmers' model
    }

    /// ID_DFR0 Register bits
    namespace id_dfr0_bits {
        constexpr uint32_t DEBUGMODEL = (4 << 20);  ///< Support for memory-mapped debug model for M profile processors
    }

    /// ID_AFR0 Register bits
    namespace id_afr0_bits {
        constexpr uint32_t IMPLEMENTATION_DEFINED0 = (4 << 0);  ///< Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
        constexpr uint32_t IMPLEMENTATION_DEFINED1 = (4 << 4);  ///< Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
        constexpr uint32_t IMPLEMENTATION_DEFINED2 = (4 << 8);  ///< Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
        constexpr uint32_t IMPLEMENTATION_DEFINED3 = (4 << 12);  ///< Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
    }

    /// ID_MMFR0 Register bits
    namespace id_mmfr0_bits {
        constexpr uint32_t PMSASUPPORT = (4 << 4);  ///< Indicates support for a PMSA
        constexpr uint32_t OUTERMOST_SHAREABILITY = (4 << 8);  ///< Indicates the outermost shareability domain implemented
        constexpr uint32_t SHAREABILITY_LEVELS = (4 << 12);  ///< Indicates the number of shareability levels implemented
        constexpr uint32_t TCM_SUPPORT = (4 << 16);  ///< Indicates the support for Tightly Coupled Memory
        constexpr uint32_t AUXILIARY_REGISTERS = (4 << 20);  ///< Indicates the support for Auxiliary registers
    }

    /// ID_MMFR1 Register bits
    namespace id_mmfr1_bits {
        constexpr uint32_t ID_MMFR1 = (32 << 0);  ///< Gives information about the implemented memory model and memory management support.
    }

    /// ID_MMFR2 Register bits
    namespace id_mmfr2_bits {
        constexpr uint32_t WFI_STALL = (4 << 24);  ///< Indicates the support for Wait For Interrupt (WFI) stalling
    }

    /// ID_MMFR3 Register bits
    namespace id_mmfr3_bits {
        constexpr uint32_t ID_MMFR3 = (32 << 0);  ///< Gives information about the implemented memory model and memory management support.
    }

    /// ID_ISAR0 Register bits
    namespace id_isar0_bits {
        constexpr uint32_t BITCOUNT_INSTRS = (4 << 4);  ///< Indicates the supported Bit Counting instructions
        constexpr uint32_t BITFIELD_INSTRS = (4 << 8);  ///< Indicates the supported BitField instructions
        constexpr uint32_t CMPBRANCH_INSTRS = (4 << 12);  ///< Indicates the supported combined Compare and Branch instructions
        constexpr uint32_t COPROC_INSTRS = (4 << 16);  ///< Indicates the supported Coprocessor instructions
        constexpr uint32_t DEBUG_INSTRS = (4 << 20);  ///< Indicates the supported Debug instructions
        constexpr uint32_t DIVIDE_INSTRS = (4 << 24);  ///< Indicates the supported Divide instructions
    }

    /// ID_ISAR1 Register bits
    namespace id_isar1_bits {
        constexpr uint32_t EXTEND_INSTRS = (4 << 12);  ///< Indicates the supported Extend instructions
        constexpr uint32_t IFTHEN_INSTRS = (4 << 16);  ///< Indicates the supported IfThen instructions
        constexpr uint32_t IMMEDIATE_INSTRS = (4 << 20);  ///< Indicates the support for data-processing instructions with long immediate
        constexpr uint32_t INTERWORK_INSTRS = (4 << 24);  ///< Indicates the supported Interworking instructions
    }

    /// ID_ISAR2 Register bits
    namespace id_isar2_bits {
        constexpr uint32_t LOADSTORE_INSTRS = (4 << 0);  ///< Indicates the supported additional load and store instructions
        constexpr uint32_t MEMHINT_INSTRS = (4 << 4);  ///< Indicates the supported Memory Hint instructions
        constexpr uint32_t MULTIACCESSINT_INSTRS = (4 << 8);  ///< Indicates the support for multi-access interruptible instructions
        constexpr uint32_t MULT_INSTRS = (4 << 12);  ///< Indicates the supported additional Multiply instructions
        constexpr uint32_t MULTS_INSTRS = (4 << 16);  ///< Indicates the supported advanced signed Multiply instructions
        constexpr uint32_t MULTU_INSTRS = (4 << 20);  ///< Indicates the supported advanced unsigned Multiply instructions
        constexpr uint32_t REVERSAL_INSTRS = (4 << 28);  ///< Indicates the supported Reversal instructions
    }

    /// ID_ISAR3 Register bits
    namespace id_isar3_bits {
        constexpr uint32_t SATURATE_INSTRS = (4 << 0);  ///< Indicates the supported Saturate instructions
        constexpr uint32_t SIMD_INSTRS = (4 << 4);  ///< Indicates the supported SIMD instructions
        constexpr uint32_t SVC_INSTRS = (4 << 8);  ///< Indicates the supported SVC instructions
        constexpr uint32_t SYNCHPRIM_INSTRS = (4 << 12);  ///< Together with the ID_ISAR4[SYNCHPRIM_INSTRS_FRAC] indicates the supported Synchronization Primitives
        constexpr uint32_t TABBRANCH_INSTRS = (4 << 16);  ///< Indicates the supported Table Branch instructions
        constexpr uint32_t THUMBCOPY_INSTRS = (4 << 20);  ///< Indicates the supported non flag-setting MOV instructions
        constexpr uint32_t TRUENOP_INSTRS = (4 << 24);  ///< Indicates the supported non flag-setting MOV instructions
    }

    /// ID_ISAR4 Register bits
    namespace id_isar4_bits {
        constexpr uint32_t UNPRIV_INSTRS = (4 << 0);  ///< Indicates the supported unprivileged instructions. These are the instruction variants indicated by a T suffix.
        constexpr uint32_t WITHSHIFTS_INSTRS = (4 << 4);  ///< Indicates the support for instructions with shifts
        constexpr uint32_t WRITEBACK_INSTRS = (4 << 8);  ///< Indicates the support for Writeback addressing modes
        constexpr uint32_t BARRIER_INSTRS = (4 << 16);  ///< Indicates the supported Barrier instructions
        constexpr uint32_t SYNCHPRIM_INSTRS_FRAC = (4 << 20);  ///< Together with the ID_ISAR3[SYNCHPRIM_INSTRS] indicates the supported Synchronization Primitives
        constexpr uint32_t PSR_M_INSTRS = (4 << 24);  ///< Indicates the supported M profile instructions to modify the PSRs
    }

    /// CLIDR Register bits
    namespace clidr_bits {
        constexpr uint32_t Ctype1 = (3 << 0);  ///< Indicate the type of cache implemented at level 1.
        constexpr uint32_t Ctype2 = (3 << 3);  ///< Indicate the type of cache implemented at level 2.
        constexpr uint32_t Ctype3 = (3 << 6);  ///< Indicate the type of cache implemented at level 3.
        constexpr uint32_t Ctype4 = (3 << 9);  ///< Indicate the type of cache implemented at level 4.
        constexpr uint32_t Ctype5 = (3 << 12);  ///< Indicate the type of cache implemented at level 5.
        constexpr uint32_t Ctype6 = (3 << 15);  ///< Indicate the type of cache implemented at level 6.
        constexpr uint32_t Ctype7 = (3 << 18);  ///< Indicate the type of cache implemented at level 7.
        constexpr uint32_t LoUIS = (3 << 21);  ///< Level of Unification Inner Shareable for the cache hierarchy. This field is RAZ.
        constexpr uint32_t LOC = (3 << 24);  ///< Level of Coherency for the cache hierarchy
        constexpr uint32_t LOUU = (3 << 27);  ///< Level of Unification Uniprocessor for the cache hierarchy
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t IMINLINE = (4 << 0);  ///< Log2 of the number of words in the smallest cache line of all the instruction caches that are controlled by the processor.
        constexpr uint32_t DMINLINE = (4 << 16);  ///< Log2 of the number of words in the smallest cache line of all the data caches and unified caches that are controlled by the processor.
        constexpr uint32_t ERG = (4 << 20);  ///< Exclusives Reservation Granule. The maximum size of the reservation granule that has been implemented for the Load-Exclusive and Store-Exclusive instructions, encoded as Log2 of the number of words.
        constexpr uint32_t CWG = (4 << 24);  ///< Cache Write-back Granule. The maximum size of memory that can be overwritten as a result of the eviction of a cache entry that has had a memory location in it modified, encoded as Log2 of the number of words.
        constexpr uint32_t FORMAT = (3 << 29);  ///< Indicates the implemented CTR format.
    }

    /// CCSIDR Register bits
    namespace ccsidr_bits {
        constexpr uint32_t LINESIZE = (3 << 0);  ///< (Log2(Number of words in cache line)) - 2.
        constexpr uint32_t ASSOCIATIVITY = (10 << 3);  ///< (Associativity of cache) - 1, therefore a value of 0 indicates an associativity of 1. The associativity does not have to be a power of 2.
        constexpr uint32_t NUMSETS = (15 << 13);  ///< (Number of sets in cache) - 1, therefore a value of 0 indicates 1 set in the cache. The number of sets does not have to be a power of 2.
        constexpr uint32_t WA = (1U << 28);  ///< Indicates whether the cache level supports write-allocation
        constexpr uint32_t RA = (1U << 29);  ///< Indicates whether the cache level supports read-allocation
        constexpr uint32_t WB = (1U << 30);  ///< Indicates whether the cache level supports write-back
        constexpr uint32_t WT = (1U << 31);  ///< Indicates whether the cache level supports write-through
    }

    /// CSSELR Register bits
    namespace csselr_bits {
        constexpr uint32_t IND = (1U << 0);  ///< Instruction not data bit
        constexpr uint32_t Level = (3 << 1);  ///< Cache level of required cache
    }

    /// CPACR Register bits
    namespace cpacr_bits {
        constexpr uint32_t CP0 = (2 << 0);  ///< Access privileges for coprocessor 0.
        constexpr uint32_t CP1 = (2 << 2);  ///< Access privileges for coprocessor 1.
        constexpr uint32_t CP2 = (2 << 4);  ///< Access privileges for coprocessor 2.
        constexpr uint32_t CP3 = (2 << 6);  ///< Access privileges for coprocessor 3.
        constexpr uint32_t CP4 = (2 << 8);  ///< Access privileges for coprocessor 4.
        constexpr uint32_t CP5 = (2 << 10);  ///< Access privileges for coprocessor 5.
        constexpr uint32_t CP6 = (2 << 12);  ///< Access privileges for coprocessor 6.
        constexpr uint32_t CP7 = (2 << 14);  ///< Access privileges for coprocessor 7.
        constexpr uint32_t CP10 = (2 << 20);  ///< Access privileges for coprocessor 10.
        constexpr uint32_t CP11 = (2 << 22);  ///< Access privileges for coprocessor 11.
    }

    /// STIR Register bits
    namespace stir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< Indicates the interrupt to be triggered
    }

    /// MVFR0 Register bits
    namespace mvfr0_bits {
        constexpr uint32_t A_SIMD = (4 << 0);  ///< Indicates the size of the FP register bank.
        constexpr uint32_t SINGLE_PRECISION = (4 << 4);  ///< Indicates the hardware support for FP single-precision operations.
        constexpr uint32_t DOUBLE_PRECISION = (4 << 8);  ///< Indicates the hardware support for FP double-precision operations.
        constexpr uint32_t FP_EXCEPTION_TRAPPING = (4 << 12);  ///< Indicates whether the FP hardware implementation supports exception trapping.
        constexpr uint32_t DIVIDE = (4 << 16);  ///< Indicates whether the FP hardware implementation supports exception trapping.
        constexpr uint32_t SQUARE_ROOT = (4 << 20);  ///< Indicates the hardware support for FP square root operations.
        constexpr uint32_t SHORT_VECTORS = (4 << 24);  ///< Indicates the hardware support for FP square root operations.
        constexpr uint32_t FP_ROUNDING_MODES = (4 << 28);  ///< Indicates the rounding modes supported by the FP floating-point hardware.
    }

    /// MVFR1 Register bits
    namespace mvfr1_bits {
        constexpr uint32_t FTZ_MODE = (4 << 0);  ///< Indicates whether the FP hardware implementation supports only the Flush-to-Zero mode of operation.
        constexpr uint32_t D_NAN_MODE = (4 << 4);  ///< Indicates whether the FP hardware implementation supports only the Default NaN mode.
        constexpr uint32_t FP_HPFP = (4 << 24);  ///< Floating Point Half-Precision and double-precision.
        constexpr uint32_t FP_FUSED_MAC = (4 << 28);  ///< Indicates whether the FP supports fused multiply accumulate operations.
    }

    /// MVFR2 Register bits
    namespace mvfr2_bits {
        constexpr uint32_t VFP_MISC = (4 << 4);  ///< Indicates the hardware support for FP miscellaneous features.
    }

    /// ICIALLU Register bits
    namespace iciallu_bits {
        constexpr uint32_t ICIALLU = (32 << 0);  ///< I-cache invalidate all to PoU
    }

    /// ICIMVAU Register bits
    namespace icimvau_bits {
        constexpr uint32_t ICIMVAU = (32 << 0);  ///< I-cache invalidate by MVA to PoU
    }

    /// DCIMVAC Register bits
    namespace dcimvac_bits {
        constexpr uint32_t DCIMVAC = (32 << 0);  ///< D-cache invalidate by MVA to PoC
    }

    /// DCISW Register bits
    namespace dcisw_bits {
        constexpr uint32_t DCISW = (32 << 0);  ///< D-cache invalidate by set-way
    }

    /// DCCMVAU Register bits
    namespace dccmvau_bits {
        constexpr uint32_t DCCMVAU = (32 << 0);  ///< D-cache clean by MVA to PoU
    }

    /// DCCMVAC Register bits
    namespace dccmvac_bits {
        constexpr uint32_t DCCMVAC = (32 << 0);  ///< D-cache clean by MVA to PoC
    }

    /// DCCSW Register bits
    namespace dccsw_bits {
        constexpr uint32_t DCCSW = (32 << 0);  ///< D-cache clean by set-way
    }

    /// DCCIMVAC Register bits
    namespace dccimvac_bits {
        constexpr uint32_t DCCIMVAC = (32 << 0);  ///< D-cache clean and invalidate by MVA to PoC
    }

    /// DCCISW Register bits
    namespace dccisw_bits {
        constexpr uint32_t DCCISW = (32 << 0);  ///< D-cache clean and invalidate by set-way
    }

    /// CM7_ITCMCR Register bits
    namespace cm7_itcmcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< TCM enable. When a TCM is disabled all accesses are made to the AXIM interface.
        constexpr uint32_t RMW = (1U << 1);  ///< Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that are not the full width of the TCM RAM, use a RMW sequence.
        constexpr uint32_t RETEN = (1U << 2);  ///< Retry phase enable. When enabled the processor guarantees to honor the retry output on the corresponding TCM interface, re-executing the instruction which carried out the TCM access.
        constexpr uint32_t SZ = (4 << 3);  ///< TCM size. Indicates the size of the relevant TCM.
    }

    /// CM7_DTCMCR Register bits
    namespace cm7_dtcmcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< TCM enable. When a TCM is disabled all accesses are made to the AXIM interface.
        constexpr uint32_t RMW = (1U << 1);  ///< Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that are not the full width of the TCM RAM, use a RMW sequence.
        constexpr uint32_t RETEN = (1U << 2);  ///< Retry phase enable. When enabled the processor guarantees to honor the retry output on the corresponding TCM interface, re-executing the instruction which carried out the TCM access.
        constexpr uint32_t SZ = (4 << 3);  ///< TCM size. Indicates the size of the relevant TCM.
    }

    /// CM7_AHBPCR Register bits
    namespace cm7_ahbpcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< AHBP enable.
        constexpr uint32_t SZ = (3 << 1);  ///< AHBP size.
    }

    /// CM7_CACR Register bits
    namespace cm7_cacr_bits {
        constexpr uint32_t SIWT = (1U << 0);  ///< Shared cacheable-is-WT for data cache. Enables limited cache coherency usage.
        constexpr uint32_t ECCDIS = (1U << 1);  ///< Enables ECC in the instruction and data cache.
        constexpr uint32_t FORCEWT = (1U << 2);  ///< Enables Force Write-Through in the data cache.
    }

    /// CM7_AHBSCR Register bits
    namespace cm7_ahbscr_bits {
        constexpr uint32_t CTL = (2 << 0);  ///< AHBS prioritization control.
        constexpr uint32_t TPRI = (9 << 2);  ///< Threshold execution priority for AHBS traffic demotion.
        constexpr uint32_t INITCOUNT = (5 << 11);  ///< Fairness counter initialization value.
    }

    /// CM7_ABFSR Register bits
    namespace cm7_abfsr_bits {
        constexpr uint32_t ITCM = (1U << 0);  ///< Asynchronous fault on ITCM interface.
        constexpr uint32_t DTCM = (1U << 1);  ///< Asynchronous fault on DTCM interface.
        constexpr uint32_t AHBP = (1U << 2);  ///< Asynchronous fault on AHBP interface.
        constexpr uint32_t AXIM = (1U << 3);  ///< Asynchronous fault on AXIM interface.
        constexpr uint32_t EPPB = (1U << 4);  ///< Asynchronous fault on EPPB interface.
        constexpr uint32_t AXIMTYPE = (2 << 8);  ///< Indicates the type of fault on the AXIM interface. Only valid when AXIM is 1.
    }

}

// ============================================================================
// SysTick Peripheral
// ============================================================================

namespace systick {
    /// Base addresses
    constexpr uint32_t SysTick_BASE = 0xE000E010;

    /// SysTick Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - SysTick Control and Status Register
        volatile uint32_t RVR;  ///< Offset: 0x04 - SysTick Reload Value Register
        volatile uint32_t CVR;  ///< Offset: 0x08 - SysTick Current Value Register
        volatile uint32_t CALIB;  ///< Offset: 0x0C - SysTick Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* SysTick = reinterpret_cast<Registers*>(SysTick_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< no description available
        constexpr uint32_t TICKINT = (1U << 1);  ///< no description available
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< no description available
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< no description available
    }

    /// RVR Register bits
    namespace rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Value to load into the SysTick Current Value Register when the counter reaches 0
    }

    /// CVR Register bits
    namespace cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current value at the time the register is accessed
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Reload value to use for 10ms timing
        constexpr uint32_t SKEW = (1U << 30);  ///< no description available
        constexpr uint32_t NOREF = (1U << 31);  ///< no description available
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t NVICISER0;  ///< Offset: 0x00 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER1;  ///< Offset: 0x04 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER2;  ///< Offset: 0x08 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER3;  ///< Offset: 0x0C - Interrupt Set Enable Register n
        volatile uint32_t NVICICER0;  ///< Offset: 0x80 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER1;  ///< Offset: 0x84 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER2;  ///< Offset: 0x88 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER3;  ///< Offset: 0x8C - Interrupt Clear Enable Register n
        volatile uint32_t NVICISPR0;  ///< Offset: 0x100 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR1;  ///< Offset: 0x104 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR2;  ///< Offset: 0x108 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR3;  ///< Offset: 0x10C - Interrupt Set Pending Register n
        volatile uint32_t NVICICPR0;  ///< Offset: 0x180 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR1;  ///< Offset: 0x184 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR2;  ///< Offset: 0x188 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR3;  ///< Offset: 0x18C - Interrupt Clear Pending Register n
        volatile uint32_t NVICIABR0;  ///< Offset: 0x200 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR1;  ///< Offset: 0x204 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR2;  ///< Offset: 0x208 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR3;  ///< Offset: 0x20C - Interrupt Active bit Register n
        volatile uint32_t NVICIP0;  ///< Offset: 0x300 - Interrupt Priority Register 0
        volatile uint32_t NVICIP1;  ///< Offset: 0x301 - Interrupt Priority Register 1
        volatile uint32_t NVICIP2;  ///< Offset: 0x302 - Interrupt Priority Register 2
        volatile uint32_t NVICIP3;  ///< Offset: 0x303 - Interrupt Priority Register 3
        volatile uint32_t NVICIP4;  ///< Offset: 0x304 - Interrupt Priority Register 4
        volatile uint32_t NVICIP5;  ///< Offset: 0x305 - Interrupt Priority Register 5
        volatile uint32_t NVICIP6;  ///< Offset: 0x306 - Interrupt Priority Register 6
        volatile uint32_t NVICIP7;  ///< Offset: 0x307 - Interrupt Priority Register 7
        volatile uint32_t NVICIP8;  ///< Offset: 0x308 - Interrupt Priority Register 8
        volatile uint32_t NVICIP9;  ///< Offset: 0x309 - Interrupt Priority Register 9
        volatile uint32_t NVICIP10;  ///< Offset: 0x30A - Interrupt Priority Register 10
        volatile uint32_t NVICIP11;  ///< Offset: 0x30B - Interrupt Priority Register 11
        volatile uint32_t NVICIP12;  ///< Offset: 0x30C - Interrupt Priority Register 12
        volatile uint32_t NVICIP13;  ///< Offset: 0x30D - Interrupt Priority Register 13
        volatile uint32_t NVICIP14;  ///< Offset: 0x30E - Interrupt Priority Register 14
        volatile uint32_t NVICIP15;  ///< Offset: 0x30F - Interrupt Priority Register 15
        volatile uint32_t NVICIP16;  ///< Offset: 0x310 - Interrupt Priority Register 16
        volatile uint32_t NVICIP17;  ///< Offset: 0x311 - Interrupt Priority Register 17
        volatile uint32_t NVICIP18;  ///< Offset: 0x312 - Interrupt Priority Register 18
        volatile uint32_t NVICIP19;  ///< Offset: 0x313 - Interrupt Priority Register 19
        volatile uint32_t NVICIP20;  ///< Offset: 0x314 - Interrupt Priority Register 20
        volatile uint32_t NVICIP21;  ///< Offset: 0x315 - Interrupt Priority Register 21
        volatile uint32_t NVICIP22;  ///< Offset: 0x316 - Interrupt Priority Register 22
        volatile uint32_t NVICIP23;  ///< Offset: 0x317 - Interrupt Priority Register 23
        volatile uint32_t NVICIP24;  ///< Offset: 0x318 - Interrupt Priority Register 24
        volatile uint32_t NVICIP25;  ///< Offset: 0x319 - Interrupt Priority Register 25
        volatile uint32_t NVICIP26;  ///< Offset: 0x31A - Interrupt Priority Register 26
        volatile uint32_t NVICIP27;  ///< Offset: 0x31B - Interrupt Priority Register 27
        volatile uint32_t NVICIP28;  ///< Offset: 0x31C - Interrupt Priority Register 28
        volatile uint32_t NVICIP29;  ///< Offset: 0x31D - Interrupt Priority Register 29
        volatile uint32_t NVICIP30;  ///< Offset: 0x31E - Interrupt Priority Register 30
        volatile uint32_t NVICIP31;  ///< Offset: 0x31F - Interrupt Priority Register 31
        volatile uint32_t NVICIP32;  ///< Offset: 0x320 - Interrupt Priority Register 32
        volatile uint32_t NVICIP33;  ///< Offset: 0x321 - Interrupt Priority Register 33
        volatile uint32_t NVICIP34;  ///< Offset: 0x322 - Interrupt Priority Register 34
        volatile uint32_t NVICIP35;  ///< Offset: 0x323 - Interrupt Priority Register 35
        volatile uint32_t NVICIP36;  ///< Offset: 0x324 - Interrupt Priority Register 36
        volatile uint32_t NVICIP37;  ///< Offset: 0x325 - Interrupt Priority Register 37
        volatile uint32_t NVICIP38;  ///< Offset: 0x326 - Interrupt Priority Register 38
        volatile uint32_t NVICIP39;  ///< Offset: 0x327 - Interrupt Priority Register 39
        volatile uint32_t NVICIP40;  ///< Offset: 0x328 - Interrupt Priority Register 40
        volatile uint32_t NVICIP41;  ///< Offset: 0x329 - Interrupt Priority Register 41
        volatile uint32_t NVICIP42;  ///< Offset: 0x32A - Interrupt Priority Register 42
        volatile uint32_t NVICIP43;  ///< Offset: 0x32B - Interrupt Priority Register 43
        volatile uint32_t NVICIP44;  ///< Offset: 0x32C - Interrupt Priority Register 44
        volatile uint32_t NVICIP45;  ///< Offset: 0x32D - Interrupt Priority Register 45
        volatile uint32_t NVICIP46;  ///< Offset: 0x32E - Interrupt Priority Register 46
        volatile uint32_t NVICIP47;  ///< Offset: 0x32F - Interrupt Priority Register 47
        volatile uint32_t NVICIP48;  ///< Offset: 0x330 - Interrupt Priority Register 48
        volatile uint32_t NVICIP49;  ///< Offset: 0x331 - Interrupt Priority Register 49
        volatile uint32_t NVICIP50;  ///< Offset: 0x332 - Interrupt Priority Register 50
        volatile uint32_t NVICIP51;  ///< Offset: 0x333 - Interrupt Priority Register 51
        volatile uint32_t NVICIP52;  ///< Offset: 0x334 - Interrupt Priority Register 52
        volatile uint32_t NVICIP53;  ///< Offset: 0x335 - Interrupt Priority Register 53
        volatile uint32_t NVICIP54;  ///< Offset: 0x336 - Interrupt Priority Register 54
        volatile uint32_t NVICIP55;  ///< Offset: 0x337 - Interrupt Priority Register 55
        volatile uint32_t NVICIP56;  ///< Offset: 0x338 - Interrupt Priority Register 56
        volatile uint32_t NVICIP57;  ///< Offset: 0x339 - Interrupt Priority Register 57
        volatile uint32_t NVICIP58;  ///< Offset: 0x33A - Interrupt Priority Register 58
        volatile uint32_t NVICIP59;  ///< Offset: 0x33B - Interrupt Priority Register 59
        volatile uint32_t NVICIP60;  ///< Offset: 0x33C - Interrupt Priority Register 60
        volatile uint32_t NVICIP61;  ///< Offset: 0x33D - Interrupt Priority Register 61
        volatile uint32_t NVICIP62;  ///< Offset: 0x33E - Interrupt Priority Register 62
        volatile uint32_t NVICIP63;  ///< Offset: 0x33F - Interrupt Priority Register 63
        volatile uint32_t NVICIP64;  ///< Offset: 0x340 - Interrupt Priority Register 64
        volatile uint32_t NVICIP65;  ///< Offset: 0x341 - Interrupt Priority Register 65
        volatile uint32_t NVICIP66;  ///< Offset: 0x342 - Interrupt Priority Register 66
        volatile uint32_t NVICIP67;  ///< Offset: 0x343 - Interrupt Priority Register 67
        volatile uint32_t NVICIP68;  ///< Offset: 0x344 - Interrupt Priority Register 68
        volatile uint32_t NVICIP69;  ///< Offset: 0x345 - Interrupt Priority Register 69
        volatile uint32_t NVICIP70;  ///< Offset: 0x346 - Interrupt Priority Register 70
        volatile uint32_t NVICIP71;  ///< Offset: 0x347 - Interrupt Priority Register 71
        volatile uint32_t NVICIP72;  ///< Offset: 0x348 - Interrupt Priority Register 72
        volatile uint32_t NVICIP73;  ///< Offset: 0x349 - Interrupt Priority Register 73
        volatile uint32_t NVICIP74;  ///< Offset: 0x34A - Interrupt Priority Register 74
        volatile uint32_t NVICIP75;  ///< Offset: 0x34B - Interrupt Priority Register 75
        volatile uint32_t NVICIP76;  ///< Offset: 0x34C - Interrupt Priority Register 76
        volatile uint32_t NVICIP77;  ///< Offset: 0x34D - Interrupt Priority Register 77
        volatile uint32_t NVICIP78;  ///< Offset: 0x34E - Interrupt Priority Register 78
        volatile uint32_t NVICIP79;  ///< Offset: 0x34F - Interrupt Priority Register 79
        volatile uint32_t NVICIP80;  ///< Offset: 0x350 - Interrupt Priority Register 80
        volatile uint32_t NVICIP81;  ///< Offset: 0x351 - Interrupt Priority Register 81
        volatile uint32_t NVICIP82;  ///< Offset: 0x352 - Interrupt Priority Register 82
        volatile uint32_t NVICIP83;  ///< Offset: 0x353 - Interrupt Priority Register 83
        volatile uint32_t NVICIP84;  ///< Offset: 0x354 - Interrupt Priority Register 84
        volatile uint32_t NVICIP85;  ///< Offset: 0x355 - Interrupt Priority Register 85
        volatile uint32_t NVICIP86;  ///< Offset: 0x356 - Interrupt Priority Register 86
        volatile uint32_t NVICIP87;  ///< Offset: 0x357 - Interrupt Priority Register 87
        volatile uint32_t NVICIP88;  ///< Offset: 0x358 - Interrupt Priority Register 88
        volatile uint32_t NVICIP89;  ///< Offset: 0x359 - Interrupt Priority Register 89
        volatile uint32_t NVICIP90;  ///< Offset: 0x35A - Interrupt Priority Register 90
        volatile uint32_t NVICIP91;  ///< Offset: 0x35B - Interrupt Priority Register 91
        volatile uint32_t NVICIP92;  ///< Offset: 0x35C - Interrupt Priority Register 92
        volatile uint32_t NVICIP93;  ///< Offset: 0x35D - Interrupt Priority Register 93
        volatile uint32_t NVICIP94;  ///< Offset: 0x35E - Interrupt Priority Register 94
        volatile uint32_t NVICIP95;  ///< Offset: 0x35F - Interrupt Priority Register 95
        volatile uint32_t NVICIP96;  ///< Offset: 0x360 - Interrupt Priority Register 96
        volatile uint32_t NVICIP97;  ///< Offset: 0x361 - Interrupt Priority Register 97
        volatile uint32_t NVICIP98;  ///< Offset: 0x362 - Interrupt Priority Register 98
        volatile uint32_t NVICIP99;  ///< Offset: 0x363 - Interrupt Priority Register 99
        volatile uint32_t NVICIP100;  ///< Offset: 0x364 - Interrupt Priority Register 100
        volatile uint32_t NVICIP101;  ///< Offset: 0x365 - Interrupt Priority Register 101
        volatile uint32_t NVICIP102;  ///< Offset: 0x366 - Interrupt Priority Register 102
        volatile uint32_t NVICIP103;  ///< Offset: 0x367 - Interrupt Priority Register 103
        volatile uint32_t NVICIP104;  ///< Offset: 0x368 - Interrupt Priority Register 104
        volatile uint32_t NVICIP105;  ///< Offset: 0x369 - Interrupt Priority Register 105
        volatile uint32_t NVICIP106;  ///< Offset: 0x36A - Interrupt Priority Register 106
        volatile uint32_t NVICIP107;  ///< Offset: 0x36B - Interrupt Priority Register 107
        volatile uint32_t NVICIP108;  ///< Offset: 0x36C - Interrupt Priority Register 108
        volatile uint32_t NVICIP109;  ///< Offset: 0x36D - Interrupt Priority Register 109
        volatile uint32_t NVICIP110;  ///< Offset: 0x36E - Interrupt Priority Register 110
        volatile uint32_t NVICIP111;  ///< Offset: 0x36F - Interrupt Priority Register 111
        volatile uint32_t NVICIP112;  ///< Offset: 0x370 - Interrupt Priority Register 112
        volatile uint32_t NVICIP113;  ///< Offset: 0x371 - Interrupt Priority Register 113
        volatile uint32_t NVICIP114;  ///< Offset: 0x372 - Interrupt Priority Register 114
        volatile uint32_t NVICSTIR;  ///< Offset: 0xE00 - Software Trigger Interrupt Register
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

    // Bit definitions
    /// NVICISER0 Register bits
    namespace nviciser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER1 Register bits
    namespace nviciser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER2 Register bits
    namespace nviciser2_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER3 Register bits
    namespace nviciser3_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICICER0 Register bits
    namespace nvicicer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER1 Register bits
    namespace nvicicer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER2 Register bits
    namespace nvicicer2_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER3 Register bits
    namespace nvicicer3_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICISPR0 Register bits
    namespace nvicispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR1 Register bits
    namespace nvicispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR2 Register bits
    namespace nvicispr2_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR3 Register bits
    namespace nvicispr3_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICICPR0 Register bits
    namespace nvicicpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR1 Register bits
    namespace nvicicpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR2 Register bits
    namespace nvicicpr2_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR3 Register bits
    namespace nvicicpr3_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICIABR0 Register bits
    namespace nviciabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR1 Register bits
    namespace nviciabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR2 Register bits
    namespace nviciabr2_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR3 Register bits
    namespace nviciabr3_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIP0 Register bits
    namespace nvicip0_bits {
        constexpr uint32_t PRI0 = (4 << 4);  ///< Priority of the INT_DMA0_DMA16 interrupt 0
    }

    /// NVICIP1 Register bits
    namespace nvicip1_bits {
        constexpr uint32_t PRI1 = (4 << 4);  ///< Priority of the INT_DMA1_DMA17 interrupt 1
    }

    /// NVICIP2 Register bits
    namespace nvicip2_bits {
        constexpr uint32_t PRI2 = (4 << 4);  ///< Priority of the INT_DMA2_DMA18 interrupt 2
    }

    /// NVICIP3 Register bits
    namespace nvicip3_bits {
        constexpr uint32_t PRI3 = (4 << 4);  ///< Priority of the INT_DMA3_DMA19 interrupt 3
    }

    /// NVICIP4 Register bits
    namespace nvicip4_bits {
        constexpr uint32_t PRI4 = (4 << 4);  ///< Priority of the INT_DMA4_DMA20 interrupt 4
    }

    /// NVICIP5 Register bits
    namespace nvicip5_bits {
        constexpr uint32_t PRI5 = (4 << 4);  ///< Priority of the INT_DMA5_DMA21 interrupt 5
    }

    /// NVICIP6 Register bits
    namespace nvicip6_bits {
        constexpr uint32_t PRI6 = (4 << 4);  ///< Priority of the INT_DMA6_DMA22 interrupt 6
    }

    /// NVICIP7 Register bits
    namespace nvicip7_bits {
        constexpr uint32_t PRI7 = (4 << 4);  ///< Priority of the INT_DMA7_DMA23 interrupt 7
    }

    /// NVICIP8 Register bits
    namespace nvicip8_bits {
        constexpr uint32_t PRI8 = (4 << 4);  ///< Priority of the INT_DMA8_DMA24 interrupt 8
    }

    /// NVICIP9 Register bits
    namespace nvicip9_bits {
        constexpr uint32_t PRI9 = (4 << 4);  ///< Priority of the INT_DMA9_DMA25 interrupt 9
    }

    /// NVICIP10 Register bits
    namespace nvicip10_bits {
        constexpr uint32_t PRI10 = (4 << 4);  ///< Priority of the INT_DMA10_DMA26 interrupt 10
    }

    /// NVICIP11 Register bits
    namespace nvicip11_bits {
        constexpr uint32_t PRI11 = (4 << 4);  ///< Priority of the INT_DMA11_DMA27 interrupt 11
    }

    /// NVICIP12 Register bits
    namespace nvicip12_bits {
        constexpr uint32_t PRI12 = (4 << 4);  ///< Priority of the INT_DMA12_DMA28 interrupt 12
    }

    /// NVICIP13 Register bits
    namespace nvicip13_bits {
        constexpr uint32_t PRI13 = (4 << 4);  ///< Priority of the INT_DMA13_DMA29 interrupt 13
    }

    /// NVICIP14 Register bits
    namespace nvicip14_bits {
        constexpr uint32_t PRI14 = (4 << 4);  ///< Priority of the INT_DMA14_DMA30 interrupt 14
    }

    /// NVICIP15 Register bits
    namespace nvicip15_bits {
        constexpr uint32_t PRI15 = (4 << 4);  ///< Priority of the INT_DMA15_DMA31 interrupt 15
    }

    /// NVICIP16 Register bits
    namespace nvicip16_bits {
        constexpr uint32_t PRI16 = (4 << 4);  ///< Priority of the INT_DMA_Error interrupt 16
    }

    /// NVICIP17 Register bits
    namespace nvicip17_bits {
        constexpr uint32_t PRI17 = (4 << 4);  ///< Priority of the INT_MCM interrupt 17
    }

    /// NVICIP18 Register bits
    namespace nvicip18_bits {
        constexpr uint32_t PRI18 = (4 << 4);  ///< Priority of the INT_FTFE interrupt 18
    }

    /// NVICIP19 Register bits
    namespace nvicip19_bits {
        constexpr uint32_t PRI19 = (4 << 4);  ///< Priority of the INT_Read_Collision interrupt 19
    }

    /// NVICIP20 Register bits
    namespace nvicip20_bits {
        constexpr uint32_t PRI20 = (4 << 4);  ///< Priority of the INT_PMC interrupt 20
    }

    /// NVICIP21 Register bits
    namespace nvicip21_bits {
        constexpr uint32_t PRI21 = (4 << 4);  ///< Priority of the INT_LLWU interrupt 21
    }

    /// NVICIP22 Register bits
    namespace nvicip22_bits {
        constexpr uint32_t PRI22 = (4 << 4);  ///< Priority of the INT_WDOG_EWM interrupt 22
    }

    /// NVICIP23 Register bits
    namespace nvicip23_bits {
        constexpr uint32_t PRI23 = (4 << 4);  ///< Priority of the INT_TRNG0 interrupt 23
    }

    /// NVICIP24 Register bits
    namespace nvicip24_bits {
        constexpr uint32_t PRI24 = (4 << 4);  ///< Priority of the INT_I2C0 interrupt 24
    }

    /// NVICIP25 Register bits
    namespace nvicip25_bits {
        constexpr uint32_t PRI25 = (4 << 4);  ///< Priority of the INT_I2C1 interrupt 25
    }

    /// NVICIP26 Register bits
    namespace nvicip26_bits {
        constexpr uint32_t PRI26 = (4 << 4);  ///< Priority of the INT_SPI0 interrupt 26
    }

    /// NVICIP27 Register bits
    namespace nvicip27_bits {
        constexpr uint32_t PRI27 = (4 << 4);  ///< Priority of the INT_SPI1 interrupt 27
    }

    /// NVICIP28 Register bits
    namespace nvicip28_bits {
        constexpr uint32_t PRI28 = (4 << 4);  ///< Priority of the INT_UART5_RX_TX interrupt 28
    }

    /// NVICIP29 Register bits
    namespace nvicip29_bits {
        constexpr uint32_t PRI29 = (4 << 4);  ///< Priority of the INT_UART5_ERR interrupt 29
    }

    /// NVICIP30 Register bits
    namespace nvicip30_bits {
        constexpr uint32_t PRI30 = (4 << 4);  ///< Priority of interrupt 30
    }

    /// NVICIP31 Register bits
    namespace nvicip31_bits {
        constexpr uint32_t PRI31 = (4 << 4);  ///< Priority of the INT_UART0_RX_TX interrupt 31
    }

    /// NVICIP32 Register bits
    namespace nvicip32_bits {
        constexpr uint32_t PRI32 = (4 << 4);  ///< Priority of the INT_UART0_ERR interrupt 32
    }

    /// NVICIP33 Register bits
    namespace nvicip33_bits {
        constexpr uint32_t PRI33 = (4 << 4);  ///< Priority of the INT_UART1_RX_TX interrupt 33
    }

    /// NVICIP34 Register bits
    namespace nvicip34_bits {
        constexpr uint32_t PRI34 = (4 << 4);  ///< Priority of the INT_UART1_ERR interrupt 34
    }

    /// NVICIP35 Register bits
    namespace nvicip35_bits {
        constexpr uint32_t PRI35 = (4 << 4);  ///< Priority of the INT_UART2_RX_TX interrupt 35
    }

    /// NVICIP36 Register bits
    namespace nvicip36_bits {
        constexpr uint32_t PRI36 = (4 << 4);  ///< Priority of the INT_UART2_ERR interrupt 36
    }

    /// NVICIP37 Register bits
    namespace nvicip37_bits {
        constexpr uint32_t PRI37 = (4 << 4);  ///< Priority of the INT_ADC0 interrupt 37
    }

    /// NVICIP38 Register bits
    namespace nvicip38_bits {
        constexpr uint32_t PRI38 = (4 << 4);  ///< Priority of the INT_HSADC_ERR interrupt 38
    }

    /// NVICIP39 Register bits
    namespace nvicip39_bits {
        constexpr uint32_t PRI39 = (4 << 4);  ///< Priority of the INT_HSADC0_CCA interrupt 39
    }

    /// NVICIP40 Register bits
    namespace nvicip40_bits {
        constexpr uint32_t PRI40 = (4 << 4);  ///< Priority of the INT_CMP0 interrupt 40
    }

    /// NVICIP41 Register bits
    namespace nvicip41_bits {
        constexpr uint32_t PRI41 = (4 << 4);  ///< Priority of the INT_CMP1 interrupt 41
    }

    /// NVICIP42 Register bits
    namespace nvicip42_bits {
        constexpr uint32_t PRI42 = (4 << 4);  ///< Priority of the INT_FTM0 interrupt 42
    }

    /// NVICIP43 Register bits
    namespace nvicip43_bits {
        constexpr uint32_t PRI43 = (4 << 4);  ///< Priority of the INT_FTM1 interrupt 43
    }

    /// NVICIP44 Register bits
    namespace nvicip44_bits {
        constexpr uint32_t PRI44 = (4 << 4);  ///< Priority of the INT_UART3_RX_TX interrupt 44
    }

    /// NVICIP45 Register bits
    namespace nvicip45_bits {
        constexpr uint32_t PRI45 = (4 << 4);  ///< Priority of the INT_UART3_ERR interrupt 45
    }

    /// NVICIP46 Register bits
    namespace nvicip46_bits {
        constexpr uint32_t PRI46 = (4 << 4);  ///< Priority of the INT_UART4_RX_TX interrupt 46
    }

    /// NVICIP47 Register bits
    namespace nvicip47_bits {
        constexpr uint32_t PRI47 = (4 << 4);  ///< Priority of the INT_UART4_ERR interrupt 47
    }

    /// NVICIP48 Register bits
    namespace nvicip48_bits {
        constexpr uint32_t PRI48 = (4 << 4);  ///< Priority of the INT_PIT0 interrupt 48
    }

    /// NVICIP49 Register bits
    namespace nvicip49_bits {
        constexpr uint32_t PRI49 = (4 << 4);  ///< Priority of the INT_PIT1 interrupt 49
    }

    /// NVICIP50 Register bits
    namespace nvicip50_bits {
        constexpr uint32_t PRI50 = (4 << 4);  ///< Priority of the INT_PIT2 interrupt 50
    }

    /// NVICIP51 Register bits
    namespace nvicip51_bits {
        constexpr uint32_t PRI51 = (4 << 4);  ///< Priority of the INT_PIT3 interrupt 51
    }

    /// NVICIP52 Register bits
    namespace nvicip52_bits {
        constexpr uint32_t PRI52 = (4 << 4);  ///< Priority of the INT_PDB0 interrupt 52
    }

    /// NVICIP53 Register bits
    namespace nvicip53_bits {
        constexpr uint32_t PRI53 = (4 << 4);  ///< Priority of the INT_FTM2 interrupt 53
    }

    /// NVICIP54 Register bits
    namespace nvicip54_bits {
        constexpr uint32_t PRI54 = (4 << 4);  ///< Priority of the INT_XBARA interrupt 54
    }

    /// NVICIP55 Register bits
    namespace nvicip55_bits {
        constexpr uint32_t PRI55 = (4 << 4);  ///< Priority of the INT_PDB1 interrupt 55
    }

    /// NVICIP56 Register bits
    namespace nvicip56_bits {
        constexpr uint32_t PRI56 = (4 << 4);  ///< Priority of the INT_DAC0 interrupt 56
    }

    /// NVICIP57 Register bits
    namespace nvicip57_bits {
        constexpr uint32_t PRI57 = (4 << 4);  ///< Priority of the INT_MCG interrupt 57
    }

    /// NVICIP58 Register bits
    namespace nvicip58_bits {
        constexpr uint32_t PRI58 = (4 << 4);  ///< Priority of the INT_LPTMR0 interrupt 58
    }

    /// NVICIP59 Register bits
    namespace nvicip59_bits {
        constexpr uint32_t PRI59 = (4 << 4);  ///< Priority of the INT_PORTA interrupt 59
    }

    /// NVICIP60 Register bits
    namespace nvicip60_bits {
        constexpr uint32_t PRI60 = (4 << 4);  ///< Priority of the INT_PORTB interrupt 60
    }

    /// NVICIP61 Register bits
    namespace nvicip61_bits {
        constexpr uint32_t PRI61 = (4 << 4);  ///< Priority of the INT_PORTC interrupt 61
    }

    /// NVICIP62 Register bits
    namespace nvicip62_bits {
        constexpr uint32_t PRI62 = (4 << 4);  ///< Priority of the INT_PORTD interrupt 62
    }

    /// NVICIP63 Register bits
    namespace nvicip63_bits {
        constexpr uint32_t PRI63 = (4 << 4);  ///< Priority of the INT_PORTE interrupt 63
    }

    /// NVICIP64 Register bits
    namespace nvicip64_bits {
        constexpr uint32_t PRI64 = (4 << 4);  ///< Priority of the INT_SWI interrupt 64
    }

    /// NVICIP65 Register bits
    namespace nvicip65_bits {
        constexpr uint32_t PRI65 = (4 << 4);  ///< Priority of the INT_SPI2 interrupt 65
    }

    /// NVICIP66 Register bits
    namespace nvicip66_bits {
        constexpr uint32_t PRI66 = (4 << 4);  ///< Priority of the INT_ENC_COMPARE interrupt 66
    }

    /// NVICIP67 Register bits
    namespace nvicip67_bits {
        constexpr uint32_t PRI67 = (4 << 4);  ///< Priority of the INT_ENC_HOME interrupt 67
    }

    /// NVICIP68 Register bits
    namespace nvicip68_bits {
        constexpr uint32_t PRI68 = (4 << 4);  ///< Priority of the INT_ENC_WDOG_SAB interrupt 68
    }

    /// NVICIP69 Register bits
    namespace nvicip69_bits {
        constexpr uint32_t PRI69 = (4 << 4);  ///< Priority of the INT_ENC_INDEX interrupt 69
    }

    /// NVICIP70 Register bits
    namespace nvicip70_bits {
        constexpr uint32_t PRI70 = (4 << 4);  ///< Priority of the INT_CMP2 interrupt 70
    }

    /// NVICIP71 Register bits
    namespace nvicip71_bits {
        constexpr uint32_t PRI71 = (4 << 4);  ///< Priority of the INT_FTM3 interrupt 71
    }

    /// NVICIP72 Register bits
    namespace nvicip72_bits {
        constexpr uint32_t PRI72 = (4 << 4);  ///< Priority of interrupt 72
    }

    /// NVICIP73 Register bits
    namespace nvicip73_bits {
        constexpr uint32_t PRI73 = (4 << 4);  ///< Priority of the INT_HSADC0_CCB interrupt 73
    }

    /// NVICIP74 Register bits
    namespace nvicip74_bits {
        constexpr uint32_t PRI74 = (4 << 4);  ///< Priority of the INT_HSADC1_CCA interrupt 74
    }

    /// NVICIP75 Register bits
    namespace nvicip75_bits {
        constexpr uint32_t PRI75 = (4 << 4);  ///< Priority of the INT_CAN0_ORed_Message_buffer interrupt 75
    }

    /// NVICIP76 Register bits
    namespace nvicip76_bits {
        constexpr uint32_t PRI76 = (4 << 4);  ///< Priority of the INT_CAN0_Bus_Off interrupt 76
    }

    /// NVICIP77 Register bits
    namespace nvicip77_bits {
        constexpr uint32_t PRI77 = (4 << 4);  ///< Priority of the INT_CAN0_Error interrupt 77
    }

    /// NVICIP78 Register bits
    namespace nvicip78_bits {
        constexpr uint32_t PRI78 = (4 << 4);  ///< Priority of the INT_CAN0_Tx_Warning interrupt 78
    }

    /// NVICIP79 Register bits
    namespace nvicip79_bits {
        constexpr uint32_t PRI79 = (4 << 4);  ///< Priority of the INT_CAN0_Rx_Warning interrupt 79
    }

    /// NVICIP80 Register bits
    namespace nvicip80_bits {
        constexpr uint32_t PRI80 = (4 << 4);  ///< Priority of the INT_CAN0_Wake_Up interrupt 80
    }

    /// NVICIP81 Register bits
    namespace nvicip81_bits {
        constexpr uint32_t PRI81 = (4 << 4);  ///< Priority of the INT_PWM0_CMP0 interrupt 81
    }

    /// NVICIP82 Register bits
    namespace nvicip82_bits {
        constexpr uint32_t PRI82 = (4 << 4);  ///< Priority of the INT_PWM0_RELOAD0 interrupt 82
    }

    /// NVICIP83 Register bits
    namespace nvicip83_bits {
        constexpr uint32_t PRI83 = (4 << 4);  ///< Priority of the INT_PWM0_CMP1 interrupt 83
    }

    /// NVICIP84 Register bits
    namespace nvicip84_bits {
        constexpr uint32_t PRI84 = (4 << 4);  ///< Priority of the INT_PWM0_RELOAD1 interrupt 84
    }

    /// NVICIP85 Register bits
    namespace nvicip85_bits {
        constexpr uint32_t PRI85 = (4 << 4);  ///< Priority of the INT_PWM0_CMP2 interrupt 85
    }

    /// NVICIP86 Register bits
    namespace nvicip86_bits {
        constexpr uint32_t PRI86 = (4 << 4);  ///< Priority of the INT_PWM0_RELOAD2 interrupt 86
    }

    /// NVICIP87 Register bits
    namespace nvicip87_bits {
        constexpr uint32_t PRI87 = (4 << 4);  ///< Priority of the INT_PWM0_CMP3 interrupt 87
    }

    /// NVICIP88 Register bits
    namespace nvicip88_bits {
        constexpr uint32_t PRI88 = (4 << 4);  ///< Priority of the INT_PWM0_RELOAD3 interrupt 88
    }

    /// NVICIP89 Register bits
    namespace nvicip89_bits {
        constexpr uint32_t PRI89 = (4 << 4);  ///< Priority of the INT_PWM0_CAP interrupt 89
    }

    /// NVICIP90 Register bits
    namespace nvicip90_bits {
        constexpr uint32_t PRI90 = (4 << 4);  ///< Priority of the INT_PWM0_RERR interrupt 90
    }

    /// NVICIP91 Register bits
    namespace nvicip91_bits {
        constexpr uint32_t PRI91 = (4 << 4);  ///< Priority of the INT_PWM0_FAULT interrupt 91
    }

    /// NVICIP92 Register bits
    namespace nvicip92_bits {
        constexpr uint32_t PRI92 = (4 << 4);  ///< Priority of the INT_CMP3 interrupt 92
    }

    /// NVICIP93 Register bits
    namespace nvicip93_bits {
        constexpr uint32_t PRI93 = (4 << 4);  ///< Priority of the INT_HSADC1_CCB interrupt 93
    }

    /// NVICIP94 Register bits
    namespace nvicip94_bits {
        constexpr uint32_t PRI94 = (4 << 4);  ///< Priority of the INT_CAN1_ORed_Message_buffer interrupt 94
    }

    /// NVICIP95 Register bits
    namespace nvicip95_bits {
        constexpr uint32_t PRI95 = (4 << 4);  ///< Priority of the INT_CAN1_Bus_Off interrupt 95
    }

    /// NVICIP96 Register bits
    namespace nvicip96_bits {
        constexpr uint32_t PRI96 = (4 << 4);  ///< Priority of the INT_CAN1_Error interrupt 96
    }

    /// NVICIP97 Register bits
    namespace nvicip97_bits {
        constexpr uint32_t PRI97 = (4 << 4);  ///< Priority of the INT_CAN1_Tx_Warning interrupt 97
    }

    /// NVICIP98 Register bits
    namespace nvicip98_bits {
        constexpr uint32_t PRI98 = (4 << 4);  ///< Priority of the INT_CAN1_Rx_Warning interrupt 98
    }

    /// NVICIP99 Register bits
    namespace nvicip99_bits {
        constexpr uint32_t PRI99 = (4 << 4);  ///< Priority of the INT_CAN1_Wake_Up interrupt 99
    }

    /// NVICIP100 Register bits
    namespace nvicip100_bits {
        constexpr uint32_t PRI100 = (4 << 4);  ///< Priority of interrupt 100
    }

    /// NVICIP101 Register bits
    namespace nvicip101_bits {
        constexpr uint32_t PRI101 = (4 << 4);  ///< Priority of interrupt 101
    }

    /// NVICIP102 Register bits
    namespace nvicip102_bits {
        constexpr uint32_t PRI102 = (4 << 4);  ///< Priority of interrupt 102
    }

    /// NVICIP103 Register bits
    namespace nvicip103_bits {
        constexpr uint32_t PRI103 = (4 << 4);  ///< Priority of interrupt 103
    }

    /// NVICIP104 Register bits
    namespace nvicip104_bits {
        constexpr uint32_t PRI104 = (4 << 4);  ///< Priority of the INT_PWM1_CMP0 interrupt 104
    }

    /// NVICIP105 Register bits
    namespace nvicip105_bits {
        constexpr uint32_t PRI105 = (4 << 4);  ///< Priority of the INT_PWM1_RELOAD0 interrupt 105
    }

    /// NVICIP106 Register bits
    namespace nvicip106_bits {
        constexpr uint32_t PRI106 = (4 << 4);  ///< Priority of the INT_PWM1_CMP1 interrupt 106
    }

    /// NVICIP107 Register bits
    namespace nvicip107_bits {
        constexpr uint32_t PRI107 = (4 << 4);  ///< Priority of the INT_PWM1_RELOAD1 interrupt 107
    }

    /// NVICIP108 Register bits
    namespace nvicip108_bits {
        constexpr uint32_t PRI108 = (4 << 4);  ///< Priority of the INT_PWM1_CMP2 interrupt 108
    }

    /// NVICIP109 Register bits
    namespace nvicip109_bits {
        constexpr uint32_t PRI109 = (4 << 4);  ///< Priority of the INT_PWM1_RELOAD2 interrupt 109
    }

    /// NVICIP110 Register bits
    namespace nvicip110_bits {
        constexpr uint32_t PRI110 = (4 << 4);  ///< Priority of the INT_PWM1_CMP3 interrupt 110
    }

    /// NVICIP111 Register bits
    namespace nvicip111_bits {
        constexpr uint32_t PRI111 = (4 << 4);  ///< Priority of the INT_PWM1_RELOAD3 interrupt 111
    }

    /// NVICIP112 Register bits
    namespace nvicip112_bits {
        constexpr uint32_t PRI112 = (4 << 4);  ///< Priority of the INT_PWM1_CAP interrupt 112
    }

    /// NVICIP113 Register bits
    namespace nvicip113_bits {
        constexpr uint32_t PRI113 = (4 << 4);  ///< Priority of the INT_PWM1_RERR interrupt 113
    }

    /// NVICIP114 Register bits
    namespace nvicip114_bits {
        constexpr uint32_t PRI114 = (4 << 4);  ///< Priority of the INT_PWM1_FAULT interrupt 114
    }

    /// NVICSTIR Register bits
    namespace nvicstir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< Interrupt ID of the interrupt to trigger, in the range 0-239. For example, a value of 0x03 specifies interrupt IRQ3.
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xE0080000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PCT;  ///< Offset: 0x00 - Processor core type
        volatile uint32_t CR;  ///< Offset: 0x0C - Control Register
        volatile uint32_t ISCR;  ///< Offset: 0x10 - Interrupt Status and Control Register
        volatile uint32_t CPO;  ///< Offset: 0x34 - Compute Only Operation Control Register
        volatile uint32_t LMEM%s;  ///< Offset: 0x400 - Local Memory General Descriptor Register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PCT Register bits
    namespace pct_bits {
        constexpr uint32_t PLREV = (16 << 0);  ///< Platform revision
        constexpr uint32_t PCT = (16 << 16);  ///< This MCM design supports the ARM Cortex M7 core.
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t AHBSPRI = (1U << 27);  ///< AHB Slave Interface Priority
    }

    /// ISCR Register bits
    namespace iscr_bits {
        constexpr uint32_t FIOC = (1U << 8);  ///< FPU invalid operation interrupt status
        constexpr uint32_t FDZC = (1U << 9);  ///< FPU divide-by-zero interrupt status
        constexpr uint32_t FOFC = (1U << 10);  ///< FPU overflow interrupt status
        constexpr uint32_t FUFC = (1U << 11);  ///< FPU underflow interrupt status
        constexpr uint32_t FIXC = (1U << 12);  ///< FPU inexact interrupt status
        constexpr uint32_t FIDC = (1U << 15);  ///< FPU input denormal interrupt status
        constexpr uint32_t FIOCE = (1U << 24);  ///< FPU invalid operation interrupt enable
        constexpr uint32_t FDZCE = (1U << 25);  ///< FPU divide-by-zero interrupt enable
        constexpr uint32_t FOFCE = (1U << 26);  ///< FPU overflow interrupt enable
        constexpr uint32_t FUFCE = (1U << 27);  ///< FPU underflow interrupt enable
        constexpr uint32_t FIXCE = (1U << 28);  ///< FPU inexact interrupt enable
        constexpr uint32_t FIDCE = (1U << 31);  ///< FPU input denormal interrupt enable
    }

    /// CPO Register bits
    namespace cpo_bits {
        constexpr uint32_t CPOREQ = (1U << 0);  ///< Compute Only Operation request
        constexpr uint32_t CPOACK = (1U << 1);  ///< Compute Only Operation acknowledge
    }

    /// LMEM%s Register bits
    namespace lmem%s_bits {
        constexpr uint32_t LMEM_Type = (3 << 13);  ///< Defines the type of local memory
        constexpr uint32_t LMEM_Width = (3 << 17);  ///< Defines the local memory bit width
        constexpr uint32_t LMEM_Ways = (4 << 20);  ///< Defines the ways of set associative
        constexpr uint32_t LMEM_Size = (4 << 24);  ///< Defines the local memory size
        constexpr uint32_t LMEM_Valid = (1U << 31);  ///< Defines whether the local memory is present
    }

}

// ============================================================================
// CAU Peripheral
// ============================================================================

namespace cau {
    /// Base addresses
    constexpr uint32_t CAU_BASE = 0xE0081000;

    /// CAU Register structure
    struct Registers {
        volatile uint32_t CAU_DIRECT0;  ///< Offset: 0x00 - Direct access register 0
        volatile uint32_t CAU_DIRECT1;  ///< Offset: 0x04 - Direct access register 1
        volatile uint32_t CAU_DIRECT2;  ///< Offset: 0x08 - Direct access register 2
        volatile uint32_t CAU_DIRECT3;  ///< Offset: 0x0C - Direct access register 3
        volatile uint32_t CAU_DIRECT4;  ///< Offset: 0x10 - Direct access register 4
        volatile uint32_t CAU_DIRECT5;  ///< Offset: 0x14 - Direct access register 5
        volatile uint32_t CAU_DIRECT6;  ///< Offset: 0x18 - Direct access register 6
        volatile uint32_t CAU_DIRECT7;  ///< Offset: 0x1C - Direct access register 7
        volatile uint32_t CAU_DIRECT8;  ///< Offset: 0x20 - Direct access register 8
        volatile uint32_t CAU_DIRECT9;  ///< Offset: 0x24 - Direct access register 9
        volatile uint32_t CAU_DIRECT10;  ///< Offset: 0x28 - Direct access register 10
        volatile uint32_t CAU_DIRECT11;  ///< Offset: 0x2C - Direct access register 11
        volatile uint32_t CAU_DIRECT12;  ///< Offset: 0x30 - Direct access register 12
        volatile uint32_t CAU_DIRECT13;  ///< Offset: 0x34 - Direct access register 13
        volatile uint32_t CAU_DIRECT14;  ///< Offset: 0x38 - Direct access register 14
        volatile uint32_t CAU_DIRECT15;  ///< Offset: 0x3C - Direct access register 15
        volatile uint32_t CAU_LDR_CASR;  ///< Offset: 0x840 - Status register - Load Register command
        volatile uint32_t CAU_LDR_CAA;  ///< Offset: 0x844 - Accumulator register - Load Register command
        volatile uint32_t CAU_LDR_CA0;  ///< Offset: 0x848 - General Purpose Register 0 - Load Register command
        volatile uint32_t CAU_LDR_CA1;  ///< Offset: 0x84C - General Purpose Register 1 - Load Register command
        volatile uint32_t CAU_LDR_CA2;  ///< Offset: 0x850 - General Purpose Register 2 - Load Register command
        volatile uint32_t CAU_LDR_CA3;  ///< Offset: 0x854 - General Purpose Register 3 - Load Register command
        volatile uint32_t CAU_LDR_CA4;  ///< Offset: 0x858 - General Purpose Register 4 - Load Register command
        volatile uint32_t CAU_LDR_CA5;  ///< Offset: 0x85C - General Purpose Register 5 - Load Register command
        volatile uint32_t CAU_LDR_CA6;  ///< Offset: 0x860 - General Purpose Register 6 - Load Register command
        volatile uint32_t CAU_LDR_CA7;  ///< Offset: 0x864 - General Purpose Register 7 - Load Register command
        volatile uint32_t CAU_LDR_CA8;  ///< Offset: 0x868 - General Purpose Register 8 - Load Register command
        volatile uint32_t CAU_STR_CASR;  ///< Offset: 0x880 - Status register - Store Register command
        volatile uint32_t CAU_STR_CAA;  ///< Offset: 0x884 - Accumulator register - Store Register command
        volatile uint32_t CAU_STR_CA0;  ///< Offset: 0x888 - General Purpose Register 0 - Store Register command
        volatile uint32_t CAU_STR_CA1;  ///< Offset: 0x88C - General Purpose Register 1 - Store Register command
        volatile uint32_t CAU_STR_CA2;  ///< Offset: 0x890 - General Purpose Register 2 - Store Register command
        volatile uint32_t CAU_STR_CA3;  ///< Offset: 0x894 - General Purpose Register 3 - Store Register command
        volatile uint32_t CAU_STR_CA4;  ///< Offset: 0x898 - General Purpose Register 4 - Store Register command
        volatile uint32_t CAU_STR_CA5;  ///< Offset: 0x89C - General Purpose Register 5 - Store Register command
        volatile uint32_t CAU_STR_CA6;  ///< Offset: 0x8A0 - General Purpose Register 6 - Store Register command
        volatile uint32_t CAU_STR_CA7;  ///< Offset: 0x8A4 - General Purpose Register 7 - Store Register command
        volatile uint32_t CAU_STR_CA8;  ///< Offset: 0x8A8 - General Purpose Register 8 - Store Register command
        volatile uint32_t CAU_ADR_CASR;  ///< Offset: 0x8C0 - Status register - Add Register command
        volatile uint32_t CAU_ADR_CAA;  ///< Offset: 0x8C4 - Accumulator register - Add to register command
        volatile uint32_t CAU_ADR_CA0;  ///< Offset: 0x8C8 - General Purpose Register 0 - Add to register command
        volatile uint32_t CAU_ADR_CA1;  ///< Offset: 0x8CC - General Purpose Register 1 - Add to register command
        volatile uint32_t CAU_ADR_CA2;  ///< Offset: 0x8D0 - General Purpose Register 2 - Add to register command
        volatile uint32_t CAU_ADR_CA3;  ///< Offset: 0x8D4 - General Purpose Register 3 - Add to register command
        volatile uint32_t CAU_ADR_CA4;  ///< Offset: 0x8D8 - General Purpose Register 4 - Add to register command
        volatile uint32_t CAU_ADR_CA5;  ///< Offset: 0x8DC - General Purpose Register 5 - Add to register command
        volatile uint32_t CAU_ADR_CA6;  ///< Offset: 0x8E0 - General Purpose Register 6 - Add to register command
        volatile uint32_t CAU_ADR_CA7;  ///< Offset: 0x8E4 - General Purpose Register 7 - Add to register command
        volatile uint32_t CAU_ADR_CA8;  ///< Offset: 0x8E8 - General Purpose Register 8 - Add to register command
        volatile uint32_t CAU_RADR_CASR;  ///< Offset: 0x900 - Status register - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CAA;  ///< Offset: 0x904 - Accumulator register - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA0;  ///< Offset: 0x908 - General Purpose Register 0 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA1;  ///< Offset: 0x90C - General Purpose Register 1 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA2;  ///< Offset: 0x910 - General Purpose Register 2 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA3;  ///< Offset: 0x914 - General Purpose Register 3 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA4;  ///< Offset: 0x918 - General Purpose Register 4 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA5;  ///< Offset: 0x91C - General Purpose Register 5 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA6;  ///< Offset: 0x920 - General Purpose Register 6 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA7;  ///< Offset: 0x924 - General Purpose Register 7 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA8;  ///< Offset: 0x928 - General Purpose Register 8 - Reverse and Add to Register command
        volatile uint32_t CAU_XOR_CASR;  ///< Offset: 0x980 - Status register - Exclusive Or command
        volatile uint32_t CAU_XOR_CAA;  ///< Offset: 0x984 - Accumulator register - Exclusive Or command
        volatile uint32_t CAU_XOR_CA0;  ///< Offset: 0x988 - General Purpose Register 0 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA1;  ///< Offset: 0x98C - General Purpose Register 1 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA2;  ///< Offset: 0x990 - General Purpose Register 2 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA3;  ///< Offset: 0x994 - General Purpose Register 3 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA4;  ///< Offset: 0x998 - General Purpose Register 4 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA5;  ///< Offset: 0x99C - General Purpose Register 5 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA6;  ///< Offset: 0x9A0 - General Purpose Register 6 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA7;  ///< Offset: 0x9A4 - General Purpose Register 7 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA8;  ///< Offset: 0x9A8 - General Purpose Register 8 - Exclusive Or command
        volatile uint32_t CAU_ROTL_CASR;  ///< Offset: 0x9C0 - Status register - Rotate Left command
        volatile uint32_t CAU_ROTL_CAA;  ///< Offset: 0x9C4 - Accumulator register - Rotate Left command
        volatile uint32_t CAU_ROTL_CA0;  ///< Offset: 0x9C8 - General Purpose Register 0 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA1;  ///< Offset: 0x9CC - General Purpose Register 1 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA2;  ///< Offset: 0x9D0 - General Purpose Register 2 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA3;  ///< Offset: 0x9D4 - General Purpose Register 3 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA4;  ///< Offset: 0x9D8 - General Purpose Register 4 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA5;  ///< Offset: 0x9DC - General Purpose Register 5 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA6;  ///< Offset: 0x9E0 - General Purpose Register 6 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA7;  ///< Offset: 0x9E4 - General Purpose Register 7 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA8;  ///< Offset: 0x9E8 - General Purpose Register 8 - Rotate Left command
        volatile uint32_t CAU_AESC_CASR;  ///< Offset: 0xB00 - Status register - AES Column Operation command
        volatile uint32_t CAU_AESC_CAA;  ///< Offset: 0xB04 - Accumulator register - AES Column Operation command
        volatile uint32_t CAU_AESC_CA0;  ///< Offset: 0xB08 - General Purpose Register 0 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA1;  ///< Offset: 0xB0C - General Purpose Register 1 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA2;  ///< Offset: 0xB10 - General Purpose Register 2 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA3;  ///< Offset: 0xB14 - General Purpose Register 3 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA4;  ///< Offset: 0xB18 - General Purpose Register 4 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA5;  ///< Offset: 0xB1C - General Purpose Register 5 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA6;  ///< Offset: 0xB20 - General Purpose Register 6 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA7;  ///< Offset: 0xB24 - General Purpose Register 7 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA8;  ///< Offset: 0xB28 - General Purpose Register 8 - AES Column Operation command
        volatile uint32_t CAU_AESIC_CASR;  ///< Offset: 0xB40 - Status register - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CAA;  ///< Offset: 0xB44 - Accumulator register - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA0;  ///< Offset: 0xB48 - General Purpose Register 0 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA1;  ///< Offset: 0xB4C - General Purpose Register 1 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA2;  ///< Offset: 0xB50 - General Purpose Register 2 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA3;  ///< Offset: 0xB54 - General Purpose Register 3 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA4;  ///< Offset: 0xB58 - General Purpose Register 4 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA5;  ///< Offset: 0xB5C - General Purpose Register 5 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA6;  ///< Offset: 0xB60 - General Purpose Register 6 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA7;  ///< Offset: 0xB64 - General Purpose Register 7 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA8;  ///< Offset: 0xB68 - General Purpose Register 8 - AES Inverse Column Operation command
    };

    /// Peripheral instances
    inline Registers* CAU = reinterpret_cast<Registers*>(CAU_BASE);

    // Bit definitions
    /// CAU_DIRECT0 Register bits
    namespace cau_direct0_bits {
        constexpr uint32_t CAU_DIRECT0 = (32 << 0);  ///< Direct register 0
    }

    /// CAU_DIRECT1 Register bits
    namespace cau_direct1_bits {
        constexpr uint32_t CAU_DIRECT1 = (32 << 0);  ///< Direct register 1
    }

    /// CAU_DIRECT2 Register bits
    namespace cau_direct2_bits {
        constexpr uint32_t CAU_DIRECT2 = (32 << 0);  ///< Direct register 2
    }

    /// CAU_DIRECT3 Register bits
    namespace cau_direct3_bits {
        constexpr uint32_t CAU_DIRECT3 = (32 << 0);  ///< Direct register 3
    }

    /// CAU_DIRECT4 Register bits
    namespace cau_direct4_bits {
        constexpr uint32_t CAU_DIRECT4 = (32 << 0);  ///< Direct register 4
    }

    /// CAU_DIRECT5 Register bits
    namespace cau_direct5_bits {
        constexpr uint32_t CAU_DIRECT5 = (32 << 0);  ///< Direct register 5
    }

    /// CAU_DIRECT6 Register bits
    namespace cau_direct6_bits {
        constexpr uint32_t CAU_DIRECT6 = (32 << 0);  ///< Direct register 6
    }

    /// CAU_DIRECT7 Register bits
    namespace cau_direct7_bits {
        constexpr uint32_t CAU_DIRECT7 = (32 << 0);  ///< Direct register 7
    }

    /// CAU_DIRECT8 Register bits
    namespace cau_direct8_bits {
        constexpr uint32_t CAU_DIRECT8 = (32 << 0);  ///< Direct register 8
    }

    /// CAU_DIRECT9 Register bits
    namespace cau_direct9_bits {
        constexpr uint32_t CAU_DIRECT9 = (32 << 0);  ///< Direct register 9
    }

    /// CAU_DIRECT10 Register bits
    namespace cau_direct10_bits {
        constexpr uint32_t CAU_DIRECT10 = (32 << 0);  ///< Direct register 10
    }

    /// CAU_DIRECT11 Register bits
    namespace cau_direct11_bits {
        constexpr uint32_t CAU_DIRECT11 = (32 << 0);  ///< Direct register 11
    }

    /// CAU_DIRECT12 Register bits
    namespace cau_direct12_bits {
        constexpr uint32_t CAU_DIRECT12 = (32 << 0);  ///< Direct register 12
    }

    /// CAU_DIRECT13 Register bits
    namespace cau_direct13_bits {
        constexpr uint32_t CAU_DIRECT13 = (32 << 0);  ///< Direct register 13
    }

    /// CAU_DIRECT14 Register bits
    namespace cau_direct14_bits {
        constexpr uint32_t CAU_DIRECT14 = (32 << 0);  ///< Direct register 14
    }

    /// CAU_DIRECT15 Register bits
    namespace cau_direct15_bits {
        constexpr uint32_t CAU_DIRECT15 = (32 << 0);  ///< Direct register 15
    }

    /// CAU_LDR_CASR Register bits
    namespace cau_ldr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_LDR_CAA Register bits
    namespace cau_ldr_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_LDR_CA0 Register bits
    namespace cau_ldr_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_LDR_CA1 Register bits
    namespace cau_ldr_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_LDR_CA2 Register bits
    namespace cau_ldr_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_LDR_CA3 Register bits
    namespace cau_ldr_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_LDR_CA4 Register bits
    namespace cau_ldr_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_LDR_CA5 Register bits
    namespace cau_ldr_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_LDR_CA6 Register bits
    namespace cau_ldr_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_LDR_CA7 Register bits
    namespace cau_ldr_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_LDR_CA8 Register bits
    namespace cau_ldr_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_STR_CASR Register bits
    namespace cau_str_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_STR_CAA Register bits
    namespace cau_str_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_STR_CA0 Register bits
    namespace cau_str_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_STR_CA1 Register bits
    namespace cau_str_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_STR_CA2 Register bits
    namespace cau_str_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_STR_CA3 Register bits
    namespace cau_str_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_STR_CA4 Register bits
    namespace cau_str_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_STR_CA5 Register bits
    namespace cau_str_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_STR_CA6 Register bits
    namespace cau_str_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_STR_CA7 Register bits
    namespace cau_str_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_STR_CA8 Register bits
    namespace cau_str_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_ADR_CASR Register bits
    namespace cau_adr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_ADR_CAA Register bits
    namespace cau_adr_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_ADR_CA0 Register bits
    namespace cau_adr_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_ADR_CA1 Register bits
    namespace cau_adr_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_ADR_CA2 Register bits
    namespace cau_adr_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_ADR_CA3 Register bits
    namespace cau_adr_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_ADR_CA4 Register bits
    namespace cau_adr_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_ADR_CA5 Register bits
    namespace cau_adr_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_ADR_CA6 Register bits
    namespace cau_adr_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_ADR_CA7 Register bits
    namespace cau_adr_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_ADR_CA8 Register bits
    namespace cau_adr_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_RADR_CASR Register bits
    namespace cau_radr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_RADR_CAA Register bits
    namespace cau_radr_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_RADR_CA0 Register bits
    namespace cau_radr_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_RADR_CA1 Register bits
    namespace cau_radr_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_RADR_CA2 Register bits
    namespace cau_radr_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_RADR_CA3 Register bits
    namespace cau_radr_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_RADR_CA4 Register bits
    namespace cau_radr_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_RADR_CA5 Register bits
    namespace cau_radr_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_RADR_CA6 Register bits
    namespace cau_radr_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_RADR_CA7 Register bits
    namespace cau_radr_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_RADR_CA8 Register bits
    namespace cau_radr_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_XOR_CASR Register bits
    namespace cau_xor_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_XOR_CAA Register bits
    namespace cau_xor_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_XOR_CA0 Register bits
    namespace cau_xor_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_XOR_CA1 Register bits
    namespace cau_xor_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_XOR_CA2 Register bits
    namespace cau_xor_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_XOR_CA3 Register bits
    namespace cau_xor_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_XOR_CA4 Register bits
    namespace cau_xor_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_XOR_CA5 Register bits
    namespace cau_xor_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_XOR_CA6 Register bits
    namespace cau_xor_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_XOR_CA7 Register bits
    namespace cau_xor_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_XOR_CA8 Register bits
    namespace cau_xor_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_ROTL_CASR Register bits
    namespace cau_rotl_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_ROTL_CAA Register bits
    namespace cau_rotl_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_ROTL_CA0 Register bits
    namespace cau_rotl_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_ROTL_CA1 Register bits
    namespace cau_rotl_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_ROTL_CA2 Register bits
    namespace cau_rotl_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_ROTL_CA3 Register bits
    namespace cau_rotl_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_ROTL_CA4 Register bits
    namespace cau_rotl_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_ROTL_CA5 Register bits
    namespace cau_rotl_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_ROTL_CA6 Register bits
    namespace cau_rotl_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_ROTL_CA7 Register bits
    namespace cau_rotl_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_ROTL_CA8 Register bits
    namespace cau_rotl_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_AESC_CASR Register bits
    namespace cau_aesc_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_AESC_CAA Register bits
    namespace cau_aesc_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_AESC_CA0 Register bits
    namespace cau_aesc_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_AESC_CA1 Register bits
    namespace cau_aesc_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_AESC_CA2 Register bits
    namespace cau_aesc_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_AESC_CA3 Register bits
    namespace cau_aesc_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_AESC_CA4 Register bits
    namespace cau_aesc_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_AESC_CA5 Register bits
    namespace cau_aesc_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_AESC_CA6 Register bits
    namespace cau_aesc_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_AESC_CA7 Register bits
    namespace cau_aesc_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_AESC_CA8 Register bits
    namespace cau_aesc_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_AESIC_CASR Register bits
    namespace cau_aesic_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_AESIC_CAA Register bits
    namespace cau_aesic_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_AESIC_CA0 Register bits
    namespace cau_aesic_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_AESIC_CA1 Register bits
    namespace cau_aesic_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_AESIC_CA2 Register bits
    namespace cau_aesic_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_AESIC_CA3 Register bits
    namespace cau_aesic_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_AESIC_CA4 Register bits
    namespace cau_aesic_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_AESIC_CA5 Register bits
    namespace cau_aesic_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_AESIC_CA6 Register bits
    namespace cau_aesic_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_AESIC_CA7 Register bits
    namespace cau_aesic_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_AESIC_CA8 Register bits
    namespace cau_aesic_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

}


} // namespace alloy::generated::mkv56f24

#endif // ALLOY_GENERATED_MKV56F24_PERIPHERALS_HPP