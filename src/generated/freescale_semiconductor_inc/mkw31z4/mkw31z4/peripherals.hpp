/// Auto-generated code for MKW31Z4
/// Generated by Alloy Code Generator
/// Source: nxp_mkw31.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:34
#ifndef ALLOY_GENERATED_MKW31Z4_PERIPHERALS_HPP
#define ALLOY_GENERATED_MKW31Z4_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mkw31z4 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 2;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 5;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_rfsys = true;
    constexpr uint32_t num_rfsys_instances = 1;
    constexpr bool has_tsi0 = true;
    constexpr uint32_t num_tsi0_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 9;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 1;
    constexpr bool has_ltc0 = true;
    constexpr uint32_t num_ltc0_instances = 1;
    constexpr bool has_rsim = true;
    constexpr uint32_t num_rsim_instances = 1;
    constexpr bool has_dcdc = true;
    constexpr uint32_t num_dcdc_instances = 1;
    constexpr bool has_btle = true;
    constexpr uint32_t num_btle_instances = 1;
    constexpr bool has_rx = true;
    constexpr uint32_t num_rx_instances = 1;
    constexpr bool has_tx = true;
    constexpr uint32_t num_tx_instances = 1;
    constexpr bool has_pll = true;
    constexpr uint32_t num_pll_instances = 1;
    constexpr bool has_xcvr = true;
    constexpr uint32_t num_xcvr_instances = 6;
    constexpr bool has_ant = true;
    constexpr uint32_t num_ant_instances = 1;
    constexpr bool has_genfsk = true;
    constexpr uint32_t num_genfsk_instances = 1;
    constexpr bool has_cmt = true;
    constexpr uint32_t num_cmt_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_vref = true;
    constexpr uint32_t num_vref_instances = 1;
    constexpr bool has_llwu = true;
    constexpr uint32_t num_llwu_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_mtb = true;
    constexpr uint32_t num_mtb_instances = 1;
    constexpr bool has_mtbdwt = true;
    constexpr uint32_t num_mtbdwt_instances = 1;
    constexpr bool has_rom = true;
    constexpr uint32_t num_rom_instances = 1;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 9;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ltc0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rsim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcdc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct btle_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rx_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tx_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pll_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct xcvr_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct ant_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct genfsk_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vref_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct llwu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtbdwt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rom_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 9;
    constexpr uint32_t max_gpio_pins = 144;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart0 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFA_FlashConfig_BASE = 0x00000400;
    constexpr uint32_t FTFA_BASE = 0x40020000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
    };

    /// Peripheral instances
    inline Registers* FTFA_FlashConfig = reinterpret_cast<Registers*>(FTFA_FlashConfig_BASE);
    inline Registers* FTFA = reinterpret_cast<Registers*>(FTFA_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT0 = (1U << 0);  ///< no description available
        constexpr uint32_t NMI_DIS = (1U << 2);  ///< no description available
        constexpr uint32_t RESET_PIN_CFG = (1U << 3);  ///< no description available
        constexpr uint32_t LPBOOT1 = (1U << 4);  ///< no description available
        constexpr uint32_t FAST_INIT = (1U << 5);  ///< no description available
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX0_BASE = 0x40021000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT_;  ///< Offset: 0x24 - Interrupt Request Register (renamed from INT_)
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t EARS;  ///< Offset: 0x44 - Enable Asynchronous Request in Stop Register
        volatile uint32_t DCHPRI;  ///< Offset: 0x100 - Channel n Priority Register (renamed from DCHPRI)
        volatile uint32_t TCD_SADDR;  ///< Offset: 0x1000 - TCD Source Address (renamed from TCD_SADDR)
        volatile uint32_t TCD_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset (renamed from TCD_SOFF)
        volatile uint32_t TCD_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes (renamed from TCD_ATTR)
        volatile uint32_t TCD_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Mapping Disabled) (renamed from TCD_NBYTES_MLNO)
        volatile uint32_t TCD_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled... (renamed from TCD_NBYTES_MLOFFNO)
        volatile uint32_t TCD_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping and... (renamed from TCD_NBYTES_MLOFFYES)
        volatile uint32_t TCD_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment (renamed from TCD_SLAST)
        volatile uint32_t TCD_DADDR;  ///< Offset: 0x1010 - TCD Destination Address (renamed from TCD_DADDR)
        volatile uint32_t TCD_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset (renamed from TCD_DOFF)
        volatile uint32_t TCD_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKNO)
        volatile uint32_t TCD_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKYES)
        volatile uint32_t TCD_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address (renamed from TCD_DLASTSGA)
        volatile uint32_t TCD_CSR;  ///< Offset: 0x101C - TCD Control and Status (renamed from TCD_CSR)
        volatile uint32_t TCD_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKNO)
        volatile uint32_t TCD_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKYES)
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX0 = reinterpret_cast<Registers*>(DMAMUX0_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
        constexpr uint32_t ACTIVE = (1U << 31);  ///< DMA Active Status
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (2 << 8);  ///< Error Channel Number or Canceled Channel Number
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Canceled
        constexpr uint32_t VLD = (1U << 31);  ///< Logical OR of all ERR status bits
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (2 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (2 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (2 << 0);  ///< Clear Enable Request
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (2 << 0);  ///< Set Enable Request
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (2 << 0);  ///< Clear DONE Bit
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (2 << 0);  ///< Set START Bit
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (2 << 0);  ///< Clear Error Indicator
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (2 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// INT_ Register bits
    namespace int__bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
    }

    /// EARS Register bits
    namespace ears_bits {
        constexpr uint32_t EDREQ_0 = (1U << 0);  ///< Enable asynchronous DMA request in stop mode for channel 0.
        constexpr uint32_t EDREQ_1 = (1U << 1);  ///< Enable asynchronous DMA request in stop mode for channel 1.
        constexpr uint32_t EDREQ_2 = (1U << 2);  ///< Enable asynchronous DMA request in stop mode for channel 2.
        constexpr uint32_t EDREQ_3 = (1U << 3);  ///< Enable asynchronous DMA request in stop mode for channel 3.
    }

    /// DCHPRI Register bits
    namespace dchpri_bits {
        constexpr uint32_t CHPRI = (2 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption.
    }

    /// TCD_SADDR Register bits
    namespace tcd_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD_SOFF Register bits
    namespace tcd_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD_ATTR Register bits
    namespace tcd_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD_NBYTES_MLNO Register bits
    namespace tcd_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD_NBYTES_MLOFFNO Register bits
    namespace tcd_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_NBYTES_MLOFFYES Register bits
    namespace tcd_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_SLAST Register bits
    namespace tcd_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD_DADDR Register bits
    namespace tcd_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD_DOFF Register bits
    namespace tcd_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD_CITER_ELINKNO Register bits
    namespace tcd_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_CITER_ELINKYES Register bits
    namespace tcd_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (2 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_DLASTSGA Register bits
    namespace tcd_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather)
    }

    /// TCD_CSR Register bits
    namespace tcd_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (2 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD_BITER_ELINKNO Register bits
    namespace tcd_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD_BITER_ELINKYES Register bits
    namespace tcd_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (2 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t TRNG0_BASE = 0x40029000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t MCTL;  ///< Offset: 0x00 - Miscellaneous Control Register
        volatile uint32_t SCMISC;  ///< Offset: 0x04 - Statistical Check Miscellaneous Register
        volatile uint32_t PKRRNG;  ///< Offset: 0x08 - Poker Range Register
        volatile uint32_t PKRMAX;  ///< Offset: 0x0C - Poker Maximum Limit Register
        volatile uint32_t PKRSQ;  ///< Offset: 0x0C - Poker Square Calculation Result Register
        volatile uint32_t SDCTL;  ///< Offset: 0x10 - Seed Control Register
        volatile uint32_t SBLIM;  ///< Offset: 0x14 - Sparse Bit Limit Register
        volatile uint32_t TOTSAM;  ///< Offset: 0x14 - Total Samples Register
        volatile uint32_t FRQMIN;  ///< Offset: 0x18 - Frequency Count Minimum Limit Register
        volatile uint32_t FRQCNT;  ///< Offset: 0x1C - Frequency Count Register
        volatile uint32_t FRQMAX;  ///< Offset: 0x1C - Frequency Count Maximum Limit Register
        volatile uint32_t SCMC;  ///< Offset: 0x20 - Statistical Check Monobit Count Register
        volatile uint32_t SCML;  ///< Offset: 0x20 - Statistical Check Monobit Limit Register
        volatile uint32_t SCR1C;  ///< Offset: 0x24 - Statistical Check Run Length 1 Count Register
        volatile uint32_t SCR1L;  ///< Offset: 0x24 - Statistical Check Run Length 1 Limit Register
        volatile uint32_t SCR2C;  ///< Offset: 0x28 - Statistical Check Run Length 2 Count Register
        volatile uint32_t SCR2L;  ///< Offset: 0x28 - Statistical Check Run Length 2 Limit Register
        volatile uint32_t SCR3C;  ///< Offset: 0x2C - Statistical Check Run Length 3 Count Register
        volatile uint32_t SCR3L;  ///< Offset: 0x2C - Statistical Check Run Length 3 Limit Register
        volatile uint32_t SCR4C;  ///< Offset: 0x30 - Statistical Check Run Length 4 Count Register
        volatile uint32_t SCR4L;  ///< Offset: 0x30 - Statistical Check Run Length 4 Limit Register
        volatile uint32_t SCR5C;  ///< Offset: 0x34 - Statistical Check Run Length 5 Count Register
        volatile uint32_t SCR5L;  ///< Offset: 0x34 - Statistical Check Run Length 5 Limit Register
        volatile uint32_t SCR6PC;  ///< Offset: 0x38 - Statistical Check Run Length 6+ Count Register
        volatile uint32_t SCR6PL;  ///< Offset: 0x38 - Statistical Check Run Length 6+ Limit Register
        volatile uint32_t STATUS;  ///< Offset: 0x3C - Status Register
        volatile uint32_t ENT0;  ///< Offset: 0x40 - Entropy Read Register
        volatile uint32_t ENT1;  ///< Offset: 0x44 - Entropy Read Register
        volatile uint32_t ENT2;  ///< Offset: 0x48 - Entropy Read Register
        volatile uint32_t ENT3;  ///< Offset: 0x4C - Entropy Read Register
        volatile uint32_t ENT4;  ///< Offset: 0x50 - Entropy Read Register
        volatile uint32_t ENT5;  ///< Offset: 0x54 - Entropy Read Register
        volatile uint32_t ENT6;  ///< Offset: 0x58 - Entropy Read Register
        volatile uint32_t ENT7;  ///< Offset: 0x5C - Entropy Read Register
        volatile uint32_t ENT8;  ///< Offset: 0x60 - Entropy Read Register
        volatile uint32_t ENT9;  ///< Offset: 0x64 - Entropy Read Register
        volatile uint32_t ENT10;  ///< Offset: 0x68 - Entropy Read Register
        volatile uint32_t ENT11;  ///< Offset: 0x6C - Entropy Read Register
        volatile uint32_t ENT12;  ///< Offset: 0x70 - Entropy Read Register
        volatile uint32_t ENT13;  ///< Offset: 0x74 - Entropy Read Register
        volatile uint32_t ENT14;  ///< Offset: 0x78 - Entropy Read Register
        volatile uint32_t ENT15;  ///< Offset: 0x7C - Entropy Read Register
        volatile uint32_t PKRCNT10;  ///< Offset: 0x80 - Statistical Check Poker Count 1 and 0 Register
        volatile uint32_t PKRCNT32;  ///< Offset: 0x84 - Statistical Check Poker Count 3 and 2 Register
        volatile uint32_t PKRCNT54;  ///< Offset: 0x88 - Statistical Check Poker Count 5 and 4 Register
        volatile uint32_t PKRCNT76;  ///< Offset: 0x8C - Statistical Check Poker Count 7 and 6 Register
        volatile uint32_t PKRCNT98;  ///< Offset: 0x90 - Statistical Check Poker Count 9 and 8 Register
        volatile uint32_t PKRCNTBA;  ///< Offset: 0x94 - Statistical Check Poker Count B and A Register
        volatile uint32_t PKRCNTDC;  ///< Offset: 0x98 - Statistical Check Poker Count D and C Register
        volatile uint32_t PKRCNTFE;  ///< Offset: 0x9C - Statistical Check Poker Count F and E Register
        volatile uint32_t SEC_CFG;  ///< Offset: 0xB0 - Security Configuration Register
        volatile uint32_t INT_CTRL;  ///< Offset: 0xB4 - Interrupt Control Register
        volatile uint32_t INT_MASK;  ///< Offset: 0xB8 - Mask Register
        volatile uint32_t INT_STATUS;  ///< Offset: 0xBC - Interrupt Status Register
        volatile uint32_t VID1;  ///< Offset: 0xF0 - Version ID Register (MS)
        volatile uint32_t VID2;  ///< Offset: 0xF4 - Version ID Register (LS)
    };

    /// Peripheral instances
    inline Registers* TRNG0 = reinterpret_cast<Registers*>(TRNG0_BASE);

    // Bit definitions
    /// MCTL Register bits
    namespace mctl_bits {
        constexpr uint32_t SAMP_MODE = (2 << 0);  ///< Sample Mode
        constexpr uint32_t OSC_DIV = (2 << 2);  ///< Oscillator Divide
        constexpr uint32_t UNUSED = (1U << 4);  ///< This bit is unused but write-able. Must be left as zero.
        constexpr uint32_t TRNG_ACC = (1U << 5);  ///< TRNG Access Mode
        constexpr uint32_t RST_DEF = (1U << 6);  ///< Reset Defaults
        constexpr uint32_t FOR_SCLK = (1U << 7);  ///< Force System Clock
        constexpr uint32_t FCT_FAIL = (1U << 8);  ///< Read only: Frequency Count Fail
        constexpr uint32_t FCT_VAL = (1U << 9);  ///< Read only: Frequency Count Valid. Indicates that a valid frequency count may be read from FRQCNT.
        constexpr uint32_t ENT_VAL = (1U << 10);  ///< Read only: Entropy Valid
        constexpr uint32_t TST_OUT = (1U << 11);  ///< Read only: Test point inside ring oscillator.
        constexpr uint32_t ERR = (1U << 12);  ///< Read: Error status
        constexpr uint32_t TSTOP_OK = (1U << 13);  ///< TRNG_OK_TO_STOP
        constexpr uint32_t PRGM = (1U << 16);  ///< Programming Mode Select
    }

    /// SCMISC Register bits
    namespace scmisc_bits {
        constexpr uint32_t LRUN_MAX = (8 << 0);  ///< LONG RUN MAX LIMIT
        constexpr uint32_t RTY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// PKRRNG Register bits
    namespace pkrrng_bits {
        constexpr uint32_t PKR_RNG = (16 << 0);  ///< Poker Range
    }

    /// PKRMAX Register bits
    namespace pkrmax_bits {
        constexpr uint32_t PKR_MAX = (24 << 0);  ///< Poker Maximum Limit.
    }

    /// PKRSQ Register bits
    namespace pkrsq_bits {
        constexpr uint32_t PKR_SQ = (24 << 0);  ///< Poker Square Calculation Result.
    }

    /// SDCTL Register bits
    namespace sdctl_bits {
        constexpr uint32_t SAMP_SIZE = (16 << 0);  ///< Sample Size
        constexpr uint32_t ENT_DLY = (16 << 16);  ///< Entropy Delay
    }

    /// SBLIM Register bits
    namespace sblim_bits {
        constexpr uint32_t SB_LIM = (10 << 0);  ///< Sparse Bit Limit
    }

    /// TOTSAM Register bits
    namespace totsam_bits {
        constexpr uint32_t TOT_SAM = (20 << 0);  ///< Total Samples
    }

    /// FRQMIN Register bits
    namespace frqmin_bits {
        constexpr uint32_t FRQ_MIN = (22 << 0);  ///< Frequency Count Minimum Limit
    }

    /// FRQCNT Register bits
    namespace frqcnt_bits {
        constexpr uint32_t FRQ_CT = (22 << 0);  ///< Frequency Count
    }

    /// FRQMAX Register bits
    namespace frqmax_bits {
        constexpr uint32_t FRQ_MAX = (22 << 0);  ///< Frequency Counter Maximum Limit
    }

    /// SCMC Register bits
    namespace scmc_bits {
        constexpr uint32_t MONO_CT = (16 << 0);  ///< Monobit Count
    }

    /// SCML Register bits
    namespace scml_bits {
        constexpr uint32_t MONO_MAX = (16 << 0);  ///< Monobit Maximum Limit
        constexpr uint32_t MONO_RNG = (16 << 16);  ///< Monobit Range
    }

    /// SCR1C Register bits
    namespace scr1c_bits {
        constexpr uint32_t R1_0_CT = (15 << 0);  ///< Runs of Zero, Length 1 Count
        constexpr uint32_t R1_1_CT = (15 << 16);  ///< Runs of One, Length 1 Count
    }

    /// SCR1L Register bits
    namespace scr1l_bits {
        constexpr uint32_t RUN1_MAX = (15 << 0);  ///< Run Length 1 Maximum Limit
        constexpr uint32_t RUN1_RNG = (15 << 16);  ///< Run Length 1 Range
    }

    /// SCR2C Register bits
    namespace scr2c_bits {
        constexpr uint32_t R2_0_CT = (14 << 0);  ///< Runs of Zero, Length 2 Count
        constexpr uint32_t R2_1_CT = (14 << 16);  ///< Runs of One, Length 2 Count
    }

    /// SCR2L Register bits
    namespace scr2l_bits {
        constexpr uint32_t RUN2_MAX = (14 << 0);  ///< Run Length 2 Maximum Limit
        constexpr uint32_t RUN2_RNG = (14 << 16);  ///< Run Length 2 Range
    }

    /// SCR3C Register bits
    namespace scr3c_bits {
        constexpr uint32_t R3_0_CT = (13 << 0);  ///< Runs of Zeroes, Length 3 Count
        constexpr uint32_t R3_1_CT = (13 << 16);  ///< Runs of Ones, Length 3 Count
    }

    /// SCR3L Register bits
    namespace scr3l_bits {
        constexpr uint32_t RUN3_MAX = (13 << 0);  ///< Run Length 3 Maximum Limit
        constexpr uint32_t RUN3_RNG = (13 << 16);  ///< Run Length 3 Range
    }

    /// SCR4C Register bits
    namespace scr4c_bits {
        constexpr uint32_t R4_0_CT = (12 << 0);  ///< Runs of Zero, Length 4 Count
        constexpr uint32_t R4_1_CT = (12 << 16);  ///< Runs of One, Length 4 Count
    }

    /// SCR4L Register bits
    namespace scr4l_bits {
        constexpr uint32_t RUN4_MAX = (12 << 0);  ///< Run Length 4 Maximum Limit
        constexpr uint32_t RUN4_RNG = (12 << 16);  ///< Run Length 4 Range
    }

    /// SCR5C Register bits
    namespace scr5c_bits {
        constexpr uint32_t R5_0_CT = (11 << 0);  ///< Runs of Zero, Length 5 Count
        constexpr uint32_t R5_1_CT = (11 << 16);  ///< Runs of One, Length 5 Count
    }

    /// SCR5L Register bits
    namespace scr5l_bits {
        constexpr uint32_t RUN5_MAX = (11 << 0);  ///< Run Length 5 Maximum Limit
        constexpr uint32_t RUN5_RNG = (11 << 16);  ///< Run Length 5 Range
    }

    /// SCR6PC Register bits
    namespace scr6pc_bits {
        constexpr uint32_t R6P_0_CT = (11 << 0);  ///< Runs of Zero, Length 6+ Count
        constexpr uint32_t R6P_1_CT = (11 << 16);  ///< Runs of One, Length 6+ Count
    }

    /// SCR6PL Register bits
    namespace scr6pl_bits {
        constexpr uint32_t RUN6P_MAX = (11 << 0);  ///< Run Length 6+ Maximum Limit
        constexpr uint32_t RUN6P_RNG = (11 << 16);  ///< Run Length 6+ Range
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t TF1BR0 = (1U << 0);  ///< Test Fail, 1-Bit Run, Sampling 0s. If TF1BR0=1, the 1-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF1BR1 = (1U << 1);  ///< Test Fail, 1-Bit Run, Sampling 1s. If TF1BR1=1, the 1-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF2BR0 = (1U << 2);  ///< Test Fail, 2-Bit Run, Sampling 0s. If TF2BR0=1, the 2-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF2BR1 = (1U << 3);  ///< Test Fail, 2-Bit Run, Sampling 1s. If TF2BR1=1, the 2-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF3BR0 = (1U << 4);  ///< Test Fail, 3-Bit Run, Sampling 0s. If TF3BR0=1, the 3-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF3BR1 = (1U << 5);  ///< Test Fail, 3-Bit Run, Sampling 1s. If TF3BR1=1, the 3-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF4BR0 = (1U << 6);  ///< Test Fail, 4-Bit Run, Sampling 0s. If TF4BR0=1, the 4-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF4BR1 = (1U << 7);  ///< Test Fail, 4-Bit Run, Sampling 1s. If TF4BR1=1, the 4-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF5BR0 = (1U << 8);  ///< Test Fail, 5-Bit Run, Sampling 0s. If TF5BR0=1, the 5-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF5BR1 = (1U << 9);  ///< Test Fail, 5-Bit Run, Sampling 1s. If TF5BR1=1, the 5-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF6PBR0 = (1U << 10);  ///< Test Fail, 6 Plus Bit Run, Sampling 0s
        constexpr uint32_t TF6PBR1 = (1U << 11);  ///< Test Fail, 6 Plus Bit Run, Sampling 1s
        constexpr uint32_t TFSB = (1U << 12);  ///< Test Fail, Sparse Bit. If TFSB=1, the Sparse Bit Test has failed.
        constexpr uint32_t TFLR = (1U << 13);  ///< Test Fail, Long Run. If TFLR=1, the Long Run Test has failed.
        constexpr uint32_t TFP = (1U << 14);  ///< Test Fail, Poker. If TFP=1, the Poker Test has failed.
        constexpr uint32_t TFMB = (1U << 15);  ///< Test Fail, Mono Bit. If TFMB=1, the Mono Bit Test has failed.
        constexpr uint32_t RETRY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// ENT0 Register bits
    namespace ent0_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT1 Register bits
    namespace ent1_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT2 Register bits
    namespace ent2_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT3 Register bits
    namespace ent3_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT4 Register bits
    namespace ent4_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT5 Register bits
    namespace ent5_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT6 Register bits
    namespace ent6_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT7 Register bits
    namespace ent7_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT8 Register bits
    namespace ent8_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT9 Register bits
    namespace ent9_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT10 Register bits
    namespace ent10_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT11 Register bits
    namespace ent11_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT12 Register bits
    namespace ent12_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT13 Register bits
    namespace ent13_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT14 Register bits
    namespace ent14_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT15 Register bits
    namespace ent15_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// PKRCNT10 Register bits
    namespace pkrcnt10_bits {
        constexpr uint32_t PKR_0_CT = (16 << 0);  ///< Poker 0h Count
        constexpr uint32_t PKR_1_CT = (16 << 16);  ///< Poker 1h Count
    }

    /// PKRCNT32 Register bits
    namespace pkrcnt32_bits {
        constexpr uint32_t PKR_2_CT = (16 << 0);  ///< Poker 2h Count
        constexpr uint32_t PKR_3_CT = (16 << 16);  ///< Poker 3h Count
    }

    /// PKRCNT54 Register bits
    namespace pkrcnt54_bits {
        constexpr uint32_t PKR_4_CT = (16 << 0);  ///< Poker 4h Count
        constexpr uint32_t PKR_5_CT = (16 << 16);  ///< Poker 5h Count
    }

    /// PKRCNT76 Register bits
    namespace pkrcnt76_bits {
        constexpr uint32_t PKR_6_CT = (16 << 0);  ///< Poker 6h Count
        constexpr uint32_t PKR_7_CT = (16 << 16);  ///< Poker 7h Count
    }

    /// PKRCNT98 Register bits
    namespace pkrcnt98_bits {
        constexpr uint32_t PKR_8_CT = (16 << 0);  ///< Poker 8h Count
        constexpr uint32_t PKR_9_CT = (16 << 16);  ///< Poker 9h Count
    }

    /// PKRCNTBA Register bits
    namespace pkrcntba_bits {
        constexpr uint32_t PKR_A_CT = (16 << 0);  ///< Poker Ah Count
        constexpr uint32_t PKR_B_CT = (16 << 16);  ///< Poker Bh Count
    }

    /// PKRCNTDC Register bits
    namespace pkrcntdc_bits {
        constexpr uint32_t PKR_C_CT = (16 << 0);  ///< Poker Ch Count
        constexpr uint32_t PKR_D_CT = (16 << 16);  ///< Poker Dh Count
    }

    /// PKRCNTFE Register bits
    namespace pkrcntfe_bits {
        constexpr uint32_t PKR_E_CT = (16 << 0);  ///< Poker Eh Count
        constexpr uint32_t PKR_F_CT = (16 << 16);  ///< Poker Fh Count
    }

    /// SEC_CFG Register bits
    namespace sec_cfg_bits {
        constexpr uint32_t SH0 = (1U << 0);  ///< Reserved. DRNG specific, not applicable to this version.
        constexpr uint32_t NO_PRGM = (1U << 1);  ///< If set, the TRNG registers cannot be programmed
        constexpr uint32_t SK_VAL = (1U << 2);  ///< Reserved. DRNG-specific, not applicable to this version.
    }

    /// INT_CTRL Register bits
    namespace int_ctrl_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 above.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 above.
        constexpr uint32_t UNUSED = (29 << 3);  ///< Reserved but writeable.
    }

    /// INT_MASK Register bits
    namespace int_mask_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 above.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 above.
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Read: Error status
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Read only: Entropy Valid
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Read only: Frequency Count Fail
    }

    /// VID1 Register bits
    namespace vid1_bits {
        constexpr uint32_t MIN_REV = (8 << 0);  ///< Shows the Freescale IP's Minor revision of the TRNG.
        constexpr uint32_t MAJ_REV = (8 << 8);  ///< Shows the Freescale IP's Major revision of the TRNG.
        constexpr uint32_t IP_ID = (16 << 16);  ///< Shows the Freescale IP ID.
    }

    /// VID2 Register bits
    namespace vid2_bits {
        constexpr uint32_t CONFIG_OPT = (8 << 0);  ///< Shows the Freescale IP's Configuaration options for the TRNG.
        constexpr uint32_t ECO_REV = (8 << 8);  ///< Shows the Freescale IP's ECO revision of the TRNG.
        constexpr uint32_t INTG_OPT = (8 << 16);  ///< Shows the Freescale integration options for the TRNG.
        constexpr uint32_t ERA = (8 << 24);  ///< Shows the Freescale compile options for the TRNG.
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x4002C000;
    constexpr uint32_t SPI1_BASE = 0x4002D000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t TCR;  ///< Offset: 0x08 - Transfer Count Register
        volatile uint32_t CTAR;  ///< Offset: 0x0C - Clock and Transfer Attributes Register (In Master Mode) (renamed from CTAR)
        volatile uint32_t CTAR_SLAVE;  ///< Offset: 0x0C - Clock and Transfer Attributes Register (In Slave Mode)
        volatile uint32_t SR;  ///< Offset: 0x2C - Status Register
        volatile uint32_t RSER;  ///< Offset: 0x30 - DMA/Interrupt Request Select and Enable Register
        volatile uint32_t PUSHR;  ///< Offset: 0x34 - PUSH TX FIFO Register In Master Mode
        volatile uint32_t PUSHR_SLAVE;  ///< Offset: 0x34 - PUSH TX FIFO Register In Slave Mode
        volatile uint32_t POPR;  ///< Offset: 0x38 - POP RX FIFO Register
        volatile uint32_t TXFR;  ///< Offset: 0x3C - Transmit FIFO Registers (renamed from TXFR)
        volatile uint32_t RXFR;  ///< Offset: 0x7C - Receive FIFO Registers (renamed from RXFR)
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t HALT = (1U << 0);  ///< Halt
        constexpr uint32_t SMPL_PT = (2 << 8);  ///< Sample Point
        constexpr uint32_t CLR_RXF = (1U << 10);  ///< CLR_RXF
        constexpr uint32_t CLR_TXF = (1U << 11);  ///< Clear TX FIFO
        constexpr uint32_t DIS_RXF = (1U << 12);  ///< Disable Receive FIFO
        constexpr uint32_t DIS_TXF = (1U << 13);  ///< Disable Transmit FIFO
        constexpr uint32_t MDIS = (1U << 14);  ///< Module Disable
        constexpr uint32_t DOZE = (1U << 15);  ///< Doze Enable
        constexpr uint32_t PCSIS = (4 << 16);  ///< Peripheral Chip Select x Inactive State
        constexpr uint32_t ROOE = (1U << 24);  ///< Receive FIFO Overflow Overwrite Enable
        constexpr uint32_t MTFE = (1U << 26);  ///< Modified Transfer Format Enable
        constexpr uint32_t FRZ = (1U << 27);  ///< Freeze
        constexpr uint32_t DCONF = (2 << 28);  ///< SPI Configuration.
        constexpr uint32_t CONT_SCKE = (1U << 30);  ///< Continuous SCK Enable
        constexpr uint32_t MSTR = (1U << 31);  ///< Master/Slave Mode Select
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t SPI_TCNT = (16 << 16);  ///< SPI Transfer Counter
    }

    /// CTAR Register bits
    namespace ctar_bits {
        constexpr uint32_t BR = (4 << 0);  ///< Baud Rate Scaler
        constexpr uint32_t DT = (4 << 4);  ///< Delay After Transfer Scaler
        constexpr uint32_t ASC = (4 << 8);  ///< After SCK Delay Scaler
        constexpr uint32_t CSSCK = (4 << 12);  ///< PCS to SCK Delay Scaler
        constexpr uint32_t PBR = (2 << 16);  ///< Baud Rate Prescaler
        constexpr uint32_t PDT = (2 << 18);  ///< Delay after Transfer Prescaler
        constexpr uint32_t PASC = (2 << 20);  ///< After SCK Delay Prescaler
        constexpr uint32_t PCSSCK = (2 << 22);  ///< PCS to SCK Delay Prescaler
        constexpr uint32_t LSBFE = (1U << 24);  ///< LSB First
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
        constexpr uint32_t DBR = (1U << 31);  ///< Double Baud Rate
    }

    /// CTAR_SLAVE Register bits
    namespace ctar_slave_bits {
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t POPNXTPTR = (4 << 0);  ///< Pop Next Pointer
        constexpr uint32_t RXCTR = (4 << 4);  ///< RX FIFO Counter
        constexpr uint32_t TXNXTPTR = (4 << 8);  ///< Transmit Next Pointer
        constexpr uint32_t TXCTR = (4 << 12);  ///< TX FIFO Counter
        constexpr uint32_t RFDF = (1U << 17);  ///< Receive FIFO Drain Flag
        constexpr uint32_t RFOF = (1U << 19);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t TFFF = (1U << 25);  ///< Transmit FIFO Fill Flag
        constexpr uint32_t TFUF = (1U << 27);  ///< Transmit FIFO Underflow Flag
        constexpr uint32_t EOQF = (1U << 28);  ///< End of Queue Flag
        constexpr uint32_t TXRXS = (1U << 30);  ///< TX and RX Status
        constexpr uint32_t TCF = (1U << 31);  ///< Transfer Complete Flag
    }

    /// RSER Register bits
    namespace rser_bits {
        constexpr uint32_t RFDF_DIRS = (1U << 16);  ///< Receive FIFO Drain DMA or Interrupt Request Select
        constexpr uint32_t RFDF_RE = (1U << 17);  ///< Receive FIFO Drain Request Enable
        constexpr uint32_t RFOF_RE = (1U << 19);  ///< Receive FIFO Overflow Request Enable
        constexpr uint32_t TFFF_DIRS = (1U << 24);  ///< Transmit FIFO Fill DMA or Interrupt Request Select
        constexpr uint32_t TFFF_RE = (1U << 25);  ///< Transmit FIFO Fill Request Enable
        constexpr uint32_t TFUF_RE = (1U << 27);  ///< Transmit FIFO Underflow Request Enable
        constexpr uint32_t EOQF_RE = (1U << 28);  ///< Finished Request Enable
        constexpr uint32_t TCF_RE = (1U << 31);  ///< Transmission Complete Request Enable
    }

    /// PUSHR Register bits
    namespace pushr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t PCS = (4 << 16);  ///< Select which PCS signals are to be asserted for the transfer
        constexpr uint32_t CTCNT = (1U << 26);  ///< Clear Transfer Counter
        constexpr uint32_t EOQ = (1U << 27);  ///< End Of Queue
        constexpr uint32_t CTAS = (3 << 28);  ///< Clock and Transfer Attributes Select
        constexpr uint32_t CONT = (1U << 31);  ///< Continuous Peripheral Chip Select Enable
    }

    /// PUSHR_SLAVE Register bits
    namespace pushr_slave_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
    }

    /// POPR Register bits
    namespace popr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Received Data
    }

    /// TXFR Register bits
    namespace txfr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t TXCMD_TXDATA = (16 << 16);  ///< Transmit Command or Transmit Data
    }

    /// RXFR Register bits
    namespace rxfr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Receive Data
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT_BASE = 0x40037000;
    constexpr uint32_t TPM0_BASE = 0x40038000;
    constexpr uint32_t TPM1_BASE = 0x40039000;
    constexpr uint32_t TPM2_BASE = 0x4003A000;
    constexpr uint32_t LPTMR0_BASE = 0x40040000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LTMR64H;  ///< Offset: 0xE0 - PIT Upper Lifetime Timer Register
        volatile uint32_t LTMR64L;  ///< Offset: 0xE4 - PIT Lower Lifetime Timer Register
        volatile uint32_t LDVAL;  ///< Offset: 0x100 - Timer Load Value Register (renamed from LDVAL)
        volatile uint32_t CVAL;  ///< Offset: 0x104 - Current Timer Value Register (renamed from CVAL)
        volatile uint32_t TCTRL;  ///< Offset: 0x108 - Timer Control Register (renamed from TCTRL)
        volatile uint32_t TFLG;  ///< Offset: 0x10C - Timer Flag Register (renamed from TFLG)
    };

    /// Peripheral instances
    inline Registers* PIT = reinterpret_cast<Registers*>(PIT_BASE);
    inline Registers* TPM0 = reinterpret_cast<Registers*>(TPM0_BASE);
    inline Registers* TPM1 = reinterpret_cast<Registers*>(TPM1_BASE);
    inline Registers* TPM2 = reinterpret_cast<Registers*>(TPM2_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable - (PIT section)
    }

    /// LTMR64H Register bits
    namespace ltmr64h_bits {
        constexpr uint32_t LTH = (32 << 0);  ///< Life Timer value
    }

    /// LTMR64L Register bits
    namespace ltmr64l_bits {
        constexpr uint32_t LTL = (32 << 0);  ///< Life Timer value
    }

    /// LDVAL Register bits
    namespace ldval_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value
    }

    /// CVAL Register bits
    namespace cval_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL Register bits
    namespace tctrl_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable
        constexpr uint32_t CHN = (1U << 2);  ///< Chain Mode
    }

    /// TFLG Register bits
    namespace tflg_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1;  ///< Offset: 0x00 - ADC Status and Control Registers 1 (renamed from SC1)
        volatile uint32_t CFG1;  ///< Offset: 0x08 - ADC Configuration Register 1
        volatile uint32_t CFG2;  ///< Offset: 0x0C - ADC Configuration Register 2
        volatile uint32_t R;  ///< Offset: 0x10 - ADC Data Result Register (renamed from R)
        volatile uint32_t CV;  ///< Offset: 0x18 - Compare Value Registers (renamed from CV)
        volatile uint32_t SC2;  ///< Offset: 0x20 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x24 - Status and Control Register 3
        volatile uint32_t OFS;  ///< Offset: 0x28 - ADC Offset Correction Register
        volatile uint32_t PG;  ///< Offset: 0x2C - ADC Plus-Side Gain Register
        volatile uint32_t MG;  ///< Offset: 0x30 - ADC Minus-Side Gain Register
        volatile uint32_t CLPD;  ///< Offset: 0x34 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPS;  ///< Offset: 0x38 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP4;  ///< Offset: 0x3C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP3;  ///< Offset: 0x40 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2;  ///< Offset: 0x44 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1;  ///< Offset: 0x48 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0;  ///< Offset: 0x4C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLMD;  ///< Offset: 0x54 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLMS;  ///< Offset: 0x58 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM4;  ///< Offset: 0x5C - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM3;  ///< Offset: 0x60 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM2;  ///< Offset: 0x64 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM1;  ///< Offset: 0x68 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM0;  ///< Offset: 0x6C - ADC Minus-Side General Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);

    // Bit definitions
    /// SC1 Register bits
    namespace sc1_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t DIFF = (1U << 5);  ///< Differential Mode Enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Sample Time Configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-Power Configuration
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t ADLSTS = (2 << 0);  ///< Long Sample Time Select
        constexpr uint32_t ADHSC = (1U << 2);  ///< High-Speed Configuration
        constexpr uint32_t ADACKEN = (1U << 3);  ///< Asynchronous Clock Output Enable
        constexpr uint32_t MUXSEL = (1U << 4);  ///< ADC Mux Select
    }

    /// R Register bits
    namespace r_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data result
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t CV = (16 << 0);  ///< Compare Value.
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage Reference Selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA Enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare Function Range Enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware Average Select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware Average Enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous Conversion Enable
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration Failed Flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset Error Correction Value
    }

    /// PG Register bits
    namespace pg_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Plus-Side Gain
    }

    /// MG Register bits
    namespace mg_bits {
        constexpr uint32_t MG = (16 << 0);  ///< Minus-Side Gain
    }

    /// CLPD Register bits
    namespace clpd_bits {
        constexpr uint32_t CLPD = (6 << 0);  ///< Calibration Value
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (6 << 0);  ///< Calibration Value
    }

    /// CLP4 Register bits
    namespace clp4_bits {
        constexpr uint32_t CLP4 = (10 << 0);  ///< Calibration Value
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (9 << 0);  ///< Calibration Value
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (8 << 0);  ///< Calibration Value
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (7 << 0);  ///< Calibration Value
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (6 << 0);  ///< Calibration Value
    }

    /// CLMD Register bits
    namespace clmd_bits {
        constexpr uint32_t CLMD = (6 << 0);  ///< Calibration Value
    }

    /// CLMS Register bits
    namespace clms_bits {
        constexpr uint32_t CLMS = (6 << 0);  ///< Calibration Value
    }

    /// CLM4 Register bits
    namespace clm4_bits {
        constexpr uint32_t CLM4 = (10 << 0);  ///< Calibration Value
    }

    /// CLM3 Register bits
    namespace clm3_bits {
        constexpr uint32_t CLM3 = (9 << 0);  ///< Calibration Value
    }

    /// CLM2 Register bits
    namespace clm2_bits {
        constexpr uint32_t CLM2 = (8 << 0);  ///< Calibration Value
    }

    /// CLM1 Register bits
    namespace clm1_bits {
        constexpr uint32_t CLM1 = (7 << 0);  ///< Calibration Value
    }

    /// CLM0 Register bits
    namespace clm0_bits {
        constexpr uint32_t CLM0 = (6 << 0);  ///< Calibration Value
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TSR;  ///< Offset: 0x00 - RTC Time Seconds Register
        volatile uint32_t TPR;  ///< Offset: 0x04 - RTC Time Prescaler Register
        volatile uint32_t TAR;  ///< Offset: 0x08 - RTC Time Alarm Register
        volatile uint32_t TCR;  ///< Offset: 0x0C - RTC Time Compensation Register
        volatile uint32_t CR;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - RTC Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - RTC Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - RTC Interrupt Enable Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (32 << 0);  ///< Time Seconds Register
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t TPR = (16 << 0);  ///< Time Prescaler Register
    }

    /// TAR Register bits
    namespace tar_bits {
        constexpr uint32_t TAR = (32 << 0);  ///< Time Alarm Register
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCR = (8 << 0);  ///< Time Compensation Register
        constexpr uint32_t CIR = (8 << 8);  ///< Compensation Interval Register
        constexpr uint32_t TCV = (8 << 16);  ///< Time Compensation Value
        constexpr uint32_t CIC = (8 << 24);  ///< Compensation Interval Counter
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t WPE = (1U << 1);  ///< Wakeup Pin Enable
        constexpr uint32_t SUP = (1U << 2);  ///< Supervisor Access
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t WPS = (1U << 4);  ///< Wakeup Pin Select
        constexpr uint32_t OSCE = (1U << 8);  ///< Oscillator Enable
        constexpr uint32_t CLKO = (1U << 9);  ///< Clock Output
        constexpr uint32_t SC16P = (1U << 10);  ///< Oscillator 16pF Load Configure
        constexpr uint32_t SC8P = (1U << 11);  ///< Oscillator 8pF Load Configure
        constexpr uint32_t SC4P = (1U << 12);  ///< Oscillator 4pF Load Configure
        constexpr uint32_t SC2P = (1U << 13);  ///< Oscillator 2pF Load Configure
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time Invalid Flag
        constexpr uint32_t TOF = (1U << 1);  ///< Time Overflow Flag
        constexpr uint32_t TAF = (1U << 2);  ///< Time Alarm Flag
        constexpr uint32_t TCE = (1U << 4);  ///< Time Counter Enable
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t TCL = (1U << 3);  ///< Time Compensation Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TIIE = (1U << 0);  ///< Time Invalid Interrupt Enable
        constexpr uint32_t TOIE = (1U << 1);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t TAIE = (1U << 2);  ///< Time Alarm Interrupt Enable
        constexpr uint32_t TSIE = (1U << 4);  ///< Time Seconds Interrupt Enable
        constexpr uint32_t WPON = (1U << 7);  ///< Wakeup Pin On
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC0_BASE = 0x4003F000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DATL;  ///< Offset: 0x00 - DAC Data Low Register (renamed from DATL)
        volatile uint32_t DATH;  ///< Offset: 0x01 - DAC Data High Register (renamed from DATH)
        volatile uint32_t SR;  ///< Offset: 0x20 - DAC Status Register
        volatile uint32_t C0;  ///< Offset: 0x21 - DAC Control Register
        volatile uint32_t C1;  ///< Offset: 0x22 - DAC Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x23 - DAC Control Register 2
    };

    /// Peripheral instances
    inline Registers* DAC0 = reinterpret_cast<Registers*>(DAC0_BASE);

    // Bit definitions
    /// DATL Register bits
    namespace datl_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0
    }

    /// DATH Register bits
    namespace dath_bits {
        constexpr uint32_t DATA1 = (4 << 0);  ///< DATA1
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DACBFRPBF = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Position Flag
        constexpr uint32_t DACBFRPTF = (1U << 1);  ///< DAC Buffer Read Pointer Top Position Flag
        constexpr uint32_t DACBFWMF = (1U << 2);  ///< DAC Buffer Watermark Flag
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t DACBBIEN = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Flag Interrupt Enable
        constexpr uint32_t DACBTIEN = (1U << 1);  ///< DAC Buffer Read Pointer Top Flag Interrupt Enable
        constexpr uint32_t DACBWIEN = (1U << 2);  ///< DAC Buffer Watermark Interrupt Enable
        constexpr uint32_t LPEN = (1U << 3);  ///< DAC Low Power Control
        constexpr uint32_t DACSWTRG = (1U << 4);  ///< DAC Software Trigger
        constexpr uint32_t DACTRGSEL = (1U << 5);  ///< DAC Trigger Select
        constexpr uint32_t DACRFS = (1U << 6);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DACBFEN = (1U << 0);  ///< DAC Buffer Enable
        constexpr uint32_t DACBFMD = (1U << 2);  ///< DAC Buffer Work Mode Select
        constexpr uint32_t DACBFWM = (2 << 3);  ///< DAC Buffer Watermark Select
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA Enable Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t DACBFUP = (1U << 0);  ///< DAC Buffer Upper Limit
        constexpr uint32_t DACBFRP = (1U << 4);  ///< DAC Buffer Read Pointer
    }

}

// ============================================================================
// RFSYS Peripheral
// ============================================================================

namespace rfsys {
    /// Base addresses
    constexpr uint32_t RFSYS_BASE = 0x40041000;

    /// RFSYS Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - Register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFSYS = reinterpret_cast<Registers*>(RFSYS_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< Low lower byte
        constexpr uint32_t LH = (8 << 8);  ///< Low higher byte
        constexpr uint32_t HL = (8 << 16);  ///< High lower byte
        constexpr uint32_t HH = (8 << 24);  ///< High higher byte
    }

}

// ============================================================================
// TSI0 Peripheral
// ============================================================================

namespace tsi0 {
    /// Base addresses
    constexpr uint32_t TSI0_BASE = 0x40045000;

    /// TSI0 Register structure
    struct Registers {
        volatile uint32_t GENCS;  ///< Offset: 0x00 - TSI General Control and Status Register
        volatile uint32_t DATA;  ///< Offset: 0x04 - TSI DATA Register
        volatile uint32_t TSHD;  ///< Offset: 0x08 - TSI Threshold Register
    };

    /// Peripheral instances
    inline Registers* TSI0 = reinterpret_cast<Registers*>(TSI0_BASE);

    // Bit definitions
    /// GENCS Register bits
    namespace gencs_bits {
        constexpr uint32_t CURSW = (1U << 1);  ///< CURSW
        constexpr uint32_t EOSF = (1U << 2);  ///< End of Scan Flag
        constexpr uint32_t SCNIP = (1U << 3);  ///< Scan In Progress Status
        constexpr uint32_t STM = (1U << 4);  ///< Scan Trigger Mode
        constexpr uint32_t STPE = (1U << 5);  ///< TSI STOP Enable
        constexpr uint32_t TSIIEN = (1U << 6);  ///< Touch Sensing Input Interrupt Enable
        constexpr uint32_t TSIEN = (1U << 7);  ///< Touch Sensing Input Module Enable
        constexpr uint32_t NSCN = (5 << 8);  ///< NSCN
        constexpr uint32_t PS = (3 << 13);  ///< PS
        constexpr uint32_t EXTCHRG = (3 << 16);  ///< EXTCHRG
        constexpr uint32_t DVOLT = (2 << 19);  ///< DVOLT
        constexpr uint32_t REFCHRG = (3 << 21);  ///< REFCHRG
        constexpr uint32_t MODE = (4 << 24);  ///< TSI analog modes setup and status bits.
        constexpr uint32_t ESOR = (1U << 28);  ///< End-of-scan or Out-of-Range Interrupt Selection
        constexpr uint32_t OUTRGF = (1U << 31);  ///< Out of Range Flag.
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t TSICNT = (16 << 0);  ///< TSI Conversion Counter Value
        constexpr uint32_t SWTS = (1U << 22);  ///< Software Trigger Start
        constexpr uint32_t DMAEN = (1U << 23);  ///< DMA Transfer Enabled
        constexpr uint32_t TSICH = (4 << 28);  ///< TSICH
    }

    /// TSHD Register bits
    namespace tshd_bits {
        constexpr uint32_t THRESL = (16 << 0);  ///< TSI Wakeup Channel Low-threshold
        constexpr uint32_t THRESH = (16 << 16);  ///< TSI Wakeup Channel High-threshold
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40047000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT1;  ///< Offset: 0x00 - System Options Register 1
        volatile uint32_t SOPT2;  ///< Offset: 0x1004 - System Options Register 2
        volatile uint32_t SOPT4;  ///< Offset: 0x100C - System Options Register 4
        volatile uint32_t SOPT5;  ///< Offset: 0x1010 - System Options Register 5
        volatile uint32_t SOPT7;  ///< Offset: 0x1018 - System Options Register 7
        volatile uint32_t SDID;  ///< Offset: 0x1024 - System Device Identification Register
        volatile uint32_t SCGC4;  ///< Offset: 0x1034 - System Clock Gating Control Register 4
        volatile uint32_t SCGC5;  ///< Offset: 0x1038 - System Clock Gating Control Register 5
        volatile uint32_t SCGC6;  ///< Offset: 0x103C - System Clock Gating Control Register 6
        volatile uint32_t SCGC7;  ///< Offset: 0x1040 - System Clock Gating Control Register 7
        volatile uint32_t CLKDIV1;  ///< Offset: 0x1044 - System Clock Divider Register 1
        volatile uint32_t FCFG1;  ///< Offset: 0x104C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x1050 - Flash Configuration Register 2
        volatile uint32_t UIDMH;  ///< Offset: 0x1058 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x105C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x1060 - Unique Identification Register Low
        volatile uint32_t COPC;  ///< Offset: 0x1100 - COP Control Register
        volatile uint32_t SRVCOP;  ///< Offset: 0x1104 - Service COP
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t OSC32KOUT = (2 << 16);  ///< 32K oscillator clock output
        constexpr uint32_t OSC32KSEL = (2 << 18);  ///< 32K Oscillator Clock Select
    }

    /// SOPT2 Register bits
    namespace sopt2_bits {
        constexpr uint32_t CLKOUTSEL = (3 << 5);  ///< CLKOUT select
        constexpr uint32_t TPMSRC = (2 << 24);  ///< TPM Clock Source Select
        constexpr uint32_t LPUART0SRC = (2 << 26);  ///< LPUART0 Clock Source Select
    }

    /// SOPT4 Register bits
    namespace sopt4_bits {
        constexpr uint32_t TPM1CH0SRC = (1U << 18);  ///< TPM1 Channel 0 Input Capture Source Select
        constexpr uint32_t TPM2CH0SRC = (1U << 20);  ///< TPM2 Channel 0 Input Capture Source Select
        constexpr uint32_t TPM0CLKSEL = (1U << 24);  ///< TPM0 External Clock Pin Select
        constexpr uint32_t TPM1CLKSEL = (1U << 25);  ///< TPM1 External Clock Pin Select
        constexpr uint32_t TPM2CLKSEL = (1U << 26);  ///< TPM2 External Clock Pin Select
    }

    /// SOPT5 Register bits
    namespace sopt5_bits {
        constexpr uint32_t LPUART0TXSRC = (2 << 0);  ///< LPUART0 Transmit Data Source Select
        constexpr uint32_t LPUART0RXSRC = (1U << 2);  ///< LPUART0 Receive Data Source Select
        constexpr uint32_t LPUART0ODE = (1U << 16);  ///< LPUART0 Open Drain Enable
    }

    /// SOPT7 Register bits
    namespace sopt7_bits {
        constexpr uint32_t ADC0TRGSEL = (4 << 0);  ///< ADC0 Trigger Select
        constexpr uint32_t ADC0PRETRGSEL = (1U << 4);  ///< ADC0 Pretrigger Select
        constexpr uint32_t ADC0ALTTRGEN = (1U << 7);  ///< ADC0 Alternate Trigger Enable
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (4 << 0);  ///< Pin count Identification
        constexpr uint32_t DIEID = (5 << 7);  ///< Device Die Number
        constexpr uint32_t REVID = (4 << 12);  ///< Device Revision Number
        constexpr uint32_t SRAMSIZE = (4 << 16);  ///< System SRAM Size
        constexpr uint32_t SERIESID = (4 << 20);  ///< Kinetis Series ID
        constexpr uint32_t SUBFAMID = (2 << 24);  ///< Kinetis Sub-Family ID.
        constexpr uint32_t FAMID = (4 << 28);  ///< Kinetis family ID
    }

    /// SCGC4 Register bits
    namespace scgc4_bits {
        constexpr uint32_t CMT = (1U << 2);  ///< CMT Clock Gate Control
        constexpr uint32_t I2C0 = (1U << 6);  ///< I2C0 Clock Gate Control
        constexpr uint32_t I2C1 = (1U << 7);  ///< I2C1 Clock Gate Control
        constexpr uint32_t CMP = (1U << 19);  ///< Comparator Clock Gate Control
        constexpr uint32_t VREF = (1U << 20);  ///< VREF Clock Gate Control
    }

    /// SCGC5 Register bits
    namespace scgc5_bits {
        constexpr uint32_t LPTMR = (1U << 0);  ///< Low Power Timer Access Control
        constexpr uint32_t TSI = (1U << 5);  ///< TSI Access Control
        constexpr uint32_t PORTA = (1U << 9);  ///< Port A Clock Gate Control
        constexpr uint32_t PORTB = (1U << 10);  ///< Port B Clock Gate Control
        constexpr uint32_t PORTC = (1U << 11);  ///< Port C Clock Gate Control
        constexpr uint32_t LPUART0 = (1U << 20);  ///< LPUART0 Clock Gate Control
        constexpr uint32_t LTC = (1U << 24);  ///< LTC Clock Gate Control
        constexpr uint32_t RSIM = (1U << 25);  ///< RSIM Clock Gate Control
        constexpr uint32_t DCDC = (1U << 26);  ///< DCDC Clock Gate Control
        constexpr uint32_t BTLL = (1U << 27);  ///< BTLL System Clock Gate Control
        constexpr uint32_t PHYDIG = (1U << 28);  ///< PHY Digital Clock Gate Control
        constexpr uint32_t ZigBee = (1U << 29);  ///< ZigBee Clock Gate Control
        constexpr uint32_t ANT = (1U << 30);  ///< ANT Clock Gate Control
        constexpr uint32_t GEN_FSK = (1U << 31);  ///< Generic FSK enabled
    }

    /// SCGC6 Register bits
    namespace scgc6_bits {
        constexpr uint32_t FTF = (1U << 0);  ///< Flash Memory Clock Gate Control
        constexpr uint32_t DMAMUX = (1U << 1);  ///< DMA Mux Clock Gate Control
        constexpr uint32_t TRNG = (1U << 9);  ///< TRNG Clock Gate Control
        constexpr uint32_t SPI0 = (1U << 12);  ///< SPI0 Clock Gate Control
        constexpr uint32_t SPI1 = (1U << 13);  ///< SPI1 Clock Gate Control
        constexpr uint32_t PIT = (1U << 23);  ///< PIT Clock Gate Control
        constexpr uint32_t TPM0 = (1U << 24);  ///< TPM0 Clock Gate Control
        constexpr uint32_t TPM1 = (1U << 25);  ///< TPM1 Clock Gate Control
        constexpr uint32_t TPM2 = (1U << 26);  ///< TPM2 Clock Gate Control
        constexpr uint32_t ADC0 = (1U << 27);  ///< ADC0 Clock Gate Control
        constexpr uint32_t RTC = (1U << 29);  ///< RTC Access Control
        constexpr uint32_t DAC0 = (1U << 31);  ///< DAC0 Clock Gate Control
    }

    /// SCGC7 Register bits
    namespace scgc7_bits {
        constexpr uint32_t DMA = (1U << 8);  ///< DMA Clock Gate Control
    }

    /// CLKDIV1 Register bits
    namespace clkdiv1_bits {
        constexpr uint32_t OUTDIV4 = (3 << 16);  ///< Clock 4 Output Divider value
        constexpr uint32_t OUTDIV1 = (4 << 28);  ///< Clock 1 Output Divider value
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FLASHDIS = (1U << 0);  ///< Flash Disable
        constexpr uint32_t FLASHDOZE = (1U << 1);  ///< Flash Doze
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program Flash Size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR1 = (7 << 16);  ///< This field concatenated with leading zeros plus the value of the MAXADDR1 field indicates the first invalid address of the second program flash block (flash block 1)
        constexpr uint32_t MAXADDR0 = (7 << 24);  ///< Max Address lock
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID = (16 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// COPC Register bits
    namespace copc_bits {
        constexpr uint32_t COPW = (1U << 0);  ///< COP Windowed Mode
        constexpr uint32_t COPCLKS = (1U << 1);  ///< COP Clock Select
        constexpr uint32_t COPT = (2 << 2);  ///< COP Watchdog Timeout
        constexpr uint32_t COPSTPEN = (1U << 4);  ///< COP Stop Enable
        constexpr uint32_t COPDBGEN = (1U << 5);  ///< COP Debug Enable
        constexpr uint32_t COPCLKSEL = (2 << 6);  ///< COP Clock Select
    }

    /// SRVCOP Register bits
    namespace srvcop_bits {
        constexpr uint32_t SRVCOP = (8 << 0);  ///< Service COP Register
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40049000;
    constexpr uint32_t PORTB_BASE = 0x4004A000;
    constexpr uint32_t PORTC_BASE = 0x4004B000;
    constexpr uint32_t GPIOA_BASE = 0x400FF000;
    constexpr uint32_t GPIOB_BASE = 0x400FF040;
    constexpr uint32_t GPIOC_BASE = 0x400FF080;
    constexpr uint32_t FGPIOA_BASE = 0xF8000000;
    constexpr uint32_t FGPIOB_BASE = 0xF8000040;
    constexpr uint32_t FGPIOC_BASE = 0xF8000080;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR0;  ///< Offset: 0x00 - Pin Control Register n
        volatile uint32_t PCR1;  ///< Offset: 0x04 - Pin Control Register n
        volatile uint32_t PCR2;  ///< Offset: 0x08 - Pin Control Register n
        volatile uint32_t PCR3;  ///< Offset: 0x0C - Pin Control Register n
        volatile uint32_t PCR4;  ///< Offset: 0x10 - Pin Control Register n
        volatile uint32_t PCR5;  ///< Offset: 0x14 - Pin Control Register n
        volatile uint32_t PCR6;  ///< Offset: 0x18 - Pin Control Register n
        volatile uint32_t PCR7;  ///< Offset: 0x1C - Pin Control Register n
        volatile uint32_t PCR8;  ///< Offset: 0x20 - Pin Control Register n
        volatile uint32_t PCR9;  ///< Offset: 0x24 - Pin Control Register n
        volatile uint32_t PCR10;  ///< Offset: 0x28 - Pin Control Register n
        volatile uint32_t PCR11;  ///< Offset: 0x2C - Pin Control Register n
        volatile uint32_t PCR12;  ///< Offset: 0x30 - Pin Control Register n
        volatile uint32_t PCR13;  ///< Offset: 0x34 - Pin Control Register n
        volatile uint32_t PCR14;  ///< Offset: 0x38 - Pin Control Register n
        volatile uint32_t PCR15;  ///< Offset: 0x3C - Pin Control Register n
        volatile uint32_t PCR16;  ///< Offset: 0x40 - Pin Control Register n
        volatile uint32_t PCR17;  ///< Offset: 0x44 - Pin Control Register n
        volatile uint32_t PCR18;  ///< Offset: 0x48 - Pin Control Register n
        volatile uint32_t PCR19;  ///< Offset: 0x4C - Pin Control Register n
        volatile uint32_t PCR20;  ///< Offset: 0x50 - Pin Control Register n
        volatile uint32_t PCR21;  ///< Offset: 0x54 - Pin Control Register n
        volatile uint32_t PCR22;  ///< Offset: 0x58 - Pin Control Register n
        volatile uint32_t PCR23;  ///< Offset: 0x5C - Pin Control Register n
        volatile uint32_t PCR24;  ///< Offset: 0x60 - Pin Control Register n
        volatile uint32_t PCR25;  ///< Offset: 0x64 - Pin Control Register n
        volatile uint32_t PCR26;  ///< Offset: 0x68 - Pin Control Register n
        volatile uint32_t PCR27;  ///< Offset: 0x6C - Pin Control Register n
        volatile uint32_t PCR28;  ///< Offset: 0x70 - Pin Control Register n
        volatile uint32_t PCR29;  ///< Offset: 0x74 - Pin Control Register n
        volatile uint32_t PCR30;  ///< Offset: 0x78 - Pin Control Register n
        volatile uint32_t PCR31;  ///< Offset: 0x7C - Pin Control Register n
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* FGPIOA = reinterpret_cast<Registers*>(FGPIOA_BASE);
    inline Registers* FGPIOB = reinterpret_cast<Registers*>(FGPIOB_BASE);
    inline Registers* FGPIOC = reinterpret_cast<Registers*>(FGPIOC_BASE);

    // Bit definitions
    /// PCR0 Register bits
    namespace pcr0_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR1 Register bits
    namespace pcr1_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR2 Register bits
    namespace pcr2_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR3 Register bits
    namespace pcr3_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR4 Register bits
    namespace pcr4_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR5 Register bits
    namespace pcr5_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR6 Register bits
    namespace pcr6_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR7 Register bits
    namespace pcr7_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR8 Register bits
    namespace pcr8_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR9 Register bits
    namespace pcr9_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR10 Register bits
    namespace pcr10_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR11 Register bits
    namespace pcr11_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR12 Register bits
    namespace pcr12_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR13 Register bits
    namespace pcr13_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR14 Register bits
    namespace pcr14_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR15 Register bits
    namespace pcr15_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR16 Register bits
    namespace pcr16_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR17 Register bits
    namespace pcr17_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR18 Register bits
    namespace pcr18_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR19 Register bits
    namespace pcr19_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR20 Register bits
    namespace pcr20_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR21 Register bits
    namespace pcr21_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR22 Register bits
    namespace pcr22_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR23 Register bits
    namespace pcr23_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR24 Register bits
    namespace pcr24_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR25 Register bits
    namespace pcr25_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR26 Register bits
    namespace pcr26_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR27 Register bits
    namespace pcr27_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR28 Register bits
    namespace pcr28_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR29 Register bits
    namespace pcr29_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR30 Register bits
    namespace pcr30_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR31 Register bits
    namespace pcr31_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART0_BASE = 0x40054000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BAUD;  ///< Offset: 0x00 - LPUART Baud Rate Register
        volatile uint32_t STAT;  ///< Offset: 0x04 - LPUART Status Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - LPUART Control Register
        volatile uint32_t DATA;  ///< Offset: 0x0C - LPUART Data Register
        volatile uint32_t MATCH;  ///< Offset: 0x10 - LPUART Match Address Register
        volatile uint32_t MODIR;  ///< Offset: 0x14 - LPUART Modem IrDA Register
    };

    /// Peripheral instances
    inline Registers* LPUART0 = reinterpret_cast<Registers*>(LPUART0_BASE);

    // Bit definitions
    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t SBR = (13 << 0);  ///< Baud Rate Modulo Divisor.
        constexpr uint32_t SBNS = (1U << 13);  ///< Stop Bit Number Select
        constexpr uint32_t RXEDGIE = (1U << 14);  ///< RX Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 15);  ///< LIN Break Detect Interrupt Enable
        constexpr uint32_t RESYNCDIS = (1U << 16);  ///< Resynchronization Disable
        constexpr uint32_t BOTHEDGE = (1U << 17);  ///< Both Edge Sampling
        constexpr uint32_t MATCFG = (2 << 18);  ///< Match Configuration
        constexpr uint32_t RDMAE = (1U << 21);  ///< Receiver Full DMA Enable
        constexpr uint32_t TDMAE = (1U << 23);  ///< Transmitter DMA Enable
        constexpr uint32_t OSR = (5 << 24);  ///< Oversampling Ratio
        constexpr uint32_t M10 = (1U << 29);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 30);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 31);  ///< Match Address Mode Enable 1
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t MA2F = (1U << 14);  ///< Match 2 Flag
        constexpr uint32_t MA1F = (1U << 15);  ///< Match 1 Flag
        constexpr uint32_t PF = (1U << 16);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 17);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 18);  ///< Noise Flag
        constexpr uint32_t OR_ = (1U << 19);  ///< Receiver Overrun Flag (renamed from OR_)
        constexpr uint32_t IDLE = (1U << 20);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 21);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 22);  ///< Transmission Complete Flag
        constexpr uint32_t TDRE = (1U << 23);  ///< Transmit Data Register Empty Flag
        constexpr uint32_t RAF = (1U << 24);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 25);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 26);  ///< Break Character Generation Length
        constexpr uint32_t RWUID = (1U << 27);  ///< Receive Wake Up Idle Detect
        constexpr uint32_t RXINV = (1U << 28);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 29);  ///< MSB First
        constexpr uint32_t RXEDGIF = (1U << 30);  ///< LPUART_RX Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 31);  ///< LIN Break Detect Interrupt Flag
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-Bit or 8-Bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t DOZEEN = (1U << 6);  ///< Doze Enable
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
        constexpr uint32_t IDLECFG = (3 << 8);  ///< Idle Configuration
        constexpr uint32_t MA2IE = (1U << 14);  ///< Match 2 Interrupt Enable
        constexpr uint32_t MA1IE = (1U << 15);  ///< Match 1 Interrupt Enable
        constexpr uint32_t SBK = (1U << 16);  ///< Send Break
        constexpr uint32_t RWU = (1U << 17);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 18);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 19);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 20);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 21);  ///< Receiver Interrupt Enable
        constexpr uint32_t TCIE = (1U << 22);  ///< Transmission Complete Interrupt Enable for
        constexpr uint32_t TIE = (1U << 23);  ///< Transmit Interrupt Enable
        constexpr uint32_t PEIE = (1U << 24);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 25);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 26);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 27);  ///< Overrun Interrupt Enable
        constexpr uint32_t TXINV = (1U << 28);  ///< Transmit Data Inversion
        constexpr uint32_t TXDIR = (1U << 29);  ///< LPUART_TX Pin Direction in Single-Wire Mode
        constexpr uint32_t R9T8 = (1U << 30);  ///< Receive Bit 9 / Transmit Bit 8
        constexpr uint32_t R8T9 = (1U << 31);  ///< Receive Bit 8 / Transmit Bit 9
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t R0T0 = (1U << 0);  ///< Read receive data buffer 0 or write transmit data buffer 0.
        constexpr uint32_t R1T1 = (1U << 1);  ///< Read receive data buffer 1 or write transmit data buffer 1.
        constexpr uint32_t R2T2 = (1U << 2);  ///< Read receive data buffer 2 or write transmit data buffer 2.
        constexpr uint32_t R3T3 = (1U << 3);  ///< Read receive data buffer 3 or write transmit data buffer 3.
        constexpr uint32_t R4T4 = (1U << 4);  ///< Read receive data buffer 4 or write transmit data buffer 4.
        constexpr uint32_t R5T5 = (1U << 5);  ///< Read receive data buffer 5 or write transmit data buffer 5.
        constexpr uint32_t R6T6 = (1U << 6);  ///< Read receive data buffer 6 or write transmit data buffer 6.
        constexpr uint32_t R7T7 = (1U << 7);  ///< Read receive data buffer 7 or write transmit data buffer 7.
        constexpr uint32_t R8T8 = (1U << 8);  ///< Read receive data buffer 8 or write transmit data buffer 8.
        constexpr uint32_t R9T9 = (1U << 9);  ///< Read receive data buffer 9 or write transmit data buffer 9.
        constexpr uint32_t IDLINE = (1U << 11);  ///< Idle Line
        constexpr uint32_t RXEMPT = (1U << 12);  ///< Receive Buffer Empty
        constexpr uint32_t FRETSC = (1U << 13);  ///< Frame Error / Transmit Special Character
        constexpr uint32_t PARITYE = (1U << 14);  ///< The current received dataword contained in DATA[R9:R0] was received with a parity error.
        constexpr uint32_t NOISY = (1U << 15);  ///< The current received dataword contained in DATA[R9:R0] was received with noise.
    }

    /// MATCH Register bits
    namespace match_bits {
        constexpr uint32_t MA1 = (10 << 0);  ///< Match Address 1
        constexpr uint32_t MA2 = (10 << 16);  ///< Match Address 2
    }

    /// MODIR Register bits
    namespace modir_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
        constexpr uint32_t TXCTSC = (1U << 4);  ///< Transmit CTS Configuration
        constexpr uint32_t TXCTSSRC = (1U << 5);  ///< Transmit CTS Source
        constexpr uint32_t TNP = (2 << 16);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 18);  ///< Infrared enable
    }

}

// ============================================================================
// LTC0 Peripheral
// ============================================================================

namespace ltc0 {
    /// Base addresses
    constexpr uint32_t LTC0_BASE = 0x40058000;

    /// LTC0 Register structure
    struct Registers {
        volatile uint32_t MD;  ///< Offset: 0x00 - Mode Register
        volatile uint32_t KS;  ///< Offset: 0x08 - Key Size Register
        volatile uint32_t DS;  ///< Offset: 0x10 - Data Size Register
        volatile uint32_t ICVS;  ///< Offset: 0x18 - ICV Size Register
        volatile uint32_t COM;  ///< Offset: 0x30 - Command Register
        volatile uint32_t CTL;  ///< Offset: 0x34 - Control Register
        volatile uint32_t CW;  ///< Offset: 0x40 - Clear Written Register
        volatile uint32_t STA;  ///< Offset: 0x48 - Status Register
        volatile uint32_t ESTA;  ///< Offset: 0x4C - Error Status Register
        volatile uint32_t AADSZ;  ///< Offset: 0x58 - AAD Size Register
        volatile uint32_t CTX_0;  ///< Offset: 0x100 - Context Register
        volatile uint32_t CTX_1;  ///< Offset: 0x104 - Context Register
        volatile uint32_t CTX_2;  ///< Offset: 0x108 - Context Register
        volatile uint32_t CTX_3;  ///< Offset: 0x10C - Context Register
        volatile uint32_t CTX_4;  ///< Offset: 0x110 - Context Register
        volatile uint32_t CTX_5;  ///< Offset: 0x114 - Context Register
        volatile uint32_t CTX_6;  ///< Offset: 0x118 - Context Register
        volatile uint32_t CTX_7;  ///< Offset: 0x11C - Context Register
        volatile uint32_t CTX_8;  ///< Offset: 0x120 - Context Register
        volatile uint32_t CTX_9;  ///< Offset: 0x124 - Context Register
        volatile uint32_t CTX_10;  ///< Offset: 0x128 - Context Register
        volatile uint32_t CTX_11;  ///< Offset: 0x12C - Context Register
        volatile uint32_t CTX_12;  ///< Offset: 0x130 - Context Register
        volatile uint32_t CTX_13;  ///< Offset: 0x134 - Context Register
        volatile uint32_t KEY_0;  ///< Offset: 0x200 - Key Registers
        volatile uint32_t KEY_1;  ///< Offset: 0x204 - Key Registers
        volatile uint32_t KEY_2;  ///< Offset: 0x208 - Key Registers
        volatile uint32_t KEY_3;  ///< Offset: 0x20C - Key Registers
        volatile uint32_t VID1;  ///< Offset: 0x4F0 - Version ID Register
        volatile uint32_t VID2;  ///< Offset: 0x4F4 - Version ID 2 Register
        volatile uint32_t CHAVID;  ///< Offset: 0x4F8 - CHA Version ID Register
        volatile uint32_t FIFOSTA;  ///< Offset: 0x7C0 - FIFO Status Register
        volatile uint32_t IFIFO;  ///< Offset: 0x7E0 - Input Data FIFO
        volatile uint32_t OFIFO;  ///< Offset: 0x7F0 - Output Data FIFO
    };

    /// Peripheral instances
    inline Registers* LTC0 = reinterpret_cast<Registers*>(LTC0_BASE);

    // Bit definitions
    /// MD Register bits
    namespace md_bits {
        constexpr uint32_t ENC = (1U << 0);  ///< Encrypt/Decrypt.
        constexpr uint32_t ICV_TEST = (1U << 1);  ///< ICV Checking / Test AES fault detection.
        constexpr uint32_t AS = (2 << 2);  ///< Algorithm State
        constexpr uint32_t AAI = (9 << 4);  ///< Additional Algorithm information
        constexpr uint32_t ALG = (8 << 16);  ///< Algorithm
    }

    /// KS Register bits
    namespace ks_bits {
        constexpr uint32_t KS = (5 << 0);  ///< Key Size
    }

    /// DS Register bits
    namespace ds_bits {
        constexpr uint32_t DS = (12 << 0);  ///< Data Size
    }

    /// ICVS Register bits
    namespace icvs_bits {
        constexpr uint32_t ICVS = (5 << 0);  ///< ICV Size, in Bytes
    }

    /// COM Register bits
    namespace com_bits {
        constexpr uint32_t ALL = (1U << 0);  ///< Reset All Internal Logic
        constexpr uint32_t AES = (1U << 1);  ///< Reset AESA
    }

    /// CTL Register bits
    namespace ctl_bits {
        constexpr uint32_t IM = (1U << 0);  ///< Interrupt Mask
        constexpr uint32_t IFE = (1U << 8);  ///< Input FIFO DMA Enable
        constexpr uint32_t IFR = (1U << 9);  ///< Input FIFO DMA Request Size
        constexpr uint32_t OFE = (1U << 12);  ///< Output FIFO DMA Enable
        constexpr uint32_t OFR = (1U << 13);  ///< Output FIFO DMA Request Size
        constexpr uint32_t IFS = (1U << 16);  ///< Input FIFO Byte Swap
        constexpr uint32_t OFS = (1U << 17);  ///< Output FIFO Byte Swap
        constexpr uint32_t KIS = (1U << 20);  ///< Key Register Input Byte Swap
        constexpr uint32_t KOS = (1U << 21);  ///< Key Register Output Byte Swap
        constexpr uint32_t CIS = (1U << 22);  ///< Context Register Input Byte Swap
        constexpr uint32_t COS = (1U << 23);  ///< Context Register Output Byte Swap
        constexpr uint32_t KAL = (1U << 31);  ///< Key Register Access Lock
    }

    /// CW Register bits
    namespace cw_bits {
        constexpr uint32_t CM = (1U << 0);  ///< Clear the Mode Register
        constexpr uint32_t CDS = (1U << 2);  ///< Clear the Data Size Register
        constexpr uint32_t CICV = (1U << 3);  ///< Clear the ICV Size Register
        constexpr uint32_t CCR = (1U << 5);  ///< Clear the Context Register
        constexpr uint32_t CKR = (1U << 6);  ///< Clear the Key Register
        constexpr uint32_t COF = (1U << 30);  ///< Clear Output FIFO
        constexpr uint32_t CIF = (1U << 31);  ///< Clear Input FIFO
    }

    /// STA Register bits
    namespace sta_bits {
        constexpr uint32_t AB = (1U << 1);  ///< AESA Busy
        constexpr uint32_t DI = (1U << 16);  ///< Done Interrupt
        constexpr uint32_t EI = (1U << 20);  ///< Error Interrupt
    }

    /// ESTA Register bits
    namespace esta_bits {
        constexpr uint32_t ERRID1 = (4 << 0);  ///< Error ID 1
        constexpr uint32_t CL1 = (4 << 8);  ///< algorithms
    }

    /// AADSZ Register bits
    namespace aadsz_bits {
        constexpr uint32_t AADSZ = (4 << 0);  ///< AAD size in Bytes, mod 16
        constexpr uint32_t AL = (1U << 31);  ///< AAD Last
    }

    /// CTX_0 Register bits
    namespace ctx_0_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// CTX_1 Register bits
    namespace ctx_1_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// CTX_2 Register bits
    namespace ctx_2_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// CTX_3 Register bits
    namespace ctx_3_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// CTX_4 Register bits
    namespace ctx_4_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// CTX_5 Register bits
    namespace ctx_5_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// CTX_6 Register bits
    namespace ctx_6_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// CTX_7 Register bits
    namespace ctx_7_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// CTX_8 Register bits
    namespace ctx_8_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// CTX_9 Register bits
    namespace ctx_9_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// CTX_10 Register bits
    namespace ctx_10_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// CTX_11 Register bits
    namespace ctx_11_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// CTX_12 Register bits
    namespace ctx_12_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// CTX_13 Register bits
    namespace ctx_13_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// KEY_0 Register bits
    namespace key_0_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// KEY_1 Register bits
    namespace key_1_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// KEY_2 Register bits
    namespace key_2_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// KEY_3 Register bits
    namespace key_3_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// VID1 Register bits
    namespace vid1_bits {
        constexpr uint32_t MIN_REV = (8 << 0);  ///< Minor revision number.
        constexpr uint32_t MAJ_REV = (8 << 8);  ///< Major revision number.
        constexpr uint32_t IP_ID = (16 << 16);  ///< ID(0x0034).
    }

    /// VID2 Register bits
    namespace vid2_bits {
        constexpr uint32_t ECO_REV = (8 << 0);  ///< ECO revision number.
        constexpr uint32_t ARCH_ERA = (8 << 8);  ///< Architectural ERA.
    }

    /// CHAVID Register bits
    namespace chavid_bits {
        constexpr uint32_t AESREV = (4 << 0);  ///< AES Revision Number
        constexpr uint32_t AESVID = (4 << 4);  ///< AES Version ID
    }

    /// FIFOSTA Register bits
    namespace fifosta_bits {
        constexpr uint32_t IFL = (7 << 0);  ///< Input FIFO Level
        constexpr uint32_t IFF = (1U << 15);  ///< Input FIFO Full
        constexpr uint32_t OFL = (7 << 16);  ///< Output FIFO Level
        constexpr uint32_t OFF = (1U << 31);  ///< Output FIFO Full
    }

    /// IFIFO Register bits
    namespace ififo_bits {
        constexpr uint32_t IFIFO = (32 << 0);  ///< IFIFO
    }

    /// OFIFO Register bits
    namespace ofifo_bits {
        constexpr uint32_t OFIFO = (32 << 0);  ///< Output FIFO
    }

}

// ============================================================================
// RSIM Peripheral
// ============================================================================

namespace rsim {
    /// Base addresses
    constexpr uint32_t RSIM_REGS_BASE = 0x40059000;

    /// RSIM Register structure
    struct Registers {
        volatile uint32_t CONTROL;  ///< Offset: 0x00 - Radio System Control
        volatile uint32_t ACTIVE_DELAY;  ///< Offset: 0x04 - Radio Active Early Warning
        volatile uint32_t MAC_MSB;  ///< Offset: 0x08 - Radio MAC Address
        volatile uint32_t MAC_LSB;  ///< Offset: 0x0C - Radio MAC Address
        volatile uint32_t MISC;  ///< Offset: 0x10 - Radio Miscellaneous
        volatile uint32_t DSM_TIMER;  ///< Offset: 0x100 - Deep Sleep Timer
        volatile uint32_t DSM_CONTROL;  ///< Offset: 0x104 - Deep Sleep Timer Control
        volatile uint32_t DSM_OSC_OFFSET;  ///< Offset: 0x108 - Deep Sleep Wakeup Time Offset
        volatile uint32_t ANT_SLEEP;  ///< Offset: 0x10C - ANT Link Layer Sleep Time
        volatile uint32_t ANT_WAKE;  ///< Offset: 0x110 - ANT Link Layer Wake Time
        volatile uint32_t ZIG_SLEEP;  ///< Offset: 0x114 - 802.15.4 Link Layer Sleep Time
        volatile uint32_t ZIG_WAKE;  ///< Offset: 0x118 - 802.15.4 Link Layer Wake Time
        volatile uint32_t GEN_SLEEP;  ///< Offset: 0x11C - Generic FSK Link Layer Sleep Time
        volatile uint32_t GEN_WAKE;  ///< Offset: 0x120 - Generic FSK Link Layer Wake Time
        volatile uint32_t RF_OSC_CTRL;  ///< Offset: 0x124 - Radio Oscillator Control
        volatile uint32_t ANA_TEST;  ///< Offset: 0x128 - Radio Analog Test Registers
        volatile uint32_t ANA_TRIM;  ///< Offset: 0x12C - Radio Analog Trim Registers
    };

    /// Peripheral instances
    inline Registers* RSIM_REGS = reinterpret_cast<Registers*>(RSIM_REGS_BASE);

    // Bit definitions
    /// CONTROL Register bits
    namespace control_bits {
        constexpr uint32_t BLE_RF_OSC_REQ_EN = (1U << 0);  ///< BLE Ref Osc (Sysclk) Request Enable
        constexpr uint32_t BLE_RF_OSC_REQ_STAT = (1U << 1);  ///< BLE Ref Osc (Sysclk) Request Status
        constexpr uint32_t BLE_RF_OSC_REQ_INT_EN = (1U << 4);  ///< BLE Ref Osc (Sysclk) Request Interrupt Enable
        constexpr uint32_t BLE_RF_OSC_REQ_INT = (1U << 5);  ///< BLE Ref Osc (Sysclk) Request Interrupt Flag
        constexpr uint32_t RF_OSC_EN = (4 << 8);  ///< RF Ref Osc Enable Select
        constexpr uint32_t RADIO_GASKET_BYPASS_OVRD_EN = (1U << 12);  ///< Radio Gasket Bypass Override Enable
        constexpr uint32_t RADIO_GASKET_BYPASS_OVRD = (1U << 13);  ///< Radio Gasket Bypass Override
        constexpr uint32_t IPP_OBE_3V_BLE_ACTIVE_1 = (1U << 16);  ///< IPP_OBE_3V_BLE_ACTIVE_1
        constexpr uint32_t IPP_OBE_3V_BLE_ACTIVE_2 = (1U << 17);  ///< IPP_OBE_3V_BLE_ACTIVE_2
        constexpr uint32_t RADIO_RAM_ACCESS_OVRD_EN = (1U << 18);  ///< Radio RAM Access Override Enable
        constexpr uint32_t RADIO_RAM_ACCESS_OVRD = (1U << 19);  ///< Radio RAM Access Override
        constexpr uint32_t RSIM_DSM_EXIT = (1U << 20);  ///< BLE Force Deep Sleep Mode Exit
        constexpr uint32_t RSIM_STOP_ACK_OVRD_EN = (1U << 22);  ///< Stop Acknowledge Override Enable
        constexpr uint32_t RSIM_STOP_ACK_OVRD = (1U << 23);  ///< Stop Acknowledge Override
        constexpr uint32_t RF_OSC_READY = (1U << 24);  ///< RF Ref Osc Ready
        constexpr uint32_t RF_OSC_READY_OVRD_EN = (1U << 25);  ///< RF Ref Osc Ready Override Enable
        constexpr uint32_t RF_OSC_READY_OVRD = (1U << 26);  ///< RF Ref Osc Ready Override
        constexpr uint32_t BLOCK_SOC_RESETS = (1U << 28);  ///< Block SoC Resets of the Radio
        constexpr uint32_t BLOCK_RADIO_OUTPUTS = (1U << 29);  ///< Block Radio Outputs
        constexpr uint32_t ALLOW_DFT_RESETS = (1U << 30);  ///< Allow the DFT Reset Pin to Reset the Radio
        constexpr uint32_t RADIO_RESET_BIT = (1U << 31);  ///< Software Reset for the Radio
    }

    /// ACTIVE_DELAY Register bits
    namespace active_delay_bits {
        constexpr uint32_t BLE_FINE_DELAY = (6 << 0);  ///< BLE Active Fine Delay
        constexpr uint32_t BLE_COARSE_DELAY = (4 << 16);  ///< BLE Active Coarse Delay
    }

    /// MAC_MSB Register bits
    namespace mac_msb_bits {
        constexpr uint32_t MAC_ADDR_MSB = (8 << 0);  ///< Radio MAC Address MSB
    }

    /// MAC_LSB Register bits
    namespace mac_lsb_bits {
        constexpr uint32_t MAC_ADDR_LSB = (32 << 0);  ///< Radio MAC Address LSB
    }

    /// MISC Register bits
    namespace misc_bits {
        constexpr uint32_t ANALOG_TEST_EN = (5 << 0);  ///< RSIM Analog Test Mux Enables
        constexpr uint32_t RADIO_VERSION = (8 << 24);  ///< Radio Version ID number
    }

    /// DSM_TIMER Register bits
    namespace dsm_timer_bits {
        constexpr uint32_t DSM_TIMER = (24 << 0);  ///< Deep Sleep Mode Timer
    }

    /// DSM_CONTROL Register bits
    namespace dsm_control_bits {
        constexpr uint32_t DSM_ANT_READY = (1U << 0);  ///< ANT Ready for Deep Sleep Mode
        constexpr uint32_t ANT_DEEP_SLEEP_STATUS = (1U << 1);  ///< ANT Link Layer Deep Sleep Mode Status
        constexpr uint32_t DSM_ANT_FINISHED = (1U << 2);  ///< ANT Deep Sleep Time Finished
        constexpr uint32_t ANT_SYSCLK_REQUEST_EN = (1U << 3);  ///< Enable ANT Link Layer to Request RF OSC
        constexpr uint32_t ANT_SLEEP_REQUEST = (1U << 4);  ///< ANT Link Layer Deep Sleep Requested
        constexpr uint32_t ANT_SYSCLK_REQ = (1U << 5);  ///< ANT Link Layer RF OSC Request Status
        constexpr uint32_t ANT_SYSCLK_INTERRUPT_EN = (1U << 6);  ///< ANT Link Layer RF OSC Request Interrupt Enable
        constexpr uint32_t ANT_SYSCLK_REQ_INT = (1U << 7);  ///< Interrupt Flag from an ANT Link Layer RF OSC Request
        constexpr uint32_t DSM_GEN_READY = (1U << 8);  ///< Generic FSK Ready for Deep Sleep Mode
        constexpr uint32_t GEN_DEEP_SLEEP_STATUS = (1U << 9);  ///< Generic FSK Link Layer Deep Sleep Mode Status
        constexpr uint32_t DSM_GEN_FINISHED = (1U << 10);  ///< Generic FSK Deep Sleep Time Finished
        constexpr uint32_t GEN_SYSCLK_REQUEST_EN = (1U << 11);  ///< Enable Generic FSK Link Layer to Request RF OSC
        constexpr uint32_t GEN_SLEEP_REQUEST = (1U << 12);  ///< Generic FSK Link Layer Deep Sleep Requested
        constexpr uint32_t GEN_SYSCLK_REQ = (1U << 13);  ///< Generic FSK Link Layer RF OSC Request Status
        constexpr uint32_t GEN_SYSCLK_INTERRUPT_EN = (1U << 14);  ///< Generic FSK Link Layer RF OSC Request Interrupt Enable
        constexpr uint32_t GEN_SYSCLK_REQ_INT = (1U << 15);  ///< Interrupt Flag from an Generic FSK Link Layer RF OSC Request
        constexpr uint32_t DSM_ZIG_READY = (1U << 16);  ///< 802.15.4 Ready for Deep Sleep Mode
        constexpr uint32_t ZIG_DEEP_SLEEP_STATUS = (1U << 17);  ///< 802.15.4 Link Layer Deep Sleep Mode Status
        constexpr uint32_t DSM_ZIG_FINISHED = (1U << 18);  ///< 802.15.4 Deep Sleep Time Finished
        constexpr uint32_t ZIG_SYSCLK_REQUEST_EN = (1U << 19);  ///< Enable 802.15.4 Link Layer to Request RF OSC
        constexpr uint32_t ZIG_SLEEP_REQUEST = (1U << 20);  ///< 802.15.4 Link Layer Deep Sleep Requested
        constexpr uint32_t ZIG_SYSCLK_REQ = (1U << 21);  ///< 802.15.4 Link Layer RF OSC Request Status
        constexpr uint32_t ZIG_SYSCLK_INTERRUPT_EN = (1U << 22);  ///< 802.15.4 Link Layer RF OSC Request Interrupt Enable
        constexpr uint32_t ZIG_SYSCLK_REQ_INT = (1U << 23);  ///< Interrupt Flag from an 802.15.4 Link Layer RF OSC Request
        constexpr uint32_t DSM_TIMER_CLR = (1U << 27);  ///< Deep Sleep Mode Timer Clear
        constexpr uint32_t DSM_TIMER_EN = (1U << 31);  ///< Deep Sleep Mode Timer Enable
    }

    /// DSM_OSC_OFFSET Register bits
    namespace dsm_osc_offset_bits {
        constexpr uint32_t DSM_OSC_STABILIZE_TIME = (10 << 0);  ///< Deep Sleep Wakeup RF OSC Stabilize Time
    }

    /// ANT_SLEEP Register bits
    namespace ant_sleep_bits {
        constexpr uint32_t ANT_SLEEP_TIME = (24 << 0);  ///< ANT Link Layer Sleep Time
    }

    /// ANT_WAKE Register bits
    namespace ant_wake_bits {
        constexpr uint32_t ANT_WAKE_TIME = (24 << 0);  ///< ANT Link Layer Wake Time
    }

    /// ZIG_SLEEP Register bits
    namespace zig_sleep_bits {
        constexpr uint32_t ZIG_SLEEP_TIME = (24 << 0);  ///< 802.15.4 Link Layer Sleep Time
    }

    /// ZIG_WAKE Register bits
    namespace zig_wake_bits {
        constexpr uint32_t ZIG_WAKE_TIME = (24 << 0);  ///< 802.15.4 Link Layer Wake Time
    }

    /// GEN_SLEEP Register bits
    namespace gen_sleep_bits {
        constexpr uint32_t GEN_SLEEP_TIME = (24 << 0);  ///< Generic FSK Link Layer Sleep Time
    }

    /// GEN_WAKE Register bits
    namespace gen_wake_bits {
        constexpr uint32_t GEN_WAKE_TIME = (24 << 0);  ///< Generic FSK Link Layer Wake Time
    }

    /// RF_OSC_CTRL Register bits
    namespace rf_osc_ctrl_bits {
        constexpr uint32_t BB_XTAL_ALC_COUNT_SEL = (2 << 0);  ///< rmap_bb_xtal_alc_count_sel_hv[1:0]
        constexpr uint32_t BB_XTAL_ALC_ON = (1U << 2);  ///< rmap_bb_xtal_alc_on_hv
        constexpr uint32_t RF_OSC_BYPASS_EN = (1U << 3);  ///< RF Ref Osc Bypass Enable
        constexpr uint32_t BB_XTAL_COMP_BIAS = (5 << 4);  ///< rmap_bb_xtal_comp_bias_hv[4:0]
        constexpr uint32_t BB_XTAL_DC_COUP_MODE_EN = (1U << 9);  ///< rmap_bb_xtal_dc_coup_mode_en_hv
        constexpr uint32_t BB_XTAL_DIAGSEL = (1U << 10);  ///< rmap_bb_xtal_diagsel_hv
        constexpr uint32_t BB_XTAL_DIG_CLK_ON = (1U << 11);  ///< rmap_bb_xtal_dig_clk_on_hv
        constexpr uint32_t BB_XTAL_GM = (5 << 12);  ///< rmap_bb_xtal_gm_hv[4:0]
        constexpr uint32_t BB_XTAL_ON_OVRD = (1U << 17);  ///< rmap_bb_xtal_on_ovrd_hv
        constexpr uint32_t BB_XTAL_ON_OVRD_ON = (1U << 18);  ///< rmap_bb_xtal_on_ovrd_on_hv
        constexpr uint32_t BB_XTAL_READY_COUNT_SEL = (2 << 20);  ///< rmap_bb_xtal_ready_count_sel_hv[1:0]
        constexpr uint32_t RADIO_EXT_OSC_RF_EN_SEL = (1U << 27);  ///< Radio External Request for RF OSC Select
        constexpr uint32_t RADIO_EXT_OSC_OVRD = (1U << 28);  ///< Radio External Request for RF OSC Override
        constexpr uint32_t RADIO_EXT_OSC_OVRD_EN = (1U << 29);  ///< Radio External Request for RF OSC Override Enable
        constexpr uint32_t RADIO_RF_ABORT_OVRD = (1U << 30);  ///< Radio RF Abort Override
        constexpr uint32_t RADIO_RF_ABORT_OVRD_EN = (1U << 31);  ///< Radio RF Abort Override Enable
    }

    /// ANA_TEST Register bits
    namespace ana_test_bits {
        constexpr uint32_t BB_LDO_LS_BYP = (1U << 0);  ///< rmap_bb_ldo_ls_byp_hv
        constexpr uint32_t BB_LDO_LS_DIAGSEL = (1U << 1);  ///< rmap_bb_ldo_ls_diagsel_hv
        constexpr uint32_t BB_LDO_XO_BYP_ON = (1U << 2);  ///< rmap_bb_ldo_xo_byp_on_hv
        constexpr uint32_t BB_LDO_XO_DIAGSEL = (1U << 3);  ///< rmap_bb_ldo_xo_diagsel_hv
        constexpr uint32_t BB_XTAL_TEST = (1U << 4);  ///< rmap_bb_xtal_test_en_hv
        constexpr uint32_t BG_DIAGBUF = (1U << 5);  ///< rmap_bg_diagbuf_hv
        constexpr uint32_t BG_DIAGSEL = (1U << 6);  ///< rmap_bg_diagsel_hv
        constexpr uint32_t BG_STARTUPFORCE = (1U << 7);  ///< rmap_bg_startupforce_hv
        constexpr uint32_t DIAG_1234_ON = (1U << 8);  ///< rmap_diag_1234_on_hv
        constexpr uint32_t DIAG2SOCADC_DEC = (2 << 9);  ///< rmap_diag2socadc_dec_hv[1:0]
        constexpr uint32_t DIAG2SOCADC_DEC_ON = (1U << 11);  ///< rmap_diag2socadc_dec_on_hv
        constexpr uint32_t DIAGCODE = (3 << 12);  ///< rmap_diagcode_hv[2:0]
    }

    /// ANA_TRIM Register bits
    namespace ana_trim_bits {
        constexpr uint32_t BB_LDO_LS_SPARE = (2 << 0);  ///< rmap_bb_ldo_ls_spare_hv[1:0]
        constexpr uint32_t BB_LDO_LS_TRIM = (3 << 3);  ///< rmap_bb_ldo_ls_trim_hv[2:0]
        constexpr uint32_t BB_LDO_XO_SPARE = (2 << 6);  ///< rmap_bb_ldo_xo_spare_hv[1:0]
        constexpr uint32_t BB_LDO_XO_TRIM = (3 << 8);  ///< rmap_bb_ldo_xo_trim_hv[2:0]
        constexpr uint32_t BB_XTAL_SPARE = (5 << 11);  ///< rmap_bb_xtal_spare_hv[4:0]
        constexpr uint32_t BB_XTAL_TRIM = (8 << 16);  ///< rmap_bb_xtal_trim_hv[7:0]
        constexpr uint32_t BG_1V_TRIM = (4 << 24);  ///< rmap_bg_1v_trim_hv[3:0]
        constexpr uint32_t BG_IBIAS_5U_TRIM = (4 << 28);  ///< rmap_bg_ibias_5u_trim_hv[3:0]
    }

}

// ============================================================================
// DCDC Peripheral
// ============================================================================

namespace dcdc {
    /// Base addresses
    constexpr uint32_t DCDC_BASE = 0x4005A000;

    /// DCDC Register structure
    struct Registers {
        volatile uint32_t REG0;  ///< Offset: 0x00 - DCDC REGISTER 0
        volatile uint32_t REG1;  ///< Offset: 0x04 - DCDC REGISTER 1
        volatile uint32_t REG2;  ///< Offset: 0x08 - DCDC REGISTER 2
        volatile uint32_t REG3;  ///< Offset: 0x0C - DCDC REGISTER 3
        volatile uint32_t REG4;  ///< Offset: 0x10 - DCDC REGISTER 4
        volatile uint32_t REG6;  ///< Offset: 0x18 - DCDC REGISTER 6
        volatile uint32_t REG7;  ///< Offset: 0x1C - DCDC REGISTER 7
    };

    /// Peripheral instances
    inline Registers* DCDC = reinterpret_cast<Registers*>(DCDC_BASE);

    // Bit definitions
    /// REG0 Register bits
    namespace reg0_bits {
        constexpr uint32_t DCDC_DISABLE_AUTO_CLK_SWITCH = (1U << 1);  ///< Disable automatic clock switch from internal oscillator to external clock.
        constexpr uint32_t DCDC_SEL_CLK = (1U << 2);  ///< Select external clock for DCDC when DCDC_DISABLE_AUTO_CLK_SWITCH is set.
        constexpr uint32_t DCDC_PWD_OSC_INT = (1U << 3);  ///< Power down internal oscillator. Only set this bit when 32M crystal oscillator is available.
        constexpr uint32_t DCDC_LP_DF_CMP_ENABLE = (1U << 9);  ///< Enable low power differential comparators, to sense lower supply in pulsed mode
        constexpr uint32_t DCDC_VBAT_DIV_CTRL = (2 << 10);  ///< Controls VBAT voltage divider
        constexpr uint32_t DCDC_LP_STATE_HYS_L = (2 << 17);  ///< Configure the hysteretic lower threshold value in low power mode
        constexpr uint32_t DCDC_LP_STATE_HYS_H = (2 << 19);  ///< Configure the hysteretic upper threshold value in low power mode
        constexpr uint32_t HYST_LP_COMP_ADJ = (1U << 21);  ///< Adjust hysteretic value in low power comparator.
        constexpr uint32_t HYST_LP_CMP_DISABLE = (1U << 22);  ///< Disable hysteresis in low power comparator.
        constexpr uint32_t OFFSET_RSNS_LP_ADJ = (1U << 23);  ///< Adjust hysteretic value in low power voltage sense.
        constexpr uint32_t OFFSET_RSNS_LP_DISABLE = (1U << 24);  ///< Disable hysteresis in low power voltage sense.
        constexpr uint32_t DCDC_LESS_I = (1U << 25);  ///< Reduce DCDC current. It will save approximately 20 uA in RUN.
        constexpr uint32_t PWD_CMP_OFFSET = (1U << 26);  ///< Power down output range comparator
        constexpr uint32_t DCDC_XTALOK_DISABLE = (1U << 27);  ///< Disable xtalok detection circuit.
        constexpr uint32_t PSWITCH_STATUS = (1U << 28);  ///< Status register to indicate PSWITCH status
        constexpr uint32_t VLPS_CONFIG_DCDC_HP = (1U << 29);  ///< Selects behavior of DCDC in device VLPS low power mode
        constexpr uint32_t VLPR_VLPW_CONFIG_DCDC_HP = (1U << 30);  ///< Selects behavior of DCDC in device VLPR and VLPW low power modes
        constexpr uint32_t DCDC_STS_DC_OK = (1U << 31);  ///< Status register to indicate DCDC lock
    }

    /// REG1 Register bits
    namespace reg1_bits {
        constexpr uint32_t POSLIMIT_BUCK_IN = (7 << 0);  ///< Upper limit duty cycle limit in DC-DC converter
        constexpr uint32_t POSLIMIT_BOOST_IN = (7 << 7);  ///< Upper limit duty cycle limit in DC-DC converter
        constexpr uint32_t DCDC_LOOPCTRL_CM_HST_THRESH = (1U << 21);  ///< Enable hysteresis in switching converter common mode analog comparators
        constexpr uint32_t DCDC_LOOPCTRL_DF_HST_THRESH = (1U << 22);  ///< Enable hysteresis in switching converter differential mode analog comparators
        constexpr uint32_t DCDC_LOOPCTRL_EN_CM_HYST = (1U << 23);  ///< Enable hysteresis in switching converter common mode analog comparators
        constexpr uint32_t DCDC_LOOPCTRL_EN_DF_HYST = (1U << 24);  ///< Enable hysteresis in switching converter differential mode analog comparators
    }

    /// REG2 Register bits
    namespace reg2_bits {
        constexpr uint32_t DCDC_LOOPCTRL_HYST_SIGN = (1U << 13);  ///< Invert the sign of the hysteresis in DC-DC analog comparators. This bit is set when in Pulsed mode.
        constexpr uint32_t DCDC_BATTMONITOR_EN_BATADJ = (1U << 15);  ///< This bit enables the DC-DC to improve efficiency and minimize ripple using the information from the BATT_VAL field
        constexpr uint32_t DCDC_BATTMONITOR_BATT_VAL = (10 << 16);  ///< Software should be configured to place the battery voltage in this register measured with an 8 mV LSB resolution through the ADC
    }

    /// REG3 Register bits
    namespace reg3_bits {
        constexpr uint32_t DCDC_VDD1P8CTRL_TRG = (6 << 0);  ///< Target value of VDD1P8, 25 mV each step in two ranges, from 0x00 to 0x11 and 0x20 to 0x3F.
        constexpr uint32_t DCDC_VDD1P5CTRL_TRG_BUCK = (5 << 6);  ///< Target value of VDD1P5 in buck mode, 25 mV each step from 0x00 to 0x0F
        constexpr uint32_t DCDC_VDD1P5CTRL_TRG_BOOST = (5 << 11);  ///< Target value of VDD1P5 in boost mode, 25 mV each step from 0x00 to 0x0F
        constexpr uint32_t DCDC_VDD1P5CTRL_ADJTN = (4 << 17);  ///< Adjust value of duty cycle when switching between VDD1P5 and VDD1P8. The unit is 1/32 or 3.125%.
        constexpr uint32_t DCDC_MINPWR_DC_HALFCLK_PULSED = (1U << 21);  ///< Set DCDC clock to half frequency for the Pulsed mode.
        constexpr uint32_t DCDC_MINPWR_DOUBLE_FETS_PULSED = (1U << 22);  ///< Use double switch FET for the Pulsed mode.
        constexpr uint32_t DCDC_MINPWR_HALF_FETS_PULSED = (1U << 23);  ///< Use half switch FET for the Pulsed mode.
        constexpr uint32_t DCDC_MINPWR_DC_HALFCLK = (1U << 24);  ///< Set DCDC clock to half frequency for the continuous mode.
        constexpr uint32_t DCDC_MINPWR_DOUBLE_FETS = (1U << 25);  ///< Use double switch FET for the continuous mode.
        constexpr uint32_t DCDC_MINPWR_HALF_FETS = (1U << 26);  ///< Use half switch FET for the continuous mode.
        constexpr uint32_t DCDC_VDD1P5CTRL_DISABLE_STEP = (1U << 29);  ///< Disable stepping for VDD1P5. Must set this bit before enter low power modes.
        constexpr uint32_t DCDC_VDD1P8CTRL_DISABLE_STEP = (1U << 30);  ///< Disable stepping for VDD1P8. Must set this bit before enter low power modes.
    }

    /// REG4 Register bits
    namespace reg4_bits {
        constexpr uint32_t DCDC_SW_SHUTDOWN = (1U << 0);  ///< Shut down DCDC in buck mode. DCDC can be turned on by pulling PSWITCH to high momentarily (min 50 ms).DCDC_SW_SHUTDOWN should not be used in boost mode because when user write this bit, MCU won't be POR and enters an abnormal state.
        constexpr uint32_t UNLOCK = (16 << 16);  ///< 0x3E77 KEY-Key needed to unlock HW_POWER_RESET register
    }

    /// REG6 Register bits
    namespace reg6_bits {
        constexpr uint32_t PSWITCH_INT_RISE_EN = (1U << 0);  ///< Enable rising edge detect for interrupt.
        constexpr uint32_t PSWITCH_INT_FALL_EN = (1U << 1);  ///< Enable falling edge detect for interrupt.
        constexpr uint32_t PSWITCH_INT_CLEAR = (1U << 2);  ///< Write 1 to clear interrupt. Set to 0 after clear.
        constexpr uint32_t PSWITCH_INT_MUTE = (1U << 3);  ///< Mask interrupt to SoC, edge detection result can be read from PSIWTCH_INT_STS.
        constexpr uint32_t PSWITCH_INT_STS = (1U << 31);  ///< PSWITCH edge detection interrupt status
    }

    /// REG7 Register bits
    namespace reg7_bits {
        constexpr uint32_t INTEGRATOR_VALUE = (19 << 0);  ///< Integrator value which can be loaded in pulsed mode
        constexpr uint32_t INTEGRATOR_VALUE_SEL = (1U << 19);  ///< Select the integrator value from above register or saved value in hardware.
        constexpr uint32_t PULSE_RUN_SPEEDUP = (1U << 20);  ///< Enable pulse run speedup
    }

}

// ============================================================================
// BTLE Peripheral
// ============================================================================

namespace btle {
    /// Base addresses
    constexpr uint32_t BTLE_RF_regs_BASE = 0x4005B000;

    /// BTLE Register structure
    struct Registers {
        volatile uint32_t BLE_PART_ID;  ///< Offset: 0x600 - BLUETOOTH LOW ENERGY PART ID
        volatile uint32_t DSM_STATUS;  ///< Offset: 0x604 - BLE DSM STATUS
        volatile uint32_t MISC_CTRL;  ///< Offset: 0x608 - BLUETOOTH LOW ENERGY MISCELLANEOUS CONTROL
    };

    /// Peripheral instances
    inline Registers* BTLE_RF_regs = reinterpret_cast<Registers*>(BTLE_RF_regs_BASE);

    // Bit definitions
    /// BLE_PART_ID Register bits
    namespace ble_part_id_bits {
        constexpr uint32_t BLE_PART_ID = (16 << 0);  ///< BLE Part ID
    }

    /// DSM_STATUS Register bits
    namespace dsm_status_bits {
        constexpr uint32_t ORF_SYSCLK_REQ = (1U << 0);  ///< RF Oscillator Requested
        constexpr uint32_t RIF_LL_ACTIVE = (1U << 1);  ///< Link Layer Active
        constexpr uint32_t XCVR_BUSY = (1U << 2);  ///< Transceiver Busy Status Bit
    }

    /// MISC_CTRL Register bits
    namespace misc_ctrl_bits {
        constexpr uint32_t TSM_INTR_EN = (1U << 1);  ///< TSM Interrupt Enable
    }

}

// ============================================================================
// RX Peripheral
// ============================================================================

namespace rx {
    /// Base addresses
    constexpr uint32_t RX_DIG_BASE = 0x4005C000;

    /// RX Register structure
    struct Registers {
        volatile uint32_t RX_DIG_CTRL;  ///< Offset: 0x00 - RX Digital Control
        volatile uint32_t AGC_CTRL_0;  ///< Offset: 0x04 - AGC Control 0
        volatile uint32_t AGC_CTRL_1;  ///< Offset: 0x08 - AGC Control 1
        volatile uint32_t AGC_CTRL_2;  ///< Offset: 0x0C - AGC Control 2
        volatile uint32_t AGC_CTRL_3;  ///< Offset: 0x10 - AGC Control 3
        volatile uint32_t AGC_STAT;  ///< Offset: 0x14 - AGC Status
        volatile uint32_t RSSI_CTRL_0;  ///< Offset: 0x18 - RSSI Control 0
        volatile uint32_t RSSI_CTRL_1;  ///< Offset: 0x1C - RSSI Control 1
        volatile uint32_t RSSI_DFT;  ///< Offset: 0x20 - RSSI DFT
        volatile uint32_t DCOC_CTRL_0;  ///< Offset: 0x24 - DCOC Control 0
        volatile uint32_t DCOC_CTRL_1;  ///< Offset: 0x28 - DCOC Control 1
        volatile uint32_t DCOC_DAC_INIT;  ///< Offset: 0x2C - DCOC DAC Initialization
        volatile uint32_t DCOC_DIG_MAN;  ///< Offset: 0x30 - DCOC Digital Correction Manual Override
        volatile uint32_t DCOC_CAL_GAIN;  ///< Offset: 0x34 - DCOC Calibration Gain
        volatile uint32_t DCOC_STAT;  ///< Offset: 0x38 - DCOC Status
        volatile uint32_t DCOC_DC_EST;  ///< Offset: 0x3C - DCOC DC Estimate
        volatile uint32_t DCOC_CAL_RCP;  ///< Offset: 0x40 - DCOC Calibration Reciprocals
        volatile uint32_t IQMC_CTRL;  ///< Offset: 0x48 - IQMC Control
        volatile uint32_t IQMC_CAL;  ///< Offset: 0x4C - IQMC Calibration
        volatile uint32_t LNA_GAIN_VAL_3_0;  ///< Offset: 0x50 - LNA_GAIN Step Values 3..0
        volatile uint32_t LNA_GAIN_VAL_7_4;  ///< Offset: 0x54 - LNA_GAIN Step Values 7..4
        volatile uint32_t LNA_GAIN_VAL_8;  ///< Offset: 0x58 - LNA_GAIN Step Values 8
        volatile uint32_t BBA_RES_TUNE_VAL_7_0;  ///< Offset: 0x5C - BBA Resistor Tune Values 7..0
        volatile uint32_t BBA_RES_TUNE_VAL_10_8;  ///< Offset: 0x60 - BBA Resistor Tune Values 10..8
        volatile uint32_t LNA_GAIN_LIN_VAL_2_0;  ///< Offset: 0x64 - LNA Linear Gain Values 2..0
        volatile uint32_t LNA_GAIN_LIN_VAL_5_3;  ///< Offset: 0x68 - LNA Linear Gain Values 5..3
        volatile uint32_t LNA_GAIN_LIN_VAL_8_6;  ///< Offset: 0x6C - LNA Linear Gain Values 8..6
        volatile uint32_t LNA_GAIN_LIN_VAL_9;  ///< Offset: 0x70 - LNA Linear Gain Values 9
        volatile uint32_t BBA_RES_TUNE_LIN_VAL_3_0;  ///< Offset: 0x74 - BBA Resistor Tune Values 3..0
        volatile uint32_t BBA_RES_TUNE_LIN_VAL_7_4;  ///< Offset: 0x78 - BBA Resistor Tune Values 7..4
        volatile uint32_t BBA_RES_TUNE_LIN_VAL_10_8;  ///< Offset: 0x7C - BBA Resistor Tune Values 10..8
        volatile uint32_t AGC_GAIN_TBL_03_00;  ///< Offset: 0x80 - AGC Gain Tables Step 03..00
        volatile uint32_t AGC_GAIN_TBL_07_04;  ///< Offset: 0x84 - AGC Gain Tables Step 07..04
        volatile uint32_t AGC_GAIN_TBL_11_08;  ///< Offset: 0x88 - AGC Gain Tables Step 11..08
        volatile uint32_t AGC_GAIN_TBL_15_12;  ///< Offset: 0x8C - AGC Gain Tables Step 15..12
        volatile uint32_t AGC_GAIN_TBL_19_16;  ///< Offset: 0x90 - AGC Gain Tables Step 19..16
        volatile uint32_t AGC_GAIN_TBL_23_20;  ///< Offset: 0x94 - AGC Gain Tables Step 23..20
        volatile uint32_t AGC_GAIN_TBL_26_24;  ///< Offset: 0x98 - AGC Gain Tables Step 26..24
        volatile uint32_t DCOC_OFFSET_0;  ///< Offset: 0xA0 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_1;  ///< Offset: 0xA4 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_2;  ///< Offset: 0xA8 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_3;  ///< Offset: 0xAC - DCOC Offset
        volatile uint32_t DCOC_OFFSET_4;  ///< Offset: 0xB0 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_5;  ///< Offset: 0xB4 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_6;  ///< Offset: 0xB8 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_7;  ///< Offset: 0xBC - DCOC Offset
        volatile uint32_t DCOC_OFFSET_8;  ///< Offset: 0xC0 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_9;  ///< Offset: 0xC4 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_10;  ///< Offset: 0xC8 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_11;  ///< Offset: 0xCC - DCOC Offset
        volatile uint32_t DCOC_OFFSET_12;  ///< Offset: 0xD0 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_13;  ///< Offset: 0xD4 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_14;  ///< Offset: 0xD8 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_15;  ///< Offset: 0xDC - DCOC Offset
        volatile uint32_t DCOC_OFFSET_16;  ///< Offset: 0xE0 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_17;  ///< Offset: 0xE4 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_18;  ///< Offset: 0xE8 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_19;  ///< Offset: 0xEC - DCOC Offset
        volatile uint32_t DCOC_OFFSET_20;  ///< Offset: 0xF0 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_21;  ///< Offset: 0xF4 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_22;  ///< Offset: 0xF8 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_23;  ///< Offset: 0xFC - DCOC Offset
        volatile uint32_t DCOC_OFFSET_24;  ///< Offset: 0x100 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_25;  ///< Offset: 0x104 - DCOC Offset
        volatile uint32_t DCOC_OFFSET_26;  ///< Offset: 0x108 - DCOC Offset
        volatile uint32_t DCOC_BBA_STEP;  ///< Offset: 0x10C - DCOC BBA DAC Step
        volatile uint32_t DCOC_TZA_STEP_0;  ///< Offset: 0x110 - DCOC TZA DAC Step 0
        volatile uint32_t DCOC_TZA_STEP_1;  ///< Offset: 0x114 - DCOC TZA DAC Step 1
        volatile uint32_t DCOC_TZA_STEP_2;  ///< Offset: 0x118 - DCOC TZA DAC Step 2
        volatile uint32_t DCOC_TZA_STEP_3;  ///< Offset: 0x11C - DCOC TZA DAC Step 3
        volatile uint32_t DCOC_TZA_STEP_4;  ///< Offset: 0x120 - DCOC TZA DAC Step 4
        volatile uint32_t DCOC_TZA_STEP_5;  ///< Offset: 0x124 - DCOC TZA DAC Step 5
        volatile uint32_t DCOC_TZA_STEP_6;  ///< Offset: 0x128 - DCOC TZA DAC Step 6
        volatile uint32_t DCOC_TZA_STEP_7;  ///< Offset: 0x12C - DCOC TZA DAC Step 7
        volatile uint32_t DCOC_TZA_STEP_8;  ///< Offset: 0x130 - DCOC TZA DAC Step 5
        volatile uint32_t DCOC_TZA_STEP_9;  ///< Offset: 0x134 - DCOC TZA DAC Step 9
        volatile uint32_t DCOC_TZA_STEP_10;  ///< Offset: 0x138 - DCOC TZA DAC Step 10
        volatile uint32_t DCOC_CAL_ALPHA;  ///< Offset: 0x168 - DCOC Calibration Alpha
        volatile uint32_t DCOC_CAL_BETA_Q;  ///< Offset: 0x16C - DCOC Calibration Beta Q
        volatile uint32_t DCOC_CAL_BETA_I;  ///< Offset: 0x170 - DCOC Calibration Beta I
        volatile uint32_t DCOC_CAL_GAMMA;  ///< Offset: 0x174 - DCOC Calibration Gamma
        volatile uint32_t DCOC_CAL_IIR;  ///< Offset: 0x178 - DCOC Calibration IIR
        volatile uint32_t DCOC_CAL1;  ///< Offset: 0x180 - DCOC Calibration Result
        volatile uint32_t DCOC_CAL2;  ///< Offset: 0x184 - DCOC Calibration Result
        volatile uint32_t DCOC_CAL3;  ///< Offset: 0x188 - DCOC Calibration Result
        volatile uint32_t CCA_ED_LQI_CTRL_0;  ///< Offset: 0x190 - RX_DIG CCA ED LQI Control Register 0
        volatile uint32_t CCA_ED_LQI_CTRL_1;  ///< Offset: 0x194 - RX_DIG CCA ED LQI Control Register 1
        volatile uint32_t CCA_ED_LQI_STAT_0;  ///< Offset: 0x198 - RX_DIG CCA ED LQI Status Register 0
        volatile uint32_t RX_CHF_COEF_0;  ///< Offset: 0x1A0 - Receive Channel Filter Coefficient 0
        volatile uint32_t RX_CHF_COEF_1;  ///< Offset: 0x1A4 - Receive Channel Filter Coefficient 1
        volatile uint32_t RX_CHF_COEF_2;  ///< Offset: 0x1A8 - Receive Channel Filter Coefficient 2
        volatile uint32_t RX_CHF_COEF_3;  ///< Offset: 0x1AC - Receive Channel Filter Coefficient 3
        volatile uint32_t RX_CHF_COEF_4;  ///< Offset: 0x1B0 - Receive Channel Filter Coefficient 4
        volatile uint32_t RX_CHF_COEF_5;  ///< Offset: 0x1B4 - Receive Channel Filter Coefficient 5
        volatile uint32_t RX_CHF_COEF_6;  ///< Offset: 0x1B8 - Receive Channel Filter Coefficient 6
        volatile uint32_t RX_CHF_COEF_7;  ///< Offset: 0x1BC - Receive Channel Filter Coefficient 7
        volatile uint32_t RX_CHF_COEF_8;  ///< Offset: 0x1C0 - Receive Channel Filter Coefficient 8
        volatile uint32_t RX_CHF_COEF_9;  ///< Offset: 0x1C4 - Receive Channel Filter Coefficient 9
        volatile uint32_t RX_CHF_COEF_10;  ///< Offset: 0x1C8 - Receive Channel Filter Coefficient 10
        volatile uint32_t RX_CHF_COEF_11;  ///< Offset: 0x1CC - Receive Channel Filter Coefficient 11
        volatile uint32_t AGC_MAN_AGC_IDX;  ///< Offset: 0x1D0 - AGC Manual AGC Index
        volatile uint32_t DC_RESID_CTRL;  ///< Offset: 0x1D4 - DC Residual Control
        volatile uint32_t DC_RESID_EST;  ///< Offset: 0x1D8 - DC Residual Estimate
        volatile uint32_t RX_RCCAL_CTRL0;  ///< Offset: 0x1DC - RX RC Calibration Control0
        volatile uint32_t RX_RCCAL_CTRL1;  ///< Offset: 0x1E0 - RX RC Calibration Control1
        volatile uint32_t RX_RCCAL_STAT;  ///< Offset: 0x1E4 - RX RC Calibration Status
        volatile uint32_t AUXPLL_FCAL_CTRL;  ///< Offset: 0x1E8 - Aux PLL Frequency Calibration Control
        volatile uint32_t AUXPLL_FCAL_CNT6;  ///< Offset: 0x1EC - Aux PLL Frequency Calibration Count 6
        volatile uint32_t AUXPLL_FCAL_CNT5_4;  ///< Offset: 0x1F0 - Aux PLL Frequency Calibration Count 5 and 4
        volatile uint32_t AUXPLL_FCAL_CNT3_2;  ///< Offset: 0x1F4 - Aux PLL Frequency Calibration Count 3 and 2
        volatile uint32_t AUXPLL_FCAL_CNT1_0;  ///< Offset: 0x1F8 - Aux PLL Frequency Calibration Count 1 and 0
        volatile uint32_t RXDIG_DFT;  ///< Offset: 0x1FC - RXDIG DFT
    };

    /// Peripheral instances
    inline Registers* RX_DIG = reinterpret_cast<Registers*>(RX_DIG_BASE);

    // Bit definitions
    /// RX_DIG_CTRL Register bits
    namespace rx_dig_ctrl_bits {
        constexpr uint32_t RX_ADC_NEGEDGE = (1U << 0);  ///< Receive ADC Negative Edge Selection
        constexpr uint32_t RX_CH_FILT_BYPASS = (1U << 1);  ///< Receive Channel Filter Bypass
        constexpr uint32_t RX_ADC_RAW_EN = (1U << 2);  ///< ADC Raw Mode selection
        constexpr uint32_t RX_ADC_POL = (1U << 3);  ///< Receive ADC Polarity
        constexpr uint32_t RX_DEC_FILT_OSR = (3 << 4);  ///< Decimation Filter Oversampling
        constexpr uint32_t RX_FSK_ZB_SEL = (1U << 8);  ///< FSK / 802.15.4 demodulator select
        constexpr uint32_t RX_NORM_EN = (1U << 9);  ///< Normalizer Enable
        constexpr uint32_t RX_RSSI_EN = (1U << 10);  ///< RSSI Measurement Enable
        constexpr uint32_t RX_AGC_EN = (1U << 11);  ///< AGC Global Enable
        constexpr uint32_t RX_DCOC_EN = (1U << 12);  ///< DCOC Enable
        constexpr uint32_t RX_DCOC_CAL_EN = (1U << 13);  ///< DCOC Calibration Enable
        constexpr uint32_t RX_IQ_SWAP = (1U << 14);  ///< RX IQ Swap
        constexpr uint32_t RX_DC_RESID_EN = (1U << 15);  ///< DC Residual Enable
        constexpr uint32_t RX_SRC_EN = (1U << 16);  ///< RX Sample Rate Converter Enable
        constexpr uint32_t RX_SRC_RATE = (1U << 17);  ///< RX Sample Rate Converter Rate Selections
        constexpr uint32_t RX_DMA_DTEST_EN = (1U << 18);  ///< RX DMA and DTEST enable
        constexpr uint32_t RX_DEC_FILT_GAIN = (5 << 20);  ///< Decimation Filter Fractional Gain
        constexpr uint32_t RX_DEC_FILT_HZD_CORR_DIS = (1U << 25);  ///< Decimator filter hazard correction disable
        constexpr uint32_t RX_DEC_FILT_HAZARD = (1U << 28);  ///< Decimator output, hazard condition detected
        constexpr uint32_t RX_RSSI_FILT_HAZARD = (1U << 29);  ///< Decimator output for RSSI, hazard condition detected
        constexpr uint32_t RX_DEC_FILT_SAT_I = (1U << 30);  ///< Decimator output, saturation detected for I channel
        constexpr uint32_t RX_DEC_FILT_SAT_Q = (1U << 31);  ///< Decimator output, saturation detected for Q channel
    }

    /// AGC_CTRL_0 Register bits
    namespace agc_ctrl_0_bits {
        constexpr uint32_t SLOW_AGC_EN = (1U << 0);  ///< Slow AGC Enable
        constexpr uint32_t SLOW_AGC_SRC = (2 << 1);  ///< Slow AGC Source Selection
        constexpr uint32_t AGC_FREEZE_EN = (1U << 3);  ///< AGC Freeze Enable
        constexpr uint32_t AGC_FREEZE_PRE_OR_AA = (1U << 4);  ///< AGC Freeze Source Selection
        constexpr uint32_t AGC_UP_EN = (1U << 6);  ///< AGC Up Enable
        constexpr uint32_t AGC_UP_SRC = (1U << 7);  ///< AGC Up Source
        constexpr uint32_t AGC_DOWN_BBA_STEP_SZ = (4 << 8);  ///< AGC_DOWN_BBA_STEP_SZ
        constexpr uint32_t AGC_DOWN_LNA_STEP_SZ = (4 << 12);  ///< AGC_DOWN_LNA_STEP_SZ
        constexpr uint32_t AGC_UP_RSSI_THRESH = (8 << 16);  ///< AGC UP RSSI Threshold
        constexpr uint32_t AGC_DOWN_RSSI_THRESH = (8 << 24);  ///< AGC DOWN RSSI Threshold
    }

    /// AGC_CTRL_1 Register bits
    namespace agc_ctrl_1_bits {
        constexpr uint32_t BBA_ALT_CODE = (4 << 0);  ///< BBA_ALT_CODE
        constexpr uint32_t LNA_ALT_CODE = (8 << 4);  ///< LNA_ALT_CODE
        constexpr uint32_t LNA_USER_GAIN = (4 << 12);  ///< LNA_USER_GAIN
        constexpr uint32_t BBA_USER_GAIN = (4 << 16);  ///< BBA_USER_GAIN
        constexpr uint32_t USER_LNA_GAIN_EN = (1U << 20);  ///< User LNA Gain Enable
        constexpr uint32_t USER_BBA_GAIN_EN = (1U << 21);  ///< User BBA Gain Enable
        constexpr uint32_t PRESLOW_EN = (1U << 22);  ///< Pre-slow Enable
        constexpr uint32_t LNA_GAIN_SETTLE_TIME = (8 << 24);  ///< LNA_GAIN_SETTLE_TIME
    }

    /// AGC_CTRL_2 Register bits
    namespace agc_ctrl_2_bits {
        constexpr uint32_t BBA_PDET_RST = (1U << 0);  ///< BBA PDET Reset
        constexpr uint32_t TZA_PDET_RST = (1U << 1);  ///< TZA PDET Reset
        constexpr uint32_t MAN_PDET_RST = (1U << 2);  ///< MAN PDET Reset
        constexpr uint32_t BBA_GAIN_SETTLE_TIME = (8 << 4);  ///< BBA Gain Settle Time
        constexpr uint32_t BBA_PDET_SEL_LO = (3 << 12);  ///< BBA PDET Threshold Low
        constexpr uint32_t BBA_PDET_SEL_HI = (3 << 15);  ///< BBA PDET Threshold High
        constexpr uint32_t TZA_PDET_SEL_LO = (3 << 18);  ///< TZA PDET Threshold Low
        constexpr uint32_t TZA_PDET_SEL_HI = (3 << 21);  ///< TZA PDET Threshold High
        constexpr uint32_t AGC_FAST_EXPIRE = (6 << 24);  ///< AGC Fast Expire
        constexpr uint32_t LNA_LG_ON_OVR = (1U << 30);  ///< LNA_LG_ON override
        constexpr uint32_t LNA_HG_ON_OVR = (1U << 31);  ///< LNA_HG_ON override
    }

    /// AGC_CTRL_3 Register bits
    namespace agc_ctrl_3_bits {
        constexpr uint32_t AGC_UNFREEZE_TIME = (13 << 0);  ///< AGC Unfreeze Time
        constexpr uint32_t AGC_PDET_LO_DLY = (3 << 13);  ///< AGC Peak Detect Low Delay
        constexpr uint32_t AGC_RSSI_DELT_H2S = (7 << 16);  ///< AGC_RSSI_DELT_H2S
        constexpr uint32_t AGC_H2S_STEP_SZ = (5 << 23);  ///< AGC_H2S_STEP_SZ
        constexpr uint32_t AGC_UP_STEP_SZ = (4 << 28);  ///< AGC Up Step Size
    }

    /// AGC_STAT Register bits
    namespace agc_stat_bits {
        constexpr uint32_t BBA_PDET_LO_STAT = (1U << 0);  ///< BBA Peak Detector Low Status
        constexpr uint32_t BBA_PDET_HI_STAT = (1U << 1);  ///< BBA Peak Detector High Status
        constexpr uint32_t TZA_PDET_LO_STAT = (1U << 2);  ///< TZA Peak Detector Low Status
        constexpr uint32_t TZA_PDET_HI_STAT = (1U << 3);  ///< TZA Peak Detector High Status
        constexpr uint32_t CURR_AGC_IDX = (5 << 4);  ///< Current AGC Gain Index
        constexpr uint32_t AGC_FROZEN = (1U << 9);  ///< AGC Frozen Status
        constexpr uint32_t RSSI_ADC_RAW = (8 << 16);  ///< ADC RAW RSSI Reading
    }

    /// RSSI_CTRL_0 Register bits
    namespace rssi_ctrl_0_bits {
        constexpr uint32_t RSSI_USE_VALS = (1U << 0);  ///< RSSI Values Selection
        constexpr uint32_t RSSI_HOLD_SRC = (2 << 1);  ///< RSSI Hold Source Selection
        constexpr uint32_t RSSI_HOLD_EN = (1U << 3);  ///< RSSI Hold Enable
        constexpr uint32_t RSSI_IIR_CW_WEIGHT = (2 << 5);  ///< RSSI IIR CW Weighting
        constexpr uint32_t RSSI_N_WINDOW_AVG = (2 << 8);  ///< RSSI N Window Average
        constexpr uint32_t RSSI_HOLD_DELAY = (6 << 10);  ///< RSSI Hold Delay
        constexpr uint32_t RSSI_IIR_WEIGHT = (4 << 16);  ///< RSSI IIR Weighting
        constexpr uint32_t RSSI_VLD_SETTLE = (3 << 20);  ///< RSSI Valid Settle
        constexpr uint32_t RSSI_ADJ = (8 << 24);  ///< RSSI Adjustment
    }

    /// RSSI_CTRL_1 Register bits
    namespace rssi_ctrl_1_bits {
        constexpr uint32_t RSSI_OUT = (8 << 24);  ///< RSSI Reading
    }

    /// RSSI_DFT Register bits
    namespace rssi_dft_bits {
        constexpr uint32_t DFT_MAG = (13 << 0);  ///< RSSI MAG
        constexpr uint32_t DFT_NOISE = (13 << 16);  ///< RSSI MAG
    }

    /// DCOC_CTRL_0 Register bits
    namespace dcoc_ctrl_0_bits {
        constexpr uint32_t DCOC_MIDPWR_TRK_DIS = (1U << 0);  ///< DCOC Mid Power Tracking Disable
        constexpr uint32_t DCOC_MAN = (1U << 1);  ///< DCOC Manual Override
        constexpr uint32_t DCOC_TRK_EST_OVR = (1U << 2);  ///< Override for the DCOC tracking estimator
        constexpr uint32_t DCOC_CORRECT_SRC = (1U << 3);  ///< DCOC Corrector Source
        constexpr uint32_t DCOC_CORRECT_EN = (1U << 4);  ///< DCOC Correction Enable
        constexpr uint32_t TRACK_FROM_ZERO = (1U << 5);  ///< Track from Zero
        constexpr uint32_t BBA_CORR_POL = (1U << 6);  ///< BBA Correction Polarity
        constexpr uint32_t TZA_CORR_POL = (1U << 7);  ///< TZA Correction Polarity
        constexpr uint32_t DCOC_CAL_DURATION = (5 << 8);  ///< DCOC Calibration Duration
        constexpr uint32_t DCOC_CORR_DLY = (5 << 16);  ///< DCOC Correction Delay
        constexpr uint32_t DCOC_CORR_HOLD_TIME = (7 << 24);  ///< DCOC Correction Hold Time
    }

    /// DCOC_CTRL_1 Register bits
    namespace dcoc_ctrl_1_bits {
        constexpr uint32_t DCOC_SIGN_SCALE_IDX = (2 << 0);  ///< DCOC Sign Scaling
        constexpr uint32_t DCOC_ALPHAC_SCALE_IDX = (3 << 2);  ///< DCOC Alpha-C Scaling
        constexpr uint32_t DCOC_ALPHA_RADIUS_IDX = (3 << 5);  ///< Alpha-R Scaling
        constexpr uint32_t DCOC_TRK_EST_GS_CNT = (3 << 12);  ///< DCOC Tracking Estimator Gearshift Count
        constexpr uint32_t DCOC_SIGN_SCALE_GS_IDX = (2 << 16);  ///< DCOC Sign Scaling for Gearshift
        constexpr uint32_t DCOC_ALPHAC_SCALE_GS_IDX = (3 << 18);  ///< DCOC Alpha-C Scaling for Gearshift
        constexpr uint32_t DCOC_ALPHA_RADIUS_GS_IDX = (3 << 21);  ///< Alpha-R Scaling for Gearshift
        constexpr uint32_t DCOC_TRK_MIN_AGC_IDX = (5 << 24);  ///< DCOC Tracking Minimum AGC Table Index
    }

    /// DCOC_DAC_INIT Register bits
    namespace dcoc_dac_init_bits {
        constexpr uint32_t BBA_DCOC_INIT_I = (6 << 0);  ///< DCOC BBA Init I
        constexpr uint32_t BBA_DCOC_INIT_Q = (6 << 8);  ///< DCOC BBA Init Q
        constexpr uint32_t TZA_DCOC_INIT_I = (8 << 16);  ///< DCOC TZA Init I
        constexpr uint32_t TZA_DCOC_INIT_Q = (8 << 24);  ///< DCOC TZA Init Q
    }

    /// DCOC_DIG_MAN Register bits
    namespace dcoc_dig_man_bits {
        constexpr uint32_t DIG_DCOC_INIT_I = (12 << 0);  ///< DCOC DIG Init I
        constexpr uint32_t DIG_DCOC_INIT_Q = (12 << 16);  ///< DCOC DIG Init Q
    }

    /// DCOC_CAL_GAIN Register bits
    namespace dcoc_cal_gain_bits {
        constexpr uint32_t DCOC_BBA_CAL_GAIN1 = (4 << 8);  ///< DCOC BBA Calibration Gain 1
        constexpr uint32_t DCOC_LNA_CAL_GAIN1 = (4 << 12);  ///< DCOC LNA Calibration Gain 1
        constexpr uint32_t DCOC_BBA_CAL_GAIN2 = (4 << 16);  ///< DCOC BBA Calibration Gain 2
        constexpr uint32_t DCOC_LNA_CAL_GAIN2 = (4 << 20);  ///< DCOC LNA Calibration Gain 2
        constexpr uint32_t DCOC_BBA_CAL_GAIN3 = (4 << 24);  ///< DCOC BBA Calibration Gain 3
        constexpr uint32_t DCOC_LNA_CAL_GAIN3 = (4 << 28);  ///< DCOC LNA Calibration Gain 3
    }

    /// DCOC_STAT Register bits
    namespace dcoc_stat_bits {
        constexpr uint32_t BBA_DCOC_I = (6 << 0);  ///< DCOC BBA DAC I
        constexpr uint32_t BBA_DCOC_Q = (6 << 8);  ///< DCOC BBA DAC Q
        constexpr uint32_t TZA_DCOC_I = (8 << 16);  ///< DCOC TZA DAC I
        constexpr uint32_t TZA_DCOC_Q = (8 << 24);  ///< DCOC TZA DAC Q
    }

    /// DCOC_DC_EST Register bits
    namespace dcoc_dc_est_bits {
        constexpr uint32_t DC_EST_I = (12 << 0);  ///< DCOC DC Estimate I
        constexpr uint32_t DC_EST_Q = (12 << 16);  ///< DCOC DC Estimate Q
    }

    /// DCOC_CAL_RCP Register bits
    namespace dcoc_cal_rcp_bits {
        constexpr uint32_t DCOC_TMP_CALC_RECIP = (11 << 0);  ///< DCOC Calculation Reciprocal
        constexpr uint32_t ALPHA_CALC_RECIP = (11 << 16);  ///< Alpha Calculation Reciprocal
    }

    /// IQMC_CTRL Register bits
    namespace iqmc_ctrl_bits {
        constexpr uint32_t IQMC_CAL_EN = (1U << 0);  ///< IQ Mismatch Cal Enable
        constexpr uint32_t IQMC_NUM_ITER = (8 << 8);  ///< IQ Mismatch Cal Num Iter
        constexpr uint32_t IQMC_DC_GAIN_ADJ = (11 << 16);  ///< IQ Mismatch Correction DC Gain Coeff
    }

    /// IQMC_CAL Register bits
    namespace iqmc_cal_bits {
        constexpr uint32_t IQMC_GAIN_ADJ = (11 << 0);  ///< IQ Mismatch Correction Gain Coeff
        constexpr uint32_t IQMC_PHASE_ADJ = (12 << 16);  ///< IQ Mismatch Correction Phase Coeff
    }

    /// LNA_GAIN_VAL_3_0 Register bits
    namespace lna_gain_val_3_0_bits {
        constexpr uint32_t LNA_GAIN_VAL_0 = (8 << 0);  ///< LNA_GAIN step 0
        constexpr uint32_t LNA_GAIN_VAL_1 = (8 << 8);  ///< LNA_GAIN step 1
        constexpr uint32_t LNA_GAIN_VAL_2 = (8 << 16);  ///< LNA_GAIN step 2
        constexpr uint32_t LNA_GAIN_VAL_3 = (8 << 24);  ///< LNA_GAIN step 3
    }

    /// LNA_GAIN_VAL_7_4 Register bits
    namespace lna_gain_val_7_4_bits {
        constexpr uint32_t LNA_GAIN_VAL_4 = (8 << 0);  ///< LNA_GAIN step 4
        constexpr uint32_t LNA_GAIN_VAL_5 = (8 << 8);  ///< LNA_GAIN step 5
        constexpr uint32_t LNA_GAIN_VAL_6 = (8 << 16);  ///< LNA_GAIN step 6
        constexpr uint32_t LNA_GAIN_VAL_7 = (8 << 24);  ///< LNA_GAIN step 7
    }

    /// LNA_GAIN_VAL_8 Register bits
    namespace lna_gain_val_8_bits {
        constexpr uint32_t LNA_GAIN_VAL_8 = (8 << 0);  ///< LNA_GAIN step 8
        constexpr uint32_t LNA_GAIN_VAL_9 = (8 << 8);  ///< LNA_GAIN step 9
    }

    /// BBA_RES_TUNE_VAL_7_0 Register bits
    namespace bba_res_tune_val_7_0_bits {
        constexpr uint32_t BBA_RES_TUNE_VAL_0 = (4 << 0);  ///< BBA Resistor Tune Step 0
        constexpr uint32_t BBA_RES_TUNE_VAL_1 = (4 << 4);  ///< BBA Resistor Tune Step 1
        constexpr uint32_t BBA_RES_TUNE_VAL_2 = (4 << 8);  ///< BBA Resistor Tune Step 2
        constexpr uint32_t BBA_RES_TUNE_VAL_3 = (4 << 12);  ///< BBA Resistor Tune Step 3
        constexpr uint32_t BBA_RES_TUNE_VAL_4 = (4 << 16);  ///< BBA Resistor Tune Step 4
        constexpr uint32_t BBA_RES_TUNE_VAL_5 = (4 << 20);  ///< BBA Resistor Tune Step 5
        constexpr uint32_t BBA_RES_TUNE_VAL_6 = (4 << 24);  ///< BBA Resistor Tune Step 6
        constexpr uint32_t BBA_RES_TUNE_VAL_7 = (4 << 28);  ///< BBA Resistor Tune Step 7
    }

    /// BBA_RES_TUNE_VAL_10_8 Register bits
    namespace bba_res_tune_val_10_8_bits {
        constexpr uint32_t BBA_RES_TUNE_VAL_8 = (4 << 0);  ///< BBA Resistor Tune Step 8
        constexpr uint32_t BBA_RES_TUNE_VAL_9 = (4 << 4);  ///< BBA Resistor Tune Step 9
        constexpr uint32_t BBA_RES_TUNE_VAL_10 = (4 << 8);  ///< BBA Resistor Tune Step 10
    }

    /// LNA_GAIN_LIN_VAL_2_0 Register bits
    namespace lna_gain_lin_val_2_0_bits {
        constexpr uint32_t LNA_GAIN_LIN_VAL_0 = (10 << 0);  ///< LNA Linear Gain Step 0
        constexpr uint32_t LNA_GAIN_LIN_VAL_1 = (10 << 10);  ///< LNA Linear Gain Step 1
        constexpr uint32_t LNA_GAIN_LIN_VAL_2 = (10 << 20);  ///< LNA Linear Gain Step 2
    }

    /// LNA_GAIN_LIN_VAL_5_3 Register bits
    namespace lna_gain_lin_val_5_3_bits {
        constexpr uint32_t LNA_GAIN_LIN_VAL_3 = (10 << 0);  ///< LNA Linear Gain Step 3
        constexpr uint32_t LNA_GAIN_LIN_VAL_4 = (10 << 10);  ///< LNA Linear Gain Step 4
        constexpr uint32_t LNA_GAIN_LIN_VAL_5 = (10 << 20);  ///< LNA Linear Gain Step 5
    }

    /// LNA_GAIN_LIN_VAL_8_6 Register bits
    namespace lna_gain_lin_val_8_6_bits {
        constexpr uint32_t LNA_GAIN_LIN_VAL_6 = (10 << 0);  ///< LNA Linear Gain Step 6
        constexpr uint32_t LNA_GAIN_LIN_VAL_7 = (10 << 10);  ///< LNA Linear Gain Step 7
        constexpr uint32_t LNA_GAIN_LIN_VAL_8 = (10 << 20);  ///< LNA Linear Gain Step 8
    }

    /// LNA_GAIN_LIN_VAL_9 Register bits
    namespace lna_gain_lin_val_9_bits {
        constexpr uint32_t LNA_GAIN_LIN_VAL_9 = (10 << 0);  ///< LNA Linear Gain Step 9
    }

    /// BBA_RES_TUNE_LIN_VAL_3_0 Register bits
    namespace bba_res_tune_lin_val_3_0_bits {
        constexpr uint32_t BBA_RES_TUNE_LIN_VAL_0 = (8 << 0);  ///< BBA Resistor Tune Linear Gain Step 0
        constexpr uint32_t BBA_RES_TUNE_LIN_VAL_1 = (8 << 8);  ///< BBA Resistor Tune Linear Gain Step 1
        constexpr uint32_t BBA_RES_TUNE_LIN_VAL_2 = (8 << 16);  ///< BBA Resistor Tune Linear Gain Step 2
        constexpr uint32_t BBA_RES_TUNE_LIN_VAL_3 = (8 << 24);  ///< BBA Resistor Tune Linear Gain Step 3
    }

    /// BBA_RES_TUNE_LIN_VAL_7_4 Register bits
    namespace bba_res_tune_lin_val_7_4_bits {
        constexpr uint32_t BBA_RES_TUNE_LIN_VAL_4 = (8 << 0);  ///< BBA Resistor Tune Linear Gain Step 4
        constexpr uint32_t BBA_RES_TUNE_LIN_VAL_5 = (8 << 8);  ///< BBA Resistor Tune Linear Gain Step 5
        constexpr uint32_t BBA_RES_TUNE_LIN_VAL_6 = (8 << 16);  ///< BBA Resistor Tune Linear Gain Step 6
        constexpr uint32_t BBA_RES_TUNE_LIN_VAL_7 = (8 << 24);  ///< BBA Resistor Tune Linear Gain Step 7
    }

    /// BBA_RES_TUNE_LIN_VAL_10_8 Register bits
    namespace bba_res_tune_lin_val_10_8_bits {
        constexpr uint32_t BBA_RES_TUNE_LIN_VAL_8 = (10 << 0);  ///< BBA Resistor Tune Linear Gain Step 8
        constexpr uint32_t BBA_RES_TUNE_LIN_VAL_9 = (10 << 10);  ///< BBA Resistor Tune Linear Gain Step 9
        constexpr uint32_t BBA_RES_TUNE_LIN_VAL_10 = (10 << 20);  ///< BBA Resistor Tune Linear Gain Step 10
    }

    /// AGC_GAIN_TBL_03_00 Register bits
    namespace agc_gain_tbl_03_00_bits {
        constexpr uint32_t BBA_GAIN_00 = (4 << 0);  ///< BBA Gain 00
        constexpr uint32_t LNA_GAIN_00 = (4 << 4);  ///< LNA Gain 00
        constexpr uint32_t BBA_GAIN_01 = (4 << 8);  ///< BBA Gain 01
        constexpr uint32_t LNA_GAIN_01 = (4 << 12);  ///< LNA Gain 01
        constexpr uint32_t BBA_GAIN_02 = (4 << 16);  ///< BBA Gain 02
        constexpr uint32_t LNA_GAIN_02 = (4 << 20);  ///< LNA Gain 02
        constexpr uint32_t BBA_GAIN_03 = (4 << 24);  ///< BBA Gain 03
        constexpr uint32_t LNA_GAIN_03 = (4 << 28);  ///< LNA Gain 03
    }

    /// AGC_GAIN_TBL_07_04 Register bits
    namespace agc_gain_tbl_07_04_bits {
        constexpr uint32_t BBA_GAIN_04 = (4 << 0);  ///< BBA Gain 04
        constexpr uint32_t LNA_GAIN_04 = (4 << 4);  ///< LNA Gain 04
        constexpr uint32_t BBA_GAIN_05 = (4 << 8);  ///< BBA Gain 05
        constexpr uint32_t LNA_GAIN_05 = (4 << 12);  ///< LNA Gain 05
        constexpr uint32_t BBA_GAIN_06 = (4 << 16);  ///< BBA Gain 06
        constexpr uint32_t LNA_GAIN_06 = (4 << 20);  ///< LNA Gain 06
        constexpr uint32_t BBA_GAIN_07 = (4 << 24);  ///< BBA Gain 07
        constexpr uint32_t LNA_GAIN_07 = (4 << 28);  ///< LNA Gain 07
    }

    /// AGC_GAIN_TBL_11_08 Register bits
    namespace agc_gain_tbl_11_08_bits {
        constexpr uint32_t BBA_GAIN_08 = (4 << 0);  ///< BBA Gain 08
        constexpr uint32_t LNA_GAIN_08 = (4 << 4);  ///< LNA Gain 08
        constexpr uint32_t BBA_GAIN_09 = (4 << 8);  ///< BBA Gain 09
        constexpr uint32_t LNA_GAIN_09 = (4 << 12);  ///< LNA Gain 09
        constexpr uint32_t BBA_GAIN_10 = (4 << 16);  ///< BBA Gain 10
        constexpr uint32_t LNA_GAIN_10 = (4 << 20);  ///< LNA Gain 10
        constexpr uint32_t BBA_GAIN_11 = (4 << 24);  ///< BBA Gain 11
        constexpr uint32_t LNA_GAIN_11 = (4 << 28);  ///< LNA Gain 11
    }

    /// AGC_GAIN_TBL_15_12 Register bits
    namespace agc_gain_tbl_15_12_bits {
        constexpr uint32_t BBA_GAIN_12 = (4 << 0);  ///< BBA Gain 12
        constexpr uint32_t LNA_GAIN_12 = (4 << 4);  ///< LNA Gain 12
        constexpr uint32_t BBA_GAIN_13 = (4 << 8);  ///< BBA Gain 13
        constexpr uint32_t LNA_GAIN_13 = (4 << 12);  ///< LNA Gain 13
        constexpr uint32_t BBA_GAIN_14 = (4 << 16);  ///< BBA Gain 14
        constexpr uint32_t LNA_GAIN_14 = (4 << 20);  ///< LNA Gain 14
        constexpr uint32_t BBA_GAIN_15 = (4 << 24);  ///< BBA Gain 15
        constexpr uint32_t LNA_GAIN_15 = (4 << 28);  ///< LNA Gain 15
    }

    /// AGC_GAIN_TBL_19_16 Register bits
    namespace agc_gain_tbl_19_16_bits {
        constexpr uint32_t BBA_GAIN_16 = (4 << 0);  ///< BBA Gain 16
        constexpr uint32_t LNA_GAIN_16 = (4 << 4);  ///< LNA Gain 16
        constexpr uint32_t BBA_GAIN_17 = (4 << 8);  ///< BBA Gain 17
        constexpr uint32_t LNA_GAIN_17 = (4 << 12);  ///< LNA Gain 17
        constexpr uint32_t BBA_GAIN_18 = (4 << 16);  ///< BBA Gain 18
        constexpr uint32_t LNA_GAIN_18 = (4 << 20);  ///< LNA Gain 18
        constexpr uint32_t BBA_GAIN_19 = (4 << 24);  ///< BBA Gain 193
        constexpr uint32_t LNA_GAIN_19 = (4 << 28);  ///< LNA Gain 19
    }

    /// AGC_GAIN_TBL_23_20 Register bits
    namespace agc_gain_tbl_23_20_bits {
        constexpr uint32_t BBA_GAIN_20 = (4 << 0);  ///< BBA Gain 20
        constexpr uint32_t LNA_GAIN_20 = (4 << 4);  ///< LNA Gain 20
        constexpr uint32_t BBA_GAIN_21 = (4 << 8);  ///< BBA Gain 21
        constexpr uint32_t LNA_GAIN_21 = (4 << 12);  ///< LNA Gain 21
        constexpr uint32_t BBA_GAIN_22 = (4 << 16);  ///< BBA Gain 22
        constexpr uint32_t LNA_GAIN_22 = (4 << 20);  ///< LNA Gain 22
        constexpr uint32_t BBA_GAIN_23 = (4 << 24);  ///< BBA Gain 23
        constexpr uint32_t LNA_GAIN_23 = (4 << 28);  ///< LNA Gain 23
    }

    /// AGC_GAIN_TBL_26_24 Register bits
    namespace agc_gain_tbl_26_24_bits {
        constexpr uint32_t BBA_GAIN_24 = (4 << 0);  ///< BBA Gain 24
        constexpr uint32_t LNA_GAIN_24 = (4 << 4);  ///< LNA Gain 24
        constexpr uint32_t BBA_GAIN_25 = (4 << 8);  ///< BBA Gain 25
        constexpr uint32_t LNA_GAIN_25 = (4 << 12);  ///< LNA Gain 25
        constexpr uint32_t BBA_GAIN_26 = (4 << 16);  ///< BBA Gain 26
        constexpr uint32_t LNA_GAIN_26 = (4 << 20);  ///< LNA Gain 26
    }

    /// DCOC_OFFSET_0 Register bits
    namespace dcoc_offset_0_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_1 Register bits
    namespace dcoc_offset_1_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_2 Register bits
    namespace dcoc_offset_2_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_3 Register bits
    namespace dcoc_offset_3_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_4 Register bits
    namespace dcoc_offset_4_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_5 Register bits
    namespace dcoc_offset_5_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_6 Register bits
    namespace dcoc_offset_6_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_7 Register bits
    namespace dcoc_offset_7_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_8 Register bits
    namespace dcoc_offset_8_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_9 Register bits
    namespace dcoc_offset_9_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_10 Register bits
    namespace dcoc_offset_10_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_11 Register bits
    namespace dcoc_offset_11_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_12 Register bits
    namespace dcoc_offset_12_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_13 Register bits
    namespace dcoc_offset_13_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_14 Register bits
    namespace dcoc_offset_14_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_15 Register bits
    namespace dcoc_offset_15_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_16 Register bits
    namespace dcoc_offset_16_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_17 Register bits
    namespace dcoc_offset_17_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_18 Register bits
    namespace dcoc_offset_18_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_19 Register bits
    namespace dcoc_offset_19_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_20 Register bits
    namespace dcoc_offset_20_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_21 Register bits
    namespace dcoc_offset_21_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_22 Register bits
    namespace dcoc_offset_22_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_23 Register bits
    namespace dcoc_offset_23_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_24 Register bits
    namespace dcoc_offset_24_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_25 Register bits
    namespace dcoc_offset_25_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_OFFSET_26 Register bits
    namespace dcoc_offset_26_bits {
        constexpr uint32_t DCOC_BBA_OFFSET_I = (6 << 0);  ///< DCOC BBA I-channel offset
        constexpr uint32_t DCOC_BBA_OFFSET_Q = (6 << 8);  ///< DCOC BBA Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_BBA_STEP Register bits
    namespace dcoc_bba_step_bits {
        constexpr uint32_t BBA_DCOC_STEP_RECIP = (13 << 0);  ///< DCOC BBA Reciprocal of Step Size
        constexpr uint32_t BBA_DCOC_STEP = (9 << 16);  ///< DCOC BBA Step Size
    }

    /// DCOC_TZA_STEP_0 Register bits
    namespace dcoc_tza_step_0_bits {
        constexpr uint32_t DCOC_TZA_STEP_RCP_0 = (13 << 0);  ///< DCOC_TZA_STEP_RCP_0
        constexpr uint32_t DCOC_TZA_STEP_GAIN_0 = (12 << 16);  ///< DCOC_TZA_STEP_GAIN_0
    }

    /// DCOC_TZA_STEP_1 Register bits
    namespace dcoc_tza_step_1_bits {
        constexpr uint32_t DCOC_TZA_STEP_RCP_1 = (13 << 0);  ///< DCOC_TZA_STEP_RCP_1
        constexpr uint32_t DCOC_TZA_STEP_GAIN_1 = (12 << 16);  ///< DCOC_TZA_STEP_GAIN_1
    }

    /// DCOC_TZA_STEP_2 Register bits
    namespace dcoc_tza_step_2_bits {
        constexpr uint32_t DCOC_TZA_STEP_RCP_2 = (13 << 0);  ///< DCOC_TZA_STEP_RCP_2
        constexpr uint32_t DCOC_TZA_STEP_GAIN_2 = (12 << 16);  ///< DCOC_TZA_STEP_GAIN_2
    }

    /// DCOC_TZA_STEP_3 Register bits
    namespace dcoc_tza_step_3_bits {
        constexpr uint32_t DCOC_TZA_STEP_RCP_3 = (13 << 0);  ///< DCOC_TZA_STEP_RCP_3
        constexpr uint32_t DCOC_TZA_STEP_GAIN_3 = (12 << 16);  ///< DCOC_TZA_STEP_GAIN_3
    }

    /// DCOC_TZA_STEP_4 Register bits
    namespace dcoc_tza_step_4_bits {
        constexpr uint32_t DCOC_TZA_STEP_RCP_4 = (13 << 0);  ///< DCOC_TZA_STEP_RCP_4
        constexpr uint32_t DCOC_TZA_STEP_GAIN_4 = (12 << 16);  ///< DCOC_TZA_STEP_GAIN_4
    }

    /// DCOC_TZA_STEP_5 Register bits
    namespace dcoc_tza_step_5_bits {
        constexpr uint32_t DCOC_TZA_STEP_RCP_5 = (13 << 0);  ///< DCOC_TZA_STEP_RCP_5
        constexpr uint32_t DCOC_TZA_STEP_GAIN_5 = (12 << 16);  ///< DCOC_TZA_STEP_GAIN_5
    }

    /// DCOC_TZA_STEP_6 Register bits
    namespace dcoc_tza_step_6_bits {
        constexpr uint32_t DCOC_TZA_STEP_RCP_6 = (13 << 0);  ///< DCOC_TZA_STEP_RCP_6
        constexpr uint32_t DCOC_TZA_STEP_GAIN_6 = (12 << 16);  ///< DCOC_TZA_STEP_GAIN_6
    }

    /// DCOC_TZA_STEP_7 Register bits
    namespace dcoc_tza_step_7_bits {
        constexpr uint32_t DCOC_TZA_STEP_RCP_7 = (13 << 0);  ///< DCOC_TZA_STEP_RCP_7
        constexpr uint32_t DCOC_TZA_STEP_GAIN_7 = (13 << 16);  ///< DCOC_TZA_STEP_GAIN_7
    }

    /// DCOC_TZA_STEP_8 Register bits
    namespace dcoc_tza_step_8_bits {
        constexpr uint32_t DCOC_TZA_STEP_RCP_8 = (13 << 0);  ///< DCOC_TZA_STEP_RCP_8
        constexpr uint32_t DCOC_TZA_STEP_GAIN_8 = (13 << 16);  ///< DCOC_TZA_STEP_GAIN_8
    }

    /// DCOC_TZA_STEP_9 Register bits
    namespace dcoc_tza_step_9_bits {
        constexpr uint32_t DCOC_TZA_STEP_RCP_9 = (13 << 0);  ///< DCOC_TZA_STEP_RCP_9
        constexpr uint32_t DCOC_TZA_STEP_GAIN_9 = (14 << 16);  ///< DCOC_TZA_STEP_GAIN_9
    }

    /// DCOC_TZA_STEP_10 Register bits
    namespace dcoc_tza_step_10_bits {
        constexpr uint32_t DCOC_TZA_STEP_RCP_10 = (13 << 0);  ///< DCOC_TZA_STEP_RCP_10
        constexpr uint32_t DCOC_TZA_STEP_GAIN_10 = (14 << 16);  ///< DCOC_TZA_STEP_GAIN_10
    }

    /// DCOC_CAL_ALPHA Register bits
    namespace dcoc_cal_alpha_bits {
        constexpr uint32_t DCOC_CAL_ALPHA_I = (11 << 0);  ///< DCOC Calibration I-channel ALPHA constant
        constexpr uint32_t DCOC_CAL_ALPHA_Q = (11 << 16);  ///< DCOC_CAL_ALPHA_Q
    }

    /// DCOC_CAL_BETA_Q Register bits
    namespace dcoc_cal_beta_q_bits {
        constexpr uint32_t DCOC_CAL_BETA_Q = (17 << 0);  ///< DCOC_CAL_BETA_Q
    }

    /// DCOC_CAL_BETA_I Register bits
    namespace dcoc_cal_beta_i_bits {
        constexpr uint32_t DCOC_CAL_BETA_I = (17 << 0);  ///< DCOC_CAL_BETA_I
    }

    /// DCOC_CAL_GAMMA Register bits
    namespace dcoc_cal_gamma_bits {
        constexpr uint32_t DCOC_CAL_GAMMA_I = (16 << 0);  ///< DCOC_CAL_GAMMA_I
        constexpr uint32_t DCOC_CAL_GAMMA_Q = (16 << 16);  ///< DCOC_CAL_GAMMA_Q
    }

    /// DCOC_CAL_IIR Register bits
    namespace dcoc_cal_iir_bits {
        constexpr uint32_t DCOC_CAL_IIR1A_IDX = (2 << 0);  ///< DCOC Calibration IIR 1A Index
        constexpr uint32_t DCOC_CAL_IIR2A_IDX = (2 << 2);  ///< DCOC Calibration IIR 2A Index
        constexpr uint32_t DCOC_CAL_IIR3A_IDX = (2 << 4);  ///< DCOC Calibration IIR 3A Index
    }

    /// DCOC_CAL1 Register bits
    namespace dcoc_cal1_bits {
        constexpr uint32_t DCOC_CAL_RES_I = (12 << 0);  ///< DCOC Calibration Result - I Channel
        constexpr uint32_t DCOC_CAL_RES_Q = (12 << 16);  ///< DCOC Calibration Result - Q Channel
    }

    /// DCOC_CAL2 Register bits
    namespace dcoc_cal2_bits {
        constexpr uint32_t DCOC_CAL_RES_I = (12 << 0);  ///< DCOC Calibration Result - I Channel
        constexpr uint32_t DCOC_CAL_RES_Q = (12 << 16);  ///< DCOC Calibration Result - Q Channel
    }

    /// DCOC_CAL3 Register bits
    namespace dcoc_cal3_bits {
        constexpr uint32_t DCOC_CAL_RES_I = (12 << 0);  ///< DCOC Calibration Result - I Channel
        constexpr uint32_t DCOC_CAL_RES_Q = (12 << 16);  ///< DCOC Calibration Result - Q Channel
    }

    /// CCA_ED_LQI_CTRL_0 Register bits
    namespace cca_ed_lqi_ctrl_0_bits {
        constexpr uint32_t LQI_CORR_THRESH = (8 << 0);  ///< LQI Correlation Threshold
        constexpr uint32_t CORR_CNTR_THRESH = (8 << 8);  ///< Correlation Count Threshold
        constexpr uint32_t LQI_CNTR = (8 << 16);  ///< LQI Counter
        constexpr uint32_t SNR_ADJ = (6 << 24);  ///< SNR calculation adjustment
    }

    /// CCA_ED_LQI_CTRL_1 Register bits
    namespace cca_ed_lqi_ctrl_1_bits {
        constexpr uint32_t RSSI_NOISE_AVG_DELAY = (6 << 0);  ///< RSSI Noise Averaging Delay
        constexpr uint32_t RSSI_NOISE_AVG_FACTOR = (3 << 6);  ///< RSSI Noise Averaging Factor
        constexpr uint32_t LQI_RSSI_WEIGHT = (3 << 9);  ///< LQI RSSI Weight
        constexpr uint32_t LQI_RSSI_SENS = (4 << 12);  ///< LQI RSSI Sensitivity
        constexpr uint32_t SNR_LQI_DIS = (1U << 16);  ///< SNR LQI Disable
        constexpr uint32_t SEL_SNR_MODE = (1U << 17);  ///< Select SNR Mode
        constexpr uint32_t MEAS_TRANS_TO_IDLE = (1U << 18);  ///< Measurement Transition to IDLE
        constexpr uint32_t CCA1_ED_EN_DIS = (1U << 19);  ///< CCA1_ED_EN Disable
        constexpr uint32_t MAN_MEAS_COMPLETE = (1U << 20);  ///< Manual measurement complete
        constexpr uint32_t MAN_AA_MATCH = (1U << 21);  ///< Manual AA Match
        constexpr uint32_t SNR_LQI_WEIGHT = (4 << 24);  ///< SNR LQI Weight
        constexpr uint32_t LQI_BIAS = (4 << 28);  ///< LQI Bias.
    }

    /// CCA_ED_LQI_STAT_0 Register bits
    namespace cca_ed_lqi_stat_0_bits {
        constexpr uint32_t LQI_OUT = (8 << 0);  ///< LQI output
        constexpr uint32_t ED_OUT = (8 << 8);  ///< ED output
        constexpr uint32_t SNR_OUT = (8 << 16);  ///< SNR output
        constexpr uint32_t CCA1_STATE = (1U << 24);  ///< CCA1 State
        constexpr uint32_t MEAS_COMPLETE = (1U << 25);  ///< Measurement Complete
    }

    /// RX_CHF_COEF_0 Register bits
    namespace rx_chf_coef_0_bits {
        constexpr uint32_t RX_CH_FILT_H0 = (6 << 0);  ///< RX Channel Filter Coefficient 0
    }

    /// RX_CHF_COEF_1 Register bits
    namespace rx_chf_coef_1_bits {
        constexpr uint32_t RX_CH_FILT_H1 = (6 << 0);  ///< RX Channel Filter Coefficient 1
    }

    /// RX_CHF_COEF_2 Register bits
    namespace rx_chf_coef_2_bits {
        constexpr uint32_t RX_CH_FILT_H2 = (7 << 0);  ///< RX Channel Filter Coefficient 2
    }

    /// RX_CHF_COEF_3 Register bits
    namespace rx_chf_coef_3_bits {
        constexpr uint32_t RX_CH_FILT_H3 = (7 << 0);  ///< RX Channel Filter Coefficient 3
    }

    /// RX_CHF_COEF_4 Register bits
    namespace rx_chf_coef_4_bits {
        constexpr uint32_t RX_CH_FILT_H4 = (7 << 0);  ///< RX Channel Filter Coefficient 4
    }

    /// RX_CHF_COEF_5 Register bits
    namespace rx_chf_coef_5_bits {
        constexpr uint32_t RX_CH_FILT_H5 = (7 << 0);  ///< RX Channel Filter Coefficient 5
    }

    /// RX_CHF_COEF_6 Register bits
    namespace rx_chf_coef_6_bits {
        constexpr uint32_t RX_CH_FILT_H6 = (8 << 0);  ///< RX Channel Filter Coefficient 6
    }

    /// RX_CHF_COEF_7 Register bits
    namespace rx_chf_coef_7_bits {
        constexpr uint32_t RX_CH_FILT_H7 = (8 << 0);  ///< RX Channel Filter Coefficient 7
    }

    /// RX_CHF_COEF_8 Register bits
    namespace rx_chf_coef_8_bits {
        constexpr uint32_t RX_CH_FILT_H8 = (9 << 0);  ///< RX Channel Filter Coefficient 8
    }

    /// RX_CHF_COEF_9 Register bits
    namespace rx_chf_coef_9_bits {
        constexpr uint32_t RX_CH_FILT_H9 = (9 << 0);  ///< RX Channel Filter Coefficient 9
    }

    /// RX_CHF_COEF_10 Register bits
    namespace rx_chf_coef_10_bits {
        constexpr uint32_t RX_CH_FILT_H10 = (10 << 0);  ///< RX Channel Filter Coefficient 10
    }

    /// RX_CHF_COEF_11 Register bits
    namespace rx_chf_coef_11_bits {
        constexpr uint32_t RX_CH_FILT_H11 = (10 << 0);  ///< RX Channel Filter Coefficient 11
    }

    /// AGC_MAN_AGC_IDX Register bits
    namespace agc_man_agc_idx_bits {
        constexpr uint32_t AGC_MAN_IDX = (5 << 16);  ///< AGC Manual Index
        constexpr uint32_t AGC_MAN_IDX_EN = (1U << 24);  ///< AGC Manual Index Enable
        constexpr uint32_t AGC_DCOC_START_PT = (1U << 25);  ///< AGC DCOC Start Point
    }

    /// DC_RESID_CTRL Register bits
    namespace dc_resid_ctrl_bits {
        constexpr uint32_t DC_RESID_NWIN = (7 << 0);  ///< DC Residual NWIN
        constexpr uint32_t DC_RESID_ITER_FREEZE = (4 << 8);  ///< DC Residual Iteration Freeze
        constexpr uint32_t DC_RESID_ALPHA = (3 << 12);  ///< DC Residual Alpha
        constexpr uint32_t DC_RESID_DLY = (3 << 16);  ///< DC Residual Delay
        constexpr uint32_t DC_RESID_EXT_DC_EN = (1U << 20);  ///< DC Residual External DC Enable
        constexpr uint32_t DC_RESID_MIN_AGC_IDX = (5 << 24);  ///< DC Residual Minimum AGC Table Index
    }

    /// DC_RESID_EST Register bits
    namespace dc_resid_est_bits {
        constexpr uint32_t DC_RESID_OFFSET_I = (13 << 0);  ///< DC Residual Offset I
        constexpr uint32_t DC_RESID_OFFSET_Q = (13 << 16);  ///< DC Residual Offset Q
    }

    /// RX_RCCAL_CTRL0 Register bits
    namespace rx_rccal_ctrl0_bits {
        constexpr uint32_t BBA_RCCAL_OFFSET = (4 << 0);  ///< BBA RC Calibration value offset
        constexpr uint32_t BBA_RCCAL_MANUAL = (5 << 4);  ///< BBA RC Calibration manual value
        constexpr uint32_t BBA_RCCAL_DIS = (1U << 9);  ///< BBA RC Calibration Disable
        constexpr uint32_t RCCAL_SMP_DLY = (2 << 12);  ///< RC Calibration Sample Delay
        constexpr uint32_t RCCAL_COMP_INV = (1U << 15);  ///< RC Calibration comp_out Invert
        constexpr uint32_t TZA_RCCAL_OFFSET = (4 << 16);  ///< TZA RC Calibration value offset
        constexpr uint32_t TZA_RCCAL_MANUAL = (5 << 20);  ///< TZA RC Calibration manual value
        constexpr uint32_t TZA_RCCAL_DIS = (1U << 25);  ///< TZA RC Calibration Disable
    }

    /// RX_RCCAL_CTRL1 Register bits
    namespace rx_rccal_ctrl1_bits {
        constexpr uint32_t ADC_RCCAL_OFFSET = (4 << 0);  ///< ADC RC Calibration value offset
        constexpr uint32_t ADC_RCCAL_MANUAL = (5 << 4);  ///< ADC RC Calibration manual value
        constexpr uint32_t ADC_RCCAL_DIS = (1U << 9);  ///< ADC RC Calibration Disable
        constexpr uint32_t BBA2_RCCAL_OFFSET = (4 << 16);  ///< BBA2 RC Calibration value offset
        constexpr uint32_t BBA2_RCCAL_MANUAL = (5 << 20);  ///< BBA2 RC Calibration manual value
        constexpr uint32_t BBA2_RCCAL_DIS = (1U << 25);  ///< BBA2 RC Calibration Disable
    }

    /// RX_RCCAL_STAT Register bits
    namespace rx_rccal_stat_bits {
        constexpr uint32_t RCCAL_CODE = (5 << 0);  ///< RC Calibration code
        constexpr uint32_t ADC_RCCAL = (5 << 5);  ///< ADC RC Calibration
        constexpr uint32_t BBA2_RCCAL = (5 << 10);  ///< BBA2 RC Calibration
        constexpr uint32_t BBA_RCCAL = (5 << 16);  ///< BBA RC Calibration
        constexpr uint32_t TZA_RCCAL = (5 << 21);  ///< TZA RC Calibration
    }

    /// AUXPLL_FCAL_CTRL Register bits
    namespace auxpll_fcal_ctrl_bits {
        constexpr uint32_t DAC_CAL_ADJUST_MANUAL = (7 << 0);  ///< Aux PLL Frequency DAC Calibration Adjust Manual value
        constexpr uint32_t AUXPLL_DAC_CAL_ADJUST_DIS = (1U << 7);  ///< Aux PLL Frequency Calibration Disable
        constexpr uint32_t FCAL_RUN_CNT = (1U << 8);  ///< Aux PLL Frequency Calibration Run Count
        constexpr uint32_t FCAL_COMP_INV = (1U << 9);  ///< Aux PLL Frequency Calibration Comparison Invert
        constexpr uint32_t FCAL_SMP_DLY = (2 << 10);  ///< Aux PLL Frequency Calibration Sample Delay
        constexpr uint32_t DAC_CAL_ADJUST = (7 << 16);  ///< Aux PLL DAC Calibration Adjust value
    }

    /// AUXPLL_FCAL_CNT6 Register bits
    namespace auxpll_fcal_cnt6_bits {
        constexpr uint32_t FCAL_COUNT_6 = (10 << 0);  ///< Aux PLL Frequency Calibration Count 6
        constexpr uint32_t FCAL_BESTDIFF = (10 << 16);  ///< Aux PLL Frequency Calibration Best Difference
    }

    /// AUXPLL_FCAL_CNT5_4 Register bits
    namespace auxpll_fcal_cnt5_4_bits {
        constexpr uint32_t FCAL_COUNT_4 = (10 << 0);  ///< Aux PLL Frequency Calibration Count 4
        constexpr uint32_t FCAL_COUNT_5 = (10 << 16);  ///< Aux PLL Frequency Calibration Count 5
    }

    /// AUXPLL_FCAL_CNT3_2 Register bits
    namespace auxpll_fcal_cnt3_2_bits {
        constexpr uint32_t FCAL_COUNT_2 = (10 << 0);  ///< Aux PLL Frequency Calibration Count 2
        constexpr uint32_t FCAL_COUNT_3 = (10 << 16);  ///< Aux PLL Frequency Calibration Count 3
    }

    /// AUXPLL_FCAL_CNT1_0 Register bits
    namespace auxpll_fcal_cnt1_0_bits {
        constexpr uint32_t FCAL_COUNT_0 = (10 << 0);  ///< Frequency Calibration Count 0
        constexpr uint32_t FCAL_COUNT_1 = (10 << 16);  ///< Frequency Calibration Count 1
    }

    /// RXDIG_DFT Register bits
    namespace rxdig_dft_bits {
        constexpr uint32_t DFT_TONE_FREQ = (3 << 0);  ///< DFT Tone Generator Frequency
        constexpr uint32_t DFT_TONE_SCALE = (1U << 3);  ///< DFT Tone Generator Scale
        constexpr uint32_t DFT_TONE_TZA_EN = (1U << 4);  ///< DFT Tone Generator TZA Enable
        constexpr uint32_t DFT_TONE_BBA_EN = (1U << 5);  ///< DFT Tone Generator BBA Enable
    }

}

// ============================================================================
// TX Peripheral
// ============================================================================

namespace tx {
    /// Base addresses
    constexpr uint32_t TX_DIG_REGS_BASE = 0x4005C200;

    /// TX Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - TX Digital Control
        volatile uint32_t DATA_PADDING;  ///< Offset: 0x04 - TX Data Padding
        volatile uint32_t GFSK_CTRL;  ///< Offset: 0x08 - TX GFSK Modulator Control
        volatile uint32_t GFSK_COEFF2;  ///< Offset: 0x0C - TX GFSK Filter Coefficients 2
        volatile uint32_t GFSK_COEFF1;  ///< Offset: 0x10 - TX GFSK Filter Coefficients 1
        volatile uint32_t FSK_SCALE;  ///< Offset: 0x14 - TX FSK Modulation Levels
        volatile uint32_t DFT_PATTERN;  ///< Offset: 0x18 - TX DFT Modulation Pattern
        volatile uint32_t RF_DFT_BIST_1;  ///< Offset: 0x1C - TX DFT Control 1
        volatile uint32_t RF_DFT_BIST_2;  ///< Offset: 0x20 - TX DFT Control 2
    };

    /// Peripheral instances
    inline Registers* TX_DIG_REGS = reinterpret_cast<Registers*>(TX_DIG_REGS_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t RADIO_DFT_MODE = (4 << 0);  ///< Radio DFT Modes
        constexpr uint32_t LFSR_LENGTH = (3 << 4);  ///< LFSR Length
        constexpr uint32_t LFSR_EN = (1U << 7);  ///< LFSR Enable
        constexpr uint32_t DFT_CLK_SEL = (3 << 8);  ///< DFT Clock Selection
        constexpr uint32_t TX_DFT_EN = (1U << 11);  ///< DFT Modulation Enable
        constexpr uint32_t SOC_TEST_SEL = (2 << 12);  ///< Radio Clock Selector for SoC RF Clock Tests
        constexpr uint32_t TX_CAPTURE_POL = (1U << 16);  ///< Polarity of the Input Data for the Transmitter
        constexpr uint32_t FREQ_WORD_ADJ = (10 << 22);  ///< Frequency Word Adjustment
    }

    /// DATA_PADDING Register bits
    namespace data_padding_bits {
        constexpr uint32_t DATA_PADDING_PAT_0 = (8 << 0);  ///< Data Padding Pattern 0
        constexpr uint32_t DATA_PADDING_PAT_1 = (8 << 8);  ///< Data Padding Pattern 1
        constexpr uint32_t DFT_LFSR_OUT = (15 << 16);  ///< LFSR Output
        constexpr uint32_t LRM = (1U << 31);  ///< LFSR Reset Mask
    }

    /// GFSK_CTRL Register bits
    namespace gfsk_ctrl_bits {
        constexpr uint32_t GFSK_MULTIPLY_TABLE_MANUAL = (16 << 0);  ///< Manual GFSK Multiply Lookup Table Value
        constexpr uint32_t GFSK_MI = (2 << 16);  ///< GFSK Modulation Index
        constexpr uint32_t GFSK_MLD = (1U << 20);  ///< Disable GFSK Multiply Lookup Table
        constexpr uint32_t GFSK_FLD = (1U << 21);  ///< Disable GFSK Filter Lookup Table
        constexpr uint32_t GFSK_MOD_INDEX_SCALING = (3 << 24);  ///< GFSK Modulation Index Scaling Factor
        constexpr uint32_t TX_IMAGE_FILTER_OVRD_EN = (1U << 28);  ///< TX Image Filter Override Enable
        constexpr uint32_t TX_IMAGE_FILTER_0_OVRD = (1U << 29);  ///< TX Image Filter 0 Override Control
        constexpr uint32_t TX_IMAGE_FILTER_1_OVRD = (1U << 30);  ///< TX Image Filter 1 Override Control
        constexpr uint32_t TX_IMAGE_FILTER_2_OVRD = (1U << 31);  ///< TX Image Filter 2 Override Control
    }

    /// GFSK_COEFF2 Register bits
    namespace gfsk_coeff2_bits {
        constexpr uint32_t GFSK_FILTER_COEFF_MANUAL2 = (32 << 0);  ///< GFSK Manual Filter Coefficients[63:32]
    }

    /// GFSK_COEFF1 Register bits
    namespace gfsk_coeff1_bits {
        constexpr uint32_t GFSK_FILTER_COEFF_MANUAL1 = (32 << 0);  ///< GFSK Manual Filter Coefficient [31:0]
    }

    /// FSK_SCALE Register bits
    namespace fsk_scale_bits {
        constexpr uint32_t FSK_MODULATION_SCALE_0 = (13 << 0);  ///< FSK Modulation Scale for a data 0
        constexpr uint32_t FSK_MODULATION_SCALE_1 = (13 << 16);  ///< FSK Modulation Scale for a data 1
    }

    /// DFT_PATTERN Register bits
    namespace dft_pattern_bits {
        constexpr uint32_t DFT_MOD_PATTERN = (32 << 0);  ///< DFT Modulation Pattern
    }

    /// RF_DFT_BIST_1 Register bits
    namespace rf_dft_bist_1_bits {
        constexpr uint32_t CTUNE_BIST_GO = (1U << 0);  ///< Start the Coarse Tune BIST
        constexpr uint32_t CTUNE_BIST_FINISHED = (1U << 1);  ///< Coarse Tune BIST has finished Tuning all Channels
        constexpr uint32_t CTUNE_BIST_RESULT = (1U << 2);  ///< Coarse Tune BIST Result
        constexpr uint32_t CTUNE_BIST_THRSHLD = (4 << 4);  ///< Maximum Difference Threshold for Coarse Tune BIST
        constexpr uint32_t CTUNE_MAX_DIFF = (8 << 8);  ///< Maximum Frequency Count Difference found by the Coarse Tune BIST
        constexpr uint32_t CTUNE_MAX_DIFF_CH = (7 << 16);  ///< Maximum Frequency Count Difference Radio Channel
        constexpr uint32_t PA_AM_MOD_FREQ = (3 << 24);  ///< RF Power Amplifier Amplitude Modulation Frequency
        constexpr uint32_t PA_AM_MOD_ENTRIES = (3 << 28);  ///< RF Power Amplifier Amplitude Modulation Table Entries
        constexpr uint32_t PA_AM_MOD_EN = (1U << 31);  ///< RF Power Amplifier Amplitude Modulation Enable
    }

    /// RF_DFT_BIST_2 Register bits
    namespace rf_dft_bist_2_bits {
        constexpr uint32_t SYN_BIST_GO = (1U << 0);  ///< Start the PLL Frequency Synthesizer BIST
        constexpr uint32_t SYN_BIST_FINISHED = (1U << 1);  ///< PLL Frequency Synthesizer BIST has finished trying to lock to Radio Channels
        constexpr uint32_t SYN_BIST_RESULT = (1U << 2);  ///< PLL Frequency Synthesizer BIST Result
        constexpr uint32_t SYN_BIST_ALL_CHANNELS = (1U << 3);  ///< PLL Frequency Synthesizer BIST All Channels
        constexpr uint32_t FREQ_COUNT_THRESHOLD = (8 << 4);  ///< Frequency Meter Count Difference Threshold
        constexpr uint32_t HPM_INL_BIST_GO = (1U << 12);  ///< Start the High Port Modulator DAC INL BIST
        constexpr uint32_t HPM_INL_BIST_FINISHED = (1U << 13);  ///< High Port Modulator DAC INL BIST has finished measuring the INL of the HPM DAC
        constexpr uint32_t HPM_INL_BIST_RESULT = (1U << 14);  ///< High Port Modulator DAC INL BIST Result
        constexpr uint32_t HPM_DNL_BIST_GO = (1U << 16);  ///< Start the High Port Modulator DAC DNL BIST
        constexpr uint32_t HPM_DNL_BIST_FINISHED = (1U << 17);  ///< High Port Modulator DAC DNL BIST has finished measuring the DNL of the HPM DAC
        constexpr uint32_t HPM_DNL_BIST_RESULT = (1U << 18);  ///< High Port Modulator DAC DNL BIST Result
        constexpr uint32_t DFT_MAX_RAM_SIZE = (9 << 20);  ///< Maximum RAM Address to use as Modulation
    }

}

// ============================================================================
// PLL Peripheral
// ============================================================================

namespace pll {
    /// Base addresses
    constexpr uint32_t PLL_DIG_REGS_BASE = 0x4005C224;

    /// PLL Register structure
    struct Registers {
        volatile uint32_t HPM_BUMP;  ///< Offset: 0x00 - PLL HPM Analog Bump Control
        volatile uint32_t MOD_CTRL;  ///< Offset: 0x04 - PLL Modulation Control
        volatile uint32_t CHAN_MAP;  ///< Offset: 0x08 - PLL Channel Mapping
        volatile uint32_t LOCK_DETECT;  ///< Offset: 0x0C - PLL Lock Detect Control
        volatile uint32_t HPM_CTRL;  ///< Offset: 0x10 - PLL High Port Modulator Control
        volatile uint32_t HPMCAL_CTRL;  ///< Offset: 0x14 - PLL High Port Calibration Control
        volatile uint32_t HPM_CAL1;  ///< Offset: 0x18 - PLL High Port Calibration Result 1
        volatile uint32_t HPM_CAL2;  ///< Offset: 0x1C - PLL High Port Calibration Result 2
        volatile uint32_t HPM_SDM_RES;  ///< Offset: 0x20 - PLL High Port Sigma Delta Results
        volatile uint32_t LPM_CTRL;  ///< Offset: 0x24 - PLL Low Port Modulator Control
        volatile uint32_t LPM_SDM_CTRL1;  ///< Offset: 0x28 - PLL Low Port Sigma Delta Control 1
        volatile uint32_t LPM_SDM_CTRL2;  ///< Offset: 0x2C - PLL Low Port Sigma Delta Control 2
        volatile uint32_t LPM_SDM_CTRL3;  ///< Offset: 0x30 - PLL Low Port Sigma Delta Control 3
        volatile uint32_t LPM_SDM_RES1;  ///< Offset: 0x34 - PLL Low Port Sigma Delta Result 1
        volatile uint32_t LPM_SDM_RES2;  ///< Offset: 0x38 - PLL Low Port Sigma Delta Result 2
        volatile uint32_t DELAY_MATCH;  ///< Offset: 0x3C - PLL Delay Matching
        volatile uint32_t CTUNE_CTRL;  ///< Offset: 0x40 - PLL Coarse Tune Control
        volatile uint32_t CTUNE_CNT6;  ///< Offset: 0x44 - PLL Coarse Tune Count 6
        volatile uint32_t CTUNE_CNT5_4;  ///< Offset: 0x48 - PLL Coarse Tune Counts 5 and 4
        volatile uint32_t CTUNE_CNT3_2;  ///< Offset: 0x4C - PLL Coarse Tune Counts 3 and 2
        volatile uint32_t CTUNE_CNT1_0;  ///< Offset: 0x50 - PLL Coarse Tune Counts 1 and 0
        volatile uint32_t CTUNE_RES;  ///< Offset: 0x54 - PLL Coarse Tune Results
    };

    /// Peripheral instances
    inline Registers* PLL_DIG_REGS = reinterpret_cast<Registers*>(PLL_DIG_REGS_BASE);

    // Bit definitions
    /// HPM_BUMP Register bits
    namespace hpm_bump_bits {
        constexpr uint32_t HPM_VCM_TX = (3 << 0);  ///< rfctrl_tx_dac_bump_vcm[2:0] during Transmission
        constexpr uint32_t HPM_VCM_CAL = (3 << 4);  ///< rfctrl_tx_dac_bump_vcm[2:0] during Calibration
        constexpr uint32_t HPM_FDB_RES_TX = (2 << 8);  ///< rfctrl_tx_dac_bump_fdb_res[1:0] during Transmission
        constexpr uint32_t HPM_FDB_RES_CAL = (2 << 12);  ///< rfctrl_tx_dac_bump_fdb_res[1:0] during Calibration
    }

    /// MOD_CTRL Register bits
    namespace mod_ctrl_bits {
        constexpr uint32_t MODULATION_WORD_MANUAL = (13 << 0);  ///< Manual Modulation Word
        constexpr uint32_t MOD_DISABLE = (1U << 15);  ///< Disable Modulation Word
        constexpr uint32_t HPM_MOD_MANUAL = (8 << 16);  ///< Manual HPM Modulation
        constexpr uint32_t HPM_MOD_DISABLE = (1U << 27);  ///< Disable HPM Modulation
        constexpr uint32_t HPM_SDM_OUT_MANUAL = (2 << 28);  ///< Manual HPM SDM out
        constexpr uint32_t HPM_SDM_OUT_DISABLE = (1U << 31);  ///< Disable HPM SDM out
    }

    /// CHAN_MAP Register bits
    namespace chan_map_bits {
        constexpr uint32_t CHANNEL_NUM = (7 << 0);  ///< Protocol specific Channel Number for PLL Frequency Mapping
        constexpr uint32_t BOC = (1U << 8);  ///< BLE Channel Number Override
        constexpr uint32_t BMR = (1U << 9);  ///< BLE MBAN Channel Remap
        constexpr uint32_t ZOC = (1U << 10);  ///< 802.15.4 Channel Number Override
    }

    /// LOCK_DETECT Register bits
    namespace lock_detect_bits {
        constexpr uint32_t CT_FAIL = (1U << 0);  ///< Real time status of Coarse Tune Fail signal
        constexpr uint32_t CTFF = (1U << 1);  ///< CTUNE Failure Flag, held until cleared
        constexpr uint32_t CS_FAIL = (1U << 2);  ///< Real time status of Cycle Slip circuit
        constexpr uint32_t CSFF = (1U << 3);  ///< Cycle Slip Failure Flag, held until cleared
        constexpr uint32_t FT_FAIL = (1U << 4);  ///< Real time status of Frequency Target Failure
        constexpr uint32_t FTFF = (1U << 5);  ///< Frequency Target Failure Flag
        constexpr uint32_t TAFF = (1U << 7);  ///< TSM Abort Failure Flag
        constexpr uint32_t CTUNE_LDF_LEV = (4 << 8);  ///< CTUNE Lock Detect Fail Level
        constexpr uint32_t FTF_RX_THRSH = (6 << 12);  ///< RX Frequency Target Fail Threshold
        constexpr uint32_t FTW_RX = (1U << 19);  ///< RX Frequency Target Window time select
        constexpr uint32_t FTF_TX_THRSH = (6 << 20);  ///< TX Frequency Target Fail Threshold
        constexpr uint32_t FTW_TX = (1U << 27);  ///< TX Frequency Target Window time select
        constexpr uint32_t FREQ_COUNT_GO = (1U << 28);  ///< Start the Frequency Meter
        constexpr uint32_t FREQ_COUNT_FINISHED = (1U << 29);  ///< Frequency Meter has finished the Count Time
        constexpr uint32_t FREQ_COUNT_TIME = (2 << 30);  ///< Frequency Meter Count Time
    }

    /// HPM_CTRL Register bits
    namespace hpm_ctrl_bits {
        constexpr uint32_t HPM_SDM_IN_MANUAL = (10 << 0);  ///< Manual High Port SDM Fractional value
        constexpr uint32_t HPFF = (1U << 13);  ///< HPM SDM Invalid Flag
        constexpr uint32_t HPM_SDM_OUT_INVERT = (1U << 14);  ///< Invert HPM SDM Output
        constexpr uint32_t HPM_SDM_IN_DISABLE = (1U << 15);  ///< Disable HPM SDM Input
        constexpr uint32_t HPM_LFSR_SIZE = (3 << 16);  ///< HPM LFSR Length
        constexpr uint32_t HPM_DTH_SCL = (1U << 20);  ///< HPM Dither Scale
        constexpr uint32_t HPM_DTH_EN = (1U << 23);  ///< Dither Enable for HPM LFSR
        constexpr uint32_t HPM_INTEGER_SCALE = (2 << 24);  ///< High Port Modulation Integer Scale
        constexpr uint32_t HPM_INTEGER_INVERT = (1U << 27);  ///< Invert High Port Modulation Integer
        constexpr uint32_t HPM_CAL_INVERT = (1U << 28);  ///< Invert High Port Modulator Calibration
        constexpr uint32_t HPM_MOD_IN_INVERT = (1U << 31);  ///< Invert High Port Modulation
    }

    /// HPMCAL_CTRL Register bits
    namespace hpmcal_ctrl_bits {
        constexpr uint32_t HPM_CAL_FACTOR = (13 << 0);  ///< High Port Modulation Calibration Factor
        constexpr uint32_t HPM_CAL_NOT_BUMPED = (1U << 13);  ///< HPM_CAL_NOT_BUMPED
        constexpr uint32_t HPM_CAL_COUNT_SCALE = (1U << 14);  ///< HPM_CAL_COUNT_SCALE
        constexpr uint32_t HP_CAL_DISABLE = (1U << 15);  ///< Disable HPM Manual Calibration
        constexpr uint32_t HPM_CAL_FACTOR_MANUAL = (13 << 16);  ///< Manual HPM Calibration Factor
        constexpr uint32_t HPM_CAL_ARRAY_SIZE = (1U << 30);  ///< High Port Modulation Calibration Array Size
        constexpr uint32_t HPM_CAL_TIME = (1U << 31);  ///< High Port Modulation Calibration Time
    }

    /// HPM_CAL1 Register bits
    namespace hpm_cal1_bits {
        constexpr uint32_t HPM_COUNT_1 = (19 << 0);  ///< High Port Modulation Counter Value 1
        constexpr uint32_t CS_WT = (3 << 20);  ///< Cycle Slip Wait Time
        constexpr uint32_t CS_FW = (3 << 24);  ///< Cycle Slip Flag Window
        constexpr uint32_t CS_FCNT = (4 << 28);  ///< Cycle Slip Flag Count
    }

    /// HPM_CAL2 Register bits
    namespace hpm_cal2_bits {
        constexpr uint32_t HPM_COUNT_2 = (19 << 0);  ///< High Port Modulation Counter Value 2
        constexpr uint32_t CS_RC = (1U << 20);  ///< Cycle Slip Recycle
        constexpr uint32_t CS_FT = (5 << 24);  ///< Cycle Slip Flag Timeout
    }

    /// HPM_SDM_RES Register bits
    namespace hpm_sdm_res_bits {
        constexpr uint32_t HPM_NUM_SELECTED = (10 << 0);  ///< High Port Modulator SDM Numerator
        constexpr uint32_t HPM_DENOM = (10 << 16);  ///< High Port Modulator SDM Denominator
        constexpr uint32_t HPM_COUNT_ADJUST = (4 << 28);  ///< HPM_COUNT_ADJUST
    }

    /// LPM_CTRL Register bits
    namespace lpm_ctrl_bits {
        constexpr uint32_t PLL_LD_MANUAL = (6 << 0);  ///< Manual PLL Loop Divider value
        constexpr uint32_t PLL_LD_DISABLE = (1U << 11);  ///< Disable PLL Loop Divider
        constexpr uint32_t LPFF = (1U << 13);  ///< LPM SDM Invalid Flag
        constexpr uint32_t LPM_SDM_INV = (1U << 14);  ///< Invert LPM SDM
        constexpr uint32_t LPM_DISABLE = (1U << 15);  ///< Disable LPM SDM
        constexpr uint32_t LPM_DTH_SCL = (4 << 16);  ///< LPM Dither Scale
        constexpr uint32_t LPM_D_CTRL = (1U << 22);  ///< LPM Dither Control in Override Mode
        constexpr uint32_t LPM_D_OVRD = (1U << 23);  ///< LPM Dither Override Mode Select
        constexpr uint32_t LPM_SCALE = (4 << 24);  ///< LPM Scale Factor
        constexpr uint32_t LPM_SDM_USE_NEG = (1U << 31);  ///< Use the Negedge of the Sigma Delta clock
    }

    /// LPM_SDM_CTRL1 Register bits
    namespace lpm_sdm_ctrl1_bits {
        constexpr uint32_t LPM_INTG_SELECTED = (7 << 0);  ///< Low Port Modulation Integer Value Selected
        constexpr uint32_t HPM_ARRAY_BIAS = (7 << 8);  ///< Bias value for High Port DAC Array Midpoint
        constexpr uint32_t LPM_INTG = (7 << 16);  ///< Manual Low Port Modulation Integer Value
        constexpr uint32_t SDM_MAP_DISABLE = (1U << 31);  ///< Disable SDM Mapping
    }

    /// LPM_SDM_CTRL2 Register bits
    namespace lpm_sdm_ctrl2_bits {
        constexpr uint32_t LPM_NUM = (28 << 0);  ///< Low Port Modulation Numerator
    }

    /// LPM_SDM_CTRL3 Register bits
    namespace lpm_sdm_ctrl3_bits {
        constexpr uint32_t LPM_DENOM = (28 << 0);  ///< Low Port Modulation Denominator
    }

    /// LPM_SDM_RES1 Register bits
    namespace lpm_sdm_res1_bits {
        constexpr uint32_t LPM_NUM_SELECTED = (28 << 0);  ///< Low Port Modulation Numerator Applied
    }

    /// LPM_SDM_RES2 Register bits
    namespace lpm_sdm_res2_bits {
        constexpr uint32_t LPM_DENOM_SELECTED = (28 << 0);  ///< Low Port Modulation Denominator Selected
    }

    /// DELAY_MATCH Register bits
    namespace delay_match_bits {
        constexpr uint32_t LPM_SDM_DELAY = (4 << 0);  ///< Low Port SDM Delay Matching
        constexpr uint32_t HPM_SDM_DELAY = (4 << 8);  ///< High Port SDM Delay Matching
        constexpr uint32_t HPM_INTEGER_DELAY = (4 << 16);  ///< High Port Integer Delay Matching
    }

    /// CTUNE_CTRL Register bits
    namespace ctune_ctrl_bits {
        constexpr uint32_t CTUNE_TARGET_MANUAL = (12 << 0);  ///< Manual Coarse Tune Target
        constexpr uint32_t CTUNE_TARGET_DISABLE = (1U << 15);  ///< Disable Coarse Tune Target
        constexpr uint32_t CTUNE_ADJUST = (4 << 16);  ///< Coarse Tune Count Adjustment
        constexpr uint32_t CTUNE_MANUAL = (7 << 24);  ///< Manual Coarse Tune Setting
        constexpr uint32_t CTUNE_DISABLE = (1U << 31);  ///< Coarse Tune Disable
    }

    /// CTUNE_CNT6 Register bits
    namespace ctune_cnt6_bits {
        constexpr uint32_t CTUNE_COUNT_6 = (13 << 0);  ///< CTUNE Count 6
    }

    /// CTUNE_CNT5_4 Register bits
    namespace ctune_cnt5_4_bits {
        constexpr uint32_t CTUNE_COUNT_4 = (13 << 0);  ///< CTUNE Count 4
        constexpr uint32_t CTUNE_COUNT_5 = (13 << 16);  ///< CTUNE Count 5
    }

    /// CTUNE_CNT3_2 Register bits
    namespace ctune_cnt3_2_bits {
        constexpr uint32_t CTUNE_COUNT_2 = (13 << 0);  ///< CTUNE Count 2
        constexpr uint32_t CTUNE_COUNT_3 = (13 << 16);  ///< CTUNE Count 3
    }

    /// CTUNE_CNT1_0 Register bits
    namespace ctune_cnt1_0_bits {
        constexpr uint32_t CTUNE_COUNT_0 = (13 << 0);  ///< CTUNE Count 0
        constexpr uint32_t CTUNE_COUNT_1 = (13 << 16);  ///< CTUNE Count 1
    }

    /// CTUNE_RES Register bits
    namespace ctune_res_bits {
        constexpr uint32_t CTUNE_SELECTED = (7 << 0);  ///< Coarse Tune Setting to VCO
        constexpr uint32_t CTUNE_BEST_DIFF = (8 << 8);  ///< Coarse Tune Absolute Best Difference
        constexpr uint32_t CTUNE_FREQ_SELECTED = (12 << 16);  ///< Coarse Tune Frequency Selected
    }

}

// ============================================================================
// XCVR Peripheral
// ============================================================================

namespace xcvr {
    /// Base addresses
    constexpr uint32_t XCVR_CTRL_REGS_BASE = 0x4005C280;
    constexpr uint32_t XCVR_TSM_REGS_BASE = 0x4005C2C0;
    constexpr uint32_t XCVR_PHY_REGS_BASE = 0x4005C400;
    constexpr uint32_t XCVR_ZBDEMOD_REGS_BASE = 0x4005C480;
    constexpr uint32_t XCVR_ANALOG_REGS_BASE = 0x4005C500;
    constexpr uint32_t XCVR_PKT_RAM_BASE = 0x4005C700;

    /// XCVR Register structure
    struct Registers {
        volatile uint32_t XCVR_CTRL;  ///< Offset: 0x00 - TRANSCEIVER CONTROL
        volatile uint32_t XCVR_STATUS;  ///< Offset: 0x04 - TRANSCEIVER STATUS
        volatile uint32_t BLE_ARB_CTRL;  ///< Offset: 0x08 - BLE ARBITRATION CONTROL
        volatile uint32_t OVERWRITE_VER;  ///< Offset: 0x10 - OVERWRITE VERSION
        volatile uint32_t DMA_CTRL;  ///< Offset: 0x14 - TRANSCEIVER DMA CONTROL
        volatile uint32_t DMA_DATA;  ///< Offset: 0x18 - TRANSCEIVER DMA DATA
        volatile uint32_t DTEST_CTRL;  ///< Offset: 0x1C - DIGITAL TEST MUX CONTROL
        volatile uint32_t PACKET_RAM_CTRL;  ///< Offset: 0x20 - PACKET RAM CONTROL
        volatile uint32_t FAD_CTRL;  ///< Offset: 0x24 - FAD CONTROL
        volatile uint32_t LPPS_CTRL;  ///< Offset: 0x28 - LOW POWER PREAMBLE SEARCH CONTROL
        volatile uint32_t RF_NOT_ALLOWED_CTRL;  ///< Offset: 0x2C - WIFI COEXISTENCE CONTROL
        volatile uint32_t CRCW_CFG;  ///< Offset: 0x30 - CRC/WHITENER CONTROL
        volatile uint32_t CRC_EC_MASK;  ///< Offset: 0x34 - CRC ERROR CORRECTION MASK
        volatile uint32_t CRC_RES_OUT;  ///< Offset: 0x38 - CRC RESULT
    };

    /// Peripheral instances
    inline Registers* XCVR_CTRL_REGS = reinterpret_cast<Registers*>(XCVR_CTRL_REGS_BASE);
    inline Registers* XCVR_TSM_REGS = reinterpret_cast<Registers*>(XCVR_TSM_REGS_BASE);
    inline Registers* XCVR_PHY_REGS = reinterpret_cast<Registers*>(XCVR_PHY_REGS_BASE);
    inline Registers* XCVR_ZBDEMOD_REGS = reinterpret_cast<Registers*>(XCVR_ZBDEMOD_REGS_BASE);
    inline Registers* XCVR_ANALOG_REGS = reinterpret_cast<Registers*>(XCVR_ANALOG_REGS_BASE);
    inline Registers* XCVR_PKT_RAM = reinterpret_cast<Registers*>(XCVR_PKT_RAM_BASE);

    // Bit definitions
    /// XCVR_CTRL Register bits
    namespace xcvr_ctrl_bits {
        constexpr uint32_t PROTOCOL = (4 << 0);  ///< Radio Protocol Selection
        constexpr uint32_t TGT_PWR_SRC = (3 << 4);  ///< Target Power Source
        constexpr uint32_t REF_CLK_FREQ = (2 << 8);  ///< Radio Reference Clock Frequency
        constexpr uint32_t SOC_RF_OSC_CLK_GATE_EN = (1U << 11);  ///< SOC_RF_OSC_CLK_GATE_EN
        constexpr uint32_t DEMOD_SEL = (2 << 12);  ///< Demodulator Selector
        constexpr uint32_t RADIO0_IRQ_SEL = (3 << 16);  ///< RADIO0_IRQ_SEL
        constexpr uint32_t RADIO1_IRQ_SEL = (3 << 20);  ///< RADIO1_IRQ_SEL
    }

    /// XCVR_STATUS Register bits
    namespace xcvr_status_bits {
        constexpr uint32_t TSM_COUNT = (8 << 0);  ///< TSM_COUNT
        constexpr uint32_t PLL_SEQ_STATE = (4 << 8);  ///< PLL Sequence State
        constexpr uint32_t RX_MODE = (1U << 12);  ///< Receive Mode
        constexpr uint32_t TX_MODE = (1U << 13);  ///< Transmit Mode
        constexpr uint32_t BTLE_SYSCLK_REQ = (1U << 16);  ///< BTLE System Clock Request
        constexpr uint32_t RIF_LL_ACTIVE = (1U << 17);  ///< Link Layer Active Indication
        constexpr uint32_t XTAL_READY = (1U << 18);  ///< RF Osciallator Xtal Ready
        constexpr uint32_t SOC_USING_RF_OSC_CLK = (1U << 19);  ///< SOC Using RF Clock Indication
        constexpr uint32_t TSM_IRQ0 = (1U << 24);  ///< TSM Interrupt #0
        constexpr uint32_t TSM_IRQ1 = (1U << 25);  ///< TSM Interrupt #1
    }

    /// BLE_ARB_CTRL Register bits
    namespace ble_arb_ctrl_bits {
        constexpr uint32_t BLE_RELINQUISH = (1U << 0);  ///< BLE Relinquish Control
        constexpr uint32_t XCVR_BUSY = (1U << 1);  ///< Transceiver Busy Status Bit
    }

    /// OVERWRITE_VER Register bits
    namespace overwrite_ver_bits {
        constexpr uint32_t OVERWRITE_VER = (8 << 0);  ///< Overwrite Version Number.
    }

    /// DMA_CTRL Register bits
    namespace dma_ctrl_bits {
        constexpr uint32_t DMA_PAGE = (4 << 0);  ///< Transceiver DMA Page Selector
        constexpr uint32_t SINGLE_REQ_MODE = (1U << 4);  ///< DMA Single Request Mode
        constexpr uint32_t BYPASS_DMA_SYNC = (1U << 5);  ///< Bypass External DMA Synchronization
        constexpr uint32_t DMA_TRIGGERRED = (1U << 6);  ///< DMA TRIGGERRED
        constexpr uint32_t DMA_TIMED_OUT = (1U << 7);  ///< DMA Transfer Timed Out
        constexpr uint32_t DMA_TIMEOUT = (4 << 8);  ///< DMA Timeout
    }

    /// DMA_DATA Register bits
    namespace dma_data_bits {
        constexpr uint32_t DMA_DATA = (32 << 0);  ///< DMA Data Register
    }

    /// DTEST_CTRL Register bits
    namespace dtest_ctrl_bits {
        constexpr uint32_t DTEST_PAGE = (6 << 0);  ///< DTEST Page Selector
        constexpr uint32_t DTEST_EN = (1U << 7);  ///< DTEST Enable
        constexpr uint32_t GPIO0_OVLAY_PIN = (4 << 8);  ///< GPIO 0 Overlay Pin
        constexpr uint32_t GPIO1_OVLAY_PIN = (4 << 12);  ///< GPIO 1 Overlay Pin
        constexpr uint32_t TSM_GPIO_OVLAY = (2 << 16);  ///< TSM GPIO Overlay Pin Control
        constexpr uint32_t DTEST_SHFT = (3 << 24);  ///< DTEST Shift Control
        constexpr uint32_t RAW_MODE_I = (1U << 28);  ///< DTEST Raw Mode Enable for I Channel
        constexpr uint32_t RAW_MODE_Q = (1U << 29);  ///< DTEST Raw Mode Enable for Q Channel
    }

    /// PACKET_RAM_CTRL Register bits
    namespace packet_ram_ctrl_bits {
        constexpr uint32_t DBG_PAGE = (4 << 0);  ///< Packet RAM Debug Page Selector
        constexpr uint32_t PB_PROTECT = (1U << 4);  ///< Packet Buffer Protect
        constexpr uint32_t XCVR_RAM_ALLOW = (1U << 5);  ///< Allow Packet RAM Transceiver Access
        constexpr uint32_t ALL_PROTOCOLS_ALLOW = (1U << 6);  ///< Allow IPS bus access to Packet RAM for any protocol at any time.
        constexpr uint32_t DBG_TRIGGERRED = (1U << 7);  ///< DBG_TRIGGERRED
        constexpr uint32_t DBG_RAM_FULL = (2 << 8);  ///< DBG_RAM_FULL[1:0]
        constexpr uint32_t RAM0_CLK_ON_OVRD_EN = (1U << 10);  ///< Override control for RAM0 Clock Gate Enable
        constexpr uint32_t RAM0_CLK_ON_OVRD = (1U << 11);  ///< Override value for RAM0 Clock Gate Enable
        constexpr uint32_t RAM1_CLK_ON_OVRD_EN = (1U << 12);  ///< Override control for RAM1 Clock Gate Enable
        constexpr uint32_t RAM1_CLK_ON_OVRD = (1U << 13);  ///< Override value for RAM1 Clock Gate Enable
        constexpr uint32_t RAM0_CE_ON_OVRD_EN = (1U << 14);  ///< Override control for RAM0 CE (Chip Enable)
        constexpr uint32_t RAM0_CE_ON_OVRD = (1U << 15);  ///< Override value for RAM0 CE (Chip Enable)
        constexpr uint32_t RAM1_CE_ON_OVRD_EN = (1U << 16);  ///< Override control for RAM1 CE (Chip Enable)
        constexpr uint32_t RAM1_CE_ON_OVRD = (1U << 17);  ///< Override value for RAM1 CE (Chip Enable)
    }

    /// FAD_CTRL Register bits
    namespace fad_ctrl_bits {
        constexpr uint32_t FAD_EN = (1U << 0);  ///< Fast Antenna Diversity Enable
        constexpr uint32_t ANTX = (1U << 1);  ///< Antenna Selection State
        constexpr uint32_t ANTX_EN = (2 << 4);  ///< FAD Antenna Controls Enable
        constexpr uint32_t ANTX_HZ = (1U << 6);  ///< FAD PAD Tristate Control
        constexpr uint32_t ANTX_CTRLMODE = (1U << 7);  ///< Antenna Diversity Control Mode
        constexpr uint32_t ANTX_POL = (4 << 8);  ///< FAD Antenna Controls Polarity
        constexpr uint32_t FAD_NOT_GPIO = (4 << 12);  ///< FAD versus GPIO Mode Selector
    }

    /// LPPS_CTRL Register bits
    namespace lpps_ctrl_bits {
        constexpr uint32_t LPPS_ENABLE = (1U << 0);  ///< LPPS_ENABLE
        constexpr uint32_t LPPS_TZA_ALLOW = (1U << 1);  ///< LPPS_TZA_ALLOW
        constexpr uint32_t LPPS_BBA_ALLOW = (1U << 2);  ///< LPPS_BBA_ALLOW
        constexpr uint32_t LPPS_ADC_ALLOW = (1U << 3);  ///< LPPS_ADC_ALLOW
        constexpr uint32_t LPPS_DCOC_ALLOW = (1U << 4);  ///< LPPS_DCOC_ALLOW
        constexpr uint32_t LPPS_PDET_ALLOW = (1U << 5);  ///< LPPS_PDET_ALLOW
        constexpr uint32_t LPPS_SY_LO_ALLOW = (1U << 6);  ///< LPPS_SY_LO_ALLOW
        constexpr uint32_t LPPS_SY_LO_BUF_ALLOW = (1U << 7);  ///< LPPS_SY_LO_BUF_ALLOW
        constexpr uint32_t LPPS_RX_DIG_ALLOW = (1U << 8);  ///< LPPS_RX_DIG_ALLOW
        constexpr uint32_t LPPS_DCOC_DIG_ALLOW = (1U << 9);  ///< LPPS_DCOC_DIG_ALLOW
        constexpr uint32_t LPPS_START_RX = (8 << 16);  ///< LPPS Fast TSM RX Warmup "Jump-from" Point
        constexpr uint32_t LPPS_DEST_RX = (8 << 24);  ///< LPPS Fast TSM RX Warmup "Jump-to" Point
    }

    /// RF_NOT_ALLOWED_CTRL Register bits
    namespace rf_not_allowed_ctrl_bits {
        constexpr uint32_t RF_NOT_ALLOWED_NO_TX = (1U << 0);  ///< RF_NOT_ALLOWED_NO_TX
        constexpr uint32_t RF_NOT_ALLOWED_NO_RX = (1U << 1);  ///< RF_NOT_ALLOWED_NO_RX
        constexpr uint32_t RF_NOT_ALLOWED_ASSERTED = (1U << 2);  ///< RF_NOT_ALLOWED_ASSERTED
        constexpr uint32_t RF_NOT_ALLOWED_TX_ABORT = (1U << 3);  ///< RF_NOT_ALLOWED_TX_ABORT
        constexpr uint32_t RF_NOT_ALLOWED_RX_ABORT = (1U << 4);  ///< RF_NOT_ALLOWED_RX_ABORT
        constexpr uint32_t RF_NOT_ALLOWED = (1U << 5);  ///< RF_NOT_ALLOWED
    }

    /// CRCW_CFG Register bits
    namespace crcw_cfg_bits {
        constexpr uint32_t CRCW_EN = (1U << 0);  ///< CRC calculation enable
        constexpr uint32_t CRC_ZERO = (1U << 1);  ///< CRC zero
        constexpr uint32_t CRC_EARLY_FAIL = (1U << 2);  ///< CRC error correction fail
        constexpr uint32_t CRC_RES_OUT_VLD = (1U << 3);  ///< CRC result output valid
        constexpr uint32_t CRC_EC_OFFSET = (11 << 16);  ///< CRC error correction offset
        constexpr uint32_t CRC_EC_DONE = (1U << 28);  ///< CRC error correction done
        constexpr uint32_t CRC_EC_FAIL = (1U << 29);  ///< CRC error correction fail
    }

    /// CRC_EC_MASK Register bits
    namespace crc_ec_mask_bits {
        constexpr uint32_t CRC_EC_MASK = (32 << 0);  ///< CRC error correction mask
    }

    /// CRC_RES_OUT Register bits
    namespace crc_res_out_bits {
        constexpr uint32_t CRC_RES_OUT = (32 << 0);  ///< CRC result output
    }

}

// ============================================================================
// ANT Peripheral
// ============================================================================

namespace ant {
    /// Base addresses
    constexpr uint32_t ANT_REGS_BASE = 0x4005E000;

    /// ANT Register structure
    struct Registers {
        volatile uint32_t IRQ_CTRL;  ///< Offset: 0x00 - IRQ CONTROL
        volatile uint32_t EVENT_TMR;  ///< Offset: 0x04 - EVENT TIMER
        volatile uint32_t T1_CMP;  ///< Offset: 0x08 - T1 COMPARE
        volatile uint32_t T2_CMP;  ///< Offset: 0x0C - T2 COMPARE
        volatile uint32_t TIMESTAMP;  ///< Offset: 0x10 - TIMESTAMP
        volatile uint32_t XCVR_CTRL;  ///< Offset: 0x14 - TRANSCEIVER CONTROL
        volatile uint32_t XCVR_STS;  ///< Offset: 0x18 - TRANSCEIVER STATUS
        volatile uint32_t XCVR_CFG;  ///< Offset: 0x1C - TRANSCEIVER CONFIGURATION
        volatile uint32_t CHANNEL_NUM;  ///< Offset: 0x20 - CHANNEL NUMBER
        volatile uint32_t TX_POWER;  ///< Offset: 0x24 - TRANSMIT POWER
        volatile uint32_t NTW_ADR_CTRL;  ///< Offset: 0x28 - NETWORK ADDRESS CONTROL
        volatile uint32_t NTW_ADR_0;  ///< Offset: 0x2C - NETWORK ADDRESS 0
        volatile uint32_t NTW_ADR_1;  ///< Offset: 0x30 - NETWORK ADDRESS 1
        volatile uint32_t NTW_ADR_2;  ///< Offset: 0x34 - NETWORK ADDRESS 2
        volatile uint32_t NTW_ADR_3;  ///< Offset: 0x38 - NETWORK ADDRESS 3
        volatile uint32_t RX_WATERMARK;  ///< Offset: 0x3C - RX WATERMARK
        volatile uint32_t DSM_CTRL;  ///< Offset: 0x40 - DSM CONTROL
        volatile uint32_t PART_ID;  ///< Offset: 0x44 - PART ID
        volatile uint32_t PACKET_BUFFER_0;  ///< Offset: 0x100 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_1;  ///< Offset: 0x102 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_2;  ///< Offset: 0x104 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_3;  ///< Offset: 0x106 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_4;  ///< Offset: 0x108 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_5;  ///< Offset: 0x10A - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_6;  ///< Offset: 0x10C - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_7;  ///< Offset: 0x10E - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_8;  ///< Offset: 0x110 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_9;  ///< Offset: 0x112 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_10;  ///< Offset: 0x114 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_11;  ///< Offset: 0x116 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_12;  ///< Offset: 0x118 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_13;  ///< Offset: 0x11A - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_14;  ///< Offset: 0x11C - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_15;  ///< Offset: 0x11E - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_16;  ///< Offset: 0x120 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_17;  ///< Offset: 0x122 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_18;  ///< Offset: 0x124 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_19;  ///< Offset: 0x126 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_20;  ///< Offset: 0x128 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_21;  ///< Offset: 0x12A - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_22;  ///< Offset: 0x12C - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_23;  ///< Offset: 0x12E - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_24;  ///< Offset: 0x130 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_25;  ///< Offset: 0x132 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_26;  ///< Offset: 0x134 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_27;  ///< Offset: 0x136 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_28;  ///< Offset: 0x138 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_29;  ///< Offset: 0x13A - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_30;  ///< Offset: 0x13C - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_31;  ///< Offset: 0x13E - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_32;  ///< Offset: 0x140 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_33;  ///< Offset: 0x142 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_34;  ///< Offset: 0x144 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_35;  ///< Offset: 0x146 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_36;  ///< Offset: 0x148 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_37;  ///< Offset: 0x14A - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_38;  ///< Offset: 0x14C - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_39;  ///< Offset: 0x14E - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_40;  ///< Offset: 0x150 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_41;  ///< Offset: 0x152 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_42;  ///< Offset: 0x154 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_43;  ///< Offset: 0x156 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_44;  ///< Offset: 0x158 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_45;  ///< Offset: 0x15A - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_46;  ///< Offset: 0x15C - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_47;  ///< Offset: 0x15E - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_48;  ///< Offset: 0x160 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_49;  ///< Offset: 0x162 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_50;  ///< Offset: 0x164 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_51;  ///< Offset: 0x166 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_52;  ///< Offset: 0x168 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_53;  ///< Offset: 0x16A - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_54;  ///< Offset: 0x16C - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_55;  ///< Offset: 0x16E - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_56;  ///< Offset: 0x170 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_57;  ///< Offset: 0x172 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_58;  ///< Offset: 0x174 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_59;  ///< Offset: 0x176 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_60;  ///< Offset: 0x178 - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_61;  ///< Offset: 0x17A - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_62;  ///< Offset: 0x17C - PACKET BUFFER
        volatile uint32_t PACKET_BUFFER_63;  ///< Offset: 0x17E - PACKET BUFFER
    };

    /// Peripheral instances
    inline Registers* ANT_REGS = reinterpret_cast<Registers*>(ANT_REGS_BASE);

    // Bit definitions
    /// IRQ_CTRL Register bits
    namespace irq_ctrl_bits {
        constexpr uint32_t SEQ_END_IRQ = (1U << 0);  ///< Sequence End Interrupt
        constexpr uint32_t TX_IRQ = (1U << 1);  ///< TX Interrupt
        constexpr uint32_t RX_IRQ = (1U << 2);  ///< RX Interrupt
        constexpr uint32_t NTW_ADR_IRQ = (1U << 3);  ///< Network Address Match Interrupt
        constexpr uint32_t T1_IRQ = (1U << 4);  ///< Timer1 (T1) Compare Interrupt
        constexpr uint32_t T2_IRQ = (1U << 5);  ///< Timer2 (T2) Compare Interrupt
        constexpr uint32_t PLL_UNLOCK_IRQ = (1U << 6);  ///< PLL Unlock Interrupt
        constexpr uint32_t WAKE_IRQ = (1U << 7);  ///< Wake Interrrupt
        constexpr uint32_t RX_WATERMARK_IRQ = (1U << 8);  ///< RX Watermark Interrupt
        constexpr uint32_t TSM_IRQ = (1U << 9);  ///< TSM Interrupt
        constexpr uint32_t SEQ_END_IRQ_EN = (1U << 16);  ///< SEQ_END_IRQ Enable
        constexpr uint32_t TX_IRQ_EN = (1U << 17);  ///< TX_IRQ Enable
        constexpr uint32_t RX_IRQ_EN = (1U << 18);  ///< RX_IRQ Enable
        constexpr uint32_t NTW_ADR_IRQ_EN = (1U << 19);  ///< NTW_ADR_IRQ Enable
        constexpr uint32_t T1_IRQ_EN = (1U << 20);  ///< T1_IRQ Enable
        constexpr uint32_t T2_IRQ_EN = (1U << 21);  ///< T2_IRQ Enable
        constexpr uint32_t PLL_UNLOCK_IRQ_EN = (1U << 22);  ///< PLL_UNLOCK_IRQ Enable
        constexpr uint32_t WAKE_IRQ_EN = (1U << 23);  ///< WAKE_IRQ Enable
        constexpr uint32_t RX_WATERMARK_IRQ_EN = (1U << 24);  ///< RX_WATERMARK_IRQ Enable
        constexpr uint32_t TSM_IRQ_EN = (1U << 25);  ///< TSM_IRQ Enable
        constexpr uint32_t ANT_IRQ_EN = (1U << 26);  ///< ANT_IRQ Master Enable
        constexpr uint32_t CRC_IGNORE = (1U << 27);  ///< CRC Ignore
        constexpr uint32_t CRC_VALID = (1U << 31);  ///< CRC Valid
    }

    /// EVENT_TMR Register bits
    namespace event_tmr_bits {
        constexpr uint32_t EVENT_TMR = (24 << 0);  ///< Event Timer
        constexpr uint32_t EVENT_TMR_LD = (1U << 24);  ///< Event Timer Load
        constexpr uint32_t EVENT_TMR_ADD = (1U << 25);  ///< Event Timer Add
    }

    /// T1_CMP Register bits
    namespace t1_cmp_bits {
        constexpr uint32_t T1_CMP = (24 << 0);  ///< Timer1 (T1) Compare Value
        constexpr uint32_t T1_CMP_EN = (1U << 24);  ///< Timer1 (T1) Compare Enable
    }

    /// T2_CMP Register bits
    namespace t2_cmp_bits {
        constexpr uint32_t T2_CMP = (24 << 0);  ///< Timer2 (T2) Compare Value
        constexpr uint32_t T2_CMP_EN = (1U << 24);  ///< Timer2 (T2) Compare Enable
    }

    /// TIMESTAMP Register bits
    namespace timestamp_bits {
        constexpr uint32_t TIMESTAMP = (24 << 0);  ///< Received Packet Timestamp
    }

    /// XCVR_CTRL Register bits
    namespace xcvr_ctrl_bits {
        constexpr uint32_t SEQCMD = (4 << 0);  ///< Sequence Commands
        constexpr uint32_t TX_PKT_LENGTH = (6 << 8);  ///< Transmit Packet Length
        constexpr uint32_t RX_PKT_LENGTH = (6 << 16);  ///< Receive Packet Length
        constexpr uint32_t CMDDEC_CS = (3 << 24);  ///< Command Decode
        constexpr uint32_t XCVR_BUSY = (1U << 31);  ///< Transceiver Busy
    }

    /// XCVR_STS Register bits
    namespace xcvr_sts_bits {
        constexpr uint32_t TX_START_T1_PEND = (1U << 0);  ///< TX T1 Start Pending Status
        constexpr uint32_t TX_START_T2_PEND = (1U << 1);  ///< TX T2 Start Pending Status
        constexpr uint32_t TX_IN_WARMUP = (1U << 2);  ///< TX Warmup Status
        constexpr uint32_t TX_IN_PROGRESS = (1U << 3);  ///< TX in Progress Status
        constexpr uint32_t TX_IN_WARMDN = (1U << 4);  ///< TX Warmdown Status
        constexpr uint32_t RX_START_T1_PEND = (1U << 5);  ///< RX T1 Start Pending Status
        constexpr uint32_t RX_START_T2_PEND = (1U << 6);  ///< RX T2 Start Pending Status
        constexpr uint32_t RX_STOP_T1_PEND = (1U << 7);  ///< RX T1 Stop Pending Status
        constexpr uint32_t RX_STOP_T2_PEND = (1U << 8);  ///< RX T2 Start Pending Status
        constexpr uint32_t RX_IN_WARMUP = (1U << 9);  ///< RX Warmup Status
        constexpr uint32_t RX_IN_SEARCH = (1U << 10);  ///< RX Search Status
        constexpr uint32_t RX_IN_PROGRESS = (1U << 11);  ///< RX in Progress Status
        constexpr uint32_t RX_IN_WARMDN = (1U << 12);  ///< RX Warmdown Status
        constexpr uint32_t CRC_VALID = (1U << 15);  ///< CRC Valid Indicator
        constexpr uint32_t RSSI = (8 << 16);  ///< Received Signal Stength Indicator
    }

    /// XCVR_CFG Register bits
    namespace xcvr_cfg_bits {
        constexpr uint32_t TX_WHITEN_DIS = (1U << 0);  ///< TX Whitening Disable
        constexpr uint32_t RX_DEWHITEN_DIS = (1U << 1);  ///< RX De-Whitening Disable
        constexpr uint32_t SW_CRC_EN = (1U << 2);  ///< Software CRC Enable
        constexpr uint32_t PREAMBLE_SZ = (2 << 4);  ///< Preamble Size
        constexpr uint32_t TX_WARMUP = (8 << 8);  ///< Transmit Warmup Time
        constexpr uint32_t RX_WARMUP = (8 << 16);  ///< Receive Warmup Time
    }

    /// CHANNEL_NUM Register bits
    namespace channel_num_bits {
        constexpr uint32_t CHANNEL_NUM = (7 << 0);  ///< Channel Number
    }

    /// TX_POWER Register bits
    namespace tx_power_bits {
        constexpr uint32_t TX_POWER = (6 << 0);  ///< Transmit Power
    }

    /// NTW_ADR_CTRL Register bits
    namespace ntw_adr_ctrl_bits {
        constexpr uint32_t NTW_ADR_EN = (4 << 0);  ///< Network Address Match Enable
        constexpr uint32_t NTW_ADR_MCH = (4 << 4);  ///< Network Address Match Status
        constexpr uint32_t NTW_ADR0_SZ = (2 << 8);  ///< Network Address Match Size
        constexpr uint32_t NTW_ADR1_SZ = (2 << 10);  ///< Network Address Match Size
        constexpr uint32_t NTW_ADR2_SZ = (2 << 12);  ///< Network Address Match Size
        constexpr uint32_t NTW_ADR3_SZ = (2 << 14);  ///< Network Address Match Size
        constexpr uint32_t NTW_ADR_THR0 = (3 << 16);  ///< Network Address Match Bit Error Threshold 0
        constexpr uint32_t NTW_ADR_THR1 = (3 << 20);  ///< Network Address Match Bit Error Threshold 1
        constexpr uint32_t NTW_ADR_THR2 = (3 << 24);  ///< Network Address Match Bit Error Threshold 2
        constexpr uint32_t NTW_ADR_THR3 = (3 << 28);  ///< Network Address Match Bit Error Threshold 3
    }

    /// NTW_ADR_0 Register bits
    namespace ntw_adr_0_bits {
        constexpr uint32_t NTW_ADR_0 = (32 << 0);  ///< Network Address 0
    }

    /// NTW_ADR_1 Register bits
    namespace ntw_adr_1_bits {
        constexpr uint32_t NTW_ADR_1 = (32 << 0);  ///< Network Address 1
    }

    /// NTW_ADR_2 Register bits
    namespace ntw_adr_2_bits {
        constexpr uint32_t NTW_ADR_2 = (32 << 0);  ///< Network Address 2
    }

    /// NTW_ADR_3 Register bits
    namespace ntw_adr_3_bits {
        constexpr uint32_t NTW_ADR_3 = (32 << 0);  ///< Network Address 2
    }

    /// RX_WATERMARK Register bits
    namespace rx_watermark_bits {
        constexpr uint32_t RX_WATERMARK = (7 << 0);  ///< RX Watermark
        constexpr uint32_t BYTE_COUNTER = (7 << 16);  ///< Byte Counter
    }

    /// DSM_CTRL Register bits
    namespace dsm_ctrl_bits {
        constexpr uint32_t ANT_SLEEP_EN = (1U << 0);  ///< ANT DSM Sleep Enable
    }

    /// PART_ID Register bits
    namespace part_id_bits {
        constexpr uint32_t PART_ID = (8 << 0);  ///< Part ID
    }

    /// PACKET_BUFFER_0 Register bits
    namespace packet_buffer_0_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_1 Register bits
    namespace packet_buffer_1_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_2 Register bits
    namespace packet_buffer_2_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_3 Register bits
    namespace packet_buffer_3_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_4 Register bits
    namespace packet_buffer_4_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_5 Register bits
    namespace packet_buffer_5_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_6 Register bits
    namespace packet_buffer_6_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_7 Register bits
    namespace packet_buffer_7_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_8 Register bits
    namespace packet_buffer_8_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_9 Register bits
    namespace packet_buffer_9_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_10 Register bits
    namespace packet_buffer_10_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_11 Register bits
    namespace packet_buffer_11_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_12 Register bits
    namespace packet_buffer_12_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_13 Register bits
    namespace packet_buffer_13_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_14 Register bits
    namespace packet_buffer_14_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_15 Register bits
    namespace packet_buffer_15_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_16 Register bits
    namespace packet_buffer_16_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_17 Register bits
    namespace packet_buffer_17_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_18 Register bits
    namespace packet_buffer_18_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_19 Register bits
    namespace packet_buffer_19_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_20 Register bits
    namespace packet_buffer_20_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_21 Register bits
    namespace packet_buffer_21_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_22 Register bits
    namespace packet_buffer_22_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_23 Register bits
    namespace packet_buffer_23_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_24 Register bits
    namespace packet_buffer_24_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_25 Register bits
    namespace packet_buffer_25_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_26 Register bits
    namespace packet_buffer_26_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_27 Register bits
    namespace packet_buffer_27_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_28 Register bits
    namespace packet_buffer_28_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_29 Register bits
    namespace packet_buffer_29_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_30 Register bits
    namespace packet_buffer_30_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_31 Register bits
    namespace packet_buffer_31_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_32 Register bits
    namespace packet_buffer_32_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_33 Register bits
    namespace packet_buffer_33_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_34 Register bits
    namespace packet_buffer_34_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_35 Register bits
    namespace packet_buffer_35_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_36 Register bits
    namespace packet_buffer_36_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_37 Register bits
    namespace packet_buffer_37_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_38 Register bits
    namespace packet_buffer_38_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_39 Register bits
    namespace packet_buffer_39_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_40 Register bits
    namespace packet_buffer_40_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_41 Register bits
    namespace packet_buffer_41_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_42 Register bits
    namespace packet_buffer_42_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_43 Register bits
    namespace packet_buffer_43_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_44 Register bits
    namespace packet_buffer_44_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_45 Register bits
    namespace packet_buffer_45_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_46 Register bits
    namespace packet_buffer_46_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_47 Register bits
    namespace packet_buffer_47_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_48 Register bits
    namespace packet_buffer_48_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_49 Register bits
    namespace packet_buffer_49_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_50 Register bits
    namespace packet_buffer_50_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_51 Register bits
    namespace packet_buffer_51_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_52 Register bits
    namespace packet_buffer_52_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_53 Register bits
    namespace packet_buffer_53_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_54 Register bits
    namespace packet_buffer_54_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_55 Register bits
    namespace packet_buffer_55_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_56 Register bits
    namespace packet_buffer_56_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_57 Register bits
    namespace packet_buffer_57_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_58 Register bits
    namespace packet_buffer_58_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_59 Register bits
    namespace packet_buffer_59_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_60 Register bits
    namespace packet_buffer_60_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_61 Register bits
    namespace packet_buffer_61_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_62 Register bits
    namespace packet_buffer_62_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

    /// PACKET_BUFFER_63 Register bits
    namespace packet_buffer_63_bits {
        constexpr uint32_t PACKET_BUFFER = (16 << 0);  ///< PACKET BUFFER RAM
    }

}

// ============================================================================
// GENFSK Peripheral
// ============================================================================

namespace genfsk {
    /// Base addresses
    constexpr uint32_t GENFSK_REGS_BASE = 0x4005F000;

    /// GENFSK Register structure
    struct Registers {
        volatile uint32_t IRQ_CTRL;  ///< Offset: 0x00 - IRQ CONTROL
        volatile uint32_t EVENT_TMR;  ///< Offset: 0x04 - EVENT TIMER
        volatile uint32_t T1_CMP;  ///< Offset: 0x08 - T1 COMPARE
        volatile uint32_t T2_CMP;  ///< Offset: 0x0C - T2 COMPARE
        volatile uint32_t TIMESTAMP;  ///< Offset: 0x10 - TIMESTAMP
        volatile uint32_t XCVR_CTRL;  ///< Offset: 0x14 - TRANSCEIVER CONTROL
        volatile uint32_t XCVR_STS;  ///< Offset: 0x18 - TRANSCEIVER STATUS
        volatile uint32_t XCVR_CFG;  ///< Offset: 0x1C - TRANSCEIVER CONFIGURATION
        volatile uint32_t CHANNEL_NUM;  ///< Offset: 0x20 - CHANNEL NUMBER
        volatile uint32_t TX_POWER;  ///< Offset: 0x24 - TRANSMIT POWER
        volatile uint32_t NTW_ADR_CTRL;  ///< Offset: 0x28 - NETWORK ADDRESS CONTROL
        volatile uint32_t NTW_ADR_0;  ///< Offset: 0x2C - NETWORK ADDRESS 0
        volatile uint32_t NTW_ADR_1;  ///< Offset: 0x30 - NETWORK ADDRESS 1
        volatile uint32_t NTW_ADR_2;  ///< Offset: 0x34 - NETWORK ADDRESS 2
        volatile uint32_t NTW_ADR_3;  ///< Offset: 0x38 - NETWORK ADDRESS 3
        volatile uint32_t RX_WATERMARK;  ///< Offset: 0x3C - RECEIVE WATERMARK
        volatile uint32_t DSM_CTRL;  ///< Offset: 0x40 - DSM CONTROL
        volatile uint32_t PART_ID;  ///< Offset: 0x44 - PART ID
        volatile uint32_t PACKET_CFG;  ///< Offset: 0x60 - PACKET CONFIGURATION
        volatile uint32_t H0_CFG;  ///< Offset: 0x64 - H0 CONFIGURATION
        volatile uint32_t H1_CFG;  ///< Offset: 0x68 - H1 CONFIGURATION
        volatile uint32_t CRC_CFG;  ///< Offset: 0x6C - CRC CONFIGURATION
        volatile uint32_t CRC_INIT;  ///< Offset: 0x70 - CRC INITIALIZATION
        volatile uint32_t CRC_POLY;  ///< Offset: 0x74 - CRC POLYNOMIAL
        volatile uint32_t CRC_XOR_OUT;  ///< Offset: 0x78 - CRC XOR OUT
        volatile uint32_t WHITEN_CFG;  ///< Offset: 0x7C - WHITENER CONFIGURATION
        volatile uint32_t WHITEN_POLY;  ///< Offset: 0x80 - WHITENER POLYNOMIAL
        volatile uint32_t WHITEN_SZ_THR;  ///< Offset: 0x84 - WHITENER SIZE THRESHOLD
        volatile uint32_t BITRATE;  ///< Offset: 0x88 - BIT RATE
        volatile uint32_t PB_PARTITION;  ///< Offset: 0x8C - PACKET BUFFER PARTITION POINT
    };

    /// Peripheral instances
    inline Registers* GENFSK_REGS = reinterpret_cast<Registers*>(GENFSK_REGS_BASE);

    // Bit definitions
    /// IRQ_CTRL Register bits
    namespace irq_ctrl_bits {
        constexpr uint32_t SEQ_END_IRQ = (1U << 0);  ///< Sequence End Interrupt
        constexpr uint32_t TX_IRQ = (1U << 1);  ///< TX Interrupt
        constexpr uint32_t RX_IRQ = (1U << 2);  ///< RX Interrupt
        constexpr uint32_t NTW_ADR_IRQ = (1U << 3);  ///< Network Address Match Interrupt
        constexpr uint32_t T1_IRQ = (1U << 4);  ///< Timer1 (T1) Compare Interrupt
        constexpr uint32_t T2_IRQ = (1U << 5);  ///< Timer2 (T2) Compare Interrupt
        constexpr uint32_t PLL_UNLOCK_IRQ = (1U << 6);  ///< PLL Unlock Interrupt
        constexpr uint32_t WAKE_IRQ = (1U << 7);  ///< Wake Interrrupt
        constexpr uint32_t RX_WATERMARK_IRQ = (1U << 8);  ///< RX Watermark Interrupt
        constexpr uint32_t TSM_IRQ = (1U << 9);  ///< TSM Interrupt
        constexpr uint32_t SEQ_END_IRQ_EN = (1U << 16);  ///< SEQ_END_IRQ Enable
        constexpr uint32_t TX_IRQ_EN = (1U << 17);  ///< TX_IRQ Enable
        constexpr uint32_t RX_IRQ_EN = (1U << 18);  ///< RX_IRQ Enable
        constexpr uint32_t NTW_ADR_IRQ_EN = (1U << 19);  ///< NTW_ADR_IRQ Enable
        constexpr uint32_t T1_IRQ_EN = (1U << 20);  ///< T1_IRQ Enable
        constexpr uint32_t T2_IRQ_EN = (1U << 21);  ///< T2_IRQ Enable
        constexpr uint32_t PLL_UNLOCK_IRQ_EN = (1U << 22);  ///< PLL_UNLOCK_IRQ Enable
        constexpr uint32_t WAKE_IRQ_EN = (1U << 23);  ///< WAKE_IRQ Enable
        constexpr uint32_t RX_WATERMARK_IRQ_EN = (1U << 24);  ///< RX_WATERMARK_IRQ Enable
        constexpr uint32_t TSM_IRQ_EN = (1U << 25);  ///< TSM_IRQ Enable
        constexpr uint32_t GENERIC_FSK_IRQ_EN = (1U << 26);  ///< GENERIC_FSK_IRQ Master Enable
        constexpr uint32_t CRC_IGNORE = (1U << 27);  ///< CRC Ignore
        constexpr uint32_t CRC_VALID = (1U << 31);  ///< CRC Valid
    }

    /// EVENT_TMR Register bits
    namespace event_tmr_bits {
        constexpr uint32_t EVENT_TMR = (24 << 0);  ///< Event Timer
        constexpr uint32_t EVENT_TMR_LD = (1U << 24);  ///< Event Timer Load
        constexpr uint32_t EVENT_TMR_ADD = (1U << 25);  ///< Event Timer Add
    }

    /// T1_CMP Register bits
    namespace t1_cmp_bits {
        constexpr uint32_t T1_CMP = (24 << 0);  ///< Timer1 (T1) Compare Value
        constexpr uint32_t T1_CMP_EN = (1U << 24);  ///< Timer1 (T1) Compare Enable
    }

    /// T2_CMP Register bits
    namespace t2_cmp_bits {
        constexpr uint32_t T2_CMP = (24 << 0);  ///< Timer2 (T2) Compare Value
        constexpr uint32_t T2_CMP_EN = (1U << 24);  ///< Timer2 (T2) Compare Enable
    }

    /// TIMESTAMP Register bits
    namespace timestamp_bits {
        constexpr uint32_t TIMESTAMP = (24 << 0);  ///< Received Packet Timestamp
    }

    /// XCVR_CTRL Register bits
    namespace xcvr_ctrl_bits {
        constexpr uint32_t SEQCMD = (4 << 0);  ///< Sequence Commands
        constexpr uint32_t CMDDEC_CS = (3 << 24);  ///< Command Decode
        constexpr uint32_t XCVR_BUSY = (1U << 31);  ///< Transceiver Busy
    }

    /// XCVR_STS Register bits
    namespace xcvr_sts_bits {
        constexpr uint32_t TX_START_T1_PEND = (1U << 0);  ///< TX T1 Start Pending Status
        constexpr uint32_t TX_START_T2_PEND = (1U << 1);  ///< TX T2 Start Pending Status
        constexpr uint32_t TX_IN_WARMUP = (1U << 2);  ///< TX Warmup Status
        constexpr uint32_t TX_IN_PROGRESS = (1U << 3);  ///< TX in Progress Status
        constexpr uint32_t TX_IN_WARMDN = (1U << 4);  ///< TX Warmdown Status
        constexpr uint32_t RX_START_T1_PEND = (1U << 5);  ///< RX T1 Start Pending Status
        constexpr uint32_t RX_START_T2_PEND = (1U << 6);  ///< RX T2 Start Pending Status
        constexpr uint32_t RX_STOP_T1_PEND = (1U << 7);  ///< RX T1 Stop Pending Status
        constexpr uint32_t RX_STOP_T2_PEND = (1U << 8);  ///< RX T2 Start Pending Status
        constexpr uint32_t RX_IN_WARMUP = (1U << 9);  ///< RX Warmup Status
        constexpr uint32_t RX_IN_SEARCH = (1U << 10);  ///< RX Search Status
        constexpr uint32_t RX_IN_PROGRESS = (1U << 11);  ///< RX in Progress Status
        constexpr uint32_t RX_IN_WARMDN = (1U << 12);  ///< RX Warmdown Status
        constexpr uint32_t LQI_VALID = (1U << 14);  ///< LQI Valid Indicator
        constexpr uint32_t CRC_VALID = (1U << 15);  ///< CRC Valid Indicator
        constexpr uint32_t RSSI = (8 << 16);  ///< Received Signal Stength Indicator, in dBm
        constexpr uint32_t LQI = (8 << 24);  ///< Link Quality Indicator
    }

    /// XCVR_CFG Register bits
    namespace xcvr_cfg_bits {
        constexpr uint32_t TX_WHITEN_DIS = (1U << 0);  ///< TX Whitening Disable
        constexpr uint32_t RX_DEWHITEN_DIS = (1U << 1);  ///< RX De-Whitening Disable
        constexpr uint32_t SW_CRC_EN = (1U << 2);  ///< Software CRC Enable
        constexpr uint32_t PREAMBLE_SZ = (3 << 4);  ///< Preamble Size
        constexpr uint32_t TX_WARMUP = (8 << 8);  ///< Transmit Warmup Time
        constexpr uint32_t RX_WARMUP = (8 << 16);  ///< Receive Warmup Time
    }

    /// CHANNEL_NUM Register bits
    namespace channel_num_bits {
        constexpr uint32_t CHANNEL_NUM = (7 << 0);  ///< Channel Number
    }

    /// TX_POWER Register bits
    namespace tx_power_bits {
        constexpr uint32_t TX_POWER = (6 << 0);  ///< Transmit Power
    }

    /// NTW_ADR_CTRL Register bits
    namespace ntw_adr_ctrl_bits {
        constexpr uint32_t NTW_ADR_EN = (4 << 0);  ///< Network Address Enable
        constexpr uint32_t NTW_ADR_MCH = (4 << 4);  ///< Network Address Match
        constexpr uint32_t NTW_ADR0_SZ = (2 << 8);  ///< Network Address 0 Size
        constexpr uint32_t NTW_ADR1_SZ = (2 << 10);  ///< Network Address 1 Size
        constexpr uint32_t NTW_ADR2_SZ = (2 << 12);  ///< Network Address 2 Size
        constexpr uint32_t NTW_ADR3_SZ = (2 << 14);  ///< Network Address 3 Size
        constexpr uint32_t NTW_ADR_THR0 = (3 << 16);  ///< Network Address 0 Threshold
        constexpr uint32_t NTW_ADR_THR1 = (3 << 20);  ///< Network Address 1 Threshold
        constexpr uint32_t NTW_ADR_THR2 = (3 << 24);  ///< Network Address 2 Threshold
        constexpr uint32_t NTW_ADR_THR3 = (3 << 28);  ///< Network Address 3 Threshold
    }

    /// NTW_ADR_0 Register bits
    namespace ntw_adr_0_bits {
        constexpr uint32_t NTW_ADR_0 = (32 << 0);  ///< Network Address 0
    }

    /// NTW_ADR_1 Register bits
    namespace ntw_adr_1_bits {
        constexpr uint32_t NTW_ADR_1 = (32 << 0);  ///< Network Address 1
    }

    /// NTW_ADR_2 Register bits
    namespace ntw_adr_2_bits {
        constexpr uint32_t NTW_ADR_2 = (32 << 0);  ///< Network Address 2
    }

    /// NTW_ADR_3 Register bits
    namespace ntw_adr_3_bits {
        constexpr uint32_t NTW_ADR_3 = (32 << 0);  ///< Network Address 2
    }

    /// RX_WATERMARK Register bits
    namespace rx_watermark_bits {
        constexpr uint32_t RX_WATERMARK = (13 << 0);  ///< Receive Watermark
        constexpr uint32_t BYTE_COUNTER = (13 << 16);  ///< Byte Counter
    }

    /// DSM_CTRL Register bits
    namespace dsm_ctrl_bits {
        constexpr uint32_t GENERIC_FSK_SLEEP_EN = (1U << 0);  ///< GENERIC_FSK DSM Sleep Enable
    }

    /// PART_ID Register bits
    namespace part_id_bits {
        constexpr uint32_t PART_ID = (8 << 0);  ///< Part ID
    }

    /// PACKET_CFG Register bits
    namespace packet_cfg_bits {
        constexpr uint32_t LENGTH_SZ = (5 << 0);  ///< LENGTH Size
        constexpr uint32_t LENGTH_BIT_ORD = (1U << 5);  ///< LENGTH Bit Order
        constexpr uint32_t SYNC_ADDR_SZ = (2 << 6);  ///< Sync Address Size
        constexpr uint32_t LENGTH_ADJ = (6 << 8);  ///< Length Adjustment
        constexpr uint32_t LENGTH_FAIL = (1U << 15);  ///< Maximum Length Violated Status Bit
        constexpr uint32_t H0_SZ = (5 << 16);  ///< H0 Size
        constexpr uint32_t H0_FAIL = (1U << 23);  ///< H0 Violated Status Bit
        constexpr uint32_t H1_SZ = (5 << 24);  ///< H1 Size
        constexpr uint32_t H1_FAIL = (1U << 31);  ///< H1 Violated Status Bit
    }

    /// H0_CFG Register bits
    namespace h0_cfg_bits {
        constexpr uint32_t H0_MATCH = (16 << 0);  ///< H0 Match Register
        constexpr uint32_t H0_MASK = (16 << 16);  ///< H0 Mask Register
    }

    /// H1_CFG Register bits
    namespace h1_cfg_bits {
        constexpr uint32_t H1_MATCH = (16 << 0);  ///< H1 Match Register
        constexpr uint32_t H1_MASK = (16 << 16);  ///< H1 Mask Register
    }

    /// CRC_CFG Register bits
    namespace crc_cfg_bits {
        constexpr uint32_t CRC_SZ = (3 << 0);  ///< CRC Size (in octets)
        constexpr uint32_t CRC_START_BYTE = (4 << 8);  ///< Configure CRC Start Point
        constexpr uint32_t CRC_REF_IN = (1U << 16);  ///< CRC Reflect In
        constexpr uint32_t CRC_REF_OUT = (1U << 17);  ///< CRC Reflect Out
        constexpr uint32_t CRC_BYTE_ORD = (1U << 18);  ///< CRC Byte Order
    }

    /// CRC_INIT Register bits
    namespace crc_init_bits {
        constexpr uint32_t CRC_SEED = (32 << 0);  ///< CRC Seed Value
    }

    /// CRC_POLY Register bits
    namespace crc_poly_bits {
        constexpr uint32_t CRC_POLY = (32 << 0);  ///< CRC Polynomial.
    }

    /// CRC_XOR_OUT Register bits
    namespace crc_xor_out_bits {
        constexpr uint32_t CRC_XOR_OUT = (32 << 0);  ///< CRC XOR OUT Register
    }

    /// WHITEN_CFG Register bits
    namespace whiten_cfg_bits {
        constexpr uint32_t WHITEN_START = (2 << 0);  ///< Configure Whitener Start Point
        constexpr uint32_t WHITEN_END = (1U << 2);  ///< Configure end-of-whitening
        constexpr uint32_t WHITEN_B4_CRC = (1U << 3);  ///< Congifure for Whitening-before-CRC
        constexpr uint32_t WHITEN_POLY_TYPE = (1U << 4);  ///< Whiten Polynomial Type
        constexpr uint32_t WHITEN_REF_IN = (1U << 5);  ///< Whiten Reflect Input
        constexpr uint32_t WHITEN_PAYLOAD_REINIT = (1U << 6);  ///< Configure for Whitener re-initialization
        constexpr uint32_t WHITEN_SIZE = (4 << 8);  ///< Length of Whitener LFSR
        constexpr uint32_t MANCHESTER_EN = (1U << 12);  ///< Configure for Manchester Encoding/Decoding
        constexpr uint32_t MANCHESTER_INV = (1U << 13);  ///< Configure for Inverted Manchester Encoding
        constexpr uint32_t MANCHESTER_START = (1U << 14);  ///< Configure Manchester Encoding Start Point
        constexpr uint32_t WHITEN_INIT = (9 << 16);  ///< Initialization Value for Whitening/De-whitening
    }

    /// WHITEN_POLY Register bits
    namespace whiten_poly_bits {
        constexpr uint32_t WHITEN_POLY = (9 << 0);  ///< Whitener Polynomial
    }

    /// WHITEN_SZ_THR Register bits
    namespace whiten_sz_thr_bits {
        constexpr uint32_t WHITEN_SZ_THR = (12 << 0);  ///< Whitener Size Threshold
        constexpr uint32_t LENGTH_MAX = (7 << 16);  ///< Maximum Length for Received Packets
        constexpr uint32_t REC_BAD_PKT = (1U << 23);  ///< Receive Bad Packets
    }

    /// BITRATE Register bits
    namespace bitrate_bits {
        constexpr uint32_t BITRATE = (2 << 0);  ///< Bit Rate
    }

    /// PB_PARTITION Register bits
    namespace pb_partition_bits {
        constexpr uint32_t PB_PARTITION = (11 << 0);  ///< Packet Buffer Partition Point
    }

}

// ============================================================================
// CMT Peripheral
// ============================================================================

namespace cmt {
    /// Base addresses
    constexpr uint32_t CMT_BASE = 0x40062000;

    /// CMT Register structure
    struct Registers {
        volatile uint32_t CGH1;  ///< Offset: 0x00 - CMT Carrier Generator High Data Register 1
        volatile uint32_t CGL1;  ///< Offset: 0x01 - CMT Carrier Generator Low Data Register 1
        volatile uint32_t CGH2;  ///< Offset: 0x02 - CMT Carrier Generator High Data Register 2
        volatile uint32_t CGL2;  ///< Offset: 0x03 - CMT Carrier Generator Low Data Register 2
        volatile uint32_t OC;  ///< Offset: 0x04 - CMT Output Control Register
        volatile uint32_t MSC;  ///< Offset: 0x05 - CMT Modulator Status and Control Register
        volatile uint32_t CMD1;  ///< Offset: 0x06 - CMT Modulator Data Register Mark High
        volatile uint32_t CMD2;  ///< Offset: 0x07 - CMT Modulator Data Register Mark Low
        volatile uint32_t CMD3;  ///< Offset: 0x08 - CMT Modulator Data Register Space High
        volatile uint32_t CMD4;  ///< Offset: 0x09 - CMT Modulator Data Register Space Low
        volatile uint32_t PPS;  ///< Offset: 0x0A - CMT Primary Prescaler Register
        volatile uint32_t DMA;  ///< Offset: 0x0B - CMT Direct Memory Access Register
    };

    /// Peripheral instances
    inline Registers* CMT = reinterpret_cast<Registers*>(CMT_BASE);

    // Bit definitions
    /// CGH1 Register bits
    namespace cgh1_bits {
        constexpr uint32_t PH = (8 << 0);  ///< Primary Carrier High Time Data Value
    }

    /// CGL1 Register bits
    namespace cgl1_bits {
        constexpr uint32_t PL = (8 << 0);  ///< Primary Carrier Low Time Data Value
    }

    /// CGH2 Register bits
    namespace cgh2_bits {
        constexpr uint32_t SH = (8 << 0);  ///< Secondary Carrier High Time Data Value
    }

    /// CGL2 Register bits
    namespace cgl2_bits {
        constexpr uint32_t SL = (8 << 0);  ///< Secondary Carrier Low Time Data Value
    }

    /// OC Register bits
    namespace oc_bits {
        constexpr uint32_t IROPEN = (1U << 5);  ///< IRO Pin Enable
        constexpr uint32_t CMTPOL = (1U << 6);  ///< CMT Output Polarity
        constexpr uint32_t IROL = (1U << 7);  ///< IRO Latch Control
    }

    /// MSC Register bits
    namespace msc_bits {
        constexpr uint32_t MCGEN = (1U << 0);  ///< Modulator and Carrier Generator Enable
        constexpr uint32_t EOCIE = (1U << 1);  ///< End of Cycle Interrupt Enable
        constexpr uint32_t FSK = (1U << 2);  ///< FSK Mode Select
        constexpr uint32_t BASE = (1U << 3);  ///< Baseband Enable
        constexpr uint32_t EXSPC = (1U << 4);  ///< Extended Space Enable
        constexpr uint32_t CMTDIV = (2 << 5);  ///< CMT Clock Divide Prescaler
        constexpr uint32_t EOCF = (1U << 7);  ///< End Of Cycle Status Flag
    }

    /// CMD1 Register bits
    namespace cmd1_bits {
        constexpr uint32_t MB = (8 << 0);  ///< MB[15:8]
    }

    /// CMD2 Register bits
    namespace cmd2_bits {
        constexpr uint32_t MB = (8 << 0);  ///< MB[7:0]
    }

    /// CMD3 Register bits
    namespace cmd3_bits {
        constexpr uint32_t SB = (8 << 0);  ///< SB[15:8]
    }

    /// CMD4 Register bits
    namespace cmd4_bits {
        constexpr uint32_t SB = (8 << 0);  ///< SB[7:0]
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPSDIV = (4 << 0);  ///< Primary Prescaler Divider
    }

    /// DMA Register bits
    namespace dma_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t MCG_BASE = 0x40064000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - MCG Control 1 Register
        volatile uint32_t C2;  ///< Offset: 0x01 - MCG Control 2 Register
        volatile uint32_t C3;  ///< Offset: 0x02 - MCG Control 3 Register
        volatile uint32_t C4;  ///< Offset: 0x03 - MCG Control 4 Register
        volatile uint32_t C5;  ///< Offset: 0x04 - MCG Control 5 Register
        volatile uint32_t C6;  ///< Offset: 0x05 - MCG Control 6 Register
        volatile uint32_t S;  ///< Offset: 0x06 - MCG Status Register
        volatile uint32_t SC;  ///< Offset: 0x08 - MCG Status and Control Register
        volatile uint32_t ATCVH;  ///< Offset: 0x0A - MCG Auto Trim Compare Value High Register
        volatile uint32_t ATCVL;  ///< Offset: 0x0B - MCG Auto Trim Compare Value Low Register
        volatile uint32_t C7;  ///< Offset: 0x0C - MCG Control 7 Register
        volatile uint32_t C8;  ///< Offset: 0x0D - MCG Control 8 Register
    };

    /// Peripheral instances
    inline Registers* MCG = reinterpret_cast<Registers*>(MCG_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t IREFS = (1U << 2);  ///< Internal Reference Select
        constexpr uint32_t FRDIV = (3 << 3);  ///< FLL External Reference Divider
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t IRCS = (1U << 0);  ///< Internal Reference Clock Select
        constexpr uint32_t LP = (1U << 1);  ///< Low Power Select
        constexpr uint32_t EREFS = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE = (2 << 4);  ///< Frequency Range Select
        constexpr uint32_t FCFTRIM = (1U << 6);  ///< Fast Internal Reference Clock Fine Trim
        constexpr uint32_t LOCRE0 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t SCTRIM = (8 << 0);  ///< Slow Internal Reference Clock Trim Setting
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t SCFTRIM = (1U << 0);  ///< Slow Internal Reference Clock Fine Trim
        constexpr uint32_t FCTRIM = (4 << 1);  ///< Fast Internal Reference Clock Trim Setting
        constexpr uint32_t DRST_DRS = (2 << 5);  ///< DCO Range Select
        constexpr uint32_t DMX32 = (1U << 7);  ///< DCO Maximum Frequency with 32.768 kHz Reference
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t CME0 = (1U << 5);  ///< Clock Monitor Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t IRCST = (1U << 0);  ///< Internal Reference Clock Status
        constexpr uint32_t OSCINIT0 = (1U << 1);  ///< OSC Initialization
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
        constexpr uint32_t IREFST = (1U << 4);  ///< Internal Reference Status
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LOCS0 = (1U << 0);  ///< OSC0 Loss of Clock Status
        constexpr uint32_t FCRDIV = (3 << 1);  ///< Fast Clock Internal Reference Divider
        constexpr uint32_t FLTPRSRV = (1U << 4);  ///< FLL Filter Preserve Enable
        constexpr uint32_t ATMF = (1U << 5);  ///< Automatic Trim Machine Fail Flag
        constexpr uint32_t ATMS = (1U << 6);  ///< Automatic Trim Machine Select
        constexpr uint32_t ATME = (1U << 7);  ///< Automatic Trim Machine Enable
    }

    /// ATCVH Register bits
    namespace atcvh_bits {
        constexpr uint32_t ATCVH = (8 << 0);  ///< ATM Compare Value High
    }

    /// ATCVL Register bits
    namespace atcvl_bits {
        constexpr uint32_t ATCVL = (8 << 0);  ///< ATM Compare Value Low
    }

    /// C7 Register bits
    namespace c7_bits {
        constexpr uint32_t OSCSEL = (1U << 0);  ///< MCG OSC Clock Select
    }

    /// C8 Register bits
    namespace c8_bits {
        constexpr uint32_t LOCS1 = (1U << 0);  ///< RTC Loss of Clock Status
        constexpr uint32_t CME1 = (1U << 5);  ///< Clock Monitor Enable1
        constexpr uint32_t LOCRE1 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40066000;
    constexpr uint32_t I2C1_BASE = 0x40067000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S;  ///< Offset: 0x03 - I2C Status register
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter Register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
        volatile uint32_t S2;  ///< Offset: 0x0C - I2C Status register 2
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< ClockRate
        constexpr uint32_t MULT = (2 << 6);  ///< Multiplier Factor
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup Enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit Acknowledge Enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit Mode Select
        constexpr uint32_t MST = (1U << 5);  ///< Master Mode Select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C Interrupt Enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive Acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt Flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave Read/Write
        constexpr uint32_t RAM = (1U << 3);  ///< Range Address Match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration Lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus Busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed As A Slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer Complete Flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave Address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range Address Matching Enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave Baud Rate Control
        constexpr uint32_t HDRS = (1U << 5);  ///< High Drive Select
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address Extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General Call Address Enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (4 << 0);  ///< I2C Programmable Filter Factor
        constexpr uint32_t STARTF = (1U << 4);  ///< I2C Bus Start Detect Flag
        constexpr uint32_t SSIE = (1U << 5);  ///< I2C Bus Stop or Start Interrupt Enable
        constexpr uint32_t STOPF = (1U << 6);  ///< I2C Bus Stop Detect Flag
        constexpr uint32_t SHEN = (1U << 7);  ///< Stop Hold Enable
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RAD = (7 << 1);  ///< Range Slave Address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 Interrupt Enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL High Timeout Flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL High Timeout Flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL Low Timeout Flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout Counter Clock Select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C Address Enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus Alert Response Address Enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK Enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus Address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[15:8]
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[7:0]
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t EMPTY = (1U << 0);  ///< Empty flag
        constexpr uint32_t ERROR = (1U << 1);  ///< Error flag
        constexpr uint32_t DFEN = (1U << 2);  ///< Double Buffer Enable
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40073000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
        constexpr uint32_t PSTM = (1U << 7);  ///< Pass Through Mode Enable
    }

}

// ============================================================================
// VREF Peripheral
// ============================================================================

namespace vref {
    /// Base addresses
    constexpr uint32_t VREF_BASE = 0x40074000;

    /// VREF Register structure
    struct Registers {
        volatile uint32_t TRM;  ///< Offset: 0x00 - VREF Trim Register
        volatile uint32_t SC;  ///< Offset: 0x01 - VREF Status and Control Register
    };

    /// Peripheral instances
    inline Registers* VREF = reinterpret_cast<Registers*>(VREF_BASE);

    // Bit definitions
    /// TRM Register bits
    namespace trm_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trim bits
        constexpr uint32_t CHOPEN = (1U << 6);  ///< Chop oscillator enable. When set, internal chopping operation is enabled and the internal analog offset will be minimized.
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t MODE_LV = (2 << 0);  ///< Buffer Mode selection
        constexpr uint32_t VREFST = (1U << 2);  ///< Internal Voltage Reference stable
        constexpr uint32_t ICOMPEN = (1U << 5);  ///< Second order curvature compensation enable
        constexpr uint32_t REGEN = (1U << 6);  ///< Regulator enable
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Voltage Reference enable
    }

}

// ============================================================================
// LLWU Peripheral
// ============================================================================

namespace llwu {
    /// Base addresses
    constexpr uint32_t LLWU_BASE = 0x4007C000;

    /// LLWU Register structure
    struct Registers {
        volatile uint32_t PE1;  ///< Offset: 0x00 - LLWU Pin Enable 1 register
        volatile uint32_t PE2;  ///< Offset: 0x01 - LLWU Pin Enable 2 register
        volatile uint32_t PE3;  ///< Offset: 0x02 - LLWU Pin Enable 3 register
        volatile uint32_t PE4;  ///< Offset: 0x03 - LLWU Pin Enable 4 register
        volatile uint32_t ME;  ///< Offset: 0x04 - LLWU Module Enable register
        volatile uint32_t F1;  ///< Offset: 0x05 - LLWU Flag 1 register
        volatile uint32_t F2;  ///< Offset: 0x06 - LLWU Flag 2 register
        volatile uint32_t F3;  ///< Offset: 0x07 - LLWU Flag 3 register
        volatile uint32_t FILT1;  ///< Offset: 0x08 - LLWU Pin Filter 1 register
        volatile uint32_t FILT2;  ///< Offset: 0x09 - LLWU Pin Filter 2 register
    };

    /// Peripheral instances
    inline Registers* LLWU = reinterpret_cast<Registers*>(LLWU_BASE);

    // Bit definitions
    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P3
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE4 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P7
    }

    /// PE3 Register bits
    namespace pe3_bits {
        constexpr uint32_t WUPE8 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P11
    }

    /// PE4 Register bits
    namespace pe4_bits {
        constexpr uint32_t WUPE12 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P15
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable For Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable For Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable For Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable For Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable For Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable For Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable For Module 7
    }

    /// F1 Register bits
    namespace f1_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag For LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag For LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag For LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag For LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag For LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag For LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag For LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag For LLWU_P7
    }

    /// F2 Register bits
    namespace f2_bits {
        constexpr uint32_t WUF8 = (1U << 0);  ///< Wakeup Flag For LLWU_P8
        constexpr uint32_t WUF9 = (1U << 1);  ///< Wakeup Flag For LLWU_P9
        constexpr uint32_t WUF10 = (1U << 2);  ///< Wakeup Flag For LLWU_P10
        constexpr uint32_t WUF11 = (1U << 3);  ///< Wakeup Flag For LLWU_P11
        constexpr uint32_t WUF12 = (1U << 4);  ///< Wakeup Flag For LLWU_P12
        constexpr uint32_t WUF13 = (1U << 5);  ///< Wakeup Flag For LLWU_P13
        constexpr uint32_t WUF14 = (1U << 6);  ///< Wakeup Flag For LLWU_P14
        constexpr uint32_t WUF15 = (1U << 7);  ///< Wakeup Flag For LLWU_P15
    }

    /// F3 Register bits
    namespace f3_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag For module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag For module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag For module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag For module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag For module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag For module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag For module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag For module 7
    }

    /// FILT1 Register bits
    namespace filt1_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT2 Register bits
    namespace filt2_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status And Control 1 register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status And Control 2 register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status And Control register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDV = (2 << 0);  ///< Low-Voltage Detect Voltage Select
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low-Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low-Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low-Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWV = (2 << 0);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t REGONS = (1U << 2);  ///< Regulator In Run Regulation Status
        constexpr uint32_t ACKISO = (1U << 3);  ///< Acknowledge Isolation
        constexpr uint32_t VLPO = (1U << 6);  ///< VLPx Option
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t PMPROT;  ///< Offset: 0x00 - Power Mode Protection register
        volatile uint32_t PMCTRL;  ///< Offset: 0x01 - Power Mode Control register
        volatile uint32_t STOPCTRL;  ///< Offset: 0x02 - Stop Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x03 - Power Mode Status register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLLS = (1U << 1);  ///< Allow Very-Low-Leakage Stop Mode
        constexpr uint32_t ALLS = (1U << 3);  ///< Allow Low-Leakage Stop Mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very-Low-Power Modes
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
    }

    /// STOPCTRL Register bits
    namespace stopctrl_bits {
        constexpr uint32_t LLSM = (3 << 0);  ///< LLS or VLLS Mode Control
        constexpr uint32_t RAM2PO = (1U << 4);  ///< RAM2 Power Option
        constexpr uint32_t PORPO = (1U << 5);  ///< POR Power Option
        constexpr uint32_t PSTOPO = (2 << 6);  ///< Partial Stop Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (8 << 0);  ///< Power Mode Status
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007F000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t SRS0;  ///< Offset: 0x00 - System Reset Status Register 0
        volatile uint32_t SRS1;  ///< Offset: 0x01 - System Reset Status Register 1
        volatile uint32_t RPFC;  ///< Offset: 0x04 - Reset Pin Filter Control register
        volatile uint32_t RPFW;  ///< Offset: 0x05 - Reset Pin Filter Width register
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// SRS0 Register bits
    namespace srs0_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Low Leakage Wakeup Reset
        constexpr uint32_t LVD = (1U << 1);  ///< Low-Voltage Detect Reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-Clock Reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
    }

    /// SRS1 Register bits
    namespace srs1_bits {
        constexpr uint32_t LOCKUP = (1U << 1);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 2);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 3);  ///< MDM-AP System Reset Request
        constexpr uint32_t SACKERR = (1U << 5);  ///< Stop Mode Acknowledge Error Reset
    }

    /// RPFC Register bits
    namespace rpfc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset Pin Filter Select in Run and Wait Modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset Pin Filter Select in Stop Mode
    }

    /// RPFW Register bits
    namespace rpfw_bits {
        constexpr uint32_t RSTFLTSEL = (5 << 0);  ///< Reset Pin Filter Bus Clock Select
    }

}

// ============================================================================
// MTB Peripheral
// ============================================================================

namespace mtb {
    /// Base addresses
    constexpr uint32_t MTB_BASE = 0xF0000000;

    /// MTB Register structure
    struct Registers {
        volatile uint32_t POSITION;  ///< Offset: 0x00 - MTB Position Register
        volatile uint32_t MASTER;  ///< Offset: 0x04 - MTB Master Register
        volatile uint32_t FLOW;  ///< Offset: 0x08 - MTB Flow Register
        volatile uint32_t BASE;  ///< Offset: 0x0C - MTB Base Register
        volatile uint32_t MODECTRL;  ///< Offset: 0xF00 - Integration Mode Control Register
        volatile uint32_t TAGSET;  ///< Offset: 0xFA0 - Claim TAG Set Register
        volatile uint32_t TAGCLEAR;  ///< Offset: 0xFA4 - Claim TAG Clear Register
        volatile uint32_t LOCKACCESS;  ///< Offset: 0xFB0 - Lock Access Register
        volatile uint32_t LOCKSTAT;  ///< Offset: 0xFB4 - Lock Status Register
        volatile uint32_t AUTHSTAT;  ///< Offset: 0xFB8 - Authentication Status Register
        volatile uint32_t DEVICEARCH;  ///< Offset: 0xFBC - Device Architecture Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* MTB = reinterpret_cast<Registers*>(MTB_BASE);

    // Bit definitions
    /// POSITION Register bits
    namespace position_bits {
        constexpr uint32_t WRAP = (1U << 2);  ///< WRAP
        constexpr uint32_t POINTER = (29 << 3);  ///< Trace Packet Address Pointer[28:0]
    }

    /// MASTER Register bits
    namespace master_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< Mask
        constexpr uint32_t TSTARTEN = (1U << 5);  ///< Trace Start Input Enable
        constexpr uint32_t TSTOPEN = (1U << 6);  ///< Trace Stop Input Enable
        constexpr uint32_t SFRWPRIV = (1U << 7);  ///< Special Function Register Write Privilege
        constexpr uint32_t RAMPRIV = (1U << 8);  ///< RAM Privilege
        constexpr uint32_t HALTREQ = (1U << 9);  ///< Halt Request
        constexpr uint32_t EN = (1U << 31);  ///< Main Trace Enable
    }

    /// FLOW Register bits
    namespace flow_bits {
        constexpr uint32_t AUTOSTOP = (1U << 0);  ///< AUTOSTOP
        constexpr uint32_t AUTOHALT = (1U << 1);  ///< AUTOHALT
        constexpr uint32_t WATERMARK = (29 << 3);  ///< WATERMARK[28:0]
    }

    /// BASE Register bits
    namespace base_bits {
        constexpr uint32_t BASEADDR = (32 << 0);  ///< BASEADDR
    }

    /// MODECTRL Register bits
    namespace modectrl_bits {
        constexpr uint32_t MODECTRL = (32 << 0);  ///< MODECTRL
    }

    /// TAGSET Register bits
    namespace tagset_bits {
        constexpr uint32_t TAGSET = (32 << 0);  ///< TAGSET
    }

    /// TAGCLEAR Register bits
    namespace tagclear_bits {
        constexpr uint32_t TAGCLEAR = (32 << 0);  ///< TAGCLEAR
    }

    /// LOCKACCESS Register bits
    namespace lockaccess_bits {
        constexpr uint32_t LOCKACCESS = (32 << 0);  ///< Hardwired to 0x0000_0000
    }

    /// LOCKSTAT Register bits
    namespace lockstat_bits {
        constexpr uint32_t LOCKSTAT = (32 << 0);  ///< LOCKSTAT
    }

    /// AUTHSTAT Register bits
    namespace authstat_bits {
        constexpr uint32_t BIT0 = (1U << 0);  ///< Connected to DBGEN.
        constexpr uint32_t BIT1 = (1U << 1);  ///< BIT1
        constexpr uint32_t BIT2 = (1U << 2);  ///< BIT2
        constexpr uint32_t BIT3 = (1U << 3);  ///< BIT3
    }

    /// DEVICEARCH Register bits
    namespace devicearch_bits {
        constexpr uint32_t DEVICEARCH = (32 << 0);  ///< DEVICEARCH
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MTBDWT Peripheral
// ============================================================================

namespace mtbdwt {
    /// Base addresses
    constexpr uint32_t MTBDWT_BASE = 0xF0001000;

    /// MTBDWT Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - MTB DWT Control Register
        volatile uint32_t COMP;  ///< Offset: 0x20 - MTB_DWT Comparator Register (renamed from COMP)
        volatile uint32_t MASK;  ///< Offset: 0x24 - MTB_DWT Comparator Mask Register (renamed from MASK)
        volatile uint32_t FCT0;  ///< Offset: 0x28 - MTB_DWT Comparator Function Register 0
        volatile uint32_t FCT1;  ///< Offset: 0x38 - MTB_DWT Comparator Function Register 1
        volatile uint32_t TBCTRL;  ///< Offset: 0x200 - MTB_DWT Trace Buffer Control Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* MTBDWT = reinterpret_cast<Registers*>(MTBDWT_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t DWTCFGCTRL = (28 << 0);  ///< DWT configuration controls
        constexpr uint32_t NUMCMP = (4 << 28);  ///< Number of comparators
    }

    /// COMP Register bits
    namespace comp_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Reference value for comparison
    }

    /// MASK Register bits
    namespace mask_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< MASK
    }

    /// FCT0 Register bits
    namespace fct0_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< Data Value Match
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< Data Value Size
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< Data Value Address 0
        constexpr uint32_t MATCHED = (1U << 24);  ///< Comparator match
    }

    /// FCT1 Register bits
    namespace fct1_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function
        constexpr uint32_t MATCHED = (1U << 24);  ///< Comparator match
    }

    /// TBCTRL Register bits
    namespace tbctrl_bits {
        constexpr uint32_t ACOMP0 = (1U << 0);  ///< Action based on Comparator 0 match
        constexpr uint32_t ACOMP1 = (1U << 1);  ///< Action based on Comparator 1 match
        constexpr uint32_t NUMCOMP = (4 << 28);  ///< Number of Comparators
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// ROM Peripheral
// ============================================================================

namespace rom {
    /// Base addresses
    constexpr uint32_t ROM_BASE = 0xF0002000;

    /// ROM Register structure
    struct Registers {
        volatile uint32_t ENTRY;  ///< Offset: 0x00 - Entry (renamed from ENTRY)
        volatile uint32_t TABLEMARK;  ///< Offset: 0x0C - End of Table Marker Register
        volatile uint32_t SYSACCESS;  ///< Offset: 0xFCC - System Access Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* ROM = reinterpret_cast<Registers*>(ROM_BASE);

    // Bit definitions
    /// ENTRY Register bits
    namespace entry_bits {
        constexpr uint32_t ENTRY = (32 << 0);  ///< ENTRY
    }

    /// TABLEMARK Register bits
    namespace tablemark_bits {
        constexpr uint32_t MARK = (32 << 0);  ///< MARK
    }

    /// SYSACCESS Register bits
    namespace sysaccess_bits {
        constexpr uint32_t SYSACCESS = (32 << 0);  ///< SYSACCESS
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xF0003000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t PLACR;  ///< Offset: 0x0C - Platform Control Register
        volatile uint32_t CPO;  ///< Offset: 0x40 - Compute Operation Control Register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
    }

    /// PLACR Register bits
    namespace placr_bits {
        constexpr uint32_t ARB = (1U << 9);  ///< Arbitration select
        constexpr uint32_t CFCC = (1U << 10);  ///< Clear Flash Controller Cache
        constexpr uint32_t DFCDA = (1U << 11);  ///< Disable Flash Controller Data Caching
        constexpr uint32_t DFCIC = (1U << 12);  ///< Disable Flash Controller Instruction Caching
        constexpr uint32_t DFCC = (1U << 13);  ///< Disable Flash Controller Cache
        constexpr uint32_t EFDS = (1U << 14);  ///< Enable Flash Data Speculation
        constexpr uint32_t DFCS = (1U << 15);  ///< Disable Flash Controller Speculation
        constexpr uint32_t ESFC = (1U << 16);  ///< Enable Stalling Flash Controller
    }

    /// CPO Register bits
    namespace cpo_bits {
        constexpr uint32_t CPOREQ = (1U << 0);  ///< Compute Operation Request
        constexpr uint32_t CPOACK = (1U << 1);  ///< Compute Operation Acknowledge
        constexpr uint32_t CPOWOI = (1U << 2);  ///< Compute Operation Wake-up on Interrupt
    }

}


} // namespace alloy::generated::mkw31z4

#endif // ALLOY_GENERATED_MKW31Z4_PERIPHERALS_HPP