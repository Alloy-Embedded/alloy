/// Auto-generated code for MKW40Z4
/// Generated by Alloy Code Generator
/// Source: nxp_mkw40.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:01:15
#ifndef ALLOY_GENERATED_MKW40Z4_PERIPHERALS_HPP
#define ALLOY_GENERATED_MKW40Z4_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mkw40z4 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 2;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 5;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_tsi0 = true;
    constexpr uint32_t num_tsi0_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 9;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 1;
    constexpr bool has_ltc0 = true;
    constexpr uint32_t num_ltc0_instances = 1;
    constexpr bool has_rsim = true;
    constexpr uint32_t num_rsim_instances = 1;
    constexpr bool has_dcdc = true;
    constexpr uint32_t num_dcdc_instances = 1;
    constexpr bool has_radio = true;
    constexpr uint32_t num_radio_instances = 1;
    constexpr bool has_xcvr = true;
    constexpr uint32_t num_xcvr_instances = 1;
    constexpr bool has_zll = true;
    constexpr uint32_t num_zll_instances = 1;
    constexpr bool has_cmt = true;
    constexpr uint32_t num_cmt_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_llwu = true;
    constexpr uint32_t num_llwu_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_mtb = true;
    constexpr uint32_t num_mtb_instances = 1;
    constexpr bool has_mtbdwt = true;
    constexpr uint32_t num_mtbdwt_instances = 1;
    constexpr bool has_rom = true;
    constexpr uint32_t num_rom_instances = 1;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 9;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ltc0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rsim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcdc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct radio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct xcvr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct zll_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct llwu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtbdwt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rom_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 9;
    constexpr uint32_t max_gpio_pins = 144;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart0 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFA_FlashConfig_BASE = 0x00000400;
    constexpr uint32_t FTFA_BASE = 0x40020000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
    };

    /// Peripheral instances
    inline Registers* FTFA_FlashConfig = reinterpret_cast<Registers*>(FTFA_FlashConfig_BASE);
    inline Registers* FTFA = reinterpret_cast<Registers*>(FTFA_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT0 = (1U << 0);  ///< no description available
        constexpr uint32_t NMI_DIS = (1U << 2);  ///< no description available
        constexpr uint32_t RESET_PIN_CFG = (1U << 3);  ///< no description available
        constexpr uint32_t LPBOOT1 = (1U << 4);  ///< no description available
        constexpr uint32_t FAST_INIT = (1U << 5);  ///< no description available
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX0_BASE = 0x40021000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t SAR0;  ///< Offset: 0x100 - Source Address Register
        volatile uint32_t DAR0;  ///< Offset: 0x104 - Destination Address Register
        volatile uint32_t DSR_BCR0;  ///< Offset: 0x108 - DMA Status Register / Byte Count Register
        volatile uint32_t DSR0;  ///< Offset: 0x10B - DMA_DSR0 register.
        volatile uint32_t DCR0;  ///< Offset: 0x10C - DMA Control Register
        volatile uint32_t SAR1;  ///< Offset: 0x110 - Source Address Register
        volatile uint32_t DAR1;  ///< Offset: 0x114 - Destination Address Register
        volatile uint32_t DSR_BCR1;  ///< Offset: 0x118 - DMA Status Register / Byte Count Register
        volatile uint32_t DSR1;  ///< Offset: 0x11B - DMA_DSR1 register.
        volatile uint32_t DCR1;  ///< Offset: 0x11C - DMA Control Register
        volatile uint32_t SAR2;  ///< Offset: 0x120 - Source Address Register
        volatile uint32_t DAR2;  ///< Offset: 0x124 - Destination Address Register
        volatile uint32_t DSR_BCR2;  ///< Offset: 0x128 - DMA Status Register / Byte Count Register
        volatile uint32_t DSR2;  ///< Offset: 0x12B - DMA_DSR2 register.
        volatile uint32_t DCR2;  ///< Offset: 0x12C - DMA Control Register
        volatile uint32_t SAR3;  ///< Offset: 0x130 - Source Address Register
        volatile uint32_t DAR3;  ///< Offset: 0x134 - Destination Address Register
        volatile uint32_t DSR_BCR3;  ///< Offset: 0x138 - DMA Status Register / Byte Count Register
        volatile uint32_t DSR3;  ///< Offset: 0x13B - DMA_DSR3 register.
        volatile uint32_t DCR3;  ///< Offset: 0x13C - DMA Control Register
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX0 = reinterpret_cast<Registers*>(DMAMUX0_BASE);

    // Bit definitions
    /// SAR0 Register bits
    namespace sar0_bits {
        constexpr uint32_t SAR = (32 << 0);  ///< SAR
    }

    /// DAR0 Register bits
    namespace dar0_bits {
        constexpr uint32_t DAR = (32 << 0);  ///< DAR
    }

    /// DSR_BCR0 Register bits
    namespace dsr_bcr0_bits {
        constexpr uint32_t BCR = (24 << 0);  ///< BCR
        constexpr uint32_t DONE = (1U << 24);  ///< Transactions Done
        constexpr uint32_t BSY = (1U << 25);  ///< Busy
        constexpr uint32_t REQ = (1U << 26);  ///< Request
        constexpr uint32_t BED = (1U << 28);  ///< Bus Error on Destination
        constexpr uint32_t BES = (1U << 29);  ///< Bus Error on Source
        constexpr uint32_t CE = (1U << 30);  ///< Configuration Error
    }

    /// DCR0 Register bits
    namespace dcr0_bits {
        constexpr uint32_t LCH2 = (2 << 0);  ///< Link Channel 2
        constexpr uint32_t LCH1 = (2 << 2);  ///< Link Channel 1
        constexpr uint32_t LINKCC = (2 << 4);  ///< Link Channel Control
        constexpr uint32_t D_REQ = (1U << 7);  ///< Disable Request
        constexpr uint32_t DMOD = (4 << 8);  ///< Destination Address Modulo
        constexpr uint32_t SMOD = (4 << 12);  ///< Source Address Modulo
        constexpr uint32_t START = (1U << 16);  ///< Start Transfer
        constexpr uint32_t DSIZE = (2 << 17);  ///< Destination Size
        constexpr uint32_t DINC = (1U << 19);  ///< Destination Increment
        constexpr uint32_t SSIZE = (2 << 20);  ///< Source Size
        constexpr uint32_t SINC = (1U << 22);  ///< Source Increment
        constexpr uint32_t EADREQ = (1U << 23);  ///< Enable asynchronous DMA requests
        constexpr uint32_t AA = (1U << 28);  ///< Auto-align
        constexpr uint32_t CS = (1U << 29);  ///< Cycle Steal
        constexpr uint32_t ERQ = (1U << 30);  ///< Enable Peripheral Request
        constexpr uint32_t EINT = (1U << 31);  ///< Enable Interrupt on Completion of Transfer
    }

    /// SAR1 Register bits
    namespace sar1_bits {
        constexpr uint32_t SAR = (32 << 0);  ///< SAR
    }

    /// DAR1 Register bits
    namespace dar1_bits {
        constexpr uint32_t DAR = (32 << 0);  ///< DAR
    }

    /// DSR_BCR1 Register bits
    namespace dsr_bcr1_bits {
        constexpr uint32_t BCR = (24 << 0);  ///< BCR
        constexpr uint32_t DONE = (1U << 24);  ///< Transactions Done
        constexpr uint32_t BSY = (1U << 25);  ///< Busy
        constexpr uint32_t REQ = (1U << 26);  ///< Request
        constexpr uint32_t BED = (1U << 28);  ///< Bus Error on Destination
        constexpr uint32_t BES = (1U << 29);  ///< Bus Error on Source
        constexpr uint32_t CE = (1U << 30);  ///< Configuration Error
    }

    /// DCR1 Register bits
    namespace dcr1_bits {
        constexpr uint32_t LCH2 = (2 << 0);  ///< Link Channel 2
        constexpr uint32_t LCH1 = (2 << 2);  ///< Link Channel 1
        constexpr uint32_t LINKCC = (2 << 4);  ///< Link Channel Control
        constexpr uint32_t D_REQ = (1U << 7);  ///< Disable Request
        constexpr uint32_t DMOD = (4 << 8);  ///< Destination Address Modulo
        constexpr uint32_t SMOD = (4 << 12);  ///< Source Address Modulo
        constexpr uint32_t START = (1U << 16);  ///< Start Transfer
        constexpr uint32_t DSIZE = (2 << 17);  ///< Destination Size
        constexpr uint32_t DINC = (1U << 19);  ///< Destination Increment
        constexpr uint32_t SSIZE = (2 << 20);  ///< Source Size
        constexpr uint32_t SINC = (1U << 22);  ///< Source Increment
        constexpr uint32_t EADREQ = (1U << 23);  ///< Enable asynchronous DMA requests
        constexpr uint32_t AA = (1U << 28);  ///< Auto-align
        constexpr uint32_t CS = (1U << 29);  ///< Cycle Steal
        constexpr uint32_t ERQ = (1U << 30);  ///< Enable Peripheral Request
        constexpr uint32_t EINT = (1U << 31);  ///< Enable Interrupt on Completion of Transfer
    }

    /// SAR2 Register bits
    namespace sar2_bits {
        constexpr uint32_t SAR = (32 << 0);  ///< SAR
    }

    /// DAR2 Register bits
    namespace dar2_bits {
        constexpr uint32_t DAR = (32 << 0);  ///< DAR
    }

    /// DSR_BCR2 Register bits
    namespace dsr_bcr2_bits {
        constexpr uint32_t BCR = (24 << 0);  ///< BCR
        constexpr uint32_t DONE = (1U << 24);  ///< Transactions Done
        constexpr uint32_t BSY = (1U << 25);  ///< Busy
        constexpr uint32_t REQ = (1U << 26);  ///< Request
        constexpr uint32_t BED = (1U << 28);  ///< Bus Error on Destination
        constexpr uint32_t BES = (1U << 29);  ///< Bus Error on Source
        constexpr uint32_t CE = (1U << 30);  ///< Configuration Error
    }

    /// DCR2 Register bits
    namespace dcr2_bits {
        constexpr uint32_t LCH2 = (2 << 0);  ///< Link Channel 2
        constexpr uint32_t LCH1 = (2 << 2);  ///< Link Channel 1
        constexpr uint32_t LINKCC = (2 << 4);  ///< Link Channel Control
        constexpr uint32_t D_REQ = (1U << 7);  ///< Disable Request
        constexpr uint32_t DMOD = (4 << 8);  ///< Destination Address Modulo
        constexpr uint32_t SMOD = (4 << 12);  ///< Source Address Modulo
        constexpr uint32_t START = (1U << 16);  ///< Start Transfer
        constexpr uint32_t DSIZE = (2 << 17);  ///< Destination Size
        constexpr uint32_t DINC = (1U << 19);  ///< Destination Increment
        constexpr uint32_t SSIZE = (2 << 20);  ///< Source Size
        constexpr uint32_t SINC = (1U << 22);  ///< Source Increment
        constexpr uint32_t EADREQ = (1U << 23);  ///< Enable asynchronous DMA requests
        constexpr uint32_t AA = (1U << 28);  ///< Auto-align
        constexpr uint32_t CS = (1U << 29);  ///< Cycle Steal
        constexpr uint32_t ERQ = (1U << 30);  ///< Enable Peripheral Request
        constexpr uint32_t EINT = (1U << 31);  ///< Enable Interrupt on Completion of Transfer
    }

    /// SAR3 Register bits
    namespace sar3_bits {
        constexpr uint32_t SAR = (32 << 0);  ///< SAR
    }

    /// DAR3 Register bits
    namespace dar3_bits {
        constexpr uint32_t DAR = (32 << 0);  ///< DAR
    }

    /// DSR_BCR3 Register bits
    namespace dsr_bcr3_bits {
        constexpr uint32_t BCR = (24 << 0);  ///< BCR
        constexpr uint32_t DONE = (1U << 24);  ///< Transactions Done
        constexpr uint32_t BSY = (1U << 25);  ///< Busy
        constexpr uint32_t REQ = (1U << 26);  ///< Request
        constexpr uint32_t BED = (1U << 28);  ///< Bus Error on Destination
        constexpr uint32_t BES = (1U << 29);  ///< Bus Error on Source
        constexpr uint32_t CE = (1U << 30);  ///< Configuration Error
    }

    /// DCR3 Register bits
    namespace dcr3_bits {
        constexpr uint32_t LCH2 = (2 << 0);  ///< Link Channel 2
        constexpr uint32_t LCH1 = (2 << 2);  ///< Link Channel 1
        constexpr uint32_t LINKCC = (2 << 4);  ///< Link Channel Control
        constexpr uint32_t D_REQ = (1U << 7);  ///< Disable Request
        constexpr uint32_t DMOD = (4 << 8);  ///< Destination Address Modulo
        constexpr uint32_t SMOD = (4 << 12);  ///< Source Address Modulo
        constexpr uint32_t START = (1U << 16);  ///< Start Transfer
        constexpr uint32_t DSIZE = (2 << 17);  ///< Destination Size
        constexpr uint32_t DINC = (1U << 19);  ///< Destination Increment
        constexpr uint32_t SSIZE = (2 << 20);  ///< Source Size
        constexpr uint32_t SINC = (1U << 22);  ///< Source Increment
        constexpr uint32_t EADREQ = (1U << 23);  ///< Enable asynchronous DMA requests
        constexpr uint32_t AA = (1U << 28);  ///< Auto-align
        constexpr uint32_t CS = (1U << 29);  ///< Cycle Steal
        constexpr uint32_t ERQ = (1U << 30);  ///< Enable Peripheral Request
        constexpr uint32_t EINT = (1U << 31);  ///< Enable Interrupt on Completion of Transfer
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t TRNG0_BASE = 0x40029000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t TRNG0_MCTL;  ///< Offset: 0x00 - RNG Miscellaneous Control Register
        volatile uint32_t TRNG0_SCMISC;  ///< Offset: 0x04 - RNG Statistical Check Miscellaneous Register
        volatile uint32_t TRNG0_PKRRNG;  ///< Offset: 0x08 - RNG Poker Range Register
        volatile uint32_t TRNG0_PKRMAX;  ///< Offset: 0x0C - RNG Poker Maximum Limit Register
        volatile uint32_t TRNG0_PKRSQ;  ///< Offset: 0x0C - RNG Poker Square Calculation Result Register
        volatile uint32_t TRNG0_SDCTL;  ///< Offset: 0x10 - RNG Seed Control Register
        volatile uint32_t TRNG0_SBLIM;  ///< Offset: 0x14 - RNG Sparse Bit Limit Register
        volatile uint32_t TRNG0_TOTSAM;  ///< Offset: 0x14 - RNG Total Samples Register
        volatile uint32_t TRNG0_FRQMIN;  ///< Offset: 0x18 - RNG Frequency Count Minimum Limit Register
        volatile uint32_t TRNG0_FRQCNT;  ///< Offset: 0x1C - RNG Frequency Count Register
        volatile uint32_t TRNG0_FRQMAX;  ///< Offset: 0x1C - RNG Frequency Count Maximum Limit Register
        volatile uint32_t TRNG0_SCMC;  ///< Offset: 0x20 - RNG Statistical Check Monobit Count Register
        volatile uint32_t TRNG0_SCML;  ///< Offset: 0x20 - RNG Statistical Check Monobit Limit Register
        volatile uint32_t TRNG0_SCR1C;  ///< Offset: 0x24 - RNG Statistical Check Run Length 1 Count Register
        volatile uint32_t TRNG0_SCR1L;  ///< Offset: 0x24 - RNG Statistical Check Run Length 1 Limit Register
        volatile uint32_t TRNG0_SCR2C;  ///< Offset: 0x28 - RNG Statistical Check Run Length 2 Count Register
        volatile uint32_t TRNG0_SCR2L;  ///< Offset: 0x28 - RNG Statistical Check Run Length 2 Limit Register
        volatile uint32_t TRNG0_SCR3C;  ///< Offset: 0x2C - RNG Statistical Check Run Length 3 Count Register
        volatile uint32_t TRNG0_SCR3L;  ///< Offset: 0x2C - RNG Statistical Check Run Length 3 Limit Register
        volatile uint32_t TRNG0_SCR4C;  ///< Offset: 0x30 - RNG Statistical Check Run Length 4 Count Register
        volatile uint32_t TRNG0_SCR4L;  ///< Offset: 0x30 - RNG Statistical Check Run Length 4 Limit Register
        volatile uint32_t TRNG0_SCR5C;  ///< Offset: 0x34 - RNG Statistical Check Run Length 5 Count Register
        volatile uint32_t TRNG0_SCR5L;  ///< Offset: 0x34 - RNG Statistical Check Run Length 5 Limit Register
        volatile uint32_t TRNG0_SCR6PC;  ///< Offset: 0x38 - RNG Statistical Check Run Length 6+ Count Register
        volatile uint32_t TRNG0_SCR6PL;  ///< Offset: 0x38 - RNG Statistical Check Run Length 6+ Limit Register
        volatile uint32_t TRNG0_STATUS;  ///< Offset: 0x3C - RNG Status Register
        volatile uint32_t TRNG0_ENT0;  ///< Offset: 0x40 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT1;  ///< Offset: 0x44 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT2;  ///< Offset: 0x48 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT3;  ///< Offset: 0x4C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT4;  ///< Offset: 0x50 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT5;  ///< Offset: 0x54 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT6;  ///< Offset: 0x58 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT7;  ///< Offset: 0x5C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT8;  ///< Offset: 0x60 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT9;  ///< Offset: 0x64 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT10;  ///< Offset: 0x68 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT11;  ///< Offset: 0x6C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT12;  ///< Offset: 0x70 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT13;  ///< Offset: 0x74 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT14;  ///< Offset: 0x78 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT15;  ///< Offset: 0x7C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_PKRCNT10;  ///< Offset: 0x80 - RNG Statistical Check Poker Count 1 and 0 Register
        volatile uint32_t TRNG0_PKRCNT32;  ///< Offset: 0x84 - RNG Statistical Check Poker Count 3 and 2 Register
        volatile uint32_t TRNG0_PKRCNT54;  ///< Offset: 0x88 - RNG Statistical Check Poker Count 5 and 4 Register
        volatile uint32_t TRNG0_PKRCNT76;  ///< Offset: 0x8C - RNG Statistical Check Poker Count 7 and 6 Register
        volatile uint32_t TRNG0_PKRCNT98;  ///< Offset: 0x90 - RNG Statistical Check Poker Count 9 and 8 Register
        volatile uint32_t TRNG0_PKRCNTBA;  ///< Offset: 0x94 - RNG Statistical Check Poker Count B and A Register
        volatile uint32_t TRNG0_PKRCNTDC;  ///< Offset: 0x98 - RNG Statistical Check Poker Count D and C Register
        volatile uint32_t TRNG0_PKRCNTFE;  ///< Offset: 0x9C - RNG Statistical Check Poker Count F and E Register
        volatile uint32_t TRNG0_SEC_CFG;  ///< Offset: 0xB0 - RNG Security Configuration Register
        volatile uint32_t TRNG0_INT_CTRL;  ///< Offset: 0xB4 - RNG Interrupt Control Register
        volatile uint32_t TRNG0_INT_MASK;  ///< Offset: 0xB8 - RNG Mask Register
        volatile uint32_t TRNG0_INT_STATUS;  ///< Offset: 0xBC - RNG Interrupt Status Register
        volatile uint32_t TRNG0_VID1;  ///< Offset: 0xF0 - RNG Version ID Register (MS)
        volatile uint32_t TRNG0_VID2;  ///< Offset: 0xF4 - RNG Version ID Register (LS)
    };

    /// Peripheral instances
    inline Registers* TRNG0 = reinterpret_cast<Registers*>(TRNG0_BASE);

    // Bit definitions
    /// TRNG0_MCTL Register bits
    namespace trng0_mctl_bits {
        constexpr uint32_t SAMP_MODE = (2 << 0);  ///< Sample Mode
        constexpr uint32_t OSC_DIV = (2 << 2);  ///< Oscillator Divide
        constexpr uint32_t UNUSED = (1U << 4);  ///< This bit is unused but write-able. Must be left as zero.
        constexpr uint32_t TRNG_ACC = (1U << 5);  ///< TRNG Access Mode
        constexpr uint32_t RST_DEF = (1U << 6);  ///< Reset Defaults
        constexpr uint32_t FOR_SCLK = (1U << 7);  ///< Force System Clock
        constexpr uint32_t FCT_FAIL = (1U << 8);  ///< Read only: Frequency Count Fail
        constexpr uint32_t FCT_VAL = (1U << 9);  ///< Read only: Frequency Count Valid. Indicates that a valid frequency count may be read from FRQCNT.
        constexpr uint32_t ENT_VAL = (1U << 10);  ///< Read only: Entropy Valid
        constexpr uint32_t TST_OUT = (1U << 11);  ///< Read only: Test point inside ring oscillator.
        constexpr uint32_t ERR = (1U << 12);  ///< Read: Error status
        constexpr uint32_t TSTOP_OK = (1U << 13);  ///< TRNG_OK_TO_STOP
        constexpr uint32_t PRGM = (1U << 16);  ///< Programming Mode Select
    }

    /// TRNG0_SCMISC Register bits
    namespace trng0_scmisc_bits {
        constexpr uint32_t LRUN_MAX = (8 << 0);  ///< LONG RUN MAX LIMIT
        constexpr uint32_t RTY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// TRNG0_PKRRNG Register bits
    namespace trng0_pkrrng_bits {
        constexpr uint32_t PKR_RNG = (16 << 0);  ///< Poker Range
    }

    /// TRNG0_PKRMAX Register bits
    namespace trng0_pkrmax_bits {
        constexpr uint32_t PKR_MAX = (24 << 0);  ///< Poker Maximum Limit
    }

    /// TRNG0_PKRSQ Register bits
    namespace trng0_pkrsq_bits {
        constexpr uint32_t PKR_SQ = (24 << 0);  ///< Poker Square Calculation Result
    }

    /// TRNG0_SDCTL Register bits
    namespace trng0_sdctl_bits {
        constexpr uint32_t SAMP_SIZE = (16 << 0);  ///< Sample Size
        constexpr uint32_t ENT_DLY = (16 << 16);  ///< Entropy Delay
    }

    /// TRNG0_SBLIM Register bits
    namespace trng0_sblim_bits {
        constexpr uint32_t SB_LIM = (10 << 0);  ///< Sparse Bit Limit
    }

    /// TRNG0_TOTSAM Register bits
    namespace trng0_totsam_bits {
        constexpr uint32_t TOT_SAM = (20 << 0);  ///< Total Samples
    }

    /// TRNG0_FRQMIN Register bits
    namespace trng0_frqmin_bits {
        constexpr uint32_t FRQ_MIN = (22 << 0);  ///< Frequency Count Minimum Limit
    }

    /// TRNG0_FRQCNT Register bits
    namespace trng0_frqcnt_bits {
        constexpr uint32_t FRQ_CT = (22 << 0);  ///< Frequency Count
    }

    /// TRNG0_FRQMAX Register bits
    namespace trng0_frqmax_bits {
        constexpr uint32_t FRQ_MAX = (22 << 0);  ///< Frequency Counter Maximum Limit
    }

    /// TRNG0_SCMC Register bits
    namespace trng0_scmc_bits {
        constexpr uint32_t MONO_CT = (16 << 0);  ///< Monobit Count
    }

    /// TRNG0_SCML Register bits
    namespace trng0_scml_bits {
        constexpr uint32_t MONO_MAX = (16 << 0);  ///< Monobit Maximum Limit
        constexpr uint32_t MONO_RNG = (16 << 16);  ///< Monobit Range
    }

    /// TRNG0_SCR1C Register bits
    namespace trng0_scr1c_bits {
        constexpr uint32_t R1_0_CT = (15 << 0);  ///< Runs of Zero, Length 1 Count
        constexpr uint32_t R1_1_CT = (15 << 16);  ///< Runs of One, Length 1 Count
    }

    /// TRNG0_SCR1L Register bits
    namespace trng0_scr1l_bits {
        constexpr uint32_t RUN1_MAX = (15 << 0);  ///< Run Length 1 Maximum Limit
        constexpr uint32_t RUN1_RNG = (15 << 16);  ///< Run Length 1 Range
    }

    /// TRNG0_SCR2C Register bits
    namespace trng0_scr2c_bits {
        constexpr uint32_t R2_0_CT = (14 << 0);  ///< Runs of Zero, Length 2 Count
        constexpr uint32_t R2_1_CT = (14 << 16);  ///< Runs of One, Length 2 Count
    }

    /// TRNG0_SCR2L Register bits
    namespace trng0_scr2l_bits {
        constexpr uint32_t RUN2_MAX = (14 << 0);  ///< Run Length 2 Maximum Limit
        constexpr uint32_t RUN2_RNG = (14 << 16);  ///< Run Length 2 Range
    }

    /// TRNG0_SCR3C Register bits
    namespace trng0_scr3c_bits {
        constexpr uint32_t R3_0_CT = (13 << 0);  ///< Runs of Zeroes, Length 3 Count
        constexpr uint32_t R3_1_CT = (13 << 16);  ///< Runs of Ones, Length 3 Count
    }

    /// TRNG0_SCR3L Register bits
    namespace trng0_scr3l_bits {
        constexpr uint32_t RUN3_MAX = (13 << 0);  ///< Run Length 3 Maximum Limit
        constexpr uint32_t RUN3_RNG = (13 << 16);  ///< Run Length 3 Range
    }

    /// TRNG0_SCR4C Register bits
    namespace trng0_scr4c_bits {
        constexpr uint32_t R4_0_CT = (12 << 0);  ///< Runs of Zero, Length 4 Count
        constexpr uint32_t R4_1_CT = (12 << 16);  ///< Runs of One, Length 4 Count
    }

    /// TRNG0_SCR4L Register bits
    namespace trng0_scr4l_bits {
        constexpr uint32_t RUN4_MAX = (12 << 0);  ///< Run Length 4 Maximum Limit
        constexpr uint32_t RUN4_RNG = (12 << 16);  ///< Run Length 4 Range
    }

    /// TRNG0_SCR5C Register bits
    namespace trng0_scr5c_bits {
        constexpr uint32_t R5_0_CT = (11 << 0);  ///< Runs of Zero, Length 5 Count
        constexpr uint32_t R5_1_CT = (11 << 16);  ///< Runs of One, Length 5 Count
    }

    /// TRNG0_SCR5L Register bits
    namespace trng0_scr5l_bits {
        constexpr uint32_t RUN5_MAX = (11 << 0);  ///< Run Length 5 Maximum Limit
        constexpr uint32_t RUN5_RNG = (11 << 16);  ///< Run Length 5 Range
    }

    /// TRNG0_SCR6PC Register bits
    namespace trng0_scr6pc_bits {
        constexpr uint32_t R6P_0_CT = (11 << 0);  ///< Runs of Zero, Length 6+ Count
        constexpr uint32_t R6P_1_CT = (11 << 16);  ///< Runs of One, Length 6+ Count
    }

    /// TRNG0_SCR6PL Register bits
    namespace trng0_scr6pl_bits {
        constexpr uint32_t RUN6P_MAX = (11 << 0);  ///< Run Length 6+ Maximum Limit
        constexpr uint32_t RUN6P_RNG = (11 << 16);  ///< Run Length 6+ Range
    }

    /// TRNG0_STATUS Register bits
    namespace trng0_status_bits {
        constexpr uint32_t TF1BR0 = (1U << 0);  ///< Test Fail, 1-Bit Run, Sampling 0s. If TF1BR0=1, the 1-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF1BR1 = (1U << 1);  ///< Test Fail, 1-Bit Run, Sampling 1s. If TF1BR1=1, the 1-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF2BR0 = (1U << 2);  ///< Test Fail, 2-Bit Run, Sampling 0s. If TF2BR0=1, the 2-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF2BR1 = (1U << 3);  ///< Test Fail, 2-Bit Run, Sampling 1s. If TF2BR1=1, the 2-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF3BR0 = (1U << 4);  ///< Test Fail, 3-Bit Run, Sampling 0s. If TF3BR0=1, the 3-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF3BR1 = (1U << 5);  ///< Test Fail, 3-Bit Run, Sampling 1s. If TF3BR1=1, the 3-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF4BR0 = (1U << 6);  ///< Test Fail, 4-Bit Run, Sampling 0s. If TF4BR0=1, the 4-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF4BR1 = (1U << 7);  ///< Test Fail, 4-Bit Run, Sampling 1s. If TF4BR1=1, the 4-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF5BR0 = (1U << 8);  ///< Test Fail, 5-Bit Run, Sampling 0s. If TF5BR0=1, the 5-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF5BR1 = (1U << 9);  ///< Test Fail, 5-Bit Run, Sampling 1s. If TF5BR1=1, the 5-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF6PBR0 = (1U << 10);  ///< Test Fail, 6 Plus Bit Run, Sampling 0s
        constexpr uint32_t TF6PBR1 = (1U << 11);  ///< Test Fail, 6 Plus Bit Run, Sampling 1s
        constexpr uint32_t TFSB = (1U << 12);  ///< Test Fail, Sparse Bit. If TFSB=1, the Sparse Bit Test has failed.
        constexpr uint32_t TFLR = (1U << 13);  ///< Test Fail, Long Run. If TFLR=1, the Long Run Test has failed.
        constexpr uint32_t TFP = (1U << 14);  ///< Test Fail, Poker. If TFP=1, the Poker Test has failed.
        constexpr uint32_t TFMB = (1U << 15);  ///< Test Fail, Mono Bit. If TFMB=1, the Mono Bit Test has failed.
        constexpr uint32_t RETRY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// TRNG0_ENT0 Register bits
    namespace trng0_ent0_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT1 Register bits
    namespace trng0_ent1_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT2 Register bits
    namespace trng0_ent2_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT3 Register bits
    namespace trng0_ent3_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT4 Register bits
    namespace trng0_ent4_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT5 Register bits
    namespace trng0_ent5_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT6 Register bits
    namespace trng0_ent6_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT7 Register bits
    namespace trng0_ent7_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT8 Register bits
    namespace trng0_ent8_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT9 Register bits
    namespace trng0_ent9_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT10 Register bits
    namespace trng0_ent10_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT11 Register bits
    namespace trng0_ent11_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT12 Register bits
    namespace trng0_ent12_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT13 Register bits
    namespace trng0_ent13_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT14 Register bits
    namespace trng0_ent14_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT15 Register bits
    namespace trng0_ent15_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_PKRCNT10 Register bits
    namespace trng0_pkrcnt10_bits {
        constexpr uint32_t PKR_0_CT = (16 << 0);  ///< Poker 0h Count
        constexpr uint32_t PKR_1_CT = (16 << 16);  ///< Poker 1h Count
    }

    /// TRNG0_PKRCNT32 Register bits
    namespace trng0_pkrcnt32_bits {
        constexpr uint32_t PKR_2_CT = (16 << 0);  ///< Poker 2h Count
        constexpr uint32_t PKR_3_CT = (16 << 16);  ///< Poker 3h Count
    }

    /// TRNG0_PKRCNT54 Register bits
    namespace trng0_pkrcnt54_bits {
        constexpr uint32_t PKR_4_CT = (16 << 0);  ///< Poker 4h Count
        constexpr uint32_t PKR_5_CT = (16 << 16);  ///< Poker 5h Count
    }

    /// TRNG0_PKRCNT76 Register bits
    namespace trng0_pkrcnt76_bits {
        constexpr uint32_t PKR_6_CT = (16 << 0);  ///< Poker 6h Count
        constexpr uint32_t PKR_7_CT = (16 << 16);  ///< Poker 7h Count
    }

    /// TRNG0_PKRCNT98 Register bits
    namespace trng0_pkrcnt98_bits {
        constexpr uint32_t PKR_8_CT = (16 << 0);  ///< Poker 8h Count
        constexpr uint32_t PKR_9_CT = (16 << 16);  ///< Poker 9h Count
    }

    /// TRNG0_PKRCNTBA Register bits
    namespace trng0_pkrcntba_bits {
        constexpr uint32_t PKR_A_CT = (16 << 0);  ///< Poker Ah Count
        constexpr uint32_t PKR_B_CT = (16 << 16);  ///< Poker Bh Count
    }

    /// TRNG0_PKRCNTDC Register bits
    namespace trng0_pkrcntdc_bits {
        constexpr uint32_t PKR_C_CT = (16 << 0);  ///< Poker Ch Count
        constexpr uint32_t PKR_D_CT = (16 << 16);  ///< Poker Dh Count
    }

    /// TRNG0_PKRCNTFE Register bits
    namespace trng0_pkrcntfe_bits {
        constexpr uint32_t PKR_E_CT = (16 << 0);  ///< Poker Eh Count
        constexpr uint32_t PKR_F_CT = (16 << 16);  ///< Poker Fh Count
    }

    /// TRNG0_SEC_CFG Register bits
    namespace trng0_sec_cfg_bits {
        constexpr uint32_t SH0 = (1U << 0);  ///< Reserved. DRNG specific, not applicable to this version.
        constexpr uint32_t NO_PRGM = (1U << 1);  ///< If set the TRNG registers cannot be programmed
        constexpr uint32_t SK_VAL = (1U << 2);  ///< Reserved. DRNG-specific, not applicable to this version.
    }

    /// TRNG0_INT_CTRL Register bits
    namespace trng0_int_ctrl_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 above.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 above.
        constexpr uint32_t UNUSED = (29 << 3);  ///< Reserved but writeable.
    }

    /// TRNG0_INT_MASK Register bits
    namespace trng0_int_mask_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 above.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 above.
    }

    /// TRNG0_INT_STATUS Register bits
    namespace trng0_int_status_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Read: Error status
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Read only: Entropy Valid
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Read only: Frequency Count Fail
    }

    /// TRNG0_VID1 Register bits
    namespace trng0_vid1_bits {
        constexpr uint32_t RNG_MIN_REV = (8 << 0);  ///< Shows the Freescale IP's Minor revision of the TRNG.
        constexpr uint32_t RNG_MAJ_REV = (8 << 8);  ///< Shows the Freescale IP's Major revision of the TRNG.
        constexpr uint32_t RNG_IP_ID = (16 << 16);  ///< Shows the Freescale IP ID.
    }

    /// TRNG0_VID2 Register bits
    namespace trng0_vid2_bits {
        constexpr uint32_t RNG_CONFIG_OPT = (8 << 0);  ///< Shows the Freescale IP's Configuaration options for the TRNG.
        constexpr uint32_t RNG_ECO_REV = (8 << 8);  ///< Shows the Freescale IP's ECO revision of the TRNG.
        constexpr uint32_t RNG_INTG_OPT = (8 << 16);  ///< Shows the Freescale integration options for the TRNG.
        constexpr uint32_t RNG_ERA = (8 << 24);  ///< Shows the Freescale compile options for the TRNG.
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x4002C000;
    constexpr uint32_t SPI1_BASE = 0x4002D000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t TCR;  ///< Offset: 0x08 - Transfer Count Register
        volatile uint32_t CTAR%s;  ///< Offset: 0x0C - Clock and Transfer Attributes Register (In Master Mode)
        volatile uint32_t CTAR_SLAVE;  ///< Offset: 0x0C - Clock and Transfer Attributes Register (In Slave Mode)
        volatile uint32_t SR;  ///< Offset: 0x2C - Status Register
        volatile uint32_t RSER;  ///< Offset: 0x30 - DMA/Interrupt Request Select and Enable Register
        volatile uint32_t PUSHR;  ///< Offset: 0x34 - PUSH TX FIFO Register In Master Mode
        volatile uint32_t PUSHR_SLAVE;  ///< Offset: 0x34 - PUSH TX FIFO Register In Slave Mode
        volatile uint32_t POPR;  ///< Offset: 0x38 - POP RX FIFO Register
        volatile uint32_t TXFR%s;  ///< Offset: 0x3C - Transmit FIFO Registers
        volatile uint32_t RXFR%s;  ///< Offset: 0x7C - Receive FIFO Registers
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t HALT = (1U << 0);  ///< Halt
        constexpr uint32_t SMPL_PT = (2 << 8);  ///< Sample Point
        constexpr uint32_t CLR_RXF = (1U << 10);  ///< CLR_RXF
        constexpr uint32_t CLR_TXF = (1U << 11);  ///< Clear TX FIFO
        constexpr uint32_t DIS_RXF = (1U << 12);  ///< Disable Receive FIFO
        constexpr uint32_t DIS_TXF = (1U << 13);  ///< Disable Transmit FIFO
        constexpr uint32_t MDIS = (1U << 14);  ///< Module Disable
        constexpr uint32_t DOZE = (1U << 15);  ///< Doze Enable
        constexpr uint32_t PCSIS = (4 << 16);  ///< Peripheral Chip Select x Inactive State
        constexpr uint32_t ROOE = (1U << 24);  ///< Receive FIFO Overflow Overwrite Enable
        constexpr uint32_t MTFE = (1U << 26);  ///< Modified Transfer Format Enable
        constexpr uint32_t FRZ = (1U << 27);  ///< Freeze
        constexpr uint32_t DCONF = (2 << 28);  ///< SPI Configuration.
        constexpr uint32_t CONT_SCKE = (1U << 30);  ///< Continuous SCK Enable
        constexpr uint32_t MSTR = (1U << 31);  ///< Master/Slave Mode Select
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t SPI_TCNT = (16 << 16);  ///< SPI Transfer Counter
    }

    /// CTAR%s Register bits
    namespace ctar%s_bits {
        constexpr uint32_t BR = (4 << 0);  ///< Baud Rate Scaler
        constexpr uint32_t DT = (4 << 4);  ///< Delay After Transfer Scaler
        constexpr uint32_t ASC = (4 << 8);  ///< After SCK Delay Scaler
        constexpr uint32_t CSSCK = (4 << 12);  ///< PCS to SCK Delay Scaler
        constexpr uint32_t PBR = (2 << 16);  ///< Baud Rate Prescaler
        constexpr uint32_t PDT = (2 << 18);  ///< Delay after Transfer Prescaler
        constexpr uint32_t PASC = (2 << 20);  ///< After SCK Delay Prescaler
        constexpr uint32_t PCSSCK = (2 << 22);  ///< PCS to SCK Delay Prescaler
        constexpr uint32_t LSBFE = (1U << 24);  ///< LSB First
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
        constexpr uint32_t DBR = (1U << 31);  ///< Double Baud Rate
    }

    /// CTAR_SLAVE Register bits
    namespace ctar_slave_bits {
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t POPNXTPTR = (4 << 0);  ///< Pop Next Pointer
        constexpr uint32_t RXCTR = (4 << 4);  ///< RX FIFO Counter
        constexpr uint32_t TXNXTPTR = (4 << 8);  ///< Transmit Next Pointer
        constexpr uint32_t TXCTR = (4 << 12);  ///< TX FIFO Counter
        constexpr uint32_t RFDF = (1U << 17);  ///< Receive FIFO Drain Flag
        constexpr uint32_t RFOF = (1U << 19);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t TFFF = (1U << 25);  ///< Transmit FIFO Fill Flag
        constexpr uint32_t TFUF = (1U << 27);  ///< Transmit FIFO Underflow Flag
        constexpr uint32_t EOQF = (1U << 28);  ///< End of Queue Flag
        constexpr uint32_t TXRXS = (1U << 30);  ///< TX and RX Status
        constexpr uint32_t TCF = (1U << 31);  ///< Transfer Complete Flag
    }

    /// RSER Register bits
    namespace rser_bits {
        constexpr uint32_t RFDF_DIRS = (1U << 16);  ///< Receive FIFO Drain DMA or Interrupt Request Select
        constexpr uint32_t RFDF_RE = (1U << 17);  ///< Receive FIFO Drain Request Enable
        constexpr uint32_t RFOF_RE = (1U << 19);  ///< Receive FIFO Overflow Request Enable
        constexpr uint32_t TFFF_DIRS = (1U << 24);  ///< Transmit FIFO Fill DMA or Interrupt Request Select
        constexpr uint32_t TFFF_RE = (1U << 25);  ///< Transmit FIFO Fill Request Enable
        constexpr uint32_t TFUF_RE = (1U << 27);  ///< Transmit FIFO Underflow Request Enable
        constexpr uint32_t EOQF_RE = (1U << 28);  ///< Finished Request Enable
        constexpr uint32_t TCF_RE = (1U << 31);  ///< Transmission Complete Request Enable
    }

    /// PUSHR Register bits
    namespace pushr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t PCS = (4 << 16);  ///< Select which PCS signals are to be asserted for the transfer
        constexpr uint32_t CTCNT = (1U << 26);  ///< Clear Transfer Counter
        constexpr uint32_t EOQ = (1U << 27);  ///< End Of Queue
        constexpr uint32_t CTAS = (3 << 28);  ///< Clock and Transfer Attributes Select
        constexpr uint32_t CONT = (1U << 31);  ///< Continuous Peripheral Chip Select Enable
    }

    /// PUSHR_SLAVE Register bits
    namespace pushr_slave_bits {
        constexpr uint32_t TXDATA = (32 << 0);  ///< Transmit Data
    }

    /// POPR Register bits
    namespace popr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Received Data
    }

    /// TXFR%s Register bits
    namespace txfr%s_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t TXCMD_TXDATA = (16 << 16);  ///< Transmit Command or Transmit Data
    }

    /// RXFR%s Register bits
    namespace rxfr%s_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Receive Data
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT_BASE = 0x40037000;
    constexpr uint32_t TPM0_BASE = 0x40038000;
    constexpr uint32_t TPM1_BASE = 0x40039000;
    constexpr uint32_t TPM2_BASE = 0x4003A000;
    constexpr uint32_t LPTMR0_BASE = 0x40040000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LTMR64H;  ///< Offset: 0xE0 - PIT Upper Lifetime Timer Register
        volatile uint32_t LTMR64L;  ///< Offset: 0xE4 - PIT Lower Lifetime Timer Register
        volatile uint32_t LDVAL%s;  ///< Offset: 0x100 - Timer Load Value Register
        volatile uint32_t CVAL%s;  ///< Offset: 0x104 - Current Timer Value Register
        volatile uint32_t TCTRL%s;  ///< Offset: 0x108 - Timer Control Register
        volatile uint32_t TFLG%s;  ///< Offset: 0x10C - Timer Flag Register
    };

    /// Peripheral instances
    inline Registers* PIT = reinterpret_cast<Registers*>(PIT_BASE);
    inline Registers* TPM0 = reinterpret_cast<Registers*>(TPM0_BASE);
    inline Registers* TPM1 = reinterpret_cast<Registers*>(TPM1_BASE);
    inline Registers* TPM2 = reinterpret_cast<Registers*>(TPM2_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable - (PIT section)
    }

    /// LTMR64H Register bits
    namespace ltmr64h_bits {
        constexpr uint32_t LTH = (32 << 0);  ///< Life Timer value
    }

    /// LTMR64L Register bits
    namespace ltmr64l_bits {
        constexpr uint32_t LTL = (32 << 0);  ///< Life Timer value
    }

    /// LDVAL%s Register bits
    namespace ldval%s_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value
    }

    /// CVAL%s Register bits
    namespace cval%s_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL%s Register bits
    namespace tctrl%s_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable
        constexpr uint32_t CHN = (1U << 2);  ///< Chain Mode
    }

    /// TFLG%s Register bits
    namespace tflg%s_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1%s;  ///< Offset: 0x00 - ADC Status and Control Registers 1
        volatile uint32_t CFG1;  ///< Offset: 0x08 - ADC Configuration Register 1
        volatile uint32_t CFG2;  ///< Offset: 0x0C - ADC Configuration Register 2
        volatile uint32_t R%s;  ///< Offset: 0x10 - ADC Data Result Register
        volatile uint32_t CV%s;  ///< Offset: 0x18 - Compare Value Registers
        volatile uint32_t SC2;  ///< Offset: 0x20 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x24 - Status and Control Register 3
        volatile uint32_t OFS;  ///< Offset: 0x28 - ADC Offset Correction Register
        volatile uint32_t PG;  ///< Offset: 0x2C - ADC Plus-Side Gain Register
        volatile uint32_t MG;  ///< Offset: 0x30 - ADC Minus-Side Gain Register
        volatile uint32_t CLPD;  ///< Offset: 0x34 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPS;  ///< Offset: 0x38 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP4;  ///< Offset: 0x3C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP3;  ///< Offset: 0x40 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2;  ///< Offset: 0x44 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1;  ///< Offset: 0x48 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0;  ///< Offset: 0x4C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLMD;  ///< Offset: 0x54 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLMS;  ///< Offset: 0x58 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM4;  ///< Offset: 0x5C - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM3;  ///< Offset: 0x60 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM2;  ///< Offset: 0x64 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM1;  ///< Offset: 0x68 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM0;  ///< Offset: 0x6C - ADC Minus-Side General Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);

    // Bit definitions
    /// SC1%s Register bits
    namespace sc1%s_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t DIFF = (1U << 5);  ///< Differential Mode Enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Sample Time Configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-Power Configuration
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t ADLSTS = (2 << 0);  ///< Long Sample Time Select
        constexpr uint32_t ADHSC = (1U << 2);  ///< High-Speed Configuration
        constexpr uint32_t ADACKEN = (1U << 3);  ///< Asynchronous Clock Output Enable
        constexpr uint32_t MUXSEL = (1U << 4);  ///< ADC Mux Select
    }

    /// R%s Register bits
    namespace r%s_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data result
    }

    /// CV%s Register bits
    namespace cv%s_bits {
        constexpr uint32_t CV = (16 << 0);  ///< Compare Value.
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage Reference Selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA Enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare Function Range Enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware Average Select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware Average Enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous Conversion Enable
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration Failed Flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset Error Correction Value
    }

    /// PG Register bits
    namespace pg_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Plus-Side Gain
    }

    /// MG Register bits
    namespace mg_bits {
        constexpr uint32_t MG = (16 << 0);  ///< Minus-Side Gain
    }

    /// CLPD Register bits
    namespace clpd_bits {
        constexpr uint32_t CLPD = (6 << 0);  ///< Calibration Value
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (6 << 0);  ///< Calibration Value
    }

    /// CLP4 Register bits
    namespace clp4_bits {
        constexpr uint32_t CLP4 = (10 << 0);  ///< Calibration Value
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (9 << 0);  ///< Calibration Value
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (8 << 0);  ///< Calibration Value
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (7 << 0);  ///< Calibration Value
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (6 << 0);  ///< Calibration Value
    }

    /// CLMD Register bits
    namespace clmd_bits {
        constexpr uint32_t CLMD = (6 << 0);  ///< Calibration Value
    }

    /// CLMS Register bits
    namespace clms_bits {
        constexpr uint32_t CLMS = (6 << 0);  ///< Calibration Value
    }

    /// CLM4 Register bits
    namespace clm4_bits {
        constexpr uint32_t CLM4 = (10 << 0);  ///< Calibration Value
    }

    /// CLM3 Register bits
    namespace clm3_bits {
        constexpr uint32_t CLM3 = (9 << 0);  ///< Calibration Value
    }

    /// CLM2 Register bits
    namespace clm2_bits {
        constexpr uint32_t CLM2 = (8 << 0);  ///< Calibration Value
    }

    /// CLM1 Register bits
    namespace clm1_bits {
        constexpr uint32_t CLM1 = (7 << 0);  ///< Calibration Value
    }

    /// CLM0 Register bits
    namespace clm0_bits {
        constexpr uint32_t CLM0 = (6 << 0);  ///< Calibration Value
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TSR;  ///< Offset: 0x00 - RTC Time Seconds Register
        volatile uint32_t TPR;  ///< Offset: 0x04 - RTC Time Prescaler Register
        volatile uint32_t TAR;  ///< Offset: 0x08 - RTC Time Alarm Register
        volatile uint32_t TCR;  ///< Offset: 0x0C - RTC Time Compensation Register
        volatile uint32_t CR;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - RTC Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - RTC Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - RTC Interrupt Enable Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (32 << 0);  ///< Time Seconds Register
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t TPR = (16 << 0);  ///< Time Prescaler Register
    }

    /// TAR Register bits
    namespace tar_bits {
        constexpr uint32_t TAR = (32 << 0);  ///< Time Alarm Register
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCR = (8 << 0);  ///< Time Compensation Register
        constexpr uint32_t CIR = (8 << 8);  ///< Compensation Interval Register
        constexpr uint32_t TCV = (8 << 16);  ///< Time Compensation Value
        constexpr uint32_t CIC = (8 << 24);  ///< Compensation Interval Counter
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t WPE = (1U << 1);  ///< Wakeup Pin Enable
        constexpr uint32_t SUP = (1U << 2);  ///< Supervisor Access
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t WPS = (1U << 4);  ///< Wakeup Pin Select
        constexpr uint32_t OSCE = (1U << 8);  ///< Oscillator Enable
        constexpr uint32_t CLKO = (1U << 9);  ///< Clock Output
        constexpr uint32_t SC16P = (1U << 10);  ///< Oscillator 16pF Load Configure
        constexpr uint32_t SC8P = (1U << 11);  ///< Oscillator 8pF Load Configure
        constexpr uint32_t SC4P = (1U << 12);  ///< Oscillator 4pF Load Configure
        constexpr uint32_t SC2P = (1U << 13);  ///< Oscillator 2pF Load Configure
        constexpr uint32_t OTE = (1U << 14);  ///< Oscillator Test Enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time Invalid Flag
        constexpr uint32_t TOF = (1U << 1);  ///< Time Overflow Flag
        constexpr uint32_t TAF = (1U << 2);  ///< Time Alarm Flag
        constexpr uint32_t TCE = (1U << 4);  ///< Time Counter Enable
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t TCL = (1U << 3);  ///< Time Compensation Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TIIE = (1U << 0);  ///< Time Invalid Interrupt Enable
        constexpr uint32_t TOIE = (1U << 1);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t TAIE = (1U << 2);  ///< Time Alarm Interrupt Enable
        constexpr uint32_t TSIE = (1U << 4);  ///< Time Seconds Interrupt Enable
        constexpr uint32_t WPON = (1U << 7);  ///< Wakeup Pin On
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC0_BASE = 0x4003F000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DAT%sL;  ///< Offset: 0x00 - DAC Data Low Register
        volatile uint32_t DAT%sH;  ///< Offset: 0x01 - DAC Data High Register
        volatile uint32_t SR;  ///< Offset: 0x20 - DAC Status Register
        volatile uint32_t C0;  ///< Offset: 0x21 - DAC Control Register
        volatile uint32_t C1;  ///< Offset: 0x22 - DAC Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x23 - DAC Control Register 2
    };

    /// Peripheral instances
    inline Registers* DAC0 = reinterpret_cast<Registers*>(DAC0_BASE);

    // Bit definitions
    /// DAT%sL Register bits
    namespace dat%sl_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0
    }

    /// DAT%sH Register bits
    namespace dat%sh_bits {
        constexpr uint32_t DATA1 = (4 << 0);  ///< DATA1
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DACBFRPBF = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Position Flag
        constexpr uint32_t DACBFRPTF = (1U << 1);  ///< DAC Buffer Read Pointer Top Position Flag
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t DACBBIEN = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Flag Interrupt Enable
        constexpr uint32_t DACBTIEN = (1U << 1);  ///< DAC Buffer Read Pointer Top Flag Interrupt Enable
        constexpr uint32_t LPEN = (1U << 3);  ///< DAC Low Power Control
        constexpr uint32_t DACSWTRG = (1U << 4);  ///< DAC Software Trigger
        constexpr uint32_t DACTRGSEL = (1U << 5);  ///< DAC Trigger Select
        constexpr uint32_t DACRFS = (1U << 6);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DACBFEN = (1U << 0);  ///< DAC Buffer Enable
        constexpr uint32_t DACBFMD = (1U << 2);  ///< DAC Buffer Work Mode Select
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA Enable Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t DACBFUP = (1U << 0);  ///< DAC Buffer Upper Limit
        constexpr uint32_t DACBFRP = (1U << 4);  ///< DAC Buffer Read Pointer
    }

}

// ============================================================================
// TSI0 Peripheral
// ============================================================================

namespace tsi0 {
    /// Base addresses
    constexpr uint32_t TSI0_BASE = 0x40045000;

    /// TSI0 Register structure
    struct Registers {
        volatile uint32_t GENCS;  ///< Offset: 0x00 - TSI General Control and Status Register
        volatile uint32_t DATA;  ///< Offset: 0x04 - TSI DATA Register
        volatile uint32_t TSHD;  ///< Offset: 0x08 - TSI Threshold Register
    };

    /// Peripheral instances
    inline Registers* TSI0 = reinterpret_cast<Registers*>(TSI0_BASE);

    // Bit definitions
    /// GENCS Register bits
    namespace gencs_bits {
        constexpr uint32_t CURSW = (1U << 1);  ///< CURSW
        constexpr uint32_t EOSF = (1U << 2);  ///< End of Scan Flag
        constexpr uint32_t SCNIP = (1U << 3);  ///< Scan In Progress Status
        constexpr uint32_t STM = (1U << 4);  ///< Scan Trigger Mode
        constexpr uint32_t STPE = (1U << 5);  ///< TSI STOP Enable
        constexpr uint32_t TSIIEN = (1U << 6);  ///< Touch Sensing Input Interrupt Enable
        constexpr uint32_t TSIEN = (1U << 7);  ///< Touch Sensing Input Module Enable
        constexpr uint32_t NSCN = (5 << 8);  ///< NSCN
        constexpr uint32_t PS = (3 << 13);  ///< PS
        constexpr uint32_t EXTCHRG = (3 << 16);  ///< EXTCHRG
        constexpr uint32_t DVOLT = (2 << 19);  ///< DVOLT
        constexpr uint32_t REFCHRG = (3 << 21);  ///< REFCHRG
        constexpr uint32_t MODE = (4 << 24);  ///< TSI analog modes setup and status bits.
        constexpr uint32_t ESOR = (1U << 28);  ///< End-of-scan or Out-of-Range Interrupt Selection
        constexpr uint32_t OUTRGF = (1U << 31);  ///< Out of Range Flag.
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t TSICNT = (16 << 0);  ///< TSI Conversion Counter Value
        constexpr uint32_t SWTS = (1U << 22);  ///< Software Trigger Start
        constexpr uint32_t DMAEN = (1U << 23);  ///< DMA Transfer Enabled
        constexpr uint32_t TSICH = (4 << 28);  ///< TSICH
    }

    /// TSHD Register bits
    namespace tshd_bits {
        constexpr uint32_t THRESL = (16 << 0);  ///< TSI Wakeup Channel Low-threshold
        constexpr uint32_t THRESH = (16 << 16);  ///< TSI Wakeup Channel High-threshold
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40047000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT1;  ///< Offset: 0x00 - System Options Register 1
        volatile uint32_t SOPT2;  ///< Offset: 0x1004 - System Options Register 2
        volatile uint32_t SOPT4;  ///< Offset: 0x100C - System Options Register 4
        volatile uint32_t SOPT5;  ///< Offset: 0x1010 - System Options Register 5
        volatile uint32_t SOPT7;  ///< Offset: 0x1018 - System Options Register 7
        volatile uint32_t SDID;  ///< Offset: 0x1024 - System Device Identification Register
        volatile uint32_t SCGC4;  ///< Offset: 0x1034 - System Clock Gating Control Register 4
        volatile uint32_t SCGC5;  ///< Offset: 0x1038 - System Clock Gating Control Register 5
        volatile uint32_t SCGC6;  ///< Offset: 0x103C - System Clock Gating Control Register 6
        volatile uint32_t SCGC7;  ///< Offset: 0x1040 - System Clock Gating Control Register 7
        volatile uint32_t CLKDIV1;  ///< Offset: 0x1044 - System Clock Divider Register 1
        volatile uint32_t FCFG1;  ///< Offset: 0x104C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x1050 - Flash Configuration Register 2
        volatile uint32_t UIDMH;  ///< Offset: 0x1058 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x105C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x1060 - Unique Identification Register Low
        volatile uint32_t COPC;  ///< Offset: 0x1100 - COP Control Register
        volatile uint32_t SRVCOP;  ///< Offset: 0x1104 - Service COP
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t OSC32KOUT = (2 << 16);  ///< 32K oscillator clock output
        constexpr uint32_t OSC32KSEL = (2 << 18);  ///< 32K Oscillator Clock Select
        constexpr uint32_t SIM_MISCTL = (1U << 20);  ///< This bit control the function of RF_ACTIVE on PTC1/PTC19 ALT7
    }

    /// SOPT2 Register bits
    namespace sopt2_bits {
        constexpr uint32_t CLKOUTSEL = (3 << 5);  ///< CLKOUT select
        constexpr uint32_t TPMSRC = (2 << 24);  ///< TPM Clock Source Select
        constexpr uint32_t LPUART0SRC = (2 << 26);  ///< LPUART0 Clock Source Select
    }

    /// SOPT4 Register bits
    namespace sopt4_bits {
        constexpr uint32_t TPM1CH0SRC = (1U << 18);  ///< TPM1 Channel 0 Input Capture Source Select
        constexpr uint32_t TPM2CH0SRC = (1U << 20);  ///< TPM2 Channel 0 Input Capture Source Select
        constexpr uint32_t TPM0CLKSEL = (1U << 24);  ///< TPM0 External Clock Pin Select
        constexpr uint32_t TPM1CLKSEL = (1U << 25);  ///< TPM1 External Clock Pin Select
        constexpr uint32_t TPM2CLKSEL = (1U << 26);  ///< TPM2 External Clock Pin Select
    }

    /// SOPT5 Register bits
    namespace sopt5_bits {
        constexpr uint32_t LPUART0TXSRC = (2 << 0);  ///< LPUART0 Transmit Data Source Select
        constexpr uint32_t LPUART0RXSRC = (1U << 2);  ///< LPUART0 Receive Data Source Select
        constexpr uint32_t LPUART0ODE = (1U << 16);  ///< LPUART0 Open Drain Enable
    }

    /// SOPT7 Register bits
    namespace sopt7_bits {
        constexpr uint32_t ADC0TRGSEL = (4 << 0);  ///< ADC0 Trigger Select
        constexpr uint32_t ADC0PRETRGSEL = (1U << 4);  ///< ADC0 Pretrigger Select
        constexpr uint32_t ADC0ALTTRGEN = (1U << 7);  ///< ADC0 Alternate Trigger Enable
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (4 << 0);  ///< Pin count Identification
        constexpr uint32_t DIEID = (5 << 7);  ///< Device Die Number
        constexpr uint32_t REVID = (4 << 12);  ///< Device Revision Number
        constexpr uint32_t SRAMSIZE = (4 << 16);  ///< System SRAM Size
        constexpr uint32_t SERIESID = (4 << 20);  ///< Kinetis Series ID
        constexpr uint32_t SUBFAMID = (2 << 24);  ///< Kinetis Sub-Family ID.
        constexpr uint32_t FAMID = (4 << 28);  ///< Kinetis family ID
    }

    /// SCGC4 Register bits
    namespace scgc4_bits {
        constexpr uint32_t CMT = (1U << 2);  ///< CMT Clock Gate Control
        constexpr uint32_t I2C0 = (1U << 6);  ///< I2C0 Clock Gate Control
        constexpr uint32_t I2C1 = (1U << 7);  ///< I2C1 Clock Gate Control
        constexpr uint32_t CMP = (1U << 19);  ///< Comparator Clock Gate Control
    }

    /// SCGC5 Register bits
    namespace scgc5_bits {
        constexpr uint32_t LPTMR = (1U << 0);  ///< Low Power Timer Access Control
        constexpr uint32_t TSI = (1U << 5);  ///< TSI Access Control
        constexpr uint32_t PORTA = (1U << 9);  ///< Port A Clock Gate Control
        constexpr uint32_t PORTB = (1U << 10);  ///< Port B Clock Gate Control
        constexpr uint32_t PORTC = (1U << 11);  ///< Port C Clock Gate Control
        constexpr uint32_t LPUART0 = (1U << 20);  ///< LPUART0 Clock Gate Control
        constexpr uint32_t LTC = (1U << 24);  ///< LTC Clock Gate Control
        constexpr uint32_t RSIM = (1U << 25);  ///< RSIM Clock Gate Control
        constexpr uint32_t DCDC = (1U << 26);  ///< DCDC Clock Gate Control
        constexpr uint32_t BTLL = (1U << 27);  ///< BTLL System Clock Gate Control
        constexpr uint32_t PHYDIG = (1U << 28);  ///< PHY Digital Clock Gate Control
        constexpr uint32_t ZigBee = (1U << 29);  ///< ZigBee Clock Gate Control
    }

    /// SCGC6 Register bits
    namespace scgc6_bits {
        constexpr uint32_t FTF = (1U << 0);  ///< Flash Memory Clock Gate Control
        constexpr uint32_t DMAMUX = (1U << 1);  ///< DMA Mux Clock Gate Control
        constexpr uint32_t TRNG = (1U << 9);  ///< TRNG Clock Gate Control
        constexpr uint32_t SPI0 = (1U << 12);  ///< SPI0 Clock Gate Control
        constexpr uint32_t SPI1 = (1U << 13);  ///< SPI1 Clock Gate Control
        constexpr uint32_t PIT = (1U << 23);  ///< PIT Clock Gate Control
        constexpr uint32_t TPM0 = (1U << 24);  ///< TPM0 Clock Gate Control
        constexpr uint32_t TPM1 = (1U << 25);  ///< TPM1 Clock Gate Control
        constexpr uint32_t TPM2 = (1U << 26);  ///< TPM2 Clock Gate Control
        constexpr uint32_t ADC0 = (1U << 27);  ///< ADC0 Clock Gate Control
        constexpr uint32_t RTC = (1U << 29);  ///< RTC Access Control
        constexpr uint32_t DAC0 = (1U << 31);  ///< DAC0 Clock Gate Control
    }

    /// SCGC7 Register bits
    namespace scgc7_bits {
        constexpr uint32_t DMA = (1U << 8);  ///< DMA Clock Gate Control
    }

    /// CLKDIV1 Register bits
    namespace clkdiv1_bits {
        constexpr uint32_t OUTDIV4 = (3 << 16);  ///< Clock 4 Output Divider value
        constexpr uint32_t OUTDIV1 = (4 << 28);  ///< Clock 1 Output Divider value
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FLASHDIS = (1U << 0);  ///< Flash Disable
        constexpr uint32_t FLASHDOZE = (1U << 1);  ///< Flash Doze
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program Flash Size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR1 = (7 << 16);  ///< This field concatenated with leading zeros plus the value of the MAXADDR1 field indicates the first invalid address of the second program flash block (flash block 1)
        constexpr uint32_t MAXADDR0 = (7 << 24);  ///< Max Address lock
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID = (16 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// COPC Register bits
    namespace copc_bits {
        constexpr uint32_t COPW = (1U << 0);  ///< COP Windowed Mode
        constexpr uint32_t COPCLKS = (1U << 1);  ///< COP Clock Select
        constexpr uint32_t COPT = (2 << 2);  ///< COP Watchdog Timeout
        constexpr uint32_t COPSTPEN = (1U << 4);  ///< COP Stop Enable
        constexpr uint32_t COPDBGEN = (1U << 5);  ///< COP Debug Enable
        constexpr uint32_t COPCLKSEL = (2 << 6);  ///< COP Clock Select
    }

    /// SRVCOP Register bits
    namespace srvcop_bits {
        constexpr uint32_t SRVCOP = (8 << 0);  ///< Service COP Register
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40049000;
    constexpr uint32_t PORTB_BASE = 0x4004A000;
    constexpr uint32_t PORTC_BASE = 0x4004B000;
    constexpr uint32_t GPIOA_BASE = 0x400FF000;
    constexpr uint32_t GPIOB_BASE = 0x400FF040;
    constexpr uint32_t GPIOC_BASE = 0x400FF080;
    constexpr uint32_t FGPIOA_BASE = 0xF8000000;
    constexpr uint32_t FGPIOB_BASE = 0xF8000040;
    constexpr uint32_t FGPIOC_BASE = 0xF8000080;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR0;  ///< Offset: 0x00 - Pin Control Register n
        volatile uint32_t PCR1;  ///< Offset: 0x04 - Pin Control Register n
        volatile uint32_t PCR2;  ///< Offset: 0x08 - Pin Control Register n
        volatile uint32_t PCR3;  ///< Offset: 0x0C - Pin Control Register n
        volatile uint32_t PCR4;  ///< Offset: 0x10 - Pin Control Register n
        volatile uint32_t PCR5;  ///< Offset: 0x14 - Pin Control Register n
        volatile uint32_t PCR6;  ///< Offset: 0x18 - Pin Control Register n
        volatile uint32_t PCR7;  ///< Offset: 0x1C - Pin Control Register n
        volatile uint32_t PCR8;  ///< Offset: 0x20 - Pin Control Register n
        volatile uint32_t PCR9;  ///< Offset: 0x24 - Pin Control Register n
        volatile uint32_t PCR10;  ///< Offset: 0x28 - Pin Control Register n
        volatile uint32_t PCR11;  ///< Offset: 0x2C - Pin Control Register n
        volatile uint32_t PCR12;  ///< Offset: 0x30 - Pin Control Register n
        volatile uint32_t PCR13;  ///< Offset: 0x34 - Pin Control Register n
        volatile uint32_t PCR14;  ///< Offset: 0x38 - Pin Control Register n
        volatile uint32_t PCR15;  ///< Offset: 0x3C - Pin Control Register n
        volatile uint32_t PCR16;  ///< Offset: 0x40 - Pin Control Register n
        volatile uint32_t PCR17;  ///< Offset: 0x44 - Pin Control Register n
        volatile uint32_t PCR18;  ///< Offset: 0x48 - Pin Control Register n
        volatile uint32_t PCR19;  ///< Offset: 0x4C - Pin Control Register n
        volatile uint32_t PCR20;  ///< Offset: 0x50 - Pin Control Register n
        volatile uint32_t PCR21;  ///< Offset: 0x54 - Pin Control Register n
        volatile uint32_t PCR22;  ///< Offset: 0x58 - Pin Control Register n
        volatile uint32_t PCR23;  ///< Offset: 0x5C - Pin Control Register n
        volatile uint32_t PCR24;  ///< Offset: 0x60 - Pin Control Register n
        volatile uint32_t PCR25;  ///< Offset: 0x64 - Pin Control Register n
        volatile uint32_t PCR26;  ///< Offset: 0x68 - Pin Control Register n
        volatile uint32_t PCR27;  ///< Offset: 0x6C - Pin Control Register n
        volatile uint32_t PCR28;  ///< Offset: 0x70 - Pin Control Register n
        volatile uint32_t PCR29;  ///< Offset: 0x74 - Pin Control Register n
        volatile uint32_t PCR30;  ///< Offset: 0x78 - Pin Control Register n
        volatile uint32_t PCR31;  ///< Offset: 0x7C - Pin Control Register n
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* FGPIOA = reinterpret_cast<Registers*>(FGPIOA_BASE);
    inline Registers* FGPIOB = reinterpret_cast<Registers*>(FGPIOB_BASE);
    inline Registers* FGPIOC = reinterpret_cast<Registers*>(FGPIOC_BASE);

    // Bit definitions
    /// PCR0 Register bits
    namespace pcr0_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR1 Register bits
    namespace pcr1_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR2 Register bits
    namespace pcr2_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR3 Register bits
    namespace pcr3_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR4 Register bits
    namespace pcr4_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR5 Register bits
    namespace pcr5_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR6 Register bits
    namespace pcr6_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR7 Register bits
    namespace pcr7_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR8 Register bits
    namespace pcr8_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR9 Register bits
    namespace pcr9_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR10 Register bits
    namespace pcr10_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR11 Register bits
    namespace pcr11_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR12 Register bits
    namespace pcr12_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR13 Register bits
    namespace pcr13_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR14 Register bits
    namespace pcr14_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR15 Register bits
    namespace pcr15_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR16 Register bits
    namespace pcr16_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR17 Register bits
    namespace pcr17_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR18 Register bits
    namespace pcr18_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR19 Register bits
    namespace pcr19_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR20 Register bits
    namespace pcr20_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR21 Register bits
    namespace pcr21_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR22 Register bits
    namespace pcr22_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR23 Register bits
    namespace pcr23_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR24 Register bits
    namespace pcr24_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR25 Register bits
    namespace pcr25_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR26 Register bits
    namespace pcr26_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR27 Register bits
    namespace pcr27_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR28 Register bits
    namespace pcr28_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR29 Register bits
    namespace pcr29_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR30 Register bits
    namespace pcr30_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR31 Register bits
    namespace pcr31_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART0_BASE = 0x40054000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BAUD;  ///< Offset: 0x00 - LPUART Baud Rate Register
        volatile uint32_t STAT;  ///< Offset: 0x04 - LPUART Status Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - LPUART Control Register
        volatile uint32_t DATA;  ///< Offset: 0x0C - LPUART Data Register
        volatile uint32_t MATCH;  ///< Offset: 0x10 - LPUART Match Address Register
        volatile uint32_t MODIR;  ///< Offset: 0x14 - LPUART Modem IrDA Register
    };

    /// Peripheral instances
    inline Registers* LPUART0 = reinterpret_cast<Registers*>(LPUART0_BASE);

    // Bit definitions
    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t SBR = (13 << 0);  ///< Baud Rate Modulo Divisor.
        constexpr uint32_t SBNS = (1U << 13);  ///< Stop Bit Number Select
        constexpr uint32_t RXEDGIE = (1U << 14);  ///< RX Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 15);  ///< LIN Break Detect Interrupt Enable
        constexpr uint32_t RESYNCDIS = (1U << 16);  ///< Resynchronization Disable
        constexpr uint32_t BOTHEDGE = (1U << 17);  ///< Both Edge Sampling
        constexpr uint32_t MATCFG = (2 << 18);  ///< Match Configuration
        constexpr uint32_t RDMAE = (1U << 21);  ///< Receiver Full DMA Enable
        constexpr uint32_t TDMAE = (1U << 23);  ///< Transmitter DMA Enable
        constexpr uint32_t OSR = (5 << 24);  ///< Oversampling Ratio
        constexpr uint32_t M10 = (1U << 29);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 30);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 31);  ///< Match Address Mode Enable 1
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t MA2F = (1U << 14);  ///< Match 2 Flag
        constexpr uint32_t MA1F = (1U << 15);  ///< Match 1 Flag
        constexpr uint32_t PF = (1U << 16);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 17);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 18);  ///< Noise Flag
        constexpr uint32_t OR = (1U << 19);  ///< Receiver Overrun Flag
        constexpr uint32_t IDLE = (1U << 20);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 21);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 22);  ///< Transmission Complete Flag
        constexpr uint32_t TDRE = (1U << 23);  ///< Transmit Data Register Empty Flag
        constexpr uint32_t RAF = (1U << 24);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 25);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 26);  ///< Break Character Generation Length
        constexpr uint32_t RWUID = (1U << 27);  ///< Receive Wake Up Idle Detect
        constexpr uint32_t RXINV = (1U << 28);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 29);  ///< MSB First
        constexpr uint32_t RXEDGIF = (1U << 30);  ///< LPUART_RX Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 31);  ///< LIN Break Detect Interrupt Flag
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-Bit or 8-Bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t DOZEEN = (1U << 6);  ///< Doze Enable
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
        constexpr uint32_t IDLECFG = (3 << 8);  ///< Idle Configuration
        constexpr uint32_t MA2IE = (1U << 14);  ///< Match 2 Interrupt Enable
        constexpr uint32_t MA1IE = (1U << 15);  ///< Match 1 Interrupt Enable
        constexpr uint32_t SBK = (1U << 16);  ///< Send Break
        constexpr uint32_t RWU = (1U << 17);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 18);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 19);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 20);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 21);  ///< Receiver Interrupt Enable
        constexpr uint32_t TCIE = (1U << 22);  ///< Transmission Complete Interrupt Enable for
        constexpr uint32_t TIE = (1U << 23);  ///< Transmit Interrupt Enable
        constexpr uint32_t PEIE = (1U << 24);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 25);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 26);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 27);  ///< Overrun Interrupt Enable
        constexpr uint32_t TXINV = (1U << 28);  ///< Transmit Data Inversion
        constexpr uint32_t TXDIR = (1U << 29);  ///< LPUART_TX Pin Direction in Single-Wire Mode
        constexpr uint32_t R9T8 = (1U << 30);  ///< Receive Bit 9 / Transmit Bit 8
        constexpr uint32_t R8T9 = (1U << 31);  ///< Receive Bit 8 / Transmit Bit 9
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t R0T0 = (1U << 0);  ///< Read receive data buffer 0 or write transmit data buffer 0.
        constexpr uint32_t R1T1 = (1U << 1);  ///< Read receive data buffer 1 or write transmit data buffer 1.
        constexpr uint32_t R2T2 = (1U << 2);  ///< Read receive data buffer 2 or write transmit data buffer 2.
        constexpr uint32_t R3T3 = (1U << 3);  ///< Read receive data buffer 3 or write transmit data buffer 3.
        constexpr uint32_t R4T4 = (1U << 4);  ///< Read receive data buffer 4 or write transmit data buffer 4.
        constexpr uint32_t R5T5 = (1U << 5);  ///< Read receive data buffer 5 or write transmit data buffer 5.
        constexpr uint32_t R6T6 = (1U << 6);  ///< Read receive data buffer 6 or write transmit data buffer 6.
        constexpr uint32_t R7T7 = (1U << 7);  ///< Read receive data buffer 7 or write transmit data buffer 7.
        constexpr uint32_t R8T8 = (1U << 8);  ///< Read receive data buffer 8 or write transmit data buffer 8.
        constexpr uint32_t R9T9 = (1U << 9);  ///< Read receive data buffer 9 or write transmit data buffer 9.
        constexpr uint32_t IDLINE = (1U << 11);  ///< Idle Line
        constexpr uint32_t RXEMPT = (1U << 12);  ///< Receive Buffer Empty
        constexpr uint32_t FRETSC = (1U << 13);  ///< Frame Error / Transmit Special Character
        constexpr uint32_t PARITYE = (1U << 14);  ///< The current received dataword contained in DATA[R9:R0] was received with a parity error.
        constexpr uint32_t NOISY = (1U << 15);  ///< The current received dataword contained in DATA[R9:R0] was received with noise.
    }

    /// MATCH Register bits
    namespace match_bits {
        constexpr uint32_t MA1 = (10 << 0);  ///< Match Address 1
        constexpr uint32_t MA2 = (10 << 16);  ///< Match Address 2
    }

    /// MODIR Register bits
    namespace modir_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
        constexpr uint32_t TXCTSC = (1U << 4);  ///< Transmit CTS Configuration
        constexpr uint32_t TXCTSSRC = (1U << 5);  ///< Transmit CTS Source
        constexpr uint32_t TNP = (2 << 16);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 18);  ///< Infrared enable
    }

}

// ============================================================================
// LTC0 Peripheral
// ============================================================================

namespace ltc0 {
    /// Base addresses
    constexpr uint32_t LTC0_BASE = 0x40058000;

    /// LTC0 Register structure
    struct Registers {
        volatile uint32_t LTC_MD;  ///< Offset: 0x00 - LTC Mode Register
        volatile uint32_t LTC_KS;  ///< Offset: 0x08 - LTC Key Size Register
        volatile uint32_t LTC_DS;  ///< Offset: 0x10 - LTC Data Size Register
        volatile uint32_t LTC_ICVS;  ///< Offset: 0x18 - LTC ICV Size Register
        volatile uint32_t LTC_COM;  ///< Offset: 0x30 - LTC Command Register
        volatile uint32_t LTC_CTL;  ///< Offset: 0x34 - LTC Control Register
        volatile uint32_t LTC_CW;  ///< Offset: 0x40 - LTC Clear Written Register
        volatile uint32_t LTC_STA;  ///< Offset: 0x48 - LTC Status Register
        volatile uint32_t LTC_ESTA;  ///< Offset: 0x4C - LTC Error Status Register
        volatile uint32_t LTC_AADSZ;  ///< Offset: 0x58 - LTC AAD Size Register
        volatile uint32_t LTC_CTX_0;  ///< Offset: 0x100 - LTC Context Register
        volatile uint32_t LTC_CTX_1;  ///< Offset: 0x104 - LTC Context Register
        volatile uint32_t LTC_CTX_2;  ///< Offset: 0x108 - LTC Context Register
        volatile uint32_t LTC_CTX_3;  ///< Offset: 0x10C - LTC Context Register
        volatile uint32_t LTC_CTX_4;  ///< Offset: 0x110 - LTC Context Register
        volatile uint32_t LTC_CTX_5;  ///< Offset: 0x114 - LTC Context Register
        volatile uint32_t LTC_CTX_6;  ///< Offset: 0x118 - LTC Context Register
        volatile uint32_t LTC_CTX_7;  ///< Offset: 0x11C - LTC Context Register
        volatile uint32_t LTC_CTX_8;  ///< Offset: 0x120 - LTC Context Register
        volatile uint32_t LTC_CTX_9;  ///< Offset: 0x124 - LTC Context Register
        volatile uint32_t LTC_CTX_10;  ///< Offset: 0x128 - LTC Context Register
        volatile uint32_t LTC_CTX_11;  ///< Offset: 0x12C - LTC Context Register
        volatile uint32_t LTC_CTX_12;  ///< Offset: 0x130 - LTC Context Register
        volatile uint32_t LTC_CTX_13;  ///< Offset: 0x134 - LTC Context Register
        volatile uint32_t LTC_CTX_14;  ///< Offset: 0x138 - LTC Context Register
        volatile uint32_t LTC_CTX_15;  ///< Offset: 0x13C - LTC Context Register
        volatile uint32_t LTC_KEY_0;  ///< Offset: 0x200 - LTC Key Registers
        volatile uint32_t LTC_KEY_1;  ///< Offset: 0x204 - LTC Key Registers
        volatile uint32_t LTC_KEY_2;  ///< Offset: 0x208 - LTC Key Registers
        volatile uint32_t LTC_KEY_3;  ///< Offset: 0x20C - LTC Key Registers
        volatile uint32_t LTC_VID2;  ///< Offset: 0x4F4 - LTC Version ID 2 Register
        volatile uint32_t LTC_FIFOSTA;  ///< Offset: 0x7C0 - LTC FIFO Status Register
        volatile uint32_t LTC_IFIFO;  ///< Offset: 0x7E0 - LTC Input Data FIFO
        volatile uint32_t LTC_OFIFO;  ///< Offset: 0x7F0 - LTC Output Data FIFO
        volatile uint32_t LTC_VID1;  ///< Offset: 0x8F0 - LTC Version ID Register
        volatile uint32_t LTC_CHAVID;  ///< Offset: 0x8F8 - LTC CHA Version ID Register
    };

    /// Peripheral instances
    inline Registers* LTC0 = reinterpret_cast<Registers*>(LTC0_BASE);

    // Bit definitions
    /// LTC_MD Register bits
    namespace ltc_md_bits {
        constexpr uint32_t ENC = (1U << 0);  ///< Encrypt/Decrypt. This bit selects encryption or decryption.
        constexpr uint32_t ICV_TEST = (1U << 1);  ///< ICV Checking / Test AES fault detection
        constexpr uint32_t AS = (2 << 2);  ///< Algorithm State
        constexpr uint32_t AAI = (9 << 4);  ///< Additional Algorithm information
        constexpr uint32_t ALG = (8 << 16);  ///< Algorithm. This field specifies which algorithm is being selected.
    }

    /// LTC_KS Register bits
    namespace ltc_ks_bits {
        constexpr uint32_t KS = (5 << 0);  ///< Key Size. This is the size of a Key measured in bytes
    }

    /// LTC_DS Register bits
    namespace ltc_ds_bits {
        constexpr uint32_t DS = (12 << 0);  ///< Data Size
    }

    /// LTC_ICVS Register bits
    namespace ltc_icvs_bits {
        constexpr uint32_t ICVS = (5 << 0);  ///< ICV Size, in Bytes.
    }

    /// LTC_COM Register bits
    namespace ltc_com_bits {
        constexpr uint32_t ALL = (1U << 0);  ///< Reset All Internal Logic
        constexpr uint32_t AES = (1U << 1);  ///< Reset AESA. Writing a 1 to this bit resets the AES Accelerator core engine.
    }

    /// LTC_CTL Register bits
    namespace ltc_ctl_bits {
        constexpr uint32_t IM = (1U << 0);  ///< Interrupt Mask. Once this bit is set, it can only be cleared by hard reset.
        constexpr uint32_t IFE = (1U << 8);  ///< Input FIFO DMA Enable.
        constexpr uint32_t IFR = (1U << 9);  ///< Input FIFO DMA Request Size
        constexpr uint32_t OFE = (1U << 12);  ///< Output FIFO DMA Enable.
        constexpr uint32_t OFR = (1U << 13);  ///< Output FIFO DMA Request Size
        constexpr uint32_t IFS = (1U << 16);  ///< Input FIFO Byte Swap. Byte swap all data that is written to the Input FIFO.
        constexpr uint32_t OFS = (1U << 17);  ///< Output FIFO Byte Swap. Byte swap all data that is read from the Onput FIFO.
        constexpr uint32_t KIS = (1U << 20);  ///< Key Register Input Byte Swap
        constexpr uint32_t KOS = (1U << 21);  ///< Key Register Output Byte Swap
        constexpr uint32_t CIS = (1U << 22);  ///< Context Register Input Byte Swap
        constexpr uint32_t COS = (1U << 23);  ///< Context Register Output Byte Swap
        constexpr uint32_t KAL = (1U << 31);  ///< Key Register Access Lock
    }

    /// LTC_CW Register bits
    namespace ltc_cw_bits {
        constexpr uint32_t CM = (1U << 0);  ///< Clear the Mode Register. Writing a one to this bit causes the Mode Register to be cleared.
        constexpr uint32_t CDS = (1U << 2);  ///< Clear the Data Size Register
        constexpr uint32_t CICV = (1U << 3);  ///< Clear the ICV Size Register. Writing a one to this bit causes the ICV Size Register to be cleared.
        constexpr uint32_t CCR = (1U << 5);  ///< Clear the Context Register. Writing a one to this bit causes the Context Register to be cleared.
        constexpr uint32_t CKR = (1U << 6);  ///< Clear the Key Register
        constexpr uint32_t COF = (1U << 30);  ///< Clear Output FIFO. Writing a 1 to this bit causes the Output FIFO to be cleared.
        constexpr uint32_t CIF = (1U << 31);  ///< Clear Input FIFO. Writing a 1 to this bit causes the Input Data FIFO.
    }

    /// LTC_STA Register bits
    namespace ltc_sta_bits {
        constexpr uint32_t AB = (1U << 1);  ///< AESA Busy
        constexpr uint32_t DI = (1U << 16);  ///< Done Interrupt
        constexpr uint32_t EI = (1U << 20);  ///< Error Interrupt
    }

    /// LTC_ESTA Register bits
    namespace ltc_esta_bits {
        constexpr uint32_t ERRID1 = (4 << 0);  ///< Error ID 1
        constexpr uint32_t CL1 = (4 << 8);  ///< algorithms. The algorithms field indicates which algorithm is asserting an error. Others reserved
    }

    /// LTC_AADSZ Register bits
    namespace ltc_aadsz_bits {
        constexpr uint32_t AADSZ = (4 << 0);  ///< AAD size in Bytes, mod 16.
        constexpr uint32_t AL = (1U << 31);  ///< AAD Last. Only AAD data will be written into the Input FIFO.
    }

    /// LTC_CTX_0 Register bits
    namespace ltc_ctx_0_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_1 Register bits
    namespace ltc_ctx_1_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_2 Register bits
    namespace ltc_ctx_2_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_3 Register bits
    namespace ltc_ctx_3_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_4 Register bits
    namespace ltc_ctx_4_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_5 Register bits
    namespace ltc_ctx_5_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_6 Register bits
    namespace ltc_ctx_6_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_7 Register bits
    namespace ltc_ctx_7_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_8 Register bits
    namespace ltc_ctx_8_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_9 Register bits
    namespace ltc_ctx_9_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_10 Register bits
    namespace ltc_ctx_10_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_11 Register bits
    namespace ltc_ctx_11_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_12 Register bits
    namespace ltc_ctx_12_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_13 Register bits
    namespace ltc_ctx_13_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_14 Register bits
    namespace ltc_ctx_14_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_CTX_15 Register bits
    namespace ltc_ctx_15_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC_KEY_0 Register bits
    namespace ltc_key_0_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC_KEY_1 Register bits
    namespace ltc_key_1_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC_KEY_2 Register bits
    namespace ltc_key_2_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC_KEY_3 Register bits
    namespace ltc_key_3_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC_VID2 Register bits
    namespace ltc_vid2_bits {
        constexpr uint32_t ECO_REV = (8 << 0);  ///< ECO revision number.
        constexpr uint32_t ARCH_ERA = (8 << 8);  ///< Architectural ERA.
    }

    /// LTC_FIFOSTA Register bits
    namespace ltc_fifosta_bits {
        constexpr uint32_t IFL = (7 << 0);  ///< Input FIFO Level. These bits indicate the current number of entries in the Input FIFO.
        constexpr uint32_t IFF = (1U << 15);  ///< Input FIFO Full. The Input FIFO is full and should not be written to.
        constexpr uint32_t OFL = (7 << 16);  ///< Output FIFO Level. These bits indicate the current number of entries in the Output FIFO.
        constexpr uint32_t OFF = (1U << 31);  ///< Output FIFO Full. The Output FIFO is full and should not be written to.
    }

    /// LTC_IFIFO Register bits
    namespace ltc_ififo_bits {
        constexpr uint32_t IFIFO = (32 << 0);  ///< IFIFO
    }

    /// LTC_OFIFO Register bits
    namespace ltc_ofifo_bits {
        constexpr uint32_t OFIFO = (32 << 0);  ///< Output FIFO
    }

    /// LTC_VID1 Register bits
    namespace ltc_vid1_bits {
        constexpr uint32_t MIN_REV = (8 << 0);  ///< Minor revision number.
        constexpr uint32_t MAJ_REV = (8 << 8);  ///< Major revision number.
        constexpr uint32_t IP_ID = (16 << 16);  ///< no description available
    }

    /// LTC_CHAVID Register bits
    namespace ltc_chavid_bits {
        constexpr uint32_t AESREV = (4 << 0);  ///< AES Revision Number
        constexpr uint32_t AESVID = (4 << 4);  ///< AES Version ID
    }

}

// ============================================================================
// RSIM Peripheral
// ============================================================================

namespace rsim {
    /// Base addresses
    constexpr uint32_t RSIM_BASE = 0x40059000;

    /// RSIM Register structure
    struct Registers {
        volatile uint32_t CONTROL;  ///< Offset: 0x00 - RSIM Control
        volatile uint32_t ACTIVE_DELAY;  ///< Offset: 0x04 - RSIM BLE Active Delay
        volatile uint32_t MAC_MSB;  ///< Offset: 0x08 - RSIM MAC MSB
        volatile uint32_t MAC_LSB;  ///< Offset: 0x0C - RSIM MAC LSB
        volatile uint32_t ANA_TEST;  ///< Offset: 0x10 - RSIM Analog Test
    };

    /// Peripheral instances
    inline Registers* RSIM = reinterpret_cast<Registers*>(RSIM_BASE);

    // Bit definitions
    /// CONTROL Register bits
    namespace control_bits {
        constexpr uint32_t BLE_RF_OSC_REQ_EN = (1U << 0);  ///< BLE Ref Osc (Sysclk) Request Enable
        constexpr uint32_t BLE_RF_OSC_REQ_STAT = (1U << 1);  ///< BLE Ref Osc (Sysclk) Request Status
        constexpr uint32_t BLE_RF_OSC_REQ_INT_EN = (1U << 4);  ///< BLE Ref Osc (Sysclk) Request Interrupt Enable
        constexpr uint32_t BLE_RF_OSC_REQ_INT = (1U << 5);  ///< BLE Ref Osc (Sysclk) Request Interrupt Flag
        constexpr uint32_t RF_OSC_EN = (4 << 8);  ///< RF Ref Osc Enable [3:0]
        constexpr uint32_t GASKET_BYPASS_OVRD_EN = (1U << 12);  ///< Gasket Bypass Override Enable
        constexpr uint32_t GASKET_BYPASS_OVRD = (1U << 13);  ///< Gasket Bypass Override
        constexpr uint32_t RF_OSC_BYPASS_EN = (1U << 14);  ///< RF Ref Osc Bypass Enable
        constexpr uint32_t BLE_ACTIVE_PORT_1_SEL = (1U << 16);  ///< BLE Active port 1 select
        constexpr uint32_t BLE_ACTIVE_PORT_2_SEL = (1U << 17);  ///< BLE Active port 2 select
        constexpr uint32_t BLE_DEEP_SLEEP_EXIT = (1U << 20);  ///< BLE Deep Sleep Exit
        constexpr uint32_t STOP_ACK_OVRD_EN = (1U << 22);  ///< Stop Acknowledge Override Enable
        constexpr uint32_t STOP_ACK_OVRD = (1U << 23);  ///< Stop Acknowledge Override
        constexpr uint32_t RF_OSC_READY = (1U << 24);  ///< RF Ref Osc Ready
        constexpr uint32_t RF_OSC_READY_OVRD_EN = (1U << 25);  ///< RF Ref Osc Ready Override Enable
        constexpr uint32_t RF_OSC_READY_OVRD = (1U << 26);  ///< RF Ref Osc Ready Override
        constexpr uint32_t BLOCK_RADIO_RESETS = (1U << 28);  ///< Block Radio Resets
        constexpr uint32_t BLOCK_RADIO_OUTPUTS = (1U << 29);  ///< Block Radio Outputs
        constexpr uint32_t RADIO_RESET = (1U << 31);  ///< Software Reset for the Radio
    }

    /// ACTIVE_DELAY Register bits
    namespace active_delay_bits {
        constexpr uint32_t BLE_ACTIVE_FINE_DELAY = (6 << 0);  ///< The SoC Flash is presented with a BLE Active early warning signal to allow the Flash to complete any program or erase activities prior to a Radio communication event
        constexpr uint32_t BLE_ACTIVE_COARSE_DELAY = (4 << 16);  ///< The SoC Flash is presented with a BLE Active early warning signal to allow the Flash to complete any program or erase activities prior to a Radio communication event
    }

    /// MAC_MSB Register bits
    namespace mac_msb_bits {
        constexpr uint32_t MAC_ADDR_MSB = (8 << 0);  ///< MAC Address MSB
    }

    /// MAC_LSB Register bits
    namespace mac_lsb_bits {
        constexpr uint32_t MAC_ADDR_LSB = (32 << 0);  ///< MAC Address LSB
    }

    /// ANA_TEST Register bits
    namespace ana_test_bits {
        constexpr uint32_t ATST_GATE_EN = (5 << 0);  ///< ATST Transmission Gate Enables
        constexpr uint32_t RADIO_ID = (4 << 24);  ///< Radio Version ID number
    }

}

// ============================================================================
// DCDC Peripheral
// ============================================================================

namespace dcdc {
    /// Base addresses
    constexpr uint32_t DCDC_BASE = 0x4005A000;

    /// DCDC Register structure
    struct Registers {
        volatile uint32_t REG0;  ///< Offset: 0x00 - DCDC REGISTER 0
        volatile uint32_t REG1;  ///< Offset: 0x04 - DCDC REGISTER 1
        volatile uint32_t REG2;  ///< Offset: 0x08 - DCDC REGISTER 2
        volatile uint32_t REG3;  ///< Offset: 0x0C - DCDC REGISTER 3
        volatile uint32_t REG4;  ///< Offset: 0x10 - DCDC REGISTER 4
        volatile uint32_t REG6;  ///< Offset: 0x18 - DCDC REGISTER 6
        volatile uint32_t REG7;  ///< Offset: 0x1C - DCDC REGISTER 7
    };

    /// Peripheral instances
    inline Registers* DCDC = reinterpret_cast<Registers*>(DCDC_BASE);

    // Bit definitions
    /// REG0 Register bits
    namespace reg0_bits {
        constexpr uint32_t DCDC_DISABLE_AUTO_CLK_SWITCH = (1U << 1);  ///< Disable automatic clock switch from internal oscillator to external clock.
        constexpr uint32_t DCDC_SEL_CLK = (1U << 2);  ///< Select external clock for DCDC when DCDC_DISABLE_AUTO_CLK_SWITCH is set.
        constexpr uint32_t DCDC_PWD_OSC_INT = (1U << 3);  ///< Power down internal oscillator. Only set this bit when 32M crystal oscillator is available.
        constexpr uint32_t DCDC_LP_DF_CMP_ENABLE = (1U << 9);  ///< Enable low power differential comparators, to sense lower supply in pulsed mode
        constexpr uint32_t DCDC_VBAT_DIV_CTRL = (2 << 10);  ///< Controls VBAT voltage divider
        constexpr uint32_t DCDC_LP_STATE_HYS_L = (2 << 17);  ///< Configure the hysteretic lower threshold value in low power mode
        constexpr uint32_t DCDC_LP_STATE_HYS_H = (2 << 19);  ///< Configure the hysteretic upper threshold value in low power mode
        constexpr uint32_t HYST_LP_COMP_ADJ = (1U << 21);  ///< Adjust hysteretic value in low power comparator.
        constexpr uint32_t HYST_LP_CMP_DISABLE = (1U << 22);  ///< Disable hysteresis in low power comparator.
        constexpr uint32_t OFFSET_RSNS_LP_ADJ = (1U << 23);  ///< Adjust hysteretic value in low power voltage sense.
        constexpr uint32_t OFFSET_RSNS_LP_DISABLE = (1U << 24);  ///< Disable hysteresis in low power voltage sense.
        constexpr uint32_t DCDC_LESS_I = (1U << 25);  ///< Reduce DCDC current. It will save approximately 20 uA in RUN.
        constexpr uint32_t PWD_CMP_OFFSET = (1U << 26);  ///< Power down output range comparator
        constexpr uint32_t DCDC_XTALOK_DISABLE = (1U << 27);  ///< Disable xtalok detection circuit.
        constexpr uint32_t PSWITCH_STATUS = (1U << 28);  ///< Status register to indicate PSWITCH status
        constexpr uint32_t VLPS_CONFIG_DCDC_HP = (1U << 29);  ///< Selects behavior of DCDC in device VLPS low power mode
        constexpr uint32_t VLPR_VLPW_CONFIG_DCDC_HP = (1U << 30);  ///< Selects behavior of DCDC in device VLPR and VLPW low power modes
        constexpr uint32_t DCDC_STS_DC_OK = (1U << 31);  ///< Status register to indicate DCDC lock
    }

    /// REG1 Register bits
    namespace reg1_bits {
        constexpr uint32_t POSLIMIT_BUCK_IN = (7 << 0);  ///< Upper limit duty cycle limit in DC-DC converter
        constexpr uint32_t POSLIMIT_BOOST_IN = (7 << 7);  ///< Upper limit duty cycle limit in DC-DC converter
        constexpr uint32_t DCDC_LOOPCTRL_CM_HST_THRESH = (1U << 21);  ///< Enable hysteresis in switching converter common mode analog comparators
        constexpr uint32_t DCDC_LOOPCTRL_DF_HST_THRESH = (1U << 22);  ///< Enable hysteresis in switching converter differential mode analog comparators
        constexpr uint32_t DCDC_LOOPCTRL_EN_CM_HYST = (1U << 23);  ///< Enable hysteresis in switching converter common mode analog comparators
        constexpr uint32_t DCDC_LOOPCTRL_EN_DF_HYST = (1U << 24);  ///< Enable hysteresis in switching converter differential mode analog comparators
    }

    /// REG2 Register bits
    namespace reg2_bits {
        constexpr uint32_t DCDC_LOOPCTRL_DC_C = (2 << 0);  ///< Ratio of integral control parameter to proportional control parameter in the switching DC-DC converter, it can be used to optimize efficiency and loop response
        constexpr uint32_t DCDC_LOOPCTRL_DC_FF = (3 << 6);  ///< Two complement feed forward step in duty cycle in the switching DC-DC converter
        constexpr uint32_t DCDC_LOOPCTRL_HYST_SIGN = (1U << 13);  ///< Invert the sign of the hysteresis in DC-DC analog comparators. This bit is set when in Pulsed mode.
        constexpr uint32_t DCDC_LOOPCTRL_TOGGLE_DIF = (1U << 14);  ///< Set high to enable supply stepping to change, only after the differential control loop has toggled
        constexpr uint32_t DCDC_BATTMONITOR_EN_BATADJ = (1U << 15);  ///< This bit enables the DC-DC to improve efficiency and minimize ripple using the information from the BATT_VAL field
        constexpr uint32_t DCDC_BATTMONITOR_BATT_VAL = (10 << 16);  ///< Software should be configured to place the battery voltage in this register measured with an 8 mV LSB resolution through the ADC
    }

    /// REG3 Register bits
    namespace reg3_bits {
        constexpr uint32_t DCDC_VDD1P8CTRL_TRG = (6 << 0);  ///< Target value of VDD1P8, 25 mV each step in two ranges, from 0x00 to 0x11 and 0x20 to 0x3F.
        constexpr uint32_t DCDC_VDD1P45CTRL_TRG_BUCK = (5 << 6);  ///< Target value of VDD1P45 in buck mode, 25 mV each step from 0x00 to 0x0F
        constexpr uint32_t DCDC_VDD1P45CTRL_TRG_BOOST = (5 << 11);  ///< Target value of VDD1P45 in boost mode, 25 mV each step from 0x00 to 0x0F
        constexpr uint32_t DCDC_VDD1P45CTRL_ADJTN = (4 << 17);  ///< Adjust value of duty cycle when switching between VDD1P45 and VDD1P8. The unit is 1/32 or 3.125%.
        constexpr uint32_t DCDC_MINPWR_DC_HALFCLK_PULSED = (1U << 21);  ///< Set DCDC clock to half frequency for the Pulsed mode.
        constexpr uint32_t DCDC_MINPWR_DOUBLE_FETS_PULSED = (1U << 22);  ///< Use double switch FET for the Pulsed mode.
        constexpr uint32_t DCDC_MINPWR_HALF_FETS_PULSED = (1U << 23);  ///< Use half switch FET for the Pulsed mode.
        constexpr uint32_t DCDC_MINPWR_DC_HALFCLK = (1U << 24);  ///< Set DCDC clock to half frequency for the continuous mode.
        constexpr uint32_t DCDC_MINPWR_DOUBLE_FETS = (1U << 25);  ///< Use double switch FET for the continuous mode.
        constexpr uint32_t DCDC_MINPWR_HALF_FETS = (1U << 26);  ///< Use half switch FET for the continuous mode.
        constexpr uint32_t DCDC_VDD1P45CTRL_DISABLE_STEP = (1U << 29);  ///< Disable stepping for VDD1P45. Must set this bit before enter low power modes.
        constexpr uint32_t DCDC_VDD1P8CTRL_DISABLE_STEP = (1U << 30);  ///< Disable stepping for VDD1P8. Must set this bit before enter low power modes.
    }

    /// REG4 Register bits
    namespace reg4_bits {
        constexpr uint32_t DCDC_SW_SHUTDOWN = (1U << 0);  ///< Shut down DCDC in buck mode. DCDC can be turned on by pulling PSWITCH to high momentarily (min 50 ms).
        constexpr uint32_t UNLOCK = (16 << 16);  ///< 0x3E77 KEY-Key needed to unlock HW_POWER_RESET register
    }

    /// REG6 Register bits
    namespace reg6_bits {
        constexpr uint32_t PSWITCH_INT_RISE_EN = (1U << 0);  ///< Enable rising edge detect for interrupt.
        constexpr uint32_t PSWITCH_INT_FALL_EN = (1U << 1);  ///< Enable falling edge detect for interrupt.
        constexpr uint32_t PSWITCH_INT_CLEAR = (1U << 2);  ///< Write 1 to clear interrupt. Set to 0 after clear.
        constexpr uint32_t PSWITCH_INT_MUTE = (1U << 3);  ///< Mask interrupt to SoC, edge detection result can be read from PSIWTCH_INT_STS.
        constexpr uint32_t PSWITCH_INT_STS = (1U << 31);  ///< PSWITCH edge detection interrupt status
    }

    /// REG7 Register bits
    namespace reg7_bits {
        constexpr uint32_t INTEGRATOR_VALUE = (19 << 0);  ///< Integrator value which can be loaded in pulsed mode
        constexpr uint32_t INTEGRATOR_VALUE_SEL = (1U << 19);  ///< Select the integrator value from above register or saved value in hardware.
        constexpr uint32_t PULSE_RUN_SPEEDUP = (1U << 20);  ///< Enable pulse run speedup
    }

}

// ============================================================================
// RADIO Peripheral
// ============================================================================

namespace radio {
    /// Base addresses
    constexpr uint32_t BLE_RF_REGS_BASE = 0x4005B000;

    /// RADIO Register structure
    struct Registers {
        volatile uint32_t BLE_PART_ID;  ///< Offset: 0xD00 - Bluetooth Low Energy Part ID
        volatile uint32_t DSM_STATUS;  ///< Offset: 0xD04 - DSM Status
        volatile uint32_t BLE_AFC;  ///< Offset: 0xD08 - Bluetooth Low Energy AFC
        volatile uint32_t BLE_BSM;  ///< Offset: 0xD0C - Bluetooth Low Energy BSM
    };

    /// Peripheral instances
    inline Registers* BLE_RF_REGS = reinterpret_cast<Registers*>(BLE_RF_REGS_BASE);

    // Bit definitions
    /// BLE_PART_ID Register bits
    namespace ble_part_id_bits {
        constexpr uint32_t BLE_PART_ID = (16 << 0);  ///< BLE Part ID
    }

    /// DSM_STATUS Register bits
    namespace dsm_status_bits {
        constexpr uint32_t ORF_SYSCLK_REQ = (1U << 0);  ///< RF Oscillator Requested
        constexpr uint32_t RIF_LL_ACTIVE = (1U << 1);  ///< Link Layer Active
    }

    /// BLE_AFC Register bits
    namespace ble_afc_bits {
        constexpr uint32_t BLE_AFC = (14 << 0);  ///< BLE AFC Result
        constexpr uint32_t LATCH_AFC_ON_ACCESS_MATCH = (1U << 15);  ///< Latch AFC Estimation on Access Address Match
    }

    /// BLE_BSM Register bits
    namespace ble_bsm_bits {
        constexpr uint32_t BSM_EN_BLE = (1U << 0);  ///< BLE Bit Streaming Mode Enable
    }

}

// ============================================================================
// XCVR Peripheral
// ============================================================================

namespace xcvr {
    /// Base addresses
    constexpr uint32_t XCVR_BASE = 0x4005C000;

    /// XCVR Register structure
    struct Registers {
        volatile uint32_t RX_DIG_CTRL;  ///< Offset: 0x00 - RX Digital Control
        volatile uint32_t AGC_CTRL_0;  ///< Offset: 0x04 - AGC Control 0
        volatile uint32_t AGC_CTRL_1;  ///< Offset: 0x08 - AGC Control 1
        volatile uint32_t AGC_CTRL_2;  ///< Offset: 0x0C - AGC Control 2
        volatile uint32_t AGC_CTRL_3;  ///< Offset: 0x10 - AGC Control 3
        volatile uint32_t AGC_STAT;  ///< Offset: 0x14 - AGC Status
        volatile uint32_t RSSI_CTRL_0;  ///< Offset: 0x18 - RSSI Control 0
        volatile uint32_t RSSI_CTRL_1;  ///< Offset: 0x1C - RSSI Control 1
        volatile uint32_t DCOC_CTRL_0;  ///< Offset: 0x20 - DCOC Control 0
        volatile uint32_t DCOC_CTRL_1;  ///< Offset: 0x24 - DCOC Control 1
        volatile uint32_t DCOC_CTRL_2;  ///< Offset: 0x28 - DCOC Control 2
        volatile uint32_t DCOC_CTRL_3;  ///< Offset: 0x2C - DCOC Control 3
        volatile uint32_t DCOC_CTRL_4;  ///< Offset: 0x30 - DCOC Control 4
        volatile uint32_t DCOC_CAL_GAIN;  ///< Offset: 0x34 - DCOC Calibration Gain
        volatile uint32_t DCOC_STAT;  ///< Offset: 0x38 - DCOC Status
        volatile uint32_t DCOC_DC_EST;  ///< Offset: 0x3C - DCOC DC Estimate
        volatile uint32_t DCOC_CAL_RCP;  ///< Offset: 0x40 - DCOC Calibration Reciprocals
        volatile uint32_t IQMC_CTRL;  ///< Offset: 0x4C - IQMC Control
        volatile uint32_t IQMC_CAL;  ///< Offset: 0x50 - IQMC Calibration
        volatile uint32_t TCA_AGC_VAL_3_0;  ///< Offset: 0x54 - TCA AGC Step Values 3..0
        volatile uint32_t TCA_AGC_VAL_7_4;  ///< Offset: 0x58 - TCA AGC Step Values 7..4
        volatile uint32_t TCA_AGC_VAL_8;  ///< Offset: 0x5C - TCA AGC Step Values 8
        volatile uint32_t BBF_RES_TUNE_VAL_7_0;  ///< Offset: 0x60 - BBF Resistor Tune Values 7..0
        volatile uint32_t BBF_RES_TUNE_VAL_10_8;  ///< Offset: 0x64 - BBF Resistor Tune Values 10..8
        volatile uint32_t TCA_AGC_LIN_VAL_2_0;  ///< Offset: 0x68 - TCA AGC Linear Gain Values 2..0
        volatile uint32_t TCA_AGC_LIN_VAL_5_3;  ///< Offset: 0x6C - TCA AGC Linear Gain Values 5..3
        volatile uint32_t TCA_AGC_LIN_VAL_8_6;  ///< Offset: 0x70 - TCA AGC Linear Gain Values 8..6
        volatile uint32_t BBF_RES_TUNE_LIN_VAL_3_0;  ///< Offset: 0x74 - BBF Resistor Tune Values 3..0
        volatile uint32_t BBF_RES_TUNE_LIN_VAL_7_4;  ///< Offset: 0x78 - BBF Resistor Tune Values 7..4
        volatile uint32_t BBF_RES_TUNE_LIN_VAL_10_8;  ///< Offset: 0x7C - BBF Resistor Tune Values 10..8
        volatile uint32_t AGC_GAIN_TBL_03_00;  ///< Offset: 0x80 - AGC Gain Tables Step 03..00
        volatile uint32_t AGC_GAIN_TBL_07_04;  ///< Offset: 0x84 - AGC Gain Tables Step 07..04
        volatile uint32_t AGC_GAIN_TBL_11_08;  ///< Offset: 0x88 - AGC Gain Tables Step 11..08
        volatile uint32_t AGC_GAIN_TBL_15_12;  ///< Offset: 0x8C - AGC Gain Tables Step 15..12
        volatile uint32_t AGC_GAIN_TBL_19_16;  ///< Offset: 0x90 - AGC Gain Tables Step 19..16
        volatile uint32_t AGC_GAIN_TBL_23_20;  ///< Offset: 0x94 - AGC Gain Tables Step 23..20
        volatile uint32_t AGC_GAIN_TBL_26_24;  ///< Offset: 0x98 - AGC Gain Tables Step 26..24
        volatile uint32_t DCOC_OFFSET_%s;  ///< Offset: 0xA0 - DCOC Offset
        volatile uint32_t DCOC_TZA_STEP_%s;  ///< Offset: 0x110 - DCOC TZA DC step
        volatile uint32_t DCOC_CAL_ALPHA;  ///< Offset: 0x16C - DCOC Calibration Alpha
        volatile uint32_t DCOC_CAL_BETA;  ///< Offset: 0x170 - DCOC Calibration Beta
        volatile uint32_t DCOC_CAL_GAMMA;  ///< Offset: 0x174 - DCOC Calibration Gamma
        volatile uint32_t DCOC_CAL_IIR;  ///< Offset: 0x178 - DCOC Calibration IIR
        volatile uint32_t DCOC_CAL%s;  ///< Offset: 0x180 - DCOC Calibration Result
        volatile uint32_t RX_CHF_COEF%s;  ///< Offset: 0x1A0 - Receive Channel Filter Coefficient
        volatile uint32_t TX_DIG_CTRL;  ///< Offset: 0x200 - TX Digital Control
        volatile uint32_t TX_DATA_PAD_PAT;  ///< Offset: 0x204 - TX Data Padding Pattern
        volatile uint32_t TX_GFSK_MOD_CTRL;  ///< Offset: 0x208 - TX GFSK Modulation Control
        volatile uint32_t TX_GFSK_COEFF2;  ///< Offset: 0x20C - TX GFSK Filter Coefficients 2
        volatile uint32_t TX_GFSK_COEFF1;  ///< Offset: 0x210 - TX GFSK Filter Coefficients 1
        volatile uint32_t TX_FSK_MOD_SCALE;  ///< Offset: 0x214 - TX FSK Modulation Scale
        volatile uint32_t TX_DFT_MOD_PAT;  ///< Offset: 0x218 - TX DFT Modulation Pattern
        volatile uint32_t TX_DFT_TONE_0_1;  ///< Offset: 0x21C - TX DFT Tones 0 and 1
        volatile uint32_t TX_DFT_TONE_2_3;  ///< Offset: 0x220 - TX DFT Tones 2 and 3
        volatile uint32_t PLL_MOD_OVRD;  ///< Offset: 0x228 - PLL Modulation Overrides
        volatile uint32_t PLL_CHAN_MAP;  ///< Offset: 0x22C - PLL Channel Mapping
        volatile uint32_t PLL_LOCK_DETECT;  ///< Offset: 0x230 - PLL Lock Detect
        volatile uint32_t PLL_HP_MOD_CTRL;  ///< Offset: 0x234 - PLL High Port Modulation Control
        volatile uint32_t PLL_HPM_CAL_CTRL;  ///< Offset: 0x238 - PLL HPM Calibration Control
        volatile uint32_t PLL_LD_HPM_CAL1;  ///< Offset: 0x23C - PLL Cycle Slip Lock Detect Configuration and HPM Calibration 1
        volatile uint32_t PLL_LD_HPM_CAL2;  ///< Offset: 0x240 - PLL Cycle Slip Lock Detect Configuration and HPM Calibration 2
        volatile uint32_t PLL_HPM_SDM_FRACTION;  ///< Offset: 0x244 - PLL HPM SDM Fraction
        volatile uint32_t PLL_LP_MOD_CTRL;  ///< Offset: 0x248 - PLL Low Port Modulation Control
        volatile uint32_t PLL_LP_SDM_CTRL1;  ///< Offset: 0x24C - PLL Low Port SDM Control 1
        volatile uint32_t PLL_LP_SDM_CTRL2;  ///< Offset: 0x250 - PLL Low Port SDM Control 2
        volatile uint32_t PLL_LP_SDM_CTRL3;  ///< Offset: 0x254 - PLL Low Port SDM Control 3
        volatile uint32_t PLL_LP_SDM_NUM;  ///< Offset: 0x258 - PLL Low Port SDM Numerator Applied
        volatile uint32_t PLL_LP_SDM_DENOM;  ///< Offset: 0x25C - PLL Low Port SDM Denominator Applied
        volatile uint32_t PLL_DELAY_MATCH;  ///< Offset: 0x260 - PLL Delay Matching
        volatile uint32_t PLL_CTUNE_CTRL;  ///< Offset: 0x264 - PLL Coarse Tune Control
        volatile uint32_t PLL_CTUNE_CNT6;  ///< Offset: 0x268 - PLL Coarse Tune Count 6
        volatile uint32_t PLL_CTUNE_CNT5_4;  ///< Offset: 0x26C - PLL Coarse Tune Counts 5 and 4
        volatile uint32_t PLL_CTUNE_CNT3_2;  ///< Offset: 0x270 - PLL Coarse Tune Counts 3 and 2
        volatile uint32_t PLL_CTUNE_CNT1_0;  ///< Offset: 0x274 - PLL Coarse Tune Counts 1 and 0
        volatile uint32_t PLL_CTUNE_RESULTS;  ///< Offset: 0x278 - PLL Coarse Tune Results
        volatile uint32_t CTRL;  ///< Offset: 0x280 - Transceiver Control
        volatile uint32_t STATUS;  ///< Offset: 0x284 - Transceiver Status
        volatile uint32_t SOFT_RESET;  ///< Offset: 0x288 - Soft Reset
        volatile uint32_t OVERWRITE_VER;  ///< Offset: 0x290 - Overwrite Version
        volatile uint32_t DMA_CTRL;  ///< Offset: 0x294 - DMA Control
        volatile uint32_t DMA_DATA;  ///< Offset: 0x298 - DMA Data
        volatile uint32_t DTEST_CTRL;  ///< Offset: 0x29C - Digital Test Control
        volatile uint32_t PB_CTRL;  ///< Offset: 0x2A0 - Packet Buffer Control Register
        volatile uint32_t TSM_CTRL;  ///< Offset: 0x2C0 - Transceiver Sequence Manager Control
        volatile uint32_t END_OF_SEQ;  ///< Offset: 0x2C4 - End of Sequence Control
        volatile uint32_t TSM_OVRD0;  ///< Offset: 0x2C8 - TSM Override 0
        volatile uint32_t TSM_OVRD1;  ///< Offset: 0x2CC - TSM Override 1
        volatile uint32_t TSM_OVRD2;  ///< Offset: 0x2D0 - TSM Override 2
        volatile uint32_t TSM_OVRD3;  ///< Offset: 0x2D4 - TSM Override 3
        volatile uint32_t PA_POWER;  ///< Offset: 0x2D8 - PA Power
        volatile uint32_t PA_BIAS_TBL0;  ///< Offset: 0x2DC - PA Bias Table 0
        volatile uint32_t PA_BIAS_TBL1;  ///< Offset: 0x2E0 - PA Bias Table 1
        volatile uint32_t RECYCLE_COUNT;  ///< Offset: 0x2E4 - Recycle Count Register
        volatile uint32_t TSM_TIMING00;  ///< Offset: 0x2E8 - TSM_TIMING00
        volatile uint32_t TSM_TIMING01;  ///< Offset: 0x2EC - TSM_TIMING01
        volatile uint32_t TSM_TIMING02;  ///< Offset: 0x2F0 - TSM_TIMING02
        volatile uint32_t TSM_TIMING03;  ///< Offset: 0x2F4 - TSM_TIMING03
        volatile uint32_t TSM_TIMING04;  ///< Offset: 0x2F8 - TSM_TIMING04
        volatile uint32_t TSM_TIMING05;  ///< Offset: 0x2FC - TSM_TIMING05
        volatile uint32_t TSM_TIMING06;  ///< Offset: 0x300 - TSM_TIMING06
        volatile uint32_t TSM_TIMING07;  ///< Offset: 0x304 - TSM_TIMING07
        volatile uint32_t TSM_TIMING08;  ///< Offset: 0x308 - TSM_TIMING08
        volatile uint32_t TSM_TIMING09;  ///< Offset: 0x30C - TSM_TIMING09
        volatile uint32_t TSM_TIMING10;  ///< Offset: 0x310 - TSM_TIMING10
        volatile uint32_t TSM_TIMING11;  ///< Offset: 0x314 - TSM_TIMING11
        volatile uint32_t TSM_TIMING12;  ///< Offset: 0x318 - TSM_TIMING12
        volatile uint32_t TSM_TIMING13;  ///< Offset: 0x31C - TSM_TIMING13
        volatile uint32_t TSM_TIMING14;  ///< Offset: 0x320 - TSM_TIMING14
        volatile uint32_t TSM_TIMING15;  ///< Offset: 0x324 - TSM_TIMING15
        volatile uint32_t TSM_TIMING16;  ///< Offset: 0x328 - TSM_TIMING16
        volatile uint32_t TSM_TIMING17;  ///< Offset: 0x32C - TSM_TIMING17
        volatile uint32_t TSM_TIMING18;  ///< Offset: 0x330 - TSM_TIMING18
        volatile uint32_t TSM_TIMING19;  ///< Offset: 0x334 - TSM_TIMING19
        volatile uint32_t TSM_TIMING20;  ///< Offset: 0x338 - TSM_TIMING20
        volatile uint32_t TSM_TIMING21;  ///< Offset: 0x33C - TSM_TIMING21
        volatile uint32_t TSM_TIMING22;  ///< Offset: 0x340 - TSM_TIMING22
        volatile uint32_t TSM_TIMING23;  ///< Offset: 0x344 - TSM_TIMING23
        volatile uint32_t TSM_TIMING24;  ///< Offset: 0x348 - TSM_TIMING24
        volatile uint32_t TSM_TIMING25;  ///< Offset: 0x34C - TSM_TIMING25
        volatile uint32_t TSM_TIMING26;  ///< Offset: 0x350 - TSM_TIMING26
        volatile uint32_t TSM_TIMING27;  ///< Offset: 0x354 - TSM_TIMING27
        volatile uint32_t TSM_TIMING28;  ///< Offset: 0x358 - TSM_TIMING28
        volatile uint32_t TSM_TIMING29;  ///< Offset: 0x35C - TSM_TIMING29
        volatile uint32_t TSM_TIMING30;  ///< Offset: 0x360 - TSM_TIMING30
        volatile uint32_t TSM_TIMING31;  ///< Offset: 0x364 - TSM_TIMING31
        volatile uint32_t TSM_TIMING32;  ///< Offset: 0x368 - TSM_TIMING32
        volatile uint32_t TSM_TIMING33;  ///< Offset: 0x36C - TSM_TIMING33
        volatile uint32_t TSM_TIMING34;  ///< Offset: 0x370 - TSM_TIMING34
        volatile uint32_t TSM_TIMING35;  ///< Offset: 0x374 - TSM_TIMING35
        volatile uint32_t TSM_TIMING36;  ///< Offset: 0x378 - TSM_TIMING36
        volatile uint32_t TSM_TIMING37;  ///< Offset: 0x37C - TSM_TIMING37
        volatile uint32_t TSM_TIMING38;  ///< Offset: 0x380 - TSM_TIMING38
        volatile uint32_t TSM_TIMING39;  ///< Offset: 0x384 - TSM_TIMING39
        volatile uint32_t TSM_TIMING40;  ///< Offset: 0x388 - TSM_TIMING40
        volatile uint32_t TSM_TIMING41;  ///< Offset: 0x38C - TSM_TIMING41
        volatile uint32_t TSM_TIMING42;  ///< Offset: 0x390 - TSM_TIMING42
        volatile uint32_t TSM_TIMING43;  ///< Offset: 0x394 - TSM_TIMING43
        volatile uint32_t CORR_CTRL;  ///< Offset: 0x3C0 - CORR_CTRL
        volatile uint32_t PN_TYPE;  ///< Offset: 0x3C4 - PN_TYPE
        volatile uint32_t PN_CODE;  ///< Offset: 0x3C8 - PN_CODE
        volatile uint32_t SYNC_CTRL;  ///< Offset: 0x3CC - Sync Control
        volatile uint32_t SNF_THR;  ///< Offset: 0x3D0 - SNF_THR
        volatile uint32_t FAD_THR;  ///< Offset: 0x3D4 - FAD_THR
        volatile uint32_t ZBDEM_AFC;  ///< Offset: 0x3D8 - ZBDEM_AFC
        volatile uint32_t LPPS_CTRL;  ///< Offset: 0x3DC - LPPS Control Register
        volatile uint32_t ADC_CTRL;  ///< Offset: 0x400 - ADC Control
        volatile uint32_t ADC_TUNE;  ///< Offset: 0x404 - ADC Tuning
        volatile uint32_t ADC_ADJ;  ///< Offset: 0x408 - ADC Adjustment
        volatile uint32_t ADC_REGS;  ///< Offset: 0x40C - ADC Regulators
        volatile uint32_t ADC_TRIMS;  ///< Offset: 0x410 - ADC Regulator Trims
        volatile uint32_t ADC_TEST_CTRL;  ///< Offset: 0x414 - ADC Test Control
        volatile uint32_t BBF_CTRL;  ///< Offset: 0x420 - Baseband Filter Control
        volatile uint32_t RX_ANA_CTRL;  ///< Offset: 0x42C - RX Analog Control
        volatile uint32_t XTAL_CTRL;  ///< Offset: 0x434 - Crystal Oscillator Control Register 1
        volatile uint32_t XTAL_CTRL2;  ///< Offset: 0x438 - Crystal Oscillator Control Register 2
        volatile uint32_t BGAP_CTRL;  ///< Offset: 0x43C - Bandgap Control
        volatile uint32_t PLL_CTRL;  ///< Offset: 0x444 - PLL Control Register
        volatile uint32_t PLL_CTRL2;  ///< Offset: 0x448 - PLL Control Register 2
        volatile uint32_t PLL_TEST_CTRL;  ///< Offset: 0x44C - PLL Test Control
        volatile uint32_t QGEN_CTRL;  ///< Offset: 0x458 - QGEN Control
        volatile uint32_t TCA_CTRL;  ///< Offset: 0x464 - TCA Control
        volatile uint32_t TZA_CTRL;  ///< Offset: 0x468 - TZA Control
        volatile uint32_t TX_ANA_CTRL;  ///< Offset: 0x474 - TX Analog Control
        volatile uint32_t ANA_SPARE;  ///< Offset: 0x47C - Analog Spare
    };

    /// Peripheral instances
    inline Registers* XCVR = reinterpret_cast<Registers*>(XCVR_BASE);

    // Bit definitions
    /// RX_DIG_CTRL Register bits
    namespace rx_dig_ctrl_bits {
        constexpr uint32_t RX_ADC_NEGEDGE = (1U << 0);  ///< Receive ADC Negative Edge Selection
        constexpr uint32_t RX_CH_FILT_BYPASS = (1U << 1);  ///< Receive Channel Filter Bypass
        constexpr uint32_t RX_ADC_RAW_EN = (1U << 2);  ///< ADC Raw Mode selection
        constexpr uint32_t RX_DEC_FILT_OSR = (3 << 4);  ///< Decimation Filter Oversampling
        constexpr uint32_t RX_INTERP_EN = (1U << 8);  ///< Interpolator Enable
        constexpr uint32_t RX_NORM_EN = (1U << 9);  ///< Normalizer Enable
        constexpr uint32_t RX_RSSI_EN = (1U << 10);  ///< RSSI Measurement Enable
        constexpr uint32_t RX_AGC_EN = (1U << 11);  ///< AGC Global Enable
        constexpr uint32_t RX_DCOC_EN = (1U << 12);  ///< DCOC Enable
        constexpr uint32_t RX_DCOC_CAL_EN = (1U << 13);  ///< DCOC Calibration Enable
        constexpr uint32_t RX_IQ_SWAP = (1U << 14);  ///< RX IQ Swap
    }

    /// AGC_CTRL_0 Register bits
    namespace agc_ctrl_0_bits {
        constexpr uint32_t SLOW_AGC_EN = (1U << 0);  ///< Slow AGC Enable
        constexpr uint32_t SLOW_AGC_SRC = (2 << 1);  ///< Slow AGC Source Selection
        constexpr uint32_t AGC_FREEZE_EN = (1U << 3);  ///< AGC Freeze Enable
        constexpr uint32_t FREEZE_AGC_SRC = (2 << 4);  ///< Freeze AGC Source Selection
        constexpr uint32_t AGC_UP_EN = (1U << 6);  ///< AGC Up Enable
        constexpr uint32_t AGC_UP_SRC = (1U << 7);  ///< AGC Up Source
        constexpr uint32_t AGC_DOWN_BBF_STEP_SZ = (4 << 8);  ///< AGC_DOWN_BBF_STEP_SZ
        constexpr uint32_t AGC_DOWN_TZA_STEP_SZ = (4 << 12);  ///< AGC_DOWN_TZA_STEP_SZ
        constexpr uint32_t AGC_UP_RSSI_THRESH = (8 << 16);  ///< AGC UP RSSI Threshold
        constexpr uint32_t AGC_DOWN_RSSI_THRESH = (8 << 24);  ///< AGC DOWN RSSI Threshold
    }

    /// AGC_CTRL_1 Register bits
    namespace agc_ctrl_1_bits {
        constexpr uint32_t BBF_ALT_CODE = (4 << 0);  ///< BBF_ALT_CODE
        constexpr uint32_t LNM_ALT_CODE = (8 << 4);  ///< LNM_ALT_CODE
        constexpr uint32_t LNM_USER_GAIN = (4 << 12);  ///< LNM_USER_GAIN
        constexpr uint32_t BBF_USER_GAIN = (4 << 16);  ///< BBF_USER_GAIN
        constexpr uint32_t USER_LNM_GAIN_EN = (1U << 20);  ///< User LNM Gain Enable
        constexpr uint32_t USER_BBF_GAIN_EN = (1U << 21);  ///< User BBF Gain Enable
        constexpr uint32_t PRESLOW_EN = (1U << 22);  ///< Pre-slow Enable
        constexpr uint32_t TZA_GAIN_SETTLE_TIME = (8 << 24);  ///< TZA_GAIN_SETTLE_TIME
    }

    /// AGC_CTRL_2 Register bits
    namespace agc_ctrl_2_bits {
        constexpr uint32_t BBF_PDET_RST = (1U << 0);  ///< BBF PDET Reset
        constexpr uint32_t TZA_PDET_RST = (1U << 1);  ///< TZA PDET Reset
        constexpr uint32_t BBF_GAIN_SETTLE_TIME = (8 << 4);  ///< BBF Gain Settle Time
        constexpr uint32_t BBF_PDET_THRESH_LO = (3 << 12);  ///< BBF PDET Threshold Low
        constexpr uint32_t BBF_PDET_THRESH_HI = (3 << 15);  ///< BBF PDET Threshold High
        constexpr uint32_t TZA_PDET_THRESH_LO = (3 << 18);  ///< TZA PDET Threshold Low
        constexpr uint32_t TZA_PDET_THRESH_HI = (3 << 21);  ///< TZA PDET Threshold High
        constexpr uint32_t AGC_FAST_EXPIRE = (6 << 24);  ///< AGC Fast Expire
    }

    /// AGC_CTRL_3 Register bits
    namespace agc_ctrl_3_bits {
        constexpr uint32_t AGC_UNFREEZE_TIME = (13 << 0);  ///< AGC Unfreeze Time
        constexpr uint32_t AGC_PDET_LO_DLY = (3 << 13);  ///< AGC Peak Detect Low Delay
        constexpr uint32_t AGC_RSSI_DELT_H2S = (7 << 16);  ///< AGC_RSSI_DELT_H2S
        constexpr uint32_t AGC_H2S_STEP_SZ = (5 << 23);  ///< AGC_H2S_STEP_SZ
        constexpr uint32_t AGC_UP_STEP_SZ = (4 << 28);  ///< AGC Up Step Size
    }

    /// AGC_STAT Register bits
    namespace agc_stat_bits {
        constexpr uint32_t BBF_PDET_LO_STAT = (1U << 0);  ///< BBF Peak Detector Low Status
        constexpr uint32_t BBF_PDET_HI_STAT = (1U << 1);  ///< BBF Peak Detector High Status
        constexpr uint32_t TZA_PDET_LO_STAT = (1U << 2);  ///< TZA Peak Detector Low Status
        constexpr uint32_t TZA_PDET_HI_STAT = (1U << 3);  ///< TZA Peak Detector High Status
        constexpr uint32_t CURR_AGC_IDX = (5 << 4);  ///< Current AGC Gain Index
        constexpr uint32_t AGC_FROZEN = (1U << 9);  ///< AGC Frozen Status
        constexpr uint32_t RSSI_ADC_RAW = (8 << 16);  ///< ADC RAW RSSI Reading
    }

    /// RSSI_CTRL_0 Register bits
    namespace rssi_ctrl_0_bits {
        constexpr uint32_t RSSI_USE_VALS = (1U << 0);  ///< RSSI Values Selection
        constexpr uint32_t RSSI_HOLD_SRC = (2 << 1);  ///< Hold RSSI Source Selection
        constexpr uint32_t RSSI_HOLD_EN = (1U << 3);  ///< RSSI Hold Enable
        constexpr uint32_t RSSI_DEC_EN = (1U << 4);  ///< RSSI Decimation Enable
        constexpr uint32_t RSSI_IIR_CW_WEIGHT = (2 << 5);  ///< RSSI IIR CW Weighting
        constexpr uint32_t RSSI_IIR_WEIGHT = (4 << 16);  ///< RSSI IIR Weighting
        constexpr uint32_t RSSI_ADJ = (8 << 24);  ///< RSSI Adjustment
    }

    /// RSSI_CTRL_1 Register bits
    namespace rssi_ctrl_1_bits {
        constexpr uint32_t RSSI_ED_THRESH0 = (8 << 0);  ///< RSSI Energy Detect 0 Threshold
        constexpr uint32_t RSSI_ED_THRESH1 = (8 << 8);  ///< RSSI Energy Detect 1 Threshold
        constexpr uint32_t RSSI_ED_THRESH0_H = (4 << 16);  ///< RSSI Energy Detect 0 Hysteresis
        constexpr uint32_t RSSI_ED_THRESH1_H = (4 << 20);  ///< RSSI Energy Detect 1 Hysteresis
        constexpr uint32_t RSSI_OUT = (8 << 24);  ///< RSSI Reading
    }

    /// DCOC_CTRL_0 Register bits
    namespace dcoc_ctrl_0_bits {
        constexpr uint32_t DCOC_MAN = (1U << 1);  ///< DCOC Manual Override
        constexpr uint32_t DCOC_TRACK_EN = (1U << 3);  ///< DCOC Tracking Enable
        constexpr uint32_t DCOC_CORRECT_EN = (1U << 4);  ///< DCOC Correction Enable
        constexpr uint32_t DCOC_SIGN_SCALE_IDX = (2 << 5);  ///< DCOC Sign Scaling
        constexpr uint32_t DCOC_ALPHAC_SCALE_IDX = (2 << 8);  ///< DCOC Alpha-C Scaling
        constexpr uint32_t DCOC_ALPHA_RADIUS_IDX = (3 << 12);  ///< Alpha-R Scaling
        constexpr uint32_t DCOC_CAL_DURATION = (5 << 15);  ///< DCOC Calibration Duration
        constexpr uint32_t DCOC_CORR_DLY = (5 << 20);  ///< DCOC Correction Delay
        constexpr uint32_t DCOC_CORR_HOLD_TIME = (7 << 25);  ///< DCOC Correction Hold Time
    }

    /// DCOC_CTRL_1 Register bits
    namespace dcoc_ctrl_1_bits {
        constexpr uint32_t BBF_DCOC_STEP = (9 << 0);  ///< DCOC BBF Step Size
        constexpr uint32_t TRACK_FROM_ZERO = (1U << 24);  ///< Track from Zero
        constexpr uint32_t BBA_CORR_POL = (1U << 25);  ///< BBA Correction Polarity
        constexpr uint32_t TZA_CORR_POL = (1U << 26);  ///< TZA Correction Polarity
    }

    /// DCOC_CTRL_2 Register bits
    namespace dcoc_ctrl_2_bits {
        constexpr uint32_t BBF_DCOC_STEP_RECIP = (13 << 0);  ///< DCOC BBF Reciprocal of Step Size
    }

    /// DCOC_CTRL_3 Register bits
    namespace dcoc_ctrl_3_bits {
        constexpr uint32_t BBF_DCOC_INIT_I = (6 << 0);  ///< DCOC BBF Init I
        constexpr uint32_t BBF_DCOC_INIT_Q = (6 << 8);  ///< DCOC BBF Init Q
        constexpr uint32_t TZA_DCOC_INIT_I = (8 << 16);  ///< DCOC TZA Init I
        constexpr uint32_t TZA_DCOC_INIT_Q = (8 << 24);  ///< DCOC TZA Init Q
    }

    /// DCOC_CTRL_4 Register bits
    namespace dcoc_ctrl_4_bits {
        constexpr uint32_t DIG_DCOC_INIT_I = (12 << 0);  ///< DCOC DIG Init I
        constexpr uint32_t DIG_DCOC_INIT_Q = (12 << 16);  ///< DCOC DIG Init Q
    }

    /// DCOC_CAL_GAIN Register bits
    namespace dcoc_cal_gain_bits {
        constexpr uint32_t DCOC_BBF_CAL_GAIN1 = (4 << 8);  ///< DCOC BBF Calibration Gain 1
        constexpr uint32_t DCOC_TZA_CAL_GAIN1 = (4 << 12);  ///< DCOC TZA Calibration Gain 1
        constexpr uint32_t DCOC_BBF_CAL_GAIN2 = (4 << 16);  ///< DCOC BBF Calibration Gain 2
        constexpr uint32_t DCOC_TZA_CAL_GAIN2 = (4 << 20);  ///< DCOC TZA Calibration Gain 2
        constexpr uint32_t DCOC_BBF_CAL_GAIN3 = (4 << 24);  ///< DCOC BBF Calibration Gain 3
        constexpr uint32_t DCOC_TZA_CAL_GAIN3 = (4 << 28);  ///< DCOC TZA Calibration Gain 3
    }

    /// DCOC_STAT Register bits
    namespace dcoc_stat_bits {
        constexpr uint32_t BBF_DCOC_I = (6 << 0);  ///< DCOC BBF DAC I
        constexpr uint32_t BBF_DCOC_Q = (6 << 8);  ///< DCOC BBF DAC Q
        constexpr uint32_t TZA_DCOC_I = (8 << 16);  ///< DCOC TZA DAC I
        constexpr uint32_t TZA_DCOC_Q = (8 << 24);  ///< DCOC TZA DAC Q
    }

    /// DCOC_DC_EST Register bits
    namespace dcoc_dc_est_bits {
        constexpr uint32_t DC_EST_I = (12 << 0);  ///< DCOC DC Estimate I
        constexpr uint32_t DC_EST_Q = (12 << 16);  ///< DCOC DC Estimate Q
    }

    /// DCOC_CAL_RCP Register bits
    namespace dcoc_cal_rcp_bits {
        constexpr uint32_t DCOC_TMP_CALC_RECIP = (10 << 0);  ///< DCOC Calculation Reciprocal
        constexpr uint32_t ALPHA_CALC_RECIP = (11 << 10);  ///< Alpha Calculation Reciprocal
    }

    /// IQMC_CTRL Register bits
    namespace iqmc_ctrl_bits {
        constexpr uint32_t IQMC_CAL_EN = (1U << 0);  ///< IQ Mismatch Cal Enable
        constexpr uint32_t IQMC_NUM_ITER = (8 << 8);  ///< IQ Mismatch Cal Num Iter
    }

    /// IQMC_CAL Register bits
    namespace iqmc_cal_bits {
        constexpr uint32_t IQMC_GAIN_ADJ = (11 << 0);  ///< IQ Mismatch Correction Gain Coeff
        constexpr uint32_t IQMC_PHASE_ADJ = (12 << 16);  ///< IQ Mismatch Correction Phase Coeff
    }

    /// TCA_AGC_VAL_3_0 Register bits
    namespace tca_agc_val_3_0_bits {
        constexpr uint32_t TCA_AGC_VAL_0 = (8 << 0);  ///< TCA_AGC step 0
        constexpr uint32_t TCA_AGC_VAL_1 = (8 << 8);  ///< TCA_AGC step 1
        constexpr uint32_t TCA_AGC_VAL_2 = (8 << 16);  ///< TCA_AGC step 2
        constexpr uint32_t TCA_AGC_VAL_3 = (8 << 24);  ///< TCA_AGC step 3
    }

    /// TCA_AGC_VAL_7_4 Register bits
    namespace tca_agc_val_7_4_bits {
        constexpr uint32_t TCA_AGC_VAL_4 = (8 << 0);  ///< TCA_AGC step 4
        constexpr uint32_t TCA_AGC_VAL_5 = (8 << 8);  ///< TCA_AGC step 5
        constexpr uint32_t TCA_AGC_VAL_6 = (8 << 16);  ///< TCA_AGC step 6
        constexpr uint32_t TCA_AGC_VAL_7 = (8 << 24);  ///< TCA_AGC step 7
    }

    /// TCA_AGC_VAL_8 Register bits
    namespace tca_agc_val_8_bits {
        constexpr uint32_t TCA_AGC_VAL_8 = (8 << 0);  ///< TCA_AGC step 8
    }

    /// BBF_RES_TUNE_VAL_7_0 Register bits
    namespace bbf_res_tune_val_7_0_bits {
        constexpr uint32_t BBF_RES_TUNE_VAL_0 = (4 << 0);  ///< BBF Resistor Tune Step 0
        constexpr uint32_t BBF_RES_TUNE_VAL_1 = (4 << 4);  ///< BBF Resistor Tune Step 1
        constexpr uint32_t BBF_RES_TUNE_VAL_2 = (4 << 8);  ///< BBF Resistor Tune Step 2
        constexpr uint32_t BBF_RES_TUNE_VAL_3 = (4 << 12);  ///< BBF Resistor Tune Step 3
        constexpr uint32_t BBF_RES_TUNE_VAL_4 = (4 << 16);  ///< BBF Resistor Tune Step 4
        constexpr uint32_t BBF_RES_TUNE_VAL_5 = (4 << 20);  ///< BBF Resistor Tune Step 5
        constexpr uint32_t BBF_RES_TUNE_VAL_6 = (4 << 24);  ///< BBF Resistor Tune Step 6
        constexpr uint32_t BBF_RES_TUNE_VAL_7 = (4 << 28);  ///< BBF Resistor Tune Step 7
    }

    /// BBF_RES_TUNE_VAL_10_8 Register bits
    namespace bbf_res_tune_val_10_8_bits {
        constexpr uint32_t BBF_RES_TUNE_VAL_8 = (4 << 0);  ///< BBF Resistor Tune Step 8
        constexpr uint32_t BBF_RES_TUNE_VAL_9 = (4 << 4);  ///< BBF Resistor Tune Step 9
        constexpr uint32_t BBF_RES_TUNE_VAL_10 = (4 << 8);  ///< BBF Resistor Tune Step 10
    }

    /// TCA_AGC_LIN_VAL_2_0 Register bits
    namespace tca_agc_lin_val_2_0_bits {
        constexpr uint32_t TCA_AGC_LIN_VAL_0 = (10 << 0);  ///< LNM linear gain value for index 0, e.g. nominal value is 10^(-3/20). Stored with 2 fractional bits, e.g. round([10^(-3/20)]*2^2) = 3decimal
        constexpr uint32_t TCA_AGC_LIN_VAL_1 = (10 << 10);  ///< TCA AGC Linear Gain Step 1
        constexpr uint32_t TCA_AGC_LIN_VAL_2 = (10 << 20);  ///< TCA AGC Linear Gain Step 2
    }

    /// TCA_AGC_LIN_VAL_5_3 Register bits
    namespace tca_agc_lin_val_5_3_bits {
        constexpr uint32_t TCA_AGC_LIN_VAL_3 = (10 << 0);  ///< TCA AGC Linear Gain Step 3
        constexpr uint32_t TCA_AGC_LIN_VAL_4 = (10 << 10);  ///< TCA AGC Linear Gain Step 4
        constexpr uint32_t TCA_AGC_LIN_VAL_5 = (10 << 20);  ///< TCA AGC Linear Gain Step 5
    }

    /// TCA_AGC_LIN_VAL_8_6 Register bits
    namespace tca_agc_lin_val_8_6_bits {
        constexpr uint32_t TCA_AGC_LIN_VAL_6 = (10 << 0);  ///< TCA AGC Linear Gain Step 6
        constexpr uint32_t TCA_AGC_LIN_VAL_7 = (10 << 10);  ///< TCA AGC Linear Gain Step 7
        constexpr uint32_t TCA_AGC_LIN_VAL_8 = (10 << 20);  ///< TCA AGC Linear Gain Step 8
    }

    /// BBF_RES_TUNE_LIN_VAL_3_0 Register bits
    namespace bbf_res_tune_lin_val_3_0_bits {
        constexpr uint32_t BBF_RES_TUNE_LIN_VAL_0 = (8 << 0);  ///< BBF Resistor Tune Linear Gain Step 0
        constexpr uint32_t BBF_RES_TUNE_LIN_VAL_1 = (8 << 8);  ///< BBF Resistor Tune Linear Gain Step 1
        constexpr uint32_t BBF_RES_TUNE_LIN_VAL_2 = (8 << 16);  ///< BBF Resistor Tune Linear Gain Step 2
        constexpr uint32_t BBF_RES_TUNE_LIN_VAL_3 = (8 << 24);  ///< BBF Resistor Tune Linear Gain Step 3
    }

    /// BBF_RES_TUNE_LIN_VAL_7_4 Register bits
    namespace bbf_res_tune_lin_val_7_4_bits {
        constexpr uint32_t BBF_RES_TUNE_LIN_VAL_4 = (8 << 0);  ///< BBF Resistor Tune Linear Gain Step 4
        constexpr uint32_t BBF_RES_TUNE_LIN_VAL_5 = (8 << 8);  ///< BBF Resistor Tune Linear Gain Step 5
        constexpr uint32_t BBF_RES_TUNE_LIN_VAL_6 = (8 << 16);  ///< BBF Resistor Tune Linear Gain Step 6
        constexpr uint32_t BBF_RES_TUNE_LIN_VAL_7 = (8 << 24);  ///< BBF Resistor Tune Linear Gain Step 7
    }

    /// BBF_RES_TUNE_LIN_VAL_10_8 Register bits
    namespace bbf_res_tune_lin_val_10_8_bits {
        constexpr uint32_t BBF_RES_TUNE_LIN_VAL_8 = (8 << 0);  ///< BBF Resistor Tune Linear Gain Step 8
        constexpr uint32_t BBF_RES_TUNE_LIN_VAL_9 = (8 << 8);  ///< BBF Resistor Tune Linear Gain Step 9
        constexpr uint32_t BBF_RES_TUNE_LIN_VAL_10 = (8 << 16);  ///< BBF Resistor Tune Linear Gain Step 10
    }

    /// AGC_GAIN_TBL_03_00 Register bits
    namespace agc_gain_tbl_03_00_bits {
        constexpr uint32_t BBF_GAIN_00 = (4 << 0);  ///< BBF Gain 00
        constexpr uint32_t LNM_GAIN_00 = (4 << 4);  ///< LNM Gain 00
        constexpr uint32_t BBF_GAIN_01 = (4 << 8);  ///< BBF Gain 01
        constexpr uint32_t LNM_GAIN_01 = (4 << 12);  ///< LNM Gain 01
        constexpr uint32_t BBF_GAIN_02 = (4 << 16);  ///< BBF Gain 02
        constexpr uint32_t LNM_GAIN_02 = (4 << 20);  ///< LNM Gain 02
        constexpr uint32_t BBF_GAIN_03 = (4 << 24);  ///< BBF Gain 03
        constexpr uint32_t LNM_GAIN_03 = (4 << 28);  ///< LNM Gain 03
    }

    /// AGC_GAIN_TBL_07_04 Register bits
    namespace agc_gain_tbl_07_04_bits {
        constexpr uint32_t BBF_GAIN_04 = (4 << 0);  ///< BBF Gain 04
        constexpr uint32_t LNM_GAIN_04 = (4 << 4);  ///< LNM Gain 04
        constexpr uint32_t BBF_GAIN_05 = (4 << 8);  ///< BBF Gain 05
        constexpr uint32_t LNM_GAIN_05 = (4 << 12);  ///< LNM Gain 05
        constexpr uint32_t BBF_GAIN_06 = (4 << 16);  ///< BBF Gain 06
        constexpr uint32_t LNM_GAIN_06 = (4 << 20);  ///< LNM Gain 06
        constexpr uint32_t BBF_GAIN_07 = (4 << 24);  ///< BBF Gain 07
        constexpr uint32_t LNM_GAIN_07 = (4 << 28);  ///< LNM Gain 07
    }

    /// AGC_GAIN_TBL_11_08 Register bits
    namespace agc_gain_tbl_11_08_bits {
        constexpr uint32_t BBF_GAIN_08 = (4 << 0);  ///< BBF Gain 08
        constexpr uint32_t LNM_GAIN_08 = (4 << 4);  ///< LNM Gain 08
        constexpr uint32_t BBF_GAIN_09 = (4 << 8);  ///< BBF Gain 09
        constexpr uint32_t LNM_GAIN_09 = (4 << 12);  ///< LNM Gain 09
        constexpr uint32_t BBF_GAIN_10 = (4 << 16);  ///< BBF Gain 10
        constexpr uint32_t LNM_GAIN_10 = (4 << 20);  ///< LNM Gain 10
        constexpr uint32_t BBF_GAIN_11 = (4 << 24);  ///< BBF Gain 11
        constexpr uint32_t LNM_GAIN_11 = (4 << 28);  ///< LNM Gain 11
    }

    /// AGC_GAIN_TBL_15_12 Register bits
    namespace agc_gain_tbl_15_12_bits {
        constexpr uint32_t BBF_GAIN_12 = (4 << 0);  ///< BBF Gain 12
        constexpr uint32_t LNM_GAIN_12 = (4 << 4);  ///< LNM Gain 12
        constexpr uint32_t BBF_GAIN_13 = (4 << 8);  ///< BBF Gain 13
        constexpr uint32_t LNM_GAIN_13 = (4 << 12);  ///< LNM Gain 13
        constexpr uint32_t BBF_GAIN_14 = (4 << 16);  ///< BBF Gain 14
        constexpr uint32_t LNM_GAIN_14 = (4 << 20);  ///< LNM Gain 14
        constexpr uint32_t BBF_GAIN_15 = (4 << 24);  ///< BBF Gain 15
        constexpr uint32_t LNM_GAIN_15 = (4 << 28);  ///< LNM Gain 15
    }

    /// AGC_GAIN_TBL_19_16 Register bits
    namespace agc_gain_tbl_19_16_bits {
        constexpr uint32_t BBF_GAIN_16 = (4 << 0);  ///< BBF Gain 16
        constexpr uint32_t LNM_GAIN_16 = (4 << 4);  ///< LNM Gain 16
        constexpr uint32_t BBF_GAIN_17 = (4 << 8);  ///< BBF Gain 17
        constexpr uint32_t LNM_GAIN_17 = (4 << 12);  ///< LNM Gain 17
        constexpr uint32_t BBF_GAIN_18 = (4 << 16);  ///< BBF Gain 18
        constexpr uint32_t LNM_GAIN_18 = (4 << 20);  ///< LNM Gain 18
        constexpr uint32_t BBF_GAIN_19 = (4 << 24);  ///< BBF Gain 193
        constexpr uint32_t LNM_GAIN_19 = (4 << 28);  ///< LNM Gain 19
    }

    /// AGC_GAIN_TBL_23_20 Register bits
    namespace agc_gain_tbl_23_20_bits {
        constexpr uint32_t BBF_GAIN_20 = (4 << 0);  ///< BBF Gain 20
        constexpr uint32_t LNM_GAIN_20 = (4 << 4);  ///< LNM Gain 20
        constexpr uint32_t BBF_GAIN_21 = (4 << 8);  ///< BBF Gain 21
        constexpr uint32_t LNM_GAIN_21 = (4 << 12);  ///< LNM Gain 21
        constexpr uint32_t BBF_GAIN_22 = (4 << 16);  ///< BBF Gain 22
        constexpr uint32_t LNM_GAIN_22 = (4 << 20);  ///< LNM Gain 22
        constexpr uint32_t BBF_GAIN_23 = (4 << 24);  ///< BBF Gain 23
        constexpr uint32_t LNM_GAIN_23 = (4 << 28);  ///< LNM Gain 23
    }

    /// AGC_GAIN_TBL_26_24 Register bits
    namespace agc_gain_tbl_26_24_bits {
        constexpr uint32_t BBF_GAIN_24 = (4 << 0);  ///< BBF Gain 24
        constexpr uint32_t LNM_GAIN_24 = (4 << 4);  ///< LNM Gain 24
        constexpr uint32_t BBF_GAIN_25 = (4 << 8);  ///< BBF Gain 25
        constexpr uint32_t LNM_GAIN_25 = (4 << 12);  ///< LNM Gain 25
        constexpr uint32_t BBF_GAIN_26 = (4 << 16);  ///< BBF Gain 26
        constexpr uint32_t LNM_GAIN_26 = (4 << 20);  ///< LNM Gain 26
    }

    /// DCOC_OFFSET_%s Register bits
    namespace dcoc_offset_%s_bits {
        constexpr uint32_t DCOC_BBF_OFFSET_I = (6 << 0);  ///< DCOC BBF I-channel offset
        constexpr uint32_t DCOC_BBF_OFFSET_Q = (6 << 8);  ///< DCOC BBF Q-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_I = (8 << 16);  ///< DCOC TZA I-channel offset
        constexpr uint32_t DCOC_TZA_OFFSET_Q = (8 << 24);  ///< DCOC TZA Q-channel offset
    }

    /// DCOC_TZA_STEP_%s Register bits
    namespace dcoc_tza_step_%s_bits {
        constexpr uint32_t DCOC_TZA_STEP_RCP = (13 << 0);  ///< DCOC_TZA_STEP_RCP
        constexpr uint32_t DCOC_TZA_STEP_GAIN = (12 << 16);  ///< DCOC_TZA_STEP_GAIN
    }

    /// DCOC_CAL_ALPHA Register bits
    namespace dcoc_cal_alpha_bits {
        constexpr uint32_t DCOC_CAL_ALPHA_I = (16 << 0);  ///< DCOC Calibration I-channel ALPHA constant
        constexpr uint32_t DCOC_CAL_ALPHA_Q = (16 << 16);  ///< DCOC_CAL_ALPHA_Q
    }

    /// DCOC_CAL_BETA Register bits
    namespace dcoc_cal_beta_bits {
        constexpr uint32_t DCOC_CAL_BETA_I = (16 << 0);  ///< DCOC_CAL_BETA_I
        constexpr uint32_t DCOC_CAL_BETA_Q = (16 << 16);  ///< DCOC_CAL_BETA_Q
    }

    /// DCOC_CAL_GAMMA Register bits
    namespace dcoc_cal_gamma_bits {
        constexpr uint32_t DCOC_CAL_GAMMA_I = (16 << 0);  ///< DCOC_CAL_GAMMA_I
        constexpr uint32_t DCOC_CAL_GAMMA_Q = (16 << 16);  ///< DCOC_CAL_GAMMA_Q
    }

    /// DCOC_CAL_IIR Register bits
    namespace dcoc_cal_iir_bits {
        constexpr uint32_t DCOC_CAL_IIR1A_IDX = (2 << 0);  ///< DCOC Calibration IIR 1A Index
        constexpr uint32_t DCOC_CAL_IIR2A_IDX = (2 << 2);  ///< DCOC Calibration IIR 2A Index
        constexpr uint32_t DCOC_CAL_IIR3A_IDX = (2 << 4);  ///< DCOC Calibration IIR 3A Index
    }

    /// DCOC_CAL%s Register bits
    namespace dcoc_cal%s_bits {
        constexpr uint32_t DCOC_CAL_RES_I = (12 << 0);  ///< DCOC Calibration Result - I Channel
        constexpr uint32_t DCOC_CAL_RES_Q = (12 << 16);  ///< DCOC Calibration Result - Q Channel
    }

    /// RX_CHF_COEF%s Register bits
    namespace rx_chf_coef%s_bits {
        constexpr uint32_t RX_CH_FILT_HX = (8 << 0);  ///< RX Channel Filter Coefficient
    }

    /// TX_DIG_CTRL Register bits
    namespace tx_dig_ctrl_bits {
        constexpr uint32_t DFT_MODE = (3 << 0);  ///< Radio DFT Modes
        constexpr uint32_t DFT_EN = (1U << 3);  ///< Radio DFT Mode Enable
        constexpr uint32_t DFT_LFSR_LEN = (3 << 4);  ///< DFT LFSR Length
        constexpr uint32_t LFSR_EN = (1U << 7);  ///< DFT LFSR Enable
        constexpr uint32_t DFT_CLK_SEL = (3 << 8);  ///< DFT Clock Selection
        constexpr uint32_t TONE_SEL = (2 << 12);  ///< DFT Tone Selection
        constexpr uint32_t POL = (1U << 16);  ///< Oversample Clock Capture Polarity
        constexpr uint32_t DP_SEL = (1U << 20);  ///< Data Padding Pattern Select
        constexpr uint32_t FREQ_WORD_ADJ = (10 << 22);  ///< GFSK Frequency Word Adjustment
    }

    /// TX_DATA_PAD_PAT Register bits
    namespace tx_data_pad_pat_bits {
        constexpr uint32_t DATA_PADDING_PAT_0 = (8 << 0);  ///< Data Padding Pattern 0
        constexpr uint32_t DATA_PADDING_PAT_1 = (8 << 8);  ///< Data Padding Pattern 1
        constexpr uint32_t DFT_LFSR_OUT = (15 << 16);  ///< Transmit DFT LFSR Output
        constexpr uint32_t LRM = (1U << 31);  ///< LFSR Reset Mask
    }

    /// TX_GFSK_MOD_CTRL Register bits
    namespace tx_gfsk_mod_ctrl_bits {
        constexpr uint32_t GFSK_MULTIPLY_TABLE_MANUAL = (16 << 0);  ///< GFSK Multiply Lookup Table Override Value
        constexpr uint32_t GFSK_MI = (2 << 16);  ///< GFSK Modulation Index
        constexpr uint32_t GFSK_MLD = (1U << 20);  ///< GFSK Multiply Lookup Table Disable
        constexpr uint32_t GFSK_SYMBOL_RATE = (3 << 24);  ///< GFSK Symbol Rate
        constexpr uint32_t GFSK_FLD = (1U << 28);  ///< GFSK Filter Lookup Table Disable
    }

    /// TX_GFSK_COEFF2 Register bits
    namespace tx_gfsk_coeff2_bits {
        constexpr uint32_t GFSK_FILTER_COEFF_MANUAL2 = (32 << 0);  ///< GFSK Manual Filter Coefficients[63:32]
    }

    /// TX_GFSK_COEFF1 Register bits
    namespace tx_gfsk_coeff1_bits {
        constexpr uint32_t GFSK_FILTER_COEFF_MANUAL1 = (32 << 0);  ///< GFSK Manual Filter Coefficient [31:0]
    }

    /// TX_FSK_MOD_SCALE Register bits
    namespace tx_fsk_mod_scale_bits {
        constexpr uint32_t FSK_MODULATION_SCALE_0 = (13 << 0);  ///< FSK Modulation Scale for a data 0
        constexpr uint32_t FSK_MODULATION_SCALE_1 = (13 << 16);  ///< FSK Modulation Scale for a data 1
    }

    /// TX_DFT_MOD_PAT Register bits
    namespace tx_dft_mod_pat_bits {
        constexpr uint32_t DFT_MOD_PATTERN = (32 << 0);  ///< DFT Modulation Pattern
    }

    /// TX_DFT_TONE_0_1 Register bits
    namespace tx_dft_tone_0_1_bits {
        constexpr uint32_t DFT_TONE_1 = (13 << 0);  ///< DFT Tone 1
        constexpr uint32_t DFT_TONE_0 = (13 << 16);  ///< DFT Tone 0
    }

    /// TX_DFT_TONE_2_3 Register bits
    namespace tx_dft_tone_2_3_bits {
        constexpr uint32_t DFT_TONE_3 = (13 << 0);  ///< DFT Tone 3
        constexpr uint32_t DFT_TONE_2 = (13 << 16);  ///< DFT Tone 2
    }

    /// PLL_MOD_OVRD Register bits
    namespace pll_mod_ovrd_bits {
        constexpr uint32_t MODULATION_WORD_MANUAL = (13 << 0);  ///< Manual Modulation Word
        constexpr uint32_t MOD_DIS = (1U << 15);  ///< Disable Modulation Word
        constexpr uint32_t HPM_BANK_MANUAL = (8 << 16);  ///< Manual HPM bank
        constexpr uint32_t HPM_BANK_DIS = (1U << 27);  ///< Disable HPM Bank
        constexpr uint32_t HPM_LSB_MANUAL = (2 << 28);  ///< Manual HPM LSB
        constexpr uint32_t HPM_LSB_DIS = (1U << 31);  ///< Disable HPM LSB
    }

    /// PLL_CHAN_MAP Register bits
    namespace pll_chan_map_bits {
        constexpr uint32_t CHANNEL_NUM = (7 << 0);  ///< Protocol specific Channel Number for PLL Frequency Mapping
        constexpr uint32_t BOC = (1U << 8);  ///< BLE Channel Number Override
        constexpr uint32_t BMR = (1U << 9);  ///< BLE MBAN Channel Remap
        constexpr uint32_t ZOC = (1U << 10);  ///< Zigbee Channel Number Override
    }

    /// PLL_LOCK_DETECT Register bits
    namespace pll_lock_detect_bits {
        constexpr uint32_t CT_FAIL = (1U << 0);  ///< Real time status of Coarse Tune Fail signal
        constexpr uint32_t CTFF = (1U << 1);  ///< CTUNE Failure Flag, held until cleared
        constexpr uint32_t CS_FAIL = (1U << 2);  ///< Real time status of Cycle Slip circuit
        constexpr uint32_t CSFF = (1U << 3);  ///< Cycle Slip Failure Flag, held until cleared
        constexpr uint32_t FT_FAIL = (1U << 4);  ///< Real time status of Frequency Target Failure
        constexpr uint32_t FTFF = (1U << 5);  ///< Frequency Target Failure Flag
        constexpr uint32_t TAFF = (1U << 7);  ///< TSM Abort Failure Flag
        constexpr uint32_t CTUNE_LDF_LEV = (4 << 8);  ///< CTUNE Lock Detect Fail Level
        constexpr uint32_t FTF_RX_THRSH = (6 << 12);  ///< RX Frequency Target Fail Threshold
        constexpr uint32_t FTW_RX = (1U << 19);  ///< RX Frequency Target Window time select
        constexpr uint32_t FTF_TX_THRSH = (6 << 20);  ///< TX Frequency Target Fail Threshold
        constexpr uint32_t FTW_TX = (1U << 27);  ///< TX Frequency Target Window time select
    }

    /// PLL_HP_MOD_CTRL Register bits
    namespace pll_hp_mod_ctrl_bits {
        constexpr uint32_t HPM_SDM_MANUAL = (10 << 0);  ///< PLL HPM SDM MANUAL
        constexpr uint32_t HPFF = (1U << 13);  ///< HPM SDM Invalid Flag
        constexpr uint32_t HP_SDM_INV = (1U << 14);  ///< Invert HPM SDM
        constexpr uint32_t HP_SDM_DIS = (1U << 15);  ///< Disable HPM SDM
        constexpr uint32_t HPM_LFSR_LEN = (3 << 16);  ///< HPM LFSR Length
        constexpr uint32_t HP_DTH_SCL = (1U << 20);  ///< HPM Dither Scale
        constexpr uint32_t HPM_DTH_EN = (1U << 23);  ///< Dither Enable for HPM LFSR
        constexpr uint32_t HPM_SCALE = (2 << 24);  ///< HPM Scale Factor
        constexpr uint32_t HP_MOD_INV = (1U << 31);  ///< HPM Invert
    }

    /// PLL_HPM_CAL_CTRL Register bits
    namespace pll_hpm_cal_ctrl_bits {
        constexpr uint32_t HPM_CAL_FACTOR = (13 << 0);  ///< High Port Modulation Calibration Factor
        constexpr uint32_t HP_CAL_DIS = (1U << 15);  ///< If this bit is set, the lookup table value for the HPM Calibration Factor is overridden by the HPM_CAL_FACTOR_MANUAL register
        constexpr uint32_t HPM_CAL_FACTOR_MANUAL = (13 << 16);  ///< HPM Manual Calibration Factor
        constexpr uint32_t HP_CAL_ARY = (1U << 30);  ///< High Port Modulation Calibration Array Size
        constexpr uint32_t HP_CAL_TIME = (1U << 31);  ///< High Port Modulation Calibration Time
    }

    /// PLL_LD_HPM_CAL1 Register bits
    namespace pll_ld_hpm_cal1_bits {
        constexpr uint32_t CNT_1 = (17 << 0);  ///< High Port Modulation Counter Value 1
        constexpr uint32_t CS_WT = (3 << 20);  ///< Cycle Slip Wait Time
        constexpr uint32_t CS_FW = (3 << 24);  ///< Cycle Slip Flag Window
        constexpr uint32_t CS_FCNT = (4 << 28);  ///< Cycle Slip Flag Count
    }

    /// PLL_LD_HPM_CAL2 Register bits
    namespace pll_ld_hpm_cal2_bits {
        constexpr uint32_t CNT_2 = (17 << 0);  ///< High Port Modulation Counter Value 2
        constexpr uint32_t CS_RC = (1U << 20);  ///< Cycle Slip Recycle
        constexpr uint32_t CS_FT = (5 << 24);  ///< Cycle Slip Flag Timeout
    }

    /// PLL_HPM_SDM_FRACTION Register bits
    namespace pll_hpm_sdm_fraction_bits {
        constexpr uint32_t HPM_NUM_SELECTED = (10 << 0);  ///< HPM_NUM_SELECTED
        constexpr uint32_t HPM_DENOM = (10 << 16);  ///< High Port Modulation Denominator
    }

    /// PLL_LP_MOD_CTRL Register bits
    namespace pll_lp_mod_ctrl_bits {
        constexpr uint32_t PLL_LOOP_DIVIDER_MANUAL = (6 << 0);  ///< PLL Loop Divider Manual
        constexpr uint32_t PLL_LD_DIS = (1U << 11);  ///< PLL Loop Divider Disable
        constexpr uint32_t LPFF = (1U << 13);  ///< LPM SDM Invalid Flag
        constexpr uint32_t LPM_SDM_INV = (1U << 14);  ///< Invert LPM SDM
        constexpr uint32_t LPM_SDM_DIS = (1U << 15);  ///< Disable LPM SDM
        constexpr uint32_t LPM_DTH_SCL = (4 << 16);  ///< LPM Dither Scale
        constexpr uint32_t LPM_D_CTRL = (1U << 22);  ///< LPM Dither Control in Override Mode
        constexpr uint32_t LPM_D_OVRD = (1U << 23);  ///< LPM Dither Override Mode Select
        constexpr uint32_t LPM_SCALE = (4 << 24);  ///< LPM Scale Factor
    }

    /// PLL_LP_SDM_CTRL1 Register bits
    namespace pll_lp_sdm_ctrl1_bits {
        constexpr uint32_t LPM_INTG_SELECTED = (7 << 0);  ///< Low Port Modulation Integer Value Selected
        constexpr uint32_t LPM_INTG = (7 << 16);  ///< Low Port Modulation Integer Manual Value
        constexpr uint32_t SDM_MAP_DIS = (1U << 31);  ///< SDM Mapping Disable
    }

    /// PLL_LP_SDM_CTRL2 Register bits
    namespace pll_lp_sdm_ctrl2_bits {
        constexpr uint32_t LPM_NUM = (28 << 0);  ///< Low Port Modulation Numerator
    }

    /// PLL_LP_SDM_CTRL3 Register bits
    namespace pll_lp_sdm_ctrl3_bits {
        constexpr uint32_t LPM_DENOM = (28 << 0);  ///< Low Port Modulation Denominator
    }

    /// PLL_LP_SDM_NUM Register bits
    namespace pll_lp_sdm_num_bits {
        constexpr uint32_t LPM_NUM_SELECTED = (28 << 0);  ///< Low Port Modulation Numerator Applied
    }

    /// PLL_LP_SDM_DENOM Register bits
    namespace pll_lp_sdm_denom_bits {
        constexpr uint32_t LPM_DENOM_SELECTED = (28 << 0);  ///< Low Port Modulation Denominator Selected
    }

    /// PLL_DELAY_MATCH Register bits
    namespace pll_delay_match_bits {
        constexpr uint32_t LP_SDM_DELAY = (4 << 0);  ///< LP_SDM_DELAY
        constexpr uint32_t HPM_SDM_DELAY = (4 << 8);  ///< HPM_SDM_DELAY
        constexpr uint32_t HPM_BANK_DELAY = (4 << 16);  ///< HPM Bank Delay
    }

    /// PLL_CTUNE_CTRL Register bits
    namespace pll_ctune_ctrl_bits {
        constexpr uint32_t CTUNE_TARGET_MANUAL = (12 << 0);  ///< CTUNE Target Manual
        constexpr uint32_t CTUNE_TD = (1U << 15);  ///< CTUNE Target Disable
        constexpr uint32_t CTUNE_ADJUST = (4 << 16);  ///< CTUNE Count Adjustment
        constexpr uint32_t CTUNE_MANUAL = (7 << 24);  ///< CTUNE Manual
        constexpr uint32_t CTUNE_DIS = (1U << 31);  ///< CTUNE Disable
    }

    /// PLL_CTUNE_CNT6 Register bits
    namespace pll_ctune_cnt6_bits {
        constexpr uint32_t CTUNE_COUNT_6 = (12 << 0);  ///< CTUNE Count 6
    }

    /// PLL_CTUNE_CNT5_4 Register bits
    namespace pll_ctune_cnt5_4_bits {
        constexpr uint32_t CTUNE_COUNT_4 = (12 << 0);  ///< CTUNE Count 4
        constexpr uint32_t CTUNE_COUNT_5 = (12 << 16);  ///< CTUNE Count 5
    }

    /// PLL_CTUNE_CNT3_2 Register bits
    namespace pll_ctune_cnt3_2_bits {
        constexpr uint32_t CTUNE_COUNT_2 = (12 << 0);  ///< CTUNE Count 2
        constexpr uint32_t CTUNE_COUNT_3 = (12 << 16);  ///< CTUNE Count 3
    }

    /// PLL_CTUNE_CNT1_0 Register bits
    namespace pll_ctune_cnt1_0_bits {
        constexpr uint32_t CTUNE_COUNT_0 = (12 << 0);  ///< CTUNE Count 0
        constexpr uint32_t CTUNE_COUNT_1 = (12 << 16);  ///< CTUNE Count 1
    }

    /// PLL_CTUNE_RESULTS Register bits
    namespace pll_ctune_results_bits {
        constexpr uint32_t CTUNE_SELECTED = (7 << 0);  ///< Coarse Tune Band to VCO
        constexpr uint32_t CTUNE_BEST_DIFF = (8 << 8);  ///< Coarse Tune Absolute Best Difference
        constexpr uint32_t CTUNE_FREQ_TARGET = (12 << 16);  ///< Coarse Tune Frequency Target
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t PROTOCOL = (3 << 0);  ///< Radio Protocol Selection
        constexpr uint32_t TGT_PWR_SRC = (2 << 4);  ///< Target Power Source
        constexpr uint32_t REF_CLK_FREQ = (2 << 6);  ///< Radio Reference Clock Frequency
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t TSM_COUNT = (8 << 0);  ///< TSM Count
        constexpr uint32_t PLL_SEQ_STATE = (4 << 8);  ///< PLL Sequence State
        constexpr uint32_t RX_MODE = (1U << 12);  ///< Receive Mode
        constexpr uint32_t TX_MODE = (1U << 13);  ///< Transmit Mode
        constexpr uint32_t BTLE_SYSCLK_REQ = (1U << 16);  ///< BTLE System Clock Request
        constexpr uint32_t RIF_LL_ACTIVE = (1U << 17);  ///< Link Layer Active Indication
        constexpr uint32_t XTAL_READY = (1U << 18);  ///< RF Osciallator Xtal Ready
        constexpr uint32_t SOC_USING_RF_OSC_CLK = (1U << 19);  ///< SOC Using RF Clock Indication
    }

    /// OVERWRITE_VER Register bits
    namespace overwrite_ver_bits {
        constexpr uint32_t OVERWRITE_VER = (8 << 0);  ///< Overwrite Version Number.
    }

    /// DMA_CTRL Register bits
    namespace dma_ctrl_bits {
        constexpr uint32_t DMA_I_EN = (1U << 0);  ///< DMA I Enable
        constexpr uint32_t DMA_Q_EN = (1U << 1);  ///< DMA Q Enable
    }

    /// DMA_DATA Register bits
    namespace dma_data_bits {
        constexpr uint32_t DMA_DATA_11_0 = (12 << 0);  ///< DMA_DATA_11_0
        constexpr uint32_t DMA_DATA_27_16 = (12 << 16);  ///< DMA_DATA_27_16
    }

    /// DTEST_CTRL Register bits
    namespace dtest_ctrl_bits {
        constexpr uint32_t DTEST_PAGE = (6 << 0);  ///< DTEST Page Selector
        constexpr uint32_t DTEST_EN = (1U << 7);  ///< DTEST Enable
        constexpr uint32_t GPIO0_OVLAY_PIN = (4 << 8);  ///< GPIO 0 Overlay Pin
        constexpr uint32_t GPIO1_OVLAY_PIN = (4 << 12);  ///< GPIO 1 Overlay Pin
        constexpr uint32_t TSM_GPIO_OVLAY_0 = (1U << 16);  ///< TSM GPIO 0 Overlay Pin
        constexpr uint32_t TSM_GPIO_OVLAY_1 = (1U << 17);  ///< TSM GPIO 1 Overlay Pin
        constexpr uint32_t DTEST_SHFT = (3 << 24);  ///< DTEST Shift Control
        constexpr uint32_t RAW_MODE_I = (1U << 28);  ///< DTEST Raw Mode Enable for I Channel
        constexpr uint32_t RAW_MODE_Q = (1U << 29);  ///< DTEST Raw Mode Enable for Q Channel
    }

    /// PB_CTRL Register bits
    namespace pb_ctrl_bits {
        constexpr uint32_t PB_PROTECT = (1U << 0);  ///< PB Protect
    }

    /// TSM_CTRL Register bits
    namespace tsm_ctrl_bits {
        constexpr uint32_t FORCE_TX_EN = (1U << 2);  ///< Force Transmit Enable
        constexpr uint32_t FORCE_RX_EN = (1U << 3);  ///< Force Receive Enable
        constexpr uint32_t PA_RAMP_SEL = (2 << 4);  ///< PA Ramp Selection
        constexpr uint32_t DATA_PADDING_EN = (1U << 6);  ///< Data Padding Enable
        constexpr uint32_t TX_ABORT_DIS = (1U << 16);  ///< Transmit Abort Disable
        constexpr uint32_t RX_ABORT_DIS = (1U << 17);  ///< Receive Abort Disable
        constexpr uint32_t ABORT_ON_CTUNE = (1U << 18);  ///< Abort On Coarse Tune Lock Detect Failure
        constexpr uint32_t ABORT_ON_CYCLE_SLIP = (1U << 19);  ///< Abort On Cycle Slip Lock Detect Failure
        constexpr uint32_t ABORT_ON_FREQ_TARG = (1U << 20);  ///< Abort On Frequency Target Lock Detect Failure
        constexpr uint32_t BKPT = (8 << 24);  ///< TSM Breakpoint
    }

    /// END_OF_SEQ Register bits
    namespace end_of_seq_bits {
        constexpr uint32_t END_OF_TX_WU = (8 << 0);  ///< End of TX Warmup
        constexpr uint32_t END_OF_TX_WD = (8 << 8);  ///< End of TX Warmdown
        constexpr uint32_t END_OF_RX_WU = (8 << 16);  ///< End of RX Warmup
        constexpr uint32_t END_OF_RX_WD = (8 << 24);  ///< End of RX Warmdown
    }

    /// TSM_OVRD0 Register bits
    namespace tsm_ovrd0_bits {
        constexpr uint32_t PLL_REG_EN_OVRD_EN = (1U << 0);  ///< Override control for PLL_REG_EN
        constexpr uint32_t PLL_REG_EN_OVRD = (1U << 1);  ///< Override value for PLL_REG_EN
        constexpr uint32_t PLL_VCO_REG_EN_OVRD_EN = (1U << 2);  ///< Override control for PLL_VCO_REG_EN
        constexpr uint32_t PLL_VCO_REG_EN_OVRD = (1U << 3);  ///< Override value for PLL_VCO_REG_EN
        constexpr uint32_t QGEN_REG_EN_OVRD_EN = (1U << 4);  ///< Override control for QGEN_REG_EN
        constexpr uint32_t QGEN_REG_EN_OVRD = (1U << 5);  ///< Override value for QGEN_REG_EN
        constexpr uint32_t TCA_TX_REG_EN_OVRD_EN = (1U << 6);  ///< Override control for TCA_TX_REG_EN
        constexpr uint32_t TCA_TX_REG_EN_OVRD = (1U << 7);  ///< Override value for TCA_TX_REG_EN
        constexpr uint32_t ADC_ANA_REG_EN_OVRD_EN = (1U << 8);  ///< Override control for ADC_ANA_REG_EN
        constexpr uint32_t ADC_ANA_REG_EN_OVRD = (1U << 9);  ///< Override value for ADC_ANA_REG_EN
        constexpr uint32_t ADC_DIG_REG_EN_OVRD_EN = (1U << 10);  ///< Override control for ADC_DIG_REG_EN
        constexpr uint32_t ADC_DIG_REG_EN_OVRD = (1U << 11);  ///< Override value for ADC_DIG_REG_EN
        constexpr uint32_t XTAL_PLL_REF_CLK_EN_OVRD_EN = (1U << 12);  ///< Override control for XTAL_PLL_REF_CLK_EN
        constexpr uint32_t XTAL_PLL_REF_CLK_EN_OVRD = (1U << 13);  ///< Override value for XTAL_PLL_REF_CLK_EN
        constexpr uint32_t XTAL_ADC_REF_CLK_EN_OVRD_EN = (1U << 14);  ///< Override control for XTAL_ADC_REF_CLK_EN
        constexpr uint32_t XTAL_ADC_REF_CLK_EN_OVRD = (1U << 15);  ///< Override value for XTAL_ADC_REF_CLK_EN
        constexpr uint32_t PLL_VCO_AUTOTUNE_EN_OVRD_EN = (1U << 16);  ///< Override control for PLL_VCO_AUTOTUNE_EN
        constexpr uint32_t PLL_VCO_AUTOTUNE_EN_OVRD = (1U << 17);  ///< Override value for PLL_VCO_AUTOTUNE_EN
        constexpr uint32_t PLL_CYCLE_SLIP_LD_EN_OVRD_EN = (1U << 18);  ///< Override control for PLL_CYCLE_SLIP_LD_EN
        constexpr uint32_t PLL_CYCLE_SLIP_LD_EN_OVRD = (1U << 19);  ///< Override value for PLL_CYCLE_SLIP_LD_EN
        constexpr uint32_t PLL_VCO_EN_OVRD_EN = (1U << 20);  ///< Override control for PLL_VCO_EN
        constexpr uint32_t PLL_VCO_EN_OVRD = (1U << 21);  ///< Override value for PLL_VCO_EN
        constexpr uint32_t PLL_VCO_BUF_RX_EN_OVRD_EN = (1U << 22);  ///< Override control for PLL_VCO_BUF_RX_EN
        constexpr uint32_t PLL_VCO_BUF_RX_EN_OVRD = (1U << 23);  ///< Override value for PLL_VCO_BUF_RX_EN
        constexpr uint32_t PLL_VCO_BUF_TX_EN_OVRD_EN = (1U << 24);  ///< Override control for PLL_VCO_BUF_TX_EN
        constexpr uint32_t PLL_VCO_BUF_TX_EN_OVRD = (1U << 25);  ///< Override value for PLL_VCO_BUF_TX_EN
        constexpr uint32_t PLL_PA_BUF_EN_OVRD_EN = (1U << 26);  ///< Override control for PLL_PA_BUF_EN
        constexpr uint32_t PLL_PA_BUF_EN_OVRD = (1U << 27);  ///< Override value for PLL_PA_BUF_EN
        constexpr uint32_t PLL_LDV_EN_OVRD_EN = (1U << 28);  ///< Override control for PLL_LDV_EN
        constexpr uint32_t PLL_LDV_EN_OVRD = (1U << 29);  ///< Override value for PLL_LDV_EN
        constexpr uint32_t PLL_RX_LDV_RIPPLE_MUX_EN_OVRD_EN = (1U << 30);  ///< Override control for PLL_RX_LDV_RIPPLE_MUX_EN
        constexpr uint32_t PLL_RX_LDV_RIPPLE_MUX_EN_OVRD = (1U << 31);  ///< Override value for PLL_RX_LDV_RIPPLE_MUX_EN
    }

    /// TSM_OVRD1 Register bits
    namespace tsm_ovrd1_bits {
        constexpr uint32_t PLL_TX_LDV_RIPPLE_MUX_EN_OVRD_EN = (1U << 0);  ///< Override control for PLL_TX_LDV_RIPPLE_MUX_EN
        constexpr uint32_t PLL_TX_LDV_RIPPLE_MUX_EN_OVRD = (1U << 1);  ///< Override value for PLL_TX_LDV_RIPPLE_MUX_EN
        constexpr uint32_t PLL_FILTER_CHARGE_EN_OVRD_EN = (1U << 2);  ///< Override control for PLL_FILTER_CHARGE_EN
        constexpr uint32_t PLL_FILTER_CHARGE_EN_OVRD = (1U << 3);  ///< Override value for PLL_FILTER_CHARGE_EN
        constexpr uint32_t PLL_PHDET_EN_OVRD_EN = (1U << 4);  ///< Override control for PLL_PHDET_EN
        constexpr uint32_t PLL_PHDET_EN_OVRD = (1U << 5);  ///< Override value for PLL_PHDET_EN
        constexpr uint32_t QGEN25_EN_OVRD_EN = (1U << 6);  ///< Override control for QGEN25_EN
        constexpr uint32_t QGEN25_EN_OVRD = (1U << 7);  ///< Override value for QGEN25_EN
        constexpr uint32_t TX_EN_OVRD_EN = (1U << 8);  ///< Override control for TX_EN
        constexpr uint32_t TX_EN_OVRD = (1U << 9);  ///< Override value for TX_EN
        constexpr uint32_t ADC_EN_OVRD_EN = (1U << 10);  ///< Override control for ADC_EN
        constexpr uint32_t ADC_EN_OVRD = (1U << 11);  ///< Override value for ADC_EN
        constexpr uint32_t ADC_BIAS_EN_OVRD_EN = (1U << 12);  ///< Override control for ADC_BIAS_EN
        constexpr uint32_t ADC_BIAS_EN_OVRD = (1U << 13);  ///< Override value for ADC_BIAS_EN
        constexpr uint32_t ADC_CLK_EN_OVRD_EN = (1U << 14);  ///< Override control for ADC_CLK_EN
        constexpr uint32_t ADC_CLK_EN_OVRD = (1U << 15);  ///< Override value for ADC_CLK_EN
        constexpr uint32_t ADC_I_ADC_EN_OVRD_EN = (1U << 16);  ///< Override control for ADC_I_ADC_EN
        constexpr uint32_t ADC_I_ADC_EN_OVRD = (1U << 17);  ///< Override value for ADC_I_ADC_EN
        constexpr uint32_t ADC_Q_ADC_EN_OVRD_EN = (1U << 18);  ///< Override control for ADC_Q_ADC_EN
        constexpr uint32_t ADC_Q_ADC_EN_OVRD = (1U << 19);  ///< Override value for ADC_Q_ADC_EN
        constexpr uint32_t ADC_DAC1_EN_OVRD_EN = (1U << 20);  ///< Override control for ADC_DAC1_EN
        constexpr uint32_t ADC_DAC1_EN_OVRD = (1U << 21);  ///< Override value for ADC_DAC1_EN
        constexpr uint32_t ADC_DAC2_EN_OVRD_EN = (1U << 22);  ///< Override control for ADC_DAC2_EN
        constexpr uint32_t ADC_DAC2_EN_OVRD = (1U << 23);  ///< Override value for ADC_DAC2_EN
        constexpr uint32_t ADC_RST_EN_OVRD_EN = (1U << 24);  ///< Override control for ADC_RST_EN
        constexpr uint32_t ADC_RST_EN_OVRD = (1U << 25);  ///< Override value for ADC_RST_EN
        constexpr uint32_t BBF_I_EN_OVRD_EN = (1U << 26);  ///< Override control for BBF_I_EN
        constexpr uint32_t BBF_I_EN_OVRD = (1U << 27);  ///< Override value for BBF_I_EN
        constexpr uint32_t BBF_Q_EN_OVRD_EN = (1U << 28);  ///< Override control for BBF_Q_EN
        constexpr uint32_t BBF_Q_EN_OVRD = (1U << 29);  ///< Override value for BBF_Q_EN
        constexpr uint32_t BBF_PDET_EN_OVRD_EN = (1U << 30);  ///< Override control for BBF_PDET_EN
        constexpr uint32_t BBF_PDET_EN_OVRD = (1U << 31);  ///< Override value for BBF_PDET_EN
    }

    /// TSM_OVRD2 Register bits
    namespace tsm_ovrd2_bits {
        constexpr uint32_t BBF_DCOC_EN_OVRD_EN = (1U << 0);  ///< Override control for BBF_DCOC_EN
        constexpr uint32_t BBF_DCOC_EN_OVRD = (1U << 1);  ///< Override value for BBF_DCOC_EN
        constexpr uint32_t TCA_EN_OVRD_EN = (1U << 2);  ///< Override control for TCA_EN
        constexpr uint32_t TCA_EN_OVRD = (1U << 3);  ///< Override value for TCA_EN
        constexpr uint32_t TZA_I_EN_OVRD_EN = (1U << 4);  ///< Override control for TZA_I_EN
        constexpr uint32_t TZA_I_EN_OVRD = (1U << 5);  ///< Override value for TZA_I_EN
        constexpr uint32_t TZA_Q_EN_OVRD_EN = (1U << 6);  ///< Override control for TZA_Q_EN
        constexpr uint32_t TZA_Q_EN_OVRD = (1U << 7);  ///< Override value for TZA_Q_EN
        constexpr uint32_t TZA_PDET_EN_OVRD_EN = (1U << 8);  ///< Override control for TZA_PDET_EN
        constexpr uint32_t TZA_PDET_EN_OVRD = (1U << 9);  ///< Override value for TZA_PDET_EN
        constexpr uint32_t TZA_DCOC_EN_OVRD_EN = (1U << 10);  ///< Override control for TZA_DCOC_EN
        constexpr uint32_t TZA_DCOC_EN_OVRD = (1U << 11);  ///< Override value for TZA_DCOC_EN
        constexpr uint32_t PLL_DIG_EN_OVRD_EN = (1U << 12);  ///< Override control for PLL_DIG_EN
        constexpr uint32_t PLL_DIG_EN_OVRD = (1U << 13);  ///< Override value for PLL_DIG_EN
        constexpr uint32_t TX_DIG_EN_OVRD_EN = (1U << 14);  ///< Override control for TX_DIG_EN
        constexpr uint32_t TX_DIG_EN_OVRD = (1U << 15);  ///< Override value for TX_DIG_EN
        constexpr uint32_t RX_DIG_EN_OVRD_EN = (1U << 16);  ///< Override control for RX_DIG_EN
        constexpr uint32_t RX_DIG_EN_OVRD = (1U << 17);  ///< Override value for RX_DIG_EN
        constexpr uint32_t RX_INIT_OVRD_EN = (1U << 18);  ///< Override control for RX_INIT
        constexpr uint32_t RX_INIT_OVRD = (1U << 19);  ///< Override value for RX_INIT
        constexpr uint32_t SIGMA_DELTA_EN_OVRD_EN = (1U << 20);  ///< Override control for SIGMA_DELTA_EN
        constexpr uint32_t SIGMA_DELTA_EN_OVRD = (1U << 21);  ///< Override value for SIGMA_DELTA_EN
        constexpr uint32_t ZBDEM_RX_EN_OVRD_EN = (1U << 22);  ///< Override control for ZBDEM_RX_EN
        constexpr uint32_t ZBDEM_RX_EN_OVRD = (1U << 23);  ///< Override value for ZBDEM_RX_EN
        constexpr uint32_t DCOC_EN_OVRD_EN = (1U << 24);  ///< Override control for DCOC_EN
        constexpr uint32_t DCOC_EN_OVRD = (1U << 25);  ///< Override value for DCOC_EN
        constexpr uint32_t DCOC_INIT_OVRD_EN = (1U << 26);  ///< Override control for DCOC_INIT
        constexpr uint32_t DCOC_INIT_OVRD = (1U << 27);  ///< Override value for DCOC_INIT
        constexpr uint32_t FREQ_TARG_LD_EN_OVRD_EN = (1U << 28);  ///< Override control for FREQ_TARG_LD_EN
        constexpr uint32_t FREQ_TARG_LD_EN_OVRD = (1U << 29);  ///< Override value for FREQ_TARG_LD_EN
        constexpr uint32_t SAR_ADC_TRIG_EN_OVRD_EN = (1U << 30);  ///< Override control for SAR_ADC_TRIG_EN
        constexpr uint32_t SAR_ADC_TRIG_EN_OVRD = (1U << 31);  ///< Override value for SAR_ADC_TRIG_EN
    }

    /// TSM_OVRD3 Register bits
    namespace tsm_ovrd3_bits {
        constexpr uint32_t TSM_SPARE0_EN_OVRD_EN = (1U << 0);  ///< Override control for TSM_SPARE0_EN
        constexpr uint32_t TSM_SPARE0_EN_OVRD = (1U << 1);  ///< Override value for TSM_SPARE0_EN
        constexpr uint32_t TSM_SPARE1_EN_OVRD_EN = (1U << 2);  ///< Override control for TSM_SPARE1_EN
        constexpr uint32_t TSM_SPARE1_EN_OVRD = (1U << 3);  ///< Override value for TSM_SPARE1_EN
        constexpr uint32_t TSM_SPARE2_EN_OVRD_EN = (1U << 4);  ///< Override control for TSM_SPARE2_EN
        constexpr uint32_t TSM_SPARE2_EN_OVRD = (1U << 5);  ///< Override value for TSM_SPARE2_EN
        constexpr uint32_t TSM_SPARE3_EN_OVRD_EN = (1U << 6);  ///< Override control for TSM_SPARE3_EN
        constexpr uint32_t TSM_SPARE3_EN_OVRD = (1U << 7);  ///< Override value for TSM_SPARE3_EN
        constexpr uint32_t TX_MODE_OVRD_EN = (1U << 8);  ///< Override control for TX_MODE
        constexpr uint32_t TX_MODE_OVRD = (1U << 9);  ///< Override value for TX_MODE
        constexpr uint32_t RX_MODE_OVRD_EN = (1U << 10);  ///< Override control for RX_MODE
        constexpr uint32_t RX_MODE_OVRD = (1U << 11);  ///< Override value for RX_MODE
    }

    /// PA_POWER Register bits
    namespace pa_power_bits {
        constexpr uint32_t PA_POWER = (4 << 0);  ///< PA Power
    }

    /// PA_BIAS_TBL0 Register bits
    namespace pa_bias_tbl0_bits {
        constexpr uint32_t PA_BIAS0 = (4 << 0);  ///< PA_BIAS0
        constexpr uint32_t PA_BIAS1 = (4 << 8);  ///< PA_BIAS1
        constexpr uint32_t PA_BIAS2 = (4 << 16);  ///< PA_BIAS2
        constexpr uint32_t PA_BIAS3 = (4 << 24);  ///< PA_BIAS3
    }

    /// PA_BIAS_TBL1 Register bits
    namespace pa_bias_tbl1_bits {
        constexpr uint32_t PA_BIAS4 = (4 << 0);  ///< PA_BIAS4
        constexpr uint32_t PA_BIAS5 = (4 << 8);  ///< PA_BIAS5
        constexpr uint32_t PA_BIAS6 = (4 << 16);  ///< PA_BIAS6
        constexpr uint32_t PA_BIAS7 = (4 << 24);  ///< PA_BIAS7
    }

    /// RECYCLE_COUNT Register bits
    namespace recycle_count_bits {
        constexpr uint32_t RECYCLE_COUNT0 = (8 << 0);  ///< TSM RX Recycle Count 0
        constexpr uint32_t RECYCLE_COUNT1 = (8 << 8);  ///< TSM RX Recycle Count 1
    }

    /// TSM_TIMING00 Register bits
    namespace tsm_timing00_bits {
        constexpr uint32_t PLL_REG_EN_TX_HI = (8 << 0);  ///< Assertion time setting for PLL_REG_EN TX sequence.
        constexpr uint32_t PLL_REG_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for PLL_REG_EN signal or group TX sequence.
        constexpr uint32_t PLL_REG_EN_RX_HI = (8 << 16);  ///< Assertion time setting for PLL_REG_EN signal or group RX sequence.
        constexpr uint32_t PLL_REG_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for PLL_REG_EN signal or group RX sequence.
    }

    /// TSM_TIMING01 Register bits
    namespace tsm_timing01_bits {
        constexpr uint32_t PLL_VCO_REG_EN_TX_HI = (8 << 0);  ///< Assertion time setting for PLL_VCO_REG_EN TX sequence.
        constexpr uint32_t PLL_VCO_REG_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for PLL_VCO_REG_EN signal or group TX sequence.
        constexpr uint32_t PLL_VCO_REG_EN_RX_HI = (8 << 16);  ///< Assertion time setting for PLL_VCO_REG_EN signal or group RX sequence.
        constexpr uint32_t PLL_VCO_REG_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for PLL_VCO_REG_EN signal or group RX sequence.
    }

    /// TSM_TIMING02 Register bits
    namespace tsm_timing02_bits {
        constexpr uint32_t QGEN_REG_EN_TX_HI = (8 << 0);  ///< Assertion time setting for QGEN_REG_EN TX sequence.
        constexpr uint32_t QGEN_REG_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for QGEN_REG_EN signal or group TX sequence.
        constexpr uint32_t QGEN_REG_EN_RX_HI = (8 << 16);  ///< Assertion time setting for QGEN_REG_EN signal or group RX sequence.
        constexpr uint32_t QGEN_REG_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for QGEN_REG_EN signal or group RX sequence.
    }

    /// TSM_TIMING03 Register bits
    namespace tsm_timing03_bits {
        constexpr uint32_t TCA_TX_REG_EN_TX_HI = (8 << 0);  ///< Assertion time setting for TCA_TX_REG_EN TX sequence.
        constexpr uint32_t TCA_TX_REG_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for TCA_TX_REG_EN signal or group TX sequence.
        constexpr uint32_t TCA_TX_REG_EN_RX_HI = (8 << 16);  ///< Assertion time setting for TCA_TX_REG_EN signal or group RX sequence.
        constexpr uint32_t TCA_TX_REG_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for TCA_TX_REG_EN signal or group RX sequence.
    }

    /// TSM_TIMING04 Register bits
    namespace tsm_timing04_bits {
        constexpr uint32_t ADC_REG_EN_RX_HI = (8 << 16);  ///< Assertion time setting for ADC_REG_EN signal or group RX sequence.
        constexpr uint32_t ADC_REG_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for ADC_REG_EN signal or group RX sequence.
    }

    /// TSM_TIMING05 Register bits
    namespace tsm_timing05_bits {
        constexpr uint32_t PLL_REF_CLK_EN_TX_HI = (8 << 0);  ///< Assertion time setting for PLL_REF_CLK_EN TX sequence.
        constexpr uint32_t PLL_REF_CLK_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for PLL_REF_CLK_EN signal or group TX sequence.
        constexpr uint32_t PLL_REF_CLK_EN_RX_HI = (8 << 16);  ///< Assertion time setting for PLL_REF_CLK_EN signal or group RX sequence.
        constexpr uint32_t PLL_REF_CLK_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for PLL_REF_CLK_EN signal or group RX sequence.
    }

    /// TSM_TIMING06 Register bits
    namespace tsm_timing06_bits {
        constexpr uint32_t ADC_CLK_EN_RX_HI = (8 << 16);  ///< Assertion time setting for ADC_CLK_EN signal or group RX sequence.
        constexpr uint32_t ADC_CLK_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for ADC_CLK_EN signal or group RX sequence.
    }

    /// TSM_TIMING07 Register bits
    namespace tsm_timing07_bits {
        constexpr uint32_t PLL_VCO_AUTOTUNE_EN_TX_HI = (8 << 0);  ///< Assertion time setting for PLL_VCO_AUTOTUNE_EN TX sequence.
        constexpr uint32_t PLL_VCO_AUTOTUNE_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for PLL_VCO_AUTOTUNE_EN signal or group TX sequence.
        constexpr uint32_t PLL_VCO_AUTOTUNE_EN_RX_HI = (8 << 16);  ///< Assertion time setting for PLL_VCO_AUTOTUNE_EN signal or group RX sequence.
        constexpr uint32_t PLL_VCO_AUTOTUNE_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for PLL_VCO_AUTOTUNE_EN signal or group RX sequence.
    }

    /// TSM_TIMING08 Register bits
    namespace tsm_timing08_bits {
        constexpr uint32_t PLL_CYCLE_SLIP_LD_EN_TX_HI = (8 << 0);  ///< Assertion time setting for PLL_CYCLE_SLIP_LD_EN TX sequence.
        constexpr uint32_t PLL_CYCLE_SLIP_LD_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for PLL_CYCLE_SLIP_LD_EN signal or group TX sequence.
        constexpr uint32_t PLL_CYCLE_SLIP_LD_EN_RX_HI = (8 << 16);  ///< Assertion time setting for PLL_CYCLE_SLIP_LD_EN signal or group RX sequence.
        constexpr uint32_t PLL_CYCLE_SLIP_LD_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for PLL_CYCLE_SLIP_LD_EN signal or group RX sequence.
    }

    /// TSM_TIMING09 Register bits
    namespace tsm_timing09_bits {
        constexpr uint32_t PLL_VCO_EN_TX_HI = (8 << 0);  ///< Assertion time setting for PLL_VCO_EN TX sequence.
        constexpr uint32_t PLL_VCO_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for PLL_VCO_EN signal or group TX sequence.
        constexpr uint32_t PLL_VCO_EN_RX_HI = (8 << 16);  ///< Assertion time setting for PLL_VCO_EN signal or group RX sequence.
        constexpr uint32_t PLL_VCO_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for PLL_VCO_EN signal or group RX sequence.
    }

    /// TSM_TIMING10 Register bits
    namespace tsm_timing10_bits {
        constexpr uint32_t PLL_VCO_BUF_RX_EN_RX_HI = (8 << 16);  ///< Assertion time setting for PLL_VCO_BUF_RX_EN signal or group RX sequence.
        constexpr uint32_t PLL_VCO_BUF_RX_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for PLL_VCO_BUF_RX_EN signal or group RX sequence.
    }

    /// TSM_TIMING11 Register bits
    namespace tsm_timing11_bits {
        constexpr uint32_t PLL_VCO_BUF_TX_EN_TX_HI = (8 << 0);  ///< Assertion time setting for PLL_VCO_BUF_TX_EN TX sequence.
        constexpr uint32_t PLL_VCO_BUF_TX_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for PLL_VCO_BUF_TX_EN signal or group TX sequence.
    }

    /// TSM_TIMING12 Register bits
    namespace tsm_timing12_bits {
        constexpr uint32_t PLL_PA_BUF_EN_TX_HI = (8 << 0);  ///< Assertion time setting for PLL_PA_BUF_EN TX sequence.
        constexpr uint32_t PLL_PA_BUF_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for PLL_PA_BUF_EN signal or group TX sequence.
    }

    /// TSM_TIMING13 Register bits
    namespace tsm_timing13_bits {
        constexpr uint32_t PLL_LDV_EN_TX_HI = (8 << 0);  ///< Assertion time setting for PLL_LDV_EN TX sequence.
        constexpr uint32_t PLL_LDV_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for PLL_LDV_EN signal or group TX sequence.
        constexpr uint32_t PLL_LDV_EN_RX_HI = (8 << 16);  ///< Assertion time setting for PLL_LDV_EN signal or group RX sequence.
        constexpr uint32_t PLL_LDV_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for PLL_LDV_EN signal or group RX sequence.
    }

    /// TSM_TIMING14 Register bits
    namespace tsm_timing14_bits {
        constexpr uint32_t PLL_RX_LDV_RIPPLE_MUX_EN_RX_HI = (8 << 16);  ///< Assertion time setting for PLL_RX_LDV_RIPPLE_MUX_EN signal or group RX sequence.
        constexpr uint32_t PLL_RX_LDV_RIPPLE_MUX_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for PLL_RX_LDV_RIPPLE_MUX_EN signal or group RX sequence.
    }

    /// TSM_TIMING15 Register bits
    namespace tsm_timing15_bits {
        constexpr uint32_t PLL_TX_LDV_RIPPLE_MUX_EN_TX_HI = (8 << 0);  ///< Assertion time setting for PLL_TX_LDV_RIPPLE_MUX_EN TX sequence.
        constexpr uint32_t PLL_TX_LDV_RIPPLE_MUX_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for PLL_TX_LDV_RIPPLE_MUX_EN signal or group TX sequence.
    }

    /// TSM_TIMING16 Register bits
    namespace tsm_timing16_bits {
        constexpr uint32_t PLL_FILTER_CHARGE_EN_TX_HI = (8 << 0);  ///< Assertion time setting for PLL_FILTER_CHARGE_EN TX sequence.
        constexpr uint32_t PLL_FILTER_CHARGE_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for PLL_FILTER_CHARGE_EN signal or group TX sequence.
        constexpr uint32_t PLL_FILTER_CHARGE_EN_RX_HI = (8 << 16);  ///< Assertion time setting for PLL_FILTER_CHARGE_EN signal or group RX sequence.
        constexpr uint32_t PLL_FILTER_CHARGE_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for PLL_FILTER_CHARGE_EN signal or group RX sequence.
    }

    /// TSM_TIMING17 Register bits
    namespace tsm_timing17_bits {
        constexpr uint32_t PLL_PHDET_EN_TX_HI = (8 << 0);  ///< Assertion time setting for PLL_PHDET_EN TX sequence.
        constexpr uint32_t PLL_PHDET_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for PLL_PHDET_EN signal or group TX sequence.
        constexpr uint32_t PLL_PHDET_EN_RX_HI = (8 << 16);  ///< Assertion time setting for PLL_PHDET_EN signal or group RX sequence.
        constexpr uint32_t PLL_PHDET_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for PLL_PHDET_EN signal or group RX sequence.
    }

    /// TSM_TIMING18 Register bits
    namespace tsm_timing18_bits {
        constexpr uint32_t QGEN25_EN_RX_HI = (8 << 16);  ///< Assertion time setting for QGEN25_EN signal or group RX sequence.
        constexpr uint32_t QGEN25_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for QGEN25_EN signal or group RX sequence.
    }

    /// TSM_TIMING19 Register bits
    namespace tsm_timing19_bits {
        constexpr uint32_t TX_EN_TX_HI = (8 << 0);  ///< Assertion time setting for TX_EN TX sequence.
        constexpr uint32_t TX_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for TX_EN signal or group TX sequence.
    }

    /// TSM_TIMING20 Register bits
    namespace tsm_timing20_bits {
        constexpr uint32_t ADC_EN_RX_HI = (8 << 16);  ///< Assertion time setting for ADC_EN signal or group RX sequence.
        constexpr uint32_t ADC_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for ADC_EN signal or group RX sequence.
    }

    /// TSM_TIMING21 Register bits
    namespace tsm_timing21_bits {
        constexpr uint32_t ADC_I_Q_EN_RX_HI = (8 << 16);  ///< Assertion time setting for ADC_I_Q_EN signal or group RX sequence.
        constexpr uint32_t ADC_I_Q_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for ADC_I_Q_EN signal or group RX sequence.
    }

    /// TSM_TIMING22 Register bits
    namespace tsm_timing22_bits {
        constexpr uint32_t ADC_DAC_EN_RX_HI = (8 << 16);  ///< Assertion time setting for ADC_DAC_EN signal or group RX sequence.
        constexpr uint32_t ADC_DAC_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for ADC_DAC_EN signal or group RX sequence.
    }

    /// TSM_TIMING23 Register bits
    namespace tsm_timing23_bits {
        constexpr uint32_t ADC_RST_EN_RX_HI = (8 << 16);  ///< Assertion time setting for ADC_RST_EN signal or group RX sequence.
        constexpr uint32_t ADC_RST_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for ADC_RST_EN signal or group RX sequence.
    }

    /// TSM_TIMING24 Register bits
    namespace tsm_timing24_bits {
        constexpr uint32_t BBF_EN_RX_HI = (8 << 16);  ///< Assertion time setting for BBF_EN signal or group RX sequence.
        constexpr uint32_t BBF_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for BBF_EN signal or group RX sequence.
    }

    /// TSM_TIMING25 Register bits
    namespace tsm_timing25_bits {
        constexpr uint32_t TCA_EN_RX_HI = (8 << 16);  ///< Assertion time setting for TCA_EN signal or group RX sequence.
        constexpr uint32_t TCA_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for TCA_EN signal or group RX sequence.
    }

    /// TSM_TIMING26 Register bits
    namespace tsm_timing26_bits {
        constexpr uint32_t PLL_DIG_EN_TX_HI = (8 << 0);  ///< Assertion time setting for PLL_DIG_EN TX sequence.
        constexpr uint32_t PLL_DIG_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for PLL_DIG_EN signal or group TX sequence.
        constexpr uint32_t PLL_DIG_EN_RX_HI = (8 << 16);  ///< Assertion time setting for PLL_DIG_EN signal or group RX sequence.
        constexpr uint32_t PLL_DIG_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for PLL_DIG_EN signal or group RX sequence.
    }

    /// TSM_TIMING27 Register bits
    namespace tsm_timing27_bits {
        constexpr uint32_t TX_DIG_EN_TX_HI = (8 << 0);  ///< Assertion time setting for TX_DIG_EN TX sequence.
        constexpr uint32_t TX_DIG_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for TX_DIG_EN signal or group TX sequence.
    }

    /// TSM_TIMING28 Register bits
    namespace tsm_timing28_bits {
        constexpr uint32_t RX_DIG_EN_RX_HI = (8 << 16);  ///< Assertion time setting for RX_DIG_EN signal or group RX sequence.
        constexpr uint32_t RX_DIG_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for RX_DIG_EN signal or group RX sequence.
    }

    /// TSM_TIMING29 Register bits
    namespace tsm_timing29_bits {
        constexpr uint32_t RX_INIT_RX_HI = (8 << 16);  ///< Assertion time setting for RX_INIT signal or group RX sequence.
        constexpr uint32_t RX_INIT_RX_LO = (8 << 24);  ///< Deassertion time setting for RX_INIT signal or group RX sequence.
    }

    /// TSM_TIMING30 Register bits
    namespace tsm_timing30_bits {
        constexpr uint32_t SIGMA_DELTA_EN_TX_HI = (8 << 0);  ///< Assertion time setting for SIGMA_DELTA_EN TX sequence.
        constexpr uint32_t SIGMA_DELTA_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for SIGMA_DELTA_EN signal or group TX sequence.
        constexpr uint32_t SIGMA_DELTA_EN_RX_HI = (8 << 16);  ///< Assertion time setting for SIGMA_DELTA_EN signal or group RX sequence.
        constexpr uint32_t SIGMA_DELTA_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for SIGMA_DELTA_EN signal or group RX sequence.
    }

    /// TSM_TIMING31 Register bits
    namespace tsm_timing31_bits {
        constexpr uint32_t ZBDEM_RX_EN_RX_HI = (8 << 16);  ///< Assertion time setting for ZBDEM_RX_EN signal or group RX sequence.
        constexpr uint32_t ZBDEM_RX_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for ZBDEM_RX_EN signal or group RX sequence.
    }

    /// TSM_TIMING32 Register bits
    namespace tsm_timing32_bits {
        constexpr uint32_t DCOC_EN_RX_HI = (8 << 16);  ///< Assertion time setting for DCOC_EN signal or group RX sequence.
        constexpr uint32_t DCOC_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for DCOC_EN signal or group RX sequence.
    }

    /// TSM_TIMING33 Register bits
    namespace tsm_timing33_bits {
        constexpr uint32_t DCOC_INIT_RX_HI = (8 << 16);  ///< Assertion time setting for DCOC_INIT signal or group RX sequence.
        constexpr uint32_t DCOC_INIT_RX_LO = (8 << 24);  ///< Deassertion time setting for DCOC_INIT signal or group RX sequence.
    }

    /// TSM_TIMING34 Register bits
    namespace tsm_timing34_bits {
        constexpr uint32_t FREQ_TARG_LD_EN_TX_HI = (8 << 0);  ///< Assertion time setting for FREQ_TARG_LD_EN TX sequence.
        constexpr uint32_t FREQ_TARG_LD_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for FREQ_TARG_LD_EN signal or group TX sequence.
        constexpr uint32_t FREQ_TARG_LD_EN_RX_HI = (8 << 16);  ///< Assertion time setting for FREQ_TARG_LD_EN signal or group RX sequence.
        constexpr uint32_t FREQ_TARG_LD_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for FREQ_TARG_LD_EN signal or group RX sequence.
    }

    /// TSM_TIMING35 Register bits
    namespace tsm_timing35_bits {
        constexpr uint32_t SAR_ADC_TRIG_EN_TX_HI = (8 << 0);  ///< Assertion time setting for SAR_ADC_TRIG_EN TX sequence.
        constexpr uint32_t SAR_ADC_TRIG_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for SAR_ADC_TRIG_EN signal or group TX sequence.
        constexpr uint32_t SAR_ADC_TRIG_EN_RX_HI = (8 << 16);  ///< Assertion time setting for SAR_ADC_TRIG_EN signal or group RX sequence.
        constexpr uint32_t SAR_ADC_TRIG_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for SAR_ADC_TRIG_EN signal or group RX sequence.
    }

    /// TSM_TIMING36 Register bits
    namespace tsm_timing36_bits {
        constexpr uint32_t TSM_SPARE0_EN_TX_HI = (8 << 0);  ///< Assertion time setting for TSM_SPARE0_EN TX sequence.
        constexpr uint32_t TSM_SPARE0_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for TSM_SPARE0_EN signal or group TX sequence.
        constexpr uint32_t TSM_SPARE0_EN_RX_HI = (8 << 16);  ///< Assertion time setting for TSM_SPARE0_EN signal or group RX sequence.
        constexpr uint32_t TSM_SPARE0_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for TSM_SPARE0_EN signal or group RX sequence.
    }

    /// TSM_TIMING37 Register bits
    namespace tsm_timing37_bits {
        constexpr uint32_t TSM_SPARE1_EN_TX_HI = (8 << 0);  ///< Assertion time setting for TSM_SPARE1_EN TX sequence.
        constexpr uint32_t TSM_SPARE1_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for TSM_SPARE1_EN signal or group TX sequence.
        constexpr uint32_t TSM_SPARE1_EN_RX_HI = (8 << 16);  ///< Assertion time setting for TSM_SPARE1_EN signal or group RX sequence.
        constexpr uint32_t TSM_SPARE1_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for TSM_SPARE1_EN signal or group RX sequence.
    }

    /// TSM_TIMING38 Register bits
    namespace tsm_timing38_bits {
        constexpr uint32_t TSM_SPARE2_EN_TX_HI = (8 << 0);  ///< Assertion time setting for TSM_SPARE2_EN TX sequence.
        constexpr uint32_t TSM_SPARE2_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for TSM_SPARE2_EN signal or group TX sequence.
        constexpr uint32_t TSM_SPARE2_EN_RX_HI = (8 << 16);  ///< Assertion time setting for TSM_SPARE2_EN signal or group RX sequence.
        constexpr uint32_t TSM_SPARE2_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for TSM_SPARE2_EN signal or group RX sequence.
    }

    /// TSM_TIMING39 Register bits
    namespace tsm_timing39_bits {
        constexpr uint32_t TSM_SPARE3_EN_TX_HI = (8 << 0);  ///< Assertion time setting for TSM_SPARE3_EN TX sequence.
        constexpr uint32_t TSM_SPARE3_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for TSM_SPARE3_EN signal or group TX sequence.
        constexpr uint32_t TSM_SPARE3_EN_RX_HI = (8 << 16);  ///< Assertion time setting for TSM_SPARE3_EN signal or group RX sequence.
        constexpr uint32_t TSM_SPARE3_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for TSM_SPARE3_EN signal or group RX sequence.
    }

    /// TSM_TIMING40 Register bits
    namespace tsm_timing40_bits {
        constexpr uint32_t GPIO0_TRIG_EN_TX_HI = (8 << 0);  ///< Assertion time setting for GPIO0_TRIG_EN TX sequence.
        constexpr uint32_t GPIO0_TRIG_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for GPIO0_TRIG_EN signal or group TX sequence.
        constexpr uint32_t GPIO0_TRIG_EN_RX_HI = (8 << 16);  ///< Assertion time setting for GPIO0_TRIG_EN signal or group RX sequence.
        constexpr uint32_t GPIO0_TRIG_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for GPIO0_TRIG_EN signal or group RX sequence.
    }

    /// TSM_TIMING41 Register bits
    namespace tsm_timing41_bits {
        constexpr uint32_t GPIO1_TRIG_EN_TX_HI = (8 << 0);  ///< Assertion time setting for GPIO1_TRIG_EN TX sequence.
        constexpr uint32_t GPIO1_TRIG_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for GPIO1_TRIG_EN signal or group TX sequence.
        constexpr uint32_t GPIO1_TRIG_EN_RX_HI = (8 << 16);  ///< Assertion time setting for GPIO1_TRIG_EN signal or group RX sequence.
        constexpr uint32_t GPIO1_TRIG_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for GPIO1_TRIG_EN signal or group RX sequence.
    }

    /// TSM_TIMING42 Register bits
    namespace tsm_timing42_bits {
        constexpr uint32_t GPIO2_TRIG_EN_TX_HI = (8 << 0);  ///< Assertion time setting for GPIO2_TRIG_EN TX sequence.
        constexpr uint32_t GPIO2_TRIG_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for GPIO2_TRIG_EN signal or group TX sequence.
        constexpr uint32_t GPIO2_TRIG_EN_RX_HI = (8 << 16);  ///< Assertion time setting for GPIO2_TRIG_EN signal or group RX sequence.
        constexpr uint32_t GPIO2_TRIG_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for GPIO2_TRIG_EN signal or group RX sequence.
    }

    /// TSM_TIMING43 Register bits
    namespace tsm_timing43_bits {
        constexpr uint32_t GPIO3_TRIG_EN_TX_HI = (8 << 0);  ///< Assertion time setting for GPIO3_TRIG_EN TX sequence.
        constexpr uint32_t GPIO3_TRIG_EN_TX_LO = (8 << 8);  ///< Deassertion time setting for GPIO3_TRIG_EN signal or group TX sequence.
        constexpr uint32_t GPIO3_TRIG_EN_RX_HI = (8 << 16);  ///< Assertion time setting for GPIO3_TRIG_EN signal or group RX sequence.
        constexpr uint32_t GPIO3_TRIG_EN_RX_LO = (8 << 24);  ///< Deassertion time setting for GPIO3_TRIG_EN signal or group RX sequence.
    }

    /// CORR_CTRL Register bits
    namespace corr_ctrl_bits {
        constexpr uint32_t CORR_VT = (8 << 0);  ///< CORR_VT
        constexpr uint32_t CORR_NVAL = (3 << 8);  ///< CORR_NVAL
        constexpr uint32_t MAX_CORR_EN = (1U << 11);  ///< MAX_CORR_EN
        constexpr uint32_t RX_MAX_CORR = (8 << 16);  ///< RX_MAX_CORR
        constexpr uint32_t RX_MAX_PREAMBLE = (8 << 24);  ///< RX_MAX_PREAMBLE
    }

    /// PN_TYPE Register bits
    namespace pn_type_bits {
        constexpr uint32_t PN_TYPE = (1U << 0);  ///< PN_TYPE
        constexpr uint32_t TX_INV = (1U << 1);  ///< TX_INV
    }

    /// PN_CODE Register bits
    namespace pn_code_bits {
        constexpr uint32_t PN_LSB = (16 << 0);  ///< PN_LSB
        constexpr uint32_t PN_MSB = (16 << 16);  ///< PN_MSB
    }

    /// SYNC_CTRL Register bits
    namespace sync_ctrl_bits {
        constexpr uint32_t SYNC_PER = (3 << 0);  ///< Symbol Sync Tracking Period
        constexpr uint32_t TRACK_ENABLE = (1U << 3);  ///< TRACK_ENABLE
    }

    /// SNF_THR Register bits
    namespace snf_thr_bits {
        constexpr uint32_t SNF_THR = (8 << 0);  ///< SNIFF Mode Threshold
    }

    /// FAD_THR Register bits
    namespace fad_thr_bits {
        constexpr uint32_t FAD_THR = (8 << 0);  ///< FAD_THR
    }

    /// ZBDEM_AFC Register bits
    namespace zbdem_afc_bits {
        constexpr uint32_t AFC_EN = (1U << 0);  ///< AFC_EN
        constexpr uint32_t DCD_EN = (1U << 1);  ///< DCD Mode Enable
        constexpr uint32_t AFC_OUT = (5 << 8);  ///< AFC_OUT
    }

    /// LPPS_CTRL Register bits
    namespace lpps_ctrl_bits {
        constexpr uint32_t LPPS_ENABLE = (1U << 0);  ///< LPPS Mode Enable
        constexpr uint32_t LPPS_QGEN25_ALLOW = (1U << 1);  ///< LPPS_QGEN25_ALLOW
        constexpr uint32_t LPPS_ADC_ALLOW = (1U << 2);  ///< LPPS_ADC_ALLOW
        constexpr uint32_t LPPS_ADC_CLK_ALLOW = (1U << 3);  ///< LPPS_ADC_CLK_ALLOW
        constexpr uint32_t LPPS_ADC_I_Q_ALLOW = (1U << 4);  ///< LPPS_ADC_I_Q_ALLOW
        constexpr uint32_t LPPS_ADC_DAC_ALLOW = (1U << 5);  ///< LPPS_ADC_DAC_ALLOW
        constexpr uint32_t LPPS_BBF_ALLOW = (1U << 6);  ///< LPPS_BBF_ALLOW
        constexpr uint32_t LPPS_TCA_ALLOW = (1U << 7);  ///< LPPS_TCA_ALLOW
    }

    /// ADC_CTRL Register bits
    namespace adc_ctrl_bits {
        constexpr uint32_t ADC_32MHZ_SEL = (1U << 0);  ///< ADC 32MHZ Clock Select
        constexpr uint32_t ADC_2X_CLK_SEL = (1U << 2);  ///< ADC_2X_CLK_SEL
        constexpr uint32_t ADC_DITHER_ON = (1U << 9);  ///< ADC Dither On
        constexpr uint32_t ADC_TEST_ON = (1U << 10);  ///< ADC Test On
        constexpr uint32_t ADC_COMP_ON = (16 << 16);  ///< ADC Comparator Enable
    }

    /// ADC_TUNE Register bits
    namespace adc_tune_bits {
        constexpr uint32_t ADC_R1_TUNE = (3 << 0);  ///< ADC_R1_TUNE
        constexpr uint32_t ADC_R2_TUNE = (3 << 4);  ///< ADC_R2_TUNE
        constexpr uint32_t ADC_C1_TUNE = (4 << 16);  ///< ADC_C1_TUNE
        constexpr uint32_t ADC_C2_TUNE = (4 << 20);  ///< ADC_C2_TUNE
    }

    /// ADC_ADJ Register bits
    namespace adc_adj_bits {
        constexpr uint32_t ADC_IB_OPAMP1_ADJ = (3 << 0);  ///< ADC_IB_OPAMP1_ADJ
        constexpr uint32_t ADC_IB_OPAMP2_ADJ = (3 << 4);  ///< ADC_IB_OPAMP2_ADJ
        constexpr uint32_t ADC_IB_DAC1_ADJ = (3 << 12);  ///< ADC_IB_DAC1_ADJ
        constexpr uint32_t ADC_IB_DAC2_ADJ = (3 << 16);  ///< ADC_IB_DAC2_ADJ
        constexpr uint32_t ADC_IB_FLSH_ADJ = (3 << 24);  ///< ADC_IB_FLSH_ADJ
        constexpr uint32_t ADC_FLSH_RES_ADJ = (3 << 28);  ///< ADC_FLSH_RES_ADJ
    }

    /// ADC_REGS Register bits
    namespace adc_regs_bits {
        constexpr uint32_t ADC_ANA_REG_SUPPLY = (4 << 0);  ///< ADC_ANA_REG_SUPPLY
        constexpr uint32_t ADC_REG_DIG_SUPPLY = (4 << 4);  ///< ADC_REG_DIG_SUPPLY
        constexpr uint32_t ADC_ANA_REG_BYPASS_ON = (1U << 8);  ///< ADC_ANA_REG_BYPASS_ON
        constexpr uint32_t ADC_DIG_REG_BYPASS_ON = (1U << 9);  ///< ADC_DIG_REG_BYPASS_ON
        constexpr uint32_t ADC_VCMREF_BYPASS_ON = (1U << 15);  ///< ADC_VCMREF_BYPASS_ON
        constexpr uint32_t ADC_INTERNAL_IREF_BYPASS_ON = (1U << 17);  ///< ADC_INTERNAL_IREF_BYPASS_ON
    }

    /// ADC_TRIMS Register bits
    namespace adc_trims_bits {
        constexpr uint32_t ADC_IREF_OPAMPS_RES_TRIM = (3 << 0);  ///< ADC_IREF_OPAMPS_RES_TRIM
        constexpr uint32_t ADC_IREF_FLSH_RES_TRIM = (3 << 4);  ///< ADC_IREF_FLSH_RES_TRIM
        constexpr uint32_t ADC_VCM_TRIM = (3 << 8);  ///< ADC_VCM_TRIM
    }

    /// ADC_TEST_CTRL Register bits
    namespace adc_test_ctrl_bits {
        constexpr uint32_t ADC_ATST_SEL = (5 << 0);  ///< ADC Analog Test Selection
        constexpr uint32_t ADC_DIG_REG_ATST_SEL = (2 << 8);  ///< ADC_DIG_REG_ATST_SEL
        constexpr uint32_t ADC_ANA_REG_ATST_SEL = (2 << 12);  ///< ADC_ANA_REG_ATST_SEL
        constexpr uint32_t DCOC_ALPHA_RADIUS_GS_IDX = (3 << 24);  ///< Alpha-R Scaling
        constexpr uint32_t ADC_SPARE3 = (1U << 27);  ///< ADC_SPARE3
    }

    /// BBF_CTRL Register bits
    namespace bbf_ctrl_bits {
        constexpr uint32_t BBF_CAP_TUNE = (4 << 0);  ///< BBF_CAP_TUNE
        constexpr uint32_t BBF_RES_TUNE2 = (4 << 4);  ///< BBF_RES_TUNE2
        constexpr uint32_t BBF_CUR_CNTL = (1U << 8);  ///< BBF_CUR_CNTL
        constexpr uint32_t BBF_DCOC_ON = (1U << 9);  ///< BBF_DCOC_ON
        constexpr uint32_t BBF_TMUX_ON = (1U << 11);  ///< BBF_TMUX_ON
        constexpr uint32_t DCOC_ALPHAC_SCALE_GS_IDX = (2 << 12);  ///< DCOC Alpha-C Scaling
        constexpr uint32_t BBF_SPARE_3_2 = (2 << 14);  ///< BBF_SPARE_3_2
    }

    /// RX_ANA_CTRL Register bits
    namespace rx_ana_ctrl_bits {
        constexpr uint32_t RX_ATST_SEL = (4 << 0);  ///< RX_ATST_SEL
        constexpr uint32_t IQMC_DC_GAIN_ADJ_EN = (1U << 4);  ///< IQMC_DC_GAIN_ADJ_EN
        constexpr uint32_t LNM_SPARE_3_2_1 = (3 << 5);  ///< LNM_SPARE_3_2_1
    }

    /// XTAL_CTRL Register bits
    namespace xtal_ctrl_bits {
        constexpr uint32_t XTAL_TRIM = (8 << 0);  ///< XTAL Trim
        constexpr uint32_t XTAL_GM = (5 << 8);  ///< XTAL_GM
        constexpr uint32_t XTAL_BYPASS = (1U << 13);  ///< XTAL Bypass
        constexpr uint32_t XTAL_READY_COUNT_SEL = (2 << 14);  ///< XTAL Ready Count Select
        constexpr uint32_t XTAL_COMP_BIAS_LO = (5 << 16);  ///< XTAL_COMP_BIAS (Low)
        constexpr uint32_t XTAL_ALC_START_512U = (1U << 22);  ///< XTAL_ALC_START_512U
        constexpr uint32_t XTAL_ALC_ON = (1U << 23);  ///< XTAL_ALC_ON
        constexpr uint32_t XTAL_COMP_BIAS_HI = (5 << 24);  ///< XTAL_COMP_BIAS (High)
        constexpr uint32_t XTAL_READY = (1U << 31);  ///< XTAL Ready Indicator
    }

    /// XTAL_CTRL2 Register bits
    namespace xtal_ctrl2_bits {
        constexpr uint32_t XTAL_REG_SUPPLY = (4 << 0);  ///< XTAL_REG_SUPPLY
        constexpr uint32_t XTAL_REG_BYPASS_ON = (1U << 4);  ///< XTAL_REG_BYPASS_ON
        constexpr uint32_t XTAL_REG_ON_OVRD_ON = (1U << 8);  ///< XTAL_REG_ON_OVRD_ON
        constexpr uint32_t XTAL_REG_ON_OVRD = (1U << 9);  ///< XTAL_REG_ON_OVRD
        constexpr uint32_t XTAL_ON_OVRD_ON = (1U << 10);  ///< XTAL_ON_OVRD_ON
        constexpr uint32_t XTAL_ON_OVRD = (1U << 11);  ///< XTAL_ON_OVRD
        constexpr uint32_t XTAL_DIG_CLK_OUT_ON = (1U << 12);  ///< XTAL_DIG_CLK_OUT_ON
        constexpr uint32_t XTAL_REG_ATST_SEL = (2 << 16);  ///< XTAL_REG_ATST_SEL
        constexpr uint32_t XTAL_ATST_SEL = (2 << 24);  ///< XTAL_ATST_SEL
        constexpr uint32_t XTAL_ATST_ON = (1U << 26);  ///< XTAL_ATST_ON
        constexpr uint32_t XTAL_SPARE = (4 << 28);  ///< XTAL_SPARE
    }

    /// BGAP_CTRL Register bits
    namespace bgap_ctrl_bits {
        constexpr uint32_t BGAP_CURRENT_TRIM = (4 << 0);  ///< BGAP_CURRENT_TRIM
        constexpr uint32_t BGAP_VOLTAGE_TRIM = (4 << 4);  ///< BGAP_VOLTAGE_TRIM
        constexpr uint32_t BGAP_ATST_SEL = (4 << 8);  ///< BGAP_ATST_SEL
        constexpr uint32_t BGAP_ATST_ON = (1U << 12);  ///< BGAP_ATST_ON
    }

    /// PLL_CTRL Register bits
    namespace pll_ctrl_bits {
        constexpr uint32_t PLL_VCO_BIAS = (3 << 0);  ///< PLL VCO Bias Control
        constexpr uint32_t PLL_LFILT_CNTL = (3 << 4);  ///< PLL Loop Filter Control
        constexpr uint32_t PLL_REG_SUPPLY = (4 << 8);  ///< PLL_REG_SUPPLY
        constexpr uint32_t PLL_REG_BYPASS_ON = (1U << 16);  ///< PLL_REG_BYPASS_ON
        constexpr uint32_t PLL_VCO_LDO_BYPASS = (1U << 17);  ///< PLL_VCO_LDO_BYPASS
        constexpr uint32_t HPM_BIAS = (7 << 24);  ///< HPM Array Bias
        constexpr uint32_t PLL_VCO_SPARE7 = (1U << 31);  ///< PLL_VCO_SPARE7
    }

    /// PLL_CTRL2 Register bits
    namespace pll_ctrl2_bits {
        constexpr uint32_t PLL_VCO_KV = (3 << 0);  ///< PLL_VCO_KV
        constexpr uint32_t PLL_KMOD_SLOPE = (1U << 3);  ///< PLL_KMOD_SLOPE
        constexpr uint32_t PLL_VCO_REG_SUPPLY = (2 << 4);  ///< PLL_VCO_REG_SUPPLY
        constexpr uint32_t PLL_TMUX_ON = (1U << 8);  ///< PLL_TMUX_ON
    }

    /// PLL_TEST_CTRL Register bits
    namespace pll_test_ctrl_bits {
        constexpr uint32_t PLL_TMUX_SEL = (2 << 0);  ///< PLL_TMUX_SEL
        constexpr uint32_t PLL_VCO_REG_ATST = (2 << 4);  ///< PLL_VCO_REG_ATST
        constexpr uint32_t PLL_REG_ATST_SEL = (2 << 8);  ///< PLL_REG_ATST_SEL
        constexpr uint32_t PLL_VCO_TEST_CLK_MODE = (1U << 12);  ///< PLL_VCO_TEST_CLK_MODE
        constexpr uint32_t PLL_FORCE_VTUNE_EXTERNALLY = (1U << 13);  ///< PLL_FORCE_VTUNE_EXTERNALLY
        constexpr uint32_t PLL_RIPPLE_COUNTER_TEST_MODE = (1U << 14);  ///< PLL_RIPPLE_COUNTER_TEST_MODE
    }

    /// QGEN_CTRL Register bits
    namespace qgen_ctrl_bits {
        constexpr uint32_t QGEN_REG_SUPPLY = (4 << 0);  ///< QGEN_REG_SUPPLY
        constexpr uint32_t QGEN_REG_ATST_SEL = (4 << 4);  ///< QGEN_REG_ATST_SEL
        constexpr uint32_t QGEN_REG_BYPASS_ON = (1U << 8);  ///< QGEN_REG_BYPASS_ON
    }

    /// TCA_CTRL Register bits
    namespace tca_ctrl_bits {
        constexpr uint32_t TCA_BIAS_CURR = (2 << 0);  ///< TCA_BIAS_CURR
        constexpr uint32_t TCA_LOW_PWR_ON = (1U << 2);  ///< TCA_LOW_PWR_ON
        constexpr uint32_t TCA_TX_REG_BYPASS_ON = (1U << 3);  ///< TCA_TX_REG_BYPASS_ON
        constexpr uint32_t TCA_TX_REG_SUPPLY = (4 << 4);  ///< TCA_TX_REG_SUPPLY
        constexpr uint32_t TCA_TX_REG_ATST_SEL = (2 << 8);  ///< TCA_TX_REG_ATST_SEL
    }

    /// TZA_CTRL Register bits
    namespace tza_ctrl_bits {
        constexpr uint32_t TZA_CAP_TUNE = (4 << 0);  ///< TZA_CAP_TUNE
        constexpr uint32_t TZA_GAIN = (1U << 4);  ///< TZA_GAIN
        constexpr uint32_t TZA_DCOC_ON = (1U << 5);  ///< TZA_DCOC_ON
        constexpr uint32_t TZA_CUR_CNTL = (2 << 6);  ///< TZA_CUR_CNTL
        constexpr uint32_t TZA_SPARE = (4 << 20);  ///< TZA_SPARE
    }

    /// TX_ANA_CTRL Register bits
    namespace tx_ana_ctrl_bits {
        constexpr uint32_t HPM_CAL_ADJUST = (4 << 0);  ///< HPM Cal Count Adjust
    }

    /// ANA_SPARE Register bits
    namespace ana_spare_bits {
        constexpr uint32_t IQMC_DC_GAIN_ADJ = (11 << 0);  ///< IQ Mismatch Correction DC Gain Coeff
        constexpr uint32_t DCOC_TRK_EST_GS_CNT = (3 << 11);  ///< DCOC Tracking Estimator Gearshift Count
        constexpr uint32_t HPM_LSB_INVERT = (2 << 14);  ///< High port LSB array inversion control
        constexpr uint32_t ANA_DTEST = (6 << 16);  ///< ANA_DTEST
    }

}

// ============================================================================
// ZLL Peripheral
// ============================================================================

namespace zll {
    /// Base addresses
    constexpr uint32_t ZLL_BASE = 0x4005D000;

    /// ZLL Register structure
    struct Registers {
        volatile uint32_t IRQSTS;  ///< Offset: 0x00 - INTERRUPT REQUEST STATUS
        volatile uint32_t PHY_CTRL;  ///< Offset: 0x04 - PHY CONTROL
        volatile uint32_t EVENT_TMR;  ///< Offset: 0x08 - EVENT TIMER
        volatile uint32_t TIMESTAMP;  ///< Offset: 0x0C - TIMESTAMP
        volatile uint32_t T1CMP;  ///< Offset: 0x10 - T1 COMPARE
        volatile uint32_t T2CMP;  ///< Offset: 0x14 - T2 COMPARE
        volatile uint32_t T2PRIMECMP;  ///< Offset: 0x18 - T2 PRIME COMPARE
        volatile uint32_t T3CMP;  ///< Offset: 0x1C - T3 COMPARE
        volatile uint32_t T4CMP;  ///< Offset: 0x20 - T4 COMPARE
        volatile uint32_t PA_PWR;  ///< Offset: 0x24 - PA POWER
        volatile uint32_t CHANNEL_NUM0;  ///< Offset: 0x28 - CHANNEL NUMBER 0
        volatile uint32_t LQI_AND_RSSI;  ///< Offset: 0x2C - LQI AND RSSI
        volatile uint32_t MACSHORTADDRS0;  ///< Offset: 0x30 - MAC SHORT ADDRESS 0
        volatile uint32_t MACLONGADDRS0_LSB;  ///< Offset: 0x34 - MAC LONG ADDRESS 0 LSB
        volatile uint32_t MACLONGADDRS0_MSB;  ///< Offset: 0x38 - MAC LONG ADDRESS 0 MSB
        volatile uint32_t RX_FRAME_FILTER;  ///< Offset: 0x3C - RECEIVE FRAME FILTER
        volatile uint32_t CCA_LQI_CTRL;  ///< Offset: 0x40 - CCA AND LQI CONTROL
        volatile uint32_t CCA2_CTRL;  ///< Offset: 0x44 - CCA2 CONTROL
        volatile uint32_t FAD_CTRL;  ///< Offset: 0x48 - FAD CONTROL
        volatile uint32_t SNF_CTRL;  ///< Offset: 0x4C - SNF CONTROL
        volatile uint32_t BSM_CTRL;  ///< Offset: 0x50 - BSM CONTROL
        volatile uint32_t MACSHORTADDRS1;  ///< Offset: 0x54 - MAC SHORT ADDRESS 1
        volatile uint32_t MACLONGADDRS1_LSB;  ///< Offset: 0x58 - MAC LONG ADDRESS 1 LSB
        volatile uint32_t MACLONGADDRS1_MSB;  ///< Offset: 0x5C - MAC LONG ADDRESS 1 MSB
        volatile uint32_t DUAL_PAN_CTRL;  ///< Offset: 0x60 - DUAL PAN CONTROL
        volatile uint32_t CHANNEL_NUM1;  ///< Offset: 0x64 - CHANNEL NUMBER 1
        volatile uint32_t SAM_CTRL;  ///< Offset: 0x68 - SAM CONTROL
        volatile uint32_t SAM_TABLE;  ///< Offset: 0x6C - SOURCE ADDRESS MANAGEMENT TABLE
        volatile uint32_t SAM_MATCH;  ///< Offset: 0x70 - SAM MATCH
        volatile uint32_t SAM_FREE_IDX;  ///< Offset: 0x74 - SAM FREE INDEX
        volatile uint32_t SEQ_CTRL_STS;  ///< Offset: 0x78 - SEQUENCE CONTROL AND STATUS
        volatile uint32_t ACKDELAY;  ///< Offset: 0x7C - ACK DELAY
        volatile uint32_t FILTERFAIL_CODE;  ///< Offset: 0x80 - FILTER FAIL CODE
        volatile uint32_t RX_WTR_MARK;  ///< Offset: 0x84 - RECEIVE WATER MARK
        volatile uint32_t SLOT_PRELOAD;  ///< Offset: 0x8C - SLOT PRELOAD
        volatile uint32_t SEQ_STATE;  ///< Offset: 0x90 - ZIGBEE SEQUENCE STATE
        volatile uint32_t TMR_PRESCALE;  ///< Offset: 0x94 - TIMER PRESCALER
        volatile uint32_t LENIENCY_LSB;  ///< Offset: 0x98 - LENIENCY LSB
        volatile uint32_t LENIENCY_MSB;  ///< Offset: 0x9C - LENIENCY MSB
        volatile uint32_t PART_ID;  ///< Offset: 0xA0 - PART ID
        volatile uint32_t PKT_BUFFER%s;  ///< Offset: 0x100 - PACKET BUFFER
    };

    /// Peripheral instances
    inline Registers* ZLL = reinterpret_cast<Registers*>(ZLL_BASE);

    // Bit definitions
    /// IRQSTS Register bits
    namespace irqsts_bits {
        constexpr uint32_t SEQIRQ = (1U << 0);  ///< Sequence-end Interrupt Status bit. A '1' indicates the completion of an autosequence. This interrupt will assert whenever the Sequence Manager transitions from non-idle to idle state, for any reason. This is write a '1' to clear bit.
        constexpr uint32_t TXIRQ = (1U << 1);  ///< Transmitter Interrupt Status bit. A '1' indicates the completion of a transmit operation. This is write a '1' to clear bit.
        constexpr uint32_t RXIRQ = (1U << 2);  ///< Receiver Interrupt Status bit. A '1' indicates the completion of a receive operation. This is write a '1' to clear bit.
        constexpr uint32_t CCAIRQ = (1U << 3);  ///< Clear Channel Assessment Interrupt Status bit. A '1' indicates completion of CCA operation. This is write '1' to clear bit.
        constexpr uint32_t RXWTRMRKIRQ = (1U << 4);  ///< Receiver Byte Count Water Mark Interrupt Status bit. A '1' indicates that the number of bytes specified in the RX_WTR_MARK register has been reached. This is write a '1' to clear bit.
        constexpr uint32_t FILTERFAIL_IRQ = (1U << 5);  ///< Receiver Packet Filter Fail Interrupt Status bit. A '1' indicates that the most-recently received packet has been rejected due to elements within the packet. This is write a '1' to clear bit. In Dual PAN mode, FILTERFAIL_IRQ applies to either or both networks, as follows: A: If PAN0 and PAN1 occupy different channels and CURRENT_NETWORK=0, FILTERFAIL_IRQ applies to PAN0. B: If PAN0 and PAN1 occupy different channels and CURRENT_NETWORK=1, FILTERFAIL_IRQ applies to PAN1. C: If PAN0 and PAN1 occupy the same channel, FILTERFAIL_IRQ is the logical 'AND' of the individual PANs' Filter Fail status.
        constexpr uint32_t PLL_UNLOCK_IRQ = (1U << 6);  ///< PLL Un-lock Interrupt Status bit. A '1' indicates an unlock event has occurred in the PLL. This is write a '1' to clear bit.
        constexpr uint32_t RX_FRM_PEND = (1U << 7);  ///< Status of the frame pending bit of the frame control field for the most-recently received packet. Read-only.
        constexpr uint32_t PB_ERR_IRQ = (1U << 9);  ///< Packet Buffer Underrun Error IRQ
        constexpr uint32_t TMRSTATUS = (1U << 11);  ///< Composite TMR Status
        constexpr uint32_t PI = (1U << 12);  ///< Poll Indication
        constexpr uint32_t SRCADDR = (1U << 13);  ///< Source Address Match Status
        constexpr uint32_t CCA = (1U << 14);  ///< CCA Status
        constexpr uint32_t CRCVALID = (1U << 15);  ///< CRC Valid Status
        constexpr uint32_t TMR1IRQ = (1U << 16);  ///< Timer 1 IRQ
        constexpr uint32_t TMR2IRQ = (1U << 17);  ///< Timer 2 IRQ
        constexpr uint32_t TMR3IRQ = (1U << 18);  ///< Timer 3 IRQ
        constexpr uint32_t TMR4IRQ = (1U << 19);  ///< Timer 4 IRQ
        constexpr uint32_t TMR1MSK = (1U << 20);  ///< Timer Comperator 1 Interrupt Mask bit
        constexpr uint32_t TMR2MSK = (1U << 21);  ///< Timer Comperator 2 Interrupt Mask bit
        constexpr uint32_t TMR3MSK = (1U << 22);  ///< Timer Comperator 3 Interrupt Mask bit
        constexpr uint32_t TMR4MSK = (1U << 23);  ///< Timer Comperator 4 Interrupt Mask bit
        constexpr uint32_t RX_FRAME_LENGTH = (7 << 24);  ///< Receive Frame Length
    }

    /// PHY_CTRL Register bits
    namespace phy_ctrl_bits {
        constexpr uint32_t XCVSEQ = (3 << 0);  ///< Zigbee Transceiver Sequence Selector
        constexpr uint32_t AUTOACK = (1U << 3);  ///< Auto Acknowledge Enable
        constexpr uint32_t RXACKRQD = (1U << 4);  ///< Receive Acknowledge Frame required
        constexpr uint32_t CCABFRTX = (1U << 5);  ///< CCA Before TX
        constexpr uint32_t SLOTTED = (1U << 6);  ///< Slotted Mode
        constexpr uint32_t TMRTRIGEN = (1U << 7);  ///< Timer2 Trigger Enable
        constexpr uint32_t SEQMSK = (1U << 8);  ///< Sequencer Interrupt Mask
        constexpr uint32_t TXMSK = (1U << 9);  ///< TX Interrupt Mask
        constexpr uint32_t RXMSK = (1U << 10);  ///< RX Interrupt Mask
        constexpr uint32_t CCAMSK = (1U << 11);  ///< CCA Interrupt Mask
        constexpr uint32_t RX_WMRK_MSK = (1U << 12);  ///< RX Watermark Interrupt Mask
        constexpr uint32_t FILTERFAIL_MSK = (1U << 13);  ///< FilterFail Interrupt Mask
        constexpr uint32_t PLL_UNLOCK_MSK = (1U << 14);  ///< PLL Unlock Interrupt Mask
        constexpr uint32_t CRC_MSK = (1U << 15);  ///< CRC Mask
        constexpr uint32_t PB_ERR_MSK = (1U << 17);  ///< Packet Buffer Error Interrupt Mask
        constexpr uint32_t TMR1CMP_EN = (1U << 20);  ///< Timer 1 Compare Enable
        constexpr uint32_t TMR2CMP_EN = (1U << 21);  ///< Timer 2 Compare Enable
        constexpr uint32_t TMR3CMP_EN = (1U << 22);  ///< Timer 3 Compare Enable
        constexpr uint32_t TMR4CMP_EN = (1U << 23);  ///< Timer 4 Compare Enable
        constexpr uint32_t TC2PRIME_EN = (1U << 24);  ///< Timer 2 Prime Compare Enable
        constexpr uint32_t PROMISCUOUS = (1U << 25);  ///< Promiscuous Mode Enable
        constexpr uint32_t TMRLOAD = (1U << 26);  ///< Event Timer Load Enable
        constexpr uint32_t CCATYPE = (2 << 27);  ///< Clear Channel Assessment Type
        constexpr uint32_t PANCORDNTR0 = (1U << 29);  ///< Device is a PAN Coordinator on PAN0
        constexpr uint32_t TC3TMOUT = (1U << 30);  ///< TMR3 Timeout Enable
        constexpr uint32_t TRCV_MSK = (1U << 31);  ///< Transceiver Global Interrupt Mask
    }

    /// EVENT_TMR Register bits
    namespace event_tmr_bits {
        constexpr uint32_t EVENT_TMR = (24 << 0);  ///< Event Timer
    }

    /// TIMESTAMP Register bits
    namespace timestamp_bits {
        constexpr uint32_t TIMESTAMP = (24 << 0);  ///< Timestamp
    }

    /// T1CMP Register bits
    namespace t1cmp_bits {
        constexpr uint32_t T1CMP = (24 << 0);  ///< TMR1 Compare Value
    }

    /// T2CMP Register bits
    namespace t2cmp_bits {
        constexpr uint32_t T2CMP = (24 << 0);  ///< TMR2 Compare Value
    }

    /// T2PRIMECMP Register bits
    namespace t2primecmp_bits {
        constexpr uint32_t T2PRIMECMP = (16 << 0);  ///< TMR2 Prime Compare Value
    }

    /// T3CMP Register bits
    namespace t3cmp_bits {
        constexpr uint32_t T3CMP = (24 << 0);  ///< TMR3 Compare Value
    }

    /// T4CMP Register bits
    namespace t4cmp_bits {
        constexpr uint32_t T4CMP = (24 << 0);  ///< TMR4 Compare Value
    }

    /// PA_PWR Register bits
    namespace pa_pwr_bits {
        constexpr uint32_t PA_PWR = (4 << 0);  ///< PA Power
    }

    /// CHANNEL_NUM0 Register bits
    namespace channel_num0_bits {
        constexpr uint32_t CHANNEL_NUM0 = (7 << 0);  ///< Channel Number for PAN0
    }

    /// LQI_AND_RSSI Register bits
    namespace lqi_and_rssi_bits {
        constexpr uint32_t LQI_VALUE = (8 << 0);  ///< LQI Value
        constexpr uint32_t RSSI = (8 << 8);  ///< RSSI Value
        constexpr uint32_t CCA1_ED_FNL = (8 << 16);  ///< RSSI Value
    }

    /// MACSHORTADDRS0 Register bits
    namespace macshortaddrs0_bits {
        constexpr uint32_t MACPANID0 = (16 << 0);  ///< MAC PAN ID for PAN0
        constexpr uint32_t MACSHORTADDRS0 = (16 << 16);  ///< MAC SHORT ADDRESS for PAN0
    }

    /// MACLONGADDRS0_LSB Register bits
    namespace maclongaddrs0_lsb_bits {
        constexpr uint32_t MACLONGADDRS0_LSB = (32 << 0);  ///< MAC LONG ADDRESS for PAN0 LSB
    }

    /// MACLONGADDRS0_MSB Register bits
    namespace maclongaddrs0_msb_bits {
        constexpr uint32_t MACLONGADDRS0_MSB = (32 << 0);  ///< MAC LONG ADDRESS for PAN0 MSB
    }

    /// RX_FRAME_FILTER Register bits
    namespace rx_frame_filter_bits {
        constexpr uint32_t BEACON_FT = (1U << 0);  ///< Beacon Frame Type Enable
        constexpr uint32_t DATA_FT = (1U << 1);  ///< Data Frame Type Enable
        constexpr uint32_t ACK_FT = (1U << 2);  ///< Ack Frame Type Enable
        constexpr uint32_t CMD_FT = (1U << 3);  ///< MAC Command Frame Type Enable
        constexpr uint32_t NS_FT = (1U << 4);  ///< Not Specified Frame Type Enable
        constexpr uint32_t ACTIVE_PROMISCUOUS = (1U << 5);  ///< Active Promiscuous
        constexpr uint32_t FRM_VER = (2 << 6);  ///< Frame Version Selector
    }

    /// CCA_LQI_CTRL Register bits
    namespace cca_lqi_ctrl_bits {
        constexpr uint32_t CCA1_THRESH = (8 << 0);  ///< CCA Mode 1 Threshold
        constexpr uint32_t LQI_OFFSET_COMP = (8 << 16);  ///< LQI Offset Compensation
        constexpr uint32_t CCA3_AND_NOT_OR = (1U << 27);  ///< CCA Mode 3 AND not OR
    }

    /// CCA2_CTRL Register bits
    namespace cca2_ctrl_bits {
        constexpr uint32_t CCA2_NUM_CORR_PEAKS = (4 << 0);  ///< CCA Mode 2 Number of Correlation Peaks Detected
        constexpr uint32_t CCA2_MIN_NUM_CORR_TH = (3 << 4);  ///< CCA Mode 2 Threshold Number of Correlation Peaks
        constexpr uint32_t CCA2_CORR_THRESH = (8 << 8);  ///< CCA Mode 2 Correlation Threshold
    }

    /// FAD_CTRL Register bits
    namespace fad_ctrl_bits {
        constexpr uint32_t FAD_EN = (1U << 0);  ///< FAD Enable
        constexpr uint32_t ANTX = (1U << 1);  ///< Antenna Selection
        constexpr uint32_t FAD_NOT_GPIO = (1U << 2);  ///< FAD/GPIO Selector
        constexpr uint32_t ANTX_EN = (2 << 8);  ///< FAD Antenna Controls Enable
        constexpr uint32_t ANTX_HZ = (1U << 10);  ///< FAD PAD Tristate Control
        constexpr uint32_t ANTX_CTRLMODE = (1U << 11);  ///< Antenna Diversity Control Mode
        constexpr uint32_t ANTX_POL = (4 << 12);  ///< Antenna Diversity PAD Polarity
    }

    /// SNF_CTRL Register bits
    namespace snf_ctrl_bits {
        constexpr uint32_t SNF_EN = (1U << 0);  ///< SNF Enable
    }

    /// BSM_CTRL Register bits
    namespace bsm_ctrl_bits {
        constexpr uint32_t BSM_EN = (1U << 0);  ///< BSM Enable
    }

    /// MACSHORTADDRS1 Register bits
    namespace macshortaddrs1_bits {
        constexpr uint32_t MACPANID1 = (16 << 0);  ///< MAC PAN ID for PAN1
        constexpr uint32_t MACSHORTADDRS1 = (16 << 16);  ///< MAC SHORT ADDRESS for PAN1
    }

    /// MACLONGADDRS1_LSB Register bits
    namespace maclongaddrs1_lsb_bits {
        constexpr uint32_t MACLONGADDRS1_LSB = (32 << 0);  ///< MAC LONG ADDRESS for PAN1 LSB
    }

    /// MACLONGADDRS1_MSB Register bits
    namespace maclongaddrs1_msb_bits {
        constexpr uint32_t MACLONGADDRS1_MSB = (32 << 0);  ///< MAC LONG ADDRESS for PAN1 MSB
    }

    /// DUAL_PAN_CTRL Register bits
    namespace dual_pan_ctrl_bits {
        constexpr uint32_t ACTIVE_NETWORK = (1U << 0);  ///< Active Network Selector
        constexpr uint32_t DUAL_PAN_AUTO = (1U << 1);  ///< Activates automatic Dual PAN operating mode
        constexpr uint32_t PANCORDNTR1 = (1U << 2);  ///< Device is a PAN Coordinator on PAN1
        constexpr uint32_t CURRENT_NETWORK = (1U << 3);  ///< Indicates which PAN is currently selected by hardware
        constexpr uint32_t ZB_DP_CHAN_OVRD_EN = (1U << 4);  ///< Dual PAN Channel Override Enable
        constexpr uint32_t ZB_DP_CHAN_OVRD_SEL = (1U << 5);  ///< Dual PAN Channel Override Selector
        constexpr uint32_t DUAL_PAN_DWELL = (8 << 8);  ///< Dual PAN Channel Frequency Dwell Time
        constexpr uint32_t DUAL_PAN_REMAIN = (6 << 16);  ///< Time Remaining before next PAN switch in auto Dual PAN mode
        constexpr uint32_t RECD_ON_PAN0 = (1U << 22);  ///< Last Packet was Received on PAN0
        constexpr uint32_t RECD_ON_PAN1 = (1U << 23);  ///< Last Packet was Received on PAN1
    }

    /// CHANNEL_NUM1 Register bits
    namespace channel_num1_bits {
        constexpr uint32_t CHANNEL_NUM1 = (7 << 0);  ///< Channel Number for PAN1
    }

    /// SAM_CTRL Register bits
    namespace sam_ctrl_bits {
        constexpr uint32_t SAP0_EN = (1U << 0);  ///< Enables SAP0 Partition of the SAM Table
        constexpr uint32_t SAA0_EN = (1U << 1);  ///< Enables SAA0 Partition of the SAM Table
        constexpr uint32_t SAP1_EN = (1U << 2);  ///< Enables SAP1 Partition of the SAM Table
        constexpr uint32_t SAA1_EN = (1U << 3);  ///< Enables SAA1 Partition of the SAM Table
        constexpr uint32_t SAA0_START = (8 << 8);  ///< First Index of SAA0 partition
        constexpr uint32_t SAP1_START = (8 << 16);  ///< First Index of SAP1 partition
        constexpr uint32_t SAA1_START = (8 << 24);  ///< First Index of SAA1 partition
    }

    /// SAM_TABLE Register bits
    namespace sam_table_bits {
        constexpr uint32_t SAM_INDEX = (7 << 0);  ///< Contains the SAM table index to be enabled or invalidated
        constexpr uint32_t SAM_INDEX_WR = (1U << 7);  ///< Enables SAM Table Contents to be updated
        constexpr uint32_t SAM_CHECKSUM = (16 << 8);  ///< Software-computed source address checksum, to be installed into a table index
        constexpr uint32_t SAM_INDEX_INV = (1U << 24);  ///< Invalidate the SAM table index selected by SAM_INDEX
        constexpr uint32_t SAM_INDEX_EN = (1U << 25);  ///< Enable the SAM table index selected by SAM_INDEX
        constexpr uint32_t ACK_FRM_PND = (1U << 26);  ///< Software-override value for the state of the AutoTxAck FramePending field
        constexpr uint32_t ACK_FRM_PND_CTRL = (1U << 27);  ///< Software-override control for the state of the AutoTxAck FramePending field
        constexpr uint32_t FIND_FREE_IDX = (1U << 28);  ///< Find First Free Index
        constexpr uint32_t INVALIDATE_ALL = (1U << 29);  ///< Invalidated Entire SAM Table
        constexpr uint32_t SAM_BUSY = (1U << 31);  ///< SAM Table Update Status Bit
    }

    /// SAM_MATCH Register bits
    namespace sam_match_bits {
        constexpr uint32_t SAP0_MATCH = (7 << 0);  ///< Index in the SAP0 Partition of the SAM Table corresponding to the first checksum match
        constexpr uint32_t SAP0_ADDR_PRESENT = (1U << 7);  ///< A Checksum Match is Present in the SAP0 Partition of the SAM Table
        constexpr uint32_t SAA0_MATCH = (7 << 8);  ///< Index in the SAA0 Partition of the SAM Table corresponding to the first checksum match
        constexpr uint32_t SAA0_ADDR_ABSENT = (1U << 15);  ///< A Checksum Match is Absent in the SAA0 Partition of the SAM Table
        constexpr uint32_t SAP1_MATCH = (7 << 16);  ///< Index in the SAP1 Partition of the SAM Table corresponding to the first checksum match
        constexpr uint32_t SAP1_ADDR_PRESENT = (1U << 23);  ///< A Checksum Match is Present in the SAP1 Partition of the SAM Table
        constexpr uint32_t SAA1_MATCH = (7 << 24);  ///< Index in the SAA1 Partition of the SAM Table corresponding to the first checksum match
        constexpr uint32_t SAA1_ADDR_ABSENT = (1U << 31);  ///< A Checksum Match is Absent in the SAP1 Partition of the SAM Table
    }

    /// SAM_FREE_IDX Register bits
    namespace sam_free_idx_bits {
        constexpr uint32_t SAP0_1ST_FREE_IDX = (8 << 0);  ///< First non-enabled (invalid) index in the SAP0 partition
        constexpr uint32_t SAA0_1ST_FREE_IDX = (8 << 8);  ///< First non-enabled (invalid) index in the SAA0 partition
        constexpr uint32_t SAP1_1ST_FREE_IDX = (8 << 16);  ///< First non-enabled (invalid) index in the SAP1 partition
        constexpr uint32_t SAA1_1ST_FREE_IDX = (8 << 24);  ///< First non-enabled (invalid) index in the SAA1 partition
    }

    /// SEQ_CTRL_STS Register bits
    namespace seq_ctrl_sts_bits {
        constexpr uint32_t CLR_NEW_SEQ_INHIBIT = (1U << 2);  ///< Overrides the automatic hardware locking of the programmed XCVSEQ while an autosequence is underway
        constexpr uint32_t EVENT_TMR_DO_NOT_LATCH = (1U << 3);  ///< Overrides the automatic hardware latching of the Event Timer
        constexpr uint32_t LATCH_PREAMBLE = (1U << 4);  ///< Stickiness Control for Preamble Detection
        constexpr uint32_t NO_RX_RECYCLE = (1U << 5);  ///< Disable Automatic RX Sequence Recycling
        constexpr uint32_t FORCE_CRC_ERROR = (1U << 6);  ///< Induce a CRC Error in Transmitted Packets
        constexpr uint32_t CONTINUOUS_EN = (1U << 7);  ///< Enable Continuous TX or RX Mode
        constexpr uint32_t XCVSEQ_ACTUAL = (3 << 8);  ///< Reflects the programmed sequence that has been recognized by the ZSM Sequence Manager
        constexpr uint32_t SEQ_IDLE = (1U << 11);  ///< ZSM Sequence Idle Indicator
        constexpr uint32_t NEW_SEQ_INHIBIT = (1U << 12);  ///< New Sequence Inhibit
        constexpr uint32_t RX_TIMEOUT_PENDING = (1U << 13);  ///< Indicates a TMR3 RX Timeout is Pending
        constexpr uint32_t RX_MODE = (1U << 14);  ///< RX Operation in Progress
        constexpr uint32_t TMR2_SEQ_TRIG_ARMED = (1U << 15);  ///< indicates that TMR2 has been programmed and is armed to trigger a new autosequence
        constexpr uint32_t SEQ_T_STATUS = (6 << 16);  ///< Status of the just-completed or ongoing Sequence T or Sequence TR
        constexpr uint32_t SW_ABORTED = (1U << 24);  ///< Autosequence has terminated due to a Software abort.
        constexpr uint32_t TC3_ABORTED = (1U << 25);  ///< Autosequence has terminated due to an TMR3 timeout
        constexpr uint32_t PLL_ABORTED = (1U << 26);  ///< Autosequence has terminated due to an PLL unlock event
    }

    /// ACKDELAY Register bits
    namespace ackdelay_bits {
        constexpr uint32_t ACKDELAY = (6 << 0);  ///< Provides a fine-tune adjustment of the time delay between Rx warmdown and the beginning of Tx warmup for an autoTxAck packet
        constexpr uint32_t TXDELAY = (6 << 8);  ///< Provides a fine-tune adjustment of the time delay between post-CCA Rx warm-down and the beginning of Tx warm-up
    }

    /// FILTERFAIL_CODE Register bits
    namespace filterfail_code_bits {
        constexpr uint32_t FILTERFAIL_CODE = (10 << 0);  ///< Filter Fail Code
        constexpr uint32_t FILTERFAIL_PAN_SEL = (1U << 15);  ///< PAN Selector for Filter Fail Code
    }

    /// RX_WTR_MARK Register bits
    namespace rx_wtr_mark_bits {
        constexpr uint32_t RX_WTR_MARK = (8 << 0);  ///< Receive byte count needed to trigger a RXWTRMRKIRQ interrupt
    }

    /// SLOT_PRELOAD Register bits
    namespace slot_preload_bits {
        constexpr uint32_t SLOT_PRELOAD = (8 << 0);  ///< Slotted Mode Preload
    }

    /// SEQ_STATE Register bits
    namespace seq_state_bits {
        constexpr uint32_t SEQ_STATE = (5 << 0);  ///< ZSM Sequence State
        constexpr uint32_t PREAMBLE_DET = (1U << 8);  ///< Preamble Detected
        constexpr uint32_t SFD_DET = (1U << 9);  ///< SFD Detected
        constexpr uint32_t FILTERFAIL_FLAG_SEL = (1U << 10);  ///< Consolidated Filter Fail Flag
        constexpr uint32_t CRCVALID = (1U << 11);  ///< CRC Valid Indicator
        constexpr uint32_t PLL_ABORT = (1U << 12);  ///< Raw PLL Abort Signal
        constexpr uint32_t PLL_ABORTED = (1U << 13);  ///< Autosequence has terminated due to an PLL unlock event
        constexpr uint32_t RX_BYTE_COUNT = (8 << 16);  ///< Realtime Received Byte Count
        constexpr uint32_t CCCA_BUSY_CNT = (6 << 24);  ///< Number of CCA Measurements resulting in Busy Channel
    }

    /// TMR_PRESCALE Register bits
    namespace tmr_prescale_bits {
        constexpr uint32_t TMR_PRESCALE = (3 << 0);  ///< Timer Prescaler
    }

    /// LENIENCY_LSB Register bits
    namespace leniency_lsb_bits {
        constexpr uint32_t LENIENCY_REGISTER = (32 << 0);  ///< Leniency Register, bits [31:0]
    }

    /// LENIENCY_MSB Register bits
    namespace leniency_msb_bits {
        constexpr uint32_t LENIENCY_REGISTER = (8 << 0);  ///< Leniency Register, bits [39:32]
    }

    /// PART_ID Register bits
    namespace part_id_bits {
        constexpr uint32_t PART_ID = (8 << 0);  ///< Zigbee Part ID
    }

    /// PKT_BUFFER%s Register bits
    namespace pkt_buffer%s_bits {
        constexpr uint32_t PKT_BUFFER = (32 << 0);  ///< Packet Buffer Entry
    }

}

// ============================================================================
// CMT Peripheral
// ============================================================================

namespace cmt {
    /// Base addresses
    constexpr uint32_t CMT_BASE = 0x40062000;

    /// CMT Register structure
    struct Registers {
        volatile uint32_t CGH1;  ///< Offset: 0x00 - CMT Carrier Generator High Data Register 1
        volatile uint32_t CGL1;  ///< Offset: 0x01 - CMT Carrier Generator Low Data Register 1
        volatile uint32_t CGH2;  ///< Offset: 0x02 - CMT Carrier Generator High Data Register 2
        volatile uint32_t CGL2;  ///< Offset: 0x03 - CMT Carrier Generator Low Data Register 2
        volatile uint32_t OC;  ///< Offset: 0x04 - CMT Output Control Register
        volatile uint32_t MSC;  ///< Offset: 0x05 - CMT Modulator Status and Control Register
        volatile uint32_t CMD1;  ///< Offset: 0x06 - CMT Modulator Data Register Mark High
        volatile uint32_t CMD2;  ///< Offset: 0x07 - CMT Modulator Data Register Mark Low
        volatile uint32_t CMD3;  ///< Offset: 0x08 - CMT Modulator Data Register Space High
        volatile uint32_t CMD4;  ///< Offset: 0x09 - CMT Modulator Data Register Space Low
        volatile uint32_t PPS;  ///< Offset: 0x0A - CMT Primary Prescaler Register
        volatile uint32_t DMA;  ///< Offset: 0x0B - CMT Direct Memory Access Register
    };

    /// Peripheral instances
    inline Registers* CMT = reinterpret_cast<Registers*>(CMT_BASE);

    // Bit definitions
    /// CGH1 Register bits
    namespace cgh1_bits {
        constexpr uint32_t PH = (8 << 0);  ///< Primary Carrier High Time Data Value
    }

    /// CGL1 Register bits
    namespace cgl1_bits {
        constexpr uint32_t PL = (8 << 0);  ///< Primary Carrier Low Time Data Value
    }

    /// CGH2 Register bits
    namespace cgh2_bits {
        constexpr uint32_t SH = (8 << 0);  ///< Secondary Carrier High Time Data Value
    }

    /// CGL2 Register bits
    namespace cgl2_bits {
        constexpr uint32_t SL = (8 << 0);  ///< Secondary Carrier Low Time Data Value
    }

    /// OC Register bits
    namespace oc_bits {
        constexpr uint32_t IROPEN = (1U << 5);  ///< IRO Pin Enable
        constexpr uint32_t CMTPOL = (1U << 6);  ///< CMT Output Polarity
        constexpr uint32_t IROL = (1U << 7);  ///< IRO Latch Control
    }

    /// MSC Register bits
    namespace msc_bits {
        constexpr uint32_t MCGEN = (1U << 0);  ///< Modulator and Carrier Generator Enable
        constexpr uint32_t EOCIE = (1U << 1);  ///< End of Cycle Interrupt Enable
        constexpr uint32_t FSK = (1U << 2);  ///< FSK Mode Select
        constexpr uint32_t BASE = (1U << 3);  ///< Baseband Enable
        constexpr uint32_t EXSPC = (1U << 4);  ///< Extended Space Enable
        constexpr uint32_t CMTDIV = (2 << 5);  ///< CMT Clock Divide Prescaler
        constexpr uint32_t EOCF = (1U << 7);  ///< End Of Cycle Status Flag
    }

    /// CMD1 Register bits
    namespace cmd1_bits {
        constexpr uint32_t MB = (8 << 0);  ///< MB[15:8]
    }

    /// CMD2 Register bits
    namespace cmd2_bits {
        constexpr uint32_t MB = (8 << 0);  ///< MB[7:0]
    }

    /// CMD3 Register bits
    namespace cmd3_bits {
        constexpr uint32_t SB = (8 << 0);  ///< SB[15:8]
    }

    /// CMD4 Register bits
    namespace cmd4_bits {
        constexpr uint32_t SB = (8 << 0);  ///< SB[7:0]
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPSDIV = (4 << 0);  ///< Primary Prescaler Divider
    }

    /// DMA Register bits
    namespace dma_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t MCG_BASE = 0x40064000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - MCG Control 1 Register
        volatile uint32_t C2;  ///< Offset: 0x01 - MCG Control 2 Register
        volatile uint32_t C3;  ///< Offset: 0x02 - MCG Control 3 Register
        volatile uint32_t C4;  ///< Offset: 0x03 - MCG Control 4 Register
        volatile uint32_t C5;  ///< Offset: 0x04 - MCG Control 5 Register
        volatile uint32_t C6;  ///< Offset: 0x05 - MCG Control 6 Register
        volatile uint32_t S;  ///< Offset: 0x06 - MCG Status Register
        volatile uint32_t SC;  ///< Offset: 0x08 - MCG Status and Control Register
        volatile uint32_t ATCVH;  ///< Offset: 0x0A - MCG Auto Trim Compare Value High Register
        volatile uint32_t ATCVL;  ///< Offset: 0x0B - MCG Auto Trim Compare Value Low Register
        volatile uint32_t C7;  ///< Offset: 0x0C - MCG Control 7 Register
        volatile uint32_t C8;  ///< Offset: 0x0D - MCG Control 8 Register
    };

    /// Peripheral instances
    inline Registers* MCG = reinterpret_cast<Registers*>(MCG_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t IREFS = (1U << 2);  ///< Internal Reference Select
        constexpr uint32_t FRDIV = (3 << 3);  ///< FLL External Reference Divider
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t IRCS = (1U << 0);  ///< Internal Reference Clock Select
        constexpr uint32_t LP = (1U << 1);  ///< Low Power Select
        constexpr uint32_t EREFS = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE = (2 << 4);  ///< Frequency Range Select
        constexpr uint32_t FCFTRIM = (1U << 6);  ///< Fast Internal Reference Clock Fine Trim
        constexpr uint32_t LOCRE0 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t SCTRIM = (8 << 0);  ///< Slow Internal Reference Clock Trim Setting
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t SCFTRIM = (1U << 0);  ///< Slow Internal Reference Clock Fine Trim
        constexpr uint32_t FCTRIM = (4 << 1);  ///< Fast Internal Reference Clock Trim Setting
        constexpr uint32_t DRST_DRS = (2 << 5);  ///< DCO Range Select
        constexpr uint32_t DMX32 = (1U << 7);  ///< DCO Maximum Frequency with 32.768 kHz Reference
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t CME0 = (1U << 5);  ///< Clock Monitor Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t IRCST = (1U << 0);  ///< Internal Reference Clock Status
        constexpr uint32_t OSCINIT0 = (1U << 1);  ///< OSC Initialization
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
        constexpr uint32_t IREFST = (1U << 4);  ///< Internal Reference Status
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LOCS0 = (1U << 0);  ///< OSC0 Loss of Clock Status
        constexpr uint32_t FCRDIV = (3 << 1);  ///< Fast Clock Internal Reference Divider
        constexpr uint32_t FLTPRSRV = (1U << 4);  ///< FLL Filter Preserve Enable
        constexpr uint32_t ATMF = (1U << 5);  ///< Automatic Trim Machine Fail Flag
        constexpr uint32_t ATMS = (1U << 6);  ///< Automatic Trim Machine Select
        constexpr uint32_t ATME = (1U << 7);  ///< Automatic Trim Machine Enable
    }

    /// ATCVH Register bits
    namespace atcvh_bits {
        constexpr uint32_t ATCVH = (8 << 0);  ///< ATM Compare Value High
    }

    /// ATCVL Register bits
    namespace atcvl_bits {
        constexpr uint32_t ATCVL = (8 << 0);  ///< ATM Compare Value Low
    }

    /// C7 Register bits
    namespace c7_bits {
        constexpr uint32_t OSCSEL = (1U << 0);  ///< MCG OSC Clock Select
    }

    /// C8 Register bits
    namespace c8_bits {
        constexpr uint32_t LOCS1 = (1U << 0);  ///< RTC Loss of Clock Status
        constexpr uint32_t CME1 = (1U << 5);  ///< Clock Monitor Enable1
        constexpr uint32_t LOCRE1 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40066000;
    constexpr uint32_t I2C1_BASE = 0x40067000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S;  ///< Offset: 0x03 - I2C Status register
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter Register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
        volatile uint32_t S2;  ///< Offset: 0x0C - I2C Status register 2
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< ClockRate
        constexpr uint32_t MULT = (2 << 6);  ///< Multiplier Factor
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup Enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit Acknowledge Enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit Mode Select
        constexpr uint32_t MST = (1U << 5);  ///< Master Mode Select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C Interrupt Enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive Acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt Flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave Read/Write
        constexpr uint32_t RAM = (1U << 3);  ///< Range Address Match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration Lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus Busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed As A Slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer Complete Flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave Address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range Address Matching Enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave Baud Rate Control
        constexpr uint32_t HDRS = (1U << 5);  ///< High Drive Select
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address Extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General Call Address Enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (4 << 0);  ///< I2C Programmable Filter Factor
        constexpr uint32_t STARTF = (1U << 4);  ///< I2C Bus Start Detect Flag
        constexpr uint32_t SSIE = (1U << 5);  ///< I2C Bus Stop or Start Interrupt Enable
        constexpr uint32_t STOPF = (1U << 6);  ///< I2C Bus Stop Detect Flag
        constexpr uint32_t SHEN = (1U << 7);  ///< Stop Hold Enable
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RAD = (7 << 1);  ///< Range Slave Address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 Interrupt Enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL High Timeout Flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL High Timeout Flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL Low Timeout Flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout Counter Clock Select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C Address Enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus Alert Response Address Enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK Enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus Address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[15:8]
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[7:0]
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t EMPTY = (1U << 0);  ///< Empty flag
        constexpr uint32_t ERROR = (1U << 1);  ///< Error flag
        constexpr uint32_t DFEN = (1U << 2);  ///< Double Buffer Enable
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40073000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
        constexpr uint32_t PSTM = (1U << 7);  ///< Pass Through Mode Enable
    }

}

// ============================================================================
// LLWU Peripheral
// ============================================================================

namespace llwu {
    /// Base addresses
    constexpr uint32_t LLWU_BASE = 0x4007C000;

    /// LLWU Register structure
    struct Registers {
        volatile uint32_t PE1;  ///< Offset: 0x00 - LLWU Pin Enable 1 register
        volatile uint32_t PE2;  ///< Offset: 0x01 - LLWU Pin Enable 2 register
        volatile uint32_t PE3;  ///< Offset: 0x02 - LLWU Pin Enable 3 register
        volatile uint32_t PE4;  ///< Offset: 0x03 - LLWU Pin Enable 4 register
        volatile uint32_t ME;  ///< Offset: 0x04 - LLWU Module Enable register
        volatile uint32_t F1;  ///< Offset: 0x05 - LLWU Flag 1 register
        volatile uint32_t F2;  ///< Offset: 0x06 - LLWU Flag 2 register
        volatile uint32_t F3;  ///< Offset: 0x07 - LLWU Flag 3 register
        volatile uint32_t FILT1;  ///< Offset: 0x08 - LLWU Pin Filter 1 register
        volatile uint32_t FILT2;  ///< Offset: 0x09 - LLWU Pin Filter 2 register
    };

    /// Peripheral instances
    inline Registers* LLWU = reinterpret_cast<Registers*>(LLWU_BASE);

    // Bit definitions
    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P3
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE4 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P7
    }

    /// PE3 Register bits
    namespace pe3_bits {
        constexpr uint32_t WUPE8 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P11
    }

    /// PE4 Register bits
    namespace pe4_bits {
        constexpr uint32_t WUPE12 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P15
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable For Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable For Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable For Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable For Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable For Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable For Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable For Module 7
    }

    /// F1 Register bits
    namespace f1_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag For LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag For LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag For LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag For LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag For LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag For LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag For LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag For LLWU_P7
    }

    /// F2 Register bits
    namespace f2_bits {
        constexpr uint32_t WUF8 = (1U << 0);  ///< Wakeup Flag For LLWU_P8
        constexpr uint32_t WUF9 = (1U << 1);  ///< Wakeup Flag For LLWU_P9
        constexpr uint32_t WUF10 = (1U << 2);  ///< Wakeup Flag For LLWU_P10
        constexpr uint32_t WUF11 = (1U << 3);  ///< Wakeup Flag For LLWU_P11
        constexpr uint32_t WUF12 = (1U << 4);  ///< Wakeup Flag For LLWU_P12
        constexpr uint32_t WUF13 = (1U << 5);  ///< Wakeup Flag For LLWU_P13
        constexpr uint32_t WUF14 = (1U << 6);  ///< Wakeup Flag For LLWU_P14
        constexpr uint32_t WUF15 = (1U << 7);  ///< Wakeup Flag For LLWU_P15
    }

    /// F3 Register bits
    namespace f3_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag For module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag For module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag For module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag For module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag For module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag For module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag For module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag For module 7
    }

    /// FILT1 Register bits
    namespace filt1_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT2 Register bits
    namespace filt2_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status And Control 1 register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status And Control 2 register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status And Control register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDV = (2 << 0);  ///< Low-Voltage Detect Voltage Select
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low-Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low-Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low-Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWV = (2 << 0);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t REGONS = (1U << 2);  ///< Regulator In Run Regulation Status
        constexpr uint32_t ACKISO = (1U << 3);  ///< Acknowledge Isolation
        constexpr uint32_t VLPO = (1U << 6);  ///< VLPx Option
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t PMPROT;  ///< Offset: 0x00 - Power Mode Protection register
        volatile uint32_t PMCTRL;  ///< Offset: 0x01 - Power Mode Control register
        volatile uint32_t STOPCTRL;  ///< Offset: 0x02 - Stop Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x03 - Power Mode Status register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLLS = (1U << 1);  ///< Allow Very-Low-Leakage Stop Mode
        constexpr uint32_t ALLS = (1U << 3);  ///< Allow Low-Leakage Stop Mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very-Low-Power Modes
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
    }

    /// STOPCTRL Register bits
    namespace stopctrl_bits {
        constexpr uint32_t LLSM = (3 << 0);  ///< LLS or VLLS Mode Control
        constexpr uint32_t PORPO = (1U << 5);  ///< POR Power Option
        constexpr uint32_t PSTOPO = (2 << 6);  ///< Partial Stop Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (8 << 0);  ///< Power Mode Status
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007F000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t SRS0;  ///< Offset: 0x00 - System Reset Status Register 0
        volatile uint32_t SRS1;  ///< Offset: 0x01 - System Reset Status Register 1
        volatile uint32_t RPFC;  ///< Offset: 0x04 - Reset Pin Filter Control register
        volatile uint32_t RPFW;  ///< Offset: 0x05 - Reset Pin Filter Width register
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// SRS0 Register bits
    namespace srs0_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Low Leakage Wakeup Reset
        constexpr uint32_t LVD = (1U << 1);  ///< Low-Voltage Detect Reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-Clock Reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
    }

    /// SRS1 Register bits
    namespace srs1_bits {
        constexpr uint32_t LOCKUP = (1U << 1);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 2);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 3);  ///< MDM-AP System Reset Request
        constexpr uint32_t SACKERR = (1U << 5);  ///< Stop Mode Acknowledge Error Reset
    }

    /// RPFC Register bits
    namespace rpfc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset Pin Filter Select in Run and Wait Modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset Pin Filter Select in Stop Mode
    }

    /// RPFW Register bits
    namespace rpfw_bits {
        constexpr uint32_t RSTFLTSEL = (5 << 0);  ///< Reset Pin Filter Bus Clock Select
    }

}

// ============================================================================
// MTB Peripheral
// ============================================================================

namespace mtb {
    /// Base addresses
    constexpr uint32_t MTB_BASE = 0xF0000000;

    /// MTB Register structure
    struct Registers {
        volatile uint32_t POSITION;  ///< Offset: 0x00 - MTB Position Register
        volatile uint32_t MASTER;  ///< Offset: 0x04 - MTB Master Register
        volatile uint32_t FLOW;  ///< Offset: 0x08 - MTB Flow Register
        volatile uint32_t BASE;  ///< Offset: 0x0C - MTB Base Register
        volatile uint32_t MODECTRL;  ///< Offset: 0xF00 - Integration Mode Control Register
        volatile uint32_t TAGSET;  ///< Offset: 0xFA0 - Claim TAG Set Register
        volatile uint32_t TAGCLEAR;  ///< Offset: 0xFA4 - Claim TAG Clear Register
        volatile uint32_t LOCKACCESS;  ///< Offset: 0xFB0 - Lock Access Register
        volatile uint32_t LOCKSTAT;  ///< Offset: 0xFB4 - Lock Status Register
        volatile uint32_t AUTHSTAT;  ///< Offset: 0xFB8 - Authentication Status Register
        volatile uint32_t DEVICEARCH;  ///< Offset: 0xFBC - Device Architecture Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID%s;  ///< Offset: 0xFD0 - Peripheral ID Register
        volatile uint32_t COMPID%s;  ///< Offset: 0xFF0 - Component ID Register
    };

    /// Peripheral instances
    inline Registers* MTB = reinterpret_cast<Registers*>(MTB_BASE);

    // Bit definitions
    /// POSITION Register bits
    namespace position_bits {
        constexpr uint32_t WRAP = (1U << 2);  ///< WRAP
        constexpr uint32_t POINTER = (29 << 3);  ///< Trace Packet Address Pointer[28:0]
    }

    /// MASTER Register bits
    namespace master_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< Mask
        constexpr uint32_t TSTARTEN = (1U << 5);  ///< Trace Start Input Enable
        constexpr uint32_t TSTOPEN = (1U << 6);  ///< Trace Stop Input Enable
        constexpr uint32_t SFRWPRIV = (1U << 7);  ///< Special Function Register Write Privilege
        constexpr uint32_t RAMPRIV = (1U << 8);  ///< RAM Privilege
        constexpr uint32_t HALTREQ = (1U << 9);  ///< Halt Request
        constexpr uint32_t EN = (1U << 31);  ///< Main Trace Enable
    }

    /// FLOW Register bits
    namespace flow_bits {
        constexpr uint32_t AUTOSTOP = (1U << 0);  ///< AUTOSTOP
        constexpr uint32_t AUTOHALT = (1U << 1);  ///< AUTOHALT
        constexpr uint32_t WATERMARK = (29 << 3);  ///< WATERMARK[28:0]
    }

    /// BASE Register bits
    namespace base_bits {
        constexpr uint32_t BASEADDR = (32 << 0);  ///< BASEADDR
    }

    /// MODECTRL Register bits
    namespace modectrl_bits {
        constexpr uint32_t MODECTRL = (32 << 0);  ///< MODECTRL
    }

    /// TAGSET Register bits
    namespace tagset_bits {
        constexpr uint32_t TAGSET = (32 << 0);  ///< TAGSET
    }

    /// TAGCLEAR Register bits
    namespace tagclear_bits {
        constexpr uint32_t TAGCLEAR = (32 << 0);  ///< TAGCLEAR
    }

    /// LOCKACCESS Register bits
    namespace lockaccess_bits {
        constexpr uint32_t LOCKACCESS = (32 << 0);  ///< Hardwired to 0x0000_0000
    }

    /// LOCKSTAT Register bits
    namespace lockstat_bits {
        constexpr uint32_t LOCKSTAT = (32 << 0);  ///< LOCKSTAT
    }

    /// AUTHSTAT Register bits
    namespace authstat_bits {
        constexpr uint32_t BIT0 = (1U << 0);  ///< Connected to DBGEN.
        constexpr uint32_t BIT1 = (1U << 1);  ///< BIT1
        constexpr uint32_t BIT2 = (1U << 2);  ///< BIT2
        constexpr uint32_t BIT3 = (1U << 3);  ///< BIT3
    }

    /// DEVICEARCH Register bits
    namespace devicearch_bits {
        constexpr uint32_t DEVICEARCH = (32 << 0);  ///< DEVICEARCH
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID%s Register bits
    namespace periphid%s_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID%s Register bits
    namespace compid%s_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MTBDWT Peripheral
// ============================================================================

namespace mtbdwt {
    /// Base addresses
    constexpr uint32_t MTBDWT_BASE = 0xF0001000;

    /// MTBDWT Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - MTB DWT Control Register
        volatile uint32_t COMP%s;  ///< Offset: 0x20 - MTB_DWT Comparator Register
        volatile uint32_t MASK%s;  ///< Offset: 0x24 - MTB_DWT Comparator Mask Register
        volatile uint32_t FCT0;  ///< Offset: 0x28 - MTB_DWT Comparator Function Register 0
        volatile uint32_t FCT1;  ///< Offset: 0x38 - MTB_DWT Comparator Function Register 1
        volatile uint32_t TBCTRL;  ///< Offset: 0x200 - MTB_DWT Trace Buffer Control Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID%s;  ///< Offset: 0xFD0 - Peripheral ID Register
        volatile uint32_t COMPID%s;  ///< Offset: 0xFF0 - Component ID Register
    };

    /// Peripheral instances
    inline Registers* MTBDWT = reinterpret_cast<Registers*>(MTBDWT_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t DWTCFGCTRL = (28 << 0);  ///< DWT configuration controls
        constexpr uint32_t NUMCMP = (4 << 28);  ///< Number of comparators
    }

    /// COMP%s Register bits
    namespace comp%s_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Reference value for comparison
    }

    /// MASK%s Register bits
    namespace mask%s_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< MASK
    }

    /// FCT0 Register bits
    namespace fct0_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< Data Value Match
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< Data Value Size
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< Data Value Address 0
        constexpr uint32_t MATCHED = (1U << 24);  ///< Comparator match
    }

    /// FCT1 Register bits
    namespace fct1_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function
        constexpr uint32_t MATCHED = (1U << 24);  ///< Comparator match
    }

    /// TBCTRL Register bits
    namespace tbctrl_bits {
        constexpr uint32_t ACOMP0 = (1U << 0);  ///< Action based on Comparator 0 match
        constexpr uint32_t ACOMP1 = (1U << 1);  ///< Action based on Comparator 1 match
        constexpr uint32_t NUMCOMP = (4 << 28);  ///< Number of Comparators
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID%s Register bits
    namespace periphid%s_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID%s Register bits
    namespace compid%s_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// ROM Peripheral
// ============================================================================

namespace rom {
    /// Base addresses
    constexpr uint32_t ROM_BASE = 0xF0002000;

    /// ROM Register structure
    struct Registers {
        volatile uint32_t ENTRY%s;  ///< Offset: 0x00 - Entry
        volatile uint32_t TABLEMARK;  ///< Offset: 0x0C - End of Table Marker Register
        volatile uint32_t SYSACCESS;  ///< Offset: 0xFCC - System Access Register
        volatile uint32_t PERIPHID%s;  ///< Offset: 0xFD0 - Peripheral ID Register
        volatile uint32_t COMPID%s;  ///< Offset: 0xFF0 - Component ID Register
    };

    /// Peripheral instances
    inline Registers* ROM = reinterpret_cast<Registers*>(ROM_BASE);

    // Bit definitions
    /// ENTRY%s Register bits
    namespace entry%s_bits {
        constexpr uint32_t ENTRY = (32 << 0);  ///< ENTRY
    }

    /// TABLEMARK Register bits
    namespace tablemark_bits {
        constexpr uint32_t MARK = (32 << 0);  ///< MARK
    }

    /// SYSACCESS Register bits
    namespace sysaccess_bits {
        constexpr uint32_t SYSACCESS = (32 << 0);  ///< SYSACCESS
    }

    /// PERIPHID%s Register bits
    namespace periphid%s_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID%s Register bits
    namespace compid%s_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xF0003000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t PLACR;  ///< Offset: 0x0C - Platform Control Register
        volatile uint32_t CPO;  ///< Offset: 0x40 - Compute Operation Control Register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
    }

    /// PLACR Register bits
    namespace placr_bits {
        constexpr uint32_t ARB = (1U << 9);  ///< Arbitration select
        constexpr uint32_t CFCC = (1U << 10);  ///< Clear Flash Controller Cache
        constexpr uint32_t DFCDA = (1U << 11);  ///< Disable Flash Controller Data Caching
        constexpr uint32_t DFCIC = (1U << 12);  ///< Disable Flash Controller Instruction Caching
        constexpr uint32_t DFCC = (1U << 13);  ///< Disable Flash Controller Cache
        constexpr uint32_t EFDS = (1U << 14);  ///< Enable Flash Data Speculation
        constexpr uint32_t DFCS = (1U << 15);  ///< Disable Flash Controller Speculation
        constexpr uint32_t ESFC = (1U << 16);  ///< Enable Stalling Flash Controller
    }

    /// CPO Register bits
    namespace cpo_bits {
        constexpr uint32_t CPOREQ = (1U << 0);  ///< Compute Operation Request
        constexpr uint32_t CPOACK = (1U << 1);  ///< Compute Operation Acknowledge
        constexpr uint32_t CPOWOI = (1U << 2);  ///< Compute Operation Wake-up on Interrupt
    }

}


} // namespace alloy::generated::mkw40z4

#endif // ALLOY_GENERATED_MKW40Z4_PERIPHERALS_HPP