/// Auto-generated code for SKEAZ1284
/// Generated by Alloy Code Generator
/// Source: nxp_skeaz1284.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:45:02
#ifndef ALLOY_GENERATED_SKEAZ1284_PERIPHERALS_HPP
#define ALLOY_GENERATED_SKEAZ1284_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::skeaz1284 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_ftmre = true;
    constexpr uint32_t num_ftmre_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 1;
    constexpr bool has_irq = true;
    constexpr uint32_t num_irq_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_pwt = true;
    constexpr uint32_t num_pwt_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 1;
    constexpr bool has_ftm0 = true;
    constexpr uint32_t num_ftm0_instances = 1;
    constexpr bool has_ftm1 = true;
    constexpr uint32_t num_ftm1_instances = 1;
    constexpr bool has_ftm2 = true;
    constexpr uint32_t num_ftm2_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 7;
    constexpr bool has_wdog = true;
    constexpr uint32_t num_wdog_instances = 1;
    constexpr bool has_ics = true;
    constexpr uint32_t num_ics_instances = 1;
    constexpr bool has_osc = true;
    constexpr uint32_t num_osc_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 3;
    constexpr bool has_acmp0 = true;
    constexpr uint32_t num_acmp0_instances = 1;
    constexpr bool has_acmp1 = true;
    constexpr uint32_t num_acmp1_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_kbi0 = true;
    constexpr uint32_t num_kbi0_instances = 1;
    constexpr bool has_kbi1 = true;
    constexpr uint32_t num_kbi1_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_systemcontrol = true;
    constexpr uint32_t num_systemcontrol_instances = 1;
    constexpr bool has_systick = true;
    constexpr uint32_t num_systick_instances = 1;
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 1;
    constexpr bool has_rom = true;
    constexpr uint32_t num_rom_instances = 1;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftmre_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct irq_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 7;
    };
    template<>
    struct peripheral_count<struct wdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ics_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct acmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct acmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct kbi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct kbi1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systemcontrol_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systick_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rom_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 7;
    constexpr uint32_t max_gpio_pins = 112;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTMRE_FlashConfig_BASE = 0x00000400;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY0;  ///< Offset: 0x00 - Backdoor Comparison Key 0
        volatile uint32_t BACKKEY1;  ///< Offset: 0x01 - Backdoor Comparison Key 1
        volatile uint32_t BACKKEY2;  ///< Offset: 0x02 - Backdoor Comparison Key 2
        volatile uint32_t BACKKEY3;  ///< Offset: 0x03 - Backdoor Comparison Key 3
        volatile uint32_t BACKKEY4;  ///< Offset: 0x04 - Backdoor Comparison Key 4
        volatile uint32_t BACKKEY5;  ///< Offset: 0x05 - Backdoor Comparison Key 5
        volatile uint32_t BACKKEY6;  ///< Offset: 0x06 - Backdoor Comparison Key 6
        volatile uint32_t BACKKEY7;  ///< Offset: 0x07 - Backdoor Comparison Key 7
        volatile uint32_t FPROT;  ///< Offset: 0x0D - Non-volatile P-Flash Protection Register
        volatile uint32_t FSEC;  ///< Offset: 0x0E - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0F - Non-volatile Flash Option Register
    };

    /// Peripheral instances
    inline Registers* FTMRE_FlashConfig = reinterpret_cast<Registers*>(FTMRE_FlashConfig_BASE);

    // Bit definitions
    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT Register bits
    namespace fprot_bits {
        constexpr uint32_t FPLS = (2 << 0);  ///< no description available
        constexpr uint32_t FPLDIS = (1U << 2);  ///< no description available
        constexpr uint32_t FPHS = (2 << 3);  ///< no description available
        constexpr uint32_t FPHDIS = (1U << 5);  ///< no description available
        constexpr uint32_t FPOPEN = (1U << 7);  ///< no description available
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

}

// ============================================================================
// FTMRE Peripheral
// ============================================================================

namespace ftmre {
    /// Base addresses
    constexpr uint32_t FTMRE_BASE = 0x40020000;

    /// FTMRE Register structure
    struct Registers {
        volatile uint32_t FCCOBIX;  ///< Offset: 0x01 - Flash CCOB Index Register
        volatile uint32_t FSEC;  ///< Offset: 0x02 - Flash Security Register
        volatile uint32_t FCLKDIV;  ///< Offset: 0x03 - Flash Clock Divider Register
        volatile uint32_t FSTAT;  ///< Offset: 0x05 - Flash Status Register
        volatile uint32_t FCNFG;  ///< Offset: 0x07 - Flash Configuration Register
        volatile uint32_t FCCOBLO;  ///< Offset: 0x08 - Flash Common Command Object Register: Low
        volatile uint32_t FCCOBHI;  ///< Offset: 0x09 - Flash Common Command Object Register:High
        volatile uint32_t FPROT;  ///< Offset: 0x0B - Flash Protection Register
        volatile uint32_t FOPT;  ///< Offset: 0x0F - Flash Option Register
    };

    /// Peripheral instances
    inline Registers* FTMRE = reinterpret_cast<Registers*>(FTMRE_BASE);

    // Bit definitions
    /// FCCOBIX Register bits
    namespace fccobix_bits {
        constexpr uint32_t CCOBIX = (3 << 0);  ///< Common Command Register Index
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security Bits
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable Bits
    }

    /// FCLKDIV Register bits
    namespace fclkdiv_bits {
        constexpr uint32_t FDIV = (6 << 0);  ///< Clock Divider Bits
        constexpr uint32_t FDIVLCK = (1U << 6);  ///< Clock Divider Locked
        constexpr uint32_t FDIVLD = (1U << 7);  ///< Clock Divider Loaded
    }

    /// FSTAT Register bits
    namespace fstat_bits {
        constexpr uint32_t MGSTAT = (2 << 0);  ///< Memory Controller Command Completion Status Flag
        constexpr uint32_t MGBUSY = (1U << 3);  ///< Memory Controller Busy Flag
        constexpr uint32_t FPVIOL = (1U << 4);  ///< Flash Protection Violation Flag
        constexpr uint32_t ACCERR = (1U << 5);  ///< Flash Access Error Flag
        constexpr uint32_t CCIF = (1U << 7);  ///< Command Complete Interrupt Flag
    }

    /// FCNFG Register bits
    namespace fcnfg_bits {
        constexpr uint32_t ERSAREQ = (1U << 5);  ///< Debugger Mass Erase Request
        constexpr uint32_t CCIE = (1U << 7);  ///< Command Complete Interrupt Enable
    }

    /// FCCOBLO Register bits
    namespace fccoblo_bits {
        constexpr uint32_t CCOB = (8 << 0);  ///< Common Command Object Bit 7:0
    }

    /// FCCOBHI Register bits
    namespace fccobhi_bits {
        constexpr uint32_t CCOB = (8 << 0);  ///< Common Command Object Bit 15:8
    }

    /// FPROT Register bits
    namespace fprot_bits {
        constexpr uint32_t FPLS = (2 << 0);  ///< Flash Protection Lower Address Size
        constexpr uint32_t FPLDIS = (1U << 2);  ///< Flash Protection Lower Address Range Disable
        constexpr uint32_t FPHS = (2 << 3);  ///< Flash Protection Higher Address Size
        constexpr uint32_t FPHDIS = (1U << 5);  ///< Flash Protection Higher Address Range Disable
        constexpr uint32_t RNV6 = (1U << 6);  ///< Reserved Nonvolatile Bit
        constexpr uint32_t FPOPEN = (1U << 7);  ///< Flash Protection Operation Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t NV = (8 << 0);  ///< Nonvolatile Bits
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t MSCAN_BASE = 0x40024000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t CANCTL0;  ///< Offset: 0x00 - MSCAN Control Register 0
        volatile uint32_t CANCTL1;  ///< Offset: 0x01 - MSCAN Control Register 1
        volatile uint32_t CANBTR0;  ///< Offset: 0x02 - MSCAN Bus Timing Register 0
        volatile uint32_t CANBTR1;  ///< Offset: 0x03 - MSCAN Bus Timing Register 1
        volatile uint32_t CANRFLG;  ///< Offset: 0x04 - MSCAN Receiver Flag Register
        volatile uint32_t CANRIER;  ///< Offset: 0x05 - MSCAN Receiver Interrupt Enable Register
        volatile uint32_t CANTFLG;  ///< Offset: 0x06 - MSCAN Transmitter Flag Register
        volatile uint32_t CANTIER;  ///< Offset: 0x07 - MSCAN Transmitter Interrupt Enable Register
        volatile uint32_t CANTARQ;  ///< Offset: 0x08 - MSCAN Transmitter Message Abort Request Register
        volatile uint32_t CANTAAK;  ///< Offset: 0x09 - MSCAN Transmitter Message Abort Acknowledge Register
        volatile uint32_t CANTBSEL;  ///< Offset: 0x0A - MSCAN Transmit Buffer Selection Register
        volatile uint32_t CANIDAC;  ///< Offset: 0x0B - MSCAN Identifier Acceptance Control Register
        volatile uint32_t CANMISC;  ///< Offset: 0x0D - MSCAN Miscellaneous Register
        volatile uint32_t CANRXERR;  ///< Offset: 0x0E - MSCAN Receive Error Counter
        volatile uint32_t CANTXERR;  ///< Offset: 0x0F - MSCAN Transmit Error Counter
        volatile uint32_t CANIDAR0;  ///< Offset: 0x10 - MSCAN Identifier Acceptance Register n of First Bank
        volatile uint32_t CANIDAR1;  ///< Offset: 0x11 - MSCAN Identifier Acceptance Register n of First Bank
        volatile uint32_t CANIDAR2;  ///< Offset: 0x12 - MSCAN Identifier Acceptance Register n of First Bank
        volatile uint32_t CANIDAR3;  ///< Offset: 0x13 - MSCAN Identifier Acceptance Register n of First Bank
        volatile uint32_t CANIDMR0;  ///< Offset: 0x14 - MSCAN Identifier Mask Register n of First Bank
        volatile uint32_t CANIDMR1;  ///< Offset: 0x15 - MSCAN Identifier Mask Register n of First Bank
        volatile uint32_t CANIDMR2;  ///< Offset: 0x16 - MSCAN Identifier Mask Register n of First Bank
        volatile uint32_t CANIDMR3;  ///< Offset: 0x17 - MSCAN Identifier Mask Register n of First Bank
        volatile uint32_t CANIDAR4;  ///< Offset: 0x18 - MSCAN Identifier Acceptance Register n of Second Bank
        volatile uint32_t CANIDAR5;  ///< Offset: 0x19 - MSCAN Identifier Acceptance Register n of Second Bank
        volatile uint32_t CANIDAR6;  ///< Offset: 0x1A - MSCAN Identifier Acceptance Register n of Second Bank
        volatile uint32_t CANIDAR7;  ///< Offset: 0x1B - MSCAN Identifier Acceptance Register n of Second Bank
        volatile uint32_t CANIDMR4;  ///< Offset: 0x1C - MSCAN Identifier Mask Register n of Second Bank
        volatile uint32_t CANIDMR5;  ///< Offset: 0x1D - MSCAN Identifier Mask Register n of Second Bank
        volatile uint32_t CANIDMR6;  ///< Offset: 0x1E - MSCAN Identifier Mask Register n of Second Bank
        volatile uint32_t CANIDMR7;  ///< Offset: 0x1F - MSCAN Identifier Mask Register n of Second Bank
        volatile uint32_t REIDR0;  ///< Offset: 0x20 - Receive Extended Identifier Register 0
        volatile uint32_t RSIDR0;  ///< Offset: 0x20 - Receive Standard Identifier Register 0
        volatile uint32_t REIDR1;  ///< Offset: 0x21 - Receive Extended Identifier Register 1
        volatile uint32_t RSIDR1;  ///< Offset: 0x21 - Standard Identifier Register 1
        volatile uint32_t REIDR2;  ///< Offset: 0x22 - Receive Extended Identifier Register 2
        volatile uint32_t REIDR3;  ///< Offset: 0x23 - Receive Extended Identifier Register 3
        volatile uint32_t REDSR;  ///< Offset: 0x24 - Receive Extended Data Segment Register N (renamed from REDSR)
        volatile uint32_t RDLR;  ///< Offset: 0x2C - Receive Data Length Register
        volatile uint32_t RTSRH;  ///< Offset: 0x2E - Receive Time Stamp Register High
        volatile uint32_t RTSRL;  ///< Offset: 0x2F - Receive Time Stamp Register Low
        volatile uint32_t TEIDR0;  ///< Offset: 0x30 - Transmit Extended Identifier Register 0
        volatile uint32_t TSIDR0;  ///< Offset: 0x30 - Transmit Standard Identifier Register 0
        volatile uint32_t TEIDR1;  ///< Offset: 0x31 - Transmit Extended Identifier Register 1
        volatile uint32_t TSIDR1;  ///< Offset: 0x31 - Transmit Standard Identifier Register 1
        volatile uint32_t TEIDR2;  ///< Offset: 0x32 - Transmit Extended Identifier Register 2
        volatile uint32_t TEIDR3;  ///< Offset: 0x33 - Transmit Extended Identifier Register 3
        volatile uint32_t TEDSR;  ///< Offset: 0x34 - Transmit Extended Data Segment Register N (renamed from TEDSR)
        volatile uint32_t TDLR;  ///< Offset: 0x3C - This register keeps the data length field of the CAN frame.
        volatile uint32_t TBPR;  ///< Offset: 0x3D - Transmit Buffer Priority Register
        volatile uint32_t TTSRH;  ///< Offset: 0x3E - Transmit Time Stamp Register High
        volatile uint32_t TTSRL;  ///< Offset: 0x3F - Transmit Time Stamp Register Low
    };

    /// Peripheral instances
    inline Registers* MSCAN = reinterpret_cast<Registers*>(MSCAN_BASE);

    // Bit definitions
    /// CANCTL0 Register bits
    namespace canctl0_bits {
        constexpr uint32_t INITRQ = (1U << 0);  ///< Initialization Mode Request
        constexpr uint32_t SLPRQ = (1U << 1);  ///< Sleep Mode Request
        constexpr uint32_t WUPE = (1U << 2);  ///< WakeUp Enable
        constexpr uint32_t TIME = (1U << 3);  ///< Timer Enable
        constexpr uint32_t SYNCH = (1U << 4);  ///< Synchronized Status
        constexpr uint32_t CSWAI = (1U << 5);  ///< CAN Stops in Wait Mode
        constexpr uint32_t RXACT = (1U << 6);  ///< Receiver Active Status
        constexpr uint32_t RXFRM = (1U << 7);  ///< Received Frame Flag
    }

    /// CANCTL1 Register bits
    namespace canctl1_bits {
        constexpr uint32_t INITAK = (1U << 0);  ///< Initialization Mode Acknowledge
        constexpr uint32_t SLPAK = (1U << 1);  ///< Sleep Mode Acknowledge
        constexpr uint32_t WUPM = (1U << 2);  ///< WakeUp Mode
        constexpr uint32_t BORM = (1U << 3);  ///< Bus-Off Recovery Mode
        constexpr uint32_t LISTEN = (1U << 4);  ///< Listen Only Mode
        constexpr uint32_t LOOPB = (1U << 5);  ///< Loopback Self Test Mode
        constexpr uint32_t CLKSRC = (1U << 6);  ///< MSCAN Clock Source
        constexpr uint32_t CANE = (1U << 7);  ///< MSCAN Enable
    }

    /// CANBTR0 Register bits
    namespace canbtr0_bits {
        constexpr uint32_t BRP = (6 << 0);  ///< Baud Rate Prescaler
        constexpr uint32_t SJW = (2 << 6);  ///< Synchronization Jump Width
    }

    /// CANBTR1 Register bits
    namespace canbtr1_bits {
        constexpr uint32_t TSEG1 = (4 << 0);  ///< Time Segment 1
        constexpr uint32_t TSEG2 = (3 << 4);  ///< Time Segment 2
        constexpr uint32_t SAMP = (1U << 7);  ///< Sampling
    }

    /// CANRFLG Register bits
    namespace canrflg_bits {
        constexpr uint32_t RXF = (1U << 0);  ///< Receive Buffer Full Flag
        constexpr uint32_t OVRIF = (1U << 1);  ///< Overrun Interrupt Flag
        constexpr uint32_t TSTAT = (2 << 2);  ///< Transmitter Status
        constexpr uint32_t RSTAT = (2 << 4);  ///< Receiver Status
        constexpr uint32_t CSCIF = (1U << 6);  ///< CAN Status Change Interrupt Flag
        constexpr uint32_t WUPIF = (1U << 7);  ///< Wake-Up Interrupt Flag
    }

    /// CANRIER Register bits
    namespace canrier_bits {
        constexpr uint32_t RXFIE = (1U << 0);  ///< Receiver Full Interrupt Enable
        constexpr uint32_t OVRIE = (1U << 1);  ///< Overrun Interrupt Enable
        constexpr uint32_t TSTATE = (2 << 2);  ///< Transmitter Status Change Enable
        constexpr uint32_t RSTATE = (2 << 4);  ///< Receiver Status Change Enable
        constexpr uint32_t CSCIE = (1U << 6);  ///< CAN Status Change Interrupt Enable
        constexpr uint32_t WUPIE = (1U << 7);  ///< WakeUp Interrupt Enable
    }

    /// CANTFLG Register bits
    namespace cantflg_bits {
        constexpr uint32_t TXE = (3 << 0);  ///< Transmitter Buffer Empty
    }

    /// CANTIER Register bits
    namespace cantier_bits {
        constexpr uint32_t TXEIE = (3 << 0);  ///< Transmitter Empty Interrupt Enable
    }

    /// CANTARQ Register bits
    namespace cantarq_bits {
        constexpr uint32_t ABTRQ = (3 << 0);  ///< Abort Request
    }

    /// CANTAAK Register bits
    namespace cantaak_bits {
        constexpr uint32_t ABTAK = (3 << 0);  ///< Abort Acknowledge
    }

    /// CANTBSEL Register bits
    namespace cantbsel_bits {
        constexpr uint32_t TX = (3 << 0);  ///< Transmit Buffer Select
    }

    /// CANIDAC Register bits
    namespace canidac_bits {
        constexpr uint32_t IDHIT = (3 << 0);  ///< Identifier Acceptance Hit Indicator
        constexpr uint32_t IDAM = (2 << 4);  ///< Identifier Acceptance Mode
    }

    /// CANMISC Register bits
    namespace canmisc_bits {
        constexpr uint32_t BOHOLD = (1U << 0);  ///< Bus-off State Hold Until User Request
    }

    /// CANRXERR Register bits
    namespace canrxerr_bits {
        constexpr uint32_t RXERR = (8 << 0);  ///< Receive Error Counter
    }

    /// CANTXERR Register bits
    namespace cantxerr_bits {
        constexpr uint32_t TXERR = (8 << 0);  ///< Transmit Error Counter
    }

    /// CANIDAR0 Register bits
    namespace canidar0_bits {
        constexpr uint32_t AC = (8 << 0);  ///< Acceptance Code Bits
    }

    /// CANIDAR1 Register bits
    namespace canidar1_bits {
        constexpr uint32_t AC = (8 << 0);  ///< Acceptance Code Bits
    }

    /// CANIDAR2 Register bits
    namespace canidar2_bits {
        constexpr uint32_t AC = (8 << 0);  ///< Acceptance Code Bits
    }

    /// CANIDAR3 Register bits
    namespace canidar3_bits {
        constexpr uint32_t AC = (8 << 0);  ///< Acceptance Code Bits
    }

    /// CANIDMR0 Register bits
    namespace canidmr0_bits {
        constexpr uint32_t AM = (8 << 0);  ///< Acceptance Mask Bits
    }

    /// CANIDMR1 Register bits
    namespace canidmr1_bits {
        constexpr uint32_t AM = (8 << 0);  ///< Acceptance Mask Bits
    }

    /// CANIDMR2 Register bits
    namespace canidmr2_bits {
        constexpr uint32_t AM = (8 << 0);  ///< Acceptance Mask Bits
    }

    /// CANIDMR3 Register bits
    namespace canidmr3_bits {
        constexpr uint32_t AM = (8 << 0);  ///< Acceptance Mask Bits
    }

    /// CANIDAR4 Register bits
    namespace canidar4_bits {
        constexpr uint32_t AC = (8 << 0);  ///< Acceptance Code Bits
    }

    /// CANIDAR5 Register bits
    namespace canidar5_bits {
        constexpr uint32_t AC = (8 << 0);  ///< Acceptance Code Bits
    }

    /// CANIDAR6 Register bits
    namespace canidar6_bits {
        constexpr uint32_t AC = (8 << 0);  ///< Acceptance Code Bits
    }

    /// CANIDAR7 Register bits
    namespace canidar7_bits {
        constexpr uint32_t AC = (8 << 0);  ///< Acceptance Code Bits
    }

    /// CANIDMR4 Register bits
    namespace canidmr4_bits {
        constexpr uint32_t AM = (8 << 0);  ///< Acceptance Mask Bits
    }

    /// CANIDMR5 Register bits
    namespace canidmr5_bits {
        constexpr uint32_t AM = (8 << 0);  ///< Acceptance Mask Bits
    }

    /// CANIDMR6 Register bits
    namespace canidmr6_bits {
        constexpr uint32_t AM = (8 << 0);  ///< Acceptance Mask Bits
    }

    /// CANIDMR7 Register bits
    namespace canidmr7_bits {
        constexpr uint32_t AM = (8 << 0);  ///< Acceptance Mask Bits
    }

    /// REIDR0 Register bits
    namespace reidr0_bits {
        constexpr uint32_t REID28_REID21 = (8 << 0);  ///< Extended Format Identifier
    }

    /// RSIDR0 Register bits
    namespace rsidr0_bits {
        constexpr uint32_t RSID10_RSID3 = (8 << 0);  ///< Standard Format Identifier
    }

    /// REIDR1 Register bits
    namespace reidr1_bits {
        constexpr uint32_t REID17_REID15 = (3 << 0);  ///< Extended Format Identifier 17-15
        constexpr uint32_t REIDE = (1U << 3);  ///< ID Extended
        constexpr uint32_t RSRR = (1U << 4);  ///< Substitute Remote Request
        constexpr uint32_t REID20_REID18 = (3 << 5);  ///< Extended Format Identifier 20-18
    }

    /// RSIDR1 Register bits
    namespace rsidr1_bits {
        constexpr uint32_t RSIDE = (1U << 3);  ///< ID Extended
        constexpr uint32_t RSRTR = (1U << 4);  ///< Remote Transmission Request
        constexpr uint32_t RSID2_RSID0 = (3 << 5);  ///< Standard Format Identifier 2-0
    }

    /// REIDR2 Register bits
    namespace reidr2_bits {
        constexpr uint32_t REID14_REID7 = (8 << 0);  ///< Extended Format Identifier 14-7
    }

    /// REIDR3 Register bits
    namespace reidr3_bits {
        constexpr uint32_t RERTR = (1U << 0);  ///< Remote Transmission Request
        constexpr uint32_t REID6_REID0 = (7 << 1);  ///< Extended Format Identifier 6-0
    }

    /// REDSR Register bits
    namespace redsr_bits {
        constexpr uint32_t RDB = (8 << 0);  ///< Data Bits
    }

    /// RDLR Register bits
    namespace rdlr_bits {
        constexpr uint32_t RDLC = (4 << 0);  ///< Data Length Code Bits
    }

    /// RTSRH Register bits
    namespace rtsrh_bits {
        constexpr uint32_t RTS = (8 << 0);  ///< Time Stamp
    }

    /// RTSRL Register bits
    namespace rtsrl_bits {
        constexpr uint32_t RTS = (8 << 0);  ///< Time Stamp
    }

    /// TEIDR0 Register bits
    namespace teidr0_bits {
        constexpr uint32_t TEID28_TEID21 = (8 << 0);  ///< Extended Format Identifier
    }

    /// TSIDR0 Register bits
    namespace tsidr0_bits {
        constexpr uint32_t TSID10_TSID3 = (8 << 0);  ///< Standard Format Identifier
    }

    /// TEIDR1 Register bits
    namespace teidr1_bits {
        constexpr uint32_t TEID17_TEID15 = (3 << 0);  ///< Extended Format Identifier 17-15
        constexpr uint32_t TEIDE = (1U << 3);  ///< ID Extended
        constexpr uint32_t TSRR = (1U << 4);  ///< Substitute Remote Request
        constexpr uint32_t TEID20_TEID18 = (3 << 5);  ///< Extended Format Identifier 20-18
    }

    /// TSIDR1 Register bits
    namespace tsidr1_bits {
        constexpr uint32_t TSIDE = (1U << 3);  ///< ID Extended
        constexpr uint32_t TSRTR = (1U << 4);  ///< Remote Transmission Request
        constexpr uint32_t TSID2_TSID0 = (3 << 5);  ///< Standard Format Identifier 2-0
    }

    /// TEIDR2 Register bits
    namespace teidr2_bits {
        constexpr uint32_t TEID14_TEID7 = (8 << 0);  ///< Extended Format Identifier 14-7
    }

    /// TEIDR3 Register bits
    namespace teidr3_bits {
        constexpr uint32_t TERTR = (1U << 0);  ///< Remote Transmission Request
        constexpr uint32_t TEID6_TEID0 = (7 << 1);  ///< Extended Format Identifier 6-0
    }

    /// TEDSR Register bits
    namespace tedsr_bits {
        constexpr uint32_t TDB = (8 << 0);  ///< Data Bits
    }

    /// TDLR Register bits
    namespace tdlr_bits {
        constexpr uint32_t TDLC = (4 << 0);  ///< Data Length Code Bits
    }

    /// TBPR Register bits
    namespace tbpr_bits {
        constexpr uint32_t PRIO = (8 << 0);  ///< Priority
    }

    /// TTSRH Register bits
    namespace ttsrh_bits {
        constexpr uint32_t TTS = (8 << 0);  ///< Time Stamp
    }

    /// TTSRL Register bits
    namespace ttsrl_bits {
        constexpr uint32_t TTS = (8 << 0);  ///< Time Stamp
    }

}

// ============================================================================
// IRQ Peripheral
// ============================================================================

namespace irq {
    /// Base addresses
    constexpr uint32_t IRQ_BASE = 0x40031000;

    /// IRQ Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Interrupt Pin Request Status and Control Register
    };

    /// Peripheral instances
    inline Registers* IRQ = reinterpret_cast<Registers*>(IRQ_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t IRQMOD = (1U << 0);  ///< IRQ Detection Mode
        constexpr uint32_t IRQIE = (1U << 1);  ///< IRQ Interrupt Enable
        constexpr uint32_t IRQACK = (1U << 2);  ///< IRQ Acknowledge
        constexpr uint32_t IRQF = (1U << 3);  ///< IRQ Flag
        constexpr uint32_t IRQPE = (1U << 4);  ///< IRQ Pin Enable
        constexpr uint32_t IRQEDG = (1U << 5);  ///< Interrupt Request (IRQ) Edge Select
        constexpr uint32_t IRQPDD = (1U << 6);  ///< Interrupt Request (IRQ) Pull Device Disable
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40032000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x00 - CRC Data register
        volatile uint32_t DATAL;  ///< Offset: 0x00 - CRC_DATAL register.
        volatile uint32_t DATALL;  ///< Offset: 0x00 - CRC_DATALL register.
        volatile uint32_t DATALU;  ///< Offset: 0x01 - CRC_DATALU register.
        volatile uint32_t DATAH;  ///< Offset: 0x02 - CRC_DATAH register.
        volatile uint32_t DATAHL;  ///< Offset: 0x02 - CRC_DATAHL register.
        volatile uint32_t DATAHU;  ///< Offset: 0x03 - CRC_DATAHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial register
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// DATAL Register bits
    namespace datal_bits {
        constexpr uint32_t DATAL = (16 << 0);  ///< DATAL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// DATALL Register bits
    namespace datall_bits {
        constexpr uint32_t DATALL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit DATA
    }

    /// DATALU Register bits
    namespace datalu_bits {
        constexpr uint32_t DATALU = (8 << 0);  ///< DATALL stores the second 8 bits of the 32 bit CRC
    }

    /// DATAH Register bits
    namespace datah_bits {
        constexpr uint32_t DATAH = (16 << 0);  ///< DATAH stores the high 16 bits of the 16/32 bit CRC
    }

    /// DATAHL Register bits
    namespace datahl_bits {
        constexpr uint32_t DATAHL = (8 << 0);  ///< DATAHL stores the third 8 bits of the 32 bit CRC
    }

    /// DATAHU Register bits
    namespace datahu_bits {
        constexpr uint32_t DATAHU = (8 << 0);  ///< DATAHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low Polynominal Half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High Polynominal Half-word
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TCRC = (1U << 24);  ///< no description available
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC Data Register As Seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read Of CRC Data Register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type Of Transpose For Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type Of Transpose For Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// PWT Peripheral
// ============================================================================

namespace pwt {
    /// Base addresses
    constexpr uint32_t PWT_BASE = 0x40033000;

    /// PWT Register structure
    struct Registers {
        volatile uint32_t R1;  ///< Offset: 0x00 - Pulse Width Timer Register 1
        volatile uint32_t R2;  ///< Offset: 0x04 - Pulse Width Timer Register 2
    };

    /// Peripheral instances
    inline Registers* PWT = reinterpret_cast<Registers*>(PWT_BASE);

    // Bit definitions
    /// R1 Register bits
    namespace r1_bits {
        constexpr uint32_t PWTOV = (1U << 0);  ///< PWT Counter Overflow
        constexpr uint32_t PWTRDY = (1U << 1);  ///< PWT Pulse Width Valid
        constexpr uint32_t PWTSR = (1U << 3);  ///< PWT Soft Reset
        constexpr uint32_t POVIE = (1U << 4);  ///< PWT Counter Overflow Interrupt Enable
        constexpr uint32_t PRDYIE = (1U << 5);  ///< PWT Pulse Width Data Ready Interrupt Enable
        constexpr uint32_t PWTIE = (1U << 6);  ///< PWT Module Interrupt Enable
        constexpr uint32_t PWTEN = (1U << 7);  ///< PWT Module Enable
        constexpr uint32_t PRE = (3 << 8);  ///< PWT Clock Prescaler (CLKPRE) Setting
        constexpr uint32_t EDGE = (2 << 11);  ///< PWT Input Edge Sensitivity
        constexpr uint32_t PINSEL = (2 << 13);  ///< PWT Pulse Inputs Selection
        constexpr uint32_t PCLKS = (1U << 15);  ///< PWT Clock Source Selection
        constexpr uint32_t PPW = (16 << 16);  ///< Positive Pulse Width
    }

    /// R2 Register bits
    namespace r2_bits {
        constexpr uint32_t NPW = (16 << 0);  ///< Negative Pulse Width. It is suggested to use half-word (16-bit) or word (32-bit) to read out this value.
        constexpr uint32_t PWTC = (16 << 16);  ///< PWT Counter. It is suggested to use half-word (16-bit) or word (32-bit) to read out this value.
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT_BASE = 0x40037000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LDVAL;  ///< Offset: 0x100 - Timer Load Value Register (renamed from LDVAL)
        volatile uint32_t CVAL;  ///< Offset: 0x104 - Current Timer Value Register (renamed from CVAL)
        volatile uint32_t TCTRL;  ///< Offset: 0x108 - Timer Control Register (renamed from TCTRL)
        volatile uint32_t TFLG;  ///< Offset: 0x10C - Timer Flag Register (renamed from TFLG)
    };

    /// Peripheral instances
    inline Registers* PIT = reinterpret_cast<Registers*>(PIT_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable - (PIT section)
    }

    /// LDVAL Register bits
    namespace ldval_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value
    }

    /// CVAL Register bits
    namespace cval_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL Register bits
    namespace tctrl_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable
        constexpr uint32_t CHN = (1U << 2);  ///< Chain Mode
    }

    /// TFLG Register bits
    namespace tflg_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag
    }

}

// ============================================================================
// FTM0 Peripheral
// ============================================================================

namespace ftm0 {
    /// Base addresses
    constexpr uint32_t FTM0_BASE = 0x40038000;

    /// FTM0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
    };

    /// Peripheral instances
    inline Registers* FTM0 = reinterpret_cast<Registers*>(FTM0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

}

// ============================================================================
// FTM1 Peripheral
// ============================================================================

namespace ftm1 {
    /// Base addresses
    constexpr uint32_t FTM1_BASE = 0x40039000;

    /// FTM1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
    };

    /// Peripheral instances
    inline Registers* FTM1 = reinterpret_cast<Registers*>(FTM1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

}

// ============================================================================
// FTM2 Peripheral
// ============================================================================

namespace ftm2 {
    /// Base addresses
    constexpr uint32_t FTM2_BASE = 0x4003A000;

    /// FTM2 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM2 = reinterpret_cast<Registers*>(FTM2_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< no description available
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< Debug Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< no description available
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< no description available
        constexpr uint32_t SWOM = (1U << 10);  ///< no description available
        constexpr uint32_t SWINVC = (1U << 11);  ///< no description available
        constexpr uint32_t SWSOC = (1U << 12);  ///< no description available
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< no description available
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< no description available
        constexpr uint32_t HWOM = (1U << 18);  ///< no description available
        constexpr uint32_t HWINVC = (1U << 19);  ///< no description available
        constexpr uint32_t HWSOC = (1U << 20);  ///< no description available
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x4003B000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1;  ///< Offset: 0x00 - Status and Control Register 1
        volatile uint32_t SC2;  ///< Offset: 0x04 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x08 - Status and Control Register 3
        volatile uint32_t SC4;  ///< Offset: 0x0C - Status and Control Register 4
        volatile uint32_t R;  ///< Offset: 0x10 - Conversion Result Register
        volatile uint32_t CV;  ///< Offset: 0x14 - Compare Value Register
        volatile uint32_t APCTL1;  ///< Offset: 0x18 - Pin Control 1 Register
        volatile uint32_t SC5;  ///< Offset: 0x1C - Status and Control Register 5
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// SC1 Register bits
    namespace sc1_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input Channel Select
        constexpr uint32_t ADCO = (1U << 5);  ///< Continuous Conversion Enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage Reference Selection
        constexpr uint32_t FFULL = (1U << 2);  ///< Result FIFO full
        constexpr uint32_t FEMPTY = (1U << 3);  ///< Result FIFO empty
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion Mode Selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Long Sample Time Configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-Power Configuration
    }

    /// SC4 Register bits
    namespace sc4_bits {
        constexpr uint32_t AFDEP = (3 << 0);  ///< FIFO Depth
        constexpr uint32_t ACFSEL = (1U << 5);  ///< Compare Function Selection
        constexpr uint32_t ASCANE = (1U << 6);  ///< FIFO Scan Mode Enable
        constexpr uint32_t HTRGME = (1U << 8);  ///< Hardware Trigger Multiple Conversion Enable
    }

    /// R Register bits
    namespace r_bits {
        constexpr uint32_t ADR = (12 << 0);  ///< Conversion Result
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t CV = (12 << 0);  ///< Conversion Result[11:0]
    }

    /// APCTL1 Register bits
    namespace apctl1_bits {
        constexpr uint32_t ADPC = (16 << 0);  ///< ADC Pin Control
    }

    /// SC5 Register bits
    namespace sc5_bits {
        constexpr uint32_t HTRGMASKSEL = (1U << 0);  ///< Hardware Trigger Mask Mode Select
        constexpr uint32_t HTRGMASKE = (1U << 1);  ///< Hardware Trigger Mask Enable
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - RTC Status and Control Register
        volatile uint32_t MOD;  ///< Offset: 0x04 - RTC Modulo Register
        volatile uint32_t CNT;  ///< Offset: 0x08 - RTC Counter Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t RTCO = (1U << 4);  ///< Real-Time Counter Output
        constexpr uint32_t RTIE = (1U << 6);  ///< Real-Time Interrupt Enable
        constexpr uint32_t RTIF = (1U << 7);  ///< Real-Time Interrupt Flag
        constexpr uint32_t RTCPS = (3 << 8);  ///< Real-Time Clock Prescaler Select
        constexpr uint32_t RTCLKS = (2 << 14);  ///< Real-Time Clock Source Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< RTC Modulo
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< RTC Count
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40048000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SRSID;  ///< Offset: 0x00 - System Reset Status and ID Register
        volatile uint32_t SOPT0;  ///< Offset: 0x04 - System Options Register 0
        volatile uint32_t SOPT1;  ///< Offset: 0x08 - System Options Register
        volatile uint32_t PINSEL0;  ///< Offset: 0x0C - Pin Selection Register 0
        volatile uint32_t PINSEL1;  ///< Offset: 0x10 - Pin Selection Register 1
        volatile uint32_t SCGC;  ///< Offset: 0x14 - System Clock Gating Control Register
        volatile uint32_t UUIDL;  ///< Offset: 0x18 - Universally Unique Identifier Low Register
        volatile uint32_t UUIDML;  ///< Offset: 0x1C - Universally Unique Identifier Middle Low Register
        volatile uint32_t UUIDMH;  ///< Offset: 0x20 - Universally Unique Identifier Middle High Register
        volatile uint32_t CLKDIV;  ///< Offset: 0x24 - Clock Divider Register
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SRSID Register bits
    namespace srsid_bits {
        constexpr uint32_t LVD = (1U << 1);  ///< Low Voltage Detect
        constexpr uint32_t LOC = (1U << 2);  ///< Internal Clock Source Module Reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog (WDOG)
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
        constexpr uint32_t LOCKUP = (1U << 9);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 10);  ///< Software
        constexpr uint32_t MDMAP = (1U << 11);  ///< MDM-AP System Reset Request
        constexpr uint32_t SACKERR = (1U << 13);  ///< Stop Mode Acknowledge Error Reset
        constexpr uint32_t PINID = (4 << 16);  ///< Device Pin ID
        constexpr uint32_t RevID = (4 << 20);  ///< Device Revision Number
        constexpr uint32_t SUBFAMID = (4 << 24);  ///< Kinetis sub-family ID
        constexpr uint32_t FAMID = (4 << 28);  ///< Kinetis family ID
    }

    /// SOPT0 Register bits
    namespace sopt0_bits {
        constexpr uint32_t NMIE = (1U << 1);  ///< NMI Pin Enable
        constexpr uint32_t RSTPE = (1U << 2);  ///< RESET Pin Enable
        constexpr uint32_t SWDE = (1U << 3);  ///< Single Wire Debug Port Pin Enable
        constexpr uint32_t ACTRG = (1U << 5);  ///< ACMP Trigger FTM2 selection
        constexpr uint32_t RXDFE = (2 << 8);  ///< UART0 RxD Filter Select
        constexpr uint32_t RTCC = (1U << 10);  ///< Real-Time Counter Capture
        constexpr uint32_t ACIC = (1U << 11);  ///< Analog Comparator to Input Capture Enable
        constexpr uint32_t RXDCE = (1U << 12);  ///< UART0_RX Capture Select
        constexpr uint32_t FTMSYNC = (1U << 14);  ///< FTM2 Synchronization Select
        constexpr uint32_t TXDME = (1U << 15);  ///< UART0_TX Modulation Select
        constexpr uint32_t BUSREF = (3 << 16);  ///< BUS Clock Output select
        constexpr uint32_t CLKOE = (1U << 19);  ///< Bus Clock Output Enable
        constexpr uint32_t ADHWT = (3 << 20);  ///< ADC Hardware Trigger Source
        constexpr uint32_t DLYACT = (1U << 23);  ///< FTM2 Trigger Delay Active
        constexpr uint32_t DELAY = (8 << 24);  ///< FTM2 Trigger Delay
    }

    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t I2C04WEN = (1U << 0);  ///< I2C0 4-Wire Interface Enable
        constexpr uint32_t I2C0OINV = (1U << 1);  ///< I2C0 Output Invert
        constexpr uint32_t ACPWTS = (1U << 3);  ///< PWT ACMP_OUT select
        constexpr uint32_t UARTPWTS = (2 << 4);  ///< PWT UART RX select
    }

    /// PINSEL0 Register bits
    namespace pinsel0_bits {
        constexpr uint32_t IRQPS = (3 << 0);  ///< IRQ Port Pin Select
        constexpr uint32_t RTCPS = (1U << 4);  ///< RTCO Pin Select
        constexpr uint32_t I2C0PS = (1U << 5);  ///< I2C0 Port Pin Select
        constexpr uint32_t SPI0PS = (1U << 6);  ///< SPI0 Pin Select
        constexpr uint32_t UART0PS = (1U << 7);  ///< UART0 Pin Select
        constexpr uint32_t FTM0PS0 = (1U << 8);  ///< FTM0_CH0 Port Pin Select
        constexpr uint32_t FTM0PS1 = (1U << 9);  ///< FTM0_CH1 Port Pin Select
        constexpr uint32_t FTM1PS0 = (1U << 10);  ///< FTM1_CH0 Port Pin Select
        constexpr uint32_t FTM1PS1 = (1U << 11);  ///< FTM1_CH1 Port Pin Select
        constexpr uint32_t FTM0CLKPS = (2 << 24);  ///< FTM0 TCLK Pin Select
        constexpr uint32_t FTM1CLKPS = (2 << 26);  ///< FTM1 TCLK Pin Select
        constexpr uint32_t FTM2CLKPS = (2 << 28);  ///< FTM2 TCLK Pin Select
        constexpr uint32_t PWTCLKPS = (2 << 30);  ///< PWT TCLK Pin Select
    }

    /// PINSEL1 Register bits
    namespace pinsel1_bits {
        constexpr uint32_t FTM2PS0 = (2 << 0);  ///< FTM2 Channel 0 Pin Select
        constexpr uint32_t FTM2PS1 = (2 << 2);  ///< FTM2 Channel 1 Pin Select
        constexpr uint32_t FTM2PS2 = (2 << 4);  ///< FTM2 Channel 2 Pin Select
        constexpr uint32_t FTM2PS3 = (2 << 6);  ///< FTM2 Channel 3 Pin Select
        constexpr uint32_t FTM2PS4 = (1U << 8);  ///< FTM2 Channel4 Pin Select
        constexpr uint32_t FTM2PS5 = (1U << 9);  ///< FTM2 Channel 5 Pin Select
        constexpr uint32_t I2C1PS = (1U << 10);  ///< I2C1 Pin Select
        constexpr uint32_t SPI1PS = (1U << 11);  ///< SPI1 Pin Select
        constexpr uint32_t UART1PS = (1U << 12);  ///< UART1 Pin Select
        constexpr uint32_t UART2PS = (1U << 13);  ///< UART2 Pin Select
        constexpr uint32_t PWTIN0PS = (1U << 14);  ///< PWTIN0 Pin Select
        constexpr uint32_t PWTIN1PS = (1U << 15);  ///< PWTIN1 Pin Select
        constexpr uint32_t MSCANPS = (1U << 16);  ///< MSCAN Pin Select
    }

    /// SCGC Register bits
    namespace scgc_bits {
        constexpr uint32_t RTC = (1U << 0);  ///< RTC Clock Gate Control
        constexpr uint32_t PIT = (1U << 1);  ///< PIT Clock Gate Control
        constexpr uint32_t PWT = (1U << 4);  ///< PWT Clock Gate Control
        constexpr uint32_t FTM0 = (1U << 5);  ///< FTM0 Clock Gate Control
        constexpr uint32_t FTM1 = (1U << 6);  ///< FTM1 Clock Gate Control
        constexpr uint32_t FTM2 = (1U << 7);  ///< FTM2 Clock Gate Control
        constexpr uint32_t CRC = (1U << 10);  ///< CRC Clock Gate Control
        constexpr uint32_t FLASH = (1U << 12);  ///< Flash Clock Gate Control
        constexpr uint32_t SWD = (1U << 13);  ///< SWD (single wire debugger) Clock Gate Control
        constexpr uint32_t MSCAN = (1U << 15);  ///< MSCAN Clock Gate Control
        constexpr uint32_t I2C0 = (1U << 16);  ///< I2C0 Clock Gate Control
        constexpr uint32_t I2C1 = (1U << 17);  ///< I2C1 Clock Gate Control
        constexpr uint32_t SPI0 = (1U << 18);  ///< SPI0 Clock Gate Control
        constexpr uint32_t SPI1 = (1U << 19);  ///< SPI1 Clock Gate Control
        constexpr uint32_t UART0 = (1U << 20);  ///< UART0 Clock Gate Control
        constexpr uint32_t UART1 = (1U << 21);  ///< UART1 Clock Gate Control
        constexpr uint32_t UART2 = (1U << 22);  ///< UART2 Clock Gate Control
        constexpr uint32_t KBI0 = (1U << 24);  ///< KBI0 Clock Gate Control
        constexpr uint32_t KBI1 = (1U << 25);  ///< KBI1 Clock Gate Control
        constexpr uint32_t IRQ = (1U << 27);  ///< IRQ Clock Gate Control
        constexpr uint32_t ADC = (1U << 29);  ///< ADC Clock Gate Control
        constexpr uint32_t ACMP0 = (1U << 30);  ///< ACMP0 Clock Gate Control
        constexpr uint32_t ACMP1 = (1U << 31);  ///< ACMP1 Clock Gate Control
    }

    /// UUIDL Register bits
    namespace uuidl_bits {
        constexpr uint32_t ID = (32 << 0);  ///< Universally Unique Identifier
    }

    /// UUIDML Register bits
    namespace uuidml_bits {
        constexpr uint32_t ID = (32 << 0);  ///< Universally Unique Identifier
    }

    /// UUIDMH Register bits
    namespace uuidmh_bits {
        constexpr uint32_t ID = (16 << 0);  ///< Universally Unique Identifier
    }

    /// CLKDIV Register bits
    namespace clkdiv_bits {
        constexpr uint32_t OUTDIV3 = (1U << 20);  ///< Clock 3 output divider value
        constexpr uint32_t OUTDIV2 = (1U << 24);  ///< Clock 2 output divider value
        constexpr uint32_t OUTDIV1 = (2 << 28);  ///< Clock 1 output divider value
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT_BASE = 0x40049000;
    constexpr uint32_t GPIOA_BASE = 0x400FF000;
    constexpr uint32_t GPIOB_BASE = 0x400FF040;
    constexpr uint32_t GPIOC_BASE = 0x400FF080;
    constexpr uint32_t FGPIOA_BASE = 0xF8000000;
    constexpr uint32_t FGPIOB_BASE = 0xF8000040;
    constexpr uint32_t FGPIOC_BASE = 0xF8000080;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t IOFLT0;  ///< Offset: 0x00 - Port Filter Register 0
        volatile uint32_t IOFLT1;  ///< Offset: 0x04 - Port Filter Register 1
        volatile uint32_t PUE0;  ///< Offset: 0x08 - Port Pullup Enable Register 0
        volatile uint32_t PUE1;  ///< Offset: 0x0C - Port Pullup Enable Register 1
        volatile uint32_t PUE2;  ///< Offset: 0x10 - Port Pullup Enable Register 2
        volatile uint32_t HDRVE;  ///< Offset: 0x14 - Port High Drive Enable Register
    };

    /// Peripheral instances
    inline Registers* PORT = reinterpret_cast<Registers*>(PORT_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* FGPIOA = reinterpret_cast<Registers*>(FGPIOA_BASE);
    inline Registers* FGPIOB = reinterpret_cast<Registers*>(FGPIOB_BASE);
    inline Registers* FGPIOC = reinterpret_cast<Registers*>(FGPIOC_BASE);

    // Bit definitions
    /// IOFLT0 Register bits
    namespace ioflt0_bits {
        constexpr uint32_t FLTA = (2 << 0);  ///< Filter Selection for Input from PTA
        constexpr uint32_t FLTB = (2 << 2);  ///< Filter Selection for Input from PTB
        constexpr uint32_t FLTC = (2 << 4);  ///< Filter Selection for Input from PTC
        constexpr uint32_t FLTD = (2 << 6);  ///< Filter Selection for Input from PTD
        constexpr uint32_t FLTE = (2 << 8);  ///< Filter Selection for Input from PTD
        constexpr uint32_t FLTF = (2 << 10);  ///< Filter Selection for Input from PTF
        constexpr uint32_t FLTG = (2 << 12);  ///< Filter Selection for Input from PTG
        constexpr uint32_t FLTH = (2 << 14);  ///< Filter Selection for Input from PTH
        constexpr uint32_t FLTRST = (2 << 16);  ///< Filter Selection for Input from RESET/IRQ
        constexpr uint32_t FLTKBI0 = (2 << 18);  ///< Filter selection for Input from KBI0
        constexpr uint32_t FLTKBI1 = (2 << 20);  ///< Filter Selection for Input from KBI1
        constexpr uint32_t FLTNMI = (2 << 22);  ///< Filter Selection for Input from NMI
        constexpr uint32_t FLTDIV1 = (2 << 24);  ///< Filter Division Set 1
        constexpr uint32_t FLTDIV2 = (3 << 26);  ///< Filter Division Set 2
        constexpr uint32_t FLTDIV3 = (3 << 29);  ///< Filter Division Set 3
    }

    /// IOFLT1 Register bits
    namespace ioflt1_bits {
        constexpr uint32_t FLTI = (2 << 0);  ///< Filter Selection for Input from PTI
        constexpr uint32_t FLTIRQ = (2 << 4);  ///< Filter Selection for Input from IRQ
        constexpr uint32_t FLTFTM0 = (2 << 6);  ///< Filter Selection For Input from FTM0CH0/FTM0CH1
        constexpr uint32_t FLTFTM1 = (2 << 8);  ///< Filter Selection For Input from FTM1CH0/FTM1CH1
        constexpr uint32_t FLTPWT = (2 << 10);  ///< Filter Selection For Input from PWT_IN1/PWT_IN0
        constexpr uint32_t FLTI2C0 = (2 << 12);  ///< Filter Selection For Input from SCL0/SDA0
        constexpr uint32_t FLTI2C1 = (2 << 14);  ///< Filter Selection For Input from SCL1/SDA1
    }

    /// PUE0 Register bits
    namespace pue0_bits {
        constexpr uint32_t PTAPE0 = (1U << 0);  ///< Pull Enable for Port A Bit 0
        constexpr uint32_t PTAPE1 = (1U << 1);  ///< Pull Enable for Port A Bit 1
        constexpr uint32_t PTAPE2 = (1U << 2);  ///< Pull Enable for Port A Bit 2
        constexpr uint32_t PTAPE3 = (1U << 3);  ///< Pull Enable for Port A Bit 3
        constexpr uint32_t PTAPE4 = (1U << 4);  ///< Pull Enable for Port A Bit 4
        constexpr uint32_t PTAPE5 = (1U << 5);  ///< Pull Enable for Port A Bit 5
        constexpr uint32_t PTAPE6 = (1U << 6);  ///< Pull Enable for Port A Bit 6
        constexpr uint32_t PTAPE7 = (1U << 7);  ///< Pull Enable for Port A Bit 7
        constexpr uint32_t PTBPE0 = (1U << 8);  ///< Pull Enable for Port B Bit 0
        constexpr uint32_t PTBPE1 = (1U << 9);  ///< Pull Enable for Port B Bit 1
        constexpr uint32_t PTBPE2 = (1U << 10);  ///< Pull Enable for Port B Bit 2
        constexpr uint32_t PTBPE3 = (1U << 11);  ///< Pull Enable for Port B Bit 3
        constexpr uint32_t PTBPE4 = (1U << 12);  ///< Pull Enable for Port B Bit 4
        constexpr uint32_t PTBPE5 = (1U << 13);  ///< Pull Enable for Port B Bit 5
        constexpr uint32_t PTBPE6 = (1U << 14);  ///< Pull Enable for Port B Bit 6
        constexpr uint32_t PTBPE7 = (1U << 15);  ///< Pull Enable for Port B Bit 7
        constexpr uint32_t PTCPE0 = (1U << 16);  ///< Pull Enable for Port C Bit 0
        constexpr uint32_t PTCPE1 = (1U << 17);  ///< Pull Enable for Port C Bit 1
        constexpr uint32_t PTCPE2 = (1U << 18);  ///< Pull Enable for Port C Bit 2
        constexpr uint32_t PTCPE3 = (1U << 19);  ///< Pull Enable for Port C Bit 3
        constexpr uint32_t PTCPE4 = (1U << 20);  ///< Pull Enable for Port C Bit 4
        constexpr uint32_t PTCPE5 = (1U << 21);  ///< Pull Enable for Port C Bit 5
        constexpr uint32_t PTCPE6 = (1U << 22);  ///< Pull Enable for Port C Bit 6
        constexpr uint32_t PTCPE7 = (1U << 23);  ///< Pull Enable for Port C Bit 7
        constexpr uint32_t PTDPE0 = (1U << 24);  ///< Pull Enable for Port D Bit 0
        constexpr uint32_t PTDPE1 = (1U << 25);  ///< Pull Enable for Port D Bit 1
        constexpr uint32_t PTDPE2 = (1U << 26);  ///< Pull Enable for Port D Bit 2
        constexpr uint32_t PTDPE3 = (1U << 27);  ///< Pull Enable for Port D Bit 3
        constexpr uint32_t PTDPE4 = (1U << 28);  ///< Pull Enable for Port D Bit 4
        constexpr uint32_t PTDPE5 = (1U << 29);  ///< Pull Enable for Port D Bit 5
        constexpr uint32_t PTDPE6 = (1U << 30);  ///< Pull Enable for Port D Bit 6
        constexpr uint32_t PTDPE7 = (1U << 31);  ///< Pull Enable for Port D Bit 7
    }

    /// PUE1 Register bits
    namespace pue1_bits {
        constexpr uint32_t PTEPE0 = (1U << 0);  ///< Pull Enable for Port E Bit 0
        constexpr uint32_t PTEPE1 = (1U << 1);  ///< Pull Enable for Port E Bit 1
        constexpr uint32_t PTEPE2 = (1U << 2);  ///< Pull Enable for Port E Bit 2
        constexpr uint32_t PTEPE3 = (1U << 3);  ///< Pull Enable for Port E Bit 3
        constexpr uint32_t PTEPE4 = (1U << 4);  ///< Pull Enable for Port E Bit 4
        constexpr uint32_t PTEPE5 = (1U << 5);  ///< Pull Enable for Port E Bit 5
        constexpr uint32_t PTEPE6 = (1U << 6);  ///< Pull Enable for Port E Bit 6
        constexpr uint32_t PTEPE7 = (1U << 7);  ///< Pull Enable for Port E Bit 7
        constexpr uint32_t PTFPE0 = (1U << 8);  ///< Pull Enable for Port F Bit 0
        constexpr uint32_t PTFPE1 = (1U << 9);  ///< Pull Enable for Port F Bit 1
        constexpr uint32_t PTFPE2 = (1U << 10);  ///< Pull Enable for Port F Bit 2
        constexpr uint32_t PTFPE3 = (1U << 11);  ///< Pull Enable for Port F Bit 3
        constexpr uint32_t PTFPE4 = (1U << 12);  ///< Pull Enable for Port F Bit 4
        constexpr uint32_t PTFPE5 = (1U << 13);  ///< Pull Enable for Port F Bit 5
        constexpr uint32_t PTFPE6 = (1U << 14);  ///< Pull Enable for Port F Bit 6
        constexpr uint32_t PTFPE7 = (1U << 15);  ///< Pull Enable for Port F Bit 7
        constexpr uint32_t PTGPE0 = (1U << 16);  ///< Pull Enable for Port G Bit 0
        constexpr uint32_t PTGPE1 = (1U << 17);  ///< Pull Enable for Port G Bit 1
        constexpr uint32_t PTGPE2 = (1U << 18);  ///< Pull Enable for Port G Bit 2
        constexpr uint32_t PTGPE3 = (1U << 19);  ///< Pull Enable for Port G Bit 3
        constexpr uint32_t PTGPE4 = (1U << 20);  ///< Pull Enable for Port G Bit 4
        constexpr uint32_t PTGPE5 = (1U << 21);  ///< Pull Enable for Port G Bit 5
        constexpr uint32_t PTGPE6 = (1U << 22);  ///< Pull Enable for Port G Bit 6
        constexpr uint32_t PTGPE7 = (1U << 23);  ///< Pull Enable for Port G Bit 7
        constexpr uint32_t PTHPE0 = (1U << 24);  ///< Pull Enable for Port H Bit 0
        constexpr uint32_t PTHPE1 = (1U << 25);  ///< Pull Enable for Port H Bit 1
        constexpr uint32_t PTHPE2 = (1U << 26);  ///< Pull Enable for Port H Bit 2
        constexpr uint32_t PTHPE3 = (1U << 27);  ///< Pull Enable for Port H Bit 3
        constexpr uint32_t PTHPE4 = (1U << 28);  ///< Pull Enable for Port H Bit 4
        constexpr uint32_t PTHPE5 = (1U << 29);  ///< Pull Enable for Port H Bit 5
        constexpr uint32_t PTHPE6 = (1U << 30);  ///< Pull Enable for Port H Bit 6
        constexpr uint32_t PTHPE7 = (1U << 31);  ///< Pull Enable for Port H Bit 7
    }

    /// PUE2 Register bits
    namespace pue2_bits {
        constexpr uint32_t PTIPE0 = (1U << 0);  ///< Pull Enable for Port I Bit 0
        constexpr uint32_t PTIPE1 = (1U << 1);  ///< Pull Enable for Port I Bit 1
        constexpr uint32_t PTIPE2 = (1U << 2);  ///< Pull Enable for Port I Bit 2
        constexpr uint32_t PTIPE3 = (1U << 3);  ///< Pull Enable for Port I Bit 3
        constexpr uint32_t PTIPE4 = (1U << 4);  ///< Pull Enable for Port I Bit 4
        constexpr uint32_t PTIPE5 = (1U << 5);  ///< Pull Enable for Port I Bit 5
        constexpr uint32_t PTIPE6 = (1U << 6);  ///< Pull Enable for Port I Bit 6
    }

    /// HDRVE Register bits
    namespace hdrve_bits {
        constexpr uint32_t PTB4 = (1U << 0);  ///< High Current Drive Capability of PTB4
        constexpr uint32_t PTB5 = (1U << 1);  ///< High Current Drive Capability of PTB5
        constexpr uint32_t PTD0 = (1U << 2);  ///< High Current Drive Capability of PTD0
        constexpr uint32_t PTD1 = (1U << 3);  ///< High Current Drive Capability of PTD1
        constexpr uint32_t PTE0 = (1U << 4);  ///< High Current Drive Capability of PTE0
        constexpr uint32_t PTE1 = (1U << 5);  ///< High Current Drive Capability of PTE1
        constexpr uint32_t PTH0 = (1U << 6);  ///< High Current Drive Capability of PTH0
        constexpr uint32_t PTH1 = (1U << 7);  ///< High Current Drive Capability of PTH1
    }

}

// ============================================================================
// WDOG Peripheral
// ============================================================================

namespace wdog {
    /// Base addresses
    constexpr uint32_t WDOG_BASE = 0x40052000;

    /// WDOG Register structure
    struct Registers {
        volatile uint32_t CS1;  ///< Offset: 0x00 - Watchdog Control and Status Register 1
        volatile uint32_t CS2;  ///< Offset: 0x01 - Watchdog Control and Status Register 2
        volatile uint32_t CNT;  ///< Offset: 0x02 - Watchdog Counter Register.
        volatile uint32_t CNTH;  ///< Offset: 0x02 - Watchdog Counter Register: High
        volatile uint32_t CNTL;  ///< Offset: 0x03 - Watchdog Counter Register: Low
        volatile uint32_t TOVAL;  ///< Offset: 0x04 - Watchdog Timeout Value Register.
        volatile uint32_t TOVALH;  ///< Offset: 0x04 - Watchdog Timeout Value Register: High
        volatile uint32_t TOVALL;  ///< Offset: 0x05 - Watchdog Timeout Value Register: Low
        volatile uint32_t WIN;  ///< Offset: 0x06 - Watchdog Window Register.
        volatile uint32_t WINH;  ///< Offset: 0x06 - Watchdog Window Register: High
        volatile uint32_t WINL;  ///< Offset: 0x07 - Watchdog Window Register: Low
    };

    /// Peripheral instances
    inline Registers* WDOG = reinterpret_cast<Registers*>(WDOG_BASE);

    // Bit definitions
    /// CS1 Register bits
    namespace cs1_bits {
        constexpr uint32_t STOP = (1U << 0);  ///< Stop Enable
        constexpr uint32_t WAIT = (1U << 1);  ///< Wait Enable
        constexpr uint32_t DBG = (1U << 2);  ///< Debug Enable
        constexpr uint32_t TST = (2 << 3);  ///< Watchdog Test
        constexpr uint32_t UPDATE = (1U << 5);  ///< Allow updates
        constexpr uint32_t INT_ = (1U << 6);  ///< Watchdog Interrupt (renamed from INT_)
        constexpr uint32_t EN = (1U << 7);  ///< Watchdog Enable
    }

    /// CS2 Register bits
    namespace cs2_bits {
        constexpr uint32_t CLK = (2 << 0);  ///< Watchdog Clock
        constexpr uint32_t PRES = (1U << 4);  ///< Watchdog Prescalar
        constexpr uint32_t FLG = (1U << 6);  ///< Watchdog Interrupt Flag
        constexpr uint32_t WIN = (1U << 7);  ///< Watchdog Window
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Watchdog Counter Value
    }

    /// CNTH Register bits
    namespace cnth_bits {
        constexpr uint32_t CNTHIGH = (8 << 0);  ///< High byte of the Watchdog Counter
    }

    /// CNTL Register bits
    namespace cntl_bits {
        constexpr uint32_t CNTLOW = (8 << 0);  ///< Low byte of the Watchdog Counter
    }

    /// TOVAL Register bits
    namespace toval_bits {
        constexpr uint32_t TOVAL = (16 << 0);  ///< Watchdog Timeout Value
    }

    /// TOVALH Register bits
    namespace tovalh_bits {
        constexpr uint32_t TOVALHIGH = (8 << 0);  ///< High byte of the timeout value
    }

    /// TOVALL Register bits
    namespace tovall_bits {
        constexpr uint32_t TOVALLOW = (8 << 0);  ///< Low byte of the timeout value
    }

    /// WIN Register bits
    namespace win_bits {
        constexpr uint32_t WIN = (16 << 0);  ///< Watchdog Window Value
    }

    /// WINH Register bits
    namespace winh_bits {
        constexpr uint32_t WINHIGH = (8 << 0);  ///< High byte of Watchdog Window
    }

    /// WINL Register bits
    namespace winl_bits {
        constexpr uint32_t WINLOW = (8 << 0);  ///< Low byte of Watchdog Window
    }

}

// ============================================================================
// ICS Peripheral
// ============================================================================

namespace ics {
    /// Base addresses
    constexpr uint32_t ICS_BASE = 0x40064000;

    /// ICS Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - ICS Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x01 - ICS Control Register 2
        volatile uint32_t C3;  ///< Offset: 0x02 - ICS Control Register 3
        volatile uint32_t C4;  ///< Offset: 0x03 - ICS Control Register 4
        volatile uint32_t S;  ///< Offset: 0x04 - ICS Status Register
    };

    /// Peripheral instances
    inline Registers* ICS = reinterpret_cast<Registers*>(ICS_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t IREFS = (1U << 2);  ///< Internal Reference Select
        constexpr uint32_t RDIV = (3 << 3);  ///< Reference Divider
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t LP = (1U << 4);  ///< Low Power Select
        constexpr uint32_t BDIV = (3 << 5);  ///< Bus Frequency Divider
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t SCTRIM = (8 << 0);  ///< Slow Internal Reference Clock Trim Setting
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t SCFTRIM = (1U << 0);  ///< Slow Internal Reference Clock Fine Trim
        constexpr uint32_t CME = (1U << 5);  ///< Clock Monitor Enable
        constexpr uint32_t LOLIE = (1U << 7);  ///< Loss of Lock Interrupt
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
        constexpr uint32_t IREFST = (1U << 4);  ///< Internal Reference Status
        constexpr uint32_t LOCK = (1U << 6);  ///< Lock Status
        constexpr uint32_t LOLS = (1U << 7);  ///< Loss of Lock Status
    }

}

// ============================================================================
// OSC Peripheral
// ============================================================================

namespace osc {
    /// Base addresses
    constexpr uint32_t OSC_BASE = 0x40065000;

    /// OSC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OSC Control Register
    };

    /// Peripheral instances
    inline Registers* OSC = reinterpret_cast<Registers*>(OSC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t OSCINIT = (1U << 0);  ///< OSC Initialization
        constexpr uint32_t HGO = (1U << 1);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE = (1U << 2);  ///< Frequency Range Select
        constexpr uint32_t OSCOS = (1U << 4);  ///< OSC Output Select
        constexpr uint32_t OSCSTEN = (1U << 5);  ///< OSC Enable in Stop mode
        constexpr uint32_t OSCEN = (1U << 7);  ///< OSC Enable
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40066000;
    constexpr uint32_t I2C1_BASE = 0x40067000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S1;  ///< Offset: 0x03 - I2C Status register 1
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< ClockRate
        constexpr uint32_t MULT = (2 << 6);  ///< Multiplier Factor
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup Enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit Acknowledge Enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit Mode Select
        constexpr uint32_t MST = (1U << 5);  ///< Master Mode Select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C Interrupt Enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C Enable
    }

    /// S1 Register bits
    namespace s1_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive Acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt Flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave Read/Write
        constexpr uint32_t RAM = (1U << 3);  ///< Range Address Match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration Lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus Busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed As A Slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer Complete Flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave Address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range Address Matching Enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave Baud Rate Control
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address Extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General Call Address Enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (4 << 0);  ///< I2C Programmable Filter Factor
        constexpr uint32_t STARTF = (1U << 4);  ///< I2C Bus Start Detect Flag
        constexpr uint32_t SSIE = (1U << 5);  ///< I2C Bus Stop or Start Interrupt Enable
        constexpr uint32_t STOPF = (1U << 6);  ///< I2C Bus Stop Detect Flag
        constexpr uint32_t SHEN = (1U << 7);  ///< Stop Hold Enable
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RAD = (7 << 1);  ///< Range Slave Address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 Interrupt Enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL High Timeout Flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL High Timeout Flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL Low Timeout Flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout Counter Clock Select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C Address Enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus Alert Response Address Enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK Enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus Address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< no description available
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< no description available
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x4006A000;
    constexpr uint32_t UART1_BASE = 0x4006B000;
    constexpr uint32_t UART2_BASE = 0x4006C000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BDH;  ///< Offset: 0x00 - UART Baud Rate Register: High
        volatile uint32_t BDL;  ///< Offset: 0x01 - UART Baud Rate Register: Low
        volatile uint32_t C1;  ///< Offset: 0x02 - UART Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x03 - UART Control Register 2
        volatile uint32_t S1;  ///< Offset: 0x04 - UART Status Register 1
        volatile uint32_t S2;  ///< Offset: 0x05 - UART Status Register 2
        volatile uint32_t C3;  ///< Offset: 0x06 - UART Control Register 3
        volatile uint32_t D;  ///< Offset: 0x07 - UART Data Register
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);

    // Bit definitions
    /// BDH Register bits
    namespace bdh_bits {
        constexpr uint32_t SBR = (5 << 0);  ///< Baud Rate Modulo Divisor.
        constexpr uint32_t SBNS = (1U << 5);  ///< Stop Bit Number Select
        constexpr uint32_t RXEDGIE = (1U << 6);  ///< RxD Input Active Edge Interrupt Enable (for RXEDGIF)
        constexpr uint32_t LBKDIE = (1U << 7);  ///< LIN Break Detect Interrupt Enable (for LBKDIF)
    }

    /// BDL Register bits
    namespace bdl_bits {
        constexpr uint32_t SBR = (8 << 0);  ///< Baud Rate Modulo Divisor
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-Bit or 8-Bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t UARTSWAI = (1U << 6);  ///< UART Stops in Wait Mode
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t SBK = (1U << 0);  ///< Send Break
        constexpr uint32_t RWU = (1U << 1);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 2);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 4);  ///< Idle Line Interrupt Enable for IDLE
        constexpr uint32_t RIE = (1U << 5);  ///< Receiver Interrupt Enable for RDRF
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission Complete Interrupt Enable for TC
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable for TDRE
    }

    /// S1 Register bits
    namespace s1_bits {
        constexpr uint32_t PF = (1U << 0);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 1);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 2);  ///< Noise Flag
        constexpr uint32_t OR_ = (1U << 3);  ///< Receiver Overrun Flag (renamed from OR_)
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 6);  ///< Transmission Complete Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Register Empty Flag
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t RAF = (1U << 0);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 1);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 2);  ///< Break Character Generation Length
        constexpr uint32_t RWUID = (1U << 3);  ///< Receive Wake Up Idle Detect
        constexpr uint32_t RXINV = (1U << 4);  ///< Receive Data Inversion
        constexpr uint32_t RXEDGIF = (1U << 6);  ///< RxD Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 7);  ///< LIN Break Detect Interrupt Flag
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t PEIE = (1U << 0);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 1);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 2);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 3);  ///< Overrun Interrupt Enable
        constexpr uint32_t TXINV = (1U << 4);  ///< Transmit Data Inversion
        constexpr uint32_t TXDIR = (1U << 5);  ///< TxD Pin Direction in Single-Wire Mode
        constexpr uint32_t T8 = (1U << 6);  ///< Ninth Data Bit for Transmitter
        constexpr uint32_t R8 = (1U << 7);  ///< Ninth Data Bit for Receiver
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t R0T0 = (1U << 0);  ///< no description available
        constexpr uint32_t R1T1 = (1U << 1);  ///< no description available
        constexpr uint32_t R2T2 = (1U << 2);  ///< no description available
        constexpr uint32_t R3T3 = (1U << 3);  ///< no description available
        constexpr uint32_t R4T4 = (1U << 4);  ///< no description available
        constexpr uint32_t R5T5 = (1U << 5);  ///< no description available
        constexpr uint32_t R6T6 = (1U << 6);  ///< no description available
        constexpr uint32_t R7T7 = (1U << 7);  ///< no description available
    }

}

// ============================================================================
// ACMP0 Peripheral
// ============================================================================

namespace acmp0 {
    /// Base addresses
    constexpr uint32_t ACMP0_BASE = 0x40073000;

    /// ACMP0 Register structure
    struct Registers {
        volatile uint32_t CS;  ///< Offset: 0x00 - ACMP Control and Status Register
        volatile uint32_t C0;  ///< Offset: 0x01 - ACMP Control Register 0
        volatile uint32_t C1;  ///< Offset: 0x02 - ACMP Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x03 - ACMP Control Register 2
    };

    /// Peripheral instances
    inline Registers* ACMP0 = reinterpret_cast<Registers*>(ACMP0_BASE);

    // Bit definitions
    /// CS Register bits
    namespace cs_bits {
        constexpr uint32_t ACMOD = (2 << 0);  ///< ACMP MOD
        constexpr uint32_t ACOPE = (1U << 2);  ///< ACMP Output Pin Enable
        constexpr uint32_t ACO = (1U << 3);  ///< ACMP Output
        constexpr uint32_t ACIE = (1U << 4);  ///< ACMP Interrupt Enable
        constexpr uint32_t ACF = (1U << 5);  ///< ACMP Interrupt Flag Bit
        constexpr uint32_t HYST = (1U << 6);  ///< Analog Comparator Hysterisis Selection
        constexpr uint32_t ACE = (1U << 7);  ///< Analog Comparator Enable
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t ACNSEL = (2 << 0);  ///< ACMP Negative Input Select
        constexpr uint32_t ACPSEL = (2 << 4);  ///< ACMP Positive Input Select
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DACVAL = (6 << 0);  ///< DAC Output Level Selection
        constexpr uint32_t DACREF = (1U << 6);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t ACIPE = (3 << 0);  ///< ACMP Input Pin Enable
    }

}

// ============================================================================
// ACMP1 Peripheral
// ============================================================================

namespace acmp1 {
    /// Base addresses
    constexpr uint32_t ACMP1_BASE = 0x40074000;

    /// ACMP1 Register structure
    struct Registers {
        volatile uint32_t CS;  ///< Offset: 0x00 - ACMP Control and Status Register
        volatile uint32_t C0;  ///< Offset: 0x01 - ACMP Control Register 0
        volatile uint32_t C1;  ///< Offset: 0x02 - ACMP Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x03 - ACMP Control Register 2
    };

    /// Peripheral instances
    inline Registers* ACMP1 = reinterpret_cast<Registers*>(ACMP1_BASE);

    // Bit definitions
    /// CS Register bits
    namespace cs_bits {
        constexpr uint32_t ACMOD = (2 << 0);  ///< ACMP MOD
        constexpr uint32_t ACOPE = (1U << 2);  ///< ACMP Output Pin Enable
        constexpr uint32_t ACO = (1U << 3);  ///< ACMP Output
        constexpr uint32_t ACIE = (1U << 4);  ///< ACMP Interrupt Enable
        constexpr uint32_t ACF = (1U << 5);  ///< ACMP Interrupt Flag Bit
        constexpr uint32_t HYST = (1U << 6);  ///< Analog Comparator Hysterisis Selection
        constexpr uint32_t ACE = (1U << 7);  ///< Analog Comparator Enable
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t ACNSEL = (2 << 0);  ///< ACMP Negative Input Select
        constexpr uint32_t ACPSEL = (2 << 4);  ///< ACMP Positive Input Select
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DACVAL = (6 << 0);  ///< DAC Output Level Selection
        constexpr uint32_t DACREF = (1U << 6);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t ACIPE = (3 << 0);  ///< ACMP Input Pin Enable
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40076000;
    constexpr uint32_t SPI1_BASE = 0x40077000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - SPI Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x01 - SPI Control Register 2
        volatile uint32_t BR;  ///< Offset: 0x02 - SPI Baud Rate Register
        volatile uint32_t S;  ///< Offset: 0x03 - SPI Status Register
        volatile uint32_t D;  ///< Offset: 0x05 - SPI Data Register
        volatile uint32_t M;  ///< Offset: 0x07 - SPI Match Register
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t LSBFE = (1U << 0);  ///< LSB First (shifter direction)
        constexpr uint32_t SSOE = (1U << 1);  ///< Slave Select Output Enable
        constexpr uint32_t CPHA = (1U << 2);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 3);  ///< Clock Polarity
        constexpr uint32_t MSTR = (1U << 4);  ///< Master/Slave Mode Select
        constexpr uint32_t SPTIE = (1U << 5);  ///< SPI Transmit Interrupt Enable
        constexpr uint32_t SPE = (1U << 6);  ///< SPI System Enable
        constexpr uint32_t SPIE = (1U << 7);  ///< SPI Interrupt Enable: for SPRF and MODF
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t SPC0 = (1U << 0);  ///< SPI Pin Control 0
        constexpr uint32_t SPISWAI = (1U << 1);  ///< SPI Stop in Wait Mode
        constexpr uint32_t BIDIROE = (1U << 3);  ///< Bidirectional Mode Output Enable
        constexpr uint32_t MODFEN = (1U << 4);  ///< Master Mode-Fault Function Enable
        constexpr uint32_t SPMIE = (1U << 7);  ///< SPI Match Interrupt Enable
    }

    /// BR Register bits
    namespace br_bits {
        constexpr uint32_t SPR = (4 << 0);  ///< SPI Baud Rate Divisor
        constexpr uint32_t SPPR = (3 << 4);  ///< SPI Baud Rate Prescale Divisor
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t MODF = (1U << 4);  ///< Master Mode Fault Flag
        constexpr uint32_t SPTEF = (1U << 5);  ///< SPI Transmit Buffer Empty Flag
        constexpr uint32_t SPMF = (1U << 6);  ///< SPI Match Flag
        constexpr uint32_t SPRF = (1U << 7);  ///< SPI Read Buffer Full Flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Data (low byte)
    }

    /// M Register bits
    namespace m_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Hardware compare value (low byte)
    }

}

// ============================================================================
// KBI0 Peripheral
// ============================================================================

namespace kbi0 {
    /// Base addresses
    constexpr uint32_t KBI0_BASE = 0x40079000;

    /// KBI0 Register structure
    struct Registers {
        volatile uint32_t PE;  ///< Offset: 0x00 - KBI Pin Enable Register
        volatile uint32_t ES;  ///< Offset: 0x04 - KBI Edge Select Register
        volatile uint32_t SC;  ///< Offset: 0x08 - KBI Status and Control Register
        volatile uint32_t SP;  ///< Offset: 0x0C - KBI Source Pin Register
    };

    /// Peripheral instances
    inline Registers* KBI0 = reinterpret_cast<Registers*>(KBI0_BASE);

    // Bit definitions
    /// PE Register bits
    namespace pe_bits {
        constexpr uint32_t KBIPE = (32 << 0);  ///< KBI Pin Enables
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t KBEDG = (32 << 0);  ///< KBI Edge Selects
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t KBMOD = (1U << 0);  ///< KBI Detection Mode
        constexpr uint32_t KBIE = (1U << 1);  ///< KBI Interrupt Enable
        constexpr uint32_t KBACK = (1U << 2);  ///< KBI Acknowledge
        constexpr uint32_t KBF = (1U << 3);  ///< KBI Interrupt Flag
        constexpr uint32_t KBSPEN = (1U << 4);  ///< Real KBI_SP register enable
        constexpr uint32_t RSTKBSP = (1U << 5);  ///< Reset KBI_SP registe
    }

    /// SP Register bits
    namespace sp_bits {
        constexpr uint32_t SP = (32 << 0);  ///< KBI Source Pin
    }

}

// ============================================================================
// KBI1 Peripheral
// ============================================================================

namespace kbi1 {
    /// Base addresses
    constexpr uint32_t KBI1_BASE = 0x4007A000;

    /// KBI1 Register structure
    struct Registers {
        volatile uint32_t PE;  ///< Offset: 0x00 - KBI Pin Enable Register
        volatile uint32_t ES;  ///< Offset: 0x04 - KBI Edge Select Register
        volatile uint32_t SC;  ///< Offset: 0x08 - KBI Status and Control Register
        volatile uint32_t SP;  ///< Offset: 0x0C - KBI Source Pin Register
    };

    /// Peripheral instances
    inline Registers* KBI1 = reinterpret_cast<Registers*>(KBI1_BASE);

    // Bit definitions
    /// PE Register bits
    namespace pe_bits {
        constexpr uint32_t KBIPE = (32 << 0);  ///< KBI Pin Enables
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t KBEDG = (32 << 0);  ///< KBI Edge Selects
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t KBMOD = (1U << 0);  ///< KBI Detection Mode
        constexpr uint32_t KBIE = (1U << 1);  ///< KBI Interrupt Enable
        constexpr uint32_t KBACK = (1U << 2);  ///< KBI Acknowledge
        constexpr uint32_t KBF = (1U << 3);  ///< KBI Interrupt Flag
        constexpr uint32_t KBSPEN = (1U << 4);  ///< Real KBI_SP register enable
        constexpr uint32_t RSTKBSP = (1U << 5);  ///< Reset KBI_SP registe
    }

    /// SP Register bits
    namespace sp_bits {
        constexpr uint32_t SP = (32 << 0);  ///< KBI Source Pin
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t SPMSC1;  ///< Offset: 0x00 - System Power Management Status and Control 1 Register
        volatile uint32_t SPMSC2;  ///< Offset: 0x01 - System Power Management Status and Control 2 Register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// SPMSC1 Register bits
    namespace spmsc1_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t LVDE = (1U << 2);  ///< Low-Voltage Detect Enable
        constexpr uint32_t LVDSE = (1U << 3);  ///< Low-Voltage Detect Stop Enable
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// SPMSC2 Register bits
    namespace spmsc2_bits {
        constexpr uint32_t LVWV = (2 << 4);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVDV = (1U << 6);  ///< Low-Voltage Detect Voltage Select
    }

}

// ============================================================================
// SystemControl Peripheral
// ============================================================================

namespace systemcontrol {
    /// Base addresses
    constexpr uint32_t SystemControl_BASE = 0xE000E000;

    /// SystemControl Register structure
    struct Registers {
        volatile uint32_t ACTLR;  ///< Offset: 0x08 - Auxiliary Control Register,
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control and State Register
        volatile uint32_t VTOR;  ///< Offset: 0xD08 - Vector Table Offset Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt and Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration and Control Register
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
        volatile uint32_t DFSR;  ///< Offset: 0xD30 - Debug Fault Status Register
    };

    /// Peripheral instances
    inline Registers* SystemControl = reinterpret_cast<Registers*>(SystemControl_BASE);

    // Bit definitions
    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t REVISION = (4 << 0);  ///< Indicates patch release: 0x0 = Patch 0
        constexpr uint32_t PARTNO = (12 << 4);  ///< Indicates part number
        constexpr uint32_t VARIANT = (4 << 20);  ///< Indicates processor revision: 0x2 = Revision 2
        constexpr uint32_t IMPLEMENTER = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTPENDING = (6 << 12);  ///< Exception number of the highest priority pending enabled exception
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< no description available
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< no description available
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< no description available
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< no description available
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< no description available
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (25 << 7);  ///< Vector table base offset
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< no description available
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< no description available
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< no description available
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< no description available
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< no description available
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< no description available
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Always reads as one, indicates that all unaligned accesses generate a HardFault
        constexpr uint32_t STKALIGN = (1U << 9);  ///< Indicates stack alignment on exception entry
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (2 << 30);  ///< Priority of system handler 11, SVCall
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (2 << 22);  ///< Priority of system handler 14, PendSV
        constexpr uint32_t PRI_15 = (2 << 30);  ///< Priority of system handler 15, SysTick exception
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< no description available
    }

    /// DFSR Register bits
    namespace dfsr_bits {
        constexpr uint32_t HALTED = (1U << 0);  ///< no description available
        constexpr uint32_t BKPT = (1U << 1);  ///< no description available
        constexpr uint32_t DWTTRAP = (1U << 2);  ///< no description available
        constexpr uint32_t VCATCH = (1U << 3);  ///< no description available
        constexpr uint32_t EXTERNAL = (1U << 4);  ///< no description available
    }

}

// ============================================================================
// SysTick Peripheral
// ============================================================================

namespace systick {
    /// Base addresses
    constexpr uint32_t SysTick_BASE = 0xE000E010;

    /// SysTick Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - SysTick Control and Status Register
        volatile uint32_t RVR;  ///< Offset: 0x04 - SysTick Reload Value Register
        volatile uint32_t CVR;  ///< Offset: 0x08 - SysTick Current Value Register
        volatile uint32_t CALIB;  ///< Offset: 0x0C - SysTick Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* SysTick = reinterpret_cast<Registers*>(SysTick_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< no description available
        constexpr uint32_t TICKINT = (1U << 1);  ///< no description available
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< no description available
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< no description available
    }

    /// RVR Register bits
    namespace rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Value to load into the SysTick Current Value Register when the counter reaches 0
    }

    /// CVR Register bits
    namespace cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current value at the time the register is accessed
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Reload value to use for 10ms timing
        constexpr uint32_t SKEW = (1U << 30);  ///< no description available
        constexpr uint32_t NOREF = (1U << 31);  ///< no description available
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t NVIC_ISER;  ///< Offset: 0x00 - Interrupt Set Enable Register
        volatile uint32_t NVIC_ICER;  ///< Offset: 0x80 - Interrupt Clear Enable Register
        volatile uint32_t NVIC_ISPR;  ///< Offset: 0x100 - Interrupt Set Pending Register
        volatile uint32_t NVIC_ICPR;  ///< Offset: 0x180 - Interrupt Clear Pending Register
        volatile uint32_t NVIC_IPR0;  ///< Offset: 0x300 - Interrupt Priority Register 0
        volatile uint32_t NVIC_IPR1;  ///< Offset: 0x304 - Interrupt Priority Register 1
        volatile uint32_t NVIC_IPR2;  ///< Offset: 0x308 - Interrupt Priority Register 2
        volatile uint32_t NVIC_IPR3;  ///< Offset: 0x30C - Interrupt Priority Register 3
        volatile uint32_t NVIC_IPR4;  ///< Offset: 0x310 - Interrupt Priority Register 4
        volatile uint32_t NVIC_IPR5;  ///< Offset: 0x314 - Interrupt Priority Register 5
        volatile uint32_t NVIC_IPR6;  ///< Offset: 0x318 - Interrupt Priority Register 6
        volatile uint32_t NVIC_IPR7;  ///< Offset: 0x31C - Interrupt Priority Register 7
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

    // Bit definitions
    /// NVIC_ISER Register bits
    namespace nvic_iser_bits {
        constexpr uint32_t SETENA0 = (1U << 0);  ///< no description available
        constexpr uint32_t SETENA1 = (1U << 1);  ///< no description available
        constexpr uint32_t SETENA2 = (1U << 2);  ///< no description available
        constexpr uint32_t SETENA3 = (1U << 3);  ///< no description available
        constexpr uint32_t SETENA4 = (1U << 4);  ///< no description available
        constexpr uint32_t SETENA5 = (1U << 5);  ///< no description available
        constexpr uint32_t SETENA6 = (1U << 6);  ///< no description available
        constexpr uint32_t SETENA7 = (1U << 7);  ///< no description available
        constexpr uint32_t SETENA8 = (1U << 8);  ///< no description available
        constexpr uint32_t SETENA9 = (1U << 9);  ///< no description available
        constexpr uint32_t SETENA10 = (1U << 10);  ///< no description available
        constexpr uint32_t SETENA11 = (1U << 11);  ///< no description available
        constexpr uint32_t SETENA12 = (1U << 12);  ///< no description available
        constexpr uint32_t SETENA13 = (1U << 13);  ///< no description available
        constexpr uint32_t SETENA14 = (1U << 14);  ///< no description available
        constexpr uint32_t SETENA15 = (1U << 15);  ///< no description available
        constexpr uint32_t SETENA16 = (1U << 16);  ///< no description available
        constexpr uint32_t SETENA17 = (1U << 17);  ///< no description available
        constexpr uint32_t SETENA18 = (1U << 18);  ///< no description available
        constexpr uint32_t SETENA19 = (1U << 19);  ///< no description available
        constexpr uint32_t SETENA20 = (1U << 20);  ///< no description available
        constexpr uint32_t SETENA21 = (1U << 21);  ///< no description available
        constexpr uint32_t SETENA22 = (1U << 22);  ///< no description available
        constexpr uint32_t SETENA23 = (1U << 23);  ///< no description available
        constexpr uint32_t SETENA24 = (1U << 24);  ///< no description available
        constexpr uint32_t SETENA25 = (1U << 25);  ///< no description available
        constexpr uint32_t SETENA26 = (1U << 26);  ///< no description available
        constexpr uint32_t SETENA27 = (1U << 27);  ///< no description available
        constexpr uint32_t SETENA28 = (1U << 28);  ///< no description available
        constexpr uint32_t SETENA29 = (1U << 29);  ///< no description available
        constexpr uint32_t SETENA30 = (1U << 30);  ///< no description available
        constexpr uint32_t SETENA31 = (1U << 31);  ///< no description available
    }

    /// NVIC_ICER Register bits
    namespace nvic_icer_bits {
        constexpr uint32_t CLRENA0 = (1U << 0);  ///< no description available
        constexpr uint32_t CLRENA1 = (1U << 1);  ///< no description available
        constexpr uint32_t CLRENA2 = (1U << 2);  ///< no description available
        constexpr uint32_t CLRENA3 = (1U << 3);  ///< no description available
        constexpr uint32_t CLRENA4 = (1U << 4);  ///< no description available
        constexpr uint32_t CLRENA5 = (1U << 5);  ///< no description available
        constexpr uint32_t CLRENA6 = (1U << 6);  ///< no description available
        constexpr uint32_t CLRENA7 = (1U << 7);  ///< no description available
        constexpr uint32_t CLRENA8 = (1U << 8);  ///< no description available
        constexpr uint32_t CLRENA9 = (1U << 9);  ///< no description available
        constexpr uint32_t CLRENA10 = (1U << 10);  ///< no description available
        constexpr uint32_t CLRENA11 = (1U << 11);  ///< no description available
        constexpr uint32_t CLRENA12 = (1U << 12);  ///< no description available
        constexpr uint32_t CLRENA13 = (1U << 13);  ///< no description available
        constexpr uint32_t CLRENA14 = (1U << 14);  ///< no description available
        constexpr uint32_t CLRENA15 = (1U << 15);  ///< no description available
        constexpr uint32_t CLRENA16 = (1U << 16);  ///< no description available
        constexpr uint32_t CLRENA17 = (1U << 17);  ///< no description available
        constexpr uint32_t CLRENA18 = (1U << 18);  ///< no description available
        constexpr uint32_t CLRENA19 = (1U << 19);  ///< no description available
        constexpr uint32_t CLRENA20 = (1U << 20);  ///< no description available
        constexpr uint32_t CLRENA21 = (1U << 21);  ///< no description available
        constexpr uint32_t CLRENA22 = (1U << 22);  ///< no description available
        constexpr uint32_t CLRENA23 = (1U << 23);  ///< no description available
        constexpr uint32_t CLRENA24 = (1U << 24);  ///< no description available
        constexpr uint32_t CLRENA25 = (1U << 25);  ///< no description available
        constexpr uint32_t CLRENA26 = (1U << 26);  ///< no description available
        constexpr uint32_t CLRENA27 = (1U << 27);  ///< no description available
        constexpr uint32_t CLRENA28 = (1U << 28);  ///< no description available
        constexpr uint32_t CLRENA29 = (1U << 29);  ///< no description available
        constexpr uint32_t CLRENA30 = (1U << 30);  ///< no description available
        constexpr uint32_t CLRENA31 = (1U << 31);  ///< no description available
    }

    /// NVIC_ISPR Register bits
    namespace nvic_ispr_bits {
        constexpr uint32_t SETPEND0 = (1U << 0);  ///< no description available
        constexpr uint32_t SETPEND1 = (1U << 1);  ///< no description available
        constexpr uint32_t SETPEND2 = (1U << 2);  ///< no description available
        constexpr uint32_t SETPEND3 = (1U << 3);  ///< no description available
        constexpr uint32_t SETPEND4 = (1U << 4);  ///< no description available
        constexpr uint32_t SETPEND5 = (1U << 5);  ///< no description available
        constexpr uint32_t SETPEND6 = (1U << 6);  ///< no description available
        constexpr uint32_t SETPEND7 = (1U << 7);  ///< no description available
        constexpr uint32_t SETPEND8 = (1U << 8);  ///< no description available
        constexpr uint32_t SETPEND9 = (1U << 9);  ///< no description available
        constexpr uint32_t SETPEND10 = (1U << 10);  ///< no description available
        constexpr uint32_t SETPEND11 = (1U << 11);  ///< no description available
        constexpr uint32_t SETPEND12 = (1U << 12);  ///< no description available
        constexpr uint32_t SETPEND13 = (1U << 13);  ///< no description available
        constexpr uint32_t SETPEND14 = (1U << 14);  ///< no description available
        constexpr uint32_t SETPEND15 = (1U << 15);  ///< no description available
        constexpr uint32_t SETPEND16 = (1U << 16);  ///< no description available
        constexpr uint32_t SETPEND17 = (1U << 17);  ///< no description available
        constexpr uint32_t SETPEND18 = (1U << 18);  ///< no description available
        constexpr uint32_t SETPEND19 = (1U << 19);  ///< no description available
        constexpr uint32_t SETPEND20 = (1U << 20);  ///< no description available
        constexpr uint32_t SETPEND21 = (1U << 21);  ///< no description available
        constexpr uint32_t SETPEND22 = (1U << 22);  ///< no description available
        constexpr uint32_t SETPEND23 = (1U << 23);  ///< no description available
        constexpr uint32_t SETPEND24 = (1U << 24);  ///< no description available
        constexpr uint32_t SETPEND25 = (1U << 25);  ///< no description available
        constexpr uint32_t SETPEND26 = (1U << 26);  ///< no description available
        constexpr uint32_t SETPEND27 = (1U << 27);  ///< no description available
        constexpr uint32_t SETPEND28 = (1U << 28);  ///< no description available
        constexpr uint32_t SETPEND29 = (1U << 29);  ///< no description available
        constexpr uint32_t SETPEND30 = (1U << 30);  ///< no description available
        constexpr uint32_t SETPEND31 = (1U << 31);  ///< no description available
    }

    /// NVIC_ICPR Register bits
    namespace nvic_icpr_bits {
        constexpr uint32_t CLRPEND0 = (1U << 0);  ///< no description available
        constexpr uint32_t CLRPEND1 = (1U << 1);  ///< no description available
        constexpr uint32_t CLRPEND2 = (1U << 2);  ///< no description available
        constexpr uint32_t CLRPEND3 = (1U << 3);  ///< no description available
        constexpr uint32_t CLRPEND4 = (1U << 4);  ///< no description available
        constexpr uint32_t CLRPEND5 = (1U << 5);  ///< no description available
        constexpr uint32_t CLRPEND6 = (1U << 6);  ///< no description available
        constexpr uint32_t CLRPEND7 = (1U << 7);  ///< no description available
        constexpr uint32_t CLRPEND8 = (1U << 8);  ///< no description available
        constexpr uint32_t CLRPEND9 = (1U << 9);  ///< no description available
        constexpr uint32_t CLRPEND10 = (1U << 10);  ///< no description available
        constexpr uint32_t CLRPEND11 = (1U << 11);  ///< no description available
        constexpr uint32_t CLRPEND12 = (1U << 12);  ///< no description available
        constexpr uint32_t CLRPEND13 = (1U << 13);  ///< no description available
        constexpr uint32_t CLRPEND14 = (1U << 14);  ///< no description available
        constexpr uint32_t CLRPEND15 = (1U << 15);  ///< no description available
        constexpr uint32_t CLRPEND16 = (1U << 16);  ///< no description available
        constexpr uint32_t CLRPEND17 = (1U << 17);  ///< no description available
        constexpr uint32_t CLRPEND18 = (1U << 18);  ///< no description available
        constexpr uint32_t CLRPEND19 = (1U << 19);  ///< no description available
        constexpr uint32_t CLRPEND20 = (1U << 20);  ///< no description available
        constexpr uint32_t CLRPEND21 = (1U << 21);  ///< no description available
        constexpr uint32_t CLRPEND22 = (1U << 22);  ///< no description available
        constexpr uint32_t CLRPEND23 = (1U << 23);  ///< no description available
        constexpr uint32_t CLRPEND24 = (1U << 24);  ///< no description available
        constexpr uint32_t CLRPEND25 = (1U << 25);  ///< no description available
        constexpr uint32_t CLRPEND26 = (1U << 26);  ///< no description available
        constexpr uint32_t CLRPEND27 = (1U << 27);  ///< no description available
        constexpr uint32_t CLRPEND28 = (1U << 28);  ///< no description available
        constexpr uint32_t CLRPEND29 = (1U << 29);  ///< no description available
        constexpr uint32_t CLRPEND30 = (1U << 30);  ///< no description available
        constexpr uint32_t CLRPEND31 = (1U << 31);  ///< no description available
    }

    /// NVIC_IPR0 Register bits
    namespace nvic_ipr0_bits {
        constexpr uint32_t PRI_0 = (2 << 6);  ///< Priority of the Reserved iv 16 interrupt
        constexpr uint32_t PRI_1 = (2 << 14);  ///< Priority of the Reserved iv 17 interrupt
        constexpr uint32_t PRI_2 = (2 << 22);  ///< Priority of the Reserved iv 18 interrupt
        constexpr uint32_t PRI_3 = (2 << 30);  ///< Priority of the Reserved iv 19 interrupt
    }

    /// NVIC_IPR1 Register bits
    namespace nvic_ipr1_bits {
        constexpr uint32_t PRI_4 = (2 << 6);  ///< Priority of the Reserved iv 20 interrupt
        constexpr uint32_t PRI_5 = (2 << 14);  ///< Priority of the Command complete and read collision interrupt
        constexpr uint32_t PRI_6 = (2 << 22);  ///< Priority of the Low-voltage detect, low-voltage warning interrupt
        constexpr uint32_t PRI_7 = (2 << 30);  ///< Priority of the External Interrupt interrupt
    }

    /// NVIC_IPR2 Register bits
    namespace nvic_ipr2_bits {
        constexpr uint32_t PRI_8 = (2 << 6);  ///< Priority of the Inter-Integrated Circuit 0 interrupt
        constexpr uint32_t PRI_9 = (2 << 14);  ///< Priority of the Inter-Integrated Circuit 1 interrupt
        constexpr uint32_t PRI_10 = (2 << 22);  ///< Priority of the Serial Peripheral Interface 0 interrupt
        constexpr uint32_t PRI_11 = (2 << 30);  ///< Priority of the Serial Peripheral Interface 1 interrupt
    }

    /// NVIC_IPR3 Register bits
    namespace nvic_ipr3_bits {
        constexpr uint32_t PRI_12 = (2 << 6);  ///< Priority of the UART0 status and error interrupt
        constexpr uint32_t PRI_13 = (2 << 14);  ///< Priority of the UART1 status and error interrupt
        constexpr uint32_t PRI_14 = (2 << 22);  ///< Priority of the UART2 status and error interrupt
        constexpr uint32_t PRI_15 = (2 << 30);  ///< Priority of the Analog-to-Digital Converter 0 interrupt
    }

    /// NVIC_IPR4 Register bits
    namespace nvic_ipr4_bits {
        constexpr uint32_t PRI_16 = (2 << 6);  ///< Priority of the Analog comparator 0 interrupt interrupt
        constexpr uint32_t PRI_17 = (2 << 14);  ///< Priority of the FlexTimer Module 0 interrupt
        constexpr uint32_t PRI_18 = (2 << 22);  ///< Priority of the FlexTimer Module 1 interrupt
        constexpr uint32_t PRI_19 = (2 << 30);  ///< Priority of the FlexTimer Module 2 interrupt
    }

    /// NVIC_IPR5 Register bits
    namespace nvic_ipr5_bits {
        constexpr uint32_t PRI_20 = (2 << 6);  ///< Priority of the Real-time counter interrupt
        constexpr uint32_t PRI_21 = (2 << 14);  ///< Priority of the Analog comparator 1 interrupt interrupt
        constexpr uint32_t PRI_22 = (2 << 22);  ///< Priority of the Periodic timer overflow channel 0 interrupt
        constexpr uint32_t PRI_23 = (2 << 30);  ///< Priority of the Periodic timer overflow channel 1 interrupt
    }

    /// NVIC_IPR6 Register bits
    namespace nvic_ipr6_bits {
        constexpr uint32_t PRI_24 = (2 << 6);  ///< Priority of the Keyboard interrupt interrupt
        constexpr uint32_t PRI_25 = (2 << 14);  ///< Priority of the Keyboard interrupt interrupt
        constexpr uint32_t PRI_26 = (2 << 22);  ///< Priority of the Reserved iv 42 interrupt
        constexpr uint32_t PRI_27 = (2 << 30);  ///< Priority of the Clock loss of lock interrupt
    }

    /// NVIC_IPR7 Register bits
    namespace nvic_ipr7_bits {
        constexpr uint32_t PRI_28 = (2 << 6);  ///< Priority of the WDOG interrupt
        constexpr uint32_t PRI_29 = (2 << 14);  ///< Priority of the Pulse width timer interrupt
        constexpr uint32_t PRI_30 = (2 << 22);  ///< Priority of the Freescale's Scalable Controller Area Network Rx interrupt
        constexpr uint32_t PRI_31 = (2 << 30);  ///< Priority of the Freescale's Scalable Controller Area Network Tx and error interrupt
    }

}

// ============================================================================
// ROM Peripheral
// ============================================================================

namespace rom {
    /// Base addresses
    constexpr uint32_t ROM_BASE = 0xF0002000;

    /// ROM Register structure
    struct Registers {
        volatile uint32_t ENTRY;  ///< Offset: 0x00 - Entry
        volatile uint32_t TABLEMARK;  ///< Offset: 0x04 - End of Table Marker Register
        volatile uint32_t SYSACCESS;  ///< Offset: 0xFCC - System Access Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* ROM = reinterpret_cast<Registers*>(ROM_BASE);

    // Bit definitions
    /// ENTRY Register bits
    namespace entry_bits {
        constexpr uint32_t ENTRY = (32 << 0);  ///< ENTRY
    }

    /// TABLEMARK Register bits
    namespace tablemark_bits {
        constexpr uint32_t MARK = (32 << 0);  ///< no description available
    }

    /// SYSACCESS Register bits
    namespace sysaccess_bits {
        constexpr uint32_t SYSACCESS = (32 << 0);  ///< no description available
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< no description available
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xF0003000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t PLACR;  ///< Offset: 0x0C - Platform Control Register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
    }

    /// PLACR Register bits
    namespace placr_bits {
        constexpr uint32_t CFCC = (1U << 10);  ///< Clear Flash Controller Cache
        constexpr uint32_t DFCDA = (1U << 11);  ///< Disable Flash Controller Data Caching
        constexpr uint32_t DFCIC = (1U << 12);  ///< Disable Flash Controller Instruction Caching
        constexpr uint32_t DFCC = (1U << 13);  ///< Disable Flash Controller Cache
        constexpr uint32_t EFDS = (1U << 14);  ///< Enable Flash Data Speculation
        constexpr uint32_t DFCS = (1U << 15);  ///< Disable Flash Controller Speculation
        constexpr uint32_t ESFC = (1U << 16);  ///< Enable Stalling Flash Controller
    }

}


} // namespace alloy::generated::skeaz1284

#endif // ALLOY_GENERATED_SKEAZ1284_PERIPHERALS_HPP