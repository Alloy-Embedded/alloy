/// Auto-generated code for IMC300A
/// Generated by Alloy Code Generator
/// Source: infineon_imc300a.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:50
#ifndef ALLOY_GENERATED_IMC300A_PERIPHERALS_HPP
#define ALLOY_GENERATED_IMC300A_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::imc300a {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_ppb = true;
    constexpr uint32_t num_ppb_instances = 1;
    constexpr bool has_eru0 = true;
    constexpr uint32_t num_eru0_instances = 1;
    constexpr bool has_eru1 = true;
    constexpr uint32_t num_eru1_instances = 1;
    constexpr bool has_math = true;
    constexpr uint32_t num_math_instances = 1;
    constexpr bool has_pau = true;
    constexpr uint32_t num_pau_instances = 1;
    constexpr bool has_nvm = true;
    constexpr uint32_t num_nvm_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_usic0 = true;
    constexpr uint32_t num_usic0_instances = 3;
    constexpr bool has_usic1 = true;
    constexpr uint32_t num_usic1_instances = 2;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 4;
    constexpr bool has_scu = true;
    constexpr uint32_t num_scu_instances = 5;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_comp = true;
    constexpr uint32_t num_comp_instances = 1;
    constexpr bool has_ccu40 = true;
    constexpr uint32_t num_ccu40_instances = 5;
    constexpr bool has_ccu41 = true;
    constexpr uint32_t num_ccu41_instances = 5;
    constexpr bool has_posif1 = true;
    constexpr uint32_t num_posif1_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_shs = true;
    constexpr uint32_t num_shs_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 10;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 4;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct ppb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eru0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eru1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct math_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pau_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usic0_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct usic1_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct scu_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct comp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccu40_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct ccu41_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct posif1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct shs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 10;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 4;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 4;
    constexpr uint32_t max_gpio_pins = 64;  // 16 pins per port

    // USART-specific traits
}

// ============================================================================
// PPB Peripheral
// ============================================================================

namespace ppb {
    /// Base addresses
    constexpr uint32_t PPB_BASE = 0xE000E000;

    /// PPB Register structure
    struct Registers {
        volatile uint32_t SYST_CSR;  ///< Offset: 0x10 - SysTick Control and Status Register
        volatile uint32_t SYST_RVR;  ///< Offset: 0x14 - SysTick Reload Value Register
        volatile uint32_t SYST_CVR;  ///< Offset: 0x18 - SysTick Current Value Register
        volatile uint32_t SYST_CALIB;  ///< Offset: 0x1C - SysTick Calibration Value Register
        volatile uint32_t NVIC_ISER;  ///< Offset: 0x100 - Interrupt Set-enable Register
        volatile uint32_t NVIC_ICER;  ///< Offset: 0x180 - IInterrupt Clear-enable Register
        volatile uint32_t NVIC_ISPR;  ///< Offset: 0x200 - Interrupt Set-pending Register
        volatile uint32_t NVIC_ICPR;  ///< Offset: 0x280 - Interrupt Clear-pending Register
        volatile uint32_t NVIC_IPR0;  ///< Offset: 0x400 - Interrupt Priority Register 0
        volatile uint32_t NVIC_IPR1;  ///< Offset: 0x404 - Interrupt Priority Register 1
        volatile uint32_t NVIC_IPR2;  ///< Offset: 0x408 - Interrupt Priority Register 2
        volatile uint32_t NVIC_IPR3;  ///< Offset: 0x40C - Interrupt Priority Register 3
        volatile uint32_t NVIC_IPR4;  ///< Offset: 0x410 - Interrupt Priority Register 4
        volatile uint32_t NVIC_IPR5;  ///< Offset: 0x414 - Interrupt Priority Register 5
        volatile uint32_t NVIC_IPR6;  ///< Offset: 0x418 - Interrupt Priority Register 6
        volatile uint32_t NVIC_IPR7;  ///< Offset: 0x41C - Interrupt Priority Register 7
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control and State Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt and Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration and Control Register
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
    };

    /// Peripheral instances
    inline Registers* PPB = reinterpret_cast<Registers*>(PPB_BASE);

    // Bit definitions
    /// SYST_CSR Register bits
    namespace syst_csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Counter Enable
        constexpr uint32_t TICKINT = (1U << 1);  ///< SysTick Exception Request
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< Clock Source
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< Counter Flag
    }

    /// SYST_RVR Register bits
    namespace syst_rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Reload Value
    }

    /// SYST_CVR Register bits
    namespace syst_cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< SysTick Counter Current Value
    }

    /// SYST_CALIB Register bits
    namespace syst_calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< 10 Milliseconds
        constexpr uint32_t SKEW = (1U << 30);  ///< Clock Skew
        constexpr uint32_t NOREF = (1U << 31);  ///< Reference Clock
    }

    /// NVIC_ISER Register bits
    namespace nvic_iser_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt Node Set-enable
    }

    /// NVIC_ICER Register bits
    namespace nvic_icer_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt Node Clear-enable
    }

    /// NVIC_ISPR Register bits
    namespace nvic_ispr_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt Node Set-pending
    }

    /// NVIC_ICPR Register bits
    namespace nvic_icpr_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt Node Clear-pending
    }

    /// NVIC_IPR0 Register bits
    namespace nvic_ipr0_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR1 Register bits
    namespace nvic_ipr1_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR2 Register bits
    namespace nvic_ipr2_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR3 Register bits
    namespace nvic_ipr3_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR4 Register bits
    namespace nvic_ipr4_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR5 Register bits
    namespace nvic_ipr5_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR6 Register bits
    namespace nvic_ipr6_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR7 Register bits
    namespace nvic_ipr7_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t Revision = (4 << 0);  ///< Revision Number
        constexpr uint32_t PartNo = (12 << 4);  ///< Part Number of the Processor
        constexpr uint32_t Architecture = (4 << 16);  ///< Architecture
        constexpr uint32_t Variant = (4 << 20);  ///< Variant Number
        constexpr uint32_t Implementer = (8 << 24);  ///< Implementer Code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (6 << 0);  ///< Active Exception Number
        constexpr uint32_t VECTPENDING = (6 << 12);  ///< Pending Exception Number
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt Pending Flag
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick Exception Clear-pending
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick Exception Set-pending
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV Clear Pending
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV Set Pending
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< System Reset Request
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< Data Endianness
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Register Key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< Sleep-on-exit
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< Low Power Sleep Mode
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< Send Event on Pending bit
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Unaligned Access Traps
        constexpr uint32_t STKALIGN = (1U << 9);  ///< Stack Alignment
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of System Handler 11
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of System Handler 14
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of System Handler 15
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVCall Pending bit
    }

}

// ============================================================================
// ERU0 Peripheral
// ============================================================================

namespace eru0 {
    /// Base addresses
    constexpr uint32_t ERU0_BASE = 0x40010600;

    /// ERU0 Register structure
    struct Registers {
        volatile uint32_t EXISEL;  ///< Offset: 0x00 - Event Input Select
        volatile uint32_t EXICON__;  ///< Offset: 0x10 - Event Input Control (renamed from EXICON__)
        volatile uint32_t EXOCON__;  ///< Offset: 0x20 - Event Output Trigger Control (renamed from EXOCON__)
    };

    /// Peripheral instances
    inline Registers* ERU0 = reinterpret_cast<Registers*>(ERU0_BASE);

    // Bit definitions
    /// EXISEL Register bits
    namespace exisel_bits {
        constexpr uint32_t EXS0A = (2 << 0);  ///< Event Source Select for A0 (ERS0)
        constexpr uint32_t EXS0B = (2 << 2);  ///< Event Source Select for B0 (ERS0)
        constexpr uint32_t EXS1A = (2 << 4);  ///< Event Source Select for A1 (ERS1)
        constexpr uint32_t EXS1B = (2 << 6);  ///< Event Source Select for B1 (ERS1)
        constexpr uint32_t EXS2A = (2 << 8);  ///< Event Source Select for A2 (ERS2)
        constexpr uint32_t EXS2B = (2 << 10);  ///< Event Source Select for B2 (ERS2)
        constexpr uint32_t EXS3A = (2 << 12);  ///< Event Source Select for A3 (ERS3)
        constexpr uint32_t EXS3B = (2 << 14);  ///< Event Source Select for B3 (ERS3)
    }

    /// EXICON__ Register bits
    namespace exicon___bits {
        constexpr uint32_t PE = (1U << 0);  ///< Output Trigger Pulse Enable for ETLx
        constexpr uint32_t LD = (1U << 1);  ///< Rebuild Level Detection for Status Flag for ETLx
        constexpr uint32_t RE = (1U << 2);  ///< Rising Edge Detection Enable ETLx
        constexpr uint32_t FE = (1U << 3);  ///< Falling Edge Detection Enable ETLx
        constexpr uint32_t OCS = (3 << 4);  ///< Output Channel Select for ETLx Output Trigger Pulse
        constexpr uint32_t FL = (1U << 7);  ///< Status Flag for ETLx
        constexpr uint32_t SS = (2 << 8);  ///< Input Source Select for ERSx
        constexpr uint32_t NA = (1U << 10);  ///< Input A Negation Select for ERSx
        constexpr uint32_t NB = (1U << 11);  ///< Input B Negation Select for ERSx
    }

    /// EXOCON__ Register bits
    namespace exocon___bits {
        constexpr uint32_t ISS = (2 << 0);  ///< Internal Trigger Source Selection
        constexpr uint32_t GEEN = (1U << 2);  ///< Gating Event Enable
        constexpr uint32_t PDR = (1U << 3);  ///< Pattern Detection Result Flag
        constexpr uint32_t GP = (2 << 4);  ///< Gating Selection for Pattern Detection Result
        constexpr uint32_t IPEN0 = (1U << 12);  ///< Pattern Detection Enable for ETL0
        constexpr uint32_t IPEN1 = (1U << 13);  ///< Pattern Detection Enable for ETL1
        constexpr uint32_t IPEN2 = (1U << 14);  ///< Pattern Detection Enable for ETL2
        constexpr uint32_t IPEN3 = (1U << 15);  ///< Pattern Detection Enable for ETL3
    }

}

// ============================================================================
// ERU1 Peripheral
// ============================================================================

namespace eru1 {
    /// Base addresses
    constexpr uint32_t ERU1_BASE = 0x40010630;

    /// ERU1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ERU1 = reinterpret_cast<Registers*>(ERU1_BASE);

}

// ============================================================================
// MATH Peripheral
// ============================================================================

namespace math {
    /// Base addresses
    constexpr uint32_t MATH_BASE = 0x40030000;

    /// MATH Register structure
    struct Registers {
        volatile uint32_t GLBCON;  ///< Offset: 0x04 - Global Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t EVIER;  ///< Offset: 0x0C - Event Interrupt Enable Register
        volatile uint32_t EVFR;  ///< Offset: 0x10 - Event Flag Register
        volatile uint32_t EVFSR;  ///< Offset: 0x14 - Event Flag Set Register
        volatile uint32_t EVFCR;  ///< Offset: 0x18 - Event Flag Clear Register
        volatile uint32_t DVD;  ///< Offset: 0x20 - Dividend Register
        volatile uint32_t DVS;  ///< Offset: 0x24 - Divisor Register
        volatile uint32_t QUOT;  ///< Offset: 0x28 - Quotient Register
        volatile uint32_t RMD;  ///< Offset: 0x2C - Remainder Register
        volatile uint32_t DIVST;  ///< Offset: 0x30 - Divider Status Register
        volatile uint32_t DIVCON;  ///< Offset: 0x34 - Divider Control Register
        volatile uint32_t STATC;  ///< Offset: 0x40 - CORDIC Status and Data Control Register
        volatile uint32_t CON;  ///< Offset: 0x44 - CORDIC Control Register
        volatile uint32_t CORDX;  ///< Offset: 0x48 - CORDIC X Data Register
        volatile uint32_t CORDY;  ///< Offset: 0x4C - CORDIC Y Data Register
        volatile uint32_t CORDZ;  ///< Offset: 0x50 - CORDIC Z Data Register
        volatile uint32_t CORRX;  ///< Offset: 0x54 - CORDIC X Result Register
        volatile uint32_t CORRY;  ///< Offset: 0x58 - CORDIC Y Result Register
        volatile uint32_t CORRZ;  ///< Offset: 0x5C - CORDIC Z Result Register
    };

    /// Peripheral instances
    inline Registers* MATH = reinterpret_cast<Registers*>(MATH_BASE);

    // Bit definitions
    /// GLBCON Register bits
    namespace glbcon_bits {
        constexpr uint32_t DVDRC = (3 << 0);  ///< Dividend Register Result Chaining
        constexpr uint32_t DVSRC = (3 << 3);  ///< Divisor Register Result Chaining
        constexpr uint32_t CORDXRC = (2 << 6);  ///< CORDX Register Result Chaining
        constexpr uint32_t CORDYRC = (2 << 9);  ///< CORDY Register Result Chaining
        constexpr uint32_t CORDZRC = (2 << 12);  ///< CORDZ Register Result Chaining
        constexpr uint32_t SUSCFG = (2 << 16);  ///< Suspend Mode Configuration
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// EVIER Register bits
    namespace evier_bits {
        constexpr uint32_t DIVEOCIEN = (1U << 0);  ///< Divider End of Calculation Interrupt Enable
        constexpr uint32_t DIVERRIEN = (1U << 1);  ///< Divider Error Interrupt Enable
        constexpr uint32_t CDEOCIEN = (1U << 2);  ///< CORDIC End of Calculation Interrupt Enable
        constexpr uint32_t CDERRIEN = (1U << 3);  ///< CORDIC Error Interrupt Enable
    }

    /// EVFR Register bits
    namespace evfr_bits {
        constexpr uint32_t DIVEOC = (1U << 0);  ///< Divider End of Calculation Event Flag
        constexpr uint32_t DIVERR = (1U << 1);  ///< Divider Error Event Flag
        constexpr uint32_t CDEOC = (1U << 2);  ///< CORDIC End of Calculation Event Flag
        constexpr uint32_t CDERR = (1U << 3);  ///< CORDIC Error Event Flag
    }

    /// EVFSR Register bits
    namespace evfsr_bits {
        constexpr uint32_t DIVEOCS = (1U << 0);  ///< Divider End of Calculation Event Flag Set
        constexpr uint32_t DIVERRS = (1U << 1);  ///< Divider Error Event Flag Set
        constexpr uint32_t CDEOCS = (1U << 2);  ///< CORDIC Event Flag Set
        constexpr uint32_t CDERRS = (1U << 3);  ///< CORDIC Error Event Flag Set
    }

    /// EVFCR Register bits
    namespace evfcr_bits {
        constexpr uint32_t DIVEOCC = (1U << 0);  ///< Divider End of Calculation Event Flag Clear
        constexpr uint32_t DIVERRC = (1U << 1);  ///< Divider Error Event Flag Clear
        constexpr uint32_t CDEOCC = (1U << 2);  ///< CORDIC End of Calculation Event Flag Clear
        constexpr uint32_t CDERRC = (1U << 3);  ///< CORDIC Error Event Flag Clear
    }

    /// DVD Register bits
    namespace dvd_bits {
        constexpr uint32_t VAL = (32 << 0);  ///< Dividend Value
    }

    /// DVS Register bits
    namespace dvs_bits {
        constexpr uint32_t VAL = (32 << 0);  ///< Divisor Value
    }

    /// QUOT Register bits
    namespace quot_bits {
        constexpr uint32_t VAL = (32 << 0);  ///< Quotient Value
    }

    /// RMD Register bits
    namespace rmd_bits {
        constexpr uint32_t VAL = (32 << 0);  ///< Remainder Value
    }

    /// DIVST Register bits
    namespace divst_bits {
        constexpr uint32_t BSY = (1U << 0);  ///< Busy Indication
    }

    /// DIVCON Register bits
    namespace divcon_bits {
        constexpr uint32_t ST = (1U << 0);  ///< Start Bit
        constexpr uint32_t STMODE = (1U << 1);  ///< Start Mode
        constexpr uint32_t USIGN = (1U << 2);  ///< Unsigned Division Enable
        constexpr uint32_t DIVMODE = (2 << 3);  ///< Division Mode
        constexpr uint32_t QSDIR = (1U << 15);  ///< Quotient Shift Direction
        constexpr uint32_t QSCNT = (5 << 8);  ///< Quotient Shift Count
        constexpr uint32_t DVDSLC = (5 << 16);  ///< Dividend Shift Left Count
        constexpr uint32_t DVSSRC = (5 << 24);  ///< Divisor Shift Right Count
    }

    /// STATC Register bits
    namespace statc_bits {
        constexpr uint32_t BSY = (1U << 0);  ///< Busy Indication
        constexpr uint32_t KEEPX = (1U << 5);  ///< Last X Result as Initial Data for New Calculation
        constexpr uint32_t KEEPY = (1U << 6);  ///< Last Y Result as Initial Data for New Calculation
        constexpr uint32_t KEEPZ = (1U << 7);  ///< Last Z Result as Initial Data for New Calculation
    }

    /// CON Register bits
    namespace con_bits {
        constexpr uint32_t ST = (1U << 0);  ///< Start Calculation
        constexpr uint32_t MODE = (2 << 1);  ///< Operating Mode
        constexpr uint32_t ROTVEC = (1U << 3);  ///< Rotation Vectoring Selection
        constexpr uint32_t ST_MODE = (1U << 4);  ///< Start Method
        constexpr uint32_t X_USIGN = (1U << 5);  ///< Result Data Format for X in Circular Vectoring Mode
        constexpr uint32_t MPS = (2 << 6);  ///< X and Y Magnitude Prescaler
    }

    /// CORDX Register bits
    namespace cordx_bits {
        constexpr uint32_t DATA = (24 << 8);  ///< Initial X Parameter Data
    }

    /// CORDY Register bits
    namespace cordy_bits {
        constexpr uint32_t DATA = (24 << 8);  ///< Initial Y Parameter Data
    }

    /// CORDZ Register bits
    namespace cordz_bits {
        constexpr uint32_t DATA = (24 << 8);  ///< Initial Z Parameter Data
    }

    /// CORRX Register bits
    namespace corrx_bits {
        constexpr uint32_t RESULT = (24 << 8);  ///< X Calculation Result
    }

    /// CORRY Register bits
    namespace corry_bits {
        constexpr uint32_t RESULT = (24 << 8);  ///< Y Calculation Result
    }

    /// CORRZ Register bits
    namespace corrz_bits {
        constexpr uint32_t RESULT = (24 << 8);  ///< Z Calculation Result
    }

}

// ============================================================================
// PAU Peripheral
// ============================================================================

namespace pau {
    /// Base addresses
    constexpr uint32_t PAU_BASE = 0x40000000;

    /// PAU Register structure
    struct Registers {
        volatile uint32_t AVAIL0;  ///< Offset: 0x40 - Peripheral Availability Register 0
        volatile uint32_t AVAIL1;  ///< Offset: 0x44 - Peripheral Availability Register 1
        volatile uint32_t AVAIL2;  ///< Offset: 0x48 - Peripheral Availability Register 2
        volatile uint32_t PRIVDIS0;  ///< Offset: 0x80 - Peripheral Privilege Access Register 0
        volatile uint32_t PRIVDIS1;  ///< Offset: 0x84 - Peripheral Privilege Access Register 1
        volatile uint32_t PRIVDIS2;  ///< Offset: 0x88 - Peripheral Privilege Access Register 2
        volatile uint32_t ROMSIZE;  ///< Offset: 0x400 - ROM Size Register
        volatile uint32_t FLSIZE;  ///< Offset: 0x404 - Flash Size Register
        volatile uint32_t RAM0SIZE;  ///< Offset: 0x410 - RAM0 Size Register
    };

    /// Peripheral instances
    inline Registers* PAU = reinterpret_cast<Registers*>(PAU_BASE);

    // Bit definitions
    /// AVAIL0 Register bits
    namespace avail0_bits {
        constexpr uint32_t AVAIL5 = (1U << 5);  ///< RAM Block 1 Availability Flag
        constexpr uint32_t AVAIL6 = (1U << 6);  ///< RAM Block 2 Availability Flag
        constexpr uint32_t AVAIL7 = (1U << 7);  ///< RAM Block 3 Availability Flag
        constexpr uint32_t AVAIL20 = (1U << 20);  ///< MATH Global SFRs and Divider Availability Flag
        constexpr uint32_t AVAIL21 = (1U << 21);  ///< MATH CORDIC Availability Flag
        constexpr uint32_t AVAIL22 = (1U << 22);  ///< Port 0 Availability Flag
        constexpr uint32_t AVAIL23 = (1U << 23);  ///< Port 1 Availability Flag
        constexpr uint32_t AVAIL24 = (1U << 24);  ///< Port 2 Availability Flag
        constexpr uint32_t AVAIL25 = (1U << 25);  ///< Port 3 Availability Flag
        constexpr uint32_t AVAIL26 = (1U << 26);  ///< Port 4 Availability Flag
    }

    /// AVAIL1 Register bits
    namespace avail1_bits {
        constexpr uint32_t AVAIL0 = (1U << 0);  ///< USIC0 Channel 0 Availability Flag
        constexpr uint32_t AVAIL1 = (1U << 1);  ///< USIC0 Channel 1 Availability Flag
        constexpr uint32_t AVAIL4 = (1U << 4);  ///< PRNG Availability Flag
        constexpr uint32_t AVAIL5 = (1U << 5);  ///< ADC SFRs Availability Flag
        constexpr uint32_t AVAIL8 = (1U << 8);  ///< SHS Availability Flag
        constexpr uint32_t AVAIL9 = (1U << 9);  ///< CCU40 kernel SFRs and CC40 Availability Flag
        constexpr uint32_t AVAIL10 = (1U << 10);  ///< CCU40 CC41 Availability Flag
        constexpr uint32_t AVAIL11 = (1U << 11);  ///< CCU40 CC42 Availability Flag
        constexpr uint32_t AVAIL12 = (1U << 12);  ///< CCU40 CC43 Availability Flag
        constexpr uint32_t AVAIL16 = (1U << 16);  ///< USIC1 Channel 0 Availability Flag
        constexpr uint32_t AVAIL17 = (1U << 17);  ///< USIC1 Channel 1 Availability Flag
        constexpr uint32_t AVAIL25 = (1U << 25);  ///< CCU41 kernel SFRs and CC40 Availability Flag
        constexpr uint32_t AVAIL26 = (1U << 26);  ///< CCU41 CC41 Availability Flag
        constexpr uint32_t AVAIL27 = (1U << 27);  ///< CCU41 CC42 Availability Flag
        constexpr uint32_t AVAIL28 = (1U << 28);  ///< CCU41 CC43 Availability Flag
    }

    /// AVAIL2 Register bits
    namespace avail2_bits {
        constexpr uint32_t AVAIL0 = (1U << 0);  ///< CCU80 kernel SFRs and CC80 Availability Flag
        constexpr uint32_t AVAIL1 = (1U << 1);  ///< CCU80 CC81 Availability Flag
        constexpr uint32_t AVAIL2 = (1U << 2);  ///< CCU80 CC82 Availability Flag
        constexpr uint32_t AVAIL3 = (1U << 3);  ///< CCU80 CC83 Availability Flag
        constexpr uint32_t AVAIL12 = (1U << 12);  ///< POSIF0 Availability Flag
        constexpr uint32_t AVAIL15 = (1U << 15);  ///< DAC0 Availability Flag
        constexpr uint32_t AVAIL16 = (1U << 16);  ///< CCU81 kernel SFRs and CC80 Availability Flag
        constexpr uint32_t AVAIL17 = (1U << 17);  ///< CCU81 CC81 Availability Flag
        constexpr uint32_t AVAIL18 = (1U << 18);  ///< CCU81 CC82 Availability Flag
        constexpr uint32_t AVAIL19 = (1U << 19);  ///< CCU81 CC83 Availability Flag
        constexpr uint32_t AVAIL20 = (1U << 20);  ///< MultiCAN Node 0 and Global SFRs Availability Flag
        constexpr uint32_t AVAIL21 = (1U << 21);  ///< MultiCAN Node 1 Availability Flag
        constexpr uint32_t AVAIL23 = (1U << 23);  ///< MultiCAN Message Object SFRs Availability Flag
        constexpr uint32_t AVAIL28 = (1U << 28);  ///< POSIF1 Availability Flag
    }

    /// PRIVDIS0 Register bits
    namespace privdis0_bits {
        constexpr uint32_t PDIS2 = (1U << 2);  ///< Flash SFRs Privilege Disable Flag
        constexpr uint32_t PDIS5 = (1U << 5);  ///< RAM Block 1 Privilege Disable Flag
        constexpr uint32_t PDIS6 = (1U << 6);  ///< RAM Block 2 Privilege Disable Flag
        constexpr uint32_t PDIS7 = (1U << 7);  ///< RAM Block 3 Privilege Disable Flag
        constexpr uint32_t PDIS19 = (1U << 19);  ///< WDT Privilege Disable Flag
        constexpr uint32_t PDIS20 = (1U << 20);  ///< MATH Global SFRs and Divider Privilege Disable Flag
        constexpr uint32_t PDIS21 = (1U << 21);  ///< MATH CORDIC Privilege Disable Flag
        constexpr uint32_t PDIS22 = (1U << 22);  ///< Port 0 Privilege Disable Flag
        constexpr uint32_t PDIS23 = (1U << 23);  ///< Port 1 Privilege Disable Flag
        constexpr uint32_t PDIS24 = (1U << 24);  ///< Port 2 Privilege Disable Flag
        constexpr uint32_t PDIS25 = (1U << 25);  ///< Port 3 Privilege Disable Flag
        constexpr uint32_t PDIS26 = (1U << 26);  ///< Port 4 Privilege Disable Flag
    }

    /// PRIVDIS1 Register bits
    namespace privdis1_bits {
        constexpr uint32_t PDIS0 = (1U << 0);  ///< USIC0 Channel 0 Privilege Disable Flag
        constexpr uint32_t PDIS1 = (1U << 1);  ///< USIC0 Channel 1 Privilege Disable Flag
        constexpr uint32_t PDIS5 = (1U << 5);  ///< ADC SFRs Privilege Disable Flag
        constexpr uint32_t PDIS8 = (1U << 8);  ///< SHS Privilege Disable Flag
        constexpr uint32_t PDIS9 = (1U << 9);  ///< CC40 and CCU40 Kernel SFRs Privilege Disable Flag
        constexpr uint32_t PDIS10 = (1U << 10);  ///< CCU40 CC41 Privilege Disable Flag
        constexpr uint32_t PDIS11 = (1U << 11);  ///< CCU40 CC42 Privilege Disable Flag
        constexpr uint32_t PDIS12 = (1U << 12);  ///< CCU40 CC43 Privilege Disable Flag
        constexpr uint32_t PDIS16 = (1U << 16);  ///< USIC1 Channel 0 Privilege Disable Flag
        constexpr uint32_t PDIS17 = (1U << 17);  ///< USIC1 Channel 1 Privilege Disable Flag
        constexpr uint32_t PDIS25 = (1U << 25);  ///< CCU41 Kernel SFRs and CC40 Privilege Disable Flag
        constexpr uint32_t PDIS26 = (1U << 26);  ///< CCU41 CC41 Privilege Disable Flag
        constexpr uint32_t PDIS27 = (1U << 27);  ///< CCU41 CC42 Privilege Disable Flag
        constexpr uint32_t PDIS28 = (1U << 28);  ///< CCU41 CC43 Privilege Disable Flag
    }

    /// PRIVDIS2 Register bits
    namespace privdis2_bits {
        constexpr uint32_t PDIS0 = (1U << 0);  ///< CC80 and CCU80 Kernel SFRs Privilege Disable Flag
        constexpr uint32_t PDIS1 = (1U << 1);  ///< CCU80 CC81 Privilege Disable Flag
        constexpr uint32_t PDIS2 = (1U << 2);  ///< CCU80 CC82 Privilege Disable Flag
        constexpr uint32_t PDIS3 = (1U << 3);  ///< CCU80 CC83 Privilege Disable Flag
        constexpr uint32_t PDIS12 = (1U << 12);  ///< POSIF0 Privilege Disable Flag
        constexpr uint32_t PDIS15 = (1U << 15);  ///< DAC0 Privilege Disable Flag
        constexpr uint32_t PDIS16 = (1U << 16);  ///< CCU81 Kernel SFRs and CC80 Privilege Disable Flag
        constexpr uint32_t PDIS17 = (1U << 17);  ///< CCU81 CC81 Privilege Disable Flag
        constexpr uint32_t PDIS18 = (1U << 18);  ///< CCU81 CC82 Privilege Disable Flag
        constexpr uint32_t PDIS19 = (1U << 19);  ///< CCU81 CC83 Privilege Disable Flag
        constexpr uint32_t PDIS20 = (1U << 20);  ///< MultiCAN Node 0 and Global SFRs Privilege Disable Flag
        constexpr uint32_t PDIS21 = (1U << 21);  ///< MultiCAN Node 1 Privilege Disable Flag
        constexpr uint32_t PDIS23 = (1U << 23);  ///< MultiCAN Message Object SFRs Privilege Disable Flag
        constexpr uint32_t PDIS28 = (1U << 28);  ///< POSIF1 Privilege Disable Flag
    }

    /// ROMSIZE Register bits
    namespace romsize_bits {
        constexpr uint32_t ADDR = (6 << 8);  ///< ROM Size
    }

    /// FLSIZE Register bits
    namespace flsize_bits {
        constexpr uint32_t ADDR = (6 << 12);  ///< Flash Size
    }

    /// RAM0SIZE Register bits
    namespace ram0size_bits {
        constexpr uint32_t ADDR = (5 << 8);  ///< RAM0 Size
    }

}

// ============================================================================
// NVM Peripheral
// ============================================================================

namespace nvm {
    /// Base addresses
    constexpr uint32_t NVM_BASE = 0x40050000;

    /// NVM Register structure
    struct Registers {
        volatile uint32_t NVMSTATUS;  ///< Offset: 0x00 - NVM Status Register
        volatile uint32_t NVMPROG;  ///< Offset: 0x04 - NVM Programming Control Register
        volatile uint32_t NVMCONF;  ///< Offset: 0x08 - NVM Configuration Register
    };

    /// Peripheral instances
    inline Registers* NVM = reinterpret_cast<Registers*>(NVM_BASE);

    // Bit definitions
    /// NVMSTATUS Register bits
    namespace nvmstatus_bits {
        constexpr uint32_t WRPERR = (1U << 6);  ///< Write Protocol Error
        constexpr uint32_t ECC2READ = (1U << 5);  ///< ECC2 Read
        constexpr uint32_t ECC1READ = (1U << 4);  ///< ECC1 Read
        constexpr uint32_t VERR = (2 << 2);  ///< Verify Error
        constexpr uint32_t SLEEP = (1U << 1);  ///< Sleep Mode
        constexpr uint32_t BUSY = (1U << 0);  ///< Busy
    }

    /// NVMPROG Register bits
    namespace nvmprog_bits {
        constexpr uint32_t RSTECC = (1U << 13);  ///< Reset ECC
        constexpr uint32_t RSTVERR = (1U << 12);  ///< Reset Verify Error
        constexpr uint32_t ACTION = (8 << 0);  ///< ACTION: [VERIFY, ONE_SHOT, OPTYPE]
    }

    /// NVMCONF Register bits
    namespace nvmconf_bits {
        constexpr uint32_t NVM_ON = (1U << 15);  ///< NVM On
        constexpr uint32_t INT_ON = (1U << 14);  ///< Interrupt On
        constexpr uint32_t SECPROT = (8 << 4);  ///< Sector Protection
        constexpr uint32_t HRLEV = (2 << 1);  ///< Hardread Level
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40020000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - WDT Module ID Register
        volatile uint32_t CTR;  ///< Offset: 0x04 - WDT Control Register
        volatile uint32_t SRV;  ///< Offset: 0x08 - WDT Service Register
        volatile uint32_t TIM;  ///< Offset: 0x0C - WDT Timer Register
        volatile uint32_t WLB;  ///< Offset: 0x10 - WDT Window Lower Bound Register
        volatile uint32_t WUB;  ///< Offset: 0x14 - WDT Window Upper Bound Register
        volatile uint32_t WDTSTS;  ///< Offset: 0x18 - WDT Status Register
        volatile uint32_t WDTCLR;  ///< Offset: 0x1C - WDT Clear Register
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t ENB = (1U << 0);  ///< Enable
        constexpr uint32_t PRE = (1U << 1);  ///< Pre-warning
        constexpr uint32_t DSP = (1U << 4);  ///< Debug Suspend
        constexpr uint32_t SPW = (8 << 8);  ///< Service Indication Pulse Width
    }

    /// SRV Register bits
    namespace srv_bits {
        constexpr uint32_t SRV = (32 << 0);  ///< Service
    }

    /// TIM Register bits
    namespace tim_bits {
        constexpr uint32_t TIM = (32 << 0);  ///< Timer Value
    }

    /// WLB Register bits
    namespace wlb_bits {
        constexpr uint32_t WLB = (32 << 0);  ///< Window Lower Bound
    }

    /// WUB Register bits
    namespace wub_bits {
        constexpr uint32_t WUB = (32 << 0);  ///< Window Upper Bound
    }

    /// WDTSTS Register bits
    namespace wdtsts_bits {
        constexpr uint32_t ALMS = (1U << 0);  ///< Pre-warning Alarm
    }

    /// WDTCLR Register bits
    namespace wdtclr_bits {
        constexpr uint32_t ALMC = (1U << 0);  ///< Pre-warning Alarm
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40010A00;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - RTC Module ID Register
        volatile uint32_t CTR;  ///< Offset: 0x04 - RTC Control Register
        volatile uint32_t RAWSTAT;  ///< Offset: 0x08 - RTC Raw Service Request Register
        volatile uint32_t STSSR;  ///< Offset: 0x0C - RTC Service Request Status Register
        volatile uint32_t MSKSR;  ///< Offset: 0x10 - RTC Service Request Mask Register
        volatile uint32_t CLRSR;  ///< Offset: 0x14 - RTC Clear Service Request Register
        volatile uint32_t ATIM0;  ///< Offset: 0x18 - RTC Alarm Time Register 0
        volatile uint32_t ATIM1;  ///< Offset: 0x1C - RTC Alarm Time Register 1
        volatile uint32_t TIM0;  ///< Offset: 0x20 - RTC Time Register 0
        volatile uint32_t TIM1;  ///< Offset: 0x24 - RTC Time Register 1
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t ENB = (1U << 0);  ///< RTC Module Enable
        constexpr uint32_t SUS = (1U << 1);  ///< Debug Suspend Control
        constexpr uint32_t DIV = (16 << 16);  ///< Divider Value
    }

    /// RAWSTAT Register bits
    namespace rawstat_bits {
        constexpr uint32_t RPSE = (1U << 0);  ///< Raw Periodic Seconds Service Request
        constexpr uint32_t RPMI = (1U << 1);  ///< Raw Periodic Minutes Service Request
        constexpr uint32_t RPHO = (1U << 2);  ///< Raw Periodic Hours Service Request
        constexpr uint32_t RPDA = (1U << 3);  ///< Raw Periodic Days Service Request
        constexpr uint32_t RPMO = (1U << 5);  ///< Raw Periodic Months Service Request
        constexpr uint32_t RPYE = (1U << 6);  ///< Raw Periodic Years Service Request
        constexpr uint32_t RAI = (1U << 8);  ///< Alarm Service Request
    }

    /// STSSR Register bits
    namespace stssr_bits {
        constexpr uint32_t SPSE = (1U << 0);  ///< Periodic Seconds Service Request Status after masking
        constexpr uint32_t SPMI = (1U << 1);  ///< Periodic Minutes Service Request Status after masking
        constexpr uint32_t SPHO = (1U << 2);  ///< Periodic Hours Service Request Status after masking
        constexpr uint32_t SPDA = (1U << 3);  ///< Periodic Days Service Request Status after masking
        constexpr uint32_t SPMO = (1U << 5);  ///< Periodic Months Service Request Status after masking
        constexpr uint32_t SPYE = (1U << 6);  ///< Periodic Years Service Request Status after masking
        constexpr uint32_t SAI = (1U << 8);  ///< Alarm Service Request Status after masking
    }

    /// MSKSR Register bits
    namespace msksr_bits {
        constexpr uint32_t MPSE = (1U << 0);  ///< Periodic Seconds Interrupt Mask
        constexpr uint32_t MPMI = (1U << 1);  ///< Periodic Minutes Interrupt Mask
        constexpr uint32_t MPHO = (1U << 2);  ///< Periodic Hours Interrupt Mask
        constexpr uint32_t MPDA = (1U << 3);  ///< Periodic Days Interrupt Mask
        constexpr uint32_t MPMO = (1U << 5);  ///< Periodic Months Interrupt Mask
        constexpr uint32_t MPYE = (1U << 6);  ///< Periodic Years Interrupt Mask
        constexpr uint32_t MAI = (1U << 8);  ///< Alarm Interrupt Mask
    }

    /// CLRSR Register bits
    namespace clrsr_bits {
        constexpr uint32_t RPSE = (1U << 0);  ///< Raw Periodic Seconds Interrupt Clear
        constexpr uint32_t RPMI = (1U << 1);  ///< Raw Periodic Minutes Interrupt Clear
        constexpr uint32_t RPHO = (1U << 2);  ///< Raw Periodic Hours Interrupt Clear
        constexpr uint32_t RPDA = (1U << 3);  ///< Raw Periodic Days Interrupt Clear
        constexpr uint32_t RPMO = (1U << 5);  ///< Raw Periodic Months Interrupt Clear
        constexpr uint32_t RPYE = (1U << 6);  ///< Raw Periodic Years Interrupt Clear
        constexpr uint32_t RAI = (1U << 8);  ///< Raw Alarm Interrupt Clear
    }

    /// ATIM0 Register bits
    namespace atim0_bits {
        constexpr uint32_t ASE = (6 << 0);  ///< Alarm Seconds Compare Value
        constexpr uint32_t AMI = (6 << 8);  ///< Alarm Minutes Compare Value
        constexpr uint32_t AHO = (5 << 16);  ///< Alarm Hours Compare Value
        constexpr uint32_t ADA = (5 << 24);  ///< Alarm Days Compare Value
    }

    /// ATIM1 Register bits
    namespace atim1_bits {
        constexpr uint32_t AMO = (4 << 8);  ///< Alarm Month Compare Value
        constexpr uint32_t AYE = (16 << 16);  ///< Alarm Year Compare Value
    }

    /// TIM0 Register bits
    namespace tim0_bits {
        constexpr uint32_t SE = (6 << 0);  ///< Seconds Time Value
        constexpr uint32_t MI = (6 << 8);  ///< Minutes Time Value
        constexpr uint32_t HO = (5 << 16);  ///< Hours Time Value
        constexpr uint32_t DA = (5 << 24);  ///< Days Time Value
    }

    /// TIM1 Register bits
    namespace tim1_bits {
        constexpr uint32_t DAWE = (3 << 0);  ///< Days of Week Time Value
        constexpr uint32_t MO = (4 << 8);  ///< Month Time Value
        constexpr uint32_t YE = (16 << 16);  ///< Year Time Value
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t PRNG_BASE = 0x48020000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t WORD;  ///< Offset: 0x00 - PRNG Word Register
        volatile uint32_t CHK;  ///< Offset: 0x04 - PRNG Status Check Register
        volatile uint32_t CTRL;  ///< Offset: 0x0C - PRNG Control Register
    };

    /// Peripheral instances
    inline Registers* PRNG = reinterpret_cast<Registers*>(PRNG_BASE);

    // Bit definitions
    /// WORD Register bits
    namespace word_bits {
        constexpr uint32_t RDATA = (16 << 0);  ///< Random Data
    }

    /// CHK Register bits
    namespace chk_bits {
        constexpr uint32_t RDV = (1U << 0);  ///< Random Data / Key Valid Flag
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t KLD = (1U << 3);  ///< Key Load Operation Mode
        constexpr uint32_t RDBS = (2 << 1);  ///< Random Data Block Size
    }

}

// ============================================================================
// USIC0 Peripheral
// ============================================================================

namespace usic0 {
    /// Base addresses
    constexpr uint32_t USIC0_BASE = 0x48000008;
    constexpr uint32_t USIC0_CH0_BASE = 0x48000000;
    constexpr uint32_t USIC0_CH1_BASE = 0x48000200;

    /// USIC0 Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - Module Identification Register
    };

    /// Peripheral instances
    inline Registers* USIC0 = reinterpret_cast<Registers*>(USIC0_BASE);
    inline Registers* USIC0_CH0 = reinterpret_cast<Registers*>(USIC0_CH0_BASE);
    inline Registers* USIC0_CH1 = reinterpret_cast<Registers*>(USIC0_CH1_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

}

// ============================================================================
// USIC1 Peripheral
// ============================================================================

namespace usic1 {
    /// Base addresses
    constexpr uint32_t USIC1_BASE = 0x48004008;
    constexpr uint32_t USIC1_CH0_BASE = 0x48004000;

    /// USIC1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* USIC1 = reinterpret_cast<Registers*>(USIC1_BASE);
    inline Registers* USIC1_CH0 = reinterpret_cast<Registers*>(USIC1_CH0_BASE);

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN_BASE = 0x50040000;
    constexpr uint32_t CAN_NODE0_BASE = 0x50040200;
    constexpr uint32_t CAN_NODE1_BASE = 0x50040300;
    constexpr uint32_t CAN_MO_BASE = 0x50041000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t CLC;  ///< Offset: 0x00 - CAN Clock Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t FDR;  ///< Offset: 0x0C - CAN Fractional Divider Register
        volatile uint32_t LIST__;  ///< Offset: 0x100 - List Register (renamed from LIST__)
        volatile uint32_t MSPND__;  ///< Offset: 0x140 - Message Pending Register (renamed from MSPND__)
        volatile uint32_t MSID__;  ///< Offset: 0x180 - Message Index Register (renamed from MSID__)
        volatile uint32_t MSIMASK;  ///< Offset: 0x1C0 - Message Index Mask Register
        volatile uint32_t PANCTR;  ///< Offset: 0x1C4 - Panel Control Register
        volatile uint32_t MCR;  ///< Offset: 0x1C8 - Module Control Register
        volatile uint32_t MITR;  ///< Offset: 0x1CC - Module Interrupt Trigger Register
    };

    /// Peripheral instances
    inline Registers* CAN = reinterpret_cast<Registers*>(CAN_BASE);
    inline Registers* CAN_NODE0 = reinterpret_cast<Registers*>(CAN_NODE0_BASE);
    inline Registers* CAN_NODE1 = reinterpret_cast<Registers*>(CAN_NODE1_BASE);
    inline Registers* CAN_MO = reinterpret_cast<Registers*>(CAN_MO_BASE);

    // Bit definitions
    /// CLC Register bits
    namespace clc_bits {
        constexpr uint32_t DISR = (1U << 0);  ///< Module Disable Request Bit
        constexpr uint32_t DISS = (1U << 1);  ///< Module Disable Status Bit
        constexpr uint32_t EDIS = (1U << 3);  ///< Sleep Mode Enable Control
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t STEP = (10 << 0);  ///< Step Value
        constexpr uint32_t DM = (2 << 14);  ///< Divider Mode
    }

    /// LIST__ Register bits
    namespace list___bits {
        constexpr uint32_t BEGIN = (8 << 0);  ///< List Begin
        constexpr uint32_t END = (8 << 8);  ///< List End
        constexpr uint32_t SIZE = (8 << 16);  ///< List Size
        constexpr uint32_t EMPTY = (1U << 24);  ///< List Empty Indication
    }

    /// MSPND__ Register bits
    namespace mspnd___bits {
        constexpr uint32_t PND = (32 << 0);  ///< Message Pending
    }

    /// MSID__ Register bits
    namespace msid___bits {
        constexpr uint32_t INDEX = (6 << 0);  ///< Message Pending Index
    }

    /// MSIMASK Register bits
    namespace msimask_bits {
        constexpr uint32_t IM = (32 << 0);  ///< Message Index Mask
    }

    /// PANCTR Register bits
    namespace panctr_bits {
        constexpr uint32_t PANCMD = (8 << 0);  ///< Panel Command
        constexpr uint32_t BUSY = (1U << 8);  ///< Panel Busy Flag
        constexpr uint32_t RBUSY = (1U << 9);  ///< Result Busy Flag
        constexpr uint32_t PANAR1 = (8 << 16);  ///< Panel Argument 1
        constexpr uint32_t PANAR2 = (8 << 24);  ///< Panel Argument 2
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t CLKSEL = (4 << 0);  ///< Baud Rate Logic Clock Select
        constexpr uint32_t MPSEL = (4 << 12);  ///< Message Pending Selector
    }

    /// MITR Register bits
    namespace mitr_bits {
        constexpr uint32_t IT = (8 << 0);  ///< Interrupt Trigger
    }

}

// ============================================================================
// SCU Peripheral
// ============================================================================

namespace scu {
    /// Base addresses
    constexpr uint32_t SCU_GENERAL_BASE = 0x40010000;
    constexpr uint32_t SCU_INTERRUPT_BASE = 0x40010038;
    constexpr uint32_t SCU_CLK_BASE = 0x40010300;
    constexpr uint32_t SCU_RESET_BASE = 0x40010400;
    constexpr uint32_t SCU_ANALOG_BASE = 0x40011000;

    /// SCU Register structure
    struct Registers {
        volatile uint32_t DBGROMID;  ///< Offset: 0x00 - Debug System ROM ID Register
        volatile uint32_t IDCHIP;  ///< Offset: 0x04 - Chip ID Register
        volatile uint32_t ID;  ///< Offset: 0x08 - SCU Module ID Register
        volatile uint32_t SSW0;  ///< Offset: 0x14 - SSW Register 0
        volatile uint32_t PASSWD;  ///< Offset: 0x24 - Password Register
        volatile uint32_t CCUCON;  ///< Offset: 0x30 - CCU Control Register
        volatile uint32_t MIRRSTS;  ///< Offset: 0x48 - Mirror Update Status Register
        volatile uint32_t PMTSR;  ///< Offset: 0x54 - Parity Memory Test Select Register
        volatile uint32_t PFUCR;  ///< Offset: 0x68 - Prefetch Unit Control Register
        volatile uint32_t INTCR0;  ///< Offset: 0x6C - Interrupt Control Register 0
        volatile uint32_t INTCR1;  ///< Offset: 0x70 - Interrupt Control Register 1
        volatile uint32_t STSTAT;  ///< Offset: 0x74 - Startup Status Register
    };

    /// Peripheral instances
    inline Registers* SCU_GENERAL = reinterpret_cast<Registers*>(SCU_GENERAL_BASE);
    inline Registers* SCU_INTERRUPT = reinterpret_cast<Registers*>(SCU_INTERRUPT_BASE);
    inline Registers* SCU_CLK = reinterpret_cast<Registers*>(SCU_CLK_BASE);
    inline Registers* SCU_RESET = reinterpret_cast<Registers*>(SCU_RESET_BASE);
    inline Registers* SCU_ANALOG = reinterpret_cast<Registers*>(SCU_ANALOG_BASE);

    // Bit definitions
    /// DBGROMID Register bits
    namespace dbgromid_bits {
        constexpr uint32_t MANUFID = (11 << 1);  ///< Manufactory Identity
        constexpr uint32_t PARTNO = (16 << 12);  ///< Part Number
        constexpr uint32_t VERSION = (4 << 28);  ///< Product version
    }

    /// IDCHIP Register bits
    namespace idchip_bits {
        constexpr uint32_t IDCHIP = (32 << 0);  ///< CHIP ID
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// SSW0 Register bits
    namespace ssw0_bits {
        constexpr uint32_t DAT = (32 << 0);  ///< SSW Data
    }

    /// PASSWD Register bits
    namespace passwd_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Bit Protection Scheme Control Bits
        constexpr uint32_t PROTS = (1U << 2);  ///< Bit Protection Signal Status Bit
        constexpr uint32_t PASS = (5 << 3);  ///< Password Bits
    }

    /// CCUCON Register bits
    namespace ccucon_bits {
        constexpr uint32_t GSC40 = (1U << 0);  ///< Global Start Control CCU40
        constexpr uint32_t GSC41 = (1U << 1);  ///< Global Start Control CCU41
    }

    /// MIRRSTS Register bits
    namespace mirrsts_bits {
        constexpr uint32_t RTC_CTR = (1U << 0);  ///< RTC CTR Mirror Register Update Status
        constexpr uint32_t RTC_ATIM0 = (1U << 1);  ///< RTC ATIM0 Mirror Register Update Status
        constexpr uint32_t RTC_ATIM1 = (1U << 2);  ///< RTC ATIM1 Mirror Register Update Status
        constexpr uint32_t RTC_TIM0 = (1U << 3);  ///< RTC TIM0 Mirror Register Update Status
        constexpr uint32_t RTC_TIM1 = (1U << 4);  ///< RTC TIM1 Mirror Register Update Status
    }

    /// PMTSR Register bits
    namespace pmtsr_bits {
        constexpr uint32_t MTENS = (1U << 0);  ///< Parity Test Enable Control for 16kbytes SRAM
    }

    /// PFUCR Register bits
    namespace pfucr_bits {
        constexpr uint32_t PFUBYP = (1U << 0);  ///< Prefetch Unit (PFU) Bypass
    }

    /// INTCR0 Register bits
    namespace intcr0_bits {
        constexpr uint32_t INTSEL0 = (2 << 0);  ///< Interrupt Source Select for Node 0
        constexpr uint32_t INTSEL1 = (2 << 2);  ///< Interrupt Source Select for Node 1
        constexpr uint32_t INTSEL2 = (2 << 4);  ///< Interrupt Source Select for Node 2
        constexpr uint32_t INTSEL3 = (2 << 6);  ///< Interrupt Source Select for Node 3
        constexpr uint32_t INTSEL4 = (2 << 8);  ///< Interrupt Source Select for Node 4
        constexpr uint32_t INTSEL5 = (2 << 10);  ///< Interrupt Source Select for Node 5
        constexpr uint32_t INTSEL6 = (2 << 12);  ///< Interrupt Source Select for Node 6
        constexpr uint32_t INTSEL7 = (2 << 14);  ///< Interrupt Source Select for Node 7
        constexpr uint32_t INTSEL8 = (2 << 16);  ///< Interrupt Source Select for Node 8
        constexpr uint32_t INTSEL9 = (2 << 18);  ///< Interrupt Source Select for Node 9
        constexpr uint32_t INTSEL10 = (2 << 20);  ///< Interrupt Source Select for Node 10
        constexpr uint32_t INTSEL11 = (2 << 22);  ///< Interrupt Source Select for Node 11
        constexpr uint32_t INTSEL12 = (2 << 24);  ///< Interrupt Source Select for Node 12
        constexpr uint32_t INTSEL13 = (2 << 26);  ///< Interrupt Source Select for Node 13
        constexpr uint32_t INTSEL14 = (2 << 28);  ///< Interrupt Source Select for Node 14
        constexpr uint32_t INTSEL15 = (2 << 30);  ///< Interrupt Source Select for Node 15
    }

    /// INTCR1 Register bits
    namespace intcr1_bits {
        constexpr uint32_t INTSEL16 = (2 << 0);  ///< Interrupt Source Select for Node 16
        constexpr uint32_t INTSEL17 = (2 << 2);  ///< Interrupt Source Select for Node 17
        constexpr uint32_t INTSEL18 = (2 << 4);  ///< Interrupt Source Select for Node 18
        constexpr uint32_t INTSEL19 = (2 << 6);  ///< Interrupt Source Select for Node 19
        constexpr uint32_t INTSEL20 = (2 << 8);  ///< Interrupt Source Select for Node 20
        constexpr uint32_t INTSEL21 = (2 << 10);  ///< Interrupt Source Select for Node 21
        constexpr uint32_t INTSEL22 = (2 << 12);  ///< Interrupt Source Select for Node 22
        constexpr uint32_t INTSEL23 = (2 << 14);  ///< Interrupt Source Select for Node 23
        constexpr uint32_t INTSEL24 = (2 << 16);  ///< Interrupt Source Select for Node 24
        constexpr uint32_t INTSEL25 = (2 << 18);  ///< Interrupt Source Select for Node 25
        constexpr uint32_t INTSEL26 = (2 << 20);  ///< Interrupt Source Select for Node 26
        constexpr uint32_t INTSEL27 = (2 << 22);  ///< Interrupt Source Select for Node 27
        constexpr uint32_t INTSEL28 = (2 << 24);  ///< Interrupt Source Select for Node 28
        constexpr uint32_t INTSEL29 = (2 << 26);  ///< Interrupt Source Select for Node 29
        constexpr uint32_t INTSEL30 = (2 << 28);  ///< Interrupt Source Select for Node 30
        constexpr uint32_t INTSEL31 = (2 << 30);  ///< Interrupt Source Select for Node 31
    }

    /// STSTAT Register bits
    namespace ststat_bits {
        constexpr uint32_t HWCON = (2 << 0);  ///< HW Configuration
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t SCU_POWER_BASE = 0x40010200;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t VDESR;  ///< Offset: 0x00 - Voltage Detector Status Register
    };

    /// Peripheral instances
    inline Registers* SCU_POWER = reinterpret_cast<Registers*>(SCU_POWER_BASE);

    // Bit definitions
    /// VDESR Register bits
    namespace vdesr_bits {
        constexpr uint32_t VCLIP = (1U << 0);  ///< VCLIP Indication
        constexpr uint32_t VDDPPW = (1U << 1);  ///< VDDPPW Indication
    }

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMPARATOR_BASE = 0x40010500;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t ORCCTRL;  ///< Offset: 0x00 - Out Of Range Comparator Control Register
    };

    /// Peripheral instances
    inline Registers* COMPARATOR = reinterpret_cast<Registers*>(COMPARATOR_BASE);

    // Bit definitions
    /// ORCCTRL Register bits
    namespace orcctrl_bits {
        constexpr uint32_t ENORC0 = (1U << 0);  ///< Enable Out of Range Comparator 0
        constexpr uint32_t ENORC1 = (1U << 1);  ///< Enable Out of Range Comparator 1
        constexpr uint32_t ENORC2 = (1U << 2);  ///< Enable Out of Range Comparator 2
        constexpr uint32_t ENORC3 = (1U << 3);  ///< Enable Out of Range Comparator 3
        constexpr uint32_t ENORC4 = (1U << 4);  ///< Enable Out of Range Comparator 4
        constexpr uint32_t ENORC5 = (1U << 5);  ///< Enable Out of Range Comparator 5
        constexpr uint32_t ENORC6 = (1U << 6);  ///< Enable Out of Range Comparator 6
        constexpr uint32_t ENORC7 = (1U << 7);  ///< Enable Out of Range Comparator 7
        constexpr uint32_t CNF0 = (1U << 16);  ///< Out of Range Comparator Flag 0
        constexpr uint32_t CNF1 = (1U << 17);  ///< Out of Range Comparator Flag 1
        constexpr uint32_t CNF2 = (1U << 18);  ///< Out of Range Comparator Flag 2
        constexpr uint32_t CNF3 = (1U << 19);  ///< Out of Range Comparator Flag 3
        constexpr uint32_t CNF4 = (1U << 20);  ///< Out of Range Comparator Flag 4
        constexpr uint32_t CNF5 = (1U << 21);  ///< Out of Range Comparator Flag 5
        constexpr uint32_t CNF6 = (1U << 22);  ///< Out of Range Comparator Flag 6
        constexpr uint32_t CNF7 = (1U << 23);  ///< Out of Range Comparator Flag 7
    }

}

// ============================================================================
// CCU40 Peripheral
// ============================================================================

namespace ccu40 {
    /// Base addresses
    constexpr uint32_t CCU40_BASE = 0x48040000;
    constexpr uint32_t CCU40_CC40_BASE = 0x48040100;
    constexpr uint32_t CCU40_CC41_BASE = 0x48040200;
    constexpr uint32_t CCU40_CC42_BASE = 0x48040300;
    constexpr uint32_t CCU40_CC43_BASE = 0x48040400;

    /// CCU40 Register structure
    struct Registers {
        volatile uint32_t GCTRL;  ///< Offset: 0x00 - Global Control Register
        volatile uint32_t GSTAT;  ///< Offset: 0x04 - Global Status Register
        volatile uint32_t GIDLS;  ///< Offset: 0x08 - Global Idle Set
        volatile uint32_t GIDLC;  ///< Offset: 0x0C - Global Idle Clear
        volatile uint32_t GCSS;  ///< Offset: 0x10 - Global Channel Set
        volatile uint32_t GCSC;  ///< Offset: 0x14 - Global Channel Clear
        volatile uint32_t GCST;  ///< Offset: 0x18 - Global Channel Status
        volatile uint32_t MIDR;  ///< Offset: 0x80 - Module Identification
    };

    /// Peripheral instances
    inline Registers* CCU40 = reinterpret_cast<Registers*>(CCU40_BASE);
    inline Registers* CCU40_CC40 = reinterpret_cast<Registers*>(CCU40_CC40_BASE);
    inline Registers* CCU40_CC41 = reinterpret_cast<Registers*>(CCU40_CC41_BASE);
    inline Registers* CCU40_CC42 = reinterpret_cast<Registers*>(CCU40_CC42_BASE);
    inline Registers* CCU40_CC43 = reinterpret_cast<Registers*>(CCU40_CC43_BASE);

    // Bit definitions
    /// GCTRL Register bits
    namespace gctrl_bits {
        constexpr uint32_t PRBC = (3 << 0);  ///< Prescaler Clear Configuration
        constexpr uint32_t PCIS = (2 << 4);  ///< Prescaler Input Clock Selection
        constexpr uint32_t SUSCFG = (2 << 8);  ///< Suspend Mode Configuration
        constexpr uint32_t MSE0 = (1U << 10);  ///< Slice 0 Multi Channel shadow transfer enable
        constexpr uint32_t MSE1 = (1U << 11);  ///< Slice 1 Multi Channel shadow transfer enable
        constexpr uint32_t MSE2 = (1U << 12);  ///< Slice 2 Multi Channel shadow transfer enable
        constexpr uint32_t MSE3 = (1U << 13);  ///< Slice 3 Multi Channel shadow transfer enable
        constexpr uint32_t MSDE = (2 << 14);  ///< Multi Channel shadow transfer request configuration
    }

    /// GSTAT Register bits
    namespace gstat_bits {
        constexpr uint32_t S0I = (1U << 0);  ///< CC40 IDLE status
        constexpr uint32_t S1I = (1U << 1);  ///< CC41 IDLE status
        constexpr uint32_t S2I = (1U << 2);  ///< CC42 IDLE status
        constexpr uint32_t S3I = (1U << 3);  ///< CC43 IDLE status
        constexpr uint32_t PRB = (1U << 8);  ///< Prescaler Run Bit
    }

    /// GIDLS Register bits
    namespace gidls_bits {
        constexpr uint32_t SS0I = (1U << 0);  ///< CC40 IDLE mode set
        constexpr uint32_t SS1I = (1U << 1);  ///< CC41 IDLE mode set
        constexpr uint32_t SS2I = (1U << 2);  ///< CC42 IDLE mode set
        constexpr uint32_t SS3I = (1U << 3);  ///< CC43 IDLE mode set
        constexpr uint32_t CPRB = (1U << 8);  ///< Prescaler Run Bit Clear
        constexpr uint32_t PSIC = (1U << 9);  ///< Prescaler clear
    }

    /// GIDLC Register bits
    namespace gidlc_bits {
        constexpr uint32_t CS0I = (1U << 0);  ///< CC40 IDLE mode clear
        constexpr uint32_t CS1I = (1U << 1);  ///< CC41 IDLE mode clear
        constexpr uint32_t CS2I = (1U << 2);  ///< CC42 IDLE mode clear
        constexpr uint32_t CS3I = (1U << 3);  ///< CC43 IDLE mode clear
        constexpr uint32_t SPRB = (1U << 8);  ///< Prescaler Run Bit Set
    }

    /// GCSS Register bits
    namespace gcss_bits {
        constexpr uint32_t S0SE = (1U << 0);  ///< Slice 0 shadow transfer set enable
        constexpr uint32_t S0DSE = (1U << 1);  ///< Slice 0 Dither shadow transfer set enable
        constexpr uint32_t S0PSE = (1U << 2);  ///< Slice 0 Prescaler shadow transfer set enable
        constexpr uint32_t S1SE = (1U << 4);  ///< Slice 1 shadow transfer set enable
        constexpr uint32_t S1DSE = (1U << 5);  ///< Slice 1 Dither shadow transfer set enable
        constexpr uint32_t S1PSE = (1U << 6);  ///< Slice 1 Prescaler shadow transfer set enable
        constexpr uint32_t S2SE = (1U << 8);  ///< Slice 2 shadow transfer set enable
        constexpr uint32_t S2DSE = (1U << 9);  ///< Slice 2 Dither shadow transfer set enable
        constexpr uint32_t S2PSE = (1U << 10);  ///< Slice 2 Prescaler shadow transfer set enable
        constexpr uint32_t S3SE = (1U << 12);  ///< Slice 3 shadow transfer set enable
        constexpr uint32_t S3DSE = (1U << 13);  ///< Slice 3 Dither shadow transfer set enable
        constexpr uint32_t S3PSE = (1U << 14);  ///< Slice 3 Prescaler shadow transfer set enable
        constexpr uint32_t S0STS = (1U << 16);  ///< Slice 0 status bit set
        constexpr uint32_t S1STS = (1U << 17);  ///< Slice 1 status bit set
        constexpr uint32_t S2STS = (1U << 18);  ///< Slice 2 status bit set
        constexpr uint32_t S3STS = (1U << 19);  ///< Slice 3 status bit set
    }

    /// GCSC Register bits
    namespace gcsc_bits {
        constexpr uint32_t S0SC = (1U << 0);  ///< Slice 0 shadow transfer clear
        constexpr uint32_t S0DSC = (1U << 1);  ///< Slice 0 Dither shadow transfer clear
        constexpr uint32_t S0PSC = (1U << 2);  ///< Slice 0 Prescaler shadow transfer clear
        constexpr uint32_t S1SC = (1U << 4);  ///< Slice 1 shadow transfer clear
        constexpr uint32_t S1DSC = (1U << 5);  ///< Slice 1 Dither shadow transfer clear
        constexpr uint32_t S1PSC = (1U << 6);  ///< Slice 1 Prescaler shadow transfer clear
        constexpr uint32_t S2SC = (1U << 8);  ///< Slice 2 shadow transfer clear
        constexpr uint32_t S2DSC = (1U << 9);  ///< Slice 2 Dither shadow transfer clear
        constexpr uint32_t S2PSC = (1U << 10);  ///< Slice 2 Prescaler shadow transfer clear
        constexpr uint32_t S3SC = (1U << 12);  ///< Slice 3 shadow transfer clear
        constexpr uint32_t S3DSC = (1U << 13);  ///< Slice 3 Dither shadow transfer clear
        constexpr uint32_t S3PSC = (1U << 14);  ///< Slice 3 Prescaler shadow transfer clear
        constexpr uint32_t S0STC = (1U << 16);  ///< Slice 0 status bit clear
        constexpr uint32_t S1STC = (1U << 17);  ///< Slice 1 status bit clear
        constexpr uint32_t S2STC = (1U << 18);  ///< Slice 2 status bit clear
        constexpr uint32_t S3STC = (1U << 19);  ///< Slice 3 status bit clear
    }

    /// GCST Register bits
    namespace gcst_bits {
        constexpr uint32_t S0SS = (1U << 0);  ///< Slice 0 shadow transfer status
        constexpr uint32_t S0DSS = (1U << 1);  ///< Slice 0 Dither shadow transfer status
        constexpr uint32_t S0PSS = (1U << 2);  ///< Slice 0 Prescaler shadow transfer status
        constexpr uint32_t S1SS = (1U << 4);  ///< Slice 1 shadow transfer status
        constexpr uint32_t S1DSS = (1U << 5);  ///< Slice 1 Dither shadow transfer status
        constexpr uint32_t S1PSS = (1U << 6);  ///< Slice 1 Prescaler shadow transfer status
        constexpr uint32_t S2SS = (1U << 8);  ///< Slice 2 shadow transfer status
        constexpr uint32_t S2DSS = (1U << 9);  ///< Slice 2 Dither shadow transfer status
        constexpr uint32_t S2PSS = (1U << 10);  ///< Slice 2 Prescaler shadow transfer status
        constexpr uint32_t S3SS = (1U << 12);  ///< Slice 3 shadow transfer status
        constexpr uint32_t S3DSS = (1U << 13);  ///< Slice 3 Dither shadow transfer status
        constexpr uint32_t S3PSS = (1U << 14);  ///< Slice 3 Prescaler shadow transfer status
        constexpr uint32_t CC40ST = (1U << 16);  ///< Slice 0 status bit
        constexpr uint32_t CC41ST = (1U << 17);  ///< Slice 1 status bit
        constexpr uint32_t CC42ST = (1U << 18);  ///< Slice 2 status bit
        constexpr uint32_t CC43ST = (1U << 19);  ///< Slice 3 status bit
    }

    /// MIDR Register bits
    namespace midr_bits {
        constexpr uint32_t MODR = (8 << 0);  ///< Module Revision
        constexpr uint32_t MODT = (8 << 8);  ///< Module Type
        constexpr uint32_t MODN = (16 << 16);  ///< Module Number
    }

}

// ============================================================================
// CCU41 Peripheral
// ============================================================================

namespace ccu41 {
    /// Base addresses
    constexpr uint32_t CCU41_BASE = 0x48044000;
    constexpr uint32_t CCU41_CC40_BASE = 0x48044100;
    constexpr uint32_t CCU41_CC41_BASE = 0x48044200;
    constexpr uint32_t CCU41_CC42_BASE = 0x48044300;
    constexpr uint32_t CCU41_CC43_BASE = 0x48044400;

    /// CCU41 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CCU41 = reinterpret_cast<Registers*>(CCU41_BASE);
    inline Registers* CCU41_CC40 = reinterpret_cast<Registers*>(CCU41_CC40_BASE);
    inline Registers* CCU41_CC41 = reinterpret_cast<Registers*>(CCU41_CC41_BASE);
    inline Registers* CCU41_CC42 = reinterpret_cast<Registers*>(CCU41_CC42_BASE);
    inline Registers* CCU41_CC43 = reinterpret_cast<Registers*>(CCU41_CC43_BASE);

}

// ============================================================================
// POSIF1 Peripheral
// ============================================================================

namespace posif1 {
    /// Base addresses
    constexpr uint32_t POSIF1_BASE = 0x50014000;

    /// POSIF1 Register structure
    struct Registers {
        volatile uint32_t PCONF;  ///< Offset: 0x00 - POSIF configuration
        volatile uint32_t PSUS;  ///< Offset: 0x04 - POSIF Suspend Config
        volatile uint32_t PRUNS;  ///< Offset: 0x08 - POSIF Run Bit Set
        volatile uint32_t PRUNC;  ///< Offset: 0x0C - POSIF Run Bit Clear
        volatile uint32_t PRUN;  ///< Offset: 0x10 - POSIF Run Bit Status
        volatile uint32_t MIDR;  ///< Offset: 0x20 - Module Identification register
        volatile uint32_t HALP;  ///< Offset: 0x30 - Hall Sensor Patterns
        volatile uint32_t HALPS;  ///< Offset: 0x34 - Hall Sensor Shadow Patterns
        volatile uint32_t MCM;  ///< Offset: 0x40 - Multi-Channel Pattern
        volatile uint32_t MCSM;  ///< Offset: 0x44 - Multi-Channel Shadow Pattern
        volatile uint32_t MCMS;  ///< Offset: 0x48 - Multi-Channel Pattern Control set
        volatile uint32_t MCMC;  ///< Offset: 0x4C - Multi-Channel Pattern Control clear
        volatile uint32_t MCMF;  ///< Offset: 0x50 - Multi-Channel Pattern Control flag
        volatile uint32_t QDC;  ///< Offset: 0x60 - Quadrature Decoder Control
        volatile uint32_t PFLG;  ///< Offset: 0x70 - POSIF Interrupt Flags
        volatile uint32_t PFLGE;  ///< Offset: 0x74 - POSIF Interrupt Enable
        volatile uint32_t SPFLG;  ///< Offset: 0x78 - POSIF Interrupt Set
        volatile uint32_t RPFLG;  ///< Offset: 0x7C - POSIF Interrupt Clear
        volatile uint32_t PDBG;  ///< Offset: 0x100 - POSIF Debug register
    };

    /// Peripheral instances
    inline Registers* POSIF1 = reinterpret_cast<Registers*>(POSIF1_BASE);

    // Bit definitions
    /// PCONF Register bits
    namespace pconf_bits {
        constexpr uint32_t FSEL = (2 << 0);  ///< Function Selector
        constexpr uint32_t QDCM = (1U << 2);  ///< Position Decoder Mode selection
        constexpr uint32_t HIDG = (1U << 4);  ///< Idle generation enable
        constexpr uint32_t MCUE = (1U << 5);  ///< Multi-Channel Pattern SW update enable
        constexpr uint32_t INSEL0 = (2 << 8);  ///< PhaseA/Hal input 1 selector
        constexpr uint32_t INSEL1 = (2 << 10);  ///< PhaseB/Hall input 2 selector
        constexpr uint32_t INSEL2 = (2 << 12);  ///< Index/Hall input 3 selector
        constexpr uint32_t DSEL = (1U << 16);  ///< Delay Pin selector
        constexpr uint32_t SPES = (1U << 17);  ///< Edge selector for the sampling trigger
        constexpr uint32_t MSETS = (3 << 18);  ///< Pattern update signal select
        constexpr uint32_t MSES = (1U << 21);  ///< Multi-Channel pattern update trigger edge
        constexpr uint32_t MSYNS = (2 << 22);  ///< PWM synchronization signal selector
        constexpr uint32_t EWIS = (2 << 24);  ///< Wrong Hall Event selection
        constexpr uint32_t EWIE = (1U << 26);  ///< External Wrong Hall Event enable
        constexpr uint32_t EWIL = (1U << 27);  ///< External Wrong Hall Event active level
        constexpr uint32_t LPC = (3 << 28);  ///< Low Pass Filters Configuration
    }

    /// PSUS Register bits
    namespace psus_bits {
        constexpr uint32_t QSUS = (2 << 0);  ///< Quadrature Mode Suspend Config
        constexpr uint32_t MSUS = (2 << 2);  ///< Multi-Channel Mode Suspend Config
    }

    /// PRUNS Register bits
    namespace pruns_bits {
        constexpr uint32_t SRB = (1U << 0);  ///< Set Run bit
    }

    /// PRUNC Register bits
    namespace prunc_bits {
        constexpr uint32_t CRB = (1U << 0);  ///< Clear Run bit
        constexpr uint32_t CSM = (1U << 1);  ///< Clear Current internal status
    }

    /// PRUN Register bits
    namespace prun_bits {
        constexpr uint32_t RB = (1U << 0);  ///< Run Bit
    }

    /// MIDR Register bits
    namespace midr_bits {
        constexpr uint32_t MODR = (8 << 0);  ///< Module Revision
        constexpr uint32_t MODT = (8 << 8);  ///< Module Type
        constexpr uint32_t MODN = (16 << 16);  ///< Module Number
    }

    /// HALP Register bits
    namespace halp_bits {
        constexpr uint32_t HCP = (3 << 0);  ///< Hall Current Pattern
        constexpr uint32_t HEP = (3 << 3);  ///< Hall Expected Pattern
    }

    /// HALPS Register bits
    namespace halps_bits {
        constexpr uint32_t HCPS = (3 << 0);  ///< Shadow Hall Current Pattern
        constexpr uint32_t HEPS = (3 << 3);  ///< Shadow Hall expected Pattern
    }

    /// MCM Register bits
    namespace mcm_bits {
        constexpr uint32_t MCMP = (16 << 0);  ///< Multi-Channel Pattern
    }

    /// MCSM Register bits
    namespace mcsm_bits {
        constexpr uint32_t MCMPS = (16 << 0);  ///< Shadow Multi-Channel Pattern
    }

    /// MCMS Register bits
    namespace mcms_bits {
        constexpr uint32_t MNPS = (1U << 0);  ///< Multi-Channel Pattern Update Enable Set
        constexpr uint32_t STHR = (1U << 1);  ///< Hall Pattern Shadow Transfer Request
        constexpr uint32_t STMR = (1U << 2);  ///< Multi-Channel Shadow Transfer Request
    }

    /// MCMC Register bits
    namespace mcmc_bits {
        constexpr uint32_t MNPC = (1U << 0);  ///< Multi-Channel Pattern Update Enable Clear
        constexpr uint32_t MPC = (1U << 1);  ///< Multi-Channel Pattern clear
    }

    /// MCMF Register bits
    namespace mcmf_bits {
        constexpr uint32_t MSS = (1U << 0);  ///< Multi-Channel Pattern update status
    }

    /// QDC Register bits
    namespace qdc_bits {
        constexpr uint32_t PALS = (1U << 0);  ///< Phase A Level selector
        constexpr uint32_t PBLS = (1U << 1);  ///< Phase B Level selector
        constexpr uint32_t PHS = (1U << 2);  ///< Phase signals swap
        constexpr uint32_t ICM = (2 << 4);  ///< Index Marker generations control
        constexpr uint32_t DVAL = (1U << 8);  ///< Current rotation direction
    }

    /// PFLG Register bits
    namespace pflg_bits {
        constexpr uint32_t CHES = (1U << 0);  ///< Correct Hall Event Status
        constexpr uint32_t WHES = (1U << 1);  ///< Wrong Hall Event Status
        constexpr uint32_t HIES = (1U << 2);  ///< Hall Inputs Update Status
        constexpr uint32_t MSTS = (1U << 4);  ///< Multi-Channel pattern shadow transfer status
        constexpr uint32_t INDXS = (1U << 8);  ///< Quadrature Index Status
        constexpr uint32_t ERRS = (1U << 9);  ///< Quadrature Phase Error Status
        constexpr uint32_t CNTS = (1U << 10);  ///< Quadrature CLK Status
        constexpr uint32_t DIRS = (1U << 11);  ///< Quadrature Direction Change
        constexpr uint32_t PCLKS = (1U << 12);  ///< Quadrature Period Clk Status
    }

    /// PFLGE Register bits
    namespace pflge_bits {
        constexpr uint32_t ECHE = (1U << 0);  ///< Correct Hall Event Enable
        constexpr uint32_t EWHE = (1U << 1);  ///< Wrong Hall Event Enable
        constexpr uint32_t EHIE = (1U << 2);  ///< Hall Input Update Enable
        constexpr uint32_t EMST = (1U << 4);  ///< Multi-Channel pattern shadow transfer enable
        constexpr uint32_t EINDX = (1U << 8);  ///< Quadrature Index Event Enable
        constexpr uint32_t EERR = (1U << 9);  ///< Quadrature Phase Error Enable
        constexpr uint32_t ECNT = (1U << 10);  ///< Quadrature CLK interrupt Enable
        constexpr uint32_t EDIR = (1U << 11);  ///< Quadrature direction change interrupt Enable
        constexpr uint32_t EPCLK = (1U << 12);  ///< Quadrature Period CLK interrupt Enable
        constexpr uint32_t CHESEL = (1U << 16);  ///< Correct Hall Event Service Request Selector
        constexpr uint32_t WHESEL = (1U << 17);  ///< Wrong Hall Event Service Request Selector
        constexpr uint32_t HIESEL = (1U << 18);  ///< Hall Inputs Update Event Service Request Selector
        constexpr uint32_t MSTSEL = (1U << 20);  ///< Multi-Channel pattern Update Event Service Request Selector
        constexpr uint32_t INDSEL = (1U << 24);  ///< Quadrature Index Event Service Request Selector
        constexpr uint32_t ERRSEL = (1U << 25);  ///< Quadrature Phase Error Event Service Request Selector
        constexpr uint32_t CNTSEL = (1U << 26);  ///< Quadrature Clock Event Service Request Selector
        constexpr uint32_t DIRSEL = (1U << 27);  ///< Quadrature Direction Update Event Service Request Selector
        constexpr uint32_t PCLSEL = (1U << 28);  ///< Quadrature Period clock Event Service Request Selector
    }

    /// SPFLG Register bits
    namespace spflg_bits {
        constexpr uint32_t SCHE = (1U << 0);  ///< Correct Hall Event flag set
        constexpr uint32_t SWHE = (1U << 1);  ///< Wrong Hall Event flag set
        constexpr uint32_t SHIE = (1U << 2);  ///< Hall Inputs Update Event flag set
        constexpr uint32_t SMST = (1U << 4);  ///< Multi-Channel Pattern shadow transfer flag set
        constexpr uint32_t SINDX = (1U << 8);  ///< Quadrature Index flag set
        constexpr uint32_t SERR = (1U << 9);  ///< Quadrature Phase Error flag set
        constexpr uint32_t SCNT = (1U << 10);  ///< Quadrature CLK flag set
        constexpr uint32_t SDIR = (1U << 11);  ///< Quadrature Direction flag set
        constexpr uint32_t SPCLK = (1U << 12);  ///< Quadrature period clock flag set
    }

    /// RPFLG Register bits
    namespace rpflg_bits {
        constexpr uint32_t RCHE = (1U << 0);  ///< Correct Hall Event flag clear
        constexpr uint32_t RWHE = (1U << 1);  ///< Wrong Hall Event flag clear
        constexpr uint32_t RHIE = (1U << 2);  ///< Hall Inputs Update Event flag clear
        constexpr uint32_t RMST = (1U << 4);  ///< Multi-Channel Pattern shadow transfer flag clear
        constexpr uint32_t RINDX = (1U << 8);  ///< Quadrature Index flag clear
        constexpr uint32_t RERR = (1U << 9);  ///< Quadrature Phase Error flag clear
        constexpr uint32_t RCNT = (1U << 10);  ///< Quadrature CLK flag clear
        constexpr uint32_t RDIR = (1U << 11);  ///< Quadrature Direction flag clear
        constexpr uint32_t RPCLK = (1U << 12);  ///< Quadrature period clock flag clear
    }

    /// PDBG Register bits
    namespace pdbg_bits {
        constexpr uint32_t QCSV = (2 << 0);  ///< Quadrature Decoder Current state
        constexpr uint32_t QPSV = (2 << 2);  ///< Quadrature Decoder Previous state
        constexpr uint32_t IVAL = (1U << 4);  ///< Current Index Value
        constexpr uint32_t HSP = (3 << 5);  ///< Hall Current Sampled Pattern
        constexpr uint32_t LPP0 = (6 << 8);  ///< Actual count of the Low Pass Filter for POSI0
        constexpr uint32_t LPP1 = (6 << 16);  ///< Actual count of the Low Pass Filter for POSI1
        constexpr uint32_t LPP2 = (6 << 22);  ///< Actual count of the Low Pass Filter for POSI2
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x48030000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CLC;  ///< Offset: 0x00 - Clock Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t OCS;  ///< Offset: 0x28 - OCDS Control and Status Register
        volatile uint32_t CFG;  ///< Offset: 0x80 - Configuration Register
        volatile uint32_t ICLASS;  ///< Offset: 0xA0 - Input Class Register
        volatile uint32_t BOUND;  ///< Offset: 0xB8 - Boundary Select Register
        volatile uint32_t EFLAG;  ///< Offset: 0xE0 - Event Flag Register
        volatile uint32_t EVNP;  ///< Offset: 0x140 - Event Node Pointer Register
        volatile uint32_t RSSEL;  ///< Offset: 0x180 - Request Source Channel Select Register
        volatile uint32_t RSPND;  ///< Offset: 0x1C0 - Request Source Pending Register
        volatile uint32_t RSCTRL;  ///< Offset: 0x200 - Request Source Control Register
        volatile uint32_t RSMR;  ///< Offset: 0x204 - Request Source Mode Register
        volatile uint32_t RCR;  ///< Offset: 0x280 - Result Control Register
        volatile uint32_t RES;  ///< Offset: 0x300 - Result Register
        volatile uint32_t RESD;  ///< Offset: 0x380 - Result Register, Debug
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// CLC Register bits
    namespace clc_bits {
        constexpr uint32_t DISR = (1U << 0);  ///< Module Disable Request Bit
        constexpr uint32_t DISS = (1U << 1);  ///< Module Disable Status Bit
        constexpr uint32_t EDIS = (1U << 3);  ///< Sleep Mode Enable Control
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// OCS Register bits
    namespace ocs_bits {
        constexpr uint32_t TGS = (2 << 0);  ///< Trigger Set for OTGB0/1
        constexpr uint32_t TGB = (1U << 2);  ///< OTGB0/1 Bus Select
        constexpr uint32_t TG_P = (1U << 3);  ///< TGS, TGB Write Protection
        constexpr uint32_t SUS = (4 << 24);  ///< OCDS Suspend Control
        constexpr uint32_t SUS_P = (1U << 28);  ///< SUS Write Protection
        constexpr uint32_t SUSSTA = (1U << 29);  ///< Suspend State
    }

    /// CFG Register bits
    namespace cfg_bits {
        constexpr uint32_t DPCAL = (1U << 16);  ///< Disable Post-Calibration
        constexpr uint32_t SUCAL = (1U << 31);  ///< Start-Up Calibration
    }

    /// ICLASS Register bits
    namespace iclass_bits {
        constexpr uint32_t STCS = (5 << 0);  ///< Sample Time Control for Standard Conversions
        constexpr uint32_t CMS = (3 << 8);  ///< Conversion Mode for Standard Conversions
    }

    /// BOUND Register bits
    namespace bound_bits {
        constexpr uint32_t BOUNDARY0 = (12 << 0);  ///< Boundary Value 0 for Limit Checking
        constexpr uint32_t BOUNDARY1 = (12 << 16);  ///< Boundary Value 1 for Limit Checking
    }

    /// EFLAG Register bits
    namespace eflag_bits {
        constexpr uint32_t SEV = (1U << 0);  ///< Source Event
        constexpr uint32_t REV = (1U << 8);  ///< Result Event
        constexpr uint32_t SEVCLR = (1U << 16);  ///< Clear Source Event
        constexpr uint32_t REVCLR = (1U << 24);  ///< Clear Result Event
    }

    /// EVNP Register bits
    namespace evnp_bits {
        constexpr uint32_t SEV0NP = (4 << 0);  ///< Service Request Node Pointer Backgr. Source
        constexpr uint32_t REV0NP = (4 << 16);  ///< Service Request Node Pointer Result
    }

    /// RSSEL Register bits
    namespace rssel_bits {
        constexpr uint32_t CHSEL0 = (1U << 0);  ///< Channel Selection 0
        constexpr uint32_t CHSEL1 = (1U << 1);  ///< Channel Selection 1
        constexpr uint32_t CHSEL2 = (1U << 2);  ///< Channel Selection 2
        constexpr uint32_t CHSEL3 = (1U << 3);  ///< Channel Selection 3
        constexpr uint32_t CHSEL4 = (1U << 4);  ///< Channel Selection 4
        constexpr uint32_t CHSEL5 = (1U << 5);  ///< Channel Selection 5
        constexpr uint32_t CHSEL6 = (1U << 6);  ///< Channel Selection 6
        constexpr uint32_t CHSEL7 = (1U << 7);  ///< Channel Selection 7
    }

    /// RSPND Register bits
    namespace rspnd_bits {
        constexpr uint32_t CHPND0 = (1U << 0);  ///< Channels Pending 0
        constexpr uint32_t CHPND1 = (1U << 1);  ///< Channels Pending 1
        constexpr uint32_t CHPND2 = (1U << 2);  ///< Channels Pending 2
        constexpr uint32_t CHPND3 = (1U << 3);  ///< Channels Pending 3
        constexpr uint32_t CHPND4 = (1U << 4);  ///< Channels Pending 4
        constexpr uint32_t CHPND5 = (1U << 5);  ///< Channels Pending 5
        constexpr uint32_t CHPND6 = (1U << 6);  ///< Channels Pending 6
        constexpr uint32_t CHPND7 = (1U << 7);  ///< Channels Pending 7
    }

    /// RSCTRL Register bits
    namespace rsctrl_bits {
        constexpr uint32_t SRCRESREG = (4 << 0);  ///< Source-specific Result Register
        constexpr uint32_t XTSEL = (4 << 8);  ///< External Trigger Input Selection
        constexpr uint32_t XTLVL = (1U << 12);  ///< External Trigger Level
        constexpr uint32_t XTMODE = (2 << 13);  ///< Trigger Operating Mode
        constexpr uint32_t XTWC = (1U << 15);  ///< Write Control for Trigger Configuration
        constexpr uint32_t GTSEL = (4 << 16);  ///< Gate Input Selection
        constexpr uint32_t GTLVL = (1U << 20);  ///< Gate Input Level
        constexpr uint32_t GTWC = (1U << 23);  ///< Write Control for Gate Configuration
    }

    /// RSMR Register bits
    namespace rsmr_bits {
        constexpr uint32_t ENGT = (2 << 0);  ///< Enable Gate
        constexpr uint32_t ENTR = (1U << 2);  ///< Enable External Trigger
        constexpr uint32_t ENSI = (1U << 3);  ///< Enable Source Interrupt
        constexpr uint32_t SCAN = (1U << 4);  ///< Autoscan Enable
        constexpr uint32_t LDM = (1U << 5);  ///< Autoscan Source Load Event Mode
        constexpr uint32_t REQGT = (1U << 7);  ///< Request Gate Level
        constexpr uint32_t CLRPND = (1U << 8);  ///< Clear Pending Bits
        constexpr uint32_t LDEV = (1U << 9);  ///< Generate Load Event
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t DRCTR = (4 << 16);  ///< Data Reduction Control
        constexpr uint32_t WFR = (1U << 24);  ///< Wait-for-Read Mode Enable
        constexpr uint32_t SRGEN = (1U << 31);  ///< Service Request Generation Enable
    }

    /// RES Register bits
    namespace res_bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Result of most recent conversion
        constexpr uint32_t CHNR = (5 << 20);  ///< Channel Number
        constexpr uint32_t FCR = (1U << 30);  ///< Fast Compare Result
        constexpr uint32_t VF = (1U << 31);  ///< Valid Flag
    }

    /// RESD Register bits
    namespace resd_bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Result of most recent conversion
        constexpr uint32_t CHNR = (5 << 20);  ///< Channel Number
        constexpr uint32_t FCR = (1U << 30);  ///< Fast Compare Result
        constexpr uint32_t VF = (1U << 31);  ///< Valid Flag
    }

}

// ============================================================================
// SHS Peripheral
// ============================================================================

namespace shs {
    /// Base addresses
    constexpr uint32_t SHS_BASE = 0x48034000;

    /// SHS Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t CFG;  ///< Offset: 0x40 - Configuration Register
        volatile uint32_t GNCTR;  ///< Offset: 0x180 - Gain Control Register
        volatile uint32_t LOOP;  ///< Offset: 0x50 - SD Loop Control Register
    };

    /// Peripheral instances
    inline Registers* SHS = reinterpret_cast<Registers*>(SHS_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// CFG Register bits
    namespace cfg_bits {
        constexpr uint32_t DIVS = (4 << 0);  ///< Divider Factor for the SHS Clock
        constexpr uint32_t AREF = (2 << 10);  ///< Analog Calbration Reference Voltage Selection
        constexpr uint32_t ANOFF = (1U << 12);  ///< Analog Converter Power Down Force
        constexpr uint32_t ANRDY = (1U << 14);  ///< Analog Converter Ready
        constexpr uint32_t SCWC = (1U << 15);  ///< Write Control for SHS Configuration
        constexpr uint32_t SP = (1U << 16);  ///< Sample Pending
        constexpr uint32_t STATE = (4 << 28);  ///< Current State of Sequencer
    }

    /// GNCTR Register bits
    namespace gnctr_bits {
        constexpr uint32_t GAIN0 = (4 << 0);  ///< Gain Control 0
        constexpr uint32_t GAIN1 = (4 << 4);  ///< Gain Control 1
        constexpr uint32_t GAIN2 = (4 << 8);  ///< Gain Control 2
        constexpr uint32_t GAIN3 = (4 << 12);  ///< Gain Control 3
        constexpr uint32_t GAIN4 = (4 << 16);  ///< Gain Control 4
        constexpr uint32_t GAIN5 = (4 << 20);  ///< Gain Control 5
        constexpr uint32_t GAIN6 = (4 << 24);  ///< Gain Control 6
        constexpr uint32_t GAIN7 = (4 << 28);  ///< Gain Control 7
    }

    /// LOOP Register bits
    namespace loop_bits {
        constexpr uint32_t LPCH0 = (5 << 0);  ///< Loop 0 Channel
        constexpr uint32_t LPCH1 = (5 << 16);  ///< Loop 1 Channel
        constexpr uint32_t LPEN0 = (1U << 15);  ///< Loop 0 Enable
        constexpr uint32_t LPEN1 = (1U << 31);  ///< Loop 1 Enable
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x50030000;
    constexpr uint32_t DAC_CH0_BASE = 0x5003003C;
    constexpr uint32_t DAC_CH1_BASE = 0x50030050;
    constexpr uint32_t DAC_CH2_BASE = 0x50030064;
    constexpr uint32_t DAC_CH3_BASE = 0x50030078;
    constexpr uint32_t DAC_CH4_BASE = 0x5003008C;
    constexpr uint32_t DAC_CH5_BASE = 0x500300A0;
    constexpr uint32_t DAC_CH6_BASE = 0x500300B4;
    constexpr uint32_t DAC_CH7_BASE = 0x500300C8;
    constexpr uint32_t DAC_CH8_BASE = 0x500300DC;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t GLOBCON;  ///< Offset: 0x00 - Global Control
        volatile uint32_t GLOBCLK;  ///< Offset: 0x04 - Global Clock
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification
        volatile uint32_t CHEN;  ///< Offset: 0x0C - Channel Enable
        volatile uint32_t CHSTRCON;  ///< Offset: 0x18 - Channel Shadow Transfer
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);
    inline Registers* DAC_CH0 = reinterpret_cast<Registers*>(DAC_CH0_BASE);
    inline Registers* DAC_CH1 = reinterpret_cast<Registers*>(DAC_CH1_BASE);
    inline Registers* DAC_CH2 = reinterpret_cast<Registers*>(DAC_CH2_BASE);
    inline Registers* DAC_CH3 = reinterpret_cast<Registers*>(DAC_CH3_BASE);
    inline Registers* DAC_CH4 = reinterpret_cast<Registers*>(DAC_CH4_BASE);
    inline Registers* DAC_CH5 = reinterpret_cast<Registers*>(DAC_CH5_BASE);
    inline Registers* DAC_CH6 = reinterpret_cast<Registers*>(DAC_CH6_BASE);
    inline Registers* DAC_CH7 = reinterpret_cast<Registers*>(DAC_CH7_BASE);
    inline Registers* DAC_CH8 = reinterpret_cast<Registers*>(DAC_CH8_BASE);

    // Bit definitions
    /// GLOBCON Register bits
    namespace globcon_bits {
        constexpr uint32_t SUSCFG = (2 << 4);  ///< Suspend Mode Configuration
        constexpr uint32_t WDMBN = (12 << 16);  ///< Watchdog Maximum Bitnumber
    }

    /// GLOBCLK Register bits
    namespace globclk_bits {
        constexpr uint32_t FCLK_PS = (12 << 0);  ///< Fast Clock Prescaler Factor
        constexpr uint32_t BCS = (1U << 15);  ///< Bit-Clock Selector
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE0 = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// CHEN Register bits
    namespace chen_bits {
        constexpr uint32_t ECH0 = (1U << 0);  ///< Channel 0 Enable
        constexpr uint32_t ECH1 = (1U << 1);  ///< Channel 1 Enable
        constexpr uint32_t ECH2 = (1U << 2);  ///< Channel 2 Enable
        constexpr uint32_t ECH3 = (1U << 3);  ///< Channel 3 Enable
        constexpr uint32_t ECH4 = (1U << 4);  ///< Channel 4 Enable
        constexpr uint32_t ECH5 = (1U << 5);  ///< Channel 5 Enable
        constexpr uint32_t ECH6 = (1U << 6);  ///< Channel 6 Enable
        constexpr uint32_t ECH7 = (1U << 7);  ///< Channel 7 Enable
        constexpr uint32_t ECH8 = (1U << 8);  ///< Channel 8 Enable
    }

    /// CHSTRCON Register bits
    namespace chstrcon_bits {
        constexpr uint32_t CH0S = (1U << 0);  ///< Channel 0 Shadow Transfer
        constexpr uint32_t CH1S = (1U << 1);  ///< Channel 1 Shadow Transfer
        constexpr uint32_t CH2S = (1U << 2);  ///< Channel 2 Shadow Transfer
        constexpr uint32_t CH3S = (1U << 3);  ///< Channel 3 Shadow Transfer
        constexpr uint32_t CH4S = (1U << 4);  ///< Channel 4 Shadow Transfer
        constexpr uint32_t CH5S = (1U << 5);  ///< Channel 5 Shadow Transfer
        constexpr uint32_t CH6S = (1U << 6);  ///< Channel 6 Shadow Transfer
        constexpr uint32_t CH7S = (1U << 7);  ///< Channel 7 Shadow Transfer
        constexpr uint32_t CH8S = (1U << 8);  ///< Channel 8 Shadow Transfer
        constexpr uint32_t CH0A = (1U << 16);  ///< Channel 0 Linear Walk Abort
        constexpr uint32_t CH1A = (1U << 17);  ///< Channel 1 Linear Walk Abort
        constexpr uint32_t CH2A = (1U << 18);  ///< Channel 2 Linear Walk Abort
        constexpr uint32_t CH3A = (1U << 19);  ///< Channel 3 Linear Walk Abort
        constexpr uint32_t CH4A = (1U << 20);  ///< Channel 4 Linear Walk Abort
        constexpr uint32_t CH5A = (1U << 21);  ///< Channel 5 Linear Walk Abort
        constexpr uint32_t CH6A = (1U << 22);  ///< Channel 6 Linear Walk Abort
        constexpr uint32_t CH7A = (1U << 23);  ///< Channel 7 Linear Walk Abort
        constexpr uint32_t CH8A = (1U << 24);  ///< Channel 8 Linear Walk Abort
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT0_BASE = 0x40040000;
    constexpr uint32_t PORT1_BASE = 0x40040100;
    constexpr uint32_t PORT2_BASE = 0x40040200;
    constexpr uint32_t PORT4_BASE = 0x40040400;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t OUT;  ///< Offset: 0x00 - Port 0 Output Register
        volatile uint32_t OMR;  ///< Offset: 0x04 - Port 0 Output Modification Register
        volatile uint32_t IOCR8;  ///< Offset: 0x18 - Port 0 Input/Output Control Register 8
        volatile uint32_t IOCR12;  ///< Offset: 0x1C - Port 0 Input/Output Control Register 12
        volatile uint32_t PHCR1;  ///< Offset: 0x44 - Port 0 Pad Hysteresis Control Register 1
        volatile uint32_t PDISC;  ///< Offset: 0x60 - Port 0 Pin Function Decision Control Register
        volatile uint32_t IN;  ///< Offset: 0x24 - Port 0 Input Register
        volatile uint32_t PPS;  ///< Offset: 0x70 - Port 0 Pin Power Save Register
    };

    /// Peripheral instances
    inline Registers* PORT0 = reinterpret_cast<Registers*>(PORT0_BASE);
    inline Registers* PORT1 = reinterpret_cast<Registers*>(PORT1_BASE);
    inline Registers* PORT2 = reinterpret_cast<Registers*>(PORT2_BASE);
    inline Registers* PORT4 = reinterpret_cast<Registers*>(PORT4_BASE);

    // Bit definitions
    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t P8 = (1U << 8);  ///< Port 0 Output Bit 8
        constexpr uint32_t P9 = (1U << 9);  ///< Port 0 Output Bit 9
        constexpr uint32_t P10 = (1U << 10);  ///< Port 0 Output Bit 10
        constexpr uint32_t P11 = (1U << 11);  ///< Port 0 Output Bit 11
        constexpr uint32_t P12 = (1U << 12);  ///< Port 0 Output Bit 12
        constexpr uint32_t P13 = (1U << 13);  ///< Port 0 Output Bit 13
        constexpr uint32_t P14 = (1U << 14);  ///< Port 0 Output Bit 14
        constexpr uint32_t P15 = (1U << 15);  ///< Port 0 Output Bit 15
    }

    /// OMR Register bits
    namespace omr_bits {
        constexpr uint32_t PS8 = (1U << 8);  ///< Port 0 Set Bit 8
        constexpr uint32_t PS9 = (1U << 9);  ///< Port 0 Set Bit 9
        constexpr uint32_t PS10 = (1U << 10);  ///< Port 0 Set Bit 10
        constexpr uint32_t PS11 = (1U << 11);  ///< Port 0 Set Bit 11
        constexpr uint32_t PS12 = (1U << 12);  ///< Port 0 Set Bit 12
        constexpr uint32_t PS13 = (1U << 13);  ///< Port 0 Set Bit 13
        constexpr uint32_t PS14 = (1U << 14);  ///< Port 0 Set Bit 14
        constexpr uint32_t PS15 = (1U << 15);  ///< Port 0 Set Bit 15
        constexpr uint32_t PR8 = (1U << 24);  ///< Port 0 Reset Bit 8
        constexpr uint32_t PR9 = (1U << 25);  ///< Port 0 Reset Bit 9
        constexpr uint32_t PR10 = (1U << 26);  ///< Port 0 Reset Bit 10
        constexpr uint32_t PR11 = (1U << 27);  ///< Port 0 Reset Bit 11
        constexpr uint32_t PR12 = (1U << 28);  ///< Port 0 Reset Bit 12
        constexpr uint32_t PR13 = (1U << 29);  ///< Port 0 Reset Bit 13
        constexpr uint32_t PR14 = (1U << 30);  ///< Port 0 Reset Bit 14
        constexpr uint32_t PR15 = (1U << 31);  ///< Port 0 Reset Bit 15
    }

    /// IOCR8 Register bits
    namespace iocr8_bits {
        constexpr uint32_t PC8 = (6 << 2);  ///< Port Control for Port 0 Pin 8
        constexpr uint32_t PC9 = (6 << 10);  ///< Port Control for Port 0 Pin 9
        constexpr uint32_t PC10 = (6 << 18);  ///< Port Control for Port 0 Pin 10
        constexpr uint32_t PC11 = (6 << 26);  ///< Port Control for Port 0 Pin 11
    }

    /// IOCR12 Register bits
    namespace iocr12_bits {
        constexpr uint32_t PC12 = (6 << 2);  ///< Port Control for Port 0 Pin 12
        constexpr uint32_t PC13 = (6 << 10);  ///< Port Control for Port 0 Pin 13
        constexpr uint32_t PC14 = (6 << 18);  ///< Port Control for Port 0 Pin 14
        constexpr uint32_t PC15 = (6 << 26);  ///< Port Control for Port 0 Pin 15
    }

    /// PHCR1 Register bits
    namespace phcr1_bits {
        constexpr uint32_t PH8 = (1U << 2);  ///< Pad Hysteresis for P0.8
        constexpr uint32_t PH9 = (1U << 6);  ///< Pad Hysteresis for P0.9
        constexpr uint32_t PH10 = (1U << 10);  ///< Pad Hysteresis for P0.10
        constexpr uint32_t PH11 = (1U << 14);  ///< Pad Hysteresis for P0.11
        constexpr uint32_t PH12 = (1U << 18);  ///< Pad Hysteresis for P0.12
        constexpr uint32_t PH13 = (1U << 22);  ///< Pad Hysteresis for P0.13
        constexpr uint32_t PH14 = (1U << 26);  ///< Pad Hysteresis for P0.14
        constexpr uint32_t PH15 = (1U << 30);  ///< Pad Hysteresis for P0.15
    }

    /// PDISC Register bits
    namespace pdisc_bits {
        constexpr uint32_t PDIS8 = (1U << 8);  ///< Pad Disable for Port 0 Pin 8
        constexpr uint32_t PDIS9 = (1U << 9);  ///< Pad Disable for Port 0 Pin 9
        constexpr uint32_t PDIS10 = (1U << 10);  ///< Pad Disable for Port 0 Pin 10
        constexpr uint32_t PDIS11 = (1U << 11);  ///< Pad Disable for Port 0 Pin 11
        constexpr uint32_t PDIS12 = (1U << 12);  ///< Pad Disable for Port 0 Pin 12
        constexpr uint32_t PDIS13 = (1U << 13);  ///< Pad Disable for Port 0 Pin 13
        constexpr uint32_t PDIS14 = (1U << 14);  ///< Pad Disable for Port 0 Pin 14
        constexpr uint32_t PDIS15 = (1U << 15);  ///< Pad Disable for Port 0 Pin 15
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t P8 = (1U << 8);  ///< Port 0 Input Bit 8
        constexpr uint32_t P9 = (1U << 9);  ///< Port 0 Input Bit 9
        constexpr uint32_t P10 = (1U << 10);  ///< Port 0 Input Bit 10
        constexpr uint32_t P11 = (1U << 11);  ///< Port 0 Input Bit 11
        constexpr uint32_t P12 = (1U << 12);  ///< Port 0 Input Bit 12
        constexpr uint32_t P13 = (1U << 13);  ///< Port 0 Input Bit 13
        constexpr uint32_t P14 = (1U << 14);  ///< Port 0 Input Bit 14
        constexpr uint32_t P15 = (1U << 15);  ///< Port 0 Input Bit 15
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPS8 = (1U << 8);  ///< Port 0 Pin Power Save Bit 8
        constexpr uint32_t PPS9 = (1U << 9);  ///< Port 0 Pin Power Save Bit 9
        constexpr uint32_t PPS10 = (1U << 10);  ///< Port 0 Pin Power Save Bit 10
        constexpr uint32_t PPS11 = (1U << 11);  ///< Port 0 Pin Power Save Bit 11
        constexpr uint32_t PPS12 = (1U << 12);  ///< Port 0 Pin Power Save Bit 12
        constexpr uint32_t PPS13 = (1U << 13);  ///< Port 0 Pin Power Save Bit 13
        constexpr uint32_t PPS14 = (1U << 14);  ///< Port 0 Pin Power Save Bit 14
        constexpr uint32_t PPS15 = (1U << 15);  ///< Port 0 Pin Power Save Bit 15
    }

}


} // namespace alloy::generated::imc300a

#endif // ALLOY_GENERATED_IMC300A_PERIPHERALS_HPP