/// Auto-generated code for tle984x
/// Generated by Alloy Code Generator
/// Source: infineon_tle984x.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:56
#ifndef ALLOY_GENERATED_TLE984X_PERIPHERALS_HPP
#define ALLOY_GENERATED_TLE984X_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::tle984x {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_ccu6 = true;
    constexpr uint32_t num_ccu6_instances = 1;
    constexpr bool has_cpu = true;
    constexpr uint32_t num_cpu_instances = 1;
    constexpr bool has_gpt12e = true;
    constexpr uint32_t num_gpt12e_instances = 1;
    constexpr bool has_hs = true;
    constexpr uint32_t num_hs_instances = 1;
    constexpr bool has_ls = true;
    constexpr uint32_t num_ls_instances = 1;
    constexpr bool has_mf = true;
    constexpr uint32_t num_mf_instances = 1;
    constexpr bool has_pmu = true;
    constexpr uint32_t num_pmu_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 1;
    constexpr bool has_scu = true;
    constexpr uint32_t num_scu_instances = 1;
    constexpr bool has_scupm = true;
    constexpr uint32_t num_scupm_instances = 1;
    constexpr bool has_ssc1 = true;
    constexpr uint32_t num_ssc1_instances = 1;
    constexpr bool has_ssc2 = true;
    constexpr uint32_t num_ssc2_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 2;
    constexpr bool has_trx = true;
    constexpr uint32_t num_trx_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ccu6_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt12e_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ls_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scupm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ssc1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ssc2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct trx_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 1;
    constexpr uint32_t max_gpio_pins = 16;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC1_BASE = 0x40004000;
    constexpr uint32_t ADC2_BASE = 0x4801C000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CAL_CH0_1;  ///< Offset: 0x48 - Calibration for channel 0 and 1 register
        volatile uint32_t CAL_CH10_11;  ///< Offset: 0x5C - Calibration for channel 10 and 11 register
        volatile uint32_t CAL_CH2_3;  ///< Offset: 0x4C - Calibration for channel 2 and 3 register
        volatile uint32_t CAL_CH4_5;  ///< Offset: 0x50 - Calibration for channel 4 and 5 register
        volatile uint32_t CAL_CH6_7;  ///< Offset: 0x54 - Calibration for channel 6 and 7 register
        volatile uint32_t CAL_CH8_9;  ///< Offset: 0x58 - Calibration for channel 8 and 9 register
        volatile uint32_t CHx_EIM;  ///< Offset: 0x08 - Channel setting bits for exceptional interrupt...
        volatile uint32_t CHx_ESM;  ///< Offset: 0x0C - Channel setting bits for exceptional sequence...
        volatile uint32_t CNT0_3_LOWER;  ///< Offset: 0xD8 - Lower counter trigger level channel 0-3 register
        volatile uint32_t CNT0_3_UPPER;  ///< Offset: 0xE8 - Upper counter trigger level channel 0-3 register
        volatile uint32_t CNT4_7_LOWER;  ///< Offset: 0xDC - Lower counter trigger level channel 4-7 register
        volatile uint32_t CNT4_7_UPPER;  ///< Offset: 0xEC - Upper counter trigger level channel 4-7 register
        volatile uint32_t CNT8_11_LOWER;  ///< Offset: 0xE0 - Lower counter trigger level channel 8-11 register
        volatile uint32_t CNT8_11_UPPER;  ///< Offset: 0xF0 - Upper counter trigger level channel 8-11 register
        volatile uint32_t CTRL_STS;  ///< Offset: 0x00 - ADC1 control and status register
        volatile uint32_t CTRL2;  ///< Offset: 0x14 - Measurement unit 1 control 2 register
        volatile uint32_t CTRL3;  ///< Offset: 0x18 - Measurement unit 1 control 3 register
        volatile uint32_t CTRL4;  ///< Offset: 0x38 - Measurement unit 1 control 4 register
        volatile uint32_t CTRL5;  ///< Offset: 0x1C - Measurement unit 1 control 5 register
        volatile uint32_t DCHCNT1_4_LOWER;  ///< Offset: 0xE4 - Lower counter trigger level differential channel 1-4 register
        volatile uint32_t DCHCNT1_4_UPPER;  ///< Offset: 0xF4 - Upper counter trigger level differential channel 1-4 register
        volatile uint32_t DCHTH1_4_LOWER;  ///< Offset: 0xC4 - Lower comparator trigger level differential channel 1-4 register
        volatile uint32_t DCHTH1_4_UPPER;  ///< Offset: 0xD4 - Upper comparator trigger level differential channel 1-4 register
        volatile uint32_t DIFFCH_OUT1;  ///< Offset: 0xA0 - ADC1 differential channel output 1 register
        volatile uint32_t DIFFCH_OUT2;  ///< Offset: 0xA4 - ADC1 differential channel output 2 register
        volatile uint32_t DIFFCH_OUT3;  ///< Offset: 0xA8 - ADC1 differential channel output 3 register
        volatile uint32_t DIFFCH_OUT4;  ///< Offset: 0xAC - ADC1 differential channel output 4 register
        volatile uint32_t DUIN_SEL;  ///< Offset: 0xFC - Measurement unit 1 - Differential unit input selection register
        volatile uint32_t FILT_LO_CTRL;  ///< Offset: 0xB4 - Lower Threshold filter enable
        volatile uint32_t FILT_OUT0;  ///< Offset: 0x70 - ADC1 or filter output channel 0 register
        volatile uint32_t FILT_OUT1;  ///< Offset: 0x74 - ADC1 or filter output channel 1 register
        volatile uint32_t FILT_OUT10;  ///< Offset: 0x98 - ADC1 or filter output channel 10 register
        volatile uint32_t FILT_OUT11;  ///< Offset: 0x9C - ADC1 or filter output channel 11 register
        volatile uint32_t FILT_OUT12;  ///< Offset: 0x110 - ADC1 or filter output channel 12 register
        volatile uint32_t FILT_OUT2;  ///< Offset: 0x78 - ADC1 or filter output channel 2 register
        volatile uint32_t FILT_OUT3;  ///< Offset: 0x7C - ADC1 or filter output channel 3 register
        volatile uint32_t FILT_OUT4;  ///< Offset: 0x80 - ADC1 or filter output channel 4 register
        volatile uint32_t FILT_OUT5;  ///< Offset: 0x84 - ADC1 or filter output channel 5 register
        volatile uint32_t FILT_OUT6;  ///< Offset: 0x88 - ADC1 or filter output channel 6 register
        volatile uint32_t FILT_OUT7;  ///< Offset: 0x8C - ADC1 or filter output channel 7 register
        volatile uint32_t FILT_OUT8;  ///< Offset: 0x90 - ADC1 or filter output channel 8 register
        volatile uint32_t FILT_OUT9;  ///< Offset: 0x94 - ADC1 or filter output channel 9 register
        volatile uint32_t FILT_OUTEIM;  ///< Offset: 0x120 - ADC1 or filter output of EIM register
        volatile uint32_t FILT_UP_CTRL;  ///< Offset: 0xB0 - Upper threshold filter enable
        volatile uint32_t FILTCOEFF0_11;  ///< Offset: 0x60 - Filter coefficients measurement unit channel 0-11 register
        volatile uint32_t IRQCLR_1;  ///< Offset: 0x6C - ADC1 interrupt status clear 1 register
        volatile uint32_t IRQCLR_2;  ///< Offset: 0x108 - ADC1 interrupt status clear 2 register
        volatile uint32_t IRQEN_1;  ///< Offset: 0x68 - ADC1 interrupt enable 1 register
        volatile uint32_t IRQEN_2;  ///< Offset: 0x10C - ADC1 interrupt enable 2 register
        volatile uint32_t IRQS_1;  ///< Offset: 0x64 - ADC1 interrupt status 1 register
        volatile uint32_t IRQS_2;  ///< Offset: 0x100 - ADC1 interrupt status 2 register
        volatile uint32_t MAX_TIME;  ///< Offset: 0x10 - Maximum time for software mode register
        volatile uint32_t MMODE0_11;  ///< Offset: 0xF8 - Overvoltage measurement mode of channel 0-11 register
        volatile uint32_t SQ_FB;  ///< Offset: 0x04 - Sequencer feedback register
        volatile uint32_t SQ0_1;  ///< Offset: 0x20 - Measurement unit 1 channel enable bits for cycle 0-1 register
        volatile uint32_t SQ10_11;  ///< Offset: 0x34 - Measurement unit 1 channel enable bits for cycle 10-11 register
        volatile uint32_t SQ2_3;  ///< Offset: 0x24 - Measurement unit 1 channel enable bits for cycle 2-3 register
        volatile uint32_t SQ4_5;  ///< Offset: 0x28 - Measurement unit 1 channel enable bits for cycle 4-5 register
        volatile uint32_t SQ6_7;  ///< Offset: 0x2C - Measurement unit 1 channel enable bits for cycle 6-7 register
        volatile uint32_t SQ8_9;  ///< Offset: 0x30 - Measurement unit 1 channel enable bits for cycle 8-9 register
        volatile uint32_t STS_1;  ///< Offset: 0x124 - ADC1 status 1 register
        volatile uint32_t STS_2;  ///< Offset: 0x104 - ADC1 status 2 register
        volatile uint32_t STSCLR_1;  ///< Offset: 0x128 - ADC1 status clear 1 register
        volatile uint32_t TH0_3_LOWER;  ///< Offset: 0x40 - Lower comparator trigger level channel 0-3
        volatile uint32_t TH0_3_UPPER;  ///< Offset: 0xC8 - Upper comparator trigger level channel 0-3 register
        volatile uint32_t TH4_7_LOWER;  ///< Offset: 0x44 - Lower comparator trigger level channel 4-7
        volatile uint32_t TH4_7_UPPER;  ///< Offset: 0xCC - Upper comparator trigger level channel 4-7 register
        volatile uint32_t TH8_11_LOWER;  ///< Offset: 0xC0 - Lower comparator trigger level channel 8-11
        volatile uint32_t TH8_11_UPPER;  ///< Offset: 0xD0 - Upper comparator trigger level channel 8-11 register
    };

    /// Peripheral instances
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* ADC2 = reinterpret_cast<Registers*>(ADC2_BASE);

    // Bit definitions
    /// CAL_CH0_1 Register bits
    namespace cal_ch0_1_bits {
        constexpr uint32_t CALOFFS_CH0 = (5 << 0);  ///< Offset calibration for channel 0
        constexpr uint32_t CALGAIN_CH0 = (8 << 8);  ///< Gain calibration for channel 0
        constexpr uint32_t CALOFFS_CH1 = (5 << 16);  ///< Offset calibration for channel 1
        constexpr uint32_t CALGAIN_CH1 = (8 << 24);  ///< Gain calibration for channel 1
    }

    /// CAL_CH10_11 Register bits
    namespace cal_ch10_11_bits {
        constexpr uint32_t CALOFFS_CH10 = (5 << 0);  ///< Offset calibration for channel 10
        constexpr uint32_t CALGAIN_CH10 = (8 << 8);  ///< Gain calibration for channel 10
        constexpr uint32_t CALOFFS_CH11 = (5 << 16);  ///< Offset calibration for channel 11
        constexpr uint32_t CALGAIN_CH11 = (8 << 24);  ///< Gain calibration for channel 11
    }

    /// CAL_CH2_3 Register bits
    namespace cal_ch2_3_bits {
        constexpr uint32_t CALOFFS_CH2 = (5 << 0);  ///< Offset calibration for channel 2
        constexpr uint32_t CALGAIN_CH2 = (8 << 8);  ///< Gain calibration for channel 2
        constexpr uint32_t CALOFFS_CH3 = (5 << 16);  ///< Offset calibration for channel 3
        constexpr uint32_t CALGAIN_CH3 = (8 << 24);  ///< Gain calibration for channel 3
    }

    /// CAL_CH4_5 Register bits
    namespace cal_ch4_5_bits {
        constexpr uint32_t CALOFFS_CH4 = (5 << 0);  ///< Offset calibration for channel 4
        constexpr uint32_t CALGAIN_CH4 = (8 << 8);  ///< Gain calibration for channel 4
        constexpr uint32_t CALOFFS_CH5 = (5 << 16);  ///< Offset calibration for channel 5
        constexpr uint32_t CALGAIN_CH5 = (8 << 24);  ///< Gain calibration for channel 5
    }

    /// CAL_CH6_7 Register bits
    namespace cal_ch6_7_bits {
        constexpr uint32_t CALOFFS_CH6 = (5 << 0);  ///< Offset calibration for channel 6
        constexpr uint32_t CALGAIN_CH6 = (8 << 8);  ///< Gain calibration for channel 6
        constexpr uint32_t CALOFFS_CH7 = (5 << 16);  ///< Offset calibration for channel 7
        constexpr uint32_t CALGAIN_CH7 = (8 << 24);  ///< Gain calibration for channel 7
    }

    /// CAL_CH8_9 Register bits
    namespace cal_ch8_9_bits {
        constexpr uint32_t CALOFFS_CH8 = (5 << 0);  ///< Offset calibration for channel 8
        constexpr uint32_t CALGAIN_CH8 = (8 << 8);  ///< Gain calibration for channel 8
        constexpr uint32_t CALOFFS_CH9 = (5 << 16);  ///< Offset calibration for channel 9
        constexpr uint32_t CALGAIN_CH9 = (8 << 24);  ///< Gain calibration for channel 9
    }

    /// CHx_EIM Register bits
    namespace chx_eim_bits {
        constexpr uint32_t EIM_CHx = (4 << 0);  ///< Channel set for exceptional interrupt measurement (EIM)
        constexpr uint32_t EIM_REP = (3 << 8);  ///< Repeat count for exceptional interrupt measurement (EIM)
        constexpr uint32_t EIM_EN = (1U << 11);  ///< Exceptional interrupt measurement (EIM) Trigger Event enable
        constexpr uint32_t ADC1_EIM_TRIG_SEL = (3 << 16);  ///< Trigger selection for exceptional interrupt measurement (EIM)
    }

    /// CHx_ESM Register bits
    namespace chx_esm_bits {
        constexpr uint32_t ESM_0 = (12 << 0);  ///< Channel sequence for exceptional sequence measurement (ESM)
        constexpr uint32_t ADC1_ESM_TRIG_SEL = (3 << 16);  ///< Trigger selection for exceptional interrupt measurement (ESM)
        constexpr uint32_t ESM_EN = (1U << 30);  ///< Enable for Exceptional Sequence Measurement Trigger Event
        constexpr uint32_t ESM_STS = (1U << 31);  ///< Exceptional sequence measurement is finished
    }

    /// CNT0_3_LOWER Register bits
    namespace cnt0_3_lower_bits {
        constexpr uint32_t CNT_LO_CH0 = (3 << 0);  ///< Lower timer trigger threshold channel 0
        constexpr uint32_t HYST_LO_CH0 = (2 << 3);  ///< Channel 0 lower hysteresis
        constexpr uint32_t CNT_LO_CH1 = (3 << 8);  ///< Lower timer trigger threshold channel 1
        constexpr uint32_t HYST_LO_CH1 = (2 << 11);  ///< Channel 1 lower hysteresis
        constexpr uint32_t CNT_LO_CH2 = (3 << 16);  ///< Lower timer trigger threshold channel 2
        constexpr uint32_t HYST_LO_CH2 = (2 << 19);  ///< Channel 2 lower hysteresis
        constexpr uint32_t CNT_LO_CH3 = (3 << 24);  ///< Lower timer trigger threshold channel 3
        constexpr uint32_t HYST_LO_CH3 = (2 << 27);  ///< Channel 3 lower hysteresis
    }

    /// CNT0_3_UPPER Register bits
    namespace cnt0_3_upper_bits {
        constexpr uint32_t CNT_UP_CH0 = (3 << 0);  ///< Upper timer trigger threshold channel 0
        constexpr uint32_t HYST_UP_CH0 = (2 << 3);  ///< Channel 0 upper hysteresis
        constexpr uint32_t CNT_UP_CH1 = (3 << 8);  ///< Upper timer trigger threshold channel 1
        constexpr uint32_t HYST_UP_CH1 = (2 << 11);  ///< Channel 1 upper hysteresis
        constexpr uint32_t CNT_UP_CH2 = (3 << 16);  ///< Upper timer trigger threshold channel 2
        constexpr uint32_t HYST_UP_CH2 = (2 << 19);  ///< Channel 2 upper hysteresis
        constexpr uint32_t CNT_UP_CH3 = (3 << 24);  ///< Upper timer trigger threshold channel 3
        constexpr uint32_t HYST_UP_CH3 = (2 << 27);  ///< Channel 3 upper hysteresis
    }

    /// CNT4_7_LOWER Register bits
    namespace cnt4_7_lower_bits {
        constexpr uint32_t CNT_LO_CH4 = (3 << 0);  ///< Lower timer trigger threshold channel 4
        constexpr uint32_t HYST_LO_CH4 = (2 << 3);  ///< Channel 4 lower hysteresis
        constexpr uint32_t CNT_LO_CH5 = (3 << 8);  ///< Lower timer trigger threshold channel 5
        constexpr uint32_t HYST_LO_CH5 = (2 << 11);  ///< Channel 5 lower hysteresis
        constexpr uint32_t CNT_LO_CH6 = (3 << 16);  ///< Lower timer trigger threshold channel 6
        constexpr uint32_t HYST_LO_CH6 = (2 << 19);  ///< Channel 6 lower hysteresis
        constexpr uint32_t CNT_LO_CH7 = (3 << 24);  ///< Lower timer trigger threshold channel 7
        constexpr uint32_t HYST_LO_CH7 = (2 << 27);  ///< Channel 7 lower hysteresis
    }

    /// CNT4_7_UPPER Register bits
    namespace cnt4_7_upper_bits {
        constexpr uint32_t CNT_UP_CH4 = (3 << 0);  ///< Upper timer trigger threshold channel 4
        constexpr uint32_t HYST_UP_CH4 = (2 << 3);  ///< Channel 4 upper hysteresis
        constexpr uint32_t CNT_UP_CH5 = (3 << 8);  ///< Upper timer trigger threshold channel 5
        constexpr uint32_t HYST_UP_CH5 = (2 << 11);  ///< Channel 5 upper hysteresis
        constexpr uint32_t CNT_UP_CH6 = (3 << 16);  ///< Upper timer trigger threshold channel 6
        constexpr uint32_t HYST_UP_CH6 = (2 << 19);  ///< Channel 6 upper hysteresis
        constexpr uint32_t CNT_UP_CH7 = (3 << 24);  ///< Upper timer trigger threshold channel 7
        constexpr uint32_t HYST_UP_CH7 = (2 << 27);  ///< Channel 7 upper hysteresis
    }

    /// CNT8_11_LOWER Register bits
    namespace cnt8_11_lower_bits {
        constexpr uint32_t CNT_LO_CH8 = (3 << 0);  ///< Lower timer trigger threshold channel 8
        constexpr uint32_t HYST_LO_CH8 = (2 << 3);  ///< Channel 8 lower hysteresis
        constexpr uint32_t CNT_LO_CH9 = (3 << 8);  ///< Lower timer trigger threshold channel 9
        constexpr uint32_t HYST_LO_CH9 = (2 << 11);  ///< Channel 9 lower hysteresis
        constexpr uint32_t CNT_LO_CH10 = (3 << 16);  ///< Lower timer trigger threshold channel 10
        constexpr uint32_t HYST_LO_CH10 = (2 << 19);  ///< Channel 10 lower hysteresis
        constexpr uint32_t CNT_LO_CH11 = (3 << 24);  ///< Lower timer trigger threshold channel 11
        constexpr uint32_t HYST_LO_CH11 = (2 << 27);  ///< Channel 11 lower hysteresis
    }

    /// CNT8_11_UPPER Register bits
    namespace cnt8_11_upper_bits {
        constexpr uint32_t CNT_UP_CH8 = (3 << 0);  ///< Upper timer trigger threshold channel 8
        constexpr uint32_t HYST_UP_CH8 = (2 << 3);  ///< Channel 8 upper hysteresis
        constexpr uint32_t CNT_UP_CH9 = (3 << 8);  ///< Upper timer trigger threshold channel 9
        constexpr uint32_t HYST_UP_CH9 = (2 << 11);  ///< Channel 9 upper hysteresis
        constexpr uint32_t CNT_UP_CH10 = (3 << 16);  ///< Upper timer trigger threshold channel 10
        constexpr uint32_t HYST_UP_CH10 = (2 << 19);  ///< Channel 10 upper hysteresis
        constexpr uint32_t CNT_UP_CH11 = (3 << 24);  ///< Upper timer trigger threshold channel 11
        constexpr uint32_t HYST_UP_CH11 = (2 << 27);  ///< Channel 11 upper hysteresis
    }

    /// CTRL_STS Register bits
    namespace ctrl_sts_bits {
        constexpr uint32_t PD_N = (1U << 0);  ///< ADC1 Power-down signal
        constexpr uint32_t SOS = (1U << 2);  ///< ADC1 Start of sampling/conversion (software mode)
        constexpr uint32_t READY = (1U << 4);  ///< HVADC ready bit
        constexpr uint32_t CAL_SIGN = (1U << 5);  ///< Output of comparator to steer gain/offset calibration
        constexpr uint32_t EOC = (1U << 7);  ///< ADC1 End of Conversion (software mode)
        constexpr uint32_t SW_CH_SEL = (4 << 8);  ///< Channel for software mode
        constexpr uint32_t STRTUP_DIS = (1U << 18);  ///< DPP1 startup disable
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t CAL_EN = (12 << 0);  ///< Calibration enable for channels 0 to 11
    }

    /// CTRL3 Register bits
    namespace ctrl3_bits {
        constexpr uint32_t MCM_PD_N = (1U << 0);  ///< Power-down signal for MCM
        constexpr uint32_t SW_MODE = (1U << 1);  ///< Software mode enable
        constexpr uint32_t EoC_FAIL_CLR = (1U << 4);  ///< Fail of ADC end of conversion signal clear
        constexpr uint32_t EoC_FAIL = (1U << 6);  ///< Fail of ADC end of conversion signal
        constexpr uint32_t MCM_RDY = (1U << 7);  ///< Ready signal for MCM (Measurement core module) after power on or reset
        constexpr uint32_t SAMPLE_TIME_HVCH = (4 << 8);  ///< Sample time of ADC1
        constexpr uint32_t SAMPLE_TIME_LVCH = (4 << 16);  ///< Sample time of ADC1
    }

    /// CTRL4 Register bits
    namespace ctrl4_bits {
        constexpr uint32_t MAX_CALTIME = (4 << 0);  ///< Maximum ADC calibration time
    }

    /// CTRL5 Register bits
    namespace ctrl5_bits {
        constexpr uint32_t FILT_OUT_SEL_11_0 = (12 << 0);  ///< Output filter selection for channels 0 to 11
    }

    /// DCHCNT1_4_LOWER Register bits
    namespace dchcnt1_4_lower_bits {
        constexpr uint32_t CNT_LO_DCH1 = (3 << 0);  ///< Lower timer trigger threshold differential channel 1
        constexpr uint32_t HYST_LO_DCH1 = (2 << 3);  ///< Differential Channel 1 lower hysteresis
        constexpr uint32_t CNT_LO_DCH2 = (3 << 8);  ///< Lower timer trigger threshold differential channel 2
        constexpr uint32_t HYST_LO_DCH2 = (2 << 11);  ///< Differential Channel 2 lower hysteresis
        constexpr uint32_t CNT_LO_DCH3 = (3 << 16);  ///< Lower timer trigger threshold differential channel 3
        constexpr uint32_t HYST_LO_DCH3 = (2 << 19);  ///< Differential Channel 3 lower hysteresis
        constexpr uint32_t CNT_LO_DCH4 = (3 << 24);  ///< Lower timer trigger threshold differential channel 4
        constexpr uint32_t HYST_LO_DCH4 = (2 << 27);  ///< Differential Channel 4 lower hysteresis
    }

    /// DCHCNT1_4_UPPER Register bits
    namespace dchcnt1_4_upper_bits {
        constexpr uint32_t CNT_UP_DCH1 = (3 << 0);  ///< Upper timer trigger threshold differential channel 1
        constexpr uint32_t HYST_UP_DCH1 = (2 << 3);  ///< Differential channel 1 upper hysteresis
        constexpr uint32_t CNT_UP_DCH2 = (3 << 8);  ///< Upper timer trigger threshold differential channel 2
        constexpr uint32_t HYST_UP_DCH2 = (2 << 11);  ///< Differential channel 2 upper hysteresis
        constexpr uint32_t CNT_UP_DCH3 = (3 << 16);  ///< Upper timer trigger threshold differential channel 3
        constexpr uint32_t HYST_UP_DCH3 = (2 << 19);  ///< Differential channel 3 upper hysteresis
        constexpr uint32_t CNT_UP_DCH4 = (3 << 24);  ///< Upper timer trigger threshold differential channel 4
        constexpr uint32_t HYST_UP_DCH4 = (2 << 27);  ///< Differential channel 4 upper hysteresis
    }

    /// DCHTH1_4_LOWER Register bits
    namespace dchth1_4_lower_bits {
        constexpr uint32_t DCH1_LOW = (8 << 0);  ///< Differential channel 1 lower trigger level
        constexpr uint32_t DCH2_LOW = (8 << 8);  ///< Differential channel 2 lower trigger level
        constexpr uint32_t DCH3_LOW = (8 << 16);  ///< Differential channel 3 lower trigger level
        constexpr uint32_t DCH4_LOW = (8 << 24);  ///< Differential channel 4 lower trigger level
    }

    /// DCHTH1_4_UPPER Register bits
    namespace dchth1_4_upper_bits {
        constexpr uint32_t DCH1_UP = (8 << 0);  ///< Differential channel 1 upper trigger level
        constexpr uint32_t DCH2_UP = (8 << 8);  ///< Differential channel 2 upper trigger level
        constexpr uint32_t DCH3_UP = (8 << 16);  ///< Differential channel 3 upper trigger level
        constexpr uint32_t DCH4_UP = (8 << 24);  ///< Differential channel 4 upper trigger level
    }

    /// DIFFCH_OUT1 Register bits
    namespace diffch_out1_bits {
        constexpr uint32_t DCH1 = (12 << 0);  ///< ADC differential output value 1
        constexpr uint32_t DWFR1 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t DVF1 = (1U << 17);  ///< Valid flag
        constexpr uint32_t DOF1 = (1U << 18);  ///< Overrun flag
    }

    /// DIFFCH_OUT2 Register bits
    namespace diffch_out2_bits {
        constexpr uint32_t DCH2 = (12 << 0);  ///< ADC differential output value 2
        constexpr uint32_t DWFR2 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t DVF2 = (1U << 17);  ///< Valid flag
        constexpr uint32_t DOF2 = (1U << 18);  ///< Overrun flag
    }

    /// DIFFCH_OUT3 Register bits
    namespace diffch_out3_bits {
        constexpr uint32_t DCH3 = (12 << 0);  ///< ADC differential output value 3
        constexpr uint32_t DWFR3 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t DVF3 = (1U << 17);  ///< Valid flag
        constexpr uint32_t DOF3 = (1U << 18);  ///< Overrun flag
    }

    /// DIFFCH_OUT4 Register bits
    namespace diffch_out4_bits {
        constexpr uint32_t DCH4 = (12 << 0);  ///< ADC differential output value 4
        constexpr uint32_t DWFR4 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t DVF4 = (1U << 17);  ///< Valid flag
        constexpr uint32_t DOF4 = (1U << 18);  ///< Overrun flag
    }

    /// DUIN_SEL Register bits
    namespace duin_sel_bits {
        constexpr uint32_t DU1_EN = (1U << 0);  ///< Differential unit 1 enable
        constexpr uint32_t DU1RES_NEG = (1U << 4);  ///< Differential unit 1 result negative
        constexpr uint32_t DU2_EN = (1U << 8);  ///< Differential unit 2 enable
        constexpr uint32_t DU2RES_NEG = (1U << 12);  ///< Differential unit 2 result negative
        constexpr uint32_t DU3_EN = (1U << 16);  ///< Differential unit 3 enable
        constexpr uint32_t DU3RES_NEG = (1U << 20);  ///< Differential unit 3 result negative
        constexpr uint32_t DU4_EN = (1U << 24);  ///< Differential unit 4 enable
        constexpr uint32_t DU4RES_NEG = (1U << 28);  ///< Differential unit 4 result negative
    }

    /// FILT_LO_CTRL Register bits
    namespace filt_lo_ctrl_bits {
        constexpr uint32_t FL_CH0_EN = (1U << 0);  ///< Lower threshold IIR filter enable channel 0
        constexpr uint32_t FL_CH1_EN = (1U << 1);  ///< Lower threshold IIR filter enable channel 1
        constexpr uint32_t FL_CH2_EN = (1U << 2);  ///< Lower threshold IIR filter enable channel 2
        constexpr uint32_t FL_CH3_EN = (1U << 3);  ///< Lower threshold IIR filter enable channel 3
        constexpr uint32_t FL_CH4_EN = (1U << 4);  ///< Lower threshold IIR filter enable channel 4
        constexpr uint32_t FL_CH5_EN = (1U << 5);  ///< Lower threshold IIR filter enable channel 5
        constexpr uint32_t FL_CH6_EN = (1U << 6);  ///< Lower threshold IIR filter enable channel 6
        constexpr uint32_t FL_CH7_EN = (1U << 7);  ///< Lower threshold IIR filter enable channel 7
        constexpr uint32_t FL_CH8_EN = (1U << 8);  ///< Lower threshold IIR filter enable channel 8
        constexpr uint32_t FL_CH9_EN = (1U << 9);  ///< Lower threshold IIR filter enable channel 9
        constexpr uint32_t FL_CH10_EN = (1U << 10);  ///< Lower threshold IIR filter enable channel 10
        constexpr uint32_t FL_CH11_EN = (1U << 11);  ///< Lower threshold IIR filter enable channel 11
    }

    /// FILT_OUT0 Register bits
    namespace filt_out0_bits {
        constexpr uint32_t FILT_OUT_CH0 = (12 << 0);  ///< ADC or filter output value channel 0
        constexpr uint32_t WFR0 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF0 = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF0 = (1U << 18);  ///< Overrun flag
    }

    /// FILT_OUT1 Register bits
    namespace filt_out1_bits {
        constexpr uint32_t FILT_OUT_CH1 = (12 << 0);  ///< ADC or filter output value channel 1
        constexpr uint32_t WFR1 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF1 = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF1 = (1U << 18);  ///< Overrun flag
    }

    /// FILT_OUT10 Register bits
    namespace filt_out10_bits {
        constexpr uint32_t FILT_OUT_CH10 = (12 << 0);  ///< ADC or filter output value channel 10
        constexpr uint32_t WFR10 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF10 = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF10 = (1U << 18);  ///< Overrun flag
    }

    /// FILT_OUT11 Register bits
    namespace filt_out11_bits {
        constexpr uint32_t FILT_OUT_CH11 = (12 << 0);  ///< ADC or filter output value channel 11
        constexpr uint32_t WFR11 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF11 = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF11 = (1U << 18);  ///< Overrun flag
    }

    /// FILT_OUT12 Register bits
    namespace filt_out12_bits {
        constexpr uint32_t FILT_OUT_CH12 = (12 << 0);  ///< ADC or filter output value channel 12
        constexpr uint32_t WFR12 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF12 = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF12 = (1U << 18);  ///< Overrun flag
    }

    /// FILT_OUT2 Register bits
    namespace filt_out2_bits {
        constexpr uint32_t FILT_OUT_CH2 = (12 << 0);  ///< ADC or filter output value channel 2
        constexpr uint32_t WFR2 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF2 = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF2 = (1U << 18);  ///< Overrun flag
    }

    /// FILT_OUT3 Register bits
    namespace filt_out3_bits {
        constexpr uint32_t FILT_OUT_CH3 = (12 << 0);  ///< ADC or filter output value channel 3
        constexpr uint32_t WFR3 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF3 = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF3 = (1U << 18);  ///< Overrun flag
    }

    /// FILT_OUT4 Register bits
    namespace filt_out4_bits {
        constexpr uint32_t FILT_OUT_CH4 = (12 << 0);  ///< ADC or filter output value channel 4
        constexpr uint32_t WFR4 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF4 = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF4 = (1U << 18);  ///< Overrun flag
    }

    /// FILT_OUT5 Register bits
    namespace filt_out5_bits {
        constexpr uint32_t FILT_OUT_CH5 = (12 << 0);  ///< ADC or filter output value channel 5
        constexpr uint32_t WFR5 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF5 = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF5 = (1U << 18);  ///< Overrun flag
    }

    /// FILT_OUT6 Register bits
    namespace filt_out6_bits {
        constexpr uint32_t FILT_OUT_CH6 = (12 << 0);  ///< ADC or filter output value channel 6
        constexpr uint32_t WFR6 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF6 = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF6 = (1U << 18);  ///< Overrun flag
    }

    /// FILT_OUT7 Register bits
    namespace filt_out7_bits {
        constexpr uint32_t FILT_OUT_CH7 = (12 << 0);  ///< ADC or filter output value channel 7
        constexpr uint32_t WFR7 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF7 = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF7 = (1U << 18);  ///< Overrun flag
    }

    /// FILT_OUT8 Register bits
    namespace filt_out8_bits {
        constexpr uint32_t FILT_OUT_CH8 = (12 << 0);  ///< ADC or filter output value channel 8
        constexpr uint32_t WFR8 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF8 = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF8 = (1U << 18);  ///< Overrun flag
    }

    /// FILT_OUT9 Register bits
    namespace filt_out9_bits {
        constexpr uint32_t FILT_OUT_CH9 = (12 << 0);  ///< ADC or filter output value channel 9
        constexpr uint32_t WFR9 = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF9 = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF9 = (1U << 18);  ///< Overrun flag
    }

    /// FILT_OUTEIM Register bits
    namespace filt_outeim_bits {
        constexpr uint32_t FILT_OUT_EIM = (12 << 0);  ///< ADC or filter output value for last EIM measurement
        constexpr uint32_t WFR_EIM = (1U << 16);  ///< Wait for read mode
        constexpr uint32_t VF_EIM = (1U << 17);  ///< Valid flag
        constexpr uint32_t OF_EIM = (1U << 18);  ///< Overrun flag
    }

    /// FILT_UP_CTRL Register bits
    namespace filt_up_ctrl_bits {
        constexpr uint32_t FU_CH0_EN = (1U << 0);  ///< Upper threshold IIR filter enable channel 0
        constexpr uint32_t FU_CH1_EN = (1U << 1);  ///< Upper threshold IIR filter enable channel 1
        constexpr uint32_t FU_CH2_EN = (1U << 2);  ///< Upper threshold IIR filter enable channel 2
        constexpr uint32_t FU_CH3_EN = (1U << 3);  ///< Upper threshold IIR filter enable channel 3
        constexpr uint32_t FU_CH4_EN = (1U << 4);  ///< Upper threshold IIR filter enable channel 4
        constexpr uint32_t FU_CH5_EN = (1U << 5);  ///< Upper threshold IIR filter enable channel 5
        constexpr uint32_t FU_CH6_EN = (1U << 6);  ///< Upper threshold IIR filter enable channel 6
        constexpr uint32_t FU_CH7_EN = (1U << 7);  ///< Upper threshold IIR filter enable channel 7
        constexpr uint32_t FU_CH8_EN = (1U << 8);  ///< Upper threshold IIR filter enable channel 8
        constexpr uint32_t FU_CH9_EN = (1U << 9);  ///< Upper threshold IIR filter enable channel 9
        constexpr uint32_t FU_CH10_EN = (1U << 10);  ///< Upper threshold IIR filter enable channel 10
        constexpr uint32_t FU_CH11_EN = (1U << 11);  ///< Upper threshold IIR filter enable channel 11
    }

    /// FILTCOEFF0_11 Register bits
    namespace filtcoeff0_11_bits {
        constexpr uint32_t CH0 = (2 << 0);  ///< Filter coefficients ADC channel 0
        constexpr uint32_t CH1 = (2 << 2);  ///< Filter coefficients ADC channel 1
        constexpr uint32_t CH2 = (2 << 4);  ///< Filter coefficients ADC channel 2
        constexpr uint32_t CH3 = (2 << 6);  ///< Filter coefficients ADC channel 3
        constexpr uint32_t CH4 = (2 << 8);  ///< Filter coefficients ADC channel 4
        constexpr uint32_t CH5 = (2 << 10);  ///< Filter coefficients ADC channel 5
        constexpr uint32_t CH6 = (2 << 12);  ///< Filter Coefficients ADC channel 6
        constexpr uint32_t CH7 = (2 << 14);  ///< Filter coefficients ADC channel 7
        constexpr uint32_t CH8 = (2 << 16);  ///< Filter coefficients ADC channel 8
        constexpr uint32_t CH9 = (2 << 18);  ///< Filter coefficients ADC channel 9
        constexpr uint32_t CH10 = (2 << 20);  ///< Filter coefficients ADC channel 10
        constexpr uint32_t CH11 = (2 << 22);  ///< Filter coefficients ADC channel 11
    }

    /// IRQCLR_1 Register bits
    namespace irqclr_1_bits {
        constexpr uint32_t VBATSEN_ISC = (1U << 0);  ///< ADC1 VBAT_SENSE interrupt status clear
        constexpr uint32_t VS_ISC = (1U << 1);  ///< ADC1 VS interrupt status clear
        constexpr uint32_t MON1_ISC = (1U << 2);  ///< ADC1 MON 1 interrupt status clear
        constexpr uint32_t MON2_ISC = (1U << 3);  ///< ADC1 MON 2 interrupt status clear
        constexpr uint32_t MON3_ISC = (1U << 4);  ///< ADC1 MON 3 interrupt status clear
        constexpr uint32_t MON4_ISC = (1U << 5);  ///< ADC1 MON 4 interrupt status clear
        constexpr uint32_t MON5_ISC = (1U << 6);  ///< ADC1 MON 5 interrupt status clear
        constexpr uint32_t P2_1_ISC = (1U << 7);  ///< ADC1 Port 2.1 interrupt status clear
        constexpr uint32_t P2_2_ISC = (1U << 8);  ///< ADC1 Port 2.2 interrupt status clear
        constexpr uint32_t P2_3_ISC = (1U << 9);  ///< ADC1 Port 2.3 interrupt status clear
        constexpr uint32_t P2_6_ISC = (1U << 10);  ///< ADC1 Port 2.6 interrupt status clear
        constexpr uint32_t P2_7_ISC = (1U << 11);  ///< ADC1 Port 2.7 interrupt status clear
        constexpr uint32_t P2_0_ISC = (1U << 12);  ///< ADC1 Port 2.0 interrupt status clear
        constexpr uint32_t EIM_ISC = (1U << 16);  ///< Exceptional interrupt measurement (EIM) status clear
        constexpr uint32_t ESM_ISC = (1U << 17);  ///< Exceptional sequence measurement (ESM) status clear
        constexpr uint32_t DU1LO_ISC = (1U << 24);  ///< Differential unit 1 lower interrupt status clear
        constexpr uint32_t DU1UP_ISC = (1U << 25);  ///< Differential unit 1 lower interrupt status clear
        constexpr uint32_t DU2LO_ISC = (1U << 26);  ///< Differential unit 2 lower interrupt status clear
        constexpr uint32_t DU2UP_ISC = (1U << 27);  ///< Differential unit 2 lower interrupt status clear
        constexpr uint32_t DU3LO_ISC = (1U << 28);  ///< Differential unit 3 lower interrupt status clear
        constexpr uint32_t DU3UP_ISC = (1U << 29);  ///< Differential unit 3 lower interrupt status clear
        constexpr uint32_t DU4LO_ISC = (1U << 30);  ///< Differential unit 4 lower interrupt status clear
        constexpr uint32_t DU4UP_ISC = (1U << 31);  ///< Differential unit 4 lower interrupt status clear
    }

    /// IRQCLR_2 Register bits
    namespace irqclr_2_bits {
        constexpr uint32_t VS_LO_ISC = (1U << 1);  ///< ADC1 VS lower threshold interrupt status clear
        constexpr uint32_t MON1_LO_ISC = (1U << 2);  ///< ADC1 MON 1 lower threshold interrupt status clear
        constexpr uint32_t MON2_LO_ISC = (1U << 3);  ///< ADC1 MON 2 lower threshold interrupt status clear
        constexpr uint32_t MON3_LO_ISC = (1U << 4);  ///< ADC1 MON 3 lower threshold interrupt status clear
        constexpr uint32_t MON4_LO_ISC = (1U << 5);  ///< ADC1 MON 4 lower threshold interrupt status clear
        constexpr uint32_t MON5_LO_ISC = (1U << 6);  ///< ADC1 MON 5 lower threshold interrupt status clear
        constexpr uint32_t P2_1_LO_ISC = (1U << 7);  ///< ADC1 port 2.1 lower threshold interrupt status clear
        constexpr uint32_t P2_2_LO_ISC = (1U << 8);  ///< ADC1 port 2.2 lower threshold interrupt status clear
        constexpr uint32_t P2_3_LO_ISC = (1U << 9);  ///< ADC1 port 2.3 lower threshold interrupt status clear
        constexpr uint32_t P2_6_LO_ISC = (1U << 10);  ///< ADC1 port 2.6 lower threshold interrupt status clear
        constexpr uint32_t P2_7_LO_ISC = (1U << 11);  ///< ADC1 port 2.7 lower threshold interrupt status clear
        constexpr uint32_t VS_UP_ISC = (1U << 17);  ///< ADC1 VS upper threshold interrupt status clear
        constexpr uint32_t MON1_UP_ISC = (1U << 18);  ///< ADC1 MON 1 upper threshold interrupt status clear
        constexpr uint32_t MON2_UP_ISC = (1U << 19);  ///< ADC1 MON 2 upper threshold interrupt status clear
        constexpr uint32_t MON3_UP_ISC = (1U << 20);  ///< ADC1 MON 3 upper threshold interrupt status clear
        constexpr uint32_t MON4_UP_ISC = (1U << 21);  ///< ADC1 MON 4 upper threshold interrupt status clear
        constexpr uint32_t MON5_UP_ISC = (1U << 22);  ///< ADC1 MON 5 upper threshold interrupt status clear
        constexpr uint32_t P2_1_UP_ISC = (1U << 23);  ///< ADC1 port 2.1 upper threshold interrupt status clear
        constexpr uint32_t P2_2_UP_ISC = (1U << 24);  ///< ADC1 port 2.2 upper threshold interrupt status clear
        constexpr uint32_t P2_3_UP_ISC = (1U << 25);  ///< ADC1 port 2.3 upper threshold interrupt status clear
        constexpr uint32_t P2_6_UP_ISC = (1U << 26);  ///< ADC1 port 2.6 upper threshold interrupt status clear
        constexpr uint32_t P2_7_UP_ISC = (1U << 27);  ///< ADC1 port 2.7 upper threshold interrupt status clear
    }

    /// IRQEN_1 Register bits
    namespace irqen_1_bits {
        constexpr uint32_t VBATSEN_IEN = (1U << 0);  ///< ADC1 VBAT_SENSE interrupt enable
        constexpr uint32_t VS_IEN = (1U << 1);  ///< ADC1 VS interrupt enable
        constexpr uint32_t MON1_IEN = (1U << 2);  ///< ADC1 MON 1 interrupt enable
        constexpr uint32_t MON2_IEN = (1U << 3);  ///< ADC1 MON 2 interrupt enable
        constexpr uint32_t MON3_IEN = (1U << 4);  ///< ADC1 MON 3 interrupt enable
        constexpr uint32_t MON4_IEN = (1U << 5);  ///< ADC1 MON 4 interrupt enable
        constexpr uint32_t MON5_IEN = (1U << 6);  ///< ADC1 MON 5 interrupt enable
        constexpr uint32_t P2_1_IEN = (1U << 7);  ///< ADC1 Port 2.1 interrupt enable
        constexpr uint32_t P2_2_IEN = (1U << 8);  ///< ADC1 Port 2.2 interrupt enable
        constexpr uint32_t P2_3_IEN = (1U << 9);  ///< ADC1 Port 2.3 interrupt enable
        constexpr uint32_t P2_6_IEN = (1U << 10);  ///< ADC1 Port 2.6 interrupt enable
        constexpr uint32_t P2_7_IEN = (1U << 11);  ///< ADC1 Port 2.7 interrupt enable
        constexpr uint32_t P2_0_IEN = (1U << 12);  ///< ADC1 Port 2.0 interrupt enable
        constexpr uint32_t EIM_IEN = (1U << 16);  ///< Exceptional interrupt measurement (EIM) interrupt enable
        constexpr uint32_t ESM_IEN = (1U << 17);  ///< Exceptional sequence measurement (ESM) interrupt enable
        constexpr uint32_t DU1LO_IEN = (1U << 24);  ///< Differential unit 1 lower interrupt enable
        constexpr uint32_t DU1UP_IEN = (1U << 25);  ///< Differential unit 1 upper interrupt enable
        constexpr uint32_t DU2LO_IEN = (1U << 26);  ///< Differential unit 2 lower interrupt enable
        constexpr uint32_t DU2UP_IEN = (1U << 27);  ///< Differential unit 2 upper interrupt enable
        constexpr uint32_t DU3LO_IEN = (1U << 28);  ///< Differential unit 3 lower interrupt enable
        constexpr uint32_t DU3UP_IEN = (1U << 29);  ///< Differential unit 3 upper interrupt enable
        constexpr uint32_t DU4LO_IEN = (1U << 30);  ///< Differential unit 4 lower interrupt enable
        constexpr uint32_t DU4UP_IEN = (1U << 31);  ///< Differential unit 4 upper interrupt enable
    }

    /// IRQEN_2 Register bits
    namespace irqen_2_bits {
        constexpr uint32_t VS_LO_IEN = (1U << 1);  ///< ADC1 VS lower threshold interrupt enable
        constexpr uint32_t MON1_LO_IEN = (1U << 2);  ///< ADC1 MON 1 lower threshold interrupt enable
        constexpr uint32_t MON2_LO_IEN = (1U << 3);  ///< ADC1 MON 2 lower threshold interrupt enable
        constexpr uint32_t MON3_LO_IEN = (1U << 4);  ///< ADC1 MON 3 lower threshold interrupt enable
        constexpr uint32_t MON4_LO_IEN = (1U << 5);  ///< ADC1 MON 4 lower threshold interrupt enable
        constexpr uint32_t MON5_LO_IEN = (1U << 6);  ///< ADC1 MON 5 lower threshold interrupt enable
        constexpr uint32_t P2_1_LO_IEN = (1U << 7);  ///< ADC1 port 2.1 lower threshold interrupt enable
        constexpr uint32_t P2_2_LO_IEN = (1U << 8);  ///< ADC1 port 2.2 lower threshold interrupt enable
        constexpr uint32_t P2_3_LO_IEN = (1U << 9);  ///< ADC1 port 2.3 lower threshold interrupt enable
        constexpr uint32_t P2_6_LO_IEN = (1U << 10);  ///< ADC1 port 2.6 lower threshold interrupt enable
        constexpr uint32_t P2_7_LO_IEN = (1U << 11);  ///< ADC1 port 2.7 lower threshold interrupt enable
        constexpr uint32_t VS_UP_IEN = (1U << 17);  ///< ADC1 VS upper threshold interrupt enable
        constexpr uint32_t MON1_UP_IEN = (1U << 18);  ///< ADC1 MON 1 upper threshold interrupt enable
        constexpr uint32_t MON2_UP_IEN = (1U << 19);  ///< ADC1 MON 2 upper threshold interrupt enable
        constexpr uint32_t MON3_UP_IEN = (1U << 20);  ///< ADC1 MON 3 upper threshold interrupt enable
        constexpr uint32_t MON4_UP_IEN = (1U << 21);  ///< ADC1 MON 4 upper threshold interrupt enable
        constexpr uint32_t MON5_UP_IEN = (1U << 22);  ///< ADC1 MON 5 upper threshold interrupt enable
        constexpr uint32_t P2_1_UP_IEN = (1U << 23);  ///< ADC1 port 2.1 upper threshold interrupt enable
        constexpr uint32_t P2_2_UP_IEN = (1U << 24);  ///< ADC1 port 2.2 upper threshold interrupt enable
        constexpr uint32_t P2_3_UP_IEN = (1U << 25);  ///< ADC1 port 2.3 upper threshold interrupt enable
        constexpr uint32_t P2_6_UP_IEN = (1U << 26);  ///< ADC1 port 2.6 upper threshold interrupt enable
        constexpr uint32_t P2_7_UP_IEN = (1U << 27);  ///< ADC1 port 2.7 upper threshold interrupt enable
    }

    /// IRQS_1 Register bits
    namespace irqs_1_bits {
        constexpr uint32_t VBATSEN_IS = (1U << 0);  ///< ADC1 channel 1 interrupt status
        constexpr uint32_t VS_IS = (1U << 1);  ///< ADC1 channel 0 interrupt status
        constexpr uint32_t MON1_IS = (1U << 2);  ///< ADC1 channel 2 interrupt status
        constexpr uint32_t MON2_IS = (1U << 3);  ///< ADC1 channel 3 interrupt status
        constexpr uint32_t MON3_IS = (1U << 4);  ///< ADC1 channel 4 interrupt status
        constexpr uint32_t MON4_IS = (1U << 5);  ///< ADC1 channel 5 interrupt status
        constexpr uint32_t MON5_IS = (1U << 6);  ///< ADC1 channel 6 interrupt status
        constexpr uint32_t P2_1_IS = (1U << 7);  ///< ADC1 channel 7 interrupt status
        constexpr uint32_t P2_2_IS = (1U << 8);  ///< ADC1 channel 8 interrupt status
        constexpr uint32_t P2_3_IS = (1U << 9);  ///< ADC1 channel 9 interrupt status
        constexpr uint32_t P2_6_IS = (1U << 10);  ///< ADC1 channel 10 interrupt status
        constexpr uint32_t P2_7_IS = (1U << 11);  ///< ADC1 channel 11 interrupt status
        constexpr uint32_t P2_0_IS = (1U << 12);  ///< ADC1 channel 12 interrupt status
        constexpr uint32_t EIM_IS = (1U << 16);  ///< Exceptional interrupt measurement (EIM) status
        constexpr uint32_t ESM_IS = (1U << 17);  ///< Exceptional sequence measurement (ESM) status
        constexpr uint32_t DU1LO_IS = (1U << 24);  ///< ADC1 Differential Unit 1 (DU1) lower channel interrupt status
        constexpr uint32_t DU1UP_IS = (1U << 25);  ///< ADC1 differential unit 1 (DU1) upper channel interrupt status
        constexpr uint32_t DU2LO_IS = (1U << 26);  ///< ADC1 differential unit 2 (DU2) lower channel interrupt status
        constexpr uint32_t DU2UP_IS = (1U << 27);  ///< ADC1 differential unit 2 (DU2) upper channel interrupt status
        constexpr uint32_t DU3LO_IS = (1U << 28);  ///< ADC1 differential unit 3 (DU3) lower Channel interrupt status
        constexpr uint32_t DU3UP_IS = (1U << 29);  ///< ADC1 differential unit 3 (DU3) upper channel interrupt status
        constexpr uint32_t DU4LO_IS = (1U << 30);  ///< ADC1 differential unit 4 (DU4) lower channel interrupt status
        constexpr uint32_t DU4UP_IS = (1U << 31);  ///< ADC1 differential unit 4 (DU4) upper channel interrupt dtatus
    }

    /// IRQS_2 Register bits
    namespace irqs_2_bits {
        constexpr uint32_t VS_LO_IS = (1U << 1);  ///< ADC1 VS lower threshold interrupt status
        constexpr uint32_t MON1_LO_IS = (1U << 2);  ///< ADC1 MON 1 lower threshold interrupt status
        constexpr uint32_t MON2_LO_IS = (1U << 3);  ///< ADC1 MON 2 lower threshold interrupt status
        constexpr uint32_t MON3_LO_IS = (1U << 4);  ///< ADC1 MON 3 lower threshold interrupt status
        constexpr uint32_t MON4_LO_IS = (1U << 5);  ///< ADC1 MON 4 lower threshold interrupt status
        constexpr uint32_t MON5_LO_IS = (1U << 6);  ///< ADC1 MON 5 lower threshold interrupt status
        constexpr uint32_t P2_1_LO_IS = (1U << 7);  ///< ADC1 port 2.1 lower threshold interrupt status
        constexpr uint32_t P2_2_LO_IS = (1U << 8);  ///< ADC1 port 2.2 lower threshold interrupt status
        constexpr uint32_t P2_3_LO_IS = (1U << 9);  ///< ADC1 port 2.3 lower threshold interrupt status
        constexpr uint32_t P2_6_LO_IS = (1U << 10);  ///< ADC1 port 2.6 lower threshold interrupt status
        constexpr uint32_t P2_7_LO_IS = (1U << 11);  ///< ADC1 port 2.7 lower threshold interrupt status
        constexpr uint32_t VS_UP_IS = (1U << 17);  ///< ADC1 VS upper threshold interrupt status
        constexpr uint32_t MON1_UP_IS = (1U << 18);  ///< ADC1 MON 1 upper threshold interrupt status
        constexpr uint32_t MON2_UP_IS = (1U << 19);  ///< ADC1 MON 2 upper threshold interrupt status
        constexpr uint32_t MON3_UP_IS = (1U << 20);  ///< ADC1 MON 3 upper threshold interrupt status
        constexpr uint32_t MON4_UP_IS = (1U << 21);  ///< ADC1 MON 4 upper threshold interrupt status
        constexpr uint32_t MON5_UP_IS = (1U << 22);  ///< ADC1 MON 5 upper threshold interrupt status
        constexpr uint32_t P2_1_UP_IS = (1U << 23);  ///< ADC1 port 2.1 upper threshold interrupt status
        constexpr uint32_t P2_2_UP_IS = (1U << 24);  ///< ADC1 port 2.2 upper threshold interrupt status
        constexpr uint32_t P2_3_UP_IS = (1U << 25);  ///< ADC1 port 2.3 upper threshold interrupt status
        constexpr uint32_t P2_6_UP_IS = (1U << 26);  ///< ADC1 port 2.6 upper threshold interrupt status
        constexpr uint32_t P2_7_UP_IS = (1U << 27);  ///< ADC1 port 2.7 upper threshold interrupt status
    }

    /// MAX_TIME Register bits
    namespace max_time_bits {
        constexpr uint32_t MAX_TIME = (8 << 0);  ///< Maximum Time in software mode
    }

    /// MMODE0_11 Register bits
    namespace mmode0_11_bits {
        constexpr uint32_t MMODE_0 = (2 << 0);  ///< Measurement mode channel 0
        constexpr uint32_t MMODE_1 = (2 << 2);  ///< Measurement mode channel 1
        constexpr uint32_t MMODE_2 = (2 << 4);  ///< Measurement mode channel 2
        constexpr uint32_t MMODE_3 = (2 << 6);  ///< Measurement mode channel 3
        constexpr uint32_t MMODE_4 = (2 << 8);  ///< Measurement mode channel 4
        constexpr uint32_t MMODE_5 = (2 << 10);  ///< Measurement mode channel 5
        constexpr uint32_t MMODE_6 = (2 << 12);  ///< Measurement mode channel 6
        constexpr uint32_t MMODE_7 = (2 << 14);  ///< Measurement mode channel 7
        constexpr uint32_t MMODE_8 = (2 << 16);  ///< Measurement mode channel 8
        constexpr uint32_t MMODE_9 = (2 << 18);  ///< Measurement mode channel 9
        constexpr uint32_t MMODE_10 = (2 << 20);  ///< Measurement mode channel 10
        constexpr uint32_t MMODE_11 = (2 << 22);  ///< Measurement mode channel 11
        constexpr uint32_t MMODE_D1 = (2 << 24);  ///< Measurement mode differential channel 1
        constexpr uint32_t MMODE_D2 = (2 << 26);  ///< Measurement mode differential channel 2
        constexpr uint32_t MMODE_D3 = (2 << 28);  ///< Measurement mode differential channel 3
        constexpr uint32_t MMODE_D4 = (2 << 30);  ///< Measurement mode differential channel 4
    }

    /// SQ_FB Register bits
    namespace sq_fb_bits {
        constexpr uint32_t SQ_FB = (5 << 0);  ///< Current sequence that caused software mode
        constexpr uint32_t SQ_STOP = (1U << 8);  ///< ADC1 sequencer stop signal for DPP
        constexpr uint32_t EIM_ACTIVE = (1U << 9);  ///< ADC1 EIM active
        constexpr uint32_t ESM_ACTIVE = (1U << 10);  ///< ADC1 ESM active
        constexpr uint32_t SQx = (4 << 11);  ///< Current active ADC1 sequence
        constexpr uint32_t CHx = (4 << 16);  ///< Current ADC1 channel
    }

    /// SQ0_1 Register bits
    namespace sq0_1_bits {
        constexpr uint32_t SQ0 = (12 << 0);  ///< Sequence 0 channel enable
        constexpr uint32_t SQ1 = (12 << 16);  ///< Sequence 1 channel enable
    }

    /// SQ10_11 Register bits
    namespace sq10_11_bits {
        constexpr uint32_t SQ10 = (12 << 0);  ///< Sequence 10 channel enable
        constexpr uint32_t SQ11 = (12 << 16);  ///< Sequence 11 channel enable
    }

    /// SQ2_3 Register bits
    namespace sq2_3_bits {
        constexpr uint32_t SQ2 = (12 << 0);  ///< Sequence 2 channel enable
        constexpr uint32_t SQ3 = (12 << 16);  ///< Sequence 3 channel enable
    }

    /// SQ4_5 Register bits
    namespace sq4_5_bits {
        constexpr uint32_t SQ4 = (12 << 0);  ///< Sequence 4 channel enable
        constexpr uint32_t SQ5 = (12 << 16);  ///< Sequence 5 channel enable
    }

    /// SQ6_7 Register bits
    namespace sq6_7_bits {
        constexpr uint32_t SQ6 = (12 << 0);  ///< Sequence 6 channel enable
        constexpr uint32_t SQ7 = (12 << 16);  ///< Sequence 7 channel enable
    }

    /// SQ8_9 Register bits
    namespace sq8_9_bits {
        constexpr uint32_t SQ8 = (12 << 0);  ///< Sequence 8 channel enable
        constexpr uint32_t SQ9 = (12 << 16);  ///< Sequence 9 channel enable
    }

    /// STS_1 Register bits
    namespace sts_1_bits {
        constexpr uint32_t DU1LO_STS = (1U << 24);  ///< ADC1 differential unit 1 (DU1) lower channel status
        constexpr uint32_t DU1UP_STS = (1U << 25);  ///< ADC1 differential unit 1 (DU1) upper channel status
        constexpr uint32_t DU2LO_STS = (1U << 26);  ///< ADC1 differential unit 2 (DU2) lower channel status
        constexpr uint32_t DU2UP_STS = (1U << 27);  ///< ADC1 differential unit 2 (DU2) upper channel status
        constexpr uint32_t DU3LO_STS = (1U << 28);  ///< ADC1 differential unit 3 (DU3) lower channel status
        constexpr uint32_t DU3UP_STS = (1U << 29);  ///< ADC1 differential unit 3 (DU3) upper channel status
        constexpr uint32_t DU4LO_STS = (1U << 30);  ///< ADC1 differential unit 4 (DU4) lower channel status
        constexpr uint32_t DU4UP_STS = (1U << 31);  ///< ADC1 differential unit 4 (DU4) upper channel status
    }

    /// STS_2 Register bits
    namespace sts_2_bits {
        constexpr uint32_t VS_LO_STS = (1U << 1);  ///< ADC1 VS lower threshold status
        constexpr uint32_t MON1_LO_STS = (1U << 2);  ///< ADC1 MON 1 lower threshold status
        constexpr uint32_t MON2_LO_STS = (1U << 3);  ///< ADC1 MON 2 lower threshold status
        constexpr uint32_t MON3_LO_STS = (1U << 4);  ///< ADC1 MON 3 lower threshold status
        constexpr uint32_t MON4_LO_STS = (1U << 5);  ///< ADC1 MON 4 lower threshold status
        constexpr uint32_t MON5_LO_STS = (1U << 6);  ///< ADC1 MON 5 lower threshold status
        constexpr uint32_t P2_1_LO_STS = (1U << 7);  ///< ADC1 port 2.1 lower threshold status
        constexpr uint32_t P2_2_LO_STS = (1U << 8);  ///< ADC1 port 2.2 lower threshold status
        constexpr uint32_t P2_3_LO_STS = (1U << 9);  ///< ADC1 port 2.3 lower threshold status
        constexpr uint32_t P2_6_LO_STS = (1U << 10);  ///< ADC1 port 2.6 lower threshold status
        constexpr uint32_t P2_7_LO_STS = (1U << 11);  ///< ADC1 port 2.7 lower threshold status
        constexpr uint32_t VS_UP_STS = (1U << 17);  ///< ADC1 VS upper threshold Status
        constexpr uint32_t MON1_UP_STS = (1U << 18);  ///< ADC1 MON 1 upper threshold Status
        constexpr uint32_t MON2_UP_STS = (1U << 19);  ///< ADC1 MON 2 upper threshold Status
        constexpr uint32_t MON3_UP_STS = (1U << 20);  ///< ADC1 MON 3 upper threshold Status
        constexpr uint32_t MON4_UP_STS = (1U << 21);  ///< ADC1 MON 4 upper threshold Status
        constexpr uint32_t MON5_UP_STS = (1U << 22);  ///< ADC1 MON 5 upper threshold Status
        constexpr uint32_t P2_1_UP_STS = (1U << 23);  ///< ADC1 port 2.1 upper threshold Status
        constexpr uint32_t P2_2_UP_STS = (1U << 24);  ///< ADC1 port 2.2 upper threshold Status
        constexpr uint32_t P2_3_UP_STS = (1U << 25);  ///< ADC1 port 2.3 upper threshold status
        constexpr uint32_t P2_6_UP_STS = (1U << 26);  ///< ADC1 port 2.6 upper threshold status
        constexpr uint32_t P2_7_UP_STS = (1U << 27);  ///< ADC1 port 2.7 upper threshold status
    }

    /// STSCLR_1 Register bits
    namespace stsclr_1_bits {
        constexpr uint32_t DU1LO_SC = (1U << 24);  ///< ADC1 differential unit 1 (DU1) lower channel status clear
        constexpr uint32_t DU1UP_SC = (1U << 25);  ///< ADC1 differential unit 1 (DU1) upper channel status clear
        constexpr uint32_t DU2LO_SC = (1U << 26);  ///< ADC1 differential unit 2 (DU2) lower channel status clear
        constexpr uint32_t DU2UP_SC = (1U << 27);  ///< ADC1 differential unit 2 (DU2) upper channel status clear
        constexpr uint32_t DU3LO_SC = (1U << 28);  ///< ADC1 differential unit 3 (DU3) lower channel status clear
        constexpr uint32_t DU3UP_SC = (1U << 29);  ///< ADC1 differential unit 3 (DU3) upper channel status clear
        constexpr uint32_t DU4LO_SC = (1U << 30);  ///< ADC1 differential unit 4 (DU4) lower channel status clear
        constexpr uint32_t DU4UP_SC = (1U << 31);  ///< ADC1 differential unit 4 (DU4) upper channel status clear
    }

    /// TH0_3_LOWER Register bits
    namespace th0_3_lower_bits {
        constexpr uint32_t CH0_LOW = (8 << 0);  ///< Channel 0 lower trigger level
        constexpr uint32_t CH1_LOW = (8 << 8);  ///< Channel 1 lower trigger level
        constexpr uint32_t CH2_LOW = (8 << 16);  ///< Channel 2 lower trigger level
        constexpr uint32_t CH3_LOW = (8 << 24);  ///< Channel 3 lower trigger level
    }

    /// TH0_3_UPPER Register bits
    namespace th0_3_upper_bits {
        constexpr uint32_t CH0_UP = (8 << 0);  ///< Channel 0 upper trigger level
        constexpr uint32_t CH1_UP = (8 << 8);  ///< Channel 1 upper trigger level
        constexpr uint32_t CH2_UP = (8 << 16);  ///< Channel 2 upper trigger level
        constexpr uint32_t CH3_UP = (8 << 24);  ///< Channel 3 upper trigger level
    }

    /// TH4_7_LOWER Register bits
    namespace th4_7_lower_bits {
        constexpr uint32_t CH4_LOW = (8 << 0);  ///< Channel 4 lower trigger level
        constexpr uint32_t CH5_LOW = (8 << 8);  ///< Channel 5 lower trigger level
        constexpr uint32_t CH6_LOW = (8 << 16);  ///< Channel 6 lower trigger level
        constexpr uint32_t CH7_LOW = (8 << 24);  ///< Channel 7 lower trigger level
    }

    /// TH4_7_UPPER Register bits
    namespace th4_7_upper_bits {
        constexpr uint32_t CH4_UP = (8 << 0);  ///< Channel 4 upper trigger level
        constexpr uint32_t CH5_UP = (8 << 8);  ///< Channel 5 upper trigger level
        constexpr uint32_t CH6_UP = (8 << 16);  ///< Channel 6 upper trigger level
        constexpr uint32_t CH7_UP = (8 << 24);  ///< Channel 7 upper trigger level
    }

    /// TH8_11_LOWER Register bits
    namespace th8_11_lower_bits {
        constexpr uint32_t CH8_LOW = (8 << 0);  ///< Channel 8 lower trigger level
        constexpr uint32_t CH9_LOW = (8 << 8);  ///< Channel 9 lower trigger level
        constexpr uint32_t CH10_LOW = (8 << 16);  ///< Channel 10 lower trigger level
        constexpr uint32_t CH11_LOW = (8 << 24);  ///< Channel 11 lower trigger level
    }

    /// TH8_11_UPPER Register bits
    namespace th8_11_upper_bits {
        constexpr uint32_t CH8_UP = (8 << 0);  ///< Channel 8 upper trigger level
        constexpr uint32_t CH9_UP = (8 << 8);  ///< Channel 9 upper trigger level
        constexpr uint32_t CH10_UP = (8 << 16);  ///< Channel 10 upper trigger level
        constexpr uint32_t CH11_UP = (8 << 24);  ///< Channel 11 upper trigger level
    }

}

// ============================================================================
// CCU6 Peripheral
// ============================================================================

namespace ccu6 {
    /// Base addresses
    constexpr uint32_t CCU6_BASE = 0x4000C000;

    /// CCU6 Register structure
    struct Registers {
        volatile uint32_t CC60R;  ///< Offset: 0x34 - Capture/compare register for channel CC60 register
        volatile uint32_t CC60SR;  ///< Offset: 0x14 - Capture/compare shadow register for channel CC60 register
        volatile uint32_t CC61R;  ///< Offset: 0x38 - Capture/compare register for channel CC61 register
        volatile uint32_t CC61SR;  ///< Offset: 0x18 - Capture/compare shadow register for channel CC61 register
        volatile uint32_t CC62R;  ///< Offset: 0x3C - Capture/compare register for channel CC62 register
        volatile uint32_t CC62SR;  ///< Offset: 0x1C - Capture/compare shadow register for channel CC62 register
        volatile uint32_t CC63R;  ///< Offset: 0x00 - Capture/compare for channel CC63 register
        volatile uint32_t CC63SR;  ///< Offset: 0x20 - Capture/compare shadow for channel CC63 register
        volatile uint32_t CMPMODIF;  ///< Offset: 0x10 - Compare state modification register
        volatile uint32_t CMPSTAT;  ///< Offset: 0x80 - Compare state register
        volatile uint32_t IEN;  ///< Offset: 0x44 - Capture/compare interrupt enable register
        volatile uint32_t INP;  ///< Offset: 0x48 - Capture/compare interrupt node pointer register
        volatile uint32_t IS;  ///< Offset: 0x68 - Capture/compare interrupt status register
        volatile uint32_t ISR;  ///< Offset: 0x0C - Capture/compare interrupt status reset register
        volatile uint32_t ISS;  ///< Offset: 0x4C - Capture/compare interrupt status set register
        volatile uint32_t MCMCTR;  ///< Offset: 0x54 - Multi-channel mode control register
        volatile uint32_t MCMOUT;  ///< Offset: 0x64 - Multi-channel mode output register
        volatile uint32_t MCMOUTS;  ///< Offset: 0x08 - Multi-channel mode output shadow register
        volatile uint32_t MODCTR;  ///< Offset: 0x5C - Modulation control register
        volatile uint32_t PISEL0;  ///< Offset: 0x6C - Port input select 0 register
        volatile uint32_t PISEL2;  ///< Offset: 0x74 - Port input select 2 register
        volatile uint32_t PSLR;  ///< Offset: 0x50 - Passive state level register
        volatile uint32_t T12;  ///< Offset: 0x78 - Timer T12 counter register
        volatile uint32_t T12DTC;  ///< Offset: 0x2C - Dead-time control register for timer T12 low register
        volatile uint32_t T12MSEL;  ///< Offset: 0x40 - T12 capture/compare mode select register
        volatile uint32_t T12PR;  ///< Offset: 0x24 - Timer T12 period register
        volatile uint32_t T13;  ///< Offset: 0x7C - Timer T13 counter register
        volatile uint32_t T13PR;  ///< Offset: 0x28 - Timer T13 period register
        volatile uint32_t TCTR0;  ///< Offset: 0x30 - Timer control 0 register
        volatile uint32_t TCTR2;  ///< Offset: 0x58 - Timer control 2 register
        volatile uint32_t TCTR4;  ///< Offset: 0x04 - Timer control 4 register
        volatile uint32_t TRPCTR;  ///< Offset: 0x60 - Trap control register
    };

    /// Peripheral instances
    inline Registers* CCU6 = reinterpret_cast<Registers*>(CCU6_BASE);

    // Bit definitions
    /// CC60R Register bits
    namespace cc60r_bits {
        constexpr uint32_t CCV = (16 << 0);  ///< Channel 0 capture/compare value
    }

    /// CC60SR Register bits
    namespace cc60sr_bits {
        constexpr uint32_t CCS = (16 << 0);  ///< Shadow register for channel 0 capture/compare value
    }

    /// CC61R Register bits
    namespace cc61r_bits {
        constexpr uint32_t CCV = (16 << 0);  ///< Channel 1 capture/compare value
    }

    /// CC61SR Register bits
    namespace cc61sr_bits {
        constexpr uint32_t CCS = (16 << 0);  ///< Shadow register for channel 1 capture/compare value
    }

    /// CC62R Register bits
    namespace cc62r_bits {
        constexpr uint32_t CCV = (16 << 0);  ///< Channel 2 capture/compare value
    }

    /// CC62SR Register bits
    namespace cc62sr_bits {
        constexpr uint32_t CCS = (16 << 0);  ///< Shadow register for channel 2 capture/compare value
    }

    /// CC63R Register bits
    namespace cc63r_bits {
        constexpr uint32_t CCV = (16 << 0);  ///< Channel CC63 compare value low byte
    }

    /// CC63SR Register bits
    namespace cc63sr_bits {
        constexpr uint32_t CCS = (16 << 0);  ///< Shadow register for channel CC63 compare value
    }

    /// CMPMODIF Register bits
    namespace cmpmodif_bits {
        constexpr uint32_t MCC60S = (1U << 0);  ///< Capture/compare status modification bit 0 (set)
        constexpr uint32_t MCC61S = (1U << 1);  ///< Capture/compare status modification bit 1 (set)
        constexpr uint32_t MCC62S = (1U << 2);  ///< Capture/compare status modification bit 2 (set)
        constexpr uint32_t MCC63S = (1U << 6);  ///< Capture/compare status modification bits (set)
        constexpr uint32_t MCC60R = (1U << 8);  ///< Capture/compare status modification bit 0 (reset)
        constexpr uint32_t MCC61R = (1U << 9);  ///< Capture/compare status modification bit 1 (reset)
        constexpr uint32_t MCC62R = (1U << 10);  ///< Capture/compare status modification bit 2 (reset)
        constexpr uint32_t MCC63R = (1U << 14);  ///< Capture/compare status modification bits (reset)
    }

    /// CMPSTAT Register bits
    namespace cmpstat_bits {
        constexpr uint32_t CC60ST = (1U << 0);  ///< Capture/compare state bits
        constexpr uint32_t CC61ST = (1U << 1);  ///< Capture/compare state bits
        constexpr uint32_t CC62ST = (1U << 2);  ///< Capture/compare state bits
        constexpr uint32_t CCPOS0 = (1U << 3);  ///< Sampled Hall pattern bit 0
        constexpr uint32_t CCPOS1 = (1U << 4);  ///< Sampled Hall pattern bit 1
        constexpr uint32_t CCPOS2 = (1U << 5);  ///< Sampled Hall pattern bit 2
        constexpr uint32_t CC63ST = (1U << 6);  ///< Capture/compare state bits
        constexpr uint32_t CC60PS = (1U << 8);  ///< Passive state select for compare outputs
        constexpr uint32_t COUT60PS = (1U << 9);  ///< Passive state select for compare outputs
        constexpr uint32_t CC61PS = (1U << 10);  ///< Passive state select for compare outputs
        constexpr uint32_t COUT61PS = (1U << 11);  ///< Passive state select for compare outputs
        constexpr uint32_t CC62PS = (1U << 12);  ///< Passive state select for compare outputs
        constexpr uint32_t COUT62PS = (1U << 13);  ///< Passive state select for compare outputs
        constexpr uint32_t COUT63PS = (1U << 14);  ///< Passive state select for compare outputs
        constexpr uint32_t T13IM = (1U << 15);  ///< T13 inverted modulation
    }

    /// IEN Register bits
    namespace ien_bits {
        constexpr uint32_t ENCC60R = (1U << 0);  ///< Capture, compare-match rising edge interrupt enable for channel 0
        constexpr uint32_t ENCC60F = (1U << 1);  ///< Capture, compare-match falling edge interrupt enable for channel 0
        constexpr uint32_t ENCC61R = (1U << 2);  ///< Capture, compare-match rising edge interrupt enable for channel 1
        constexpr uint32_t ENCC61F = (1U << 3);  ///< Capture, compare-match falling edge interrupt enable for channel 1
        constexpr uint32_t ENCC62R = (1U << 4);  ///< Capture, compare-match rising edge interrupt enable for channel 2
        constexpr uint32_t ENCC62F = (1U << 5);  ///< Capture, compare-match falling edge interrupt enable for channel 2
        constexpr uint32_t ENT12OM = (1U << 6);  ///< Enable interrupt for T12 one-match
        constexpr uint32_t ENT12PM = (1U << 7);  ///< Enable interrupt for T12 period-match
        constexpr uint32_t ENT13CM = (1U << 8);  ///< Enable interrupt for T13 compare-match
        constexpr uint32_t ENT13PM = (1U << 9);  ///< Enable interrupt for T13 period-match
        constexpr uint32_t ENTRPF = (1U << 10);  ///< Enable interrupt for trap flag
        constexpr uint32_t ENCHE = (1U << 12);  ///< Enable interrupt for correct Hall Event
        constexpr uint32_t ENWHE = (1U << 13);  ///< Enable interrupt for wrong Hall Event
        constexpr uint32_t ENIDLE = (1U << 14);  ///< Enable idle
        constexpr uint32_t ENSTR = (1U << 15);  ///< Enable multi-channel mode shadow transfer interrupt
    }

    /// INP Register bits
    namespace inp_bits {
        constexpr uint32_t INPCC60 = (2 << 0);  ///< Interrupt node pointer for channel 0 interrupts
        constexpr uint32_t INPCC61 = (2 << 2);  ///< Interrupt node pointer for channel 1 interrupts
        constexpr uint32_t INPCC62 = (2 << 4);  ///< Interrupt node pointer for channel 2 interrupts
        constexpr uint32_t INPCHE = (2 << 6);  ///< Interrupt node pointer for the CHE interrupt
        constexpr uint32_t INPERR = (2 << 8);  ///< Interrupt node pointer for error interrupts
        constexpr uint32_t INPT12 = (2 << 10);  ///< Interrupt node pointer for timer T12 interrupts
        constexpr uint32_t INPT13 = (2 << 12);  ///< Interrupt node pointer for timer T13 interrupts
    }

    /// IS Register bits
    namespace is_bits {
        constexpr uint32_t ICC60R = (1U << 0);  ///< Capture, compare-match rising edge flag
        constexpr uint32_t ICC60F = (1U << 1);  ///< Capture, compare-match falling edge flag
        constexpr uint32_t ICC61R = (1U << 2);  ///< Capture, compare-match rising edge flag
        constexpr uint32_t ICC61F = (1U << 3);  ///< Capture, compare-match falling edge flag
        constexpr uint32_t ICC62R = (1U << 4);  ///< Capture, compare-match rising edge flag
        constexpr uint32_t ICC62F = (1U << 5);  ///< Capture, compare-match falling edge flag
        constexpr uint32_t T12OM = (1U << 6);  ///< Timer T12 one-match flag
        constexpr uint32_t T12PM = (1U << 7);  ///< Timer T12 period-match flag
        constexpr uint32_t T13CM = (1U << 8);  ///< Timer T13 compare-match flag
        constexpr uint32_t T13PM = (1U << 9);  ///< Timer T13 period-match flag
        constexpr uint32_t TRPF = (1U << 10);  ///< Trap flag
        constexpr uint32_t TRPS = (1U << 11);  ///< Trap state
        constexpr uint32_t CHE = (1U << 12);  ///< Correct Hall event
        constexpr uint32_t WHE = (1U << 13);  ///< Wrong Hall event
        constexpr uint32_t IDLE = (1U << 14);  ///< IDLE state
        constexpr uint32_t STR = (1U << 15);  ///< Multi-channel mode shadow transfer request
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t RCC60R = (1U << 0);  ///< Reset capture, compare-match rising edge flag
        constexpr uint32_t RCC60F = (1U << 1);  ///< Reset capture, compare-match falling edge flag
        constexpr uint32_t RCC61R = (1U << 2);  ///< Reset capture, compare-match rising edge Flag
        constexpr uint32_t RCC61F = (1U << 3);  ///< Reset capture, compare-match falling edge flag
        constexpr uint32_t RCC62R = (1U << 4);  ///< Reset capture, compare-match rising edge flag
        constexpr uint32_t RCC62F = (1U << 5);  ///< Reset capture, compare-match falling edge flag
        constexpr uint32_t RT12OM = (1U << 6);  ///< Reset timer T12 one-match flag
        constexpr uint32_t RT12PM = (1U << 7);  ///< Reset timer T12 period-match flag
        constexpr uint32_t RT13CM = (1U << 8);  ///< Reset timer T13 compare-match flag
        constexpr uint32_t RT13PM = (1U << 9);  ///< Reset timer T13 period-Match flag
        constexpr uint32_t RTRPF = (1U << 10);  ///< Reset trap flag
        constexpr uint32_t RCHE = (1U << 12);  ///< Reset correct Hall event flag
        constexpr uint32_t RWHE = (1U << 13);  ///< Reset wrong Hall event flag
        constexpr uint32_t RIDLE = (1U << 14);  ///< Reset IDLE flag
        constexpr uint32_t RSTR = (1U << 15);  ///< Reset STR flag
    }

    /// ISS Register bits
    namespace iss_bits {
        constexpr uint32_t SCC60R = (1U << 0);  ///< Set capture, compare-match rising edge flag
        constexpr uint32_t SCC60F = (1U << 1);  ///< Set capture, compare-match falling edge flag
        constexpr uint32_t SCC61R = (1U << 2);  ///< Set capture, compare-match rising edge flag
        constexpr uint32_t SCC61F = (1U << 3);  ///< Set capture, compare-match falling edge flag
        constexpr uint32_t SCC62R = (1U << 4);  ///< Set capture, compare-match rising edge flag
        constexpr uint32_t SCC62F = (1U << 5);  ///< Set capture, compare-match falling edge flag
        constexpr uint32_t ST12OM = (1U << 6);  ///< Set timer T12 one-match flag
        constexpr uint32_t ST12PM = (1U << 7);  ///< Set timer T12 period-match flag
        constexpr uint32_t ST13CM = (1U << 8);  ///< Set timer T13 compare-match flag
        constexpr uint32_t ST13PM = (1U << 9);  ///< Set timer T13 period-match flag
        constexpr uint32_t STRPF = (1U << 10);  ///< Set trap flag
        constexpr uint32_t SWHC = (1U << 11);  ///< Software Hall compare
        constexpr uint32_t SCHE = (1U << 12);  ///< Set correct Hall event flag
        constexpr uint32_t SWHE = (1U << 13);  ///< Set wrong Hall event flag
        constexpr uint32_t SIDLE = (1U << 14);  ///< Set IDLE flag
        constexpr uint32_t SSTR = (1U << 15);  ///< Set STR flag
    }

    /// MCMCTR Register bits
    namespace mcmctr_bits {
        constexpr uint32_t SWSEL = (3 << 0);  ///< Switching selection
        constexpr uint32_t SWSYN = (2 << 4);  ///< Switching Synchronization
        constexpr uint32_t STE12U = (1U << 8);  ///< Shadow transfer enable for T12 upcounting
        constexpr uint32_t STE12D = (1U << 9);  ///< Shadow transfer Enable for T12 downcounting
        constexpr uint32_t STE13U = (1U << 10);  ///< Shadow transfer enable for T13 upcounting
    }

    /// MCMOUT Register bits
    namespace mcmout_bits {
        constexpr uint32_t MCMP = (6 << 0);  ///< Multi-channel PWM pattern
        constexpr uint32_t R = (1U << 6);  ///< Reminder Flag
        constexpr uint32_t EXPH = (3 << 8);  ///< Expected Hall pattern
        constexpr uint32_t CURH = (3 << 11);  ///< Current Hall pattern
    }

    /// MCMOUTS Register bits
    namespace mcmouts_bits {
        constexpr uint32_t MCMPS = (6 << 0);  ///< Multi-channel PWM pattern shadow
        constexpr uint32_t STRMCM = (1U << 7);  ///< Shadow transfer request for MCMPS
        constexpr uint32_t EXPHS = (3 << 8);  ///< Expected Hall pattern shadow
        constexpr uint32_t CURHS = (3 << 11);  ///< Current Hall pattern shadow
        constexpr uint32_t STRHP = (1U << 15);  ///< Shadow transfer request for the Hall pattern
    }

    /// MODCTR Register bits
    namespace modctr_bits {
        constexpr uint32_t T12MODEN = (6 << 0);  ///< T12 modulation enable
        constexpr uint32_t MCMEN = (1U << 7);  ///< Multi-channel mode enable
        constexpr uint32_t T13MODEN = (6 << 8);  ///< T13 modulation enable
        constexpr uint32_t ECT13O = (1U << 15);  ///< Enable compare timer T13 output
    }

    /// PISEL0 Register bits
    namespace pisel0_bits {
        constexpr uint32_t ISCC60 = (2 << 0);  ///< Input select for CC60
        constexpr uint32_t ISCC61 = (2 << 2);  ///< Input select for CC61
        constexpr uint32_t ISCC62 = (2 << 4);  ///< Input select for CC62
        constexpr uint32_t ISTRP = (2 << 6);  ///< Input select for CTRAP
        constexpr uint32_t ISPOS0 = (2 << 8);  ///< Input select for CCPOS0
        constexpr uint32_t ISPOS1 = (2 << 10);  ///< Input select for CCPOS1
        constexpr uint32_t ISPOS2 = (2 << 12);  ///< Input select for CCPOS2
        constexpr uint32_t IST12HR = (2 << 14);  ///< Input select for T12HR
    }

    /// PISEL2 Register bits
    namespace pisel2_bits {
        constexpr uint32_t IST13HR = (2 << 0);  ///< Input select for T13HR
        constexpr uint32_t ISCNT12 = (2 << 2);  ///< Input select for T12 counting input
        constexpr uint32_t ISCNT13 = (2 << 4);  ///< Input select for T13 counting input
        constexpr uint32_t T12EXT = (1U << 6);  ///< Extension for T12HR inputs
        constexpr uint32_t T13EXT = (1U << 7);  ///< Extension for T13HR inputs
    }

    /// PSLR Register bits
    namespace pslr_bits {
        constexpr uint32_t PSL = (6 << 0);  ///< Compare outputs passive state level
        constexpr uint32_t PSL63 = (1U << 7);  ///< Passive state level of output COUT63
    }

    /// T12 Register bits
    namespace t12_bits {
        constexpr uint32_t T12CV = (16 << 0);  ///< Timer T12 counter value
    }

    /// T12DTC Register bits
    namespace t12dtc_bits {
        constexpr uint32_t DTM = (8 << 0);  ///< Dead-time
        constexpr uint32_t DTE0 = (1U << 8);  ///< Dead-time enable bit 0
        constexpr uint32_t DTE1 = (1U << 9);  ///< Dead-time enable bit 1
        constexpr uint32_t DTE2 = (1U << 10);  ///< Dead-time enable bit 2
        constexpr uint32_t DTR0 = (1U << 12);  ///< Dead-time run indication bit 0
        constexpr uint32_t DTR1 = (1U << 13);  ///< Dead-time run indication bit 1
        constexpr uint32_t DTR2 = (1U << 14);  ///< Dead-time run indication bit 2
    }

    /// T12MSEL Register bits
    namespace t12msel_bits {
        constexpr uint32_t MSEL60 = (4 << 0);  ///< Capture/compare mode selection
        constexpr uint32_t MSEL61 = (4 << 4);  ///< Capture/compare mode selection
        constexpr uint32_t MSEL62 = (4 << 8);  ///< Capture/compare mode selection
        constexpr uint32_t HSYNC = (3 << 12);  ///< Hall synchronization
        constexpr uint32_t DBYP = (1U << 15);  ///< Delay bypass
    }

    /// T12PR Register bits
    namespace t12pr_bits {
        constexpr uint32_t T12PV = (16 << 0);  ///< T12 period value
    }

    /// T13 Register bits
    namespace t13_bits {
        constexpr uint32_t T13CV = (16 << 0);  ///< Timer T13 counter value
    }

    /// T13PR Register bits
    namespace t13pr_bits {
        constexpr uint32_t T13PV = (16 << 0);  ///< T13 period value
    }

    /// TCTR0 Register bits
    namespace tctr0_bits {
        constexpr uint32_t T12CLK = (3 << 0);  ///< Timer T12 input clock select
        constexpr uint32_t T12PRE = (1U << 3);  ///< Timer T12 prescaler bit
        constexpr uint32_t T12R = (1U << 4);  ///< Timer T12 run bit
        constexpr uint32_t STE12 = (1U << 5);  ///< Timer T12 shadow transfer enable
        constexpr uint32_t CDIR = (1U << 6);  ///< Count direction of timer T12
        constexpr uint32_t CTM = (1U << 7);  ///< T12 operating mode
        constexpr uint32_t T13CLK = (3 << 8);  ///< Timer T13 input clock Select
        constexpr uint32_t T13PRE = (1U << 11);  ///< Timer T13 prescaler bit
        constexpr uint32_t T13R = (1U << 12);  ///< Timer T13 run bit
        constexpr uint32_t STE13 = (1U << 13);  ///< Timer T13 shadow transfer enable
    }

    /// TCTR2 Register bits
    namespace tctr2_bits {
        constexpr uint32_t T12SSC = (1U << 0);  ///< Timer T12 single shot control
        constexpr uint32_t T13SSC = (1U << 1);  ///< Timer T13 single shot control
        constexpr uint32_t T13TEC = (3 << 2);  ///< T13 trigger event control
        constexpr uint32_t T13TED = (2 << 5);  ///< Timer T13 trigger event direction
        constexpr uint32_t T12RSEL = (2 << 8);  ///< Timer T12 external run selection
        constexpr uint32_t T13RSEL = (2 << 10);  ///< Timer T13 external run selection
    }

    /// TCTR4 Register bits
    namespace tctr4_bits {
        constexpr uint32_t T12RR = (1U << 0);  ///< Timer T12 run reset
        constexpr uint32_t T12RS = (1U << 1);  ///< Timer T12 run set
        constexpr uint32_t T12RES = (1U << 2);  ///< Timer T12 reset
        constexpr uint32_t DTRES = (1U << 3);  ///< Dead-time counter reset
        constexpr uint32_t T12CNT = (1U << 5);  ///< Timer T12 count event
        constexpr uint32_t T12STR = (1U << 6);  ///< Timer T12 shadow transfer request
        constexpr uint32_t T12STD = (1U << 7);  ///< Timer T12 shadow transfer disable
        constexpr uint32_t T13RR = (1U << 8);  ///< Timer T13 run reset
        constexpr uint32_t T13RS = (1U << 9);  ///< Timer T13 run set
        constexpr uint32_t T13RES = (1U << 10);  ///< Timer T13 reset
        constexpr uint32_t T13CNT = (1U << 13);  ///< Timer T13 count event
        constexpr uint32_t T13STR = (1U << 14);  ///< Timer T13 shadow transfer request
        constexpr uint32_t T13STD = (1U << 15);  ///< Timer T13 shadow transfer disable
    }

    /// TRPCTR Register bits
    namespace trpctr_bits {
        constexpr uint32_t TRPM10 = (2 << 0);  ///< Trap mode control bits 1, 0
        constexpr uint32_t TRPM2 = (1U << 2);  ///< Trap mode control bit 2
        constexpr uint32_t TRPEN = (6 << 8);  ///< Trap enable control
        constexpr uint32_t TRPEN13 = (1U << 14);  ///< Trap enable control for timer T13
        constexpr uint32_t TRPPEN = (1U << 15);  ///< Trap pin enable
    }

}

// ============================================================================
// CPU Peripheral
// ============================================================================

namespace cpu {
    /// Base addresses
    constexpr uint32_t CPU_BASE = 0xE000E000;

    /// CPU Register structure
    struct Registers {
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application interrupt/reset control register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration control register
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPU ID base register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt control and state register
        volatile uint32_t NVIC_ICER;  ///< Offset: 0x180 - Interrupt clear-enable register
        volatile uint32_t NVIC_ICPR;  ///< Offset: 0x280 - Interrupt clear-pending register
        volatile uint32_t NVIC_IPR0;  ///< Offset: 0x400 - Interrupt priority 0 register
        volatile uint32_t NVIC_IPR1;  ///< Offset: 0x404 - Interrupt priority 1 register
        volatile uint32_t NVIC_IPR2;  ///< Offset: 0x408 - Interrupt priority 2 register
        volatile uint32_t NVIC_IPR3;  ///< Offset: 0x40C - Interrupt priority 3 register
        volatile uint32_t NVIC_IPR4;  ///< Offset: 0x410 - Interrupt priority 4 register
        volatile uint32_t NVIC_IPR5;  ///< Offset: 0x414 - Interrupt priority 5 register
        volatile uint32_t NVIC_ISER;  ///< Offset: 0x100 - Interrupt set-enable register
        volatile uint32_t NVIC_ISPR;  ///< Offset: 0x200 - Interrupt set-pending register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System control register
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System handler priority 2 register
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System handler priority 3 register
        volatile uint32_t SYSTICK_CALIB;  ///< Offset: 0x1C - SysTick calibration value register
        volatile uint32_t SYSTICK_CSR;  ///< Offset: 0x10 - SysTick control and status register
        volatile uint32_t SYSTICK_CVR;  ///< Offset: 0x18 - SysTick current value register
        volatile uint32_t SYSTICK_RVR;  ///< Offset: 0x14 - SysTick reload value register
    };

    /// Peripheral instances
    inline Registers* CPU = reinterpret_cast<Registers*>(CPU_BASE);

    // Bit definitions
    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< VECTCLRACTIVE
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< System reset request
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< Data endianness
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Vector key
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< UNALIGN_TRP
        constexpr uint32_t STKALIGN = (1U << 9);  ///< STKALIGN
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t REVISION = (4 << 0);  ///< Revision number
        constexpr uint32_t PARTNO = (12 << 4);  ///< Part number
        constexpr uint32_t CONSTANT = (4 << 16);  ///< Constant
        constexpr uint32_t VARIANT = (4 << 20);  ///< Variant number
        constexpr uint32_t IMPLEMENTER = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (6 << 0);  ///< VECTACTIVATE
        constexpr uint32_t VECTPENDING = (6 << 12);  ///< VECTPENDING
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick exception clear pending
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick exception set pending
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV clear pending
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV set pending
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI set pending
    }

    /// NVIC_ICER Register bits
    namespace nvic_icer_bits {
        constexpr uint32_t Int_GPT1 = (1U << 0);  ///< Interrupt clear for GPT1
        constexpr uint32_t Int_GPT2 = (1U << 1);  ///< Interrupt clear for GPT2
        constexpr uint32_t Int_ADC2 = (1U << 2);  ///< Interrupt clear for MU, ADC2
        constexpr uint32_t Int_ADC1 = (1U << 3);  ///< Interrupt clear for ADC1
        constexpr uint32_t Int_CCU6SR0 = (1U << 4);  ///< Interrupt clear for CCU6 SR0
        constexpr uint32_t Int_CCU6SR1 = (1U << 5);  ///< Interrupt clear for CCU6 SR1
        constexpr uint32_t Int_CCU6SR2 = (1U << 6);  ///< Interrupt clear for CCU6 SR2
        constexpr uint32_t Int_CCU6SR3 = (1U << 7);  ///< Interrupt clear for CCU6 SR3
        constexpr uint32_t Int_SSC1 = (1U << 8);  ///< Interrupt clear for SSC1
        constexpr uint32_t Int_SSC2 = (1U << 9);  ///< Interrupt clear for SSC2
        constexpr uint32_t Int_UART1 = (1U << 10);  ///< Interrupt clear for UART1
        constexpr uint32_t Int_UART2 = (1U << 11);  ///< Interrupt clear for UART2
        constexpr uint32_t Int_EXINT0 = (1U << 12);  ///< Interrupt clear for external Int 0
        constexpr uint32_t Int_EXINT1 = (1U << 13);  ///< Interrupt clear for external Int 1
        constexpr uint32_t Int_WAKEUP = (1U << 14);  ///< Interrupt clear for WAKEUP
        constexpr uint32_t Int_LS1 = (1U << 17);  ///< Interrupt clear for LS1
        constexpr uint32_t Int_LS2 = (1U << 18);  ///< Interrupt clear for LS2
        constexpr uint32_t Int_HS1 = (1U << 19);  ///< Interrupt clear for HS1
        constexpr uint32_t Int_HS2 = (1U << 20);  ///< Interrupt clear for HS2
        constexpr uint32_t Int_DU = (1U << 21);  ///< Interrupt clear for differential unit
        constexpr uint32_t Int_MON = (1U << 22);  ///< Interrupt clear for MON
        constexpr uint32_t Int_PORT2 = (1U << 23);  ///< Interrupt Clear for PORT2
    }

    /// NVIC_ICPR Register bits
    namespace nvic_icpr_bits {
        constexpr uint32_t Int_GPT1 = (1U << 0);  ///< Interrupt clear pending for GPT1
        constexpr uint32_t Int_GPT2 = (1U << 1);  ///< Interrupt clear pending for GPT2
        constexpr uint32_t Int_ADC2 = (1U << 2);  ///< Interrupt clear pending for MU, ADC2
        constexpr uint32_t Int_ADC1 = (1U << 3);  ///< Interrupt clear pending for ADC1
        constexpr uint32_t Int_CCU6SR0 = (1U << 4);  ///< Interrupt clear pending for CCU6 SR0
        constexpr uint32_t Int_CCU6SR1 = (1U << 5);  ///< Interrupt clear pending for CCU6 SR1
        constexpr uint32_t Int_CCU6SR2 = (1U << 6);  ///< Interrupt clear pending for CCU6 SR2
        constexpr uint32_t Int_CCU6SR3 = (1U << 7);  ///< Interrupt clear pending for CCU6 SR3
        constexpr uint32_t Int_SSC1 = (1U << 8);  ///< Interrupt clear pending for SSC1
        constexpr uint32_t Int_SSC2 = (1U << 9);  ///< Interrupt clear pending for SSC2
        constexpr uint32_t Int_UART1 = (1U << 10);  ///< Interrupt clear pending for UART1
        constexpr uint32_t Int_UART2 = (1U << 11);  ///< Interrupt clear pending for UART2
        constexpr uint32_t Int_EXINT0 = (1U << 12);  ///< Interrupt clear pending for external Int 0
        constexpr uint32_t Int_EXINT1 = (1U << 13);  ///< Interrupt clear pending for external Int 1
        constexpr uint32_t Int_WAKEUP = (1U << 14);  ///< Interrupt clear pending for WAKEUP
        constexpr uint32_t Int_LS1 = (1U << 17);  ///< Interrupt clear pending for LS1
        constexpr uint32_t Int_LS2 = (1U << 18);  ///< Interrupt clear pending for LS2
        constexpr uint32_t Int_HS1 = (1U << 19);  ///< Interrupt clear pending for HS1
        constexpr uint32_t Int_HS2 = (1U << 20);  ///< Interrupt clear pending for HS2
        constexpr uint32_t Int_DU = (1U << 21);  ///< Interrupt clear pending for differential unit
        constexpr uint32_t Int_MON = (1U << 22);  ///< Interrupt clear pending for MON
        constexpr uint32_t Int_PORT2 = (1U << 23);  ///< Interrupt clear pending for PORT2
    }

    /// NVIC_IPR0 Register bits
    namespace nvic_ipr0_bits {
        constexpr uint32_t PRI_GPT1 = (2 << 6);  ///< Priority for GPT1
        constexpr uint32_t PRI_GPT2 = (2 << 14);  ///< Priority for GPT2
        constexpr uint32_t PRI_ADC2 = (2 << 22);  ///< Priority for MU, ADC2
        constexpr uint32_t PRI_ADC1 = (2 << 30);  ///< Priority for ADC1
    }

    /// NVIC_IPR1 Register bits
    namespace nvic_ipr1_bits {
        constexpr uint32_t PRI_CCU6SR0 = (2 << 6);  ///< Priority for CCU6 SR0
        constexpr uint32_t PRI_CCU6SR1 = (2 << 14);  ///< Priority for CCU6 SR1
        constexpr uint32_t PRI_CCU6SR2 = (2 << 22);  ///< Priority for CCU6 SR2
        constexpr uint32_t PRI_CCU6SR3 = (2 << 30);  ///< Priority for CCU6 SR3
    }

    /// NVIC_IPR2 Register bits
    namespace nvic_ipr2_bits {
        constexpr uint32_t PRI_SSC1 = (2 << 6);  ///< Priority for CCU6 SSC1
        constexpr uint32_t PRI_SSC2 = (2 << 14);  ///< Priority for CCU6 SSC2
        constexpr uint32_t PRI_UART1 = (2 << 22);  ///< Priority for CCU6 UART1
        constexpr uint32_t PRI_UART2 = (2 << 30);  ///< Priority for CCU6 UART2
    }

    /// NVIC_IPR3 Register bits
    namespace nvic_ipr3_bits {
        constexpr uint32_t PRI_EXINT0 = (2 << 6);  ///< Priority for external Int 0
        constexpr uint32_t PRI_EXINT1 = (2 << 14);  ///< Priority for external Int 1
        constexpr uint32_t PRI_WAKEUP = (2 << 22);  ///< Priority for WAKEUP
    }

    /// NVIC_IPR4 Register bits
    namespace nvic_ipr4_bits {
        constexpr uint32_t PRI_LS1 = (2 << 14);  ///< Priority for LS1
        constexpr uint32_t PRI_LS2 = (2 << 22);  ///< Priority for LS2
        constexpr uint32_t PRI_HS1 = (2 << 30);  ///< Priority for HS1
    }

    /// NVIC_IPR5 Register bits
    namespace nvic_ipr5_bits {
        constexpr uint32_t PRI_HS2 = (2 << 6);  ///< Priority for HS2
        constexpr uint32_t PRI_DU = (2 << 14);  ///< Priority for differential unit
        constexpr uint32_t PRI_MON = (2 << 22);  ///< Priority for MON
        constexpr uint32_t PRI_PORT2 = (2 << 30);  ///< Priority for PORT2
    }

    /// NVIC_ISER Register bits
    namespace nvic_iser_bits {
        constexpr uint32_t Int_GPT1 = (1U << 0);  ///< Interrupt set for GPT1
        constexpr uint32_t Int_GPT2 = (1U << 1);  ///< Interrupt set for GPT2
        constexpr uint32_t Int_ADC2 = (1U << 2);  ///< Interrupt set for MU, ADC2
        constexpr uint32_t Int_ADC1 = (1U << 3);  ///< Interrupt set for ADC1
        constexpr uint32_t Int_CCU6SR0 = (1U << 4);  ///< Interrupt set for CCU6 SR0
        constexpr uint32_t Int_CCU6SR1 = (1U << 5);  ///< Interrupt set for CCU6 SR1
        constexpr uint32_t Int_CCU6SR2 = (1U << 6);  ///< Interrupt set for CCU6 SR2
        constexpr uint32_t Int_CCU6SR3 = (1U << 7);  ///< Interrupt set for CCU6 SR3
        constexpr uint32_t Int_SSC1 = (1U << 8);  ///< Interrupt set for SSC1
        constexpr uint32_t Int_SSC2 = (1U << 9);  ///< Interrupt set for SSC2
        constexpr uint32_t Int_UART1 = (1U << 10);  ///< Interrupt set for UART1
        constexpr uint32_t Int_UART2 = (1U << 11);  ///< Interrupt set for UART2
        constexpr uint32_t Int_EXINT0 = (1U << 12);  ///< Interrupt set for external Int 0
        constexpr uint32_t Int_EXINT1 = (1U << 13);  ///< Interrupt set for external Int 1
        constexpr uint32_t Int_WAKEUP = (1U << 14);  ///< Interrupt set for WAKEUP
        constexpr uint32_t Int_LS1 = (1U << 17);  ///< Interrupt set for LS1
        constexpr uint32_t Int_LS2 = (1U << 18);  ///< Interrupt set for LS2
        constexpr uint32_t Int_HS1 = (1U << 19);  ///< Interrupt set for HS1
        constexpr uint32_t Int_HS2 = (1U << 20);  ///< Interrupt set for HS2
        constexpr uint32_t Int_DU = (1U << 21);  ///< Interrupt set for differential unit
        constexpr uint32_t Int_MON = (1U << 22);  ///< Interrupt set for MON
        constexpr uint32_t Int_PORT2 = (1U << 23);  ///< Interrupt set for PORT2
    }

    /// NVIC_ISPR Register bits
    namespace nvic_ispr_bits {
        constexpr uint32_t Int_GPT1 = (1U << 0);  ///< Interrupt set pending for GPT1
        constexpr uint32_t Int_GPT2 = (1U << 1);  ///< Interrupt set pending for GPT2
        constexpr uint32_t Int_ADC2 = (1U << 2);  ///< Interrupt set pending for MU, ADC2
        constexpr uint32_t Int_ADC1 = (1U << 3);  ///< Interrupt set pending for ADC1
        constexpr uint32_t Int_CCU6SR0 = (1U << 4);  ///< Interrupt set pending for CCU6 SR0
        constexpr uint32_t Int_CCU6SR1 = (1U << 5);  ///< Interrupt set pending for CCU6 SR1
        constexpr uint32_t Int_CCU6SR2 = (1U << 6);  ///< Interrupt set pending for CCU6 SR2
        constexpr uint32_t Int_CCU6SR3 = (1U << 7);  ///< Interrupt set pending for CCU6 SR3
        constexpr uint32_t Int_SSC1 = (1U << 8);  ///< Interrupt set pending for SSC1
        constexpr uint32_t Int_SSC2 = (1U << 9);  ///< Interrupt set pending for SSC2
        constexpr uint32_t Int_UART1 = (1U << 10);  ///< Interrupt set pending for UART1
        constexpr uint32_t Int_UART2 = (1U << 11);  ///< Interrupt set pending for UART2
        constexpr uint32_t Int_EXINT0 = (1U << 12);  ///< Interrupt set pending for external Int 0
        constexpr uint32_t Int_EXINT1 = (1U << 13);  ///< Interrupt set pending for external Int 1
        constexpr uint32_t Int_WAKEUP = (1U << 14);  ///< Interrupt set pending for WAKEUP
        constexpr uint32_t Int_LS1 = (1U << 17);  ///< Interrupt set pending for LS1
        constexpr uint32_t Int_LS2 = (1U << 18);  ///< Interrupt set pending for LS2
        constexpr uint32_t Int_HS1 = (1U << 19);  ///< Interrupt set pending for HS1
        constexpr uint32_t Int_HS2 = (1U << 20);  ///< Interrupt set pending for HS2
        constexpr uint32_t Int_DU = (1U << 21);  ///< Interrupt set pending for differential unit
        constexpr uint32_t Int_MON = (1U << 22);  ///< Interrupt set pending for MON
        constexpr uint32_t Int_PORT2 = (1U << 23);  ///< Interrupt set pending for PORT2
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< Sleep on exit
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< Sleep deep
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< Send event on pending bit
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (2 << 30);  ///< Priority of system handler 11, SVCall
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (2 << 22);  ///< Priority of system handler 14, PendSV
        constexpr uint32_t PRI_15 = (2 << 30);  ///< Priority of system handler 15, SysTick
    }

    /// SYSTICK_CALIB Register bits
    namespace systick_calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Tenms
        constexpr uint32_t SKEW = (1U << 30);  ///< Skew
        constexpr uint32_t NOREF = (1U << 31);  ///< No reference clock
    }

    /// SYSTICK_CSR Register bits
    namespace systick_csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable
        constexpr uint32_t TICKINT = (1U << 1);  ///< TICKINT
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< CLK source
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< Count flag
    }

    /// SYSTICK_CVR Register bits
    namespace systick_cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current
    }

    /// SYSTICK_RVR Register bits
    namespace systick_rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Reload
    }

}

// ============================================================================
// GPT12E Peripheral
// ============================================================================

namespace gpt12e {
    /// Base addresses
    constexpr uint32_t GPT12E_BASE = 0x40010000;

    /// GPT12E Register structure
    struct Registers {
        volatile uint32_t CAPREL;  ///< Offset: 0x1C - Capture/reload register
        volatile uint32_t ID;  ///< Offset: 0x00 - Module identification register
        volatile uint32_t PISEL;  ///< Offset: 0x04 - Port input select register
        volatile uint32_t T2;  ///< Offset: 0x20 - Timer T2 count register
        volatile uint32_t T2CON;  ///< Offset: 0x08 - Timer T2 control register
        volatile uint32_t T3;  ///< Offset: 0x24 - Timer T3 count register
        volatile uint32_t T3CON;  ///< Offset: 0x0C - Timer T3 control register
        volatile uint32_t T4;  ///< Offset: 0x28 - Timer T4 count register
        volatile uint32_t T4CON;  ///< Offset: 0x10 - Timer T4 control register
        volatile uint32_t T5;  ///< Offset: 0x2C - Timer 5 count register
        volatile uint32_t T5CON;  ///< Offset: 0x14 - Timer T5 control register
        volatile uint32_t T6;  ///< Offset: 0x30 - Timer 6 count register
        volatile uint32_t T6CON;  ///< Offset: 0x18 - Timer T6 control register
    };

    /// Peripheral instances
    inline Registers* GPT12E = reinterpret_cast<Registers*>(GPT12E_BASE);

    // Bit definitions
    /// CAPREL Register bits
    namespace caprel_bits {
        constexpr uint32_t CAPREL = (16 << 0);  ///< Current reload value or captured value
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module revision number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module identification number
    }

    /// PISEL Register bits
    namespace pisel_bits {
        constexpr uint32_t IST2IN = (1U << 0);  ///< Input select for T2IN
        constexpr uint32_t IST2EUD = (1U << 1);  ///< Input select for T2EUD
        constexpr uint32_t IST3IN = (2 << 2);  ///< Input select for T3IN
        constexpr uint32_t IST3EUD = (2 << 4);  ///< Input select for T3EUD
        constexpr uint32_t IST4IN = (2 << 6);  ///< Input select for T4IN
        constexpr uint32_t IST4EUD = (2 << 8);  ///< Input select for TEUD
        constexpr uint32_t IST5IN = (1U << 10);  ///< Input select for T5IN
        constexpr uint32_t IST5EUD = (1U << 11);  ///< Input select for T5EUD
        constexpr uint32_t IST6IN = (1U << 12);  ///< Input select for T6IN
        constexpr uint32_t IST6EUD = (1U << 13);  ///< Input select for T6EUD
        constexpr uint32_t ISCAPIN = (2 << 14);  ///< Input select for CAPIN
    }

    /// T2 Register bits
    namespace t2_bits {
        constexpr uint32_t T2 = (16 << 0);  ///< Timer T2 current value
    }

    /// T2CON Register bits
    namespace t2con_bits {
        constexpr uint32_t T2I = (3 << 0);  ///< Timer T2 input parameter selection
        constexpr uint32_t T2M = (3 << 3);  ///< Timer T2 input mode control
        constexpr uint32_t T2R = (1U << 6);  ///< Timer T2 input run bit
        constexpr uint32_t T2UD = (1U << 7);  ///< Timer T2 up/down control
        constexpr uint32_t T2UDE = (1U << 8);  ///< Timer T2 external up/down enable
        constexpr uint32_t T2RC = (1U << 9);  ///< Timer T2 remote control
        constexpr uint32_t T2IRIDIS = (1U << 12);  ///< Timer T2 interrupt disable
        constexpr uint32_t T2EDGE = (1U << 13);  ///< Timer T2 edge detection
        constexpr uint32_t T2CHDIR = (1U << 14);  ///< Timer T2 count direction change
        constexpr uint32_t T2DIR = (1U << 15);  ///< Timer T2 rotation direction
    }

    /// T3 Register bits
    namespace t3_bits {
        constexpr uint32_t T3 = (16 << 0);  ///< Timer T3 current value
    }

    /// T3CON Register bits
    namespace t3con_bits {
        constexpr uint32_t T3I = (3 << 0);  ///< Timer T3 input parameter selection
        constexpr uint32_t T3M = (3 << 3);  ///< Timer T3 input mode control
        constexpr uint32_t T3R = (1U << 6);  ///< Timer T3 input run bit
        constexpr uint32_t T3UD = (1U << 7);  ///< Timer T3 up/down control
        constexpr uint32_t T3UDE = (1U << 8);  ///< Timer T3 external up/down enable
        constexpr uint32_t T3OE = (1U << 9);  ///< Overflow/underflow output enable
        constexpr uint32_t T3OTL = (1U << 10);  ///< Timer T3 overflow toggle latch
        constexpr uint32_t BPS1 = (2 << 11);  ///< GPT1 block prescaler control
        constexpr uint32_t T3EDGE = (1U << 13);  ///< Timer T3 edge detection flag
        constexpr uint32_t T3CHDIR = (1U << 14);  ///< Timer T3 count direction change flag
        constexpr uint32_t T3DIR = (1U << 15);  ///< Timer T3 rotation direction flag
    }

    /// T4 Register bits
    namespace t4_bits {
        constexpr uint32_t T4 = (16 << 0);  ///< Timer T4 current value
    }

    /// T4CON Register bits
    namespace t4con_bits {
        constexpr uint32_t T4I = (3 << 0);  ///< Timer T4 input parameter selection
        constexpr uint32_t T4M = (3 << 3);  ///< Timer T4 mode control (basic operating mode)
        constexpr uint32_t T4R = (1U << 6);  ///< Timer T4 input run bit
        constexpr uint32_t T4UD = (1U << 7);  ///< Timer T4 up/down control
        constexpr uint32_t T4UDE = (1U << 8);  ///< Timer T4 external up/down enable
        constexpr uint32_t T4RC = (1U << 9);  ///< Timer T4 remote control
        constexpr uint32_t CLRT2EN = (1U << 10);  ///< Clear timer T2 enable
        constexpr uint32_t CLRT3EN = (1U << 11);  ///< Clear timer T3 enable
        constexpr uint32_t T4IRDIS = (1U << 12);  ///< Timer T4 interrupt disable
        constexpr uint32_t T4EDGE = (1U << 13);  ///< Timer T4 edge direction
        constexpr uint32_t T4CHDIR = (1U << 14);  ///< Timer T4 count direction change
        constexpr uint32_t T4RDIR = (1U << 15);  ///< Timer T4 rotation direction
    }

    /// T5 Register bits
    namespace t5_bits {
        constexpr uint32_t T5 = (16 << 0);  ///< Timer T5 current value
    }

    /// T5CON Register bits
    namespace t5con_bits {
        constexpr uint32_t T5I = (3 << 0);  ///< Timer T5 input parameter selection
        constexpr uint32_t T5M = (2 << 3);  ///< Timer T5 input mode control
        constexpr uint32_t T5R = (1U << 6);  ///< Timer T5 run bit
        constexpr uint32_t T5UD = (1U << 7);  ///< Timer T5 up/down control
        constexpr uint32_t T5UDE = (1U << 8);  ///< Timer T5 external up/down enable
        constexpr uint32_t T5RC = (1U << 9);  ///< Timer T5 remote control
        constexpr uint32_t CT3 = (1U << 10);  ///< Timer T3 capture trigger enable
        constexpr uint32_t CI = (2 << 12);  ///< Register CAPREL capture trigger selection
        constexpr uint32_t T5CLR = (1U << 14);  ///< Timer T5 clear enable bit
        constexpr uint32_t T5SC = (1U << 15);  ///< Timer T5 capture mode enable
    }

    /// T6 Register bits
    namespace t6_bits {
        constexpr uint32_t T6 = (16 << 0);  ///< Timer T6 current value
    }

    /// T6CON Register bits
    namespace t6con_bits {
        constexpr uint32_t T6I = (3 << 0);  ///< Timer T6 input parameter selection
        constexpr uint32_t T6M = (3 << 3);  ///< Timer T6 mode control
        constexpr uint32_t T6R = (1U << 6);  ///< Timer T6 input run bit
        constexpr uint32_t T6UD = (1U << 7);  ///< Timer T6 up/down control
        constexpr uint32_t T6UDE = (1U << 8);  ///< Timer T6 external up/down enable
        constexpr uint32_t T6OE = (1U << 9);  ///< Overflow/underflow output enable
        constexpr uint32_t T6OTL = (1U << 10);  ///< Timer T6 overflow toggle latch
        constexpr uint32_t BPS2 = (2 << 11);  ///< GPT2 block prescaler control
        constexpr uint32_t T6CLR = (1U << 14);  ///< Timer T6 clear enable bit
        constexpr uint32_t T6SR = (1U << 15);  ///< Timer T6 reload mode enable
    }

}

// ============================================================================
// HS Peripheral
// ============================================================================

namespace hs {
    /// Base addresses
    constexpr uint32_t HS_BASE = 0x40024000;

    /// HS Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x04 - High-side driver control register
        volatile uint32_t HS1_TRIM;  ///< Offset: 0x1C - High-side driver 1 TRIM register
        volatile uint32_t HS2_TRIM;  ///< Offset: 0x20 - High-side driver 2 TRIM register
        volatile uint32_t IRQCLR;  ///< Offset: 0x0C - High-side driver interrupt status clear register
        volatile uint32_t IRQEN;  ///< Offset: 0x10 - High-side driver interrupt enable register
        volatile uint32_t IRQS;  ///< Offset: 0x08 - High-side driver interrupt status register
        volatile uint32_t PWMSRCSEL;  ///< Offset: 0x24 - High-side PWM source selection register
    };

    /// Peripheral instances
    inline Registers* HS = reinterpret_cast<Registers*>(HS_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t HS1_EN = (1U << 0);  ///< High side 1 enable
        constexpr uint32_t HS1_PWM = (1U << 1);  ///< High side 1 PWM enable
        constexpr uint32_t HS1_ON = (1U << 2);  ///< High side 1 on
        constexpr uint32_t HS1_OL_EN = (1U << 3);  ///< High side 1 open load detection enable
        constexpr uint32_t HS1_CYC_ON_ACTIVE = (1U << 7);  ///< High side 1 cyclic ON driver
        constexpr uint32_t HS1_SRCTL_SEL = (1U << 8);  ///< High side 1 slew rate control select
        constexpr uint32_t HS1_OC_SEL = (2 << 12);  ///< High side 1 overcurrent threshold selection
        constexpr uint32_t HS2_EN = (1U << 16);  ///< High side 2 enable
        constexpr uint32_t HS2_PWM = (1U << 17);  ///< High side 2 PWM enable
        constexpr uint32_t HS2_ON = (1U << 18);  ///< High side 2 on
        constexpr uint32_t HS2_OL_EN = (1U << 19);  ///< High side 2 open load detection enable
        constexpr uint32_t HS2_CYC_ON_ACTIVE = (1U << 23);  ///< High side 2 cyclic ON driver
        constexpr uint32_t HS2_SRCTL_SEL = (1U << 24);  ///< High side 2 slew rate control select
        constexpr uint32_t HS2_OC_SEL = (2 << 28);  ///< High side 2 overcurrent threshold selection
    }

    /// HS1_TRIM Register bits
    namespace hs1_trim_bits {
        constexpr uint32_t HS1_OL_BTFILT_SEL = (2 << 0);  ///< Blanking time filter select for HS1 open load detection
        constexpr uint32_t HS1_OC_OT_BTFILT_SEL = (2 << 8);  ///< Blanking time filter select for HS1 overcurrent/overtemperature detection
    }

    /// HS2_TRIM Register bits
    namespace hs2_trim_bits {
        constexpr uint32_t HS2_OL_BTFILT_SEL = (2 << 0);  ///< Blanking time filter select for HS2 open load detection
        constexpr uint32_t HS2_OC_OT_BTFILT_SEL = (2 << 8);  ///< Blanking time/filter select for HS2 overcurrent/overtemperature detection
    }

    /// IRQCLR Register bits
    namespace irqclr_bits {
        constexpr uint32_t HS1_OT_ISC = (1U << 5);  ///< High Side 1 overtemperature interrupt status clear
        constexpr uint32_t HS1_OL_ISC = (1U << 6);  ///< High side 1 open load interrupt status clear
        constexpr uint32_t HS1_OC_ISC = (1U << 7);  ///< High side 1 overcurrent interrupt status clear
        constexpr uint32_t HS1_OT_SC = (1U << 13);  ///< High side 1 overtemperature status clear
        constexpr uint32_t HS1_OL_SC = (1U << 14);  ///< High side 1 open load status clear
        constexpr uint32_t HS2_OT_ISC = (1U << 21);  ///< High side 2 overtemperature interrupt status clear
        constexpr uint32_t HS2_OL_ISC = (1U << 22);  ///< High side 2 open load interrupt status clear
        constexpr uint32_t HS2_OC_ISC = (1U << 23);  ///< High side 2 overcurrent interrupt status clear
        constexpr uint32_t HS2_OT_SC = (1U << 29);  ///< High side 2 overtemperature status clear
        constexpr uint32_t HS2_OL_SC = (1U << 30);  ///< High side 2 open load status clear
    }

    /// IRQEN Register bits
    namespace irqen_bits {
        constexpr uint32_t HS1_OT_IEN = (1U << 5);  ///< High Side 1 overtemperature interrupt enable
        constexpr uint32_t HS1_OL_IEN = (1U << 6);  ///< High side 1 open load interrupt enable
        constexpr uint32_t HS1_OC_IEN = (1U << 7);  ///< High side 1 overcurrent interrupt enable
        constexpr uint32_t HS2_OT_IEN = (1U << 21);  ///< High side 2 overtemperature interrupt enable
        constexpr uint32_t HS2_OL_IEN = (1U << 22);  ///< High side 2 open load interrupt enable
        constexpr uint32_t HS2_OC_IEN = (1U << 23);  ///< High side 2 overcurrent interrupt enable
    }

    /// IRQS Register bits
    namespace irqs_bits {
        constexpr uint32_t HS1_OT_IS = (1U << 5);  ///< High side 1 overtemperature interrupt status
        constexpr uint32_t HS1_OL_IS = (1U << 6);  ///< High side 1 open load interrupt status
        constexpr uint32_t HS1_OC_IS = (1U << 7);  ///< High side 1 overcurrent interrupt status
        constexpr uint32_t HS1_OT_STS = (1U << 13);  ///< High side 1 overtemperature status
        constexpr uint32_t HS1_OL_STS = (1U << 14);  ///< High side 1 open load interrupt status
        constexpr uint32_t HS2_OT_IS = (1U << 21);  ///< High side 2 overtemperature interrupt status
        constexpr uint32_t HS2_OL_IS = (1U << 22);  ///< High side 2 open load interrupt status
        constexpr uint32_t HS2_OC_IS = (1U << 23);  ///< High side 2 overcurrent interrupt status
        constexpr uint32_t HS2_OT_STS = (1U << 29);  ///< High side 2 overtemperature status
        constexpr uint32_t HS2_OL_STS = (1U << 30);  ///< High side 2 open load interrupt status
    }

    /// PWMSRCSEL Register bits
    namespace pwmsrcsel_bits {
        constexpr uint32_t HS2_SRC_SEL = (3 << 0);  ///< HS2 PWM source selection
        constexpr uint32_t HS1_SRC_SEL = (3 << 3);  ///< HS1 PWM source selection
    }

}

// ============================================================================
// LS Peripheral
// ============================================================================

namespace ls {
    /// Base addresses
    constexpr uint32_t LS_BASE = 0x4001C000;

    /// LS Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x04 - Low-side driver control register
        volatile uint32_t IRQCLR;  ///< Offset: 0x0C - Low-side driver interrupt status clear register
        volatile uint32_t IRQEN;  ///< Offset: 0x10 - Low-side driver interrupt enable register
        volatile uint32_t IRQS;  ///< Offset: 0x08 - Low-side driver interrupt status register
        volatile uint32_t LS1_TRIM;  ///< Offset: 0x18 - Low-side 1 reference current trimming register
        volatile uint32_t LS2_TRIM;  ///< Offset: 0x20 - Low-side 2 reference current trimming register
        volatile uint32_t PWMSRCSEL;  ///< Offset: 0x1C - Low-side PWM source selection register
    };

    /// Peripheral instances
    inline Registers* LS = reinterpret_cast<Registers*>(LS_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t LS1_EN = (1U << 0);  ///< Low-side switch 1 enable
        constexpr uint32_t LS1_PWM = (1U << 1);  ///< Low-side switch 1 PWM enable
        constexpr uint32_t LS1_ON = (1U << 2);  ///< Low-side switch 1 on/off
        constexpr uint32_t LS1_OL_EN = (1U << 3);  ///< Open load detection enable
        constexpr uint32_t LS1_SRCTL_SEL = (1U << 8);  ///< Low-side switch 1 slew rate selection
        constexpr uint32_t LS2_EN = (1U << 16);  ///< Low-side switch 2 enable
        constexpr uint32_t LS2_PWM = (1U << 17);  ///< Low-side switch 2 PWM enable
        constexpr uint32_t LS2_ON = (1U << 18);  ///< Low-Side switch 2 on/off
        constexpr uint32_t LS2_OL_EN = (1U << 19);  ///< Open load detection enable
        constexpr uint32_t LS2_SRCTL_SEL = (1U << 24);  ///< Low-side switch 2 slew rate selection
    }

    /// IRQCLR Register bits
    namespace irqclr_bits {
        constexpr uint32_t LS1_OT_PREWARN_ISC = (1U << 4);  ///< Low-side 1 overtemperature prewarn interrupt status clear
        constexpr uint32_t LS1_OT_ISC = (1U << 5);  ///< Low-side 1 overtemperature interrupt status clear
        constexpr uint32_t LS1_OL_ISC = (1U << 6);  ///< Low-side 1 open load interrupt status clear
        constexpr uint32_t LS1_OC_ISC = (1U << 7);  ///< Low-side 1 overcurrent interrupt status clear
        constexpr uint32_t LS1_OT_PREWARN_SC = (1U << 12);  ///< Low-side 1 overtemperature prewarn status clear
        constexpr uint32_t LS1_OT_SC = (1U << 13);  ///< Low-side 1 overtemperature status clear
        constexpr uint32_t LS1_OL_SC = (1U << 14);  ///< Low-side 1 open load status clear
        constexpr uint32_t LS2_OT_PREWARN_ISC = (1U << 20);  ///< Low-side 2 overtemperature prewarn interrupt status clear
        constexpr uint32_t LS2_OT_ISC = (1U << 21);  ///< Low-side 2 overtemperature interrupt status clear
        constexpr uint32_t LS2_OL_ISC = (1U << 22);  ///< Low-side 2 open load interrupt status clear
        constexpr uint32_t LS2_OC_ISC = (1U << 23);  ///< Low-side 2 overcurrent interrupt status clear
        constexpr uint32_t LS2_OT_PREWARN_SC = (1U << 28);  ///< Low-side 2 overtemperature prewarn status clear
        constexpr uint32_t LS2_OT_SC = (1U << 29);  ///< Low-side switch 2 overtemperature status clear
        constexpr uint32_t LS2_OL_SC = (1U << 30);  ///< Low-side 2 open load status clear
    }

    /// IRQEN Register bits
    namespace irqen_bits {
        constexpr uint32_t LS1_OT_PREWARN_IEN = (1U << 4);  ///< Low-side 1 overtemperature prewarn interrupt enable
        constexpr uint32_t LS1_OT_IEN = (1U << 5);  ///< Low-side 1 overtemperature interrupt enable
        constexpr uint32_t LS1_OL_IEN = (1U << 6);  ///< Low-side 1 open load interrupt enable
        constexpr uint32_t LS1_OC_IEN = (1U << 7);  ///< Low-side 1 overcurrent interrupt enable
        constexpr uint32_t LS2_OT_PREWARN_IEN = (1U << 20);  ///< Low-side 2 overtemperature prewarn interrupt enable
        constexpr uint32_t LS2_OT_IEN = (1U << 21);  ///< Low-side 2 overtemperature interrupt enable
        constexpr uint32_t LS2_OL_IEN = (1U << 22);  ///< Low-side 2 open load interrupt enable
        constexpr uint32_t LS2_OC_IEN = (1U << 23);  ///< Low-side 2 overcurrent interrupt enable
    }

    /// IRQS Register bits
    namespace irqs_bits {
        constexpr uint32_t LS1_OT_PREWARN_IS = (1U << 4);  ///< Low-Side 1 overtemperature prewarning interrupt status
        constexpr uint32_t LS1_OT_IS = (1U << 5);  ///< Low-Side 1 overtemperature interrupt status
        constexpr uint32_t LS1_OL_IS = (1U << 6);  ///< Low-Side 1 open load interrupt status
        constexpr uint32_t LS1_OC_IS = (1U << 7);  ///< Low-Side 1 overcurrent interrupt status
        constexpr uint32_t LS1_OT_PREWARN_STS = (1U << 12);  ///< Low-Side 1 overtemperature prewarning status
        constexpr uint32_t LS1_OT_STS = (1U << 13);  ///< Low-Side 1 overtemperature status
        constexpr uint32_t LS1_OL_STS = (1U << 14);  ///< Low-Side 1 open load status
        constexpr uint32_t LS2_OT_PREWARN_IS = (1U << 20);  ///< Low-Side 2 overtemperature prewarning interrupt status
        constexpr uint32_t LS2_OT_IS = (1U << 21);  ///< Low-Side 2 overtemperature interrupt status
        constexpr uint32_t LS2_OL_IS = (1U << 22);  ///< Low-Side 2 open load interrupt status
        constexpr uint32_t LS2_OC_IS = (1U << 23);  ///< Low-Side 2 overcurrent interrupt status
        constexpr uint32_t LS2_OT_PREWARN_STS = (1U << 28);  ///< Low-Side 2 overtemperature prewarning status
        constexpr uint32_t LS2_OT_STS = (1U << 29);  ///< Low-Side 2 overtemperature status
        constexpr uint32_t LS2_OL_STS = (1U << 30);  ///< Low-side 2 open load status
    }

    /// LS1_TRIM Register bits
    namespace ls1_trim_bits {
        constexpr uint32_t LS1_OL_BTFILT_SEL = (2 << 0);  ///< Open load blank time select for LS1
        constexpr uint32_t LS1_OC_BTFILT_SEL = (2 << 8);  ///< Overcurrent blanktime select for LS1
    }

    /// LS2_TRIM Register bits
    namespace ls2_trim_bits {
        constexpr uint32_t LS2_OL_BTFILT_SEL = (2 << 0);  ///< Open load blank time select for LS2
        constexpr uint32_t LS2_OC_BTFILT_SEL = (2 << 8);  ///< Overcurrent blank time select for LS2
    }

    /// PWMSRCSEL Register bits
    namespace pwmsrcsel_bits {
        constexpr uint32_t LS2_SRC_SEL = (3 << 0);  ///< LS2 PWM source selection
        constexpr uint32_t LS1_SRC_SEL = (3 << 3);  ///< LS1 PWM source selection
    }

}

// ============================================================================
// MF Peripheral
// ============================================================================

namespace mf {
    /// Base addresses
    constexpr uint32_t MF_BASE = 0x48018000;

    /// MF Register structure
    struct Registers {
        volatile uint32_t REF1_STS;  ///< Offset: 0x14 - Reference 1 status register
        volatile uint32_t TEMPSENSE_CTRL;  ///< Offset: 0x10 - Temperature sensor control register
    };

    /// Peripheral instances
    inline Registers* MF = reinterpret_cast<Registers*>(MF_BASE);

    // Bit definitions
    /// REF1_STS Register bits
    namespace ref1_sts_bits {
        constexpr uint32_t REFBG_LOTHWARN_STS = (1U << 4);  ///< Status for Undervoltage threshold measurement of internal VAREF
        constexpr uint32_t REFBG_UPTHWARN_STS = (1U << 5);  ///< Status for overvoltage threshold measurement of internal VAREF
    }

    /// TEMPSENSE_CTRL Register bits
    namespace tempsense_ctrl_bits {
        constexpr uint32_t LS_OTWARN_STS = (1U << 4);  ///< Low-side overtemperature warning (MU) status
        constexpr uint32_t LS_OT_STS = (1U << 5);  ///< Low-side overtemperature (MU) status
        constexpr uint32_t SYS_OTWARN_STS = (1U << 6);  ///< System overtemperature warning (MU) status
        constexpr uint32_t SYS_OT_STS = (1U << 7);  ///< System overtemperature (MU) status
    }

}

// ============================================================================
// PMU Peripheral
// ============================================================================

namespace pmu {
    /// Base addresses
    constexpr uint32_t PMU_BASE = 0x50004000;

    /// PMU Register structure
    struct Registers {
        volatile uint32_t CNF_RST_TFB;  ///< Offset: 0x6C - Reset blind time register
        volatile uint32_t CNF_WAKE_FILTER;  ///< Offset: 0xAC - PMU wake-up timing register
        volatile uint32_t GPIO_WAKE_STATUS;  ///< Offset: 0x04 - GPIO port wake status register
        volatile uint32_t GPUDATA0to3;  ///< Offset: 0xC0 - General purpose user DATA0to3 register
        volatile uint32_t GPUDATA4to7;  ///< Offset: 0xC4 - General purpose user DATA4to7 register
        volatile uint32_t GPUDATA8to11;  ///< Offset: 0xC8 - General purpose user DATA8to11 register
        volatile uint32_t HIGHSIDE_CTRL;  ///< Offset: 0x5C - High-side control register
        volatile uint32_t LIN_WAKE_EN;  ///< Offset: 0x50 - LIN wake enable register
        volatile uint32_t MON_CNF1;  ///< Offset: 0x34 - Settings monitor 1-4 register
        volatile uint32_t MON_CNF2;  ///< Offset: 0x38 - Settings monitor 5 register
        volatile uint32_t RESET_STS;  ///< Offset: 0x10 - Reset status register
        volatile uint32_t SLEEP;  ///< Offset: 0x20 - PMU sleep behavior register
        volatile uint32_t SUPPLY_STS;  ///< Offset: 0x08 - Voltage reg status register
        volatile uint32_t VDDEXT_CTRL;  ///< Offset: 0x0C - VDDEXT control register
        volatile uint32_t WAKE_CNF_GPIO1;  ///< Offset: 0xCC - Wake configuration GPIO port 1 register
        volatile uint32_t WAKE_STATUS;  ///< Offset: 0x00 - Main wake status register
        volatile uint32_t WFS;  ///< Offset: 0x70 - WFS system fail register
    };

    /// Peripheral instances
    inline Registers* PMU = reinterpret_cast<Registers*>(PMU_BASE);

    // Bit definitions
    /// CNF_RST_TFB Register bits
    namespace cnf_rst_tfb_bits {
        constexpr uint32_t RST_TFB = (2 << 0);  ///< Reset pin blind time selection bits
    }

    /// CNF_WAKE_FILTER Register bits
    namespace cnf_wake_filter_bits {
        constexpr uint32_t CNF_LIN_FT = (1U << 0);  ///< Wake-up filter time for LIN WAKE
        constexpr uint32_t CNF_MON_FT = (1U << 1);  ///< Wake-up filter time for monitoring inputs
        constexpr uint32_t CNF_GPIO_FT = (2 << 2);  ///< Wake-up filter time for general purpose IO
    }

    /// GPIO_WAKE_STATUS Register bits
    namespace gpio_wake_status_bits {
        constexpr uint32_t GPIO1_STS_0 = (1U << 8);  ///< Wake GPIO1_0
        constexpr uint32_t GPIO1_STS_1 = (1U << 9);  ///< Wake GPIO1_1
        constexpr uint32_t GPIO1_STS_2 = (1U << 10);  ///< Wake GPIO1_2
        constexpr uint32_t GPIO1_STS_4 = (1U << 12);  ///< Wake GPIO1_4
    }

    /// GPUDATA0to3 Register bits
    namespace gpudata0to3_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0 storage byte
        constexpr uint32_t DATA1 = (8 << 8);  ///< DATA1 storage byte
        constexpr uint32_t DATA2 = (8 << 16);  ///< DATA2 storage byte
        constexpr uint32_t DATA3 = (8 << 24);  ///< DATA3 storage byte
    }

    /// GPUDATA4to7 Register bits
    namespace gpudata4to7_bits {
        constexpr uint32_t DATA4 = (8 << 0);  ///< DATA4 storage byte
        constexpr uint32_t DATA5 = (8 << 8);  ///< DATA5 storage byte
        constexpr uint32_t DATA6 = (8 << 16);  ///< DATA6 storage byte
        constexpr uint32_t DATA7 = (8 << 24);  ///< DATA7 storage byte
    }

    /// GPUDATA8to11 Register bits
    namespace gpudata8to11_bits {
        constexpr uint32_t DATA8 = (8 << 0);  ///< DATA8 storage byte
        constexpr uint32_t DATA9 = (8 << 8);  ///< DATA9 storage byte
        constexpr uint32_t DATA10 = (8 << 16);  ///< DATA10 storage byte
        constexpr uint32_t DATA11 = (8 << 24);  ///< DATA11 storage byte
    }

    /// HIGHSIDE_CTRL Register bits
    namespace highside_ctrl_bits {
        constexpr uint32_t HS1_CYC_EN = (1U << 2);  ///< High-side 1 switch enable for cyclic sense
        constexpr uint32_t HS2_CYC_EN = (1U << 10);  ///< High-side 2 switch enable for cyclic sense
    }

    /// LIN_WAKE_EN Register bits
    namespace lin_wake_en_bits {
        constexpr uint32_t LIN_EN = (1U << 7);  ///< Lin wake enable
    }

    /// MON_CNF1 Register bits
    namespace mon_cnf1_bits {
        constexpr uint32_t MON1_EN = (1U << 0);  ///< MON1 enable
        constexpr uint32_t MON1_FALL = (1U << 1);  ///< MON1 wake-up on falling edge enable
        constexpr uint32_t MON1_RISE = (1U << 2);  ///< MON1 wake-up on rising edge enable
        constexpr uint32_t MON1_CYC = (1U << 3);  ///< MON1 for cycle sense enable
        constexpr uint32_t MON1_PD = (1U << 4);  ///< Pull-down current source for MON1 input enable
        constexpr uint32_t MON1_PU = (1U << 5);  ///< Pull-up current source for MON1 input enable
        constexpr uint32_t MON1_STS = (1U << 7);  ///< MON1 status input
        constexpr uint32_t MON2_EN = (1U << 8);  ///< MON2 enable
        constexpr uint32_t MON2_FALL = (1U << 9);  ///< MON2 wake-up on falling edge enable
        constexpr uint32_t MON2_RISE = (1U << 10);  ///< MON2 wake-up on rising edge enable
        constexpr uint32_t MON2_CYC = (1U << 11);  ///< MON2 for cycle sense enable
        constexpr uint32_t MON2_PD = (1U << 12);  ///< Pull-down current source for MON2 Input enable
        constexpr uint32_t MON2_PU = (1U << 13);  ///< Pull-up current source for MON2 input enable
        constexpr uint32_t MON2_STS = (1U << 15);  ///< MON2 status input
        constexpr uint32_t MON3_EN = (1U << 16);  ///< MON3 enable
        constexpr uint32_t MON3_FALL = (1U << 17);  ///< MON3 wake-up on falling edge enable
        constexpr uint32_t MON3_RISE = (1U << 18);  ///< MON3 wake-up on rising edge enable
        constexpr uint32_t MON3_CYC = (1U << 19);  ///< MON3 for cycle sense enable
        constexpr uint32_t MON3_PD = (1U << 20);  ///< Pull-down current source for MON3 input enable
        constexpr uint32_t MON3_PU = (1U << 21);  ///< Pull-up current source for MON3 Input enable
        constexpr uint32_t MON3_STS = (1U << 23);  ///< MON3 Status Input
        constexpr uint32_t MON4_EN = (1U << 24);  ///< MON4 Enable
        constexpr uint32_t MON4_FALL = (1U << 25);  ///< MON4 wake-up on falling edge enable
        constexpr uint32_t MON4_RISE = (1U << 26);  ///< MON4 wake-up on rising edge enable
        constexpr uint32_t MON4_CYC = (1U << 27);  ///< MON4 for cycle sense enable
        constexpr uint32_t MON4_PD = (1U << 28);  ///< Pull-down current source for MON4 input enable
        constexpr uint32_t MON4_PU = (1U << 29);  ///< Pull-up current source for MON4 input enable
        constexpr uint32_t MON4_STS = (1U << 31);  ///< MON4 status input
    }

    /// MON_CNF2 Register bits
    namespace mon_cnf2_bits {
        constexpr uint32_t MON5_EN = (1U << 0);  ///< MON5 enable
        constexpr uint32_t MON5_FALL = (1U << 1);  ///< MON5 wake-up on falling edge enable
        constexpr uint32_t MON5_RISE = (1U << 2);  ///< MON5 wake-up on rising edge enable
        constexpr uint32_t MON5_CYC = (1U << 3);  ///< MON5 for cycle sense enable
        constexpr uint32_t MON5_PD = (1U << 4);  ///< Pull-down current source for MON5 input enable
        constexpr uint32_t MON5_PU = (1U << 5);  ///< Pull-up current source for MON5 input enable
        constexpr uint32_t MON5_STS = (1U << 7);  ///< MON5 status input
    }

    /// RESET_STS Register bits
    namespace reset_sts_bits {
        constexpr uint32_t SYS_FAIL = (1U << 0);  ///< Flag which indicates a reset caused by a system fail reported in the corresponding fail register
        constexpr uint32_t PMU_WAKE = (1U << 1);  ///< Flag which indicates a reset caused by stop-exit
        constexpr uint32_t PMU_SleepEX = (1U << 2);  ///< Flag which indicates a reset caused by sleep-exit
        constexpr uint32_t PMU_LPR = (1U << 3);  ///< Low priority resets
        constexpr uint32_t PMU_ClkWDT = (1U << 4);  ///< Clock watchdog (CLKWDT) reset flag
        constexpr uint32_t PMU_ExtWDT = (1U << 5);  ///< External watchdog (WDT1) reset flag
        constexpr uint32_t PMU_PIN = (1U << 6);  ///< PIN-reset flag
        constexpr uint32_t PMU_VS_POR = (1U << 7);  ///< Power-on reset flag
        constexpr uint32_t PMU_SOFT = (1U << 9);  ///< Soft-reset flag
        constexpr uint32_t LOCKUP = (1U << 10);  ///< Lockup-reset flag
    }

    /// SLEEP Register bits
    namespace sleep_bits {
        constexpr uint32_t WAKE_W_RST = (1U << 0);  ///< Wake-up with reset execution
        constexpr uint32_t EN_0V9_N = (1U << 1);  ///< Enables the reduction of the VDDC regulator output to reduced voltage during stop mode
        constexpr uint32_t CYC_WAKE_EN = (1U << 2);  ///< Enabling cyclic wake
        constexpr uint32_t CYC_SENSE_EN = (1U << 3);  ///< Enabling cyclic sense
        constexpr uint32_t CYC_SENSE_M03 = (4 << 8);  ///< Mantissa
        constexpr uint32_t CYC_SENSE_E01 = (2 << 12);  ///< Exponent
        constexpr uint32_t CYC_WAKE_M03 = (4 << 16);  ///< Mantissa
        constexpr uint32_t CYC_WAKE_E01 = (2 << 20);  ///< Exponent
        constexpr uint32_t CYC_SENSE_S_DEL = (3 << 24);  ///< Sample delay in cyclic sense mode
    }

    /// SUPPLY_STS Register bits
    namespace supply_sts_bits {
        constexpr uint32_t PMU_1V5_OVERVOLT = (1U << 0);  ///< Overvoltage at VDDC regulator
        constexpr uint32_t PMU_1V5_OVERLOAD = (1U << 1);  ///< Overload at VDDC regulator
        constexpr uint32_t PMU_1V5_FAIL_EN = (1U << 2);  ///< Enabling of VDDC status information as interrupt source
        constexpr uint32_t PMU_5V_OVERVOLT = (1U << 4);  ///< Overvoltage at VDDP regulator
        constexpr uint32_t PMU_5V_OVERLOAD = (1U << 5);  ///< Overload at VDDP regulator
        constexpr uint32_t PMU_5V_FAIL_EN = (1U << 6);  ///< Enabling of VDDP status information as interrupt source
    }

    /// VDDEXT_CTRL Register bits
    namespace vddext_ctrl_bits {
        constexpr uint32_t VDDEXT_ENABLE = (1U << 0);  ///< VDDEXT supply enable
        constexpr uint32_t VDDEXT_CYC_EN = (1U << 1);  ///< VDDEXT supply for cyclic sense enable
        constexpr uint32_t VDDEXT_FAIL_EN = (1U << 2);  ///< Enabling of VDDEXT supply status information as interrupt source
        constexpr uint32_t VDDEXT_OT_IS = (1U << 3);  ///< VDDEXT supply overtemperature interrupt status
        constexpr uint32_t VDDEXT_UV_IS = (1U << 4);  ///< VDDEXT supply undervoltage interrupt status
        constexpr uint32_t VDDEXT_OT_STS = (1U << 5);  ///< VDDEXT supply overtemperature status
        constexpr uint32_t VDDEXT_OT = (1U << 6);  ///< VDDEXT supply overtemperature
        constexpr uint32_t VDDEXT_STABLE = (1U << 7);  ///< VDDEXT supply stable
        constexpr uint32_t VDDEXT_OT_ISC = (1U << 11);  ///< VDDEXT supply overtemperature interrupt status clear
        constexpr uint32_t VDDEXT_UV_ISC = (1U << 12);  ///< VDDEXT supply undervoltage interrupt status clear
        constexpr uint32_t VDDEXT_OT_SC = (1U << 13);  ///< VDDEXT supply overtemperature status clear
    }

    /// WAKE_CNF_GPIO1 Register bits
    namespace wake_cnf_gpio1_bits {
        constexpr uint32_t RI_0 = (1U << 0);  ///< Port 1_0 wake-up on rising edge enable
        constexpr uint32_t RI_1 = (1U << 1);  ///< Port 1_1 wake-up on rising edge enable
        constexpr uint32_t RI_2 = (1U << 2);  ///< Port 1_2 wake-up on rising edge enable
        constexpr uint32_t RI_4 = (1U << 4);  ///< Port 1_4 wake-up on rising edge enable
        constexpr uint32_t FA_0 = (1U << 8);  ///< Port 1_0 wake-up on falling edge enable
        constexpr uint32_t FA_1 = (1U << 9);  ///< Port 1_1 wake-up on falling edge enable
        constexpr uint32_t FA_2 = (1U << 10);  ///< Port 1_2 wake-up on falling edge enable
        constexpr uint32_t FA_4 = (1U << 12);  ///< Port 1_4 wake-up on falling edge enable
        constexpr uint32_t CYC_0 = (1U << 16);  ///< GPIO1_0 input for cycle sense enable
        constexpr uint32_t CYC_1 = (1U << 17);  ///< GPIO1_1 input for cycle sense enable
        constexpr uint32_t CYC_2 = (1U << 18);  ///< GPIO1_2 input for cycle sense enable
        constexpr uint32_t CYC_4 = (1U << 20);  ///< GPIO1_4 input for cycle sense enable
    }

    /// WAKE_STATUS Register bits
    namespace wake_status_bits {
        constexpr uint32_t LIN_WAKE = (1U << 0);  ///< Wake-up via LIN- Message
        constexpr uint32_t MON = (1U << 1);  ///< Wake-up via MON which is a logical OR combination of all Wake_STS_MON bits
        constexpr uint32_t GPIO1 = (1U << 3);  ///< Wake-up via GPIO1 which is a logical OR combination of all Wake_STS_GPIO1 bits
        constexpr uint32_t CYC_WAKE = (1U << 4);  ///< Wake-up caused by cyclic wake
        constexpr uint32_t FAIL = (1U << 5);  ///< Wake-up after VDDEXT fail
        constexpr uint32_t MON1_WAKE_STS = (1U << 8);  ///< Status of MON1
        constexpr uint32_t MON2_WAKE_STS = (1U << 9);  ///< Status of MON2
        constexpr uint32_t MON3_WAKE_STS = (1U << 10);  ///< Status of MON3
        constexpr uint32_t MON4_WAKE_STS = (1U << 11);  ///< Status of MON4
        constexpr uint32_t MON5_WAKE_STS = (1U << 12);  ///< Status of MON5
        constexpr uint32_t VDDEXT_OT = (1U << 17);  ///< Wake VDDEXT overtemperature
        constexpr uint32_t VDDEXT_UV = (1U << 18);  ///< Wake VDDEXT undervoltage
    }

    /// WFS Register bits
    namespace wfs_bits {
        constexpr uint32_t SUPP_SHORT = (1U << 0);  ///< Supply short
        constexpr uint32_t PMU_1V5_OVL = (1U << 2);  ///< VDDC overload flag
        constexpr uint32_t PMU_5V_OVL = (1U << 3);  ///< VDDP overload flag
        constexpr uint32_t SYS_OT = (1U << 5);  ///< System overtemperature indication flag
        constexpr uint32_t WDT1_SEQ_FAIL = (1U << 6);  ///< External watchdog (WDT1) sequential fail
        constexpr uint32_t LP_CLKWD = (1U << 7);  ///< LP_CLKWD
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT_BASE = 0x48028000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t P0_ALTSEL0;  ///< Offset: 0x14 - Port 0 alternate select 0 register
        volatile uint32_t P0_ALTSEL1;  ///< Offset: 0x18 - Port 0 alternate select 1 register
        volatile uint32_t P0_DATA;  ///< Offset: 0x00 - Port 0 data register
        volatile uint32_t P0_DIR;  ///< Offset: 0x04 - Port 0 direction register
        volatile uint32_t P0_OD;  ///< Offset: 0x08 - Port 0 open drain control register
        volatile uint32_t P0_PUDEN;  ///< Offset: 0x10 - Port 0 pull-up/pull-down enable register
        volatile uint32_t P0_PUDSEL;  ///< Offset: 0x0C - Port 0 pull-up/pull-down select register
        volatile uint32_t P1_ALTSEL0;  ///< Offset: 0x34 - Port 1 alternate select 0 register
        volatile uint32_t P1_ALTSEL1;  ///< Offset: 0x38 - Port 1 alternate select 1 register
        volatile uint32_t P1_DATA;  ///< Offset: 0x20 - Port 1 data register
        volatile uint32_t P1_DIR;  ///< Offset: 0x24 - Port 1 direction register
        volatile uint32_t P1_OD;  ///< Offset: 0x28 - Port 1 open drain control register
        volatile uint32_t P1_PUDEN;  ///< Offset: 0x30 - Port 1 pull-up/pull-down enable register
        volatile uint32_t P1_PUDSEL;  ///< Offset: 0x2C - Port 1 pull-up/pull-down select register
        volatile uint32_t P2_DATA;  ///< Offset: 0x40 - Port 2 data register
        volatile uint32_t P2_DIR;  ///< Offset: 0x44 - Port 2 direction register
        volatile uint32_t P2_PUDEN;  ///< Offset: 0x50 - Port 2 pull-up/pull-down enable register
        volatile uint32_t P2_PUDSEL;  ///< Offset: 0x4C - Port 2 pull-up/pull-down select register
    };

    /// Peripheral instances
    inline Registers* PORT = reinterpret_cast<Registers*>(PORT_BASE);

    // Bit definitions
    /// P0_ALTSEL0 Register bits
    namespace p0_altsel0_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P0_ALTSEL0.PPx and P0_ALTSEL1.PPx)
        constexpr uint32_t PP1 = (1U << 1);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P0_ALTSEL0.PPx and P0_ALTSEL1.PPx)
        constexpr uint32_t PP2 = (1U << 2);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P0_ALTSEL0.PPx and P0_ALTSEL1.PPx)
        constexpr uint32_t PP3 = (1U << 3);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P0_ALTSEL0.PPx and P0_ALTSEL1.PPx)
        constexpr uint32_t PP4 = (1U << 4);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P0_ALTSEL0.PPx and P0_ALTSEL1.PPx)
        constexpr uint32_t PP5 = (1U << 5);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P0_ALTSEL0.PPx and P0_ALTSEL1.PPx)
    }

    /// P0_ALTSEL1 Register bits
    namespace p0_altsel1_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P0_ALTSEL0.PPx and P0_ALTSEL1.PPx)
        constexpr uint32_t PP1 = (1U << 1);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P0_ALTSEL0.PPx and P0_ALTSEL1.PPx)
        constexpr uint32_t PP2 = (1U << 2);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P0_ALTSEL0.PPx and P0_ALTSEL1.PPx)
        constexpr uint32_t PP3 = (1U << 3);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P0_ALTSEL0.PPx and P0_ALTSEL1.PPx)
        constexpr uint32_t PP4 = (1U << 4);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P0_ALTSEL0.PPx and P0_ALTSEL1.PPx)
        constexpr uint32_t PP5 = (1U << 5);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P0_ALTSEL0.PPx and P0_ALTSEL1.PPx)
    }

    /// P0_DATA Register bits
    namespace p0_data_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 0 pin 0 data value
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 0 pin 1 data value
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 0 pin 2 data value
        constexpr uint32_t PP3 = (1U << 3);  ///< Port 0 pin 3 data value
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 0 pin 4 data value
        constexpr uint32_t PP5 = (1U << 5);  ///< Port 0 pin 5 data value
        constexpr uint32_t PP0_STS = (1U << 16);  ///< Port 0 pin 0 data value (read back of port data when IO is configured as output)
        constexpr uint32_t PP1_STS = (1U << 17);  ///< Port 0 pin 1 data value (read back of port data when IO is configured as output)
        constexpr uint32_t PP2_STS = (1U << 18);  ///< Port 0 pin 2 data value (read back of port data when IO is configured as output)
        constexpr uint32_t PP3_STS = (1U << 19);  ///< Port 0 pin 3 data value (read back of port data when IO is configured as output)
        constexpr uint32_t PP4_STS = (1U << 20);  ///< Port 0 pin 4 data value (read back of port data when IO is configured as output)
        constexpr uint32_t PP5_STS = (1U << 21);  ///< Port 0 pin 5 data value (read back of port data when IO is configured as output)
    }

    /// P0_DIR Register bits
    namespace p0_dir_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 0 pin 0 direction control
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 0 pin 1 direction control
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 0 pin 2 direction control
        constexpr uint32_t PP3 = (1U << 3);  ///< Port 0 pin 3 direction control
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 0 pin 4 direction control
        constexpr uint32_t PP5 = (1U << 5);  ///< Port 0 pin 5 direction control
        constexpr uint32_t PP0_INEN = (1U << 16);  ///< Port 0 pin 0 input Schmitt trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP1_INEN = (1U << 17);  ///< Port 0 pin 1 input Schmitt trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP2_INEN = (1U << 18);  ///< Port 0 pin 2 input Schmitt trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP3_INEN = (1U << 19);  ///< Port 0 pin 3 input Schmitt trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP4_INEN = (1U << 20);  ///< Port 0 pin 4 input Schmitt trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP5_INEN = (1U << 21);  ///< Port 0 pin 5 input Schmitt trigger enable (only valid if IO is configured as output)
    }

    /// P0_OD Register bits
    namespace p0_od_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 0 pin 0 open drain mode
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 0 pin 1 open drain mode
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 0 pin 2 open drain mode
        constexpr uint32_t PP3 = (1U << 3);  ///< Port 0 pin 3 open drain mode
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 0 pin 4 open drain mode
        constexpr uint32_t PP5 = (1U << 5);  ///< Port 0 pin 5 open drain mode
    }

    /// P0_PUDEN Register bits
    namespace p0_puden_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Pull-up/pull-down enable at port 0 bit 0
        constexpr uint32_t PP1 = (1U << 1);  ///< Pull-up/pull-down enable at port 0 bit 1
        constexpr uint32_t PP2 = (1U << 2);  ///< Pull-up/pull-down enable at port 0 bit 2
        constexpr uint32_t PP3 = (1U << 3);  ///< Pull-up/pull-down enable at port 0 bit 3
        constexpr uint32_t PP4 = (1U << 4);  ///< Pull-up/pull-down enable at port 0 bit 4
        constexpr uint32_t PP5 = (1U << 5);  ///< Pull-up/pull-down enable at port 0 bit 5
    }

    /// P0_PUDSEL Register bits
    namespace p0_pudsel_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Pull-up/pull-down select port 0 bit 0
        constexpr uint32_t PP1 = (1U << 1);  ///< Pull-up/pull-down select port 0 bit 1
        constexpr uint32_t PP2 = (1U << 2);  ///< Pull-up/pull-down select port 0 bit 2
        constexpr uint32_t PP3 = (1U << 3);  ///< Pull-up/pull-down select port 0 bit 3
        constexpr uint32_t PP4 = (1U << 4);  ///< Pull-up/pull-down select port 0 bit 4
        constexpr uint32_t PP5 = (1U << 5);  ///< Pull-up/pull-down select port 0 bit 5
    }

    /// P1_ALTSEL0 Register bits
    namespace p1_altsel0_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P1_ALTSEL0.PPx and P1_ALTSEL1.PPx)
        constexpr uint32_t PP1 = (1U << 1);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P1_ALTSEL0.PPx and P1_ALTSEL1.PPx)
        constexpr uint32_t PP2 = (1U << 2);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P1_ALTSEL0.PPx and P1_ALTSEL1.PPx)
        constexpr uint32_t PP4 = (1U << 4);  ///< Normal GPIO or alternate select 1, 2 or 3 (depends on bits P1_ALTSEL0.PPx and P1_ALTSEL1.PPx)
    }

    /// P1_ALTSEL1 Register bits
    namespace p1_altsel1_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< PP0
        constexpr uint32_t PP1 = (1U << 1);  ///< PP1
        constexpr uint32_t PP2 = (1U << 2);  ///< PP2
        constexpr uint32_t PP4 = (1U << 4);  ///< PP4
    }

    /// P1_DATA Register bits
    namespace p1_data_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 1 pin 0 data value
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 1 pin 1 data value
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 1 pin 2 data value
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 1 pin 4 data value
        constexpr uint32_t PP0_STS = (1U << 16);  ///< Port 1 pin 0 data value (read back of port data when IO is configured as output)
        constexpr uint32_t PP1_STS = (1U << 17);  ///< Port 1 pin 1 data value (read back of port data when IO is configured as output)
        constexpr uint32_t PP2_STS = (1U << 18);  ///< Port 1 pin 2 data value (read back of port data when IO is configured as output)
        constexpr uint32_t PP4_STS = (1U << 20);  ///< Port 1 pin 4 data value (read back of port data when IO is configured as output)
    }

    /// P1_DIR Register bits
    namespace p1_dir_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 1 pin 0 direction control
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 1 pin 1 direction control
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 1 pin 2 direction control
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 1 pin 4 direction control
        constexpr uint32_t PP0_INEN = (1U << 16);  ///< Port 1 pin 0 input Schmitt trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP1_INEN = (1U << 17);  ///< Port 1 pin 1 input Schmitt trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP2_INEN = (1U << 18);  ///< Port 1 pin 2 input Schmitt trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP3_INEN = (1U << 20);  ///< Port 1 pin 4 input Schmitt trigger enable (only valid if IO is configured as output)
    }

    /// P1_OD Register bits
    namespace p1_od_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 1 pin 0 open drain mode
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 1 pin 1 open drain mode
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 1 pin 2 open drain mode
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 1 pin 4 open drain mode
    }

    /// P1_PUDEN Register bits
    namespace p1_puden_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Pull-up/pull-down enable at port 1 bit 0
        constexpr uint32_t PP1 = (1U << 1);  ///< Pull-up/pull-down enable at port 1 bit 1
        constexpr uint32_t PP2 = (1U << 2);  ///< Pull-up/pull-down enable at port 1 bit 2
        constexpr uint32_t PP4 = (1U << 4);  ///< Pull-up/pull-down enable at port 1 bit 4
    }

    /// P1_PUDSEL Register bits
    namespace p1_pudsel_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Pull-up/pull-down select port 1 bit 0
        constexpr uint32_t PP1 = (1U << 1);  ///< Pull-up/pull-down select port 1 bit 1
        constexpr uint32_t PP2 = (1U << 2);  ///< Pull-up/pull-down select port 1 bit 2
        constexpr uint32_t PP4 = (1U << 4);  ///< Pull-up/pull-down select port 1 bit 4
    }

    /// P2_DATA Register bits
    namespace p2_data_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 2 pin 0 data value
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 2 pin 1 data value
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 2 pin 2 data value
        constexpr uint32_t PP3 = (1U << 3);  ///< Port 2 pin 3 data value
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 2 pin 4 data value
        constexpr uint32_t PP5 = (1U << 5);  ///< Port 2 pin 5 data value
        constexpr uint32_t PP6 = (1U << 6);  ///< Port 2 pin 6 data value
        constexpr uint32_t PP7 = (1U << 7);  ///< Port 2 pin 7 data value
    }

    /// P2_DIR Register bits
    namespace p2_dir_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 2 pin 0 direction control
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 2 pin 1 direction control
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 2 pin 2 direction control
        constexpr uint32_t PP3 = (1U << 3);  ///< Port 2 pin 3 direction control
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 2 pin 4 direction control
        constexpr uint32_t PP5 = (1U << 5);  ///< Port 2 pin 5 direction control
        constexpr uint32_t PP6 = (1U << 6);  ///< Port 2 pin 6 direction control
        constexpr uint32_t PP7 = (1U << 7);  ///< Port 2 pin 7 direction control
    }

    /// P2_PUDEN Register bits
    namespace p2_puden_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Pull-up/pull-down enable at port 2 bit 0
        constexpr uint32_t PP1 = (1U << 1);  ///< Pull-up/pull-down enable at port 2 bit 1
        constexpr uint32_t PP2 = (1U << 2);  ///< Pull-up/pull-down enable at port 2 bit 2
        constexpr uint32_t PP3 = (1U << 3);  ///< Pull-up/pull-down enable at port 2 bit 3
        constexpr uint32_t PP4 = (1U << 4);  ///< Pull-up/pull-down enable at port 2 bit 4
        constexpr uint32_t PP5 = (1U << 5);  ///< Pull-up/pull-down enable at port 2 bit 5
        constexpr uint32_t PP6 = (1U << 6);  ///< Pull-up/pull-down enable at port 2 bit 6
        constexpr uint32_t PP7 = (1U << 7);  ///< Pull-up/pull-down enable at port 2 bit 7
    }

    /// P2_PUDSEL Register bits
    namespace p2_pudsel_bits {
        constexpr uint32_t PP0 = (1U << 0);  ///< Pull-up/pull-down select port 2 bit 0
        constexpr uint32_t PP1 = (1U << 1);  ///< Pull-up/pull-down select port 2 bit 1
        constexpr uint32_t PP2 = (1U << 2);  ///< Pull-up/pull-down select port 2 bit 2
        constexpr uint32_t PP3 = (1U << 3);  ///< Pull-up/pull-down select port 2 bit 3
        constexpr uint32_t PP4 = (1U << 4);  ///< Pull-up/pull-down select port 2 bit 4
        constexpr uint32_t PP5 = (1U << 5);  ///< Pull-up/pull-down select port 2 bit 5
        constexpr uint32_t PP6 = (1U << 6);  ///< Pull-up/pull-down select port 2 bit 6
        constexpr uint32_t PP7 = (1U << 7);  ///< Pull-up/pull-down select port 2 bit 7
    }

}

// ============================================================================
// SCU Peripheral
// ============================================================================

namespace scu {
    /// Base addresses
    constexpr uint32_t SCU_BASE = 0x50005000;

    /// SCU Register structure
    struct Registers {
        volatile uint32_t ADC1_CLK;  ///< Offset: 0x6C - ADC1 peripheral clock register
        volatile uint32_t APCLK;  ///< Offset: 0x58 - Analog peripheral clock register
        volatile uint32_t APCLK_CTRL;  ///< Offset: 0x54 - Analog peripheral clock control register
        volatile uint32_t APCLK_SCLR;  ///< Offset: 0x64 - Analog peripheral clock status clear register
        volatile uint32_t APCLK_STS;  ///< Offset: 0x5C - Analog peripheral clock status register
        volatile uint32_t BCON1;  ///< Offset: 0x88 - Baud-rate control 1 register
        volatile uint32_t BCON2;  ///< Offset: 0x98 - Baud-rate control 2 register
        volatile uint32_t BG1;  ///< Offset: 0x90 - Baud-rate timer/reload 1 register
        volatile uint32_t BG2;  ///< Offset: 0xA0 - Baud-rate timer/reload 2 register
        volatile uint32_t BGL1;  ///< Offset: 0x8C - Baud-rate timer/reload, low byte 1 register
        volatile uint32_t BGL2;  ///< Offset: 0x9C - Baud-rate timer/reload, low byte 2 register
        volatile uint32_t CMCON1;  ///< Offset: 0x48 - Clock control 1 register
        volatile uint32_t CMCON2;  ///< Offset: 0x4C - Clock control 2 register
        volatile uint32_t COCON;  ///< Offset: 0xB4 - Clock output control register
        volatile uint32_t EDCCON;  ///< Offset: 0xD4 - Error detection and correction control register
        volatile uint32_t EDCSCLR;  ///< Offset: 0x10C - Error detection and correction status clear register
        volatile uint32_t EDCSTAT;  ///< Offset: 0xD8 - Error detection and correction status register
        volatile uint32_t EMOP;  ///< Offset: 0xCC - Emergency and program operation status register
        volatile uint32_t EXICON0;  ///< Offset: 0x28 - External interrupt control 0 register
        volatile uint32_t EXICON1;  ///< Offset: 0x2C - External interrupt control 1 register
        volatile uint32_t GPT12ICLR;  ///< Offset: 0x180 - Timer and counter control/status clear register
        volatile uint32_t GPT12IEN;  ///< Offset: 0x15C - General purpose timer 12 interrupt enable register
        volatile uint32_t GPT12IRC;  ///< Offset: 0x160 - Timer and counter control/status register
        volatile uint32_t GPT12PISEL;  ///< Offset: 0xD0 - GPT12 peripheral input select register
        volatile uint32_t ID;  ///< Offset: 0xA8 - Identity register
        volatile uint32_t IEN0;  ///< Offset: 0x1C - Interrupt enable 0 register
        volatile uint32_t IRCON0;  ///< Offset: 0x04 - Interrupt request 0 register
        volatile uint32_t IRCON0CLR;  ///< Offset: 0x178 - Interrupt request 0 clear register
        volatile uint32_t IRCON1;  ///< Offset: 0x08 - Interrupt request 1 register
        volatile uint32_t IRCON1CLR;  ///< Offset: 0x17C - Interrupt request 1 clear register
        volatile uint32_t IRCON2;  ///< Offset: 0x0C - Interrupt request 2 register
        volatile uint32_t IRCON2CLR;  ///< Offset: 0x190 - Interrupt request 2 clear register
        volatile uint32_t IRCON3;  ///< Offset: 0x10 - Interrupt request 3 register
        volatile uint32_t IRCON3CLR;  ///< Offset: 0x194 - Interrupt request 3 clear register
        volatile uint32_t IRCON4;  ///< Offset: 0x14 - Interrupt request 4 register
        volatile uint32_t IRCON4CLR;  ///< Offset: 0x198 - Interrupt request 4 clear register
        volatile uint32_t IRCON5;  ///< Offset: 0x7C - Interrupt request 5 register
        volatile uint32_t IRCON5CLR;  ///< Offset: 0x19C - Interrupt request 5 clear register
        volatile uint32_t LINSCLR;  ///< Offset: 0xA4 - LIN status clear register
        volatile uint32_t LINST;  ///< Offset: 0x94 - LIN status register
        volatile uint32_t MEM_ACC_STS;  ///< Offset: 0xE4 - Memory access status register
        volatile uint32_t MEMSTAT;  ///< Offset: 0xDC - Memory status register
        volatile uint32_t MODIEN1;  ///< Offset: 0x30 - Peripheral interrupt enable 1 register
        volatile uint32_t MODIEN2;  ///< Offset: 0x34 - Peripheral interrupt enable 2 register
        volatile uint32_t MODIEN3;  ///< Offset: 0x38 - Peripheral interrupt enable 3 register
        volatile uint32_t MODIEN4;  ///< Offset: 0x3C - Peripheral interrupt enable 4 register
        volatile uint32_t MODPISEL;  ///< Offset: 0xB8 - Peripheral input select register
        volatile uint32_t MODPISEL1;  ///< Offset: 0xBC - Peripheral input select 1 register
        volatile uint32_t MODPISEL2;  ///< Offset: 0xC0 - Peripheral input select 2 register
        volatile uint32_t MODPISEL3;  ///< Offset: 0xC4 - Peripheral input select 3 register
        volatile uint32_t MODPISEL4;  ///< Offset: 0xFC - Peripheral input select 4 register
        volatile uint32_t MODSUSP;  ///< Offset: 0xC8 - Module suspend control register
        volatile uint32_t MONIEN;  ///< Offset: 0x18C - Monitoring input interrupt enable register
        volatile uint32_t NMICON;  ///< Offset: 0x24 - NMI control register
        volatile uint32_t NMISR;  ///< Offset: 0x18 - NMI status register
        volatile uint32_t NMISRCLR;  ///< Offset: 0x00 - NMI status clear register
        volatile uint32_t NVM_PROT_STS;  ///< Offset: 0xE0 - NVM protection status register
        volatile uint32_t OSC_CON;  ///< Offset: 0xB0 - OSC control register
        volatile uint32_t P0_POCON0;  ///< Offset: 0xE8 - Port output control register
        volatile uint32_t P1_POCON0;  ///< Offset: 0xF8 - Port output control register
        volatile uint32_t PASSWD;  ///< Offset: 0xAC - Password register
        volatile uint32_t PLL_CON;  ///< Offset: 0x44 - PLL control register
        volatile uint32_t PMCON;  ///< Offset: 0x60 - Peripheral management control register
        volatile uint32_t PMCON0;  ///< Offset: 0x40 - Power mode control 0 register
        volatile uint32_t RSTCON;  ///< Offset: 0x68 - Reset control register
        volatile uint32_t SYS_STRTUP_STS;  ///< Offset: 0x74 - System startup status register
        volatile uint32_t SYSCON0;  ///< Offset: 0x70 - System control 0 register
        volatile uint32_t TCCR;  ///< Offset: 0xF4 - Temperature compensation control register
        volatile uint32_t VTOR;  ///< Offset: 0x20 - Vector table reallocation register
        volatile uint32_t WAKECON;  ///< Offset: 0x78 - Wake-up interrupt control register
    };

    /// Peripheral instances
    inline Registers* SCU = reinterpret_cast<Registers*>(SCU_BASE);

    // Bit definitions
    /// ADC1_CLK Register bits
    namespace adc1_clk_bits {
        constexpr uint32_t ADC1_CLK_DIV = (4 << 0);  ///< ADC1 clock divider
        constexpr uint32_t DPP1_CLK_DIV = (2 << 8);  ///< ADC1 post processing clock divider
    }

    /// APCLK Register bits
    namespace apclk_bits {
        constexpr uint32_t APCLK1FAC = (2 << 0);  ///< Analog module clock factor
        constexpr uint32_t APCLK2FAC = (5 << 8);  ///< Slow down clock divider for TFILT_CLK generation
        constexpr uint32_t BGCLK_SEL = (1U << 24);  ///< Bandgap clock selection
        constexpr uint32_t BGCLK_DIV = (1U << 25);  ///< Bandgap clock divider
    }

    /// APCLK_CTRL Register bits
    namespace apclk_ctrl_bits {
        constexpr uint32_t APCLK_SET = (1U << 0);  ///< Set and overtake flag for clock settings
        constexpr uint32_t CLKWDT_IE = (1U << 8);  ///< Clock watchdog interrupt enable
    }

    /// APCLK_SCLR Register bits
    namespace apclk_sclr_bits {
        constexpr uint32_t APCLK1SCLR = (1U << 0);  ///< Analog peripherals clock status clear
        constexpr uint32_t APCLK2SCLR = (1U << 8);  ///< Analog peripherals clock status clear
        constexpr uint32_t APCLK3SCLR = (1U << 16);  ///< Analog peripherals clock 3 status clear
        constexpr uint32_t PLL_LOCK_SCLR = (1U << 24);  ///< PLL lock status clear
    }

    /// APCLK_STS Register bits
    namespace apclk_sts_bits {
        constexpr uint32_t APCLK1STS = (2 << 0);  ///< Analog peripherals clock status
        constexpr uint32_t APCLK2STS = (2 << 8);  ///< Analog peripherals clock status
        constexpr uint32_t APCLK3STS = (1U << 16);  ///< Loss of clock status
        constexpr uint32_t PLL_LOCK = (1U << 24);  ///< PLL LOCK status
    }

    /// BCON1 Register bits
    namespace bcon1_bits {
        constexpr uint32_t BR1_R = (1U << 0);  ///< Baud-rate generator run control bit
        constexpr uint32_t BR1_PRE = (3 << 1);  ///< Prescaler bit
    }

    /// BCON2 Register bits
    namespace bcon2_bits {
        constexpr uint32_t BR2_R = (1U << 0);  ///< Baud-rate generator run control bit
        constexpr uint32_t BR2_PRE = (3 << 1);  ///< Prescaler bit
    }

    /// BG1 Register bits
    namespace bg1_bits {
        constexpr uint32_t BG1_BR_VALUE = (11 << 0);  ///< Baud-rate timer/reload value UART1
    }

    /// BG2 Register bits
    namespace bg2_bits {
        constexpr uint32_t BG2_BR_VALUE = (11 << 0);  ///< Baud-rate timer/reload value UART2
    }

    /// BGL1 Register bits
    namespace bgl1_bits {
        constexpr uint32_t BG1_FD_SEL = (5 << 0);  ///< Fractional divider selection
    }

    /// BGL2 Register bits
    namespace bgl2_bits {
        constexpr uint32_t BG2_FD_SEL = (5 << 0);  ///< Fractional divider selection
    }

    /// CMCON1 Register bits
    namespace cmcon1_bits {
        constexpr uint32_t CLKREL = (4 << 0);  ///< Slow down clock divider for fCCLK generation
        constexpr uint32_t K2DIV = (2 << 4);  ///< PLL K2-divider
        constexpr uint32_t K1DIV = (1U << 6);  ///< PLL K1-divider
        constexpr uint32_t PDIV = (2 << 8);  ///< PLL PDIV-divider
    }

    /// CMCON2 Register bits
    namespace cmcon2_bits {
        constexpr uint32_t PBA0CLKREL = (1U << 0);  ///< PBA0 clock divider
    }

    /// COCON Register bits
    namespace cocon_bits {
        constexpr uint32_t COREL = (4 << 0);  ///< Clock output divider
        constexpr uint32_t COUTS0 = (1U << 4);  ///< Clock out source select bit 0
        constexpr uint32_t TLEN = (1U << 5);  ///< Toggle latch enable
        constexpr uint32_t COUTS1 = (1U << 6);  ///< Clock out source select bit 1
        constexpr uint32_t EN = (1U << 7);  ///< CLKOUT enable
    }

    /// EDCCON Register bits
    namespace edccon_bits {
        constexpr uint32_t RIE = (1U << 0);  ///< RAM double bit ECC error interrupt enable
        constexpr uint32_t NVMIE = (1U << 2);  ///< NVM double bit ECC error interrupt enable
    }

    /// EDCSCLR Register bits
    namespace edcsclr_bits {
        constexpr uint32_t RDBEC = (1U << 0);  ///< RAM double bit error clear
        constexpr uint32_t NVMDBEC = (1U << 2);  ///< NVM double bit error clear
        constexpr uint32_t RSBEC = (1U << 4);  ///< RAM single bit error clear
    }

    /// EDCSTAT Register bits
    namespace edcstat_bits {
        constexpr uint32_t RDBE = (1U << 0);  ///< RAM double bit error
        constexpr uint32_t NVMDBE = (1U << 2);  ///< NVM double bit error
        constexpr uint32_t RSBE = (1U << 4);  ///< RAM single bit error
    }

    /// EMOP Register bits
    namespace emop_bits {
        constexpr uint32_t NVMPROP = (1U << 0);  ///< NVM program operation status bit
        constexpr uint32_t EMPROP = (1U << 1);  ///< Emergency program operation status bit
    }

    /// EXICON0 Register bits
    namespace exicon0_bits {
        constexpr uint32_t EXINT0 = (2 << 0);  ///< External interrupt 0 trigger select
        constexpr uint32_t EXINT1 = (2 << 2);  ///< External interrupt 1 trigger select
        constexpr uint32_t EXINT2 = (2 << 4);  ///< External interrupt 2 trigger select
    }

    /// EXICON1 Register bits
    namespace exicon1_bits {
        constexpr uint32_t MON1 = (2 << 0);  ///< MON1 input trigger select
        constexpr uint32_t MON2 = (2 << 2);  ///< MON2 input trigger select
        constexpr uint32_t MON3 = (2 << 4);  ///< MON3 input trigger select
        constexpr uint32_t MON4 = (2 << 6);  ///< MON4 input trigger select
        constexpr uint32_t MON5 = (2 << 8);  ///< MON5 input trigger select
    }

    /// GPT12ICLR Register bits
    namespace gpt12iclr_bits {
        constexpr uint32_t GPT1T2C = (1U << 0);  ///< GPT module 1 Timer2 interrupt status
        constexpr uint32_t GPT1T3C = (1U << 1);  ///< GPT module 1 Timer3 interrupt status
        constexpr uint32_t GPT1T4C = (1U << 2);  ///< GPT module 1 Timer4 interrupt status
        constexpr uint32_t GPT2T5C = (1U << 3);  ///< GPT module 2 Timer5 interrupt status
        constexpr uint32_t GPT2T6C = (1U << 4);  ///< GPT module 2 Timer6 interrupt status
        constexpr uint32_t GPT12CRC = (1U << 5);  ///< GPT12 capture reload interrupt status
    }

    /// GPT12IEN Register bits
    namespace gpt12ien_bits {
        constexpr uint32_t T2IE = (1U << 0);  ///< GPT12 T2 interrupt enable
        constexpr uint32_t T3IE = (1U << 1);  ///< GPT12 T3 interrupt enable
        constexpr uint32_t T4IE = (1U << 2);  ///< GPT12 T4 interrupt enable
        constexpr uint32_t T5IE = (1U << 3);  ///< GPT12 T5 interrupt enable
        constexpr uint32_t T6IE = (1U << 4);  ///< GPT12 T6 interrupt enable
        constexpr uint32_t CRIE = (1U << 5);  ///< GPT12 capture and reload interrupt enable
    }

    /// GPT12IRC Register bits
    namespace gpt12irc_bits {
        constexpr uint32_t GPT1T2 = (1U << 0);  ///< GPT module 1 Timer2 interrupt status
        constexpr uint32_t GPT1T3 = (1U << 1);  ///< GPT module 1 Timer3 interrupt status
        constexpr uint32_t GPT1T4 = (1U << 2);  ///< GPT module 1 Timer4 interrupt status
        constexpr uint32_t GPT2T5 = (1U << 3);  ///< GPT module 2 Timer5 interrupt status
        constexpr uint32_t GPT2T6 = (1U << 4);  ///< GPT module 2 Timer6 interrupt status
        constexpr uint32_t GPT12CR = (1U << 5);  ///< GPT12 capture reload interrupt status
    }

    /// GPT12PISEL Register bits
    namespace gpt12pisel_bits {
        constexpr uint32_t GPT12 = (4 << 0);  ///< GPT12 T3INB/T4IND input select
        constexpr uint32_t TRIG_CONF = (1U << 4);  ///< CCU6 trigger Configuration
        constexpr uint32_t GPT12_SEL = (1U << 5);  ///< CCU6 trigger configuration
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t VERID = (3 << 0);  ///< Version ID
        constexpr uint32_t PRODID = (5 << 3);  ///< Product ID
    }

    /// IEN0 Register bits
    namespace ien0_bits {
        constexpr uint32_t EA = (1U << 31);  ///< Global interrupt mask
    }

    /// IRCON0 Register bits
    namespace ircon0_bits {
        constexpr uint32_t EXINT0R = (1U << 0);  ///< Interrupt flag for external interrupt 0x on rising edge
        constexpr uint32_t EXINT0F = (1U << 1);  ///< Interrupt flag for external interrupt 0x on falling edge
        constexpr uint32_t EXINT1R = (1U << 2);  ///< Interrupt flag for external interrupt 1x on rising edge
        constexpr uint32_t EXINT1F = (1U << 3);  ///< Interrupt flag for external interrupt 1x on falling edge
        constexpr uint32_t EXINT2R = (1U << 4);  ///< Interrupt flag for external interrupt 2x on rising edge
        constexpr uint32_t EXINT2F = (1U << 5);  ///< Interrupt flag for external interrupt 2x on falling edge
    }

    /// IRCON0CLR Register bits
    namespace ircon0clr_bits {
        constexpr uint32_t EXINT0RC = (1U << 0);  ///< Interrupt flag for external interrupt 0x on rising edge
        constexpr uint32_t EXINT0FC = (1U << 1);  ///< Interrupt flag for external interrupt 0x on falling edge
        constexpr uint32_t EXINT1RC = (1U << 2);  ///< Interrupt flag for external interrupt 1x on rising edge
        constexpr uint32_t EXINT1FC = (1U << 3);  ///< Interrupt flag for external interrupt 1x on falling edge
        constexpr uint32_t EXINT2RC = (1U << 4);  ///< Interrupt flag for external interrupt 2x on rising edge
        constexpr uint32_t EXINT2FC = (1U << 5);  ///< Interrupt flag for external interrupt 2x on falling edge
    }

    /// IRCON1 Register bits
    namespace ircon1_bits {
        constexpr uint32_t MON1R = (1U << 0);  ///< Interrupt flag for MON1x on rising edge
        constexpr uint32_t MON1F = (1U << 1);  ///< Interrupt flag for MON1x on falling edge
        constexpr uint32_t MON2R = (1U << 2);  ///< Interrupt flag for MON2x on rising edge
        constexpr uint32_t MON2F = (1U << 3);  ///< Interrupt flag for MON2x on falling edge
        constexpr uint32_t MON3R = (1U << 4);  ///< Interrupt flag for MON3x on rising edge
        constexpr uint32_t MON3F = (1U << 5);  ///< Interrupt flag for MON3x on falling edge
        constexpr uint32_t MON4R = (1U << 6);  ///< Interrupt flag for MON4x on rising edge
        constexpr uint32_t MON4F = (1U << 7);  ///< Interrupt flag for MON4x on falling edge
        constexpr uint32_t MON5R = (1U << 8);  ///< Interrupt flag for MON5x on rising edge
        constexpr uint32_t MON5F = (1U << 9);  ///< Interrupt flag for MON5x on falling edge
    }

    /// IRCON1CLR Register bits
    namespace ircon1clr_bits {
        constexpr uint32_t MON1RC = (1U << 0);  ///< Interrupt flag for MON1x on rising edge
        constexpr uint32_t MON1FC = (1U << 1);  ///< Interrupt flag for MON1x on falling edge
        constexpr uint32_t MON2RC = (1U << 2);  ///< Interrupt flag for MON2x on rising edge
        constexpr uint32_t MON2FC = (1U << 3);  ///< Interrupt flag for MON2x on falling edge
        constexpr uint32_t MON3RC = (1U << 4);  ///< Interrupt flag for MON3x on rising edge
        constexpr uint32_t MON3FC = (1U << 5);  ///< Interrupt flag for MON3x on falling edge
        constexpr uint32_t MON4RC = (1U << 6);  ///< Interrupt flag for MON4x on rising edge
        constexpr uint32_t MON4FC = (1U << 7);  ///< Interrupt flag for MON4x on falling edge
        constexpr uint32_t MON5RC = (1U << 8);  ///< Interrupt flag for MON5x on rising edge
        constexpr uint32_t MON5FC = (1U << 9);  ///< Interrupt flag for MON5x on falling edge
    }

    /// IRCON2 Register bits
    namespace ircon2_bits {
        constexpr uint32_t EIR1 = (1U << 0);  ///< Error interrupt flag for SSC1
        constexpr uint32_t TIR1 = (1U << 1);  ///< Transmit interrupt flag for SSC1
        constexpr uint32_t RIR1 = (1U << 2);  ///< Receive interrupt flag for SSC1
    }

    /// IRCON2CLR Register bits
    namespace ircon2clr_bits {
        constexpr uint32_t EIR1C = (1U << 0);  ///< Error interrupt flag for SSC1
        constexpr uint32_t TIR1C = (1U << 1);  ///< Transmit interrupt flag for SSC1
        constexpr uint32_t RIR1C = (1U << 2);  ///< Receive interrupt flag for SSC1
    }

    /// IRCON3 Register bits
    namespace ircon3_bits {
        constexpr uint32_t EIR2 = (1U << 0);  ///< Error interrupt flag for SSC2
        constexpr uint32_t TIR2 = (1U << 1);  ///< Transmit interrupt flag for SSC2
        constexpr uint32_t RIR2 = (1U << 2);  ///< Receive interrupt flag for SSC2
    }

    /// IRCON3CLR Register bits
    namespace ircon3clr_bits {
        constexpr uint32_t EIR2C = (1U << 0);  ///< Error interrupt flag for SSC2
        constexpr uint32_t TIR2C = (1U << 1);  ///< Transmit interrupt flag for SSC2
        constexpr uint32_t RIR2C = (1U << 2);  ///< Receive interrupt flag for SSC2
    }

    /// IRCON4 Register bits
    namespace ircon4_bits {
        constexpr uint32_t CCU6SR0 = (1U << 0);  ///< Interrupt flag 0 for CCU6
        constexpr uint32_t CCU6SR1 = (1U << 4);  ///< Interrupt flag 1 for CCU6
        constexpr uint32_t CCU6SR2 = (1U << 16);  ///< Interrupt flag 2 for CCU6
        constexpr uint32_t CCU6SR3 = (1U << 20);  ///< Interrupt flag 3 for CCU6
    }

    /// IRCON4CLR Register bits
    namespace ircon4clr_bits {
        constexpr uint32_t CCU6SR0C = (1U << 0);  ///< Interrupt flag 0 for CCU6
        constexpr uint32_t CCU6SR1C = (1U << 4);  ///< Interrupt flag 1 for CCU6
        constexpr uint32_t CCU6SR2C = (1U << 16);  ///< Interrupt flag 2 for CCU6
        constexpr uint32_t CCU6SR3C = (1U << 20);  ///< Interrupt flag 3 for CCU6
    }

    /// IRCON5 Register bits
    namespace ircon5_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Interrupt flag for wake-up
    }

    /// IRCON5CLR Register bits
    namespace ircon5clr_bits {
        constexpr uint32_t WAKEUPC = (1U << 0);  ///< Clear flag for wake-up interrupt
    }

    /// LINSCLR Register bits
    namespace linsclr_bits {
        constexpr uint32_t BRKC = (1U << 3);  ///< Break field flag clear
        constexpr uint32_t EOFSYNC = (1U << 4);  ///< End of SYN byte interrupt flag clear
        constexpr uint32_t ERRSYNC = (1U << 5);  ///< SYN byte error interrupt flag
    }

    /// LINST Register bits
    namespace linst_bits {
        constexpr uint32_t BRDIS = (1U << 0);  ///< Baud-rate detection disable
        constexpr uint32_t BGSEL = (2 << 1);  ///< Baud-rate select for detection
        constexpr uint32_t BRK = (1U << 3);  ///< Break field flag
        constexpr uint32_t EOFSYN = (1U << 4);  ///< End of SYN byte interrupt flag
        constexpr uint32_t ERRSYN = (1U << 5);  ///< SYN byte error interrupt flag
        constexpr uint32_t SYNEN = (1U << 6);  ///< End of SYN byte and SYN byte error interrupts enable
    }

    /// MEM_ACC_STS Register bits
    namespace mem_acc_sts_bits {
        constexpr uint32_t NVM_PROT_ERR = (1U << 0);  ///< NVM access protection
        constexpr uint32_t NVM_ADDR_ERR = (1U << 1);  ///< NVM address protection
        constexpr uint32_t NVM_SFR_PROT_ERR = (1U << 2);  ///< NVM SFR access protection
        constexpr uint32_t NVM_SFR_ADDR_ERR = (1U << 3);  ///< NVM SFR address protection
        constexpr uint32_t ROM_PROT_ERR = (1U << 4);  ///< ROM access protection
    }

    /// MEMSTAT Register bits
    namespace memstat_bits {
        constexpr uint32_t SECTORINFO = (6 << 0);  ///< Sector information
        constexpr uint32_t SASTATUS = (2 << 6);  ///< Service algorithm status
    }

    /// MODIEN1 Register bits
    namespace modien1_bits {
        constexpr uint32_t EIREN1 = (1U << 0);  ///< SSC 1 error interrupt enable
        constexpr uint32_t TIREN1 = (1U << 1);  ///< SSC 1 transmit interrupt enable
        constexpr uint32_t RIREN1 = (1U << 2);  ///< SSC 1 receive interrupt enable
        constexpr uint32_t EIREN2 = (1U << 8);  ///< SSC 2 error interrupt enable
        constexpr uint32_t TIREN2 = (1U << 9);  ///< SSC 2 transmit interrupt enable
        constexpr uint32_t RIREN2 = (1U << 10);  ///< SSC 2 receive interrupt enable
    }

    /// MODIEN2 Register bits
    namespace modien2_bits {
        constexpr uint32_t RIEN1 = (1U << 0);  ///< UART 1 receive interrupt enable
        constexpr uint32_t TIEN1 = (1U << 1);  ///< UART 1 transmit interrupt enable
        constexpr uint32_t EXINT2_EN = (1U << 5);  ///< External interrupt 2 enable
        constexpr uint32_t RIEN2 = (1U << 6);  ///< UART 2 receive interrupt enable
        constexpr uint32_t TIEN2 = (1U << 7);  ///< UART 2 transmit interrupt enable
    }

    /// MODIEN3 Register bits
    namespace modien3_bits {
        constexpr uint32_t IE0 = (1U << 0);  ///< External interrupt enable
    }

    /// MODIEN4 Register bits
    namespace modien4_bits {
        constexpr uint32_t IE1 = (1U << 0);  ///< External interrupt enable
    }

    /// MODPISEL Register bits
    namespace modpisel_bits {
        constexpr uint32_t EXINT0IS = (2 << 0);  ///< External interrupt 0 input select
        constexpr uint32_t EXINT1IS = (2 << 2);  ///< External interrupt 1 input select
        constexpr uint32_t EXINT2IS = (2 << 4);  ///< External interrupt 2 input select
        constexpr uint32_t URIOS1 = (1U << 6);  ///< UART1 input select
        constexpr uint32_t U_TX_CONDIS = (1U << 7);  ///< TRX input select
        constexpr uint32_t SSC12_M_SCK_OUTSEL = (1U << 16);  ///< Output selection for SSC12_M_SCK
        constexpr uint32_t SSC12_M_MTSR_OUTSEL = (1U << 17);  ///< Output selection for SSC12_M_MTSR
        constexpr uint32_t SSC12_S_MRST_OUTSEL = (1U << 18);  ///< Output selection for SSC12_S_MRST
    }

    /// MODPISEL1 Register bits
    namespace modpisel1_bits {
        constexpr uint32_t XTAL12EN = (1U << 0);  ///< Pins XTAL1/2 enable bit
        constexpr uint32_t T2EXCON = (1U << 6);  ///< Timer 2 external input control
        constexpr uint32_t T21EXCON = (1U << 7);  ///< Timer 21 external input control
    }

    /// MODPISEL2 Register bits
    namespace modpisel2_bits {
        constexpr uint32_t T2IS = (2 << 0);  ///< Timer 2 input select
        constexpr uint32_t T21IS = (2 << 2);  ///< Timer 21 input select
        constexpr uint32_t T2EXIS = (2 << 4);  ///< Timer 2 external input select
        constexpr uint32_t T21EXIS = (2 << 6);  ///< Timer 21 external input select
    }

    /// MODPISEL3 Register bits
    namespace modpisel3_bits {
        constexpr uint32_t URIOS2 = (1U << 6);  ///< UART2 input select
    }

    /// MODPISEL4 Register bits
    namespace modpisel4_bits {
        constexpr uint32_t DU1TRIGGEN = (3 << 0);  ///< Differential unit trigger enable
        constexpr uint32_t DU2TRIGGEN = (3 << 8);  ///< Differential unit trigger enable
        constexpr uint32_t DU3TRIGGEN = (3 << 16);  ///< Differential unit trigger enable
        constexpr uint32_t DU4TRIGGEN = (3 << 24);  ///< Differential unit trigger enable
    }

    /// MODSUSP Register bits
    namespace modsusp_bits {
        constexpr uint32_t T12SUSP = (1U << 1);  ///< Timer 12 debug suspend bit
        constexpr uint32_t T13SUSP = (1U << 2);  ///< Timer 13 debug suspend bit
        constexpr uint32_t T2_SUSP = (1U << 3);  ///< Timer 2 debug suspend bit
        constexpr uint32_t GPT12_SUSP = (1U << 4);  ///< GPT12 debug suspend bit
        constexpr uint32_t T21_SUSP = (1U << 6);  ///< Timer 21 debug suspend bit
        constexpr uint32_t WDT1SUSP = (1U << 7);  ///< Watchdog timer 1 debug suspend bit
        constexpr uint32_t MU_SUSP = (1U << 9);  ///< Measurement unit debug suspend bit
        constexpr uint32_t ADC1_SUSP = (1U << 10);  ///< ADC1 unit debug suspend bit
    }

    /// MONIEN Register bits
    namespace monien_bits {
        constexpr uint32_t MON1IE = (1U << 0);  ///< MON1 interrupt enable
        constexpr uint32_t MON2IE = (1U << 1);  ///< MON2 interrupt enable
        constexpr uint32_t MON3IE = (1U << 2);  ///< MON3 interrupt enable
        constexpr uint32_t MON4IE = (1U << 3);  ///< MON4 interrupt enable
        constexpr uint32_t MON5IE = (1U << 4);  ///< MON5 interrupt enable
    }

    /// NMICON Register bits
    namespace nmicon_bits {
        constexpr uint32_t NMIPLL = (1U << 1);  ///< PLL loss of lock NMI enable
        constexpr uint32_t NMINVM = (1U << 2);  ///< NVM operation complete NMI enable
        constexpr uint32_t NMIOT = (1U << 3);  ///< NMI OT enable
        constexpr uint32_t NMIOWD = (1U << 4);  ///< Oscillator watchdog NMI enable
        constexpr uint32_t NMIMAP = (1U << 5);  ///< NVM map error NMI enable
        constexpr uint32_t NMIECC = (1U << 6);  ///< ECC error NMI enable
        constexpr uint32_t NMISUP = (1U << 7);  ///< Supply prewarning NMI enable
    }

    /// NMISR Register bits
    namespace nmisr_bits {
        constexpr uint32_t FNMIPLL = (1U << 1);  ///< PLL NMI flag
        constexpr uint32_t FNMINVM = (1U << 2);  ///< NVM operation complete NMI flag
        constexpr uint32_t FNMIOT = (1U << 3);  ///< Overtemperature NMI flag
        constexpr uint32_t FNMIOWD = (1U << 4);  ///< Oscillator watchdog NMI flag
        constexpr uint32_t FNMIMAP = (1U << 5);  ///< NVM map error NMI flag
        constexpr uint32_t FNMIECC = (1U << 6);  ///< ECC error NMI flag
        constexpr uint32_t FNMISUP = (1U << 7);  ///< Supply prewarning NMI flag
    }

    /// NMISRCLR Register bits
    namespace nmisrclr_bits {
        constexpr uint32_t FNMIPLLC = (1U << 1);  ///< PLL NMI flag
        constexpr uint32_t FNMINVMC = (1U << 2);  ///< NVM operation complete NMI flag
        constexpr uint32_t FNMIOTC = (1U << 3);  ///< Overtemperature NMI flag
        constexpr uint32_t FNMIOWDC = (1U << 4);  ///< Oscillator watchdog NMI flag
        constexpr uint32_t FNMIMAPC = (1U << 5);  ///< NVM map error NMI flag
        constexpr uint32_t FNMIECCC = (1U << 6);  ///< ECC error NMI flag
        constexpr uint32_t FNMISUPC = (1U << 7);  ///< Supply prewarning NMI flag
    }

    /// NVM_PROT_STS Register bits
    namespace nvm_prot_sts_bits {
        constexpr uint32_t EN_PRG_NL = (1U << 0);  ///< NVM protection of data in non-linear sectors
        constexpr uint32_t EN_PRG_LIN = (1U << 1);  ///< NVM protection of data in linear sectors
        constexpr uint32_t EN_PRG_CBSL = (1U << 2);  ///< NVM protection of data in CBSL region
        constexpr uint32_t EN_RD_NL = (1U << 3);  ///< NVM read protection of data in non-linear sectors
        constexpr uint32_t EN_RD_LIN = (1U << 4);  ///< NVM read protection of data in linear sectors
        constexpr uint32_t EN_RD_CBSL = (1U << 5);  ///< NVM read protection of data in CBSL region
        constexpr uint32_t EN_RD_S0 = (1U << 8);  ///< NVM read protection for sector 0
        constexpr uint32_t DIS_RDUS = (1U << 9);  ///< Configuration of NVM read protection for sector 1...n with EN_RD_* = 0
        constexpr uint32_t DIS_RDUS_S0 = (1U << 10);  ///< Configuration of NVM read protection for sector 0 with EN_RD_S0 = 0
        constexpr uint32_t NL_PW = (1U << 11);  ///< Status of non-linear region password/protection
        constexpr uint32_t LIN_PW = (1U << 12);  ///< Status of linear region password/protection
        constexpr uint32_t CBSL_PW = (1U << 13);  ///< Status of CBSL region password/protection
        constexpr uint32_t NVMBSL = (2 << 14);  ///< CBSL region size definition
    }

    /// OSC_CON Register bits
    namespace osc_con_bits {
        constexpr uint32_t OSCSS = (2 << 0);  ///< Oscillator source select
        constexpr uint32_t OSCWDTRST = (1U << 2);  ///< Oscillator watchdog reset
        constexpr uint32_t OSC2L = (1U << 3);  ///< OSC-too-low condition flag
        constexpr uint32_t XPD = (1U << 4);  ///< XTAL (OSC_HP) power down control
    }

    /// P0_POCON0 Register bits
    namespace p0_pocon0_bits {
        constexpr uint32_t P0_PDM0 = (3 << 0);  ///< P0.0 port driver mode
        constexpr uint32_t P0_PDM1 = (3 << 4);  ///< P0.1 port driver mode
        constexpr uint32_t P0_PDM2 = (3 << 8);  ///< P0.2 port driver mode
        constexpr uint32_t P0_PDM3 = (3 << 12);  ///< P0.3 port driver mode
        constexpr uint32_t P0_PDM4 = (3 << 16);  ///< P0.4 port driver mode
        constexpr uint32_t P0_PDM5 = (3 << 20);  ///< P0.5 port driver mode
    }

    /// P1_POCON0 Register bits
    namespace p1_pocon0_bits {
        constexpr uint32_t P1_PDM0 = (3 << 0);  ///< P1.0 port driver mode
        constexpr uint32_t P1_PDM1 = (3 << 4);  ///< P1.1 port driver mode
        constexpr uint32_t P1_PDM2 = (3 << 8);  ///< P1.2 port driver mode
        constexpr uint32_t P1_PDM4 = (3 << 16);  ///< P1.4 port driver mode
    }

    /// PASSWD Register bits
    namespace passwd_bits {
        constexpr uint32_t PW_MODE = (2 << 0);  ///< Bit protection scheme control bit
        constexpr uint32_t PROTECT_S = (1U << 2);  ///< Bit protection signal status bit
        constexpr uint32_t PASS = (5 << 3);  ///< Password bits
    }

    /// PLL_CON Register bits
    namespace pll_con_bits {
        constexpr uint32_t LOCK = (1U << 0);  ///< PLL lock status flag
        constexpr uint32_t RESLD = (1U << 1);  ///< Restart lock detection
        constexpr uint32_t OSCDISC = (1U << 2);  ///< Oscillator disconnect
        constexpr uint32_t VCOBYP = (1U << 3);  ///< PLL VCO bypass mode select
        constexpr uint32_t NDIV = (4 << 4);  ///< PLL N-divider
        constexpr uint32_t UNPROT_OSCDISC = (1U << 10);  ///< Unprotect write access of OSC_DISC
        constexpr uint32_t UNPROT_VCOBYP = (1U << 11);  ///< Unprotect write access of VCO_BYP
    }

    /// PMCON Register bits
    namespace pmcon_bits {
        constexpr uint32_t ADC1_DIS = (1U << 0);  ///< ADC1 disable request, active high
        constexpr uint32_t SSC1_DIS = (1U << 1);  ///< SSC1 disable request, active high
        constexpr uint32_t CCU6_DIS = (1U << 2);  ///< CCU6 disable request, active high
        constexpr uint32_t T2_DIS = (1U << 3);  ///< T2 disable request, active high
        constexpr uint32_t GPT12_DIS = (1U << 4);  ///< General purpose timer 12 disable request, active high
        constexpr uint32_t SSC2_DIS = (1U << 8);  ///< SSC2 disable request, active high
        constexpr uint32_t T21_DIS = (1U << 10);  ///< T21 disable request, active high
    }

    /// PMCON0 Register bits
    namespace pmcon0_bits {
        constexpr uint32_t XTAL_ON = (1U << 0);  ///< OSC_HP operation in STOP mode
        constexpr uint32_t SL = (1U << 1);  ///< Sleep mode
        constexpr uint32_t PD = (1U << 2);  ///< Power-down mode
        constexpr uint32_t SD = (1U << 3);  ///< Slow-down mode
    }

    /// RSTCON Register bits
    namespace rstcon_bits {
        constexpr uint32_t LOCKUP = (1U << 0);  ///< Lockup flag
        constexpr uint32_t LOCKUP_EN = (1U << 7);  ///< Lockup reset enable flag
    }

    /// SYS_STRTUP_STS Register bits
    namespace sys_strtup_sts_bits {
        constexpr uint32_t INIT_FAIL = (1U << 0);  ///< Initialization at startup failed
        constexpr uint32_t MRAMINITSTS = (1U << 1);  ///< Map RAM initialization status
        constexpr uint32_t PG100TP_CHKS_ERR = (1U << 2);  ///< 100 TP Page checksum error
    }

    /// SYSCON0 Register bits
    namespace syscon0_bits {
        constexpr uint32_t NVMCLKFAC = (2 << 4);  ///< NVM access clock factor
        constexpr uint32_t SYSCLKSEL = (2 << 6);  ///< System clock select
    }

    /// TCCR Register bits
    namespace tccr_bits {
        constexpr uint32_t TCC = (2 << 0);  ///< Temperature compensation control
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t VTOR_BYP = (2 << 0);  ///< Vector table bypass mode
    }

    /// WAKECON Register bits
    namespace wakecon_bits {
        constexpr uint32_t WAKEUPEN = (1U << 0);  ///< Wake-up interrupt enable
    }

}

// ============================================================================
// SCUPM Peripheral
// ============================================================================

namespace scupm {
    /// Base addresses
    constexpr uint32_t SCUPM_BASE = 0x50006000;

    /// SCUPM Register structure
    struct Registers {
        volatile uint32_t AMCLK_CTRL;  ///< Offset: 0x04 - Analog module clock control register
        volatile uint32_t AMCLK_FREQ_STS;  ///< Offset: 0x00 - Analog module clock frequency status register
        volatile uint32_t AMCLK_TH_HYS;  ///< Offset: 0x0C - Analog module clock limit register
        volatile uint32_t PCU_CTRL_STS;  ///< Offset: 0x30 - Power control unit control status register
        volatile uint32_t STCALIB;  ///< Offset: 0x6C - System tick calibration register
        volatile uint32_t SYS_IRQ_CTRL;  ///< Offset: 0x28 - System interrupt control register
        volatile uint32_t SYS_IS;  ///< Offset: 0x18 - System interrupt status register
        volatile uint32_t SYS_ISCLR;  ///< Offset: 0x14 - System interrupt status clear register
        volatile uint32_t SYS_SUPPLY_IRQ_CLR;  ///< Offset: 0x24 - System supply interrupt status clear register
        volatile uint32_t SYS_SUPPLY_IRQ_CTRL;  ///< Offset: 0x20 - System supply interrupt control register
        volatile uint32_t SYS_SUPPLY_IRQ_STS;  ///< Offset: 0x1C - System supply interrupt status register
        volatile uint32_t WDT1_TRIG;  ///< Offset: 0x34 - WDT1 watchdog control register
    };

    /// Peripheral instances
    inline Registers* SCUPM = reinterpret_cast<Registers*>(SCUPM_BASE);

    // Bit definitions
    /// AMCLK_CTRL Register bits
    namespace amclk_ctrl_bits {
        constexpr uint32_t CLKWDT_PD_N = (1U << 0);  ///< Clock watchdog power down
    }

    /// AMCLK_FREQ_STS Register bits
    namespace amclk_freq_sts_bits {
        constexpr uint32_t AMCLK1_FREQ = (6 << 0);  ///< Current frequency of analog module clock system clock (MI_CLK)
        constexpr uint32_t AMCLK2_FREQ = (6 << 8);  ///< Current frequency of analog module clock 2 (TFILT_CLK)
    }

    /// AMCLK_TH_HYS Register bits
    namespace amclk_th_hys_bits {
        constexpr uint32_t AMCLK1_UP_TH = (6 << 0);  ///< Analog module clock 1 (MI_CLK) upper limit threshold
        constexpr uint32_t AMCLK1_UP_HYS = (2 << 6);  ///< Analog module clock 1 (MI_CLK) upper hysteresis
        constexpr uint32_t AMCLK1_LOW_TH = (6 << 8);  ///< Analog module clock 1 (MI_CLK) lower limit threshold
        constexpr uint32_t AMCLK1_LOW_HYS = (2 << 14);  ///< Analog module clock 1 (MI_CLK) lower hysteresis
        constexpr uint32_t AMCLK2_UP_TH = (6 << 16);  ///< Analog module clock 2 (TFILT_CLK) upper limit threshold
        constexpr uint32_t AMCLK2_UP_HYS = (2 << 22);  ///< Analog module clock 2 (TFILT_CLK) upper hysteresis
        constexpr uint32_t AMCLK2_LOW_TH = (6 << 24);  ///< Analog module clock 2 (TFILT_CLK) lower limit threshold
        constexpr uint32_t AMCLK2_LOW_HYS = (2 << 30);  ///< Analog module clock 2 (TFILT_CLK) lower hysteresis
    }

    /// PCU_CTRL_STS Register bits
    namespace pcu_ctrl_sts_bits {
        constexpr uint32_t CLKWDT_SD_DIS = (1U << 1);  ///< Power modules clock watchdog shutdown disable
        constexpr uint32_t LIN_VS_UV_SD_DIS = (1U << 8);  ///< LIN module VS undervoltage transmitter shutdown
    }

    /// STCALIB Register bits
    namespace stcalib_bits {
        constexpr uint32_t STCALIB = (26 << 0);  ///< System tick calibration
    }

    /// SYS_IRQ_CTRL Register bits
    namespace sys_irq_ctrl_bits {
        constexpr uint32_t SYS_OTWARN_IE = (1U << 8);  ///< System overtemperature warning interrupt enable
        constexpr uint32_t SYS_OT_IE = (1U << 9);  ///< System overtemperature shutdown interrupt enable (leads to shutdown of system)
        constexpr uint32_t REFBG_LOTHWARN_IE = (1U << 10);  ///< Reference voltage undervoltage interrupt enable
        constexpr uint32_t REFBG_UPTHWARN_IE = (1U << 11);  ///< Reference voltage overvoltage interrupt enable
    }

    /// SYS_IS Register bits
    namespace sys_is_bits {
        constexpr uint32_t LS1_FAIL_IS = (1U << 0);  ///< Low-side driver 1 fail interrupt status
        constexpr uint32_t LS2_FAIL_IS = (1U << 1);  ///< Low-side driver 2 fail interrupt status
        constexpr uint32_t HS1_FAIL_IS = (1U << 2);  ///< High-side driver 1 fail interrupt status
        constexpr uint32_t HS2_FAIL_IS = (1U << 3);  ///< High-side driver 2 fail interrupt status
        constexpr uint32_t LIN_FAIL_IS = (1U << 6);  ///< LIN fail interrupt status
        constexpr uint32_t SYS_OTWARN_IS = (1U << 8);  ///< System overtemperature prewarning (ADC2, channel 6) interrupt status
        constexpr uint32_t SYS_OT_IS = (1U << 9);  ///< System overtemperature shutdown (ADC2, channel 6) interrupt status
        constexpr uint32_t REFBG_LOTHWARN_IS = (1U << 10);  ///< 8-bit ADC2 reference undervoltage (ADC2, channel 3) interrupt status
        constexpr uint32_t REFBG_UPTHWARN_IS = (1U << 11);  ///< 8-bit ADC2 reference overvoltage (ADC2, channel 3) interrupt status
        constexpr uint32_t LS1_FAIL_STS = (1U << 16);  ///< Low-side driver 1 fail status
        constexpr uint32_t LS2_FAIL_STS = (1U << 17);  ///< Low-side driver 2 fail status
        constexpr uint32_t HS1_FAIL_STS = (1U << 18);  ///< High-side driver 1 fail status
        constexpr uint32_t HS2_FAIL_STS = (1U << 19);  ///< High-side driver 2 fail status
        constexpr uint32_t LIN_FAIL_STS = (1U << 22);  ///< LIN fail status
        constexpr uint32_t SYS_OTWARN_STS = (1U << 24);  ///< System overtemperature pre-warning (ADC2, channel 6) status
        constexpr uint32_t SYS_OT_STS = (1U << 25);  ///< System overtemperature shutdown (ADC2, channel 6) status
    }

    /// SYS_ISCLR Register bits
    namespace sys_isclr_bits {
        constexpr uint32_t SYS_OTWARN_ISC = (1U << 8);  ///< System overtemperature pre-warning status clear
        constexpr uint32_t SYS_OT_ISC = (1U << 9);  ///< System overtemperature shutdown status clear
        constexpr uint32_t REFBG_LOTHWARN_ISC = (1U << 10);  ///< 8-bit ADC2 reference undervoltage interrupt status clear
        constexpr uint32_t REFBG_UPTHWARN_ISC = (1U << 11);  ///< 8-bit ADC2 reference overvoltage interrupt status clear
        constexpr uint32_t SYS_OTWARN_SC = (1U << 24);  ///< System overtemperature pre-warning status clear
        constexpr uint32_t SYS_OT_SC = (1U << 25);  ///< System overtemperature shutdown status clear
    }

    /// SYS_SUPPLY_IRQ_CLR Register bits
    namespace sys_supply_irq_clr_bits {
        constexpr uint32_t VBAT_UV_ISC = (1U << 0);  ///< VBAT undervoltage interrupt status clear
        constexpr uint32_t VS_UV_ISC = (1U << 1);  ///< VS undervoltage interrupt status clear
        constexpr uint32_t VDD5V_UV_ISC = (1U << 2);  ///< VDDP undervoltage interrupt status clear
        constexpr uint32_t VDD1V5_UV_ISC = (1U << 3);  ///< VDDC undervoltage interrupt status clear
        constexpr uint32_t VDDEXT_UV_ISC = (1U << 4);  ///< VDDEXT undervoltage interrupt status clear
        constexpr uint32_t VBAT_OV_ISC = (1U << 5);  ///< VBAT overvoltage interrupt status clear
        constexpr uint32_t VS_OV_ISC = (1U << 6);  ///< VS overvoltage interrupt status clear
        constexpr uint32_t VDD5V_OV_ISC = (1U << 7);  ///< VDDP overvoltage interrupt status clear
        constexpr uint32_t VDD1V5_OV_ISC = (1U << 8);  ///< VDDC overvoltage interrupt status clear
        constexpr uint32_t VDDEXT_OV_ISC = (1U << 9);  ///< VDDEXT overvoltage interrupt status clear
        constexpr uint32_t VBAT_UV_SC = (1U << 16);  ///< VBAT undervoltage status clear
        constexpr uint32_t VS_UV_SC = (1U << 17);  ///< VS undervoltage status clear
        constexpr uint32_t VDD5V_UV_SC = (1U << 18);  ///< VDDP undervoltage status clear
        constexpr uint32_t VDD1V5_UV_SC = (1U << 19);  ///< VDDC undervoltage status clear
        constexpr uint32_t VDDEXT_UV_SC = (1U << 20);  ///< VDDEXT undervoltage status clear
        constexpr uint32_t VBAT_OV_SC = (1U << 21);  ///< VBAT overvoltage status clear
        constexpr uint32_t VS_OV_SC = (1U << 22);  ///< VS overvoltage status clear
        constexpr uint32_t VDD5V_OV_SC = (1U << 23);  ///< VDDP overvoltage status clear
        constexpr uint32_t VDD1V5_OV_SC = (1U << 24);  ///< VDDC overvoltage status clear
        constexpr uint32_t VDDEXT_OV_SC = (1U << 25);  ///< VDDEXT overvoltage status clear
    }

    /// SYS_SUPPLY_IRQ_CTRL Register bits
    namespace sys_supply_irq_ctrl_bits {
        constexpr uint32_t VBAT_UV_IE = (1U << 0);  ///< VBAT undervoltage interrupt enable
        constexpr uint32_t VS_UV_IE = (1U << 1);  ///< VS undervoltage interrupt enable
        constexpr uint32_t VDD5V_UV_IE = (1U << 2);  ///< VDDP undervoltage interrupt enable
        constexpr uint32_t VDD1V5_UV_IE = (1U << 3);  ///< VDDC undervoltage interrupt enable
        constexpr uint32_t VDDEXT_UV_IE = (1U << 4);  ///< VDDEXT undervoltage interrupt enable
        constexpr uint32_t VBAT_OV_IE = (1U << 5);  ///< VBAT overvoltage interrupt enable
        constexpr uint32_t VS_OV_IE = (1U << 6);  ///< VS overvoltage interrupt enable
        constexpr uint32_t VDD5V_OV_IE = (1U << 7);  ///< VDDP overvoltage interrupt enable
        constexpr uint32_t VDD1V5_OV_IE = (1U << 8);  ///< VDDC overvoltage interrupt enable
        constexpr uint32_t VDDEXT_OV_IE = (1U << 9);  ///< VDDEXT overvoltage interrupt enable
    }

    /// SYS_SUPPLY_IRQ_STS Register bits
    namespace sys_supply_irq_sts_bits {
        constexpr uint32_t VBAT_UV_IS = (1U << 0);  ///< VBAT undervoltage interrupt status
        constexpr uint32_t VS_UV_IS = (1U << 1);  ///< VS undervoltage interrupt status
        constexpr uint32_t VDD5V_UV_IS = (1U << 2);  ///< VDDP undervoltage interrupt status
        constexpr uint32_t VDD1V5_UV_IS = (1U << 3);  ///< VDDC undervoltage interrupt status
        constexpr uint32_t VDDEXT_UV_IS = (1U << 4);  ///< VDDEXT undervoltage interrupt status
        constexpr uint32_t VBAT_OV_IS = (1U << 5);  ///< VBAT overvoltage interrupt status
        constexpr uint32_t VS_OV_IS = (1U << 6);  ///< VS overvoltage interrupt status
        constexpr uint32_t VDD5V_OV_IS = (1U << 7);  ///< VDDP overvoltage interrupt status
        constexpr uint32_t VDD1V5_OV_IS = (1U << 8);  ///< VDDC overvoltage interrupt status
        constexpr uint32_t VDDEXT_OV_IS = (1U << 9);  ///< VDDEXT overvoltage interrupt status
        constexpr uint32_t VBAT_UV_STS = (1U << 16);  ///< VBAT undervoltage status
        constexpr uint32_t VS_UV_STS = (1U << 17);  ///< VS undervoltage status
        constexpr uint32_t VDD5V_UV_STS = (1U << 18);  ///< VDDP undervoltage status
        constexpr uint32_t VDD1V5_UV_STS = (1U << 19);  ///< VDDC undervoltage status
        constexpr uint32_t VDDEXT_UV_STS = (1U << 20);  ///< VDDEXT undervoltage status
        constexpr uint32_t VBAT_OV_STS = (1U << 21);  ///< VBAT overvoltage status
        constexpr uint32_t VS_OV_STS = (1U << 22);  ///< VS overvoltage status
        constexpr uint32_t VDD5V_OV_STS = (1U << 23);  ///< VDDP overvoltage status
        constexpr uint32_t VDD1V5_OV_STS = (1U << 24);  ///< VDDC overvoltage status
        constexpr uint32_t VDDEXT_OV_STS = (1U << 25);  ///< VDDEXT overvoltage status
    }

    /// WDT1_TRIG Register bits
    namespace wdt1_trig_bits {
        constexpr uint32_t WDP_SEL = (6 << 0);  ///< Watchdog period selection and trigger
        constexpr uint32_t SOWCONF = (2 << 6);  ///< Short open window configuration
    }

}

// ============================================================================
// SSC1 Peripheral
// ============================================================================

namespace ssc1 {
    /// Base addresses
    constexpr uint32_t SSC1_BASE = 0x48024000;

    /// SSC1 Register structure
    struct Registers {
        volatile uint32_t BR;  ///< Offset: 0x10 - Baud-rate timer reload register
        volatile uint32_t CON;  ///< Offset: 0x04 - Control register
        volatile uint32_t ISRCLR;  ///< Offset: 0x14 - Interrupt status register clear
        volatile uint32_t PISEL;  ///< Offset: 0x00 - Port input select register
        volatile uint32_t RB;  ///< Offset: 0x0C - Receiver buffer register
        volatile uint32_t TB;  ///< Offset: 0x08 - Transmitter buffer register
    };

    /// Peripheral instances
    inline Registers* SSC1 = reinterpret_cast<Registers*>(SSC1_BASE);

    // Bit definitions
    /// BR Register bits
    namespace br_bits {
        constexpr uint32_t BR_VALUE = (16 << 0);  ///< Baud rate timer/reload register value
    }

    /// CON Register bits
    namespace con_bits {
        constexpr uint32_t BM = (4 << 0);  ///< Data width selection
        constexpr uint32_t HB = (1U << 4);  ///< Heading control
        constexpr uint32_t PH = (1U << 5);  ///< Clock phase control
        constexpr uint32_t PO = (1U << 6);  ///< Clock polarity control
        constexpr uint32_t LB = (1U << 7);  ///< Loop back control
        constexpr uint32_t TEN = (1U << 8);  ///< Transmit error enable
        constexpr uint32_t REN = (1U << 9);  ///< Receive error enable
        constexpr uint32_t PEN = (1U << 10);  ///< Phase error enable
        constexpr uint32_t BEN = (1U << 11);  ///< Baud rate error enable
        constexpr uint32_t AREN = (1U << 12);  ///< Automatic reset enable
        constexpr uint32_t MS = (1U << 14);  ///< Master select
        constexpr uint32_t EN = (1U << 15);  ///< Enable bit
        constexpr uint32_t BC = (4 << 16);  ///< Bit count field
        constexpr uint32_t TE = (1U << 24);  ///< Transmit error flag
        constexpr uint32_t RE = (1U << 25);  ///< Receive error flag
        constexpr uint32_t PE = (1U << 26);  ///< Phase error flag
        constexpr uint32_t BE = (1U << 27);  ///< Baud rate error flag
        constexpr uint32_t BSY = (1U << 28);  ///< Busy flag
    }

    /// ISRCLR Register bits
    namespace isrclr_bits {
        constexpr uint32_t TECLR = (1U << 8);  ///< Transmit error flag clear
        constexpr uint32_t RECLR = (1U << 9);  ///< Receive error flag clear
        constexpr uint32_t PECLR = (1U << 10);  ///< Phase error flag clear
        constexpr uint32_t BECLR = (1U << 11);  ///< Baud rate error flag clear
    }

    /// PISEL Register bits
    namespace pisel_bits {
        constexpr uint32_t MIS_0 = (1U << 0);  ///< Master mode input select bit 0 (master mode only)
        constexpr uint32_t SIS = (1U << 1);  ///< Slave mode input select (slave mode only)
        constexpr uint32_t CIS = (1U << 2);  ///< Clock input select (slave mode only)
        constexpr uint32_t MIS_1 = (1U << 3);  ///< Master mode input select bit 1 (master mode only)
    }

    /// RB Register bits
    namespace rb_bits {
        constexpr uint32_t RB_VALUE = (16 << 0);  ///< Receive data register value
    }

    /// TB Register bits
    namespace tb_bits {
        constexpr uint32_t TB_VALUE = (16 << 0);  ///< Transmit data register value
    }

}

// ============================================================================
// SSC2 Peripheral
// ============================================================================

namespace ssc2 {
    /// Base addresses
    constexpr uint32_t SSC2_BASE = 0x48026000;

    /// SSC2 Register structure
    struct Registers {
        volatile uint32_t BR;  ///< Offset: 0x10 - Baud-rate timer reload register
        volatile uint32_t CON;  ///< Offset: 0x04 - Control register
        volatile uint32_t ISRCLR;  ///< Offset: 0x14 - Interrupt status register clear
        volatile uint32_t PISEL;  ///< Offset: 0x00 - Port input select register
        volatile uint32_t RB;  ///< Offset: 0x0C - Receiver buffer register
        volatile uint32_t TB;  ///< Offset: 0x08 - Transmitter buffer register
    };

    /// Peripheral instances
    inline Registers* SSC2 = reinterpret_cast<Registers*>(SSC2_BASE);

    // Bit definitions
    /// BR Register bits
    namespace br_bits {
        constexpr uint32_t BR_VALUE = (16 << 0);  ///< Baud rate timer/reload register value
    }

    /// CON Register bits
    namespace con_bits {
        constexpr uint32_t BM = (4 << 0);  ///< Data width selection
        constexpr uint32_t HB = (1U << 4);  ///< Heading control
        constexpr uint32_t PH = (1U << 5);  ///< Clock phase control
        constexpr uint32_t PO = (1U << 6);  ///< Clock polarity control
        constexpr uint32_t LB = (1U << 7);  ///< Loop back control
        constexpr uint32_t TEN = (1U << 8);  ///< Transmit error enable
        constexpr uint32_t REN = (1U << 9);  ///< Receive error enable
        constexpr uint32_t PEN = (1U << 10);  ///< Phase error enable
        constexpr uint32_t BEN = (1U << 11);  ///< Baud rate error enable
        constexpr uint32_t AREN = (1U << 12);  ///< Automatic reset enable
        constexpr uint32_t MS = (1U << 14);  ///< Master select
        constexpr uint32_t EN = (1U << 15);  ///< Enable bit
        constexpr uint32_t BC = (4 << 16);  ///< Bit count field
        constexpr uint32_t TE = (1U << 24);  ///< Transmit error flag
        constexpr uint32_t RE = (1U << 25);  ///< Receive error flag
        constexpr uint32_t PE = (1U << 26);  ///< Phase error flag
        constexpr uint32_t BE = (1U << 27);  ///< Baud rate error flag
        constexpr uint32_t BSY = (1U << 28);  ///< Busy flag
    }

    /// ISRCLR Register bits
    namespace isrclr_bits {
        constexpr uint32_t TECLR = (1U << 8);  ///< Transmit error flag clear
        constexpr uint32_t RECLR = (1U << 9);  ///< Receive error flag clear
        constexpr uint32_t PECLR = (1U << 10);  ///< Phase error flag clear
        constexpr uint32_t BECLR = (1U << 11);  ///< Baud rate error flag clear
    }

    /// PISEL Register bits
    namespace pisel_bits {
        constexpr uint32_t MIS_0 = (1U << 0);  ///< Master mode input select bit 0 (master mode only)
        constexpr uint32_t SIS = (1U << 1);  ///< Slave mode input select (slave mode only)
        constexpr uint32_t CIS = (1U << 2);  ///< Clock input select (slave mode only)
        constexpr uint32_t MIS_1 = (1U << 3);  ///< Master mode input select bit 1 (master mode only)
    }

    /// RB Register bits
    namespace rb_bits {
        constexpr uint32_t RB_VALUE = (16 << 0);  ///< Receive data register value
    }

    /// TB Register bits
    namespace tb_bits {
        constexpr uint32_t TB_VALUE = (16 << 0);  ///< Transmit data register value
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER2_BASE = 0x48004000;
    constexpr uint32_t TIMER21_BASE = 0x48005000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CNT;  ///< Offset: 0x10 - Timer2 count register
        volatile uint32_t CON;  ///< Offset: 0x00 - Timer2 control register
        volatile uint32_t CON1;  ///< Offset: 0x1C - Timer2 control 1 register
        volatile uint32_t ICLR;  ///< Offset: 0x18 - Timer2 interrupt clear register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Timer2 mode register
        volatile uint32_t RC;  ///< Offset: 0x08 - Timer2 reload/capture register
    };

    /// Peripheral instances
    inline Registers* TIMER2 = reinterpret_cast<Registers*>(TIMER2_BASE);
    inline Registers* TIMER21 = reinterpret_cast<Registers*>(TIMER21_BASE);

    // Bit definitions
    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t T2L = (8 << 0);  ///< Timer2 value
        constexpr uint32_t T2H = (8 << 8);  ///< Timer2 value
    }

    /// CON Register bits
    namespace con_bits {
        constexpr uint32_t CP_RL2 = (1U << 0);  ///< Capture/reload select
        constexpr uint32_t C_T2 = (1U << 1);  ///< Timer or counter select
        constexpr uint32_t TR2 = (1U << 2);  ///< Timer2 start/stop control
        constexpr uint32_t EXEN2 = (1U << 3);  ///< Timer2 external enable control
        constexpr uint32_t EXF2 = (1U << 6);  ///< Timer2 external flag
        constexpr uint32_t TF2 = (1U << 7);  ///< Timer2 overflow/underflow flag
    }

    /// CON1 Register bits
    namespace con1_bits {
        constexpr uint32_t EXF2EN = (1U << 0);  ///< External interrupt enable
        constexpr uint32_t TF2EN = (1U << 1);  ///< Overflow/underflow interrupt enable
    }

    /// ICLR Register bits
    namespace iclr_bits {
        constexpr uint32_t EXF2CLR = (1U << 6);  ///< External interrupt clear flag
        constexpr uint32_t TF2CLR = (1U << 7);  ///< Overflow/underflow interrupt clear flag
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t DCEN = (1U << 0);  ///< Up/down counter enable
        constexpr uint32_t T2PRE = (3 << 1);  ///< Timer2 prescaler bit
        constexpr uint32_t PREN = (1U << 4);  ///< Prescaler enable
        constexpr uint32_t EDGESEL = (1U << 5);  ///< Edge select in capture mode/reload mode
        constexpr uint32_t T2RHEN = (1U << 6);  ///< Timer2 external start enable
        constexpr uint32_t T2REGS = (1U << 7);  ///< Edge select for Timer2 external start
    }

    /// RC Register bits
    namespace rc_bits {
        constexpr uint32_t RCL2 = (8 << 0);  ///< Reload/capture value
        constexpr uint32_t RCH2 = (8 << 8);  ///< Reload/capture value
    }

}

// ============================================================================
// TRX Peripheral
// ============================================================================

namespace trx {
    /// Base addresses
    constexpr uint32_t TRX_BASE = 0x4801E000;

    /// TRX Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Transceiver control register
        volatile uint32_t IRQCLR;  ///< Offset: 0x08 - Transceiver interrupt status rclear register
        volatile uint32_t IRQEN;  ///< Offset: 0x0C - Transceiver interrupt enable register
        volatile uint32_t IRQS;  ///< Offset: 0x04 - Transceiver interrupt status register
    };

    /// Peripheral instances
    inline Registers* TRX = reinterpret_cast<Registers*>(TRX_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t MODE = (2 << 1);  ///< Transceiver power mode control
        constexpr uint32_t MODE_FB = (3 << 4);  ///< Transmitter feedback signals settings [2:1]
        constexpr uint32_t TXD = (1U << 9);  ///< Transmitter state (only used when HV_MODE is set)
        constexpr uint32_t RXD = (1U << 10);  ///< Reveiver output signal
        constexpr uint32_t SM = (2 << 11);  ///< Transmitter slope mode control
        constexpr uint32_t FB_SM = (3 << 13);  ///< Feedback signal for slope mode setting [3:1]
        constexpr uint32_t HV_MODE = (1U << 21);  ///< Transceiver high-voltage I/O mode
    }

    /// IRQCLR Register bits
    namespace irqclr_bits {
        constexpr uint32_t M_SM_ERR_ISC = (1U << 3);  ///< Transceiver mode error - slope mode error interrupt status clear
        constexpr uint32_t OT_ISC = (1U << 4);  ///< Tranceiver overtemperature interrupt status / status clear
        constexpr uint32_t OC_ISC = (1U << 5);  ///< Tranceiver overcurrent interrupt status clear
        constexpr uint32_t TXD_TMOUT_ISC = (1U << 6);  ///< Transceiver TXD timeout interrupt status clear
        constexpr uint32_t M_SM_ERR_SC = (1U << 8);  ///< Transceiver mode error - slope mode error status clear
        constexpr uint32_t OT_SC = (1U << 9);  ///< Tranceiver overtemperature status clear
        constexpr uint32_t TXD_TMOUT_SC = (1U << 11);  ///< Transceiver TXD timeout status clear
    }

    /// IRQEN Register bits
    namespace irqen_bits {
        constexpr uint32_t M_SM_ERR_IEN = (1U << 3);  ///< Transceiver mode error - slope mode error interrupt
        constexpr uint32_t OT_IEN = (1U << 4);  ///< Transceiver overtemperature interrupt
        constexpr uint32_t OC_IEN = (1U << 5);  ///< Transceiver overcurrent interrupt
        constexpr uint32_t TXD_TMOUT_IEN = (1U << 6);  ///< Transceiver TxD-timeout interrupt
    }

    /// IRQS Register bits
    namespace irqs_bits {
        constexpr uint32_t M_SM_ERR_IS = (1U << 3);  ///< Transceiver mode error - slope mode error interrupt status
        constexpr uint32_t OT_IS = (1U << 4);  ///< Transceiver overtemperature interrupt status
        constexpr uint32_t OC_IS = (1U << 5);  ///< Transceiver overcurrent interrupt status
        constexpr uint32_t TXD_TMOUT_IS = (1U << 6);  ///< Transceiver TXD timeout interrupt status
        constexpr uint32_t M_SM_ERR_STS = (1U << 8);  ///< Transceiver mode error - slope mode error status
        constexpr uint32_t OT_STS = (1U << 9);  ///< Transceiver overtemperature status
        constexpr uint32_t TXD_TMOUT_STS = (1U << 11);  ///< Transceiver TXD timeout status
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART1_BASE = 0x48020000;
    constexpr uint32_t UART2_BASE = 0x48022000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t SBUF;  ///< Offset: 0x04 - Serial data buffer register
        volatile uint32_t SCON;  ///< Offset: 0x00 - Serial channel control register
        volatile uint32_t SCONCLR;  ///< Offset: 0x08 - Serial channel control clear register
    };

    /// Peripheral instances
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);

    // Bit definitions
    /// SBUF Register bits
    namespace sbuf_bits {
        constexpr uint32_t VAL = (8 << 0);  ///< Serial interface buffer register
    }

    /// SCON Register bits
    namespace scon_bits {
        constexpr uint32_t RI = (1U << 0);  ///< Receive interrupt flag
        constexpr uint32_t TI = (1U << 1);  ///< Transmit interrupt flag
        constexpr uint32_t RB8 = (1U << 2);  ///< Serial port receiver bit 9
        constexpr uint32_t TB8 = (1U << 3);  ///< Serial port transmitter bit 9
        constexpr uint32_t REN = (1U << 4);  ///< Enable receiver of serial port
        constexpr uint32_t SM2 = (1U << 5);  ///< Enable serial port multiprocessor communication in modes 2 and 3
        constexpr uint32_t SM1 = (1U << 6);  ///< Serial port operating mode selection
        constexpr uint32_t SM0 = (1U << 7);  ///< Serial port operating mode selection
    }

    /// SCONCLR Register bits
    namespace sconclr_bits {
        constexpr uint32_t RICLR = (1U << 0);  ///< SCON.RI clear flag
        constexpr uint32_t TICLR = (1U << 1);  ///< SCON.TI clear flag
        constexpr uint32_t RB8CLR = (1U << 2);  ///< SCON.RB8 clear flag
    }

}


} // namespace alloy::generated::tle984x

#endif // ALLOY_GENERATED_TLE984X_PERIPHERALS_HPP