/// Auto-generated code for TLE985x
/// Generated by Alloy Code Generator
/// Source: infineon_tle985x.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:09
#ifndef ALLOY_GENERATED_TLE985X_PERIPHERALS_HPP
#define ALLOY_GENERATED_TLE985X_PERIPHERALS_HPP

#include <stdint.h>

namespace alloy::generated::tle985x {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_bdrv = true;
    constexpr uint32_t num_bdrv_instances = 1;
    constexpr bool has_ccu6 = true;
    constexpr uint32_t num_ccu6_instances = 1;
    constexpr bool has_cpu = true;
    constexpr uint32_t num_cpu_instances = 1;
    constexpr bool has_gpt12e = true;
    constexpr uint32_t num_gpt12e_instances = 1;
    constexpr bool has_hs = true;
    constexpr uint32_t num_hs_instances = 1;
    constexpr bool has_lin = true;
    constexpr uint32_t num_lin_instances = 1;
    constexpr bool has_math = true;
    constexpr uint32_t num_math_instances = 1;
    constexpr bool has_mf = true;
    constexpr uint32_t num_mf_instances = 1;
    constexpr bool has_pmu = true;
    constexpr uint32_t num_pmu_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 1;
    constexpr bool has_scu = true;
    constexpr uint32_t num_scu_instances = 1;
    constexpr bool has_scupm = true;
    constexpr uint32_t num_scupm_instances = 1;
    constexpr bool has_ssc1 = true;
    constexpr uint32_t num_ssc1_instances = 1;
    constexpr bool has_ssc2 = true;
    constexpr uint32_t num_ssc2_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct bdrv_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccu6_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt12e_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lin_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct math_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scupm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ssc1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ssc2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 1;
    constexpr uint32_t max_gpio_pins = 16;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC1_BASE = 0x40004000;
    constexpr uint32_t ADC2_BASE = 0x4801C000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CAL_CH0_1;  ///< Offset: 0x48 - Calibration for Channel 0 and 1
        volatile uint32_t CAL_CH10_11;  ///< Offset: 0x5C - Calibration for Channel 10 and 11
        volatile uint32_t CAL_CH12_13;  ///< Offset: 0x138 - Calibration for Channel 12 and 13
        volatile uint32_t CAL_CH2_3;  ///< Offset: 0x4C - Calibration for Channel 2 and 3
        volatile uint32_t CAL_CH4_5;  ///< Offset: 0x50 - Calibration for Channel 4 and 5
        volatile uint32_t CAL_CH6_7;  ///< Offset: 0x54 - Calibration for Channel 6 and 7
        volatile uint32_t CAL_CH8_9;  ///< Offset: 0x58 - Calibration for Channel 8 and 9
        volatile uint32_t CHx_EIM;  ///< Offset: 0x08 - Channel Setting Bits for Exceptional Interrupt Measurement
        volatile uint32_t CHx_ESM;  ///< Offset: 0x0C - Channel Setting Bits for Exceptional Sequence Measurement
        volatile uint32_t CNT0_3_LOWER;  ///< Offset: 0xD8 - Lower Counter Trigger Level Post-Processing-Channel 0-3
        volatile uint32_t CNT0_3_UPPER;  ///< Offset: 0xE8 - Upper Counter Trigger Level Post-Processing-Channel 0-3
        volatile uint32_t CNT4_7_LOWER;  ///< Offset: 0xDC - Lower Counter Trigger Level Post-Processing-Channel 4-7
        volatile uint32_t CNT4_7_UPPER;  ///< Offset: 0xEC - Upper Counter Trigger Level Post-Processing-Channel 4-7
        volatile uint32_t CTRL2;  ///< Offset: 0x14 - Measurement Unit 1 Control Register 2
        volatile uint32_t CTRL3;  ///< Offset: 0x18 - Measurement Unit 1 Control Register 3
        volatile uint32_t CTRL5;  ///< Offset: 0x1C - Measurement Unit 1 Control Register 5
        volatile uint32_t CTRL_STS;  ///< Offset: 0x00 - ADC1 Control and Status Register
        volatile uint32_t DCHCNT1_4_LOWER;  ///< Offset: 0xE4 - Lower Counter Trigger Level DifferentialChannel 1
        volatile uint32_t DCHCNT1_4_UPPER;  ///< Offset: 0xF4 - Upper Counter Trigger Level DifferentialChannel 1
        volatile uint32_t DCHTH1_4_LOWER;  ///< Offset: 0xC4 - Lower Comparator Trigger Level Differential Channel 1
        volatile uint32_t DCHTH1_4_UPPER;  ///< Offset: 0xD4 - Upper Comparator Trigger Level Differential Channel 1
        volatile uint32_t DIFFCH_OUT1;  ///< Offset: 0xA0 - ADC1 Differential Channel Output 1
        volatile uint32_t DUIN_SEL;  ///< Offset: 0xFC - Measurement Unit 1 - Differential Unit Input Selection Register
        volatile uint32_t FILT_OUT0;  ///< Offset: 0x70 - ADC1 or Filter Output Channel 0
        volatile uint32_t FILT_OUT1;  ///< Offset: 0x74 - ADC1 or Filter Output Channel 1
        volatile uint32_t FILT_OUT10;  ///< Offset: 0x98 - ADC1 or Filter Output Channel 10
        volatile uint32_t FILT_OUT11;  ///< Offset: 0x9C - ADC1 or Filter Output Channel 11
        volatile uint32_t FILT_OUT12;  ///< Offset: 0x110 - ADC1 or Filter Output Channel 12
        volatile uint32_t FILT_OUT13;  ///< Offset: 0x140 - ADC1 or Filter Output Channel 13
        volatile uint32_t FILT_OUT2;  ///< Offset: 0x78 - ADC1 or Filter Output Channel 2
        volatile uint32_t FILT_OUT3;  ///< Offset: 0x7C - ADC1 or Filter Output Channel 3
        volatile uint32_t FILT_OUT4;  ///< Offset: 0x80 - ADC1 or Filter Output Channel 4
        volatile uint32_t FILT_OUT5;  ///< Offset: 0x84 - ADC1 or Filter Output Channel 5
        volatile uint32_t FILT_OUT6;  ///< Offset: 0x88 - ADC1 or Filter Output Channel 6
        volatile uint32_t FILT_OUT7;  ///< Offset: 0x8C - ADC1 or Filter Output Channel 7
        volatile uint32_t FILT_OUT8;  ///< Offset: 0x90 - ADC1 or Filter Output Channel 8
        volatile uint32_t FILT_OUT9;  ///< Offset: 0x94 - ADC1 or Filter Output Channel 9
        volatile uint32_t FILT_OUTEIM;  ///< Offset: 0x120 - ADC1 or Filter Output of EIM
        volatile uint32_t FILT_UPLO_CTRL;  ///< Offset: 0xB0 - Upper And Lower Threshold Filter Enable
        volatile uint32_t FILTCOEFF0_13;  ///< Offset: 0x60 - Filter Coefficients Measurement Unit Channel 0-13
        volatile uint32_t IRQCLR_1;  ///< Offset: 0x6C - ADC1 Interrupt Status Clear 1 Register
        volatile uint32_t IRQCLR_2;  ///< Offset: 0x108 - ADC1 Interrupt Status Clear 2 Register
        volatile uint32_t IRQEN_1;  ///< Offset: 0x68 - ADC1 Interrupt Enable 1 Register
        volatile uint32_t IRQEN_2;  ///< Offset: 0x10C - ADC1 Interrupt Enable 2 Register
        volatile uint32_t IRQS_1;  ///< Offset: 0x64 - ADC1 Interrupt Status 1 Register
        volatile uint32_t IRQS_2;  ///< Offset: 0x100 - ADC1 Interrupt Status 2 Register
        volatile uint32_t MAX_TIME;  ///< Offset: 0x10 - Maximum Time for Software Mode
        volatile uint32_t MMODE0_7;  ///< Offset: 0xF8 - Overvoltage Measurement Mode of Post-Processing-Channel 0-7
        volatile uint32_t OFFSETCALIB;  ///< Offset: 0x3C - ADC1 Offset Calibration Register
        volatile uint32_t PP_MAP0_3;  ///< Offset: 0x118 - Post-Processing Mapping Channel 0-3
        volatile uint32_t PP_MAP4_7;  ///< Offset: 0x11C - Post-Processing Mapping Channel 4-7
        volatile uint32_t SQ0_1;  ///< Offset: 0x20 - Measurement Unit 1 Channel Enable Bits for Cycle 0-1
        volatile uint32_t SQ10_11;  ///< Offset: 0x34 - Measurement Unit 1 Channel Enable Bits for Cycle 10-11
        volatile uint32_t SQ12_13;  ///< Offset: 0x130 - Measurement Unit 1 Channel Enable Bits for Cycle 12-13
        volatile uint32_t SQ2_3;  ///< Offset: 0x24 - Measurement Unit 1 Channel Enable Bits for Cycle 2-3
        volatile uint32_t SQ4_5;  ///< Offset: 0x28 - Measurement Unit 1 Channel Enable Bits for Cycle 4-5
        volatile uint32_t SQ6_7;  ///< Offset: 0x2C - Measurement Unit 1 Channel Enable Bits for Cycle 6-7
        volatile uint32_t SQ8_9;  ///< Offset: 0x30 - Measurement Unit 1 Channel Enable Bits for Cycle 8-9
        volatile uint32_t SQ_CH_MAP;  ///< Offset: 0x38 - ADC1 Channel Mapping for Sequencer
        volatile uint32_t SQ_FB;  ///< Offset: 0x04 - Sequencer Feedback Register
        volatile uint32_t STATUS;  ///< Offset: 0xBC - ADC1 Status Register
        volatile uint32_t STS_1;  ///< Offset: 0x124 - ADC1 Status 1Register
        volatile uint32_t STS_2;  ///< Offset: 0x104 - ADC1 Status 2 Register
        volatile uint32_t STSCLR_1;  ///< Offset: 0x128 - ADC1 Status Clear 1 Register
        volatile uint32_t TH0_3_LOWER;  ///< Offset: 0x40 - Lower Comparator Trigger Level Post-Processing-Channel 0-3
        volatile uint32_t TH0_3_UPPER;  ///< Offset: 0xC8 - Upper Comparator Trigger Level Post-Processing-Channel 0-3
        volatile uint32_t TH4_7_LOWER;  ///< Offset: 0x44 - Lower Comparator Trigger Level Post-Processing-Channel 4-7
        volatile uint32_t TH4_7_UPPER;  ///< Offset: 0xCC - Upper Comparator Trigger Level Post-Processing-Channel 4-7
    };

    /// Peripheral instances
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* ADC2 = reinterpret_cast<Registers*>(ADC2_BASE);

    // Bit definitions
    /// CAL_CH0_1 Register bits
    namespace cal_ch0_1_bits {
        constexpr uint32_t CALGAIN_CH1 = (8 << 24);  ///< Gain Calibration for channel 1
        constexpr uint32_t CALOFFS_CH1 = (5 << 16);  ///< Offset Calibration for channel 1
        constexpr uint32_t CALGAIN_CH0 = (8 << 8);  ///< Gain Calibration for channel 0
        constexpr uint32_t CALOFFS_CH0 = (5 << 0);  ///< Offset Calibration for channel 0
    }

    /// CAL_CH10_11 Register bits
    namespace cal_ch10_11_bits {
        constexpr uint32_t CALGAIN_CH11 = (8 << 24);  ///< Gain Calibration for channel 11
        constexpr uint32_t CALOFFS_CH11 = (5 << 16);  ///< Offset Calibration for channel 11
        constexpr uint32_t CALGAIN_CH10 = (8 << 8);  ///< Gain Calibration for channel 10
        constexpr uint32_t CALOFFS_CH10 = (5 << 0);  ///< Offset Calibration for channel 10
    }

    /// CAL_CH12_13 Register bits
    namespace cal_ch12_13_bits {
        constexpr uint32_t CALGAIN_CH13 = (8 << 24);  ///< Gain Calibration for channel 13
        constexpr uint32_t CALOFFS_CH13 = (5 << 16);  ///< Offset Calibration for channel 13
        constexpr uint32_t CALGAIN_CH12 = (8 << 8);  ///< Gain Calibration for channel 12
        constexpr uint32_t CALOFFS_CH12 = (5 << 0);  ///< Offset Calibration for channel 12
    }

    /// CAL_CH2_3 Register bits
    namespace cal_ch2_3_bits {
        constexpr uint32_t CALGAIN_CH3 = (8 << 24);  ///< Gain Calibration for channel 3
        constexpr uint32_t CALOFFS_CH3 = (5 << 16);  ///< Offset Calibration for channel 3
        constexpr uint32_t CALGAIN_CH2 = (8 << 8);  ///< Gain Calibration for channel 2
        constexpr uint32_t CALOFFS_CH2 = (5 << 0);  ///< Offset Calibration for channel 2
    }

    /// CAL_CH4_5 Register bits
    namespace cal_ch4_5_bits {
        constexpr uint32_t CALGAIN_CH5 = (8 << 24);  ///< Gain Calibration for channel 5
        constexpr uint32_t CALOFFS_CH5 = (5 << 16);  ///< Offset Calibration for channel 5
        constexpr uint32_t CALGAIN_CH4 = (8 << 8);  ///< Gain Calibration for channel 4
        constexpr uint32_t CALOFFS_CH4 = (5 << 0);  ///< Offset Calibration for channel 4
    }

    /// CAL_CH6_7 Register bits
    namespace cal_ch6_7_bits {
        constexpr uint32_t CALGAIN_CH7 = (8 << 24);  ///< Gain Calibration for channel 7
        constexpr uint32_t CALOFFS_CH7 = (5 << 16);  ///< Offset Calibration for channel 7
        constexpr uint32_t CALGAIN_CH6 = (8 << 8);  ///< Gain Calibration for channel 6
        constexpr uint32_t CALOFFS_CH6 = (5 << 0);  ///< Offset Calibration for channel 6
    }

    /// CAL_CH8_9 Register bits
    namespace cal_ch8_9_bits {
        constexpr uint32_t CALGAIN_CH9 = (8 << 24);  ///< Gain Calibration for channel 9
        constexpr uint32_t CALOFFS_CH9 = (5 << 16);  ///< Offset Calibration for channel 9
        constexpr uint32_t CALGAIN_CH8 = (8 << 8);  ///< Gain Calibration for channel 8
        constexpr uint32_t CALOFFS_CH8 = (5 << 0);  ///< Offset Calibration for channel 8
    }

    /// CHx_EIM Register bits
    namespace chx_eim_bits {
        constexpr uint32_t ADC1_EIM_TRIG_SEL = (3 << 16);  ///< Trigger selection for exceptional interrupt measurement (EIM)
        constexpr uint32_t EIM_EN = (1U << 11);  ///< Exceptional interrupt measurement (EIM) Trigger Event enable
        constexpr uint32_t EIM_REP = (3 << 8);  ///< Repeat count for exceptional interrupt measurement (EIM)
        constexpr uint32_t EIM_CHx = (4 << 0);  ///< Channel set for exceptional interrupt measurement (EIM)
    }

    /// CHx_ESM Register bits
    namespace chx_esm_bits {
        constexpr uint32_t ESM_STS = (1U << 31);  ///< Exceptional Sequence Measurement is finished
        constexpr uint32_t ESM_EN = (1U << 30);  ///< Enable for Exceptional Sequence Measurement Trigger Event
        constexpr uint32_t ADC1_ESM_TRIG_SEL = (3 << 16);  ///< Trigger selection for exceptional interrupt measurement (ESM)
        constexpr uint32_t ESM_0 = (14 << 0);  ///< Channel Sequence for Exceptional Sequence Measurement (ESM)
    }

    /// CNT0_3_LOWER Register bits
    namespace cnt0_3_lower_bits {
        constexpr uint32_t HYST_LO_PP3 = (2 << 27);  ///< Post-Processing-Channel 3 lower hysteresis
        constexpr uint32_t CNT_LO_PP3 = (2 << 24);  ///< Lower timer trigger threshold Post-Processing-Channel 3
        constexpr uint32_t HYST_LO_PP2 = (2 << 19);  ///< Post-Processing-Channel 2 lower hysteresis
        constexpr uint32_t CNT_LO_PP2 = (2 << 16);  ///< Lower timer trigger threshold Post-Processing-Channel 2
        constexpr uint32_t HYST_LO_PP1 = (2 << 11);  ///< Post-Processing-Channel 1 lower hysteresis
        constexpr uint32_t CNT_LO_PP1 = (2 << 8);  ///< Lower timer trigger threshold Post-Processing-Channel 1
        constexpr uint32_t HYST_LO_PP0 = (2 << 3);  ///< Post-Processing-Channel 0 lower hysteresis
        constexpr uint32_t CNT_LO_PP0 = (2 << 0);  ///< Lower timer trigger threshold Post-Processing-Channel 0
    }

    /// CNT0_3_UPPER Register bits
    namespace cnt0_3_upper_bits {
        constexpr uint32_t HYST_UP_PP3 = (2 << 27);  ///< Post-Processing-Channel 3 upper hysteresis
        constexpr uint32_t CNT_UP_PP3 = (2 << 24);  ///< Upper timer trigger threshold Post-Processing-Channel 3
        constexpr uint32_t HYST_UP_PP2 = (2 << 19);  ///< Post-Processing-Channel 2 upper hysteresis
        constexpr uint32_t CNT_UP_PP2 = (2 << 16);  ///< Upper timer trigger threshold Post-Processing-Channel 2
        constexpr uint32_t HYST_UP_PP1 = (2 << 11);  ///< Post-Processing-Channel 1 upper hysteresis
        constexpr uint32_t CNT_UP_PP1 = (2 << 8);  ///< Upper timer trigger threshold Post-Processing-Channel 1
        constexpr uint32_t HYST_UP_PP0 = (2 << 3);  ///< Post-Processing-Channel 0 upper hysteresis
        constexpr uint32_t CNT_UP_PP0 = (2 << 0);  ///< Upper timer trigger threshold Post-Processing-Channel 0
    }

    /// CNT4_7_LOWER Register bits
    namespace cnt4_7_lower_bits {
        constexpr uint32_t HYST_LO_PP7 = (2 << 27);  ///< Post-Processing-Channel 7 lower hysteresis
        constexpr uint32_t CNT_LO_PP7 = (2 << 24);  ///< Lower timer trigger threshold Post-Processing-Channel 7
        constexpr uint32_t HYST_LO_PP6 = (2 << 19);  ///< Channel 6 lower hysteresis
        constexpr uint32_t CNT_LO_PP6 = (2 << 16);  ///< Lower timer trigger threshold Post-Processing-Channel 6
        constexpr uint32_t HYST_LO_PP5 = (2 << 11);  ///< Post-Processing-Channel 5 lower hysteresis
        constexpr uint32_t CNT_LO_PP5 = (2 << 8);  ///< Lower timer trigger threshold Post-Processing-Channel 5
        constexpr uint32_t HYST_LO_PP4 = (2 << 3);  ///< Post-Processing-Channel 4 lower hysteresis
        constexpr uint32_t CNT_LO_PP4 = (2 << 0);  ///< Lower timer trigger threshold Post-Processing-Channel 4
    }

    /// CNT4_7_UPPER Register bits
    namespace cnt4_7_upper_bits {
        constexpr uint32_t HYST_UP_PP7 = (2 << 27);  ///< Post-Processing-Channel 7 upper hysteresis
        constexpr uint32_t CNT_UP_PP7 = (2 << 24);  ///< Upper timer trigger threshold Post-Processing-Channel 7
        constexpr uint32_t HYST_UP_PP6 = (2 << 19);  ///< Post-Processing-Channel 6 upper hysteresis
        constexpr uint32_t CNT_UP_PP6 = (2 << 16);  ///< Upper timer trigger threshold Post-Processing-Channel 6
        constexpr uint32_t HYST_UP_PP5 = (2 << 11);  ///< Post-Processing-Channel 5 upper hysteresis
        constexpr uint32_t CNT_UP_PP5 = (2 << 8);  ///< Upper timer trigger threshold Post-Processing-Channel 5
        constexpr uint32_t HYST_UP_PP4 = (2 << 3);  ///< Post-Processing-Channel 4 upper hysteresis
        constexpr uint32_t CNT_UP_PP4 = (2 << 0);  ///< Upper timer trigger threshold Post-Processing-Channel 4
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t CAL_EN = (14 << 0);  ///< Calibration Enable for Channels 0 to 13
    }

    /// CTRL3 Register bits
    namespace ctrl3_bits {
        constexpr uint32_t SAMPLE_TIME_LVCH = (4 << 16);  ///< Sample time of ADC1
        constexpr uint32_t SAMPLE_TIME_HVCH = (5 << 8);  ///< Sample time of ADC1
        constexpr uint32_t MCM_RDY = (1U << 7);  ///< Ready Signal for MCM after Power On or Reset
        constexpr uint32_t EoC_FAIL = (1U << 6);  ///< Fail of ADC End of Conversion Signal
        constexpr uint32_t EoC_FAIL_CLR = (1U << 4);  ///< Fail of ADC End of Conversion Signal Clear
        constexpr uint32_t SW_MODE = (1U << 1);  ///< Flag to enter SW Mode
        constexpr uint32_t MCM_PD_N = (1U << 0);  ///< Power Down Signal for MCM
    }

    /// CTRL5 Register bits
    namespace ctrl5_bits {
        constexpr uint32_t FILT_OUT_SEL_13_0 = (14 << 0);  ///< Output Filter Selection for Channels 0 to 13
    }

    /// CTRL_STS Register bits
    namespace ctrl_sts_bits {
        constexpr uint32_t STRTUP_DIS = (1U << 18);  ///< DPP1 Startup Disable
        constexpr uint32_t SW_CH_SEL = (4 << 8);  ///< Channel for software mode
        constexpr uint32_t EOC = (1U << 7);  ///< ADC1 End of Conversion (software mode)
        constexpr uint32_t CAL_SIGN = (1U << 5);  ///< Output of Comparator to Steer Gain / Offset calibration
        constexpr uint32_t READY = (1U << 4);  ///< HVADC Ready bit
        constexpr uint32_t SOS = (1U << 2);  ///< ADC1 Start of Sampling/Conversion (software mode)
        constexpr uint32_t SOOC = (1U << 1);  ///< ADC1 Start of Offset Calibration (software mode)
        constexpr uint32_t PD_N = (1U << 0);  ///< ADC1 Power Down Signal
    }

    /// DCHCNT1_4_LOWER Register bits
    namespace dchcnt1_4_lower_bits {
        constexpr uint32_t HYST_LO_DCH1 = (2 << 3);  ///< Post-Processing-Channel 4 lower hysteresis
        constexpr uint32_t CNT_LO_DCH1 = (2 << 0);  ///< Lower timer trigger threshold Post-Processing-Channel 4
    }

    /// DCHCNT1_4_UPPER Register bits
    namespace dchcnt1_4_upper_bits {
        constexpr uint32_t HYST_UP_DCH1 = (2 << 3);  ///< Post-Processing-Channel 4 upper hysteresis
        constexpr uint32_t CNT_UP_DCH1 = (2 << 0);  ///< Upper timer trigger threshold Post-Processing-Channel 4
    }

    /// DCHTH1_4_LOWER Register bits
    namespace dchth1_4_lower_bits {
        constexpr uint32_t DCH1_LOW = (8 << 0);  ///< Differential Channel 1 lower trigger level
    }

    /// DCHTH1_4_UPPER Register bits
    namespace dchth1_4_upper_bits {
        constexpr uint32_t DCH1_UP = (8 << 0);  ///< Differential Channel 1 upper trigger level
    }

    /// DIFFCH_OUT1 Register bits
    namespace diffch_out1_bits {
        constexpr uint32_t DOF1 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t DVF1 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t DWFR1 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t DCH1 = (12 << 0);  ///< ADC differential output value 1
    }

    /// DUIN_SEL Register bits
    namespace duin_sel_bits {
        constexpr uint32_t DU1RES_NEG = (1U << 4);  ///< Differential Unit 1 result negative
        constexpr uint32_t DU1_EN = (1U << 0);  ///< Differential Unit 1 enable
    }

    /// FILT_OUT0 Register bits
    namespace filt_out0_bits {
        constexpr uint32_t OF0 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF0 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR0 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH0 = (12 << 0);  ///< ADC or filter output value channel 0
    }

    /// FILT_OUT1 Register bits
    namespace filt_out1_bits {
        constexpr uint32_t OF1 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF1 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR1 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH1 = (12 << 0);  ///< ADC or filter output value channel 1
    }

    /// FILT_OUT10 Register bits
    namespace filt_out10_bits {
        constexpr uint32_t OF10 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF10 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR10 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH10 = (12 << 0);  ///< ADC or filter output value channel 10
    }

    /// FILT_OUT11 Register bits
    namespace filt_out11_bits {
        constexpr uint32_t OF11 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF11 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR11 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH11 = (12 << 0);  ///< ADC or filter output value channel 11
    }

    /// FILT_OUT12 Register bits
    namespace filt_out12_bits {
        constexpr uint32_t OF12 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF12 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR12 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH12 = (12 << 0);  ///< ADC or filter output value channel 12
    }

    /// FILT_OUT13 Register bits
    namespace filt_out13_bits {
        constexpr uint32_t OF13 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF13 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR13 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH13 = (12 << 0);  ///< ADC or filter output value channel 13
    }

    /// FILT_OUT2 Register bits
    namespace filt_out2_bits {
        constexpr uint32_t OF2 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF2 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR2 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH2 = (12 << 0);  ///< ADC or filter output value channel 2
    }

    /// FILT_OUT3 Register bits
    namespace filt_out3_bits {
        constexpr uint32_t OF3 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF3 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR3 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH3 = (12 << 0);  ///< ADC or filter output value channel 3
    }

    /// FILT_OUT4 Register bits
    namespace filt_out4_bits {
        constexpr uint32_t OF4 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF4 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR4 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH4 = (12 << 0);  ///< ADC or filter output value channel 4
    }

    /// FILT_OUT5 Register bits
    namespace filt_out5_bits {
        constexpr uint32_t OF5 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF5 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR5 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH5 = (12 << 0);  ///< ADC or filter output value channel 5
    }

    /// FILT_OUT6 Register bits
    namespace filt_out6_bits {
        constexpr uint32_t OF6 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF6 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR6 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH6 = (12 << 0);  ///< ADC or filter output value channel 6
    }

    /// FILT_OUT7 Register bits
    namespace filt_out7_bits {
        constexpr uint32_t OF7 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF7 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR7 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH7 = (12 << 0);  ///< ADC or filter output value channel 7
    }

    /// FILT_OUT8 Register bits
    namespace filt_out8_bits {
        constexpr uint32_t OF8 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF8 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR8 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH8 = (12 << 0);  ///< ADC or filter output value channel 8
    }

    /// FILT_OUT9 Register bits
    namespace filt_out9_bits {
        constexpr uint32_t OF9 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF9 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR9 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_CH9 = (12 << 0);  ///< ADC or filter output value channel 9
    }

    /// FILT_OUTEIM Register bits
    namespace filt_outeim_bits {
        constexpr uint32_t OF_EIM = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF_EIM = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR_EIM = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t FILT_OUT_EIM = (12 << 0);  ///< ADC or filter output value for last EIM measurement
    }

    /// FILT_UPLO_CTRL Register bits
    namespace filt_uplo_ctrl_bits {
        constexpr uint32_t FUL_PP_CH7_EN = (1U << 7);  ///< Upper and lower threshold IIR filter enable Post-Processing-Channel 7
        constexpr uint32_t FUL_PP_CH6_EN = (1U << 6);  ///< Upper and lower threshold IIR filter enable Post-Processing-Channel 6
        constexpr uint32_t FUL_PP_CH5_EN = (1U << 5);  ///< Upper and lower threshold IIR filter enable Post-Processing-Channel 5
        constexpr uint32_t FUL_PP_CH4_EN = (1U << 4);  ///< Upper and lower threshold IIR filter enable Post-Processing-Channel 4
        constexpr uint32_t FUL_PP_CH3_EN = (1U << 3);  ///< Upper and lower threshold IIR filter enable Post-Processing-Channel 3
        constexpr uint32_t FUL_PP_CH2_EN = (1U << 2);  ///< Upper and lower threshold IIR filter enable Post-Processing-Channel 2
        constexpr uint32_t FUL_PP_CH1_EN = (1U << 1);  ///< Upper and lower threshold IIR filter enable Post-Processing-Channel 1
        constexpr uint32_t FUL_PP_CH0_EN = (1U << 0);  ///< Upper and lower threshold IIR filter enable Post-Processing-Channel 0
    }

    /// FILTCOEFF0_13 Register bits
    namespace filtcoeff0_13_bits {
        constexpr uint32_t CH13 = (2 << 26);  ///< Filter Coefficients ADC channel 13
        constexpr uint32_t CH12 = (2 << 24);  ///< Filter Coefficients ADC channel 12
        constexpr uint32_t CH11 = (2 << 22);  ///< Filter Coefficients ADC channel 11
        constexpr uint32_t CH10 = (2 << 20);  ///< Filter Coefficients ADC channel 10
        constexpr uint32_t CH9 = (2 << 18);  ///< Filter Coefficients ADC channel 9
        constexpr uint32_t CH8 = (2 << 16);  ///< Filter Coefficients ADC channel 8
        constexpr uint32_t CH7 = (2 << 14);  ///< Filter Coefficients ADC channel 7
        constexpr uint32_t CH6 = (2 << 12);  ///< Filter Coefficients ADC channel 6
        constexpr uint32_t CH5 = (2 << 10);  ///< Filter Coefficients ADC channel 5
        constexpr uint32_t CH4 = (2 << 8);  ///< Filter Coefficients ADC channel 4
        constexpr uint32_t CH3 = (2 << 6);  ///< Filter Coefficients ADC channel 3
        constexpr uint32_t CH2 = (2 << 4);  ///< Filter Coefficients ADC channel 2
        constexpr uint32_t CH1 = (2 << 2);  ///< Filter Coefficients ADC channel 1
        constexpr uint32_t CH0 = (2 << 0);  ///< Filter Coefficients ADC channel 0
    }

    /// IRQCLR_1 Register bits
    namespace irqclr_1_bits {
        constexpr uint32_t DU1UP_ISC = (1U << 25);  ///< Differential Unit 1 lower Interrupt Status Clear
        constexpr uint32_t DU1LO_ISC = (1U << 24);  ///< Differential Unit 1 lower Interrupt Status Clear
        constexpr uint32_t ESM_ISC = (1U << 17);  ///< Exceptional Sequence Measurement (ESM) Status Clear
        constexpr uint32_t EIM_ISC = (1U << 16);  ///< Exceptional Interrupt Measurement (EIM) Status Clear
        constexpr uint32_t IIR_CH13_ISC = (1U << 13);  ///< ADC1 IIR-Filter-Channel 13 Interrupt Status Clear
        constexpr uint32_t IIR_CH12_ISC = (1U << 12);  ///< ADC1 IIR-Filter-Channel 12 Interrupt Status Clear
        constexpr uint32_t IIR_CH11_ISC = (1U << 11);  ///< ADC1 IIR-Filter-Channel 11 Interrupt Status Clear
        constexpr uint32_t IIR_CH10_ISC = (1U << 10);  ///< ADC1 IIR-Filter-Channel 10 Interrupt Status Clear
        constexpr uint32_t IIR_CH9_ISC = (1U << 9);  ///< ADC1 IIR-Filter-Channel 9 Interrupt Status Clear
        constexpr uint32_t IIR_CH8_ISC = (1U << 8);  ///< ADC1 IIR-Filter-Channel 8 Interrupt Status Clear
        constexpr uint32_t IIR_CH7_ISC = (1U << 7);  ///< ADC1 IIR-Filter-Channel 7 Interrupt Status Clear
        constexpr uint32_t IIR_CH6_ISC = (1U << 6);  ///< ADC1 IIR-Filter-Channel 6 Interrupt Status Clear
        constexpr uint32_t IIR_CH5_ISC = (1U << 5);  ///< ADC1 IIR-Filter-Channel 5 Interrupt Status Clear
        constexpr uint32_t IIR_CH4_ISC = (1U << 4);  ///< ADC1 IIR-Filter-Channel 4 Interrupt Status Clear
        constexpr uint32_t IIR_CH3_ISC = (1U << 3);  ///< ADC1 IIR-Filter-Channel 3 Interrupt Status Clear
        constexpr uint32_t IIR_CH2_ISC = (1U << 2);  ///< ADC1 IIR-Filter-Channel 2 Interrupt Status Clear
        constexpr uint32_t VS_ISC = (1U << 1);  ///< ADC1 IIR-Filter-Channel 1 Interrupt Status Clear
        constexpr uint32_t IIR_CH0_ISC = (1U << 0);  ///< ADC1 IIR-Filter-Channel 0 Interrupt Status Clear
    }

    /// IRQCLR_2 Register bits
    namespace irqclr_2_bits {
        constexpr uint32_t PP_CH7_UP_ISC = (1U << 23);  ///< ADC1 Post-Processing-Channel 7 Upper Threshold Interrupt Status Clear
        constexpr uint32_t PP_CH6_UP_ISC = (1U << 22);  ///< ADC1 Post-Processing-Channel 6 Upper Threshold Interrupt Status Clear
        constexpr uint32_t PP_CH5_UP_ISC = (1U << 21);  ///< ADC1 Post-Processing-Channel 5 Upper Threshold Interrupt Status Clear
        constexpr uint32_t PP_CH4_UP_ISC = (1U << 20);  ///< ADC1 Post-Processing-Channel 4 Upper Threshold Interrupt Status Clear
        constexpr uint32_t PP_CH3_UP_ISC = (1U << 19);  ///< ADC1 Post-Processing-Channel 3 Upper Threshold Interrupt Status Clear
        constexpr uint32_t PP_CH2_UP_ISC = (1U << 18);  ///< ADC1 Post-Processing-Channel 2 Upper Threshold Interrupt Status Clear
        constexpr uint32_t VS_UP_ISC = (1U << 17);  ///< ADC1 Post-Processing-Channel 1 Upper Threshold Interrupt Status Clear
        constexpr uint32_t PP_CH0_UP_ISC = (1U << 16);  ///< ADC1 Post-Processing-Channel 0 Upper Threshold Interrupt Status Clear
        constexpr uint32_t PP_CH7_LO_ISC = (1U << 7);  ///< ADC1 Post-Processing-Channel 7 Lower Threshold Interrupt Status Clear
        constexpr uint32_t PP_CH6_LO_ISC = (1U << 6);  ///< ADC1 Post-Processing-Channel 6 Lower Threshold Interrupt Status Clear
        constexpr uint32_t PP_CH5_LO_ISC = (1U << 5);  ///< ADC1 Post-Processing-Channel 5 Lower Threshold Interrupt Status Clear
        constexpr uint32_t PP_CH4_LO_ISC = (1U << 4);  ///< ADC1 Post-Processing-Channel 4 Lower Threshold Interrupt Status Clear
        constexpr uint32_t PP_CH3_LO_ISC = (1U << 3);  ///< ADC1 Post-Processing-Channel 3 Lower Threshold Interrupt Status Clear
        constexpr uint32_t PP_CH2_LO_ISC = (1U << 2);  ///< ADC1 Post-Processing-Channel 2 Lower Threshold Interrupt Status Clear
        constexpr uint32_t VS_LO_ISC = (1U << 1);  ///< ADC1 Post-Processing-Channel 1 Lower Threshold Interrupt Status Clear
        constexpr uint32_t PP_CH0_LO_ISC = (1U << 0);  ///< ADC1 Post-Processing-Channel 0 Lower Threshold Interrupt Status Clear
    }

    /// IRQEN_1 Register bits
    namespace irqen_1_bits {
        constexpr uint32_t DU1UP_IEN = (1U << 25);  ///< Differential Unit 1 upper Interrupt Enable
        constexpr uint32_t DU1LO_IEN = (1U << 24);  ///< Differential Unit 1 lower Interrupt Enable
        constexpr uint32_t ESM_IEN = (1U << 17);  ///< Exceptional Sequence Measurement (ESM) Interrupt Enable
        constexpr uint32_t EIM_IEN = (1U << 16);  ///< Exceptional Interrupt Measurement (EIM) Interrupt Enable
        constexpr uint32_t IIR_CH13_IEN = (1U << 13);  ///< ADC1 IIR-Filter-Channel 13 Interrupt Enable
        constexpr uint32_t IIR_CH12_IEN = (1U << 12);  ///< ADC1 IIR-Filter-Channel 12 Interrupt Enable
        constexpr uint32_t IIR_CH11_IEN = (1U << 11);  ///< ADC1 IIR-Filter-Channel 11 Interrupt Enable
        constexpr uint32_t IIR_CH10_IEN = (1U << 10);  ///< ADC1 IIR-Filter-Channel 10 Interrupt Enable
        constexpr uint32_t IIR_CH9_IEN = (1U << 9);  ///< ADC1 IIR-Filter-Channel 9 Interrupt Enable
        constexpr uint32_t IIR_CH8_IEN = (1U << 8);  ///< ADC1 IIR-Filter-Channel 8 Interrupt Enable
        constexpr uint32_t IIR_CH7_IEN = (1U << 7);  ///< ADC1 IIR-Filter-Channel 7 Interrupt Enable
        constexpr uint32_t IIR_CH6_IEN = (1U << 6);  ///< ADC1 IIR-Filter-Channel 6 Interrupt Enable
        constexpr uint32_t IIR_CH5_IEN = (1U << 5);  ///< ADC1 IIR-Filter-Channel 5 Interrupt Enable
        constexpr uint32_t IIR_CH4_IEN = (1U << 4);  ///< ADC1 IIR-Filter-Channel 4 Interrupt Enable
        constexpr uint32_t IIR_CH3_IEN = (1U << 3);  ///< ADC1 IIR-Filter-Channel 3 Interrupt Enable
        constexpr uint32_t IIR_CH2_IEN = (1U << 2);  ///< ADC1 IIR-Filter-Channel 2 Interrupt Enable
        constexpr uint32_t VS_IEN = (1U << 1);  ///< ADC1 IIR-Filter-Channel 1 Interrupt Enable
        constexpr uint32_t IIR_CH0_IEN = (1U << 0);  ///< ADC1 IIR-Filter-Channel 0 Interrupt Enable
    }

    /// IRQEN_2 Register bits
    namespace irqen_2_bits {
        constexpr uint32_t PP_CH7_UP_IEN = (1U << 23);  ///< ADC1 Post-Processing-Channel 7 Upper Threshold Interrupt Enable
        constexpr uint32_t PP_CH6_UP_IEN = (1U << 22);  ///< ADC1 Post-Processing-Channel 6 Upper Threshold Interrupt Enable
        constexpr uint32_t PP_CH5_UP_IEN = (1U << 21);  ///< ADC1 Post-Processing-Channel 5 Upper Threshold Interrupt Enable
        constexpr uint32_t PP_CH4_UP_IEN = (1U << 20);  ///< ADC1 Post-Processing-Channel 4 Upper Threshold Interrupt Enable
        constexpr uint32_t PP_CH3_UP_IEN = (1U << 19);  ///< ADC1 Post-Processing-Channel 3 Upper Threshold Interrupt Enable
        constexpr uint32_t PP_CH2_UP_IEN = (1U << 18);  ///< ADC1 Post-Processing-Channel 2 Upper Threshold Interrupt Enable
        constexpr uint32_t VS_UP_IEN = (1U << 17);  ///< ADC1 Post-Processing-Channel 1 Upper Threshold Interrupt Enable
        constexpr uint32_t PP_CH0_UP_IEN = (1U << 16);  ///< ADC1 Post-Processing-Channel 0 Upper Threshold Interrupt Enable
        constexpr uint32_t PP_CH7_LO_IEN = (1U << 7);  ///< ADC1 Post-Processing-Channel 7 Lower Threshold Interrupt Enable
        constexpr uint32_t PP_CH6_LO_IEN = (1U << 6);  ///< ADC1 Post-Processing-Channel 6 Lower Threshold Interrupt Enable
        constexpr uint32_t PP_CH5_LO_IEN = (1U << 5);  ///< ADC1 Post-Processing-Channel 5 Lower Threshold Interrupt Enable
        constexpr uint32_t PP_CH4_LO_IEN = (1U << 4);  ///< ADC1 Post-Processing-Channel 4 Lower Threshold Interrupt Enable
        constexpr uint32_t PP_CH3_LO_IEN = (1U << 3);  ///< ADC1 Post-Processing-Channel 3 Lower Threshold Interrupt Enable
        constexpr uint32_t PP_CH2_LO_IEN = (1U << 2);  ///< ADC1 Post-Processing-Channel 2 Lower Threshold Interrupt Enable
        constexpr uint32_t VS_LO_IEN = (1U << 1);  ///< ADC1 Post-Processing-Channel 1 Lower Threshold Interrupt Enable
        constexpr uint32_t PP_CH0_LO_IEN = (1U << 0);  ///< ADC1 Post-Processing-Channel 0 Lower Threshold Interrupt Enable
    }

    /// IRQS_1 Register bits
    namespace irqs_1_bits {
        constexpr uint32_t DU1UP_IS = (1U << 25);  ///< ADC1 Differential Unit 1 (DU1) upper Channel Interrupt Status
        constexpr uint32_t DU1LO_IS = (1U << 24);  ///< ADC1 Differential Unit 1 (DU1) lower Channel Interrupt Status
        constexpr uint32_t ESM_IS = (1U << 17);  ///< Exceptional Sequence Measurement (ESM) Status
        constexpr uint32_t EIM_IS = (1U << 16);  ///< Exceptional Interrupt Measurement (EIM) Status
        constexpr uint32_t IIR_CH13_IS = (1U << 13);  ///< ADC1 IIR-Filter-Channel 13 Interrupt Status
        constexpr uint32_t IIR_CH12_IS = (1U << 12);  ///< ADC1 IIR-Filter-Channel 12 Interrupt Status
        constexpr uint32_t IIR_CH11_IS = (1U << 11);  ///< ADC1 IIR-Filter-Channel 11 Interrupt Status
        constexpr uint32_t IIR_CH10_IS = (1U << 10);  ///< ADC1 IIR-Filter-Channel 10 Interrupt Status
        constexpr uint32_t IIR_CH9_IS = (1U << 9);  ///< ADC1 IIR-Filter-Channel 9 Interrupt Status
        constexpr uint32_t IIR_CH8_IS = (1U << 8);  ///< ADC1 IIR-Filter-Channel 8 Interrupt Status
        constexpr uint32_t IIR_CH7_IS = (1U << 7);  ///< ADC1 IIR-Filter-Channel 7 Interrupt Status
        constexpr uint32_t IIR_CH6_IS = (1U << 6);  ///< ADC1 IIR-Filter-Channel 6 Interrupt Status
        constexpr uint32_t IIR_CH5_IS = (1U << 5);  ///< ADC1 IIR-Filter-Channel 5 Interrupt Status
        constexpr uint32_t IIR_CH4_IS = (1U << 4);  ///< ADC1 IIR-Filter-Channel 4 Interrupt Status
        constexpr uint32_t IIR_CH3_IS = (1U << 3);  ///< ADC1 IIR-Filter-Channel 3 Interrupt Status
        constexpr uint32_t IIR_CH2_IS = (1U << 2);  ///< ADC1 IIR-Filter-Channel 2 Interrupt Status
        constexpr uint32_t VS_IS = (1U << 1);  ///< ADC1 IIR-Filter-Channel 1 Interrupt Status
        constexpr uint32_t IIR_CH0_IS = (1U << 0);  ///< ADC1 IIR-Filter-Channel 0 Interrupt Status
    }

    /// IRQS_2 Register bits
    namespace irqs_2_bits {
        constexpr uint32_t PP_CH7_UP_IS = (1U << 23);  ///< ADC1 Post-Processing-Channel 7 Upper Threshold Interrupt Status
        constexpr uint32_t PP_CH6_UP_IS = (1U << 22);  ///< ADC1 Post-Processing-Channel 6 Upper Threshold Interrupt Status
        constexpr uint32_t PP_CH5_UP_IS = (1U << 21);  ///< ADC1 Post-Processing-Channel 5 Upper Threshold Interrupt Status
        constexpr uint32_t PP_CH4_UP_IS = (1U << 20);  ///< ADC1 Post-Processing-Channel 4 Upper Threshold Interrupt Status
        constexpr uint32_t PP_CH3_UP_IS = (1U << 19);  ///< ADC1 Post-Processing-Channel 3 Upper Threshold Interrupt Status
        constexpr uint32_t PP_CH2_UP_IS = (1U << 18);  ///< ADC1 Post-Processing-Channel 2 Upper Threshold Interrupt Status
        constexpr uint32_t VS_UP_IS = (1U << 17);  ///< ADC1 Post-Processing-Channel 1 Upper Threshold Interrupt Status
        constexpr uint32_t PP_CH0_UP_IS = (1U << 16);  ///< ADC1 Post-Processing-Channel 0 Upper Threshold Interrupt Status
        constexpr uint32_t PP_CH7_LO_IS = (1U << 7);  ///< ADC1 Post-Processing-Channel 7 Lower Threshold Interrupt Status
        constexpr uint32_t PP_CH6_LO_IS = (1U << 6);  ///< ADC1 Post-Processing-Channel 6 Lower Threshold Interrupt Status
        constexpr uint32_t PP_CH5_LO_IS = (1U << 5);  ///< ADC1 Post-Processing-Channel 5 Lower Threshold Interrupt Status
        constexpr uint32_t PP_CH4_LO_IS = (1U << 4);  ///< ADC1 Post-Processing-Channel 4 Lower Threshold Interrupt Status
        constexpr uint32_t PP_CH3_LO_IS = (1U << 3);  ///< ADC1 Post-Processing-Channel 3 Lower Threshold Interrupt Status
        constexpr uint32_t PP_CH2_LO_IS = (1U << 2);  ///< ADC1 Post-Processing-Channel 2 Lower Threshold Interrupt Status
        constexpr uint32_t VS_LO_IS = (1U << 1);  ///< ADC1 Post-Processing-Channel 1 Lower Threshold Interrupt Status
        constexpr uint32_t PP_CH0_LO_IS = (1U << 0);  ///< ADC1 Post-Processing-Channel 0 Lower Threshold Interrupt Status
    }

    /// MAX_TIME Register bits
    namespace max_time_bits {
        constexpr uint32_t MAX_TIME = (8 << 0);  ///< Maximum Time in Software Mode
    }

    /// MMODE0_7 Register bits
    namespace mmode0_7_bits {
        constexpr uint32_t MMODE_D1 = (2 << 24);  ///< Measurement mode Differential Channel 1
        constexpr uint32_t MMODE_7 = (2 << 14);  ///< Measurement mode Post-Processing-Channel 7
        constexpr uint32_t MMODE_6 = (2 << 12);  ///< Measurement mode Post-Processing-Channel 6
        constexpr uint32_t MMODE_5 = (2 << 10);  ///< Measurement mode Post-Processing-Channel 5
        constexpr uint32_t MMODE_4 = (2 << 8);  ///< Measurement mode Post-Processing-Channel 4
        constexpr uint32_t MMODE_3 = (2 << 6);  ///< Measurement mode Post-Processing-Channel 3
        constexpr uint32_t MMODE_2 = (2 << 4);  ///< Measurement mode Post-Processing-Channel 2
        constexpr uint32_t MMODE_1 = (2 << 2);  ///< Measurement mode Post-Processing-Channel 1
        constexpr uint32_t MMODE_0 = (2 << 0);  ///< Measurement mode Post-Processing-Channel 0
    }

    /// OFFSETCALIB Register bits
    namespace offsetcalib_bits {
        constexpr uint32_t OFFSET_DAC = (5 << 8);  ///< Set the Value of the Offset Calibration DAC
        constexpr uint32_t OFFSET_SHIFT = (3 << 0);  ///< Set the Value of the Offset Shift DAC
    }

    /// PP_MAP0_3 Register bits
    namespace pp_map0_3_bits {
        constexpr uint32_t EN_PP_MAP3 = (1U << 31);  ///< Mapping Enable for Post-Processing-Channel 3
        constexpr uint32_t RESET_PP_MAP3 = (1U << 30);  ///< Post-Processing Reset for Mapped Post-Processing-Channel 3
        constexpr uint32_t PP_MAP3 = (4 << 24);  ///< Mapping of Entry Channel to Post-Processing-Channel 3
        constexpr uint32_t EN_PP_MAP2 = (1U << 23);  ///< Mapping Enable for Post-Processing-Channel 2
        constexpr uint32_t RESET_PP_MAP2 = (1U << 22);  ///< Post-Processing Reset for Mapped Post-Processing-Channel 2
        constexpr uint32_t PP_MAP2 = (4 << 16);  ///< Mapping of Entry Channel to Post-Processing-Channel 2
        constexpr uint32_t EN_PP_MAP1 = (1U << 15);  ///< Mapping Enable for Post-Processing-Channel 1
        constexpr uint32_t RESET_PP_MAP1 = (1U << 14);  ///< Post-Processing Reset for Mapped Post-Processing-Channel 1
        constexpr uint32_t EN_PP_MAP0 = (1U << 7);  ///< Mapping Enable for Post-Processing-Channel 0
        constexpr uint32_t RESET_PP_MAP0 = (1U << 6);  ///< Post-Processing Reset for Mapped Post-Processing-Channel 0
    }

    /// PP_MAP4_7 Register bits
    namespace pp_map4_7_bits {
        constexpr uint32_t EN_PP_MAP7 = (1U << 31);  ///< Mapping Enable for Post-Processing-Channel 7
        constexpr uint32_t RESET_PP_MAP7 = (1U << 30);  ///< Post-Processing Reset for Mapped Post-Processing-Channel 7
        constexpr uint32_t PP_MAP7 = (4 << 24);  ///< Mapping of Entry Channel to Post-Processing-Channel 7
        constexpr uint32_t EN_PP_MAP6 = (1U << 23);  ///< Mapping Enable for Post-Processing-Channel 6
        constexpr uint32_t RESET_PP_MAP6 = (1U << 22);  ///< Post-Processing Reset for Mapped Post-Processing-Channel 6
        constexpr uint32_t PP_MAP6 = (4 << 16);  ///< Mapping of Entry Channel to Post-Processing-Channel 6
        constexpr uint32_t EN_PP_MAP5 = (1U << 15);  ///< Mapping Enable for Post-Processing-Channel 5
        constexpr uint32_t RESET_PP_MAP5 = (1U << 14);  ///< Post-Processing Reset for Mapped Post-Processing-Channel 5
        constexpr uint32_t PP_MAP5 = (4 << 8);  ///< Mapping of Entry Channel to Post-Processing-Channel 5
        constexpr uint32_t EN_PP_MAP4 = (1U << 7);  ///< Mapping Enable for Post-Processing-Channel 4
        constexpr uint32_t RESET_PP_MAP4 = (1U << 6);  ///< Post-Processing Reset for Mapped Post-Processing-Channel 4
        constexpr uint32_t PP_MAP4 = (4 << 0);  ///< Mapping of Entry Channel to Post-Processing-Channel 4
    }

    /// SQ0_1 Register bits
    namespace sq0_1_bits {
        constexpr uint32_t SQ1 = (14 << 16);  ///< Sequence 1 channel enable
        constexpr uint32_t SQ0 = (14 << 0);  ///< Sequence 0 channel enable
    }

    /// SQ10_11 Register bits
    namespace sq10_11_bits {
        constexpr uint32_t SQ11 = (14 << 16);  ///< Sequence 11 channel enable
        constexpr uint32_t SQ10 = (14 << 0);  ///< Sequence 10 channel enable
    }

    /// SQ12_13 Register bits
    namespace sq12_13_bits {
        constexpr uint32_t SQ13 = (14 << 16);  ///< Sequence 13 channel enable
        constexpr uint32_t SQ12 = (14 << 0);  ///< Sequence 12 channel enable
    }

    /// SQ2_3 Register bits
    namespace sq2_3_bits {
        constexpr uint32_t SQ3 = (14 << 16);  ///< Sequence 3 channel enable
        constexpr uint32_t SQ2 = (14 << 0);  ///< Sequence 2 channel enable
    }

    /// SQ4_5 Register bits
    namespace sq4_5_bits {
        constexpr uint32_t SQ5 = (14 << 16);  ///< Sequence 5 channel enable
        constexpr uint32_t SQ4 = (14 << 0);  ///< Sequence 4 channel enable
    }

    /// SQ6_7 Register bits
    namespace sq6_7_bits {
        constexpr uint32_t SQ7 = (14 << 16);  ///< Sequence 7 channel enable
        constexpr uint32_t SQ6 = (14 << 0);  ///< Sequence 6 channel enable
    }

    /// SQ8_9 Register bits
    namespace sq8_9_bits {
        constexpr uint32_t SQ9 = (14 << 16);  ///< Sequence 9 channel enable
        constexpr uint32_t SQ8 = (14 << 0);  ///< Sequence 8 channel enable
    }

    /// SQ_CH_MAP Register bits
    namespace sq_ch_map_bits {
        constexpr uint32_t SQ_CH12_MAP = (1U << 12);  ///< ADC mapping to CH12
        constexpr uint32_t SQ_CH6_MAP = (1U << 6);  ///< ADC mapping to CH6
        constexpr uint32_t SQ_CH5_MAP = (1U << 5);  ///< ADC mapping to CH5
    }

    /// SQ_FB Register bits
    namespace sq_fb_bits {
        constexpr uint32_t CHx = (4 << 16);  ///< Current ADC1 Channel
        constexpr uint32_t SQx = (4 << 11);  ///< Current Active ADC1 Sequence
        constexpr uint32_t ESM_ACTIVE = (1U << 10);  ///< ADC1 ESM active
        constexpr uint32_t EIM_ACTIVE = (1U << 9);  ///< ADC1 EIM active
        constexpr uint32_t SQ_STOP = (1U << 8);  ///< ADC1 Sequencer Stop Signal for DPP
        constexpr uint32_t SQ_FB = (5 << 0);  ///< Current Sequence that caused software mode
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SD_FEEDB_ON = (1U << 31);  ///< Sigma Delta Feedback Loop
        constexpr uint32_t SOC_JITTER = (2 << 16);  ///< Programs Soc Clock Jitter
        constexpr uint32_t DAC_IN = (3 << 0);  ///< Programs the 2-bit DAC for functional test
    }

    /// STS_1 Register bits
    namespace sts_1_bits {
        constexpr uint32_t DU1UP_STS = (1U << 25);  ///< ADC1 Differential Unit 1 (DU1) upper Channel Status
        constexpr uint32_t DU1LO_STS = (1U << 24);  ///< ADC1 Differential Unit 1 (DU1) lower Channel Status
    }

    /// STS_2 Register bits
    namespace sts_2_bits {
        constexpr uint32_t PP_CH7_UP_STS = (1U << 23);  ///< ADC1 Post-Processing-Channel 7 Upper Threshold Status
        constexpr uint32_t PP_CH6_UP_STS = (1U << 22);  ///< ADC1 Post-Processing-Channel 6 Upper Threshold Status
        constexpr uint32_t PP_CH5_UP_STS = (1U << 21);  ///< ADC1 Post-Processing-Channel 5 Upper Threshold Status
        constexpr uint32_t PP_CH4_UP_STS = (1U << 20);  ///< ADC1 Post-Processing-Channel 4 Upper Threshold Status
        constexpr uint32_t PP_CH3_UP_STS = (1U << 19);  ///< ADC1 Post-Processing-Channel 3 Upper Threshold Status
        constexpr uint32_t PP_CH2_UP_STS = (1U << 18);  ///< ADC1 Post-Processing-Channel 2 Upper Threshold Status
        constexpr uint32_t VS_UP_STS = (1U << 17);  ///< ADC1 Post-Processing-Channel 1 Upper Threshold Status
        constexpr uint32_t PP_CH0_UP_STS = (1U << 16);  ///< ADC1 Post-Processing-Channel 0 Upper Threshold Status
        constexpr uint32_t PP_CH7_LO_STS = (1U << 7);  ///< ADC1 Post-Processing-Channel 7 Lower Threshold Status
        constexpr uint32_t PP_CH6_LO_STS = (1U << 6);  ///< ADC1 Post-Processing-Channel 6 Lower Threshold Status
        constexpr uint32_t PP_CH5_LO_STS = (1U << 5);  ///< ADC1 Post-Processing-Channel 5 Lower Threshold Status
        constexpr uint32_t PP_CH4_LO_STS = (1U << 4);  ///< ADC1 Post-Processing-Channel 4 Lower Threshold Status
        constexpr uint32_t PP_CH3_LO_STS = (1U << 3);  ///< ADC1 Post-Processing-Channel 3 Lower Threshold Status
        constexpr uint32_t PP_CH2_LO_STS = (1U << 2);  ///< ADC1 Post-Processing-Channel 2 Lower Threshold Status
        constexpr uint32_t VS_LO_STS = (1U << 1);  ///< ADC1 Post-Processing-Channel 1 Lower Threshold Status
        constexpr uint32_t PP_CH0_LO_STS = (1U << 0);  ///< ADC1 Post-Processing-Channel 0 Lower Threshold Status
    }

    /// STSCLR_1 Register bits
    namespace stsclr_1_bits {
        constexpr uint32_t DU1UP_SC = (1U << 25);  ///< ADC1 Differential Unit 1 (DU1) upper Channel Status Clear
        constexpr uint32_t DU1LO_SC = (1U << 24);  ///< ADC1 Differential Unit 1 (DU1) lower Channel Status Clear
    }

    /// TH0_3_LOWER Register bits
    namespace th0_3_lower_bits {
        constexpr uint32_t PP_CH3_LOW = (8 << 24);  ///< Post-Processing-Channel 3 lower trigger level
        constexpr uint32_t PP_CH2_LOW = (8 << 16);  ///< Post-Processing-Channel 2 lower trigger level
        constexpr uint32_t PP_CH1_LOW = (8 << 8);  ///< Post-Processing-Channel 1 lower trigger level
        constexpr uint32_t PP_CH0_LOW = (8 << 0);  ///< Post-Processing-Channel 0 lower trigger level
    }

    /// TH0_3_UPPER Register bits
    namespace th0_3_upper_bits {
        constexpr uint32_t PP_CH3_UP = (8 << 24);  ///< Post-Processing-Channel 3 upper trigger level
        constexpr uint32_t PP_CH2_UP = (8 << 16);  ///< Post-Processing-Channel 2 upper trigger level
        constexpr uint32_t PP_CH1_UP = (8 << 8);  ///< Post-Processing-Channel 1 upper trigger level
        constexpr uint32_t PP_CH0_UP = (8 << 0);  ///< Post-Processing-Channel 0 upper trigger level
    }

    /// TH4_7_LOWER Register bits
    namespace th4_7_lower_bits {
        constexpr uint32_t PP_CH7_LOW = (8 << 24);  ///< Post-Processing-Channel 7 lower trigger level
        constexpr uint32_t PP_CH6_LOW = (8 << 16);  ///< Post-Processing-Channel 6 lower trigger level
        constexpr uint32_t PP_CH5_LOW = (8 << 8);  ///< Post-Processing-Channel 5 lower trigger level
        constexpr uint32_t PP_CH4_LOW = (8 << 0);  ///< Post-Processing-Channel 4 lower trigger level
    }

    /// TH4_7_UPPER Register bits
    namespace th4_7_upper_bits {
        constexpr uint32_t PP_CH7_UP = (8 << 24);  ///< Post-Processing-Channel 7 upper trigger level
        constexpr uint32_t PP_CH6_UP = (8 << 16);  ///< Post-Processing-Channel 6upper trigger level
        constexpr uint32_t PP_CH5_UP = (8 << 8);  ///< Post-Processing-Channel 5 upper trigger level
        constexpr uint32_t PP_CH4_UP = (8 << 0);  ///< Post-Processing-Channel 4 upper trigger level
    }

}

// ============================================================================
// BDRV Peripheral
// ============================================================================

namespace bdrv {
    /// Base addresses
    constexpr uint32_t BDRV_BASE = 0x40034000;

    /// BDRV Register structure
    struct Registers {
        volatile uint32_t ASEQC;  ///< Offset: 0x90 - Adaptive Slewrate Sequencer Control Register
        volatile uint32_t ASEQERRCNT;  ///< Offset: 0xD8 - Adaptive Slewrate Sequencer Error Counter Control Register
        volatile uint32_t ASEQIOFFMAX;  ///< Offset: 0xB4 - Adaptive Slewrate Sequencer Off Phase Maximum Current Setting
        volatile uint32_t ASEQIOFFMIN;  ///< Offset: 0xA4 - Adaptive Slewrate Sequencer Off Phase Minimum Current Setting
        volatile uint32_t ASEQIONMAX;  ///< Offset: 0xB0 - Adaptive Slewrate Sequencer On Phase Maximum Current Setting
        volatile uint32_t ASEQIONMIN;  ///< Offset: 0xA0 - Adaptive Slewrate Sequencer On Phase Minimum Current Setting
        volatile uint32_t ASEQSTS;  ///< Offset: 0x94 - Adaptive Slewrate Sequencer Status Register
        volatile uint32_t CP_CLK_CTRL;  ///< Offset: 0x24 - Charge Pump Clock Control Register
        volatile uint32_t CP_CTRL;  ///< Offset: 0x20 - Charge Pump Control and Status Register
        volatile uint32_t CP_IRQCLR;  ///< Offset: 0x44 - Charge Pump Interrupt Status Clear Register
        volatile uint32_t CP_IRQEN;  ///< Offset: 0x48 - Charge Pump Interrupt Enable Register
        volatile uint32_t CP_IRQS;  ///< Offset: 0x40 - Charge Pump Status Register
        volatile uint32_t CTRL1;  ///< Offset: 0x00 - H-Bridge Driver Control 1
        volatile uint32_t CTRL2;  ///< Offset: 0x04 - H-Bridge Driver Control 2
        volatile uint32_t CTRL3;  ///< Offset: 0x08 - H-Bridge Driver Control 3
        volatile uint32_t DCTRIM_DRVx;  ///< Offset: 0xE0 - Current Trimming of Driver
        volatile uint32_t HB1ASEQOFFVAL;  ///< Offset: 0xBC - Half Bridge 1 Adaptive Sequencer Off Values
        volatile uint32_t HB1ASEQONVAL;  ///< Offset: 0xB8 - Half Bridge 1 Adaptive Sequencer On Values
        volatile uint32_t HB2ASEQOFFVAL;  ///< Offset: 0xD4 - Half Bridge 2 Adaptive Sequencer Off Values
        volatile uint32_t HB2ASEQONVAL;  ///< Offset: 0xD0 - Half Bridge 2 Adaptive Sequencer On Values
        volatile uint32_t IGATECLMPOFFC;  ///< Offset: 0x34 - Gate Current Clamping Value in OFF State
        volatile uint32_t IGATECLMPONC;  ///< Offset: 0x30 - Gate Current Clamping Value in ON State
        volatile uint32_t IRQCLR;  ///< Offset: 0xF4 - H-Bridge Driver Interrupt Status Clear Register
        volatile uint32_t IRQEN;  ///< Offset: 0xF8 - H-Bridge Driver Control
        volatile uint32_t IRQS;  ///< Offset: 0xF0 - H-Bridge Driver Interrupt Status
        volatile uint32_t OFFASEQTMAX;  ///< Offset: 0xAC - Adaptive Slewrate Off Sequencer Maximum Time Setting
        volatile uint32_t OFFASEQTMIN;  ///< Offset: 0x9C - Turn OFF Adaptive Slewrate Sequencer Minimum Time Setting
        volatile uint32_t OFFSEQHB1IC;  ///< Offset: 0x54 - Turn-off Slewrate Sequencer Half Bridge 1 Current Control
        volatile uint32_t OFFSEQHB1TC;  ///< Offset: 0x50 - Turn-off Slewrate Sequencer Half Bridge 1 Time Control
        volatile uint32_t OFFSEQHB2IC;  ///< Offset: 0x74 - Turn-off Slewrate Sequencer Half Bridge 2 Current Control
        volatile uint32_t OFFSEQHB2TC;  ///< Offset: 0x70 - Turn-off Slewrate Sequencer Half Bridge 2 Time Control
        volatile uint32_t ONASEQTMAX;  ///< Offset: 0xA8 - Adaptive Slewrate On Sequencer Maximum Time Setting
        volatile uint32_t ONASEQTMIN;  ///< Offset: 0x98 - Turn ON Adaptive Slewrate Sequencer Minimum Time Setting
        volatile uint32_t ONSEQHB1IC;  ///< Offset: 0x5C - Turn-on Slewrate Sequencer Half Bridge 1 Current Control
        volatile uint32_t ONSEQHB1TC;  ///< Offset: 0x58 - Turn-on Slewrate Sequencer Half Bridge 1 Time Control
        volatile uint32_t ONSEQHB2IC;  ///< Offset: 0x7C - Turn-on Slewrate Sequencer Half Bridge 2 Current Control
        volatile uint32_t ONSEQHB2TC;  ///< Offset: 0x78 - Turn-on Slewrate Sequencer Half Bridge 2 Time Control
        volatile uint32_t PWMSRCSEL;  ///< Offset: 0x0C - PWM Source Selection Register
        volatile uint32_t SEQAFHB1CD;  ///< Offset: 0x68 - Slewrate Sequencer-Active Freewheeling- Half Bridge 1...
        volatile uint32_t SEQAFHB1IC;  ///< Offset: 0x64 - Slewrate Sequencer-Active Freewheeling-Half Bridge 1...
        volatile uint32_t SEQAFHB2CD;  ///< Offset: 0x88 - Slewrate Sequencer-Active Freewheeling- Half Bridge 2...
        volatile uint32_t SEQAFHB2IC;  ///< Offset: 0x84 - Slewrate Sequencer-Active Freewheeling- Half Bridge 2...
        volatile uint32_t SEQMAP;  ///< Offset: 0x10 - Slewrate Sequencer Mapping Register
        volatile uint32_t TRIM_DRVx;  ///< Offset: 0x18 - Trimming of Driver
    };

    /// Peripheral instances
    inline Registers* BDRV = reinterpret_cast<Registers*>(BDRV_BASE);

    // Bit definitions
    /// ASEQC Register bits
    namespace aseqc_bits {
        constexpr uint32_t HB2OFFHYSTEN = (1U << 23);  ///< Half Bridge 2 Optimizer Hysteresis for Switch Off Enable Bit
        constexpr uint32_t HB2ONHYSTEN = (1U << 22);  ///< Half Bridge 2 Optimizer Hysteresis for Switch On Enable Bit
        constexpr uint32_t HB2OPTOFFACT = (1U << 21);  ///< Half Bridge 2 Optimizer for Switch Off Active Bit
        constexpr uint32_t HB2OPTONACT = (1U << 20);  ///< Half Bridge 2 Optimizer for Switch On Active Bit
        constexpr uint32_t HB2ASMOFFEN = (1U << 17);  ///< Half Bridge 2 Adaptive Sequencer Mode for Switch Off Enable
        constexpr uint32_t HB2ASMONEN = (1U << 16);  ///< Half Bridge 2 Adaptive Sequencer Mode for Switch On Enable
        constexpr uint32_t HB1OFFHYSTEN = (1U << 7);  ///< Half Bridge 1 Optimizer Hysteresis for Switch Off Enable Bit
        constexpr uint32_t HB1ONHYSTEN = (1U << 6);  ///< Half Bridge 1 Optimizer Hysteresis for Switch On Enable Bit
        constexpr uint32_t HB1OPTOFFACT = (1U << 5);  ///< Half Bridge 1 Optimizer for Switch Off Active Bit
        constexpr uint32_t HB1OPTONACT = (1U << 4);  ///< Half Bridge 1 Optimizer for Switch On Active Bit
        constexpr uint32_t HB1ASMOFFEN = (1U << 1);  ///< Half Bridge 1 Adaptive Sequencer Mode for Switch Off Enable
        constexpr uint32_t HB1ASMONEN = (1U << 0);  ///< Half Bridge 1 Adaptive Sequencer Mode for Switch On Enable
    }

    /// ASEQERRCNT Register bits
    namespace aseqerrcnt_bits {
        constexpr uint32_t HB2MFERRCNT = (2 << 20);  ///< Half Bridge 2-Measurement Failure Error Counter Setting
        constexpr uint32_t HB2T12ONERRCNT = (2 << 18);  ///< Half Bridge 2-T12 On Error Counter Setting
        constexpr uint32_t HB2T1OFFERRCNT = (2 << 16);  ///< Half Bridge 2-T1 Off Error Counter Setting
        constexpr uint32_t HB1MFERRCNT = (2 << 4);  ///< Half Bridge 1-Measurement Failure Error Counter Setting
        constexpr uint32_t HB1T12ONERRCNT = (2 << 2);  ///< Half Bridge 1-T12 On Error Counter Setting
        constexpr uint32_t HB1T1OFFERRCNT = (2 << 0);  ///< Half Bridge 1-T1 Off Error Counter Setting
    }

    /// ASEQIOFFMAX Register bits
    namespace aseqioffmax_bits {
        constexpr uint32_t I1OFFMAX = (6 << 0);  ///< Slew rate sequencer off-phase 1 max. current setting
    }

    /// ASEQIOFFMIN Register bits
    namespace aseqioffmin_bits {
        constexpr uint32_t I1OFFMIN = (6 << 0);  ///< Slew rate sequencer off-phase 1 min. current setting
    }

    /// ASEQIONMAX Register bits
    namespace aseqionmax_bits {
        constexpr uint32_t I1ONMAX = (6 << 0);  ///< Slew rate sequencer on-phase 1 max. current setting
    }

    /// ASEQIONMIN Register bits
    namespace aseqionmin_bits {
        constexpr uint32_t I1ONMIN = (6 << 0);  ///< Slew rate sequencer on-phase 1 min. current setting
    }

    /// ASEQSTS Register bits
    namespace aseqsts_bits {
        constexpr uint32_t HB2ONMF = (1U << 31);  ///< Half Bridge 2- On Adaptive Mode Measurement Failure
        constexpr uint32_t HB2OFFMF = (1U << 30);  ///< Half Bridge 2- Off Adaptive Mode Measurement Failure
        constexpr uint32_t HB2I1ONMIN = (1U << 23);  ///< Half Bridge 2-I1 On Min Value reached
        constexpr uint32_t HB2T12ONMIN = (1U << 22);  ///< Half Bridge 2-T12 On Min Value reached
        constexpr uint32_t HB2I1ONMAX = (1U << 21);  ///< Half Bridge 2-I1 On Max Value reached
        constexpr uint32_t HB2T12ONMAX = (1U << 20);  ///< Half Bridge 2-T12 On Max Value reached
        constexpr uint32_t HB2I1OFFMIN = (1U << 19);  ///< Half Bridge 2-I1 Off Min Value reached
        constexpr uint32_t HB2T1OFFMIN = (1U << 18);  ///< Half Bridge 2-T1 Off Min Value reached
        constexpr uint32_t HB2I1OFFMAX = (1U << 17);  ///< Half Bridge 2-I1 Off Max Value reached
        constexpr uint32_t HB2T1OFFMAX = (1U << 16);  ///< Half Bridge 2-T1 Off Max Value reached
        constexpr uint32_t HB1ONMF = (1U << 15);  ///< Half Bridge 1-On Adaptive Mode Measurement Failure
        constexpr uint32_t HB1OFFMF = (1U << 14);  ///< Half Bridge 1-Off Adaptive Mode Measurement Failure
        constexpr uint32_t HB1I1ONMIN = (1U << 7);  ///< Half Bridge 1-I1 On Min Value reached
        constexpr uint32_t HB1T12ONMIN = (1U << 6);  ///< Half Bridge 1-T12 On Min Value reached
        constexpr uint32_t HB1I1ONMAX = (1U << 5);  ///< Half Bridge 1-I1 On Max Value reached
        constexpr uint32_t HB1T12ONMAX = (1U << 4);  ///< Half Bridge 1-T12 On Max Value reached
        constexpr uint32_t HB1I1OFFMIN = (1U << 3);  ///< Half Bridge 1-I1 Off Min Value reached
        constexpr uint32_t HB1T1OFFMIN = (1U << 2);  ///< Half Bridge 1-T1 Off Min Value reached
        constexpr uint32_t HB1I1OFFMAX = (1U << 1);  ///< Half Bridge 1-I1 Off Max Value reached
        constexpr uint32_t HB1T1OFFMAX = (1U << 0);  ///< Half Bridge 1-T1 Off Max Value reached
    }

    /// CP_CLK_CTRL Register bits
    namespace cp_clk_ctrl_bits {
        constexpr uint32_t CPCLKDIS_SET = (1U << 16);  ///< Charge Pump Clock Set If Disabled
        constexpr uint32_t CPCLK_EN = (1U << 15);  ///< Charge Pump Clock Enable
        constexpr uint32_t F_CP = (2 << 13);  ///< MSB of CP_CLK divider
        constexpr uint32_t DITH_UPPER = (5 << 8);  ///< CP_CLK upper frequency boundary during dithering
        constexpr uint32_t DITH_LOWER = (5 << 0);  ///< CP_CLK lower frequency boundary during dithering
    }

    /// CP_CTRL Register bits
    namespace cp_ctrl_bits {
        constexpr uint32_t CP_STAGE_SEL = (2 << 29);  ///< Charge Pump Output Voltage Trimming
        constexpr uint32_t VCP14_15V_SEL = (1U << 28);  ///< Charge Pump 15V/14V Output Voltage Sel
        constexpr uint32_t VTHVCP_TRIM = (2 << 26);  ///< Charge Pump Output Voltage Trimming
        constexpr uint32_t VCP9V_SET = (1U << 25);  ///< Charge Pump 9 V Output Voltage Set
        constexpr uint32_t CPLOPWRM_EN = (1U << 24);  ///< Charge Pump Low Power Mode Enable
        constexpr uint32_t DRVx_VSDUP_DIS = (1U << 22);  ///< Driver On VSD Upper Voltage Disable
        constexpr uint32_t DRVx_VSDLO_DIS = (1U << 20);  ///< Driver On VSD Lower Voltage Disable
        constexpr uint32_t DRVx_VCPUP_DIS = (1U << 18);  ///< Driver On Charge Pump Upper Voltage Disable
        constexpr uint32_t DRVx_VCPLO_SDEN = (1U << 17);  ///< Driver Charge Pump Low Voltage Shut-Down
        constexpr uint32_t DRVx_VCPLO_DIS = (1U << 16);  ///< Driver On Charge Pump Low Voltage Disable
        constexpr uint32_t VCP_LOWTH2 = (3 << 8);  ///< Charge Pump Output Voltage Lower Threshold Detection Level
        constexpr uint32_t CP_RDY_EN = (1U << 2);  ///< Bridge Driver on Charge Pump Ready Enable
        constexpr uint32_t CP_EN = (1U << 0);  ///< Charge Pump Enable
    }

    /// CP_IRQCLR Register bits
    namespace cp_irqclr_bits {
        constexpr uint32_t VSD_UPTH_SC = (1U << 31);  ///< Driver Supply MU High Status Clear
        constexpr uint32_t VSD_LOTH_SC = (1U << 29);  ///< Driver Supply MU Low Status Clear
        constexpr uint32_t VCP_UPTH_SC = (1U << 27);  ///< Charge Pump MU High Status Clear
        constexpr uint32_t VCP_LOTH1_SC = (1U << 25);  ///< Charge Pump MU Low Status Clear
        constexpr uint32_t VCP_LOTH2_SC = (1U << 24);  ///< Charge Pump Low Status Clear
        constexpr uint32_t VCP_OTSD_SC = (1U << 20);  ///< Charge Pump Over-temperature Shutdown Status Clear
        constexpr uint32_t VCP_OTW_SC = (1U << 16);  ///< Charge Pump Over-temperature Warning Status Clear
        constexpr uint32_t VSD_UPTH_ISC = (1U << 15);  ///< Driver Supply MU High Interrupt Status Clear
        constexpr uint32_t VSD_LOTH_ISC = (1U << 13);  ///< Driver Supply MU Low Interrupt Status Clear
        constexpr uint32_t VCP_UPTH_ISC = (1U << 11);  ///< Charge Pump MU High Interrupt Status Clear
        constexpr uint32_t VCP_LOTH1_ISC = (1U << 9);  ///< Charge Pump MU Low Interrupt Status Clear
        constexpr uint32_t VCP_LOTH2_ISC = (1U << 8);  ///< Charge Pump Low Interrupt Status Clear
        constexpr uint32_t VCP_OTSD_ISC = (1U << 4);  ///< Charge Pump Over-temperature Shutdown Interrupt Status Clear
        constexpr uint32_t VCP_OTW_ISC = (1U << 0);  ///< Charge Pump Over-temperature Warning Interrupt Status Clear
    }

    /// CP_IRQEN Register bits
    namespace cp_irqen_bits {
        constexpr uint32_t VSD_UPTH_IEN = (1U << 15);  ///< Driver Supply MU High Interrupt Enable
        constexpr uint32_t VSD_LOTH_IEN = (1U << 13);  ///< Driver Supply MU Low Interrupt Enable
        constexpr uint32_t VCP_UPTH_IEN = (1U << 11);  ///< Charge Pump MU High Interrupt Enable
        constexpr uint32_t VCP_LOTH1_IEN = (1U << 9);  ///< Charge Pump MU Low Interrupt Enable
        constexpr uint32_t VCP_LOTH2_IEN = (1U << 8);  ///< Charge Pump Low Interrupt Enable
        constexpr uint32_t VCP_OTSD_IEN = (1U << 4);  ///< Charge Pump Over-temperature Shutdown Interrupt Enable
        constexpr uint32_t VCP_OTW_IEN = (1U << 0);  ///< Charge Pump Over-temperature Warning Interrupt Enable
    }

    /// CP_IRQS Register bits
    namespace cp_irqs_bits {
        constexpr uint32_t VSD_UPTH_STS = (1U << 31);  ///< Driver Supply MU High Status
        constexpr uint32_t VSD_LOTH_STS = (1U << 29);  ///< Driver Supply MU Low Status
        constexpr uint32_t VCP_UPTH_STS = (1U << 27);  ///< Charge Pump MU High Status
        constexpr uint32_t VCP_LOTH1_STS = (1U << 25);  ///< Charge Pump MU Low Status
        constexpr uint32_t VCP_LOTH2_STS = (1U << 24);  ///< Charge Pump Low Status
        constexpr uint32_t VCP_OTSD_STS = (1U << 20);  ///< Charge Pump Overtemperature Shutdown Status
        constexpr uint32_t VCP_OTW_STS = (1U << 16);  ///< Charge Pump Overtemperature Warning Status
        constexpr uint32_t VSD_UPTH_IS = (1U << 15);  ///< Driver Supply MU High Interrupt Status
        constexpr uint32_t VSD_LOTH_IS = (1U << 13);  ///< Driver Supply MU Low Interrupt Status
        constexpr uint32_t VCP_UPTH_IS = (1U << 11);  ///< Charge Pump MU High Interrupt Status
        constexpr uint32_t VCP_LOTH1_IS = (1U << 9);  ///< Charge Pump MU Low Interrupt Status
        constexpr uint32_t VCP_LOTH2_IS = (1U << 8);  ///< Charge Pump Low Interrupt Status
        constexpr uint32_t VCP_OTSD_IS = (1U << 4);  ///< Charge Pump Overtemperature Shutdown Interrupt Status
        constexpr uint32_t VCP_OTW_IS = (1U << 0);  ///< Charge Pump Overtemperature Warning Interrupt Status
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t HS2_OC_DIS = (1U << 31);  ///< High Side Driver Overcurrent Shutdown Select
        constexpr uint32_t HS2_SUPERR_STS = (1U << 29);  ///< High Side Driver 2 Supply Error Status
        constexpr uint32_t HS2_DCS_EN = (1U << 27);  ///< High Side Driver 2 Diagnosis Current Source Enable
        constexpr uint32_t HS2_ON = (1U << 26);  ///< High Side Driver 2 On
        constexpr uint32_t HS2_PWM = (1U << 25);  ///< High Side Driver 2 PWM Enable
        constexpr uint32_t HS2_EN = (1U << 24);  ///< High Side Driver 2 Enable
        constexpr uint32_t HS1_OC_DIS = (1U << 23);  ///< High Side Driver Overcurrent Shutdown Select
        constexpr uint32_t HS1_SUPERR_STS = (1U << 21);  ///< High Side Driver 1 Supply Error Status
        constexpr uint32_t HS1_DCS_EN = (1U << 19);  ///< High Side Driver 1 Diagnosis Current Source Enable
        constexpr uint32_t HS1_ON = (1U << 18);  ///< High Side Driver 1 On
        constexpr uint32_t HS1_PWM = (1U << 17);  ///< High Side Driver 1 PWM Enable
        constexpr uint32_t HS1_EN = (1U << 16);  ///< High Side Driver 1 Enable
        constexpr uint32_t LS2_OC_DIS = (1U << 15);  ///< Low Side Driver Overcurrent Shutdown Select
        constexpr uint32_t LS2_SUPERR_STS = (1U << 13);  ///< Low Side Driver 2 Supply Error Status
        constexpr uint32_t LS2_ON = (1U << 10);  ///< Low Side Driver 2 On
        constexpr uint32_t LS2_PWM = (1U << 9);  ///< Low Side Driver 2 PWM Enable
        constexpr uint32_t LS2_EN = (1U << 8);  ///< Low Side Driver 2 Enable
        constexpr uint32_t LS1_OC_DIS = (1U << 7);  ///< Low Side Driver 1 Overcurrent Shutdown Select
        constexpr uint32_t LS1_SUPERR_STS = (1U << 5);  ///< Low Side Driver 1 Supply Error Status
        constexpr uint32_t LS1_ON = (1U << 2);  ///< Low Side Driver 1 On
        constexpr uint32_t LS1_PWM = (1U << 1);  ///< Low Side Driver 1 PWM Enable
        constexpr uint32_t LS1_EN = (1U << 0);  ///< Low Side Driver 1 Enable
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t DLY_DIAG_DIRSEL = (1U << 31);  ///< Ext. power diag timer on / off select
        constexpr uint32_t DLY_DIAG_CHSEL = (3 << 28);  ///< Ext. power diag timer channel select
        constexpr uint32_t DLY_DIAG_STS = (1U << 27);  ///< Ext. power diag timer valid flag
        constexpr uint32_t DLY_DIAG_SCLR = (1U << 26);  ///< Ext. power diag timer valid flag clear
        constexpr uint32_t DLY_DIAG_TIM = (10 << 16);  ///< Ext. power diag timer result register
        constexpr uint32_t HB2OFFSEQCNF = (1U << 3);  ///< Half Bridge 2 Off Sequencer Configuration
        constexpr uint32_t HB1OFFSEQCNF = (1U << 2);  ///< Half Bridge 1 Off Sequencer Configuration
        constexpr uint32_t HB2ONSEQCNF = (1U << 1);  ///< Half Bridge 2 On Sequencer Configuration
        constexpr uint32_t HB1ONSEQCNF = (1U << 0);  ///< Half Bridge 1 On Sequencer Configuration
    }

    /// CTRL3 Register bits
    namespace ctrl3_bits {
        constexpr uint32_t DRV_CCP_DIS = (1U << 30);  ///< Dynamic cross conduction protection Disable
        constexpr uint32_t DRV_CCP_TMUL = (2 << 28);  ///< Multiplier bits for cross conduction time settings in register DRV_CCP_TIMSEL
        constexpr uint32_t DRV_CCP_TIMSEL = (2 << 24);  ///< Minimum cross conduction protection time setting
        constexpr uint32_t DSMONVTH = (3 << 16);  ///< Voltage Threshold for Drain-Source Monitoring of external FETs
    }

    /// DCTRIM_DRVx Register bits
    namespace dctrim_drvx_bits {
        constexpr uint32_t COMPENS_LS = (3 << 16);  ///< Gain Settings for Low Side Charge Current Compensation
        constexpr uint32_t COMPENS_HS = (3 << 8);  ///< Current Settings for High Side Charge Current Compensation
    }

    /// HB1ASEQOFFVAL Register bits
    namespace hb1aseqoffval_bits {
        constexpr uint32_t HB1_OFFVALVF_CLR = (1U << 31);  ///< Half Bridge 1-Turn off slew rate values Valid Flag - Clear.
        constexpr uint32_t HB1_OFFVALVF = (1U << 30);  ///< Half Bridge 1-Turn off slew rate values - Valid Flag.
        constexpr uint32_t HB1_T2MERR = (1U << 22);  ///< Half Bridge 1-T2 Measurement Error.
        constexpr uint32_t HB1_T2OFFCNT = (6 << 16);  ///< Half Bridge 1-Turn off slew rate-time value measured from beginning of phase 2 to end of phase 2.
        constexpr uint32_t HB1_I1OFFVAL = (6 << 8);  ///< Half Bridge 1-slew rate sequencer off-phase 1 current setting
        constexpr uint32_t HB1_T1OFFCNT = (8 << 0);  ///< Half Bridge 1-Turn off slew rate-time value measured from beginning of phase 1 to end of phase 1.
    }

    /// HB1ASEQONVAL Register bits
    namespace hb1aseqonval_bits {
        constexpr uint32_t HB1_ONVALVF_CLR = (1U << 31);  ///< Half Bridge 1-Turn on slew rate values Valid Flag - Clear.
        constexpr uint32_t HB1_ONVALVF = (1U << 30);  ///< Half Bridge 1-Turn on slew rate values - Valid Flag.
        constexpr uint32_t HB1_T3MERR = (1U << 22);  ///< Half Bridge 1-T3 Measurement Error.
        constexpr uint32_t HB1_T3ONCNT = (6 << 16);  ///< Half Bridge 1-Turn on slew rate-time value measured from beginning of phase 3 to end of phase 3.
        constexpr uint32_t HB1_I1ONVAL = (6 << 8);  ///< Half Bridge 1-slew rate sequencer on-phase 1 current setting
        constexpr uint32_t HB1_T12ONCNT = (8 << 0);  ///< Half Bridge 1-Turn on slew rate-time value measured from beginning of phase 1 to end of phase 2.
    }

    /// HB2ASEQOFFVAL Register bits
    namespace hb2aseqoffval_bits {
        constexpr uint32_t HB2_OFFVALVF_CLR = (1U << 31);  ///< Half Bridge 2-Turn off slew rate values Valid Flag - Clear.
        constexpr uint32_t HB2_OFFVALVF = (1U << 30);  ///< Half Bridge 2-Turn off slew rate values - Valid Flag.
        constexpr uint32_t HB2_T2MERR = (1U << 22);  ///< Half Bridge 2-T2 Measurement Error.
        constexpr uint32_t HB2_T2OFFCNT = (6 << 16);  ///< Half Bridge 2-Turn off slew rate-time value measured from beginning of phase 2 to end of phase 2.
        constexpr uint32_t HB2_I1OFFVAL = (6 << 8);  ///< Half Bridge 2-slew rate sequencer off-phase 1 current setting
        constexpr uint32_t HB2_T1OFFCNT = (8 << 0);  ///< Half Bridge 2-Turn off slew rate-time value measured from beginning of phase 1 to end of phase 1.
    }

    /// HB2ASEQONVAL Register bits
    namespace hb2aseqonval_bits {
        constexpr uint32_t HB2_ONVALVF_CLR = (1U << 31);  ///< Half Bridge 2-Turn on slew rate values Valid Flag - Clear.
        constexpr uint32_t HB2_ONVALVF = (1U << 30);  ///< Half Bridge 2-Turn on slew rate values - Valid Flag.
        constexpr uint32_t HB2_T3MERR = (1U << 22);  ///< Half Bridge 2-T3 Measurement Error.
        constexpr uint32_t HB2_T3ONCNT = (6 << 16);  ///< Half Bridge 2-Turn on slew rate-time value measured from beginning of phase 3 to end of phase 3.
        constexpr uint32_t HB2_I1ONVAL = (6 << 8);  ///< Half Bridge 2-slew rate sequencer on-phase 1 current setting
        constexpr uint32_t HB2_T12ONCNT = (8 << 0);  ///< Half Bridge 2-Turn on slew rate-time value measured from beginning of phase 1 to end of phase 2.
    }

    /// IGATECLMPOFFC Register bits
    namespace igateclmpoffc_bits {
        constexpr uint32_t HB2AF_ICLMPOFF = (6 << 24);  ///< Half Bridge 2-active freewheeling-current clamping value for OFF state
        constexpr uint32_t HB1AF_ICLMPOFF = (6 << 16);  ///< Half Bridge 1-active freewheeling-current clamping value for OFF state
        constexpr uint32_t HB2_ICLMPOFF = (6 << 8);  ///< Half Bridge 2-current clamping value for OFF state
        constexpr uint32_t HB1_ICLMPOFF = (6 << 0);  ///< Half Bridge 1-current clamping value for OFF state
    }

    /// IGATECLMPONC Register bits
    namespace igateclmponc_bits {
        constexpr uint32_t HB2AF_ICLMPON = (6 << 24);  ///< Half Bridge 2-active freewheeling-current clamping value for ON state
        constexpr uint32_t HB1AF_ICLMPON = (6 << 16);  ///< Half Bridge 1-active freewheeling-current clamping value for ON state
        constexpr uint32_t HB2_ICLMPON = (6 << 8);  ///< Half Bridge 2-current clamping value for ON state
        constexpr uint32_t HB1_ICLMPON = (6 << 0);  ///< Half Bridge 1-current clamping value for ON state
    }

    /// IRQCLR Register bits
    namespace irqclr_bits {
        constexpr uint32_t SEQ_ERR_ISC = (1U << 31);  ///< Driver Sequence Error Status Clear
        constexpr uint32_t HS2_OC_ISC = (1U << 30);  ///< External High Side 2 FET Over-current Status Clear
        constexpr uint32_t HS2_DS_SC = (1U << 29);  ///< High Side Driver 2 Drain Source Monitoring Status Clear in OFF-State
        constexpr uint32_t HS2_DS_ISC = (1U << 28);  ///< High Side Driver 2 Drain Source Monitoring Interrupt Status Clear in OFF-State
        constexpr uint32_t HS1_OC_ISC = (1U << 22);  ///< External High Side 1 FET Over-current Status Clear
        constexpr uint32_t HS1_DS_SC = (1U << 21);  ///< High Side Driver 1 Drain Source Monitoring Status Clear in OFF-State
        constexpr uint32_t HS1_DS_ISC = (1U << 20);  ///< High Side Driver 1 Drain Source Monitoring Interrupt Status Clear in OFF-State
        constexpr uint32_t LS2_OC_ISC = (1U << 14);  ///< External Low Side 2 FET Over-current Status Clear
        constexpr uint32_t LS2_DS_SC = (1U << 13);  ///< Low Side Driver 2 Drain Source Monitoring Status Clear in OFF-State
        constexpr uint32_t LS2_DS_ISC = (1U << 12);  ///< Low Side Driver 2 Drain Source Monitoring Interrupt Status Clear in OFF-State
        constexpr uint32_t LS1_OC_ISC = (1U << 6);  ///< External Low Side 1 FET Over-current Status Clear
        constexpr uint32_t LS1_DS_SC = (1U << 5);  ///< Low Side Driver 1 Drain Source Monitoring Status Clear in OFF-State
        constexpr uint32_t LS1_DS_ISC = (1U << 4);  ///< Low Side Driver 1 Drain Source Monitoring Interrupt Status Clear in OFF-State
        constexpr uint32_t HB2_ASEQ_ISC = (1U << 1);  ///< Half Bridge 2 Adaptive Sequencer Interrupt Status Clear
        constexpr uint32_t HB1_ASEQ_ISC = (1U << 0);  ///< Half Bridge 1 Adaptive Sequencer Interrupt Status Clear
    }

    /// IRQEN Register bits
    namespace irqen_bits {
        constexpr uint32_t SEQ_ERR_IEN = (1U << 31);  ///< Driver Sequence Error Interrupt Enable
        constexpr uint32_t HS2_OC_IEN = (1U << 30);  ///< External High Side 2 FET Over-current Interrupt Enable
        constexpr uint32_t HS2_DS_IEN = (1U << 28);  ///< High Side Driver 2 Drain Source Monitoring Interrupt Enable in OFF-State
        constexpr uint32_t HS1_OC_IEN = (1U << 22);  ///< External High Side 1 FET Over-current Interrupt Enable
        constexpr uint32_t HS1_DS_IEN = (1U << 20);  ///< High Side Driver 1 Drain Source Monitoring Interrupt Enable in OFF-State
        constexpr uint32_t LS2_OC_IEN = (1U << 14);  ///< External Low Side 2 FET Over-current Interrupt Enable
        constexpr uint32_t LS2_DS_IEN = (1U << 12);  ///< Low Side Driver 2 Drain Source Monitoring Interrupt Enable in OFF-State
        constexpr uint32_t LS1_OC_IEN = (1U << 6);  ///< External Low Side 1 FET Over-current Interrupt Enable
        constexpr uint32_t LS1_DS_IEN = (1U << 4);  ///< Low Side Driver 1 Drain Source Monitoring Interrupt Enable in OFF-State
        constexpr uint32_t HB2_ASEQ_IEN = (1U << 1);  ///< Half Bridge 2 Adaptive Sequencer Interrupt Enable
        constexpr uint32_t HB1_ASEQ_IEN = (1U << 0);  ///< Half Bridge 1 Adaptive Sequencer Interrupt Enable
    }

    /// IRQS Register bits
    namespace irqs_bits {
        constexpr uint32_t SEQ_ERR_IS = (1U << 31);  ///< Driver Sequence Error Interrupt Status
        constexpr uint32_t HS2_OC_IS = (1U << 30);  ///< External High Side 2 FET Over-current Interrupt Status
        constexpr uint32_t HS2_DS_STS = (1U << 29);  ///< High Side Driver 2 Drain Source Monitoring Status in OFF-State
        constexpr uint32_t HS2_DS_IS = (1U << 28);  ///< High Side Driver 2 Drain Source Monitoring Interrupt Status in OFF-State
        constexpr uint32_t HS1_OC_IS = (1U << 22);  ///< External High Side 1 FET Over-current Interrupt Status
        constexpr uint32_t HS1_DS_STS = (1U << 21);  ///< High Side Driver 1 Drain Source Monitoring Status in OFF-State
        constexpr uint32_t HS1_DS_IS = (1U << 20);  ///< High Side Driver 1 Drain Source Monitoring Interrupt Status in OFF-State
        constexpr uint32_t LS2_OC_IS = (1U << 14);  ///< External Low Side 2 FET Over-current Interrupt Status
        constexpr uint32_t LS2_DS_STS = (1U << 13);  ///< Low Side Driver 2 Drain Source Monitoring Status in OFF-State
        constexpr uint32_t LS2_DS_IS = (1U << 12);  ///< Low Side Driver 2 Drain Source Monitoring Interrupt Status in OFF-State
        constexpr uint32_t LS1_OC_IS = (1U << 6);  ///< External Low Side 1 FET Over-current Interrupt Status
        constexpr uint32_t LS1_DS_STS = (1U << 5);  ///< Low Side Driver 1 Drain Source Monitoring Status in OFF-State
        constexpr uint32_t LS1_DS_IS = (1U << 4);  ///< Low Side Driver 1 Drain Source Monitoring Interrupt Status in OFF-State
        constexpr uint32_t HB2_ASEQ_IS = (1U << 1);  ///< Half Bridge 2 Adaptive Sequencer Interrupt Status
        constexpr uint32_t HB1_ASEQ_IS = (1U << 0);  ///< Half Bridge 1 Adaptive Sequencer Interrupt Status
    }

    /// OFFASEQTMAX Register bits
    namespace offaseqtmax_bits {
        constexpr uint32_t T1OFFMAX = (8 << 0);  ///< Slew rate sequencer off-phase 1 max. time setting
    }

    /// OFFASEQTMIN Register bits
    namespace offaseqtmin_bits {
        constexpr uint32_t HB2T1OFFADDDLY = (4 << 12);  ///< HB2 adaptive sequencer T1OFF additional delay setting.
        constexpr uint32_t HB1T1OFFADDDLY = (4 << 8);  ///< HB1 adaptive sequencer T1OFF additional delay setting.
        constexpr uint32_t T1OFFMIN = (8 << 0);  ///< Slew rate sequencer off-phase 1 min. time setting
    }

    /// OFFSEQHB1IC Register bits
    namespace offseqhb1ic_bits {
        constexpr uint32_t HB1_I4OFF = (6 << 24);  ///< Half Bridge 1-slew rate sequencer off-phase 4 current setting
        constexpr uint32_t HB1_I3OFF = (6 << 16);  ///< Half Bridge 1-slew rate sequencer off-phase 3 current setting
        constexpr uint32_t HB1_I2OFF = (6 << 8);  ///< Half Bridge 1-slew rate sequencer-off phase 2 current setting
        constexpr uint32_t HB1_I1OFF = (6 << 0);  ///< Half Bridge 1-slew rate sequencer off-phase 1 current setting
    }

    /// OFFSEQHB1TC Register bits
    namespace offseqhb1tc_bits {
        constexpr uint32_t HB1_T4OFF = (8 << 24);  ///< Half Bridge 1-slew rate sequencer off-phase 4 time setting
        constexpr uint32_t HB1_T3OFF = (6 << 16);  ///< Half Bridge 1-slew rate sequencer off-phase 3 time setting
        constexpr uint32_t HB1_T2OFF = (6 << 8);  ///< Half Bridge 1-slew rate sequencer off-phase 2 time setting
        constexpr uint32_t HB1_T1OFF = (8 << 0);  ///< Half Bridge 1-slew rate sequencer off-phase 1 time setting
    }

    /// OFFSEQHB2IC Register bits
    namespace offseqhb2ic_bits {
        constexpr uint32_t HB2_I4OFF = (6 << 24);  ///< Half Bridge 2-slew rate sequencer off-phase 4 current setting
        constexpr uint32_t HB2_I3OFF = (6 << 16);  ///< Half Bridge 2-slew rate sequencer off-phase 3 current setting
        constexpr uint32_t HB2_I2OFF = (6 << 8);  ///< Half Bridge 2-slew rate sequencer off-phase 2 current setting
        constexpr uint32_t HB2_I1OFF = (6 << 0);  ///< Half Bridge 2-slew rate sequencer off-phase 1 current setting
    }

    /// OFFSEQHB2TC Register bits
    namespace offseqhb2tc_bits {
        constexpr uint32_t HB2_T4OFF = (8 << 24);  ///< Half Bridge 2-slew rate sequencer off-phase 4 time setting
        constexpr uint32_t HB2_T3OFF = (6 << 16);  ///< Half Bridge 2-slew rate sequencer off-phase 3 time setting
        constexpr uint32_t HB2_T2OFF = (6 << 8);  ///< Half Bridge 2-slew rate sequencer off-phase 2 time setting
        constexpr uint32_t HB2_T1OFF = (8 << 0);  ///< Half Bridge 2-slew rate sequencer off-phase 1 time setting
    }

    /// ONASEQTMAX Register bits
    namespace onaseqtmax_bits {
        constexpr uint32_t T12ONMAX = (8 << 0);  ///< Slew rate sequencer on-phase 12 max. time setting
    }

    /// ONASEQTMIN Register bits
    namespace onaseqtmin_bits {
        constexpr uint32_t T12ONMIN = (8 << 0);  ///< Slew rate sequencer on-phase 12 min. time setting
    }

    /// ONSEQHB1IC Register bits
    namespace onseqhb1ic_bits {
        constexpr uint32_t HB1_I4ON = (6 << 24);  ///< Half Bridge 1-slew rate sequencer on-phase 4 current setting
        constexpr uint32_t HB1_I3ON = (6 << 16);  ///< Half Bridge 1-slew rate sequencer on-phase 3 current setting
        constexpr uint32_t HB1_I2ON = (6 << 8);  ///< Half Bridge 1-slew rate sequencer on-phase 2 current setting
        constexpr uint32_t HB1_I1ON = (6 << 0);  ///< Half Bridge 1-slew rate sequencer on-phase 1 current setting
    }

    /// ONSEQHB1TC Register bits
    namespace onseqhb1tc_bits {
        constexpr uint32_t HB1_T4ON = (8 << 24);  ///< Half Bridge 1-slew rate sequencer on-phase 4 time setting
        constexpr uint32_t HB1_T3ON = (6 << 16);  ///< Half Bridge 1-slew rate sequencer on-phase 3 time setting
        constexpr uint32_t HB1_T2ON = (6 << 8);  ///< Half Bridge 1-slew rate sequencer on-phase 2 time setting
        constexpr uint32_t HB1_T1ON = (8 << 0);  ///< Half Bridge 1-slew rate sequencer on-phase 1 time setting
    }

    /// ONSEQHB2IC Register bits
    namespace onseqhb2ic_bits {
        constexpr uint32_t HB2_I4ON = (6 << 24);  ///< Half Bridge 2-slew rate sequencer on-phase 4 current setting
        constexpr uint32_t HB2_I3ON = (6 << 16);  ///< Half Bridge 2-slew rate sequencer on-phase 3 current setting
        constexpr uint32_t HB2_I2ON = (6 << 8);  ///< Half Bridge 2-slew rate sequencer on-phase 2 current setting
        constexpr uint32_t HB2_I1ON = (6 << 0);  ///< Half Bridge 2-slew rate sequencer on-phase 1 current setting
    }

    /// ONSEQHB2TC Register bits
    namespace onseqhb2tc_bits {
        constexpr uint32_t HB2_T4ON = (8 << 24);  ///< Half Bridge 2-slew rate sequencer on-phase 4 time setting
        constexpr uint32_t HB2_T3ON = (6 << 16);  ///< Half Bridge 2-slew rate sequencer on-phase 3 time setting
        constexpr uint32_t HB2_T2ON = (6 << 8);  ///< Half Bridge 2-slew rate sequencer on-phase 2 time setting
        constexpr uint32_t HB2_T1ON = (8 << 0);  ///< Half Bridge 2-slew rate sequencer on-phase 1 time setting
    }

    /// PWMSRCSEL Register bits
    namespace pwmsrcsel_bits {
        constexpr uint32_t HS2_SRC_SEL = (2 << 19);  ///< HS2 PWM Source Selection
        constexpr uint32_t HS1_SRC_SEL = (2 << 16);  ///< HS1 PWM Source Selection
        constexpr uint32_t LS2_SRC_SEL = (2 << 3);  ///< LS2 PWM Source Selection
        constexpr uint32_t LS1_SRC_SEL = (2 << 0);  ///< LS1 PWM Source Selection
    }

    /// SEQAFHB1CD Register bits
    namespace seqafhb1cd_bits {
        constexpr uint32_t HB1AF_TDICLMPON = (8 << 8);  ///< Clamping current delay during active freewheeling for switch on
        constexpr uint32_t HB1AF_TDICLMPOFF = (8 << 0);  ///< Clamping current delay during active freewheeling for switch off
    }

    /// SEQAFHB1IC Register bits
    namespace seqafhb1ic_bits {
        constexpr uint32_t HB1AF_ION = (6 << 16);  ///< Half Bridge 1-active freewheeling-slew rate sequencer on-phase current setting
        constexpr uint32_t HB1AF_IOFF = (6 << 0);  ///< Half Bridge 1-active freewheeling-slew rate sequencer off-phase current setting
    }

    /// SEQAFHB2CD Register bits
    namespace seqafhb2cd_bits {
        constexpr uint32_t HB2AF_TDICLMPON = (8 << 8);  ///< Clamping current delay during active freewheeling for switch on
        constexpr uint32_t HB2AF_TDICLMPOFF = (8 << 0);  ///< Clamping current delay during active freewheeling for switch off
    }

    /// SEQAFHB2IC Register bits
    namespace seqafhb2ic_bits {
        constexpr uint32_t HB2AF_ION = (6 << 16);  ///< Half Bridge 2-active freewheeling-slew rate sequencer on-phase current setting
        constexpr uint32_t HB2AF_IOFF = (6 << 0);  ///< Half Bridge 2-active freewheeling-slew rate sequencer off-phase current setting
    }

    /// SEQMAP Register bits
    namespace seqmap_bits {
        constexpr uint32_t HB2_SEQMAP = (1U << 2);  ///< Half Bridge 2 Sequencer Mapping
        constexpr uint32_t HB1_SEQMAP = (1U << 0);  ///< Half Bridge 1 Sequencer Mapping
    }

    /// TRIM_DRVx Register bits
    namespace trim_drvx_bits {
        constexpr uint32_t CPLOW_TFILT_SEL = (2 << 28);  ///< Filter Time for Charge Pump Voltage Low Diagnosis
        constexpr uint32_t HS2DRV_OCSDN_DIS = (1U << 25);  ///< High Side 2 Predriver in overcurrent situation disable
        constexpr uint32_t HS1DRV_OCSDN_DIS = (1U << 24);  ///< High Side 1 Predriver in overcurrent situation disable
        constexpr uint32_t HS2DRV_FDISCHG_DIS = (1U << 21);  ///< High Side 2 Predriver fast discharge disable
        constexpr uint32_t HS1DRV_FDISCHG_DIS = (1U << 20);  ///< High Side 1 Predriver fast discharge disable
        constexpr uint32_t HSDRV_DS_TFILT_SEL = (2 << 18);  ///< Filter Time for Drain-Source Monitoring of High Side Drivers
        constexpr uint32_t LS2DRV_OCSDN_DIS = (1U << 15);  ///< Low Side 2 Predriver in overcurrent situation disable
        constexpr uint32_t LS1DRV_OCSDN_DIS = (1U << 14);  ///< Low Side 1 Predriver in overcurrent situation disable
        constexpr uint32_t LS2DRV_FDISCHG_DIS = (1U << 11);  ///< Low Side 2 Predriver fast discharge disable
        constexpr uint32_t LS1DRV_FDISCHG_DIS = (1U << 10);  ///< Low Side 1 Predriver fast discharge disable
        constexpr uint32_t LSDRV_DS_TFILT_SEL = (2 << 8);  ///< Filter Time for Drain-Source Monitoring of Low Side Drivers
        constexpr uint32_t LS_HS_BT_TFILT_SEL = (2 << 0);  ///< Blanking Time for Drain-Source Monitoring of Low / High Side Drivers
    }

}

// ============================================================================
// CCU6 Peripheral
// ============================================================================

namespace ccu6 {
    /// Base addresses
    constexpr uint32_t CCU6_BASE = 0x4000C000;

    /// CCU6 Register structure
    struct Registers {
        volatile uint32_t CC60R;  ///< Offset: 0x34 - Capture/Compare Register for Channel CC60
        volatile uint32_t CC60SR;  ///< Offset: 0x14 - Capture/Compare Shadow Register for Channel CC60
        volatile uint32_t CC61R;  ///< Offset: 0x38 - Capture/Compare Register for Channel CC61
        volatile uint32_t CC61SR;  ///< Offset: 0x18 - Capture/Compare Shadow Register for Channel CC61
        volatile uint32_t CC62R;  ///< Offset: 0x3C - Capture/Compare Register for Channel CC62
        volatile uint32_t CC62SR;  ///< Offset: 0x1C - Capture/Compare Shadow Register for Channel CC62
        volatile uint32_t CC63R;  ///< Offset: 0x00 - Capture/Compare Register for Channel CC63
        volatile uint32_t CC63SR;  ///< Offset: 0x20 - Capture/Compare Shadow Register for Channel CC63
        volatile uint32_t CMPMODIF;  ///< Offset: 0x10 - Compare State Modification Register
        volatile uint32_t CMPSTAT;  ///< Offset: 0x80 - Compare State Register
        volatile uint32_t IEN;  ///< Offset: 0x44 - Capture/Compare Interrupt Enable Register
        volatile uint32_t INP;  ///< Offset: 0x48 - Capture/Compare Interrupt Node Pointer Register
        volatile uint32_t IS;  ///< Offset: 0x68 - Capture/Compare Interrupt Status Register
        volatile uint32_t ISR;  ///< Offset: 0x0C - Capture/Compare Interrupt Status Reset Register
        volatile uint32_t ISS;  ///< Offset: 0x4C - Capture/Compare Interrupt Status Set Register
        volatile uint32_t MCMCTR;  ///< Offset: 0x54 - Multi-Channel Mode Control Register
        volatile uint32_t MCMOUT;  ///< Offset: 0x64 - Multi-Channel Mode Output Register
        volatile uint32_t MCMOUTS;  ///< Offset: 0x08 - Multi-Channel Mode Output Shadow Register
        volatile uint32_t MODCTR;  ///< Offset: 0x5C - Modulation Control Register
        volatile uint32_t PISEL0;  ///< Offset: 0x6C - Port Input Select Register 0
        volatile uint32_t PISEL2;  ///< Offset: 0x74 - Port Input Select Register 2
        volatile uint32_t PSLR;  ///< Offset: 0x50 - Passive State Level Register
        volatile uint32_t T12;  ///< Offset: 0x78 - Timer T12 Counter Register
        volatile uint32_t T12DTC;  ///< Offset: 0x2C - Dead-Time Control Register for Timer T12 Low
        volatile uint32_t T12MSEL;  ///< Offset: 0x40 - T12 Capture/Compare Mode Select Register
        volatile uint32_t T12PR;  ///< Offset: 0x24 - Timer T12 Period Register
        volatile uint32_t T13;  ///< Offset: 0x7C - Timer T13 Counter Register
        volatile uint32_t T13PR;  ///< Offset: 0x28 - Timer T13 Period Register
        volatile uint32_t TCTR0;  ///< Offset: 0x30 - Timer Control Register 0
        volatile uint32_t TCTR2;  ///< Offset: 0x58 - Timer Control Register 2
        volatile uint32_t TCTR4;  ///< Offset: 0x04 - Timer Control Register 4
        volatile uint32_t TRPCTR;  ///< Offset: 0x60 - Trap Control Register
    };

    /// Peripheral instances
    inline Registers* CCU6 = reinterpret_cast<Registers*>(CCU6_BASE);

    // Bit definitions
    /// CC60R Register bits
    namespace cc60r_bits {
        constexpr uint32_t CCV = (16 << 0);  ///< Channel 0 Capture/Compare Value
    }

    /// CC60SR Register bits
    namespace cc60sr_bits {
        constexpr uint32_t CCS = (16 << 0);  ///< Shadow Register for Channel 0 Capture/Compare Value
    }

    /// CC61R Register bits
    namespace cc61r_bits {
        constexpr uint32_t CCV = (16 << 0);  ///< Channel 1 Capture/Compare Value
    }

    /// CC61SR Register bits
    namespace cc61sr_bits {
        constexpr uint32_t CCS = (16 << 0);  ///< Shadow Register for Channel 1 Capture/Compare Value
    }

    /// CC62R Register bits
    namespace cc62r_bits {
        constexpr uint32_t CCV = (16 << 0);  ///< Channel 2 Capture/Compare Value
    }

    /// CC62SR Register bits
    namespace cc62sr_bits {
        constexpr uint32_t CCS = (16 << 0);  ///< Shadow Register for Channel 2 Capture/Compare Value
    }

    /// CC63R Register bits
    namespace cc63r_bits {
        constexpr uint32_t CCV = (16 << 0);  ///< Channel CC63 Compare Value Low Byte
    }

    /// CC63SR Register bits
    namespace cc63sr_bits {
        constexpr uint32_t CCS = (16 << 0);  ///< Shadow Register for Channel CC63 Compare Value
    }

    /// CMPMODIF Register bits
    namespace cmpmodif_bits {
        constexpr uint32_t MCC63R = (1U << 14);  ///< Capture/Compare Status Modification Bits (Reset)
        constexpr uint32_t MCC62R = (1U << 10);  ///< Capture/Compare Status Modification Bit 2(Reset)
        constexpr uint32_t MCC61R = (1U << 9);  ///< Capture/Compare Status Modification Bit 1(Reset)
        constexpr uint32_t MCC60R = (1U << 8);  ///< Capture/Compare Status Modification Bit 0(Reset)
        constexpr uint32_t MCC63S = (1U << 6);  ///< Capture/Compare Status Modification Bits (Set)
        constexpr uint32_t MCC62S = (1U << 2);  ///< Capture/Compare Status Modification Bit 2 (Set)
        constexpr uint32_t MCC61S = (1U << 1);  ///< Capture/Compare Status Modification Bit 1 (Set)
        constexpr uint32_t MCC60S = (1U << 0);  ///< Capture/Compare Status Modification Bit 0 (Set)
    }

    /// CMPSTAT Register bits
    namespace cmpstat_bits {
        constexpr uint32_t T13IM = (1U << 15);  ///< T13 Inverted Modulation
        constexpr uint32_t COUT63PS = (1U << 14);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t COUT62PS = (1U << 13);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t CC62PS = (1U << 12);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t COUT61PS = (1U << 11);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t CC61PS = (1U << 10);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t COUT60PS = (1U << 9);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t CC60PS = (1U << 8);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t CC63ST = (1U << 6);  ///< Capture/Compare State Bits
        constexpr uint32_t CCPOS2 = (1U << 5);  ///< Sampled Hall Pattern Bit 2
        constexpr uint32_t CCPOS1 = (1U << 4);  ///< Sampled Hall Pattern Bit 1
        constexpr uint32_t CCPOS0 = (1U << 3);  ///< Sampled Hall Pattern Bit 0
        constexpr uint32_t CC62ST = (1U << 2);  ///< Capture/Compare State Bits
        constexpr uint32_t CC61ST = (1U << 1);  ///< Capture/Compare State Bits
        constexpr uint32_t CC60ST = (1U << 0);  ///< Capture/Compare State Bits
    }

    /// IEN Register bits
    namespace ien_bits {
        constexpr uint32_t ENSTR = (1U << 15);  ///< Enable Multi-Channel Mode Shadow Transfer Interrupt
        constexpr uint32_t ENIDLE = (1U << 14);  ///< Enable Idle
        constexpr uint32_t ENWHE = (1U << 13);  ///< Enable Interrupt for Wrong Hall Event
        constexpr uint32_t ENCHE = (1U << 12);  ///< Enable Interrupt for Correct Hall Event
        constexpr uint32_t ENTRPF = (1U << 10);  ///< Enable Interrupt for Trap Flag
        constexpr uint32_t ENT13PM = (1U << 9);  ///< Enable Interrupt for T13 Period-Match
        constexpr uint32_t ENT13CM = (1U << 8);  ///< Enable Interrupt for T13 Compare-Match
        constexpr uint32_t ENT12PM = (1U << 7);  ///< Enable Interrupt for T12 Period-Match
        constexpr uint32_t ENT12OM = (1U << 6);  ///< Enable Interrupt for T12 One-Match
        constexpr uint32_t ENCC62F = (1U << 5);  ///< Capture, Compare-Match Falling Edge Interrupt Enable for Channel 2
        constexpr uint32_t ENCC62R = (1U << 4);  ///< Capture, Compare-Match Rising Edge Interrupt Enable for Channel 2
        constexpr uint32_t ENCC61F = (1U << 3);  ///< Capture, Compare-Match Falling Edge Interrupt Enable for Channel 1
        constexpr uint32_t ENCC61R = (1U << 2);  ///< Capture, Compare-Match Rising Edge Interrupt Enable for Channel 1
        constexpr uint32_t ENCC60F = (1U << 1);  ///< Capture, Compare-Match Falling Edge Interrupt Enable for Channel 0
        constexpr uint32_t ENCC60R = (1U << 0);  ///< Capture, Compare-Match Rising Edge Interrupt Enable for Channel 0
    }

    /// INP Register bits
    namespace inp_bits {
        constexpr uint32_t INPT13 = (2 << 12);  ///< Interrupt Node Pointer for Timer T13 Interrupts
        constexpr uint32_t INPT12 = (2 << 10);  ///< Interrupt Node Pointer for Timer T12 Interrupts
        constexpr uint32_t INPERR = (2 << 8);  ///< Interrupt Node Pointer for Error Interrupts
        constexpr uint32_t INPCHE = (2 << 6);  ///< Interrupt Node Pointer for the CHE Interrupt
        constexpr uint32_t INPCC62 = (2 << 4);  ///< Interrupt Node Pointer for Channel 2 Interrupts
        constexpr uint32_t INPCC61 = (2 << 2);  ///< Interrupt Node Pointer for Channel 1 Interrupts
        constexpr uint32_t INPCC60 = (2 << 0);  ///< Interrupt Node Pointer for Channel 0 Interrupts
    }

    /// IS Register bits
    namespace is_bits {
        constexpr uint32_t STR = (1U << 15);  ///< Multi-Channel Mode Shadow Transfer Request
        constexpr uint32_t IDLE = (1U << 14);  ///< IDLE State
        constexpr uint32_t WHE = (1U << 13);  ///< Wrong Hall Event
        constexpr uint32_t CHE = (1U << 12);  ///< Correct Hall Event
        constexpr uint32_t TRPS = (1U << 11);  ///< Trap State
        constexpr uint32_t TRPF = (1U << 10);  ///< Trap Flag
        constexpr uint32_t T13PM = (1U << 9);  ///< Timer T13 Period-Match Flag
        constexpr uint32_t T13CM = (1U << 8);  ///< Timer T13 Compare-Match Flag
        constexpr uint32_t T12PM = (1U << 7);  ///< Timer T12 Period-Match Flag
        constexpr uint32_t T12OM = (1U << 6);  ///< Timer T12 One-Match Flag
        constexpr uint32_t ICC62F = (1U << 5);  ///< Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t ICC62R = (1U << 4);  ///< Capture, Compare-Match Rising Edge Flag
        constexpr uint32_t ICC61F = (1U << 3);  ///< Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t ICC61R = (1U << 2);  ///< Capture, Compare-Match Rising Edge Flag
        constexpr uint32_t ICC60F = (1U << 1);  ///< Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t ICC60R = (1U << 0);  ///< Capture, Compare-Match Rising Edge Flag
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t RSTR = (1U << 15);  ///< Reset STR Flag
        constexpr uint32_t RIDLE = (1U << 14);  ///< Reset IDLE Flag
        constexpr uint32_t RWHE = (1U << 13);  ///< Reset Wrong Hall Event Flag
        constexpr uint32_t RCHE = (1U << 12);  ///< Reset Correct Hall Event Flag
        constexpr uint32_t RTRPF = (1U << 10);  ///< Reset Trap Flag
        constexpr uint32_t RT13PM = (1U << 9);  ///< Reset Timer T13 Period-Match Flag
        constexpr uint32_t RT13CM = (1U << 8);  ///< Reset Timer T13 Compare-Match Flag
        constexpr uint32_t RT12PM = (1U << 7);  ///< Reset Timer T12 Period-Match Flag
        constexpr uint32_t RT12OM = (1U << 6);  ///< Reset Timer T12 One-Match Flag
        constexpr uint32_t RCC62F = (1U << 5);  ///< Reset Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t RCC62R = (1U << 4);  ///< Reset Capture, Compare-Match Rising Edge Flag
        constexpr uint32_t RCC61F = (1U << 3);  ///< Reset Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t RCC61R = (1U << 2);  ///< Reset Capture, Compare-Match Rising Edge Flag
        constexpr uint32_t RCC60F = (1U << 1);  ///< Reset Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t RCC60R = (1U << 0);  ///< Reset Capture, Compare-Match Rising Edge Flag
    }

    /// ISS Register bits
    namespace iss_bits {
        constexpr uint32_t SSTR = (1U << 15);  ///< Set STR Flag
        constexpr uint32_t SIDLE = (1U << 14);  ///< Set IDLE Flag
        constexpr uint32_t SWHE = (1U << 13);  ///< Set Wrong Hall Event Flag
        constexpr uint32_t SCHE = (1U << 12);  ///< Set Correct Hall Event Flag
        constexpr uint32_t SWHC = (1U << 11);  ///< Software Hall Compare
        constexpr uint32_t STRPF = (1U << 10);  ///< Set Trap Flag
        constexpr uint32_t ST13PM = (1U << 9);  ///< Set Timer T13 Period-Match Flag
        constexpr uint32_t ST13CM = (1U << 8);  ///< Set Timer T13 Compare-Match Flag
        constexpr uint32_t ST12PM = (1U << 7);  ///< Set Timer T12 Period-Match Flag
        constexpr uint32_t ST12OM = (1U << 6);  ///< Set Timer T12 One-Match Flag
        constexpr uint32_t SCC62F = (1U << 5);  ///< Set Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t SCC62R = (1U << 4);  ///< Set Capture, Compare-Match Rising Edge Flag
        constexpr uint32_t SCC61F = (1U << 3);  ///< Set Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t SCC61R = (1U << 2);  ///< Set Capture, Compare-Match Rising Edge Flag
        constexpr uint32_t SCC60F = (1U << 1);  ///< Set Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t SCC60R = (1U << 0);  ///< Set Capture, Compare-Match Rising Edge Flag
    }

    /// MCMCTR Register bits
    namespace mcmctr_bits {
        constexpr uint32_t STE13U = (1U << 10);  ///< Shadow Transfer Enable for T13 Upcounting
        constexpr uint32_t STE12D = (1U << 9);  ///< Shadow Transfer Enable for T12 Downcounting
        constexpr uint32_t STE12U = (1U << 8);  ///< Shadow Transfer Enable for T12 Upcounting
        constexpr uint32_t SWSYN = (2 << 4);  ///< Switching Synchronization
        constexpr uint32_t SWSEL = (3 << 0);  ///< Switching Selection
    }

    /// MCMOUT Register bits
    namespace mcmout_bits {
        constexpr uint32_t CURH = (3 << 11);  ///< Current Hall Pattern
        constexpr uint32_t EXPH = (3 << 8);  ///< Expected Hall Pattern
        constexpr uint32_t R = (1U << 6);  ///< Reminder Flag
        constexpr uint32_t MCMP = (6 << 0);  ///< Multi-Channel PWM Pattern
    }

    /// MCMOUTS Register bits
    namespace mcmouts_bits {
        constexpr uint32_t STRHP = (1U << 15);  ///< Shadow Transfer Request for the Hall Pattern
        constexpr uint32_t CURHS = (3 << 11);  ///< Current Hall Pattern Shadow
        constexpr uint32_t EXPHS = (3 << 8);  ///< Expected Hall Pattern Shadow
        constexpr uint32_t STRMCM = (1U << 7);  ///< Shadow Transfer Request for MCMPS
        constexpr uint32_t MCMPS = (6 << 0);  ///< Multi-Channel PWM Pattern Shadow
    }

    /// MODCTR Register bits
    namespace modctr_bits {
        constexpr uint32_t ECT13O = (1U << 15);  ///< Enable Compare Timer T13 Output
        constexpr uint32_t T13MODEN = (6 << 8);  ///< T13 Modulation Enable
        constexpr uint32_t MCMEN = (1U << 7);  ///< Multi-Channel Mode Enable
        constexpr uint32_t T12MODEN = (6 << 0);  ///< T12 Modulation Enable
    }

    /// PISEL0 Register bits
    namespace pisel0_bits {
        constexpr uint32_t IST12HR = (2 << 14);  ///< Input Select for T12HR
        constexpr uint32_t ISPOS2 = (2 << 12);  ///< Input Select for CCPOS2
        constexpr uint32_t ISPOS1 = (2 << 10);  ///< Input Select for CCPOS1
        constexpr uint32_t ISPOS0 = (2 << 8);  ///< Input Select for CCPOS0
        constexpr uint32_t ISTRP = (2 << 6);  ///< Input Select for CTRAP
        constexpr uint32_t ISCC62 = (2 << 4);  ///< Input Select for CC62
        constexpr uint32_t ISCC61 = (2 << 2);  ///< Input Select for CC61
        constexpr uint32_t ISCC60 = (2 << 0);  ///< Input Select for CC60
    }

    /// PISEL2 Register bits
    namespace pisel2_bits {
        constexpr uint32_t T13EXT = (1U << 7);  ///< Extension for T13HR Inputs
        constexpr uint32_t T12EXT = (1U << 6);  ///< Extension for T12HR Inputs
        constexpr uint32_t ISCNT13 = (2 << 4);  ///< Input Select for T13 Counting Input
        constexpr uint32_t ISCNT12 = (2 << 2);  ///< Input Select for T12 Counting Input
        constexpr uint32_t IST13HR = (2 << 0);  ///< Input Select for T13HR
    }

    /// PSLR Register bits
    namespace pslr_bits {
        constexpr uint32_t PSL63 = (1U << 7);  ///< Passive State Level of Output COUT63
        constexpr uint32_t PSL = (6 << 0);  ///< Compare Outputs Passive State Level
    }

    /// T12 Register bits
    namespace t12_bits {
        constexpr uint32_t T12CV = (16 << 0);  ///< Timer T12 Counter Value
    }

    /// T12DTC Register bits
    namespace t12dtc_bits {
        constexpr uint32_t DTR2 = (1U << 14);  ///< Dead-Time Run Indication Bit 2
        constexpr uint32_t DTR1 = (1U << 13);  ///< Dead-Time Run Indication Bit 1
        constexpr uint32_t DTR0 = (1U << 12);  ///< Dead-Time Run Indication Bit 0
        constexpr uint32_t DTE2 = (1U << 10);  ///< Dead-Time Enable Bit 2
        constexpr uint32_t DTE1 = (1U << 9);  ///< Dead-Time Enable Bit 1
        constexpr uint32_t DTE0 = (1U << 8);  ///< Dead-Time Enable Bit 0
        constexpr uint32_t DTM = (8 << 0);  ///< Dead-Time
    }

    /// T12MSEL Register bits
    namespace t12msel_bits {
        constexpr uint32_t DBYP = (1U << 15);  ///< Delay Bypass
        constexpr uint32_t HSYNC = (3 << 12);  ///< Hall Synchronization
        constexpr uint32_t MSEL62 = (4 << 8);  ///< Capture/Compare Mode Selection
        constexpr uint32_t MSEL61 = (4 << 4);  ///< Capture/Compare Mode Selection
        constexpr uint32_t MSEL60 = (4 << 0);  ///< Capture/Compare Mode Selection
    }

    /// T12PR Register bits
    namespace t12pr_bits {
        constexpr uint32_t T12PV = (16 << 0);  ///< T12 Period Value
    }

    /// T13 Register bits
    namespace t13_bits {
        constexpr uint32_t T13CV = (16 << 0);  ///< Timer T13 Counter Value
    }

    /// T13PR Register bits
    namespace t13pr_bits {
        constexpr uint32_t T13PV = (16 << 0);  ///< T13 Period Value
    }

    /// TCTR0 Register bits
    namespace tctr0_bits {
        constexpr uint32_t STE13 = (1U << 13);  ///< Timer T13 Shadow Transfer Enable
        constexpr uint32_t T13R = (1U << 12);  ///< Timer T13 Run Bit
        constexpr uint32_t T13PRE = (1U << 11);  ///< Timer T13 Prescaler Bit
        constexpr uint32_t T13CLK = (3 << 8);  ///< Timer T13 Input Clock Select
        constexpr uint32_t CTM = (1U << 7);  ///< T12 Operating Mode
        constexpr uint32_t CDIR = (1U << 6);  ///< Count Direction of Timer T12
        constexpr uint32_t STE12 = (1U << 5);  ///< Timer T12 Shadow Transfer Enable
        constexpr uint32_t T12R = (1U << 4);  ///< Timer T12 Run Bit
        constexpr uint32_t T12PRE = (1U << 3);  ///< Timer T12 Prescaler Bit
        constexpr uint32_t T12CLK = (3 << 0);  ///< Timer T12 Input Clock Select
    }

    /// TCTR2 Register bits
    namespace tctr2_bits {
        constexpr uint32_t T13RSEL = (2 << 10);  ///< Timer T13 External Run Selection
        constexpr uint32_t T12RSEL = (2 << 8);  ///< Timer T12 External Run Selection
        constexpr uint32_t T13TED = (2 << 5);  ///< Timer T13 Trigger Event Direction
        constexpr uint32_t T13TEC = (3 << 2);  ///< T13 Trigger Event Control
        constexpr uint32_t T13SSC = (1U << 1);  ///< Timer T13 Single Shot Control
        constexpr uint32_t T12SSC = (1U << 0);  ///< Timer T12 Single Shot Control
    }

    /// TCTR4 Register bits
    namespace tctr4_bits {
        constexpr uint32_t T13STD = (1U << 15);  ///< Timer T13 Shadow Transfer Disable
        constexpr uint32_t T13STR = (1U << 14);  ///< Timer T13 Shadow Transfer Request
        constexpr uint32_t T13CNT = (1U << 13);  ///< Timer T13 Count Event
        constexpr uint32_t T13RES = (1U << 10);  ///< Timer T13 Reset
        constexpr uint32_t T13RS = (1U << 9);  ///< Timer T13 Run Set
        constexpr uint32_t T13RR = (1U << 8);  ///< Timer T13 Run Reset
        constexpr uint32_t T12STD = (1U << 7);  ///< Timer T12 Shadow Transfer Disable
        constexpr uint32_t T12STR = (1U << 6);  ///< Timer T12 Shadow Transfer Request
        constexpr uint32_t T12CNT = (1U << 5);  ///< Timer T12 Count Event
        constexpr uint32_t DTRES = (1U << 3);  ///< Dead-Time Counter Reset
        constexpr uint32_t T12RES = (1U << 2);  ///< Timer T12 Reset
        constexpr uint32_t T12RS = (1U << 1);  ///< Timer T12 Run Set
        constexpr uint32_t T12RR = (1U << 0);  ///< Timer T12 Run Reset
    }

    /// TRPCTR Register bits
    namespace trpctr_bits {
        constexpr uint32_t TRPPEN = (1U << 15);  ///< Trap Pin Enable
        constexpr uint32_t TRPEN13 = (1U << 14);  ///< Trap Enable Control for Timer T13
        constexpr uint32_t TRPEN = (6 << 8);  ///< Trap Enable Control
        constexpr uint32_t TRPM2 = (1U << 2);  ///< Trap Mode Control Bit 2
        constexpr uint32_t TRPM10 = (2 << 0);  ///< Trap Mode Control Bits 1, 0
    }

}

// ============================================================================
// CPU Peripheral
// ============================================================================

namespace cpu {
    /// Base addresses
    constexpr uint32_t CPU_BASE = 0xE000E000;

    /// CPU Register structure
    struct Registers {
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt/Reset Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration Control Register
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPU ID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control and State Register
        volatile uint32_t NVIC_ICER;  ///< Offset: 0x180 - Interrupt Clear-Enable
        volatile uint32_t NVIC_ICPR;  ///< Offset: 0x280 - Interrupt Clear-Pending
        volatile uint32_t NVIC_IPR0;  ///< Offset: 0x400 - Interrupt Priority
        volatile uint32_t NVIC_IPR1;  ///< Offset: 0x404 - Interrupt Priority
        volatile uint32_t NVIC_IPR2;  ///< Offset: 0x408 - Interrupt Priority
        volatile uint32_t NVIC_IPR3;  ///< Offset: 0x40C - Interrupt Priority
        volatile uint32_t NVIC_IPR4;  ///< Offset: 0x410 - Interrupt Priority
        volatile uint32_t NVIC_IPR5;  ///< Offset: 0x414 - Interrupt Priority
        volatile uint32_t NVIC_ISER;  ///< Offset: 0x100 - Interrupt Set-Enable
        volatile uint32_t NVIC_ISPR;  ///< Offset: 0x200 - Interrupt Set-Pending
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SYSTICK_CALIB;  ///< Offset: 0x1C - SysTick Calibration Value Register
        volatile uint32_t SYSTICK_CSR;  ///< Offset: 0x10 - SysTick Control and Status Register
        volatile uint32_t SYSTICK_CVR;  ///< Offset: 0x18 - SysTick Current Value Register
        volatile uint32_t SYSTICK_RVR;  ///< Offset: 0x14 - SysTick Reload Value Register
    };

    /// Peripheral instances
    inline Registers* CPU = reinterpret_cast<Registers*>(CPU_BASE);

    // Bit definitions
    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Vector Key
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< Data Endianness
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< System Reset Request
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< VECTCLRACTIVE
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t STKALIGN = (1U << 9);  ///< STKALIGN
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< UNALIGN_TRP
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t IMPLEMENTER = (8 << 24);  ///< Implementer Code
        constexpr uint32_t VARIANT = (4 << 20);  ///< Variant Number
        constexpr uint32_t CONSTANT = (4 << 16);  ///< Constant
        constexpr uint32_t PARTNO = (12 << 4);  ///< Part Number
        constexpr uint32_t REVISION = (4 << 0);  ///< Revision Number
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI Set Pending
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PENDSV Set Pending
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PENDSV Clear Pending
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick Exception Set Pending
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick Exception Clear Pending
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt Pending Flag
        constexpr uint32_t VECTPENDING = (6 << 12);  ///< VECTPENDING
        constexpr uint32_t VECTACTIVE = (6 << 0);  ///< VECTACTIVE
    }

    /// NVIC_ICER Register bits
    namespace nvic_icer_bits {
        constexpr uint32_t Int_PORT2 = (1U << 23);  ///< Interrupt Clear for PORT2
        constexpr uint32_t Int_MON = (1U << 22);  ///< Interrupt Clear for MON
        constexpr uint32_t Int_DU = (1U << 21);  ///< Interrupt Clear for Differential Unit
        constexpr uint32_t Int_OPA = (1U << 20);  ///< Interrupt Clear for Current Sense Amplifier
        constexpr uint32_t Int_HS = (1U << 19);  ///< Interrupt Clear for High-Side Switch
        constexpr uint32_t Int_BDRV = (1U << 18);  ///< Interrupt Clear for Bridge Driver
        constexpr uint32_t Int_CP = (1U << 17);  ///< Interrupt Clear for Charge Pump
        constexpr uint32_t Int_MATHDIV = (1U << 15);  ///< Interrupt Clear for Math Divider
        constexpr uint32_t Int_WAKEUP = (1U << 14);  ///< Interrupt Clear for WAKEUP
        constexpr uint32_t Int_EXINT1 = (1U << 13);  ///< Interrupt Clear for External Int 1
        constexpr uint32_t Int_EXINT0 = (1U << 12);  ///< Interrupt Clear for External Int 0
        constexpr uint32_t Int_UART2 = (1U << 11);  ///< Interrupt Clear for UART2
        constexpr uint32_t Int_UART1 = (1U << 10);  ///< Interrupt Clear for UART1
        constexpr uint32_t Int_SSC2 = (1U << 9);  ///< Interrupt Clear for SSC2
        constexpr uint32_t Int_SSC1 = (1U << 8);  ///< Interrupt Clear for SSC1
        constexpr uint32_t Int_CCU6SR3 = (1U << 7);  ///< Interrupt Clear for CCU6 SR3
        constexpr uint32_t Int_CCU6SR2 = (1U << 6);  ///< Interrupt Clear for CCU6 SR2
        constexpr uint32_t Int_CCU6SR1 = (1U << 5);  ///< Interrupt Clear for CCU6 SR1
        constexpr uint32_t Int_CCU6SR0 = (1U << 4);  ///< Interrupt Clear for CCU6 SR0
        constexpr uint32_t Int_ADC1 = (1U << 3);  ///< Interrupt Clear for ADC1
        constexpr uint32_t Int_ADC2 = (1U << 2);  ///< Interrupt Clear for MU, ADC2
        constexpr uint32_t Int_GPT2 = (1U << 1);  ///< Interrupt Clear for GPT2
        constexpr uint32_t Int_GPT1 = (1U << 0);  ///< Interrupt Clear for GPT1
    }

    /// NVIC_ICPR Register bits
    namespace nvic_icpr_bits {
        constexpr uint32_t Int_PORT2 = (1U << 23);  ///< Interrupt Clear Pending for PORT2
        constexpr uint32_t Int_MON = (1U << 22);  ///< Interrupt Clear Pending for MON
        constexpr uint32_t Int_DU = (1U << 21);  ///< Interrupt Clear Pending for Differential Unit
        constexpr uint32_t Int_OPA = (1U << 20);  ///< Interrupt Clear Pending for Current Sense Amplifier
        constexpr uint32_t Int_HS = (1U << 19);  ///< Interrupt Clear Pending for High-Side Switch
        constexpr uint32_t Int_BDRV = (1U << 18);  ///< Interrupt Clear Pending for Bridge Driver
        constexpr uint32_t Int_CP = (1U << 17);  ///< Interrupt Clear Pending for Charge Pump
        constexpr uint32_t Int_MATHDIV = (1U << 15);  ///< Interrupt Clear Pending for Math Divider
        constexpr uint32_t Int_WAKEUP = (1U << 14);  ///< Interrupt Clear Pending for WAKEUP
        constexpr uint32_t Int_EXINT1 = (1U << 13);  ///< Interrupt Clear Pending for External Int 1
        constexpr uint32_t Int_EXINT0 = (1U << 12);  ///< Interrupt Clear Pending for External Int 0
        constexpr uint32_t Int_UART2 = (1U << 11);  ///< Interrupt Clear Pending for UART2
        constexpr uint32_t Int_UART1 = (1U << 10);  ///< Interrupt Clear Pending for UART1
        constexpr uint32_t Int_SSC2 = (1U << 9);  ///< Interrupt Clear Pending for SSC2
        constexpr uint32_t Int_SSC1 = (1U << 8);  ///< Interrupt Clear Pending for SSC1
        constexpr uint32_t Int_CCU6SR3 = (1U << 7);  ///< Interrupt Clear Pending for CCU6 SR3
        constexpr uint32_t Int_CCU6SR2 = (1U << 6);  ///< Interrupt Clear Pending for CCU6 SR2
        constexpr uint32_t Int_CCU6SR1 = (1U << 5);  ///< Interrupt Clear Pending for CCU6 SR1
        constexpr uint32_t Int_CCU6SR0 = (1U << 4);  ///< Interrupt Clear Pending for CCU6 SR0
        constexpr uint32_t Int_ADC1 = (1U << 3);  ///< Interrupt Clear Pending for ADC1
        constexpr uint32_t Int_ADC2 = (1U << 2);  ///< Interrupt Clear Pending for MU, ADC2
        constexpr uint32_t Int_GPT2 = (1U << 1);  ///< Interrupt Clear Pending for GPT2
        constexpr uint32_t Int_GPT1 = (1U << 0);  ///< Interrupt Clear Pending for GPT1
    }

    /// NVIC_IPR0 Register bits
    namespace nvic_ipr0_bits {
        constexpr uint32_t PRI_ADC1 = (2 << 30);  ///< Priority for ADC1
        constexpr uint32_t PRI_ADC2 = (2 << 22);  ///< Priority for MU, ADC2
        constexpr uint32_t PRI_GPT2 = (2 << 14);  ///< Priority for GPT2
        constexpr uint32_t PRI_GPT1 = (2 << 6);  ///< Priority for GPT1
    }

    /// NVIC_IPR1 Register bits
    namespace nvic_ipr1_bits {
        constexpr uint32_t PRI_CCU6SR3 = (2 << 30);  ///< Priority for CCU6 SR3
        constexpr uint32_t PRI_CCU6SR2 = (2 << 22);  ///< Priority for CCU6 SR2
        constexpr uint32_t PRI_CCU6SR1 = (2 << 14);  ///< Priority for CCU6 SR1
        constexpr uint32_t PRI_CCU6SR0 = (2 << 6);  ///< Priority for CCU6 SR0
    }

    /// NVIC_IPR2 Register bits
    namespace nvic_ipr2_bits {
        constexpr uint32_t PRI_UART2 = (2 << 30);  ///< Priority for UART2
        constexpr uint32_t PRI_UART1 = (2 << 22);  ///< Priority for UART1
        constexpr uint32_t PRI_SSC2 = (2 << 14);  ///< Priority for SSC2
        constexpr uint32_t PRI_SSC1 = (2 << 6);  ///< Priority for SSC1
    }

    /// NVIC_IPR3 Register bits
    namespace nvic_ipr3_bits {
        constexpr uint32_t PRI_MATHDIV = (2 << 30);  ///< Priority for Math Divider
        constexpr uint32_t PRI_WAKEUP = (2 << 22);  ///< Priority for WAKEUP
        constexpr uint32_t PRI_EXINT1 = (2 << 14);  ///< Priority for External Int 1
        constexpr uint32_t PRI_EXINT0 = (2 << 6);  ///< Priority for External Int 0
    }

    /// NVIC_IPR4 Register bits
    namespace nvic_ipr4_bits {
        constexpr uint32_t PRI_HS = (2 << 30);  ///< Priority for High-Side Switch
        constexpr uint32_t PRI_BDRV = (2 << 22);  ///< Priority for Bridge Driver
        constexpr uint32_t PRI_CP = (2 << 14);  ///< Priority for Charge Pump
    }

    /// NVIC_IPR5 Register bits
    namespace nvic_ipr5_bits {
        constexpr uint32_t PRI_PORT2 = (2 << 30);  ///< Priority for PORT2
        constexpr uint32_t PRI_MON = (2 << 22);  ///< Priority for MON
        constexpr uint32_t PRI_DU = (2 << 14);  ///< Priority for Differential Unit
        constexpr uint32_t PRI_OPA = (2 << 6);  ///< Priority for Current Sense Amplifier
    }

    /// NVIC_ISER Register bits
    namespace nvic_iser_bits {
        constexpr uint32_t Int_PORT2 = (1U << 23);  ///< Interrupt Set for PORT2
        constexpr uint32_t Int_MON = (1U << 22);  ///< Interrupt Set for MON
        constexpr uint32_t Int_DU = (1U << 21);  ///< Interrupt Set for Differential Unit
        constexpr uint32_t Int_OPA = (1U << 20);  ///< Interrupt Set for Current Sense Amplifier
        constexpr uint32_t Int_HS = (1U << 19);  ///< Interrupt Set for High-Side Switch
        constexpr uint32_t Int_BDRV = (1U << 18);  ///< Interrupt Set for Bridge Driver
        constexpr uint32_t Int_CP = (1U << 17);  ///< Interrupt Set for Charge Pump
        constexpr uint32_t Int_MATHDIV = (1U << 15);  ///< Interrupt Set for Math Divider
        constexpr uint32_t Int_WAKEUP = (1U << 14);  ///< Interrupt Set for WAKEUP
        constexpr uint32_t Int_EXINT1 = (1U << 13);  ///< Interrupt Set for External Int 1
        constexpr uint32_t Int_EXINT0 = (1U << 12);  ///< Interrupt Set for External Int 0
        constexpr uint32_t Int_UART2 = (1U << 11);  ///< Interrupt Set for UART2
        constexpr uint32_t Int_UART1 = (1U << 10);  ///< Interrupt Set for UART1
        constexpr uint32_t Int_SSC2 = (1U << 9);  ///< Interrupt Set for SSC2
        constexpr uint32_t Int_SSC1 = (1U << 8);  ///< Interrupt Set for SSC1
        constexpr uint32_t Int_CCU6SR3 = (1U << 7);  ///< Interrupt Set for CCU6 SR3
        constexpr uint32_t Int_CCU6SR2 = (1U << 6);  ///< Interrupt Set for CCU6 SR2
        constexpr uint32_t Int_CCU6SR1 = (1U << 5);  ///< Interrupt Set for CCU6 SR1
        constexpr uint32_t Int_CCU6SR0 = (1U << 4);  ///< Interrupt Set for CCU6 SR0
        constexpr uint32_t Int_ADC1 = (1U << 3);  ///< Interrupt Set for ADC1
        constexpr uint32_t Int_ADC2 = (1U << 2);  ///< Interrupt Set for MU, ADC2
        constexpr uint32_t Int_GPT2 = (1U << 1);  ///< Interrupt Set for GPT2
        constexpr uint32_t Int_GPT1 = (1U << 0);  ///< Interrupt Set for GPT1
    }

    /// NVIC_ISPR Register bits
    namespace nvic_ispr_bits {
        constexpr uint32_t Int_PORT2 = (1U << 23);  ///< Interrupt Set Pending for PORT2
        constexpr uint32_t Int_MON = (1U << 22);  ///< Interrupt Set Pending for MON
        constexpr uint32_t Int_DU = (1U << 21);  ///< Interrupt Set Pending for Differential Unit
        constexpr uint32_t Int_OPA = (1U << 20);  ///< Interrupt Set Pending for Current Sense Amplifier
        constexpr uint32_t Int_HS = (1U << 19);  ///< Interrupt Set Pending for High-Side Switch
        constexpr uint32_t Int_BDRV = (1U << 18);  ///< Interrupt Set Pending for Bridge Driver
        constexpr uint32_t Int_CP = (1U << 17);  ///< Interrupt Set Pending for Charge Pump
        constexpr uint32_t Int_MATHDIV = (1U << 15);  ///< Interrupt Set Pending for Math Divider
        constexpr uint32_t Int_WAKEUP = (1U << 14);  ///< Interrupt Set Pending for WAKEUP
        constexpr uint32_t Int_EXINT1 = (1U << 13);  ///< Interrupt Set Pending for External Int 1
        constexpr uint32_t Int_EXINT0 = (1U << 12);  ///< Interrupt Set Pending for External Int 0
        constexpr uint32_t Int_UART2 = (1U << 11);  ///< Interrupt Set Pending for UART2
        constexpr uint32_t Int_UART1 = (1U << 10);  ///< Interrupt Set Pending for UART1
        constexpr uint32_t Int_SSC2 = (1U << 9);  ///< Interrupt Set Pending for SSC2
        constexpr uint32_t Int_SSC1 = (1U << 8);  ///< Interrupt Set Pending for SSC1
        constexpr uint32_t Int_CCU6SR3 = (1U << 7);  ///< Interrupt Set Pending for CCU6 SR3
        constexpr uint32_t Int_CCU6SR2 = (1U << 6);  ///< Interrupt Set Pending for CCU6 SR2
        constexpr uint32_t Int_CCU6SR1 = (1U << 5);  ///< Interrupt Set Pending for CCU6 SR1
        constexpr uint32_t Int_CCU6SR0 = (1U << 4);  ///< Interrupt Set Pending for CCU6 SR0
        constexpr uint32_t Int_ADC1 = (1U << 3);  ///< Interrupt Set Pending for ADC1
        constexpr uint32_t Int_ADC2 = (1U << 2);  ///< Interrupt Set Pending for MU, ADC2
        constexpr uint32_t Int_GPT2 = (1U << 1);  ///< Interrupt Set Pending for GPT2
        constexpr uint32_t Int_GPT1 = (1U << 0);  ///< Interrupt Set Pending for GPT1
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< SEVONPEND
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< Sleep Deep
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< Sleep on Exit
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVCALLPENDED
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (2 << 30);  ///< Priority of System Handler 11, SVCall
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_15 = (2 << 30);  ///< Priority of System Handler 15, SysTick
        constexpr uint32_t PRI_14 = (2 << 22);  ///< Priority of System Handler 14, PendSV
    }

    /// SYSTICK_CALIB Register bits
    namespace systick_calib_bits {
        constexpr uint32_t NOREF = (1U << 31);  ///< No Reference Clock
        constexpr uint32_t SKEW = (1U << 30);  ///< Skew
        constexpr uint32_t TENMS = (24 << 0);  ///< Tenms
    }

    /// SYSTICK_CSR Register bits
    namespace systick_csr_bits {
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< Count Flag
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< CLK Source
        constexpr uint32_t TICKINT = (1U << 1);  ///< TICKINT
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable
    }

    /// SYSTICK_CVR Register bits
    namespace systick_cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current
    }

    /// SYSTICK_RVR Register bits
    namespace systick_rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Reload
    }

}

// ============================================================================
// GPT12E Peripheral
// ============================================================================

namespace gpt12e {
    /// Base addresses
    constexpr uint32_t GPT12E_BASE = 0x40010000;

    /// GPT12E Register structure
    struct Registers {
        volatile uint32_t CAPREL;  ///< Offset: 0x1C - Capture/Reload Register
        volatile uint32_t ID;  ///< Offset: 0x00 - Module Identification Register
        volatile uint32_t PISEL;  ///< Offset: 0x04 - Port Input Select Register
        volatile uint32_t T2;  ///< Offset: 0x20 - Timer T2 Count Register
        volatile uint32_t T2CON;  ///< Offset: 0x08 - Timer T2 Control Register
        volatile uint32_t T3;  ///< Offset: 0x24 - Timer T3 Count Register
        volatile uint32_t T3CON;  ///< Offset: 0x0C - Timer T3 Control Register
        volatile uint32_t T4;  ///< Offset: 0x28 - Timer T4 Count Register
        volatile uint32_t T4CON;  ///< Offset: 0x10 - Timer T4 Control Register
        volatile uint32_t T5;  ///< Offset: 0x2C - Timer 5 Count Register
        volatile uint32_t T5CON;  ///< Offset: 0x14 - Timer T5 Control Register
        volatile uint32_t T6;  ///< Offset: 0x30 - Timer 6 Count Register
        volatile uint32_t T6CON;  ///< Offset: 0x18 - Timer T6 Control Register
    };

    /// Peripheral instances
    inline Registers* GPT12E = reinterpret_cast<Registers*>(GPT12E_BASE);

    // Bit definitions
    /// CAPREL Register bits
    namespace caprel_bits {
        constexpr uint32_t CAPREL = (16 << 0);  ///< Current reload value or Captured value
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Identification Number
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
    }

    /// PISEL Register bits
    namespace pisel_bits {
        constexpr uint32_t ISCAPIN = (2 << 14);  ///< Input Select for CAPIN
        constexpr uint32_t IST6EUD = (1U << 13);  ///< Input Select for T6EUD
        constexpr uint32_t IST6IN = (1U << 12);  ///< Input Select for T6IN
        constexpr uint32_t IST5EUD = (1U << 11);  ///< Input Select for T5EUD
        constexpr uint32_t IST5IN = (1U << 10);  ///< Input Select for T5IN
        constexpr uint32_t IST4EUD = (2 << 8);  ///< Input Select for TEUD
        constexpr uint32_t IST4IN = (2 << 6);  ///< Input Select for T4IN
        constexpr uint32_t IST3EUD = (2 << 4);  ///< Input Select for T3EUD
        constexpr uint32_t IST3IN = (2 << 2);  ///< Input Select for T3IN
        constexpr uint32_t IST2EUD = (1U << 1);  ///< Input Select for T2EUD
        constexpr uint32_t IST2IN = (1U << 0);  ///< Input Select for T2IN
    }

    /// T2 Register bits
    namespace t2_bits {
        constexpr uint32_t T2 = (16 << 0);  ///< Timer T2 Current Value
    }

    /// T2CON Register bits
    namespace t2con_bits {
        constexpr uint32_t T2DIR = (1U << 15);  ///< Timer T2 Rotation Direction
        constexpr uint32_t T2CHDIR = (1U << 14);  ///< Timer T2 Count Direction Change
        constexpr uint32_t T2EDGE = (1U << 13);  ///< Timer T2 Edge Detection
        constexpr uint32_t T2IRIDIS = (1U << 12);  ///< Timer T2 Interrupt Disable
        constexpr uint32_t T2RC = (1U << 9);  ///< Timer T2 Remote Control
        constexpr uint32_t T2UDE = (1U << 8);  ///< Timer T2 External Up/Down Enable
        constexpr uint32_t T2UD = (1U << 7);  ///< Timer T2 Up/Down Control
        constexpr uint32_t T2R = (1U << 6);  ///< Timer T2 Input Run Bit
        constexpr uint32_t T2M = (3 << 3);  ///< Timer T2 Input Mode Control
        constexpr uint32_t T2I = (3 << 0);  ///< Timer T2 Input Parameter Selection
    }

    /// T3 Register bits
    namespace t3_bits {
        constexpr uint32_t T3 = (16 << 0);  ///< Timer T3 Current Value
    }

    /// T3CON Register bits
    namespace t3con_bits {
        constexpr uint32_t T3DIR = (1U << 15);  ///< Timer T3 Rotation Direction Flag
        constexpr uint32_t T3CHDIR = (1U << 14);  ///< Timer T3 Count Direction Change Flag
        constexpr uint32_t T3EDGE = (1U << 13);  ///< Timer T3 Edge Detection Flag
        constexpr uint32_t BPS1 = (2 << 11);  ///< GPT1 Block Prescaler Control
        constexpr uint32_t T3OTL = (1U << 10);  ///< Timer T3 Overflow Toggle Latch
        constexpr uint32_t T3OE = (1U << 9);  ///< Overflow/Underflow Output Enable
        constexpr uint32_t T3UDE = (1U << 8);  ///< Timer T3 External Up/Down Enable
        constexpr uint32_t T3UD = (1U << 7);  ///< Timer T3 Up/Down Control
        constexpr uint32_t T3R = (1U << 6);  ///< Timer T3 Input Run Bit
        constexpr uint32_t T3M = (3 << 3);  ///< Timer T3 Input Mode Control
        constexpr uint32_t T3I = (3 << 0);  ///< Timer T3 Input Parameter Selection
    }

    /// T4 Register bits
    namespace t4_bits {
        constexpr uint32_t T4 = (16 << 0);  ///< Timer T4 Current Value
    }

    /// T4CON Register bits
    namespace t4con_bits {
        constexpr uint32_t T4RDIR = (1U << 15);  ///< Timer T4 Rotation Direction
        constexpr uint32_t T4CHDIR = (1U << 14);  ///< Timer T4 Count Direction Change
        constexpr uint32_t T4EDGE = (1U << 13);  ///< Timer T4 Edge Direction
        constexpr uint32_t T4IRDIS = (1U << 12);  ///< Timer T4 Interrupt Disable
        constexpr uint32_t CLRT3EN = (1U << 11);  ///< Clear Timer T3 Enable
        constexpr uint32_t CLRT2EN = (1U << 10);  ///< Clear Timer T2 Enable
        constexpr uint32_t T4RC = (1U << 9);  ///< Timer T4 Remote Control
        constexpr uint32_t T4UDE = (1U << 8);  ///< Timer T4 External Up/Down Enable
        constexpr uint32_t T4UD = (1U << 7);  ///< Timer T2 Up/Down Control
        constexpr uint32_t T4R = (1U << 6);  ///< Timer T4 Input Run Bit
        constexpr uint32_t T4M = (3 << 3);  ///< Timer T4 Mode Control (Basic Operating Mode)
        constexpr uint32_t T4I = (3 << 0);  ///< Timer T4 Input Parameter Selection
    }

    /// T5 Register bits
    namespace t5_bits {
        constexpr uint32_t T5 = (16 << 0);  ///< Timer T5 Current Value
    }

    /// T5CON Register bits
    namespace t5con_bits {
        constexpr uint32_t T5SC = (1U << 15);  ///< Timer T5 Capture Mode Enable
        constexpr uint32_t T5CLR = (1U << 14);  ///< Timer T5 Clear Enable Bit
        constexpr uint32_t CI = (2 << 12);  ///< Register CAPREL Capture Trigger Selection
        constexpr uint32_t CT3 = (1U << 10);  ///< Timer T3 Capture Trigger Enable
        constexpr uint32_t T5RC = (1U << 9);  ///< Timer T5 Remote Control
        constexpr uint32_t T5UDE = (1U << 8);  ///< Timer T5 External Up/Down Enable
        constexpr uint32_t T5UD = (1U << 7);  ///< Timer T2 Up/Down Control
        constexpr uint32_t T5R = (1U << 6);  ///< Timer T5 Run Bit
        constexpr uint32_t T5M = (2 << 3);  ///< Timer T5 Input Mode Control
        constexpr uint32_t T5I = (3 << 0);  ///< Timer T5 Input Parameter Selection
    }

    /// T6 Register bits
    namespace t6_bits {
        constexpr uint32_t T6 = (16 << 0);  ///< Timer T6 Current Value
    }

    /// T6CON Register bits
    namespace t6con_bits {
        constexpr uint32_t T6SR = (1U << 15);  ///< Timer T6 Reload Mode Enable
        constexpr uint32_t T6CLR = (1U << 14);  ///< Timer T6 Clear Enable Bit
        constexpr uint32_t BPS2 = (2 << 11);  ///< GPT2 Block Prescaler Control
        constexpr uint32_t T6OTL = (1U << 10);  ///< Timer T6 Overflow Toggle Latch
        constexpr uint32_t T6OE = (1U << 9);  ///< Overflow/Underflow Output Enable
        constexpr uint32_t T6UDE = (1U << 8);  ///< Timer T6 External Up/Down Enable
        constexpr uint32_t T6UD = (1U << 7);  ///< Timer T6 Up/Down Control
        constexpr uint32_t T6R = (1U << 6);  ///< Timer T6 Input Run Bit
        constexpr uint32_t T6M = (3 << 3);  ///< Timer T6 Mode Control
        constexpr uint32_t T6I = (3 << 0);  ///< Timer T6 Input Parameter Selection
    }

}

// ============================================================================
// HS Peripheral
// ============================================================================

namespace hs {
    /// Base addresses
    constexpr uint32_t HS_BASE = 0x40024000;

    /// HS Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x04 - High Side Driver Control
        volatile uint32_t IRQCLR;  ///< Offset: 0x0C - High Side Driver Interrupt Status Clear Register
        volatile uint32_t IRQEN;  ///< Offset: 0x10 - High Side Driver Interrupt Enable Register
        volatile uint32_t IRQS;  ///< Offset: 0x08 - High Side Driver Interrupt Status
        volatile uint32_t PWMSRCSEL;  ///< Offset: 0x24 - High Side PWM Source Selection Register
        volatile uint32_t TRIM;  ///< Offset: 0x1C - High Side Driver 1 TRIM
    };

    /// Peripheral instances
    inline Registers* HS = reinterpret_cast<Registers*>(HS_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t HS1_OC_SEL = (2 << 12);  ///< High Side 1 Overcurrent Threshold Selection
        constexpr uint32_t HS1_SR_CTRL_SEL = (2 << 8);  ///< High Side 1 Slew Rate Control select
        constexpr uint32_t HS1_OL_EN = (1U << 3);  ///< High Side 1 Open Load Detection Enable
        constexpr uint32_t HS1_ON = (1U << 2);  ///< High Side 1 On
        constexpr uint32_t HS1_PWM = (1U << 1);  ///< High Side 1 PWM Enable
        constexpr uint32_t HS1_EN = (1U << 0);  ///< High Side 1 Enable
    }

    /// IRQCLR Register bits
    namespace irqclr_bits {
        constexpr uint32_t HS1_OL_SC = (1U << 14);  ///< High Side 1 Open Load Status Clear
        constexpr uint32_t HS1_OT_SC = (1U << 13);  ///< High Side 1 Overtemperature Status Clear
        constexpr uint32_t HS1_OC_ISC = (1U << 7);  ///< High Side 1 Overcurrent Interrupt Status Clear
        constexpr uint32_t HS1_OL_ISC = (1U << 6);  ///< High Side 1 Open Load Interrupt Status Clear
        constexpr uint32_t HS1_OT_ISC = (1U << 5);  ///< High Side 1 Overtemperature Interrupt Status Clear
    }

    /// IRQEN Register bits
    namespace irqen_bits {
        constexpr uint32_t HS1_OC_IEN = (1U << 7);  ///< High Side 1 Overcurrent Interrupt Enable
        constexpr uint32_t HS1_OL_IEN = (1U << 6);  ///< High Side 1 Open Load Interrupt Enable
        constexpr uint32_t HS1_OT_IEN = (1U << 5);  ///< High Side 1 Overtemperature Interrupt Enable
    }

    /// IRQS Register bits
    namespace irqs_bits {
        constexpr uint32_t HS1_OL_STS = (1U << 14);  ///< High Side 1 Open Load Status
        constexpr uint32_t HS1_OT_STS = (1U << 13);  ///< High Side 1 Overtemperature Status
        constexpr uint32_t HS1_OC_IS = (1U << 7);  ///< High Side 1 Overcurrent Interrupt Status
        constexpr uint32_t HS1_OL_IS = (1U << 6);  ///< High Side 1 Open Load Interrupt Status
        constexpr uint32_t HS1_OT_IS = (1U << 5);  ///< High Side 1 Overtemperature Interrupt Status
    }

    /// PWMSRCSEL Register bits
    namespace pwmsrcsel_bits {
        constexpr uint32_t HS1_SRC_SEL = (3 << 3);  ///< HS1 PWM Source Selection
    }

    /// TRIM Register bits
    namespace trim_bits {
        constexpr uint32_t HS1_OC_OT_BTFILT_SEL = (2 << 8);  ///< Blanking Time Filter Select for HS1 overcurrent / overtemperature detection
        constexpr uint32_t HS1_OL_BTFILT_SEL = (2 << 0);  ///< Blanking Time Filter Select for HS1 open Load detection
    }

}

// ============================================================================
// LIN Peripheral
// ============================================================================

namespace lin {
    /// Base addresses
    constexpr uint32_t LIN_BASE = 0x4801E000;

    /// LIN Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - LIN Transceiver Control
        volatile uint32_t IRQCLR;  ///< Offset: 0x08 - LIN Transceiver Interrupt Status Register Clear
        volatile uint32_t IRQEN;  ///< Offset: 0x0C - LIN Transceiver Interrupt Enable Register
        volatile uint32_t IRQS;  ///< Offset: 0x04 - LIN Transceiver Interrupt Status
    };

    /// Peripheral instances
    inline Registers* LIN = reinterpret_cast<Registers*>(LIN_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t HV_MODE = (1U << 21);  ///< LIN Transceiver High Voltage Input - Output Mode
        constexpr uint32_t FB_SM3 = (1U << 15);  ///< Feedback Signal 3 for Slope Mode Setting
        constexpr uint32_t FB_SM2 = (1U << 14);  ///< Feedback Signal 2 for Slope Mode Setting
        constexpr uint32_t FB_SM1 = (1U << 13);  ///< Feedback Signal 1 for Slope Mode Setting
        constexpr uint32_t SM = (2 << 11);  ///< LIN Transmitter Slope mode control
        constexpr uint32_t RXD = (1U << 10);  ///< Output Signal of Receiver
        constexpr uint32_t TXD = (1U << 9);  ///< LIN Transmitter switch on (only used when LIN_HV_MODE is set)
        constexpr uint32_t MODE_FB = (3 << 4);  ///< Feedback Signals for LIN Transmitter Mode Settings
        constexpr uint32_t MODE = (2 << 1);  ///< LIN transceiver power mode control
        constexpr uint32_t EN = (1U << 0);  ///< LIN Transceiver enable
    }

    /// IRQCLR Register bits
    namespace irqclr_bits {
        constexpr uint32_t TXD_TMOUT_SC = (1U << 11);  ///< LIN TXD time-out Status Clear
        constexpr uint32_t OT_SC = (1U << 9);  ///< LIN Receiver Overtemperature Status Clear
        constexpr uint32_t M_SM_ERR_SC = (1U << 8);  ///< LIN Transceiver Mode Error - Slope Mode Error Status Clear
        constexpr uint32_t TXD_TMOUT_ISC = (1U << 6);  ///< LIN TXD time-out Interrupt Status Clear
        constexpr uint32_t OC_ISC = (1U << 5);  ///< LIN Receiver Overcurrent Interrupt Status Clear
        constexpr uint32_t OT_ISC = (1U << 4);  ///< LIN Receiver Overtemperature Interrupt Status / Status Clear
        constexpr uint32_t M_SM_ERR_ISC = (1U << 3);  ///< LIN Transceiver Mode Error - Slope Mode Error Interrupt Status Clear
    }

    /// IRQEN Register bits
    namespace irqen_bits {
        constexpr uint32_t TXD_TMOUT_IEN = (1U << 6);  ///< LIN Transceiver TxD-Timeout interrupt enable
        constexpr uint32_t OC_IEN = (1U << 5);  ///< LIN Transceiver Overcurrent interrupt enable
        constexpr uint32_t OT_IEN = (1U << 4);  ///< LIN Transceiver Overtemperature interrupt enable
        constexpr uint32_t M_SM_ERR_IEN = (1U << 3);  ///< LIN Transceiver Mode - Slope Mode Error interrupt enable
    }

    /// IRQS Register bits
    namespace irqs_bits {
        constexpr uint32_t TXD_TMOUT_STS = (1U << 11);  ///< LIN TXD time-out Status
        constexpr uint32_t OT_STS = (1U << 9);  ///< LIN Receiver Overtemperature Status
        constexpr uint32_t M_SM_ERR_STS = (1U << 8);  ///< LIN Transceiver Mode Error - Slope Mode Error Status
        constexpr uint32_t TXD_TMOUT_IS = (1U << 6);  ///< LIN TXD time-out Interrupt Status
        constexpr uint32_t OC_IS = (1U << 5);  ///< LIN Receiver Overcurrent Interrupt Status
        constexpr uint32_t OT_IS = (1U << 4);  ///< LIN Receiver Overtemperature Interrupt Status
        constexpr uint32_t M_SM_ERR_IS = (1U << 3);  ///< LIN Transceiver Mode Error - Slope Mode Error Interrupt Status
    }

}

// ============================================================================
// MATH Peripheral
// ============================================================================

namespace math {
    /// Base addresses
    constexpr uint32_t MATH_BASE = 0x48013000;

    /// MATH Register structure
    struct Registers {
        volatile uint32_t DIVCON;  ///< Offset: 0x34 - Divider Control Register
        volatile uint32_t DIVST;  ///< Offset: 0x30 - Divider Status Register
        volatile uint32_t DVD;  ///< Offset: 0x20 - Dividend Register
        volatile uint32_t DVS;  ///< Offset: 0x24 - Divisor Register
        volatile uint32_t EVFCR;  ///< Offset: 0x18 - Event Flag Clear Register
        volatile uint32_t EVFR;  ///< Offset: 0x10 - Event Flag Register
        volatile uint32_t EVIER;  ///< Offset: 0x0C - Event Interupt Enable Register
        volatile uint32_t EVSFR;  ///< Offset: 0x14 - Event Flag Set Register
        volatile uint32_t GLBCON;  ///< Offset: 0x04 - Global Control Register
        volatile uint32_t MATH_ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t QUOT;  ///< Offset: 0x28 - Quotient Register
        volatile uint32_t RMD;  ///< Offset: 0x2C - Remainder Register
    };

    /// Peripheral instances
    inline Registers* MATH = reinterpret_cast<Registers*>(MATH_BASE);

    // Bit definitions
    /// DIVCON Register bits
    namespace divcon_bits {
        constexpr uint32_t DVSSRC = (5 << 24);  ///< Divisor Shift Right Count
        constexpr uint32_t DVDSLC = (5 << 16);  ///< Dividend Shift Left Count
        constexpr uint32_t QSDIR = (1U << 15);  ///< Quotient Shift Direction
        constexpr uint32_t QSCNT = (5 << 8);  ///< Quotient Shift Count
        constexpr uint32_t DIVMODE = (2 << 3);  ///< Division Mode
        constexpr uint32_t USIGN = (1U << 2);  ///< Unsigned Division Enable
        constexpr uint32_t STMODE = (1U << 1);  ///< Start Mode
        constexpr uint32_t ST = (1U << 0);  ///< Start Bit
    }

    /// DIVST Register bits
    namespace divst_bits {
        constexpr uint32_t BSY = (1U << 0);  ///< Busy Indication
    }

    /// DVD Register bits
    namespace dvd_bits {
        constexpr uint32_t VAL = (32 << 0);  ///< Dividend Value
    }

    /// DVS Register bits
    namespace dvs_bits {
        constexpr uint32_t VAL = (32 << 0);  ///< Divisor Value
    }

    /// EVFCR Register bits
    namespace evfcr_bits {
        constexpr uint32_t DIVERRC = (1U << 1);  ///< Divider Error Event Flag Clear
        constexpr uint32_t DIVEOCC = (1U << 0);  ///< Divider End of Calculation Event Flag Clear
    }

    /// EVFR Register bits
    namespace evfr_bits {
        constexpr uint32_t DIVERR = (1U << 1);  ///< Divider Error Event Flag
        constexpr uint32_t DIVEOC = (1U << 0);  ///< Divider End of Calculation Event Flag
    }

    /// EVIER Register bits
    namespace evier_bits {
        constexpr uint32_t DIVERRIEN = (1U << 1);  ///< Divider Error Interrupt Enable
        constexpr uint32_t DIVEOCIEN = (1U << 0);  ///< Divider End of Calculation Interrupt Enable
    }

    /// EVSFR Register bits
    namespace evsfr_bits {
        constexpr uint32_t DIVERRS = (1U << 1);  ///< Divider Error Event Flag Set
        constexpr uint32_t DIVEOCS = (1U << 0);  ///< Divider End of Calculation Event Flag Set
    }

    /// GLBCON Register bits
    namespace glbcon_bits {
        constexpr uint32_t MATH_EN = (1U << 31);  ///< Enable Math Module
        constexpr uint32_t SUSCFG = (2 << 16);  ///< Suspend Mode Configuration
        constexpr uint32_t DVSRC = (2 << 3);  ///< Divisor Register Result Chaining
        constexpr uint32_t DVDRC = (2 << 0);  ///< Dividend Register Result Chaining
    }

    /// MATH_ID Register bits
    namespace math_id_bits {
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
    }

    /// QUOT Register bits
    namespace quot_bits {
        constexpr uint32_t VAL = (32 << 0);  ///< Quotient Value
    }

    /// RMD Register bits
    namespace rmd_bits {
        constexpr uint32_t VAL = (32 << 0);  ///< Remainder Value
    }

}

// ============================================================================
// MF Peripheral
// ============================================================================

namespace mf {
    /// Base addresses
    constexpr uint32_t MF_BASE = 0x48018000;

    /// MF Register structure
    struct Registers {
        volatile uint32_t CSA_CTRL;  ///< Offset: 0x00 - Current Sense Amplifier Control Register
        volatile uint32_t REF1_STS;  ///< Offset: 0x14 - Reference 1 Status Register
    };

    /// Peripheral instances
    inline Registers* MF = reinterpret_cast<Registers*>(MF_BASE);

    // Bit definitions
    /// CSA_CTRL Register bits
    namespace csa_ctrl_bits {
        constexpr uint32_t CSA_VZERO = (1U << 8);  ///< Current Sense Output Selection
        constexpr uint32_t CSA_MI_EN = (1U << 4);  ///< Enable Module Isolation Testmode
        constexpr uint32_t CSA_GAIN = (2 << 1);  ///< Operational Amplifier Gain Setting
        constexpr uint32_t CSA_EN = (1U << 0);  ///< CSA Enable
    }

    /// REF1_STS Register bits
    namespace ref1_sts_bits {
        constexpr uint32_t VREF1V2_UPTHWARN_STS = (1U << 5);  ///< Status for Overvoltage Threshold Measurement of internal VAREF
        constexpr uint32_t VREF1V2_LOTHWARN_STS = (1U << 4);  ///< Status for Undervoltage Threshold Measurement of internal VAREF
    }

}

// ============================================================================
// PMU Peripheral
// ============================================================================

namespace pmu {
    /// Base addresses
    constexpr uint32_t PMU_BASE = 0x50004000;

    /// PMU Register structure
    struct Registers {
        volatile uint32_t CNF_RST_TFB;  ///< Offset: 0x6C - Reset Blind Time Register
        volatile uint32_t CNF_WAKE_FILTER;  ///< Offset: 0xAC - PMU Wake-up Timing Register
        volatile uint32_t DRV_CTRL;  ///< Offset: 0x24 - PMU Bridge Driver Control
        volatile uint32_t GPIO_WAKE_STATUS;  ///< Offset: 0x04 - GPIO Port wake status register
        volatile uint32_t GPUDATA0to3;  ///< Offset: 0xC0 - General Purpose User DATA0to3
        volatile uint32_t GPUDATA4to7;  ///< Offset: 0xC4 - General Purpose User DATA4to7
        volatile uint32_t GPUDATA8to11;  ///< Offset: 0xC8 - General Purpose User DATA8to11
        volatile uint32_t HIGHSIDE_CTRL;  ///< Offset: 0x5C - Highside Control Register
        volatile uint32_t LIN_WAKE_EN;  ///< Offset: 0x50 - LIN Wake Enable
        volatile uint32_t MON_CNF1;  ///< Offset: 0x34 - Settings Monitor
        volatile uint32_t MON_CNF2;  ///< Offset: 0x38 - Settings Monitor
        volatile uint32_t OT_CTRL;  ///< Offset: 0x54 - Overtemperature Control Register
        volatile uint32_t PORCFG;  ///< Offset: 0xB4 - POR Reset Configuration Register
        volatile uint32_t RESET_STS;  ///< Offset: 0x10 - Reset Status Register
        volatile uint32_t SLEEP;  ///< Offset: 0x20 - PMU Sleep Behavior Register
        volatile uint32_t SUPPLY_STS;  ///< Offset: 0x08 - Voltage Reg Status Register
        volatile uint32_t VDDEXT_CTRL;  ///< Offset: 0x0C - VDDEXT Control
        volatile uint32_t WAKE_CNF_GPIO0;  ///< Offset: 0xBC - Wake Configuration GPIO Port 0 Register
        volatile uint32_t WAKE_CNF_GPIO1;  ///< Offset: 0xCC - Wake Configuration GPIO Port 1 Register
        volatile uint32_t WAKE_STATUS;  ///< Offset: 0x00 - Main wake status register
        volatile uint32_t WFS;  ///< Offset: 0x70 - WFS System Fail Register
    };

    /// Peripheral instances
    inline Registers* PMU = reinterpret_cast<Registers*>(PMU_BASE);

    // Bit definitions
    /// CNF_RST_TFB Register bits
    namespace cnf_rst_tfb_bits {
        constexpr uint32_t RST_TFB = (2 << 0);  ///< Reset Pin Blind Time Selection Bits
    }

    /// CNF_WAKE_FILTER Register bits
    namespace cnf_wake_filter_bits {
        constexpr uint32_t CNF_GPIO_FT = (2 << 2);  ///< Wake-up Filter time for General Purpose IO
        constexpr uint32_t CNF_MON_FT = (1U << 1);  ///< Wake-up Filter time for Monitoring Inputs
        constexpr uint32_t CNF_LIN_FT = (1U << 0);  ///< Wake-up Filter time for LIN WAKE
    }

    /// DRV_CTRL Register bits
    namespace drv_ctrl_bits {
        constexpr uint32_t CNF_OFF = (2 << 6);  ///< CNF_OFF Function
        constexpr uint32_t CNF_ON = (2 << 4);  ///< CNF_ON Function
        constexpr uint32_t GL2_HOLD_ON = (1U << 3);  ///< GL2 Hold Mode On
        constexpr uint32_t GL2_CYC_ON = (1U << 2);  ///< GL2 Cyclic On
        constexpr uint32_t GL1_HOLD_ON = (1U << 1);  ///< GL1 Hold Mode On
        constexpr uint32_t GL1_CYC_ON = (1U << 0);  ///< GL1 Cyclic On
    }

    /// GPIO_WAKE_STATUS Register bits
    namespace gpio_wake_status_bits {
        constexpr uint32_t GPIO1_STS_4 = (1U << 12);  ///< Wake GPIO1_4
        constexpr uint32_t GPIO1_STS_2 = (1U << 10);  ///< Wake GPIO1_2
        constexpr uint32_t GPIO1_STS_1 = (1U << 9);  ///< Wake GPIO1_1
        constexpr uint32_t GPIO1_STS_0 = (1U << 8);  ///< Wake GPIO1_0
        constexpr uint32_t GPIO0_STS_5 = (1U << 5);  ///< Status of GPIO0_5
        constexpr uint32_t GPIO0_STS_4 = (1U << 4);  ///< Status of GPIO0_4
        constexpr uint32_t GPIO0_STS_3 = (1U << 3);  ///< Status of GPIO0_3
        constexpr uint32_t GPIO0_STS_2 = (1U << 2);  ///< Status of GPIO0_2
        constexpr uint32_t GPIO0_STS_1 = (1U << 1);  ///< Status of GPIO0_1
        constexpr uint32_t GPIO0_STS_0 = (1U << 0);  ///< Status of GPIO0_0
    }

    /// GPUDATA0to3 Register bits
    namespace gpudata0to3_bits {
        constexpr uint32_t DATA3 = (8 << 24);  ///< DATA3 Storage Byte
        constexpr uint32_t DATA2 = (8 << 16);  ///< DATA2 Storage Byte
        constexpr uint32_t DATA1 = (8 << 8);  ///< DATA1 Storage Byte
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0 Storage Byte
    }

    /// GPUDATA4to7 Register bits
    namespace gpudata4to7_bits {
        constexpr uint32_t DATA7 = (8 << 24);  ///< DATA7 Storage Byte
        constexpr uint32_t DATA6 = (8 << 16);  ///< DATA6 Storage Byte
        constexpr uint32_t DATA5 = (8 << 8);  ///< DATA5 Storage Byte
        constexpr uint32_t DATA4 = (8 << 0);  ///< DATA4 Storage Byte
    }

    /// GPUDATA8to11 Register bits
    namespace gpudata8to11_bits {
        constexpr uint32_t DATA11 = (8 << 24);  ///< DATA11 Storage Byte
        constexpr uint32_t DATA10 = (8 << 16);  ///< DATA10 Storage Byte
        constexpr uint32_t DATA9 = (8 << 8);  ///< DATA9 Storage Byte
        constexpr uint32_t DATA8 = (8 << 0);  ///< DATA8 Storage Byte
    }

    /// HIGHSIDE_CTRL Register bits
    namespace highside_ctrl_bits {
        constexpr uint32_t SPARE = (1U << 10);  ///< Spare
        constexpr uint32_t HS1_CYC_EN = (1U << 2);  ///< High-Side 1 switch enable for cyclic sense
    }

    /// LIN_WAKE_EN Register bits
    namespace lin_wake_en_bits {
        constexpr uint32_t LIN_WAKE_EN = (1U << 7);  ///< Lin Wake enable
    }

    /// MON_CNF1 Register bits
    namespace mon_cnf1_bits {
        constexpr uint32_t MON4_STS = (1U << 31);  ///< MON4 Status Input
        constexpr uint32_t MON4_NSLEEP_SPARE = (1U << 30);  ///< MON4 Sleep Bit
        constexpr uint32_t MON4_PU = (1U << 29);  ///< Pull-Up Current Source for MON4 Input Enable
        constexpr uint32_t MON4_PD = (1U << 28);  ///< Pull-Down Current Source for MON4 Input Enable
        constexpr uint32_t MON4_CYC = (1U << 27);  ///< MON4 for Cycle Sense Enable
        constexpr uint32_t MON4_RISE = (1U << 26);  ///< MON4 Wake-up on Rising Edge Enable
        constexpr uint32_t MON4_FALL = (1U << 25);  ///< MON4 Wake-up on Falling Edge Enable
        constexpr uint32_t MON4_EN = (1U << 24);  ///< MON4 Enable
        constexpr uint32_t MON3_STS = (1U << 23);  ///< MON3 Status Input
        constexpr uint32_t MON3_NSLEEP_SPARE = (1U << 22);  ///< MON3 Sleep Bit
        constexpr uint32_t MON3_PU = (1U << 21);  ///< Pull-Up Current Source for MON3 Input Enable
        constexpr uint32_t MON3_PD = (1U << 20);  ///< Pull-Down Current Source for MON3 Input Enable
        constexpr uint32_t MON3_CYC = (1U << 19);  ///< MON3 for Cycle Sense Enable
        constexpr uint32_t MON3_RISE = (1U << 18);  ///< MON3 Wake-up on Rising Edge Enable
        constexpr uint32_t MON3_FALL = (1U << 17);  ///< MON3 Wake-up on Falling Edge Enable
        constexpr uint32_t MON3_EN = (1U << 16);  ///< MON3 Enable
        constexpr uint32_t MON2_STS = (1U << 15);  ///< MON2 Status Input
        constexpr uint32_t MON2_NSLEEP_SPARE = (1U << 14);  ///< MON2 Sleep Bit
        constexpr uint32_t MON2_PU = (1U << 13);  ///< Pull-Up Current Source for MON2 Input Enable
        constexpr uint32_t MON2_PD = (1U << 12);  ///< Pull-Down Current Source for MON2 Input Enable
        constexpr uint32_t MON2_CYC = (1U << 11);  ///< MON2 for Cycle Sense Enable
        constexpr uint32_t MON2_RISE = (1U << 10);  ///< MON2 Wake-up on Rising Edge Enable
        constexpr uint32_t MON2_FALL = (1U << 9);  ///< MON2 Wake-up on Falling Edge Enable
        constexpr uint32_t MON2_EN = (1U << 8);  ///< MON2 Enable
        constexpr uint32_t MON1_STS = (1U << 7);  ///< MON1 Status Input
        constexpr uint32_t MON1_NSLEEP_SPARE = (1U << 6);  ///< MON1 Sleep Bit
        constexpr uint32_t MON1_PU = (1U << 5);  ///< Pull-Up Current Source for MON1 Input Enable
        constexpr uint32_t MON1_PD = (1U << 4);  ///< Pull-Down Current Source for MON1 Input Enable
        constexpr uint32_t MON1_CYC = (1U << 3);  ///< MON1 for Cycle Sense Enable
        constexpr uint32_t MON1_RISE = (1U << 2);  ///< MON1 Wake-up on Rising Edge Enable
        constexpr uint32_t MON1_FALL = (1U << 1);  ///< MON1 Wake-up on Falling Edge Enable
        constexpr uint32_t MON1_EN = (1U << 0);  ///< MON1 Enable
    }

    /// MON_CNF2 Register bits
    namespace mon_cnf2_bits {
        constexpr uint32_t MON5_STS = (1U << 7);  ///< MON5 Status Input
        constexpr uint32_t MON5_NSLEEP_SPARE = (1U << 6);  ///< MON5 Sleep Bit
        constexpr uint32_t MON5_PU = (1U << 5);  ///< Pull-Up Current Source for MON5 Input Enable
        constexpr uint32_t MON5_PD = (1U << 4);  ///< Pull-Down Current Source for MON5 Input Enable
        constexpr uint32_t MON5_CYC = (1U << 3);  ///< MON5 for Cycle Sense Enable
        constexpr uint32_t MON5_RISE = (1U << 2);  ///< MON5 Wake-up on Rising Edge Enable
        constexpr uint32_t MON5_FALL = (1U << 1);  ///< MON5 Wake-up on Falling Edge Enable
        constexpr uint32_t MON5_EN = (1U << 0);  ///< MON5 Enable
    }

    /// OT_CTRL Register bits
    namespace ot_ctrl_bits {
        constexpr uint32_t PMU_OT_EN = (1U << 7);  ///< PMU Overtemperature Detection Enable
        constexpr uint32_t PMU_OT_WAKE_EN = (1U << 6);  ///< PMU Wake On Overtemperature Enable
        constexpr uint32_t PMU_OT_INT_EN = (1U << 5);  ///< PMU Overtemperature Interrupt Enable
        constexpr uint32_t PMU_OT_TH_CNF = (4 << 0);  ///< PMU Overtemperature threshold
    }

    /// PORCFG Register bits
    namespace porcfg_bits {
        constexpr uint32_t CNF_FILT = (2 << 0);  ///< Configuration for reset filter
    }

    /// RESET_STS Register bits
    namespace reset_sts_bits {
        constexpr uint32_t LOCKUP = (1U << 10);  ///< Lockup-Reset Flag
        constexpr uint32_t PMU_SOFT = (1U << 9);  ///< Soft-Reset Flag
        constexpr uint32_t PMU_IntWDT = (1U << 8);  ///< Internal Watchdog Reset Flag
        constexpr uint32_t PMU_VS_POR = (1U << 7);  ///< Power-On Reset Flag
        constexpr uint32_t PMU_PIN = (1U << 6);  ///< PIN-Reset Flag
        constexpr uint32_t PMU_ExtWDT = (1U << 5);  ///< External Watchdog (WDT1) Reset Flag
        constexpr uint32_t PMU_ClkWDT = (1U << 4);  ///< Clock Watchdog (CLKWDT) Reset Flag
        constexpr uint32_t PMU_LPR = (1U << 3);  ///< Low Priority Resets (see PMU_RST_STS2)
        constexpr uint32_t PMU_SleepEX = (1U << 2);  ///< Flag which indicates a reset caused by Sleep-Exit
        constexpr uint32_t PMU_WAKE = (1U << 1);  ///< Flag which indicates a reset caused by Stop-Exit
        constexpr uint32_t SYS_FAIL = (1U << 0);  ///< Flag which indicates a reset caused by a System Fail reported in the corresponding Fail Register
    }

    /// SLEEP Register bits
    namespace sleep_bits {
        constexpr uint32_t CYC_SENSE_S_DEL = (3 << 24);  ///< Sample Delay in Cyclic Sense
        constexpr uint32_t CYC_WAKE_E01 = (2 << 20);  ///< Exponent
        constexpr uint32_t CYC_WAKE_M03 = (4 << 16);  ///< Mantissa
        constexpr uint32_t CYC_SENSE_E01 = (2 << 12);  ///< Exponent
        constexpr uint32_t CYC_SENSE_M03 = (4 << 8);  ///< Mantissa
        constexpr uint32_t CYC_SENSE_EN = (1U << 3);  ///< Enabling Cyclic Sense
        constexpr uint32_t CYC_WAKE_EN = (1U << 2);  ///< Enabling Cyclic Wake
        constexpr uint32_t EN_0V9_N = (1U << 1);  ///< Enables the reduction of the VDDC regulator output to 0.9 V during Stop-Mode
        constexpr uint32_t WAKE_W_RST = (1U << 0);  ///< Wake-up with reset execution
    }

    /// SUPPLY_STS Register bits
    namespace supply_sts_bits {
        constexpr uint32_t PMU_5V_OVERLOAD_SC = (1U << 13);  ///< Overload at VDDP regulator Status clear
        constexpr uint32_t PMU_5V_OVERVOLT_SC = (1U << 12);  ///< Overvoltage at VDDP regulator Status clear
        constexpr uint32_t PMU_OVERTEMP_SC = (1U << 11);  ///< Overtemperature Status clear
        constexpr uint32_t PMU_1V5_OVERLOAD_SC = (1U << 9);  ///< Overload at VDDC regulator Status clear
        constexpr uint32_t PMU_1V5_OVERVOLT_SC = (1U << 8);  ///< Overvoltage at VDDC regulator Status clear
        constexpr uint32_t PMU_5V_FAIL_EN = (1U << 6);  ///< Enabling of VDDP status information as interrupt source
        constexpr uint32_t PMU_5V_OVERLOAD = (1U << 5);  ///< Overload at VDDP regulator
        constexpr uint32_t PMU_5V_OVERVOLT = (1U << 4);  ///< Overvoltage at VDDP regulator
        constexpr uint32_t PMU_OVERTEMP = (1U << 3);  ///< PMU Overtemperature
        constexpr uint32_t PMU_1V5_FAIL_EN = (1U << 2);  ///< Enabling of VDDC status information as interrupt source
        constexpr uint32_t PMU_1V5_OVERLOAD = (1U << 1);  ///< Overload at VDDC regulator
        constexpr uint32_t PMU_1V5_OVERVOLT = (1U << 0);  ///< Overvoltage at VDDC regulator
    }

    /// VDDEXT_CTRL Register bits
    namespace vddext_ctrl_bits {
        constexpr uint32_t VDDEXT_OT_SC = (1U << 13);  ///< VDDEXT Supply Overtemperature Status clear
        constexpr uint32_t VDDEXT_UV_ISC = (1U << 12);  ///< VDDEXT Supply Undervoltage Interrupt Status clear
        constexpr uint32_t VDDEXT_OT_ISC = (1U << 11);  ///< VDDEXT Supply Overtemperature Interrupt Status clear
        constexpr uint32_t VDDEXT_STABLE = (1U << 7);  ///< VDDEXT Supply Stable
        constexpr uint32_t VDDEXT_OT = (1U << 6);  ///< VDDEXT Supply Overtemperature
        constexpr uint32_t VDDEXT_OT_STS = (1U << 5);  ///< VDDEXT Supply Overtemperature Status
        constexpr uint32_t VDDEXT_UV_IS = (1U << 4);  ///< VDDEXT Supply Undervoltage Interrupt Status
        constexpr uint32_t VDDEXT_OT_IS = (1U << 3);  ///< VDDEXT Supply OverTemperature Interrupt Status
        constexpr uint32_t VDDEXT_FAIL_EN = (1U << 2);  ///< Enabling of VDDEXT Supply status information as interrupt source
        constexpr uint32_t VDDEXT_CYC_EN = (1U << 1);  ///< VDDEXT Supply for Cyclic Sense Enable
        constexpr uint32_t VDDEXT_ENABLE = (1U << 0);  ///< VDDEXT Supply Enable
    }

    /// WAKE_CNF_GPIO0 Register bits
    namespace wake_cnf_gpio0_bits {
        constexpr uint32_t CYC_5 = (1U << 21);  ///< GPIO0_5 input for cycle sense enable
        constexpr uint32_t CYC_4 = (1U << 20);  ///< GPIO0_4 input for cycle sense enable
        constexpr uint32_t CYC_3 = (1U << 19);  ///< GPIO0_3 input for cycle sense enable
        constexpr uint32_t CYC_2 = (1U << 18);  ///< GPIO0_2 input for cycle sense enable
        constexpr uint32_t CYC_1 = (1U << 17);  ///< GPIO0_1 input for cycle sense enable
        constexpr uint32_t CYC_0 = (1U << 16);  ///< GPIO0_0 input for cycle sense enable
        constexpr uint32_t FA_5 = (1U << 13);  ///< Port 0_5 Wake-up on Falling Edge enable
        constexpr uint32_t FA_4 = (1U << 12);  ///< Port 0_4 Wake-up on Falling Edge enable
        constexpr uint32_t FA_3 = (1U << 11);  ///< Port 0_3 Wake-up on Falling Edge enable
        constexpr uint32_t FA_2 = (1U << 10);  ///< Port 0_2 Wake-up on Falling Edge enable
        constexpr uint32_t FA_1 = (1U << 9);  ///< Port 0_1 Wake-up on Falling Edge enable
        constexpr uint32_t FA_0 = (1U << 8);  ///< Port 0_0 Wake-up on Falling Edge enable
        constexpr uint32_t RI_5 = (1U << 5);  ///< Port 0_5 Wake-up on Rising Edge enable
        constexpr uint32_t RI_4 = (1U << 4);  ///< Port 0_4 Wake-up on Rising Edge enable
        constexpr uint32_t RI_3 = (1U << 3);  ///< Port 0_3 Wake-up on Rising Edge enable
        constexpr uint32_t RI_2 = (1U << 2);  ///< Port 0_2 Wake-up on Rising Edge enable
        constexpr uint32_t RI_1 = (1U << 1);  ///< Port 0_1 Wake-up on Rising Edge enable
        constexpr uint32_t RI_0 = (1U << 0);  ///< Port 0_0 Wake-up on Rising Edge enable
    }

    /// WAKE_CNF_GPIO1 Register bits
    namespace wake_cnf_gpio1_bits {
        constexpr uint32_t CYC_4 = (1U << 20);  ///< GPIO1_4 input for cycle sense enable
        constexpr uint32_t CYC_2 = (1U << 18);  ///< GPIO1_2 input for cycle sense enable
        constexpr uint32_t CYC_1 = (1U << 17);  ///< GPIO1_1 input for cycle sense enable
        constexpr uint32_t CYC_0 = (1U << 16);  ///< GPIO1_0 input for cycle sense enable
        constexpr uint32_t FA_4 = (1U << 12);  ///< Port 1_4 Wake-up on Falling Edge enable
        constexpr uint32_t FA_2 = (1U << 10);  ///< Port 1_2 Wake-up on Falling Edge enable
        constexpr uint32_t FA_1 = (1U << 9);  ///< Port 1_1 Wake-up on Falling Edge enable
        constexpr uint32_t FA_0 = (1U << 8);  ///< Port 1_0 Wake-up on Falling Edge enable
        constexpr uint32_t RI_4 = (1U << 4);  ///< Port 1_4 Wake-up on Rising Edge enable
        constexpr uint32_t RI_2 = (1U << 2);  ///< Port 1_2 Wake-up on Rising Edge enable
        constexpr uint32_t RI_1 = (1U << 1);  ///< Port 1_1 Wake-up on Rising Edge enable
        constexpr uint32_t RI_0 = (1U << 0);  ///< Port 1_0 Wake-up on Rising Edge enable
    }

    /// WAKE_STATUS Register bits
    namespace wake_status_bits {
        constexpr uint32_t VDDEXT_UV = (1U << 18);  ///< Wake VDDEXT Undervoltage
        constexpr uint32_t VDDEXT_OT = (1U << 17);  ///< Wake VDDEXT Overtemperature
        constexpr uint32_t PMU_OT = (1U << 16);  ///< Wake PMU Overtemperature
        constexpr uint32_t MON5_WAKE_STS = (1U << 12);  ///< Status of MON5
        constexpr uint32_t MON4_WAKE_STS = (1U << 11);  ///< Status of MON4
        constexpr uint32_t MON3_WAKE_STS = (1U << 10);  ///< Status of MON3
        constexpr uint32_t MON2_WAKE_STS = (1U << 9);  ///< Status of MON2
        constexpr uint32_t MON1_WAKE_STS = (1U << 8);  ///< Status of MON1
        constexpr uint32_t GPIO2 = (1U << 6);  ///< Wake-up via GPIO2 which is a logical OR combination of all Wake_STS_GPIO2 bits
        constexpr uint32_t FAIL = (1U << 5);  ///< Wake-up after any Fail, which is a logical OR combination of PMU_OT, VDDEXT_OT, VDDEXT_UV
        constexpr uint32_t CYC_WAKE = (1U << 4);  ///< Wake-up caused by Cyclic Wake
        constexpr uint32_t GPIO1 = (1U << 3);  ///< Wake-up via GPIO1 which is a logical OR combination of all Wake_STS_GPIO1 bits
        constexpr uint32_t GPIO0 = (1U << 2);  ///< Wake-up via GPIO0 which is a logical OR combination of all Wake_STS_GPIO0 bits
        constexpr uint32_t MON = (1U << 1);  ///< Wake-up via MON which is a logical OR combination of all Wake_STS_MON bits
        constexpr uint32_t LIN_WAKE = (1U << 0);  ///< Wake-up via LIN- Message
    }

    /// WFS Register bits
    namespace wfs_bits {
        constexpr uint32_t PMU_OT_FAIL = (1U << 8);  ///< PMU Overtemperature Indication Flag
        constexpr uint32_t LP_CLKWD = (1U << 7);  ///< LP_CLKWD
        constexpr uint32_t WDT1_SEQ_FAIL = (1U << 6);  ///< External Watchdog (WDT1) Sequential Fail
        constexpr uint32_t SYS_OT = (1U << 5);  ///< System Overtemperature Indication Flag
        constexpr uint32_t SYS_CLK_WDT = (1U << 4);  ///< System Clock (fsys)Watchdog Fail
        constexpr uint32_t PMU_5V_OVL = (1U << 3);  ///< VDDP Overload Flag
        constexpr uint32_t PMU_1V5_OVL = (1U << 2);  ///< VDDC Overload Flag
        constexpr uint32_t SUPP_TMOUT = (1U << 1);  ///< Supply Time Out
        constexpr uint32_t SUPP_SHORT = (1U << 0);  ///< Supply Short
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT_BASE = 0x48028000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t P0_ALTSEL0;  ///< Offset: 0x14 - Port 0 Alternate Select Register 0
        volatile uint32_t P0_ALTSEL1;  ///< Offset: 0x18 - Port 0 Alternate Select Register 1
        volatile uint32_t P0_DATA;  ///< Offset: 0x00 - Port 0 Data Register
        volatile uint32_t P0_DIR;  ///< Offset: 0x04 - Port 0 Direction Register
        volatile uint32_t P0_OD;  ///< Offset: 0x08 - Port 0 Open Drain Control Register
        volatile uint32_t P0_PUDEN;  ///< Offset: 0x10 - Port 0 Pull-Up/Pull-Down Enable Register
        volatile uint32_t P0_PUDSEL;  ///< Offset: 0x0C - Port 0 Pull-Up/Pull-Down Select Register
        volatile uint32_t P1_ALTSEL0;  ///< Offset: 0x34 - Port 1 Alternate Select Register 0
        volatile uint32_t P1_ALTSEL1;  ///< Offset: 0x38 - Port 1 Alternate Select Register 1
        volatile uint32_t P1_DATA;  ///< Offset: 0x20 - Port 1 Data Register
        volatile uint32_t P1_DIR;  ///< Offset: 0x24 - Port 1 Direction Register
        volatile uint32_t P1_OD;  ///< Offset: 0x28 - Port 1 Open Drain Control Register
        volatile uint32_t P1_PUDEN;  ///< Offset: 0x30 - Port 1 Pull-Up/Pull-Down Enable Register
        volatile uint32_t P1_PUDSEL;  ///< Offset: 0x2C - Port 1 Pull-Up/Pull-Down Select Register
        volatile uint32_t P2_DATA;  ///< Offset: 0x40 - Port 2 Data Register
        volatile uint32_t P2_DIR;  ///< Offset: 0x44 - Port 2 Direction Register
        volatile uint32_t P2_PUDEN;  ///< Offset: 0x50 - Port 2 Pull-Up/Pull-Down Enable Register
        volatile uint32_t P2_PUDSEL;  ///< Offset: 0x4C - Port 2 Pull-Up/Pull-Down Select Register
    };

    /// Peripheral instances
    inline Registers* PORT = reinterpret_cast<Registers*>(PORT_BASE);

    // Bit definitions
    /// P0_ALTSEL0 Register bits
    namespace p0_altsel0_bits {
        constexpr uint32_t PP5 = (1U << 5);  ///< See
        constexpr uint32_t PP4 = (1U << 4);  ///< See
        constexpr uint32_t PP3 = (1U << 3);  ///< See
        constexpr uint32_t PP2 = (1U << 2);  ///< See
        constexpr uint32_t PP1 = (1U << 1);  ///< See
        constexpr uint32_t PP0 = (1U << 0);  ///< See
    }

    /// P0_ALTSEL1 Register bits
    namespace p0_altsel1_bits {
        constexpr uint32_t PP5 = (1U << 5);  ///< See
        constexpr uint32_t PP4 = (1U << 4);  ///< See
        constexpr uint32_t PP3 = (1U << 3);  ///< See
        constexpr uint32_t PP2 = (1U << 2);  ///< See
        constexpr uint32_t PP1 = (1U << 1);  ///< See
        constexpr uint32_t PP0 = (1U << 0);  ///< See
    }

    /// P0_DATA Register bits
    namespace p0_data_bits {
        constexpr uint32_t PP5_STS = (1U << 21);  ///< Port 0 Pin 5 Data Value (read back of Port Data when IO is configured as output)
        constexpr uint32_t PP4_STS = (1U << 20);  ///< Port 0 Pin 4 Data Value (read back of Port Data when IO is configured as output)
        constexpr uint32_t PP3_STS = (1U << 19);  ///< Port 0 Pin 3 Data Value (read back of Port Data when IO is configured as output)
        constexpr uint32_t PP2_STS = (1U << 18);  ///< Port 0 Pin 2 Data Value (read back of Port Data when IO is configured as output)
        constexpr uint32_t PP1_STS = (1U << 17);  ///< Port 0 Pin 1 Data Value (read back of Port Data when IO is configured as output)
        constexpr uint32_t PP0_STS = (1U << 16);  ///< Port 0 Pin 0 Data Value (read back of Port Data when IO is configured as output)
        constexpr uint32_t PP5 = (1U << 5);  ///< Port 0 Pin 5 Data Value
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 0 Pin 4 Data Value
        constexpr uint32_t PP3 = (1U << 3);  ///< Port 0 Pin 3 Data Value
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 0 Pin 2 Data Value
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 0 Pin 1 Data Value
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 0 Pin 0 Data Value
    }

    /// P0_DIR Register bits
    namespace p0_dir_bits {
        constexpr uint32_t PP5_INEN = (1U << 21);  ///< Port 0 Pin 5 Input Schmitt Trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP4_INEN = (1U << 20);  ///< Port 0 Pin 4 Input Schmitt Trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP3_INEN = (1U << 19);  ///< Port 0 Pin 3 Input Schmitt Trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP2_INEN = (1U << 18);  ///< Port 0 Pin 2 Input Schmitt Trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP1_INEN = (1U << 17);  ///< Port 0 Pin 1 Input Schmitt Trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP0_INEN = (1U << 16);  ///< Port 0 Pin 0 Input Schmitt Trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP5 = (1U << 5);  ///< Port 0 Pin 5 Direction Control
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 0 Pin 4 Direction Control
        constexpr uint32_t PP3 = (1U << 3);  ///< Port 0 Pin 3 Direction Control
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 0 Pin 2 Direction Control
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 0 Pin 1 Direction Control
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 0 Pin 0 Direction Control
    }

    /// P0_OD Register bits
    namespace p0_od_bits {
        constexpr uint32_t PP5 = (1U << 5);  ///< Port 0 Pin 5 Open Drain Mode
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 0 Pin 4 Open Drain Mode
        constexpr uint32_t PP3 = (1U << 3);  ///< Port 0 Pin 3 Open Drain Mode
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 0 Pin 2 Open Drain Mode
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 0 Pin 1 Open Drain Mode
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 0 Pin 0 Open Drain Mode
    }

    /// P0_PUDEN Register bits
    namespace p0_puden_bits {
        constexpr uint32_t PP5 = (1U << 5);  ///< Pull-Up/Pull-Down Enable at Port 0 Bit 5
        constexpr uint32_t PP4 = (1U << 4);  ///< Pull-Up/Pull-Down Enable at Port 0 Bit 4
        constexpr uint32_t PP3 = (1U << 3);  ///< Pull-Up/Pull-Down Enable at Port 0 Bit 3
        constexpr uint32_t PP2 = (1U << 2);  ///< Pull-Up/Pull-Down Enable at Port 0 Bit 2
        constexpr uint32_t PP1 = (1U << 1);  ///< Pull-Up/Pull-Down Enable at Port 0 Bit 1
        constexpr uint32_t PP0 = (1U << 0);  ///< Pull-Up/Pull-Down Enable at Port 0 Bit 0
    }

    /// P0_PUDSEL Register bits
    namespace p0_pudsel_bits {
        constexpr uint32_t PP5 = (1U << 5);  ///< Pull-Up/Pull-Down Select Port 0 Bit 5
        constexpr uint32_t PP4 = (1U << 4);  ///< Pull-Up/Pull-Down Select Port 0 Bit 4
        constexpr uint32_t PP3 = (1U << 3);  ///< Pull-Up/Pull-Down Select Port 0 Bit 3
        constexpr uint32_t PP2 = (1U << 2);  ///< Pull-Up/Pull-Down Select Port 0 Bit 2
        constexpr uint32_t PP1 = (1U << 1);  ///< Pull-Up/Pull-Down Select Port 0 Bit 1
        constexpr uint32_t PP0 = (1U << 0);  ///< Pull-Up/Pull-Down Select Port 0 Bit 0
    }

    /// P1_ALTSEL0 Register bits
    namespace p1_altsel0_bits {
        constexpr uint32_t PP4 = (1U << 4);  ///< See
        constexpr uint32_t PP2 = (1U << 2);  ///< See
        constexpr uint32_t PP1 = (1U << 1);  ///< See
        constexpr uint32_t PP0 = (1U << 0);  ///< See
    }

    /// P1_ALTSEL1 Register bits
    namespace p1_altsel1_bits {
        constexpr uint32_t PP4 = (1U << 4);  ///< See
        constexpr uint32_t PP2 = (1U << 2);  ///< See
        constexpr uint32_t PP1 = (1U << 1);  ///< See
        constexpr uint32_t PP0 = (1U << 0);  ///< See
    }

    /// P1_DATA Register bits
    namespace p1_data_bits {
        constexpr uint32_t PP4_STS = (1U << 20);  ///< Port 1 Pin 4 Data Value (read back of Port Data when IO is configured as output)
        constexpr uint32_t PP2_STS = (1U << 18);  ///< Port 1 Pin 2 Data Value (read back of Port Data when IO is configured as output)
        constexpr uint32_t PP1_STS = (1U << 17);  ///< Port 1 Pin 1 Data Value (read back of Port Data when IO is configured as output)
        constexpr uint32_t PP0_STS = (1U << 16);  ///< Port 1 Pin 0 Data Value (read back of Port Data when IO is configured as output)
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 1 Pin 4 Data Value
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 1 Pin 2 Data Value
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 1 Pin 1 Data Value
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 1 Pin 0 Data Value
    }

    /// P1_DIR Register bits
    namespace p1_dir_bits {
        constexpr uint32_t PP4_INEN = (1U << 20);  ///< Port 1 Pin 4 Input Schmitt Trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP2_INEN = (1U << 18);  ///< Port 1 Pin 2 Input Schmitt Trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP1_INEN = (1U << 17);  ///< Port 1 Pin 1 Input Schmitt Trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP0_INEN = (1U << 16);  ///< Port 1 Pin 0 Input Schmitt Trigger enable (only valid if IO is configured as output)
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 1 Pin 4 Direction Control
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 1 Pin 2 Direction Control
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 1 Pin 1 Direction Control
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 1 Pin 0 Direction Control
    }

    /// P1_OD Register bits
    namespace p1_od_bits {
        constexpr uint32_t PP4 = (1U << 4);  ///< Port 1 Pin 4 Open Drain Mode
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 1 Pin 2 Open Drain Mode
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 1 Pin 1 Open Drain Mode
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 1 Pin 0 Open Drain Mode
    }

    /// P1_PUDEN Register bits
    namespace p1_puden_bits {
        constexpr uint32_t PP4 = (1U << 4);  ///< Pull-Up/Pull-Down Enable at Port 1 Bit 4
        constexpr uint32_t PP2 = (1U << 2);  ///< Pull-Up/Pull-Down Enable at Port 1 Bit 2
        constexpr uint32_t PP1 = (1U << 1);  ///< Pull-Up/Pull-Down Enable at Port 1 Bit 1
        constexpr uint32_t PP0 = (1U << 0);  ///< Pull-Up/Pull-Down Enable at Port 1 Bit 0
    }

    /// P1_PUDSEL Register bits
    namespace p1_pudsel_bits {
        constexpr uint32_t PP4 = (1U << 4);  ///< Pull-Up/Pull-Down Select Port 1 Bit 4
        constexpr uint32_t PP2 = (1U << 2);  ///< Pull-Up/Pull-Down Select Port 1 Bit 2
        constexpr uint32_t PP1 = (1U << 1);  ///< Pull-Up/Pull-Down Select Port 1 Bit 1
        constexpr uint32_t PP0 = (1U << 0);  ///< Pull-Up/Pull-Down Select Port 1 Bit 0
    }

    /// P2_DATA Register bits
    namespace p2_data_bits {
        constexpr uint32_t PP7 = (1U << 7);  ///< Port 2 Pin 7 Data Value
        constexpr uint32_t PP3 = (1U << 3);  ///< Port 2 Pin 3 Data Value
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 2 Pin 2 Data Value
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 2 Pin 1 Data Value
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 2 Pin 0 Data Value
    }

    /// P2_DIR Register bits
    namespace p2_dir_bits {
        constexpr uint32_t PP7 = (1U << 7);  ///< Port 2 Pin 7 Driver Control
        constexpr uint32_t PP3 = (1U << 3);  ///< Port 2 Pin 3 Driver Control
        constexpr uint32_t PP2 = (1U << 2);  ///< Port 2 Pin 2 Driver Control
        constexpr uint32_t PP1 = (1U << 1);  ///< Port 2 Pin 1 Driver Control
        constexpr uint32_t PP0 = (1U << 0);  ///< Port 2 Pin 0 Driver Control
    }

    /// P2_PUDEN Register bits
    namespace p2_puden_bits {
        constexpr uint32_t PP7 = (1U << 7);  ///< Pull-Up/Pull-Down Enable at Port 2 Bit 7
        constexpr uint32_t PP3 = (1U << 3);  ///< Pull-Up/Pull-Down Enable at Port 2 Bit 3
        constexpr uint32_t PP2 = (1U << 2);  ///< Pull-Up/Pull-Down Enable at Port 2 Bit 2
        constexpr uint32_t PP1 = (1U << 1);  ///< Pull-Up/Pull-Down Enable at Port 2 Bit 1
        constexpr uint32_t PP0 = (1U << 0);  ///< Pull-Up/Pull-Down Enable at Port 2 Bit 0
    }

    /// P2_PUDSEL Register bits
    namespace p2_pudsel_bits {
        constexpr uint32_t PP7 = (1U << 7);  ///< Pull-Up/Pull-Down Select Port 2 Bit 7
        constexpr uint32_t PP3 = (1U << 3);  ///< Pull-Up/Pull-Down Select Port 2 Bit 3
        constexpr uint32_t PP2 = (1U << 2);  ///< Pull-Up/Pull-Down Select Port 2 Bit 2
        constexpr uint32_t PP1 = (1U << 1);  ///< Pull-Up/Pull-Down Select Port 2 Bit 1
        constexpr uint32_t PP0 = (1U << 0);  ///< Pull-Up/Pull-Down Select Port 2 Bit 0
    }

}

// ============================================================================
// SCU Peripheral
// ============================================================================

namespace scu {
    /// Base addresses
    constexpr uint32_t SCU_BASE = 0x50005000;

    /// SCU Register structure
    struct Registers {
        volatile uint32_t ADC1_CLK;  ///< Offset: 0x6C - ADC1 Peripheral Clock Register
        volatile uint32_t APCLK;  ///< Offset: 0x58 - Analog Peripheral Clock Register
        volatile uint32_t APCLK_CTRL;  ///< Offset: 0x54 - Analog Peripheral Clock Control Register
        volatile uint32_t APCLK_SCLR;  ///< Offset: 0x64 - Analog Peripheral Clock Status Clear Register
        volatile uint32_t APCLK_STS;  ///< Offset: 0x5C - Analog Peripheral Clock Status Register
        volatile uint32_t BCON1;  ///< Offset: 0x88 - Baud Rate Control Register 1
        volatile uint32_t BCON2;  ///< Offset: 0x98 - Baud Rate Control Register 2
        volatile uint32_t BG1;  ///< Offset: 0x90 - Baud Rate Timer/Reload Register
        volatile uint32_t BG2;  ///< Offset: 0xA0 - Baud Rate Timer/Reload Register
        volatile uint32_t BGL1;  ///< Offset: 0x8C - Baud Rate Timer/Reload Register, Low Byte 1
        volatile uint32_t BGL2;  ///< Offset: 0x9C - Baud Rate Timer/Reload Register, Low Byte 2
        volatile uint32_t BRDRV_CLK;  ///< Offset: 0x150 - ADC1 Peripheral Clock Register
        volatile uint32_t CMCON1;  ///< Offset: 0x48 - Clock Control Register 1
        volatile uint32_t CMCON2;  ///< Offset: 0x4C - Clock Control Register 2
        volatile uint32_t COCON;  ///< Offset: 0xB4 - Clock Output Control Register
        volatile uint32_t EDCCON;  ///< Offset: 0xD4 - Error Detection and Correction Control Register
        volatile uint32_t EDCSCLR;  ///< Offset: 0x10C - Error Detection and Correction Status Clear Register
        volatile uint32_t EDCSTAT;  ///< Offset: 0xD8 - Error Detection and Correction Status Register
        volatile uint32_t EXICON0;  ///< Offset: 0x28 - External Interrupt Control Register 0
        volatile uint32_t EXICON1;  ///< Offset: 0x2C - External Interrupt Control Register 1
        volatile uint32_t GPT12ICLR;  ///< Offset: 0x180 - Timer and Counter Control/Status Clear Register
        volatile uint32_t GPT12IEN;  ///< Offset: 0x15C - General Purpose Timer 12 Interrupt Enable Register
        volatile uint32_t GPT12IRC;  ///< Offset: 0x160 - Timer and Counter Control/Status Register
        volatile uint32_t GPT12PISEL;  ///< Offset: 0xD0 - GPT12 Peripheral Input Select Register
        volatile uint32_t ID;  ///< Offset: 0xA8 - Identity Register
        volatile uint32_t IEN0;  ///< Offset: 0x1C - Interrupt Enable Register 0
        volatile uint32_t IRCON0;  ///< Offset: 0x04 - Interrupt Request Register 0
        volatile uint32_t IRCON0CLR;  ///< Offset: 0x178 - Interrupt Request 0 Clear Register
        volatile uint32_t IRCON1;  ///< Offset: 0x08 - Interrupt Request Register 1
        volatile uint32_t IRCON1CLR;  ///< Offset: 0x17C - Interrupt Request 1 Clear Register
        volatile uint32_t IRCON2;  ///< Offset: 0x0C - Interrupt Request Register 2
        volatile uint32_t IRCON2CLR;  ///< Offset: 0x190 - Interrupt Request 2 Clear Register
        volatile uint32_t IRCON3;  ///< Offset: 0x10 - Interrupt Request Register 3
        volatile uint32_t IRCON3CLR;  ///< Offset: 0x194 - Interrupt Request 3 Clear Register
        volatile uint32_t IRCON4;  ///< Offset: 0x14 - Interrupt Request Register 4
        volatile uint32_t IRCON4CLR;  ///< Offset: 0x198 - Interrupt Request 4 Clear Register
        volatile uint32_t IRCON5;  ///< Offset: 0xF0 - Interrupt Request Register 5
        volatile uint32_t IRCON5CLR;  ///< Offset: 0x19C - Interrupt Request 5 Clear Register
        volatile uint32_t LINSCLR;  ///< Offset: 0xA4 - LIN Status Clear Register
        volatile uint32_t LINST;  ///< Offset: 0x94 - LIN Status Register
        volatile uint32_t MEM_ACC_STS;  ///< Offset: 0xE4 - Memory Access Status Register
        volatile uint32_t MEMSTAT;  ///< Offset: 0xDC - Memory Status Register
        volatile uint32_t MODIEN1;  ///< Offset: 0x30 - Peripheral Interrupt Enable Register 1
        volatile uint32_t MODIEN2;  ///< Offset: 0x34 - Peripheral Interrupt Enable Register 2
        volatile uint32_t MODIEN3;  ///< Offset: 0x38 - Peripheral Interrupt Enable Register 3
        volatile uint32_t MODIEN4;  ///< Offset: 0x3C - Peripheral Interrupt Enable Register 4
        volatile uint32_t MODPISEL;  ///< Offset: 0xB8 - Peripheral Input Select Register
        volatile uint32_t MODPISEL1;  ///< Offset: 0xBC - Peripheral Input Select Register 1
        volatile uint32_t MODPISEL2;  ///< Offset: 0xC0 - Peripheral Input Select Register 2
        volatile uint32_t MODPISEL3;  ///< Offset: 0xC4 - Peripheral Input Select Register 3
        volatile uint32_t MODPISEL4;  ///< Offset: 0xFC - Peripheral Input Select Register 4
        volatile uint32_t MODSUSP;  ///< Offset: 0xC8 - Module Suspend Control Register
        volatile uint32_t MONIEN;  ///< Offset: 0x18C - Monitoring Input Interrupt Enable Register
        volatile uint32_t NMICON;  ///< Offset: 0x24 - NMI Control Register
        volatile uint32_t NMISR;  ///< Offset: 0x18 - NMI Status Register
        volatile uint32_t NMISRCLR;  ///< Offset: 0x00 - NMI Status Clear Register
        volatile uint32_t NVM_PROT_STS;  ///< Offset: 0xE0 - NVM Protection Status Register
        volatile uint32_t OSC_CON;  ///< Offset: 0xB0 - OSC Control Register
        volatile uint32_t P0_POCON0;  ///< Offset: 0xE8 - Port Output Control Register
        volatile uint32_t P1_POCON0;  ///< Offset: 0xF8 - Port Output Control Register
        volatile uint32_t PASSWD;  ///< Offset: 0xAC - Password Register
        volatile uint32_t PLL_CON;  ///< Offset: 0x44 - PLL Control Register
        volatile uint32_t PMCON;  ///< Offset: 0x60 - Peripheral Management Control Register
        volatile uint32_t PMCON0;  ///< Offset: 0x40 - Power Mode Control Register 0
        volatile uint32_t RSTCON;  ///< Offset: 0x68 - Reset Control Register
        volatile uint32_t STACK_OVF_ADDR;  ///< Offset: 0x148 - Stack Overflow Control Register
        volatile uint32_t STACK_OVF_CTRL;  ///< Offset: 0x144 - Stack Overflow Control Register
        volatile uint32_t STACK_OVF_STS;  ///< Offset: 0x14C - Stack Overflow Status Register
        volatile uint32_t STACK_OVFCLR;  ///< Offset: 0x12C - Stack Overflow Status Clear Register
        volatile uint32_t SYS_STRTUP_STS;  ///< Offset: 0x74 - System Startup Status Register
        volatile uint32_t SYSCON0;  ///< Offset: 0x70 - System Control Register 0
        volatile uint32_t TCCR;  ///< Offset: 0xF4 - Temperature Compensation Control Register
        volatile uint32_t VTOR;  ///< Offset: 0x20 - Vector Table Reallocation Register
        volatile uint32_t WAKECON;  ///< Offset: 0xEC - Wakeup Interrupt Control Register
        volatile uint32_t WDT;  ///< Offset: 0x80 - Watchdog Timer
        volatile uint32_t WDTCON;  ///< Offset: 0x50 - Watchdog Timer Control Register
        volatile uint32_t WDTREL;  ///< Offset: 0x78 - Watchdog Timer Reload Register
        volatile uint32_t WDTWINB;  ///< Offset: 0x7C - Watchdog Window-Boundary Count
        volatile uint32_t XTAL_CTRL;  ///< Offset: 0x100 - Peripheral Input Select Register
    };

    /// Peripheral instances
    inline Registers* SCU = reinterpret_cast<Registers*>(SCU_BASE);

    // Bit definitions
    /// ADC1_CLK Register bits
    namespace adc1_clk_bits {
        constexpr uint32_t DPP1_CLK_DIV = (2 << 8);  ///< ADC1 Post processing clock divider
        constexpr uint32_t ADC1_CLK_DIV = (4 << 0);  ///< ADC1 Clock divider
    }

    /// APCLK Register bits
    namespace apclk_bits {
        constexpr uint32_t CPCLK_DIV = (1U << 29);  ///< Charge Pump Clock Divider
        constexpr uint32_t CPCLK_SEL = (1U << 28);  ///< Charge Pump Clock Selection
        constexpr uint32_t BGCLK_DIV = (1U << 25);  ///< Bandgap Clock Divider
        constexpr uint32_t BGCLK_SEL = (1U << 24);  ///< Bandgap Clock Selection
        constexpr uint32_t APCLK2FAC = (5 << 8);  ///< Slow Down Clock Divider for TFILT_CLK Generation
        constexpr uint32_t APCLK1FAC = (2 << 0);  ///< Analog Module Clock Factor
    }

    /// APCLK_CTRL Register bits
    namespace apclk_ctrl_bits {
        constexpr uint32_t CLKWDT_IE = (1U << 8);  ///< Clock Watchdog Interrupt Enable
        constexpr uint32_t APCLK_SET = (1U << 0);  ///< Set and Overtake Flag for Clock Settings
    }

    /// APCLK_SCLR Register bits
    namespace apclk_sclr_bits {
        constexpr uint32_t APCLK3SCLR = (1U << 16);  ///< Analog Peripherals Clock 3 Status Clear
        constexpr uint32_t APCLK2SCLR = (1U << 8);  ///< Analog Peripherals Clock Status Clear
        constexpr uint32_t APCLK1SCLR = (1U << 0);  ///< Analog Peripherals Clock Status Clear
    }

    /// APCLK_STS Register bits
    namespace apclk_sts_bits {
        constexpr uint32_t PLL_LOCK = (1U << 24);  ///< PLL LOCK Status
        constexpr uint32_t BRDRV_CLK_ERR_STS = (1U << 20);  ///< BRDRV CLK Error Status
        constexpr uint32_t APCLK3STS = (1U << 16);  ///< Loss of Clock Status
        constexpr uint32_t APCLK2STS = (2 << 8);  ///< Analog Peripherals Clock Status
        constexpr uint32_t APCLK_ERR_STS = (1U << 4);  ///< APCLK Error Status
        constexpr uint32_t APCLK1STS = (2 << 0);  ///< Analog Peripherals Clock Status
    }

    /// BCON1 Register bits
    namespace bcon1_bits {
        constexpr uint32_t BR1_PRE = (3 << 1);  ///< Prescaler Bit
        constexpr uint32_t BR1_R = (1U << 0);  ///< Baud Rate Generator Run Control Bit
    }

    /// BCON2 Register bits
    namespace bcon2_bits {
        constexpr uint32_t BR2_PRE = (3 << 1);  ///< Prescaler Bit
        constexpr uint32_t BR2_R = (1U << 0);  ///< Baud Rate Generator Run Control Bit
    }

    /// BG1 Register bits
    namespace bg1_bits {
        constexpr uint32_t BG1_TIM_VALUE = (11 << 16);  ///< Baud Rate Timer Value
        constexpr uint32_t BG1_BR_VALUE = (11 << 0);  ///< Baud Rate Reload Value
    }

    /// BG2 Register bits
    namespace bg2_bits {
        constexpr uint32_t BG2_TIM_VALUE = (11 << 16);  ///< Baud Rate Timer Value
        constexpr uint32_t BG2_BR_VALUE = (11 << 0);  ///< Baud Rate Reload Value
    }

    /// BGL1 Register bits
    namespace bgl1_bits {
        constexpr uint32_t BG1_FD_SEL = (5 << 0);  ///< Fractional Divider Selection
    }

    /// BGL2 Register bits
    namespace bgl2_bits {
        constexpr uint32_t BG2_FD_SEL = (5 << 0);  ///< Fractional Divider Selection
    }

    /// BRDRV_CLK Register bits
    namespace brdrv_clk_bits {
        constexpr uint32_t BRDRV_TFILT_DIV = (5 << 8);  ///< Slow Down Clock Divider for TFILT_CLK Generation
        constexpr uint32_t BRDRV_CLK_DIV = (2 << 0);  ///< Analog Module Clock Factorf
    }

    /// CMCON1 Register bits
    namespace cmcon1_bits {
        constexpr uint32_t PDIV = (6 << 8);  ///< PLL PDIV-Divider:
        constexpr uint32_t K1DIV = (1U << 7);  ///< PLL K1-Divider
        constexpr uint32_t K2DIV = (3 << 4);  ///< PLL K2-Divider
        constexpr uint32_t CLKREL = (4 << 0);  ///< Slow Down Clock Divider for fCCLK Generation
    }

    /// CMCON2 Register bits
    namespace cmcon2_bits {
        constexpr uint32_t PBA0CLKREL = (1U << 0);  ///< PBA0 Clock Divider
    }

    /// COCON Register bits
    namespace cocon_bits {
        constexpr uint32_t EN = (1U << 7);  ///< CLKOUT Enable
        constexpr uint32_t COUTS1 = (1U << 6);  ///< Clock Out Source Select Bit 1
        constexpr uint32_t TLEN = (1U << 5);  ///< Toggle Latch Enable
        constexpr uint32_t COUTS0 = (1U << 4);  ///< Clock Out Source Select Bit 0
        constexpr uint32_t COREL = (4 << 0);  ///< Clock Output Divider
    }

    /// EDCCON Register bits
    namespace edccon_bits {
        constexpr uint32_t NVMIE = (1U << 2);  ///< NVM Double Bit ECC Error Interrupt Enable
        constexpr uint32_t RIE = (1U << 0);  ///< RAM Double Bit ECC Error Interrupt Enable
    }

    /// EDCSCLR Register bits
    namespace edcsclr_bits {
        constexpr uint32_t RSBEC = (1U << 4);  ///< RAM Single Bit Error Clear
        constexpr uint32_t NVMDBEC = (1U << 2);  ///< NVM Double Bit Error Clear
        constexpr uint32_t RDBEC = (1U << 0);  ///< RAM Double Bit Error Clear
    }

    /// EDCSTAT Register bits
    namespace edcstat_bits {
        constexpr uint32_t RSBE = (1U << 4);  ///< RAM Single Bit Error
        constexpr uint32_t NVMDBE = (1U << 2);  ///< NVM Double Bit Error
        constexpr uint32_t RDBE = (1U << 0);  ///< RAM Double Bit Error
    }

    /// EXICON0 Register bits
    namespace exicon0_bits {
        constexpr uint32_t EXINT2 = (2 << 4);  ///< External Interrupt 2 Trigger Select
        constexpr uint32_t EXINT1 = (2 << 2);  ///< External Interrupt 1 Trigger Select
        constexpr uint32_t EXINT0 = (2 << 0);  ///< External Interrupt 0 Trigger Select
    }

    /// EXICON1 Register bits
    namespace exicon1_bits {
        constexpr uint32_t MON4 = (2 << 6);  ///< MON4 Input Trigger Select
        constexpr uint32_t MON3 = (2 << 4);  ///< MON3 Input Trigger Select
        constexpr uint32_t MON2 = (2 << 2);  ///< MON2 Input Trigger Select
        constexpr uint32_t MON1 = (2 << 0);  ///< MON1 Input Trigger Select
    }

    /// GPT12ICLR Register bits
    namespace gpt12iclr_bits {
        constexpr uint32_t GPT12CRC = (1U << 5);  ///< GPT Module 1 Capture Reload Interrupt Status
        constexpr uint32_t GPT2T6C = (1U << 4);  ///< GPT Module 2Timer6 Interrupt Status
        constexpr uint32_t GPT2T5C = (1U << 3);  ///< GPT Module 2 Timer5 Interrupt Status
        constexpr uint32_t GPT1T4C = (1U << 2);  ///< GPT Module 1 Timer4 Interrupt Status
        constexpr uint32_t GPT1T3C = (1U << 1);  ///< GPT Module 1 Timer3 Interrupt Status
        constexpr uint32_t GPT1T2C = (1U << 0);  ///< GPT Module 1 Timer 2 Interrupt Status
    }

    /// GPT12IEN Register bits
    namespace gpt12ien_bits {
        constexpr uint32_t CRIE = (1U << 5);  ///< General Purpose Timer 12 Capture and Reload Interrupt Enable
        constexpr uint32_t T6IE = (1U << 4);  ///< General Purpose Timer 12 T6 Interrupt Enable
        constexpr uint32_t T5IE = (1U << 3);  ///< General Purpose Timer 12 T5 Interrupt Enable
        constexpr uint32_t T4IE = (1U << 2);  ///< General Purpose Timer 12 T4 Interrupt Enable
        constexpr uint32_t T3IE = (1U << 1);  ///< General Purpose Timer 12 T3 Interrupt Enable
        constexpr uint32_t T2IE = (1U << 0);  ///< General Purpose Timer 12 T2 Interrupt Enable
    }

    /// GPT12IRC Register bits
    namespace gpt12irc_bits {
        constexpr uint32_t GPT12CR = (1U << 5);  ///< GPT Module 1 Capture Reload Interrupt Status
        constexpr uint32_t GPT2T6 = (1U << 4);  ///< GPT Module 2Timer6 Interrupt Status
        constexpr uint32_t GPT2T5 = (1U << 3);  ///< GPT Module 2 Timer5 Interrupt Status
        constexpr uint32_t GPT1T4 = (1U << 2);  ///< GPT Module 1 Timer4 Interrupt Status
        constexpr uint32_t GPT1T3 = (1U << 1);  ///< GPT Module 1 Timer3 Interrupt Status
        constexpr uint32_t GPT1T2 = (1U << 0);  ///< GPT Module 1 Timer 2 Interrupt Status
    }

    /// GPT12PISEL Register bits
    namespace gpt12pisel_bits {
        constexpr uint32_t GPT12_SEL = (1U << 5);  ///< CCU6 Trigger Configuration.
        constexpr uint32_t TRIG_CONF = (1U << 4);  ///< CCU6 Trigger Configuration.
        constexpr uint32_t GPT12 = (4 << 0);  ///< GPT12 TIN3B / TIN4D Input Select
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t PRODID = (5 << 3);  ///< Product ID
        constexpr uint32_t VERID = (3 << 0);  ///< Version ID
    }

    /// IEN0 Register bits
    namespace ien0_bits {
        constexpr uint32_t EA = (1U << 31);  ///< Global Interrupt Mask
    }

    /// IRCON0 Register bits
    namespace ircon0_bits {
        constexpr uint32_t EXINT2F = (1U << 5);  ///< Interrupt Flag for External Interrupt 2x on falling edge
        constexpr uint32_t EXINT2R = (1U << 4);  ///< Interrupt Flag for External Interrupt 2x on rising edge
        constexpr uint32_t EXINT1F = (1U << 3);  ///< Interrupt Flag for External Interrupt 1x on falling edge
        constexpr uint32_t EXINT1R = (1U << 2);  ///< Interrupt Flag for External Interrupt 1x on rising edge
        constexpr uint32_t EXINT0F = (1U << 1);  ///< Interrupt Flag for External Interrupt 0x on falling edge
        constexpr uint32_t EXINT0R = (1U << 0);  ///< Interrupt Flag for External Interrupt 0x on rising edge
    }

    /// IRCON0CLR Register bits
    namespace ircon0clr_bits {
        constexpr uint32_t EXINT2FC = (1U << 5);  ///< Interrupt Flag for External Interrupt 2x on falling edge
        constexpr uint32_t EXINT2RC = (1U << 4);  ///< Interrupt Flag for External Interrupt 2x on rising edge
        constexpr uint32_t EXINT1FC = (1U << 3);  ///< Interrupt Flag for External Interrupt 1x on falling edge
        constexpr uint32_t EXINT1RC = (1U << 2);  ///< Interrupt Flag for External Interrupt 1x on rising edge
        constexpr uint32_t EXINT0FC = (1U << 1);  ///< Interrupt Flag for External Interrupt 0x on falling edge
        constexpr uint32_t EXINT0RC = (1U << 0);  ///< Interrupt Flag for External Interrupt 0x on rising edge
    }

    /// IRCON1 Register bits
    namespace ircon1_bits {
        constexpr uint32_t MON4F = (1U << 7);  ///< Interrupt Flag for MON4x on falling edge
        constexpr uint32_t MON4R = (1U << 6);  ///< Interrupt Flag for MON4x on rising edge
        constexpr uint32_t MON3F = (1U << 5);  ///< Interrupt Flag for MON3x on falling edge
        constexpr uint32_t MON3R = (1U << 4);  ///< Interrupt Flag for MON3x on rising edge
        constexpr uint32_t MON2F = (1U << 3);  ///< Interrupt Flag for MON2x on falling edge
        constexpr uint32_t MON2R = (1U << 2);  ///< Interrupt Flag for MON2x on rising edge
        constexpr uint32_t MON1F = (1U << 1);  ///< Interrupt Flag for MON1x on falling edge
        constexpr uint32_t MON1R = (1U << 0);  ///< Interrupt Flag for MON1x on rising edge
    }

    /// IRCON1CLR Register bits
    namespace ircon1clr_bits {
        constexpr uint32_t MON4FC = (1U << 7);  ///< Interrupt Flag for MON4x on falling edge
        constexpr uint32_t MON4RC = (1U << 6);  ///< Interrupt Flag for MON4x on rising edge
        constexpr uint32_t MON3FC = (1U << 5);  ///< Interrupt Flag for MON3x on falling edge
        constexpr uint32_t MON3RC = (1U << 4);  ///< Interrupt Flag for MON3x on rising edge
        constexpr uint32_t MON2FC = (1U << 3);  ///< Interrupt Flag for MON2x on falling edge
        constexpr uint32_t MON2RC = (1U << 2);  ///< Interrupt Flag for MON2x on rising edge
        constexpr uint32_t MON1FC = (1U << 1);  ///< Interrupt Flag for MON1x on falling edge
        constexpr uint32_t MON1RC = (1U << 0);  ///< Interrupt Flag for MON1x on rising edge
    }

    /// IRCON2 Register bits
    namespace ircon2_bits {
        constexpr uint32_t RIR1 = (1U << 2);  ///< Receive Interrupt Flag for SSC1
        constexpr uint32_t TIR1 = (1U << 1);  ///< Transmit Interrupt Flag for SSC1
        constexpr uint32_t EIR1 = (1U << 0);  ///< Error Interrupt Flag for SSC1
    }

    /// IRCON2CLR Register bits
    namespace ircon2clr_bits {
        constexpr uint32_t RIR1C = (1U << 2);  ///< Receive Interrupt Flag for SSC1
        constexpr uint32_t TIR1C = (1U << 1);  ///< Transmit Interrupt Flag for SSC1
        constexpr uint32_t EIR1C = (1U << 0);  ///< Error Interrupt Flag for SSC1
    }

    /// IRCON3 Register bits
    namespace ircon3_bits {
        constexpr uint32_t RIR2 = (1U << 2);  ///< Receive Interrupt Flag for SSC2
        constexpr uint32_t TIR2 = (1U << 1);  ///< Transmit Interrupt Flag for SSC2
        constexpr uint32_t EIR2 = (1U << 0);  ///< Error Interrupt Flag for SSC2
    }

    /// IRCON3CLR Register bits
    namespace ircon3clr_bits {
        constexpr uint32_t RIR2C = (1U << 2);  ///< Receive Interrupt Flag for SSC2
        constexpr uint32_t TIR2C = (1U << 1);  ///< Transmit Interrupt Flag for SSC2
        constexpr uint32_t EIR2C = (1U << 0);  ///< Error Interrupt Flag for SSC2
    }

    /// IRCON4 Register bits
    namespace ircon4_bits {
        constexpr uint32_t CCU6SR3 = (1U << 20);  ///< Interrupt Flag 1 for CCU6
        constexpr uint32_t CCU6SR2 = (1U << 16);  ///< Interrupt Flag 1 for CCU6
        constexpr uint32_t CCU6SR1 = (1U << 4);  ///< Interrupt Flag 1 for CCU6
        constexpr uint32_t CCU6SR0 = (1U << 0);  ///< Interrupt Flag 1 for CCU6
    }

    /// IRCON4CLR Register bits
    namespace ircon4clr_bits {
        constexpr uint32_t CCU6SR3C = (1U << 20);  ///< Interrupt Flag 1 for CCU6
        constexpr uint32_t CCU6SR2C = (1U << 16);  ///< Interrupt Flag 1 for CCU6
        constexpr uint32_t CCU6SR1C = (1U << 4);  ///< Interrupt Flag 1 for CCU6
        constexpr uint32_t CCU6SR0C = (1U << 0);  ///< Interrupt Flag 1 for CCU6
    }

    /// IRCON5 Register bits
    namespace ircon5_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Interrupt Flag for Wakeup
    }

    /// IRCON5CLR Register bits
    namespace ircon5clr_bits {
        constexpr uint32_t WAKEUPC = (1U << 0);  ///< Clear Flag for Wakeup Interrupt
    }

    /// LINSCLR Register bits
    namespace linsclr_bits {
        constexpr uint32_t ERRSYNC = (1U << 5);  ///< SYN Byte Error Interrupt Flag
        constexpr uint32_t EOFSYNC = (1U << 4);  ///< End of SYN Byte Interrupt Flag Clear
        constexpr uint32_t BRKC = (1U << 3);  ///< Break Field Flag Clear
    }

    /// LINST Register bits
    namespace linst_bits {
        constexpr uint32_t SYNEN = (1U << 6);  ///< End of SYN Byte and SYN Byte Error Interrupts Enable
        constexpr uint32_t ERRSYN = (1U << 5);  ///< SYN Byte Error Interrupt Flag
        constexpr uint32_t EOFSYN = (1U << 4);  ///< End of SYN Byte Interrupt Flag
        constexpr uint32_t BRK = (1U << 3);  ///< Break Field Flag
        constexpr uint32_t BGSEL = (2 << 1);  ///< Baud Rate Select for Detection
        constexpr uint32_t BRDIS = (1U << 0);  ///< Baud Rate Detection Disable
    }

    /// MEM_ACC_STS Register bits
    namespace mem_acc_sts_bits {
        constexpr uint32_t ROM_PROT_ERR = (1U << 4);  ///< ROM Access Protection
        constexpr uint32_t NVM_SFR_ADDR_ERR = (1U << 3);  ///< NVM SFR Address Protection
        constexpr uint32_t NVM_SFR_PROT_ERR = (1U << 2);  ///< NVM SFR Access Protection
        constexpr uint32_t NVM_ADDR_ERR = (1U << 1);  ///< NVM Address Protection
        constexpr uint32_t NVM_PROT_ERR = (1U << 0);  ///< NVM Access Protection
    }

    /// MEMSTAT Register bits
    namespace memstat_bits {
        constexpr uint32_t RAM_TEST_MODE = (1U << 22);  ///< RAM Data Mode
        constexpr uint32_t RAM_VAL_KEYS = (2 << 20);  ///< RAM valid keys
        constexpr uint32_t NVM_DATA_MODE = (1U << 18);  ///< NVM Data Mode
        constexpr uint32_t NVM_VAL_KEYS = (2 << 16);  ///< NVM valid keys
        constexpr uint32_t SASTATUS = (2 << 6);  ///< Service Algorithm Status
        constexpr uint32_t SECTORINFO = (6 << 0);  ///< Sector Information
    }

    /// MODIEN1 Register bits
    namespace modien1_bits {
        constexpr uint32_t RIREN2 = (1U << 10);  ///< SSC 2 Receive Interrupt Enable
        constexpr uint32_t TIREN2 = (1U << 9);  ///< SSC 2 Transmit Interrupt Enable
        constexpr uint32_t EIREN2 = (1U << 8);  ///< SSC 2 Error Interrupt Enable
        constexpr uint32_t RIREN1 = (1U << 2);  ///< SSC 1 Receive Interrupt Enable
        constexpr uint32_t TIREN1 = (1U << 1);  ///< SSC 1 Transmit Interrupt Enable
        constexpr uint32_t EIREN1 = (1U << 0);  ///< SSC 1 Error Interrupt Enable
    }

    /// MODIEN2 Register bits
    namespace modien2_bits {
        constexpr uint32_t TIEN2 = (1U << 7);  ///< UART 2 Transmit Interrupt Enable
        constexpr uint32_t RIEN2 = (1U << 6);  ///< UART 2 Receive Interrupt Enable
        constexpr uint32_t EXINT2_EN = (1U << 5);  ///< External Interrupt 2 Enable
        constexpr uint32_t TIEN1 = (1U << 1);  ///< UART 1 Transmit Interrupt Enable
        constexpr uint32_t RIEN1 = (1U << 0);  ///< UART 1 Receive Interrupt Enable
    }

    /// MODIEN3 Register bits
    namespace modien3_bits {
        constexpr uint32_t IE0 = (1U << 0);  ///< External Interrupt Enable
    }

    /// MODIEN4 Register bits
    namespace modien4_bits {
        constexpr uint32_t IE1 = (1U << 0);  ///< External Interrupt Enable
    }

    /// MODPISEL Register bits
    namespace modpisel_bits {
        constexpr uint32_t SSC12_S_MRST_OUTSEL = (1U << 18);  ///< Output selection for SSC12_S_MRST
        constexpr uint32_t SSC12_M_MTSR_OUTSEL = (1U << 17);  ///< Output selection for SSC12_M_MTSR
        constexpr uint32_t SSC12_M_SCK_OUTSEL = (1U << 16);  ///< Output selection for SSC12_M_SCK
        constexpr uint32_t U_TX_CONDIS = (1U << 7);  ///< UART1 TxD Connection Disable
        constexpr uint32_t URIOS1 = (1U << 6);  ///< UART1 Input/Output Select
        constexpr uint32_t EXINT2IS = (2 << 4);  ///< External Interrupt 2 Input Select
        constexpr uint32_t EXINT1IS = (2 << 2);  ///< External Interrupt 1 Input Select
        constexpr uint32_t EXINT0IS = (2 << 0);  ///< External Interrupt 0 Input Select
    }

    /// MODPISEL1 Register bits
    namespace modpisel1_bits {
        constexpr uint32_t T21EXCON = (1U << 7);  ///< Timer 21 External Input Control
        constexpr uint32_t T2EXCON = (1U << 6);  ///< Timer 2 External Input Control
    }

    /// MODPISEL2 Register bits
    namespace modpisel2_bits {
        constexpr uint32_t T21EXISCNF = (2 << 10);  ///< Timer 21 External Input Select Configuration
        constexpr uint32_t T2EXISCNF = (2 << 8);  ///< Timer 2 External Input Select Configuration
        constexpr uint32_t T21EXIS = (2 << 6);  ///< Timer 21 External Input Select
        constexpr uint32_t T2EXIS = (2 << 4);  ///< Timer 2 External Input Select
        constexpr uint32_t T21IS = (2 << 2);  ///< Timer 21 Input Select
        constexpr uint32_t T2IS = (2 << 0);  ///< Timer 2 Input Select
    }

    /// MODPISEL3 Register bits
    namespace modpisel3_bits {
        constexpr uint32_t URIOS2 = (1U << 6);  ///< UART2 Input/Output Select
    }

    /// MODPISEL4 Register bits
    namespace modpisel4_bits {
        constexpr uint32_t DU4TRIGGEN = (3 << 24);  ///< Differential Unit Trigger Enable
        constexpr uint32_t DU3TRIGGEN = (3 << 16);  ///< Differential Unit Trigger Enable
        constexpr uint32_t DU2TRIGGEN = (3 << 8);  ///< Differential Unit Trigger Enable
        constexpr uint32_t DU1TRIGGEN = (3 << 0);  ///< Differential Unit Trigger Enable
    }

    /// MODSUSP Register bits
    namespace modsusp_bits {
        constexpr uint32_t ADC1_SUSP = (1U << 10);  ///< ADC1 Unit Debug Suspend Bit
        constexpr uint32_t MU_SUSP = (1U << 9);  ///< Measurement Unit Debug Suspend Bit
        constexpr uint32_t WDT1SUSP = (1U << 7);  ///< Watchdog Timer 1 Debug Suspend Bit
        constexpr uint32_t T21_SUSP = (1U << 6);  ///< Timer21 Debug Suspend Bit
        constexpr uint32_t GPT12_SUSP = (1U << 4);  ///< GPT12 Debug Suspend Bit
        constexpr uint32_t T2_SUSP = (1U << 3);  ///< Timer2 Debug Suspend Bit
        constexpr uint32_t T13SUSP = (1U << 2);  ///< Timer 13 Debug Suspend Bit
        constexpr uint32_t T12SUSP = (1U << 1);  ///< Timer 12 Debug Suspend Bit
        constexpr uint32_t WDTSUSP = (1U << 0);  ///< SCU Watchdog Timer Debug Suspend Bit
    }

    /// MONIEN Register bits
    namespace monien_bits {
        constexpr uint32_t MON4IE = (1U << 3);  ///< MON 4 Interrupt Enable
        constexpr uint32_t MON3IE = (1U << 2);  ///< MON 3 Interrupt Enable
        constexpr uint32_t MON2IE = (1U << 1);  ///< MON 2 Interrupt Enable
        constexpr uint32_t MON1IE = (1U << 0);  ///< MON 1 Interrupt Enable
    }

    /// NMICON Register bits
    namespace nmicon_bits {
        constexpr uint32_t NMISTOF = (1U << 8);  ///< Stack Overflow NMI Enable
        constexpr uint32_t NMISUP = (1U << 7);  ///< Supply Prewarning NMI Enable
        constexpr uint32_t NMIECC = (1U << 6);  ///< ECC Error NMI Enable
        constexpr uint32_t NMIMAP = (1U << 5);  ///< NVM Map Error NMI Enable
        constexpr uint32_t NMIOWD = (1U << 4);  ///< Oscillator Watchdog NMI Enable
        constexpr uint32_t NMIOT = (1U << 3);  ///< NMI OT Enable
        constexpr uint32_t NMIPLL = (1U << 1);  ///< PLL Loss of Lock NMI Enable
        constexpr uint32_t NMIWDT = (1U << 0);  ///< Watchdog Timer NMI Enable
    }

    /// NMISR Register bits
    namespace nmisr_bits {
        constexpr uint32_t FNMISTOF = (1U << 8);  ///< Stack Overflow NMI Flag
        constexpr uint32_t FNMISUP = (1U << 7);  ///< Supply Prewarning NMI Flag
        constexpr uint32_t FNMIECC = (1U << 6);  ///< ECC Error NMI Flag
        constexpr uint32_t FNMIMAP = (1U << 5);  ///< NVM Map Error NMI Flag
        constexpr uint32_t FNMIOWD = (1U << 4);  ///< Oscillator Watchdog NMI Flag
        constexpr uint32_t FNMIOT = (1U << 3);  ///< Overtemperature NMI Flag
        constexpr uint32_t FNMIPLL = (1U << 1);  ///< PLL NMI Flag
        constexpr uint32_t FNMIWDT = (1U << 0);  ///< Watchdog Timer NMI Flag
    }

    /// NMISRCLR Register bits
    namespace nmisrclr_bits {
        constexpr uint32_t FNMIMAPC = (1U << 5);  ///< NVM Map Error NMI Flag
        constexpr uint32_t FNMIOWDC = (1U << 4);  ///< Oscillator Watchdog NMI Flag
        constexpr uint32_t FNMIPLLC = (1U << 1);  ///< PLL NMI Flag
        constexpr uint32_t FNMIWDTC = (1U << 0);  ///< Watchdog Timer NMI Flag
    }

    /// NVM_PROT_STS Register bits
    namespace nvm_prot_sts_bits {
        constexpr uint32_t DAT_LIN_SIZE = (2 << 26);  ///< Data linear Region Size Definition
        constexpr uint32_t CUS_BSL_SIZE = (2 << 24);  ///< CBSL Region Size Definition
        constexpr uint32_t DAT_NL_PW = (1U << 22);  ///< Status of Non-Linear Region Password / Protection
        constexpr uint32_t DAT_LIN_PW = (1U << 21);  ///< Status of Data linear Region Password / Protection
        constexpr uint32_t COD_LIN_PW = (1U << 20);  ///< Status of Linear Region Password / Protection
        constexpr uint32_t CUS_BSL_PW = (1U << 19);  ///< Status of CBSL Region Password / Protection
        constexpr uint32_t DIS_RDUS_S0 = (1U << 18);  ///< Configuration of NVM Read Protection for Sector 0 with EN_RD_S0 = 0
        constexpr uint32_t DIS_RDUS = (1U << 17);  ///< Configuration of NVM Read Protection for Sector 1...n with EN_RD_* = 0
        constexpr uint32_t EN_RD_S0 = (1U << 16);  ///< NVM Read Protection for Sector 0
        constexpr uint32_t EN_PRG_DAT_NL = (1U << 7);  ///< NVM Protection of Data in Non-Linear Data Sectors
        constexpr uint32_t EN_RD_DAT_NL = (1U << 6);  ///< NVM Read Protection of Data in Non-Linear Data Sectors
        constexpr uint32_t EN_PRG_DAT_LIN = (1U << 5);  ///< NVM Protection of Data in Linear Data Sectors
        constexpr uint32_t EN_RD_DAT_LIN = (1U << 4);  ///< NVM Read Protection of Data in Linear Data Sectors
        constexpr uint32_t EN_PRG_COD_LIN = (1U << 3);  ///< NVM Protection of Data in Linear Code Sectors
        constexpr uint32_t EN_RD_COD_LIN = (1U << 2);  ///< NVM Read Protection of Data in Linear Code Sectors
        constexpr uint32_t EN_PRG_CUS_BSL = (1U << 1);  ///< NVM Protection of Data in Customer BSL Region
        constexpr uint32_t EN_RD_CUS_BSL = (1U << 0);  ///< NVM Read Protection of Data in Customer BSL Region
    }

    /// OSC_CON Register bits
    namespace osc_con_bits {
        constexpr uint32_t XPD = (1U << 4);  ///< XTAL (OSC_HP) Power Down Control
        constexpr uint32_t OSC2L = (1U << 3);  ///< OSC-Too-Low Condition Flag
        constexpr uint32_t OSCWDTRST = (1U << 2);  ///< Oscillator Watchdog Reset
        constexpr uint32_t OSCSS = (2 << 0);  ///< Oscillator Source Select
    }

    /// P0_POCON0 Register bits
    namespace p0_pocon0_bits {
        constexpr uint32_t P0_PDM6 = (3 << 24);  ///< P0.6 Port Driver Mode
        constexpr uint32_t P0_PDM5 = (3 << 20);  ///< P0.5 Port Driver Mode
        constexpr uint32_t P0_PDM4 = (3 << 16);  ///< P0.4 Port Driver Mode
        constexpr uint32_t P0_PDM3 = (3 << 12);  ///< P0.3 Port Driver Mode
        constexpr uint32_t P0_PDM2 = (3 << 8);  ///< P0.2 Port Driver Mode
        constexpr uint32_t P0_PDM1 = (3 << 4);  ///< P0.1 Port Driver Mode
        constexpr uint32_t P0_PDM0 = (3 << 0);  ///< P0.0 Port Driver Mode
    }

    /// P1_POCON0 Register bits
    namespace p1_pocon0_bits {
        constexpr uint32_t P1_PDM4 = (3 << 16);  ///< P1.4 Port Driver Mode
        constexpr uint32_t P1_PDM2 = (3 << 8);  ///< P1.2 Port Driver Mode
        constexpr uint32_t P1_PDM1 = (3 << 4);  ///< P1.1 Port Driver Mode
        constexpr uint32_t P1_PDM0 = (3 << 0);  ///< P1.0 Port Driver Mode
    }

    /// PASSWD Register bits
    namespace passwd_bits {
        constexpr uint32_t PASS = (5 << 3);  ///< Password Bits
        constexpr uint32_t PROTECT_S = (1U << 2);  ///< Bit-Protection Signal Status Bit
        constexpr uint32_t PW_MODE = (2 << 0);  ///< Bit-Protection Scheme Control Bit
    }

    /// PLL_CON Register bits
    namespace pll_con_bits {
        constexpr uint32_t UNPROT_VCOBYP = (1U << 19);  ///< Unprotect write access of VCO_BYP
        constexpr uint32_t UNPROT_OSCDISC = (1U << 18);  ///< Unprotect write access of OSC_DISC
        constexpr uint32_t NDIV = (8 << 8);  ///< PLL N-Divider
        constexpr uint32_t VCOBYP = (1U << 3);  ///< PLL VCO Bypass Mode Select
        constexpr uint32_t OSCDISC = (1U << 2);  ///< Oscillator Disconnect
        constexpr uint32_t RESLD = (1U << 1);  ///< Restart Lock Detection
        constexpr uint32_t LOCK = (1U << 0);  ///< PLL Lock Status Flag
    }

    /// PMCON Register bits
    namespace pmcon_bits {
        constexpr uint32_t T21_DIS = (1U << 10);  ///< T21 Disable Request. Active high.
        constexpr uint32_t SSC2_DIS = (1U << 8);  ///< SSC Disable Request. Active high.
        constexpr uint32_t GPT12_DIS = (1U << 4);  ///< General Purpose Timer 12 Disable Request. Active high.
        constexpr uint32_t T2_DIS = (1U << 3);  ///< T2 Disable Request. Active high.
        constexpr uint32_t CCU_DIS = (1U << 2);  ///< CCU Disable Request. Active high.
        constexpr uint32_t SSC1_DIS = (1U << 1);  ///< SSC Disable Request. Active high.
        constexpr uint32_t ADC1_DIS = (1U << 0);  ///< ADC1 Disable Request. Active high.
    }

    /// PMCON0 Register bits
    namespace pmcon0_bits {
        constexpr uint32_t SD = (1U << 3);  ///< Slow Down Mode Enable. Active High.
        constexpr uint32_t PD = (1U << 2);  ///< Power Down Mode Enable. Active High.
        constexpr uint32_t SL = (1U << 1);  ///< Sleep Mode Enable. Active High.
        constexpr uint32_t XTAL_ON = (1U << 0);  ///< OSC_HP Operation in Power Down Mode
    }

    /// RSTCON Register bits
    namespace rstcon_bits {
        constexpr uint32_t LOCKUP_EN = (1U << 7);  ///< Lockup Reset Enable Flag
        constexpr uint32_t LOCKUP = (1U << 0);  ///< Lockup Flag
    }

    /// STACK_OVF_ADDR Register bits
    namespace stack_ovf_addr_bits {
        constexpr uint32_t STOF_ADDR_OFF_H = (10 << 18);  ///< Stack Overflow High Address Offset
        constexpr uint32_t STOF_ADDR_OFF_L = (10 << 2);  ///< Stack Overflow Low Address Offset
    }

    /// STACK_OVF_CTRL Register bits
    namespace stack_ovf_ctrl_bits {
        constexpr uint32_t STOF_EN = (1U << 0);  ///< Stack Overflow Enable
    }

    /// STACK_OVF_STS Register bits
    namespace stack_ovf_sts_bits {
        constexpr uint32_t STOF_STS = (1U << 0);  ///< Stack Overflow Status
    }

    /// STACK_OVFCLR Register bits
    namespace stack_ovfclr_bits {
        constexpr uint32_t STOF_STSC = (1U << 0);  ///< Clear Stack Overflow Status
    }

    /// SYS_STRTUP_STS Register bits
    namespace sys_strtup_sts_bits {
        constexpr uint32_t PG100TP_CHKS_ERR = (1U << 2);  ///< 100 TP Page Checksum Error
        constexpr uint32_t MRAMINITSTS = (1U << 1);  ///< Map RAM Initialisation Status
        constexpr uint32_t PLL_LOCK_STS = (1U << 0);  ///< PLL LOCK STATUS
    }

    /// SYSCON0 Register bits
    namespace syscon0_bits {
        constexpr uint32_t SYSCLKSEL = (2 << 6);  ///< System Clock Select
        constexpr uint32_t NVMCLKFAC = (2 << 4);  ///< NVM Access Clock Factor
    }

    /// TCCR Register bits
    namespace tccr_bits {
        constexpr uint32_t TCC = (2 << 0);  ///< Temperature Compensation Control
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t VTOR_BYP = (2 << 0);  ///< Vector Table Bypass Mode
    }

    /// WAKECON Register bits
    namespace wakecon_bits {
        constexpr uint32_t WAKEUPEN = (1U << 0);  ///< Wakeup Interrupt Enable
    }

    /// WDT Register bits
    namespace wdt_bits {
        constexpr uint32_t WDT = (16 << 0);  ///< Watchdog Timer Current Value
    }

    /// WDTCON Register bits
    namespace wdtcon_bits {
        constexpr uint32_t WINBEN = (1U << 5);  ///< Watchdog Window-Boundary Enable
        constexpr uint32_t WDTPR = (1U << 4);  ///< Watchdog Prewarning Mode Flag
        constexpr uint32_t WDTEN = (1U << 2);  ///< WDT Enable
        constexpr uint32_t WDTRS = (1U << 1);  ///< WDT Refresh Start
        constexpr uint32_t WDTIN = (1U << 0);  ///< Watchdog Timer Input Frequency Selection
    }

    /// WDTREL Register bits
    namespace wdtrel_bits {
        constexpr uint32_t WDTREL = (8 << 0);  ///< Watchdog Timer Reload Value
    }

    /// WDTWINB Register bits
    namespace wdtwinb_bits {
        constexpr uint32_t WDTWINB = (8 << 0);  ///< Watchdog Window-Boundary Count Value
    }

    /// XTAL_CTRL Register bits
    namespace xtal_ctrl_bits {
        constexpr uint32_t XTALHYSCTRL = (2 << 4);  ///< XTAL Hysteresis Control
        constexpr uint32_t XTALHYSEN = (1U << 1);  ///< XTAL Hysteresis Enable
        constexpr uint32_t XTAL12EN = (1U << 0);  ///< Pins XTAL1/2 Enable Bit
    }

}

// ============================================================================
// SCUPM Peripheral
// ============================================================================

namespace scupm {
    /// Base addresses
    constexpr uint32_t SCUPM_BASE = 0x50006000;

    /// SCUPM Register structure
    struct Registers {
        volatile uint32_t AMCLK_CTRL;  ///< Offset: 0x04 - Analog Module Clock Control Register
        volatile uint32_t AMCLK_FREQ_STS;  ///< Offset: 0x00 - Analog Module Clock Frequency Status Register
        volatile uint32_t AMCLK_TH_HYS;  ///< Offset: 0x0C - Analog Module Clock Limit Register
        volatile uint32_t PCU_CTRL_STS;  ///< Offset: 0x30 - Power Control Unit Control Status Register
        volatile uint32_t STCALIB;  ///< Offset: 0x6C - System Tick Calibration Register
        volatile uint32_t SYS_IRQ_CTRL;  ///< Offset: 0x28 - System Interrupt Control Register
        volatile uint32_t SYS_IS;  ///< Offset: 0x18 - System Interrupt Status Register
        volatile uint32_t SYS_ISCLR;  ///< Offset: 0x14 - System Interrupt Status Clear Register
        volatile uint32_t SYS_SUPPLY_IRQ_CLR;  ///< Offset: 0x24 - System Supply Interrupt Status Clear Register
        volatile uint32_t SYS_SUPPLY_IRQ_CTRL;  ///< Offset: 0x20 - System Supply Interrupt Control Register
        volatile uint32_t SYS_SUPPLY_IRQ_STS;  ///< Offset: 0x1C - System Supply Interrupt Status Register
        volatile uint32_t WDT1_TRIG;  ///< Offset: 0x34 - WDT1 Watchdog Control Register
    };

    /// Peripheral instances
    inline Registers* SCUPM = reinterpret_cast<Registers*>(SCUPM_BASE);

    // Bit definitions
    /// AMCLK_CTRL Register bits
    namespace amclk_ctrl_bits {
        constexpr uint32_t CLKWDT_PD_N = (1U << 0);  ///< Clock Watchdog Powerdown
    }

    /// AMCLK_FREQ_STS Register bits
    namespace amclk_freq_sts_bits {
        constexpr uint32_t AMCLK2_FREQ = (6 << 8);  ///< Current frequency of Analog Module Clock 2 (TFILT_CLK)
        constexpr uint32_t AMCLK1_FREQ = (6 << 0);  ///< Current frequency of Analog Module Clock System Clock (MI_CLK)
    }

    /// AMCLK_TH_HYS Register bits
    namespace amclk_th_hys_bits {
        constexpr uint32_t AMCLK2_LOW_HYS = (2 << 30);  ///< Analog Module Clock 2 (TFILT_CLK) Lower Hysteresis
        constexpr uint32_t AMCLK2_LOW_TH = (6 << 24);  ///< Analog Module Clock 2 (TFILT_CLK) Lower Limit Threshold
        constexpr uint32_t AMCLK2_UP_HYS = (2 << 22);  ///< Analog Module Clock 2 (TFILT_CLK) Upper Hysteresis
        constexpr uint32_t AMCLK2_UP_TH = (6 << 16);  ///< Analog Module Clock 2 (TFILT_CLK) Upper Limit Threshold
        constexpr uint32_t AMCLK1_LOW_HYS = (2 << 14);  ///< Analog Module Clock 1 (MI_CLK) Lower Hysteresis
        constexpr uint32_t AMCLK1_LOW_TH = (6 << 8);  ///< Analog Module Clock 1 (MI_CLK) Lower Limit Threshold
        constexpr uint32_t AMCLK1_UP_HYS = (2 << 6);  ///< Analog Module Clock 1 (MI_CLK) Upper Hysteresis
        constexpr uint32_t AMCLK1_UP_TH = (6 << 0);  ///< Analog Module Clock 1 (MI_CLK) Upper Limit Threshold
    }

    /// PCU_CTRL_STS Register bits
    namespace pcu_ctrl_sts_bits {
        constexpr uint32_t CLKLOSS_RES_SD_DIS = (1U << 27);  ///< Loss of Clock Reset Disable
        constexpr uint32_t CLKWDT_RES_SD_DIS = (1U << 26);  ///< Clock Watchdog Reset Disable
        constexpr uint32_t CLKLOSS_SD_DIS = (1U << 25);  ///< System Loss of Clock Shutdown Disable (AMCLK3)
        constexpr uint32_t SYS_OTWARN_PS_DIS = (1U << 24);  ///< System Overtemperature Warning Power Switches Shutdown Disable
        constexpr uint32_t SYS_VS_OV_SLM_DIS = (1U << 14);  ///< VS Overvoltage Shutdown for Peripherals Disable
        constexpr uint32_t SYS_VS_UV_SLM_DIS = (1U << 13);  ///< VS Undervoltage Shutdown for Peripherals Disable
        constexpr uint32_t LIN_VS_UV_SD_DIS = (1U << 8);  ///< LIN Module VS Undervoltage Transmitter Shutdown
        constexpr uint32_t FAIL_PS_DIS = (1U << 7);  ///< Disable LIN Tx and HS and because of Overtemperature Warning or VS OV/UV
        constexpr uint32_t CLKWDT_SD_DIS = (1U << 1);  ///< Power Modules Clock Watchdog Shutdown Disable
    }

    /// STCALIB Register bits
    namespace stcalib_bits {
        constexpr uint32_t STCALIB = (26 << 0);  ///< System Tick Calibration
    }

    /// SYS_IRQ_CTRL Register bits
    namespace sys_irq_ctrl_bits {
        constexpr uint32_t VREF1V2_OV_IE = (1U << 13);  ///< 8 Bit ADC2 Reference Overvoltage Interrupt Enable
        constexpr uint32_t VREF1V2_UV_IE = (1U << 12);  ///< 8 Bit ADC2 Reference Undervoltage Interrupt Enable
        constexpr uint32_t SYS_OT_IE = (1U << 9);  ///< System Overtemperature Shutdown Interrupt Enable
        constexpr uint32_t SYS_OTWARN_IE = (1U << 8);  ///< System Overtemperature Prewarning Interrupt Enable
    }

    /// SYS_IS Register bits
    namespace sys_is_bits {
        constexpr uint32_t SYS_SUPPLY_STS = (1U << 30);  ///< System Supply Status
        constexpr uint32_t VREF1V2_OV_STS = (1U << 29);  ///< 8 Bit ADC2 Reference Overvoltage (ADC2, Channel 5) interrupt status
        constexpr uint32_t VREF1V2_UV_STS = (1U << 28);  ///< 8 Bit ADC2 Reference Undervoltage (ADC2, Channel 5) interrstatus
        constexpr uint32_t SYS_OT_STS = (1U << 25);  ///< System Overtemperature Shutdown (ADC2, Channel 6) status
        constexpr uint32_t SYS_OTWARN_STS = (1U << 24);  ///< System Overtemperature Prewarning (ADC2, Channel 6) status
        constexpr uint32_t HS_FAIL_STS = (1U << 19);  ///< High Side Driver Fail Status
        constexpr uint32_t DRV_FAIL_STS = (1U << 18);  ///< Gate Driver Fail Status
        constexpr uint32_t CP_FAIL_STS = (1U << 17);  ///< Charge Pump Fail Status
        constexpr uint32_t LIN_FAIL_STS = (1U << 16);  ///< LIN Fail Status
        constexpr uint32_t SYS_SUPPLY_IS = (1U << 14);  ///< System Supply Interrupt Status
        constexpr uint32_t VREF1V2_OV_IS = (1U << 13);  ///< 8 Bit ADC2 Reference Overvoltage (ADC2, Channel 5) interrupt status
        constexpr uint32_t VREF1V2_UV_IS = (1U << 12);  ///< 8 Bit ADC2 Reference Undervoltage (ADC2, Channel 5) interrupt status
        constexpr uint32_t CLKWDT_IS = (1U << 10);  ///< Clock Watchdog Interrupt Status
        constexpr uint32_t SYS_OT_IS = (1U << 9);  ///< System Overtemperature Shutdown (ADC2, Channel 8) interrupt status
        constexpr uint32_t SYS_OTWARN_IS = (1U << 8);  ///< System Overtemperature Prewarning (ADC2, Channel 8) interrupt status
        constexpr uint32_t HS_FAIL_IS = (1U << 3);  ///< High Side Driver Fail Interrupt Status
        constexpr uint32_t DRV_FAIL_IS = (1U << 2);  ///< Gate Driver Fail Interrupt Status
        constexpr uint32_t CP_FAIL_IS = (1U << 1);  ///< Charge Pump Fail Interrupt Status
        constexpr uint32_t LIN_FAIL_IS = (1U << 0);  ///< LIN Fail Interrupt Status
    }

    /// SYS_ISCLR Register bits
    namespace sys_isclr_bits {
        constexpr uint32_t VREF1V2_OV_SC = (1U << 29);  ///< 8 Bit ADC2 Reference Overvoltage Status Clear
        constexpr uint32_t VREF1V2_UV_SC = (1U << 28);  ///< 8 Bit ADC2 Reference Undervoltage Status Clear
        constexpr uint32_t SYS_OT_SC = (1U << 25);  ///< System Overtemperature Shutdown Status Clear
        constexpr uint32_t SYS_OTWARN_SC = (1U << 24);  ///< System Overtemperature Prewarning Status Clear
        constexpr uint32_t VREF1V2_OV_ISC = (1U << 13);  ///< 8 Bit ADC2 Reference Overvoltage Interrupt Status Clear
        constexpr uint32_t VREF1V2_UV_ISC = (1U << 12);  ///< 8 Bit ADC2 Reference Undervoltage Interrupt Status Clear
        constexpr uint32_t SYS_OT_ISC = (1U << 9);  ///< System Overtemperature Shutdown Interrupt Status Clear
        constexpr uint32_t SYS_OTWARN_ISC = (1U << 8);  ///< System Overtemperature Prewarning Interrupt Status Clear
    }

    /// SYS_SUPPLY_IRQ_CLR Register bits
    namespace sys_supply_irq_clr_bits {
        constexpr uint32_t VDD1V5_OV_SC = (1U << 30);  ///< VDDC Overvoltage Status clear
        constexpr uint32_t VDD5V_OV_SC = (1U << 28);  ///< VDDP Overvoltage Status clear
        constexpr uint32_t VDDEXT_OV_SC = (1U << 27);  ///< VDDEXT Overvoltage Status clear
        constexpr uint32_t VS_OV_SC = (1U << 24);  ///< VS Overvoltage Status clear
        constexpr uint32_t VDD1V5_UV_SC = (1U << 22);  ///< VDDC Undervoltage Status clear
        constexpr uint32_t VDD5V_UV_SC = (1U << 20);  ///< VDDP Undervoltage Status clear
        constexpr uint32_t VDDEXT_UV_SC = (1U << 19);  ///< VDDEXT Undervoltage Status clear
        constexpr uint32_t VS_UV_SC = (1U << 16);  ///< VS Undervoltage Status clear
        constexpr uint32_t VDD1V5_OV_ISC = (1U << 14);  ///< VDDC Overvoltage Interrupt Status clear
        constexpr uint32_t VDD5V_OV_ISC = (1U << 12);  ///< VDDP Overvoltage Interrupt Status clear
        constexpr uint32_t VDDEXT_OV_ISC = (1U << 11);  ///< VDDEXT Overvoltage Interrupt Status clear
        constexpr uint32_t VS_OV_ISC = (1U << 8);  ///< VS Overvoltage Interrupt Status clear
        constexpr uint32_t VDD1V5_UV_ISC = (1U << 6);  ///< VDDC Undervoltage Interrupt Status clear
        constexpr uint32_t VDD5V_UV_ISC = (1U << 4);  ///< VDDP Undervoltage Interrupt Status clear
        constexpr uint32_t VDDEXT_UV_ISC = (1U << 3);  ///< VDDEXT Undervoltage Interrupt Status clear
        constexpr uint32_t VS_UV_ISC = (1U << 0);  ///< VS Undervoltage Interrupt Status clear
    }

    /// SYS_SUPPLY_IRQ_CTRL Register bits
    namespace sys_supply_irq_ctrl_bits {
        constexpr uint32_t VDD1V5_OV_IE = (1U << 14);  ///< VDDC Overvoltage Interrupt Enable
        constexpr uint32_t VDD5V_OV_IE = (1U << 12);  ///< VDDP Overvoltage Interrupt Enable
        constexpr uint32_t VDDEXT_OV_IE = (1U << 11);  ///< VDDEXT Overvoltage Interrupt Enable
        constexpr uint32_t VS_OV_IE = (1U << 8);  ///< VS Overvoltage Interrupt Enable
        constexpr uint32_t VDD1V5_UV_IE = (1U << 6);  ///< VDDC Undervoltage Interrupt Enable
        constexpr uint32_t VDD5V_UV_IE = (1U << 4);  ///< VDDP Undervoltage Interrupt Enable
        constexpr uint32_t VDDEXT_UV_IE = (1U << 3);  ///< VDDEXT Undervoltage Interrupt Enable
        constexpr uint32_t VS_UV_IE = (1U << 0);  ///< VS Undervoltage Interrupt Enable
    }

    /// SYS_SUPPLY_IRQ_STS Register bits
    namespace sys_supply_irq_sts_bits {
        constexpr uint32_t VDD1V5_OV_STS = (1U << 30);  ///< VDDC Overvoltage Status (ADC2 channel 6)
        constexpr uint32_t VDD5V_OV_STS = (1U << 28);  ///< VDDP Overvoltage Status (ADC2 channel 4)
        constexpr uint32_t VDDEXT_OV_STS = (1U << 27);  ///< VDDEXT Overvoltage Status (ADC2 channel 3)
        constexpr uint32_t VS_OV_STS = (1U << 24);  ///< VS Overvoltage Status (ADC2 channel 0)
        constexpr uint32_t VDD1V5_UV_STS = (1U << 22);  ///< VDDC Undervoltage Status (ADC2 channel 6)
        constexpr uint32_t VDD5V_UV_STS = (1U << 20);  ///< VDDP Undervoltage Status (ADC2 channel 4)
        constexpr uint32_t VDDEXT_UV_STS = (1U << 19);  ///< VDDEXT Undervoltage Status (ADC2 channel 3)
        constexpr uint32_t VS_UV_STS = (1U << 16);  ///< VS Undervoltage Status (ADC2 channel 0)
        constexpr uint32_t VDD1V5_OV_IS = (1U << 14);  ///< VDDC Overvoltage Interrupt Status (ADC2 channel 6)
        constexpr uint32_t VDD5V_OV_IS = (1U << 12);  ///< VDDP Overvoltage Interrupt Status (ADC2 channel 4)
        constexpr uint32_t VDDEXT_OV_IS = (1U << 11);  ///< VDDEXT Overvoltage Interrupt Status (ADC2 channel 3)
        constexpr uint32_t VS_OV_IS = (1U << 8);  ///< VS Overvoltage Interrupt Status (ADC2 channel 0)
        constexpr uint32_t VDD1V5_UV_IS = (1U << 6);  ///< VDDC Undervoltage Interrupt Status (ADC2 channel 6)
        constexpr uint32_t VDD5V_UV_IS = (1U << 4);  ///< VDDP Undervoltage Interrupt Status (ADC2 channel 4)
        constexpr uint32_t VDDEXT_UV_IS = (1U << 3);  ///< VDDEXT Undervoltage Interrupt Status (ADC2 channel 3)
        constexpr uint32_t VS_UV_IS = (1U << 0);  ///< VS Undervoltage Interrupt Status (ADC2 channel 0)
    }

    /// WDT1_TRIG Register bits
    namespace wdt1_trig_bits {
        constexpr uint32_t SOWCONF = (2 << 6);  ///< Short Open Window Configuration
        constexpr uint32_t WDP_SEL = (6 << 0);  ///< Watchdog Period Selection and trigger
    }

}

// ============================================================================
// SSC1 Peripheral
// ============================================================================

namespace ssc1 {
    /// Base addresses
    constexpr uint32_t SSC1_BASE = 0x48024000;

    /// SSC1 Register structure
    struct Registers {
        volatile uint32_t BR;  ///< Offset: 0x10 - Baud Rate Timer Reload Register
        volatile uint32_t CON;  ///< Offset: 0x04 - Control Register
        volatile uint32_t ISRCLR;  ///< Offset: 0x14 - Interrupt Status Register Clear
        volatile uint32_t PISEL;  ///< Offset: 0x00 - Port Input Select Register
        volatile uint32_t RB;  ///< Offset: 0x0C - Receiver Buffer Register
        volatile uint32_t TB;  ///< Offset: 0x08 - Transmitter Buffer Register
    };

    /// Peripheral instances
    inline Registers* SSC1 = reinterpret_cast<Registers*>(SSC1_BASE);

    // Bit definitions
    /// BR Register bits
    namespace br_bits {
        constexpr uint32_t BR_VALUE = (16 << 0);  ///< Baud Rate Timer/Reload Register Value
    }

    /// CON Register bits
    namespace con_bits {
        constexpr uint32_t BSY = (1U << 28);  ///< Busy Flag
        constexpr uint32_t BE = (1U << 27);  ///< Baud Rate Error Flag
        constexpr uint32_t PE = (1U << 26);  ///< Phase Error Flag
        constexpr uint32_t RE = (1U << 25);  ///< Receive Error Flag
        constexpr uint32_t TE = (1U << 24);  ///< Transmit Error Flag
        constexpr uint32_t BC = (4 << 16);  ///< Bit Count Field
        constexpr uint32_t EN = (1U << 15);  ///< Enable Bit
        constexpr uint32_t MS = (1U << 14);  ///< Master Select
        constexpr uint32_t AREN = (1U << 12);  ///< Automatic Reset Enable
        constexpr uint32_t BEN = (1U << 11);  ///< Baud Rate Error Enable
        constexpr uint32_t PEN = (1U << 10);  ///< Phase Error Enable
        constexpr uint32_t REN = (1U << 9);  ///< Receive Error Enable
        constexpr uint32_t TEN = (1U << 8);  ///< Transmit Error Enable
        constexpr uint32_t LB = (1U << 7);  ///< Loop Back Control
        constexpr uint32_t PO = (1U << 6);  ///< Clock Polarity Control
        constexpr uint32_t PH = (1U << 5);  ///< Clock Phase Control
        constexpr uint32_t HB = (1U << 4);  ///< Heading Control
        constexpr uint32_t BM = (4 << 0);  ///< Data Width Selection
    }

    /// ISRCLR Register bits
    namespace isrclr_bits {
        constexpr uint32_t BECLR = (1U << 11);  ///< Baud Rate Error Flag Clear
        constexpr uint32_t PECLR = (1U << 10);  ///< Phase Error Flag Clear
        constexpr uint32_t RECLR = (1U << 9);  ///< Receive Error Flag Clear
        constexpr uint32_t TECLR = (1U << 8);  ///< Transmit Error Flag Clear
    }

    /// PISEL Register bits
    namespace pisel_bits {
        constexpr uint32_t GIS = (1U << 4);  ///< Global SSC12 Input Select
        constexpr uint32_t MIS_1 = (1U << 3);  ///< Master Mode Input Select Bit 1 (Master Mode only)
        constexpr uint32_t CIS = (1U << 2);  ///< Clock Input Select (Slave Mode only)
        constexpr uint32_t SIS = (1U << 1);  ///< Slave Mode Input Select (Slave Mode only)
        constexpr uint32_t MIS_0 = (1U << 0);  ///< Master Mode Input Select Bit 0 (Master Mode only)
    }

    /// RB Register bits
    namespace rb_bits {
        constexpr uint32_t RB_VALUE = (16 << 0);  ///< Receive Data Register Value
    }

    /// TB Register bits
    namespace tb_bits {
        constexpr uint32_t TB_VALUE = (16 << 0);  ///< Transmit Data Register Value
    }

}

// ============================================================================
// SSC2 Peripheral
// ============================================================================

namespace ssc2 {
    /// Base addresses
    constexpr uint32_t SSC2_BASE = 0x48026000;

    /// SSC2 Register structure
    struct Registers {
        volatile uint32_t BR;  ///< Offset: 0x10 - Baud Rate Timer Reload Register
        volatile uint32_t CON;  ///< Offset: 0x04 - Control Register
        volatile uint32_t ISRCLR;  ///< Offset: 0x14 - Interrupt Status Register Clear
        volatile uint32_t PISEL;  ///< Offset: 0x00 - Port Input Select Register
        volatile uint32_t RB;  ///< Offset: 0x0C - Receiver Buffer Register
        volatile uint32_t TB;  ///< Offset: 0x08 - Transmitter Buffer Register
    };

    /// Peripheral instances
    inline Registers* SSC2 = reinterpret_cast<Registers*>(SSC2_BASE);

    // Bit definitions
    /// BR Register bits
    namespace br_bits {
        constexpr uint32_t BR_VALUE = (16 << 0);  ///< Baud Rate Timer/Reload Register Value
    }

    /// CON Register bits
    namespace con_bits {
        constexpr uint32_t BSY = (1U << 28);  ///< Busy Flag
        constexpr uint32_t BE = (1U << 27);  ///< Baud Rate Error Flag
        constexpr uint32_t PE = (1U << 26);  ///< Phase Error Flag
        constexpr uint32_t RE = (1U << 25);  ///< Receive Error Flag
        constexpr uint32_t TE = (1U << 24);  ///< Transmit Error Flag
        constexpr uint32_t BC = (4 << 16);  ///< Bit Count Field
        constexpr uint32_t EN = (1U << 15);  ///< Enable Bit
        constexpr uint32_t MS = (1U << 14);  ///< Master Select
        constexpr uint32_t AREN = (1U << 12);  ///< Automatic Reset Enable
        constexpr uint32_t BEN = (1U << 11);  ///< Baud Rate Error Enable
        constexpr uint32_t PEN = (1U << 10);  ///< Phase Error Enable
        constexpr uint32_t REN = (1U << 9);  ///< Receive Error Enable
        constexpr uint32_t TEN = (1U << 8);  ///< Transmit Error Enable
        constexpr uint32_t LB = (1U << 7);  ///< Loop Back Control
        constexpr uint32_t PO = (1U << 6);  ///< Clock Polarity Control
        constexpr uint32_t PH = (1U << 5);  ///< Clock Phase Control
        constexpr uint32_t HB = (1U << 4);  ///< Heading Control
        constexpr uint32_t BM = (4 << 0);  ///< Data Width Selection
    }

    /// ISRCLR Register bits
    namespace isrclr_bits {
        constexpr uint32_t BECLR = (1U << 11);  ///< Baud Rate Error Flag Clear
        constexpr uint32_t PECLR = (1U << 10);  ///< Phase Error Flag Clear
        constexpr uint32_t RECLR = (1U << 9);  ///< Receive Error Flag Clear
        constexpr uint32_t TECLR = (1U << 8);  ///< Transmit Error Flag Clear
    }

    /// PISEL Register bits
    namespace pisel_bits {
        constexpr uint32_t GIS = (1U << 4);  ///< Global SSC12 Input Select
        constexpr uint32_t MIS_1 = (1U << 3);  ///< Master Mode Input Select Bit 1 (Master Mode only)
        constexpr uint32_t CIS = (1U << 2);  ///< Clock Input Select (Slave Mode only)
        constexpr uint32_t SIS = (1U << 1);  ///< Slave Mode Input Select (Slave Mode only)
        constexpr uint32_t MIS_0 = (1U << 0);  ///< Master Mode Input Select Bit 0 (Master Mode only)
    }

    /// RB Register bits
    namespace rb_bits {
        constexpr uint32_t RB_VALUE = (16 << 0);  ///< Receive Data Register Value
    }

    /// TB Register bits
    namespace tb_bits {
        constexpr uint32_t TB_VALUE = (16 << 0);  ///< Transmit Data Register Value
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER2_BASE = 0x48004000;
    constexpr uint32_t TIMER21_BASE = 0x48005000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CNT;  ///< Offset: 0x10 - Timer 2 Count Register
        volatile uint32_t CON;  ///< Offset: 0x00 - Timer 2 Control Register
        volatile uint32_t CON1;  ///< Offset: 0x1C - Timer 2 Control Register 1
        volatile uint32_t ICLR;  ///< Offset: 0x18 - Timer 2 Interrupt Clear Register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Timer 2 Mode Register
        volatile uint32_t RC;  ///< Offset: 0x08 - Timer 2 Reload/Capture Register
    };

    /// Peripheral instances
    inline Registers* TIMER2 = reinterpret_cast<Registers*>(TIMER2_BASE);
    inline Registers* TIMER21 = reinterpret_cast<Registers*>(TIMER21_BASE);

    // Bit definitions
    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t T2H = (8 << 8);  ///< Timer 2 Value
        constexpr uint32_t T2L = (8 << 0);  ///< Timer 2 Value
    }

    /// CON Register bits
    namespace con_bits {
        constexpr uint32_t TF2 = (1U << 7);  ///< Timer 2 Overflow/Underflow Flag
        constexpr uint32_t EXF2 = (1U << 6);  ///< Timer 2 External Flag
        constexpr uint32_t EXEN2 = (1U << 3);  ///< Timer 2 External Enable Control
        constexpr uint32_t TR2 = (1U << 2);  ///< Timer 2 Start/Stop Control
        constexpr uint32_t C_T2 = (1U << 1);  ///< Timer or Counter Select
        constexpr uint32_t CP_RL2 = (1U << 0);  ///< Capture/Reload Select
    }

    /// CON1 Register bits
    namespace con1_bits {
        constexpr uint32_t TF2EN = (1U << 1);  ///< Overflow/Underflow Interrupt Enable
        constexpr uint32_t EXF2EN = (1U << 0);  ///< External Interrupt Enable
    }

    /// ICLR Register bits
    namespace iclr_bits {
        constexpr uint32_t TF2CLR = (1U << 7);  ///< Overflow/Underflow Interrupt Clear Flag
        constexpr uint32_t EXF2CLR = (1U << 6);  ///< External Interrupt Clear Flag
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t T2REGS = (1U << 7);  ///< Edge Select for Timer 2 External Start
        constexpr uint32_t T2RHEN = (1U << 6);  ///< Timer 2 External Start Enable
        constexpr uint32_t EDGESEL = (1U << 5);  ///< Edge Select in Capture Mode/Reload Mode
        constexpr uint32_t PREN = (1U << 4);  ///< Prescaler Enable
        constexpr uint32_t T2PRE = (3 << 1);  ///< Timer 2 Prescaler Bit
        constexpr uint32_t DCEN = (1U << 0);  ///< Up/Down Counter Enable
    }

    /// RC Register bits
    namespace rc_bits {
        constexpr uint32_t RCH2 = (8 << 8);  ///< Reload/Capture Value
        constexpr uint32_t RCL2 = (8 << 0);  ///< Reload/Capture Value
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART1_BASE = 0x48020000;
    constexpr uint32_t UART2_BASE = 0x48022000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t SBUF;  ///< Offset: 0x04 - Serial Data Buffer
        volatile uint32_t SCON;  ///< Offset: 0x00 - Serial Channel Control Register
        volatile uint32_t SCONCLR;  ///< Offset: 0x08 - Serial Channel Control Clear Register
    };

    /// Peripheral instances
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);

    // Bit definitions
    /// SBUF Register bits
    namespace sbuf_bits {
        constexpr uint32_t VAL = (8 << 0);  ///< Serial Interface Buffer Register
    }

    /// SCON Register bits
    namespace scon_bits {
        constexpr uint32_t SM0 = (1U << 7);  ///< Serial Port Operating Mode Selection
        constexpr uint32_t SM1 = (1U << 6);  ///< Serial Port Operating Mode Selection
        constexpr uint32_t SM2 = (1U << 5);  ///< Enable Serial Port Multiprocessor Communication in Modes 2 and 3
        constexpr uint32_t REN = (1U << 4);  ///< Enable Receiver of Serial Port
        constexpr uint32_t TB8 = (1U << 3);  ///< Serial Port Transmitter Bit 9
        constexpr uint32_t RB8 = (1U << 2);  ///< Serial Port Receiver Bit 9
        constexpr uint32_t TI = (1U << 1);  ///< Transmit Interrupt Flag
        constexpr uint32_t RI = (1U << 0);  ///< Receive Interrupt Flag
    }

    /// SCONCLR Register bits
    namespace sconclr_bits {
        constexpr uint32_t RB8CLR = (1U << 2);  ///< SCON.RB8 Clear Flag
        constexpr uint32_t TICLR = (1U << 1);  ///< SCON.TI Clear Flag
        constexpr uint32_t RICLR = (1U << 0);  ///< SCON.RI Clear Flag
    }

}


} // namespace alloy::generated::tle985x

#endif // ALLOY_GENERATED_TLE985X_PERIPHERALS_HPP