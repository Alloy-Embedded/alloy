/// Auto-generated code for TLE9868
/// Generated by Alloy Code Generator
/// Source: infineon_tle9868.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:22:01
#ifndef ALLOY_GENERATED_TLE9868_PERIPHERALS_HPP
#define ALLOY_GENERATED_TLE9868_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::tle9868 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC1_BASE = 0x40004000;
    constexpr uint32_t ADC2_BASE = 0x4801C000;
    constexpr uint32_t ADC34_BASE = 0x40008000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CHx_EIM;  ///< Offset: 0x08 - Channel Settings Bits for Exceptional Interrupt Measurement
        volatile uint32_t CHx_ESM;  ///< Offset: 0x0C - Channel Settings Bits for Exceptional Sequence Measurement
        volatile uint32_t CTRL_STS;  ///< Offset: 0x00 - ADC1 Control and Status Register
        volatile uint32_t DWSEL;  ///< Offset: 0x24 - Measurement Channel Data Width Selection
        volatile uint32_t GLOBCTR;  ///< Offset: 0x04 - Global Control Register
        volatile uint32_t GLOBSTR;  ///< Offset: 0x74 - Global Status Register
        volatile uint32_t ICLR;  ///< Offset: 0x80 - ADC1 Interrupt Status Clear Register
        volatile uint32_t IE;  ///< Offset: 0x7C - ADC1 Interrupt Enable Register
        volatile uint32_t IS;  ///< Offset: 0x78 - ADC1 Interrupt Status Register
        volatile uint32_t RES_OUT0;  ///< Offset: 0x70 - ADC1 Output Channel 0
        volatile uint32_t RES_OUT1;  ///< Offset: 0x6C - ADC1 Output Channel 1
        volatile uint32_t RES_OUT2;  ///< Offset: 0x68 - ADC1 Output Channel 2
        volatile uint32_t RES_OUT3;  ///< Offset: 0x64 - ADC1 Output Channel 3
        volatile uint32_t RES_OUT4;  ///< Offset: 0x60 - ADC1 Output Channel 4
        volatile uint32_t RES_OUT5;  ///< Offset: 0x5C - ADC1 Output Channel 5
        volatile uint32_t RES_OUT6;  ///< Offset: 0x58 - ADC1 Output Channel 6
        volatile uint32_t RES_OUT7;  ///< Offset: 0x54 - ADC1 Output Channel 7
        volatile uint32_t RES_OUT_EIM;  ///< Offset: 0x40 - ADC1 Output Channel EIM
        volatile uint32_t SQ1_4;  ///< Offset: 0x18 - Measurement Channel Enable Bits for Cycle 1 - 4
        volatile uint32_t SQ5_8;  ///< Offset: 0x1C - Measurement Channel Enable Bits for Cycle 5 - 8
        volatile uint32_t SQ_FB;  ///< Offset: 0x50 - Sequencer Feedback Register
        volatile uint32_t STC_0_3;  ///< Offset: 0x28 - Measurement Channel Sample Time Control 0 - 3
        volatile uint32_t STC_4_7;  ///< Offset: 0x2C - Measurement Channel Sample Time Control 4 - 7
    };

    /// Peripheral instances
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* ADC2 = reinterpret_cast<Registers*>(ADC2_BASE);
    inline Registers* ADC34 = reinterpret_cast<Registers*>(ADC34_BASE);

    // Bit definitions
    /// CHx_EIM Register bits
    namespace chx_eim_bits {
        constexpr uint32_t TRIG_SEL = (3 << 16);  ///< Trigger selection for exceptional interrupt measurement (EIM)
        constexpr uint32_t REP = (3 << 4);  ///< Repeat count for exceptional interrupt measurement (EIM)
        constexpr uint32_t CHx = (3 << 0);  ///< Channel set for exceptional interrupt measurement (EIM)
    }

    /// CHx_ESM Register bits
    namespace chx_esm_bits {
        constexpr uint32_t TRIG_SEL = (3 << 16);  ///< Trigger selection for exceptional interrupt measurement (ESM)
        constexpr uint32_t ESM_0 = (8 << 0);  ///< Channel Sequence for Exceptional Sequence Measurement (ESM)
    }

    /// CTRL_STS Register bits
    namespace ctrl_sts_bits {
        constexpr uint32_t IN_MUX_SEL = (3 << 4);  ///< Channel for software mode
        constexpr uint32_t EOC = (1U << 3);  ///< ADC1 End of Conversion (software mode)
        constexpr uint32_t SOC = (1U << 2);  ///< ADC1 Start of Conversion (software mode)
        constexpr uint32_t PD_N = (1U << 0);  ///< ADC1 Power Down Signal
    }

    /// DWSEL Register bits
    namespace dwsel_bits {
        constexpr uint32_t ch7 = (1U << 7);  ///< Data Width channel 7
        constexpr uint32_t ch6 = (1U << 6);  ///< Data Width channel 6
        constexpr uint32_t ch5 = (1U << 5);  ///< Data Width channel 5
        constexpr uint32_t ch4 = (1U << 4);  ///< Data Width channel 4
        constexpr uint32_t ch3 = (1U << 3);  ///< Data Width channel 3
        constexpr uint32_t ch2 = (1U << 2);  ///< Data Width channel 2
        constexpr uint32_t ch1 = (1U << 1);  ///< Data Width channel 1
        constexpr uint32_t ch0 = (1U << 0);  ///< Data Width channel 0
    }

    /// GLOBCTR Register bits
    namespace globctr_bits {
        constexpr uint32_t ANON = (2 << 8);  ///< Analog Part Switched On
        constexpr uint32_t DIVA = (6 << 0);  ///< Divide Factor for the Analog internal clock: 0x00=Fadci = Fadc, 0x01=Fadci = Fadc/2, 0x02=Fadci = Fadc/3, 0x02=..., 0x3F=Fadci = Fadc/64,
    }

    /// GLOBSTR Register bits
    namespace globstr_bits {
        constexpr uint32_t ANON_ST = (2 << 8);  ///< Analog Part Switched On
        constexpr uint32_t CHNR = (3 << 3);  ///< Channel Number
        constexpr uint32_t SAMPLE = (1U << 1);  ///< Sample Phase Indication
        constexpr uint32_t BUSY = (1U << 0);  ///< Analog Part Busy
    }

    /// ICLR Register bits
    namespace iclr_bits {
        constexpr uint32_t ESM_ICLR = (1U << 9);  ///< Exceptional Sequence Measurement (ESM) Status Clear
        constexpr uint32_t EIM_ICLR = (1U << 8);  ///< Exceptional Interrupt Measurement (EIM) Status Clear
        constexpr uint32_t CH7_ICLR = (1U << 7);  ///< ADC1 Channel 7 Interrupt Status Clear
        constexpr uint32_t CH6_ICLR = (1U << 6);  ///< ADC1 Channel 6 Interrupt Status Clear
        constexpr uint32_t CH5_ICLR = (1U << 5);  ///< ADC1 Channel 5 Interrupt Status Clear
        constexpr uint32_t CH4_ICLR = (1U << 4);  ///< ADC1 Channel 4 Interrupt Status Clear
        constexpr uint32_t CH3_ICLR = (1U << 3);  ///< ADC1 Channel 3 Interrupt Status Clear
        constexpr uint32_t CH2_ICLR = (1U << 2);  ///< ADC1 Channel 2 Interrupt Status Clear
        constexpr uint32_t CH1_ICLR = (1U << 1);  ///< ADC1 Channel 1 Interrupt Status Clear
        constexpr uint32_t CH0_ICLR = (1U << 0);  ///< ADC1 Channel 0 Interrupt Status Clear
    }

    /// IE Register bits
    namespace ie_bits {
        constexpr uint32_t ESM_IE = (1U << 9);  ///< Exceptional Sequence Measurement (ESM) Interrupt Enable
        constexpr uint32_t EIM_IE = (1U << 8);  ///< Exceptional Interrupt Measurement (EIM) Interrupt Enable
        constexpr uint32_t CH7_IE = (1U << 7);  ///< ADC1 Channel 7 Interrupt Enable
        constexpr uint32_t CH6_IE = (1U << 6);  ///< ADC1 Channel 6 Interrupt Enable
        constexpr uint32_t CH5_IE = (1U << 5);  ///< ADC1 Channel 5 Interrupt Enable
        constexpr uint32_t CH4_IE = (1U << 4);  ///< ADC1 Channel 4 Interrupt Enable
        constexpr uint32_t CH3_IE = (1U << 3);  ///< ADC1 Channel 3 Interrupt Enable
        constexpr uint32_t CH2_IE = (1U << 2);  ///< ADC1 Channel 2 Interrupt Enable
        constexpr uint32_t CH1_IE = (1U << 1);  ///< ADC1 Channel 1 Interrupt Enable
        constexpr uint32_t CH0_IE = (1U << 0);  ///< ADC1 Channel 0 Interrupt Enable
    }

    /// IS Register bits
    namespace is_bits {
        constexpr uint32_t ESM_STS = (1U << 9);  ///< Exceptional Sequence Measurement (ESM) Status
        constexpr uint32_t EIM_STS = (1U << 8);  ///< Exceptional Interrupt Measurement (EIM) Status
        constexpr uint32_t CH7_STS = (1U << 7);  ///< ADC1 Channel 7 Interrupt Status
        constexpr uint32_t CH6_STS = (1U << 6);  ///< ADC1 Channel 6 Interrupt Status
        constexpr uint32_t CH5_STS = (1U << 5);  ///< ADC1 Channel 5 Interrupt Status
        constexpr uint32_t CH4_STS = (1U << 4);  ///< ADC1 Channel 4 Interrupt Status
        constexpr uint32_t CH3_STS = (1U << 3);  ///< ADC1 Channel 3 Interrupt Status
        constexpr uint32_t CH2_STS = (1U << 2);  ///< ADC1 Channel 2 Interrupt Status
        constexpr uint32_t CH1_STS = (1U << 1);  ///< ADC1 Channel 1 Interrupt Status
        constexpr uint32_t CH0_STS = (1U << 0);  ///< ADC1 Channel 0 Interrupt Status
    }

    /// RES_OUT0 Register bits
    namespace res_out0_bits {
        constexpr uint32_t OF0 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF0 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR0 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t OUT_CH0 = (12 << 0);  ///< ADC1 output reset value channel 0
    }

    /// RES_OUT1 Register bits
    namespace res_out1_bits {
        constexpr uint32_t OF1 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF1 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR1 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t OUT_CH1 = (12 << 0);  ///< ADC1 output result value channel 1
    }

    /// RES_OUT2 Register bits
    namespace res_out2_bits {
        constexpr uint32_t OF2 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF2 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR2 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t OUT_CH2 = (12 << 0);  ///< ADC1 output result value channel 2
    }

    /// RES_OUT3 Register bits
    namespace res_out3_bits {
        constexpr uint32_t OF3 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF3 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR3 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t OUT_CH3 = (12 << 0);  ///< ADC1 output result value channel 3
    }

    /// RES_OUT4 Register bits
    namespace res_out4_bits {
        constexpr uint32_t OF4 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF4 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR4 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t OUT_CH4 = (12 << 0);  ///< ADC1 output result value channel 4
    }

    /// RES_OUT5 Register bits
    namespace res_out5_bits {
        constexpr uint32_t OF5 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF5 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR5 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t OUT_CH5 = (12 << 0);  ///< ADC1 output result value channel 5
    }

    /// RES_OUT6 Register bits
    namespace res_out6_bits {
        constexpr uint32_t OF6 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF6 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR6 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t OUT_CH6 = (12 << 0);  ///< ADC1 output result value channel 6
    }

    /// RES_OUT7 Register bits
    namespace res_out7_bits {
        constexpr uint32_t OF7 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF7 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR7 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t OUT_CH7 = (12 << 0);  ///< ADC1 output result value channel 7
    }

    /// RES_OUT_EIM Register bits
    namespace res_out_eim_bits {
        constexpr uint32_t OF8 = (1U << 18);  ///< Overrun Flag
        constexpr uint32_t VF8 = (1U << 17);  ///< Valid Flag
        constexpr uint32_t WFR8 = (1U << 16);  ///< Wait for Read Mode
        constexpr uint32_t OUT_CH_EIM = (12 << 0);  ///< ADC1 output result value EIM
    }

    /// SQ1_4 Register bits
    namespace sq1_4_bits {
        constexpr uint32_t SQ4 = (8 << 24);  ///< Sequence 4 channel enable
        constexpr uint32_t SQ3 = (8 << 16);  ///< Sequence 3 channel enable
        constexpr uint32_t SQ2 = (8 << 8);  ///< Sequence 2 channel enable
        constexpr uint32_t SQ1 = (8 << 0);  ///< Sequence 1 channel enable
    }

    /// SQ5_8 Register bits
    namespace sq5_8_bits {
        constexpr uint32_t SQ8 = (8 << 24);  ///< Sequence 8 channel enable
        constexpr uint32_t SQ7 = (8 << 16);  ///< Sequence 7 channel enable
        constexpr uint32_t SQ6 = (8 << 8);  ///< Sequence 6 channel enable
        constexpr uint32_t SQ5 = (8 << 0);  ///< Sequence 5 channel enable
    }

    /// SQ_FB Register bits
    namespace sq_fb_bits {
        constexpr uint32_t CHx = (3 << 16);  ///< Current Channel
        constexpr uint32_t SQx = (3 << 11);  ///< Current Active Sequence in Sequencer Mode
        constexpr uint32_t ESM_ACTIVE = (1U << 10);  ///< ADC1 ESM active
        constexpr uint32_t EIM_ACTIVE = (1U << 9);  ///< ADC1 EIM active
        constexpr uint32_t SQ_RUN = (1U << 8);  ///< ADC1 Sequencer RUN
    }

    /// STC_0_3 Register bits
    namespace stc_0_3_bits {
        constexpr uint32_t ch3 = (8 << 24);  ///< Sample Time Control for Channel 3
        constexpr uint32_t ch2 = (8 << 16);  ///< Sample Time Control for Channel 2
        constexpr uint32_t ch1 = (8 << 8);  ///< Sample Time Control for Channel 1
        constexpr uint32_t ch0 = (8 << 0);  ///< Sample Time Control for Channel 0
    }

    /// STC_4_7 Register bits
    namespace stc_4_7_bits {
        constexpr uint32_t ch7 = (8 << 24);  ///< Sample Time Control for Channel 7
        constexpr uint32_t ch6 = (8 << 16);  ///< Sample Time Control for Channel 6
        constexpr uint32_t ch5 = (8 << 8);  ///< Sample Time Control for Channel 5
        constexpr uint32_t ch4 = (8 << 0);  ///< Sample Time Control for Channel 4
    }

}

// ============================================================================
// BDRV Peripheral
// ============================================================================

namespace bdrv {
    /// Base addresses
    constexpr uint32_t BDRV_BASE = 0x40034000;

    /// BDRV Register structure
    struct Registers {
        volatile uint32_t CP_CLK_CTRL;  ///< Offset: 0x24 - Charge Pump Clock Control Register
        volatile uint32_t CP_CTRL_STS;  ///< Offset: 0x20 - Charge Pump Control and Status Register
        volatile uint32_t CTRL1;  ///< Offset: 0x00 - H-Bridge Driver Control 1
        volatile uint32_t CTRL2;  ///< Offset: 0x04 - H-Bridge Driver Control 2
        volatile uint32_t CTRL3;  ///< Offset: 0x08 - H-Bridge Driver Control 3
        volatile uint32_t OFF_SEQ_CTRL;  ///< Offset: 0x10 - Turn on Slewrate Sequencer Control
        volatile uint32_t ON_SEQ_CTRL;  ///< Offset: 0x14 - Turn off Slewrate Sequencer Control
        volatile uint32_t TRIM_DRVx;  ///< Offset: 0x18 - Trimming of Driver
    };

    /// Peripheral instances
    inline Registers* BDRV = reinterpret_cast<Registers*>(BDRV_BASE);

    // Bit definitions
    /// CP_CLK_CTRL Register bits
    namespace cp_clk_ctrl_bits {
        constexpr uint32_t CPCLK_EN = (1U << 15);  ///< Charge Pump Clock Enable
        constexpr uint32_t F_CP = (2 << 13);  ///< MSB of CP_CLK divider
        constexpr uint32_t DITH_UPPER = (5 << 8);  ///< CP_CLK upper frequency boundary during dithering
        constexpr uint32_t DITH_LOWER = (5 << 0);  ///< CP_CLK lower frequency boundary during dithering
    }

    /// CP_CTRL_STS Register bits
    namespace cp_ctrl_sts_bits {
        constexpr uint32_t VTHVCP9V_TRIM = (2 << 26);  ///< Charge Pump Output Voltage 9V Trimming
        constexpr uint32_t VCP9V_SET = (1U << 25);  ///< Charge Pump 9 V Output Voltage Set
        constexpr uint32_t CPLOPWRM_EN = (1U << 24);  ///< Charge Pump Low Power Mode Enable
        constexpr uint32_t VSD_UPTH_STS = (1U << 23);  ///< Driver Supply MU High Status
        constexpr uint32_t DRVx_VSDUP_DIS = (1U << 22);  ///< Driver shutdown on VSD Upper Voltage
        constexpr uint32_t VSD_LOTH_STS = (1U << 21);  ///< Driver Supply MU Low Status
        constexpr uint32_t DRVx_VSDLO_DIS = (1U << 20);  ///< Driver shutdown on VSD Lower Voltage
        constexpr uint32_t VCP_UPTH_STS = (1U << 19);  ///< Charge Pump MU High Status
        constexpr uint32_t DRVx_VCPUP_DIS = (1U << 18);  ///< Driver shutdown on Charge Pump Upper Voltage
        constexpr uint32_t VCP_LOTH1_STS = (1U << 17);  ///< Charge Pump MU Low Status
        constexpr uint32_t DRVx_VCPLO_DIS = (1U << 16);  ///< Driver Shutdown on Charge Pump Low Voltage
        constexpr uint32_t VCP_LOWTH2 = (3 << 8);  ///< Charge Pump Output Voltage Lower Threshold Detection Level
        constexpr uint32_t VCP_LOTH2_STS = (1U << 5);  ///< Charge Pump Low Status
        constexpr uint32_t CP_RDY_EN = (1U << 2);  ///< Bridge Driver on Charge Pump Ready Enable
        constexpr uint32_t CP_EN = (1U << 0);  ///< Charge Pump Enable
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t HS2_OC_DIS = (1U << 31);  ///< High Side Driver Overcurrent Shutdown Disable
        constexpr uint32_t HS2_OC_STS = (1U << 30);  ///< External High Side 2 FET Over-current Status
        constexpr uint32_t HS2_SUPERR_STS = (1U << 29);  ///< High Side Driver 2 Supply Error Status
        constexpr uint32_t HS2_DS_STS = (1U << 28);  ///< High Side Driver 2 Drain Source Monitoring Status in OFF-State
        constexpr uint32_t HS2_DCS_EN = (1U << 27);  ///< High Side Driver 2 Diagnosis Current Source Enable
        constexpr uint32_t HS2_ON = (1U << 26);  ///< High Side Driver 2 On
        constexpr uint32_t HS2_PWM = (1U << 25);  ///< High Side Driver 2 PWM Enable
        constexpr uint32_t HS2_EN = (1U << 24);  ///< High Side Driver 2 Enable
        constexpr uint32_t HS1_OC_DIS = (1U << 23);  ///< High Side Driver Overcurrent Shutdown Disable
        constexpr uint32_t HS1_OC_STS = (1U << 22);  ///< External High Side 1 FET Over-current Status
        constexpr uint32_t HS1_SUPERR_STS = (1U << 21);  ///< High Side Driver 1 Supply Error Status
        constexpr uint32_t HS1_DS_STS = (1U << 20);  ///< High Side Driver 1 Drain Source Monitoring Status in OFF-State
        constexpr uint32_t HS1_DCS_EN = (1U << 19);  ///< High Side Driver 1 Diagnosis Current Source Enable
        constexpr uint32_t HS1_ON = (1U << 18);  ///< High Side Driver 1 On
        constexpr uint32_t HS1_PWM = (1U << 17);  ///< High Side Driver 1 PWM Enable
        constexpr uint32_t HS1_EN = (1U << 16);  ///< High Side Driver 1 Enable
        constexpr uint32_t LS2_OC_DIS = (1U << 15);  ///< Low Side Driver Overcurrent Shutdown Disable
        constexpr uint32_t LS2_OC_STS = (1U << 14);  ///< External Low Side 2 FET Over-current Status
        constexpr uint32_t LS2_SUPERR_STS = (1U << 13);  ///< Low Side Driver 2 Supply Error Status
        constexpr uint32_t LS2_DS_STS = (1U << 12);  ///< Low Side Driver 2 Drain Source Monitoring Status in OFF-State
        constexpr uint32_t LS2_DCS_EN = (1U << 11);  ///< Low Side Driver 2 Diagnosis Current Source Enable
        constexpr uint32_t LS2_ON = (1U << 10);  ///< Low Side Driver 2 On
        constexpr uint32_t LS2_PWM = (1U << 9);  ///< Low Side Driver 2 PWM Enable
        constexpr uint32_t LS2_EN = (1U << 8);  ///< Low Side Driver 2 Enable
        constexpr uint32_t LS1_OC_DIS = (1U << 7);  ///< Low Side Driver 1 Overcurrent Shutdown Disable
        constexpr uint32_t LS1_OC_STS = (1U << 6);  ///< External Low Side 1 FET Over-current Status
        constexpr uint32_t LS1_SUPERR_STS = (1U << 5);  ///< Low Side Driver 1 Supply Error Status
        constexpr uint32_t LS1_DS_STS = (1U << 4);  ///< Low Side Driver 1 Drain Source Monitoring Status in OFF-State
        constexpr uint32_t LS1_DCS_EN = (1U << 3);  ///< Low Side Driver 1 Diagnosis Current Source Enable
        constexpr uint32_t LS1_ON = (1U << 2);  ///< Low Side Driver 1 On
        constexpr uint32_t LS1_PWM = (1U << 1);  ///< Low Side Driver 1 PWM Enable
        constexpr uint32_t LS1_EN = (1U << 0);  ///< Low Side Driver 1 Enable
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t DLY_DIAG_DIRSEL = (1U << 31);  ///< Ext. power diag timer on / off select
        constexpr uint32_t DLY_DIAG_CHSEL = (3 << 28);  ///< Ext. power on/off timer channel select
        constexpr uint32_t DLY_DIAG_STS = (1U << 27);  ///< Ext. power diag timer valid flag
        constexpr uint32_t DLY_DIAG_SCLR = (1U << 26);  ///< Ext. power diag timer valid flag clear
        constexpr uint32_t DLY_DIAG_TIM = (10 << 16);  ///< Ext. power on/off diag timer result register
    }

    /// CTRL3 Register bits
    namespace ctrl3_bits {
        constexpr uint32_t DRV_CCP_DIS = (1U << 26);  ///< Dynamic cross conduction protection Disable
        constexpr uint32_t DRV_CCP_TIMSEL = (2 << 24);  ///< minimum cross conduction protection time setting
        constexpr uint32_t DSMONVTH = (3 << 16);  ///< Voltage Threshold for Drain-Source Monitoring of external FETs
        constexpr uint32_t OFF_SEQ_EN = (1U << 15);  ///< Turn Off Slewrate Sequencer enable
        constexpr uint32_t IDISCHARGEDIV2_N = (1U << 14);  ///< IDISCHARGE Current divide by 2 not
        constexpr uint32_t IDISCHARGE_TRIM = (5 << 8);  ///< Trimming of the internal driver dis-charge current
        constexpr uint32_t ON_SEQ_EN = (1U << 7);  ///< Turn On SlewrateSequencer enable
        constexpr uint32_t ICHARGEDIV2_N = (1U << 6);  ///< ICHARGE Current divide by 2 not
        constexpr uint32_t ICHARGE_TRIM = (5 << 0);  ///< Trimming of the internal driver charge current
    }

    /// OFF_SEQ_CTRL Register bits
    namespace off_seq_ctrl_bits {
        constexpr uint32_t DRV_OFF_I_1 = (5 << 27);  ///< Slew rate sequencer off phase 1 current
        constexpr uint32_t DRV_OFF_t_1 = (3 << 24);  ///< Slew rate sequencer off phase 1 time
        constexpr uint32_t DRV_OFF_I_2 = (5 << 19);  ///< Slew rate sequencer off phase 2 current
        constexpr uint32_t DRV_OFF_t_2 = (3 << 16);  ///< Slew rate sequencer off phase 2 time
        constexpr uint32_t DRV_OFF_I_3 = (5 << 11);  ///< Slew rate sequencer off phase 3 current
        constexpr uint32_t DRV_OFF_t_3 = (3 << 8);  ///< Slew rate sequencer off phase 3 time
        constexpr uint32_t DRV_OFF_I_4 = (5 << 3);  ///< Slew rate sequencer off phase 4 current
        constexpr uint32_t DRV_OFF_t_4 = (3 << 0);  ///< Slew rate sequencer off phase 4 time
    }

    /// ON_SEQ_CTRL Register bits
    namespace on_seq_ctrl_bits {
        constexpr uint32_t DRV_ON_I_1 = (5 << 27);  ///< Slew rate sequencer on phase 1 current
        constexpr uint32_t DRV_ON_t_1 = (3 << 24);  ///< Slew rate sequencer on phase 1 time
        constexpr uint32_t DRV_ON_I_2 = (5 << 19);  ///< Slew rate sequencer on phase 2 current
        constexpr uint32_t DRV_ON_t_2 = (3 << 16);  ///< Slew rate sequencer on phase 2 time
        constexpr uint32_t DRV_ON_I_3 = (5 << 11);  ///< Slew rate sequencer on phase 3 current
        constexpr uint32_t DRV_ON_t_3 = (3 << 8);  ///< Slew rate sequencer on phase 3 time
        constexpr uint32_t DRV_ON_I_4 = (5 << 3);  ///< Slew rate sequencer on phase 4 current
        constexpr uint32_t DRV_ON_t_4 = (3 << 0);  ///< Slew rate sequencer on phase 4 time
    }

    /// TRIM_DRVx Register bits
    namespace trim_drvx_bits {
        constexpr uint32_t CPLOW_TFILT_SEL = (2 << 24);  ///< Filter Time for Charge Pump Voltage Low Diagnosis
        constexpr uint32_t HS2DRV_OCSDN_DIS = (1U << 22);  ///< High Side 2 Predriver in overcurrent situation disable
        constexpr uint32_t HS1DRV_OCSDN_DIS = (1U << 21);  ///< High Side 1 Predriver in overcurrent situation disable
        constexpr uint32_t HS2DRV_FDISCHG_DIS = (1U << 19);  ///< High Side 2 Predriver in overcurrent situation disable
        constexpr uint32_t HS1DRV_FDISCHG_DIS = (1U << 18);  ///< High Side 1 Predriver in overcurrent situation disable
        constexpr uint32_t HSDRV_DS_TFILT_SEL = (2 << 16);  ///< Filter Time for Drain-Source Monitoring of High Side Drivers
        constexpr uint32_t LS2DRV_OCSDN_DIS = (1U << 14);  ///< Low Side 2 Predriver in overcurrent situation disable
        constexpr uint32_t LS1DRV_OCSDN_DIS = (1U << 13);  ///< Low Side 1 Predriver in overcurrent situation disable
        constexpr uint32_t LS2DRV_FDISCHG_DIS = (1U << 11);  ///< Low Side 2 Predriver in overcurrent situation disable
        constexpr uint32_t LS1DRV_FDISCHG_DIS = (1U << 10);  ///< Low Side 1 Predriver in overcurrent situation disable
        constexpr uint32_t LSDRV_DS_TFILT_SEL = (2 << 8);  ///< Filter Time for Drain-Source Monitoring of Low Side Drivers
        constexpr uint32_t DRV_CCPTIMMUL = (2 << 5);  ///< Multiplier bits for cross conduction time settings in register DRV_CCP_TIMSEL
        constexpr uint32_t LS_HS_BT_TFILT_SEL = (2 << 0);  ///< Blanking Time for Drain-Source Monitoring of Low / High Side Drivers
    }

}

// ============================================================================
// CCU6 Peripheral
// ============================================================================

namespace ccu6 {
    /// Base addresses
    constexpr uint32_t CCU6_BASE = 0x4000C000;

    /// CCU6 Register structure
    struct Registers {
        volatile uint32_t CC60R;  ///< Offset: 0x34 - Capture/Compare Register for Channel CC60
        volatile uint32_t CC60SR;  ///< Offset: 0x14 - Capture/Compare Shadow Register for Channel CC60
        volatile uint32_t CC61R;  ///< Offset: 0x38 - Capture/Compare Register for Channel CC61
        volatile uint32_t CC61SR;  ///< Offset: 0x18 - Capture/Compare Shadow Register for Channel CC61
        volatile uint32_t CC62R;  ///< Offset: 0x3C - Capture/Compare Register for Channel CC62
        volatile uint32_t CC62SR;  ///< Offset: 0x1C - Capture/Compare Shadow Register for Channel CC62
        volatile uint32_t CC63R;  ///< Offset: 0x00 - Capture/Compare Register for Channel CC63
        volatile uint32_t CC63SR;  ///< Offset: 0x20 - Capture/Compare Shadow Register for Channel CC63
        volatile uint32_t CMPMODIF;  ///< Offset: 0x10 - Compare State Modification Register
        volatile uint32_t CMPSTAT;  ///< Offset: 0x80 - Compare State Register
        volatile uint32_t IEN;  ///< Offset: 0x44 - Capture/Compare Interrupt Enable Register
        volatile uint32_t INP;  ///< Offset: 0x48 - Capture/Compare Interrupt Node Pointer Register
        volatile uint32_t IS;  ///< Offset: 0x68 - Capture/Compare Interrupt Status Register
        volatile uint32_t ISR;  ///< Offset: 0x0C - Capture/Compare Interrupt Status Reset Register
        volatile uint32_t ISS;  ///< Offset: 0x4C - Capture/Compare Interrupt Status Set Register
        volatile uint32_t MCMCTR;  ///< Offset: 0x54 - Multi-Channel Mode Control Register
        volatile uint32_t MCMOUT;  ///< Offset: 0x64 - Multi-Channel Mode Output Register
        volatile uint32_t MCMOUTS;  ///< Offset: 0x08 - Multi-Channel Mode Output Shadow Register
        volatile uint32_t MODCTR;  ///< Offset: 0x5C - Modulation Control Register
        volatile uint32_t PISEL0;  ///< Offset: 0x6C - Port Input Select Register 0
        volatile uint32_t PISEL2;  ///< Offset: 0x74 - Port Input Select Register 2
        volatile uint32_t PSLR;  ///< Offset: 0x50 - Passive State Level Register
        volatile uint32_t T12;  ///< Offset: 0x78 - Timer T12 Counter Register
        volatile uint32_t T12DTC;  ///< Offset: 0x2C - Timer T12 Dead-Time Control Register
        volatile uint32_t T12MSEL;  ///< Offset: 0x40 - Capture/Compare T12 Mode Select Register
        volatile uint32_t T12PR;  ///< Offset: 0x24 - Timer T12 Period Register
        volatile uint32_t T13;  ///< Offset: 0x7C - Timer T13 Counter Register
        volatile uint32_t T13PR;  ///< Offset: 0x28 - Timer T13 Period Register
        volatile uint32_t TCTR0;  ///< Offset: 0x30 - Timer Control Register 0
        volatile uint32_t TCTR2;  ///< Offset: 0x58 - Timer Control Register 2
        volatile uint32_t TCTR4;  ///< Offset: 0x04 - Timer Control Register 4
        volatile uint32_t TRPCTR;  ///< Offset: 0x60 - Trap Control Register
    };

    /// Peripheral instances
    inline Registers* CCU6 = reinterpret_cast<Registers*>(CCU6_BASE);

    // Bit definitions
    /// CC60R Register bits
    namespace cc60r_bits {
        constexpr uint32_t CCV = (16 << 0);  ///< Channel x Capture/Compare Value
    }

    /// CC60SR Register bits
    namespace cc60sr_bits {
        constexpr uint32_t CCS = (16 << 0);  ///< Shadow Register for Channel x Capture/Compare Value
    }

    /// CC61R Register bits
    namespace cc61r_bits {
        constexpr uint32_t CCV = (16 << 0);  ///< Channel x Capture/Compare Value
    }

    /// CC61SR Register bits
    namespace cc61sr_bits {
        constexpr uint32_t CCS = (16 << 0);  ///< Shadow Register for Channel x Capture/Compare Value
    }

    /// CC62R Register bits
    namespace cc62r_bits {
        constexpr uint32_t CCV = (16 << 0);  ///< Channel x Capture/Compare Value
    }

    /// CC62SR Register bits
    namespace cc62sr_bits {
        constexpr uint32_t CCS = (16 << 0);  ///< Shadow Register for Channel x Capture/Compare Value
    }

    /// CC63R Register bits
    namespace cc63r_bits {
        constexpr uint32_t CCV = (16 << 0);  ///< Channel CC63 Compare Value
    }

    /// CC63SR Register bits
    namespace cc63sr_bits {
        constexpr uint32_t CCS = (16 << 0);  ///< Shadow Register for Channel CC63 Compare Value
    }

    /// CMPMODIF Register bits
    namespace cmpmodif_bits {
        constexpr uint32_t MCC60S = (1U << 0);  ///< Capture/Compare Status Modification Bits (Set) (x = 0, 1, 2, 3)
        constexpr uint32_t MCC61S = (1U << 1);  ///< Capture/Compare Status Modification Bits (Set) (x = 0, 1, 2, 3)
        constexpr uint32_t MCC62S = (1U << 2);  ///< Capture/Compare Status Modification Bits (Set) (x = 0, 1, 2, 3)
        constexpr uint32_t MCC63S = (1U << 6);  ///< Capture/Compare Status Modification Bits (Set) (x = 0, 1, 2, 3)
        constexpr uint32_t MCC60R = (1U << 8);  ///< Capture/Compare Status Modification Bits (Reset) (x = 0, 1, 2, 3)
        constexpr uint32_t MCC61R = (1U << 9);  ///< Capture/Compare Status Modification Bits (Reset) (x = 0, 1, 2, 3)
        constexpr uint32_t MCC62R = (1U << 10);  ///< Capture/Compare Status Modification Bits (Reset) (x = 0, 1, 2, 3)
        constexpr uint32_t MCC63R = (1U << 14);  ///< Capture/Compare Status Modification Bits (Reset) (x = 0, 1, 2, 3)
    }

    /// CMPSTAT Register bits
    namespace cmpstat_bits {
        constexpr uint32_t CC60ST = (1U << 0);  ///< Capture/Compare State Bits (x = 0, 1, 2, 3)
        constexpr uint32_t CC61ST = (1U << 1);  ///< Capture/Compare State Bits (x = 0, 1, 2, 3)
        constexpr uint32_t CC62ST = (1U << 2);  ///< Capture/Compare State Bits (x = 0, 1, 2, 3)
        constexpr uint32_t CC63ST = (1U << 6);  ///< Capture/Compare State Bits (x = 0, 1, 2, 3)
        constexpr uint32_t CCPOS0 = (1U << 3);  ///< Sampled Hall Pattern Bits (x = 0, 1, 2)
        constexpr uint32_t CCPOS1 = (1U << 4);  ///< Sampled Hall Pattern Bits (x = 0, 1, 2)
        constexpr uint32_t CCPOS2 = (1U << 5);  ///< Sampled Hall Pattern Bits (x = 0, 1, 2)
        constexpr uint32_t CC60PS = (1U << 8);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t CC61PS = (1U << 10);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t CC62PS = (1U << 12);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t COUT60PS = (1U << 9);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t COUT61PS = (1U << 11);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t COUT62PS = (1U << 13);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t COUT63PS = (1U << 14);  ///< Passive State Select for Compare Outputs
        constexpr uint32_t T13IM = (1U << 15);  ///< T13 Inverted Modulation
    }

    /// IEN Register bits
    namespace ien_bits {
        constexpr uint32_t ENCC60R = (1U << 0);  ///< Capture, Compare-Match Rising Edge Interrupt Enable for Channel 0
        constexpr uint32_t ENCC60F = (1U << 1);  ///< Capture, Compare-Match Falling Edge Interrupt Enable for Channel 0
        constexpr uint32_t ENCC61R = (1U << 2);  ///< Capture, Compare-Match Rising Edge Interrupt Enable for Channel 1
        constexpr uint32_t ENCC61F = (1U << 3);  ///< Capture, Compare-Match Falling Edge Interrupt Enable for Channel 1
        constexpr uint32_t ENCC62R = (1U << 4);  ///< Capture, Compare-Match Rising Edge Interrupt Enable for Channel 2
        constexpr uint32_t ENCC62F = (1U << 5);  ///< Capture, Compare-Match Falling Edge Interrupt Enable for Channel 2
        constexpr uint32_t ENT12OM = (1U << 6);  ///< Enable Interrupt for T12 One-Match
        constexpr uint32_t ENT12PM = (1U << 7);  ///< Enable Interrupt for T12 Period-Match
        constexpr uint32_t ENT13CM = (1U << 8);  ///< Enable Interrupt for T13 Compare-Match
        constexpr uint32_t ENT13PM = (1U << 9);  ///< Enable Interrupt for T13 Period-Match
        constexpr uint32_t ENTRPF = (1U << 10);  ///< Enable Interrupt for Trap Flag
        constexpr uint32_t ENCHE = (1U << 12);  ///< Enable Interrupt for Correct Hall Event
        constexpr uint32_t ENWHE = (1U << 13);  ///< Enable Interrupt for Wrong Hall Event
        constexpr uint32_t ENIDLE = (1U << 14);  ///< Enable Idle
        constexpr uint32_t ENSTR = (1U << 15);  ///< Enable Multi-Channel Mode Shadow Transfer Interrupt
    }

    /// INP Register bits
    namespace inp_bits {
        constexpr uint32_t INPCC60 = (2 << 0);  ///< Interrupt Node Pointer for Channel 0 Interrupts
        constexpr uint32_t INPCC61 = (2 << 2);  ///< Interrupt Node Pointer for Channel 1 Interrupts
        constexpr uint32_t INPCC62 = (2 << 4);  ///< Interrupt Node Pointer for Channel 2 Interrupts
        constexpr uint32_t INPCHE = (2 << 6);  ///< Interrupt Node Pointer for the CHE Interrupt
        constexpr uint32_t INPERR = (2 << 8);  ///< Interrupt Node Pointer for Error Interrupts
        constexpr uint32_t INPT12 = (2 << 10);  ///< Interrupt Node Pointer for Timer T12 Interrupts
        constexpr uint32_t INPT13 = (2 << 12);  ///< Interrupt Node Pointer for Timer T13 Interrupts
    }

    /// IS Register bits
    namespace is_bits {
        constexpr uint32_t ICC60R = (1U << 0);  ///< Capture, Compare-Match Rising Edge Flag (x = 0, 1, 2)
        constexpr uint32_t ICC61R = (1U << 2);  ///< Capture, Compare-Match Rising Edge Flag (x = 0, 1, 2)
        constexpr uint32_t ICC62R = (1U << 4);  ///< Capture, Compare-Match Rising Edge Flag (x = 0, 1, 2)
        constexpr uint32_t ICC60F = (1U << 1);  ///< Capture, Compare-Match Falling Edge Flag (x = 0, 1, 2)
        constexpr uint32_t ICC61F = (1U << 3);  ///< Capture, Compare-Match Falling Edge Flag (x = 0, 1, 2)
        constexpr uint32_t ICC62F = (1U << 5);  ///< Capture, Compare-Match Falling Edge Flag (x = 0, 1, 2)
        constexpr uint32_t T12OM = (1U << 6);  ///< Timer T12 One-Match Flag
        constexpr uint32_t T12PM = (1U << 7);  ///< Timer T12 Period-Match Flag
        constexpr uint32_t T13CM = (1U << 8);  ///< Timer T13 Compare-Match Flag
        constexpr uint32_t T13PM = (1U << 9);  ///< Timer T13 Period-Match Flag
        constexpr uint32_t TRPF = (1U << 10);  ///< Trap Flag
        constexpr uint32_t TRPS = (1U << 11);  ///< Trap State
        constexpr uint32_t CHE = (1U << 12);  ///< Correct Hall Event
        constexpr uint32_t WHE = (1U << 13);  ///< Wrong Hall Event
        constexpr uint32_t IDLE = (1U << 14);  ///< IDLE State
        constexpr uint32_t STR = (1U << 15);  ///< Multi-Channel Mode Shadow Transfer Request
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t RCC60R = (1U << 0);  ///< Reset Capture, Compare-Match Rising Edge Flag
        constexpr uint32_t RCC60F = (1U << 1);  ///< Reset Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t RCC61R = (1U << 2);  ///< Reset Capture, Compare-Match Rising Edge Flag
        constexpr uint32_t RCC61F = (1U << 3);  ///< Reset Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t RCC62R = (1U << 4);  ///< Reset Capture, Compare-Match Rising Edge Flag
        constexpr uint32_t RCC62F = (1U << 5);  ///< Reset Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t RT12OM = (1U << 6);  ///< Reset Timer T12 One-Match Flag
        constexpr uint32_t RT12PM = (1U << 7);  ///< Reset Timer T12 Period-Match Flag
        constexpr uint32_t RT13CM = (1U << 8);  ///< Reset Timer T13 Compare-Match Flag
        constexpr uint32_t RT13PM = (1U << 9);  ///< Reset Timer T13 Period-Match Flag
        constexpr uint32_t RTRPF = (1U << 10);  ///< Reset Trap Flag
        constexpr uint32_t RCHE = (1U << 12);  ///< Reset Correct Hall Event Flag
        constexpr uint32_t RWHE = (1U << 13);  ///< Reset Wrong Hall Event Flag
        constexpr uint32_t RIDLE = (1U << 14);  ///< Reset IDLE Flag
        constexpr uint32_t RSTR = (1U << 15);  ///< Reset STR Flag
    }

    /// ISS Register bits
    namespace iss_bits {
        constexpr uint32_t SCC60R = (1U << 0);  ///< Set Capture, Compare-Match Rising Edge Flag
        constexpr uint32_t SCC60F = (1U << 1);  ///< Set Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t SCC61R = (1U << 2);  ///< Set Capture, Compare-Match Rising Edge Flag
        constexpr uint32_t SCC61F = (1U << 3);  ///< Set Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t SCC62R = (1U << 4);  ///< Set Capture, Compare-Match Rising Edge Flag
        constexpr uint32_t SCC62F = (1U << 5);  ///< Set Capture, Compare-Match Falling Edge Flag
        constexpr uint32_t ST12OM = (1U << 6);  ///< Set Timer T12 One-Match Flag
        constexpr uint32_t ST12PM = (1U << 7);  ///< Set Timer T12 Period-Match Flag
        constexpr uint32_t ST13CM = (1U << 8);  ///< Set Timer T13 Compare-Match Flag
        constexpr uint32_t ST13PM = (1U << 9);  ///< Set Timer T13 Period-Match Flag
        constexpr uint32_t STRPF = (1U << 10);  ///< Set Trap Flag
        constexpr uint32_t SWHC = (1U << 11);  ///< Software Hall Compare
        constexpr uint32_t SCHE = (1U << 12);  ///< Set Correct Hall Event Flag
        constexpr uint32_t SWHE = (1U << 13);  ///< Set Wrong Hall Event Flag
        constexpr uint32_t SIDLE = (1U << 14);  ///< Set IDLE Flag
        constexpr uint32_t SSTR = (1U << 15);  ///< Set STR Flag
    }

    /// MCMCTR Register bits
    namespace mcmctr_bits {
        constexpr uint32_t SWSEL = (3 << 0);  ///< Switching Selection
        constexpr uint32_t SWSYN = (2 << 4);  ///< Switching Synchronization
        constexpr uint32_t STE12U = (1U << 8);  ///< Shadow Transfer Enable for T12 Upcounting
        constexpr uint32_t STE12D = (1U << 9);  ///< Shadow Transfer Enable for T12 Downcounting
        constexpr uint32_t STE13U = (1U << 10);  ///< Shadow Transfer Enable for T13 Upcounting
    }

    /// MCMOUT Register bits
    namespace mcmout_bits {
        constexpr uint32_t MCMP = (6 << 0);  ///< Multi-Channel PWM Pattern
        constexpr uint32_t R = (1U << 6);  ///< Reminder Flag
        constexpr uint32_t EXPH = (3 << 8);  ///< Expected Hall Pattern
        constexpr uint32_t CURH = (3 << 11);  ///< Current Hall Pattern
    }

    /// MCMOUTS Register bits
    namespace mcmouts_bits {
        constexpr uint32_t MCMPS = (6 << 0);  ///< Multi-Channel PWM Pattern Shadow
        constexpr uint32_t STRMCM = (1U << 7);  ///< Shadow Transfer Request for MCMPS
        constexpr uint32_t EXPHS = (3 << 8);  ///< Expected Hall Pattern Shadow
        constexpr uint32_t CURHS = (3 << 11);  ///< Current Hall Pattern Shadow
        constexpr uint32_t STRHP = (1U << 15);  ///< Shadow Transfer Request for the Hall Pattern
    }

    /// MODCTR Register bits
    namespace modctr_bits {
        constexpr uint32_t T12MODEN = (6 << 0);  ///< T12 Modulation Enable
        constexpr uint32_t MCMEN = (1U << 7);  ///< Multi-Channel Mode Enable
        constexpr uint32_t T13MODEN = (6 << 8);  ///< T13 Modulation Enable
        constexpr uint32_t ECT13O = (1U << 15);  ///< Enable Compare Timer T13 Output
    }

    /// PISEL0 Register bits
    namespace pisel0_bits {
        constexpr uint32_t ISCC60 = (2 << 0);  ///< Input Select for CC60
        constexpr uint32_t ISCC61 = (2 << 2);  ///< Input Select for CC61
        constexpr uint32_t ISCC62 = (2 << 4);  ///< Input Select for CC62
        constexpr uint32_t ISTRP = (2 << 6);  ///< Input Select for CTRAP
        constexpr uint32_t ISPOS0 = (2 << 8);  ///< Input Select for CCPOS0
        constexpr uint32_t ISPOS1 = (2 << 10);  ///< Input Select for CCPOS1
        constexpr uint32_t ISPOS2 = (2 << 12);  ///< Input Select for CCPOS2
        constexpr uint32_t IST12HR = (2 << 14);  ///< Input Select for T12HR
    }

    /// PISEL2 Register bits
    namespace pisel2_bits {
        constexpr uint32_t IST13HR = (2 << 0);  ///< Input Select for T13HR
        constexpr uint32_t ISCNT12 = (2 << 2);  ///< Input Select for T12 Counting Input
        constexpr uint32_t ISCNT13 = (2 << 4);  ///< Input Select for T13 Counting Input
        constexpr uint32_t T12EXT = (1U << 6);  ///< Extension for T12HR Inputs
        constexpr uint32_t T13EXT = (1U << 7);  ///< Extension for T13HR Inputs
    }

    /// PSLR Register bits
    namespace pslr_bits {
        constexpr uint32_t PSL = (6 << 0);  ///< Compare Outputs Passive State Level
        constexpr uint32_t PSL63 = (1U << 7);  ///< Passive State Level of Output COUT63
    }

    /// T12 Register bits
    namespace t12_bits {
        constexpr uint32_t T12CV = (16 << 0);  ///< Timer T12 Counter Value
    }

    /// T12DTC Register bits
    namespace t12dtc_bits {
        constexpr uint32_t DTM = (8 << 0);  ///< Dead-Time
        constexpr uint32_t DTE0 = (1U << 8);  ///< Dead-Time Enable Bits
        constexpr uint32_t DTE1 = (1U << 9);  ///< Dead-Time Enable Bits
        constexpr uint32_t DTE2 = (1U << 10);  ///< Dead-Time Enable Bits
        constexpr uint32_t DTR0 = (1U << 12);  ///< Dead-Time Run Indication Bits
        constexpr uint32_t DTR1 = (1U << 13);  ///< Dead-Time Run Indication Bits
        constexpr uint32_t DTR2 = (1U << 14);  ///< Dead-Time Run Indication Bits
    }

    /// T12MSEL Register bits
    namespace t12msel_bits {
        constexpr uint32_t MSEL60 = (4 << 0);  ///< Capture/Compare Mode Selection
        constexpr uint32_t MSEL61 = (4 << 4);  ///< Capture/Compare Mode Selection
        constexpr uint32_t MSEL62 = (4 << 8);  ///< Capture/Compare Mode Selection
        constexpr uint32_t HSYNC = (3 << 12);  ///< Hall Synchronization
        constexpr uint32_t DBYP = (1U << 15);  ///< Delay Bypass
    }

    /// T12PR Register bits
    namespace t12pr_bits {
        constexpr uint32_t T12PV = (16 << 0);  ///< T12 Period Value
    }

    /// T13 Register bits
    namespace t13_bits {
        constexpr uint32_t T13CV = (16 << 0);  ///< Timer T13 Counter Value
    }

    /// T13PR Register bits
    namespace t13pr_bits {
        constexpr uint32_t T13PV = (16 << 0);  ///< T13 Period Value
    }

    /// TCTR0 Register bits
    namespace tctr0_bits {
        constexpr uint32_t T12CLK = (3 << 0);  ///< Timer T12 Input Clock Select
        constexpr uint32_t T12PRE = (1U << 3);  ///< Timer T12 Prescaler Bit
        constexpr uint32_t T12R = (1U << 4);  ///< Timer T12 Run Bit
        constexpr uint32_t STE12 = (1U << 5);  ///< Timer T12 Shadow Transfer Enable
        constexpr uint32_t CDIR = (1U << 6);  ///< Count Direction of Timer T12
        constexpr uint32_t CTM = (1U << 7);  ///< T12 Operating Mode
        constexpr uint32_t T13CLK = (3 << 8);  ///< Timer T13 Input Clock Select
        constexpr uint32_t T13PRE = (1U << 11);  ///< Timer T13 Prescaler Bit
        constexpr uint32_t T13R = (1U << 12);  ///< Timer T13 Run Bit
        constexpr uint32_t STE13 = (1U << 13);  ///< Timer T13 Shadow Transfer Enable
    }

    /// TCTR2 Register bits
    namespace tctr2_bits {
        constexpr uint32_t T12SSC = (1U << 0);  ///< Timer T12 Single Shot Control
        constexpr uint32_t T13SSC = (1U << 1);  ///< Timer T13 Single Shot Control
        constexpr uint32_t T13TEC = (3 << 2);  ///< T13 Trigger Event Control
        constexpr uint32_t T13TED = (2 << 5);  ///< Timer T13 Trigger Event Direction
        constexpr uint32_t T12RSEL = (2 << 8);  ///< Timer T12 External Run Selection
        constexpr uint32_t T13RSEL = (2 << 10);  ///< Timer T13 External Run Selection
    }

    /// TCTR4 Register bits
    namespace tctr4_bits {
        constexpr uint32_t T12RR = (1U << 0);  ///< Timer T12 Run Reset
        constexpr uint32_t T12RS = (1U << 1);  ///< Timer T12 Run Set
        constexpr uint32_t T12RES = (1U << 2);  ///< Timer T12 Reset
        constexpr uint32_t DTRES = (1U << 3);  ///< Dead-Time Counter Reset
        constexpr uint32_t T12CNT = (1U << 5);  ///< Timer T12 Count Event
        constexpr uint32_t T12STR = (1U << 6);  ///< Timer T12 Shadow Transfer Request
        constexpr uint32_t T12STD = (1U << 7);  ///< Timer T12 Shadow Transfer Disable
        constexpr uint32_t T13RR = (1U << 8);  ///< Timer T13 Run Reset
        constexpr uint32_t T13RS = (1U << 9);  ///< Timer T13 Run Set
        constexpr uint32_t T13RES = (1U << 10);  ///< Timer T13 Reset
        constexpr uint32_t T13CNT = (1U << 13);  ///< Timer T13 Count Event
        constexpr uint32_t T13STR = (1U << 14);  ///< Timer T13 Shadow Transfer Request
        constexpr uint32_t T13STD = (1U << 15);  ///< Timer T13 Shadow Transfer Disable
    }

    /// TRPCTR Register bits
    namespace trpctr_bits {
        constexpr uint32_t TRPM0 = (1U << 0);  ///< Trap Mode Control Bits 1, 0
        constexpr uint32_t TRPM1 = (1U << 1);  ///< Trap Mode Control Bits 1, 0
        constexpr uint32_t TRPM2 = (1U << 2);  ///< Trap Mode Control Bit 2
        constexpr uint32_t TRPEN = (6 << 8);  ///< Trap Enable Control
        constexpr uint32_t TRPEN13 = (1U << 14);  ///< Trap Enable Control for Timer T13
        constexpr uint32_t TRPPEN = (1U << 15);  ///< Trap Pin Enable
    }

}

// ============================================================================
// CPU Peripheral
// ============================================================================

namespace cpu {
    /// Base addresses
    constexpr uint32_t CPU_BASE = 0xE000E000;

    /// CPU Register structure
    struct Registers {
        volatile uint32_t AFSR;  ///< Offset: 0xD3C - Auxiliary Fault Status Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt/Reset Control Register
        volatile uint32_t BFAR;  ///< Offset: 0xD38 - Bus Fault Status Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration Control Register
        volatile uint32_t CFSR;  ///< Offset: 0xD28 - Configurable Fault Status Register
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPU ID Base Register
        volatile uint32_t DFSR;  ///< Offset: 0xD30 - Debug Fault Status Register
        volatile uint32_t HFSR;  ///< Offset: 0xD2C - Hard Fault Status Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control State Register
        volatile uint32_t ICT;  ///< Offset: 0x04 - Interrupt Controller Type
        volatile uint32_t MMFAR;  ///< Offset: 0xD34 - MemManage Fault Status Register
        volatile uint32_t NVIC_IABR0;  ///< Offset: 0x300 - Active Bit Register Interrupt Active Flags
        volatile uint32_t NVIC_ICER0;  ///< Offset: 0x180 - Interrupt Clear-Enable
        volatile uint32_t NVIC_ICPR0;  ///< Offset: 0x280 - Interrupt Clear-Pending
        volatile uint32_t NVIC_IPR0;  ///< Offset: 0x400 - Interrupt Priority
        volatile uint32_t NVIC_IPR1;  ///< Offset: 0x404 - Interrupt Priority
        volatile uint32_t NVIC_IPR2;  ///< Offset: 0x408 - Interrupt Priority
        volatile uint32_t NVIC_IPR3;  ///< Offset: 0x40C - Interrupt Priority
        volatile uint32_t NVIC_ISER0;  ///< Offset: 0x100 - Interrupt Set-Enable
        volatile uint32_t NVIC_ISPR0;  ///< Offset: 0x200 - Interrupt Set-Pending
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
        volatile uint32_t SHPR1;  ///< Offset: 0xD18 - System Handler Priority Register 1
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SYSTICK_CAL;  ///< Offset: 0x1C - SysTick Calibration Value
        volatile uint32_t SYSTICK_CS;  ///< Offset: 0x10 - SysTick Control and Status
        volatile uint32_t SYSTICK_CUR;  ///< Offset: 0x18 - SysTick Current Value
        volatile uint32_t SYSTICK_RL;  ///< Offset: 0x14 - SysTick Reload Value
        volatile uint32_t VTOR;  ///< Offset: 0xD08 - Vector Table Offset Register
    };

    /// Peripheral instances
    inline Registers* CPU = reinterpret_cast<Registers*>(CPU_BASE);

    // Bit definitions
    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t CP0 = (2 << 0);  ///< Access Privileges for Coprocessor 0 (n= 0-7, 10, 11)
        constexpr uint32_t CP1 = (2 << 2);  ///< Access Privileges for Coprocessor 1 (n= 0-7, 10, 11)
        constexpr uint32_t CP2 = (2 << 4);  ///< Access Privileges for Coprocessor 2 (n= 0-7, 10, 11)
        constexpr uint32_t CP3 = (2 << 6);  ///< Access Privileges for Coprocessor 3 (n= 0-7, 10, 11)
        constexpr uint32_t CP4 = (2 << 8);  ///< Access Privileges for Coprocessor 4 (n= 0-7, 10, 11)
        constexpr uint32_t CP5 = (2 << 10);  ///< Access Privileges for Coprocessor 5 (n= 0-7, 10, 11)
        constexpr uint32_t CP6 = (2 << 12);  ///< Access Privileges for Coprocessor 6 (n= 0-7, 10, 11)
        constexpr uint32_t CP7 = (2 << 14);  ///< Access Privileges for Coprocessor 7 (n= 0-7, 10, 11)
        constexpr uint32_t CP10 = (2 << 20);  ///< Access Privileges for Coprocessor 10 (n= 0-7, 10, 11)
        constexpr uint32_t CP11 = (2 << 22);  ///< Access Privileges for Coprocessor 11 (n= 0-7, 10, 11)
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Vector Key
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< Memory System Endianness
        constexpr uint32_t PRIGROUP = (3 << 8);  ///< Priority Grouping
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< System Reset Request
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< VECTCLRACTIVE for debug only
        constexpr uint32_t VECTRESET = (1U << 0);  ///< VECTRESET for debug only
    }

    /// BFAR Register bits
    namespace bfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Data Address for a precise BusFault
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t STKALIGN = (1U << 9);  ///< stack alignment
        constexpr uint32_t BFHFMIGN = (1U << 8);  ///< Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Enables unaligned access traps
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< Enables unprivileged software access to the STIR
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< Indicates how the processor enters Thread mode
    }

    /// CFSR Register bits
    namespace cfsr_bits {
        constexpr uint32_t DIVBYZERO = (1U << 25);  ///< Divide by Zero
        constexpr uint32_t UNALIGNED = (1U << 24);  ///< Unaligned access UsageFault
        constexpr uint32_t NOCP = (1U << 19);  ///< No coprocessor UsageFault
        constexpr uint32_t INVPC = (1U << 18);  ///< Invalid PC load UsageFault
        constexpr uint32_t INVSTATE = (1U << 17);  ///< Invalid state UsageFault
        constexpr uint32_t UNDEFINSTR = (1U << 16);  ///< Undefined instruction UsageFault
        constexpr uint32_t BFARVALID = (1U << 15);  ///< BFAR Valid
        constexpr uint32_t STKERR = (1U << 12);  ///< BusFault on stacking for exception entry
        constexpr uint32_t UNSTKERR = (1U << 11);  ///< BusFault on unstacking for a return from exception
        constexpr uint32_t IMPRECISERR = (1U << 10);  ///< Imprecise data bus error
        constexpr uint32_t PRECISERR = (1U << 9);  ///< Precise data bus error
        constexpr uint32_t IBUSERR = (1U << 8);  ///< Instruction bus error
        constexpr uint32_t MMARVALID = (1U << 7);  ///< MemManage Fault Address Register (MMFAR) valid flag
        constexpr uint32_t MSTERR = (1U << 4);  ///< MemManage fault on stacking for exception entry
        constexpr uint32_t MUNSTKERR = (1U << 3);  ///< MemManage fault on unstacking for a return from exception
        constexpr uint32_t DACCVIOL = (1U << 1);  ///< Data access violation flag
        constexpr uint32_t IACCVIOL = (1U << 0);  ///< Instruction access violation flag
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t IMPLEMENTER = (8 << 24);  ///< Implementer Code
        constexpr uint32_t VARIANT = (4 << 20);  ///< Variant Number
        constexpr uint32_t ARCHITECTURE = (4 << 16);  ///< Architecture
        constexpr uint32_t PARTNO = (12 << 4);  ///< Part Number
        constexpr uint32_t REVISION = (4 << 0);  ///< Revision Number
    }

    /// DFSR Register bits
    namespace dfsr_bits {
        constexpr uint32_t EXTERNAL = (1U << 4);  ///< External
        constexpr uint32_t VCATCH = (1U << 3);  ///< Vector Catch
        constexpr uint32_t DWTTRAP = (1U << 2);  ///< DWTTRAP
        constexpr uint32_t BKPT = (1U << 1);  ///< BKPT
        constexpr uint32_t HALTED = (1U << 0);  ///< HALTED
    }

    /// HFSR Register bits
    namespace hfsr_bits {
        constexpr uint32_t DEBUGEVT = (1U << 31);  ///< Debug Event
        constexpr uint32_t FORCED = (1U << 30);  ///< Forced
        constexpr uint32_t VECTTBL = (1U << 1);  ///< VECTTBL
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI PendSet
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV set-pending bit
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV clear-pending bit
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick exception set-pending bit
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick exception clear-pending bit
        constexpr uint32_t ISRPREEMPT = (1U << 23);  ///< ISRPREEMPT
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag. Excludes NMI and Faults
        constexpr uint32_t VECTPENDING = (9 << 12);  ///< Pending ISR number field
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< RETTOBASE
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active ISR number field
    }

    /// ICT Register bits
    namespace ict_bits {
        constexpr uint32_t INTLINESNUM = (5 << 0);  ///< Interrupt Lines
    }

    /// MMFAR Register bits
    namespace mmfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Data Address for an MPU Fault
    }

    /// NVIC_IABR0 Register bits
    namespace nvic_iabr0_bits {
        constexpr uint32_t Int_BDRV = (1U << 14);  ///< Interrupt Active for Bridge Driver
        constexpr uint32_t Int_EXINT1 = (1U << 13);  ///< Interrupt Active for External Int 1
        constexpr uint32_t Int_EXINT0 = (1U << 12);  ///< Interrupt Active for External Int 0
        constexpr uint32_t Int_UART2 = (1U << 11);  ///< Interrupt Active for UART2
        constexpr uint32_t Int_UART1 = (1U << 10);  ///< Interrupt Active for UART1
        constexpr uint32_t Int_SSC2 = (1U << 9);  ///< Interrupt Active for SSC2
        constexpr uint32_t Int_SSC1 = (1U << 8);  ///< Interrupt Active for SSC1
        constexpr uint32_t Int_CCU6SR3 = (1U << 7);  ///< Interrupt Active for CCU6 SR3
        constexpr uint32_t Int_CCU6SR2 = (1U << 6);  ///< Interrupt Active for CCU6 SR2
        constexpr uint32_t Int_CCU6SR1 = (1U << 5);  ///< Interrupt Active for CCU6 SR1
        constexpr uint32_t Int_CCU6SR0 = (1U << 4);  ///< Interrupt Active for CCU6 SR0
        constexpr uint32_t Int_ADC1 = (1U << 3);  ///< Interrupt Active for ADC1
        constexpr uint32_t Int_ADC2 = (1U << 2);  ///< Interrupt Active for MU, ADC2
        constexpr uint32_t Int_GPT2 = (1U << 1);  ///< Interrupt Active for GPT2
        constexpr uint32_t Int_GPT1 = (1U << 0);  ///< Interrupt Active for GPT1
    }

    /// NVIC_ICER0 Register bits
    namespace nvic_icer0_bits {
        constexpr uint32_t Int_BDRV = (1U << 14);  ///< Interrupt Clear for Bridge Driver
        constexpr uint32_t Int_EXINT1 = (1U << 13);  ///< Interrupt Clear for External Int 1
        constexpr uint32_t Int_EXINT0 = (1U << 12);  ///< Interrupt Clear for External Int 0
        constexpr uint32_t Int_UART2 = (1U << 11);  ///< Interrupt Clear for UART2
        constexpr uint32_t Int_UART1 = (1U << 10);  ///< Interrupt Clear for UART1
        constexpr uint32_t Int_SSC2 = (1U << 9);  ///< Interrupt Clear for SSC2
        constexpr uint32_t Int_SSC1 = (1U << 8);  ///< Interrupt Clear for SSC1
        constexpr uint32_t Int_CCU6SR3 = (1U << 7);  ///< Interrupt Clear for CCU6 SR3
        constexpr uint32_t Int_CCU6SR2 = (1U << 6);  ///< Interrupt Clear for CCU6 SR2
        constexpr uint32_t Int_CCU6SR1 = (1U << 5);  ///< Interrupt Clear for CCU6 SR1
        constexpr uint32_t Int_CCU6SR0 = (1U << 4);  ///< Interrupt Clear for CCU6 SR0
        constexpr uint32_t Int_ADC1 = (1U << 3);  ///< Interrupt Clear for ADC1
        constexpr uint32_t Int_ADC2 = (1U << 2);  ///< Interrupt Clear for MU, ADC2
        constexpr uint32_t Int_GPT2 = (1U << 1);  ///< Interrupt Clear for GPT2
        constexpr uint32_t Int_GPT1 = (1U << 0);  ///< Interrupt Clear for GPT1
    }

    /// NVIC_ICPR0 Register bits
    namespace nvic_icpr0_bits {
        constexpr uint32_t Int_BDRV = (1U << 14);  ///< Interrupt Clear Pending for Bridge Driver
        constexpr uint32_t Int_EXINT1 = (1U << 13);  ///< Interrupt Clear Pending for External Int 1
        constexpr uint32_t Int_EXINT0 = (1U << 12);  ///< Interrupt Clear Pending for External Int 0
        constexpr uint32_t Int_UART2 = (1U << 11);  ///< Interrupt Clear Pending for UART2
        constexpr uint32_t Int_UART1 = (1U << 10);  ///< Interrupt Clear Pending for UART1
        constexpr uint32_t Int_SSC2 = (1U << 9);  ///< Interrupt Clear Pending for SSC2
        constexpr uint32_t Int_SSC1 = (1U << 8);  ///< Interrupt Clear Pending for SSC1
        constexpr uint32_t Int_CCU6SR3 = (1U << 7);  ///< Interrupt Clear Pending for CCU6 SR3
        constexpr uint32_t Int_CCU6SR2 = (1U << 6);  ///< Interrupt Clear Pending for CCU6 SR2
        constexpr uint32_t Int_CCU6SR1 = (1U << 5);  ///< Interrupt Clear Pending for CCU6 SR1
        constexpr uint32_t Int_CCU6SR0 = (1U << 4);  ///< Interrupt Clear Pending for CCU6 SR0
        constexpr uint32_t Int_ADC1 = (1U << 3);  ///< Interrupt Clear Pending for ADC1
        constexpr uint32_t Int_ADC2 = (1U << 2);  ///< Interrupt Clear Pending for MU, ADC2
        constexpr uint32_t Int_GPT2 = (1U << 1);  ///< Interrupt Clear Pending for GPT2
        constexpr uint32_t Int_GPT1 = (1U << 0);  ///< Interrupt Clear Pending for GPT1
    }

    /// NVIC_IPR0 Register bits
    namespace nvic_ipr0_bits {
        constexpr uint32_t PRI_ADC1 = (8 << 24);  ///< Priority for ADC1
        constexpr uint32_t PRI_ADC2 = (8 << 16);  ///< Priority for MU, ADC2
        constexpr uint32_t PRI_GPT2 = (8 << 8);  ///< Priority for GPT2
        constexpr uint32_t PRI_GPT1 = (8 << 0);  ///< Priority for GPT1
    }

    /// NVIC_IPR1 Register bits
    namespace nvic_ipr1_bits {
        constexpr uint32_t PRI_CCU6SR3 = (8 << 24);  ///< Priority for CCU6 SR3
        constexpr uint32_t PRI_CCU6SR2 = (8 << 16);  ///< Priority for CCU6 SR2
        constexpr uint32_t PRI_CCU6SR1 = (8 << 8);  ///< Priority for CCU6 SR1
        constexpr uint32_t PRI_CCU6SR0 = (8 << 0);  ///< Priority for CCU6 SR0
    }

    /// NVIC_IPR2 Register bits
    namespace nvic_ipr2_bits {
        constexpr uint32_t PRI_UART2 = (8 << 24);  ///< Priority for UART2
        constexpr uint32_t PRI_UART1 = (8 << 16);  ///< Priority for UART1
        constexpr uint32_t PRI_SSC2 = (8 << 8);  ///< Priority for SSC2
        constexpr uint32_t PRI_SSC1 = (8 << 0);  ///< Priority for SSC1
    }

    /// NVIC_IPR3 Register bits
    namespace nvic_ipr3_bits {
        constexpr uint32_t PRI_BDRV = (8 << 16);  ///< Priority for Bridge Driver
        constexpr uint32_t PRI_EXINT1 = (8 << 8);  ///< Priority for Ext. Int 1
        constexpr uint32_t PRI_EXINT0 = (8 << 0);  ///< Priority for Ext. Int 0
    }

    /// NVIC_ISER0 Register bits
    namespace nvic_iser0_bits {
        constexpr uint32_t Int_BDRV = (1U << 14);  ///< Interrupt Set for Bridge Driver
        constexpr uint32_t Int_EXINT1 = (1U << 13);  ///< Interrupt Set for External Int 1
        constexpr uint32_t Int_EXINT0 = (1U << 12);  ///< Interrupt Set for External Int 0
        constexpr uint32_t Int_UART2 = (1U << 11);  ///< Interrupt Set for UART2
        constexpr uint32_t Int_UART1 = (1U << 10);  ///< Interrupt Set for UART1
        constexpr uint32_t Int_SSC2 = (1U << 9);  ///< Interrupt Set for SSC2
        constexpr uint32_t Int_SSC1 = (1U << 8);  ///< Interrupt Set for SSC1
        constexpr uint32_t Int_CCU6SR3 = (1U << 7);  ///< Interrupt Set for CCU6 SR3
        constexpr uint32_t Int_CCU6SR2 = (1U << 6);  ///< Interrupt Set for CCU6 SR2
        constexpr uint32_t Int_CCU6SR1 = (1U << 5);  ///< Interrupt Set for CCU6 SR1
        constexpr uint32_t Int_CCU6SR0 = (1U << 4);  ///< Interrupt Set for CCU6 SR0
        constexpr uint32_t Int_ADC1 = (1U << 3);  ///< Interrupt Set for ADC1
        constexpr uint32_t Int_ADC2 = (1U << 2);  ///< Interrupt Set for MU, ADC2
        constexpr uint32_t Int_GPT2 = (1U << 1);  ///< Interrupt Set for GPT2
        constexpr uint32_t Int_GPT1 = (1U << 0);  ///< Interrupt Set for GPT1
    }

    /// NVIC_ISPR0 Register bits
    namespace nvic_ispr0_bits {
        constexpr uint32_t Int_BDRV = (1U << 14);  ///< Interrupt Set Pending for Bridge Driver
        constexpr uint32_t Int_EXINT1 = (1U << 13);  ///< Interrupt Set Pending for External Int 1
        constexpr uint32_t Int_EXINT0 = (1U << 12);  ///< Interrupt Set Pending for External Int 0
        constexpr uint32_t Int_UART2 = (1U << 11);  ///< Interrupt Set Pending for UART2
        constexpr uint32_t Int_UART1 = (1U << 10);  ///< Interrupt Set Pending for UART1
        constexpr uint32_t Int_SSC2 = (1U << 9);  ///< Interrupt Set Pending for SSC2
        constexpr uint32_t Int_SSC1 = (1U << 8);  ///< Interrupt Set Pending for SSC1
        constexpr uint32_t Int_CCU6SR3 = (1U << 7);  ///< Interrupt Set Pending for CCU6 SR3
        constexpr uint32_t Int_CCU6SR2 = (1U << 6);  ///< Interrupt Set Pending for CCU6 SR2
        constexpr uint32_t Int_CCU6SR1 = (1U << 5);  ///< Interrupt Set Pending for CCU6 SR1
        constexpr uint32_t Int_CCU6SR0 = (1U << 4);  ///< Interrupt Set Pending for CCU6 SR0
        constexpr uint32_t Int_ADC1 = (1U << 3);  ///< Interrupt Set Pending for ADC1
        constexpr uint32_t Int_ADC2 = (1U << 2);  ///< Interrupt Set Pending for MU, ADC2
        constexpr uint32_t Int_GPT2 = (1U << 1);  ///< Interrupt Set Pending for GPT2
        constexpr uint32_t Int_GPT1 = (1U << 0);  ///< Interrupt Set Pending for GPT1
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< SEVONPEND
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< Sleep Deep
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< Sleep on Exit
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t USGFAULTENA = (1U << 18);  ///< USGFAULTENA
        constexpr uint32_t BUSFAULTENA = (1U << 17);  ///< BUSFAULTENA
        constexpr uint32_t MEMFAULTENA = (1U << 16);  ///< MEMFAULTENA
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVCALLPENDED
        constexpr uint32_t BUSFAULTPENDED = (1U << 14);  ///< BUSFAULTPENDED
        constexpr uint32_t MEMFAULTPENDED = (1U << 13);  ///< MEMFAULTPENDED
        constexpr uint32_t USGFAULTPENDED = (1U << 12);  ///< USGFAULTPENDED
        constexpr uint32_t SYSTICKACT = (1U << 11);  ///< SYSTICKACT
        constexpr uint32_t PENDSVACT = (1U << 10);  ///< PENDSVACT
        constexpr uint32_t MONITORACT = (1U << 8);  ///< MONITORACT
        constexpr uint32_t SVCALLACT = (1U << 7);  ///< SVCALLACT
        constexpr uint32_t USGFAULTACT = (1U << 3);  ///< USGFAULTACT
        constexpr uint32_t BUSFAULTACT = (1U << 1);  ///< BUSFAULTACT
        constexpr uint32_t MEMFAULTACT = (1U << 0);  ///< MEMFAULTACT
    }

    /// SHPR1 Register bits
    namespace shpr1_bits {
        constexpr uint32_t PRI_7 = (8 << 24);  ///< Reserved for Priority of System Handler 7
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of System Handler 6, UsageFault
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of System Handler 5, BusFault
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of System Handler 4, MemManage
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of System Handler 11, SVCall
        constexpr uint32_t PRI_10 = (8 << 16);  ///< Reserved for Priority of System Handler 10
        constexpr uint32_t PRI_9 = (8 << 8);  ///< Reserved for Priority of System Handler 9
        constexpr uint32_t PRI_8 = (8 << 0);  ///< Reserved for Priority of System Handler 8
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of System Handler 15, SysTick
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of System Handler 14, PendSV
        constexpr uint32_t PRI_13 = (8 << 8);  ///< Reserved for Priority of System Handler 13
        constexpr uint32_t PRI_12 = (8 << 0);  ///< Priority of System Handler 12, DebugMonitor
    }

    /// SYSTICK_CAL Register bits
    namespace systick_cal_bits {
        constexpr uint32_t NOREF = (1U << 31);  ///< No Reference Clock
        constexpr uint32_t SKEW = (1U << 30);  ///< Skew
        constexpr uint32_t TENMS = (24 << 0);  ///< Tenms
    }

    /// SYSTICK_CS Register bits
    namespace systick_cs_bits {
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< Count Flag
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< CLK Source
        constexpr uint32_t TICKINT = (1U << 1);  ///< Enables SysTick exception request
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable
    }

    /// SYSTICK_CUR Register bits
    namespace systick_cur_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current
    }

    /// SYSTICK_RL Register bits
    namespace systick_rl_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Reload
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (25 << 7);  ///< Vector Table Offset
    }

}

// ============================================================================
// GPT12E Peripheral
// ============================================================================

namespace gpt12e {
    /// Base addresses
    constexpr uint32_t GPT12E_BASE = 0x40010000;

    /// GPT12E Register structure
    struct Registers {
        volatile uint32_t CAPREL;  ///< Offset: 0x1C - Capture/Reload Register
        volatile uint32_t ID;  ///< Offset: 0x00 - Module Identification Register
        volatile uint32_t PISEL;  ///< Offset: 0x04 - Port Input Select Register
        volatile uint32_t T2;  ///< Offset: 0x20 - Timer T2 Count Register
        volatile uint32_t T2CON;  ///< Offset: 0x08 - Timer T2 Control Register
        volatile uint32_t T3;  ///< Offset: 0x24 - Timer T3 Count Register
        volatile uint32_t T3CON;  ///< Offset: 0x0C - Timer T3 Control Register
        volatile uint32_t T4;  ///< Offset: 0x28 - Timer T4 Count Register
        volatile uint32_t T4CON;  ///< Offset: 0x10 - Timer T4 Control Register
        volatile uint32_t T5;  ///< Offset: 0x2C - Timer 5 Count Register
        volatile uint32_t T5CON;  ///< Offset: 0x14 - Timer 5 Control Register
        volatile uint32_t T6;  ///< Offset: 0x30 - Timer T6 Count Register
        volatile uint32_t T6CON;  ///< Offset: 0x18 - Timer T6 Control Register
    };

    /// Peripheral instances
    inline Registers* GPT12E = reinterpret_cast<Registers*>(GPT12E_BASE);

    // Bit definitions
    /// CAPREL Register bits
    namespace caprel_bits {
        constexpr uint32_t CAPREL = (16 << 0);  ///< Current reload value or Captured value
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Identification Number
    }

    /// PISEL Register bits
    namespace pisel_bits {
        constexpr uint32_t IST2IN = (1U << 0);  ///< Input Select for T2IN
        constexpr uint32_t IST2EUD = (1U << 1);  ///< Input Select for T2EUD
        constexpr uint32_t IST3IN = (2 << 2);  ///< Input Select for T3IN
        constexpr uint32_t IST3EUD = (2 << 4);  ///< Input Select for T3EUD
        constexpr uint32_t IST4IN = (2 << 6);  ///< Input Select for T4IN
        constexpr uint32_t IST4EUD = (2 << 8);  ///< Input Select for T4EUD
        constexpr uint32_t IST5IN = (1U << 10);  ///< Input Select for T5IN
        constexpr uint32_t IST5EUD = (1U << 11);  ///< Input Select for T5EUD
        constexpr uint32_t IST6IN = (1U << 12);  ///< Input Select for T6IN
        constexpr uint32_t IST6EUD = (1U << 13);  ///< Input Select for T6EUD
        constexpr uint32_t ISCAPIN = (2 << 14);  ///< Input Select for CAPIN
    }

    /// T2 Register bits
    namespace t2_bits {
        constexpr uint32_t T2 = (16 << 0);  ///< Timer T2 Current Value
    }

    /// T2CON Register bits
    namespace t2con_bits {
        constexpr uint32_t T2I = (3 << 0);  ///< Timer T2 Input Parameter Selection
        constexpr uint32_t T2M = (3 << 3);  ///< Timer T2 Mode Control (Basic Operating Mode)
        constexpr uint32_t T2R = (1U << 6);  ///< Timer T2 Run Bit
        constexpr uint32_t T2UD = (1U << 7);  ///< Timer T2 Up/Down Control
        constexpr uint32_t T2UDE = (1U << 8);  ///< Timer T2 External Up/Down Enable
        constexpr uint32_t T2RC = (1U << 9);  ///< Timer T2 Remote Control
        constexpr uint32_t T2IRDIS = (1U << 12);  ///< Timer T2 Interrupt Disable
        constexpr uint32_t T2EDGE = (1U << 13);  ///< Timer T2 Edge Detection
        constexpr uint32_t T2CHDIR = (1U << 14);  ///< Timer T2 Count Direction Change
        constexpr uint32_t T2RDIR = (1U << 15);  ///< Timer T2 Rotation Direction
    }

    /// T3 Register bits
    namespace t3_bits {
        constexpr uint32_t T3 = (16 << 0);  ///< Timer T3 Current Value
    }

    /// T3CON Register bits
    namespace t3con_bits {
        constexpr uint32_t T3I = (3 << 0);  ///< Timer T3 Input Parameter Selection
        constexpr uint32_t T3M = (3 << 3);  ///< Timer T3 Mode Control
        constexpr uint32_t T3R = (1U << 6);  ///< Timer T3 Run Bit
        constexpr uint32_t T3UD = (1U << 7);  ///< Timer T3 Up/Down Control
        constexpr uint32_t T3UDE = (1U << 8);  ///< Timer T3 External Up/Down Enable
        constexpr uint32_t T3OE = (1U << 9);  ///< Overflow/Underflow Output Enable
        constexpr uint32_t T3OTL = (1U << 10);  ///< Timer T3 Overflow Toggle Latch
        constexpr uint32_t BPS1 = (2 << 11);  ///< GPT1 Block Prescaler Control
        constexpr uint32_t T3EDGE = (1U << 13);  ///< Timer T3 Edge Detection Flag
        constexpr uint32_t T3CHDIR = (1U << 14);  ///< Timer T3 Count Direction Change Flag
        constexpr uint32_t T3RDIR = (1U << 15);  ///< Timer T3 Rotation Direction Flag
    }

    /// T4 Register bits
    namespace t4_bits {
        constexpr uint32_t T4 = (16 << 0);  ///< Timer T4 Current Value
    }

    /// T4CON Register bits
    namespace t4con_bits {
        constexpr uint32_t T4I = (3 << 0);  ///< Timer T4 Input Parameter Selection
        constexpr uint32_t T4M = (3 << 3);  ///< Timer T4 Mode Control (Basic Operating Mode)
        constexpr uint32_t T4R = (1U << 6);  ///< Timer T4 Run Bit
        constexpr uint32_t T4UD = (1U << 7);  ///< Timer T4 Up/Down Control
        constexpr uint32_t T4UDE = (1U << 8);  ///< Timer T4 External Up/Down Enable
        constexpr uint32_t T4RC = (1U << 9);  ///< Timer T4 Remote Control
        constexpr uint32_t CLRT2EN = (1U << 10);  ///< Clear Timer T2 Enable
        constexpr uint32_t CLRT3EN = (1U << 11);  ///< Clear Timer T3 Enable
        constexpr uint32_t T4IRDIS = (1U << 12);  ///< Timer T4 Interrupt Disable
        constexpr uint32_t T4EDGE = (1U << 13);  ///< Timer T4 Edge Detection
        constexpr uint32_t T4CHDIR = (1U << 14);  ///< Timer T4 Count Direction Change
        constexpr uint32_t T4RDIR = (1U << 15);  ///< Timer T4 Rotation Direction
    }

    /// T5 Register bits
    namespace t5_bits {
        constexpr uint32_t T5 = (16 << 0);  ///< Timer T5 Current Value
    }

    /// T5CON Register bits
    namespace t5con_bits {
        constexpr uint32_t T5I = (3 << 0);  ///< Timer T5 Input Parameter Selection
        constexpr uint32_t T5M = (2 << 3);  ///< Timer T5 Mode Control (Basic Operating Mode)
        constexpr uint32_t T5R = (1U << 6);  ///< Timer T5 Run Bit
        constexpr uint32_t T5UD = (1U << 7);  ///< Timer T5 Up/Down Control
        constexpr uint32_t T5UDE = (1U << 8);  ///< Timer T5 External Up/Down Enable
        constexpr uint32_t T5RC = (1U << 9);  ///< Timer T5 Remote Control
        constexpr uint32_t CT3 = (1U << 10);  ///< Timer T3 Capture Trigger Enable
        constexpr uint32_t CI = (2 << 12);  ///< Register CAPREL Capture Trigger Selection
        constexpr uint32_t T5CLR = (1U << 14);  ///< Timer T5 Clear Enable Bit
        constexpr uint32_t T5SC = (1U << 15);  ///< Timer T5 Capture Mode Enable
    }

    /// T6 Register bits
    namespace t6_bits {
        constexpr uint32_t T6 = (16 << 0);  ///< Timer T6 Current Value
    }

    /// T6CON Register bits
    namespace t6con_bits {
        constexpr uint32_t T6I = (3 << 0);  ///< Timer T6 Input Parameter Selection
        constexpr uint32_t T6M = (3 << 3);  ///< Timer T6 Mode Control (Basic Operating Mode)
        constexpr uint32_t T6R = (1U << 6);  ///< Timer T6 Run Bit
        constexpr uint32_t T6UD = (1U << 7);  ///< Timer T6 Up/Down Control
        constexpr uint32_t T6UDE = (1U << 8);  ///< Timer T6 External Up/Down Enable
        constexpr uint32_t T6OE = (1U << 9);  ///< Overflow/Underflow Output Enable
        constexpr uint32_t T6OTL = (1U << 10);  ///< Timer T6 Overflow Toggle Latch
        constexpr uint32_t BPS2 = (2 << 11);  ///< GPT2 Block Prescaler Control
        constexpr uint32_t T6CLR = (1U << 14);  ///< Timer T6 Clear Enable Bit
        constexpr uint32_t T6SR = (1U << 15);  ///< Timer T6 Reload Mode Enable
    }

}

// ============================================================================
// LIN Peripheral
// ============================================================================

namespace lin {
    /// Base addresses
    constexpr uint32_t LIN_BASE = 0x4801E000;

    /// LIN Register structure
    struct Registers {
        volatile uint32_t CTRL_STS;  ///< Offset: 0x00 - LIN Transceiver Control and Status
    };

    /// Peripheral instances
    inline Registers* LIN = reinterpret_cast<Registers*>(LIN_BASE);

    // Bit definitions
    /// CTRL_STS Register bits
    namespace ctrl_sts_bits {
        constexpr uint32_t M_SM_ERR_CLR = (1U << 24);  ///< LIN Transceiver Mode or Slope Mode Error Clear
        constexpr uint32_t HV_MODE = (1U << 21);  ///< LIN Transceiver High Voltage Input - Output Mode
        constexpr uint32_t MODE_FB = (3 << 16);  ///< Feedback Signals for LIN Transmitter Mode Settings
        constexpr uint32_t FB_SM3 = (1U << 15);  ///< Feedback Signal 3 for Slope Mode Setting
        constexpr uint32_t FB_SM2 = (1U << 14);  ///< Feedback Signal 2 for Slope Mode Setting
        constexpr uint32_t FB_SM1 = (1U << 13);  ///< Feedback Signal 1 for Slope Mode Setting
        constexpr uint32_t SM = (2 << 11);  ///< LIN Transmitter Slope mode control
        constexpr uint32_t RXD = (1U << 10);  ///< Output Signal of Receiver
        constexpr uint32_t TXD = (1U << 9);  ///< LIN Transmitter switch on (only used when LIN_HV_MODE is set)
        constexpr uint32_t TXD_TMOUT_STS = (1U << 6);  ///< LIN TXD time-out status
        constexpr uint32_t OC_STS = (1U << 5);  ///< LIN Receiver Overcurrent Status
        constexpr uint32_t OT_STS = (1U << 4);  ///< LIN Receiver Overtemperature Status
        constexpr uint32_t M_SM_ERR = (1U << 3);  ///< LIN Transceiver Mode or Slope Mode Error
        constexpr uint32_t MODE = (2 << 1);  ///< LIN transceiver power mode control
    }

}

// ============================================================================
// MF Peripheral
// ============================================================================

namespace mf {
    /// Base addresses
    constexpr uint32_t MF_BASE = 0x48018000;

    /// MF Register structure
    struct Registers {
        volatile uint32_t P2_ADCSEL_CTRL;  ///< Offset: 0x00 - Port 2 ADC Selection Control Register
        volatile uint32_t REF1_STS;  ///< Offset: 0x14 - Reference 1 Status Register
        volatile uint32_t REF2_CTRL;  ///< Offset: 0x18 - Reference 2 Control Register
        volatile uint32_t TEMPSENSE_CTRL;  ///< Offset: 0x10 - Temperature Sensor Control Register
        volatile uint32_t VMON_SEN_CTRL;  ///< Offset: 0x04 - Supply Sense Control Register
    };

    /// Peripheral instances
    inline Registers* MF = reinterpret_cast<Registers*>(MF_BASE);

    // Bit definitions
    /// P2_ADCSEL_CTRL Register bits
    namespace p2_adcsel_ctrl_bits {
        constexpr uint32_t P2_7_ADC_SEL = (1U << 5);  ///< Port 2.7 Input Selection
        constexpr uint32_t P2_5_ADC_SEL = (1U << 4);  ///< Port 2.5 Input Selection
        constexpr uint32_t P2_4_ADC_SEL = (1U << 3);  ///< Port 2.4 Input Selection
        constexpr uint32_t P2_3_ADC_SEL = (1U << 2);  ///< Port 2.3 Input Selection
    }

    /// REF1_STS Register bits
    namespace ref1_sts_bits {
        constexpr uint32_t REFBG_UPTHWARN_STS = (1U << 5);  ///< Status for Overvoltage Threshold Measurement of internal VAREF
        constexpr uint32_t REFBG_LOTHWARN_STS = (1U << 4);  ///< Status for Undervoltage Threshold Measurement of internal VAREF
    }

    /// REF2_CTRL Register bits
    namespace ref2_ctrl_bits {
        constexpr uint32_t VREF5V_OV_STS = (1U << 3);  ///< ADC1 Bit Reference Voltage Generation Overvoltage Bit
        constexpr uint32_t VREF5V_UV_STS = (1U << 2);  ///< ADC1 Bit Reference Voltage Generation Undervoltage Bit
        constexpr uint32_t VREF5V_OVL_STS = (1U << 1);  ///< ADC1 Bit Reference Voltage Generation Over Load Bit
        constexpr uint32_t VREF5V_PD_N = (1U << 0);  ///< ADC1 Bit Reference Voltage Generation Power Down Bit
    }

    /// TEMPSENSE_CTRL Register bits
    namespace tempsense_ctrl_bits {
        constexpr uint32_t SYS_OT_STS = (1U << 7);  ///< System Overtemperature (MU) Status
        constexpr uint32_t SYS_OTWARN_STS = (1U << 6);  ///< System Overtemperature Warning (MU) Status
        constexpr uint32_t PMU_OT_STS = (1U << 5);  ///< PMU Regulator Overtemperature (MU) Status
        constexpr uint32_t PMU_OTWARN_STS = (1U << 4);  ///< PMU Regulator Overtemperature Warning (MU) Status
    }

    /// VMON_SEN_CTRL Register bits
    namespace vmon_sen_ctrl_bits {
        constexpr uint32_t VMON_SEN_SEL_INRANGE = (1U << 5);  ///< Monitoring Input Attenuator Select Inputrange
        constexpr uint32_t VMON_SEN_HRESO_5V = (1U << 4);  ///< Monitoring Input Attenuator High Impedance Output Control
        constexpr uint32_t VMON_SEN_PD_N = (1U << 0);  ///< Monitoring Input Attenuator enable
    }

}

// ============================================================================
// PMU Peripheral
// ============================================================================

namespace pmu {
    /// Base addresses
    constexpr uint32_t PMU_BASE = 0x50004000;

    /// PMU Register structure
    struct Registers {
        volatile uint32_t CNF_CYC_WAKE;  ///< Offset: 0x2C - Dead Time in Cyclic Wake Register
        volatile uint32_t CNF_PMU_SETTINGS;  ///< Offset: 0x20 - PMU Settings Register
        volatile uint32_t CNF_RST_TFB;  ///< Offset: 0x6C - Reset Blind Time Register
        volatile uint32_t CNF_WAKE_FILTER;  ///< Offset: 0xAC - PMU Wake-up Timing Register
        volatile uint32_t GPUDATA00;  ///< Offset: 0xC0 - General Purpose User DATA0
        volatile uint32_t GPUDATA01;  ///< Offset: 0xC4 - General Purpose User DATA1
        volatile uint32_t GPUDATA02;  ///< Offset: 0xC8 - General Purpose User DATA2
        volatile uint32_t GPUDATA03;  ///< Offset: 0xCC - General Purpose User DATA3
        volatile uint32_t GPUDATA04;  ///< Offset: 0xD0 - General Purpose User DATA4
        volatile uint32_t GPUDATA05;  ///< Offset: 0xD4 - General Purpose User DATA5
        volatile uint32_t GPUDATA06;  ///< Offset: 0xD8 - General Purpose User DATA6
        volatile uint32_t GPUDATA07;  ///< Offset: 0xDC - General Purpose User DATA7
        volatile uint32_t GPUDATA08;  ///< Offset: 0xE0 - General Purpose User DATA8
        volatile uint32_t GPUDATA09;  ///< Offset: 0xE4 - General Purpose User DATA9
        volatile uint32_t GPUDATA10;  ///< Offset: 0xE8 - General Purpose User DATA10
        volatile uint32_t GPUDATA11;  ///< Offset: 0xEC - General Purpose User DATA11
        volatile uint32_t LIN_WAKE_EN;  ///< Offset: 0x50 - LIN Wake Enable
        volatile uint32_t MON_CNF;  ///< Offset: 0x34 - Settings Monitor 1
        volatile uint32_t PMU_RESET_STS1;  ///< Offset: 0x10 - Reset Status Hard Register
        volatile uint32_t PMU_RESET_STS2;  ///< Offset: 0x14 - Reset Status Soft Register
        volatile uint32_t PMU_SUPPLY_STS;  ///< Offset: 0x04 - Voltage Reg Status Register
        volatile uint32_t SYS_FAIL_STS;  ///< Offset: 0x70 - System Fail Status Register
        volatile uint32_t SystemStartConfig;  ///< Offset: 0x2D4 - System Startup Config
        volatile uint32_t VDDEXT_CTRL;  ///< Offset: 0x08 - VDDEXT Control
        volatile uint32_t WAKE_STATUS;  ///< Offset: 0x00 - Main wake status register
        volatile uint32_t WAKE_STS_MON;  ///< Offset: 0x84 - Wake Source MON Input Register
    };

    /// Peripheral instances
    inline Registers* PMU = reinterpret_cast<Registers*>(PMU_BASE);

    // Bit definitions
    /// CNF_CYC_WAKE Register bits
    namespace cnf_cyc_wake_bits {
        constexpr uint32_t E01 = (2 << 4);  ///< Exponent
        constexpr uint32_t M03 = (4 << 0);  ///< Mantissa
    }

    /// CNF_PMU_SETTINGS Register bits
    namespace cnf_pmu_settings_bits {
        constexpr uint32_t EN_VDDEXT_OC_OFF_N = (1U << 7);  ///< Disabling VDDEXT Shutdown in Overload Condition
        constexpr uint32_t CYC_WAKE_EN = (1U << 2);  ///< Enabling Cyclic Wake
    }

    /// CNF_RST_TFB Register bits
    namespace cnf_rst_tfb_bits {
        constexpr uint32_t RST_TFB = (2 << 0);  ///< Reset Pin Blind Time Selection Bits
    }

    /// CNF_WAKE_FILTER Register bits
    namespace cnf_wake_filter_bits {
        constexpr uint32_t CNF_MON_FT = (1U << 1);  ///< Wake-up Filter time for Monitoring Inputs
        constexpr uint32_t CNF_LIN_FT = (1U << 0);  ///< Wake-up Filter time for LIN WAKE
    }

    /// GPUDATA00 Register bits
    namespace gpudata00_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0 Storage Byte
    }

    /// GPUDATA01 Register bits
    namespace gpudata01_bits {
        constexpr uint32_t DATA1 = (8 << 0);  ///< DATA1 Storage Byte
    }

    /// GPUDATA02 Register bits
    namespace gpudata02_bits {
        constexpr uint32_t DATA2 = (8 << 0);  ///< DATA2 Storage Byte
    }

    /// GPUDATA03 Register bits
    namespace gpudata03_bits {
        constexpr uint32_t DATA3 = (8 << 0);  ///< DATA3 Storage Byte
    }

    /// GPUDATA04 Register bits
    namespace gpudata04_bits {
        constexpr uint32_t DATA4 = (8 << 0);  ///< DATA4 Storage Byte
    }

    /// GPUDATA05 Register bits
    namespace gpudata05_bits {
        constexpr uint32_t DATA5 = (8 << 0);  ///< DATA5 Storage Byte
    }

    /// GPUDATA06 Register bits
    namespace gpudata06_bits {
        constexpr uint32_t DATA6 = (8 << 0);  ///< DATA6 Storage Byte
    }

    /// GPUDATA07 Register bits
    namespace gpudata07_bits {
        constexpr uint32_t DATA7 = (8 << 0);  ///< DATA7 Storage Byte
    }

    /// GPUDATA08 Register bits
    namespace gpudata08_bits {
        constexpr uint32_t DATA8 = (8 << 0);  ///< DATA8 Storage Byte
    }

    /// GPUDATA09 Register bits
    namespace gpudata09_bits {
        constexpr uint32_t DATA9 = (8 << 0);  ///< DATA9 Storage Byte
    }

    /// GPUDATA10 Register bits
    namespace gpudata10_bits {
        constexpr uint32_t DATA10 = (8 << 0);  ///< DATA10 Storage Byte
    }

    /// GPUDATA11 Register bits
    namespace gpudata11_bits {
        constexpr uint32_t DATA11 = (8 << 0);  ///< DATA11 Storage Byte
    }

    /// LIN_WAKE_EN Register bits
    namespace lin_wake_en_bits {
        constexpr uint32_t LIN_EN = (1U << 7);  ///< Lin Wake enable
    }

    /// MON_CNF Register bits
    namespace mon_cnf_bits {
        constexpr uint32_t STS = (1U << 7);  ///< MON Status Input
        constexpr uint32_t PU = (1U << 5);  ///< Pull-Up Current Source for MON Input Enable
        constexpr uint32_t PD = (1U << 4);  ///< Pull-Down Current Source for MON Input Enable
        constexpr uint32_t RISE = (1U << 2);  ///< MON Wake-up on Rising Edge Enable
        constexpr uint32_t FALL = (1U << 1);  ///< MON Wake-up on Falling Edge Enable
        constexpr uint32_t EN = (1U << 0);  ///< MON Enable
    }

    /// PMU_RESET_STS1 Register bits
    namespace pmu_reset_sts1_bits {
        constexpr uint32_t PMU_1V5DidPOR = (1U << 7);  ///< Power-On Reset Flag
        constexpr uint32_t PMU_PIN = (1U << 6);  ///< PIN-Reset Flag
        constexpr uint32_t PMU_ExtWDT = (1U << 5);  ///< External Watchdog (WDT1) Reset Flag
        constexpr uint32_t PMU_ClkWDT = (1U << 4);  ///< Clock Watchdog (CLKWDT) Reset Flag
        constexpr uint32_t PMU_LPR = (1U << 3);  ///< Low Priority Resets (see PMU_RESET_STS2)
        constexpr uint32_t PMU_SleepEX = (1U << 2);  ///< Flag which indicates a reset caused by Sleep-Exit
        constexpr uint32_t SYS_FAIL = (1U << 0);  ///< Flag which indicates a reset caused by a System Fail reported in the corresponding Fail Register
    }

    /// PMU_RESET_STS2 Register bits
    namespace pmu_reset_sts2_bits {
        constexpr uint32_t LOCKUP = (1U << 2);  ///< Lockup-Reset Flag
        constexpr uint32_t PMU_SOFT = (1U << 1);  ///< Soft-Reset Flag
        constexpr uint32_t PMU_IntWDT = (1U << 0);  ///< Internal Watchdog Reset Flag
    }

    /// PMU_SUPPLY_STS Register bits
    namespace pmu_supply_sts_bits {
        constexpr uint32_t PMU_5V_FAIL_EN = (1U << 6);  ///< Enabling of VDDP status information as interrupt source
        constexpr uint32_t PMU_5V_OVERLOAD = (1U << 5);  ///< Overload at VDDP regulator
        constexpr uint32_t PMU_5V_OVERVOLT = (1U << 4);  ///< Overvoltage at VDDP regulator
        constexpr uint32_t PMU_1V5_FAIL_EN = (1U << 2);  ///< Enabling of VDDC status information as interrupt source
        constexpr uint32_t PMU_1V5_OVERLOAD = (1U << 1);  ///< Overload at VDDC regulator
        constexpr uint32_t PMU_1V5_OVERVOLT = (1U << 0);  ///< Overvoltage at VDDC regulator
    }

    /// SYS_FAIL_STS Register bits
    namespace sys_fail_sts_bits {
        constexpr uint32_t WDT1_SEQ_FAIL = (1U << 6);  ///< External Watchdog (WDT1) Sequential Fail
        constexpr uint32_t SYS_OT = (1U << 5);  ///< System Overtemperature Indication Flag
        constexpr uint32_t PMU_5V_OVL = (1U << 3);  ///< VDDP Overload Flag
        constexpr uint32_t PMU_1V5_OVL = (1U << 2);  ///< VDDC Overload Flag
        constexpr uint32_t SUPP_TMOUT = (1U << 1);  ///< Supply Time Out
        constexpr uint32_t SUPP_SHORT = (1U << 0);  ///< Supply Short
    }

    /// SystemStartConfig Register bits
    namespace systemstartconfig_bits {
        constexpr uint32_t MBIST_EN = (1U << 0);  ///< System Startup Configuration Bit for RAM MBIST at Sleep Mode exit
    }

    /// VDDEXT_CTRL Register bits
    namespace vddext_ctrl_bits {
        constexpr uint32_t STABLE = (1U << 7);  ///< VDDEXT Supply works inside its specified range 1
        constexpr uint32_t OK = (1U << 6);  ///< VDDEXT Supply works inside its specified range 2
        constexpr uint32_t OVERLOAD = (1U << 5);  ///< VDDEXT Supply Overload
        constexpr uint32_t OVERVOLT = (1U << 4);  ///< VDDEXT Supply Overvoltage
        constexpr uint32_t SHORT = (1U << 3);  ///< VDDEXT Supply Shorted Output
        constexpr uint32_t FAIL_EN = (1U << 2);  ///< Enabling of VDDEXT Supply status information as interrupt source
        constexpr uint32_t ENABLE = (1U << 0);  ///< VDDEXT Supply Enable
    }

    /// WAKE_STATUS Register bits
    namespace wake_status_bits {
        constexpr uint32_t CYC_WAKE = (1U << 4);  ///< Wake-up caused by Cyclic Wake
        constexpr uint32_t MON_WAKE = (1U << 1);  ///< Wake-up via MON
        constexpr uint32_t LIN_WAKE = (1U << 0);  ///< Wake-up via LIN- Message
    }

    /// WAKE_STS_MON Register bits
    namespace wake_sts_mon_bits {
        constexpr uint32_t WAKE_STS = (1U << 0);  ///< Status of MON
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT_BASE = 0x48028000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t P0_ALTSEL0;  ///< Offset: 0x30 - Port 0 Alternate Select Register
        volatile uint32_t P0_ALTSEL1;  ///< Offset: 0x34 - Port 0 Alternate Select Register
        volatile uint32_t P0_DATA;  ///< Offset: 0x00 - Port 0 Data Register
        volatile uint32_t P0_DIR;  ///< Offset: 0x04 - Port 0 Direction Register
        volatile uint32_t P0_OD;  ///< Offset: 0x40 - Port 0 Open Drain Control Register
        volatile uint32_t P0_PUDEN;  ///< Offset: 0x1C - Port 0 Pull-Up/Pull-Down Enable Register
        volatile uint32_t P0_PUDSEL;  ///< Offset: 0x18 - Port 0 Pull-Up/Pull-Down Select Register
        volatile uint32_t P1_ALTSEL0;  ///< Offset: 0x38 - Port 1 Alternate Select Register
        volatile uint32_t P1_ALTSEL1;  ///< Offset: 0x3C - Port 1 Alternate Select Register
        volatile uint32_t P1_DATA;  ///< Offset: 0x08 - Port 1 Data Register
        volatile uint32_t P1_DIR;  ///< Offset: 0x0C - Port 1 Direction Register
        volatile uint32_t P1_OD;  ///< Offset: 0x44 - Port 1 Open Drain Control Register
        volatile uint32_t P1_PUDEN;  ///< Offset: 0x24 - Port 1 Pull-Up/Pull-Down Enable Register
        volatile uint32_t P1_PUDSEL;  ///< Offset: 0x20 - Port 1 Pull-Up/Pull-Down Select Register
        volatile uint32_t P2_DATA;  ///< Offset: 0x10 - Port 2 Data Register
        volatile uint32_t P2_DIR;  ///< Offset: 0x14 - Port 2 Direction Register
        volatile uint32_t P2_PUDEN;  ///< Offset: 0x2C - Port 2 Pull-Up/Pull-Down Enable Register
        volatile uint32_t P2_PUDSEL;  ///< Offset: 0x28 - Port 2 Pull-Up/Pull-Down Select Register
    };

    /// Peripheral instances
    inline Registers* PORT = reinterpret_cast<Registers*>(PORT_BASE);

    // Bit definitions
    /// P0_ALTSEL0 Register bits
    namespace p0_altsel0_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Alternate Select Port 0 Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Alternate Select Port 0 Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Alternate Select Port 0 Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Alternate Select Port 0 Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Alternate Select Port 0 Bit 4
    }

    /// P0_ALTSEL1 Register bits
    namespace p0_altsel1_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Alternate Select Port 0 Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Alternate Select Port 0 Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Alternate Select Port 0 Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Alternate Select Port 0 Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Alternate Select Port 0 Bit 4
    }

    /// P0_DATA Register bits
    namespace p0_data_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Port 0 Pin 0 Data Value
        constexpr uint32_t P1 = (1U << 1);  ///< Port 0 Pin 1 Data Value
        constexpr uint32_t P2 = (1U << 2);  ///< Port 0 Pin 2 Data Value
        constexpr uint32_t P3 = (1U << 3);  ///< Port 0 Pin 3 Data Value
        constexpr uint32_t P4 = (1U << 4);  ///< Port 0 Pin 4 Data Value
    }

    /// P0_DIR Register bits
    namespace p0_dir_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Port 0 Pin 0 Direction Control
        constexpr uint32_t P1 = (1U << 1);  ///< Port 0 Pin 1 Direction Control
        constexpr uint32_t P2 = (1U << 2);  ///< Port 0 Pin 2 Direction Control
        constexpr uint32_t P3 = (1U << 3);  ///< Port 0 Pin 3 Direction Control
        constexpr uint32_t P4 = (1U << 4);  ///< Port 0 Pin 4 Direction Control
    }

    /// P0_OD Register bits
    namespace p0_od_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Port 0 Pin 0 Open Drain Mode
        constexpr uint32_t P1 = (1U << 1);  ///< Port 0 Pin 1 Open Drain Mode
        constexpr uint32_t P2 = (1U << 2);  ///< Port 0 Pin 2 Open Drain Mode
        constexpr uint32_t P3 = (1U << 3);  ///< Port 0 Pin 3 Open Drain Mode
        constexpr uint32_t P4 = (1U << 4);  ///< Port 0 Pin 4 Open Drain Mode
    }

    /// P0_PUDEN Register bits
    namespace p0_puden_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Pull-Up/Pull-Down Enable at Port 0 Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Pull-Up/Pull-Down Enable at Port 0 Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Pull-Up/Pull-Down Enable at Port 0 Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Pull-Up/Pull-Down Enable at Port 0 Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Pull-Up/Pull-Down Enable at Port 0 Bit 4
    }

    /// P0_PUDSEL Register bits
    namespace p0_pudsel_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Pull-Up/Pull-Down Select Port 0 Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Pull-Up/Pull-Down Select Port 0 Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Pull-Up/Pull-Down Select Port 0 Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Pull-Up/Pull-Down Select Port 0 Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Pull-Up/Pull-Down Select Port 0 Bit 4
    }

    /// P1_ALTSEL0 Register bits
    namespace p1_altsel0_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Alternate Select Port 1 Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Alternate Select Port 1 Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Alternate Select Port 1 Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Alternate Select Port 1 Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Alternate Select Port 1 Bit 4
    }

    /// P1_ALTSEL1 Register bits
    namespace p1_altsel1_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Alternate Select Port 1 Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Alternate Select Port 1 Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Alternate Select Port 1 Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Alternate Select Port 1 Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Alternate Select Port 1 Bit 4
    }

    /// P1_DATA Register bits
    namespace p1_data_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Port 1 Pin 0 Data Value
        constexpr uint32_t P1 = (1U << 1);  ///< Port 1 Pin 1 Data Value
        constexpr uint32_t P2 = (1U << 2);  ///< Port 1 Pin 2 Data Value
        constexpr uint32_t P3 = (1U << 3);  ///< Port 1 Pin 3 Data Value
        constexpr uint32_t P4 = (1U << 4);  ///< Port 1 Pin 4 Data Value
    }

    /// P1_DIR Register bits
    namespace p1_dir_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Port 1 Pin 0 Direction Control
        constexpr uint32_t P1 = (1U << 1);  ///< Port 1 Pin 1 Direction Control
        constexpr uint32_t P2 = (1U << 2);  ///< Port 1 Pin 2 Direction Control
        constexpr uint32_t P3 = (1U << 3);  ///< Port 1 Pin 3 Direction Control
        constexpr uint32_t P4 = (1U << 4);  ///< Port 1 Pin 4 Direction Control
    }

    /// P1_OD Register bits
    namespace p1_od_bits {
        constexpr uint32_t P0 = (1U << 1);  ///< P1.0 Open Drain Mode
        constexpr uint32_t P1 = (1U << 2);  ///< P1.1 Open Drain Mode
        constexpr uint32_t P3_P2 = (1U << 3);  ///< P1.3/P1.2 Open Drain Mode
        constexpr uint32_t P4 = (1U << 4);  ///< P1.4 Open Drain Mode
    }

    /// P1_PUDEN Register bits
    namespace p1_puden_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Pull-Up/Pull-Down Enable at Port 1 Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Pull-Up/Pull-Down Enable at Port 1 Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Pull-Up/Pull-Down Enable at Port 1 Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Pull-Up/Pull-Down Enable at Port 1 Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Pull-Up/Pull-Down Enable at Port 1 Bit 4
    }

    /// P1_PUDSEL Register bits
    namespace p1_pudsel_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Pull-Up/Pull-Down Select Port 1 Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Pull-Up/Pull-Down Select Port 1 Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Pull-Up/Pull-Down Select Port 1 Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Pull-Up/Pull-Down Select Port 1 Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Pull-Up/Pull-Down Select Port 1 Bit 4
    }

    /// P2_DATA Register bits
    namespace p2_data_bits {
        constexpr uint32_t P1 = (1U << 1);  ///< Port 2 Pin 1 Data Value
        constexpr uint32_t P3 = (1U << 3);  ///< Port 2 Pin 3 Data Value
        constexpr uint32_t P4 = (1U << 4);  ///< Port 2 Pin 4 Data Value
        constexpr uint32_t P5 = (1U << 5);  ///< Port 2 Pin 5 Data Value
        constexpr uint32_t P7 = (1U << 7);  ///< Port 2 Pin 7 Data Value
    }

    /// P2_DIR Register bits
    namespace p2_dir_bits {
        constexpr uint32_t P1 = (1U << 1);  ///< Port 2 Pin 1 Driver Control
        constexpr uint32_t P3 = (1U << 3);  ///< Port 2 Pin 3 Driver Control
        constexpr uint32_t P4 = (1U << 4);  ///< Port 2 Pin 4 Driver Control
        constexpr uint32_t P5 = (1U << 5);  ///< Port 2 Pin 5 Driver Control
        constexpr uint32_t P7 = (1U << 7);  ///< Port 2 Pin 7 Driver Control
    }

    /// P2_PUDEN Register bits
    namespace p2_puden_bits {
        constexpr uint32_t P1 = (1U << 1);  ///< Pull-Up/Pull-Down Enable at Port 2 Bit 1
        constexpr uint32_t P3 = (1U << 3);  ///< Pull-Up/Pull-Down Enable at Port 2 Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Pull-Up/Pull-Down Enable at Port 2 Bit 4
        constexpr uint32_t P5 = (1U << 5);  ///< Pull-Up/Pull-Down Enable at Port 2 Bit 5
        constexpr uint32_t P7 = (1U << 7);  ///< Pull-Up/Pull-Down Enable at Port 2 Bit 7
    }

    /// P2_PUDSEL Register bits
    namespace p2_pudsel_bits {
        constexpr uint32_t P1 = (1U << 1);  ///< Pull-Up/Pull-Down Select Port 2 Bit 1
        constexpr uint32_t P3 = (1U << 3);  ///< Pull-Up/Pull-Down Select Port 2 Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Pull-Up/Pull-Down Select Port 2 Bit 4
        constexpr uint32_t P5 = (1U << 5);  ///< Pull-Up/Pull-Down Select Port 2 Bit 5
        constexpr uint32_t P7 = (1U << 7);  ///< Pull-Up/Pull-Down Select Port 2 Bit 7
    }

}

// ============================================================================
// SCU Peripheral
// ============================================================================

namespace scu {
    /// Base addresses
    constexpr uint32_t SCU_BASE = 0x50005000;

    /// SCU Register structure
    struct Registers {
        volatile uint32_t APCLK1;  ///< Offset: 0x58 - Analog Peripheral Clock Register 1, RESET_TYPE_4
        volatile uint32_t APCLK2;  ///< Offset: 0x5C - Analog Peripheral Clock Register 2, RESET_TYPE_4
        volatile uint32_t APCLK_CTRL1;  ///< Offset: 0x54 - Analog Peripheral Clock Control 1 Register, RESET_TYPE_4
        volatile uint32_t APCLK_CTRL2;  ///< Offset: 0x6C - Analog Peripheral Clock Control 2 Register, RESET_TYPE_4
        volatile uint32_t BCON1;  ///< Offset: 0x88 - Baud Rate Control Register 1, RESET_TYPE_3
        volatile uint32_t BCON2;  ///< Offset: 0x98 - Baud Rate Control Register 2, RESET_TYPE_3
        volatile uint32_t BGH1;  ///< Offset: 0x90 - Baud Rate Timer/Reload Register, High Byte, RESET_TYPE_3
        volatile uint32_t BGH2;  ///< Offset: 0xA0 - Baud Rate Timer/Reload Register, High Byte, RESET_TYPE_3
        volatile uint32_t BGL1;  ///< Offset: 0x8C - Baud Rate Timer/Reload Register, Low Byte 1, RESET_TYPE_3
        volatile uint32_t BGL2;  ///< Offset: 0x9C - Baud Rate Timer/Reload Register, Low Byte 2, RESET_TYPE_3
        volatile uint32_t CMCON1;  ///< Offset: 0x48 - Clock Control Register 1, RESET_TYPE_4
        volatile uint32_t CMCON2;  ///< Offset: 0x4C - Clock Control Register 2, RESET_TYPE_4
        volatile uint32_t COCON;  ///< Offset: 0xB4 - Clock Output Control Register, RESET_TYPE_4
        volatile uint32_t EDCCON;  ///< Offset: 0xD4 - Error Detection and Correction Control Register, RESET_TYPE_3
        volatile uint32_t EDCSCLR;  ///< Offset: 0x10C - Error Detection and Correction Status Clear Register,...
        volatile uint32_t EDCSTAT;  ///< Offset: 0xD8 - Error Detection and Correction Status Register, RESET_TYPE_4
        volatile uint32_t EXICON0;  ///< Offset: 0x28 - External Interrupt Control Register 0, RESET_TYPE_3
        volatile uint32_t GPT12ICLR;  ///< Offset: 0x164 - Timer and Counter Control/Status Clear Register, RESET_TYPE_3
        volatile uint32_t GPT12IEN;  ///< Offset: 0x15C - General Purpose Timer 12 Interrupt Enable Register , RESET_TYPE_3
        volatile uint32_t GPT12IRC;  ///< Offset: 0x160 - Timer and Counter Control/Status Register, RESET_TYPE_3
        volatile uint32_t GPT12PISEL;  ///< Offset: 0xD0 - GPT12 Peripheral Input Select Register, RESET_TYPE_3
        volatile uint32_t ID;  ///< Offset: 0xA8 - Identity Register, RESET_TYPE_3
        volatile uint32_t IEN0;  ///< Offset: 0x1C - Interrupt Enable Register 0, RESET_TYPE_4
        volatile uint32_t IRCON0;  ///< Offset: 0x04 - Interrupt Request Register 0, RESET_TYPE_3
        volatile uint32_t IRCON0CLR;  ///< Offset: 0x2C - Interrupt Request 0 Clear Register, RESET_TYPE_3
        volatile uint32_t IRCON1;  ///< Offset: 0x08 - Interrupt Request Register 1, RESET_TYPE_3
        volatile uint32_t IRCON1CLR;  ///< Offset: 0x178 - Interrupt Request 1 Clear Register, RESET_TYPE_3
        volatile uint32_t IRCON2;  ///< Offset: 0x0C - Interrupt Request Register 2, RESET_TYPE_3
        volatile uint32_t IRCON2CLR;  ///< Offset: 0x17C - Interrupt Request 2 Clear Register, RESET_TYPE_3
        volatile uint32_t IRCON3;  ///< Offset: 0x10 - Interrupt Request Register 3, RESET_TYPE_3
        volatile uint32_t IRCON3CLR;  ///< Offset: 0x190 - Interrupt Request 3 Clear Register, RESET_TYPE_3
        volatile uint32_t IRCON4;  ///< Offset: 0x14 - Interrupt Request Register 4, RESET_TYPE_3
        volatile uint32_t IRCON4CLR;  ///< Offset: 0x194 - Interrupt Request 4 Clear Register, RESET_TYPE_3
        volatile uint32_t LINSCLR;  ///< Offset: 0xA4 - LIN Status Clear Register, RESET_TYPE_3
        volatile uint32_t LINST;  ///< Offset: 0x94 - LIN Status Register, RESET_TYPE_3
        volatile uint32_t MEM_ACC_STS;  ///< Offset: 0xE4 - Memory Access Status Register, RESET_TYPE_3
        volatile uint32_t MEMSTAT;  ///< Offset: 0xDC - Memory Status Register, RESET_TYPE_3
        volatile uint32_t MODIEN1;  ///< Offset: 0x30 - Peripheral Interrupt Enable Register 1, RESET_TYPE_3
        volatile uint32_t MODIEN2;  ///< Offset: 0x34 - Peripheral Interrupt Enable Register 2, RESET_TYPE_3
        volatile uint32_t MODIEN3;  ///< Offset: 0x38 - Peripheral Interrupt Enable Register 3, RESET_TYPE_3
        volatile uint32_t MODIEN4;  ///< Offset: 0x3C - Peripheral Interrupt Enable Register 4, RESET_TYPE_3
        volatile uint32_t MODPISEL;  ///< Offset: 0xB8 - Peripheral Input Select Register, RESET_TYPE_3
        volatile uint32_t MODPISEL1;  ///< Offset: 0xBC - Peripheral Input Select Register 1, RESET_TYPE_3
        volatile uint32_t MODPISEL2;  ///< Offset: 0xC0 - Peripheral Input Select Register 2, RESET_TYPE_3
        volatile uint32_t MODPISEL3;  ///< Offset: 0xC4 - Peripheral Input Select Register, RESET_TYPE_3
        volatile uint32_t MODSUSP1;  ///< Offset: 0xC8 - Module Suspend Control Register 1, RESET_TYPE_3
        volatile uint32_t MODSUSP2;  ///< Offset: 0xCC - Module Suspend Control Register 2, RESET_TYPE_3
        volatile uint32_t NMICLR;  ///< Offset: 0x00 - NMI Clear Register, RESET_TYPE_3
        volatile uint32_t NMICON;  ///< Offset: 0x24 - NMI Control Register, RESET_TYPE_4
        volatile uint32_t NMISR;  ///< Offset: 0x18 - NMI Status Register, RESET_TYPE_4
        volatile uint32_t NVM_PROT_STS;  ///< Offset: 0xE0 - NVM Protection Status Register, RESET_TYPE_4
        volatile uint32_t OSC_CON;  ///< Offset: 0xB0 - OSC Control Register, RESET_TYPE_4
        volatile uint32_t P0_POCON0;  ///< Offset: 0xE8 - Port Output Control Register, RESET_TYPE_3
        volatile uint32_t P0_POCON1;  ///< Offset: 0xEC - Port Output Control Register, RESET_TYPE_3
        volatile uint32_t P0_POCON2;  ///< Offset: 0xF0 - Port Output Control Register, RESET_TYPE_3
        volatile uint32_t P1_POCON0;  ///< Offset: 0xF8 - Port Output Control Register, RESET_TYPE_3
        volatile uint32_t P1_POCON1;  ///< Offset: 0xFC - Port Output Control Register, RESET_TYPE_3
        volatile uint32_t P1_POCON2;  ///< Offset: 0x100 - Port Output Control Register, RESET_TYPE_3
        volatile uint32_t PASSWD;  ///< Offset: 0xAC - Password Register, RESET_TYPE_3
        volatile uint32_t PLL_CON;  ///< Offset: 0x44 - PLL Control Register, RESET_TYPE_4
        volatile uint32_t PMCON0;  ///< Offset: 0x40 - Power Mode Control Register 0, RESET_TYPE_3
        volatile uint32_t PMCON1;  ///< Offset: 0x60 - Peripheral Management Control Register 1, RESET_TYPE_3
        volatile uint32_t PMCON2;  ///< Offset: 0x64 - Peripheral Management Control Register 2, RESET_TYPE_3
        volatile uint32_t RSTCON;  ///< Offset: 0x68 - Reset Control Register, RESET_TYPE_3
        volatile uint32_t SYS_STRTUP_STS;  ///< Offset: 0x74 - System Startup Status Register
        volatile uint32_t SYSCON0;  ///< Offset: 0x70 - System Control Register 0, RESET_TYPE_4
        volatile uint32_t TCCR;  ///< Offset: 0xF4 - Temperature Compensation Control Register, RESET_TYPE_3
        volatile uint32_t WDTCON;  ///< Offset: 0x50 - Watchdog Timer Control Register, RESET_TYPE_3
        volatile uint32_t WDTH;  ///< Offset: 0x84 - Watchdog Timer, High Byte, RESET_TYPE_3
        volatile uint32_t WDTL;  ///< Offset: 0x80 - Watchdog Timer, Low Byte, RESET_TYPE_3
        volatile uint32_t WDTREL;  ///< Offset: 0x78 - Watchdog Timer Reload Register, RESET_TYPE_3
        volatile uint32_t WDTWINB;  ///< Offset: 0x7C - Watchdog Window-Boundary Count, RESET_TYPE_3
    };

    /// Peripheral instances
    inline Registers* SCU = reinterpret_cast<Registers*>(SCU_BASE);

    // Bit definitions
    /// APCLK1 Register bits
    namespace apclk1_bits {
        constexpr uint32_t APCLK3SCLR = (1U << 7);  ///< Analog Peripherals Clock Status Clear
        constexpr uint32_t APCLK3STS = (1U << 6);  ///< Loss of Clock Status
        constexpr uint32_t APCLK1STS = (2 << 4);  ///< Analog Peripherals Clock Status
        constexpr uint32_t APCLK1SCLR = (1U << 2);  ///< Analog Peripherals Clock Status Clear
        constexpr uint32_t APCLK1FAC = (2 << 0);  ///< Analog Module Clock Factor
    }

    /// APCLK2 Register bits
    namespace apclk2_bits {
        constexpr uint32_t APCLK2SCLR = (1U << 7);  ///< Analog Peripherals Clock Status Clear
        constexpr uint32_t APCLK2STS = (2 << 5);  ///< Analog Peripherals Clock Status
        constexpr uint32_t APCLK2FAC = (5 << 0);  ///< Slow Down Clock Divider for TFILT_CLK Generation
    }

    /// APCLK_CTRL1 Register bits
    namespace apclk_ctrl1_bits {
        constexpr uint32_t CPCLK_DIV = (1U << 7);  ///< Charge Pump Clock Divider
        constexpr uint32_t CPCLK_SEL = (1U << 6);  ///< Charge Pump Clock Selection
        constexpr uint32_t BGCLK_DIV = (1U << 5);  ///< Bandgap Clock Divider
        constexpr uint32_t BGCLK_SEL = (1U << 4);  ///< Bandgap Clock Selection
        constexpr uint32_t CLKWDT_IE = (1U << 3);  ///< Clock Watchdog Interrupt Enable
        constexpr uint32_t T3CLK_SEL = (1U << 2);  ///< Timer 3 Clock Selection
        constexpr uint32_t APCLK_SET = (1U << 1);  ///< Set and Overtake Flag for Clock Settings
        constexpr uint32_t PLL_LOCK = (1U << 0);  ///< PLL Lock Indicator
    }

    /// APCLK_CTRL2 Register bits
    namespace apclk_ctrl2_bits {
        constexpr uint32_t T3CLK_DIV = (2 << 2);  ///< Timer 3 Clock Divider
        constexpr uint32_t SDADCCLK_DIV = (2 << 0);  ///< SD-ADC Clock Divider
    }

    /// BCON1 Register bits
    namespace bcon1_bits {
        constexpr uint32_t R = (1U << 0);  ///< Baud Rate Generator Run Control Bit
        constexpr uint32_t BRPRE = (3 << 1);  ///< Prescaler Bit
    }

    /// BCON2 Register bits
    namespace bcon2_bits {
        constexpr uint32_t R = (1U << 0);  ///< Baud Rate Generator Run Control Bit
        constexpr uint32_t BRPRE = (3 << 1);  ///< Prescaler Bit
    }

    /// BGH1 Register bits
    namespace bgh1_bits {
        constexpr uint32_t BR_VALUE = (8 << 0);  ///< Baud Rate Timer/Reload Value
    }

    /// BGH2 Register bits
    namespace bgh2_bits {
        constexpr uint32_t BR_VALUE = (8 << 0);  ///< Baud Rate Timer/Reload Value
    }

    /// BGL1 Register bits
    namespace bgl1_bits {
        constexpr uint32_t FD_SEL = (5 << 0);  ///< Fractional Divider Selection
        constexpr uint32_t BR_VALUE = (3 << 5);  ///< Baud Rate Timer/Reload Value
    }

    /// BGL2 Register bits
    namespace bgl2_bits {
        constexpr uint32_t FD_SEL = (5 << 0);  ///< Fractional Divider Selection
        constexpr uint32_t BR_VALUE = (3 << 5);  ///< Baud Rate Timer/Reload Value
    }

    /// CMCON1 Register bits
    namespace cmcon1_bits {
        constexpr uint32_t VCOSEL = (1U << 7);  ///< VCOSEL Setting
        constexpr uint32_t K1DIV = (1U << 6);  ///< PLL K1-Divider
        constexpr uint32_t K2DIV = (2 << 4);  ///< PLL K2-Divider
        constexpr uint32_t CLKREL = (4 << 0);  ///< Slow Down Clock Divider for fCCLK Generation
    }

    /// CMCON2 Register bits
    namespace cmcon2_bits {
        constexpr uint32_t PBA0CLKREL = (1U << 0);  ///< PBA0 Clock Divider
    }

    /// COCON Register bits
    namespace cocon_bits {
        constexpr uint32_t EN = (1U << 7);  ///< CLKOUT Enable
        constexpr uint32_t COUTS1 = (1U << 6);  ///< Clock Out Source Select Bit 1
        constexpr uint32_t TLEN = (1U << 5);  ///< Toggle Latch Enable
        constexpr uint32_t COUTS0 = (1U << 4);  ///< Clock Out Source Select Bit 0
        constexpr uint32_t COREL = (4 << 0);  ///< Clock Output Divider
    }

    /// EDCCON Register bits
    namespace edccon_bits {
        constexpr uint32_t NVMIE = (1U << 2);  ///< NVM Double Bit ECC Error Interrupt Enable
        constexpr uint32_t RIE = (1U << 0);  ///< RAM Double Bit ECC Error Interrupt Enable
    }

    /// EDCSCLR Register bits
    namespace edcsclr_bits {
        constexpr uint32_t RSBEC = (1U << 4);  ///< RAM Single Bit Error Clear
        constexpr uint32_t NVMDBEC = (1U << 2);  ///< NVM Double Bit Error Clear
        constexpr uint32_t RDBEC = (1U << 0);  ///< RAM Double Bit Error Clear
    }

    /// EDCSTAT Register bits
    namespace edcstat_bits {
        constexpr uint32_t RSBE = (1U << 4);  ///< RAM Single Bit Error
        constexpr uint32_t NVMDBE = (1U << 2);  ///< NVM Double Bit Error
        constexpr uint32_t RDBE = (1U << 0);  ///< RAM Double Bit Error
    }

    /// EXICON0 Register bits
    namespace exicon0_bits {
        constexpr uint32_t MON_Trig_Sel = (2 << 6);  ///< MON Input Trigger Select
        constexpr uint32_t EXINT2 = (2 << 4);  ///< External Interrupt 2 Trigger Select
        constexpr uint32_t EXINT1 = (2 << 2);  ///< External Interrupt 1 Trigger Select
        constexpr uint32_t EXINT0 = (2 << 0);  ///< External Interrupt 0 Trigger Select
    }

    /// GPT12ICLR Register bits
    namespace gpt12iclr_bits {
        constexpr uint32_t CRC = (1U << 5);  ///< GPT Module 2 Capture Reload Interrupt Status Clear
        constexpr uint32_t T6C = (1U << 4);  ///< GPT Module 2Timer6 Interrupt Status Clear
        constexpr uint32_t T5C = (1U << 3);  ///< GPT Module 2 Timer5 Interrupt Status Clear
        constexpr uint32_t T4C = (1U << 2);  ///< GPT Module 1 Timer4 Interrupt Status Clear
        constexpr uint32_t T3C = (1U << 1);  ///< GPT Module 1 Timer3 Interrupt Status Clear
        constexpr uint32_t T2C = (1U << 0);  ///< GPT Module 1 Timer 2 Interrupt Status Clear
    }

    /// GPT12IEN Register bits
    namespace gpt12ien_bits {
        constexpr uint32_t CRIE = (1U << 5);  ///< General Purpose Timer 12 Capture and Reload Interrupt Enable
        constexpr uint32_t T6IE = (1U << 4);  ///< General Purpose Timer 12 T6 Interrupt Enable
        constexpr uint32_t T5IE = (1U << 3);  ///< General Purpose Timer 12 T5 Interrupt Enable
        constexpr uint32_t T4IE = (1U << 2);  ///< General Purpose Timer 12 T4 Interrupt Enable
        constexpr uint32_t T3IE = (1U << 1);  ///< General Purpose Timer 12 T3 Interrupt Enable
        constexpr uint32_t T2IE = (1U << 0);  ///< General Purpose Timer 12 T2 Interrupt Enable
    }

    /// GPT12IRC Register bits
    namespace gpt12irc_bits {
        constexpr uint32_t CR = (1U << 5);  ///< GPT Module 2 Capture Reload Interrupt Status
        constexpr uint32_t T6 = (1U << 4);  ///< GPT Module 2Timer6 Interrupt Status
        constexpr uint32_t T5 = (1U << 3);  ///< GPT Module 2 Timer5 Interrupt Status
        constexpr uint32_t T4 = (1U << 2);  ///< GPT Module 1 Timer4 Interrupt Status
        constexpr uint32_t T3 = (1U << 1);  ///< GPT Module 1 Timer3 Interrupt Status
        constexpr uint32_t T2 = (1U << 0);  ///< GPT Module 1 Timer 2 Interrupt Status
    }

    /// GPT12PISEL Register bits
    namespace gpt12pisel_bits {
        constexpr uint32_t T3_GPT12_SEL = (1U << 5);  ///< CCU6_INT_SEL.
        constexpr uint32_t TRIG_CONF = (1U << 4);  ///< CCU6 Trigger Configuration.
        constexpr uint32_t GPT12 = (4 << 0);  ///< GPT12 TIN3B / TIN4D Input Select
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t PRODID = (5 << 3);  ///< Product ID
        constexpr uint32_t VERID = (3 << 0);  ///< Version ID
    }

    /// IEN0 Register bits
    namespace ien0_bits {
        constexpr uint32_t EA = (1U << 7);  ///< Global Interrupt Mask
    }

    /// IRCON0 Register bits
    namespace ircon0_bits {
        constexpr uint32_t MONF = (1U << 7);  ///< Interrupt Flag for External Interrupt MON on falling edge
        constexpr uint32_t MONR = (1U << 6);  ///< Interrupt Flag for External Interrupt MON on rising edge
        constexpr uint32_t EXINT2F = (1U << 5);  ///< Interrupt Flag for External Interrupt 2x on falling edge
        constexpr uint32_t EXINT2R = (1U << 4);  ///< Interrupt Flag for External Interrupt 2x on rising edge
        constexpr uint32_t EXINT1F = (1U << 3);  ///< Interrupt Flag for External Interrupt 1x on falling edge
        constexpr uint32_t EXINT1R = (1U << 2);  ///< Interrupt Flag for External Interrupt 1x on rising edge
        constexpr uint32_t EXINT0F = (1U << 1);  ///< Interrupt Flag for External Interrupt 0x on falling edge
        constexpr uint32_t EXINT0R = (1U << 0);  ///< Interrupt Flag for External Interrupt 0x on rising edge
    }

    /// IRCON0CLR Register bits
    namespace ircon0clr_bits {
        constexpr uint32_t MONFC = (1U << 7);  ///< Interrupt Flag for External Interrupt MON on falling edge clear
        constexpr uint32_t MONRC = (1U << 6);  ///< Interrupt Flag for External Interrupt MON on rising edge clear
        constexpr uint32_t EXINT2FC = (1U << 5);  ///< Interrupt Flag for External Interrupt 2x on falling edge clear
        constexpr uint32_t EXINT2RC = (1U << 4);  ///< Interrupt Flag for External Interrupt 2x on rising edge clear
        constexpr uint32_t EXINT1FC = (1U << 3);  ///< Interrupt Flag for External Interrupt 1x on falling edge clear
        constexpr uint32_t EXINT1RC = (1U << 2);  ///< Interrupt Flag for External Interrupt 1x on rising edge clear
        constexpr uint32_t EXINT0FC = (1U << 1);  ///< Interrupt Flag for External Interrupt 0x on falling edge clear
        constexpr uint32_t EXINT0RC = (1U << 0);  ///< Interrupt Flag for External Interrupt 0x on rising edge clear
    }

    /// IRCON1 Register bits
    namespace ircon1_bits {
        constexpr uint32_t RIR = (1U << 2);  ///< Receive Interrupt Flag for SSC1
        constexpr uint32_t TIR = (1U << 1);  ///< Transmit Interrupt Flag for SSC1
        constexpr uint32_t EIR = (1U << 0);  ///< Error Interrupt Flag for SSC1
    }

    /// IRCON1CLR Register bits
    namespace ircon1clr_bits {
        constexpr uint32_t RIRC = (1U << 2);  ///< Receive Interrupt Flag for SSC1 Clear
        constexpr uint32_t TIRC = (1U << 1);  ///< Transmit Interrupt Flag for SSC1 Clear
        constexpr uint32_t EIRC = (1U << 0);  ///< Error Interrupt Flag for SSC1 Clear
    }

    /// IRCON2 Register bits
    namespace ircon2_bits {
        constexpr uint32_t RIR = (1U << 2);  ///< Receive Interrupt Flag for SSC2
        constexpr uint32_t TIR = (1U << 1);  ///< Transmit Interrupt Flag for SSC2
        constexpr uint32_t EIR = (1U << 0);  ///< Error Interrupt Flag for SSC2
    }

    /// IRCON2CLR Register bits
    namespace ircon2clr_bits {
        constexpr uint32_t RIRC = (1U << 2);  ///< Receive Interrupt Flag for SSC2 Clear
        constexpr uint32_t TIRC = (1U << 1);  ///< Transmit Interrupt Flag for SSC2 Clear
        constexpr uint32_t EIRC = (1U << 0);  ///< Error Interrupt Flag for SSC2 Clear
    }

    /// IRCON3 Register bits
    namespace ircon3_bits {
        constexpr uint32_t CCU6SR1 = (1U << 4);  ///< Interrupt Flag 1 for CCU6
        constexpr uint32_t CCU6SR0 = (1U << 0);  ///< Interrupt Flag 0 for CCU6
    }

    /// IRCON3CLR Register bits
    namespace ircon3clr_bits {
        constexpr uint32_t CCU6SR1C = (1U << 4);  ///< Interrupt Flag 1 for CCU6 Clear
        constexpr uint32_t CCU6SR0C = (1U << 0);  ///< Interrupt Flag 0 for CCU6 Clear
    }

    /// IRCON4 Register bits
    namespace ircon4_bits {
        constexpr uint32_t CCU6SR3 = (1U << 4);  ///< Interrupt Flag 3 for CCU6
        constexpr uint32_t CCU6SR2 = (1U << 0);  ///< Interrupt Flag 2 for CCU6
    }

    /// IRCON4CLR Register bits
    namespace ircon4clr_bits {
        constexpr uint32_t CCU6SR3C = (1U << 4);  ///< Interrupt Flag 3 for CCU6 Clear
        constexpr uint32_t CCU6SR2C = (1U << 0);  ///< Interrupt Flag 2 for CCU6 Clear
    }

    /// LINSCLR Register bits
    namespace linsclr_bits {
        constexpr uint32_t BRKC = (1U << 3);  ///< Break Field Flag Clear
        constexpr uint32_t EOFSYNC = (1U << 4);  ///< End of SYN Byte Interrupt Flag Clear
        constexpr uint32_t ERRSYNC = (1U << 5);  ///< SYN Byte Error Interrupt Flag
    }

    /// LINST Register bits
    namespace linst_bits {
        constexpr uint32_t BRDIS = (1U << 0);  ///< Baud Rate Detection Disable
        constexpr uint32_t BGSEL = (2 << 1);  ///< Baud Rate Select for Detection
        constexpr uint32_t BRK = (1U << 3);  ///< Break Field Flag
        constexpr uint32_t EOFSYN = (1U << 4);  ///< End of SYN Byte Interrupt Flag
        constexpr uint32_t ERRSYN = (1U << 5);  ///< SYN Byte Error Interrupt Flag
        constexpr uint32_t SYNEN = (1U << 6);  ///< End of SYN Byte and SYN Byte Error Interrupts Enable
    }

    /// MEM_ACC_STS Register bits
    namespace mem_acc_sts_bits {
        constexpr uint32_t RAM_PROT_ERR = (1U << 6);  ///< RAM Access Protection
        constexpr uint32_t ROM_ADDR_ERR = (1U << 5);  ///< ROM Address Protection
        constexpr uint32_t ROM_PROT_ERR = (1U << 4);  ///< ROM Access Protection
        constexpr uint32_t NVM_SFR_ADDR_ERR = (1U << 3);  ///< NVM SFR Address Protection
        constexpr uint32_t NVM_SFR_PROT_ERR = (1U << 2);  ///< NVM SFR Access Protection
        constexpr uint32_t NVM_ADDR_ERR = (1U << 1);  ///< NVM Address Protection
        constexpr uint32_t NVM_PROT_ERR = (1U << 0);  ///< NVM Access Protection
    }

    /// MEMSTAT Register bits
    namespace memstat_bits {
        constexpr uint32_t SASTATUS = (2 << 6);  ///< Service Algorithm Status
        constexpr uint32_t SECTORINFO = (6 << 0);  ///< Sector Information
    }

    /// MODIEN1 Register bits
    namespace modien1_bits {
        constexpr uint32_t TIEN1 = (1U << 7);  ///< UART 1 Transmit Interrupt Enable
        constexpr uint32_t RIEN1 = (1U << 6);  ///< UART 1 Receive Interrupt Enable
        constexpr uint32_t RIREN1 = (1U << 2);  ///< SSC 1 Receive Interrupt Enable
        constexpr uint32_t TIREN1 = (1U << 1);  ///< SSC 1 Transmit Interrupt Enable
        constexpr uint32_t EIREN1 = (1U << 0);  ///< SSC 1 Error Interrupt Enable
    }

    /// MODIEN2 Register bits
    namespace modien2_bits {
        constexpr uint32_t TIEN2 = (1U << 7);  ///< UART 2 Transmit Interrupt Enable
        constexpr uint32_t RIEN2 = (1U << 6);  ///< UART 2 Receive Interrupt Enable
        constexpr uint32_t EXINT2_EN = (1U << 5);  ///< External Interrupt 2 Enable
        constexpr uint32_t RIREN2 = (1U << 2);  ///< SSC 2 Receive Interrupt Enable
        constexpr uint32_t TIREN2 = (1U << 1);  ///< SSC 2 Transmit Interrupt Enable
        constexpr uint32_t EIREN2 = (1U << 0);  ///< SSC 2 Error Interrupt Enable
    }

    /// MODIEN3 Register bits
    namespace modien3_bits {
        constexpr uint32_t MONSTS = (1U << 5);  ///< MON Input Status
        constexpr uint32_t MONIE = (1U << 4);  ///< MON Interrupt Enable
        constexpr uint32_t IE0 = (1U << 0);  ///< External Interrupt Enable
    }

    /// MODIEN4 Register bits
    namespace modien4_bits {
        constexpr uint32_t IE1 = (1U << 0);  ///< External Interrupt Enable
    }

    /// MODPISEL Register bits
    namespace modpisel_bits {
        constexpr uint32_t U_TX_CONDIS = (1U << 7);  ///< UART1 TxD Connection Disable
        constexpr uint32_t URIOS1 = (1U << 6);  ///< UART1 Input/Output Select
        constexpr uint32_t EXINT2IS = (2 << 4);  ///< External Interrupt 2 Input Select
        constexpr uint32_t EXINT1IS = (2 << 2);  ///< External Interrupt 1 Input Select
        constexpr uint32_t EXINT0IS = (2 << 0);  ///< External Interrupt 0 Input Select
    }

    /// MODPISEL1 Register bits
    namespace modpisel1_bits {
        constexpr uint32_t T21EXCON = (1U << 7);  ///< Timer 21 External Input Control
        constexpr uint32_t T2EXCON = (1U << 6);  ///< Timer 2 External Input Control
        constexpr uint32_t GPT12CAPINB = (1U << 0);  ///< GPT12 CAPINB Input Control
    }

    /// MODPISEL2 Register bits
    namespace modpisel2_bits {
        constexpr uint32_t T21EXIS = (2 << 6);  ///< Timer 21 External Input Select
        constexpr uint32_t T2EXIS = (2 << 4);  ///< Timer 2 External Input Select
        constexpr uint32_t T21IS = (2 << 2);  ///< Timer 21 Input Select
        constexpr uint32_t T2IS = (2 << 0);  ///< Timer 2 Input Select
    }

    /// MODPISEL3 Register bits
    namespace modpisel3_bits {
        constexpr uint32_t URIOS2 = (1U << 6);  ///< UART2 Input/Output Select
    }

    /// MODSUSP1 Register bits
    namespace modsusp1_bits {
        constexpr uint32_t T21_SUSP = (1U << 6);  ///< Timer21 Debug Suspend Bit
        constexpr uint32_t GPT12_SUSP = (1U << 4);  ///< GPT12 Debug Suspend Bit
        constexpr uint32_t T2_SUSP = (1U << 3);  ///< Timer2 Debug Suspend Bit
        constexpr uint32_t T13SUSP = (1U << 2);  ///< Timer 13 Debug Suspend Bit
        constexpr uint32_t T12SUSP = (1U << 1);  ///< Timer 12 Debug Suspend Bit
        constexpr uint32_t WDTSUSP = (1U << 0);  ///< SCU Watchdog Timer Debug Suspend Bit
    }

    /// MODSUSP2 Register bits
    namespace modsusp2_bits {
        constexpr uint32_t ADC1_SUSP = (1U << 2);  ///< ADC1 Unit Debug Suspend Bit
        constexpr uint32_t MU_SUSP = (1U << 1);  ///< Measurement Unit Debug Suspend Bit
        constexpr uint32_t T3_SUSP = (1U << 0);  ///< Measurement Unit Debug Suspend Bit
    }

    /// NMICLR Register bits
    namespace nmiclr_bits {
        constexpr uint32_t NMISUPC = (1U << 7);  ///< Supply Prewarning NMI Clear
        constexpr uint32_t NMIECCC = (1U << 6);  ///< ECC Error NMI Clear
        constexpr uint32_t NMIMAPC = (1U << 5);  ///< NVM Map Error NMI Clear
        constexpr uint32_t NMIOWDC = (1U << 4);  ///< Oscillator Watchdog NMI Clear
        constexpr uint32_t NMIOTC = (1U << 3);  ///< NMI OT Clear
        constexpr uint32_t NMINVMC = (1U << 2);  ///< NVM Operation Complete NMI Clear
        constexpr uint32_t NMIPLLC = (1U << 1);  ///< PLL Loss of Lock NMI Clear
        constexpr uint32_t NMIWDTC = (1U << 0);  ///< Watchdog Timer NMI Clear
    }

    /// NMICON Register bits
    namespace nmicon_bits {
        constexpr uint32_t NMISUP = (1U << 7);  ///< Supply Prewarning NMI Enable
        constexpr uint32_t NMIECC = (1U << 6);  ///< ECC Error NMI Enable
        constexpr uint32_t NMIMAP = (1U << 5);  ///< NVM Map Error NMI Enable
        constexpr uint32_t NMIOWD = (1U << 4);  ///< Oscillator Watchdog NMI Enable
        constexpr uint32_t NMIOT = (1U << 3);  ///< NMI OT Enable
        constexpr uint32_t NMINVM = (1U << 2);  ///< NVM Operation Complete NMI Enable
        constexpr uint32_t NMIPLL = (1U << 1);  ///< PLL Loss of Lock NMI Enable
        constexpr uint32_t NMIWDT = (1U << 0);  ///< Watchdog Timer NMI Enable
    }

    /// NMISR Register bits
    namespace nmisr_bits {
        constexpr uint32_t FNMISUP = (1U << 7);  ///< Supply Prewarning NMI Flag
        constexpr uint32_t FNMIECC = (1U << 6);  ///< ECC Error NMI Flag
        constexpr uint32_t FNMIMAP = (1U << 5);  ///< NVM Map Error NMI Flag
        constexpr uint32_t FNMIOWD = (1U << 4);  ///< Oscillator Watchdog or MI_CLK Watchdog NMI Flag
        constexpr uint32_t FNMIOT = (1U << 3);  ///< Over-temperature NMI Flag
        constexpr uint32_t FNMINVM = (1U << 2);  ///< NVM Operation Complete NMI Flag
        constexpr uint32_t FNMIPLL = (1U << 1);  ///< PLL NMI Flag
        constexpr uint32_t FNMIWDT = (1U << 0);  ///< Watchdog Timer NMI Flag
    }

    /// NVM_PROT_STS Register bits
    namespace nvm_prot_sts_bits {
        constexpr uint32_t NVMPROTSTSL_3 = (1U << 3);  ///< NVM Protection Status Register Low Flags
        constexpr uint32_t NVMPROTSTSL_2 = (1U << 2);  ///< NVM Protection Status Register Low Flags
        constexpr uint32_t NVMPROTSTSL_1 = (1U << 1);  ///< NVM Protection Status Register Low Flags
        constexpr uint32_t NVMPROTSTSL_0 = (1U << 0);  ///< NVM Protection Status Register Low Flags
    }

    /// OSC_CON Register bits
    namespace osc_con_bits {
        constexpr uint32_t OSCTRIM_8 = (1U << 7);  ///< OSC_PLL Trim Configuration Bit [8]
        constexpr uint32_t XPD = (1U << 4);  ///< XTAL (OSC_HP) Power Down Control
        constexpr uint32_t OSC2L = (1U << 3);  ///< OSC-Too-Low Condition Flag
        constexpr uint32_t OSCWDTRST = (1U << 2);  ///< Oscillator Watchdog Reset
        constexpr uint32_t OSCSS = (2 << 0);  ///< Oscillator Source Select
    }

    /// P0_POCON0 Register bits
    namespace p0_pocon0_bits {
        constexpr uint32_t PDM1 = (3 << 4);  ///< P0.1 Port Driver Mode
        constexpr uint32_t PDM0 = (3 << 0);  ///< P0.0 Port Driver Mode
    }

    /// P0_POCON1 Register bits
    namespace p0_pocon1_bits {
        constexpr uint32_t PDM3 = (3 << 4);  ///< P0.3 Port Driver Mode
        constexpr uint32_t PDM2 = (3 << 0);  ///< P0.2 Port Driver Mode
    }

    /// P0_POCON2 Register bits
    namespace p0_pocon2_bits {
        constexpr uint32_t PDM4 = (3 << 0);  ///< P0.4 Port Driver Mode
    }

    /// P1_POCON0 Register bits
    namespace p1_pocon0_bits {
        constexpr uint32_t PDM1 = (3 << 4);  ///< P1.1 Port Driver Mode
        constexpr uint32_t PDM0 = (3 << 0);  ///< P1.0 Port Driver Mode
    }

    /// P1_POCON1 Register bits
    namespace p1_pocon1_bits {
        constexpr uint32_t PDM3 = (3 << 4);  ///< P1.3 Port Driver Mode
        constexpr uint32_t PDM2 = (3 << 0);  ///< P1.2 Port Driver Mode
    }

    /// P1_POCON2 Register bits
    namespace p1_pocon2_bits {
        constexpr uint32_t PDM4 = (3 << 0);  ///< P1.4 Port Driver Mode
    }

    /// PASSWD Register bits
    namespace passwd_bits {
        constexpr uint32_t PASS = (5 << 3);  ///< Password Bits
        constexpr uint32_t PROTECT_S = (1U << 2);  ///< Bit-Protection Signal Status Bit
        constexpr uint32_t MODE = (2 << 0);  ///< Bit-Protection Scheme Control Bit
    }

    /// PLL_CON Register bits
    namespace pll_con_bits {
        constexpr uint32_t NDIV = (4 << 4);  ///< PLL N-Divider
        constexpr uint32_t VCOBYP = (1U << 3);  ///< PLL VCO Bypass Mode Select
        constexpr uint32_t OSCDISC = (1U << 2);  ///< Oscillator Disconnect
        constexpr uint32_t RESLD = (1U << 1);  ///< Restart Lock Detection
        constexpr uint32_t LOCK = (1U << 0);  ///< PLL Lock Status Flag
    }

    /// PMCON0 Register bits
    namespace pmcon0_bits {
        constexpr uint32_t SD = (1U << 3);  ///< Slow Down Mode Enable. Active High.
        constexpr uint32_t SL = (1U << 1);  ///< Sleep Mode Enable. Active High.
        constexpr uint32_t XTAL_ON = (1U << 0);  ///< OSC_HP Operation in Power Down Mode
    }

    /// PMCON1 Register bits
    namespace pmcon1_bits {
        constexpr uint32_t GPT12_DIS = (1U << 4);  ///< General Purpose Timer 12 Disable Request. Active high.
        constexpr uint32_t T2_DIS = (1U << 3);  ///< T2 Disable Request. Active high.
        constexpr uint32_t CCU6_DIS = (1U << 2);  ///< CCU6 Disable Request. Active high.
        constexpr uint32_t SSC1_DIS = (1U << 1);  ///< SSC1 Disable Request. Active high.
        constexpr uint32_t ADC1_DIS = (1U << 0);  ///< ADC1 Disable Request. Active high.
    }

    /// PMCON2 Register bits
    namespace pmcon2_bits {
        constexpr uint32_t T3_DIS = (1U << 5);  ///< T3 Disable Request. Active high.
        constexpr uint32_t T21_DIS = (1U << 3);  ///< T21 Disable Request. Active high.
        constexpr uint32_t SSC2_DIS = (1U << 1);  ///< SSC2 Disable Request. Active high.
    }

    /// RSTCON Register bits
    namespace rstcon_bits {
        constexpr uint32_t LOCKUP_EN = (1U << 7);  ///< Lockup Reset Enable Flag
        constexpr uint32_t LOCKUP = (1U << 0);  ///< Lockup Flag
    }

    /// SYS_STRTUP_STS Register bits
    namespace sys_strtup_sts_bits {
        constexpr uint32_t PG100TP_CHKS_ERR = (1U << 2);  ///< 100 TP Page Checksum Error
        constexpr uint32_t MRAMINITSTS = (1U << 1);  ///< Map RAM Initialization Status
        constexpr uint32_t INIT_FAIL = (1U << 0);  ///< Initialization at startup failed
    }

    /// SYSCON0 Register bits
    namespace syscon0_bits {
        constexpr uint32_t SYSCLKSEL = (2 << 6);  ///< System Clock Select
        constexpr uint32_t NVMCLKFAC = (2 << 4);  ///< NVM Access Clock Factor
    }

    /// TCCR Register bits
    namespace tccr_bits {
        constexpr uint32_t TCC = (2 << 0);  ///< Temperature Compensation Control
    }

    /// WDTCON Register bits
    namespace wdtcon_bits {
        constexpr uint32_t WINBEN = (1U << 5);  ///< Watchdog Window-Boundary Enable
        constexpr uint32_t WDTPR = (1U << 4);  ///< Watchdog Prewarning Mode Flag
        constexpr uint32_t WDTEN = (1U << 2);  ///< WDT Enable
        constexpr uint32_t WDTRS = (1U << 1);  ///< WDT Refresh Start
        constexpr uint32_t WDTIN = (1U << 0);  ///< Watchdog Timer Input Frequency Selection
    }

    /// WDTH Register bits
    namespace wdth_bits {
        constexpr uint32_t WDT = (8 << 0);  ///< Watchdog Timer Current Value
    }

    /// WDTL Register bits
    namespace wdtl_bits {
        constexpr uint32_t WDT = (8 << 0);  ///< Watchdog Timer Current Value
    }

    /// WDTREL Register bits
    namespace wdtrel_bits {
        constexpr uint32_t WDTREL = (8 << 0);  ///< Watchdog Timer Reload Value
    }

    /// WDTWINB Register bits
    namespace wdtwinb_bits {
        constexpr uint32_t WDTWINB = (8 << 0);  ///< Watchdog Window-Boundary Count Value
    }

}

// ============================================================================
// SCUPM Peripheral
// ============================================================================

namespace scupm {
    /// Base addresses
    constexpr uint32_t SCUPM_BASE = 0x50006000;

    /// SCUPM Register structure
    struct Registers {
        volatile uint32_t AMCLK_CTRL;  ///< Offset: 0x04 - Analog Module Clock Control
        volatile uint32_t AMCLK_FREQ_STS;  ///< Offset: 0x00 - Analog Module Clock Frequency Status Register
        volatile uint32_t AMCLK_TH_HYS;  ///< Offset: 0x0C - Analog Module Clock Limit Register
        volatile uint32_t BDRV_IRQ_CTRL;  ///< Offset: 0x5C - Bridge Driver Interrupt Control
        volatile uint32_t BDRV_IS;  ///< Offset: 0x58 - Bridge Driver Interrrupt Status
        volatile uint32_t BDRV_ISCLR;  ///< Offset: 0x54 - Bridge Driver Interrrupt Status Clear
        volatile uint32_t BFSTS;  ///< Offset: 0x80 - Bus Fault Status
        volatile uint32_t BFSTS_CLR;  ///< Offset: 0x8C - Bus Fault Status Clear Register
        volatile uint32_t DBFA;  ///< Offset: 0x84 - Data Bus Fault Address Register
        volatile uint32_t PCU_CTRL_STS;  ///< Offset: 0x30 - Power Control Unit Control Status
        volatile uint32_t SBFA;  ///< Offset: 0x88 - System Bus Fault Address Register
        volatile uint32_t STCALIB;  ///< Offset: 0x6C - System Tick Calibration Register
        volatile uint32_t SYS_IRQ_CTRL;  ///< Offset: 0x28 - System Interrupt Control
        volatile uint32_t SYS_IS;  ///< Offset: 0x18 - System Interrupt Status
        volatile uint32_t SYS_ISCLR;  ///< Offset: 0x14 - System Interrupt Status Clear
        volatile uint32_t SYS_SUPPLY_IRQ_CLR;  ///< Offset: 0x24 - System Supply Interrupt Status Clear
        volatile uint32_t SYS_SUPPLY_IRQ_CTRL;  ///< Offset: 0x20 - System Supply Interrupt Control
        volatile uint32_t SYS_SUPPLY_IRQ_STS;  ///< Offset: 0x1C - System Supply Interrupt Status
        volatile uint32_t WDT1_TRIG;  ///< Offset: 0x34 - WDT1 Watchdog Control
    };

    /// Peripheral instances
    inline Registers* SCUPM = reinterpret_cast<Registers*>(SCUPM_BASE);

    // Bit definitions
    /// AMCLK_CTRL Register bits
    namespace amclk_ctrl_bits {
        constexpr uint32_t CLKWDT_PD_N = (1U << 0);  ///< Clock Watchdog Powerdown
    }

    /// AMCLK_FREQ_STS Register bits
    namespace amclk_freq_sts_bits {
        constexpr uint32_t AMCLK2_FREQ = (6 << 8);  ///< Current frequency of Analog Module Clock 2 (TFILT_CLK)
        constexpr uint32_t AMCLK1_FREQ = (6 << 0);  ///< Current frequency of Analog Module Clock System Clock (MI_CLK)
    }

    /// AMCLK_TH_HYS Register bits
    namespace amclk_th_hys_bits {
        constexpr uint32_t AMCLK2_LOW_HYS = (2 << 30);  ///< Analog Module Clock 2 (TFILT_CLK) Lower Hysteresis
        constexpr uint32_t AMCLK2_LOW_TH = (6 << 24);  ///< Analog Module Clock 2 (TFILT_CLK) Lower Limit Threshold
        constexpr uint32_t AMCLK2_UP_HYS = (2 << 22);  ///< Analog Module Clock 2 (TFILT_CLK) Upper Hysteresis
        constexpr uint32_t AMCLK2_UP_TH = (6 << 16);  ///< Analog Module Clock 2 (TFILT_CLK) Upper Limit Threshold
        constexpr uint32_t AMCLK1_LOW_HYS = (2 << 14);  ///< Analog Module Clock 1 (MI_CLK) Lower Hysteresis
        constexpr uint32_t AMCLK1_LOW_TH = (6 << 8);  ///< Analog Module Clock 1 (MI_CLK) Lower Limit Threshold
        constexpr uint32_t AMCLK1_UP_HYS = (2 << 6);  ///< Analog Module Clock 1 (MI_CLK) Upper Hysteresis
        constexpr uint32_t AMCLK1_UP_TH = (6 << 0);  ///< Analog Module Clock 1 (MI_CLK) Upper Limit Threshold
    }

    /// BDRV_IRQ_CTRL Register bits
    namespace bdrv_irq_ctrl_bits {
        constexpr uint32_t VSD_UPTH_IE = (1U << 20);  ///< VSD Measurement Upper Threshold Interrupt Enable
        constexpr uint32_t VSD_LOWTH_IE = (1U << 19);  ///< VSD Measurement Lower Threshold Interrupt Enable
        constexpr uint32_t VCP_UPTH_IE = (1U << 18);  ///< VCP Measurement Upper Threshold Interrupt Enable
        constexpr uint32_t VCP_LOWTH1_IE = (1U << 17);  ///< VCP Measurement Lower Threshold 1 Interrupt Enable
        constexpr uint32_t VCP_LOWTH2_IE = (1U << 16);  ///< VCP Measurement Lower Threshold 2 Interrupt Enable
        constexpr uint32_t HS2_OC_IE = (1U << 13);  ///< External High Side 2 FET Over-current Interrupt Enable
        constexpr uint32_t HS1_OC_IE = (1U << 12);  ///< External High Side 1 FET Over-current Interrupt Enable
        constexpr uint32_t LS2_OC_IE = (1U << 11);  ///< External Low Side 2 FET Over-current Interrupt Enable
        constexpr uint32_t LS1_OC_IE = (1U << 10);  ///< External Low Side 1 FET Over-current Interrupt Enable
        constexpr uint32_t HS2_DS_IE = (1U << 3);  ///< Bridge Driver High Side 2 Pre-Driver Short Interrupt Enable
        constexpr uint32_t HS1_DS_IE = (1U << 2);  ///< Bridge Driver High Side 1 Pre-Driver Short Interrupt Enable
        constexpr uint32_t LS2_DS_IE = (1U << 1);  ///< Bridge Driver Low Side 2 Pre-Driver Short Interrupt Enable
        constexpr uint32_t LS1_DS_IE = (1U << 0);  ///< Bridge Driver Low Side 1 Pre-Driver Short Interrupt Enable
    }

    /// BDRV_IS Register bits
    namespace bdrv_is_bits {
        constexpr uint32_t VSD_UPTH_STS = (1U << 28);  ///< Warning for VSD Upper Threshold Measurement (ADC2 channel 2) Status
        constexpr uint32_t VSD_LOWTH_STS = (1U << 27);  ///< Warning for VSD Lower Threshold Measurement (ADC2 channel 2) Status
        constexpr uint32_t VCP_UPTH_STS = (1U << 26);  ///< Warning for VCP Upper Threshold Measurement (ADC2 channel 3) Status
        constexpr uint32_t VCP_LOWTH1_STS = (1U << 25);  ///< Warning for VCP Lower Threshold 1 Measurement (ADC2 channel 3) Status
        constexpr uint32_t VCP_LOWTH2_STS = (1U << 24);  ///< Warning for VCP Lower Threshold 2 Measurement (VCP_LOW Signal from CP) Status
        constexpr uint32_t VSD_UPTH_IS = (1U << 20);  ///< Warning for VSD Upper Threshold Measurement (ADC2 channel 2) Interrupt Status
        constexpr uint32_t VSD_LOWTH_IS = (1U << 19);  ///< Warning for VSD Lower Threshold Measurement (ADC2 channel 2) Interrupt Status
        constexpr uint32_t VCP_UPTH_IS = (1U << 18);  ///< Warning for VCP Upper Threshold Measurement (ADC2 channel 3) Interrupt Status
        constexpr uint32_t VCP_LOWTH1_IS = (1U << 17);  ///< Warning for VCP Lower Threshold 1 Measurement (ADC2 channel 3) Interrupt Status
        constexpr uint32_t VCP_LOWTH2_IS = (1U << 16);  ///< Warning for VCP Lower Threshold 2 Measurement (VCP_LOW Signal from CP) Interrupt Status
        constexpr uint32_t HS2_OC_IS = (1U << 13);  ///< External High Side 2 FET Over-current Status
        constexpr uint32_t HS1_OC_IS = (1U << 12);  ///< External High 1 FET Over-current Status
        constexpr uint32_t LS2_OC_IS = (1U << 11);  ///< External Low Side 2 FET Over-current Status
        constexpr uint32_t LS1_OC_IS = (1U << 10);  ///< External Low Side 1 FET Over-current Status
        constexpr uint32_t HS2_DS_IS = (1U << 3);  ///< Bridge Driver High Side 2 Pre-Driver short Interrupt Status
        constexpr uint32_t HS1_DS_IS = (1U << 2);  ///< Bridge Driver High Side 1 Pre-Driver short Interrupt Status
        constexpr uint32_t LS2_DS_IS = (1U << 1);  ///< Bridge Driver Low Side 2 Pre-Driver short Interrupt Status
        constexpr uint32_t LS1_DS_IS = (1U << 0);  ///< Bridge Driver Low Side 1 Pre-Driver short Interrupt Status
    }

    /// BDRV_ISCLR Register bits
    namespace bdrv_isclr_bits {
        constexpr uint32_t VSD_UPTH_SCLR = (1U << 28);  ///< Warning for VSD Upper Threshold Measurement (ADC2 channel 2) Status
        constexpr uint32_t VSD_LOWTH_SCLR = (1U << 27);  ///< Warning for VSD Lower Threshold Measurement (ADC2 channel 2) Status
        constexpr uint32_t VCP_UPTH_SCLR = (1U << 26);  ///< Warning for VCP Upper Threshold Measurement (ADC2 channel 3) Status
        constexpr uint32_t VCP_LOWTH1_SCLR = (1U << 25);  ///< Warning for VCP Lower Threshold 1 Measurement (ADC2 channel 3) Status
        constexpr uint32_t VCP_LOWTH2_SCLR = (1U << 24);  ///< Warning for VCP Lower Threshold 2 Measurement (VCP_LOW Signal from CP) Status
        constexpr uint32_t VSD_UPTH_ICLR = (1U << 20);  ///< Warning for VSD Upper Threshold Measurement (ADC2 channel 2) Interrupt Status
        constexpr uint32_t VSD_LOWTH_ICLR = (1U << 19);  ///< Warning for VSD Lower Threshold Measurement (ADC2 channel 2) Interrupt Status
        constexpr uint32_t VCP_UPTH_ICLR = (1U << 18);  ///< Warning for VCP Upper Threshold Measurement (ADC2 channel 3) Interrupt Status
        constexpr uint32_t VCP_LOWTH1_ICLR = (1U << 17);  ///< Warning for VCP Lower Threshold 1 Measurement (ADC2 channel 3) Interrupt Status
        constexpr uint32_t VCP_LOWTH2_ICLR = (1U << 16);  ///< Warning for VCP Lower Threshold 2 Measurement (VCP_LOW Signal from CP) Interrupt Status
        constexpr uint32_t HS2_OC_ICLR = (1U << 13);  ///< External High Side 2 FET Over-current Status
        constexpr uint32_t HS1_OC_ICLR = (1U << 12);  ///< External High 1 FET Over-current Status
        constexpr uint32_t LS2_OC_ICLR = (1U << 11);  ///< External Low Side 2 FET Over-current Status
        constexpr uint32_t LS1_OC_ICLR = (1U << 10);  ///< External Low Side 1 FET Over-current Status
        constexpr uint32_t HS2_DS_ICLR = (1U << 3);  ///< Bridge Driver High Side 2 Pre-Driver short Interrupt Status
        constexpr uint32_t HS1_DS_ICLR = (1U << 2);  ///< Bridge Driver High Side 1 Pre-Driver short Interrupt Status
        constexpr uint32_t LS2_DS_ICLR = (1U << 1);  ///< Bridge Driver Low Side 2 Pre-Driver short Interrupt Status
        constexpr uint32_t LS1_DS_ICLR = (1U << 0);  ///< Bridge Driver Low Side 1 Pre-Driver short Interrupt Status
    }

    /// BFSTS Register bits
    namespace bfsts_bits {
        constexpr uint32_t SBFSTS = (1U << 1);  ///< System Bus Fault Status Valid Flag
        constexpr uint32_t DBFSTS = (1U << 0);  ///< Data Bus Fault Status Valid Flag
    }

    /// BFSTS_CLR Register bits
    namespace bfsts_clr_bits {
        constexpr uint32_t SBFSTSCLR = (1U << 1);  ///< System Bus Fault Status Clear Flag
        constexpr uint32_t DBFSTSCLR = (1U << 0);  ///< Data Bus Fault Status Clear Flag
    }

    /// DBFA Register bits
    namespace dbfa_bits {
        constexpr uint32_t DBFA = (32 << 0);  ///< Data Bus Fault Address Register
    }

    /// PCU_CTRL_STS Register bits
    namespace pcu_ctrl_sts_bits {
        constexpr uint32_t CLKWDT_RES_SD_DIS = (1U << 26);  ///< Clock Watchdog Reset Disable
        constexpr uint32_t CLKLOSS_SD_DIS = (1U << 25);  ///< Power Switches Loss of Clock Shutdown Disable (AMCLK3)
        constexpr uint32_t SYS_OT_PS_DIS = (1U << 24);  ///< System Overtemperature Power Switches Shutdown Disable
        constexpr uint32_t SYS_VSD_OV_SLM_DIS = (1U << 14);  ///< VSD Overvoltage Shutdown for Peripherals Disable
        constexpr uint32_t LIN_VS_UV_SD_DIS = (1U << 8);  ///< LIN Module VS Undervoltage Transmitter Shutdown
        constexpr uint32_t FAIL_PS_DIS = (1U << 7);  ///< Disable LIN, BDRV and CP because of Overtemperature
        constexpr uint32_t CLKWDT_SD_DIS = (1U << 1);  ///< Power Modules Clock Watchdog Shutdown Disable
    }

    /// SBFA Register bits
    namespace sbfa_bits {
        constexpr uint32_t SBFA = (32 << 0);  ///< System Bus Fault Address Register
    }

    /// STCALIB Register bits
    namespace stcalib_bits {
        constexpr uint32_t STCALIB = (26 << 0);  ///< System Tick Calibration
    }

    /// SYS_IRQ_CTRL Register bits
    namespace sys_irq_ctrl_bits {
        constexpr uint32_t ADC4_EOC_IE = (1U << 23);  ///< ADC4 EOC Interrupt Enable
        constexpr uint32_t ADC3_EOC_IE = (1U << 22);  ///< ADC3 EOC Interrupt Enable
        constexpr uint32_t ADC2_ESM_IE = (1U << 15);  ///< ADC2 Exceptional Sequence Measurement Interrupt Enable
        constexpr uint32_t VREF5V_OVL_IE = (1U << 14);  ///< VREF5V Overload Interrupt Enable
        constexpr uint32_t VREF5V_UPTH_IE = (1U << 13);  ///< VREF5V ADC1 Reference Overvoltage (ADC2, Channel 4) Interrupt Enable
        constexpr uint32_t VREF5V_LOWTH_IE = (1U << 12);  ///< VREF5V ADC1 Reference Undervoltage (ADC2, Channel 4) Interrupt Enable
        constexpr uint32_t REFBG_UPTHWARN_IE = (1U << 11);  ///< Reference Voltage Overvoltage Interrupt Enable
        constexpr uint32_t REFBG_LOTHWARN_IE = (1U << 10);  ///< Reference Voltage Undervoltage Interrupt Enable
        constexpr uint32_t SYS_OT_IE = (1U << 9);  ///< System Overtemperature Shutdown Interrupt Enable (leads to shutdown of System)
        constexpr uint32_t SYS_OTWARN_IE = (1U << 8);  ///< System Overtemperature Warning Interrupt Enable
        constexpr uint32_t PMU_OT_IE = (1U << 7);  ///< PMU Regulator Overtemperature Shutdown Interrupt Enable (leads to shutdown of System)
        constexpr uint32_t PMU_OTWARN_IE = (1U << 6);  ///< PMU Regulator Overtemperature Warning Interrupt Enable
        constexpr uint32_t LIN_TMOUT_IE = (1U << 2);  ///< LIN TXD timeout Interrupt Enable
        constexpr uint32_t LIN_OT_IE = (1U << 1);  ///< LIN Overtemperature Interrupt Enable
        constexpr uint32_t LIN_OC_IE = (1U << 0);  ///< LIN Overcurrent Interrupt Enable
    }

    /// SYS_IS Register bits
    namespace sys_is_bits {
        constexpr uint32_t ADC4_EOC_IS = (1U << 23);  ///< ADC4 EOC Interrupt Status
        constexpr uint32_t ADC3_EOC_IS = (1U << 22);  ///< ADC3 EOC Interrupt Status
        constexpr uint32_t ADC2_ESM_IS = (1U << 15);  ///< ADC2 Exceptional Sequence Measurement Interrupt Status
        constexpr uint32_t VREF5V_OVL_IS = (1U << 14);  ///< VREF5V Overload Interrupt Status
        constexpr uint32_t VREF5V_UPTH_IS = (1U << 13);  ///< VREF5V ADC1 Reference Overvoltage (ADC2, Channel 4) Interrupt Status
        constexpr uint32_t VREF5V_LOWTH_IS = (1U << 12);  ///< VREF5V ADC1 Reference Undervoltage (ADC2, Channel 4) Interrupt Status
        constexpr uint32_t REFBG_UPTHWARN_IS = (1U << 11);  ///< 8 Bit ADC2 Reference Overvoltage (ADC2, Channel 5) interrupt status
        constexpr uint32_t REFBG_LOTHWARN_IS = (1U << 10);  ///< 8 Bit ADC2 Reference Undervoltage (ADC2, Channel 5) interrupt status
        constexpr uint32_t SYS_OT_IS = (1U << 9);  ///< System Overtemperature Shutdown (ADC2, Channel 8) interrupt status
        constexpr uint32_t SYS_OTWARN_IS = (1U << 8);  ///< System Overtemperature Prewarning (ADC2, Channel 8) interrupt status
        constexpr uint32_t PMU_OT_IS = (1U << 7);  ///< PMU Regulator Overtemperature Shutdown (ADC2, Channel 9) interrupt status
        constexpr uint32_t PMU_OTWARN_IS = (1U << 6);  ///< PMU Regulator Overtemperature Prewarning (ADC2, Channel 9) interrupt status
        constexpr uint32_t LIN_TMOUT_IS = (1U << 2);  ///< LIN TXD timeout
        constexpr uint32_t LIN_OT_IS = (1U << 1);  ///< LIN Overtemperature interrupt status
        constexpr uint32_t LIN_OC_IS = (1U << 0);  ///< LIN Overcurrent interrupt status
    }

    /// SYS_ISCLR Register bits
    namespace sys_isclr_bits {
        constexpr uint32_t ADC4_EOC_ICLR = (1U << 23);  ///< ADC4 EOC Interrupt Status
        constexpr uint32_t ADC3_EOC_ICLR = (1U << 22);  ///< ADC3 EOC Interrupt Status
        constexpr uint32_t ADC2_ESM_ICLR = (1U << 15);  ///< ADC2 Exceptional Sequence Measurement Interrupt Status
        constexpr uint32_t VREF5V_OVL_ICLR = (1U << 14);  ///< VREF5V Overload Interrupt Status
        constexpr uint32_t VREF5V_UPTH_ICLR = (1U << 13);  ///< VREF5V ADC1 Reference Overvoltage (ADC2, Channel 4) Interrupt Status
        constexpr uint32_t VREF5V_LOWTH_ICLR = (1U << 12);  ///< VREF5V ADC1 Reference Undervoltage (ADC2, Channel 4) Interrupt Status
        constexpr uint32_t REFBG_UPTHWARN_ICLR = (1U << 11);  ///< 8 Bit ADC2 Reference Overvoltage (ADC2, Channel 5) interrupt status
        constexpr uint32_t REFBG_LOTHWARN_ICLR = (1U << 10);  ///< 8 Bit ADC2 Reference Undervoltage (ADC2, Channel 5) interrupt status
        constexpr uint32_t SYS_OT_ICLR = (1U << 9);  ///< System Overtemperature Shutdown (ADC2, Channel 8) interrupt status
        constexpr uint32_t SYS_OTWARN_ICLR = (1U << 8);  ///< System Overtemperature Prewarning (ADC2, Channel 8) interrupt status
        constexpr uint32_t PMU_OT_ICLR = (1U << 7);  ///< PMU Regulator Overtemperature Shutdown (ADC2, Channel 9) interrupt status
        constexpr uint32_t PMU_OTWARN_ICLR = (1U << 6);  ///< PMU Regulator Overtemperature Prewarning (ADC2, Channel 9) interrupt status
        constexpr uint32_t LIN_TMOUT_ICLR = (1U << 2);  ///< LIN TXD timeout
        constexpr uint32_t LIN_OT_ICLR = (1U << 1);  ///< LIN Overtemperature interrupt status
        constexpr uint32_t LIN_OC_ICLR = (1U << 0);  ///< LIN Overcurrent interrupt status
    }

    /// SYS_SUPPLY_IRQ_CLR Register bits
    namespace sys_supply_irq_clr_bits {
        constexpr uint32_t VDD1V5_OV_SCLR = (1U << 23);  ///< VDDC Overvoltage Status
        constexpr uint32_t VDD5V_OV_SCLR = (1U << 22);  ///< VDDP Overvoltage Status
        constexpr uint32_t VS_OV_SCLR = (1U << 21);  ///< VS Overvoltage Interrupt Status
        constexpr uint32_t VBAT_OV_SCLR = (1U << 20);  ///< VBAT Overvoltage Status
        constexpr uint32_t VDD1V5_UV_SCLR = (1U << 19);  ///< VDDC Undervoltage Status
        constexpr uint32_t VDD5V_UV_SCLR = (1U << 18);  ///< VDDP Undervoltage Status
        constexpr uint32_t VS_UV_SCLR = (1U << 17);  ///< VS Undervoltage Status
        constexpr uint32_t VBAT_UV_SCLR = (1U << 16);  ///< VBAT Undervoltage Status
        constexpr uint32_t VDD1V5_OV_ICLR = (1U << 7);  ///< VDDC Overvoltage Interrupt Status (ADC2 channel 8)
        constexpr uint32_t VDD5V_OV_ICLR = (1U << 6);  ///< VDDP Overvoltage Interrupt Status (ADC2 channel 5)
        constexpr uint32_t VS_OV_ICLR = (1U << 5);  ///< VS Overvoltage Interrupt Status (ADC2 channel 1)
        constexpr uint32_t VBAT_OV_ICLR = (1U << 4);  ///< VBAT Overvoltage Interrupt Status (ADC2 channel 0)
        constexpr uint32_t VDD1V5_UV_ICLR = (1U << 3);  ///< VDDC Undervoltage Interrupt Status (ADC2 channel 8)
        constexpr uint32_t VDD5V_UV_ICLR = (1U << 2);  ///< VDDP Undervoltage Interrupt Status (ADC2 channel 5)
        constexpr uint32_t VS_UV_ICLR = (1U << 1);  ///< VS Undervoltage Interrupt Status (ADC2 channel 1)
        constexpr uint32_t VBAT_UV_ICLR = (1U << 0);  ///< VBAT Undervoltage Interrupt Status (ADC2 channel 0)
    }

    /// SYS_SUPPLY_IRQ_CTRL Register bits
    namespace sys_supply_irq_ctrl_bits {
        constexpr uint32_t VDD1V5_OV_IE = (1U << 7);  ///< VDD1V5 Overvoltage Interrupt Enable
        constexpr uint32_t VDD5V_OV_IE = (1U << 6);  ///< VDD5V Overvoltage Interrupt Enable
        constexpr uint32_t VS_OV_IE = (1U << 5);  ///< VS Overvoltage Interrupt Enable
        constexpr uint32_t VBAT_OV_IE = (1U << 4);  ///< VBAT Overvoltage Interrupt Enable
        constexpr uint32_t VDD1V5_UV_IE = (1U << 3);  ///< VDD1V5 Undervoltage Interrupt Enable
        constexpr uint32_t VDD5V_UV_IE = (1U << 2);  ///< VDD5V Undervoltage Interrupt Enable
        constexpr uint32_t VS_UV_IE = (1U << 1);  ///< VS Undervoltage Interrupt Enable
        constexpr uint32_t VBAT_UV_IE = (1U << 0);  ///< VBAT Undervoltage Interrupt Enable
    }

    /// SYS_SUPPLY_IRQ_STS Register bits
    namespace sys_supply_irq_sts_bits {
        constexpr uint32_t VDD1V5_OV_STS = (1U << 23);  ///< VDDC Overvoltage Status
        constexpr uint32_t VDD5V_OV_STS = (1U << 22);  ///< VDDP Overvoltage Status
        constexpr uint32_t VS_OV_STS = (1U << 21);  ///< VS Overvoltage Interrupt Status
        constexpr uint32_t VBAT_OV_STS = (1U << 20);  ///< VBAT Overvoltage Status
        constexpr uint32_t VDD1V5_UV_STS = (1U << 19);  ///< VDDC Undervoltage Status
        constexpr uint32_t VDD5V_UV_STS = (1U << 18);  ///< VDDP Undervoltage Status
        constexpr uint32_t VS_UV_STS = (1U << 17);  ///< VS Undervoltage Status
        constexpr uint32_t VBAT_UV_STS = (1U << 16);  ///< VBAT Undervoltage Status
        constexpr uint32_t VDD1V5_OV_IS = (1U << 7);  ///< VDDC Overvoltage Interrupt Status (ADC2 channel 8)
        constexpr uint32_t VDD5V_OV_IS = (1U << 6);  ///< VDDP Overvoltage Interrupt Status (ADC2 channel 5)
        constexpr uint32_t VS_OV_IS = (1U << 5);  ///< VS Overvoltage Interrupt Status (ADC2 channel 1)
        constexpr uint32_t VBAT_OV_IS = (1U << 4);  ///< VBAT Overvoltage Interrupt Status (ADC2 channel 0)
        constexpr uint32_t VDD1V5_UV_IS = (1U << 3);  ///< VDDC Undervoltage Interrupt Status (ADC2 channel 8)
        constexpr uint32_t VDD5V_UV_IS = (1U << 2);  ///< VDDP Undervoltage Interrupt Status (ADC2 channel 5)
        constexpr uint32_t VS_UV_IS = (1U << 1);  ///< VS Undervoltage Interrupt Status (ADC2 channel 1)
        constexpr uint32_t VBAT_UV_IS = (1U << 0);  ///< VBAT Undervoltage Interrupt Status (ADC2 channel 0)
    }

    /// WDT1_TRIG Register bits
    namespace wdt1_trig_bits {
        constexpr uint32_t SOWCONF = (2 << 6);  ///< Short Open Window Configuration
        constexpr uint32_t WDP_SEL = (6 << 0);  ///< Watchdog Period Selection and trigger
    }

}

// ============================================================================
// SSC1 Peripheral
// ============================================================================

namespace ssc1 {
    /// Base addresses
    constexpr uint32_t SSC1_BASE = 0x48024000;

    /// SSC1 Register structure
    struct Registers {
        volatile uint32_t BR;  ///< Offset: 0x10 - Baud Rate Timer Reload Register
        volatile uint32_t CON;  ///< Offset: 0x04 - Control Register
        volatile uint32_t ISRCLR;  ///< Offset: 0x14 - Interrupt Status Register Clear
        volatile uint32_t PISEL;  ///< Offset: 0x00 - Port Input Select Register, RESET_TYPE_3
        volatile uint32_t RB;  ///< Offset: 0x0C - Receiver Buffer Register
        volatile uint32_t TB;  ///< Offset: 0x08 - Transmitter Buffer Register
    };

    /// Peripheral instances
    inline Registers* SSC1 = reinterpret_cast<Registers*>(SSC1_BASE);

    // Bit definitions
    /// BR Register bits
    namespace br_bits {
        constexpr uint32_t BR_VALUE = (16 << 0);  ///< Baud Rate Timer/Reload Register Value
    }

    /// CON Register bits
    namespace con_bits {
        constexpr uint32_t BC = (4 << 0);  ///< Bit Count Field
        constexpr uint32_t TE = (1U << 8);  ///< Transmit Error Flag
        constexpr uint32_t RE = (1U << 9);  ///< Receive Error Flag
        constexpr uint32_t PE = (1U << 10);  ///< Phase Error Flag
        constexpr uint32_t BE = (1U << 11);  ///< Baud Rate Error Flag
        constexpr uint32_t BSY = (1U << 12);  ///< Busy Flag
        constexpr uint32_t MS = (1U << 14);  ///< Master Select Bit
        constexpr uint32_t EN = (1U << 15);  ///< Enable Bit = 1
    }

    /// ISRCLR Register bits
    namespace isrclr_bits {
        constexpr uint32_t TECLR = (1U << 8);  ///< Transmit Error Flag Clear
        constexpr uint32_t RECLR = (1U << 9);  ///< Receive Error Flag Clear
        constexpr uint32_t PECLR = (1U << 10);  ///< Phase Error Flag Clear
        constexpr uint32_t BECLR = (1U << 11);  ///< Baud Rate Error Flag Clear
    }

    /// PISEL Register bits
    namespace pisel_bits {
        constexpr uint32_t MIS_0 = (1U << 0);  ///< Master Mode Receiver Input Select: 0b0=see (SSC1)., 0b1=see (SSC1)., 0b0=Receiver input (Port A: P1.2) is selected (SSC2)., 0b1=Receiver input (Port B: P2.5) is selected (SSC2).,
        constexpr uint32_t SIS = (1U << 1);  ///< Slave Mode Receiver Input Select: 0b0=Receiver input (Port A: P0.2) is selected (SSC1)., 0b1=Receiver input (Port B: P0.2) is selected (SSC1)., 0b0=Receiver input (Port A: P1.1) is selected (SSC2)., 0b1=Receiver input (Port B: P1.1) is selected (SSC2).,
        constexpr uint32_t CIS = (1U << 2);  ///< Slave Mode Clock Input Select: 0b0=Clock input (Port A: P0.3) is selected (SSC1)., 0b1=Clock input (Port B: P0.3) is selected (SSC1)., 0b0=Clock input (Port A: P1.0) is selected (SSC2)., 0b1=Clock input (Port B: P1.0) is selected (SSC2).,
        constexpr uint32_t MIS_1 = (1U << 3);  ///< Master Mode Receiver Input Select: 0b0=see (SSC1)., 0b1=see (SSC1)., 0b0=n/a (SSC2)., 0b1=n/a (SSC2).,
    }

    /// RB Register bits
    namespace rb_bits {
        constexpr uint32_t RB_VALUE = (16 << 0);  ///< Receive Data Register Value
    }

    /// TB Register bits
    namespace tb_bits {
        constexpr uint32_t TB_VALUE = (16 << 0);  ///< Transmit Data Register Value
    }

}

// ============================================================================
// SSC2 Peripheral
// ============================================================================

namespace ssc2 {
    /// Base addresses
    constexpr uint32_t SSC2_BASE = 0x48026000;

    /// SSC2 Register structure
    struct Registers {
        volatile uint32_t BR;  ///< Offset: 0x10 - Baud Rate Timer Reload Register
        volatile uint32_t CON;  ///< Offset: 0x04 - Control Register
        volatile uint32_t ISRCLR;  ///< Offset: 0x14 - Interrupt Status Register Clear
        volatile uint32_t PISEL;  ///< Offset: 0x00 - Port Input Select Register, RESET_TYPE_3
        volatile uint32_t RB;  ///< Offset: 0x0C - Receiver Buffer Register
        volatile uint32_t TB;  ///< Offset: 0x08 - Transmitter Buffer Register
    };

    /// Peripheral instances
    inline Registers* SSC2 = reinterpret_cast<Registers*>(SSC2_BASE);

    // Bit definitions
    /// BR Register bits
    namespace br_bits {
        constexpr uint32_t BR_VALUE = (16 << 0);  ///< Baud Rate Timer/Reload Register Value
    }

    /// CON Register bits
    namespace con_bits {
        constexpr uint32_t BC = (4 << 0);  ///< Bit Count Field
        constexpr uint32_t TE = (1U << 8);  ///< Transmit Error Flag
        constexpr uint32_t RE = (1U << 9);  ///< Receive Error Flag
        constexpr uint32_t PE = (1U << 10);  ///< Phase Error Flag
        constexpr uint32_t BE = (1U << 11);  ///< Baud Rate Error Flag
        constexpr uint32_t BSY = (1U << 12);  ///< Busy Flag
        constexpr uint32_t MS = (1U << 14);  ///< Master Select Bit
        constexpr uint32_t EN = (1U << 15);  ///< Enable Bit = 1
    }

    /// ISRCLR Register bits
    namespace isrclr_bits {
        constexpr uint32_t TECLR = (1U << 8);  ///< Transmit Error Flag Clear
        constexpr uint32_t RECLR = (1U << 9);  ///< Receive Error Flag Clear
        constexpr uint32_t PECLR = (1U << 10);  ///< Phase Error Flag Clear
        constexpr uint32_t BECLR = (1U << 11);  ///< Baud Rate Error Flag Clear
    }

    /// PISEL Register bits
    namespace pisel_bits {
        constexpr uint32_t MIS_0 = (1U << 0);  ///< Master Mode Receiver Input Select: 0b0=see (SSC1)., 0b1=see (SSC1)., 0b0=Receiver input (Port A: P1.2) is selected (SSC2)., 0b1=Receiver input (Port B: P2.5) is selected (SSC2).,
        constexpr uint32_t SIS = (1U << 1);  ///< Slave Mode Receiver Input Select: 0b0=Receiver input (Port A: P0.2) is selected (SSC1)., 0b1=Receiver input (Port B: P0.2) is selected (SSC1)., 0b0=Receiver input (Port A: P1.1) is selected (SSC2)., 0b1=Receiver input (Port B: P1.1) is selected (SSC2).,
        constexpr uint32_t CIS = (1U << 2);  ///< Slave Mode Clock Input Select: 0b0=Clock input (Port A: P0.3) is selected (SSC1)., 0b1=Clock input (Port B: P0.3) is selected (SSC1)., 0b0=Clock input (Port A: P1.0) is selected (SSC2)., 0b1=Clock input (Port B: P1.0) is selected (SSC2).,
        constexpr uint32_t MIS_1 = (1U << 3);  ///< Master Mode Receiver Input Select: 0b0=see (SSC1)., 0b1=see (SSC1)., 0b0=n/a (SSC2)., 0b1=n/a (SSC2).,
    }

    /// RB Register bits
    namespace rb_bits {
        constexpr uint32_t RB_VALUE = (16 << 0);  ///< Receive Data Register Value
    }

    /// TB Register bits
    namespace tb_bits {
        constexpr uint32_t TB_VALUE = (16 << 0);  ///< Transmit Data Register Value
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER2_BASE = 0x48004000;
    constexpr uint32_t TIMER21_BASE = 0x48005000;
    constexpr uint32_t TIMER3_BASE = 0x48006000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t RC2H;  ///< Offset: 0x0C - Timer 2 Reload/Capture Register, High Byte
        volatile uint32_t RC2L;  ///< Offset: 0x08 - Timer 2 Reload/Capture Register, Low Byte
        volatile uint32_t T2CON;  ///< Offset: 0x00 - Timer 2 Control Register
        volatile uint32_t T2CON1;  ///< Offset: 0x18 - Timer 2 Control Register 1
        volatile uint32_t T2H;  ///< Offset: 0x14 - Timer 2, High Byte
        volatile uint32_t T2ICLR;  ///< Offset: 0x1C - Timer 2 Interrupt Clear Register
        volatile uint32_t T2L;  ///< Offset: 0x10 - Timer 2, Low Byte
        volatile uint32_t T2MOD;  ///< Offset: 0x04 - Timer 2 Mode Register
    };

    /// Peripheral instances
    inline Registers* TIMER2 = reinterpret_cast<Registers*>(TIMER2_BASE);
    inline Registers* TIMER21 = reinterpret_cast<Registers*>(TIMER21_BASE);
    inline Registers* TIMER3 = reinterpret_cast<Registers*>(TIMER3_BASE);

    // Bit definitions
    /// RC2H Register bits
    namespace rc2h_bits {
        constexpr uint32_t RC2 = (8 << 0);  ///< Reload/Capture Value
    }

    /// RC2L Register bits
    namespace rc2l_bits {
        constexpr uint32_t RC2 = (8 << 0);  ///< Reload/Capture Value
    }

    /// T2CON Register bits
    namespace t2con_bits {
        constexpr uint32_t CP_RL2 = (1U << 0);  ///< Capture/Reload Select
        constexpr uint32_t C_T2 = (1U << 1);  ///< Timer or Counter Select
        constexpr uint32_t TR2 = (1U << 2);  ///< Timer 2 Start/Stop Control
        constexpr uint32_t EXEN2 = (1U << 3);  ///< Timer 2 External Enable Control
        constexpr uint32_t EXF2 = (1U << 6);  ///< Timer 2 External Flag
        constexpr uint32_t TF2 = (1U << 7);  ///< Timer 2 Overflow/Underflow Flag
    }

    /// T2CON1 Register bits
    namespace t2con1_bits {
        constexpr uint32_t EXF2EN = (1U << 0);  ///< External Interrupt Enable
        constexpr uint32_t TF2EN = (1U << 1);  ///< Overflow/Underflow Interrupt Enable
    }

    /// T2H Register bits
    namespace t2h_bits {
        constexpr uint32_t T2H = (8 << 0);  ///< Timer 2 Value
    }

    /// T2ICLR Register bits
    namespace t2iclr_bits {
        constexpr uint32_t EXF2CLR = (1U << 6);  ///< External Interrupt Clear Flag
        constexpr uint32_t TF2CLR = (1U << 7);  ///< Overflow/Underflow Interrupt Clear Flag
    }

    /// T2L Register bits
    namespace t2l_bits {
        constexpr uint32_t T2L = (8 << 0);  ///< Timer 2 Value
    }

    /// T2MOD Register bits
    namespace t2mod_bits {
        constexpr uint32_t DCEN = (1U << 0);  ///< Up/Down Counter Enable
        constexpr uint32_t T2PRE = (3 << 1);  ///< Timer 2 Prescaler Bit
        constexpr uint32_t PREN = (1U << 4);  ///< Prescaler Enable
        constexpr uint32_t EDGESEL = (1U << 5);  ///< Edge Select in Capture Mode/Reload Mode
        constexpr uint32_t T2RHEN = (1U << 6);  ///< Timer 2 External Start Enable
        constexpr uint32_t T2REGS = (1U << 7);  ///< Edge Select for Timer 2 External Start
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART1_BASE = 0x48020000;
    constexpr uint32_t UART2_BASE = 0x48022000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t SBUF;  ///< Offset: 0x04 - Serial Data Buffer
        volatile uint32_t SCON;  ///< Offset: 0x00 - Serial Channel Control Register
        volatile uint32_t SCONCLR;  ///< Offset: 0x08 - Serial Channel Control Clear Register
    };

    /// Peripheral instances
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);

    // Bit definitions
    /// SBUF Register bits
    namespace sbuf_bits {
        constexpr uint32_t VAL = (8 << 0);  ///< Serial Interface Buffer Register
    }

    /// SCON Register bits
    namespace scon_bits {
        constexpr uint32_t RI = (1U << 0);  ///< Receive Interrupt Flag
        constexpr uint32_t TI = (1U << 1);  ///< Transmit Interrupt Flag
        constexpr uint32_t RB8 = (1U << 2);  ///< Serial Port Receiver Bit 9
        constexpr uint32_t TB8 = (1U << 3);  ///< Serial Port Transmitter Bit 9
        constexpr uint32_t REN = (1U << 4);  ///< Enable Receiver of Serial Port
        constexpr uint32_t SM2 = (1U << 5);  ///< Enable Serial Port Multiprocessor Communication in Modes 2 and 3
        constexpr uint32_t SM1_SM0 = (2 << 6);  ///< Serial Port Operating Mode Selection
    }

    /// SCONCLR Register bits
    namespace sconclr_bits {
        constexpr uint32_t RICLR = (1U << 0);  ///< Receive Interrupt Clear Flag
        constexpr uint32_t TICLR = (1U << 1);  ///< Transmit Interrupt Clear Flag
    }

}


} // namespace alloy::generated::tle9868

#endif // ALLOY_GENERATED_TLE9868_PERIPHERALS_HPP