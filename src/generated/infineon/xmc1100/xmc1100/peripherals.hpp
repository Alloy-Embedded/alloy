/// Auto-generated code for XMC1100
/// Generated by Alloy Code Generator
/// Source: infineon_xmc1100.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:46
#ifndef ALLOY_GENERATED_XMC1100_PERIPHERALS_HPP
#define ALLOY_GENERATED_XMC1100_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::xmc1100 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_ppb = true;
    constexpr uint32_t num_ppb_instances = 1;
    constexpr bool has_eru0 = true;
    constexpr uint32_t num_eru0_instances = 1;
    constexpr bool has_pau = true;
    constexpr uint32_t num_pau_instances = 1;
    constexpr bool has_nvm = true;
    constexpr uint32_t num_nvm_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_usic0 = true;
    constexpr uint32_t num_usic0_instances = 3;
    constexpr bool has_scu = true;
    constexpr uint32_t num_scu_instances = 5;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_ccu40 = true;
    constexpr uint32_t num_ccu40_instances = 5;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_shs0 = true;
    constexpr uint32_t num_shs0_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 3;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct ppb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eru0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pau_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usic0_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct scu_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccu40_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct shs0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 3;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 3;
    constexpr uint32_t max_gpio_pins = 48;  // 16 pins per port

    // USART-specific traits
}

// ============================================================================
// PPB Peripheral
// ============================================================================

namespace ppb {
    /// Base addresses
    constexpr uint32_t PPB_BASE = 0xE000E000;

    /// PPB Register structure
    struct Registers {
        volatile uint32_t SYST_CSR;  ///< Offset: 0x10 - SysTick Control and Status Register
        volatile uint32_t SYST_RVR;  ///< Offset: 0x14 - SysTick Reload Value Register
        volatile uint32_t SYST_CVR;  ///< Offset: 0x18 - SysTick Current Value Register
        volatile uint32_t SYST_CALIB;  ///< Offset: 0x1C - SysTick Calibration Value Register
        volatile uint32_t NVIC_ISER;  ///< Offset: 0x100 - Interrupt Set-enable Register
        volatile uint32_t NVIC_ICER;  ///< Offset: 0x180 - IInterrupt Clear-enable Register
        volatile uint32_t NVIC_ISPR;  ///< Offset: 0x200 - Interrupt Set-pending Register
        volatile uint32_t NVIC_ICPR;  ///< Offset: 0x280 - Interrupt Clear-pending Register
        volatile uint32_t NVIC_IPR0;  ///< Offset: 0x400 - Interrupt Priority Register 0
        volatile uint32_t NVIC_IPR1;  ///< Offset: 0x404 - Interrupt Priority Register 1
        volatile uint32_t NVIC_IPR2;  ///< Offset: 0x408 - Interrupt Priority Register 2
        volatile uint32_t NVIC_IPR3;  ///< Offset: 0x40C - Interrupt Priority Register 3
        volatile uint32_t NVIC_IPR4;  ///< Offset: 0x410 - Interrupt Priority Register 4
        volatile uint32_t NVIC_IPR5;  ///< Offset: 0x414 - Interrupt Priority Register 5
        volatile uint32_t NVIC_IPR6;  ///< Offset: 0x418 - Interrupt Priority Register 6
        volatile uint32_t NVIC_IPR7;  ///< Offset: 0x41C - Interrupt Priority Register 7
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control and State Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt and Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration and Control Register
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
    };

    /// Peripheral instances
    inline Registers* PPB = reinterpret_cast<Registers*>(PPB_BASE);

    // Bit definitions
    /// SYST_CSR Register bits
    namespace syst_csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Counter Enable
        constexpr uint32_t TICKINT = (1U << 1);  ///< SysTick Exception Request
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< Clock Source
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< Counter Flag
    }

    /// SYST_RVR Register bits
    namespace syst_rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Reload Value
    }

    /// SYST_CVR Register bits
    namespace syst_cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< SysTick Counter Current Value
    }

    /// SYST_CALIB Register bits
    namespace syst_calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< 10 Milliseconds
        constexpr uint32_t SKEW = (1U << 30);  ///< Clock Skew
        constexpr uint32_t NOREF = (1U << 31);  ///< Reference Clock
    }

    /// NVIC_ISER Register bits
    namespace nvic_iser_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt Node Set-enable
    }

    /// NVIC_ICER Register bits
    namespace nvic_icer_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt Node Clear-enable
    }

    /// NVIC_ISPR Register bits
    namespace nvic_ispr_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt Node Set-pending
    }

    /// NVIC_ICPR Register bits
    namespace nvic_icpr_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt Node Clear-pending
    }

    /// NVIC_IPR0 Register bits
    namespace nvic_ipr0_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR1 Register bits
    namespace nvic_ipr1_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR2 Register bits
    namespace nvic_ipr2_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR3 Register bits
    namespace nvic_ipr3_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR4 Register bits
    namespace nvic_ipr4_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR5 Register bits
    namespace nvic_ipr5_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR6 Register bits
    namespace nvic_ipr6_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR7 Register bits
    namespace nvic_ipr7_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t Revision = (4 << 0);  ///< Revision Number
        constexpr uint32_t PartNo = (12 << 4);  ///< Part Number of the Processor
        constexpr uint32_t Architecture = (4 << 16);  ///< Architecture
        constexpr uint32_t Variant = (4 << 20);  ///< Variant Number
        constexpr uint32_t Implementer = (8 << 24);  ///< Implementer Code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (6 << 0);  ///< Active Exception Number
        constexpr uint32_t VECTPENDING = (6 << 12);  ///< Pending Exception Number
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt Pending Flag
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick Exception Clear-pending
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick Exception Set-pending
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV Clear Pending
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV Set Pending
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< System Reset Request
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< Data Endianness
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Register Key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< Sleep-on-exit
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< Low Power Sleep Mode
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< Send Event on Pending bit
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Unaligned Access Traps
        constexpr uint32_t STKALIGN = (1U << 9);  ///< Stack Alignment
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of System Handler 11
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of System Handler 14
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of System Handler 15
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVCall Pending bit
    }

}

// ============================================================================
// ERU0 Peripheral
// ============================================================================

namespace eru0 {
    /// Base addresses
    constexpr uint32_t ERU0_BASE = 0x40010600;

    /// ERU0 Register structure
    struct Registers {
        volatile uint32_t EXISEL;  ///< Offset: 0x00 - Event Input Select
        volatile uint32_t EXICON[%s];  ///< Offset: 0x10 - Event Input Control
        volatile uint32_t EXOCON[%s];  ///< Offset: 0x20 - Event Output Trigger Control
    };

    /// Peripheral instances
    inline Registers* ERU0 = reinterpret_cast<Registers*>(ERU0_BASE);

    // Bit definitions
    /// EXISEL Register bits
    namespace exisel_bits {
        constexpr uint32_t EXS0A = (2 << 0);  ///< Event Source Select for A0 (ERS0)
        constexpr uint32_t EXS0B = (2 << 2);  ///< Event Source Select for B0 (ERS0)
        constexpr uint32_t EXS1A = (2 << 4);  ///< Event Source Select for A1 (ERS1)
        constexpr uint32_t EXS1B = (2 << 6);  ///< Event Source Select for B1 (ERS1)
        constexpr uint32_t EXS2A = (2 << 8);  ///< Event Source Select for A2 (ERS2)
        constexpr uint32_t EXS2B = (2 << 10);  ///< Event Source Select for B2 (ERS2)
        constexpr uint32_t EXS3A = (2 << 12);  ///< Event Source Select for A3 (ERS3)
        constexpr uint32_t EXS3B = (2 << 14);  ///< Event Source Select for B3 (ERS3)
    }

    /// EXICON[%s] Register bits
    namespace exicon[%s]_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Output Trigger Pulse Enable for ETLx
        constexpr uint32_t LD = (1U << 1);  ///< Rebuild Level Detection for Status Flag for ETLx
        constexpr uint32_t RE = (1U << 2);  ///< Rising Edge Detection Enable ETLx
        constexpr uint32_t FE = (1U << 3);  ///< Falling Edge Detection Enable ETLx
        constexpr uint32_t OCS = (3 << 4);  ///< Output Channel Select for ETLx Output Trigger Pulse
        constexpr uint32_t FL = (1U << 7);  ///< Status Flag for ETLx
        constexpr uint32_t SS = (2 << 8);  ///< Input Source Select for ERSx
        constexpr uint32_t NA = (1U << 10);  ///< Input A Negation Select for ERSx
        constexpr uint32_t NB = (1U << 11);  ///< Input B Negation Select for ERSx
    }

    /// EXOCON[%s] Register bits
    namespace exocon[%s]_bits {
        constexpr uint32_t ISS = (2 << 0);  ///< Internal Trigger Source Selection
        constexpr uint32_t GEEN = (1U << 2);  ///< Gating Event Enable
        constexpr uint32_t PDR = (1U << 3);  ///< Pattern Detection Result Flag
        constexpr uint32_t GP = (2 << 4);  ///< Gating Selection for Pattern Detection Result
        constexpr uint32_t IPEN0 = (1U << 12);  ///< Pattern Detection Enable for ETL0
        constexpr uint32_t IPEN1 = (1U << 13);  ///< Pattern Detection Enable for ETL1
        constexpr uint32_t IPEN2 = (1U << 14);  ///< Pattern Detection Enable for ETL2
        constexpr uint32_t IPEN3 = (1U << 15);  ///< Pattern Detection Enable for ETL3
    }

}

// ============================================================================
// PAU Peripheral
// ============================================================================

namespace pau {
    /// Base addresses
    constexpr uint32_t PAU_BASE = 0x40000000;

    /// PAU Register structure
    struct Registers {
        volatile uint32_t AVAIL0;  ///< Offset: 0x40 - Peripheral Availability Register 0
        volatile uint32_t AVAIL1;  ///< Offset: 0x44 - Peripheral Availability Register 1
        volatile uint32_t AVAIL2;  ///< Offset: 0x48 - Peripheral Availability Register 2
        volatile uint32_t PRIVDIS0;  ///< Offset: 0x80 - Peripheral Privilege Access Register 0
        volatile uint32_t PRIVDIS1;  ///< Offset: 0x84 - Peripheral Privilege Access Register 1
        volatile uint32_t ROMSIZE;  ///< Offset: 0x400 - ROM Size Register
        volatile uint32_t FLSIZE;  ///< Offset: 0x404 - Flash Size Register
        volatile uint32_t RAM0SIZE;  ///< Offset: 0x410 - RAM0 Size Register
    };

    /// Peripheral instances
    inline Registers* PAU = reinterpret_cast<Registers*>(PAU_BASE);

    // Bit definitions
    /// AVAIL0 Register bits
    namespace avail0_bits {
        constexpr uint32_t AVAIL5 = (1U << 5);  ///< RAM Block 1 Availability Flag
        constexpr uint32_t AVAIL6 = (1U << 6);  ///< RAM Block 2 Availability Flag
        constexpr uint32_t AVAIL7 = (1U << 7);  ///< RAM Block 3 Availability Flag
        constexpr uint32_t AVAIL22 = (1U << 22);  ///< Port 0 Availability Flag
        constexpr uint32_t AVAIL23 = (1U << 23);  ///< Port 1 Availability Flag
        constexpr uint32_t AVAIL24 = (1U << 24);  ///< Port 0 Availability Flag
    }

    /// AVAIL1 Register bits
    namespace avail1_bits {
        constexpr uint32_t AVAIL0 = (1U << 0);  ///< USIC0 Channel 0 Availability Flag
        constexpr uint32_t AVAIL1 = (1U << 1);  ///< USIC0 Channel 1 Availability Flag
        constexpr uint32_t AVAIL4 = (1U << 4);  ///< PRNG Availability Flag
        constexpr uint32_t AVAIL5 = (1U << 5);  ///< VADC0 Basic SFRs Availability Flag
        constexpr uint32_t AVAIL8 = (1U << 8);  ///< SHS0 Availability Flag
        constexpr uint32_t AVAIL9 = (1U << 9);  ///< CC40 Availability Flag
        constexpr uint32_t AVAIL10 = (1U << 10);  ///< CC41 Availability Flag
        constexpr uint32_t AVAIL11 = (1U << 11);  ///< CC42 Availability Flag
        constexpr uint32_t AVAIL12 = (1U << 12);  ///< CC43 Availability Flag
    }

    /// PRIVDIS0 Register bits
    namespace privdis0_bits {
        constexpr uint32_t PDIS2 = (1U << 2);  ///< Flash SFRs Privilege Disable Flag
        constexpr uint32_t PDIS5 = (1U << 5);  ///< RAM Block 1 Privilege Disable Flag
        constexpr uint32_t PDIS6 = (1U << 6);  ///< RAM Block 2 Privilege Disable Flag
        constexpr uint32_t PDIS7 = (1U << 7);  ///< RAM Block 3 Privilege Disable Flag
        constexpr uint32_t PDIS19 = (1U << 19);  ///< WDT Privilege Disable Flag
        constexpr uint32_t PDIS22 = (1U << 22);  ///< Port 0 Privilege Disable Flag
        constexpr uint32_t PDIS23 = (1U << 23);  ///< Port 1 Privilege Disable Flag
        constexpr uint32_t PDIS24 = (1U << 24);  ///< Port 2 Privilege Disable Flag
    }

    /// PRIVDIS1 Register bits
    namespace privdis1_bits {
        constexpr uint32_t PDIS0 = (1U << 0);  ///< USIC0 Channel 0 Privilege Disable Flag
        constexpr uint32_t PDIS1 = (1U << 1);  ///< USIC0 Channel 1 Privilege Disable Flag
        constexpr uint32_t PDIS5 = (1U << 5);  ///< VADC0 Basic SFRs Privilege Disable Flag
        constexpr uint32_t PDIS8 = (1U << 8);  ///< SHS0 Privilege Disable Flag
        constexpr uint32_t PDIS9 = (1U << 9);  ///< CC40 and CCU40 Kernel SFRs Privilege Disable Flag
        constexpr uint32_t PDIS10 = (1U << 10);  ///< CC41 Privilege Disable Flag
        constexpr uint32_t PDIS11 = (1U << 11);  ///< CC42 Privilege Disable Flag
        constexpr uint32_t PDIS12 = (1U << 12);  ///< CC43 Privilege Disable Flag
    }

    /// ROMSIZE Register bits
    namespace romsize_bits {
        constexpr uint32_t ADDR = (6 << 8);  ///< ROM Size
    }

    /// FLSIZE Register bits
    namespace flsize_bits {
        constexpr uint32_t ADDR = (6 << 12);  ///< Flash Size
    }

    /// RAM0SIZE Register bits
    namespace ram0size_bits {
        constexpr uint32_t ADDR = (5 << 8);  ///< RAM0 Size
    }

}

// ============================================================================
// NVM Peripheral
// ============================================================================

namespace nvm {
    /// Base addresses
    constexpr uint32_t NVM_BASE = 0x40050000;

    /// NVM Register structure
    struct Registers {
        volatile uint32_t NVMSTATUS;  ///< Offset: 0x00 - NVM Status Register
        volatile uint32_t NVMPROG;  ///< Offset: 0x04 - NVM Programming Control Register
        volatile uint32_t NVMCONF;  ///< Offset: 0x08 - NVM Configuration Register
        volatile uint32_t CONFIG1;  ///< Offset: 0x48 - Configuration 1 Register
    };

    /// Peripheral instances
    inline Registers* NVM = reinterpret_cast<Registers*>(NVM_BASE);

    // Bit definitions
    /// NVMSTATUS Register bits
    namespace nvmstatus_bits {
        constexpr uint32_t WRPERR = (1U << 6);  ///< Write Protocol Error
        constexpr uint32_t ECC2READ = (1U << 5);  ///< ECC2 Read
        constexpr uint32_t ECC1READ = (1U << 4);  ///< ECC1 Read
        constexpr uint32_t VERR = (2 << 2);  ///< Verify Error
        constexpr uint32_t SLEEP = (1U << 1);  ///< Sleep Mode
        constexpr uint32_t BUSY = (1U << 0);  ///< Busy
    }

    /// NVMPROG Register bits
    namespace nvmprog_bits {
        constexpr uint32_t RSTECC = (1U << 13);  ///< Reset ECC
        constexpr uint32_t RSTVERR = (1U << 12);  ///< Reset Verify Error
        constexpr uint32_t ACTION = (8 << 0);  ///< ACTION: [VERIFY, ONE_SHOT, OPTYPE]
    }

    /// NVMCONF Register bits
    namespace nvmconf_bits {
        constexpr uint32_t NVM_ON = (1U << 15);  ///< NVM On
        constexpr uint32_t INT_ON = (1U << 14);  ///< Interrupt On
        constexpr uint32_t WS = (1U << 12);  ///< Number of fixed Wait States
        constexpr uint32_t SECPROT = (8 << 4);  ///< Sector Protection
        constexpr uint32_t HRLEV = (2 << 1);  ///< Hardread Level
    }

    /// CONFIG1 Register bits
    namespace config1_bits {
        constexpr uint32_t FIXWS = (1U << 11);  ///< Wait States Scheme
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40020000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - WDT Module ID Register
        volatile uint32_t CTR;  ///< Offset: 0x04 - WDT Control Register
        volatile uint32_t SRV;  ///< Offset: 0x08 - WDT Service Register
        volatile uint32_t TIM;  ///< Offset: 0x0C - WDT Timer Register
        volatile uint32_t WLB;  ///< Offset: 0x10 - WDT Window Lower Bound Register
        volatile uint32_t WUB;  ///< Offset: 0x14 - WDT Window Upper Bound Register
        volatile uint32_t WDTSTS;  ///< Offset: 0x18 - WDT Status Register
        volatile uint32_t WDTCLR;  ///< Offset: 0x1C - WDT Clear Register
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t ENB = (1U << 0);  ///< Enable
        constexpr uint32_t PRE = (1U << 1);  ///< Pre-warning
        constexpr uint32_t DSP = (1U << 4);  ///< Debug Suspend
        constexpr uint32_t SPW = (8 << 8);  ///< Service Indication Pulse Width
    }

    /// SRV Register bits
    namespace srv_bits {
        constexpr uint32_t SRV = (32 << 0);  ///< Service
    }

    /// TIM Register bits
    namespace tim_bits {
        constexpr uint32_t TIM = (32 << 0);  ///< Timer Value
    }

    /// WLB Register bits
    namespace wlb_bits {
        constexpr uint32_t WLB = (32 << 0);  ///< Window Lower Bound
    }

    /// WUB Register bits
    namespace wub_bits {
        constexpr uint32_t WUB = (32 << 0);  ///< Window Upper Bound
    }

    /// WDTSTS Register bits
    namespace wdtsts_bits {
        constexpr uint32_t ALMS = (1U << 0);  ///< Pre-warning Alarm
    }

    /// WDTCLR Register bits
    namespace wdtclr_bits {
        constexpr uint32_t ALMC = (1U << 0);  ///< Pre-warning Alarm
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40010A00;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - RTC Module ID Register
        volatile uint32_t CTR;  ///< Offset: 0x04 - RTC Control Register
        volatile uint32_t RAWSTAT;  ///< Offset: 0x08 - RTC Raw Service Request Register
        volatile uint32_t STSSR;  ///< Offset: 0x0C - RTC Service Request Status Register
        volatile uint32_t MSKSR;  ///< Offset: 0x10 - RTC Service Request Mask Register
        volatile uint32_t CLRSR;  ///< Offset: 0x14 - RTC Clear Service Request Register
        volatile uint32_t ATIM0;  ///< Offset: 0x18 - RTC Alarm Time Register 0
        volatile uint32_t ATIM1;  ///< Offset: 0x1C - RTC Alarm Time Register 1
        volatile uint32_t TIM0;  ///< Offset: 0x20 - RTC Time Register 0
        volatile uint32_t TIM1;  ///< Offset: 0x24 - RTC Time Register 1
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t ENB = (1U << 0);  ///< RTC Module Enable
        constexpr uint32_t SUS = (1U << 1);  ///< Debug Suspend Control
        constexpr uint32_t DIV = (16 << 16);  ///< Divider Value
    }

    /// RAWSTAT Register bits
    namespace rawstat_bits {
        constexpr uint32_t RPSE = (1U << 0);  ///< Raw Periodic Seconds Service Request
        constexpr uint32_t RPMI = (1U << 1);  ///< Raw Periodic Minutes Service Request
        constexpr uint32_t RPHO = (1U << 2);  ///< Raw Periodic Hours Service Request
        constexpr uint32_t RPDA = (1U << 3);  ///< Raw Periodic Days Service Request
        constexpr uint32_t RPMO = (1U << 5);  ///< Raw Periodic Months Service Request
        constexpr uint32_t RPYE = (1U << 6);  ///< Raw Periodic Years Service Request
        constexpr uint32_t RAI = (1U << 8);  ///< Alarm Service Request
    }

    /// STSSR Register bits
    namespace stssr_bits {
        constexpr uint32_t SPSE = (1U << 0);  ///< Periodic Seconds Service Request Status after masking
        constexpr uint32_t SPMI = (1U << 1);  ///< Periodic Minutes Service Request Status after masking
        constexpr uint32_t SPHO = (1U << 2);  ///< Periodic Hours Service Request Status after masking
        constexpr uint32_t SPDA = (1U << 3);  ///< Periodic Days Service Request Status after masking
        constexpr uint32_t SPMO = (1U << 5);  ///< Periodic Months Service Request Status after masking
        constexpr uint32_t SPYE = (1U << 6);  ///< Periodic Years Service Request Status after masking
        constexpr uint32_t SAI = (1U << 8);  ///< Alarm Service Request Status after masking
    }

    /// MSKSR Register bits
    namespace msksr_bits {
        constexpr uint32_t MPSE = (1U << 0);  ///< Periodic Seconds Interrupt Mask
        constexpr uint32_t MPMI = (1U << 1);  ///< Periodic Minutes Interrupt Mask
        constexpr uint32_t MPHO = (1U << 2);  ///< Periodic Hours Interrupt Mask
        constexpr uint32_t MPDA = (1U << 3);  ///< Periodic Days Interrupt Mask
        constexpr uint32_t MPMO = (1U << 5);  ///< Periodic Months Interrupt Mask
        constexpr uint32_t MPYE = (1U << 6);  ///< Periodic Years Interrupt Mask
        constexpr uint32_t MAI = (1U << 8);  ///< Alarm Interrupt Mask
    }

    /// CLRSR Register bits
    namespace clrsr_bits {
        constexpr uint32_t RPSE = (1U << 0);  ///< Raw Periodic Seconds Interrupt Clear
        constexpr uint32_t RPMI = (1U << 1);  ///< Raw Periodic Minutes Interrupt Clear
        constexpr uint32_t RPHO = (1U << 2);  ///< Raw Periodic Hours Interrupt Clear
        constexpr uint32_t RPDA = (1U << 3);  ///< Raw Periodic Days Interrupt Clear
        constexpr uint32_t RPMO = (1U << 5);  ///< Raw Periodic Months Interrupt Clear
        constexpr uint32_t RPYE = (1U << 6);  ///< Raw Periodic Years Interrupt Clear
        constexpr uint32_t RAI = (1U << 8);  ///< Raw Alarm Interrupt Clear
    }

    /// ATIM0 Register bits
    namespace atim0_bits {
        constexpr uint32_t ASE = (6 << 0);  ///< Alarm Seconds Compare Value
        constexpr uint32_t AMI = (6 << 8);  ///< Alarm Minutes Compare Value
        constexpr uint32_t AHO = (5 << 16);  ///< Alarm Hours Compare Value
        constexpr uint32_t ADA = (5 << 24);  ///< Alarm Days Compare Value
    }

    /// ATIM1 Register bits
    namespace atim1_bits {
        constexpr uint32_t AMO = (4 << 8);  ///< Alarm Month Compare Value
        constexpr uint32_t AYE = (16 << 16);  ///< Alarm Year Compare Value
    }

    /// TIM0 Register bits
    namespace tim0_bits {
        constexpr uint32_t SE = (6 << 0);  ///< Seconds Time Value
        constexpr uint32_t MI = (6 << 8);  ///< Minutes Time Value
        constexpr uint32_t HO = (5 << 16);  ///< Hours Time Value
        constexpr uint32_t DA = (5 << 24);  ///< Days Time Value
    }

    /// TIM1 Register bits
    namespace tim1_bits {
        constexpr uint32_t DAWE = (3 << 0);  ///< Days of Week Time Value
        constexpr uint32_t MO = (4 << 8);  ///< Month Time Value
        constexpr uint32_t YE = (16 << 16);  ///< Year Time Value
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t PRNG_BASE = 0x48020000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t WORD;  ///< Offset: 0x00 - PRNG Word Register
        volatile uint32_t CHK;  ///< Offset: 0x04 - PRNG Status Check Register
        volatile uint32_t CTRL;  ///< Offset: 0x0C - PRNG Control Register
    };

    /// Peripheral instances
    inline Registers* PRNG = reinterpret_cast<Registers*>(PRNG_BASE);

    // Bit definitions
    /// WORD Register bits
    namespace word_bits {
        constexpr uint32_t RDATA = (16 << 0);  ///< Random Data
    }

    /// CHK Register bits
    namespace chk_bits {
        constexpr uint32_t RDV = (1U << 0);  ///< Random Data / Key Valid Flag
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t KLD = (1U << 3);  ///< Key Load Operation Mode
        constexpr uint32_t RDBS = (2 << 1);  ///< Random Data Block Size
    }

}

// ============================================================================
// USIC0 Peripheral
// ============================================================================

namespace usic0 {
    /// Base addresses
    constexpr uint32_t USIC0_BASE = 0x48000008;
    constexpr uint32_t USIC0_CH0_BASE = 0x48000000;
    constexpr uint32_t USIC0_CH1_BASE = 0x48000200;

    /// USIC0 Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - Module Identification Register
    };

    /// Peripheral instances
    inline Registers* USIC0 = reinterpret_cast<Registers*>(USIC0_BASE);
    inline Registers* USIC0_CH0 = reinterpret_cast<Registers*>(USIC0_CH0_BASE);
    inline Registers* USIC0_CH1 = reinterpret_cast<Registers*>(USIC0_CH1_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

}

// ============================================================================
// SCU Peripheral
// ============================================================================

namespace scu {
    /// Base addresses
    constexpr uint32_t SCU_GENERAL_BASE = 0x40010000;
    constexpr uint32_t SCU_INTERRUPT_BASE = 0x40010038;
    constexpr uint32_t SCU_CLK_BASE = 0x40010300;
    constexpr uint32_t SCU_RESET_BASE = 0x40010400;
    constexpr uint32_t SCU_ANALOG_BASE = 0x40011000;

    /// SCU Register structure
    struct Registers {
        volatile uint32_t DBGROMID;  ///< Offset: 0x00 - Debug System ROM ID Register
        volatile uint32_t IDCHIP;  ///< Offset: 0x04 - Chip ID Register
        volatile uint32_t ID;  ///< Offset: 0x08 - SCU Module ID Register
        volatile uint32_t SSW0;  ///< Offset: 0x14 - SSW Register 0
        volatile uint32_t PASSWD;  ///< Offset: 0x24 - Password Register
        volatile uint32_t CCUCON;  ///< Offset: 0x30 - CCU Control Register
        volatile uint32_t MIRRSTS;  ///< Offset: 0x48 - Mirror Update Status Register
        volatile uint32_t PMTSR;  ///< Offset: 0x54 - Parity Memory Test Select Register
    };

    /// Peripheral instances
    inline Registers* SCU_GENERAL = reinterpret_cast<Registers*>(SCU_GENERAL_BASE);
    inline Registers* SCU_INTERRUPT = reinterpret_cast<Registers*>(SCU_INTERRUPT_BASE);
    inline Registers* SCU_CLK = reinterpret_cast<Registers*>(SCU_CLK_BASE);
    inline Registers* SCU_RESET = reinterpret_cast<Registers*>(SCU_RESET_BASE);
    inline Registers* SCU_ANALOG = reinterpret_cast<Registers*>(SCU_ANALOG_BASE);

    // Bit definitions
    /// DBGROMID Register bits
    namespace dbgromid_bits {
        constexpr uint32_t MANUFID = (11 << 1);  ///< Manufactory Identity
        constexpr uint32_t PARTNO = (16 << 12);  ///< Part Number
        constexpr uint32_t VERSION = (4 << 28);  ///< Product version
    }

    /// IDCHIP Register bits
    namespace idchip_bits {
        constexpr uint32_t IDCHIP = (32 << 0);  ///< CHIP ID
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// SSW0 Register bits
    namespace ssw0_bits {
        constexpr uint32_t DAT = (32 << 0);  ///< SSW Data
    }

    /// PASSWD Register bits
    namespace passwd_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Bit Protection Scheme Control Bits
        constexpr uint32_t PROTS = (1U << 2);  ///< Bit Protection Signal Status Bit
        constexpr uint32_t PASS = (5 << 3);  ///< Password Bits
    }

    /// CCUCON Register bits
    namespace ccucon_bits {
        constexpr uint32_t GSC40 = (1U << 0);  ///< Global Start Control CCU40
    }

    /// MIRRSTS Register bits
    namespace mirrsts_bits {
        constexpr uint32_t RTC_CTR = (1U << 0);  ///< RTC CTR Mirror Register Update Status
        constexpr uint32_t RTC_ATIM0 = (1U << 1);  ///< RTC ATIM0 Mirror Register Update Status
        constexpr uint32_t RTC_ATIM1 = (1U << 2);  ///< RTC ATIM1 Mirror Register Update Status
        constexpr uint32_t RTC_TIM0 = (1U << 3);  ///< RTC TIM0 Mirror Register Update Status
        constexpr uint32_t RTC_TIM1 = (1U << 4);  ///< RTC TIM1 Mirror Register Update Status
    }

    /// PMTSR Register bits
    namespace pmtsr_bits {
        constexpr uint32_t MTENS = (1U << 0);  ///< Parity Test Enable Control for 16kbytes SRAM
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t SCU_POWER_BASE = 0x40010200;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t VDESR;  ///< Offset: 0x00 - Voltage Detector Status Register
    };

    /// Peripheral instances
    inline Registers* SCU_POWER = reinterpret_cast<Registers*>(SCU_POWER_BASE);

    // Bit definitions
    /// VDESR Register bits
    namespace vdesr_bits {
        constexpr uint32_t VCLIP = (1U << 0);  ///< VCLIP Indication
        constexpr uint32_t VDDPPW = (1U << 1);  ///< VDDPPW Indication
    }

}

// ============================================================================
// CCU40 Peripheral
// ============================================================================

namespace ccu40 {
    /// Base addresses
    constexpr uint32_t CCU40_BASE = 0x48040000;
    constexpr uint32_t CCU40_CC40_BASE = 0x48040100;
    constexpr uint32_t CCU40_CC41_BASE = 0x48040200;
    constexpr uint32_t CCU40_CC42_BASE = 0x48040300;
    constexpr uint32_t CCU40_CC43_BASE = 0x48040400;

    /// CCU40 Register structure
    struct Registers {
        volatile uint32_t GCTRL;  ///< Offset: 0x00 - Global Control Register
        volatile uint32_t GSTAT;  ///< Offset: 0x04 - Global Status Register
        volatile uint32_t GIDLS;  ///< Offset: 0x08 - Global Idle Set
        volatile uint32_t GIDLC;  ///< Offset: 0x0C - Global Idle Clear
        volatile uint32_t GCSS;  ///< Offset: 0x10 - Global Channel Set
        volatile uint32_t GCSC;  ///< Offset: 0x14 - Global Channel Clear
        volatile uint32_t GCST;  ///< Offset: 0x18 - Global Channel Status
        volatile uint32_t MIDR;  ///< Offset: 0x80 - Module Identification
    };

    /// Peripheral instances
    inline Registers* CCU40 = reinterpret_cast<Registers*>(CCU40_BASE);
    inline Registers* CCU40_CC40 = reinterpret_cast<Registers*>(CCU40_CC40_BASE);
    inline Registers* CCU40_CC41 = reinterpret_cast<Registers*>(CCU40_CC41_BASE);
    inline Registers* CCU40_CC42 = reinterpret_cast<Registers*>(CCU40_CC42_BASE);
    inline Registers* CCU40_CC43 = reinterpret_cast<Registers*>(CCU40_CC43_BASE);

    // Bit definitions
    /// GCTRL Register bits
    namespace gctrl_bits {
        constexpr uint32_t PRBC = (3 << 0);  ///< Prescaler Clear Configuration
        constexpr uint32_t PCIS = (2 << 4);  ///< Prescaler Input Clock Selection
        constexpr uint32_t SUSCFG = (2 << 8);  ///< Suspend Mode Configuration
        constexpr uint32_t MSE0 = (1U << 10);  ///< Slice 0 Multi Channel shadow transfer enable
        constexpr uint32_t MSE1 = (1U << 11);  ///< Slice 1 Multi Channel shadow transfer enable
        constexpr uint32_t MSE2 = (1U << 12);  ///< Slice 2 Multi Channel shadow transfer enable
        constexpr uint32_t MSE3 = (1U << 13);  ///< Slice 3 Multi Channel shadow transfer enable
        constexpr uint32_t MSDE = (2 << 14);  ///< Multi Channel shadow transfer request configuration
    }

    /// GSTAT Register bits
    namespace gstat_bits {
        constexpr uint32_t S0I = (1U << 0);  ///< CC40 IDLE status
        constexpr uint32_t S1I = (1U << 1);  ///< CC41 IDLE status
        constexpr uint32_t S2I = (1U << 2);  ///< CC42 IDLE status
        constexpr uint32_t S3I = (1U << 3);  ///< CC43 IDLE status
        constexpr uint32_t PRB = (1U << 8);  ///< Prescaler Run Bit
    }

    /// GIDLS Register bits
    namespace gidls_bits {
        constexpr uint32_t SS0I = (1U << 0);  ///< CC40 IDLE mode set
        constexpr uint32_t SS1I = (1U << 1);  ///< CC41 IDLE mode set
        constexpr uint32_t SS2I = (1U << 2);  ///< CC42 IDLE mode set
        constexpr uint32_t SS3I = (1U << 3);  ///< CC43 IDLE mode set
        constexpr uint32_t CPRB = (1U << 8);  ///< Prescaler Run Bit Clear
        constexpr uint32_t PSIC = (1U << 9);  ///< Prescaler clear
    }

    /// GIDLC Register bits
    namespace gidlc_bits {
        constexpr uint32_t CS0I = (1U << 0);  ///< CC40 IDLE mode clear
        constexpr uint32_t CS1I = (1U << 1);  ///< CC41 IDLE mode clear
        constexpr uint32_t CS2I = (1U << 2);  ///< CC42 IDLE mode clear
        constexpr uint32_t CS3I = (1U << 3);  ///< CC43 IDLE mode clear
        constexpr uint32_t SPRB = (1U << 8);  ///< Prescaler Run Bit Set
    }

    /// GCSS Register bits
    namespace gcss_bits {
        constexpr uint32_t S0SE = (1U << 0);  ///< Slice 0 shadow transfer set enable
        constexpr uint32_t S0DSE = (1U << 1);  ///< Slice 0 Dither shadow transfer set enable
        constexpr uint32_t S0PSE = (1U << 2);  ///< Slice 0 Prescaler shadow transfer set enable
        constexpr uint32_t S1SE = (1U << 4);  ///< Slice 1 shadow transfer set enable
        constexpr uint32_t S1DSE = (1U << 5);  ///< Slice 1 Dither shadow transfer set enable
        constexpr uint32_t S1PSE = (1U << 6);  ///< Slice 1 Prescaler shadow transfer set enable
        constexpr uint32_t S2SE = (1U << 8);  ///< Slice 2 shadow transfer set enable
        constexpr uint32_t S2DSE = (1U << 9);  ///< Slice 2 Dither shadow transfer set enable
        constexpr uint32_t S2PSE = (1U << 10);  ///< Slice 2 Prescaler shadow transfer set enable
        constexpr uint32_t S3SE = (1U << 12);  ///< Slice 3 shadow transfer set enable
        constexpr uint32_t S3DSE = (1U << 13);  ///< Slice 3 Dither shadow transfer set enable
        constexpr uint32_t S3PSE = (1U << 14);  ///< Slice 3 Prescaler shadow transfer set enable
        constexpr uint32_t S0STS = (1U << 16);  ///< Slice 0 status bit set
        constexpr uint32_t S1STS = (1U << 17);  ///< Slice 1 status bit set
        constexpr uint32_t S2STS = (1U << 18);  ///< Slice 2 status bit set
        constexpr uint32_t S3STS = (1U << 19);  ///< Slice 3 status bit set
    }

    /// GCSC Register bits
    namespace gcsc_bits {
        constexpr uint32_t S0SC = (1U << 0);  ///< Slice 0 shadow transfer clear
        constexpr uint32_t S0DSC = (1U << 1);  ///< Slice 0 Dither shadow transfer clear
        constexpr uint32_t S0PSC = (1U << 2);  ///< Slice 0 Prescaler shadow transfer clear
        constexpr uint32_t S1SC = (1U << 4);  ///< Slice 1 shadow transfer clear
        constexpr uint32_t S1DSC = (1U << 5);  ///< Slice 1 Dither shadow transfer clear
        constexpr uint32_t S1PSC = (1U << 6);  ///< Slice 1 Prescaler shadow transfer clear
        constexpr uint32_t S2SC = (1U << 8);  ///< Slice 2 shadow transfer clear
        constexpr uint32_t S2DSC = (1U << 9);  ///< Slice 2 Dither shadow transfer clear
        constexpr uint32_t S2PSC = (1U << 10);  ///< Slice 2 Prescaler shadow transfer clear
        constexpr uint32_t S3SC = (1U << 12);  ///< Slice 3 shadow transfer clear
        constexpr uint32_t S3DSC = (1U << 13);  ///< Slice 3 Dither shadow transfer clear
        constexpr uint32_t S3PSC = (1U << 14);  ///< Slice 3 Prescaler shadow transfer clear
        constexpr uint32_t S0STC = (1U << 16);  ///< Slice 0 status bit clear
        constexpr uint32_t S1STC = (1U << 17);  ///< Slice 1 status bit clear
        constexpr uint32_t S2STC = (1U << 18);  ///< Slice 2 status bit clear
        constexpr uint32_t S3STC = (1U << 19);  ///< Slice 3 status bit clear
    }

    /// GCST Register bits
    namespace gcst_bits {
        constexpr uint32_t S0SS = (1U << 0);  ///< Slice 0 shadow transfer status
        constexpr uint32_t S0DSS = (1U << 1);  ///< Slice 0 Dither shadow transfer status
        constexpr uint32_t S0PSS = (1U << 2);  ///< Slice 0 Prescaler shadow transfer status
        constexpr uint32_t S1SS = (1U << 4);  ///< Slice 1 shadow transfer status
        constexpr uint32_t S1DSS = (1U << 5);  ///< Slice 1 Dither shadow transfer status
        constexpr uint32_t S1PSS = (1U << 6);  ///< Slice 1 Prescaler shadow transfer status
        constexpr uint32_t S2SS = (1U << 8);  ///< Slice 2 shadow transfer status
        constexpr uint32_t S2DSS = (1U << 9);  ///< Slice 2 Dither shadow transfer status
        constexpr uint32_t S2PSS = (1U << 10);  ///< Slice 2 Prescaler shadow transfer status
        constexpr uint32_t S3SS = (1U << 12);  ///< Slice 3 shadow transfer status
        constexpr uint32_t S3DSS = (1U << 13);  ///< Slice 3 Dither shadow transfer status
        constexpr uint32_t S3PSS = (1U << 14);  ///< Slice 3 Prescaler shadow transfer status
        constexpr uint32_t CC40ST = (1U << 16);  ///< Slice 0 status bit
        constexpr uint32_t CC41ST = (1U << 17);  ///< Slice 1 status bit
        constexpr uint32_t CC42ST = (1U << 18);  ///< Slice 2 status bit
        constexpr uint32_t CC43ST = (1U << 19);  ///< Slice 3 status bit
    }

    /// MIDR Register bits
    namespace midr_bits {
        constexpr uint32_t MODR = (8 << 0);  ///< Module Revision
        constexpr uint32_t MODT = (8 << 8);  ///< Module Type
        constexpr uint32_t MODN = (16 << 16);  ///< Module Number
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t VADC_BASE = 0x48030000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CLC;  ///< Offset: 0x00 - Clock Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t OCS;  ///< Offset: 0x28 - OCDS Control and Status Register
        volatile uint32_t GLOBCFG;  ///< Offset: 0x80 - Global Configuration Register
        volatile uint32_t GLOBICLASS[%s];  ///< Offset: 0xA0 - Input Class Register, Global
        volatile uint32_t GLOBEFLAG;  ///< Offset: 0xE0 - Global Event Flag Register
        volatile uint32_t GLOBEVNP;  ///< Offset: 0x140 - Global Event Node Pointer Register
        volatile uint32_t BRSSEL[%s];  ///< Offset: 0x180 - Background Request Source Channel Select Register
        volatile uint32_t BRSPND[%s];  ///< Offset: 0x1C0 - Background Request Source Pending Register
        volatile uint32_t BRSCTRL;  ///< Offset: 0x200 - Background Request Source Control Register
        volatile uint32_t BRSMR;  ///< Offset: 0x204 - Background Request Source Mode Register
        volatile uint32_t GLOBRCR;  ///< Offset: 0x280 - Global Result Control Register
        volatile uint32_t GLOBRES;  ///< Offset: 0x300 - Global Result Register
        volatile uint32_t GLOBRESD;  ///< Offset: 0x380 - Global Result Register, Debug
    };

    /// Peripheral instances
    inline Registers* VADC = reinterpret_cast<Registers*>(VADC_BASE);

    // Bit definitions
    /// CLC Register bits
    namespace clc_bits {
        constexpr uint32_t DISR = (1U << 0);  ///< Module Disable Request Bit
        constexpr uint32_t DISS = (1U << 1);  ///< Module Disable Status Bit
        constexpr uint32_t EDIS = (1U << 3);  ///< Sleep Mode Enable Control
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// OCS Register bits
    namespace ocs_bits {
        constexpr uint32_t TGS = (2 << 0);  ///< Trigger Set for OTGB0/1
        constexpr uint32_t TGB = (1U << 2);  ///< OTGB0/1 Bus Select
        constexpr uint32_t TG_P = (1U << 3);  ///< TGS, TGB Write Protection
        constexpr uint32_t SUS = (4 << 24);  ///< OCDS Suspend Control
        constexpr uint32_t SUS_P = (1U << 28);  ///< SUS Write Protection
        constexpr uint32_t SUSSTA = (1U << 29);  ///< Suspend State
    }

    /// GLOBCFG Register bits
    namespace globcfg_bits {
        constexpr uint32_t DIVA = (5 << 0);  ///< Divider Factor for the Analog Internal Clock
        constexpr uint32_t DCMSB = (1U << 7);  ///< Double Clock for the MSB Conversion
        constexpr uint32_t DIVD = (2 << 8);  ///< Divider Factor for the Arbiter Clock
        constexpr uint32_t DIVWC = (1U << 15);  ///< Write Control for Divider Parameters
        constexpr uint32_t DPCAL0 = (1U << 16);  ///< Disable Post-Calibration
        constexpr uint32_t DPCAL1 = (1U << 17);  ///< Disable Post-Calibration
        constexpr uint32_t SUCAL = (1U << 31);  ///< Start-Up Calibration
    }

    /// GLOBICLASS[%s] Register bits
    namespace globiclass[%s]_bits {
        constexpr uint32_t STCS = (5 << 0);  ///< Sample Time Control for Standard Conversions
        constexpr uint32_t CMS = (3 << 8);  ///< Conversion Mode for Standard Conversions
    }

    /// GLOBEFLAG Register bits
    namespace globeflag_bits {
        constexpr uint32_t SEVGLB = (1U << 0);  ///< Source Event (Background)
        constexpr uint32_t REVGLB = (1U << 8);  ///< Global Result Event
        constexpr uint32_t SEVGLBCLR = (1U << 16);  ///< Clear Source Event (Background)
        constexpr uint32_t REVGLBCLR = (1U << 24);  ///< Clear Global Result Event
    }

    /// GLOBEVNP Register bits
    namespace globevnp_bits {
        constexpr uint32_t SEV0NP = (4 << 0);  ///< Service Request Node Pointer Backgr. Source
        constexpr uint32_t REV0NP = (4 << 16);  ///< Service Request Node Pointer Global Result
    }

    /// BRSSEL[%s] Register bits
    namespace brssel[%s]_bits {
        constexpr uint32_t CHSELG0 = (1U << 0);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG1 = (1U << 1);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG2 = (1U << 2);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG3 = (1U << 3);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG4 = (1U << 4);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG5 = (1U << 5);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG6 = (1U << 6);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG7 = (1U << 7);  ///< Channel Selection Group x
    }

    /// BRSPND[%s] Register bits
    namespace brspnd[%s]_bits {
        constexpr uint32_t CHPNDG0 = (1U << 0);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG1 = (1U << 1);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG2 = (1U << 2);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG3 = (1U << 3);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG4 = (1U << 4);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG5 = (1U << 5);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG6 = (1U << 6);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG7 = (1U << 7);  ///< Channels Pending Group x
    }

    /// BRSCTRL Register bits
    namespace brsctrl_bits {
        constexpr uint32_t SRCRESREG = (4 << 0);  ///< Source-specific Result Register
        constexpr uint32_t XTSEL = (4 << 8);  ///< External Trigger Input Selection
        constexpr uint32_t XTLVL = (1U << 12);  ///< External Trigger Level
        constexpr uint32_t XTMODE = (2 << 13);  ///< Trigger Operating Mode
        constexpr uint32_t XTWC = (1U << 15);  ///< Write Control for Trigger Configuration
        constexpr uint32_t GTSEL = (4 << 16);  ///< Gate Input Selection
        constexpr uint32_t GTLVL = (1U << 20);  ///< Gate Input Level
        constexpr uint32_t GTWC = (1U << 23);  ///< Write Control for Gate Configuration
    }

    /// BRSMR Register bits
    namespace brsmr_bits {
        constexpr uint32_t ENGT = (2 << 0);  ///< Enable Gate
        constexpr uint32_t ENTR = (1U << 2);  ///< Enable External Trigger
        constexpr uint32_t ENSI = (1U << 3);  ///< Enable Source Interrupt
        constexpr uint32_t SCAN = (1U << 4);  ///< Autoscan Enable
        constexpr uint32_t LDM = (1U << 5);  ///< Autoscan Source Load Event Mode
        constexpr uint32_t REQGT = (1U << 7);  ///< Request Gate Level
        constexpr uint32_t CLRPND = (1U << 8);  ///< Clear Pending Bits
        constexpr uint32_t LDEV = (1U << 9);  ///< Generate Load Event
        constexpr uint32_t RPTDIS = (1U << 16);  ///< Repeat Disable
    }

    /// GLOBRCR Register bits
    namespace globrcr_bits {
        constexpr uint32_t DRCTR = (4 << 16);  ///< Data Reduction Control
        constexpr uint32_t WFR = (1U << 24);  ///< Wait-for-Read Mode Enable
        constexpr uint32_t SRGEN = (1U << 31);  ///< Service Request Generation Enable
    }

    /// GLOBRES Register bits
    namespace globres_bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Result of most recent conversion
        constexpr uint32_t GNR = (4 << 16);  ///< Group Number
        constexpr uint32_t CHNR = (5 << 20);  ///< Channel Number
        constexpr uint32_t EMUX = (3 << 25);  ///< External Multiplexer Setting
        constexpr uint32_t CRS = (2 << 28);  ///< Converted Request Source
        constexpr uint32_t FCR = (1U << 30);  ///< Fast Compare Result
        constexpr uint32_t VF = (1U << 31);  ///< Valid Flag
    }

    /// GLOBRESD Register bits
    namespace globresd_bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Result of most recent conversion
        constexpr uint32_t GNR = (4 << 16);  ///< Group Number
        constexpr uint32_t CHNR = (5 << 20);  ///< Channel Number
        constexpr uint32_t EMUX = (3 << 25);  ///< External Multiplexer Setting
        constexpr uint32_t CRS = (2 << 28);  ///< Converted Request Source
        constexpr uint32_t FCR = (1U << 30);  ///< Fast Compare Result
        constexpr uint32_t VF = (1U << 31);  ///< Valid Flag
    }

}

// ============================================================================
// SHS0 Peripheral
// ============================================================================

namespace shs0 {
    /// Base addresses
    constexpr uint32_t SHS0_BASE = 0x48034000;

    /// SHS0 Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t SHSCFG;  ///< Offset: 0x40 - SHS Configuration Register
        volatile uint32_t STEPCFG;  ///< Offset: 0x44 - Stepper Configuration Register
        volatile uint32_t TIMCFG0;  ///< Offset: 0x80 - Timing Configuration Register 0
        volatile uint32_t TIMCFG1;  ///< Offset: 0x84 - Timing Configuration Register 1
        volatile uint32_t CALCTR;  ///< Offset: 0xBC - Calibration Control Register
        volatile uint32_t CALGC0;  ///< Offset: 0xC0 - Gain Calibration Control Register 0
        volatile uint32_t CALGC1;  ///< Offset: 0xC4 - Gain Calibration Control Register 1
        volatile uint32_t GNCTR00;  ///< Offset: 0x180 - Gain Control Register 00
        volatile uint32_t GNCTR10;  ///< Offset: 0x190 - Gain Control Register 10
        volatile uint32_t LOOP;  ///< Offset: 0x50 - Loop Control Register
    };

    /// Peripheral instances
    inline Registers* SHS0 = reinterpret_cast<Registers*>(SHS0_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// SHSCFG Register bits
    namespace shscfg_bits {
        constexpr uint32_t DIVS = (4 << 0);  ///< Divider Factor for the SHS Clock
        constexpr uint32_t AREF = (2 << 10);  ///< Analog Reference Voltage Selection
        constexpr uint32_t ANOFF = (1U << 12);  ///< Analog Converter Power Down Force
        constexpr uint32_t ANRDY = (1U << 14);  ///< Analog Converter Ready
        constexpr uint32_t SCWC = (1U << 15);  ///< Write Control for SHS Configuration
        constexpr uint32_t SP0 = (1U << 16);  ///< Sample Pending on S&H Unit x
        constexpr uint32_t SP1 = (1U << 17);  ///< Sample Pending on S&H Unit x
        constexpr uint32_t TC = (4 << 24);  ///< Test Control
        constexpr uint32_t STATE = (4 << 28);  ///< Current State of Sequencer
    }

    /// STEPCFG Register bits
    namespace stepcfg_bits {
        constexpr uint32_t KSEL0 = (3 << 0);  ///< Kernel Select
        constexpr uint32_t KSEL1 = (3 << 4);  ///< Kernel Select
        constexpr uint32_t KSEL2 = (3 << 8);  ///< Kernel Select
        constexpr uint32_t KSEL3 = (3 << 12);  ///< Kernel Select
        constexpr uint32_t KSEL4 = (3 << 16);  ///< Kernel Select
        constexpr uint32_t KSEL5 = (3 << 20);  ///< Kernel Select
        constexpr uint32_t KSEL6 = (3 << 24);  ///< Kernel Select
        constexpr uint32_t KSEL7 = (3 << 28);  ///< Kernel Select
        constexpr uint32_t SEN0 = (1U << 3);  ///< Step x Enable
        constexpr uint32_t SEN1 = (1U << 7);  ///< Step x Enable
        constexpr uint32_t SEN2 = (1U << 11);  ///< Step x Enable
        constexpr uint32_t SEN3 = (1U << 15);  ///< Step x Enable
        constexpr uint32_t SEN4 = (1U << 19);  ///< Step x Enable
        constexpr uint32_t SEN5 = (1U << 23);  ///< Step x Enable
        constexpr uint32_t SEN6 = (1U << 27);  ///< Step x Enable
        constexpr uint32_t SEN7 = (1U << 31);  ///< Step x Enable
    }

    /// TIMCFG0 Register bits
    namespace timcfg0_bits {
        constexpr uint32_t AT = (1U << 0);  ///< Accelerated Timing
        constexpr uint32_t FCRT = (4 << 4);  ///< Fast Compare Mode Response Time
        constexpr uint32_t SST = (6 << 8);  ///< Short Sample Time
        constexpr uint32_t TGEN = (14 << 16);  ///< Timing Generator
    }

    /// TIMCFG1 Register bits
    namespace timcfg1_bits {
        constexpr uint32_t AT = (1U << 0);  ///< Accelerated Timing
        constexpr uint32_t FCRT = (4 << 4);  ///< Fast Compare Mode Response Time
        constexpr uint32_t SST = (6 << 8);  ///< Short Sample Time
        constexpr uint32_t TGEN = (14 << 16);  ///< Timing Generator
    }

    /// CALCTR Register bits
    namespace calctr_bits {
        constexpr uint32_t CALORD = (1U << 0);  ///< Calibration Order
        constexpr uint32_t CALGNSTC = (6 << 8);  ///< Gain Calibration Sample Time Control
        constexpr uint32_t SUCALVAL = (7 << 16);  ///< Startup Calibration Cycles
        constexpr uint32_t CALMAX = (6 << 24);  ///< Calibration Maximum Timing
        constexpr uint32_t SUCAL = (1U << 31);  ///< Start-Up Calibration
    }

    /// CALGC0 Register bits
    namespace calgc0_bits {
        constexpr uint32_t CALGNVALS = (14 << 0);  ///< Gain Calibration Value, Standard Reference
        constexpr uint32_t GNSWC = (1U << 15);  ///< Gain Calibration Write Control, Standard
        constexpr uint32_t CALGNVALA = (14 << 16);  ///< Gain Calibration Value, Alternate Reference
        constexpr uint32_t GNAWC = (1U << 31);  ///< Gain Calibration Write Control, Alternate
    }

    /// CALGC1 Register bits
    namespace calgc1_bits {
        constexpr uint32_t CALGNVALS = (14 << 0);  ///< Gain Calibration Value, Standard Reference
        constexpr uint32_t GNSWC = (1U << 15);  ///< Gain Calibration Write Control, Standard
        constexpr uint32_t CALGNVALA = (14 << 16);  ///< Gain Calibration Value, Alternate Reference
        constexpr uint32_t GNAWC = (1U << 31);  ///< Gain Calibration Write Control, Alternate
    }

    /// GNCTR00 Register bits
    namespace gnctr00_bits {
        constexpr uint32_t GAIN0 = (4 << 0);  ///< Gain Control 0
        constexpr uint32_t GAIN1 = (4 << 4);  ///< Gain Control 1
        constexpr uint32_t GAIN2 = (4 << 8);  ///< Gain Control 2
        constexpr uint32_t GAIN3 = (4 << 12);  ///< Gain Control 3
        constexpr uint32_t GAIN4 = (4 << 16);  ///< Gain Control 4
        constexpr uint32_t GAIN5 = (4 << 20);  ///< Gain Control 5
        constexpr uint32_t GAIN6 = (4 << 24);  ///< Gain Control 6
        constexpr uint32_t GAIN7 = (4 << 28);  ///< Gain Control 7
    }

    /// GNCTR10 Register bits
    namespace gnctr10_bits {
        constexpr uint32_t GAIN0 = (4 << 0);  ///< Gain Control 0
        constexpr uint32_t GAIN1 = (4 << 4);  ///< Gain Control 1
        constexpr uint32_t GAIN2 = (4 << 8);  ///< Gain Control 2
        constexpr uint32_t GAIN3 = (4 << 12);  ///< Gain Control 3
        constexpr uint32_t GAIN4 = (4 << 16);  ///< Gain Control 4
        constexpr uint32_t GAIN5 = (4 << 20);  ///< Gain Control 5
        constexpr uint32_t GAIN6 = (4 << 24);  ///< Gain Control 6
        constexpr uint32_t GAIN7 = (4 << 28);  ///< Gain Control 7
    }

    /// LOOP Register bits
    namespace loop_bits {
        constexpr uint32_t LPCH0 = (5 << 0);  ///< Loop y Channel
        constexpr uint32_t LPCH1 = (5 << 16);  ///< Loop y Channel
        constexpr uint32_t LPSH0 = (1U << 8);  ///< Loop y Sample&Hold Unit
        constexpr uint32_t LPSH1 = (1U << 24);  ///< Loop y Sample&Hold Unit
        constexpr uint32_t LPEN0 = (1U << 15);  ///< Loop y Enable
        constexpr uint32_t LPEN1 = (1U << 31);  ///< Loop y Enable
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT0_BASE = 0x40040000;
    constexpr uint32_t PORT1_BASE = 0x40040100;
    constexpr uint32_t PORT2_BASE = 0x40040200;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t OUT;  ///< Offset: 0x00 - Port 0 Output Register
        volatile uint32_t OMR;  ///< Offset: 0x04 - Port 0 Output Modification Register
        volatile uint32_t IOCR0;  ///< Offset: 0x10 - Port 0 Input/Output Control Register 0
        volatile uint32_t IOCR4;  ///< Offset: 0x14 - Port 0 Input/Output Control Register 4
        volatile uint32_t IOCR8;  ///< Offset: 0x18 - Port 0 Input/Output Control Register 8
        volatile uint32_t IOCR12;  ///< Offset: 0x1C - Port 0 Input/Output Control Register 12
        volatile uint32_t IN;  ///< Offset: 0x24 - Port 0 Input Register
        volatile uint32_t PHCR0;  ///< Offset: 0x40 - Port 0 Pad Hysteresis Control Register 0
        volatile uint32_t PHCR1;  ///< Offset: 0x44 - Port 0 Pad Hysteresis Control Register 1
        volatile uint32_t PDISC;  ///< Offset: 0x60 - Port 0 Pin Function Decision Control Register
        volatile uint32_t PPS;  ///< Offset: 0x70 - Port 0 Pin Power Save Register
        volatile uint32_t HWSEL;  ///< Offset: 0x74 - Port 0 Pin Hardware Select Register
    };

    /// Peripheral instances
    inline Registers* PORT0 = reinterpret_cast<Registers*>(PORT0_BASE);
    inline Registers* PORT1 = reinterpret_cast<Registers*>(PORT1_BASE);
    inline Registers* PORT2 = reinterpret_cast<Registers*>(PORT2_BASE);

    // Bit definitions
    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Port 0 Output Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Port 0 Output Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Port 0 Output Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Port 0 Output Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Port 0 Output Bit 4
        constexpr uint32_t P5 = (1U << 5);  ///< Port 0 Output Bit 5
        constexpr uint32_t P6 = (1U << 6);  ///< Port 0 Output Bit 6
        constexpr uint32_t P7 = (1U << 7);  ///< Port 0 Output Bit 7
        constexpr uint32_t P8 = (1U << 8);  ///< Port 0 Output Bit 8
        constexpr uint32_t P9 = (1U << 9);  ///< Port 0 Output Bit 9
        constexpr uint32_t P10 = (1U << 10);  ///< Port 0 Output Bit 10
        constexpr uint32_t P11 = (1U << 11);  ///< Port 0 Output Bit 11
        constexpr uint32_t P12 = (1U << 12);  ///< Port 0 Output Bit 12
        constexpr uint32_t P13 = (1U << 13);  ///< Port 0 Output Bit 13
        constexpr uint32_t P14 = (1U << 14);  ///< Port 0 Output Bit 14
        constexpr uint32_t P15 = (1U << 15);  ///< Port 0 Output Bit 15
    }

    /// OMR Register bits
    namespace omr_bits {
        constexpr uint32_t PS0 = (1U << 0);  ///< Port 0 Set Bit 0
        constexpr uint32_t PS1 = (1U << 1);  ///< Port 0 Set Bit 1
        constexpr uint32_t PS2 = (1U << 2);  ///< Port 0 Set Bit 2
        constexpr uint32_t PS3 = (1U << 3);  ///< Port 0 Set Bit 3
        constexpr uint32_t PS4 = (1U << 4);  ///< Port 0 Set Bit 4
        constexpr uint32_t PS5 = (1U << 5);  ///< Port 0 Set Bit 5
        constexpr uint32_t PS6 = (1U << 6);  ///< Port 0 Set Bit 6
        constexpr uint32_t PS7 = (1U << 7);  ///< Port 0 Set Bit 7
        constexpr uint32_t PS8 = (1U << 8);  ///< Port 0 Set Bit 8
        constexpr uint32_t PS9 = (1U << 9);  ///< Port 0 Set Bit 9
        constexpr uint32_t PS10 = (1U << 10);  ///< Port 0 Set Bit 10
        constexpr uint32_t PS11 = (1U << 11);  ///< Port 0 Set Bit 11
        constexpr uint32_t PS12 = (1U << 12);  ///< Port 0 Set Bit 12
        constexpr uint32_t PS13 = (1U << 13);  ///< Port 0 Set Bit 13
        constexpr uint32_t PS14 = (1U << 14);  ///< Port 0 Set Bit 14
        constexpr uint32_t PS15 = (1U << 15);  ///< Port 0 Set Bit 15
        constexpr uint32_t PR0 = (1U << 16);  ///< Port 0 Reset Bit 0
        constexpr uint32_t PR1 = (1U << 17);  ///< Port 0 Reset Bit 1
        constexpr uint32_t PR2 = (1U << 18);  ///< Port 0 Reset Bit 2
        constexpr uint32_t PR3 = (1U << 19);  ///< Port 0 Reset Bit 3
        constexpr uint32_t PR4 = (1U << 20);  ///< Port 0 Reset Bit 4
        constexpr uint32_t PR5 = (1U << 21);  ///< Port 0 Reset Bit 5
        constexpr uint32_t PR6 = (1U << 22);  ///< Port 0 Reset Bit 6
        constexpr uint32_t PR7 = (1U << 23);  ///< Port 0 Reset Bit 7
        constexpr uint32_t PR8 = (1U << 24);  ///< Port 0 Reset Bit 8
        constexpr uint32_t PR9 = (1U << 25);  ///< Port 0 Reset Bit 9
        constexpr uint32_t PR10 = (1U << 26);  ///< Port 0 Reset Bit 10
        constexpr uint32_t PR11 = (1U << 27);  ///< Port 0 Reset Bit 11
        constexpr uint32_t PR12 = (1U << 28);  ///< Port 0 Reset Bit 12
        constexpr uint32_t PR13 = (1U << 29);  ///< Port 0 Reset Bit 13
        constexpr uint32_t PR14 = (1U << 30);  ///< Port 0 Reset Bit 14
        constexpr uint32_t PR15 = (1U << 31);  ///< Port 0 Reset Bit 15
    }

    /// IOCR0 Register bits
    namespace iocr0_bits {
        constexpr uint32_t PC0 = (5 << 3);  ///< Port Control for Port n Pin 0 to 3
        constexpr uint32_t PC1 = (5 << 11);  ///< Port Control for Port n Pin 0 to 3
        constexpr uint32_t PC2 = (5 << 19);  ///< Port Control for Port n Pin 0 to 3
        constexpr uint32_t PC3 = (5 << 27);  ///< Port Control for Port n Pin 0 to 3
    }

    /// IOCR4 Register bits
    namespace iocr4_bits {
        constexpr uint32_t PC4 = (5 << 3);  ///< Port Control for Port n Pin 4 to 7
        constexpr uint32_t PC5 = (5 << 11);  ///< Port Control for Port n Pin 4 to 7
        constexpr uint32_t PC6 = (5 << 19);  ///< Port Control for Port n Pin 4 to 7
        constexpr uint32_t PC7 = (5 << 27);  ///< Port Control for Port n Pin 4 to 7
    }

    /// IOCR8 Register bits
    namespace iocr8_bits {
        constexpr uint32_t PC8 = (5 << 3);  ///< Port Control for Port n Pin 8 to 11
        constexpr uint32_t PC9 = (5 << 11);  ///< Port Control for Port n Pin 8 to 11
        constexpr uint32_t PC10 = (5 << 19);  ///< Port Control for Port n Pin 8 to 11
        constexpr uint32_t PC11 = (5 << 27);  ///< Port Control for Port n Pin 8 to 11
    }

    /// IOCR12 Register bits
    namespace iocr12_bits {
        constexpr uint32_t PC12 = (5 << 3);  ///< Port Control for Port n Pin 12 to 15
        constexpr uint32_t PC13 = (5 << 11);  ///< Port Control for Port n Pin 12 to 15
        constexpr uint32_t PC14 = (5 << 19);  ///< Port Control for Port n Pin 12 to 15
        constexpr uint32_t PC15 = (5 << 27);  ///< Port Control for Port n Pin 12 to 15
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Port 0 Input Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Port 0 Input Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Port 0 Input Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Port 0 Input Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Port 0 Input Bit 4
        constexpr uint32_t P5 = (1U << 5);  ///< Port 0 Input Bit 5
        constexpr uint32_t P6 = (1U << 6);  ///< Port 0 Input Bit 6
        constexpr uint32_t P7 = (1U << 7);  ///< Port 0 Input Bit 7
        constexpr uint32_t P8 = (1U << 8);  ///< Port 0 Input Bit 8
        constexpr uint32_t P9 = (1U << 9);  ///< Port 0 Input Bit 9
        constexpr uint32_t P10 = (1U << 10);  ///< Port 0 Input Bit 10
        constexpr uint32_t P11 = (1U << 11);  ///< Port 0 Input Bit 11
        constexpr uint32_t P12 = (1U << 12);  ///< Port 0 Input Bit 12
        constexpr uint32_t P13 = (1U << 13);  ///< Port 0 Input Bit 13
        constexpr uint32_t P14 = (1U << 14);  ///< Port 0 Input Bit 14
        constexpr uint32_t P15 = (1U << 15);  ///< Port 0 Input Bit 15
    }

    /// PHCR0 Register bits
    namespace phcr0_bits {
        constexpr uint32_t PH0 = (1U << 2);  ///< Pad Hysteresis for Pn.0
        constexpr uint32_t PH1 = (1U << 6);  ///< Pad Hysteresis for Pn.1
        constexpr uint32_t PH2 = (1U << 10);  ///< Pad Hysteresis for Pn.2
        constexpr uint32_t PH3 = (1U << 14);  ///< Pad Hysteresis for Pn.3
        constexpr uint32_t PH4 = (1U << 18);  ///< Pad Hysteresis for Pn.4
        constexpr uint32_t PH5 = (1U << 22);  ///< Pad Hysteresis for Pn.5
        constexpr uint32_t PH6 = (1U << 26);  ///< Pad Hysteresis for Pn.6
        constexpr uint32_t PH7 = (1U << 30);  ///< Pad Hysteresis for Pn.7
    }

    /// PHCR1 Register bits
    namespace phcr1_bits {
        constexpr uint32_t PH8 = (1U << 2);  ///< Pad Hysteresis for P0.8
        constexpr uint32_t PH9 = (1U << 6);  ///< Pad Hysteresis for P0.9
        constexpr uint32_t PH10 = (1U << 10);  ///< Pad Hysteresis for P0.10
        constexpr uint32_t PH11 = (1U << 14);  ///< Pad Hysteresis for P0.11
        constexpr uint32_t PH12 = (1U << 18);  ///< Pad Hysteresis for P0.12
        constexpr uint32_t PH13 = (1U << 22);  ///< Pad Hysteresis for P0.13
        constexpr uint32_t PH14 = (1U << 26);  ///< Pad Hysteresis for P0.14
        constexpr uint32_t PH15 = (1U << 30);  ///< Pad Hysteresis for P0.15
    }

    /// PDISC Register bits
    namespace pdisc_bits {
        constexpr uint32_t PDIS0 = (1U << 0);  ///< Pad Disable for Port 0 Pin 0
        constexpr uint32_t PDIS1 = (1U << 1);  ///< Pad Disable for Port 0 Pin 1
        constexpr uint32_t PDIS2 = (1U << 2);  ///< Pad Disable for Port 0 Pin 2
        constexpr uint32_t PDIS3 = (1U << 3);  ///< Pad Disable for Port 0 Pin 3
        constexpr uint32_t PDIS4 = (1U << 4);  ///< Pad Disable for Port 0 Pin 4
        constexpr uint32_t PDIS5 = (1U << 5);  ///< Pad Disable for Port 0 Pin 5
        constexpr uint32_t PDIS6 = (1U << 6);  ///< Pad Disable for Port 0 Pin 6
        constexpr uint32_t PDIS7 = (1U << 7);  ///< Pad Disable for Port 0 Pin 7
        constexpr uint32_t PDIS8 = (1U << 8);  ///< Pad Disable for Port 0 Pin 8
        constexpr uint32_t PDIS9 = (1U << 9);  ///< Pad Disable for Port 0 Pin 9
        constexpr uint32_t PDIS10 = (1U << 10);  ///< Pad Disable for Port 0 Pin 10
        constexpr uint32_t PDIS11 = (1U << 11);  ///< Pad Disable for Port 0 Pin 11
        constexpr uint32_t PDIS12 = (1U << 12);  ///< Pad Disable for Port 0 Pin 12
        constexpr uint32_t PDIS13 = (1U << 13);  ///< Pad Disable for Port 0 Pin 13
        constexpr uint32_t PDIS14 = (1U << 14);  ///< Pad Disable for Port 0 Pin 14
        constexpr uint32_t PDIS15 = (1U << 15);  ///< Pad Disable for Port 0 Pin 15
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPS0 = (1U << 0);  ///< Port 0 Pin Power Save Bit 0
        constexpr uint32_t PPS1 = (1U << 1);  ///< Port 0 Pin Power Save Bit 1
        constexpr uint32_t PPS2 = (1U << 2);  ///< Port 0 Pin Power Save Bit 2
        constexpr uint32_t PPS3 = (1U << 3);  ///< Port 0 Pin Power Save Bit 3
        constexpr uint32_t PPS4 = (1U << 4);  ///< Port 0 Pin Power Save Bit 4
        constexpr uint32_t PPS5 = (1U << 5);  ///< Port 0 Pin Power Save Bit 5
        constexpr uint32_t PPS6 = (1U << 6);  ///< Port 0 Pin Power Save Bit 6
        constexpr uint32_t PPS7 = (1U << 7);  ///< Port 0 Pin Power Save Bit 7
        constexpr uint32_t PPS8 = (1U << 8);  ///< Port 0 Pin Power Save Bit 8
        constexpr uint32_t PPS9 = (1U << 9);  ///< Port 0 Pin Power Save Bit 9
        constexpr uint32_t PPS10 = (1U << 10);  ///< Port 0 Pin Power Save Bit 10
        constexpr uint32_t PPS11 = (1U << 11);  ///< Port 0 Pin Power Save Bit 11
        constexpr uint32_t PPS12 = (1U << 12);  ///< Port 0 Pin Power Save Bit 12
        constexpr uint32_t PPS13 = (1U << 13);  ///< Port 0 Pin Power Save Bit 13
        constexpr uint32_t PPS14 = (1U << 14);  ///< Port 0 Pin Power Save Bit 14
        constexpr uint32_t PPS15 = (1U << 15);  ///< Port 0 Pin Power Save Bit 15
    }

    /// HWSEL Register bits
    namespace hwsel_bits {
        constexpr uint32_t HW0 = (2 << 0);  ///< Port 0 Pin Hardware Select Bit 0
        constexpr uint32_t HW1 = (2 << 2);  ///< Port 0 Pin Hardware Select Bit 1
        constexpr uint32_t HW2 = (2 << 4);  ///< Port 0 Pin Hardware Select Bit 2
        constexpr uint32_t HW3 = (2 << 6);  ///< Port 0 Pin Hardware Select Bit 3
        constexpr uint32_t HW4 = (2 << 8);  ///< Port 0 Pin Hardware Select Bit 4
        constexpr uint32_t HW5 = (2 << 10);  ///< Port 0 Pin Hardware Select Bit 5
        constexpr uint32_t HW6 = (2 << 12);  ///< Port 0 Pin Hardware Select Bit 6
        constexpr uint32_t HW7 = (2 << 14);  ///< Port 0 Pin Hardware Select Bit 7
        constexpr uint32_t HW8 = (2 << 16);  ///< Port 0 Pin Hardware Select Bit 8
        constexpr uint32_t HW9 = (2 << 18);  ///< Port 0 Pin Hardware Select Bit 9
        constexpr uint32_t HW10 = (2 << 20);  ///< Port 0 Pin Hardware Select Bit 10
        constexpr uint32_t HW11 = (2 << 22);  ///< Port 0 Pin Hardware Select Bit 11
        constexpr uint32_t HW12 = (2 << 24);  ///< Port 0 Pin Hardware Select Bit 12
        constexpr uint32_t HW13 = (2 << 26);  ///< Port 0 Pin Hardware Select Bit 13
        constexpr uint32_t HW14 = (2 << 28);  ///< Port 0 Pin Hardware Select Bit 14
        constexpr uint32_t HW15 = (2 << 30);  ///< Port 0 Pin Hardware Select Bit 15
    }

}


} // namespace alloy::generated::xmc1100

#endif // ALLOY_GENERATED_XMC1100_PERIPHERALS_HPP