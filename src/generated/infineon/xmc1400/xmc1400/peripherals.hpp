/// Auto-generated code for XMC1400
/// Generated by Alloy Code Generator
/// Source: infineon_xmc1400.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:22:00
#ifndef ALLOY_GENERATED_XMC1400_PERIPHERALS_HPP
#define ALLOY_GENERATED_XMC1400_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::xmc1400 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// PPB Peripheral
// ============================================================================

namespace ppb {
    /// Base addresses
    constexpr uint32_t PPB_BASE = 0xE000E000;

    /// PPB Register structure
    struct Registers {
        volatile uint32_t SYST_CSR;  ///< Offset: 0x10 - SysTick Control and Status Register
        volatile uint32_t SYST_RVR;  ///< Offset: 0x14 - SysTick Reload Value Register
        volatile uint32_t SYST_CVR;  ///< Offset: 0x18 - SysTick Current Value Register
        volatile uint32_t SYST_CALIB;  ///< Offset: 0x1C - SysTick Calibration Value Register
        volatile uint32_t NVIC_ISER;  ///< Offset: 0x100 - Interrupt Set-enable Register
        volatile uint32_t NVIC_ICER;  ///< Offset: 0x180 - IInterrupt Clear-enable Register
        volatile uint32_t NVIC_ISPR;  ///< Offset: 0x200 - Interrupt Set-pending Register
        volatile uint32_t NVIC_ICPR;  ///< Offset: 0x280 - Interrupt Clear-pending Register
        volatile uint32_t NVIC_IPR0;  ///< Offset: 0x400 - Interrupt Priority Register 0
        volatile uint32_t NVIC_IPR1;  ///< Offset: 0x404 - Interrupt Priority Register 1
        volatile uint32_t NVIC_IPR2;  ///< Offset: 0x408 - Interrupt Priority Register 2
        volatile uint32_t NVIC_IPR3;  ///< Offset: 0x40C - Interrupt Priority Register 3
        volatile uint32_t NVIC_IPR4;  ///< Offset: 0x410 - Interrupt Priority Register 4
        volatile uint32_t NVIC_IPR5;  ///< Offset: 0x414 - Interrupt Priority Register 5
        volatile uint32_t NVIC_IPR6;  ///< Offset: 0x418 - Interrupt Priority Register 6
        volatile uint32_t NVIC_IPR7;  ///< Offset: 0x41C - Interrupt Priority Register 7
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control and State Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt and Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration and Control Register
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
    };

    /// Peripheral instances
    inline Registers* PPB = reinterpret_cast<Registers*>(PPB_BASE);

    // Bit definitions
    /// SYST_CSR Register bits
    namespace syst_csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Counter Enable
        constexpr uint32_t TICKINT = (1U << 1);  ///< SysTick Exception Request
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< Clock Source
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< Counter Flag
    }

    /// SYST_RVR Register bits
    namespace syst_rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Reload Value
    }

    /// SYST_CVR Register bits
    namespace syst_cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< SysTick Counter Current Value
    }

    /// SYST_CALIB Register bits
    namespace syst_calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< 10 Milliseconds
        constexpr uint32_t SKEW = (1U << 30);  ///< Clock Skew
        constexpr uint32_t NOREF = (1U << 31);  ///< Reference Clock
    }

    /// NVIC_ISER Register bits
    namespace nvic_iser_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt Node Set-enable
    }

    /// NVIC_ICER Register bits
    namespace nvic_icer_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt Node Clear-enable
    }

    /// NVIC_ISPR Register bits
    namespace nvic_ispr_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt Node Set-pending
    }

    /// NVIC_ICPR Register bits
    namespace nvic_icpr_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt Node Clear-pending
    }

    /// NVIC_IPR0 Register bits
    namespace nvic_ipr0_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR1 Register bits
    namespace nvic_ipr1_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR2 Register bits
    namespace nvic_ipr2_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR3 Register bits
    namespace nvic_ipr3_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR4 Register bits
    namespace nvic_ipr4_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR5 Register bits
    namespace nvic_ipr5_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR6 Register bits
    namespace nvic_ipr6_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// NVIC_IPR7 Register bits
    namespace nvic_ipr7_bits {
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority, Byte Offset 3
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority, Byte Offset 2
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority, Byte Offset 1
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority, Byte Offset 0
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t Revision = (4 << 0);  ///< Revision Number
        constexpr uint32_t PartNo = (12 << 4);  ///< Part Number of the Processor
        constexpr uint32_t Architecture = (4 << 16);  ///< Architecture
        constexpr uint32_t Variant = (4 << 20);  ///< Variant Number
        constexpr uint32_t Implementer = (8 << 24);  ///< Implementer Code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (6 << 0);  ///< Active Exception Number
        constexpr uint32_t VECTPENDING = (6 << 12);  ///< Pending Exception Number
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt Pending Flag
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick Exception Clear-pending
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick Exception Set-pending
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV Clear Pending
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV Set Pending
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< System Reset Request
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< Data Endianness
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Register Key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< Sleep-on-exit
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< Low Power Sleep Mode
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< Send Event on Pending bit
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Unaligned Access Traps
        constexpr uint32_t STKALIGN = (1U << 9);  ///< Stack Alignment
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of System Handler 11
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of System Handler 14
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of System Handler 15
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVCall Pending bit
    }

}

// ============================================================================
// ERU0 Peripheral
// ============================================================================

namespace eru0 {
    /// Base addresses
    constexpr uint32_t ERU0_BASE = 0x40010600;

    /// ERU0 Register structure
    struct Registers {
        volatile uint32_t EXISEL;  ///< Offset: 0x00 - Event Input Select
        volatile uint32_t EXICON[%s];  ///< Offset: 0x10 - Event Input Control
        volatile uint32_t EXOCON[%s];  ///< Offset: 0x20 - Event Output Trigger Control
    };

    /// Peripheral instances
    inline Registers* ERU0 = reinterpret_cast<Registers*>(ERU0_BASE);

    // Bit definitions
    /// EXISEL Register bits
    namespace exisel_bits {
        constexpr uint32_t EXS0A = (2 << 0);  ///< Event Source Select for A0 (ERS0)
        constexpr uint32_t EXS0B = (2 << 2);  ///< Event Source Select for B0 (ERS0)
        constexpr uint32_t EXS1A = (2 << 4);  ///< Event Source Select for A1 (ERS1)
        constexpr uint32_t EXS1B = (2 << 6);  ///< Event Source Select for B1 (ERS1)
        constexpr uint32_t EXS2A = (2 << 8);  ///< Event Source Select for A2 (ERS2)
        constexpr uint32_t EXS2B = (2 << 10);  ///< Event Source Select for B2 (ERS2)
        constexpr uint32_t EXS3A = (2 << 12);  ///< Event Source Select for A3 (ERS3)
        constexpr uint32_t EXS3B = (2 << 14);  ///< Event Source Select for B3 (ERS3)
    }

    /// EXICON[%s] Register bits
    namespace exicon[%s]_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Output Trigger Pulse Enable for ETLx
        constexpr uint32_t LD = (1U << 1);  ///< Rebuild Level Detection for Status Flag for ETLx
        constexpr uint32_t RE = (1U << 2);  ///< Rising Edge Detection Enable ETLx
        constexpr uint32_t FE = (1U << 3);  ///< Falling Edge Detection Enable ETLx
        constexpr uint32_t OCS = (3 << 4);  ///< Output Channel Select for ETLx Output Trigger Pulse
        constexpr uint32_t FL = (1U << 7);  ///< Status Flag for ETLx
        constexpr uint32_t SS = (2 << 8);  ///< Input Source Select for ERSx
        constexpr uint32_t NA = (1U << 10);  ///< Input A Negation Select for ERSx
        constexpr uint32_t NB = (1U << 11);  ///< Input B Negation Select for ERSx
    }

    /// EXOCON[%s] Register bits
    namespace exocon[%s]_bits {
        constexpr uint32_t ISS = (2 << 0);  ///< Internal Trigger Source Selection
        constexpr uint32_t GEEN = (1U << 2);  ///< Gating Event Enable
        constexpr uint32_t PDR = (1U << 3);  ///< Pattern Detection Result Flag
        constexpr uint32_t GP = (2 << 4);  ///< Gating Selection for Pattern Detection Result
        constexpr uint32_t IPEN0 = (1U << 12);  ///< Pattern Detection Enable for ETL0
        constexpr uint32_t IPEN1 = (1U << 13);  ///< Pattern Detection Enable for ETL1
        constexpr uint32_t IPEN2 = (1U << 14);  ///< Pattern Detection Enable for ETL2
        constexpr uint32_t IPEN3 = (1U << 15);  ///< Pattern Detection Enable for ETL3
    }

}

// ============================================================================
// ERU1 Peripheral
// ============================================================================

namespace eru1 {
    /// Base addresses
    constexpr uint32_t ERU1_BASE = 0x40010630;

    /// ERU1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ERU1 = reinterpret_cast<Registers*>(ERU1_BASE);

}

// ============================================================================
// MATH Peripheral
// ============================================================================

namespace math {
    /// Base addresses
    constexpr uint32_t MATH_BASE = 0x40030000;

    /// MATH Register structure
    struct Registers {
        volatile uint32_t GLBCON;  ///< Offset: 0x04 - Global Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t EVIER;  ///< Offset: 0x0C - Event Interrupt Enable Register
        volatile uint32_t EVFR;  ///< Offset: 0x10 - Event Flag Register
        volatile uint32_t EVFSR;  ///< Offset: 0x14 - Event Flag Set Register
        volatile uint32_t EVFCR;  ///< Offset: 0x18 - Event Flag Clear Register
        volatile uint32_t DVD;  ///< Offset: 0x20 - Dividend Register
        volatile uint32_t DVS;  ///< Offset: 0x24 - Divisor Register
        volatile uint32_t QUOT;  ///< Offset: 0x28 - Quotient Register
        volatile uint32_t RMD;  ///< Offset: 0x2C - Remainder Register
        volatile uint32_t DIVST;  ///< Offset: 0x30 - Divider Status Register
        volatile uint32_t DIVCON;  ///< Offset: 0x34 - Divider Control Register
        volatile uint32_t STATC;  ///< Offset: 0x40 - CORDIC Status and Data Control Register
        volatile uint32_t CON;  ///< Offset: 0x44 - CORDIC Control Register
        volatile uint32_t CORDX;  ///< Offset: 0x48 - CORDIC X Data Register
        volatile uint32_t CORDY;  ///< Offset: 0x4C - CORDIC Y Data Register
        volatile uint32_t CORDZ;  ///< Offset: 0x50 - CORDIC Z Data Register
        volatile uint32_t CORRX;  ///< Offset: 0x54 - CORDIC X Result Register
        volatile uint32_t CORRY;  ///< Offset: 0x58 - CORDIC Y Result Register
        volatile uint32_t CORRZ;  ///< Offset: 0x5C - CORDIC Z Result Register
    };

    /// Peripheral instances
    inline Registers* MATH = reinterpret_cast<Registers*>(MATH_BASE);

    // Bit definitions
    /// GLBCON Register bits
    namespace glbcon_bits {
        constexpr uint32_t DVDRC = (3 << 0);  ///< Dividend Register Result Chaining
        constexpr uint32_t DVSRC = (3 << 3);  ///< Divisor Register Result Chaining
        constexpr uint32_t CORDXRC = (2 << 6);  ///< CORDX Register Result Chaining
        constexpr uint32_t CORDYRC = (2 << 9);  ///< CORDY Register Result Chaining
        constexpr uint32_t CORDZRC = (2 << 12);  ///< CORDZ Register Result Chaining
        constexpr uint32_t SUSCFG = (2 << 16);  ///< Suspend Mode Configuration
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// EVIER Register bits
    namespace evier_bits {
        constexpr uint32_t DIVEOCIEN = (1U << 0);  ///< Divider End of Calculation Interrupt Enable
        constexpr uint32_t DIVERRIEN = (1U << 1);  ///< Divider Error Interrupt Enable
        constexpr uint32_t CDEOCIEN = (1U << 2);  ///< CORDIC End of Calculation Interrupt Enable
        constexpr uint32_t CDERRIEN = (1U << 3);  ///< CORDIC Error Interrupt Enable
    }

    /// EVFR Register bits
    namespace evfr_bits {
        constexpr uint32_t DIVEOC = (1U << 0);  ///< Divider End of Calculation Event Flag
        constexpr uint32_t DIVERR = (1U << 1);  ///< Divider Error Event Flag
        constexpr uint32_t CDEOC = (1U << 2);  ///< CORDIC End of Calculation Event Flag
        constexpr uint32_t CDERR = (1U << 3);  ///< CORDIC Error Event Flag
    }

    /// EVFSR Register bits
    namespace evfsr_bits {
        constexpr uint32_t DIVEOCS = (1U << 0);  ///< Divider End of Calculation Event Flag Set
        constexpr uint32_t DIVERRS = (1U << 1);  ///< Divider Error Event Flag Set
        constexpr uint32_t CDEOCS = (1U << 2);  ///< CORDIC Event Flag Set
        constexpr uint32_t CDERRS = (1U << 3);  ///< CORDIC Error Event Flag Set
    }

    /// EVFCR Register bits
    namespace evfcr_bits {
        constexpr uint32_t DIVEOCC = (1U << 0);  ///< Divider End of Calculation Event Flag Clear
        constexpr uint32_t DIVERRC = (1U << 1);  ///< Divider Error Event Flag Clear
        constexpr uint32_t CDEOCC = (1U << 2);  ///< CORDIC End of Calculation Event Flag Clear
        constexpr uint32_t CDERRC = (1U << 3);  ///< CORDIC Error Event Flag Clear
    }

    /// DVD Register bits
    namespace dvd_bits {
        constexpr uint32_t VAL = (32 << 0);  ///< Dividend Value
    }

    /// DVS Register bits
    namespace dvs_bits {
        constexpr uint32_t VAL = (32 << 0);  ///< Divisor Value
    }

    /// QUOT Register bits
    namespace quot_bits {
        constexpr uint32_t VAL = (32 << 0);  ///< Quotient Value
    }

    /// RMD Register bits
    namespace rmd_bits {
        constexpr uint32_t VAL = (32 << 0);  ///< Remainder Value
    }

    /// DIVST Register bits
    namespace divst_bits {
        constexpr uint32_t BSY = (1U << 0);  ///< Busy Indication
    }

    /// DIVCON Register bits
    namespace divcon_bits {
        constexpr uint32_t ST = (1U << 0);  ///< Start Bit
        constexpr uint32_t STMODE = (1U << 1);  ///< Start Mode
        constexpr uint32_t USIGN = (1U << 2);  ///< Unsigned Division Enable
        constexpr uint32_t DIVMODE = (2 << 3);  ///< Division Mode
        constexpr uint32_t QSDIR = (1U << 15);  ///< Quotient Shift Direction
        constexpr uint32_t QSCNT = (5 << 8);  ///< Quotient Shift Count
        constexpr uint32_t DVDSLC = (5 << 16);  ///< Dividend Shift Left Count
        constexpr uint32_t DVSSRC = (5 << 24);  ///< Divisor Shift Right Count
    }

    /// STATC Register bits
    namespace statc_bits {
        constexpr uint32_t BSY = (1U << 0);  ///< Busy Indication
        constexpr uint32_t KEEPX = (1U << 5);  ///< Last X Result as Initial Data for New Calculation
        constexpr uint32_t KEEPY = (1U << 6);  ///< Last Y Result as Initial Data for New Calculation
        constexpr uint32_t KEEPZ = (1U << 7);  ///< Last Z Result as Initial Data for New Calculation
    }

    /// CON Register bits
    namespace con_bits {
        constexpr uint32_t ST = (1U << 0);  ///< Start Calculation
        constexpr uint32_t MODE = (2 << 1);  ///< Operating Mode
        constexpr uint32_t ROTVEC = (1U << 3);  ///< Rotation Vectoring Selection
        constexpr uint32_t ST_MODE = (1U << 4);  ///< Start Method
        constexpr uint32_t X_USIGN = (1U << 5);  ///< Result Data Format for X in Circular Vectoring Mode
        constexpr uint32_t MPS = (2 << 6);  ///< X and Y Magnitude Prescaler
    }

    /// CORDX Register bits
    namespace cordx_bits {
        constexpr uint32_t DATA = (24 << 8);  ///< Initial X Parameter Data
    }

    /// CORDY Register bits
    namespace cordy_bits {
        constexpr uint32_t DATA = (24 << 8);  ///< Initial Y Parameter Data
    }

    /// CORDZ Register bits
    namespace cordz_bits {
        constexpr uint32_t DATA = (24 << 8);  ///< Initial Z Parameter Data
    }

    /// CORRX Register bits
    namespace corrx_bits {
        constexpr uint32_t RESULT = (24 << 8);  ///< X Calculation Result
    }

    /// CORRY Register bits
    namespace corry_bits {
        constexpr uint32_t RESULT = (24 << 8);  ///< Y Calculation Result
    }

    /// CORRZ Register bits
    namespace corrz_bits {
        constexpr uint32_t RESULT = (24 << 8);  ///< Z Calculation Result
    }

}

// ============================================================================
// PAU Peripheral
// ============================================================================

namespace pau {
    /// Base addresses
    constexpr uint32_t PAU_BASE = 0x40000000;

    /// PAU Register structure
    struct Registers {
        volatile uint32_t AVAIL0;  ///< Offset: 0x40 - Peripheral Availability Register 0
        volatile uint32_t AVAIL1;  ///< Offset: 0x44 - Peripheral Availability Register 1
        volatile uint32_t AVAIL2;  ///< Offset: 0x48 - Peripheral Availability Register 2
        volatile uint32_t PRIVDIS0;  ///< Offset: 0x80 - Peripheral Privilege Access Register 0
        volatile uint32_t PRIVDIS1;  ///< Offset: 0x84 - Peripheral Privilege Access Register 1
        volatile uint32_t PRIVDIS2;  ///< Offset: 0x88 - Peripheral Privilege Access Register 2
        volatile uint32_t ROMSIZE;  ///< Offset: 0x400 - ROM Size Register
        volatile uint32_t FLSIZE;  ///< Offset: 0x404 - Flash Size Register
        volatile uint32_t RAM0SIZE;  ///< Offset: 0x410 - RAM0 Size Register
    };

    /// Peripheral instances
    inline Registers* PAU = reinterpret_cast<Registers*>(PAU_BASE);

    // Bit definitions
    /// AVAIL0 Register bits
    namespace avail0_bits {
        constexpr uint32_t AVAIL5 = (1U << 5);  ///< RAM Block 1 Availability Flag
        constexpr uint32_t AVAIL6 = (1U << 6);  ///< RAM Block 2 Availability Flag
        constexpr uint32_t AVAIL7 = (1U << 7);  ///< RAM Block 3 Availability Flag
        constexpr uint32_t AVAIL20 = (1U << 20);  ///< MATH Global SFRs and Divider Availability Flag
        constexpr uint32_t AVAIL21 = (1U << 21);  ///< MATH CORDIC Availability Flag
        constexpr uint32_t AVAIL22 = (1U << 22);  ///< Port 0 Availability Flag
        constexpr uint32_t AVAIL23 = (1U << 23);  ///< Port 1 Availability Flag
        constexpr uint32_t AVAIL24 = (1U << 24);  ///< Port 2 Availability Flag
        constexpr uint32_t AVAIL25 = (1U << 25);  ///< Port 3 Availability Flag
        constexpr uint32_t AVAIL26 = (1U << 26);  ///< Port 4 Availability Flag
    }

    /// AVAIL1 Register bits
    namespace avail1_bits {
        constexpr uint32_t AVAIL0 = (1U << 0);  ///< USIC0 Channel 0 Availability Flag
        constexpr uint32_t AVAIL1 = (1U << 1);  ///< USIC0 Channel 1 Availability Flag
        constexpr uint32_t AVAIL4 = (1U << 4);  ///< PRNG Availability Flag
        constexpr uint32_t AVAIL5 = (1U << 5);  ///< VADC0 Basic SFRs Availability Flag
        constexpr uint32_t AVAIL6 = (1U << 6);  ///< VADC0 Group 0 SFRs Availability Flag
        constexpr uint32_t AVAIL7 = (1U << 7);  ///< VADC0 Group 1 SFRs Availability Flag
        constexpr uint32_t AVAIL8 = (1U << 8);  ///< SHS0 Availability Flag
        constexpr uint32_t AVAIL9 = (1U << 9);  ///< CCU40 kernel SFRs and CC40 Availability Flag
        constexpr uint32_t AVAIL10 = (1U << 10);  ///< CCU40 CC41 Availability Flag
        constexpr uint32_t AVAIL11 = (1U << 11);  ///< CCU40 CC42 Availability Flag
        constexpr uint32_t AVAIL12 = (1U << 12);  ///< CCU40 CC43 Availability Flag
        constexpr uint32_t AVAIL16 = (1U << 16);  ///< USIC1 Channel 0 Availability Flag
        constexpr uint32_t AVAIL17 = (1U << 17);  ///< USIC1 Channel 1 Availability Flag
        constexpr uint32_t AVAIL25 = (1U << 25);  ///< CCU41 kernel SFRs and CC40 Availability Flag
        constexpr uint32_t AVAIL26 = (1U << 26);  ///< CCU41 CC41 Availability Flag
        constexpr uint32_t AVAIL27 = (1U << 27);  ///< CCU41 CC42 Availability Flag
        constexpr uint32_t AVAIL28 = (1U << 28);  ///< CCU41 CC43 Availability Flag
    }

    /// AVAIL2 Register bits
    namespace avail2_bits {
        constexpr uint32_t AVAIL0 = (1U << 0);  ///< CCU80 kernel SFRs and CC80 Availability Flag
        constexpr uint32_t AVAIL1 = (1U << 1);  ///< CCU80 CC81 Availability Flag
        constexpr uint32_t AVAIL2 = (1U << 2);  ///< CCU80 CC82 Availability Flag
        constexpr uint32_t AVAIL3 = (1U << 3);  ///< CCU80 CC83 Availability Flag
        constexpr uint32_t AVAIL12 = (1U << 12);  ///< POSIF0 Availability Flag
        constexpr uint32_t AVAIL15 = (1U << 15);  ///< BCCU0 Availability Flag
        constexpr uint32_t AVAIL16 = (1U << 16);  ///< CCU81 kernel SFRs and CC80 Availability Flag
        constexpr uint32_t AVAIL17 = (1U << 17);  ///< CCU81 CC81 Availability Flag
        constexpr uint32_t AVAIL18 = (1U << 18);  ///< CCU81 CC82 Availability Flag
        constexpr uint32_t AVAIL19 = (1U << 19);  ///< CCU81 CC83 Availability Flag
        constexpr uint32_t AVAIL20 = (1U << 20);  ///< MultiCAN Node 0 and Global SFRs Availability Flag
        constexpr uint32_t AVAIL21 = (1U << 21);  ///< MultiCAN Node 1 Availability Flag
        constexpr uint32_t AVAIL23 = (1U << 23);  ///< MultiCAN Message Object SFRs Availability Flag
        constexpr uint32_t AVAIL28 = (1U << 28);  ///< POSIF1 Availability Flag
        constexpr uint32_t AVAIL29 = (1U << 29);  ///< LEDTS2 Availability Flag
    }

    /// PRIVDIS0 Register bits
    namespace privdis0_bits {
        constexpr uint32_t PDIS2 = (1U << 2);  ///< Flash SFRs Privilege Disable Flag
        constexpr uint32_t PDIS5 = (1U << 5);  ///< RAM Block 1 Privilege Disable Flag
        constexpr uint32_t PDIS6 = (1U << 6);  ///< RAM Block 2 Privilege Disable Flag
        constexpr uint32_t PDIS7 = (1U << 7);  ///< RAM Block 3 Privilege Disable Flag
        constexpr uint32_t PDIS19 = (1U << 19);  ///< WDT Privilege Disable Flag
        constexpr uint32_t PDIS20 = (1U << 20);  ///< MATH Global SFRs and Divider Privilege Disable Flag
        constexpr uint32_t PDIS21 = (1U << 21);  ///< MATH CORDIC Privilege Disable Flag
        constexpr uint32_t PDIS22 = (1U << 22);  ///< Port 0 Privilege Disable Flag
        constexpr uint32_t PDIS23 = (1U << 23);  ///< Port 1 Privilege Disable Flag
        constexpr uint32_t PDIS24 = (1U << 24);  ///< Port 2 Privilege Disable Flag
        constexpr uint32_t PDIS25 = (1U << 25);  ///< Port 3 Privilege Disable Flag
        constexpr uint32_t PDIS26 = (1U << 26);  ///< Port 4 Privilege Disable Flag
    }

    /// PRIVDIS1 Register bits
    namespace privdis1_bits {
        constexpr uint32_t PDIS0 = (1U << 0);  ///< USIC0 Channel 0 Privilege Disable Flag
        constexpr uint32_t PDIS1 = (1U << 1);  ///< USIC0 Channel 1 Privilege Disable Flag
        constexpr uint32_t PDIS5 = (1U << 5);  ///< VADC0 Basic SFRs Privilege Disable Flag
        constexpr uint32_t PDIS6 = (1U << 6);  ///< VADC0 Group 0 SFRs Privilege Disable Flag
        constexpr uint32_t PDIS7 = (1U << 7);  ///< VADC0 Group 1 SFRs Privilege Disable Flag
        constexpr uint32_t PDIS8 = (1U << 8);  ///< SHS0 Privilege Disable Flag
        constexpr uint32_t PDIS9 = (1U << 9);  ///< CC40 and CCU40 Kernel SFRs Privilege Disable Flag
        constexpr uint32_t PDIS10 = (1U << 10);  ///< CCU40 CC41 Privilege Disable Flag
        constexpr uint32_t PDIS11 = (1U << 11);  ///< CCU40 CC42 Privilege Disable Flag
        constexpr uint32_t PDIS12 = (1U << 12);  ///< CCU40 CC43 Privilege Disable Flag
        constexpr uint32_t PDIS16 = (1U << 16);  ///< USIC1 Channel 0 Privilege Disable Flag
        constexpr uint32_t PDIS17 = (1U << 17);  ///< USIC1 Channel 1 Privilege Disable Flag
        constexpr uint32_t PDIS25 = (1U << 25);  ///< CCU41 Kernel SFRs and CC40 Privilege Disable Flag
        constexpr uint32_t PDIS26 = (1U << 26);  ///< CCU41 CC41 Privilege Disable Flag
        constexpr uint32_t PDIS27 = (1U << 27);  ///< CCU41 CC42 Privilege Disable Flag
        constexpr uint32_t PDIS28 = (1U << 28);  ///< CCU41 CC43 Privilege Disable Flag
    }

    /// PRIVDIS2 Register bits
    namespace privdis2_bits {
        constexpr uint32_t PDIS0 = (1U << 0);  ///< CC80 and CCU80 Kernel SFRs Privilege Disable Flag
        constexpr uint32_t PDIS1 = (1U << 1);  ///< CCU80 CC81 Privilege Disable Flag
        constexpr uint32_t PDIS2 = (1U << 2);  ///< CCU80 CC82 Privilege Disable Flag
        constexpr uint32_t PDIS3 = (1U << 3);  ///< CCU80 CC83 Privilege Disable Flag
        constexpr uint32_t PDIS12 = (1U << 12);  ///< POSIF0 Privilege Disable Flag
        constexpr uint32_t PDIS13 = (1U << 13);  ///< LEDTS0 Privilege Disable Flag
        constexpr uint32_t PDIS14 = (1U << 14);  ///< LEDTS1 Privilege Disable Flag
        constexpr uint32_t PDIS15 = (1U << 15);  ///< BCCU0 Privilege Disable Flag
        constexpr uint32_t PDIS16 = (1U << 16);  ///< CCU81 Kernel SFRs and CC80 Privilege Disable Flag
        constexpr uint32_t PDIS17 = (1U << 17);  ///< CCU81 CC81 Privilege Disable Flag
        constexpr uint32_t PDIS18 = (1U << 18);  ///< CCU81 CC82 Privilege Disable Flag
        constexpr uint32_t PDIS19 = (1U << 19);  ///< CCU81 CC83 Privilege Disable Flag
        constexpr uint32_t PDIS20 = (1U << 20);  ///< MultiCAN Node 0 and Global SFRs Privilege Disable Flag
        constexpr uint32_t PDIS21 = (1U << 21);  ///< MultiCAN Node 1 Privilege Disable Flag
        constexpr uint32_t PDIS23 = (1U << 23);  ///< MultiCAN Message Object SFRs Privilege Disable Flag
        constexpr uint32_t PDIS28 = (1U << 28);  ///< POSIF1 Privilege Disable Flag
        constexpr uint32_t PDIS29 = (1U << 29);  ///< LEDTS2 Privilege Disable Flag
    }

    /// ROMSIZE Register bits
    namespace romsize_bits {
        constexpr uint32_t ADDR = (6 << 8);  ///< ROM Size
    }

    /// FLSIZE Register bits
    namespace flsize_bits {
        constexpr uint32_t ADDR = (6 << 12);  ///< Flash Size
    }

    /// RAM0SIZE Register bits
    namespace ram0size_bits {
        constexpr uint32_t ADDR = (5 << 8);  ///< RAM0 Size
    }

}

// ============================================================================
// NVM Peripheral
// ============================================================================

namespace nvm {
    /// Base addresses
    constexpr uint32_t NVM_BASE = 0x40050000;

    /// NVM Register structure
    struct Registers {
        volatile uint32_t NVMSTATUS;  ///< Offset: 0x00 - NVM Status Register
        volatile uint32_t NVMPROG;  ///< Offset: 0x04 - NVM Programming Control Register
        volatile uint32_t NVMCONF;  ///< Offset: 0x08 - NVM Configuration Register
    };

    /// Peripheral instances
    inline Registers* NVM = reinterpret_cast<Registers*>(NVM_BASE);

    // Bit definitions
    /// NVMSTATUS Register bits
    namespace nvmstatus_bits {
        constexpr uint32_t WRPERR = (1U << 6);  ///< Write Protocol Error
        constexpr uint32_t ECC2READ = (1U << 5);  ///< ECC2 Read
        constexpr uint32_t ECC1READ = (1U << 4);  ///< ECC1 Read
        constexpr uint32_t VERR = (2 << 2);  ///< Verify Error
        constexpr uint32_t SLEEP = (1U << 1);  ///< Sleep Mode
        constexpr uint32_t BUSY = (1U << 0);  ///< Busy
    }

    /// NVMPROG Register bits
    namespace nvmprog_bits {
        constexpr uint32_t RSTECC = (1U << 13);  ///< Reset ECC
        constexpr uint32_t RSTVERR = (1U << 12);  ///< Reset Verify Error
        constexpr uint32_t ACTION = (8 << 0);  ///< ACTION: [VERIFY, ONE_SHOT, OPTYPE]
    }

    /// NVMCONF Register bits
    namespace nvmconf_bits {
        constexpr uint32_t NVM_ON = (1U << 15);  ///< NVM On
        constexpr uint32_t INT_ON = (1U << 14);  ///< Interrupt On
        constexpr uint32_t SECPROT = (8 << 4);  ///< Sector Protection
        constexpr uint32_t HRLEV = (2 << 1);  ///< Hardread Level
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40020000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - WDT Module ID Register
        volatile uint32_t CTR;  ///< Offset: 0x04 - WDT Control Register
        volatile uint32_t SRV;  ///< Offset: 0x08 - WDT Service Register
        volatile uint32_t TIM;  ///< Offset: 0x0C - WDT Timer Register
        volatile uint32_t WLB;  ///< Offset: 0x10 - WDT Window Lower Bound Register
        volatile uint32_t WUB;  ///< Offset: 0x14 - WDT Window Upper Bound Register
        volatile uint32_t WDTSTS;  ///< Offset: 0x18 - WDT Status Register
        volatile uint32_t WDTCLR;  ///< Offset: 0x1C - WDT Clear Register
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t ENB = (1U << 0);  ///< Enable
        constexpr uint32_t PRE = (1U << 1);  ///< Pre-warning
        constexpr uint32_t DSP = (1U << 4);  ///< Debug Suspend
        constexpr uint32_t SPW = (8 << 8);  ///< Service Indication Pulse Width
    }

    /// SRV Register bits
    namespace srv_bits {
        constexpr uint32_t SRV = (32 << 0);  ///< Service
    }

    /// TIM Register bits
    namespace tim_bits {
        constexpr uint32_t TIM = (32 << 0);  ///< Timer Value
    }

    /// WLB Register bits
    namespace wlb_bits {
        constexpr uint32_t WLB = (32 << 0);  ///< Window Lower Bound
    }

    /// WUB Register bits
    namespace wub_bits {
        constexpr uint32_t WUB = (32 << 0);  ///< Window Upper Bound
    }

    /// WDTSTS Register bits
    namespace wdtsts_bits {
        constexpr uint32_t ALMS = (1U << 0);  ///< Pre-warning Alarm
    }

    /// WDTCLR Register bits
    namespace wdtclr_bits {
        constexpr uint32_t ALMC = (1U << 0);  ///< Pre-warning Alarm
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40010A00;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - RTC Module ID Register
        volatile uint32_t CTR;  ///< Offset: 0x04 - RTC Control Register
        volatile uint32_t RAWSTAT;  ///< Offset: 0x08 - RTC Raw Service Request Register
        volatile uint32_t STSSR;  ///< Offset: 0x0C - RTC Service Request Status Register
        volatile uint32_t MSKSR;  ///< Offset: 0x10 - RTC Service Request Mask Register
        volatile uint32_t CLRSR;  ///< Offset: 0x14 - RTC Clear Service Request Register
        volatile uint32_t ATIM0;  ///< Offset: 0x18 - RTC Alarm Time Register 0
        volatile uint32_t ATIM1;  ///< Offset: 0x1C - RTC Alarm Time Register 1
        volatile uint32_t TIM0;  ///< Offset: 0x20 - RTC Time Register 0
        volatile uint32_t TIM1;  ///< Offset: 0x24 - RTC Time Register 1
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t ENB = (1U << 0);  ///< RTC Module Enable
        constexpr uint32_t SUS = (1U << 1);  ///< Debug Suspend Control
        constexpr uint32_t DIV = (16 << 16);  ///< Divider Value
    }

    /// RAWSTAT Register bits
    namespace rawstat_bits {
        constexpr uint32_t RPSE = (1U << 0);  ///< Raw Periodic Seconds Service Request
        constexpr uint32_t RPMI = (1U << 1);  ///< Raw Periodic Minutes Service Request
        constexpr uint32_t RPHO = (1U << 2);  ///< Raw Periodic Hours Service Request
        constexpr uint32_t RPDA = (1U << 3);  ///< Raw Periodic Days Service Request
        constexpr uint32_t RPMO = (1U << 5);  ///< Raw Periodic Months Service Request
        constexpr uint32_t RPYE = (1U << 6);  ///< Raw Periodic Years Service Request
        constexpr uint32_t RAI = (1U << 8);  ///< Alarm Service Request
    }

    /// STSSR Register bits
    namespace stssr_bits {
        constexpr uint32_t SPSE = (1U << 0);  ///< Periodic Seconds Service Request Status after masking
        constexpr uint32_t SPMI = (1U << 1);  ///< Periodic Minutes Service Request Status after masking
        constexpr uint32_t SPHO = (1U << 2);  ///< Periodic Hours Service Request Status after masking
        constexpr uint32_t SPDA = (1U << 3);  ///< Periodic Days Service Request Status after masking
        constexpr uint32_t SPMO = (1U << 5);  ///< Periodic Months Service Request Status after masking
        constexpr uint32_t SPYE = (1U << 6);  ///< Periodic Years Service Request Status after masking
        constexpr uint32_t SAI = (1U << 8);  ///< Alarm Service Request Status after masking
    }

    /// MSKSR Register bits
    namespace msksr_bits {
        constexpr uint32_t MPSE = (1U << 0);  ///< Periodic Seconds Interrupt Mask
        constexpr uint32_t MPMI = (1U << 1);  ///< Periodic Minutes Interrupt Mask
        constexpr uint32_t MPHO = (1U << 2);  ///< Periodic Hours Interrupt Mask
        constexpr uint32_t MPDA = (1U << 3);  ///< Periodic Days Interrupt Mask
        constexpr uint32_t MPMO = (1U << 5);  ///< Periodic Months Interrupt Mask
        constexpr uint32_t MPYE = (1U << 6);  ///< Periodic Years Interrupt Mask
        constexpr uint32_t MAI = (1U << 8);  ///< Alarm Interrupt Mask
    }

    /// CLRSR Register bits
    namespace clrsr_bits {
        constexpr uint32_t RPSE = (1U << 0);  ///< Raw Periodic Seconds Interrupt Clear
        constexpr uint32_t RPMI = (1U << 1);  ///< Raw Periodic Minutes Interrupt Clear
        constexpr uint32_t RPHO = (1U << 2);  ///< Raw Periodic Hours Interrupt Clear
        constexpr uint32_t RPDA = (1U << 3);  ///< Raw Periodic Days Interrupt Clear
        constexpr uint32_t RPMO = (1U << 5);  ///< Raw Periodic Months Interrupt Clear
        constexpr uint32_t RPYE = (1U << 6);  ///< Raw Periodic Years Interrupt Clear
        constexpr uint32_t RAI = (1U << 8);  ///< Raw Alarm Interrupt Clear
    }

    /// ATIM0 Register bits
    namespace atim0_bits {
        constexpr uint32_t ASE = (6 << 0);  ///< Alarm Seconds Compare Value
        constexpr uint32_t AMI = (6 << 8);  ///< Alarm Minutes Compare Value
        constexpr uint32_t AHO = (5 << 16);  ///< Alarm Hours Compare Value
        constexpr uint32_t ADA = (5 << 24);  ///< Alarm Days Compare Value
    }

    /// ATIM1 Register bits
    namespace atim1_bits {
        constexpr uint32_t AMO = (4 << 8);  ///< Alarm Month Compare Value
        constexpr uint32_t AYE = (16 << 16);  ///< Alarm Year Compare Value
    }

    /// TIM0 Register bits
    namespace tim0_bits {
        constexpr uint32_t SE = (6 << 0);  ///< Seconds Time Value
        constexpr uint32_t MI = (6 << 8);  ///< Minutes Time Value
        constexpr uint32_t HO = (5 << 16);  ///< Hours Time Value
        constexpr uint32_t DA = (5 << 24);  ///< Days Time Value
    }

    /// TIM1 Register bits
    namespace tim1_bits {
        constexpr uint32_t DAWE = (3 << 0);  ///< Days of Week Time Value
        constexpr uint32_t MO = (4 << 8);  ///< Month Time Value
        constexpr uint32_t YE = (16 << 16);  ///< Year Time Value
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t PRNG_BASE = 0x48020000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t WORD;  ///< Offset: 0x00 - PRNG Word Register
        volatile uint32_t CHK;  ///< Offset: 0x04 - PRNG Status Check Register
        volatile uint32_t CTRL;  ///< Offset: 0x0C - PRNG Control Register
    };

    /// Peripheral instances
    inline Registers* PRNG = reinterpret_cast<Registers*>(PRNG_BASE);

    // Bit definitions
    /// WORD Register bits
    namespace word_bits {
        constexpr uint32_t RDATA = (16 << 0);  ///< Random Data
    }

    /// CHK Register bits
    namespace chk_bits {
        constexpr uint32_t RDV = (1U << 0);  ///< Random Data / Key Valid Flag
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t KLD = (1U << 3);  ///< Key Load Operation Mode
        constexpr uint32_t RDBS = (2 << 1);  ///< Random Data Block Size
    }

}

// ============================================================================
// LEDTS0 Peripheral
// ============================================================================

namespace ledts0 {
    /// Base addresses
    constexpr uint32_t LEDTS0_BASE = 0x50020000;

    /// LEDTS0 Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - Module Identification Register
        volatile uint32_t GLOBCTL;  ///< Offset: 0x04 - Global Control Register
        volatile uint32_t FNCTL;  ///< Offset: 0x08 - Function Control Register
        volatile uint32_t EVFR;  ///< Offset: 0x0C - Event Flag Register
        volatile uint32_t TSVAL;  ///< Offset: 0x10 - Touch-sense TS-Counter Value
        volatile uint32_t LINE0;  ///< Offset: 0x14 - Line Pattern Register 0
        volatile uint32_t LINE1;  ///< Offset: 0x18 - Line Pattern Register 1
        volatile uint32_t LDCMP0;  ///< Offset: 0x1C - LED Compare Register 0
        volatile uint32_t LDCMP1;  ///< Offset: 0x20 - LED Compare Register 1
        volatile uint32_t TSCMP0;  ///< Offset: 0x24 - Touch-sense Compare Register 0
        volatile uint32_t TSCMP1;  ///< Offset: 0x28 - Touch-sense Compare Register 1
    };

    /// Peripheral instances
    inline Registers* LEDTS0 = reinterpret_cast<Registers*>(LEDTS0_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// GLOBCTL Register bits
    namespace globctl_bits {
        constexpr uint32_t TS_EN = (1U << 0);  ///< Touch-Sense Function Enable
        constexpr uint32_t LD_EN = (1U << 1);  ///< LED Function Enable
        constexpr uint32_t CMTR = (1U << 2);  ///< Clock Master Disable
        constexpr uint32_t ENSYNC = (1U << 3);  ///< Enable Autoscan Time Period Synchronization
        constexpr uint32_t SUSCFG = (1U << 8);  ///< Suspend Request Configuration
        constexpr uint32_t MASKVAL = (3 << 9);  ///< Mask Number of LSB Bits for Event Validation
        constexpr uint32_t FENVAL = (1U << 12);  ///< Enable (Extended) Time Frame Validation
        constexpr uint32_t ITS_EN = (1U << 13);  ///< Enable Time Slice Interrupt
        constexpr uint32_t ITF_EN = (1U << 14);  ///< Enable (Extended) Time Frame Interrupt
        constexpr uint32_t ITP_EN = (1U << 15);  ///< Enable Autoscan Time Period Interrupt
        constexpr uint32_t CLK_PS = (16 << 16);  ///< LEDTS-Counter Clock Pre-Scale Factor
    }

    /// FNCTL Register bits
    namespace fnctl_bits {
        constexpr uint32_t PADT = (3 << 0);  ///< Touch-Sense TSIN Pad Turn
        constexpr uint32_t PADTSW = (1U << 3);  ///< Software Control for Touch-Sense Pad Turn
        constexpr uint32_t EPULL = (1U << 4);  ///< Enable External Pull-up Configuration on Pin COLA
        constexpr uint32_t FNCOL = (3 << 5);  ///< Previous Active Function/LED Column Status
        constexpr uint32_t ACCCNT = (4 << 16);  ///< Accumulate Count on Touch-Sense Input
        constexpr uint32_t TSCCMP = (1U << 20);  ///< Common Compare Enable for Touch-Sense
        constexpr uint32_t TSOEXT = (2 << 21);  ///< Extension for Touch-Sense Output for Pin-Low-Level
        constexpr uint32_t TSCTRR = (1U << 23);  ///< TS-Counter Auto Reset
        constexpr uint32_t TSCTRSAT = (1U << 24);  ///< Saturation of TS-Counter
        constexpr uint32_t NR_TSIN = (3 << 25);  ///< Number of Touch-Sense Input
        constexpr uint32_t COLLEV = (1U << 28);  ///< Active Level of LED Column
        constexpr uint32_t NR_LEDCOL = (3 << 29);  ///< Number of LED Columns
    }

    /// EVFR Register bits
    namespace evfr_bits {
        constexpr uint32_t TSF = (1U << 0);  ///< Time Slice Interrupt Flag
        constexpr uint32_t TFF = (1U << 1);  ///< (Extended) Time Frame Interrupt Flag
        constexpr uint32_t TPF = (1U << 2);  ///< Autoscan Time Period Interrupt Flag
        constexpr uint32_t TSCTROVF = (1U << 3);  ///< TS-Counter Overflow Indication
        constexpr uint32_t CTSF = (1U << 16);  ///< Clear Time Slice Interrupt Flag
        constexpr uint32_t CTFF = (1U << 17);  ///< Clear (Extended) Time Frame Interrupt Flag
        constexpr uint32_t CTPF = (1U << 18);  ///< Clear Autoscan Time Period Interrupt Flag
    }

    /// TSVAL Register bits
    namespace tsval_bits {
        constexpr uint32_t TSCTRVALR = (16 << 0);  ///< Shadow TS-Counter Value (Read)
        constexpr uint32_t TSCTRVAL = (16 << 16);  ///< TS-Counter Value
    }

    /// LINE0 Register bits
    namespace line0_bits {
        constexpr uint32_t LINE_0 = (8 << 0);  ///< Output on LINE[x]
        constexpr uint32_t LINE_1 = (8 << 8);  ///< Output on LINE[x]
        constexpr uint32_t LINE_2 = (8 << 16);  ///< Output on LINE[x]
        constexpr uint32_t LINE_3 = (8 << 24);  ///< Output on LINE[x]
    }

    /// LINE1 Register bits
    namespace line1_bits {
        constexpr uint32_t LINE_4 = (8 << 0);  ///< Output on LINE[x]
        constexpr uint32_t LINE_5 = (8 << 8);  ///< Output on LINE[x]
        constexpr uint32_t LINE_6 = (8 << 16);  ///< Output on LINE[x]
        constexpr uint32_t LINE_A = (8 << 24);  ///< Output on LINE[x]
    }

    /// LDCMP0 Register bits
    namespace ldcmp0_bits {
        constexpr uint32_t CMP_LD0 = (8 << 0);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD1 = (8 << 8);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD2 = (8 << 16);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD3 = (8 << 24);  ///< Compare Value for LED COL[x]
    }

    /// LDCMP1 Register bits
    namespace ldcmp1_bits {
        constexpr uint32_t CMP_LD4 = (8 << 0);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD5 = (8 << 8);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD6 = (8 << 16);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LDA_TSCOM = (8 << 24);  ///< Compare Value for LED COLA / Common Compare Value for Touch-sense Pad Turns
    }

    /// TSCMP0 Register bits
    namespace tscmp0_bits {
        constexpr uint32_t CMP_TS0 = (8 << 0);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS1 = (8 << 8);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS2 = (8 << 16);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS3 = (8 << 24);  ///< Compare Value for Touch-Sense TSIN[x]
    }

    /// TSCMP1 Register bits
    namespace tscmp1_bits {
        constexpr uint32_t CMP_TS4 = (8 << 0);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS5 = (8 << 8);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS6 = (8 << 16);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS7 = (8 << 24);  ///< Compare Value for Touch-Sense TSIN[x]
    }

}

// ============================================================================
// LEDTS1 Peripheral
// ============================================================================

namespace ledts1 {
    /// Base addresses
    constexpr uint32_t LEDTS1_BASE = 0x50020400;

    /// LEDTS1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* LEDTS1 = reinterpret_cast<Registers*>(LEDTS1_BASE);

}

// ============================================================================
// LEDTS2 Peripheral
// ============================================================================

namespace ledts2 {
    /// Base addresses
    constexpr uint32_t LEDTS2_BASE = 0x50020800;

    /// LEDTS2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* LEDTS2 = reinterpret_cast<Registers*>(LEDTS2_BASE);

}

// ============================================================================
// USIC0 Peripheral
// ============================================================================

namespace usic0 {
    /// Base addresses
    constexpr uint32_t USIC0_BASE = 0x48000008;
    constexpr uint32_t USIC0_CH0_BASE = 0x48000000;
    constexpr uint32_t USIC0_CH1_BASE = 0x48000200;

    /// USIC0 Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - Module Identification Register
    };

    /// Peripheral instances
    inline Registers* USIC0 = reinterpret_cast<Registers*>(USIC0_BASE);
    inline Registers* USIC0_CH0 = reinterpret_cast<Registers*>(USIC0_CH0_BASE);
    inline Registers* USIC0_CH1 = reinterpret_cast<Registers*>(USIC0_CH1_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

}

// ============================================================================
// USIC1 Peripheral
// ============================================================================

namespace usic1 {
    /// Base addresses
    constexpr uint32_t USIC1_BASE = 0x48004008;
    constexpr uint32_t USIC1_CH0_BASE = 0x48004000;
    constexpr uint32_t USIC1_CH1_BASE = 0x48004200;

    /// USIC1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* USIC1 = reinterpret_cast<Registers*>(USIC1_BASE);
    inline Registers* USIC1_CH0 = reinterpret_cast<Registers*>(USIC1_CH0_BASE);
    inline Registers* USIC1_CH1 = reinterpret_cast<Registers*>(USIC1_CH1_BASE);

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN_BASE = 0x50040000;
    constexpr uint32_t CAN_NODE0_BASE = 0x50040200;
    constexpr uint32_t CAN_NODE1_BASE = 0x50040300;
    constexpr uint32_t CAN_MO_BASE = 0x50041000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t CLC;  ///< Offset: 0x00 - CAN Clock Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t FDR;  ///< Offset: 0x0C - CAN Fractional Divider Register
        volatile uint32_t LIST[%s];  ///< Offset: 0x100 - List Register
        volatile uint32_t MSPND[%s];  ///< Offset: 0x140 - Message Pending Register
        volatile uint32_t MSID[%s];  ///< Offset: 0x180 - Message Index Register
        volatile uint32_t MSIMASK;  ///< Offset: 0x1C0 - Message Index Mask Register
        volatile uint32_t PANCTR;  ///< Offset: 0x1C4 - Panel Control Register
        volatile uint32_t MCR;  ///< Offset: 0x1C8 - Module Control Register
        volatile uint32_t MITR;  ///< Offset: 0x1CC - Module Interrupt Trigger Register
    };

    /// Peripheral instances
    inline Registers* CAN = reinterpret_cast<Registers*>(CAN_BASE);
    inline Registers* CAN_NODE0 = reinterpret_cast<Registers*>(CAN_NODE0_BASE);
    inline Registers* CAN_NODE1 = reinterpret_cast<Registers*>(CAN_NODE1_BASE);
    inline Registers* CAN_MO = reinterpret_cast<Registers*>(CAN_MO_BASE);

    // Bit definitions
    /// CLC Register bits
    namespace clc_bits {
        constexpr uint32_t DISR = (1U << 0);  ///< Module Disable Request Bit
        constexpr uint32_t DISS = (1U << 1);  ///< Module Disable Status Bit
        constexpr uint32_t EDIS = (1U << 3);  ///< Sleep Mode Enable Control
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t STEP = (10 << 0);  ///< Step Value
        constexpr uint32_t DM = (2 << 14);  ///< Divider Mode
    }

    /// LIST[%s] Register bits
    namespace list[%s]_bits {
        constexpr uint32_t BEGIN = (8 << 0);  ///< List Begin
        constexpr uint32_t END = (8 << 8);  ///< List End
        constexpr uint32_t SIZE = (8 << 16);  ///< List Size
        constexpr uint32_t EMPTY = (1U << 24);  ///< List Empty Indication
    }

    /// MSPND[%s] Register bits
    namespace mspnd[%s]_bits {
        constexpr uint32_t PND = (32 << 0);  ///< Message Pending
    }

    /// MSID[%s] Register bits
    namespace msid[%s]_bits {
        constexpr uint32_t INDEX = (6 << 0);  ///< Message Pending Index
    }

    /// MSIMASK Register bits
    namespace msimask_bits {
        constexpr uint32_t IM = (32 << 0);  ///< Message Index Mask
    }

    /// PANCTR Register bits
    namespace panctr_bits {
        constexpr uint32_t PANCMD = (8 << 0);  ///< Panel Command
        constexpr uint32_t BUSY = (1U << 8);  ///< Panel Busy Flag
        constexpr uint32_t RBUSY = (1U << 9);  ///< Result Busy Flag
        constexpr uint32_t PANAR1 = (8 << 16);  ///< Panel Argument 1
        constexpr uint32_t PANAR2 = (8 << 24);  ///< Panel Argument 2
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t CLKSEL = (4 << 0);  ///< Baud Rate Logic Clock Select
        constexpr uint32_t MPSEL = (4 << 12);  ///< Message Pending Selector
    }

    /// MITR Register bits
    namespace mitr_bits {
        constexpr uint32_t IT = (8 << 0);  ///< Interrupt Trigger
    }

}

// ============================================================================
// SCU Peripheral
// ============================================================================

namespace scu {
    /// Base addresses
    constexpr uint32_t SCU_GENERAL_BASE = 0x40010000;
    constexpr uint32_t SCU_INTERRUPT_BASE = 0x40010038;
    constexpr uint32_t SCU_CLK_BASE = 0x40010300;
    constexpr uint32_t SCU_RESET_BASE = 0x40010400;
    constexpr uint32_t SCU_ANALOG_BASE = 0x40011000;

    /// SCU Register structure
    struct Registers {
        volatile uint32_t DBGROMID;  ///< Offset: 0x00 - Debug System ROM ID Register
        volatile uint32_t IDCHIP;  ///< Offset: 0x04 - Chip ID Register
        volatile uint32_t ID;  ///< Offset: 0x08 - SCU Module ID Register
        volatile uint32_t SSW0;  ///< Offset: 0x14 - SSW Register 0
        volatile uint32_t PASSWD;  ///< Offset: 0x24 - Password Register
        volatile uint32_t CCUCON;  ///< Offset: 0x30 - CCU Control Register
        volatile uint32_t MIRRSTS;  ///< Offset: 0x48 - Mirror Update Status Register
        volatile uint32_t PMTSR;  ///< Offset: 0x54 - Parity Memory Test Select Register
        volatile uint32_t PFUCR;  ///< Offset: 0x68 - Prefetch Unit Control Register
        volatile uint32_t INTCR0;  ///< Offset: 0x6C - Interrupt Control Register 0
        volatile uint32_t INTCR1;  ///< Offset: 0x70 - Interrupt Control Register 1
        volatile uint32_t STSTAT;  ///< Offset: 0x74 - Startup Status Register
    };

    /// Peripheral instances
    inline Registers* SCU_GENERAL = reinterpret_cast<Registers*>(SCU_GENERAL_BASE);
    inline Registers* SCU_INTERRUPT = reinterpret_cast<Registers*>(SCU_INTERRUPT_BASE);
    inline Registers* SCU_CLK = reinterpret_cast<Registers*>(SCU_CLK_BASE);
    inline Registers* SCU_RESET = reinterpret_cast<Registers*>(SCU_RESET_BASE);
    inline Registers* SCU_ANALOG = reinterpret_cast<Registers*>(SCU_ANALOG_BASE);

    // Bit definitions
    /// DBGROMID Register bits
    namespace dbgromid_bits {
        constexpr uint32_t MANUFID = (11 << 1);  ///< Manufactory Identity
        constexpr uint32_t PARTNO = (16 << 12);  ///< Part Number
        constexpr uint32_t VERSION = (4 << 28);  ///< Product version
    }

    /// IDCHIP Register bits
    namespace idchip_bits {
        constexpr uint32_t IDCHIP = (32 << 0);  ///< CHIP ID
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// SSW0 Register bits
    namespace ssw0_bits {
        constexpr uint32_t DAT = (32 << 0);  ///< SSW Data
    }

    /// PASSWD Register bits
    namespace passwd_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Bit Protection Scheme Control Bits
        constexpr uint32_t PROTS = (1U << 2);  ///< Bit Protection Signal Status Bit
        constexpr uint32_t PASS = (5 << 3);  ///< Password Bits
    }

    /// CCUCON Register bits
    namespace ccucon_bits {
        constexpr uint32_t GSC40 = (1U << 0);  ///< Global Start Control CCU40
        constexpr uint32_t GSC41 = (1U << 1);  ///< Global Start Control CCU41
        constexpr uint32_t GSC80 = (1U << 8);  ///< Global Start Control CCU80
        constexpr uint32_t GSC81 = (1U << 9);  ///< Global Start Control CCU81
    }

    /// MIRRSTS Register bits
    namespace mirrsts_bits {
        constexpr uint32_t RTC_CTR = (1U << 0);  ///< RTC CTR Mirror Register Update Status
        constexpr uint32_t RTC_ATIM0 = (1U << 1);  ///< RTC ATIM0 Mirror Register Update Status
        constexpr uint32_t RTC_ATIM1 = (1U << 2);  ///< RTC ATIM1 Mirror Register Update Status
        constexpr uint32_t RTC_TIM0 = (1U << 3);  ///< RTC TIM0 Mirror Register Update Status
        constexpr uint32_t RTC_TIM1 = (1U << 4);  ///< RTC TIM1 Mirror Register Update Status
    }

    /// PMTSR Register bits
    namespace pmtsr_bits {
        constexpr uint32_t MTENS = (1U << 0);  ///< Parity Test Enable Control for 16kbytes SRAM
    }

    /// PFUCR Register bits
    namespace pfucr_bits {
        constexpr uint32_t PFUBYP = (1U << 0);  ///< Prefetch Unit (PFU) Bypass
    }

    /// INTCR0 Register bits
    namespace intcr0_bits {
        constexpr uint32_t INTSEL0 = (2 << 0);  ///< Interrupt Source Select for Node 0
        constexpr uint32_t INTSEL1 = (2 << 2);  ///< Interrupt Source Select for Node 1
        constexpr uint32_t INTSEL2 = (2 << 4);  ///< Interrupt Source Select for Node 2
        constexpr uint32_t INTSEL3 = (2 << 6);  ///< Interrupt Source Select for Node 3
        constexpr uint32_t INTSEL4 = (2 << 8);  ///< Interrupt Source Select for Node 4
        constexpr uint32_t INTSEL5 = (2 << 10);  ///< Interrupt Source Select for Node 5
        constexpr uint32_t INTSEL6 = (2 << 12);  ///< Interrupt Source Select for Node 6
        constexpr uint32_t INTSEL7 = (2 << 14);  ///< Interrupt Source Select for Node 7
        constexpr uint32_t INTSEL8 = (2 << 16);  ///< Interrupt Source Select for Node 8
        constexpr uint32_t INTSEL9 = (2 << 18);  ///< Interrupt Source Select for Node 9
        constexpr uint32_t INTSEL10 = (2 << 20);  ///< Interrupt Source Select for Node 10
        constexpr uint32_t INTSEL11 = (2 << 22);  ///< Interrupt Source Select for Node 11
        constexpr uint32_t INTSEL12 = (2 << 24);  ///< Interrupt Source Select for Node 12
        constexpr uint32_t INTSEL13 = (2 << 26);  ///< Interrupt Source Select for Node 13
        constexpr uint32_t INTSEL14 = (2 << 28);  ///< Interrupt Source Select for Node 14
        constexpr uint32_t INTSEL15 = (2 << 30);  ///< Interrupt Source Select for Node 15
    }

    /// INTCR1 Register bits
    namespace intcr1_bits {
        constexpr uint32_t INTSEL16 = (2 << 0);  ///< Interrupt Source Select for Node 16
        constexpr uint32_t INTSEL17 = (2 << 2);  ///< Interrupt Source Select for Node 17
        constexpr uint32_t INTSEL18 = (2 << 4);  ///< Interrupt Source Select for Node 18
        constexpr uint32_t INTSEL19 = (2 << 6);  ///< Interrupt Source Select for Node 19
        constexpr uint32_t INTSEL20 = (2 << 8);  ///< Interrupt Source Select for Node 20
        constexpr uint32_t INTSEL21 = (2 << 10);  ///< Interrupt Source Select for Node 21
        constexpr uint32_t INTSEL22 = (2 << 12);  ///< Interrupt Source Select for Node 22
        constexpr uint32_t INTSEL23 = (2 << 14);  ///< Interrupt Source Select for Node 23
        constexpr uint32_t INTSEL24 = (2 << 16);  ///< Interrupt Source Select for Node 24
        constexpr uint32_t INTSEL25 = (2 << 18);  ///< Interrupt Source Select for Node 25
        constexpr uint32_t INTSEL26 = (2 << 20);  ///< Interrupt Source Select for Node 26
        constexpr uint32_t INTSEL27 = (2 << 22);  ///< Interrupt Source Select for Node 27
        constexpr uint32_t INTSEL28 = (2 << 24);  ///< Interrupt Source Select for Node 28
        constexpr uint32_t INTSEL29 = (2 << 26);  ///< Interrupt Source Select for Node 29
        constexpr uint32_t INTSEL30 = (2 << 28);  ///< Interrupt Source Select for Node 30
        constexpr uint32_t INTSEL31 = (2 << 30);  ///< Interrupt Source Select for Node 31
    }

    /// STSTAT Register bits
    namespace ststat_bits {
        constexpr uint32_t HWCON = (2 << 0);  ///< HW Configuration
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t SCU_POWER_BASE = 0x40010200;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t VDESR;  ///< Offset: 0x00 - Voltage Detector Status Register
    };

    /// Peripheral instances
    inline Registers* SCU_POWER = reinterpret_cast<Registers*>(SCU_POWER_BASE);

    // Bit definitions
    /// VDESR Register bits
    namespace vdesr_bits {
        constexpr uint32_t VCLIP = (1U << 0);  ///< VCLIP Indication
        constexpr uint32_t VDDPPW = (1U << 1);  ///< VDDPPW Indication
    }

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMPARATOR_BASE = 0x40010500;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t ORCCTRL;  ///< Offset: 0x00 - Out Of Range Comparator Control Register
        volatile uint32_t ANACMP0;  ///< Offset: 0xB5C - Analog Comparator 0 Control Register
        volatile uint32_t ANACMP1;  ///< Offset: 0xB60 - Analog Comparator 1 Control Register
        volatile uint32_t ANACMP2;  ///< Offset: 0xB64 - Analog Comparator 2 Control Register
        volatile uint32_t ANACMP3;  ///< Offset: 0xB68 - Analog Comparator 3 Control Register
    };

    /// Peripheral instances
    inline Registers* COMPARATOR = reinterpret_cast<Registers*>(COMPARATOR_BASE);

    // Bit definitions
    /// ORCCTRL Register bits
    namespace orcctrl_bits {
        constexpr uint32_t ENORC0 = (1U << 0);  ///< Enable Out of Range Comparator 0
        constexpr uint32_t ENORC1 = (1U << 1);  ///< Enable Out of Range Comparator 1
        constexpr uint32_t ENORC2 = (1U << 2);  ///< Enable Out of Range Comparator 2
        constexpr uint32_t ENORC3 = (1U << 3);  ///< Enable Out of Range Comparator 3
        constexpr uint32_t ENORC4 = (1U << 4);  ///< Enable Out of Range Comparator 4
        constexpr uint32_t ENORC5 = (1U << 5);  ///< Enable Out of Range Comparator 5
        constexpr uint32_t ENORC6 = (1U << 6);  ///< Enable Out of Range Comparator 6
        constexpr uint32_t ENORC7 = (1U << 7);  ///< Enable Out of Range Comparator 7
        constexpr uint32_t CNF0 = (1U << 16);  ///< Out of Range Comparator Flag 0
        constexpr uint32_t CNF1 = (1U << 17);  ///< Out of Range Comparator Flag 1
        constexpr uint32_t CNF2 = (1U << 18);  ///< Out of Range Comparator Flag 2
        constexpr uint32_t CNF3 = (1U << 19);  ///< Out of Range Comparator Flag 3
        constexpr uint32_t CNF4 = (1U << 20);  ///< Out of Range Comparator Flag 4
        constexpr uint32_t CNF5 = (1U << 21);  ///< Out of Range Comparator Flag 5
        constexpr uint32_t CNF6 = (1U << 22);  ///< Out of Range Comparator Flag 6
        constexpr uint32_t CNF7 = (1U << 23);  ///< Out of Range Comparator Flag 7
    }

    /// ANACMP0 Register bits
    namespace anacmp0_bits {
        constexpr uint32_t CMP_EN = (1U << 0);  ///< Comparator enable
        constexpr uint32_t CMP_FLT_OFF = (1U << 1);  ///< Disables comparator filter
        constexpr uint32_t CMP_INV_OUT = (1U << 3);  ///< Inverted Comparator output
        constexpr uint32_t CMP_HYST_ADJ = (2 << 4);  ///< Comparator hysteresis adjust
        constexpr uint32_t ACMP0_SEL = (1U << 6);  ///< Connect ACMP0.INN to ACMP1.INP
        constexpr uint32_t CMP_LPWR = (1U << 8);  ///< Low Power Mode
        constexpr uint32_t CMP_OUT = (1U << 15);  ///< Comparator output monitor bit
    }

    /// ANACMP1 Register bits
    namespace anacmp1_bits {
        constexpr uint32_t CMP_EN = (1U << 0);  ///< Comparator enable
        constexpr uint32_t CMP_FLT_OFF = (1U << 1);  ///< Disables comparator filter
        constexpr uint32_t CMP_INV_OUT = (1U << 3);  ///< Inverted Comparator output
        constexpr uint32_t CMP_HYST_ADJ = (2 << 4);  ///< Comparator hysteresis adjust
        constexpr uint32_t REF_DIV_EN = (1U << 6);  ///< Resistor Divider is enabled and Reference Voltage is applied to ACMP1
        constexpr uint32_t CMP_OUT = (1U << 15);  ///< Comparator output monitor bit
    }

    /// ANACMP2 Register bits
    namespace anacmp2_bits {
        constexpr uint32_t CMP_EN = (1U << 0);  ///< Comparator enable
        constexpr uint32_t CMP_FLT_OFF = (1U << 1);  ///< Disables comparator filter
        constexpr uint32_t CMP_INV_OUT = (1U << 3);  ///< Inverted Comparator output
        constexpr uint32_t CMP_HYST_ADJ = (2 << 4);  ///< Comparator hysteresis adjust
        constexpr uint32_t ACMP2_SEL = (1U << 6);  ///< Connect ACMP2.INP to ACMP1.INP
        constexpr uint32_t CMP_OUT = (1U << 15);  ///< Comparator output monitor bit
    }

    /// ANACMP3 Register bits
    namespace anacmp3_bits {
        constexpr uint32_t CMP_EN = (1U << 0);  ///< Comparator enable
        constexpr uint32_t CMP_FLT_OFF = (1U << 1);  ///< Disables comparator filter
        constexpr uint32_t CMP_INV_OUT = (1U << 3);  ///< Inverted Comparator output
        constexpr uint32_t CMP_HYST_ADJ = (2 << 4);  ///< Comparator hysteresis adjust
        constexpr uint32_t ACMP3_SEL = (1U << 6);  ///< Connect ACMP3.INP to ACMP1.INP
        constexpr uint32_t CMP_OUT = (1U << 15);  ///< Comparator output monitor bit
    }

}

// ============================================================================
// CCU40 Peripheral
// ============================================================================

namespace ccu40 {
    /// Base addresses
    constexpr uint32_t CCU40_BASE = 0x48040000;
    constexpr uint32_t CCU40_CC40_BASE = 0x48040100;
    constexpr uint32_t CCU40_CC41_BASE = 0x48040200;
    constexpr uint32_t CCU40_CC42_BASE = 0x48040300;
    constexpr uint32_t CCU40_CC43_BASE = 0x48040400;

    /// CCU40 Register structure
    struct Registers {
        volatile uint32_t GCTRL;  ///< Offset: 0x00 - Global Control Register
        volatile uint32_t GSTAT;  ///< Offset: 0x04 - Global Status Register
        volatile uint32_t GIDLS;  ///< Offset: 0x08 - Global Idle Set
        volatile uint32_t GIDLC;  ///< Offset: 0x0C - Global Idle Clear
        volatile uint32_t GCSS;  ///< Offset: 0x10 - Global Channel Set
        volatile uint32_t GCSC;  ///< Offset: 0x14 - Global Channel Clear
        volatile uint32_t GCST;  ///< Offset: 0x18 - Global Channel Status
        volatile uint32_t MIDR;  ///< Offset: 0x80 - Module Identification
    };

    /// Peripheral instances
    inline Registers* CCU40 = reinterpret_cast<Registers*>(CCU40_BASE);
    inline Registers* CCU40_CC40 = reinterpret_cast<Registers*>(CCU40_CC40_BASE);
    inline Registers* CCU40_CC41 = reinterpret_cast<Registers*>(CCU40_CC41_BASE);
    inline Registers* CCU40_CC42 = reinterpret_cast<Registers*>(CCU40_CC42_BASE);
    inline Registers* CCU40_CC43 = reinterpret_cast<Registers*>(CCU40_CC43_BASE);

    // Bit definitions
    /// GCTRL Register bits
    namespace gctrl_bits {
        constexpr uint32_t PRBC = (3 << 0);  ///< Prescaler Clear Configuration
        constexpr uint32_t PCIS = (2 << 4);  ///< Prescaler Input Clock Selection
        constexpr uint32_t SUSCFG = (2 << 8);  ///< Suspend Mode Configuration
        constexpr uint32_t MSE0 = (1U << 10);  ///< Slice 0 Multi Channel shadow transfer enable
        constexpr uint32_t MSE1 = (1U << 11);  ///< Slice 1 Multi Channel shadow transfer enable
        constexpr uint32_t MSE2 = (1U << 12);  ///< Slice 2 Multi Channel shadow transfer enable
        constexpr uint32_t MSE3 = (1U << 13);  ///< Slice 3 Multi Channel shadow transfer enable
        constexpr uint32_t MSDE = (2 << 14);  ///< Multi Channel shadow transfer request configuration
    }

    /// GSTAT Register bits
    namespace gstat_bits {
        constexpr uint32_t S0I = (1U << 0);  ///< CC40 IDLE status
        constexpr uint32_t S1I = (1U << 1);  ///< CC41 IDLE status
        constexpr uint32_t S2I = (1U << 2);  ///< CC42 IDLE status
        constexpr uint32_t S3I = (1U << 3);  ///< CC43 IDLE status
        constexpr uint32_t PRB = (1U << 8);  ///< Prescaler Run Bit
    }

    /// GIDLS Register bits
    namespace gidls_bits {
        constexpr uint32_t SS0I = (1U << 0);  ///< CC40 IDLE mode set
        constexpr uint32_t SS1I = (1U << 1);  ///< CC41 IDLE mode set
        constexpr uint32_t SS2I = (1U << 2);  ///< CC42 IDLE mode set
        constexpr uint32_t SS3I = (1U << 3);  ///< CC43 IDLE mode set
        constexpr uint32_t CPRB = (1U << 8);  ///< Prescaler Run Bit Clear
        constexpr uint32_t PSIC = (1U << 9);  ///< Prescaler clear
    }

    /// GIDLC Register bits
    namespace gidlc_bits {
        constexpr uint32_t CS0I = (1U << 0);  ///< CC40 IDLE mode clear
        constexpr uint32_t CS1I = (1U << 1);  ///< CC41 IDLE mode clear
        constexpr uint32_t CS2I = (1U << 2);  ///< CC42 IDLE mode clear
        constexpr uint32_t CS3I = (1U << 3);  ///< CC43 IDLE mode clear
        constexpr uint32_t SPRB = (1U << 8);  ///< Prescaler Run Bit Set
    }

    /// GCSS Register bits
    namespace gcss_bits {
        constexpr uint32_t S0SE = (1U << 0);  ///< Slice 0 shadow transfer set enable
        constexpr uint32_t S0DSE = (1U << 1);  ///< Slice 0 Dither shadow transfer set enable
        constexpr uint32_t S0PSE = (1U << 2);  ///< Slice 0 Prescaler shadow transfer set enable
        constexpr uint32_t S1SE = (1U << 4);  ///< Slice 1 shadow transfer set enable
        constexpr uint32_t S1DSE = (1U << 5);  ///< Slice 1 Dither shadow transfer set enable
        constexpr uint32_t S1PSE = (1U << 6);  ///< Slice 1 Prescaler shadow transfer set enable
        constexpr uint32_t S2SE = (1U << 8);  ///< Slice 2 shadow transfer set enable
        constexpr uint32_t S2DSE = (1U << 9);  ///< Slice 2 Dither shadow transfer set enable
        constexpr uint32_t S2PSE = (1U << 10);  ///< Slice 2 Prescaler shadow transfer set enable
        constexpr uint32_t S3SE = (1U << 12);  ///< Slice 3 shadow transfer set enable
        constexpr uint32_t S3DSE = (1U << 13);  ///< Slice 3 Dither shadow transfer set enable
        constexpr uint32_t S3PSE = (1U << 14);  ///< Slice 3 Prescaler shadow transfer set enable
        constexpr uint32_t S0STS = (1U << 16);  ///< Slice 0 status bit set
        constexpr uint32_t S1STS = (1U << 17);  ///< Slice 1 status bit set
        constexpr uint32_t S2STS = (1U << 18);  ///< Slice 2 status bit set
        constexpr uint32_t S3STS = (1U << 19);  ///< Slice 3 status bit set
    }

    /// GCSC Register bits
    namespace gcsc_bits {
        constexpr uint32_t S0SC = (1U << 0);  ///< Slice 0 shadow transfer clear
        constexpr uint32_t S0DSC = (1U << 1);  ///< Slice 0 Dither shadow transfer clear
        constexpr uint32_t S0PSC = (1U << 2);  ///< Slice 0 Prescaler shadow transfer clear
        constexpr uint32_t S1SC = (1U << 4);  ///< Slice 1 shadow transfer clear
        constexpr uint32_t S1DSC = (1U << 5);  ///< Slice 1 Dither shadow transfer clear
        constexpr uint32_t S1PSC = (1U << 6);  ///< Slice 1 Prescaler shadow transfer clear
        constexpr uint32_t S2SC = (1U << 8);  ///< Slice 2 shadow transfer clear
        constexpr uint32_t S2DSC = (1U << 9);  ///< Slice 2 Dither shadow transfer clear
        constexpr uint32_t S2PSC = (1U << 10);  ///< Slice 2 Prescaler shadow transfer clear
        constexpr uint32_t S3SC = (1U << 12);  ///< Slice 3 shadow transfer clear
        constexpr uint32_t S3DSC = (1U << 13);  ///< Slice 3 Dither shadow transfer clear
        constexpr uint32_t S3PSC = (1U << 14);  ///< Slice 3 Prescaler shadow transfer clear
        constexpr uint32_t S0STC = (1U << 16);  ///< Slice 0 status bit clear
        constexpr uint32_t S1STC = (1U << 17);  ///< Slice 1 status bit clear
        constexpr uint32_t S2STC = (1U << 18);  ///< Slice 2 status bit clear
        constexpr uint32_t S3STC = (1U << 19);  ///< Slice 3 status bit clear
    }

    /// GCST Register bits
    namespace gcst_bits {
        constexpr uint32_t S0SS = (1U << 0);  ///< Slice 0 shadow transfer status
        constexpr uint32_t S0DSS = (1U << 1);  ///< Slice 0 Dither shadow transfer status
        constexpr uint32_t S0PSS = (1U << 2);  ///< Slice 0 Prescaler shadow transfer status
        constexpr uint32_t S1SS = (1U << 4);  ///< Slice 1 shadow transfer status
        constexpr uint32_t S1DSS = (1U << 5);  ///< Slice 1 Dither shadow transfer status
        constexpr uint32_t S1PSS = (1U << 6);  ///< Slice 1 Prescaler shadow transfer status
        constexpr uint32_t S2SS = (1U << 8);  ///< Slice 2 shadow transfer status
        constexpr uint32_t S2DSS = (1U << 9);  ///< Slice 2 Dither shadow transfer status
        constexpr uint32_t S2PSS = (1U << 10);  ///< Slice 2 Prescaler shadow transfer status
        constexpr uint32_t S3SS = (1U << 12);  ///< Slice 3 shadow transfer status
        constexpr uint32_t S3DSS = (1U << 13);  ///< Slice 3 Dither shadow transfer status
        constexpr uint32_t S3PSS = (1U << 14);  ///< Slice 3 Prescaler shadow transfer status
        constexpr uint32_t CC40ST = (1U << 16);  ///< Slice 0 status bit
        constexpr uint32_t CC41ST = (1U << 17);  ///< Slice 1 status bit
        constexpr uint32_t CC42ST = (1U << 18);  ///< Slice 2 status bit
        constexpr uint32_t CC43ST = (1U << 19);  ///< Slice 3 status bit
    }

    /// MIDR Register bits
    namespace midr_bits {
        constexpr uint32_t MODR = (8 << 0);  ///< Module Revision
        constexpr uint32_t MODT = (8 << 8);  ///< Module Type
        constexpr uint32_t MODN = (16 << 16);  ///< Module Number
    }

}

// ============================================================================
// CCU41 Peripheral
// ============================================================================

namespace ccu41 {
    /// Base addresses
    constexpr uint32_t CCU41_BASE = 0x48044000;
    constexpr uint32_t CCU41_CC40_BASE = 0x48044100;
    constexpr uint32_t CCU41_CC41_BASE = 0x48044200;
    constexpr uint32_t CCU41_CC42_BASE = 0x48044300;
    constexpr uint32_t CCU41_CC43_BASE = 0x48044400;

    /// CCU41 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CCU41 = reinterpret_cast<Registers*>(CCU41_BASE);
    inline Registers* CCU41_CC40 = reinterpret_cast<Registers*>(CCU41_CC40_BASE);
    inline Registers* CCU41_CC41 = reinterpret_cast<Registers*>(CCU41_CC41_BASE);
    inline Registers* CCU41_CC42 = reinterpret_cast<Registers*>(CCU41_CC42_BASE);
    inline Registers* CCU41_CC43 = reinterpret_cast<Registers*>(CCU41_CC43_BASE);

}

// ============================================================================
// CCU80 Peripheral
// ============================================================================

namespace ccu80 {
    /// Base addresses
    constexpr uint32_t CCU80_BASE = 0x50000000;
    constexpr uint32_t CCU80_CC80_BASE = 0x50000100;
    constexpr uint32_t CCU80_CC81_BASE = 0x50000200;
    constexpr uint32_t CCU80_CC82_BASE = 0x50000300;
    constexpr uint32_t CCU80_CC83_BASE = 0x50000400;

    /// CCU80 Register structure
    struct Registers {
        volatile uint32_t GCTRL;  ///< Offset: 0x00 - Global Control Register
        volatile uint32_t GSTAT;  ///< Offset: 0x04 - Global Status Register
        volatile uint32_t GIDLS;  ///< Offset: 0x08 - Global Idle Set
        volatile uint32_t GIDLC;  ///< Offset: 0x0C - Global Idle Clear
        volatile uint32_t GCSS;  ///< Offset: 0x10 - Global Channel Set
        volatile uint32_t GCSC;  ///< Offset: 0x14 - Global Channel Clear
        volatile uint32_t GCST;  ///< Offset: 0x18 - Global Channel status
        volatile uint32_t GPCHK;  ///< Offset: 0x1C - Parity Checker Configuration
        volatile uint32_t MIDR;  ///< Offset: 0x80 - Module Identification
    };

    /// Peripheral instances
    inline Registers* CCU80 = reinterpret_cast<Registers*>(CCU80_BASE);
    inline Registers* CCU80_CC80 = reinterpret_cast<Registers*>(CCU80_CC80_BASE);
    inline Registers* CCU80_CC81 = reinterpret_cast<Registers*>(CCU80_CC81_BASE);
    inline Registers* CCU80_CC82 = reinterpret_cast<Registers*>(CCU80_CC82_BASE);
    inline Registers* CCU80_CC83 = reinterpret_cast<Registers*>(CCU80_CC83_BASE);

    // Bit definitions
    /// GCTRL Register bits
    namespace gctrl_bits {
        constexpr uint32_t PRBC = (3 << 0);  ///< Prescaler Clear Configuration
        constexpr uint32_t PCIS = (2 << 4);  ///< Prescaler Input Clock Selection
        constexpr uint32_t SUSCFG = (2 << 8);  ///< Suspend Mode Configuration
        constexpr uint32_t MSE0 = (1U << 10);  ///< Slice 0 Multi Channel shadow transfer enable
        constexpr uint32_t MSE1 = (1U << 11);  ///< Slice 1 Multi Channel shadow transfer enable
        constexpr uint32_t MSE2 = (1U << 12);  ///< Slice 2 Multi Channel shadow transfer enable
        constexpr uint32_t MSE3 = (1U << 13);  ///< Slice 3 Multi Channel shadow transfer enable
        constexpr uint32_t MSDE = (2 << 14);  ///< Multi Channel shadow transfer request configuration
    }

    /// GSTAT Register bits
    namespace gstat_bits {
        constexpr uint32_t S0I = (1U << 0);  ///< CC80 IDLE status
        constexpr uint32_t S1I = (1U << 1);  ///< CC81 IDLE status
        constexpr uint32_t S2I = (1U << 2);  ///< CC82 IDLE status
        constexpr uint32_t S3I = (1U << 3);  ///< CC83 IDLE status
        constexpr uint32_t PRB = (1U << 8);  ///< Prescaler Run Bit
        constexpr uint32_t PCRB = (1U << 10);  ///< Parity Checker Run Bit
    }

    /// GIDLS Register bits
    namespace gidls_bits {
        constexpr uint32_t SS0I = (1U << 0);  ///< CC80 IDLE mode set
        constexpr uint32_t SS1I = (1U << 1);  ///< CC81 IDLE mode set
        constexpr uint32_t SS2I = (1U << 2);  ///< CC82 IDLE mode set
        constexpr uint32_t SS3I = (1U << 3);  ///< CC83 IDLE mode set
        constexpr uint32_t CPRB = (1U << 8);  ///< Prescaler# Run Bit Clear
        constexpr uint32_t PSIC = (1U << 9);  ///< Prescaler clear
        constexpr uint32_t CPCH = (1U << 10);  ///< Parity Checker Run bit clear
    }

    /// GIDLC Register bits
    namespace gidlc_bits {
        constexpr uint32_t CS0I = (1U << 0);  ///< CC80 IDLE mode clear
        constexpr uint32_t CS1I = (1U << 1);  ///< CC81 IDLE mode clear
        constexpr uint32_t CS2I = (1U << 2);  ///< CC82 IDLE mode clear
        constexpr uint32_t CS3I = (1U << 3);  ///< CC83 IDLE mode clear
        constexpr uint32_t SPRB = (1U << 8);  ///< Prescaler Run Bit Set
        constexpr uint32_t SPCH = (1U << 10);  ///< Parity Checker run bit set
    }

    /// GCSS Register bits
    namespace gcss_bits {
        constexpr uint32_t S0SE = (1U << 0);  ///< Slice 0 shadow transfer set enable
        constexpr uint32_t S0DSE = (1U << 1);  ///< Slice 0 Dither shadow transfer set enable
        constexpr uint32_t S0PSE = (1U << 2);  ///< Slice 0 Prescaler shadow transfer set enable
        constexpr uint32_t S1SE = (1U << 4);  ///< Slice 1 shadow transfer set enable
        constexpr uint32_t S1DSE = (1U << 5);  ///< Slice 1 Dither shadow transfer set enable
        constexpr uint32_t S1PSE = (1U << 6);  ///< Slice 1 Prescaler shadow transfer set enable
        constexpr uint32_t S2SE = (1U << 8);  ///< Slice 2 shadow transfer set enable
        constexpr uint32_t S2DSE = (1U << 9);  ///< Slice 2 Dither shadow transfer set enable
        constexpr uint32_t S2PSE = (1U << 10);  ///< Slice 2 Prescaler shadow transfer set enable
        constexpr uint32_t S3SE = (1U << 12);  ///< Slice 3 shadow transfer set enable
        constexpr uint32_t S3DSE = (1U << 13);  ///< Slice 3 Dither shadow transfer set enable
        constexpr uint32_t S3PSE = (1U << 14);  ///< Slice 3 Prescaler shadow transfer set enable
        constexpr uint32_t S0ST1S = (1U << 16);  ///< Slice 0 status bit 1 set
        constexpr uint32_t S1ST1S = (1U << 17);  ///< Slice 1 status bit 1 set
        constexpr uint32_t S2ST1S = (1U << 18);  ///< Slice 2 status bit 1 set
        constexpr uint32_t S3ST1S = (1U << 19);  ///< Slice 3 status bit 1 set
        constexpr uint32_t S0ST2S = (1U << 20);  ///< Slice 0 status bit 2 set
        constexpr uint32_t S1ST2S = (1U << 21);  ///< Slice 1 status bit 2 set
        constexpr uint32_t S2ST2S = (1U << 22);  ///< Slice 2 status bit 2 set
        constexpr uint32_t S3ST2S = (1U << 23);  ///< Slice 3 status bit 2 set
    }

    /// GCSC Register bits
    namespace gcsc_bits {
        constexpr uint32_t S0SC = (1U << 0);  ///< Slice 0 shadow transfer request clear
        constexpr uint32_t S0DSC = (1U << 1);  ///< Slice 0 Dither shadow transfer clear
        constexpr uint32_t S0PSC = (1U << 2);  ///< Slice 0 Prescaler shadow transfer clear
        constexpr uint32_t S1SC = (1U << 4);  ///< Slice 1 shadow transfer clear
        constexpr uint32_t S1DSC = (1U << 5);  ///< Slice 1 Dither shadow transfer clear
        constexpr uint32_t S1PSC = (1U << 6);  ///< Slice 1 Prescaler shadow transfer clear
        constexpr uint32_t S2SC = (1U << 8);  ///< Slice 2 shadow transfer clear
        constexpr uint32_t S2DSC = (1U << 9);  ///< Slice 2 Dither shadow transfer clear
        constexpr uint32_t S2PSC = (1U << 10);  ///< Slice 2 Prescaler shadow transfer clear
        constexpr uint32_t S3SC = (1U << 12);  ///< Slice 3 shadow transfer clear
        constexpr uint32_t S3DSC = (1U << 13);  ///< Slice 3 Dither shadow transfer clear
        constexpr uint32_t S3PSC = (1U << 14);  ///< Slice 3 Prescaler shadow transfer clear
        constexpr uint32_t S0ST1C = (1U << 16);  ///< Slice 0 status bit 1 clear
        constexpr uint32_t S1ST1C = (1U << 17);  ///< Slice 1 status bit 1 clear
        constexpr uint32_t S2ST1C = (1U << 18);  ///< Slice 2 status bit 1 clear
        constexpr uint32_t S3ST1C = (1U << 19);  ///< Slice 3 status bit 1 clear
        constexpr uint32_t S0ST2C = (1U << 20);  ///< Slice 0 status bit 2 clear
        constexpr uint32_t S1ST2C = (1U << 21);  ///< Slice 1 status bit 2 clear
        constexpr uint32_t S2ST2C = (1U << 22);  ///< Slice 2 status bit 2 clear
        constexpr uint32_t S3ST2C = (1U << 23);  ///< Slice 3 status bit 2 clear
    }

    /// GCST Register bits
    namespace gcst_bits {
        constexpr uint32_t S0SS = (1U << 0);  ///< Slice 0 shadow transfer status
        constexpr uint32_t S0DSS = (1U << 1);  ///< Slice 0 Dither shadow transfer status
        constexpr uint32_t S0PSS = (1U << 2);  ///< Slice 0 Prescaler shadow transfer status
        constexpr uint32_t S1SS = (1U << 4);  ///< Slice 1 shadow transfer status
        constexpr uint32_t S1DSS = (1U << 5);  ///< Slice 1 Dither shadow transfer status
        constexpr uint32_t S1PSS = (1U << 6);  ///< Slice 1 Prescaler shadow transfer status
        constexpr uint32_t S2SS = (1U << 8);  ///< Slice 2 shadow transfer status
        constexpr uint32_t S2DSS = (1U << 9);  ///< Slice 2 Dither shadow transfer status
        constexpr uint32_t S2PSS = (1U << 10);  ///< Slice 2 Prescaler shadow transfer status
        constexpr uint32_t S3SS = (1U << 12);  ///< Slice 3 shadow transfer status
        constexpr uint32_t S3DSS = (1U << 13);  ///< Slice 3 Dither shadow transfer status
        constexpr uint32_t S3PSS = (1U << 14);  ///< Slice 3 Prescaler shadow transfer status
        constexpr uint32_t CC80ST1 = (1U << 16);  ///< Slice 0 compare channel 1 status bit
        constexpr uint32_t CC81ST1 = (1U << 17);  ///< Slice 1 compare channel 1 status bit
        constexpr uint32_t CC82ST1 = (1U << 18);  ///< Slice 2 compare channel 1 status bit
        constexpr uint32_t CC83ST1 = (1U << 19);  ///< Slice 3 compare channel 1 status bit
        constexpr uint32_t CC80ST2 = (1U << 20);  ///< Slice 0 compare channel 2 status bit
        constexpr uint32_t CC81ST2 = (1U << 21);  ///< Slice 1 compare channel 2 status bit
        constexpr uint32_t CC82ST2 = (1U << 22);  ///< Slice 2 compare channel 2 status bit
        constexpr uint32_t CC83ST2 = (1U << 23);  ///< Slice 3 compare channel 2 status bit
    }

    /// GPCHK Register bits
    namespace gpchk_bits {
        constexpr uint32_t PASE = (1U << 0);  ///< Parity Checker Automatic start/stop
        constexpr uint32_t PACS = (2 << 1);  ///< Parity Checker Automatic start/stop selector
        constexpr uint32_t PISEL = (2 << 3);  ///< Driver Input signal selector
        constexpr uint32_t PCDS = (2 << 5);  ///< Parity Checker Delay Input Selector
        constexpr uint32_t PCTS = (1U << 7);  ///< Parity Checker type selector
        constexpr uint32_t PCST = (1U << 15);  ///< Parity Checker XOR status
        constexpr uint32_t PCSEL0 = (4 << 16);  ///< Parity Checker Slice 0 output selection
        constexpr uint32_t PCSEL1 = (4 << 20);  ///< Parity Checker Slice 1 output selection
        constexpr uint32_t PCSEL2 = (4 << 24);  ///< Parity Checker Slice 2 output selection
        constexpr uint32_t PCSEL3 = (4 << 28);  ///< Parity Checker Slice 3 output selection
    }

    /// MIDR Register bits
    namespace midr_bits {
        constexpr uint32_t MODR = (8 << 0);  ///< Module Revision
        constexpr uint32_t MODT = (8 << 8);  ///< Module Type
        constexpr uint32_t MODN = (16 << 16);  ///< Module Number
    }

}

// ============================================================================
// CCU81 Peripheral
// ============================================================================

namespace ccu81 {
    /// Base addresses
    constexpr uint32_t CCU81_BASE = 0x50004000;
    constexpr uint32_t CCU81_CC80_BASE = 0x50004100;
    constexpr uint32_t CCU81_CC81_BASE = 0x50004200;
    constexpr uint32_t CCU81_CC82_BASE = 0x50004300;
    constexpr uint32_t CCU81_CC83_BASE = 0x50004400;

    /// CCU81 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CCU81 = reinterpret_cast<Registers*>(CCU81_BASE);
    inline Registers* CCU81_CC80 = reinterpret_cast<Registers*>(CCU81_CC80_BASE);
    inline Registers* CCU81_CC81 = reinterpret_cast<Registers*>(CCU81_CC81_BASE);
    inline Registers* CCU81_CC82 = reinterpret_cast<Registers*>(CCU81_CC82_BASE);
    inline Registers* CCU81_CC83 = reinterpret_cast<Registers*>(CCU81_CC83_BASE);

}

// ============================================================================
// POSIF0 Peripheral
// ============================================================================

namespace posif0 {
    /// Base addresses
    constexpr uint32_t POSIF0_BASE = 0x50010000;

    /// POSIF0 Register structure
    struct Registers {
        volatile uint32_t PCONF;  ///< Offset: 0x00 - CORDIC Coprocessor configuration
        volatile uint32_t PSUS;  ///< Offset: 0x04 - CORDIC Coprocessor Suspend Config
        volatile uint32_t PRUNS;  ///< Offset: 0x08 - CORDIC Coprocessor Run Bit Set
        volatile uint32_t PRUNC;  ///< Offset: 0x0C - CORDIC Coprocessor Run Bit Clear
        volatile uint32_t PRUN;  ///< Offset: 0x10 - CORDIC Coprocessor Run Bit Status
        volatile uint32_t MIDR;  ///< Offset: 0x20 - Module Identification register
        volatile uint32_t HALP;  ///< Offset: 0x30 - Hall Sensor Patterns
        volatile uint32_t HALPS;  ///< Offset: 0x34 - Hall Sensor Shadow Patterns
        volatile uint32_t MCM;  ///< Offset: 0x40 - Multi-Channel Pattern
        volatile uint32_t MCSM;  ///< Offset: 0x44 - Multi-Channel Shadow Pattern
        volatile uint32_t MCMS;  ///< Offset: 0x48 - Multi-Channel Pattern Control set
        volatile uint32_t MCMC;  ///< Offset: 0x4C - Multi-Channel Pattern Control clear
        volatile uint32_t MCMF;  ///< Offset: 0x50 - Multi-Channel Pattern Control flag
        volatile uint32_t QDC;  ///< Offset: 0x60 - Quadrature Decoder Control
        volatile uint32_t PFLG;  ///< Offset: 0x70 - CORDIC Coprocessor Interrupt Flags
        volatile uint32_t PFLGE;  ///< Offset: 0x74 - CORDIC Coprocessor Interrupt Enable
        volatile uint32_t SPFLG;  ///< Offset: 0x78 - CORDIC Coprocessor Interrupt Set
        volatile uint32_t RPFLG;  ///< Offset: 0x7C - CORDIC Coprocessor Interrupt Clear
        volatile uint32_t PDBG;  ///< Offset: 0x100 - CORDIC Coprocessor Debug register
    };

    /// Peripheral instances
    inline Registers* POSIF0 = reinterpret_cast<Registers*>(POSIF0_BASE);

    // Bit definitions
    /// PCONF Register bits
    namespace pconf_bits {
        constexpr uint32_t FSEL = (2 << 0);  ///< Function Selector
        constexpr uint32_t QDCM = (1U << 2);  ///< Position Decoder Mode selection
        constexpr uint32_t HIDG = (1U << 4);  ///< Idle generation enable
        constexpr uint32_t MCUE = (1U << 5);  ///< Multi-Channel Pattern SW update enable
        constexpr uint32_t INSEL0 = (2 << 8);  ///< PhaseA/Hal input 1 selector
        constexpr uint32_t INSEL1 = (2 << 10);  ///< PhaseB/Hall input 2 selector
        constexpr uint32_t INSEL2 = (2 << 12);  ///< Index/Hall input 3 selector
        constexpr uint32_t DSEL = (1U << 16);  ///< Delay Pin selector
        constexpr uint32_t SPES = (1U << 17);  ///< Edge selector for the sampling trigger
        constexpr uint32_t MSETS = (3 << 18);  ///< Pattern update signal select
        constexpr uint32_t MSES = (1U << 21);  ///< Multi-Channel pattern update trigger edge
        constexpr uint32_t MSYNS = (2 << 22);  ///< PWM synchronization signal selector
        constexpr uint32_t EWIS = (2 << 24);  ///< Wrong Hall Event selection
        constexpr uint32_t EWIE = (1U << 26);  ///< External Wrong Hall Event enable
        constexpr uint32_t EWIL = (1U << 27);  ///< External Wrong Hall Event active level
        constexpr uint32_t LPC = (3 << 28);  ///< Low Pass Filters Configuration
    }

    /// PSUS Register bits
    namespace psus_bits {
        constexpr uint32_t QSUS = (2 << 0);  ///< Quadrature Mode Suspend Config
        constexpr uint32_t MSUS = (2 << 2);  ///< Multi-Channel Mode Suspend Config
    }

    /// PRUNS Register bits
    namespace pruns_bits {
        constexpr uint32_t SRB = (1U << 0);  ///< Set Run bit
    }

    /// PRUNC Register bits
    namespace prunc_bits {
        constexpr uint32_t CRB = (1U << 0);  ///< Clear Run bit
        constexpr uint32_t CSM = (1U << 1);  ///< Clear Current internal status
    }

    /// PRUN Register bits
    namespace prun_bits {
        constexpr uint32_t RB = (1U << 0);  ///< Run Bit
    }

    /// MIDR Register bits
    namespace midr_bits {
        constexpr uint32_t MODR = (8 << 0);  ///< Module Revision
        constexpr uint32_t MODT = (8 << 8);  ///< Module Type
        constexpr uint32_t MODN = (16 << 16);  ///< Module Number
    }

    /// HALP Register bits
    namespace halp_bits {
        constexpr uint32_t HCP = (3 << 0);  ///< Hall Current Pattern
        constexpr uint32_t HEP = (3 << 3);  ///< Hall Expected Pattern
    }

    /// HALPS Register bits
    namespace halps_bits {
        constexpr uint32_t HCPS = (3 << 0);  ///< Shadow Hall Current Pattern
        constexpr uint32_t HEPS = (3 << 3);  ///< Shadow Hall expected Pattern
    }

    /// MCM Register bits
    namespace mcm_bits {
        constexpr uint32_t MCMP = (16 << 0);  ///< Multi-Channel Pattern
    }

    /// MCSM Register bits
    namespace mcsm_bits {
        constexpr uint32_t MCMPS = (16 << 0);  ///< Shadow Multi-Channel Pattern
    }

    /// MCMS Register bits
    namespace mcms_bits {
        constexpr uint32_t MNPS = (1U << 0);  ///< Multi-Channel Pattern Update Enable Set
        constexpr uint32_t STHR = (1U << 1);  ///< Hall Pattern Shadow Transfer Request
        constexpr uint32_t STMR = (1U << 2);  ///< Multi-Channel Shadow Transfer Request
    }

    /// MCMC Register bits
    namespace mcmc_bits {
        constexpr uint32_t MNPC = (1U << 0);  ///< Multi-Channel Pattern Update Enable Clear
        constexpr uint32_t MPC = (1U << 1);  ///< Multi-Channel Pattern clear
    }

    /// MCMF Register bits
    namespace mcmf_bits {
        constexpr uint32_t MSS = (1U << 0);  ///< Multi-Channel Pattern update status
    }

    /// QDC Register bits
    namespace qdc_bits {
        constexpr uint32_t PALS = (1U << 0);  ///< Phase A Level selector
        constexpr uint32_t PBLS = (1U << 1);  ///< Phase B Level selector
        constexpr uint32_t PHS = (1U << 2);  ///< Phase signals swap
        constexpr uint32_t ICM = (2 << 4);  ///< Index Marker generations control
        constexpr uint32_t DVAL = (1U << 8);  ///< Current rotation direction
    }

    /// PFLG Register bits
    namespace pflg_bits {
        constexpr uint32_t CHES = (1U << 0);  ///< Correct Hall Event Status
        constexpr uint32_t WHES = (1U << 1);  ///< Wrong Hall Event Status
        constexpr uint32_t HIES = (1U << 2);  ///< Hall Inputs Update Status
        constexpr uint32_t MSTS = (1U << 4);  ///< Multi-Channel pattern shadow transfer status
        constexpr uint32_t INDXS = (1U << 8);  ///< Quadrature Index Status
        constexpr uint32_t ERRS = (1U << 9);  ///< Quadrature Phase Error Status
        constexpr uint32_t CNTS = (1U << 10);  ///< Quadrature CLK Status
        constexpr uint32_t DIRS = (1U << 11);  ///< Quadrature Direction Change
        constexpr uint32_t PCLKS = (1U << 12);  ///< Quadrature Period Clk Status
    }

    /// PFLGE Register bits
    namespace pflge_bits {
        constexpr uint32_t ECHE = (1U << 0);  ///< Correct Hall Event Enable
        constexpr uint32_t EWHE = (1U << 1);  ///< Wrong Hall Event Enable
        constexpr uint32_t EHIE = (1U << 2);  ///< Hall Input Update Enable
        constexpr uint32_t EMST = (1U << 4);  ///< Multi-Channel pattern shadow transfer enable
        constexpr uint32_t EINDX = (1U << 8);  ///< Quadrature Index Event Enable
        constexpr uint32_t EERR = (1U << 9);  ///< Quadrature Phase Error Enable
        constexpr uint32_t ECNT = (1U << 10);  ///< Quadrature CLK interrupt Enable
        constexpr uint32_t EDIR = (1U << 11);  ///< Quadrature direction change interrupt Enable
        constexpr uint32_t EPCLK = (1U << 12);  ///< Quadrature Period CLK interrupt Enable
        constexpr uint32_t CHESEL = (1U << 16);  ///< Correct Hall Event Service Request Selector
        constexpr uint32_t WHESEL = (1U << 17);  ///< Wrong Hall Event Service Request Selector
        constexpr uint32_t HIESEL = (1U << 18);  ///< Hall Inputs Update Event Service Request Selector
        constexpr uint32_t MSTSEL = (1U << 20);  ///< Multi-Channel pattern Update Event Service Request Selector
        constexpr uint32_t INDSEL = (1U << 24);  ///< Quadrature Index Event Service Request Selector
        constexpr uint32_t ERRSEL = (1U << 25);  ///< Quadrature Phase Error Event Service Request Selector
        constexpr uint32_t CNTSEL = (1U << 26);  ///< Quadrature Clock Event Service Request Selector
        constexpr uint32_t DIRSEL = (1U << 27);  ///< Quadrature Direction Update Event Service Request Selector
        constexpr uint32_t PCLSEL = (1U << 28);  ///< Quadrature Period clock Event Service Request Selector
    }

    /// SPFLG Register bits
    namespace spflg_bits {
        constexpr uint32_t SCHE = (1U << 0);  ///< Correct Hall Event flag set
        constexpr uint32_t SWHE = (1U << 1);  ///< Wrong Hall Event flag set
        constexpr uint32_t SHIE = (1U << 2);  ///< Hall Inputs Update Event flag set
        constexpr uint32_t SMST = (1U << 4);  ///< Multi-Channel Pattern shadow transfer flag set
        constexpr uint32_t SINDX = (1U << 8);  ///< Quadrature Index flag set
        constexpr uint32_t SERR = (1U << 9);  ///< Quadrature Phase Error flag set
        constexpr uint32_t SCNT = (1U << 10);  ///< Quadrature CLK flag set
        constexpr uint32_t SDIR = (1U << 11);  ///< Quadrature Direction flag set
        constexpr uint32_t SPCLK = (1U << 12);  ///< Quadrature period clock flag set
    }

    /// RPFLG Register bits
    namespace rpflg_bits {
        constexpr uint32_t RCHE = (1U << 0);  ///< Correct Hall Event flag clear
        constexpr uint32_t RWHE = (1U << 1);  ///< Wrong Hall Event flag clear
        constexpr uint32_t RHIE = (1U << 2);  ///< Hall Inputs Update Event flag clear
        constexpr uint32_t RMST = (1U << 4);  ///< Multi-Channel Pattern shadow transfer flag clear
        constexpr uint32_t RINDX = (1U << 8);  ///< Quadrature Index flag clear
        constexpr uint32_t RERR = (1U << 9);  ///< Quadrature Phase Error flag clear
        constexpr uint32_t RCNT = (1U << 10);  ///< Quadrature CLK flag clear
        constexpr uint32_t RDIR = (1U << 11);  ///< Quadrature Direction flag clear
        constexpr uint32_t RPCLK = (1U << 12);  ///< Quadrature period clock flag clear
    }

    /// PDBG Register bits
    namespace pdbg_bits {
        constexpr uint32_t QCSV = (2 << 0);  ///< Quadrature Decoder Current state
        constexpr uint32_t QPSV = (2 << 2);  ///< Quadrature Decoder Previous state
        constexpr uint32_t IVAL = (1U << 4);  ///< Current Index Value
        constexpr uint32_t HSP = (3 << 5);  ///< Hall Current Sampled Pattern
        constexpr uint32_t LPP0 = (6 << 8);  ///< Actual count of the Low Pass Filter for POSI0
        constexpr uint32_t LPP1 = (6 << 16);  ///< Actual count of the Low Pass Filter for POSI1
        constexpr uint32_t LPP2 = (6 << 22);  ///< Actual count of the Low Pass Filter for POSI2
    }

}

// ============================================================================
// POSIF1 Peripheral
// ============================================================================

namespace posif1 {
    /// Base addresses
    constexpr uint32_t POSIF1_BASE = 0x50014000;

    /// POSIF1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* POSIF1 = reinterpret_cast<Registers*>(POSIF1_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t VADC_BASE = 0x48030000;
    constexpr uint32_t VADC_G0_BASE = 0x48030400;
    constexpr uint32_t VADC_G1_BASE = 0x48030800;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CLC;  ///< Offset: 0x00 - Clock Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t OCS;  ///< Offset: 0x28 - OCDS Control and Status Register
        volatile uint32_t GLOBCFG;  ///< Offset: 0x80 - Global Configuration Register
        volatile uint32_t ACCPROT0;  ///< Offset: 0x88 - Access Protection Register
        volatile uint32_t ACCPROT1;  ///< Offset: 0x8C - Access Protection Register
        volatile uint32_t GLOBICLASS[%s];  ///< Offset: 0xA0 - Input Class Register, Global
        volatile uint32_t GLOBBOUND;  ///< Offset: 0xB8 - Global Boundary Select Register
        volatile uint32_t GLOBEFLAG;  ///< Offset: 0xE0 - Global Event Flag Register
        volatile uint32_t GLOBEVNP;  ///< Offset: 0x140 - Global Event Node Pointer Register
        volatile uint32_t BRSSEL[%s];  ///< Offset: 0x180 - Background Request Source Channel Select Register
        volatile uint32_t BRSPND[%s];  ///< Offset: 0x1C0 - Background Request Source Pending Register
        volatile uint32_t BRSCTRL;  ///< Offset: 0x200 - Background Request Source Control Register
        volatile uint32_t BRSMR;  ///< Offset: 0x204 - Background Request Source Mode Register
        volatile uint32_t GLOBRCR;  ///< Offset: 0x280 - Global Result Control Register
        volatile uint32_t GLOBRES;  ///< Offset: 0x300 - Global Result Register
        volatile uint32_t GLOBRESD;  ///< Offset: 0x380 - Global Result Register, Debug
        volatile uint32_t EMUXSEL;  ///< Offset: 0x3F0 - External Multiplexer Select Register
    };

    /// Peripheral instances
    inline Registers* VADC = reinterpret_cast<Registers*>(VADC_BASE);
    inline Registers* VADC_G0 = reinterpret_cast<Registers*>(VADC_G0_BASE);
    inline Registers* VADC_G1 = reinterpret_cast<Registers*>(VADC_G1_BASE);

    // Bit definitions
    /// CLC Register bits
    namespace clc_bits {
        constexpr uint32_t DISR = (1U << 0);  ///< Module Disable Request Bit
        constexpr uint32_t DISS = (1U << 1);  ///< Module Disable Status Bit
        constexpr uint32_t EDIS = (1U << 3);  ///< Sleep Mode Enable Control
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// OCS Register bits
    namespace ocs_bits {
        constexpr uint32_t TGS = (2 << 0);  ///< Trigger Set for OTGB0/1
        constexpr uint32_t TGB = (1U << 2);  ///< OTGB0/1 Bus Select
        constexpr uint32_t TG_P = (1U << 3);  ///< TGS, TGB Write Protection
        constexpr uint32_t SUS = (4 << 24);  ///< OCDS Suspend Control
        constexpr uint32_t SUS_P = (1U << 28);  ///< SUS Write Protection
        constexpr uint32_t SUSSTA = (1U << 29);  ///< Suspend State
    }

    /// GLOBCFG Register bits
    namespace globcfg_bits {
        constexpr uint32_t DIVA = (5 << 0);  ///< Divider Factor for the Analog Internal Clock
        constexpr uint32_t DCMSB = (1U << 7);  ///< Double Clock for the MSB Conversion
        constexpr uint32_t DIVD = (2 << 8);  ///< Divider Factor for the Arbiter Clock
        constexpr uint32_t DIVWC = (1U << 15);  ///< Write Control for Divider Parameters
        constexpr uint32_t DPCAL0 = (1U << 16);  ///< Disable Post-Calibration
        constexpr uint32_t DPCAL1 = (1U << 17);  ///< Disable Post-Calibration
        constexpr uint32_t SUCAL = (1U << 31);  ///< Start-Up Calibration
    }

    /// ACCPROT0 Register bits
    namespace accprot0_bits {
        constexpr uint32_t APC0 = (1U << 0);  ///< Access Protection Channel Control, Group 0 - 1
        constexpr uint32_t APC1 = (1U << 1);  ///< Access Protection Channel Control, Group 0 - 1
        constexpr uint32_t APEM = (1U << 15);  ///< Access Protection External Multiplexer
        constexpr uint32_t API0 = (1U << 16);  ///< Access Protection Initialization, Group 0 - 1
        constexpr uint32_t API1 = (1U << 17);  ///< Access Protection Initialization, Group 0 - 1
        constexpr uint32_t APGC = (1U << 31);  ///< Access Protection Global Configuration
    }

    /// ACCPROT1 Register bits
    namespace accprot1_bits {
        constexpr uint32_t APS0 = (1U << 0);  ///< Access Protection Service Request, Group 0 - 1
        constexpr uint32_t APS1 = (1U << 1);  ///< Access Protection Service Request, Group 0 - 1
        constexpr uint32_t APTF = (1U << 15);  ///< Access Protection Test Function
        constexpr uint32_t APR0 = (1U << 16);  ///< Access Protection Result Registers, Group 0 - 1
        constexpr uint32_t APR1 = (1U << 17);  ///< Access Protection Result Registers, Group 0 - 1
    }

    /// GLOBICLASS[%s] Register bits
    namespace globiclass[%s]_bits {
        constexpr uint32_t STCS = (5 << 0);  ///< Sample Time Control for Standard Conversions
        constexpr uint32_t CMS = (3 << 8);  ///< Conversion Mode for Standard Conversions
        constexpr uint32_t STCE = (5 << 16);  ///< Sample Time Control for EMUX Conversions
        constexpr uint32_t CME = (3 << 24);  ///< Conversion Mode for EMUX Conversions
    }

    /// GLOBBOUND Register bits
    namespace globbound_bits {
        constexpr uint32_t BOUNDARY0 = (12 << 0);  ///< Boundary Value 0 for Limit Checking
        constexpr uint32_t BOUNDARY1 = (12 << 16);  ///< Boundary Value 1 for Limit Checking
    }

    /// GLOBEFLAG Register bits
    namespace globeflag_bits {
        constexpr uint32_t SEVGLB = (1U << 0);  ///< Source Event (Background)
        constexpr uint32_t REVGLB = (1U << 8);  ///< Global Result Event
        constexpr uint32_t SEVGLBCLR = (1U << 16);  ///< Clear Source Event (Background)
        constexpr uint32_t REVGLBCLR = (1U << 24);  ///< Clear Global Result Event
    }

    /// GLOBEVNP Register bits
    namespace globevnp_bits {
        constexpr uint32_t SEV0NP = (4 << 0);  ///< Service Request Node Pointer Backgr. Source
        constexpr uint32_t REV0NP = (4 << 16);  ///< Service Request Node Pointer Global Result
    }

    /// BRSSEL[%s] Register bits
    namespace brssel[%s]_bits {
        constexpr uint32_t CHSELG0 = (1U << 0);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG1 = (1U << 1);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG2 = (1U << 2);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG3 = (1U << 3);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG4 = (1U << 4);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG5 = (1U << 5);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG6 = (1U << 6);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG7 = (1U << 7);  ///< Channel Selection Group x
    }

    /// BRSPND[%s] Register bits
    namespace brspnd[%s]_bits {
        constexpr uint32_t CHPNDG0 = (1U << 0);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG1 = (1U << 1);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG2 = (1U << 2);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG3 = (1U << 3);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG4 = (1U << 4);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG5 = (1U << 5);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG6 = (1U << 6);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG7 = (1U << 7);  ///< Channels Pending Group x
    }

    /// BRSCTRL Register bits
    namespace brsctrl_bits {
        constexpr uint32_t SRCRESREG = (4 << 0);  ///< Source-specific Result Register
        constexpr uint32_t XTSEL = (4 << 8);  ///< External Trigger Input Selection
        constexpr uint32_t XTLVL = (1U << 12);  ///< External Trigger Level
        constexpr uint32_t XTMODE = (2 << 13);  ///< Trigger Operating Mode
        constexpr uint32_t XTWC = (1U << 15);  ///< Write Control for Trigger Configuration
        constexpr uint32_t GTSEL = (4 << 16);  ///< Gate Input Selection
        constexpr uint32_t GTLVL = (1U << 20);  ///< Gate Input Level
        constexpr uint32_t GTWC = (1U << 23);  ///< Write Control for Gate Configuration
    }

    /// BRSMR Register bits
    namespace brsmr_bits {
        constexpr uint32_t ENGT = (2 << 0);  ///< Enable Gate
        constexpr uint32_t ENTR = (1U << 2);  ///< Enable External Trigger
        constexpr uint32_t ENSI = (1U << 3);  ///< Enable Source Interrupt
        constexpr uint32_t SCAN = (1U << 4);  ///< Autoscan Enable
        constexpr uint32_t LDM = (1U << 5);  ///< Autoscan Source Load Event Mode
        constexpr uint32_t REQGT = (1U << 7);  ///< Request Gate Level
        constexpr uint32_t CLRPND = (1U << 8);  ///< Clear Pending Bits
        constexpr uint32_t LDEV = (1U << 9);  ///< Generate Load Event
        constexpr uint32_t RPTDIS = (1U << 16);  ///< Repeat Disable
    }

    /// GLOBRCR Register bits
    namespace globrcr_bits {
        constexpr uint32_t DRCTR = (4 << 16);  ///< Data Reduction Control
        constexpr uint32_t WFR = (1U << 24);  ///< Wait-for-Read Mode Enable
        constexpr uint32_t SRGEN = (1U << 31);  ///< Service Request Generation Enable
    }

    /// GLOBRES Register bits
    namespace globres_bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Result of most recent conversion
        constexpr uint32_t GNR = (4 << 16);  ///< Group Number
        constexpr uint32_t CHNR = (5 << 20);  ///< Channel Number
        constexpr uint32_t EMUX = (3 << 25);  ///< External Multiplexer Setting
        constexpr uint32_t CRS = (2 << 28);  ///< Converted Request Source
        constexpr uint32_t FCR = (1U << 30);  ///< Fast Compare Result
        constexpr uint32_t VF = (1U << 31);  ///< Valid Flag
    }

    /// GLOBRESD Register bits
    namespace globresd_bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Result of most recent conversion
        constexpr uint32_t GNR = (4 << 16);  ///< Group Number
        constexpr uint32_t CHNR = (5 << 20);  ///< Channel Number
        constexpr uint32_t EMUX = (3 << 25);  ///< External Multiplexer Setting
        constexpr uint32_t CRS = (2 << 28);  ///< Converted Request Source
        constexpr uint32_t FCR = (1U << 30);  ///< Fast Compare Result
        constexpr uint32_t VF = (1U << 31);  ///< Valid Flag
    }

    /// EMUXSEL Register bits
    namespace emuxsel_bits {
        constexpr uint32_t EMUXGRP0 = (4 << 0);  ///< External Multiplexer Group for Interface x
        constexpr uint32_t EMUXGRP1 = (4 << 4);  ///< External Multiplexer Group for Interface x
    }

}

// ============================================================================
// SHS0 Peripheral
// ============================================================================

namespace shs0 {
    /// Base addresses
    constexpr uint32_t SHS0_BASE = 0x48034000;

    /// SHS0 Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t SHSCFG;  ///< Offset: 0x40 - SHS Configuration Register
        volatile uint32_t STEPCFG;  ///< Offset: 0x44 - Stepper Configuration Register
        volatile uint32_t TIMCFG0;  ///< Offset: 0x80 - Timing Configuration Register 0
        volatile uint32_t TIMCFG1;  ///< Offset: 0x84 - Timing Configuration Register 1
        volatile uint32_t CALCTR;  ///< Offset: 0xBC - Calibration Control Register
        volatile uint32_t CALGC0;  ///< Offset: 0xC0 - Gain Calibration Control Register 0
        volatile uint32_t CALGC1;  ///< Offset: 0xC4 - Gain Calibration Control Register 1
        volatile uint32_t CALOC0;  ///< Offset: 0xE0 - Offset Calibration Control Register 0
        volatile uint32_t CALOC1;  ///< Offset: 0xE4 - Offset Calibration Control Register 1
        volatile uint32_t GNCTR00;  ///< Offset: 0x180 - Gain Control Register 00
        volatile uint32_t GNCTR10;  ///< Offset: 0x190 - Gain Control Register 10
        volatile uint32_t LOOP;  ///< Offset: 0x50 - Loop Control Register
    };

    /// Peripheral instances
    inline Registers* SHS0 = reinterpret_cast<Registers*>(SHS0_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// SHSCFG Register bits
    namespace shscfg_bits {
        constexpr uint32_t DIVS = (4 << 0);  ///< Divider Factor for the SHS Clock
        constexpr uint32_t AREF = (2 << 10);  ///< Analog Calbration Reference Voltage Selection
        constexpr uint32_t ANOFF = (1U << 12);  ///< Analog Converter Power Down Force
        constexpr uint32_t ANRDY = (1U << 14);  ///< Analog Converter Ready
        constexpr uint32_t SCWC = (1U << 15);  ///< Write Control for SHS Configuration
        constexpr uint32_t SP0 = (1U << 16);  ///< Sample Pending on S&H Unit x
        constexpr uint32_t SP1 = (1U << 17);  ///< Sample Pending on S&H Unit x
        constexpr uint32_t TC = (4 << 24);  ///< Test Control
        constexpr uint32_t STATE = (4 << 28);  ///< Current State of Sequencer
    }

    /// STEPCFG Register bits
    namespace stepcfg_bits {
        constexpr uint32_t KSEL0 = (3 << 0);  ///< Kernel Select
        constexpr uint32_t KSEL1 = (3 << 4);  ///< Kernel Select
        constexpr uint32_t KSEL2 = (3 << 8);  ///< Kernel Select
        constexpr uint32_t KSEL3 = (3 << 12);  ///< Kernel Select
        constexpr uint32_t KSEL4 = (3 << 16);  ///< Kernel Select
        constexpr uint32_t KSEL5 = (3 << 20);  ///< Kernel Select
        constexpr uint32_t KSEL6 = (3 << 24);  ///< Kernel Select
        constexpr uint32_t KSEL7 = (3 << 28);  ///< Kernel Select
        constexpr uint32_t SEN0 = (1U << 3);  ///< Step x Enable
        constexpr uint32_t SEN1 = (1U << 7);  ///< Step x Enable
        constexpr uint32_t SEN2 = (1U << 11);  ///< Step x Enable
        constexpr uint32_t SEN3 = (1U << 15);  ///< Step x Enable
        constexpr uint32_t SEN4 = (1U << 19);  ///< Step x Enable
        constexpr uint32_t SEN5 = (1U << 23);  ///< Step x Enable
        constexpr uint32_t SEN6 = (1U << 27);  ///< Step x Enable
        constexpr uint32_t SEN7 = (1U << 31);  ///< Step x Enable
    }

    /// TIMCFG0 Register bits
    namespace timcfg0_bits {
        constexpr uint32_t AT = (1U << 0);  ///< Accelerated Timing
        constexpr uint32_t FCRT = (4 << 4);  ///< Fast Compare Mode Response Time
        constexpr uint32_t SST = (6 << 8);  ///< Short Sample Time
        constexpr uint32_t TGEN = (14 << 16);  ///< Timing Generator
    }

    /// TIMCFG1 Register bits
    namespace timcfg1_bits {
        constexpr uint32_t AT = (1U << 0);  ///< Accelerated Timing
        constexpr uint32_t FCRT = (4 << 4);  ///< Fast Compare Mode Response Time
        constexpr uint32_t SST = (6 << 8);  ///< Short Sample Time
        constexpr uint32_t TGEN = (14 << 16);  ///< Timing Generator
    }

    /// CALCTR Register bits
    namespace calctr_bits {
        constexpr uint32_t CALORD = (1U << 0);  ///< Calibration Order
        constexpr uint32_t CALGNSTC = (6 << 8);  ///< Gain Calibration Sample Time Control
        constexpr uint32_t SUCALVAL = (7 << 16);  ///< Startup Calibration Cycles
        constexpr uint32_t CALMAX = (6 << 24);  ///< Calibration Maximum Timing
        constexpr uint32_t SUCAL = (1U << 31);  ///< Start-Up Calibration
    }

    /// CALGC0 Register bits
    namespace calgc0_bits {
        constexpr uint32_t CALGNVALS = (14 << 0);  ///< Gain Calibration Value, Standard Reference
        constexpr uint32_t GNSWC = (1U << 15);  ///< Gain Calibration Write Control, Standard
        constexpr uint32_t CALGNVALA = (14 << 16);  ///< Gain Calibration Value, Alternate Reference
        constexpr uint32_t GNAWC = (1U << 31);  ///< Gain Calibration Write Control, Alternate
    }

    /// CALGC1 Register bits
    namespace calgc1_bits {
        constexpr uint32_t CALGNVALS = (14 << 0);  ///< Gain Calibration Value, Standard Reference
        constexpr uint32_t GNSWC = (1U << 15);  ///< Gain Calibration Write Control, Standard
        constexpr uint32_t CALGNVALA = (14 << 16);  ///< Gain Calibration Value, Alternate Reference
        constexpr uint32_t GNAWC = (1U << 31);  ///< Gain Calibration Write Control, Alternate
    }

    /// CALOC0 Register bits
    namespace caloc0_bits {
        constexpr uint32_t CALOFFVAL0 = (7 << 0);  ///< Offset Calibration Value for Gain Level z
        constexpr uint32_t CALOFFVAL1 = (7 << 8);  ///< Offset Calibration Value for Gain Level z
        constexpr uint32_t CALOFFVAL2 = (7 << 16);  ///< Offset Calibration Value for Gain Level z
        constexpr uint32_t CALOFFVAL3 = (7 << 24);  ///< Offset Calibration Value for Gain Level z
        constexpr uint32_t OFFWC = (1U << 15);  ///< Offset Calibration Write Control
        constexpr uint32_t DISCAL = (1U << 31);  ///< Disable Calibration
    }

    /// CALOC1 Register bits
    namespace caloc1_bits {
        constexpr uint32_t CALOFFVAL0 = (7 << 0);  ///< Offset Calibration Value for Gain Level z
        constexpr uint32_t CALOFFVAL1 = (7 << 8);  ///< Offset Calibration Value for Gain Level z
        constexpr uint32_t CALOFFVAL2 = (7 << 16);  ///< Offset Calibration Value for Gain Level z
        constexpr uint32_t CALOFFVAL3 = (7 << 24);  ///< Offset Calibration Value for Gain Level z
        constexpr uint32_t OFFWC = (1U << 15);  ///< Offset Calibration Write Control
        constexpr uint32_t DISCAL = (1U << 31);  ///< Disable Calibration
    }

    /// GNCTR00 Register bits
    namespace gnctr00_bits {
        constexpr uint32_t GAIN0 = (4 << 0);  ///< Gain Control 0
        constexpr uint32_t GAIN1 = (4 << 4);  ///< Gain Control 1
        constexpr uint32_t GAIN2 = (4 << 8);  ///< Gain Control 2
        constexpr uint32_t GAIN3 = (4 << 12);  ///< Gain Control 3
        constexpr uint32_t GAIN4 = (4 << 16);  ///< Gain Control 4
        constexpr uint32_t GAIN5 = (4 << 20);  ///< Gain Control 5
        constexpr uint32_t GAIN6 = (4 << 24);  ///< Gain Control 6
        constexpr uint32_t GAIN7 = (4 << 28);  ///< Gain Control 7
    }

    /// GNCTR10 Register bits
    namespace gnctr10_bits {
        constexpr uint32_t GAIN0 = (4 << 0);  ///< Gain Control 0
        constexpr uint32_t GAIN1 = (4 << 4);  ///< Gain Control 1
        constexpr uint32_t GAIN2 = (4 << 8);  ///< Gain Control 2
        constexpr uint32_t GAIN3 = (4 << 12);  ///< Gain Control 3
        constexpr uint32_t GAIN4 = (4 << 16);  ///< Gain Control 4
        constexpr uint32_t GAIN5 = (4 << 20);  ///< Gain Control 5
        constexpr uint32_t GAIN6 = (4 << 24);  ///< Gain Control 6
        constexpr uint32_t GAIN7 = (4 << 28);  ///< Gain Control 7
    }

    /// LOOP Register bits
    namespace loop_bits {
        constexpr uint32_t LPCH0 = (5 << 0);  ///< Loop y Channel
        constexpr uint32_t LPCH1 = (5 << 16);  ///< Loop y Channel
        constexpr uint32_t LPSH0 = (1U << 8);  ///< Loop y Sample&Hold Unit
        constexpr uint32_t LPSH1 = (1U << 24);  ///< Loop y Sample&Hold Unit
        constexpr uint32_t LPEN0 = (1U << 15);  ///< Loop y Enable
        constexpr uint32_t LPEN1 = (1U << 31);  ///< Loop y Enable
    }

}

// ============================================================================
// BCCU0 Peripheral
// ============================================================================

namespace bccu0 {
    /// Base addresses
    constexpr uint32_t BCCU0_BASE = 0x50030000;
    constexpr uint32_t BCCU0_CH0_BASE = 0x5003003C;
    constexpr uint32_t BCCU0_CH1_BASE = 0x50030050;
    constexpr uint32_t BCCU0_CH2_BASE = 0x50030064;
    constexpr uint32_t BCCU0_CH3_BASE = 0x50030078;
    constexpr uint32_t BCCU0_CH4_BASE = 0x5003008C;
    constexpr uint32_t BCCU0_CH5_BASE = 0x500300A0;
    constexpr uint32_t BCCU0_CH6_BASE = 0x500300B4;
    constexpr uint32_t BCCU0_CH7_BASE = 0x500300C8;
    constexpr uint32_t BCCU0_CH8_BASE = 0x500300DC;
    constexpr uint32_t BCCU0_DE0_BASE = 0x5003017C;
    constexpr uint32_t BCCU0_DE1_BASE = 0x50030188;
    constexpr uint32_t BCCU0_DE2_BASE = 0x50030194;

    /// BCCU0 Register structure
    struct Registers {
        volatile uint32_t GLOBCON;  ///< Offset: 0x00 - Global Control
        volatile uint32_t GLOBCLK;  ///< Offset: 0x04 - Global Clock
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification
        volatile uint32_t CHEN;  ///< Offset: 0x0C - Channel Enable
        volatile uint32_t CHOCON;  ///< Offset: 0x10 - Channel Output Control
        volatile uint32_t CHTRIG;  ///< Offset: 0x14 - Channel Trigger
        volatile uint32_t CHSTRCON;  ///< Offset: 0x18 - Channel Shadow Transfer
        volatile uint32_t LTCHOL;  ///< Offset: 0x1C - Last Trigger Channel Output Level
        volatile uint32_t DEEN;  ///< Offset: 0x20 - Dimming Engine Enable
        volatile uint32_t DESTRCON;  ///< Offset: 0x24 - Dimming Shadow Transfer
        volatile uint32_t GLOBDIM;  ///< Offset: 0x28 - Global Dimming Level
        volatile uint32_t EVIER;  ///< Offset: 0x2C - Event Interrupt Enable
        volatile uint32_t EVFR;  ///< Offset: 0x30 - Event Flag
        volatile uint32_t EVFSR;  ///< Offset: 0x34 - Event Flag Set
        volatile uint32_t EVFCR;  ///< Offset: 0x38 - Event Flag Clear
    };

    /// Peripheral instances
    inline Registers* BCCU0 = reinterpret_cast<Registers*>(BCCU0_BASE);
    inline Registers* BCCU0_CH0 = reinterpret_cast<Registers*>(BCCU0_CH0_BASE);
    inline Registers* BCCU0_CH1 = reinterpret_cast<Registers*>(BCCU0_CH1_BASE);
    inline Registers* BCCU0_CH2 = reinterpret_cast<Registers*>(BCCU0_CH2_BASE);
    inline Registers* BCCU0_CH3 = reinterpret_cast<Registers*>(BCCU0_CH3_BASE);
    inline Registers* BCCU0_CH4 = reinterpret_cast<Registers*>(BCCU0_CH4_BASE);
    inline Registers* BCCU0_CH5 = reinterpret_cast<Registers*>(BCCU0_CH5_BASE);
    inline Registers* BCCU0_CH6 = reinterpret_cast<Registers*>(BCCU0_CH6_BASE);
    inline Registers* BCCU0_CH7 = reinterpret_cast<Registers*>(BCCU0_CH7_BASE);
    inline Registers* BCCU0_CH8 = reinterpret_cast<Registers*>(BCCU0_CH8_BASE);
    inline Registers* BCCU0_DE0 = reinterpret_cast<Registers*>(BCCU0_DE0_BASE);
    inline Registers* BCCU0_DE1 = reinterpret_cast<Registers*>(BCCU0_DE1_BASE);
    inline Registers* BCCU0_DE2 = reinterpret_cast<Registers*>(BCCU0_DE2_BASE);

    // Bit definitions
    /// GLOBCON Register bits
    namespace globcon_bits {
        constexpr uint32_t TM = (1U << 0);  ///< Trigger Mode
        constexpr uint32_t TRDEL = (2 << 2);  ///< Trigger Delay
        constexpr uint32_t SUSCFG = (2 << 4);  ///< Suspend Mode Configuration
        constexpr uint32_t TRAPIS = (4 << 6);  ///< Trap Input Pin Selector
        constexpr uint32_t TRAPED = (1U << 10);  ///< Trap Edge
        constexpr uint32_t LTRS = (4 << 12);  ///< Last Trigger Source
        constexpr uint32_t WDMBN = (12 << 16);  ///< Watchdog Maximum Bitnumber
    }

    /// GLOBCLK Register bits
    namespace globclk_bits {
        constexpr uint32_t FCLK_PS = (12 << 0);  ///< Fast Clock Prescaler Factor
        constexpr uint32_t BCS = (1U << 15);  ///< Bit-Clock Selector
        constexpr uint32_t DCLK_PS = (12 << 16);  ///< Dimmer Clock Prescaler Factor
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE0 = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// CHEN Register bits
    namespace chen_bits {
        constexpr uint32_t ECH0 = (1U << 0);  ///< Channel 0 Enable
        constexpr uint32_t ECH1 = (1U << 1);  ///< Channel 1 Enable
        constexpr uint32_t ECH2 = (1U << 2);  ///< Channel 2 Enable
        constexpr uint32_t ECH3 = (1U << 3);  ///< Channel 3 Enable
        constexpr uint32_t ECH4 = (1U << 4);  ///< Channel 4 Enable
        constexpr uint32_t ECH5 = (1U << 5);  ///< Channel 5 Enable
        constexpr uint32_t ECH6 = (1U << 6);  ///< Channel 6 Enable
        constexpr uint32_t ECH7 = (1U << 7);  ///< Channel 7 Enable
        constexpr uint32_t ECH8 = (1U << 8);  ///< Channel 8 Enable
    }

    /// CHOCON Register bits
    namespace chocon_bits {
        constexpr uint32_t CH0OP = (1U << 0);  ///< Channel 0 Output Passive Level
        constexpr uint32_t CH1OP = (1U << 1);  ///< Channel 1 Output Passive Level
        constexpr uint32_t CH2OP = (1U << 2);  ///< Channel 2 Output Passive Level
        constexpr uint32_t CH3OP = (1U << 3);  ///< Channel 3 Output Passive Level
        constexpr uint32_t CH4OP = (1U << 4);  ///< Channel 4 Output Passive Level
        constexpr uint32_t CH5OP = (1U << 5);  ///< Channel 5 Output Passive Level
        constexpr uint32_t CH6OP = (1U << 6);  ///< Channel 6 Output Passive Level
        constexpr uint32_t CH7OP = (1U << 7);  ///< Channel 7 Output Passive Level
        constexpr uint32_t CH8OP = (1U << 8);  ///< Channel 8 Output Passive Level
        constexpr uint32_t CH0TPE = (1U << 16);  ///< Channel 0 Trap Enable
        constexpr uint32_t CH1TPE = (1U << 17);  ///< Channel 1 Trap Enable
        constexpr uint32_t CH2TPE = (1U << 18);  ///< Channel 2 Trap Enable
        constexpr uint32_t CH3TPE = (1U << 19);  ///< Channel 3 Trap Enable
        constexpr uint32_t CH4TPE = (1U << 20);  ///< Channel 4 Trap Enable
        constexpr uint32_t CH5TPE = (1U << 21);  ///< Channel 5 Trap Enable
        constexpr uint32_t CH6TPE = (1U << 22);  ///< Channel 6 Trap Enable
        constexpr uint32_t CH7TPE = (1U << 23);  ///< Channel 7 Trap Enable
        constexpr uint32_t CH8TPE = (1U << 24);  ///< Channel 8 Trap Enable
    }

    /// CHTRIG Register bits
    namespace chtrig_bits {
        constexpr uint32_t ET0 = (1U << 0);  ///< Channel 0 Trigger Enable
        constexpr uint32_t ET1 = (1U << 1);  ///< Channel 1 Trigger Enable
        constexpr uint32_t ET2 = (1U << 2);  ///< Channel 2 Trigger Enable
        constexpr uint32_t ET3 = (1U << 3);  ///< Channel 3 Trigger Enable
        constexpr uint32_t ET4 = (1U << 4);  ///< Channel 4 Trigger Enable
        constexpr uint32_t ET5 = (1U << 5);  ///< Channel 5 Trigger Enable
        constexpr uint32_t ET6 = (1U << 6);  ///< Channel 6 Trigger Enable
        constexpr uint32_t ET7 = (1U << 7);  ///< Channel 7 Trigger Enable
        constexpr uint32_t ET8 = (1U << 8);  ///< Channel 8 Trigger Enable
        constexpr uint32_t TOS0 = (1U << 16);  ///< Channel 0 Trigger Output Select
        constexpr uint32_t TOS1 = (1U << 17);  ///< Channel 1 Trigger Output Select
        constexpr uint32_t TOS2 = (1U << 18);  ///< Channel 2 Trigger Output Select
        constexpr uint32_t TOS3 = (1U << 19);  ///< Channel 3 Trigger Output Select
        constexpr uint32_t TOS4 = (1U << 20);  ///< Channel 4 Trigger Output Select
        constexpr uint32_t TOS5 = (1U << 21);  ///< Channel 5 Trigger Output Select
        constexpr uint32_t TOS6 = (1U << 22);  ///< Channel 6 Trigger Output Select
        constexpr uint32_t TOS7 = (1U << 23);  ///< Channel 7 Trigger Output Select
        constexpr uint32_t TOS8 = (1U << 24);  ///< Channel 8 Trigger Output Select
    }

    /// CHSTRCON Register bits
    namespace chstrcon_bits {
        constexpr uint32_t CH0S = (1U << 0);  ///< Channel 0 Shadow Transfer
        constexpr uint32_t CH1S = (1U << 1);  ///< Channel 1 Shadow Transfer
        constexpr uint32_t CH2S = (1U << 2);  ///< Channel 2 Shadow Transfer
        constexpr uint32_t CH3S = (1U << 3);  ///< Channel 3 Shadow Transfer
        constexpr uint32_t CH4S = (1U << 4);  ///< Channel 4 Shadow Transfer
        constexpr uint32_t CH5S = (1U << 5);  ///< Channel 5 Shadow Transfer
        constexpr uint32_t CH6S = (1U << 6);  ///< Channel 6 Shadow Transfer
        constexpr uint32_t CH7S = (1U << 7);  ///< Channel 7 Shadow Transfer
        constexpr uint32_t CH8S = (1U << 8);  ///< Channel 8 Shadow Transfer
        constexpr uint32_t CH0A = (1U << 16);  ///< Channel 0 Linear Walk Abort
        constexpr uint32_t CH1A = (1U << 17);  ///< Channel 1 Linear Walk Abort
        constexpr uint32_t CH2A = (1U << 18);  ///< Channel 2 Linear Walk Abort
        constexpr uint32_t CH3A = (1U << 19);  ///< Channel 3 Linear Walk Abort
        constexpr uint32_t CH4A = (1U << 20);  ///< Channel 4 Linear Walk Abort
        constexpr uint32_t CH5A = (1U << 21);  ///< Channel 5 Linear Walk Abort
        constexpr uint32_t CH6A = (1U << 22);  ///< Channel 6 Linear Walk Abort
        constexpr uint32_t CH7A = (1U << 23);  ///< Channel 7 Linear Walk Abort
        constexpr uint32_t CH8A = (1U << 24);  ///< Channel 8 Linear Walk Abort
    }

    /// LTCHOL Register bits
    namespace ltchol_bits {
        constexpr uint32_t LTOL0 = (1U << 0);  ///< Last Trigger Channel Output
        constexpr uint32_t LTOL1 = (1U << 1);  ///< Last Trigger Channel Output
        constexpr uint32_t LTOL2 = (1U << 2);  ///< Last Trigger Channel Output
        constexpr uint32_t LTOL3 = (1U << 3);  ///< Last Trigger Channel Output
        constexpr uint32_t LTOL4 = (1U << 4);  ///< Last Trigger Channel Output
        constexpr uint32_t LTOL5 = (1U << 5);  ///< Last Trigger Channel Output
        constexpr uint32_t LTOL6 = (1U << 6);  ///< Last Trigger Channel Output
        constexpr uint32_t LTOL7 = (1U << 7);  ///< Last Trigger Channel Output
        constexpr uint32_t LTOL8 = (1U << 8);  ///< Last Trigger Channel Output
    }

    /// DEEN Register bits
    namespace deen_bits {
        constexpr uint32_t EDE0 = (1U << 0);  ///< Dimming Engine 0 Enable
        constexpr uint32_t EDE1 = (1U << 1);  ///< Dimming Engine 1 Enable
        constexpr uint32_t EDE2 = (1U << 2);  ///< Dimming Engine 2 Enable
    }

    /// DESTRCON Register bits
    namespace destrcon_bits {
        constexpr uint32_t DE0S = (1U << 0);  ///< Dimming Engine 0 Shadow Transfer
        constexpr uint32_t DE1S = (1U << 1);  ///< Dimming Engine 1 Shadow Transfer
        constexpr uint32_t DE2S = (1U << 2);  ///< Dimming Engine 2 Shadow Transfer
        constexpr uint32_t DE0A = (1U << 16);  ///< Dimming Engine 0 Dimming Abort
        constexpr uint32_t DE1A = (1U << 17);  ///< Dimming Engine 1 Dimming Abort
        constexpr uint32_t DE2A = (1U << 18);  ///< Dimming Engine 2 Dimming Abort
    }

    /// GLOBDIM Register bits
    namespace globdim_bits {
        constexpr uint32_t GLOBDIM = (12 << 0);  ///< Global Dimming Level
    }

    /// EVIER Register bits
    namespace evier_bits {
        constexpr uint32_t T0IEN = (1U << 0);  ///< Trigger 0 Interrupt Enable
        constexpr uint32_t T1IEN = (1U << 1);  ///< Trigger 1 Interrupt Enable
        constexpr uint32_t FIEN = (1U << 2);  ///< FIFO Full Interrupt Enable
        constexpr uint32_t EIEN = (1U << 3);  ///< FIFO Empty Interrupt Enable
        constexpr uint32_t TPIEN = (1U << 4);  ///< Trap Interrupt Enable
    }

    /// EVFR Register bits
    namespace evfr_bits {
        constexpr uint32_t T0F = (1U << 0);  ///< Trigger 0 Flag
        constexpr uint32_t T1F = (1U << 1);  ///< Trigger 1 Flag
        constexpr uint32_t FF = (1U << 2);  ///< FIFO Full Flag
        constexpr uint32_t EF = (1U << 3);  ///< FIFO Empty Flag
        constexpr uint32_t TPF = (1U << 4);  ///< Trap Flag
        constexpr uint32_t TPSF = (1U << 6);  ///< Trap State Flag
        constexpr uint32_t TPINL = (1U << 7);  ///< Trap Input Level
    }

    /// EVFSR Register bits
    namespace evfsr_bits {
        constexpr uint32_t T0FS = (1U << 0);  ///< Trigger 0 Flag Set
        constexpr uint32_t T1FS = (1U << 1);  ///< Trigger 1 Flag Set
        constexpr uint32_t FFS = (1U << 2);  ///< FIFO Full Flag Set
        constexpr uint32_t EFS = (1U << 3);  ///< FIFO Empty Flag Set
        constexpr uint32_t TPFS = (1U << 4);  ///< Trap Flag Set
        constexpr uint32_t TPS = (1U << 6);  ///< Trap Set
    }

    /// EVFCR Register bits
    namespace evfcr_bits {
        constexpr uint32_t T0FC = (1U << 0);  ///< Trigger 0 Flag Clear
        constexpr uint32_t T1FC = (1U << 1);  ///< Trigger 1 Flag Clear
        constexpr uint32_t FFC = (1U << 2);  ///< FIFO Full Flag Clear
        constexpr uint32_t EFC = (1U << 3);  ///< FIFO Empty Flag Clear
        constexpr uint32_t TPFC = (1U << 4);  ///< Trap Flag Clear
        constexpr uint32_t TPC = (1U << 6);  ///< Trap Clear
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT0_BASE = 0x40040000;
    constexpr uint32_t PORT1_BASE = 0x40040100;
    constexpr uint32_t PORT2_BASE = 0x40040200;
    constexpr uint32_t PORT3_BASE = 0x40040300;
    constexpr uint32_t PORT4_BASE = 0x40040400;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t OUT;  ///< Offset: 0x00 - Port 0 Output Register
        volatile uint32_t OMR;  ///< Offset: 0x04 - Port 0 Output Modification Register
        volatile uint32_t IOCR0;  ///< Offset: 0x10 - Port 0 Input/Output Control Register 0
        volatile uint32_t IOCR4;  ///< Offset: 0x14 - Port 0 Input/Output Control Register 4
        volatile uint32_t IOCR8;  ///< Offset: 0x18 - Port 0 Input/Output Control Register 8
        volatile uint32_t IOCR12;  ///< Offset: 0x1C - Port 0 Input/Output Control Register 12
        volatile uint32_t PHCR0;  ///< Offset: 0x40 - Port 0 Pad Hysteresis Control Register 0
        volatile uint32_t PHCR1;  ///< Offset: 0x44 - Port 0 Pad Hysteresis Control Register 1
        volatile uint32_t PDISC;  ///< Offset: 0x60 - Port 0 Pin Function Decision Control Register
        volatile uint32_t IN;  ///< Offset: 0x24 - Port 0 Input Register
        volatile uint32_t PPS;  ///< Offset: 0x70 - Port 0 Pin Power Save Register
        volatile uint32_t HWSEL;  ///< Offset: 0x74 - Port 0 Pin Hardware Select Register
    };

    /// Peripheral instances
    inline Registers* PORT0 = reinterpret_cast<Registers*>(PORT0_BASE);
    inline Registers* PORT1 = reinterpret_cast<Registers*>(PORT1_BASE);
    inline Registers* PORT2 = reinterpret_cast<Registers*>(PORT2_BASE);
    inline Registers* PORT3 = reinterpret_cast<Registers*>(PORT3_BASE);
    inline Registers* PORT4 = reinterpret_cast<Registers*>(PORT4_BASE);

    // Bit definitions
    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Port 0 Output Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Port 0 Output Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Port 0 Output Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Port 0 Output Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Port 0 Output Bit 4
        constexpr uint32_t P5 = (1U << 5);  ///< Port 0 Output Bit 5
        constexpr uint32_t P6 = (1U << 6);  ///< Port 0 Output Bit 6
        constexpr uint32_t P7 = (1U << 7);  ///< Port 0 Output Bit 7
        constexpr uint32_t P8 = (1U << 8);  ///< Port 0 Output Bit 8
        constexpr uint32_t P9 = (1U << 9);  ///< Port 0 Output Bit 9
        constexpr uint32_t P10 = (1U << 10);  ///< Port 0 Output Bit 10
        constexpr uint32_t P11 = (1U << 11);  ///< Port 0 Output Bit 11
        constexpr uint32_t P12 = (1U << 12);  ///< Port 0 Output Bit 12
        constexpr uint32_t P13 = (1U << 13);  ///< Port 0 Output Bit 13
        constexpr uint32_t P14 = (1U << 14);  ///< Port 0 Output Bit 14
        constexpr uint32_t P15 = (1U << 15);  ///< Port 0 Output Bit 15
    }

    /// OMR Register bits
    namespace omr_bits {
        constexpr uint32_t PS0 = (1U << 0);  ///< Port 0 Set Bit 0
        constexpr uint32_t PS1 = (1U << 1);  ///< Port 0 Set Bit 1
        constexpr uint32_t PS2 = (1U << 2);  ///< Port 0 Set Bit 2
        constexpr uint32_t PS3 = (1U << 3);  ///< Port 0 Set Bit 3
        constexpr uint32_t PS4 = (1U << 4);  ///< Port 0 Set Bit 4
        constexpr uint32_t PS5 = (1U << 5);  ///< Port 0 Set Bit 5
        constexpr uint32_t PS6 = (1U << 6);  ///< Port 0 Set Bit 6
        constexpr uint32_t PS7 = (1U << 7);  ///< Port 0 Set Bit 7
        constexpr uint32_t PS8 = (1U << 8);  ///< Port 0 Set Bit 8
        constexpr uint32_t PS9 = (1U << 9);  ///< Port 0 Set Bit 9
        constexpr uint32_t PS10 = (1U << 10);  ///< Port 0 Set Bit 10
        constexpr uint32_t PS11 = (1U << 11);  ///< Port 0 Set Bit 11
        constexpr uint32_t PS12 = (1U << 12);  ///< Port 0 Set Bit 12
        constexpr uint32_t PS13 = (1U << 13);  ///< Port 0 Set Bit 13
        constexpr uint32_t PS14 = (1U << 14);  ///< Port 0 Set Bit 14
        constexpr uint32_t PS15 = (1U << 15);  ///< Port 0 Set Bit 15
        constexpr uint32_t PR0 = (1U << 16);  ///< Port 0 Reset Bit 0
        constexpr uint32_t PR1 = (1U << 17);  ///< Port 0 Reset Bit 1
        constexpr uint32_t PR2 = (1U << 18);  ///< Port 0 Reset Bit 2
        constexpr uint32_t PR3 = (1U << 19);  ///< Port 0 Reset Bit 3
        constexpr uint32_t PR4 = (1U << 20);  ///< Port 0 Reset Bit 4
        constexpr uint32_t PR5 = (1U << 21);  ///< Port 0 Reset Bit 5
        constexpr uint32_t PR6 = (1U << 22);  ///< Port 0 Reset Bit 6
        constexpr uint32_t PR7 = (1U << 23);  ///< Port 0 Reset Bit 7
        constexpr uint32_t PR8 = (1U << 24);  ///< Port 0 Reset Bit 8
        constexpr uint32_t PR9 = (1U << 25);  ///< Port 0 Reset Bit 9
        constexpr uint32_t PR10 = (1U << 26);  ///< Port 0 Reset Bit 10
        constexpr uint32_t PR11 = (1U << 27);  ///< Port 0 Reset Bit 11
        constexpr uint32_t PR12 = (1U << 28);  ///< Port 0 Reset Bit 12
        constexpr uint32_t PR13 = (1U << 29);  ///< Port 0 Reset Bit 13
        constexpr uint32_t PR14 = (1U << 30);  ///< Port 0 Reset Bit 14
        constexpr uint32_t PR15 = (1U << 31);  ///< Port 0 Reset Bit 15
    }

    /// IOCR0 Register bits
    namespace iocr0_bits {
        constexpr uint32_t PC0 = (6 << 2);  ///< Port Control for Port n Pin 0 to 3
        constexpr uint32_t PC1 = (6 << 10);  ///< Port Control for Port n Pin 0 to 3
        constexpr uint32_t PC2 = (6 << 18);  ///< Port Control for Port n Pin 0 to 3
        constexpr uint32_t PC3 = (6 << 26);  ///< Port Control for Port n Pin 0 to 3
    }

    /// IOCR4 Register bits
    namespace iocr4_bits {
        constexpr uint32_t PC4 = (6 << 2);  ///< Port Control for Port n Pin 4 to 7
        constexpr uint32_t PC5 = (6 << 10);  ///< Port Control for Port n Pin 4 to 7
        constexpr uint32_t PC6 = (6 << 18);  ///< Port Control for Port n Pin 4 to 7
        constexpr uint32_t PC7 = (6 << 26);  ///< Port Control for Port n Pin 4 to 7
    }

    /// IOCR8 Register bits
    namespace iocr8_bits {
        constexpr uint32_t PC8 = (6 << 2);  ///< Port Control for Port n Pin 8 to 11
        constexpr uint32_t PC9 = (6 << 10);  ///< Port Control for Port n Pin 8 to 11
        constexpr uint32_t PC10 = (6 << 18);  ///< Port Control for Port n Pin 8 to 11
        constexpr uint32_t PC11 = (6 << 26);  ///< Port Control for Port n Pin 8 to 11
    }

    /// IOCR12 Register bits
    namespace iocr12_bits {
        constexpr uint32_t PC12 = (6 << 2);  ///< Port Control for Port n Pin 12 to 15
        constexpr uint32_t PC13 = (6 << 10);  ///< Port Control for Port n Pin 12 to 15
        constexpr uint32_t PC14 = (6 << 18);  ///< Port Control for Port n Pin 12 to 15
        constexpr uint32_t PC15 = (6 << 26);  ///< Port Control for Port n Pin 12 to 15
    }

    /// PHCR0 Register bits
    namespace phcr0_bits {
        constexpr uint32_t PH0 = (1U << 2);  ///< Pad Hysteresis for Pn.0
        constexpr uint32_t PH1 = (1U << 6);  ///< Pad Hysteresis for Pn.1
        constexpr uint32_t PH2 = (1U << 10);  ///< Pad Hysteresis for Pn.2
        constexpr uint32_t PH3 = (1U << 14);  ///< Pad Hysteresis for Pn.3
        constexpr uint32_t PH4 = (1U << 18);  ///< Pad Hysteresis for Pn.4
        constexpr uint32_t PH5 = (1U << 22);  ///< Pad Hysteresis for Pn.5
        constexpr uint32_t PH6 = (1U << 26);  ///< Pad Hysteresis for Pn.6
        constexpr uint32_t PH7 = (1U << 30);  ///< Pad Hysteresis for Pn.7
    }

    /// PHCR1 Register bits
    namespace phcr1_bits {
        constexpr uint32_t PH8 = (1U << 2);  ///< Pad Hysteresis for P0.8
        constexpr uint32_t PH9 = (1U << 6);  ///< Pad Hysteresis for P0.9
        constexpr uint32_t PH10 = (1U << 10);  ///< Pad Hysteresis for P0.10
        constexpr uint32_t PH11 = (1U << 14);  ///< Pad Hysteresis for P0.11
        constexpr uint32_t PH12 = (1U << 18);  ///< Pad Hysteresis for P0.12
        constexpr uint32_t PH13 = (1U << 22);  ///< Pad Hysteresis for P0.13
        constexpr uint32_t PH14 = (1U << 26);  ///< Pad Hysteresis for P0.14
        constexpr uint32_t PH15 = (1U << 30);  ///< Pad Hysteresis for P0.15
    }

    /// PDISC Register bits
    namespace pdisc_bits {
        constexpr uint32_t PDIS0 = (1U << 0);  ///< Pad Disable for Port 0 Pin 0
        constexpr uint32_t PDIS1 = (1U << 1);  ///< Pad Disable for Port 0 Pin 1
        constexpr uint32_t PDIS2 = (1U << 2);  ///< Pad Disable for Port 0 Pin 2
        constexpr uint32_t PDIS3 = (1U << 3);  ///< Pad Disable for Port 0 Pin 3
        constexpr uint32_t PDIS4 = (1U << 4);  ///< Pad Disable for Port 0 Pin 4
        constexpr uint32_t PDIS5 = (1U << 5);  ///< Pad Disable for Port 0 Pin 5
        constexpr uint32_t PDIS6 = (1U << 6);  ///< Pad Disable for Port 0 Pin 6
        constexpr uint32_t PDIS7 = (1U << 7);  ///< Pad Disable for Port 0 Pin 7
        constexpr uint32_t PDIS8 = (1U << 8);  ///< Pad Disable for Port 0 Pin 8
        constexpr uint32_t PDIS9 = (1U << 9);  ///< Pad Disable for Port 0 Pin 9
        constexpr uint32_t PDIS10 = (1U << 10);  ///< Pad Disable for Port 0 Pin 10
        constexpr uint32_t PDIS11 = (1U << 11);  ///< Pad Disable for Port 0 Pin 11
        constexpr uint32_t PDIS12 = (1U << 12);  ///< Pad Disable for Port 0 Pin 12
        constexpr uint32_t PDIS13 = (1U << 13);  ///< Pad Disable for Port 0 Pin 13
        constexpr uint32_t PDIS14 = (1U << 14);  ///< Pad Disable for Port 0 Pin 14
        constexpr uint32_t PDIS15 = (1U << 15);  ///< Pad Disable for Port 0 Pin 15
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Port 0 Input Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Port 0 Input Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Port 0 Input Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Port 0 Input Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Port 0 Input Bit 4
        constexpr uint32_t P5 = (1U << 5);  ///< Port 0 Input Bit 5
        constexpr uint32_t P6 = (1U << 6);  ///< Port 0 Input Bit 6
        constexpr uint32_t P7 = (1U << 7);  ///< Port 0 Input Bit 7
        constexpr uint32_t P8 = (1U << 8);  ///< Port 0 Input Bit 8
        constexpr uint32_t P9 = (1U << 9);  ///< Port 0 Input Bit 9
        constexpr uint32_t P10 = (1U << 10);  ///< Port 0 Input Bit 10
        constexpr uint32_t P11 = (1U << 11);  ///< Port 0 Input Bit 11
        constexpr uint32_t P12 = (1U << 12);  ///< Port 0 Input Bit 12
        constexpr uint32_t P13 = (1U << 13);  ///< Port 0 Input Bit 13
        constexpr uint32_t P14 = (1U << 14);  ///< Port 0 Input Bit 14
        constexpr uint32_t P15 = (1U << 15);  ///< Port 0 Input Bit 15
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPS0 = (1U << 0);  ///< Port 0 Pin Power Save Bit 0
        constexpr uint32_t PPS1 = (1U << 1);  ///< Port 0 Pin Power Save Bit 1
        constexpr uint32_t PPS2 = (1U << 2);  ///< Port 0 Pin Power Save Bit 2
        constexpr uint32_t PPS3 = (1U << 3);  ///< Port 0 Pin Power Save Bit 3
        constexpr uint32_t PPS4 = (1U << 4);  ///< Port 0 Pin Power Save Bit 4
        constexpr uint32_t PPS5 = (1U << 5);  ///< Port 0 Pin Power Save Bit 5
        constexpr uint32_t PPS6 = (1U << 6);  ///< Port 0 Pin Power Save Bit 6
        constexpr uint32_t PPS7 = (1U << 7);  ///< Port 0 Pin Power Save Bit 7
        constexpr uint32_t PPS8 = (1U << 8);  ///< Port 0 Pin Power Save Bit 8
        constexpr uint32_t PPS9 = (1U << 9);  ///< Port 0 Pin Power Save Bit 9
        constexpr uint32_t PPS10 = (1U << 10);  ///< Port 0 Pin Power Save Bit 10
        constexpr uint32_t PPS11 = (1U << 11);  ///< Port 0 Pin Power Save Bit 11
        constexpr uint32_t PPS12 = (1U << 12);  ///< Port 0 Pin Power Save Bit 12
        constexpr uint32_t PPS13 = (1U << 13);  ///< Port 0 Pin Power Save Bit 13
        constexpr uint32_t PPS14 = (1U << 14);  ///< Port 0 Pin Power Save Bit 14
        constexpr uint32_t PPS15 = (1U << 15);  ///< Port 0 Pin Power Save Bit 15
    }

    /// HWSEL Register bits
    namespace hwsel_bits {
        constexpr uint32_t HW0 = (2 << 0);  ///< Port 0 Pin Hardware Select Bit 0
        constexpr uint32_t HW1 = (2 << 2);  ///< Port 0 Pin Hardware Select Bit 1
        constexpr uint32_t HW2 = (2 << 4);  ///< Port 0 Pin Hardware Select Bit 2
        constexpr uint32_t HW3 = (2 << 6);  ///< Port 0 Pin Hardware Select Bit 3
        constexpr uint32_t HW4 = (2 << 8);  ///< Port 0 Pin Hardware Select Bit 4
        constexpr uint32_t HW5 = (2 << 10);  ///< Port 0 Pin Hardware Select Bit 5
        constexpr uint32_t HW6 = (2 << 12);  ///< Port 0 Pin Hardware Select Bit 6
        constexpr uint32_t HW7 = (2 << 14);  ///< Port 0 Pin Hardware Select Bit 7
        constexpr uint32_t HW8 = (2 << 16);  ///< Port 0 Pin Hardware Select Bit 8
        constexpr uint32_t HW9 = (2 << 18);  ///< Port 0 Pin Hardware Select Bit 9
        constexpr uint32_t HW10 = (2 << 20);  ///< Port 0 Pin Hardware Select Bit 10
        constexpr uint32_t HW11 = (2 << 22);  ///< Port 0 Pin Hardware Select Bit 11
        constexpr uint32_t HW12 = (2 << 24);  ///< Port 0 Pin Hardware Select Bit 12
        constexpr uint32_t HW13 = (2 << 26);  ///< Port 0 Pin Hardware Select Bit 13
        constexpr uint32_t HW14 = (2 << 28);  ///< Port 0 Pin Hardware Select Bit 14
        constexpr uint32_t HW15 = (2 << 30);  ///< Port 0 Pin Hardware Select Bit 15
    }

}


} // namespace alloy::generated::xmc1400

#endif // ALLOY_GENERATED_XMC1400_PERIPHERALS_HPP