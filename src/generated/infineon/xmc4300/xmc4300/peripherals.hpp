/// Auto-generated code for XMC4300
/// Generated by Alloy Code Generator
/// Source: infineon_xmc4300.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:38
#ifndef ALLOY_GENERATED_XMC4300_PERIPHERALS_HPP
#define ALLOY_GENERATED_XMC4300_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::xmc4300 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_ppb = true;
    constexpr uint32_t num_ppb_instances = 1;
    constexpr bool has_dlr = true;
    constexpr uint32_t num_dlr_instances = 1;
    constexpr bool has_eru0 = true;
    constexpr uint32_t num_eru0_instances = 1;
    constexpr bool has_eru1 = true;
    constexpr uint32_t num_eru1_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 9;
    constexpr bool has_fce = true;
    constexpr uint32_t num_fce_instances = 5;
    constexpr bool has_pba0 = true;
    constexpr uint32_t num_pba0_instances = 1;
    constexpr bool has_pba1 = true;
    constexpr uint32_t num_pba1_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_pref = true;
    constexpr uint32_t num_pref_instances = 1;
    constexpr bool has_pmu0 = true;
    constexpr uint32_t num_pmu0_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_scu = true;
    constexpr uint32_t num_scu_instances = 9;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_ledts0 = true;
    constexpr uint32_t num_ledts0_instances = 1;
    constexpr bool has_sdio = true;
    constexpr uint32_t num_sdio_instances = 2;
    constexpr bool has_eth = true;
    constexpr uint32_t num_eth_instances = 2;
    constexpr bool has_ecat0 = true;
    constexpr uint32_t num_ecat0_instances = 18;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 22;
    constexpr bool has_usic0 = true;
    constexpr uint32_t num_usic0_instances = 3;
    constexpr bool has_usic1 = true;
    constexpr uint32_t num_usic1_instances = 3;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 4;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 3;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_ccu40 = true;
    constexpr uint32_t num_ccu40_instances = 5;
    constexpr bool has_ccu41 = true;
    constexpr uint32_t num_ccu41_instances = 5;
    constexpr bool has_ccu80 = true;
    constexpr uint32_t num_ccu80_instances = 5;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 8;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct ppb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dlr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eru0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eru1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 9;
    };
    template<>
    struct peripheral_count<struct fce_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct pba0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pba1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pref_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmu0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scu_tag> {
        static constexpr uint32_t value = 9;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ledts0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct eth_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ecat0_tag> {
        static constexpr uint32_t value = 18;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 22;
    };
    template<>
    struct peripheral_count<struct usic0_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct usic1_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccu40_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct ccu41_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct ccu80_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 8;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 8;
    constexpr uint32_t max_gpio_pins = 128;  // 16 pins per port

    // USART-specific traits
}

// ============================================================================
// PPB Peripheral
// ============================================================================

namespace ppb {
    /// Base addresses
    constexpr uint32_t PPB_BASE = 0xE000E000;

    /// PPB Register structure
    struct Registers {
        volatile uint32_t ACTLR;  ///< Offset: 0x08 - Auxiliary Control Register
        volatile uint32_t SYST_CSR;  ///< Offset: 0x10 - SysTick Control and Status Register
        volatile uint32_t SYST_RVR;  ///< Offset: 0x14 - SysTick Reload Value Register
        volatile uint32_t SYST_CVR;  ///< Offset: 0x18 - SysTick Current Value Register
        volatile uint32_t SYST_CALIB;  ///< Offset: 0x1C - SysTick Calibration Value Register r
        volatile uint32_t NVIC_ISER0;  ///< Offset: 0x100 - Interrupt Set-enable Register 0
        volatile uint32_t NVIC_ISER1;  ///< Offset: 0x104 - Interrupt Set-enable Register 1
        volatile uint32_t NVIC_ISER2;  ///< Offset: 0x108 - Interrupt Set-enable Register 2
        volatile uint32_t NVIC_ISER3;  ///< Offset: 0x10C - Interrupt Set-enable Register 3
        volatile uint32_t NVIC_ICER0;  ///< Offset: 0x180 - Interrupt Clear-enable Register 0
        volatile uint32_t NVIC_ICER1;  ///< Offset: 0x184 - Interrupt Clear-enable Register 1
        volatile uint32_t NVIC_ICER2;  ///< Offset: 0x188 - Interrupt Clear-enable Register 2
        volatile uint32_t NVIC_ICER3;  ///< Offset: 0x18C - Interrupt Clear-enable Register 3
        volatile uint32_t NVIC_ISPR0;  ///< Offset: 0x200 - Interrupt Set-pending Register 0
        volatile uint32_t NVIC_ISPR1;  ///< Offset: 0x204 - Interrupt Set-pending Register 1
        volatile uint32_t NVIC_ISPR2;  ///< Offset: 0x208 - Interrupt Set-pending Register 2
        volatile uint32_t NVIC_ISPR3;  ///< Offset: 0x20C - Interrupt Set-pending Register 3
        volatile uint32_t NVIC_ICPR0;  ///< Offset: 0x280 - Interrupt Clear-pending Register 0
        volatile uint32_t NVIC_ICPR1;  ///< Offset: 0x284 - Interrupt Clear-pending Register 1
        volatile uint32_t NVIC_ICPR2;  ///< Offset: 0x288 - Interrupt Clear-pending Register 2
        volatile uint32_t NVIC_ICPR3;  ///< Offset: 0x28C - Interrupt Clear-pending Register 3
        volatile uint32_t NVIC_IABR0;  ///< Offset: 0x300 - Interrupt Active Bit Register 0
        volatile uint32_t NVIC_IABR1;  ///< Offset: 0x304 - Interrupt Active Bit Register 1
        volatile uint32_t NVIC_IABR2;  ///< Offset: 0x308 - Interrupt Active Bit Register 2
        volatile uint32_t NVIC_IABR3;  ///< Offset: 0x30C - Interrupt Active Bit Register 3
        volatile uint32_t NVIC_IPR0;  ///< Offset: 0x400 - Interrupt Priority Register 0
        volatile uint32_t NVIC_IPR1;  ///< Offset: 0x404 - Interrupt Priority Register 1
        volatile uint32_t NVIC_IPR2;  ///< Offset: 0x408 - Interrupt Priority Register 2
        volatile uint32_t NVIC_IPR3;  ///< Offset: 0x40C - Interrupt Priority Register 3
        volatile uint32_t NVIC_IPR4;  ///< Offset: 0x410 - Interrupt Priority Register 4
        volatile uint32_t NVIC_IPR5;  ///< Offset: 0x414 - Interrupt Priority Register 5
        volatile uint32_t NVIC_IPR6;  ///< Offset: 0x418 - Interrupt Priority Register 6
        volatile uint32_t NVIC_IPR7;  ///< Offset: 0x41C - Interrupt Priority Register 7
        volatile uint32_t NVIC_IPR8;  ///< Offset: 0x420 - Interrupt Priority Register 8
        volatile uint32_t NVIC_IPR9;  ///< Offset: 0x424 - Interrupt Priority Register 9
        volatile uint32_t NVIC_IPR10;  ///< Offset: 0x428 - Interrupt Priority Register 10
        volatile uint32_t NVIC_IPR11;  ///< Offset: 0x42C - Interrupt Priority Register 11
        volatile uint32_t NVIC_IPR12;  ///< Offset: 0x430 - Interrupt Priority Register 12
        volatile uint32_t NVIC_IPR13;  ///< Offset: 0x434 - Interrupt Priority Register 13
        volatile uint32_t NVIC_IPR14;  ///< Offset: 0x438 - Interrupt Priority Register 14
        volatile uint32_t NVIC_IPR15;  ///< Offset: 0x43C - Interrupt Priority Register 15
        volatile uint32_t NVIC_IPR16;  ///< Offset: 0x440 - Interrupt Priority Register 16
        volatile uint32_t NVIC_IPR17;  ///< Offset: 0x444 - Interrupt Priority Register 17
        volatile uint32_t NVIC_IPR18;  ///< Offset: 0x448 - Interrupt Priority Register 18
        volatile uint32_t NVIC_IPR19;  ///< Offset: 0x44C - Interrupt Priority Register 19
        volatile uint32_t NVIC_IPR20;  ///< Offset: 0x450 - Interrupt Priority Register 20
        volatile uint32_t NVIC_IPR21;  ///< Offset: 0x454 - Interrupt Priority Register 21
        volatile uint32_t NVIC_IPR22;  ///< Offset: 0x458 - Interrupt Priority Register 22
        volatile uint32_t NVIC_IPR23;  ///< Offset: 0x45C - Interrupt Priority Register 23
        volatile uint32_t NVIC_IPR24;  ///< Offset: 0x460 - Interrupt Priority Register 24
        volatile uint32_t NVIC_IPR25;  ///< Offset: 0x464 - Interrupt Priority Register 25
        volatile uint32_t NVIC_IPR26;  ///< Offset: 0x468 - Interrupt Priority Register 26
        volatile uint32_t NVIC_IPR27;  ///< Offset: 0x46C - Interrupt Priority Register 27
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control and State Register
        volatile uint32_t VTOR;  ///< Offset: 0xD08 - Vector Table Offset Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt and Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration and Control Register
        volatile uint32_t SHPR1;  ///< Offset: 0xD18 - System Handler Priority Register 1
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
        volatile uint32_t CFSR;  ///< Offset: 0xD28 - Configurable Fault Status Register
        volatile uint32_t HFSR;  ///< Offset: 0xD2C - HardFault Status Register
        volatile uint32_t MMFAR;  ///< Offset: 0xD34 - MemManage Fault Address Register
        volatile uint32_t BFAR;  ///< Offset: 0xD38 - BusFault Address Register
        volatile uint32_t AFSR;  ///< Offset: 0xD3C - Auxiliary Fault Status Register
        volatile uint32_t CPACR;  ///< Offset: 0xD88 - Coprocessor Access Control Register
        volatile uint32_t MPU_TYPE;  ///< Offset: 0xD90 - MPU Type Register
        volatile uint32_t MPU_CTRL;  ///< Offset: 0xD94 - MPU Control Register
        volatile uint32_t MPU_RNR;  ///< Offset: 0xD98 - MPU Region Number Register
        volatile uint32_t MPU_RBAR;  ///< Offset: 0xD9C - MPU Region Base Address Register
        volatile uint32_t MPU_RASR;  ///< Offset: 0xDA0 - MPU Region Attribute and Size Register
        volatile uint32_t MPU_RBAR_A1;  ///< Offset: 0xDA4 - MPU Region Base Address Register A1
        volatile uint32_t MPU_RASR_A1;  ///< Offset: 0xDA8 - MPU Region Attribute and Size Register A1
        volatile uint32_t MPU_RBAR_A2;  ///< Offset: 0xDAC - MPU Region Base Address Register A2
        volatile uint32_t MPU_RASR_A2;  ///< Offset: 0xDB0 - MPU Region Attribute and Size Register A2
        volatile uint32_t MPU_RBAR_A3;  ///< Offset: 0xDB4 - MPU Region Base Address Register A3
        volatile uint32_t MPU_RASR_A3;  ///< Offset: 0xDB8 - MPU Region Attribute and Size Register A3
        volatile uint32_t STIR;  ///< Offset: 0xF00 - Software Trigger Interrupt Register
        volatile uint32_t FPCCR;  ///< Offset: 0xF34 - Floating-point Context Control Register
        volatile uint32_t FPCAR;  ///< Offset: 0xF38 - Floating-point Context Address Register
        volatile uint32_t FPDSCR;  ///< Offset: 0xF3C - Floating-point Default Status Control Register
    };

    /// Peripheral instances
    inline Registers* PPB = reinterpret_cast<Registers*>(PPB_BASE);

    // Bit definitions
    /// ACTLR Register bits
    namespace actlr_bits {
        constexpr uint32_t DISMCYCINT = (1U << 0);  ///< Disable load/store multiple
        constexpr uint32_t DISDEFWBUF = (1U << 1);  ///< Disable write buffer
        constexpr uint32_t DISFOLD = (1U << 2);  ///< Disable IT folding
        constexpr uint32_t DISFPCA = (1U << 8);  ///< Disable FPCA update
        constexpr uint32_t DISOOFP = (1U << 9);  ///< Disable out of order FP execution
    }

    /// SYST_CSR Register bits
    namespace syst_csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable
        constexpr uint32_t TICKINT = (1U << 1);  ///< Tick Interrupt Enable
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< Indicates the clock source:
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< Counter Flag
    }

    /// SYST_RVR Register bits
    namespace syst_rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Reload Value
    }

    /// SYST_CVR Register bits
    namespace syst_cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current Value
    }

    /// SYST_CALIB Register bits
    namespace syst_calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Ten Milliseconds Reload Value
        constexpr uint32_t SKEW = (1U << 30);  ///< Ten Milliseconds Skewed
        constexpr uint32_t NOREF = (1U << 31);  ///< No Reference Clock
    }

    /// NVIC_ISER0 Register bits
    namespace nvic_iser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set-enable bits
    }

    /// NVIC_ISER1 Register bits
    namespace nvic_iser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set-enable bits
    }

    /// NVIC_ISER2 Register bits
    namespace nvic_iser2_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set-enable bits
    }

    /// NVIC_ISER3 Register bits
    namespace nvic_iser3_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set-enable bits
    }

    /// NVIC_ICER0 Register bits
    namespace nvic_icer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits.
    }

    /// NVIC_ICER1 Register bits
    namespace nvic_icer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits.
    }

    /// NVIC_ICER2 Register bits
    namespace nvic_icer2_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits.
    }

    /// NVIC_ICER3 Register bits
    namespace nvic_icer3_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits.
    }

    /// NVIC_ISPR0 Register bits
    namespace nvic_ispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ISPR1 Register bits
    namespace nvic_ispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ISPR2 Register bits
    namespace nvic_ispr2_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ISPR3 Register bits
    namespace nvic_ispr3_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ICPR0 Register bits
    namespace nvic_icpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ICPR1 Register bits
    namespace nvic_icpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ICPR2 Register bits
    namespace nvic_icpr2_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ICPR3 Register bits
    namespace nvic_icpr3_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_IABR0 Register bits
    namespace nvic_iabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags:
    }

    /// NVIC_IABR1 Register bits
    namespace nvic_iabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags:
    }

    /// NVIC_IABR2 Register bits
    namespace nvic_iabr2_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags:
    }

    /// NVIC_IABR3 Register bits
    namespace nvic_iabr3_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags:
    }

    /// NVIC_IPR0 Register bits
    namespace nvic_ipr0_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR1 Register bits
    namespace nvic_ipr1_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR2 Register bits
    namespace nvic_ipr2_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR3 Register bits
    namespace nvic_ipr3_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR4 Register bits
    namespace nvic_ipr4_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR5 Register bits
    namespace nvic_ipr5_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR6 Register bits
    namespace nvic_ipr6_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR7 Register bits
    namespace nvic_ipr7_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR8 Register bits
    namespace nvic_ipr8_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR9 Register bits
    namespace nvic_ipr9_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR10 Register bits
    namespace nvic_ipr10_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR11 Register bits
    namespace nvic_ipr11_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR12 Register bits
    namespace nvic_ipr12_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR13 Register bits
    namespace nvic_ipr13_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR14 Register bits
    namespace nvic_ipr14_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR15 Register bits
    namespace nvic_ipr15_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR16 Register bits
    namespace nvic_ipr16_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR17 Register bits
    namespace nvic_ipr17_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR18 Register bits
    namespace nvic_ipr18_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR19 Register bits
    namespace nvic_ipr19_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR20 Register bits
    namespace nvic_ipr20_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR21 Register bits
    namespace nvic_ipr21_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR22 Register bits
    namespace nvic_ipr22_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR23 Register bits
    namespace nvic_ipr23_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR24 Register bits
    namespace nvic_ipr24_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR25 Register bits
    namespace nvic_ipr25_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR26 Register bits
    namespace nvic_ipr26_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR27 Register bits
    namespace nvic_ipr27_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t Revision = (4 << 0);  ///< Revision number
        constexpr uint32_t PartNo = (12 << 4);  ///< Part number of the processor
        constexpr uint32_t Constant = (4 << 16);  ///< Reads as 0xF
        constexpr uint32_t Variant = (4 << 20);  ///< Variant number
        constexpr uint32_t Implementer = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active exception number
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< Return to Base
        constexpr uint32_t VECTPENDING = (6 << 12);  ///< Vector Pending
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick exception clear-pending bit
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick exception set-pending bit
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV clear-pending bit
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV set-pending bit: 0b0=no effect, 0b1=changes PendSV exception state to pending., 0b0=PendSV exception is not pending, 0b1=PendSV exception is pending.,
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI set-pending bit: 0b0=no effect, 0b1=changes NMI exception state to pending., 0b0=NMI exception is not pending, 0b1=NMI exception is pending.,
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (22 << 10);  ///< Vector table base offset field
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTRESET = (1U << 0);  ///< Reserved for Debug use.
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< Reserved for Debug use.
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< System reset request
        constexpr uint32_t PRIGROUP = (3 << 8);  ///< Interrupt priority grouping field
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< Data endianness bit
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< Sleep on Exit
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< Sleep or Deep Sleep
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< Send Event on Pending bit:
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< Non Base Thread Mode Enable
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< User Set Pending Enable
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Unaligned Access Trap Enable
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< Divide by Zero Trap Enable
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< Bus Fault Hard Fault and NMI Ignore
        constexpr uint32_t STKALIGN = (1U << 9);  ///< Stack Alignment
    }

    /// SHPR1 Register bits
    namespace shpr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of system handler 4, MemManage
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of system handler 5, BusFault
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of system handler 6, UsageFault
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11, SVCall
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t MEMFAULTACT = (1U << 0);  ///< MemManage exception active bit
        constexpr uint32_t BUSFAULTACT = (1U << 1);  ///< BusFault exception active bit
        constexpr uint32_t USGFAULTACT = (1U << 3);  ///< UsageFault exception active bit
        constexpr uint32_t SVCALLACT = (1U << 7);  ///< SVCall active bit
        constexpr uint32_t MONITORACT = (1U << 8);  ///< Debug monitor active bit
        constexpr uint32_t PENDSVACT = (1U << 10);  ///< PendSV exception active bit
        constexpr uint32_t SYSTICKACT = (1U << 11);  ///< SysTick exception active bit
        constexpr uint32_t USGFAULTPENDED = (1U << 12);  ///< UsageFault exception pending bit
        constexpr uint32_t MEMFAULTPENDED = (1U << 13);  ///< MemManage exception pending bit
        constexpr uint32_t BUSFAULTPENDED = (1U << 14);  ///< BusFault exception pending bit
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVCall pending bit
        constexpr uint32_t MEMFAULTENA = (1U << 16);  ///< MemManage enable bit
        constexpr uint32_t BUSFAULTENA = (1U << 17);  ///< BusFault enable bit
        constexpr uint32_t USGFAULTENA = (1U << 18);  ///< UsageFault enable bit
    }

    /// CFSR Register bits
    namespace cfsr_bits {
        constexpr uint32_t IACCVIOL = (1U << 0);  ///< Instruction access violation flag
        constexpr uint32_t DACCVIOL = (1U << 1);  ///< Data access violation flag
        constexpr uint32_t MUNSTKERR = (1U << 3);  ///< MemManage fault on unstacking for a return from exception
        constexpr uint32_t MSTKERR = (1U << 4);  ///< MemManage fault on stacking for exception entry
        constexpr uint32_t MLSPERR = (1U << 5);  ///< MemManage fault during floating point lazy state preservation
        constexpr uint32_t MMARVALID = (1U << 7);  ///< MemManage Fault Address Register (MMFAR) valid flag
        constexpr uint32_t IBUSERR = (1U << 8);  ///< Instruction bus error
        constexpr uint32_t PRECISERR = (1U << 9);  ///< Precise data bus error
        constexpr uint32_t IMPRECISERR = (1U << 10);  ///< Imprecise data bus error
        constexpr uint32_t UNSTKERR = (1U << 11);  ///< BusFault on unstacking for a return from exception
        constexpr uint32_t STKERR = (1U << 12);  ///< BusFault on stacking for exception entry
        constexpr uint32_t LSPERR = (1U << 13);  ///< BusFault during floating point lazy state preservation
        constexpr uint32_t BFARVALID = (1U << 15);  ///< BusFault Address Register (BFAR) valid flag
        constexpr uint32_t UNDEFINSTR = (1U << 16);  ///< Undefined instruction UsageFault
        constexpr uint32_t INVSTATE = (1U << 17);  ///< Invalid state UsageFault
        constexpr uint32_t INVPC = (1U << 18);  ///< Invalid PC load UsageFault
        constexpr uint32_t NOCP = (1U << 19);  ///< No coprocessor UsageFault
        constexpr uint32_t UNALIGNED = (1U << 24);  ///< Unaligned access UsageFault
        constexpr uint32_t DIVBYZERO = (1U << 25);  ///< Divide by zero UsageFault
    }

    /// HFSR Register bits
    namespace hfsr_bits {
        constexpr uint32_t VECTTBL = (1U << 1);  ///< BusFault on vector table read
        constexpr uint32_t FORCED = (1U << 30);  ///< Forced HardFault
        constexpr uint32_t DEBUGEVT = (1U << 31);  ///< Reserved for Debug use
    }

    /// MMFAR Register bits
    namespace mmfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address causing the fault
    }

    /// BFAR Register bits
    namespace bfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address causing the fault
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t VALUE = (32 << 0);  ///< Reserved
    }

    /// CPACR Register bits
    namespace cpacr_bits {
        constexpr uint32_t CP10 = (2 << 20);  ///< Access privileges for coprocessor 10
        constexpr uint32_t CP11 = (2 << 22);  ///< Access privileges for coprocessor 11
    }

    /// MPU_TYPE Register bits
    namespace mpu_type_bits {
        constexpr uint32_t SEPARATE = (1U << 0);  ///< Support for unified or separate instruction and date memory maps
        constexpr uint32_t DREGION = (8 << 8);  ///< Number of supported MPU data regions
        constexpr uint32_t IREGION = (8 << 16);  ///< Number of supported MPU instruction regions
    }

    /// MPU_CTRL Register bits
    namespace mpu_ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable MPU
        constexpr uint32_t HFNMIENA = (1U << 1);  ///< Enable the operation of MPU during hard fault, NMI, and FAULTMASK handlers
        constexpr uint32_t PRIVDEFENA = (1U << 2);  ///< Enables privileged software access to the default memory map
    }

    /// MPU_RNR Register bits
    namespace mpu_rnr_bits {
        constexpr uint32_t REGION = (8 << 0);  ///< Region
    }

    /// MPU_RBAR Register bits
    namespace mpu_rbar_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU Region Number valid bit
        constexpr uint32_t ADDR = (23 << 9);  ///< Region base address field
    }

    /// MPU_RASR Register bits
    namespace mpu_rasr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< MPU protection region size
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< Memory access attribute
        constexpr uint32_t C = (1U << 17);  ///< Memory access attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable bit
        constexpr uint32_t TEX = (3 << 19);  ///< Memory access attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission field
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

    /// MPU_RBAR_A1 Register bits
    namespace mpu_rbar_a1_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU Region Number valid bit
        constexpr uint32_t ADDR = (23 << 9);  ///< Region base address field
    }

    /// MPU_RASR_A1 Register bits
    namespace mpu_rasr_a1_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< MPU protection region size
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< Memory access attribute
        constexpr uint32_t C = (1U << 17);  ///< Memory access attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable bit
        constexpr uint32_t TEX = (3 << 19);  ///< Memory access attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission field
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

    /// MPU_RBAR_A2 Register bits
    namespace mpu_rbar_a2_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU Region Number valid bit
        constexpr uint32_t ADDR = (23 << 9);  ///< Region base address field
    }

    /// MPU_RASR_A2 Register bits
    namespace mpu_rasr_a2_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< MPU protection region size
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< Memory access attribute
        constexpr uint32_t C = (1U << 17);  ///< Memory access attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable bit
        constexpr uint32_t TEX = (3 << 19);  ///< Memory access attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission field
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

    /// MPU_RBAR_A3 Register bits
    namespace mpu_rbar_a3_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU Region Number valid bit
        constexpr uint32_t ADDR = (23 << 9);  ///< Region base address field
    }

    /// MPU_RASR_A3 Register bits
    namespace mpu_rasr_a3_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< MPU protection region size
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< Memory access attribute
        constexpr uint32_t C = (1U << 17);  ///< Memory access attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable bit
        constexpr uint32_t TEX = (3 << 19);  ///< Memory access attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission field
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

    /// STIR Register bits
    namespace stir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< Interrupt ID of the interrupt to trigger
    }

    /// FPCCR Register bits
    namespace fpccr_bits {
        constexpr uint32_t LSPACT = (1U << 0);  ///< Lazy State Preservation Active
        constexpr uint32_t USER = (1U << 1);  ///< User allocated Stack Frame
        constexpr uint32_t THREAD = (1U << 3);  ///< Thread Mode allocated Stack Frame
        constexpr uint32_t HFRDY = (1U << 4);  ///< HardFault Ready
        constexpr uint32_t MMRDY = (1U << 5);  ///< MemManage Ready
        constexpr uint32_t BFRDY = (1U << 6);  ///< BusFault Ready
        constexpr uint32_t MONRDY = (1U << 8);  ///< Monitor Ready
        constexpr uint32_t LSPEN = (1U << 30);  ///< Lazy State Preservation Enabled
        constexpr uint32_t ASPEN = (1U << 31);  ///< Automatic State Preservation
    }

    /// FPCAR Register bits
    namespace fpcar_bits {
        constexpr uint32_t ADDRESS = (29 << 3);  ///< Address
    }

    /// FPDSCR Register bits
    namespace fpdscr_bits {
        constexpr uint32_t RMode = (2 << 22);  ///< Default value for FPSCR.RMode
        constexpr uint32_t FZ = (1U << 24);  ///< Default value for FPSCR.FZ
        constexpr uint32_t DN = (1U << 25);  ///< Default value for FPSCR.DN
        constexpr uint32_t AHP = (1U << 26);  ///< Default value for FPSCR.AHP
    }

}

// ============================================================================
// DLR Peripheral
// ============================================================================

namespace dlr {
    /// Base addresses
    constexpr uint32_t DLR_BASE = 0x50004900;

    /// DLR Register structure
    struct Registers {
        volatile uint32_t OVRSTAT;  ///< Offset: 0x00 - Overrun Status
        volatile uint32_t OVRCLR;  ///< Offset: 0x04 - Overrun Clear
        volatile uint32_t SRSEL0;  ///< Offset: 0x08 - Service Request Selection 0
        volatile uint32_t LNEN;  ///< Offset: 0x10 - Line Enable
    };

    /// Peripheral instances
    inline Registers* DLR = reinterpret_cast<Registers*>(DLR_BASE);

    // Bit definitions
    /// OVRSTAT Register bits
    namespace ovrstat_bits {
        constexpr uint32_t LN0 = (1U << 0);  ///< Line 0 Overrun Status
        constexpr uint32_t LN1 = (1U << 1);  ///< Line 1 Overrun Status
        constexpr uint32_t LN2 = (1U << 2);  ///< Line 2 Overrun Status
        constexpr uint32_t LN3 = (1U << 3);  ///< Line 3 Overrun Status
        constexpr uint32_t LN4 = (1U << 4);  ///< Line 4 Overrun Status
        constexpr uint32_t LN5 = (1U << 5);  ///< Line 5 Overrun Status
        constexpr uint32_t LN6 = (1U << 6);  ///< Line 6 Overrun Status
        constexpr uint32_t LN7 = (1U << 7);  ///< Line 7 Overrun Status
    }

    /// OVRCLR Register bits
    namespace ovrclr_bits {
        constexpr uint32_t LN0 = (1U << 0);  ///< Line 0 Overrun Status Clear
        constexpr uint32_t LN1 = (1U << 1);  ///< Line 1 Overrun Status Clear
        constexpr uint32_t LN2 = (1U << 2);  ///< Line 2 Overrun Status Clear
        constexpr uint32_t LN3 = (1U << 3);  ///< Line 3 Overrun Status Clear
        constexpr uint32_t LN4 = (1U << 4);  ///< Line 4 Overrun Status Clear
        constexpr uint32_t LN5 = (1U << 5);  ///< Line 5 Overrun Status Clear
        constexpr uint32_t LN6 = (1U << 6);  ///< Line 6 Overrun Status Clear
        constexpr uint32_t LN7 = (1U << 7);  ///< Line 7 Overrun Status Clear
    }

    /// SRSEL0 Register bits
    namespace srsel0_bits {
        constexpr uint32_t RS0 = (4 << 0);  ///< Request Source for Line 0
        constexpr uint32_t RS1 = (4 << 4);  ///< Request Source for Line 1
        constexpr uint32_t RS2 = (4 << 8);  ///< Request Source for Line 2
        constexpr uint32_t RS3 = (4 << 12);  ///< Request Source for Line 3
        constexpr uint32_t RS4 = (4 << 16);  ///< Request Source for Line 4
        constexpr uint32_t RS5 = (4 << 20);  ///< Request Source for Line 5
        constexpr uint32_t RS6 = (4 << 24);  ///< Request Source for Line 6
        constexpr uint32_t RS7 = (4 << 28);  ///< Request Source for Line 7
    }

    /// LNEN Register bits
    namespace lnen_bits {
        constexpr uint32_t LN0 = (1U << 0);  ///< Line 0 Enable
        constexpr uint32_t LN1 = (1U << 1);  ///< Line 1 Enable
        constexpr uint32_t LN2 = (1U << 2);  ///< Line 2 Enable
        constexpr uint32_t LN3 = (1U << 3);  ///< Line 3 Enable
        constexpr uint32_t LN4 = (1U << 4);  ///< Line 4 Enable
        constexpr uint32_t LN5 = (1U << 5);  ///< Line 5 Enable
        constexpr uint32_t LN6 = (1U << 6);  ///< Line 6 Enable
        constexpr uint32_t LN7 = (1U << 7);  ///< Line 7 Enable
    }

}

// ============================================================================
// ERU0 Peripheral
// ============================================================================

namespace eru0 {
    /// Base addresses
    constexpr uint32_t ERU0_BASE = 0x50004800;

    /// ERU0 Register structure
    struct Registers {
        volatile uint32_t EXISEL;  ///< Offset: 0x00 - Event Input Select
        volatile uint32_t EXICON__;  ///< Offset: 0x10 - Event Input Control (renamed from EXICON__)
        volatile uint32_t EXOCON__;  ///< Offset: 0x20 - Event Output Trigger Control (renamed from EXOCON__)
    };

    /// Peripheral instances
    inline Registers* ERU0 = reinterpret_cast<Registers*>(ERU0_BASE);

    // Bit definitions
    /// EXISEL Register bits
    namespace exisel_bits {
        constexpr uint32_t EXS0A = (2 << 0);  ///< Event Source Select for A0 (ERS0)
        constexpr uint32_t EXS0B = (2 << 2);  ///< Event Source Select for B0 (ERS0)
        constexpr uint32_t EXS1A = (2 << 4);  ///< Event Source Select for A1 (ERS1)
        constexpr uint32_t EXS1B = (2 << 6);  ///< Event Source Select for B1 (ERS1)
        constexpr uint32_t EXS2A = (2 << 8);  ///< Event Source Select for A2 (ERS2)
        constexpr uint32_t EXS2B = (2 << 10);  ///< Event Source Select for B2 (ERS2)
        constexpr uint32_t EXS3A = (2 << 12);  ///< Event Source Select for A3 (ERS3)
        constexpr uint32_t EXS3B = (2 << 14);  ///< Event Source Select for B3 (ERS3)
    }

    /// EXICON__ Register bits
    namespace exicon___bits {
        constexpr uint32_t PE = (1U << 0);  ///< Output Trigger Pulse Enable for ETLx
        constexpr uint32_t LD = (1U << 1);  ///< Rebuild Level Detection for Status Flag for ETLx
        constexpr uint32_t RE = (1U << 2);  ///< Rising Edge Detection Enable ETLx
        constexpr uint32_t FE = (1U << 3);  ///< Falling Edge Detection Enable ETLx
        constexpr uint32_t OCS = (3 << 4);  ///< Output Channel Select for ETLx Output Trigger Pulse
        constexpr uint32_t FL = (1U << 7);  ///< Status Flag for ETLx
        constexpr uint32_t SS = (2 << 8);  ///< Input Source Select for ERSx
        constexpr uint32_t NA = (1U << 10);  ///< Input A Negation Select for ERSx
        constexpr uint32_t NB = (1U << 11);  ///< Input B Negation Select for ERSx
    }

    /// EXOCON__ Register bits
    namespace exocon___bits {
        constexpr uint32_t ISS = (2 << 0);  ///< Internal Trigger Source Selection
        constexpr uint32_t GEEN = (1U << 2);  ///< Gating Event Enable
        constexpr uint32_t PDR = (1U << 3);  ///< Pattern Detection Result Flag
        constexpr uint32_t GP = (2 << 4);  ///< Gating Selection for Pattern Detection Result
        constexpr uint32_t IPEN0 = (1U << 12);  ///< Pattern Detection Enable for ETL0
        constexpr uint32_t IPEN1 = (1U << 13);  ///< Pattern Detection Enable for ETL1
        constexpr uint32_t IPEN2 = (1U << 14);  ///< Pattern Detection Enable for ETL2
        constexpr uint32_t IPEN3 = (1U << 15);  ///< Pattern Detection Enable for ETL3
    }

}

// ============================================================================
// ERU1 Peripheral
// ============================================================================

namespace eru1 {
    /// Base addresses
    constexpr uint32_t ERU1_BASE = 0x40044000;

    /// ERU1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ERU1 = reinterpret_cast<Registers*>(ERU1_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t GPDMA0_BASE = 0x500142C0;
    constexpr uint32_t GPDMA0_CH0_BASE = 0x50014000;
    constexpr uint32_t GPDMA0_CH1_BASE = 0x50014058;
    constexpr uint32_t GPDMA0_CH2_BASE = 0x500140B0;
    constexpr uint32_t GPDMA0_CH3_BASE = 0x50014108;
    constexpr uint32_t GPDMA0_CH4_BASE = 0x50014160;
    constexpr uint32_t GPDMA0_CH5_BASE = 0x500141B8;
    constexpr uint32_t GPDMA0_CH6_BASE = 0x50014210;
    constexpr uint32_t GPDMA0_CH7_BASE = 0x50014268;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t RAWTFR;  ///< Offset: 0x00 - Raw IntTfr Status
        volatile uint32_t RAWBLOCK;  ///< Offset: 0x08 - Raw IntBlock Status
        volatile uint32_t RAWSRCTRAN;  ///< Offset: 0x10 - Raw IntSrcTran Status
        volatile uint32_t RAWDSTTRAN;  ///< Offset: 0x18 - Raw IntBlock Status
        volatile uint32_t RAWERR;  ///< Offset: 0x20 - Raw IntErr Status
        volatile uint32_t STATUSTFR;  ///< Offset: 0x28 - IntTfr Status
        volatile uint32_t STATUSBLOCK;  ///< Offset: 0x30 - IntBlock Status
        volatile uint32_t STATUSSRCTRAN;  ///< Offset: 0x38 - IntSrcTran Status
        volatile uint32_t STATUSDSTTRAN;  ///< Offset: 0x40 - IntBlock Status
        volatile uint32_t STATUSERR;  ///< Offset: 0x48 - IntErr Status
        volatile uint32_t MASKTFR;  ///< Offset: 0x50 - Mask for Raw IntTfr Status
        volatile uint32_t MASKBLOCK;  ///< Offset: 0x58 - Mask for Raw IntBlock Status
        volatile uint32_t MASKSRCTRAN;  ///< Offset: 0x60 - Mask for Raw IntSrcTran Status
        volatile uint32_t MASKDSTTRAN;  ///< Offset: 0x68 - Mask for Raw IntBlock Status
        volatile uint32_t MASKERR;  ///< Offset: 0x70 - Mask for Raw IntErr Status
        volatile uint32_t CLEARTFR;  ///< Offset: 0x78 - IntTfr Status
        volatile uint32_t CLEARBLOCK;  ///< Offset: 0x80 - IntBlock Status
        volatile uint32_t CLEARSRCTRAN;  ///< Offset: 0x88 - IntSrcTran Status
        volatile uint32_t CLEARDSTTRAN;  ///< Offset: 0x90 - IntBlock Status
        volatile uint32_t CLEARERR;  ///< Offset: 0x98 - IntErr Status
        volatile uint32_t STATUSINT;  ///< Offset: 0xA0 - Combined Interrupt Status Register
        volatile uint32_t REQSRCREG;  ///< Offset: 0xA8 - Source Software Transaction Request Register
        volatile uint32_t REQDSTREG;  ///< Offset: 0xB0 - Destination Software Transaction Request Register
        volatile uint32_t SGLREQSRCREG;  ///< Offset: 0xB8 - Single Source Transaction Request Register
        volatile uint32_t SGLREQDSTREG;  ///< Offset: 0xC0 - Single Destination Transaction Request Register
        volatile uint32_t LSTSRCREG;  ///< Offset: 0xC8 - Last Source Transaction Request Register
        volatile uint32_t LSTDSTREG;  ///< Offset: 0xD0 - Last Destination Transaction Request Register
        volatile uint32_t DMACFGREG;  ///< Offset: 0xD8 - GPDMA Configuration Register
        volatile uint32_t CHENREG;  ///< Offset: 0xE0 - GPDMA Channel Enable Register
        volatile uint32_t ID;  ///< Offset: 0xE8 - GPDMA0 ID Register
        volatile uint32_t TYPE;  ///< Offset: 0x138 - GPDMA Component Type
        volatile uint32_t VERSION;  ///< Offset: 0x13C - DMA Component Version
    };

    /// Peripheral instances
    inline Registers* GPDMA0 = reinterpret_cast<Registers*>(GPDMA0_BASE);
    inline Registers* GPDMA0_CH0 = reinterpret_cast<Registers*>(GPDMA0_CH0_BASE);
    inline Registers* GPDMA0_CH1 = reinterpret_cast<Registers*>(GPDMA0_CH1_BASE);
    inline Registers* GPDMA0_CH2 = reinterpret_cast<Registers*>(GPDMA0_CH2_BASE);
    inline Registers* GPDMA0_CH3 = reinterpret_cast<Registers*>(GPDMA0_CH3_BASE);
    inline Registers* GPDMA0_CH4 = reinterpret_cast<Registers*>(GPDMA0_CH4_BASE);
    inline Registers* GPDMA0_CH5 = reinterpret_cast<Registers*>(GPDMA0_CH5_BASE);
    inline Registers* GPDMA0_CH6 = reinterpret_cast<Registers*>(GPDMA0_CH6_BASE);
    inline Registers* GPDMA0_CH7 = reinterpret_cast<Registers*>(GPDMA0_CH7_BASE);

    // Bit definitions
    /// RAWTFR Register bits
    namespace rawtfr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Raw Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Raw Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Raw Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Raw Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Raw Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Raw Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Raw Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Raw Interrupt Status for channel 7
    }

    /// RAWBLOCK Register bits
    namespace rawblock_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Raw Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Raw Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Raw Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Raw Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Raw Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Raw Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Raw Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Raw Interrupt Status for channel 7
    }

    /// RAWSRCTRAN Register bits
    namespace rawsrctran_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Raw Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Raw Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Raw Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Raw Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Raw Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Raw Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Raw Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Raw Interrupt Status for channel 7
    }

    /// RAWDSTTRAN Register bits
    namespace rawdsttran_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Raw Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Raw Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Raw Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Raw Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Raw Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Raw Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Raw Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Raw Interrupt Status for channel 7
    }

    /// RAWERR Register bits
    namespace rawerr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Raw Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Raw Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Raw Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Raw Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Raw Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Raw Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Raw Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Raw Interrupt Status for channel 7
    }

    /// STATUSTFR Register bits
    namespace statustfr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Interrupt Status for channel 7
    }

    /// STATUSBLOCK Register bits
    namespace statusblock_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Interrupt Status for channel 7
    }

    /// STATUSSRCTRAN Register bits
    namespace statussrctran_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Interrupt Status for channel 7
    }

    /// STATUSDSTTRAN Register bits
    namespace statusdsttran_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Interrupt Status for channel 7
    }

    /// STATUSERR Register bits
    namespace statuserr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Interrupt Status for channel 7
    }

    /// MASKTFR Register bits
    namespace masktfr_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Write enable for mask bit of channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Write enable for mask bit of channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Write enable for mask bit of channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Write enable for mask bit of channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Write enable for mask bit of channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Write enable for mask bit of channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Write enable for mask bit of channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Write enable for mask bit of channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Mask bit for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Mask bit for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Mask bit for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Mask bit for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Mask bit for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Mask bit for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Mask bit for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Mask bit for channel 7
    }

    /// MASKBLOCK Register bits
    namespace maskblock_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Write enable for mask bit of channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Write enable for mask bit of channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Write enable for mask bit of channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Write enable for mask bit of channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Write enable for mask bit of channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Write enable for mask bit of channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Write enable for mask bit of channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Write enable for mask bit of channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Mask bit for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Mask bit for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Mask bit for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Mask bit for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Mask bit for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Mask bit for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Mask bit for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Mask bit for channel 7
    }

    /// MASKSRCTRAN Register bits
    namespace masksrctran_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Write enable for mask bit of channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Write enable for mask bit of channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Write enable for mask bit of channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Write enable for mask bit of channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Write enable for mask bit of channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Write enable for mask bit of channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Write enable for mask bit of channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Write enable for mask bit of channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Mask bit for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Mask bit for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Mask bit for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Mask bit for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Mask bit for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Mask bit for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Mask bit for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Mask bit for channel 7
    }

    /// MASKDSTTRAN Register bits
    namespace maskdsttran_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Write enable for mask bit of channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Write enable for mask bit of channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Write enable for mask bit of channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Write enable for mask bit of channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Write enable for mask bit of channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Write enable for mask bit of channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Write enable for mask bit of channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Write enable for mask bit of channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Mask bit for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Mask bit for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Mask bit for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Mask bit for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Mask bit for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Mask bit for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Mask bit for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Mask bit for channel 7
    }

    /// MASKERR Register bits
    namespace maskerr_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Write enable for mask bit of channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Write enable for mask bit of channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Write enable for mask bit of channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Write enable for mask bit of channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Write enable for mask bit of channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Write enable for mask bit of channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Write enable for mask bit of channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Write enable for mask bit of channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Mask bit for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Mask bit for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Mask bit for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Mask bit for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Mask bit for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Mask bit for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Mask bit for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Mask bit for channel 7
    }

    /// CLEARTFR Register bits
    namespace cleartfr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Clear Interrupt Status and Raw Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Clear Interrupt Status and Raw Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Clear Interrupt Status and Raw Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Clear Interrupt Status and Raw Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Clear Interrupt Status and Raw Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Clear Interrupt Status and Raw Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Clear Interrupt Status and Raw Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Clear Interrupt Status and Raw Status for channel 7
    }

    /// CLEARBLOCK Register bits
    namespace clearblock_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Clear Interrupt Status and Raw Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Clear Interrupt Status and Raw Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Clear Interrupt Status and Raw Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Clear Interrupt Status and Raw Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Clear Interrupt Status and Raw Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Clear Interrupt Status and Raw Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Clear Interrupt Status and Raw Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Clear Interrupt Status and Raw Status for channel 7
    }

    /// CLEARSRCTRAN Register bits
    namespace clearsrctran_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Clear Interrupt Status and Raw Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Clear Interrupt Status and Raw Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Clear Interrupt Status and Raw Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Clear Interrupt Status and Raw Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Clear Interrupt Status and Raw Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Clear Interrupt Status and Raw Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Clear Interrupt Status and Raw Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Clear Interrupt Status and Raw Status for channel 7
    }

    /// CLEARDSTTRAN Register bits
    namespace cleardsttran_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Clear Interrupt Status and Raw Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Clear Interrupt Status and Raw Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Clear Interrupt Status and Raw Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Clear Interrupt Status and Raw Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Clear Interrupt Status and Raw Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Clear Interrupt Status and Raw Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Clear Interrupt Status and Raw Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Clear Interrupt Status and Raw Status for channel 7
    }

    /// CLEARERR Register bits
    namespace clearerr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Clear Interrupt Status and Raw Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Clear Interrupt Status and Raw Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Clear Interrupt Status and Raw Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Clear Interrupt Status and Raw Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Clear Interrupt Status and Raw Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Clear Interrupt Status and Raw Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Clear Interrupt Status and Raw Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Clear Interrupt Status and Raw Status for channel 7
    }

    /// STATUSINT Register bits
    namespace statusint_bits {
        constexpr uint32_t ERR = (1U << 4);  ///< OR of the contents of STATUSERR register
        constexpr uint32_t DSTT = (1U << 3);  ///< OR of the contents of STATUSDSTTRAN register
        constexpr uint32_t SRCT = (1U << 2);  ///< OR of the contents of STATUSSRCTRAN register
        constexpr uint32_t BLOCK = (1U << 1);  ///< OR of the contents of STATUSBLOCK register
        constexpr uint32_t TFR = (1U << 0);  ///< OR of the contents of STATUSTFR register
    }

    /// REQSRCREG Register bits
    namespace reqsrcreg_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Source request write enable for channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Source request write enable for channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Source request write enable for channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Source request write enable for channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Source request write enable for channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Source request write enable for channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Source request write enable for channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Source request write enable for channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Source request for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Source request for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Source request for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Source request for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Source request for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Source request for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Source request for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Source request for channel 7
    }

    /// REQDSTREG Register bits
    namespace reqdstreg_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Source request write enable for channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Source request write enable for channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Source request write enable for channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Source request write enable for channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Source request write enable for channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Source request write enable for channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Source request write enable for channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Source request write enable for channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Source request for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Source request for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Source request for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Source request for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Source request for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Source request for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Source request for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Source request for channel 7
    }

    /// SGLREQSRCREG Register bits
    namespace sglreqsrcreg_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Source request write enable for channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Source request write enable for channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Source request write enable for channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Source request write enable for channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Source request write enable for channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Source request write enable for channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Source request write enable for channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Source request write enable for channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Source request for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Source request for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Source request for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Source request for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Source request for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Source request for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Source request for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Source request for channel 7
    }

    /// SGLREQDSTREG Register bits
    namespace sglreqdstreg_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Source request write enable for channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Source request write enable for channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Source request write enable for channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Source request write enable for channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Source request write enable for channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Source request write enable for channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Source request write enable for channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Source request write enable for channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Source request for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Source request for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Source request for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Source request for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Source request for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Source request for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Source request for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Source request for channel 7
    }

    /// LSTSRCREG Register bits
    namespace lstsrcreg_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Source last transaction request write enable for channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Source last transaction request write enable for channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Source last transaction request write enable for channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Source last transaction request write enable for channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Source last transaction request write enable for channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Source last transaction request write enable for channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Source last transaction request write enable for channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Source last transaction request write enable for channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Source last request for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Source last request for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Source last request for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Source last request for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Source last request for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Source last request for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Source last request for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Source last request for channel 7
    }

    /// LSTDSTREG Register bits
    namespace lstdstreg_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Destination last transaction request write enable for channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Destination last transaction request write enable for channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Destination last transaction request write enable for channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Destination last transaction request write enable for channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Destination last transaction request write enable for channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Destination last transaction request write enable for channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Destination last transaction request write enable for channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Destination last transaction request write enable for channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Destination last request for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Destination last request for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Destination last request for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Destination last request for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Destination last request for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Destination last request for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Destination last request for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Destination last request for channel 7
    }

    /// DMACFGREG Register bits
    namespace dmacfgreg_bits {
        constexpr uint32_t DMA_EN = (1U << 0);  ///< GPDMA Enable bit.
    }

    /// CHENREG Register bits
    namespace chenreg_bits {
        constexpr uint32_t WE_CH = (8 << 8);  ///< Channel enable write enable
        constexpr uint32_t CH = (8 << 0);  ///< Enables/Disables the channel
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t VALUE = (32 << 0);  ///< Hardcoded GPDMA Peripheral ID
    }

    /// TYPE Register bits
    namespace type_bits {
        constexpr uint32_t VALUE = (32 << 0);  ///< Component Type
    }

    /// VERSION Register bits
    namespace version_bits {
        constexpr uint32_t VALUE = (32 << 0);  ///< Version number of the component
    }

}

// ============================================================================
// FCE Peripheral
// ============================================================================

namespace fce {
    /// Base addresses
    constexpr uint32_t FCE_BASE = 0x50020000;
    constexpr uint32_t FCE_KE0_BASE = 0x50020020;
    constexpr uint32_t FCE_KE1_BASE = 0x50020040;
    constexpr uint32_t FCE_KE2_BASE = 0x50020060;
    constexpr uint32_t FCE_KE3_BASE = 0x50020080;

    /// FCE Register structure
    struct Registers {
        volatile uint32_t CLC;  ///< Offset: 0x00 - Clock Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
    };

    /// Peripheral instances
    inline Registers* FCE = reinterpret_cast<Registers*>(FCE_BASE);
    inline Registers* FCE_KE0 = reinterpret_cast<Registers*>(FCE_KE0_BASE);
    inline Registers* FCE_KE1 = reinterpret_cast<Registers*>(FCE_KE1_BASE);
    inline Registers* FCE_KE2 = reinterpret_cast<Registers*>(FCE_KE2_BASE);
    inline Registers* FCE_KE3 = reinterpret_cast<Registers*>(FCE_KE3_BASE);

    // Bit definitions
    /// CLC Register bits
    namespace clc_bits {
        constexpr uint32_t DISR = (1U << 0);  ///< Module Disable Request Bit
        constexpr uint32_t DISS = (1U << 1);  ///< Module Disable Status Bit
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

}

// ============================================================================
// PBA0 Peripheral
// ============================================================================

namespace pba0 {
    /// Base addresses
    constexpr uint32_t PBA0_BASE = 0x40000000;

    /// PBA0 Register structure
    struct Registers {
        volatile uint32_t STS;  ///< Offset: 0x00 - Peripheral Bridge Status Register
        volatile uint32_t WADDR;  ///< Offset: 0x04 - PBA Write Error Address Register
    };

    /// Peripheral instances
    inline Registers* PBA0 = reinterpret_cast<Registers*>(PBA0_BASE);

    // Bit definitions
    /// STS Register bits
    namespace sts_bits {
        constexpr uint32_t WERR = (1U << 0);  ///< Bufferable Write Access Error
    }

    /// WADDR Register bits
    namespace waddr_bits {
        constexpr uint32_t WADDR = (32 << 0);  ///< Write Error Address
    }

}

// ============================================================================
// PBA1 Peripheral
// ============================================================================

namespace pba1 {
    /// Base addresses
    constexpr uint32_t PBA1_BASE = 0x48000000;

    /// PBA1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* PBA1 = reinterpret_cast<Registers*>(PBA1_BASE);

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH0_BASE = 0x58001000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x1008 - Flash Module Identification Register
        volatile uint32_t FSR;  ///< Offset: 0x1010 - Flash Status Register
        volatile uint32_t FCON;  ///< Offset: 0x1014 - Flash Configuration Register
        volatile uint32_t MARP;  ///< Offset: 0x1018 - Margin Control Register PFLASH
        volatile uint32_t PROCON0;  ///< Offset: 0x1020 - Flash Protection Configuration Register User 0
        volatile uint32_t PROCON1;  ///< Offset: 0x1024 - Flash Protection Configuration Register User 1
        volatile uint32_t PROCON2;  ///< Offset: 0x1028 - Flash Protection Configuration Register User 2
    };

    /// Peripheral instances
    inline Registers* FLASH0 = reinterpret_cast<Registers*>(FLASH0_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// FSR Register bits
    namespace fsr_bits {
        constexpr uint32_t PBUSY = (1U << 0);  ///< Program Flash Busy
        constexpr uint32_t FABUSY = (1U << 1);  ///< Flash Array Busy
        constexpr uint32_t PROG = (1U << 4);  ///< Programming State
        constexpr uint32_t ERASE = (1U << 5);  ///< Erase State
        constexpr uint32_t PFPAGE = (1U << 6);  ///< Program Flash in Page Mode
        constexpr uint32_t PFOPER = (1U << 8);  ///< Program Flash Operation Error
        constexpr uint32_t SQER = (1U << 10);  ///< Command Sequence Error
        constexpr uint32_t PROER = (1U << 11);  ///< Protection Error
        constexpr uint32_t PFSBER = (1U << 12);  ///< PFLASH Single-Bit Error and Correction
        constexpr uint32_t PFDBER = (1U << 14);  ///< PFLASH Double-Bit Error
        constexpr uint32_t PROIN = (1U << 16);  ///< Protection Installed
        constexpr uint32_t RPROIN = (1U << 18);  ///< Read Protection Installed
        constexpr uint32_t RPRODIS = (1U << 19);  ///< Read Protection Disable State
        constexpr uint32_t WPROIN0 = (1U << 21);  ///< Sector Write Protection Installed for User 0
        constexpr uint32_t WPROIN1 = (1U << 22);  ///< Sector Write Protection Installed for User 1
        constexpr uint32_t WPROIN2 = (1U << 23);  ///< Sector OTP Protection Installed for User 2
        constexpr uint32_t WPRODIS0 = (1U << 25);  ///< Sector Write Protection Disabled for User 0
        constexpr uint32_t WPRODIS1 = (1U << 26);  ///< Sector Write Protection Disabled for User 1
        constexpr uint32_t SLM = (1U << 28);  ///< Flash Sleep Mode
        constexpr uint32_t VER = (1U << 31);  ///< Verify Error
    }

    /// FCON Register bits
    namespace fcon_bits {
        constexpr uint32_t WSPFLASH = (4 << 0);  ///< Wait States for read access to PFLASH
        constexpr uint32_t WSECPF = (1U << 4);  ///< Wait State for Error Correction of PFLASH
        constexpr uint32_t IDLE = (1U << 13);  ///< Dynamic Flash Idle
        constexpr uint32_t ESLDIS = (1U << 14);  ///< External Sleep Request Disable
        constexpr uint32_t SLEEP = (1U << 15);  ///< Flash SLEEP
        constexpr uint32_t RPA = (1U << 16);  ///< Read Protection Activated
        constexpr uint32_t DCF = (1U << 17);  ///< Disable Code Fetch from Flash Memory
        constexpr uint32_t DDF = (1U << 18);  ///< Disable Any Data Fetch from Flash
        constexpr uint32_t VOPERM = (1U << 24);  ///< Verify and Operation Error Interrupt Mask
        constexpr uint32_t SQERM = (1U << 25);  ///< Command Sequence Error Interrupt Mask
        constexpr uint32_t PROERM = (1U << 26);  ///< Protection Error Interrupt Mask
        constexpr uint32_t PFSBERM = (1U << 27);  ///< PFLASH Single-Bit Error Interrupt Mask
        constexpr uint32_t PFDBERM = (1U << 29);  ///< PFLASH Double-Bit Error Interrupt Mask
        constexpr uint32_t EOBM = (1U << 31);  ///< End of Busy Interrupt Mask
    }

    /// MARP Register bits
    namespace marp_bits {
        constexpr uint32_t MARGIN = (4 << 0);  ///< PFLASH Margin Selection
        constexpr uint32_t TRAPDIS = (1U << 15);  ///< PFLASH Double-Bit Error Trap Disable
    }

    /// PROCON0 Register bits
    namespace procon0_bits {
        constexpr uint32_t S0L = (1U << 0);  ///< Sector 0 Locked for Write Protection by User 0
        constexpr uint32_t S1L = (1U << 1);  ///< Sector 1 Locked for Write Protection by User 0
        constexpr uint32_t S2L = (1U << 2);  ///< Sector 2 Locked for Write Protection by User 0
        constexpr uint32_t S3L = (1U << 3);  ///< Sector 3 Locked for Write Protection by User 0
        constexpr uint32_t S4L = (1U << 4);  ///< Sector 4 Locked for Write Protection by User 0
        constexpr uint32_t S5L = (1U << 5);  ///< Sector 5 Locked for Write Protection by User 0
        constexpr uint32_t S6L = (1U << 6);  ///< Sector 6 Locked for Write Protection by User 0
        constexpr uint32_t S7L = (1U << 7);  ///< Sector 7 Locked for Write Protection by User 0
        constexpr uint32_t S8L = (1U << 8);  ///< Sector 8 Locked for Write Protection by User 0
        constexpr uint32_t RPRO = (1U << 15);  ///< Read Protection Configuration
    }

    /// PROCON1 Register bits
    namespace procon1_bits {
        constexpr uint32_t S0L = (1U << 0);  ///< Sector 0 Locked for Write Protection by User 1
        constexpr uint32_t S1L = (1U << 1);  ///< Sector 1 Locked for Write Protection by User 1
        constexpr uint32_t S2L = (1U << 2);  ///< Sector 2 Locked for Write Protection by User 1
        constexpr uint32_t S3L = (1U << 3);  ///< Sector 3 Locked for Write Protection by User 1
        constexpr uint32_t S4L = (1U << 4);  ///< Sector 4 Locked for Write Protection by User 1
        constexpr uint32_t S5L = (1U << 5);  ///< Sector 5 Locked for Write Protection by User 1
        constexpr uint32_t S6L = (1U << 6);  ///< Sector 6 Locked for Write Protection by User 1
        constexpr uint32_t S7L = (1U << 7);  ///< Sector 7 Locked for Write Protection by User 1
        constexpr uint32_t S8L = (1U << 8);  ///< Sector 8 Locked for Write Protection by User 1
        constexpr uint32_t PSR = (1U << 16);  ///< Physical Sector Repair
    }

    /// PROCON2 Register bits
    namespace procon2_bits {
        constexpr uint32_t S0ROM = (1U << 0);  ///< Sector 0 Locked Forever by User 2
        constexpr uint32_t S1ROM = (1U << 1);  ///< Sector 1 Locked Forever by User 2
        constexpr uint32_t S2ROM = (1U << 2);  ///< Sector 2 Locked Forever by User 2
        constexpr uint32_t S3ROM = (1U << 3);  ///< Sector 3 Locked Forever by User 2
        constexpr uint32_t S4ROM = (1U << 4);  ///< Sector 4 Locked Forever by User 2
        constexpr uint32_t S5ROM = (1U << 5);  ///< Sector 5 Locked Forever by User 2
        constexpr uint32_t S6ROM = (1U << 6);  ///< Sector 6 Locked Forever by User 2
        constexpr uint32_t S7ROM = (1U << 7);  ///< Sector 7 Locked Forever by User 2
        constexpr uint32_t S8ROM = (1U << 8);  ///< Sector 8 Locked Forever by User 2
    }

}

// ============================================================================
// PREF Peripheral
// ============================================================================

namespace pref {
    /// Base addresses
    constexpr uint32_t PREF_BASE = 0x58004000;

    /// PREF Register structure
    struct Registers {
        volatile uint32_t PCON;  ///< Offset: 0x00 - Prefetch Configuration Register
    };

    /// Peripheral instances
    inline Registers* PREF = reinterpret_cast<Registers*>(PREF_BASE);

    // Bit definitions
    /// PCON Register bits
    namespace pcon_bits {
        constexpr uint32_t IBYP = (1U << 0);  ///< Instruction Prefetch Buffer Bypass
        constexpr uint32_t IINV = (1U << 1);  ///< Instruction Prefetch Buffer Invalidate
        constexpr uint32_t DBYP = (1U << 4);  ///< Data Buffer Bypass
    }

}

// ============================================================================
// PMU0 Peripheral
// ============================================================================

namespace pmu0 {
    /// Base addresses
    constexpr uint32_t PMU0_BASE = 0x58000508;

    /// PMU0 Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - PMU0 Identification Register
    };

    /// Peripheral instances
    inline Registers* PMU0 = reinterpret_cast<Registers*>(PMU0_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x50008000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - WDT ID Register
        volatile uint32_t CTR;  ///< Offset: 0x04 - WDT Control Register
        volatile uint32_t SRV;  ///< Offset: 0x08 - WDT Service Register
        volatile uint32_t TIM;  ///< Offset: 0x0C - WDT Timer Register
        volatile uint32_t WLB;  ///< Offset: 0x10 - WDT Window Lower Bound Register
        volatile uint32_t WUB;  ///< Offset: 0x14 - WDT Window Upper Bound Register
        volatile uint32_t WDTSTS;  ///< Offset: 0x18 - WDT Status Register
        volatile uint32_t WDTCLR;  ///< Offset: 0x1C - WDT Clear Register
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t ENB = (1U << 0);  ///< Enable
        constexpr uint32_t PRE = (1U << 1);  ///< Pre-warning
        constexpr uint32_t DSP = (1U << 4);  ///< Debug Suspend
        constexpr uint32_t SPW = (8 << 8);  ///< Service Indication Pulse Width
    }

    /// SRV Register bits
    namespace srv_bits {
        constexpr uint32_t SRV = (32 << 0);  ///< Service
    }

    /// TIM Register bits
    namespace tim_bits {
        constexpr uint32_t TIM = (32 << 0);  ///< Timer Value
    }

    /// WLB Register bits
    namespace wlb_bits {
        constexpr uint32_t WLB = (32 << 0);  ///< Window Lower Bound
    }

    /// WUB Register bits
    namespace wub_bits {
        constexpr uint32_t WUB = (32 << 0);  ///< Window Upper Bound
    }

    /// WDTSTS Register bits
    namespace wdtsts_bits {
        constexpr uint32_t ALMS = (1U << 0);  ///< Pre-warning Alarm
    }

    /// WDTCLR Register bits
    namespace wdtclr_bits {
        constexpr uint32_t ALMC = (1U << 0);  ///< Pre-warning Alarm
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x50004A00;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - RTC ID Register
        volatile uint32_t CTR;  ///< Offset: 0x04 - RTC Control Register
        volatile uint32_t RAWSTAT;  ///< Offset: 0x08 - RTC Raw Service Request Register
        volatile uint32_t STSSR;  ///< Offset: 0x0C - RTC Service Request Status Register
        volatile uint32_t MSKSR;  ///< Offset: 0x10 - RTC Service Request Mask Register
        volatile uint32_t CLRSR;  ///< Offset: 0x14 - RTC Clear Service Request Register
        volatile uint32_t ATIM0;  ///< Offset: 0x18 - RTC Alarm Time Register 0
        volatile uint32_t ATIM1;  ///< Offset: 0x1C - RTC Alarm Time Register 1
        volatile uint32_t TIM0;  ///< Offset: 0x20 - RTC Time Register 0
        volatile uint32_t TIM1;  ///< Offset: 0x24 - RTC Time Register 1
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t ENB = (1U << 0);  ///< RTC Module Enable
        constexpr uint32_t TAE = (1U << 2);  ///< Timer Alarm Enable for Hibernation Wake-up
        constexpr uint32_t ESEC = (1U << 8);  ///< Enable Seconds Comparison for Hibernation Wake-up
        constexpr uint32_t EMIC = (1U << 9);  ///< Enable Minutes Comparison for Hibernation Wake-up
        constexpr uint32_t EHOC = (1U << 10);  ///< Enable Hours Comparison for Hibernation Wake-up
        constexpr uint32_t EDAC = (1U << 11);  ///< Enable Days Comparison for Hibernation Wake-up
        constexpr uint32_t EMOC = (1U << 13);  ///< Enable Months Comparison for Hibernation Wake-up
        constexpr uint32_t EYEC = (1U << 14);  ///< Enable Years Comparison for Hibernation Wake-up
        constexpr uint32_t DIV = (16 << 16);  ///< RTC Clock Divider Value
    }

    /// RAWSTAT Register bits
    namespace rawstat_bits {
        constexpr uint32_t RPSE = (1U << 0);  ///< Raw Periodic Seconds Service Request
        constexpr uint32_t RPMI = (1U << 1);  ///< Raw Periodic Minutes Service Request
        constexpr uint32_t RPHO = (1U << 2);  ///< Raw Periodic Hours Service Request
        constexpr uint32_t RPDA = (1U << 3);  ///< Raw Periodic Days Service Request
        constexpr uint32_t RPMO = (1U << 5);  ///< Raw Periodic Months Service Request
        constexpr uint32_t RPYE = (1U << 6);  ///< Raw Periodic Years Service Request
        constexpr uint32_t RAI = (1U << 8);  ///< Raw Alarm Service Request
    }

    /// STSSR Register bits
    namespace stssr_bits {
        constexpr uint32_t SPSE = (1U << 0);  ///< Periodic Seconds Service Request Status after Masking
        constexpr uint32_t SPMI = (1U << 1);  ///< Periodic Minutes Service Request Status after Masking
        constexpr uint32_t SPHO = (1U << 2);  ///< Periodic Hours Service Request Status after Masking
        constexpr uint32_t SPDA = (1U << 3);  ///< Periodic Days Service Request Status after Masking
        constexpr uint32_t SPMO = (1U << 5);  ///< Periodic Months Service Request Status after Masking
        constexpr uint32_t SPYE = (1U << 6);  ///< Periodic Years Service Request Status after Masking
        constexpr uint32_t SAI = (1U << 8);  ///< Alarm Service Request Status after Masking
    }

    /// MSKSR Register bits
    namespace msksr_bits {
        constexpr uint32_t MPSE = (1U << 0);  ///< Periodic Seconds Interrupt Mask
        constexpr uint32_t MPMI = (1U << 1);  ///< Periodic Minutes Interrupt Mask
        constexpr uint32_t MPHO = (1U << 2);  ///< Periodic Hours Interrupt Mask
        constexpr uint32_t MPDA = (1U << 3);  ///< Periodic Days Interrupt Mask
        constexpr uint32_t MPMO = (1U << 5);  ///< Periodic Months Interrupt Mask
        constexpr uint32_t MPYE = (1U << 6);  ///< Periodic Years Interrupt Mask
        constexpr uint32_t MAI = (1U << 8);  ///< Alarm Interrupt Mask
    }

    /// CLRSR Register bits
    namespace clrsr_bits {
        constexpr uint32_t RPSE = (1U << 0);  ///< Periodic Seconds Interrupt Clear
        constexpr uint32_t RPMI = (1U << 1);  ///< Periodic Minutes Interrupt Clear
        constexpr uint32_t RPHO = (1U << 2);  ///< Periodic Hours Interrupt Clear
        constexpr uint32_t RPDA = (1U << 3);  ///< Periodic Days Interrupt Clear
        constexpr uint32_t RPMO = (1U << 5);  ///< Periodic Months Interrupt Clear
        constexpr uint32_t RPYE = (1U << 6);  ///< Periodic Years Interrupt Clear
        constexpr uint32_t RAI = (1U << 8);  ///< Alarm Interrupt Clear
    }

    /// ATIM0 Register bits
    namespace atim0_bits {
        constexpr uint32_t ASE = (6 << 0);  ///< Alarm Seconds Compare Value
        constexpr uint32_t AMI = (6 << 8);  ///< Alarm Minutes Compare Value
        constexpr uint32_t AHO = (5 << 16);  ///< Alarm Hours Compare Value
        constexpr uint32_t ADA = (5 << 24);  ///< Alarm Days Compare Value
    }

    /// ATIM1 Register bits
    namespace atim1_bits {
        constexpr uint32_t AMO = (4 << 8);  ///< Alarm Month Compare Value
        constexpr uint32_t AYE = (16 << 16);  ///< Alarm Year Compare Value
    }

    /// TIM0 Register bits
    namespace tim0_bits {
        constexpr uint32_t SE = (6 << 0);  ///< Seconds Time Value
        constexpr uint32_t MI = (6 << 8);  ///< Minutes Time Value
        constexpr uint32_t HO = (5 << 16);  ///< Hours Time Value
        constexpr uint32_t DA = (5 << 24);  ///< Days Time Value
    }

    /// TIM1 Register bits
    namespace tim1_bits {
        constexpr uint32_t DAWE = (3 << 0);  ///< Days of Week Time Value
        constexpr uint32_t MO = (4 << 8);  ///< Month Time Value
        constexpr uint32_t YE = (16 << 16);  ///< Year Time Value
    }

}

// ============================================================================
// SCU Peripheral
// ============================================================================

namespace scu {
    /// Base addresses
    constexpr uint32_t SCU_CLK_BASE = 0x50004600;
    constexpr uint32_t SCU_OSC_BASE = 0x50004700;
    constexpr uint32_t SCU_PLL_BASE = 0x50004710;
    constexpr uint32_t SCU_GENERAL_BASE = 0x50004000;
    constexpr uint32_t SCU_INTERRUPT_BASE = 0x50004074;
    constexpr uint32_t SCU_PARITY_BASE = 0x5000413C;
    constexpr uint32_t SCU_TRAP_BASE = 0x50004160;
    constexpr uint32_t SCU_HIBERNATE_BASE = 0x50004300;
    constexpr uint32_t SCU_RESET_BASE = 0x50004400;

    /// SCU Register structure
    struct Registers {
        volatile uint32_t CLKSTAT;  ///< Offset: 0x00 - Clock Status Register
        volatile uint32_t CLKSET;  ///< Offset: 0x04 - CLK Set Register
        volatile uint32_t CLKCLR;  ///< Offset: 0x08 - CLK Clear Register
        volatile uint32_t SYSCLKCR;  ///< Offset: 0x0C - System Clock Control Register
        volatile uint32_t CPUCLKCR;  ///< Offset: 0x10 - CPU Clock Control Register
        volatile uint32_t PBCLKCR;  ///< Offset: 0x14 - Peripheral Bus Clock Control Register
        volatile uint32_t USBCLKCR;  ///< Offset: 0x18 - USB Clock Control Register
        volatile uint32_t CCUCLKCR;  ///< Offset: 0x20 - CCU Clock Control Register
        volatile uint32_t WDTCLKCR;  ///< Offset: 0x24 - WDT Clock Control Register
        volatile uint32_t EXTCLKCR;  ///< Offset: 0x28 - External Clock Control
        volatile uint32_t MLINKCLKCR;  ///< Offset: 0x2C - Multi-Link Clock Control
        volatile uint32_t SLEEPCR;  ///< Offset: 0x30 - Sleep Control Register
        volatile uint32_t DSLEEPCR;  ///< Offset: 0x34 - Deep Sleep Control Register
        volatile uint32_t ECATCLKCR;  ///< Offset: 0x38 - EtherCAT Clock Control Register
        volatile uint32_t CGATSTAT0;  ///< Offset: 0x40 - Peripheral 0 Clock Gating Status
        volatile uint32_t CGATSET0;  ///< Offset: 0x44 - Peripheral 0 Clock Gating Set
        volatile uint32_t CGATCLR0;  ///< Offset: 0x48 - Peripheral 0 Clock Gating Clear
        volatile uint32_t CGATSTAT1;  ///< Offset: 0x4C - Peripheral 1 Clock Gating Status
        volatile uint32_t CGATSET1;  ///< Offset: 0x50 - Peripheral 1 Clock Gating Set
        volatile uint32_t CGATCLR1;  ///< Offset: 0x54 - Peripheral 1 Clock Gating Clear
        volatile uint32_t CGATSTAT2;  ///< Offset: 0x58 - Peripheral 2 Clock Gating Status
        volatile uint32_t CGATSET2;  ///< Offset: 0x5C - Peripheral 2 Clock Gating Set
        volatile uint32_t CGATCLR2;  ///< Offset: 0x60 - Peripheral 2 Clock Gating Clear
    };

    /// Peripheral instances
    inline Registers* SCU_CLK = reinterpret_cast<Registers*>(SCU_CLK_BASE);
    inline Registers* SCU_OSC = reinterpret_cast<Registers*>(SCU_OSC_BASE);
    inline Registers* SCU_PLL = reinterpret_cast<Registers*>(SCU_PLL_BASE);
    inline Registers* SCU_GENERAL = reinterpret_cast<Registers*>(SCU_GENERAL_BASE);
    inline Registers* SCU_INTERRUPT = reinterpret_cast<Registers*>(SCU_INTERRUPT_BASE);
    inline Registers* SCU_PARITY = reinterpret_cast<Registers*>(SCU_PARITY_BASE);
    inline Registers* SCU_TRAP = reinterpret_cast<Registers*>(SCU_TRAP_BASE);
    inline Registers* SCU_HIBERNATE = reinterpret_cast<Registers*>(SCU_HIBERNATE_BASE);
    inline Registers* SCU_RESET = reinterpret_cast<Registers*>(SCU_RESET_BASE);

    // Bit definitions
    /// CLKSTAT Register bits
    namespace clkstat_bits {
        constexpr uint32_t USBCST = (1U << 0);  ///< USB Clock Status
        constexpr uint32_t MMCCST = (1U << 1);  ///< MMC Clock Status
        constexpr uint32_t ETH0CST = (1U << 2);  ///< Ethernet Clock Status
        constexpr uint32_t CCUCST = (1U << 4);  ///< CCU Clock Status
        constexpr uint32_t WDTCST = (1U << 5);  ///< WDT Clock Status
    }

    /// CLKSET Register bits
    namespace clkset_bits {
        constexpr uint32_t USBCEN = (1U << 0);  ///< USB Clock Enable
        constexpr uint32_t MMCCEN = (1U << 1);  ///< MMC Clock Enable
        constexpr uint32_t ETH0CEN = (1U << 2);  ///< Ethernet Clock Enable
        constexpr uint32_t CCUCEN = (1U << 4);  ///< CCU Clock Enable
        constexpr uint32_t WDTCEN = (1U << 5);  ///< WDT Clock Enable
    }

    /// CLKCLR Register bits
    namespace clkclr_bits {
        constexpr uint32_t USBCDI = (1U << 0);  ///< USB Clock Disable
        constexpr uint32_t MMCCDI = (1U << 1);  ///< MMC Clock Disable
        constexpr uint32_t ETH0CDI = (1U << 2);  ///< Ethernet Clock Disable
        constexpr uint32_t CCUCDI = (1U << 4);  ///< CCU Clock Disable
        constexpr uint32_t WDTCDI = (1U << 5);  ///< WDT Clock Disable
    }

    /// SYSCLKCR Register bits
    namespace sysclkcr_bits {
        constexpr uint32_t SYSDIV = (8 << 0);  ///< System Clock Division Value
        constexpr uint32_t SYSSEL = (1U << 16);  ///< System Clock Selection Value
    }

    /// CPUCLKCR Register bits
    namespace cpuclkcr_bits {
        constexpr uint32_t CPUDIV = (1U << 0);  ///< CPU Clock Divider Enable
    }

    /// PBCLKCR Register bits
    namespace pbclkcr_bits {
        constexpr uint32_t PBDIV = (1U << 0);  ///< PB Clock Divider Enable
    }

    /// USBCLKCR Register bits
    namespace usbclkcr_bits {
        constexpr uint32_t USBDIV = (3 << 0);  ///< USB Clock Divider Value
        constexpr uint32_t USBSEL = (1U << 16);  ///< USB Clock Selection Value
    }

    /// CCUCLKCR Register bits
    namespace ccuclkcr_bits {
        constexpr uint32_t CCUDIV = (1U << 0);  ///< CCU Clock Divider Enable
    }

    /// WDTCLKCR Register bits
    namespace wdtclkcr_bits {
        constexpr uint32_t WDTDIV = (8 << 0);  ///< WDT Clock Divider Value
        constexpr uint32_t WDTSEL = (2 << 16);  ///< WDT Clock Selection Value
    }

    /// EXTCLKCR Register bits
    namespace extclkcr_bits {
        constexpr uint32_t ECKSEL = (2 << 0);  ///< External Clock Selection Value
        constexpr uint32_t ECKDIV = (9 << 16);  ///< External Clock Divider Value
    }

    /// MLINKCLKCR Register bits
    namespace mlinkclkcr_bits {
        constexpr uint32_t SYSDIV = (8 << 0);  ///< System Clock Division Value
        constexpr uint32_t SYSSEL = (1U << 8);  ///< System Clock Selection Value
        constexpr uint32_t CPUDIV = (1U << 10);  ///< CPU Clock Divider Enable
        constexpr uint32_t PBDIV = (1U << 12);  ///< PB Clock Divider Enable
        constexpr uint32_t CCUDIV = (1U << 14);  ///< CCU Clock Divider Enable
        constexpr uint32_t WDTDIV = (8 << 16);  ///< WDT Clock Divider Value
        constexpr uint32_t WDTSEL = (2 << 24);  ///< WDT Clock Selection Value
    }

    /// SLEEPCR Register bits
    namespace sleepcr_bits {
        constexpr uint32_t SYSSEL = (1U << 0);  ///< System Clock Selection Value
        constexpr uint32_t USBCR = (1U << 16);  ///< USB Clock Control in Sleep Mode
        constexpr uint32_t MMCCR = (1U << 17);  ///< MMC Clock Control in Sleep Mode
        constexpr uint32_t ETH0CR = (1U << 18);  ///< Ethernet Clock Control in Sleep Mode
        constexpr uint32_t CCUCR = (1U << 20);  ///< CCU Clock Control in Sleep Mode
        constexpr uint32_t WDTCR = (1U << 21);  ///< WDT Clock Control in Sleep Mode
    }

    /// DSLEEPCR Register bits
    namespace dsleepcr_bits {
        constexpr uint32_t SYSSEL = (1U << 0);  ///< System Clock Selection Value
        constexpr uint32_t FPDN = (1U << 11);  ///< Flash Power Down
        constexpr uint32_t PLLPDN = (1U << 12);  ///< PLL Power Down
        constexpr uint32_t VCOPDN = (1U << 13);  ///< VCO Power Down
        constexpr uint32_t USBCR = (1U << 16);  ///< USB Clock Control in Deep Sleep Mode
        constexpr uint32_t MMCCR = (1U << 17);  ///< MMC Clock Control in Deep Sleep Mode
        constexpr uint32_t ETH0CR = (1U << 18);  ///< Ethernet Clock Control in Deep Sleep Mode
        constexpr uint32_t CCUCR = (1U << 20);  ///< CCU Clock Control in Deep Sleep Mode
        constexpr uint32_t WDTCR = (1U << 21);  ///< WDT Clock Control in Deep Sleep Mode
    }

    /// ECATCLKCR Register bits
    namespace ecatclkcr_bits {
        constexpr uint32_t ECADIV = (2 << 0);  ///< EtherCAT Clock Divider Value
        constexpr uint32_t ECATSEL = (1U << 16);  ///< EtherCAT Clock Selection Value
    }

    /// CGATSTAT0 Register bits
    namespace cgatstat0_bits {
        constexpr uint32_t VADC = (1U << 0);  ///< VADC Gating Status
        constexpr uint32_t CCU40 = (1U << 2);  ///< CCU40 Gating Status
        constexpr uint32_t CCU41 = (1U << 3);  ///< CCU41 Gating Status
        constexpr uint32_t CCU80 = (1U << 7);  ///< CCU80 Gating Status
        constexpr uint32_t POSIF0 = (1U << 9);  ///< POSIF0 Gating Status
        constexpr uint32_t USIC0 = (1U << 11);  ///< USIC0 Gating Status
        constexpr uint32_t ERU1 = (1U << 16);  ///< ERU1 Gating Status
    }

    /// CGATSET0 Register bits
    namespace cgatset0_bits {
        constexpr uint32_t VADC = (1U << 0);  ///< VADC Gating Set
        constexpr uint32_t CCU40 = (1U << 2);  ///< CCU40 Gating Set
        constexpr uint32_t CCU41 = (1U << 3);  ///< CCU41 Gating Set
        constexpr uint32_t CCU80 = (1U << 7);  ///< CCU80 Gating Set
        constexpr uint32_t POSIF0 = (1U << 9);  ///< POSIF0 Gating Set
        constexpr uint32_t USIC0 = (1U << 11);  ///< USIC0 Gating Set
        constexpr uint32_t ERU1 = (1U << 16);  ///< ERU1 Gating Set
    }

    /// CGATCLR0 Register bits
    namespace cgatclr0_bits {
        constexpr uint32_t VADC = (1U << 0);  ///< VADC Gating Clear
        constexpr uint32_t CCU40 = (1U << 2);  ///< CCU40 Gating Clear
        constexpr uint32_t CCU41 = (1U << 3);  ///< CCU41 Gating Clear
        constexpr uint32_t CCU80 = (1U << 7);  ///< CCU80 Gating Clear
        constexpr uint32_t POSIF0 = (1U << 9);  ///< POSIF0 Gating Clear
        constexpr uint32_t USIC0 = (1U << 11);  ///< USIC0 Gating Clear
        constexpr uint32_t ERU1 = (1U << 16);  ///< ERU1 Gating Clear
    }

    /// CGATSTAT1 Register bits
    namespace cgatstat1_bits {
        constexpr uint32_t LEDTSCU0 = (1U << 3);  ///< LEDTS Gating Status
        constexpr uint32_t MCAN0 = (1U << 4);  ///< MultiCAN Gating Status
        constexpr uint32_t DAC = (1U << 5);  ///< DAC Gating Status
        constexpr uint32_t MMCI = (1U << 6);  ///< MMC Interface Gating Status
        constexpr uint32_t USIC1 = (1U << 7);  ///< USIC1 Gating Status
        constexpr uint32_t PPORTS = (1U << 9);  ///< PORTS Gating Status
    }

    /// CGATSET1 Register bits
    namespace cgatset1_bits {
        constexpr uint32_t LEDTSCU0 = (1U << 3);  ///< LEDTS Gating Set
        constexpr uint32_t MCAN0 = (1U << 4);  ///< MultiCAN Gating Set
        constexpr uint32_t DAC = (1U << 5);  ///< DAC Gating Set
        constexpr uint32_t MMCI = (1U << 6);  ///< MMC Interface Gating Set
        constexpr uint32_t USIC1 = (1U << 7);  ///< USIC1 Gating Set
        constexpr uint32_t PPORTS = (1U << 9);  ///< PORTS Gating Set
    }

    /// CGATCLR1 Register bits
    namespace cgatclr1_bits {
        constexpr uint32_t LEDTSCU0 = (1U << 3);  ///< LEDTS Gating Clear
        constexpr uint32_t MCAN0 = (1U << 4);  ///< MultiCAN Gating Clear
        constexpr uint32_t DAC = (1U << 5);  ///< DAC Gating Clear
        constexpr uint32_t MMCI = (1U << 6);  ///< MMC Interface Gating Clear
        constexpr uint32_t USIC1 = (1U << 7);  ///< USIC1 Gating Clear
        constexpr uint32_t PPORTS = (1U << 9);  ///< PORTS Gating Clear
    }

    /// CGATSTAT2 Register bits
    namespace cgatstat2_bits {
        constexpr uint32_t WDT = (1U << 1);  ///< WDT Gating Status
        constexpr uint32_t ETH0 = (1U << 2);  ///< ETH0 Gating Status
        constexpr uint32_t DMA0 = (1U << 4);  ///< DMA0 Gating Status
        constexpr uint32_t FCE = (1U << 6);  ///< FCE Gating Status
        constexpr uint32_t USB = (1U << 7);  ///< USB Gating Status
        constexpr uint32_t ECAT0 = (1U << 10);  ///< ECAT0 Gating Status
    }

    /// CGATSET2 Register bits
    namespace cgatset2_bits {
        constexpr uint32_t WDT = (1U << 1);  ///< WDT Gating Set
        constexpr uint32_t ETH0 = (1U << 2);  ///< ETH0 Gating Set
        constexpr uint32_t DMA0 = (1U << 4);  ///< DMA0 Gating Set
        constexpr uint32_t FCE = (1U << 6);  ///< FCE Gating Set
        constexpr uint32_t USB = (1U << 7);  ///< USB Gating Set
        constexpr uint32_t ECAT0 = (1U << 10);  ///< ECAT0 Gating Set
    }

    /// CGATCLR2 Register bits
    namespace cgatclr2_bits {
        constexpr uint32_t WDT = (1U << 1);  ///< WDT Gating Clear
        constexpr uint32_t ETH0 = (1U << 2);  ///< ETH0 Gating Clear
        constexpr uint32_t DMA0 = (1U << 4);  ///< DMA0 Gating Clear
        constexpr uint32_t FCE = (1U << 6);  ///< FCE Gating Clear
        constexpr uint32_t USB = (1U << 7);  ///< USB Gating Clear
        constexpr uint32_t ECAT0 = (1U << 10);  ///< ECAT0 Gating Clear
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t SCU_POWER_BASE = 0x50004200;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t PWRSTAT;  ///< Offset: 0x00 - PCU Status Register
        volatile uint32_t PWRSET;  ///< Offset: 0x04 - PCU Set Control Register
        volatile uint32_t PWRCLR;  ///< Offset: 0x08 - PCU Clear Control Register
        volatile uint32_t EVRSTAT;  ///< Offset: 0x10 - EVR Status Register
        volatile uint32_t EVRVADCSTAT;  ///< Offset: 0x14 - EVR VADC Status Register
        volatile uint32_t PWRMON;  ///< Offset: 0x2C - Power Monitor Control
    };

    /// Peripheral instances
    inline Registers* SCU_POWER = reinterpret_cast<Registers*>(SCU_POWER_BASE);

    // Bit definitions
    /// PWRSTAT Register bits
    namespace pwrstat_bits {
        constexpr uint32_t HIBEN = (1U << 0);  ///< Hibernate Domain Enable Status
        constexpr uint32_t USBPHYPDQ = (1U << 16);  ///< USB PHY Transceiver State
        constexpr uint32_t USBOTGEN = (1U << 17);  ///< USB On-The-Go Comparators State
        constexpr uint32_t USBPUWQ = (1U << 18);  ///< USB Weak Pull-Up at PADN State
    }

    /// PWRSET Register bits
    namespace pwrset_bits {
        constexpr uint32_t HIB = (1U << 0);  ///< Set Hibernate Domain Enable
        constexpr uint32_t USBPHYPDQ = (1U << 16);  ///< Set USB PHY Transceiver Disable
        constexpr uint32_t USBOTGEN = (1U << 17);  ///< Set USB On-The-Go Comparators Enable
        constexpr uint32_t USBPUWQ = (1U << 18);  ///< Set USB Weak Pull-Up at PADN Enable
    }

    /// PWRCLR Register bits
    namespace pwrclr_bits {
        constexpr uint32_t HIB = (1U << 0);  ///< Clear Disable Hibernate Domain
        constexpr uint32_t USBPHYPDQ = (1U << 16);  ///< Clear USB PHY Transceiver Disable
        constexpr uint32_t USBOTGEN = (1U << 17);  ///< Clear USB On-The-Go Comparators Enable
        constexpr uint32_t USBPUWQ = (1U << 18);  ///< Clear USB Weak Pull-Up at PADN Enable
    }

    /// EVRSTAT Register bits
    namespace evrstat_bits {
        constexpr uint32_t OV13 = (1U << 1);  ///< Regulator Overvoltage for 1.3 V
    }

    /// EVRVADCSTAT Register bits
    namespace evrvadcstat_bits {
        constexpr uint32_t VADC13V = (8 << 0);  ///< VADC 1.3 V Conversion Result
        constexpr uint32_t VADC33V = (8 << 8);  ///< VADC 3.3 V Conversion Result
    }

    /// PWRMON Register bits
    namespace pwrmon_bits {
        constexpr uint32_t THRS = (8 << 0);  ///< Threshold
        constexpr uint32_t INTV = (8 << 8);  ///< Interval
        constexpr uint32_t ENB = (1U << 16);  ///< Enable
    }

}

// ============================================================================
// LEDTS0 Peripheral
// ============================================================================

namespace ledts0 {
    /// Base addresses
    constexpr uint32_t LEDTS0_BASE = 0x48010000;

    /// LEDTS0 Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - Module Identification Register
        volatile uint32_t GLOBCTL;  ///< Offset: 0x04 - Global Control Register
        volatile uint32_t FNCTL;  ///< Offset: 0x08 - Function Control Register
        volatile uint32_t EVFR;  ///< Offset: 0x0C - Event Flag Register
        volatile uint32_t TSVAL;  ///< Offset: 0x10 - Touch-sense TS-Counter Value
        volatile uint32_t LINE0;  ///< Offset: 0x14 - Line Pattern Register 0
        volatile uint32_t LINE1;  ///< Offset: 0x18 - Line Pattern Register 1
        volatile uint32_t LDCMP0;  ///< Offset: 0x1C - LED Compare Register 0
        volatile uint32_t LDCMP1;  ///< Offset: 0x20 - LED Compare Register 1
        volatile uint32_t TSCMP0;  ///< Offset: 0x24 - Touch-sense Compare Register 0
        volatile uint32_t TSCMP1;  ///< Offset: 0x28 - Touch-sense Compare Register 1
    };

    /// Peripheral instances
    inline Registers* LEDTS0 = reinterpret_cast<Registers*>(LEDTS0_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// GLOBCTL Register bits
    namespace globctl_bits {
        constexpr uint32_t TS_EN = (1U << 0);  ///< Touch-Sense Function Enable
        constexpr uint32_t LD_EN = (1U << 1);  ///< LED Function Enable
        constexpr uint32_t CMTR = (1U << 2);  ///< Clock Master Disable
        constexpr uint32_t ENSYNC = (1U << 3);  ///< Enable Autoscan Time Period Synchronization
        constexpr uint32_t SUSCFG = (1U << 8);  ///< Suspend Request Configuration
        constexpr uint32_t MASKVAL = (3 << 9);  ///< Mask Number of LSB Bits for Event Validation
        constexpr uint32_t FENVAL = (1U << 12);  ///< Enable (Extended) Time Frame Validation
        constexpr uint32_t ITS_EN = (1U << 13);  ///< Enable Time Slice Interrupt
        constexpr uint32_t ITF_EN = (1U << 14);  ///< Enable (Extended) Time Frame Interrupt
        constexpr uint32_t ITP_EN = (1U << 15);  ///< Enable Autoscan Time Period Interrupt
        constexpr uint32_t CLK_PS = (16 << 16);  ///< LEDTS-Counter Clock Pre-Scale Factor
    }

    /// FNCTL Register bits
    namespace fnctl_bits {
        constexpr uint32_t PADT = (3 << 0);  ///< Touch-Sense TSIN Pad Turn
        constexpr uint32_t PADTSW = (1U << 3);  ///< Software Control for Touch-Sense Pad Turn
        constexpr uint32_t EPULL = (1U << 4);  ///< Enable External Pull-up Configuration on Pin COLA
        constexpr uint32_t FNCOL = (3 << 5);  ///< Previous Active Function/LED Column Status
        constexpr uint32_t ACCCNT = (4 << 16);  ///< Accumulate Count on Touch-Sense Input
        constexpr uint32_t TSCCMP = (1U << 20);  ///< Common Compare Enable for Touch-Sense
        constexpr uint32_t TSOEXT = (2 << 21);  ///< Extension for Touch-Sense Output for Pin-Low-Level
        constexpr uint32_t TSCTRR = (1U << 23);  ///< TS-Counter Auto Reset
        constexpr uint32_t TSCTRSAT = (1U << 24);  ///< Saturation of TS-Counter
        constexpr uint32_t NR_TSIN = (3 << 25);  ///< Number of Touch-Sense Input
        constexpr uint32_t COLLEV = (1U << 28);  ///< Active Level of LED Column
        constexpr uint32_t NR_LEDCOL = (3 << 29);  ///< Number of LED Columns
    }

    /// EVFR Register bits
    namespace evfr_bits {
        constexpr uint32_t TSF = (1U << 0);  ///< Time Slice Interrupt Flag
        constexpr uint32_t TFF = (1U << 1);  ///< (Extended) Time Frame Interrupt Flag
        constexpr uint32_t TPF = (1U << 2);  ///< Autoscan Time Period Interrupt Flag
        constexpr uint32_t TSCTROVF = (1U << 3);  ///< TS-Counter Overflow Indication
        constexpr uint32_t CTSF = (1U << 16);  ///< Clear Time Slice Interrupt Flag
        constexpr uint32_t CTFF = (1U << 17);  ///< Clear (Extended) Time Frame Interrupt Flag
        constexpr uint32_t CTPF = (1U << 18);  ///< Clear Autoscan Time Period Interrupt Flag
    }

    /// TSVAL Register bits
    namespace tsval_bits {
        constexpr uint32_t TSCTRVALR = (16 << 0);  ///< Shadow TS-Counter (Read)
        constexpr uint32_t TSCTRVAL = (16 << 16);  ///< TS-Counter Value
    }

    /// LINE0 Register bits
    namespace line0_bits {
        constexpr uint32_t LINE_0 = (8 << 0);  ///< Output on LINE[x]
        constexpr uint32_t LINE_1 = (8 << 8);  ///< Output on LINE[x]
        constexpr uint32_t LINE_2 = (8 << 16);  ///< Output on LINE[x]
        constexpr uint32_t LINE_3 = (8 << 24);  ///< Output on LINE[x]
    }

    /// LINE1 Register bits
    namespace line1_bits {
        constexpr uint32_t LINE_4 = (8 << 0);  ///< Output on LINE[x]
        constexpr uint32_t LINE_5 = (8 << 8);  ///< Output on LINE[x]
        constexpr uint32_t LINE_6 = (8 << 16);  ///< Output on LINE[x]
        constexpr uint32_t LINE_A = (8 << 24);  ///< Output on LINE[x]
    }

    /// LDCMP0 Register bits
    namespace ldcmp0_bits {
        constexpr uint32_t CMP_LD0 = (8 << 0);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD1 = (8 << 8);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD2 = (8 << 16);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD3 = (8 << 24);  ///< Compare Value for LED COL[x]
    }

    /// LDCMP1 Register bits
    namespace ldcmp1_bits {
        constexpr uint32_t CMP_LD4 = (8 << 0);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD5 = (8 << 8);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD6 = (8 << 16);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LDA_TSCOM = (8 << 24);  ///< Compare Value for LED COLA / Common Compare Value for Touch-sense Pad Turns
    }

    /// TSCMP0 Register bits
    namespace tscmp0_bits {
        constexpr uint32_t CMP_TS0 = (8 << 0);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS1 = (8 << 8);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS2 = (8 << 16);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS3 = (8 << 24);  ///< Compare Value for Touch-Sense TSIN[x]
    }

    /// TSCMP1 Register bits
    namespace tscmp1_bits {
        constexpr uint32_t CMP_TS4 = (8 << 0);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS5 = (8 << 8);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS6 = (8 << 16);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS7 = (8 << 24);  ///< Compare Value for Touch-Sense TSIN[x]
    }

}

// ============================================================================
// SDIO Peripheral
// ============================================================================

namespace sdio {
    /// Base addresses
    constexpr uint32_t SDMMC_CON_BASE = 0x500040B4;
    constexpr uint32_t SDMMC_BASE = 0x4801C000;

    /// SDIO Register structure
    struct Registers {
        volatile uint32_t SDMMC_CON;  ///< Offset: 0x00 - SDMMC Configuration
    };

    /// Peripheral instances
    inline Registers* SDMMC_CON = reinterpret_cast<Registers*>(SDMMC_CON_BASE);
    inline Registers* SDMMC = reinterpret_cast<Registers*>(SDMMC_BASE);

    // Bit definitions
    /// SDMMC_CON Register bits
    namespace sdmmc_con_bits {
        constexpr uint32_t WPSEL = (1U << 0);  ///< SDMMC Write Protection Input Multiplexer Control
        constexpr uint32_t WPSVAL = (1U << 4);  ///< SDMMC Write Protect Software Control
        constexpr uint32_t CDSEL = (1U << 16);  ///< SDMMC Card Detection Control
        constexpr uint32_t CDSVAL = (1U << 20);  ///< SDMMC Write Protect Software Control
    }

}

// ============================================================================
// ETH Peripheral
// ============================================================================

namespace eth {
    /// Base addresses
    constexpr uint32_t ETH0_CON_BASE = 0x50004040;
    constexpr uint32_t ETH0_BASE = 0x5000C000;

    /// ETH Register structure
    struct Registers {
        volatile uint32_t ETH0_CON;  ///< Offset: 0x00 - Ethernet 0 Port Control Register
    };

    /// Peripheral instances
    inline Registers* ETH0_CON = reinterpret_cast<Registers*>(ETH0_CON_BASE);
    inline Registers* ETH0 = reinterpret_cast<Registers*>(ETH0_BASE);

    // Bit definitions
    /// ETH0_CON Register bits
    namespace eth0_con_bits {
        constexpr uint32_t RXD0 = (2 << 0);  ///< MAC Receive Input 0
        constexpr uint32_t RXD1 = (2 << 2);  ///< MAC Receive Input 1
        constexpr uint32_t RXD2 = (2 << 4);  ///< MAC Receive Input 2
        constexpr uint32_t RXD3 = (2 << 6);  ///< MAC Receive Input 3
        constexpr uint32_t CLK_RMII = (2 << 8);  ///< RMII clock input
        constexpr uint32_t CRS_DV = (2 << 10);  ///< CRS_DV input
        constexpr uint32_t CRS = (2 << 12);  ///< CRS input
        constexpr uint32_t RXER = (2 << 14);  ///< RXER Input
        constexpr uint32_t COL = (2 << 16);  ///< COL input
        constexpr uint32_t CLK_TX = (2 << 18);  ///< CLK_TX input
        constexpr uint32_t MDIO = (2 << 22);  ///< MDIO Input Select
        constexpr uint32_t INFSEL = (1U << 26);  ///< Ethernet MAC Interface Selection
    }

}

// ============================================================================
// ECAT0 Peripheral
// ============================================================================

namespace ecat0 {
    /// Base addresses
    constexpr uint32_t ECAT0_CON_BASE = 0x500041B0;
    constexpr uint32_t ECAT0_BASE = 0x54010000;
    constexpr uint32_t ECAT0_FMMU0_BASE = 0x54010600;
    constexpr uint32_t ECAT0_FMMU1_BASE = 0x54010610;
    constexpr uint32_t ECAT0_FMMU2_BASE = 0x54010620;
    constexpr uint32_t ECAT0_FMMU3_BASE = 0x54010630;
    constexpr uint32_t ECAT0_FMMU4_BASE = 0x54010640;
    constexpr uint32_t ECAT0_FMMU5_BASE = 0x54010650;
    constexpr uint32_t ECAT0_FMMU6_BASE = 0x54010660;
    constexpr uint32_t ECAT0_FMMU7_BASE = 0x54010670;
    constexpr uint32_t ECAT0_SM0_BASE = 0x54010800;
    constexpr uint32_t ECAT0_SM1_BASE = 0x54010808;
    constexpr uint32_t ECAT0_SM2_BASE = 0x54010810;
    constexpr uint32_t ECAT0_SM3_BASE = 0x54010818;
    constexpr uint32_t ECAT0_SM4_BASE = 0x54010820;
    constexpr uint32_t ECAT0_SM5_BASE = 0x54010828;
    constexpr uint32_t ECAT0_SM6_BASE = 0x54010830;
    constexpr uint32_t ECAT0_SM7_BASE = 0x54010838;

    /// ECAT0 Register structure
    struct Registers {
        volatile uint32_t CON;  ///< Offset: 0x00 - EtherCAT 0 Control
        volatile uint32_t CONP0;  ///< Offset: 0x04 - EtherCAT 0 Port 1 Control Register
        volatile uint32_t CONP1;  ///< Offset: 0x08 - EtherCAT 0 Port 1 Control Register
    };

    /// Peripheral instances
    inline Registers* ECAT0_CON = reinterpret_cast<Registers*>(ECAT0_CON_BASE);
    inline Registers* ECAT0 = reinterpret_cast<Registers*>(ECAT0_BASE);
    inline Registers* ECAT0_FMMU0 = reinterpret_cast<Registers*>(ECAT0_FMMU0_BASE);
    inline Registers* ECAT0_FMMU1 = reinterpret_cast<Registers*>(ECAT0_FMMU1_BASE);
    inline Registers* ECAT0_FMMU2 = reinterpret_cast<Registers*>(ECAT0_FMMU2_BASE);
    inline Registers* ECAT0_FMMU3 = reinterpret_cast<Registers*>(ECAT0_FMMU3_BASE);
    inline Registers* ECAT0_FMMU4 = reinterpret_cast<Registers*>(ECAT0_FMMU4_BASE);
    inline Registers* ECAT0_FMMU5 = reinterpret_cast<Registers*>(ECAT0_FMMU5_BASE);
    inline Registers* ECAT0_FMMU6 = reinterpret_cast<Registers*>(ECAT0_FMMU6_BASE);
    inline Registers* ECAT0_FMMU7 = reinterpret_cast<Registers*>(ECAT0_FMMU7_BASE);
    inline Registers* ECAT0_SM0 = reinterpret_cast<Registers*>(ECAT0_SM0_BASE);
    inline Registers* ECAT0_SM1 = reinterpret_cast<Registers*>(ECAT0_SM1_BASE);
    inline Registers* ECAT0_SM2 = reinterpret_cast<Registers*>(ECAT0_SM2_BASE);
    inline Registers* ECAT0_SM3 = reinterpret_cast<Registers*>(ECAT0_SM3_BASE);
    inline Registers* ECAT0_SM4 = reinterpret_cast<Registers*>(ECAT0_SM4_BASE);
    inline Registers* ECAT0_SM5 = reinterpret_cast<Registers*>(ECAT0_SM5_BASE);
    inline Registers* ECAT0_SM6 = reinterpret_cast<Registers*>(ECAT0_SM6_BASE);
    inline Registers* ECAT0_SM7 = reinterpret_cast<Registers*>(ECAT0_SM7_BASE);

    // Bit definitions
    /// CON Register bits
    namespace con_bits {
        constexpr uint32_t ECATRSTEN = (1U << 0);  ///< Enable EtherCAT Reset Request
        constexpr uint32_t LATCHIN0SEL = (2 << 8);  ///< LATCHIN0 Input Select
        constexpr uint32_t LATCHIN0 = (1U << 11);  ///< EtherCAT LATCH_IN0 Input Signal
        constexpr uint32_t LATCHIN1SEL = (2 << 12);  ///< LATCHIN1 Input Select
        constexpr uint32_t LATCHIN1 = (1U << 15);  ///< EtherCAT LATCH_IN1 Input Signal
        constexpr uint32_t PHYOFFSET = (5 << 16);  ///< Ethernet PHY Address Offset
        constexpr uint32_t MDIO = (2 << 22);  ///< MDIO Input Select
    }

    /// CONP0 Register bits
    namespace conp0_bits {
        constexpr uint32_t RXD0 = (2 << 0);  ///< PORT0 Receive Input 0 Select
        constexpr uint32_t RXD1 = (2 << 2);  ///< Port0 Receive Input 1 Select
        constexpr uint32_t RXD2 = (2 << 4);  ///< Port0 Receive Input 2 Select
        constexpr uint32_t RXD3 = (2 << 6);  ///< Port0 Receive Input 3 Select
        constexpr uint32_t RX_ERR = (2 << 8);  ///< Port0 MII RX ERROR Input Select
        constexpr uint32_t RX_DV = (2 << 10);  ///< Port0 MII RX DV Input Select
        constexpr uint32_t RX_CLK = (2 << 12);  ///< Port0 MII RX Clock Input Select
        constexpr uint32_t LINK = (2 << 16);  ///< Port0 PHY Link Input Select
        constexpr uint32_t TX_CLK = (2 << 28);  ///< Port0 MII TX Clock Input Select
        constexpr uint32_t TX_SHIFT = (2 << 30);  ///< Port0 Manual TX Shift configuration
    }

    /// CONP1 Register bits
    namespace conp1_bits {
        constexpr uint32_t RXD0 = (2 << 0);  ///< Port1 Receive Input 0 Select
        constexpr uint32_t RXD1 = (2 << 2);  ///< Port1 Receive Input 1 Select
        constexpr uint32_t RXD2 = (2 << 4);  ///< Port1 Receive Input 2 Select
        constexpr uint32_t RXD3 = (2 << 6);  ///< Port1 Receive Input 3 Select
        constexpr uint32_t RX_ERR = (2 << 8);  ///< Port1 MII RX ERROR Input Select
        constexpr uint32_t RX_DV = (2 << 10);  ///< Port1 MII RX DV Input Select
        constexpr uint32_t RX_CLK = (2 << 12);  ///< Port1 MII RX Clock Input Select
        constexpr uint32_t LINK = (2 << 16);  ///< Port1 PHY Link Input Select
        constexpr uint32_t TX_CLK = (2 << 28);  ///< Port1 MII TX Clock Input Select
        constexpr uint32_t TX_SHIFT = (2 << 30);  ///< Port1 Manual TX Shift configuration
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB0_BASE = 0x50040000;
    constexpr uint32_t USB0_EP0_BASE = 0x50040900;
    constexpr uint32_t USB0_EP1_BASE = 0x50040920;
    constexpr uint32_t USB0_EP2_BASE = 0x50040940;
    constexpr uint32_t USB0_EP3_BASE = 0x50040960;
    constexpr uint32_t USB0_EP4_BASE = 0x50040980;
    constexpr uint32_t USB0_EP5_BASE = 0x500409A0;
    constexpr uint32_t USB0_EP6_BASE = 0x500409C0;
    constexpr uint32_t USB0_CH0_BASE = 0x50040500;
    constexpr uint32_t USB0_CH1_BASE = 0x50040520;
    constexpr uint32_t USB0_CH2_BASE = 0x50040540;
    constexpr uint32_t USB0_CH3_BASE = 0x50040560;
    constexpr uint32_t USB0_CH4_BASE = 0x50040580;
    constexpr uint32_t USB0_CH5_BASE = 0x500405A0;
    constexpr uint32_t USB0_CH6_BASE = 0x500405C0;
    constexpr uint32_t USB0_CH7_BASE = 0x500405E0;
    constexpr uint32_t USB0_CH8_BASE = 0x50040600;
    constexpr uint32_t USB0_CH9_BASE = 0x50040620;
    constexpr uint32_t USB0_CH10_BASE = 0x50040640;
    constexpr uint32_t USB0_CH11_BASE = 0x50040660;
    constexpr uint32_t USB0_CH12_BASE = 0x50040680;
    constexpr uint32_t USB0_CH13_BASE = 0x500406A0;

    /// USB Register structure
    struct Registers {
        volatile uint32_t GOTGCTL;  ///< Offset: 0x00 - Control and Status Register
        volatile uint32_t GOTGINT;  ///< Offset: 0x04 - OTG Interrupt Register
        volatile uint32_t GAHBCFG;  ///< Offset: 0x08 - AHB Configuration Register
        volatile uint32_t GUSBCFG;  ///< Offset: 0x0C - USB Configuration Register
        volatile uint32_t GRSTCTL;  ///< Offset: 0x10 - Reset Register
        volatile uint32_t GINTSTS_HOSTMODE;  ///< Offset: 0x14 - Interrupt Register [HOSTMODE]
        volatile uint32_t GINTSTS_DEVICEMODE;  ///< Offset: 0x14 - Interrupt Register [DEVICEMODE]
        volatile uint32_t GINTMSK_HOSTMODE;  ///< Offset: 0x18 - Interrupt Mask Register [HOSTMODE]
        volatile uint32_t GINTMSK_DEVICEMODE;  ///< Offset: 0x18 - Interrupt Mask Register [DEVICEMODE]
        volatile uint32_t GRXSTSR_HOSTMODE;  ///< Offset: 0x1C - Receive Status Debug Read Register [HOSTMODE]
        volatile uint32_t GRXSTSR_DEVICEMODE;  ///< Offset: 0x1C - Receive Status Debug Read Register [DEVICEMODE]
        volatile uint32_t GRXSTSP_DEVICEMODE;  ///< Offset: 0x20 - Receive Status Read and Pop Register [DEVICEMODE]
        volatile uint32_t GRXSTSP_HOSTMODE;  ///< Offset: 0x20 - Receive Status Read and Pop Register [HOSTMODE]
        volatile uint32_t GRXFSIZ;  ///< Offset: 0x24 - Receive FIFO Size Register
        volatile uint32_t GNPTXFSIZ_HOSTMODE;  ///< Offset: 0x28 - Non-Periodic Transmit FIFO Size Register [HOSTMODE]
        volatile uint32_t GNPTXFSIZ_DEVICEMODE;  ///< Offset: 0x28 - Non-Periodic Transmit FIFO Size Register [DEVICEMODE]
        volatile uint32_t GNPTXSTS;  ///< Offset: 0x2C - Non-Periodic Transmit FIFO/Queue Status Register
        volatile uint32_t GUID;  ///< Offset: 0x3C - USB Module Identification Register
        volatile uint32_t GDFIFOCFG;  ///< Offset: 0x5C - Global DFIFO Software Config Register
        volatile uint32_t HPTXFSIZ;  ///< Offset: 0x100 - Host Periodic Transmit FIFO Size Register
        volatile uint32_t DIEPTXF1;  ///< Offset: 0x104 - Device IN Endpoint Transmit FIFO Size Register
        volatile uint32_t DIEPTXF2;  ///< Offset: 0x108 - Device IN Endpoint Transmit FIFO Size Register
        volatile uint32_t DIEPTXF3;  ///< Offset: 0x10C - Device IN Endpoint Transmit FIFO Size Register
        volatile uint32_t DIEPTXF4;  ///< Offset: 0x110 - Device IN Endpoint Transmit FIFO Size Register
        volatile uint32_t DIEPTXF5;  ///< Offset: 0x114 - Device IN Endpoint Transmit FIFO Size Register
        volatile uint32_t DIEPTXF6;  ///< Offset: 0x118 - Device IN Endpoint Transmit FIFO Size Register
        volatile uint32_t HCFG;  ///< Offset: 0x400 - Host Configuration Register
        volatile uint32_t HFIR;  ///< Offset: 0x404 - Host Frame Interval Register
        volatile uint32_t HFNUM;  ///< Offset: 0x408 - Host Frame Number/Frame Time Remaining Register
        volatile uint32_t HPTXSTS;  ///< Offset: 0x410 - Host Periodic Transmit FIFO/ Queue Status Register
        volatile uint32_t HAINT;  ///< Offset: 0x414 - Host All Channels Interrupt Register
        volatile uint32_t HAINTMSK;  ///< Offset: 0x418 - Host All Channels Interrupt Mask Register
        volatile uint32_t HFLBADDR;  ///< Offset: 0x41C - Host Frame List Base Address Register
        volatile uint32_t HPRT;  ///< Offset: 0x440 - Host Port Control and Status Register
        volatile uint32_t DCFG;  ///< Offset: 0x800 - Device Configuration Register
        volatile uint32_t DCTL;  ///< Offset: 0x804 - Device Control Register
        volatile uint32_t DSTS;  ///< Offset: 0x808 - Device Status Register
        volatile uint32_t DIEPMSK;  ///< Offset: 0x810 - Device IN Endpoint Common Interrupt Mask Register
        volatile uint32_t DOEPMSK;  ///< Offset: 0x814 - Device OUT Endpoint Common Interrupt Mask Register
        volatile uint32_t DAINT;  ///< Offset: 0x818 - Device All Endpoints Interrupt Register
        volatile uint32_t DAINTMSK;  ///< Offset: 0x81C - Device All Endpoints Interrupt Mask Register
        volatile uint32_t DVBUSDIS;  ///< Offset: 0x828 - Device VBUS Discharge Time Register
        volatile uint32_t DVBUSPULSE;  ///< Offset: 0x82C - Device VBUS Pulsing Time Register
        volatile uint32_t DIEPEMPMSK;  ///< Offset: 0x834 - Device IN Endpoint FIFO Empty Interrupt Mask Register
        volatile uint32_t PCGCCTL;  ///< Offset: 0xE00 - Power and Clock Gating Control Register
    };

    /// Peripheral instances
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);
    inline Registers* USB0_EP0 = reinterpret_cast<Registers*>(USB0_EP0_BASE);
    inline Registers* USB0_EP1 = reinterpret_cast<Registers*>(USB0_EP1_BASE);
    inline Registers* USB0_EP2 = reinterpret_cast<Registers*>(USB0_EP2_BASE);
    inline Registers* USB0_EP3 = reinterpret_cast<Registers*>(USB0_EP3_BASE);
    inline Registers* USB0_EP4 = reinterpret_cast<Registers*>(USB0_EP4_BASE);
    inline Registers* USB0_EP5 = reinterpret_cast<Registers*>(USB0_EP5_BASE);
    inline Registers* USB0_EP6 = reinterpret_cast<Registers*>(USB0_EP6_BASE);
    inline Registers* USB0_CH0 = reinterpret_cast<Registers*>(USB0_CH0_BASE);
    inline Registers* USB0_CH1 = reinterpret_cast<Registers*>(USB0_CH1_BASE);
    inline Registers* USB0_CH2 = reinterpret_cast<Registers*>(USB0_CH2_BASE);
    inline Registers* USB0_CH3 = reinterpret_cast<Registers*>(USB0_CH3_BASE);
    inline Registers* USB0_CH4 = reinterpret_cast<Registers*>(USB0_CH4_BASE);
    inline Registers* USB0_CH5 = reinterpret_cast<Registers*>(USB0_CH5_BASE);
    inline Registers* USB0_CH6 = reinterpret_cast<Registers*>(USB0_CH6_BASE);
    inline Registers* USB0_CH7 = reinterpret_cast<Registers*>(USB0_CH7_BASE);
    inline Registers* USB0_CH8 = reinterpret_cast<Registers*>(USB0_CH8_BASE);
    inline Registers* USB0_CH9 = reinterpret_cast<Registers*>(USB0_CH9_BASE);
    inline Registers* USB0_CH10 = reinterpret_cast<Registers*>(USB0_CH10_BASE);
    inline Registers* USB0_CH11 = reinterpret_cast<Registers*>(USB0_CH11_BASE);
    inline Registers* USB0_CH12 = reinterpret_cast<Registers*>(USB0_CH12_BASE);
    inline Registers* USB0_CH13 = reinterpret_cast<Registers*>(USB0_CH13_BASE);

    // Bit definitions
    /// GOTGCTL Register bits
    namespace gotgctl_bits {
        constexpr uint32_t SesReqScs = (1U << 0);  ///< Session Request Success
        constexpr uint32_t SesReq = (1U << 1);  ///< Session Request
        constexpr uint32_t VbvalidOvEn = (1U << 2);  ///< VBUS Valid Override Enable
        constexpr uint32_t VbvalidOvVal = (1U << 3);  ///< VBUS Valid Override Value
        constexpr uint32_t AvalidOvEn = (1U << 4);  ///< A-Peripheral Session Valid Override Enable
        constexpr uint32_t AvalidOvVal = (1U << 5);  ///< A-Peripheral Session Valid Override Value
        constexpr uint32_t BvalidOvEn = (1U << 6);  ///< B-Peripheral Session Valid Override Enable
        constexpr uint32_t BvalidOvVal = (1U << 7);  ///< B-Peripheral Session Valid Override Value
        constexpr uint32_t HstNegScs = (1U << 8);  ///< Host Negotiation Success
        constexpr uint32_t HNPReq = (1U << 9);  ///< HNP Request
        constexpr uint32_t HstSetHNPEn = (1U << 10);  ///< Host Set HNP Enable
        constexpr uint32_t DevHNPEn = (1U << 11);  ///< Device HNP Enabled
        constexpr uint32_t ConlDSts = (1U << 16);  ///< Connector ID Status
        constexpr uint32_t DbncTime = (1U << 17);  ///< Long/Short Debounce Time
        constexpr uint32_t ASesVId = (1U << 18);  ///< A-Session Valid
        constexpr uint32_t BSesVld = (1U << 19);  ///< B-Session Valid
        constexpr uint32_t OTGVer = (1U << 20);  ///< OTG Version
    }

    /// GOTGINT Register bits
    namespace gotgint_bits {
        constexpr uint32_t SesEndDet = (1U << 2);  ///< Session End Detected
        constexpr uint32_t SesReqSucStsChng = (1U << 8);  ///< Session Request Success Status Change
        constexpr uint32_t HstNegSucStsChng = (1U << 9);  ///< Host Negotiation Success Status Change
        constexpr uint32_t HstNegDet = (1U << 17);  ///< Host Negotiation Detected
        constexpr uint32_t ADevTOUTChg = (1U << 18);  ///< A-Device Timeout Change
        constexpr uint32_t DbnceDone = (1U << 19);  ///< Debounce Done
    }

    /// GAHBCFG Register bits
    namespace gahbcfg_bits {
        constexpr uint32_t GlblIntrMsk = (1U << 0);  ///< Global Interrupt Mask
        constexpr uint32_t HBstLen = (4 << 1);  ///< Burst Length/Type
        constexpr uint32_t DMAEn = (1U << 5);  ///< DMA Enable
        constexpr uint32_t NPTxFEmpLvl = (1U << 7);  ///< Non-Periodic TxFIFO Empty Level
        constexpr uint32_t PTxFEmpLvl = (1U << 8);  ///< Periodic TxFIFO Empty Level
        constexpr uint32_t AHBSingle = (1U << 23);  ///< AHB Single Support
    }

    /// GUSBCFG Register bits
    namespace gusbcfg_bits {
        constexpr uint32_t TOutCal = (3 << 0);  ///< FS Timeout Calibration
        constexpr uint32_t PHYSel = (1U << 6);  ///< USB 1.1 Full-Speed Serial Transceiver Select
        constexpr uint32_t SRPCap = (1U << 8);  ///< SRP-Capable
        constexpr uint32_t HNPCap = (1U << 9);  ///< HNP-Capable
        constexpr uint32_t USBTrdTim = (4 << 10);  ///< USB Turnaround Time
        constexpr uint32_t OtgI2CSel = (1U << 16);  ///< UTMIFS Interface Select
        constexpr uint32_t TxEndDelay = (1U << 28);  ///< Tx End Delay
        constexpr uint32_t ForceHstMode = (1U << 29);  ///< Force Host Mode
        constexpr uint32_t ForceDevMode = (1U << 30);  ///< Force Device Mode
        constexpr uint32_t CTP = (1U << 31);  ///< Corrupt Tx packet
    }

    /// GRSTCTL Register bits
    namespace grstctl_bits {
        constexpr uint32_t CSftRst = (1U << 0);  ///< Core Soft Reset
        constexpr uint32_t FrmCntrRst = (1U << 2);  ///< Host Frame Counter Reset
        constexpr uint32_t RxFFlsh = (1U << 4);  ///< RxFIFO Flush
        constexpr uint32_t TxFFlsh = (1U << 5);  ///< TxFIFO Flush
        constexpr uint32_t TxFNum = (5 << 6);  ///< TxFIFO Number
        constexpr uint32_t DMAReq = (1U << 30);  ///< DMA Request Signal
        constexpr uint32_t AHBIdle = (1U << 31);  ///< AHB Master Idle
    }

    /// GINTSTS_HOSTMODE Register bits
    namespace gintsts_hostmode_bits {
        constexpr uint32_t CurMod = (1U << 0);  ///< Current Mode of Operation
        constexpr uint32_t ModeMis = (1U << 1);  ///< Mode Mismatch Interrupt
        constexpr uint32_t OTGInt = (1U << 2);  ///< OTG Interrupt
        constexpr uint32_t Sof = (1U << 3);  ///< Start of Frame
        constexpr uint32_t RxFLvl = (1U << 4);  ///< RxFIFO Non-Empty
        constexpr uint32_t incomplP = (1U << 21);  ///< Incomplete Periodic Transfer
        constexpr uint32_t PrtInt = (1U << 24);  ///< Host Port Interrupt
        constexpr uint32_t HChInt = (1U << 25);  ///< Host Channels Interrupt
        constexpr uint32_t PTxFEmp = (1U << 26);  ///< Periodic TxFIFO Empty
        constexpr uint32_t ConIDStsChng = (1U << 28);  ///< Connector ID Status Change
        constexpr uint32_t DisconnInt = (1U << 29);  ///< Disconnect Detected Interrupt
        constexpr uint32_t SessReqInt = (1U << 30);  ///< Session Request/New Session Detected Interrupt
        constexpr uint32_t WkUpInt = (1U << 31);  ///< Resume/Remote Wakeup Detected Interrupt
    }

    /// GINTSTS_DEVICEMODE Register bits
    namespace gintsts_devicemode_bits {
        constexpr uint32_t CurMod = (1U << 0);  ///< Current Mode of Operation
        constexpr uint32_t ModeMis = (1U << 1);  ///< Mode Mismatch Interrupt
        constexpr uint32_t OTGInt = (1U << 2);  ///< OTG Interrupt
        constexpr uint32_t Sof = (1U << 3);  ///< Start of Frame
        constexpr uint32_t RxFLvl = (1U << 4);  ///< RxFIFO Non-Empty
        constexpr uint32_t GINNakEff = (1U << 6);  ///< Global IN Non-Periodic NAK Effective
        constexpr uint32_t GOUTNakEff = (1U << 7);  ///< Global OUT NAK Effective
        constexpr uint32_t ErlySusp = (1U << 10);  ///< Early Suspend
        constexpr uint32_t USBSusp = (1U << 11);  ///< USB Suspend
        constexpr uint32_t USBRst = (1U << 12);  ///< USB Reset
        constexpr uint32_t EnumDone = (1U << 13);  ///< Enumeration Done
        constexpr uint32_t ISOOutDrop = (1U << 14);  ///< Isochronous OUT Packet Dropped Interrupt
        constexpr uint32_t EOPF = (1U << 15);  ///< End of Periodic Frame Interrupt
        constexpr uint32_t IEPInt = (1U << 18);  ///< IN Endpoints Interrupt
        constexpr uint32_t OEPInt = (1U << 19);  ///< OUT Endpoints Interrupt
        constexpr uint32_t incompISOIN = (1U << 20);  ///< Incomplete Isochronous IN Transfer
        constexpr uint32_t incomplSOOUT = (1U << 21);  ///< Incomplete Isochronous OUT Transfer
        constexpr uint32_t ConIDStsChng = (1U << 28);  ///< Connector ID Status Change
        constexpr uint32_t SessReqInt = (1U << 30);  ///< Session Request/New Session Detected Interrupt
        constexpr uint32_t WkUpInt = (1U << 31);  ///< Resume/Remote Wakeup Detected Interrupt
    }

    /// GINTMSK_HOSTMODE Register bits
    namespace gintmsk_hostmode_bits {
        constexpr uint32_t ModeMisMsk = (1U << 1);  ///< Mode Mismatch Interrupt Mask
        constexpr uint32_t OTGIntMsk = (1U << 2);  ///< OTG Interrupt Mask
        constexpr uint32_t SofMsk = (1U << 3);  ///< Start of Frame Mask
        constexpr uint32_t RxFLvlMsk = (1U << 4);  ///< Receive FIFO Non-Empty Mask
        constexpr uint32_t incomplPMsk = (1U << 21);  ///< Incomplete Periodic Transfer Mask
        constexpr uint32_t PrtIntMsk = (1U << 24);  ///< Host Port Interrupt Mask
        constexpr uint32_t HChIntMsk = (1U << 25);  ///< Host Channels Interrupt Mask
        constexpr uint32_t PTxFEmpMsk = (1U << 26);  ///< Periodic TxFIFO Empty Mask
        constexpr uint32_t ConIDStsChngMsk = (1U << 28);  ///< Connector ID Status Change Mask
        constexpr uint32_t DisconnIntMsk = (1U << 29);  ///< Disconnect Detected Interrupt Mask
        constexpr uint32_t SessReqIntMsk = (1U << 30);  ///< Session Request/New Session Detected Interrupt Mask
        constexpr uint32_t WkUpIntMsk = (1U << 31);  ///< Resume/Remote Wakeup Detected Interrupt Mask
    }

    /// GINTMSK_DEVICEMODE Register bits
    namespace gintmsk_devicemode_bits {
        constexpr uint32_t ModeMisMsk = (1U << 1);  ///< Mode Mismatch Interrupt Mask
        constexpr uint32_t OTGIntMsk = (1U << 2);  ///< OTG Interrupt Mask
        constexpr uint32_t SofMsk = (1U << 3);  ///< Start of Frame Mask
        constexpr uint32_t RxFLvlMsk = (1U << 4);  ///< Receive FIFO Non-Empty Mask
        constexpr uint32_t GINNakEffMsk = (1U << 6);  ///< Global Non-periodic IN NAK Effective Mask
        constexpr uint32_t GOUTNakEffMsk = (1U << 7);  ///< Global OUT NAK Effective Mask
        constexpr uint32_t ErlySuspMsk = (1U << 10);  ///< Early Suspend Mask
        constexpr uint32_t USBSuspMsk = (1U << 11);  ///< USB Suspend Mask
        constexpr uint32_t USBRstMsk = (1U << 12);  ///< USB Reset Mask
        constexpr uint32_t EnumDoneMsk = (1U << 13);  ///< Enumeration Done Mask
        constexpr uint32_t ISOOutDropMsk = (1U << 14);  ///< Isochronous OUT Packet Dropped Interrupt Mask
        constexpr uint32_t EOPFMsk = (1U << 15);  ///< End of Periodic Frame Interrupt Mask
        constexpr uint32_t IEPIntMsk = (1U << 18);  ///< IN Endpoints Interrupt Mask
        constexpr uint32_t OEPIntMsk = (1U << 19);  ///< OUT Endpoints Interrupt Mask
        constexpr uint32_t incompISOINMsk = (1U << 20);  ///< Incomplete Isochronous IN Transfer Mask
        constexpr uint32_t incomplSOOUTMsk = (1U << 21);  ///< Incomplete Isochronous OUT Transfer Mask
        constexpr uint32_t ConIDStsChngMsk = (1U << 28);  ///< Connector ID Status Change Mask
        constexpr uint32_t DisconnIntMsk = (1U << 29);  ///< Disconnect Detected Interrupt Mask
        constexpr uint32_t SessReqIntMsk = (1U << 30);  ///< Session Request/New Session Detected Interrupt Mask
        constexpr uint32_t WkUpIntMsk = (1U << 31);  ///< Resume/Remote Wakeup Detected Interrupt Mask
    }

    /// GRXSTSR_HOSTMODE Register bits
    namespace grxstsr_hostmode_bits {
        constexpr uint32_t ChNum = (4 << 0);  ///< Channel Number
        constexpr uint32_t BCnt = (11 << 4);  ///< Byte Count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PktSts = (4 << 17);  ///< Packet Status
    }

    /// GRXSTSR_DEVICEMODE Register bits
    namespace grxstsr_devicemode_bits {
        constexpr uint32_t EPNum = (4 << 0);  ///< Endpoint Number
        constexpr uint32_t BCnt = (11 << 4);  ///< Byte Count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PktSts = (4 << 17);  ///< Packet Status
        constexpr uint32_t FN = (4 << 21);  ///< Frame Number
    }

    /// GRXSTSP_DEVICEMODE Register bits
    namespace grxstsp_devicemode_bits {
        constexpr uint32_t EPNum = (4 << 0);  ///< Endpoint Number
        constexpr uint32_t BCnt = (11 << 4);  ///< Byte Count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PktSts = (4 << 17);  ///< Packet Status
        constexpr uint32_t FN = (4 << 21);  ///< Frame Number
    }

    /// GRXSTSP_HOSTMODE Register bits
    namespace grxstsp_hostmode_bits {
        constexpr uint32_t ChNum = (4 << 0);  ///< Channel Number
        constexpr uint32_t BCnt = (11 << 4);  ///< Byte Count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PktSts = (4 << 17);  ///< Packet Status
    }

    /// GRXFSIZ Register bits
    namespace grxfsiz_bits {
        constexpr uint32_t RxFDep = (16 << 0);  ///< RxFIFO Depth
    }

    /// GNPTXFSIZ_HOSTMODE Register bits
    namespace gnptxfsiz_hostmode_bits {
        constexpr uint32_t NPTxFStAddr = (16 << 0);  ///< Non-periodic Transmit RAM Start Address
        constexpr uint32_t NPTxFDep = (16 << 16);  ///< Non-periodic TxFIFO Depth
    }

    /// GNPTXFSIZ_DEVICEMODE Register bits
    namespace gnptxfsiz_devicemode_bits {
        constexpr uint32_t INEPTxF0StAddr = (16 << 0);  ///< IN Endpoint FIFO0 Transmit RAM Start Address
        constexpr uint32_t INEPTxF0Dep = (16 << 16);  ///< IN Endpoint TxFIFO 0 Depth
    }

    /// GNPTXSTS Register bits
    namespace gnptxsts_bits {
        constexpr uint32_t NPTxFSpcAvail = (16 << 0);  ///< Non-periodic TxFIFO Space Avail
        constexpr uint32_t NPTxQSpcAvail = (8 << 16);  ///< Non-periodic Transmit Request Queue Space Available
        constexpr uint32_t NPTxQTop = (7 << 24);  ///< Top of the Non-periodic Transmit Request Queue
    }

    /// GUID Register bits
    namespace guid_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// GDFIFOCFG Register bits
    namespace gdfifocfg_bits {
        constexpr uint32_t GDFIFOCfg = (16 << 0);  ///< GDFIFOCfg
        constexpr uint32_t EPInfoBaseAddr = (16 << 16);  ///< EPInfoBaseAddr
    }

    /// HPTXFSIZ Register bits
    namespace hptxfsiz_bits {
        constexpr uint32_t PTxFStAddr = (16 << 0);  ///< Host Periodic TxFIFO Start Address
        constexpr uint32_t PTxFSize = (16 << 16);  ///< Host Periodic TxFIFO Depth
    }

    /// DIEPTXF1 Register bits
    namespace dieptxf1_bits {
        constexpr uint32_t INEPnTxFStAddr = (16 << 0);  ///< IN Endpoint FIFOn Transmit RAM Start Address
        constexpr uint32_t INEPnTxFDep = (16 << 16);  ///< IN Endpoint TxFIFO Depth
    }

    /// DIEPTXF2 Register bits
    namespace dieptxf2_bits {
        constexpr uint32_t INEPnTxFStAddr = (16 << 0);  ///< IN Endpoint FIFOn Transmit RAM Start Address
        constexpr uint32_t INEPnTxFDep = (16 << 16);  ///< IN Endpoint TxFIFO Depth
    }

    /// DIEPTXF3 Register bits
    namespace dieptxf3_bits {
        constexpr uint32_t INEPnTxFStAddr = (16 << 0);  ///< IN Endpoint FIFOn Transmit RAM Start Address
        constexpr uint32_t INEPnTxFDep = (16 << 16);  ///< IN Endpoint TxFIFO Depth
    }

    /// DIEPTXF4 Register bits
    namespace dieptxf4_bits {
        constexpr uint32_t INEPnTxFStAddr = (16 << 0);  ///< IN Endpoint FIFOn Transmit RAM Start Address
        constexpr uint32_t INEPnTxFDep = (16 << 16);  ///< IN Endpoint TxFIFO Depth
    }

    /// DIEPTXF5 Register bits
    namespace dieptxf5_bits {
        constexpr uint32_t INEPnTxFStAddr = (16 << 0);  ///< IN Endpoint FIFOn Transmit RAM Start Address
        constexpr uint32_t INEPnTxFDep = (16 << 16);  ///< IN Endpoint TxFIFO Depth
    }

    /// DIEPTXF6 Register bits
    namespace dieptxf6_bits {
        constexpr uint32_t INEPnTxFStAddr = (16 << 0);  ///< IN Endpoint FIFOn Transmit RAM Start Address
        constexpr uint32_t INEPnTxFDep = (16 << 16);  ///< IN Endpoint TxFIFO Depth
    }

    /// HCFG Register bits
    namespace hcfg_bits {
        constexpr uint32_t FSLSPclkSel = (2 << 0);  ///< FS PHY Clock Select
        constexpr uint32_t FSLSSupp = (1U << 2);  ///< FS-Only Support
        constexpr uint32_t DescDMA = (1U << 23);  ///< Enable Scatter/gather DMA in Host mode
        constexpr uint32_t FrListEn = (2 << 24);  ///< Frame List Entries
        constexpr uint32_t PerSchedEna = (1U << 26);  ///< Enable Periodic Scheduling
    }

    /// HFIR Register bits
    namespace hfir_bits {
        constexpr uint32_t FrInt = (16 << 0);  ///< Frame Interval
        constexpr uint32_t HFIRRldCtrl = (1U << 16);  ///< Reload Control
    }

    /// HFNUM Register bits
    namespace hfnum_bits {
        constexpr uint32_t FrNum = (16 << 0);  ///< Frame Number
        constexpr uint32_t FrRem = (16 << 16);  ///< Frame Time Remaining
    }

    /// HPTXSTS Register bits
    namespace hptxsts_bits {
        constexpr uint32_t PTxFSpcAvail = (16 << 0);  ///< Periodic Transmit Data FIFO Space Available
        constexpr uint32_t PTxQSpcAvail = (8 << 16);  ///< Periodic Transmit Request Queue Space Available
        constexpr uint32_t PTxQTop = (8 << 24);  ///< Top of the Periodic Transmit Request Queue
    }

    /// HAINT Register bits
    namespace haint_bits {
        constexpr uint32_t HAINT = (14 << 0);  ///< Channel Interrupts
    }

    /// HAINTMSK Register bits
    namespace haintmsk_bits {
        constexpr uint32_t HAINTMsk = (14 << 0);  ///< Channel Interrupt Mask
    }

    /// HFLBADDR Register bits
    namespace hflbaddr_bits {
        constexpr uint32_t Starting_Address = (32 << 0);  ///< Starting Address
    }

    /// HPRT Register bits
    namespace hprt_bits {
        constexpr uint32_t PrtConnSts = (1U << 0);  ///< Port Connect Status
        constexpr uint32_t PrtConnDet = (1U << 1);  ///< Port Connect Detected
        constexpr uint32_t PrtEna = (1U << 2);  ///< Port Enable
        constexpr uint32_t PrtEnChng = (1U << 3);  ///< Port Enable/Disable Change
        constexpr uint32_t PrtOvrCurrAct = (1U << 4);  ///< Port Overcurrent Active
        constexpr uint32_t PrtOvrCurrChng = (1U << 5);  ///< Port Overcurrent Change
        constexpr uint32_t PrtRes = (1U << 6);  ///< Port Resume
        constexpr uint32_t PrtSusp = (1U << 7);  ///< Port Suspend
        constexpr uint32_t PrtRst = (1U << 8);  ///< Port Reset
        constexpr uint32_t PrtLnSts = (2 << 10);  ///< Port Line Status
        constexpr uint32_t PrtPwr = (1U << 12);  ///< Port Power
        constexpr uint32_t PrtSpd = (2 << 17);  ///< Port Speed
    }

    /// DCFG Register bits
    namespace dcfg_bits {
        constexpr uint32_t DevSpd = (2 << 0);  ///< Device Speed
        constexpr uint32_t NZStsOUTHShk = (1U << 2);  ///< Non-Zero-Length Status OUT Handshake
        constexpr uint32_t DevAddr = (7 << 4);  ///< Device Address
        constexpr uint32_t PerFrInt = (2 << 11);  ///< Periodic Frame Interval
        constexpr uint32_t DescDMA = (1U << 23);  ///< Enable Scatter/Gather DMA in Device mode.
        constexpr uint32_t PerSchIntvl = (2 << 24);  ///< Periodic Scheduling Interval
    }

    /// DCTL Register bits
    namespace dctl_bits {
        constexpr uint32_t RmtWkUpSig = (1U << 0);  ///< Remote Wakeup Signaling
        constexpr uint32_t SftDiscon = (1U << 1);  ///< Soft Disconnect
        constexpr uint32_t GNPINNakSts = (1U << 2);  ///< Global Non-periodic IN NAK Status
        constexpr uint32_t GOUTNakSts = (1U << 3);  ///< Global OUT NAK Status
        constexpr uint32_t SGNPInNak = (1U << 7);  ///< Set Global Non-periodic IN NAK
        constexpr uint32_t CGNPInNak = (1U << 8);  ///< Clear Global Non-periodic IN NAK
        constexpr uint32_t SGOUTNak = (1U << 9);  ///< Set Global OUT NAK
        constexpr uint32_t CGOUTNak = (1U << 10);  ///< Clear Global OUT NAK
        constexpr uint32_t GMC = (2 << 13);  ///< Global Multi Count
        constexpr uint32_t IgnrFrmNum = (1U << 15);  ///< Ignore frame number for isochronous endpoints in case of Scatter/Gather DMA
        constexpr uint32_t NakOnBble = (1U << 16);  ///< Set NAK automatically on babble
        constexpr uint32_t EnContOnBNA = (1U << 17);  ///< Enable continue on BNA
    }

    /// DSTS Register bits
    namespace dsts_bits {
        constexpr uint32_t SuspSts = (1U << 0);  ///< Suspend Status
        constexpr uint32_t EnumSpd = (2 << 1);  ///< Enumerated Speed
        constexpr uint32_t ErrticErr = (1U << 3);  ///< Erratic Error
        constexpr uint32_t SOFFN = (14 << 8);  ///< Frame Number of the Received SOF
    }

    /// DIEPMSK Register bits
    namespace diepmsk_bits {
        constexpr uint32_t XferComplMsk = (1U << 0);  ///< Transfer Completed Interrupt Mask
        constexpr uint32_t EPDisbldMsk = (1U << 1);  ///< Endpoint Disabled Interrupt Mask
        constexpr uint32_t AHBErrMsk = (1U << 2);  ///< AHB Error Mask
        constexpr uint32_t TimeOUTMsk = (1U << 3);  ///< Timeout Condition Mask
        constexpr uint32_t INTknTXFEmpMsk = (1U << 4);  ///< IN Token Received When TxFIFO Empty Mask
        constexpr uint32_t INEPNakEffMsk = (1U << 6);  ///< IN Endpoint NAK Effective Mask
        constexpr uint32_t TxfifoUndrnMsk = (1U << 8);  ///< Fifo Underrun Mask
        constexpr uint32_t BNAInIntrMsk = (1U << 9);  ///< BNA Interrupt Mask
        constexpr uint32_t NAKMsk = (1U << 13);  ///< NAK interrupt Mask
    }

    /// DOEPMSK Register bits
    namespace doepmsk_bits {
        constexpr uint32_t XferComplMsk = (1U << 0);  ///< Transfer Completed Interrupt Mask
        constexpr uint32_t EPDisbldMsk = (1U << 1);  ///< Endpoint Disabled Interrupt Mask
        constexpr uint32_t AHBErrMsk = (1U << 2);  ///< AHB Error
        constexpr uint32_t SetUPMsk = (1U << 3);  ///< SETUP Phase Done Mask
        constexpr uint32_t OUTTknEPdisMsk = (1U << 4);  ///< OUT Token Received when Endpoint Disabled Mask
        constexpr uint32_t Back2BackSETup = (1U << 6);  ///< Back-to-Back SETUP Packets Received Mask
        constexpr uint32_t OutPktErrMsk = (1U << 8);  ///< OUT Packet Error Mask
        constexpr uint32_t BnaOutIntrMsk = (1U << 9);  ///< BNA interrupt Mask
        constexpr uint32_t BbleErrMsk = (1U << 12);  ///< Babble Interrupt Mask
        constexpr uint32_t NAKMsk = (1U << 13);  ///< NAK Interrupt Mask
        constexpr uint32_t NYETMsk = (1U << 14);  ///< NYET Interrupt Mask
    }

    /// DAINT Register bits
    namespace daint_bits {
        constexpr uint32_t InEpInt = (16 << 0);  ///< IN Endpoint Interrupt Bits
        constexpr uint32_t OutEPInt = (16 << 16);  ///< OUT Endpoint Interrupt Bits
    }

    /// DAINTMSK Register bits
    namespace daintmsk_bits {
        constexpr uint32_t InEpMsk = (16 << 0);  ///< IN EP Interrupt Mask Bits
        constexpr uint32_t OutEpMsk = (16 << 16);  ///< OUT EP Interrupt Mask Bits
    }

    /// DVBUSDIS Register bits
    namespace dvbusdis_bits {
        constexpr uint32_t DVBUSDis = (16 << 0);  ///< Device Vbus Discharge Time
    }

    /// DVBUSPULSE Register bits
    namespace dvbuspulse_bits {
        constexpr uint32_t DVBUSPulse = (12 << 0);  ///< Device Vbus Pulsing Time
    }

    /// DIEPEMPMSK Register bits
    namespace diepempmsk_bits {
        constexpr uint32_t InEpTxfEmpMsk = (16 << 0);  ///< IN EP Tx FIFO Empty Interrupt Mask Bits
    }

    /// PCGCCTL Register bits
    namespace pcgcctl_bits {
        constexpr uint32_t StopPclk = (1U << 0);  ///< Stop Pclk
        constexpr uint32_t GateHclk = (1U << 1);  ///< Gate Hclk
    }

}

// ============================================================================
// USIC0 Peripheral
// ============================================================================

namespace usic0 {
    /// Base addresses
    constexpr uint32_t USIC0_BASE = 0x40030008;
    constexpr uint32_t USIC0_CH0_BASE = 0x40030000;
    constexpr uint32_t USIC0_CH1_BASE = 0x40030200;

    /// USIC0 Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - Module Identification Register
    };

    /// Peripheral instances
    inline Registers* USIC0 = reinterpret_cast<Registers*>(USIC0_BASE);
    inline Registers* USIC0_CH0 = reinterpret_cast<Registers*>(USIC0_CH0_BASE);
    inline Registers* USIC0_CH1 = reinterpret_cast<Registers*>(USIC0_CH1_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

}

// ============================================================================
// USIC1 Peripheral
// ============================================================================

namespace usic1 {
    /// Base addresses
    constexpr uint32_t USIC1_BASE = 0x48020008;
    constexpr uint32_t USIC1_CH0_BASE = 0x48020000;
    constexpr uint32_t USIC1_CH1_BASE = 0x48020200;

    /// USIC1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* USIC1 = reinterpret_cast<Registers*>(USIC1_BASE);
    inline Registers* USIC1_CH0 = reinterpret_cast<Registers*>(USIC1_CH0_BASE);
    inline Registers* USIC1_CH1 = reinterpret_cast<Registers*>(USIC1_CH1_BASE);

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN_BASE = 0x48014000;
    constexpr uint32_t CAN_NODE0_BASE = 0x48014200;
    constexpr uint32_t CAN_NODE1_BASE = 0x48014300;
    constexpr uint32_t CAN_MO_BASE = 0x48015000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t CLC;  ///< Offset: 0x00 - CAN Clock Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t FDR;  ///< Offset: 0x0C - CAN Fractional Divider Register
        volatile uint32_t LIST__;  ///< Offset: 0x100 - List Register (renamed from LIST__)
        volatile uint32_t MSPND__;  ///< Offset: 0x140 - Message Pending Register (renamed from MSPND__)
        volatile uint32_t MSID__;  ///< Offset: 0x180 - Message Index Register (renamed from MSID__)
        volatile uint32_t MSIMASK;  ///< Offset: 0x1C0 - Message Index Mask Register
        volatile uint32_t PANCTR;  ///< Offset: 0x1C4 - Panel Control Register
        volatile uint32_t MCR;  ///< Offset: 0x1C8 - Module Control Register
        volatile uint32_t MITR;  ///< Offset: 0x1CC - Module Interrupt Trigger Register
    };

    /// Peripheral instances
    inline Registers* CAN = reinterpret_cast<Registers*>(CAN_BASE);
    inline Registers* CAN_NODE0 = reinterpret_cast<Registers*>(CAN_NODE0_BASE);
    inline Registers* CAN_NODE1 = reinterpret_cast<Registers*>(CAN_NODE1_BASE);
    inline Registers* CAN_MO = reinterpret_cast<Registers*>(CAN_MO_BASE);

    // Bit definitions
    /// CLC Register bits
    namespace clc_bits {
        constexpr uint32_t DISR = (1U << 0);  ///< Module Disable Request Bit
        constexpr uint32_t DISS = (1U << 1);  ///< Module Disable Status Bit
        constexpr uint32_t EDIS = (1U << 3);  ///< Sleep Mode Enable Control
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t STEP = (10 << 0);  ///< Step Value
        constexpr uint32_t DM = (2 << 14);  ///< Divider Mode
    }

    /// LIST__ Register bits
    namespace list___bits {
        constexpr uint32_t BEGIN = (8 << 0);  ///< List Begin
        constexpr uint32_t END = (8 << 8);  ///< List End
        constexpr uint32_t SIZE = (8 << 16);  ///< List Size
        constexpr uint32_t EMPTY = (1U << 24);  ///< List Empty Indication
    }

    /// MSPND__ Register bits
    namespace mspnd___bits {
        constexpr uint32_t PND = (32 << 0);  ///< Message Pending
    }

    /// MSID__ Register bits
    namespace msid___bits {
        constexpr uint32_t INDEX = (6 << 0);  ///< Message Pending Index
    }

    /// MSIMASK Register bits
    namespace msimask_bits {
        constexpr uint32_t IM = (32 << 0);  ///< Message Index Mask
    }

    /// PANCTR Register bits
    namespace panctr_bits {
        constexpr uint32_t PANCMD = (8 << 0);  ///< Panel Command
        constexpr uint32_t BUSY = (1U << 8);  ///< Panel Busy Flag
        constexpr uint32_t RBUSY = (1U << 9);  ///< Result Busy Flag
        constexpr uint32_t PANAR1 = (8 << 16);  ///< Panel Argument 1
        constexpr uint32_t PANAR2 = (8 << 24);  ///< Panel Argument 2
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t CLKSEL = (4 << 0);  ///< Baud Rate Logic Clock Select
        constexpr uint32_t MPSEL = (4 << 12);  ///< Message Pending Selector
    }

    /// MITR Register bits
    namespace mitr_bits {
        constexpr uint32_t IT = (8 << 0);  ///< Interrupt Trigger
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t VADC_BASE = 0x40004000;
    constexpr uint32_t VADC_G0_BASE = 0x40004400;
    constexpr uint32_t VADC_G1_BASE = 0x40004800;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CLC;  ///< Offset: 0x00 - Clock Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t OCS;  ///< Offset: 0x28 - OCDS Control and Status Register
        volatile uint32_t GLOBCFG;  ///< Offset: 0x80 - Global Configuration Register
        volatile uint32_t GLOBICLASS__;  ///< Offset: 0xA0 - Input Class Register, Global (renamed from GLOBICLASS__)
        volatile uint32_t GLOBBOUND;  ///< Offset: 0xB8 - Global Boundary Select Register
        volatile uint32_t GLOBEFLAG;  ///< Offset: 0xE0 - Global Event Flag Register
        volatile uint32_t GLOBEVNP;  ///< Offset: 0x140 - Global Event Node Pointer Register
        volatile uint32_t GLOBTF;  ///< Offset: 0x160 - Global Test Functions Register
        volatile uint32_t BRSSEL__;  ///< Offset: 0x180 - Background Request Source Channel Select Register (renamed from BRSSEL__)
        volatile uint32_t BRSPND__;  ///< Offset: 0x1C0 - Background Request Source Pending Register (renamed from BRSPND__)
        volatile uint32_t BRSCTRL;  ///< Offset: 0x200 - Background Request Source Control Register
        volatile uint32_t BRSMR;  ///< Offset: 0x204 - Background Request Source Mode Register
        volatile uint32_t GLOBRCR;  ///< Offset: 0x280 - Global Result Control Register
        volatile uint32_t GLOBRES;  ///< Offset: 0x300 - Global Result Register
        volatile uint32_t GLOBRESD;  ///< Offset: 0x380 - Global Result Register, Debug
        volatile uint32_t EMUXSEL;  ///< Offset: 0x3F0 - External Multiplexer Select Register
    };

    /// Peripheral instances
    inline Registers* VADC = reinterpret_cast<Registers*>(VADC_BASE);
    inline Registers* VADC_G0 = reinterpret_cast<Registers*>(VADC_G0_BASE);
    inline Registers* VADC_G1 = reinterpret_cast<Registers*>(VADC_G1_BASE);

    // Bit definitions
    /// CLC Register bits
    namespace clc_bits {
        constexpr uint32_t DISR = (1U << 0);  ///< Module Disable Request Bit
        constexpr uint32_t DISS = (1U << 1);  ///< Module Disable Status Bit
        constexpr uint32_t EDIS = (1U << 3);  ///< Sleep Mode Enable Control
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// OCS Register bits
    namespace ocs_bits {
        constexpr uint32_t TGS = (2 << 0);  ///< Trigger Set for OTGB0/1
        constexpr uint32_t TGB = (1U << 2);  ///< OTGB0/1 Bus Select
        constexpr uint32_t TG_P = (1U << 3);  ///< TGS, TGB Write Protection
        constexpr uint32_t SUS = (4 << 24);  ///< OCDS Suspend Control
        constexpr uint32_t SUS_P = (1U << 28);  ///< SUS Write Protection
        constexpr uint32_t SUSSTA = (1U << 29);  ///< Suspend State
    }

    /// GLOBCFG Register bits
    namespace globcfg_bits {
        constexpr uint32_t DIVA = (5 << 0);  ///< Divider Factor for the Analog Internal Clock
        constexpr uint32_t DCMSB = (1U << 7);  ///< Double Clock for the MSB Conversion
        constexpr uint32_t DIVD = (2 << 8);  ///< Divider Factor for the Arbiter Clock
        constexpr uint32_t DIVWC = (1U << 15);  ///< Write Control for Divider Parameters
        constexpr uint32_t DPCAL0 = (1U << 16);  ///< Disable Post-Calibration
        constexpr uint32_t DPCAL1 = (1U << 17);  ///< Disable Post-Calibration
        constexpr uint32_t DPCAL2 = (1U << 18);  ///< Disable Post-Calibration
        constexpr uint32_t DPCAL3 = (1U << 19);  ///< Disable Post-Calibration
        constexpr uint32_t SUCAL = (1U << 31);  ///< Start-Up Calibration
    }

    /// GLOBICLASS__ Register bits
    namespace globiclass___bits {
        constexpr uint32_t STCS = (5 << 0);  ///< Sample Time Control for Standard Conversions
        constexpr uint32_t CMS = (3 << 8);  ///< Conversion Mode for Standard Conversions
        constexpr uint32_t STCE = (5 << 16);  ///< Sample Time Control for EMUX Conversions
        constexpr uint32_t CME = (3 << 24);  ///< Conversion Mode for EMUX Conversions
    }

    /// GLOBBOUND Register bits
    namespace globbound_bits {
        constexpr uint32_t BOUNDARY0 = (12 << 0);  ///< Boundary Value 0 for Limit Checking
        constexpr uint32_t BOUNDARY1 = (12 << 16);  ///< Boundary Value 1 for Limit Checking
    }

    /// GLOBEFLAG Register bits
    namespace globeflag_bits {
        constexpr uint32_t SEVGLB = (1U << 0);  ///< Source Event (Background)
        constexpr uint32_t REVGLB = (1U << 8);  ///< Global Result Event
        constexpr uint32_t SEVGLBCLR = (1U << 16);  ///< Clear Source Event (Background)
        constexpr uint32_t REVGLBCLR = (1U << 24);  ///< Clear Global Result Event
    }

    /// GLOBEVNP Register bits
    namespace globevnp_bits {
        constexpr uint32_t SEV0NP = (4 << 0);  ///< Service Request Node Pointer Backgr. Source
        constexpr uint32_t REV0NP = (4 << 16);  ///< Service Request Node Pointer Backgr. Result
    }

    /// GLOBTF Register bits
    namespace globtf_bits {
        constexpr uint32_t CDGR = (4 << 4);  ///< Converter Diagnostics Group
        constexpr uint32_t CDEN = (1U << 8);  ///< Converter Diagnostics Enable
        constexpr uint32_t CDSEL = (2 << 9);  ///< Converter Diagnostics Pull-Devices Select
        constexpr uint32_t CDWC = (1U << 15);  ///< Write Control for Conversion Diagnostics
        constexpr uint32_t PDD = (1U << 16);  ///< Pull-Down Diagnostics Enable
        constexpr uint32_t MDWC = (1U << 23);  ///< Write Control for Multiplexer Diagnostics
    }

    /// BRSSEL__ Register bits
    namespace brssel___bits {
        constexpr uint32_t CHSELG0 = (1U << 0);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG1 = (1U << 1);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG2 = (1U << 2);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG3 = (1U << 3);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG4 = (1U << 4);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG5 = (1U << 5);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG6 = (1U << 6);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG7 = (1U << 7);  ///< Channel Selection Group x
    }

    /// BRSPND__ Register bits
    namespace brspnd___bits {
        constexpr uint32_t CHPNDG0 = (1U << 0);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG1 = (1U << 1);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG2 = (1U << 2);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG3 = (1U << 3);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG4 = (1U << 4);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG5 = (1U << 5);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG6 = (1U << 6);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG7 = (1U << 7);  ///< Channels Pending Group x
    }

    /// BRSCTRL Register bits
    namespace brsctrl_bits {
        constexpr uint32_t SRCRESREG = (4 << 0);  ///< Source-specific Result Register
        constexpr uint32_t XTSEL = (4 << 8);  ///< External Trigger Input Selection
        constexpr uint32_t XTLVL = (1U << 12);  ///< External Trigger Level
        constexpr uint32_t XTMODE = (2 << 13);  ///< Trigger Operating Mode
        constexpr uint32_t XTWC = (1U << 15);  ///< Write Control for Trigger Configuration
        constexpr uint32_t GTSEL = (4 << 16);  ///< Gate Input Selection
        constexpr uint32_t GTLVL = (1U << 20);  ///< Gate Input Level
        constexpr uint32_t GTWC = (1U << 23);  ///< Write Control for Gate Configuration
    }

    /// BRSMR Register bits
    namespace brsmr_bits {
        constexpr uint32_t ENGT = (2 << 0);  ///< Enable Gate
        constexpr uint32_t ENTR = (1U << 2);  ///< Enable External Trigger
        constexpr uint32_t ENSI = (1U << 3);  ///< Enable Source Interrupt
        constexpr uint32_t SCAN = (1U << 4);  ///< Autoscan Enable
        constexpr uint32_t LDM = (1U << 5);  ///< Autoscan Source Load Event Mode
        constexpr uint32_t REQGT = (1U << 7);  ///< Request Gate Level
        constexpr uint32_t CLRPND = (1U << 8);  ///< Clear Pending Bits
        constexpr uint32_t LDEV = (1U << 9);  ///< Generate Load Event
        constexpr uint32_t RPTDIS = (1U << 16);  ///< Repeat Disable
    }

    /// GLOBRCR Register bits
    namespace globrcr_bits {
        constexpr uint32_t DRCTR = (4 << 16);  ///< Data Reduction Control
        constexpr uint32_t WFR = (1U << 24);  ///< Wait-for-Read Mode Enable
        constexpr uint32_t SRGEN = (1U << 31);  ///< Service Request Generation Enable
    }

    /// GLOBRES Register bits
    namespace globres_bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Result of most recent conversion
        constexpr uint32_t GNR = (4 << 16);  ///< Group Number
        constexpr uint32_t CHNR = (5 << 20);  ///< Channel Number
        constexpr uint32_t EMUX = (3 << 25);  ///< External Multiplexer Setting
        constexpr uint32_t CRS = (2 << 28);  ///< Converted Request Source
        constexpr uint32_t FCR = (1U << 30);  ///< Fast Compare Result
        constexpr uint32_t VF = (1U << 31);  ///< Valid Flag
    }

    /// GLOBRESD Register bits
    namespace globresd_bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Result of most recent conversion
        constexpr uint32_t GNR = (4 << 16);  ///< Group Number
        constexpr uint32_t CHNR = (5 << 20);  ///< Channel Number
        constexpr uint32_t EMUX = (3 << 25);  ///< External Multiplexer Setting
        constexpr uint32_t CRS = (2 << 28);  ///< Converted Request Source
        constexpr uint32_t FCR = (1U << 30);  ///< Fast Compare Result
        constexpr uint32_t VF = (1U << 31);  ///< Valid Flag
    }

    /// EMUXSEL Register bits
    namespace emuxsel_bits {
        constexpr uint32_t EMUXGRP0 = (4 << 0);  ///< External Multiplexer Group for Interface x
        constexpr uint32_t EMUXGRP1 = (4 << 4);  ///< External Multiplexer Group for Interface x
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x48018000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - Module Identification Register
        volatile uint32_t DAC0CFG0;  ///< Offset: 0x04 - DAC0 Configuration Register 0
        volatile uint32_t DAC0CFG1;  ///< Offset: 0x08 - DAC0 Configuration Register 1
        volatile uint32_t DAC1CFG0;  ///< Offset: 0x0C - DAC1 Configuration Register 0
        volatile uint32_t DAC1CFG1;  ///< Offset: 0x10 - DAC1 Configuration Register 1
        volatile uint32_t DAC0DATA;  ///< Offset: 0x14 - DAC0 Data Register
        volatile uint32_t DAC1DATA;  ///< Offset: 0x18 - DAC1 Data Register
        volatile uint32_t DAC01DATA;  ///< Offset: 0x1C - DAC01 Data Register
        volatile uint32_t DAC0PATL;  ///< Offset: 0x20 - DAC0 Lower Pattern Register
        volatile uint32_t DAC0PATH;  ///< Offset: 0x24 - DAC0 Higher Pattern Register
        volatile uint32_t DAC1PATL;  ///< Offset: 0x28 - DAC1 Lower Pattern Register
        volatile uint32_t DAC1PATH;  ///< Offset: 0x2C - DAC1 Higher Pattern Register
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MODR = (8 << 0);  ///< Module Revision
        constexpr uint32_t MODT = (8 << 8);  ///< Module Type
        constexpr uint32_t MODN = (16 << 16);  ///< Module Number
    }

    /// DAC0CFG0 Register bits
    namespace dac0cfg0_bits {
        constexpr uint32_t FREQ = (20 << 0);  ///< Integer Frequency Divider Value
        constexpr uint32_t MODE = (3 << 20);  ///< Enables and Sets the Mode for DAC0
        constexpr uint32_t SIGN = (1U << 23);  ///< Selects Between Signed and Unsigned DAC0 Mode
        constexpr uint32_t FIFOIND = (2 << 24);  ///< Current write position inside the data FIFO
        constexpr uint32_t FIFOEMP = (1U << 26);  ///< Indicate if the FIFO is empty
        constexpr uint32_t FIFOFUL = (1U << 27);  ///< Indicate if the FIFO is full
        constexpr uint32_t NEGATE = (1U << 28);  ///< Negates the DAC0 output
        constexpr uint32_t SIGNEN = (1U << 29);  ///< Enable Sign Output of DAC0 Pattern Generator
        constexpr uint32_t SREN = (1U << 30);  ///< Enable DAC0 service request interrupt generation
        constexpr uint32_t RUN = (1U << 31);  ///< RUN indicates the current DAC0 operation status
    }

    /// DAC0CFG1 Register bits
    namespace dac0cfg1_bits {
        constexpr uint32_t SCALE = (3 << 0);  ///< Scale value for up- or downscale of the DAC0 input data in steps by the power of 2 (=shift operation)
        constexpr uint32_t MULDIV = (1U << 3);  ///< Switch between up- and downscale of the DAC0 input data values
        constexpr uint32_t OFFS = (8 << 4);  ///< 8-bit offset value addition
        constexpr uint32_t TRIGSEL = (3 << 12);  ///< Selects one of the eight external trigger sources for DAC0
        constexpr uint32_t DATMOD = (1U << 15);  ///< Switch between independent or simultaneous DAC mode and select the input data register for DAC0 and DAC1
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t TRIGMOD = (2 << 17);  ///< Select the trigger source for channel 0
        constexpr uint32_t ANACFG = (5 << 19);  ///< DAC0 analog configuration/calibration parameters
        constexpr uint32_t ANAEN = (1U << 24);  ///< Enable analog DAC for channel 0
        constexpr uint32_t REFCFGL = (4 << 28);  ///< Lower 4 band-gap configuration/calibration parameters
    }

    /// DAC1CFG0 Register bits
    namespace dac1cfg0_bits {
        constexpr uint32_t FREQ = (20 << 0);  ///< Integer Frequency Divider Value
        constexpr uint32_t MODE = (3 << 20);  ///< Enables and sets the Mode for DAC1
        constexpr uint32_t SIGN = (1U << 23);  ///< Selects between signed and unsigned DAC1 mode
        constexpr uint32_t FIFOIND = (2 << 24);  ///< Current write position inside the data FIFO
        constexpr uint32_t FIFOEMP = (1U << 26);  ///< Indicate if the FIFO is empty
        constexpr uint32_t FIFOFUL = (1U << 27);  ///< Indicate if the FIFO is full
        constexpr uint32_t NEGATE = (1U << 28);  ///< Negates the DAC1 output
        constexpr uint32_t SIGNEN = (1U << 29);  ///< Enable sign output of DAC1 pattern generator
        constexpr uint32_t SREN = (1U << 30);  ///< Enable DAC1 service request interrupt generation
        constexpr uint32_t RUN = (1U << 31);  ///< RUN indicates the current DAC1 operation status
    }

    /// DAC1CFG1 Register bits
    namespace dac1cfg1_bits {
        constexpr uint32_t SCALE = (3 << 0);  ///< Scale value for up- or downscale of the DAC1 input data in steps by the power of 2 (=shift operation)
        constexpr uint32_t MULDIV = (1U << 3);  ///< Switch between up- and downscale of the DAC1 input data values
        constexpr uint32_t OFFS = (8 << 4);  ///< 8-bit offset value addition
        constexpr uint32_t TRIGSEL = (3 << 12);  ///< Selects one of the eight external trigger sources for DAC1
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t TRIGMOD = (2 << 17);  ///< Select the trigger source for channel 1
        constexpr uint32_t ANACFG = (5 << 19);  ///< DAC1 analog configuration/calibration parameters
        constexpr uint32_t ANAEN = (1U << 24);  ///< Enable analog DAC for channel 1
        constexpr uint32_t REFCFGH = (4 << 28);  ///< Higher 4 band-gap configuration/calibration parameters
    }

    /// DAC0DATA Register bits
    namespace dac0data_bits {
        constexpr uint32_t DATA0 = (12 << 0);  ///< DAC0 Data Bits
    }

    /// DAC1DATA Register bits
    namespace dac1data_bits {
        constexpr uint32_t DATA1 = (12 << 0);  ///< DAC1 Data Bits
    }

    /// DAC01DATA Register bits
    namespace dac01data_bits {
        constexpr uint32_t DATA0 = (12 << 0);  ///< DAC0 Data Bits
        constexpr uint32_t DATA1 = (12 << 16);  ///< DAC1 Data Bits
    }

    /// DAC0PATL Register bits
    namespace dac0patl_bits {
        constexpr uint32_t PAT0 = (5 << 0);  ///< Pattern Number 0 for PATGEN of DAC0
        constexpr uint32_t PAT1 = (5 << 5);  ///< Pattern Number 1 for PATGEN of DAC0
        constexpr uint32_t PAT2 = (5 << 10);  ///< Pattern Number 2 for PATGEN of DAC0
        constexpr uint32_t PAT3 = (5 << 15);  ///< Pattern Number 3 for PATGEN of DAC0
        constexpr uint32_t PAT4 = (5 << 20);  ///< Pattern Number 4 for PATGEN of DAC0
        constexpr uint32_t PAT5 = (5 << 25);  ///< Pattern Number 5 for PATGEN of DAC0
    }

    /// DAC0PATH Register bits
    namespace dac0path_bits {
        constexpr uint32_t PAT6 = (5 << 0);  ///< Pattern Number 6 for PATGEN of DAC0
        constexpr uint32_t PAT7 = (5 << 5);  ///< Pattern Number 7 for PATGEN of DAC0
        constexpr uint32_t PAT8 = (5 << 10);  ///< Pattern Number 8 for PATGEN of DAC0
    }

    /// DAC1PATL Register bits
    namespace dac1patl_bits {
        constexpr uint32_t PAT0 = (5 << 0);  ///< Pattern Number 0 for PATGEN of DAC1
        constexpr uint32_t PAT1 = (5 << 5);  ///< Pattern Number 1 for PATGEN of DAC1
        constexpr uint32_t PAT2 = (5 << 10);  ///< Pattern Number 2 for PATGEN of DAC1
        constexpr uint32_t PAT3 = (5 << 15);  ///< Pattern Number 3 for PATGEN of DAC1
        constexpr uint32_t PAT4 = (5 << 20);  ///< Pattern Number 4 for PATGEN of DAC1
        constexpr uint32_t PAT5 = (5 << 25);  ///< Pattern Number 5 for PATGEN of DAC1
    }

    /// DAC1PATH Register bits
    namespace dac1path_bits {
        constexpr uint32_t PAT6 = (5 << 0);  ///< Pattern Number 6 for PATGEN of DAC1
        constexpr uint32_t PAT7 = (5 << 5);  ///< Pattern Number 7 for PATGEN of DAC1
        constexpr uint32_t PAT8 = (5 << 10);  ///< Pattern Number 8 for PATGEN of DAC1
    }

}

// ============================================================================
// CCU40 Peripheral
// ============================================================================

namespace ccu40 {
    /// Base addresses
    constexpr uint32_t CCU40_BASE = 0x4000C000;
    constexpr uint32_t CCU40_CC40_BASE = 0x4000C100;
    constexpr uint32_t CCU40_CC41_BASE = 0x4000C200;
    constexpr uint32_t CCU40_CC42_BASE = 0x4000C300;
    constexpr uint32_t CCU40_CC43_BASE = 0x4000C400;

    /// CCU40 Register structure
    struct Registers {
        volatile uint32_t GCTRL;  ///< Offset: 0x00 - Global Control Register
        volatile uint32_t GSTAT;  ///< Offset: 0x04 - Global Status Register
        volatile uint32_t GIDLS;  ///< Offset: 0x08 - Global Idle Set
        volatile uint32_t GIDLC;  ///< Offset: 0x0C - Global Idle Clear
        volatile uint32_t GCSS;  ///< Offset: 0x10 - Global Channel Set
        volatile uint32_t GCSC;  ///< Offset: 0x14 - Global Channel Clear
        volatile uint32_t GCST;  ///< Offset: 0x18 - Global Channel Status
        volatile uint32_t MIDR;  ///< Offset: 0x80 - Module Identification
    };

    /// Peripheral instances
    inline Registers* CCU40 = reinterpret_cast<Registers*>(CCU40_BASE);
    inline Registers* CCU40_CC40 = reinterpret_cast<Registers*>(CCU40_CC40_BASE);
    inline Registers* CCU40_CC41 = reinterpret_cast<Registers*>(CCU40_CC41_BASE);
    inline Registers* CCU40_CC42 = reinterpret_cast<Registers*>(CCU40_CC42_BASE);
    inline Registers* CCU40_CC43 = reinterpret_cast<Registers*>(CCU40_CC43_BASE);

    // Bit definitions
    /// GCTRL Register bits
    namespace gctrl_bits {
        constexpr uint32_t PRBC = (3 << 0);  ///< Prescaler Clear Configuration
        constexpr uint32_t PCIS = (2 << 4);  ///< Prescaler Input Clock Selection
        constexpr uint32_t SUSCFG = (2 << 8);  ///< Suspend Mode Configuration
        constexpr uint32_t MSE0 = (1U << 10);  ///< Slice 0 Multi Channel shadow transfer enable
        constexpr uint32_t MSE1 = (1U << 11);  ///< Slice 1 Multi Channel shadow transfer enable
        constexpr uint32_t MSE2 = (1U << 12);  ///< Slice 2 Multi Channel shadow transfer enable
        constexpr uint32_t MSE3 = (1U << 13);  ///< Slice 3 Multi Channel shadow transfer enable
        constexpr uint32_t MSDE = (2 << 14);  ///< Multi Channel shadow transfer request configuration
    }

    /// GSTAT Register bits
    namespace gstat_bits {
        constexpr uint32_t S0I = (1U << 0);  ///< CC40 IDLE status
        constexpr uint32_t S1I = (1U << 1);  ///< CC41 IDLE status
        constexpr uint32_t S2I = (1U << 2);  ///< CC42 IDLE status
        constexpr uint32_t S3I = (1U << 3);  ///< CC43 IDLE status
        constexpr uint32_t PRB = (1U << 8);  ///< Prescaler Run Bit
    }

    /// GIDLS Register bits
    namespace gidls_bits {
        constexpr uint32_t SS0I = (1U << 0);  ///< CC40 IDLE mode set
        constexpr uint32_t SS1I = (1U << 1);  ///< CC41 IDLE mode set
        constexpr uint32_t SS2I = (1U << 2);  ///< CC42 IDLE mode set
        constexpr uint32_t SS3I = (1U << 3);  ///< CC43 IDLE mode set
        constexpr uint32_t CPRB = (1U << 8);  ///< Prescaler Run Bit Clear
        constexpr uint32_t PSIC = (1U << 9);  ///< Prescaler clear
    }

    /// GIDLC Register bits
    namespace gidlc_bits {
        constexpr uint32_t CS0I = (1U << 0);  ///< CC40 IDLE mode clear
        constexpr uint32_t CS1I = (1U << 1);  ///< CC41 IDLE mode clear
        constexpr uint32_t CS2I = (1U << 2);  ///< CC42 IDLE mode clear
        constexpr uint32_t CS3I = (1U << 3);  ///< CC43 IDLE mode clear
        constexpr uint32_t SPRB = (1U << 8);  ///< Prescaler Run Bit Set
    }

    /// GCSS Register bits
    namespace gcss_bits {
        constexpr uint32_t S0SE = (1U << 0);  ///< Slice 0 shadow transfer set enable
        constexpr uint32_t S0DSE = (1U << 1);  ///< Slice 0 Dither shadow transfer set enable
        constexpr uint32_t S0PSE = (1U << 2);  ///< Slice 0 Prescaler shadow transfer set enable
        constexpr uint32_t S1SE = (1U << 4);  ///< Slice 1 shadow transfer set enable
        constexpr uint32_t S1DSE = (1U << 5);  ///< Slice 1 Dither shadow transfer set enable
        constexpr uint32_t S1PSE = (1U << 6);  ///< Slice 1 Prescaler shadow transfer set enable
        constexpr uint32_t S2SE = (1U << 8);  ///< Slice 2 shadow transfer set enable
        constexpr uint32_t S2DSE = (1U << 9);  ///< Slice 2 Dither shadow transfer set enable
        constexpr uint32_t S2PSE = (1U << 10);  ///< Slice 2 Prescaler shadow transfer set enable
        constexpr uint32_t S3SE = (1U << 12);  ///< Slice 3 shadow transfer set enable
        constexpr uint32_t S3DSE = (1U << 13);  ///< Slice 3 Dither shadow transfer set enable
        constexpr uint32_t S3PSE = (1U << 14);  ///< Slice 3 Prescaler shadow transfer set enable
        constexpr uint32_t S0STS = (1U << 16);  ///< Slice 0 status bit set
        constexpr uint32_t S1STS = (1U << 17);  ///< Slice 1 status bit set
        constexpr uint32_t S2STS = (1U << 18);  ///< Slice 2 status bit set
        constexpr uint32_t S3STS = (1U << 19);  ///< Slice 3 status bit set
    }

    /// GCSC Register bits
    namespace gcsc_bits {
        constexpr uint32_t S0SC = (1U << 0);  ///< Slice 0 shadow transfer clear
        constexpr uint32_t S0DSC = (1U << 1);  ///< Slice 0 Dither shadow transfer clear
        constexpr uint32_t S0PSC = (1U << 2);  ///< Slice 0 Prescaler shadow transfer clear
        constexpr uint32_t S1SC = (1U << 4);  ///< Slice 1 shadow transfer clear
        constexpr uint32_t S1DSC = (1U << 5);  ///< Slice 1 Dither shadow transfer clear
        constexpr uint32_t S1PSC = (1U << 6);  ///< Slice 1 Prescaler shadow transfer clear
        constexpr uint32_t S2SC = (1U << 8);  ///< Slice 2 shadow transfer clear
        constexpr uint32_t S2DSC = (1U << 9);  ///< Slice 2 Dither shadow transfer clear
        constexpr uint32_t S2PSC = (1U << 10);  ///< Slice 2 Prescaler shadow transfer clear
        constexpr uint32_t S3SC = (1U << 12);  ///< Slice 3 shadow transfer clear
        constexpr uint32_t S3DSC = (1U << 13);  ///< Slice 3 Dither shadow transfer clear
        constexpr uint32_t S3PSC = (1U << 14);  ///< Slice 3 Prescaler shadow transfer clear
        constexpr uint32_t S0STC = (1U << 16);  ///< Slice 0 status bit clear
        constexpr uint32_t S1STC = (1U << 17);  ///< Slice 1 status bit clear
        constexpr uint32_t S2STC = (1U << 18);  ///< Slice 2 status bit clear
        constexpr uint32_t S3STC = (1U << 19);  ///< Slice 3 status bit clear
    }

    /// GCST Register bits
    namespace gcst_bits {
        constexpr uint32_t S0SS = (1U << 0);  ///< Slice 0 shadow transfer status
        constexpr uint32_t S0DSS = (1U << 1);  ///< Slice 0 Dither shadow transfer status
        constexpr uint32_t S0PSS = (1U << 2);  ///< Slice 0 Prescaler shadow transfer status
        constexpr uint32_t S1SS = (1U << 4);  ///< Slice 1 shadow transfer status
        constexpr uint32_t S1DSS = (1U << 5);  ///< Slice 1 Dither shadow transfer status
        constexpr uint32_t S1PSS = (1U << 6);  ///< Slice 1 Prescaler shadow transfer status
        constexpr uint32_t S2SS = (1U << 8);  ///< Slice 2 shadow transfer status
        constexpr uint32_t S2DSS = (1U << 9);  ///< Slice 2 Dither shadow transfer status
        constexpr uint32_t S2PSS = (1U << 10);  ///< Slice 2 Prescaler shadow transfer status
        constexpr uint32_t S3SS = (1U << 12);  ///< Slice 3 shadow transfer status
        constexpr uint32_t S3DSS = (1U << 13);  ///< Slice 3 Dither shadow transfer status
        constexpr uint32_t S3PSS = (1U << 14);  ///< Slice 3 Prescaler shadow transfer status
        constexpr uint32_t CC40ST = (1U << 16);  ///< Slice 0 status bit
        constexpr uint32_t CC41ST = (1U << 17);  ///< Slice 1 status bit
        constexpr uint32_t CC42ST = (1U << 18);  ///< Slice 2 status bit
        constexpr uint32_t CC43ST = (1U << 19);  ///< Slice 3 status bit
    }

    /// MIDR Register bits
    namespace midr_bits {
        constexpr uint32_t MODR = (8 << 0);  ///< Module Revision
        constexpr uint32_t MODT = (8 << 8);  ///< Module Type
        constexpr uint32_t MODN = (16 << 16);  ///< Module Number
    }

}

// ============================================================================
// CCU41 Peripheral
// ============================================================================

namespace ccu41 {
    /// Base addresses
    constexpr uint32_t CCU41_BASE = 0x40010000;
    constexpr uint32_t CCU41_CC40_BASE = 0x40010100;
    constexpr uint32_t CCU41_CC41_BASE = 0x40010200;
    constexpr uint32_t CCU41_CC42_BASE = 0x40010300;
    constexpr uint32_t CCU41_CC43_BASE = 0x40010400;

    /// CCU41 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CCU41 = reinterpret_cast<Registers*>(CCU41_BASE);
    inline Registers* CCU41_CC40 = reinterpret_cast<Registers*>(CCU41_CC40_BASE);
    inline Registers* CCU41_CC41 = reinterpret_cast<Registers*>(CCU41_CC41_BASE);
    inline Registers* CCU41_CC42 = reinterpret_cast<Registers*>(CCU41_CC42_BASE);
    inline Registers* CCU41_CC43 = reinterpret_cast<Registers*>(CCU41_CC43_BASE);

}

// ============================================================================
// CCU80 Peripheral
// ============================================================================

namespace ccu80 {
    /// Base addresses
    constexpr uint32_t CCU80_BASE = 0x40020000;
    constexpr uint32_t CCU80_CC80_BASE = 0x40020100;
    constexpr uint32_t CCU80_CC81_BASE = 0x40020200;
    constexpr uint32_t CCU80_CC82_BASE = 0x40020300;
    constexpr uint32_t CCU80_CC83_BASE = 0x40020400;

    /// CCU80 Register structure
    struct Registers {
        volatile uint32_t GCTRL;  ///< Offset: 0x00 - Global Control Register
        volatile uint32_t GSTAT;  ///< Offset: 0x04 - Global Status Register
        volatile uint32_t GIDLS;  ///< Offset: 0x08 - Global Idle Set
        volatile uint32_t GIDLC;  ///< Offset: 0x0C - Global Idle Clear
        volatile uint32_t GCSS;  ///< Offset: 0x10 - Global Channel Set
        volatile uint32_t GCSC;  ///< Offset: 0x14 - Global Channel Clear
        volatile uint32_t GCST;  ///< Offset: 0x18 - Global Channel status
        volatile uint32_t GPCHK;  ///< Offset: 0x1C - Parity Checker Configuration
        volatile uint32_t MIDR;  ///< Offset: 0x80 - Module Identification
    };

    /// Peripheral instances
    inline Registers* CCU80 = reinterpret_cast<Registers*>(CCU80_BASE);
    inline Registers* CCU80_CC80 = reinterpret_cast<Registers*>(CCU80_CC80_BASE);
    inline Registers* CCU80_CC81 = reinterpret_cast<Registers*>(CCU80_CC81_BASE);
    inline Registers* CCU80_CC82 = reinterpret_cast<Registers*>(CCU80_CC82_BASE);
    inline Registers* CCU80_CC83 = reinterpret_cast<Registers*>(CCU80_CC83_BASE);

    // Bit definitions
    /// GCTRL Register bits
    namespace gctrl_bits {
        constexpr uint32_t PRBC = (3 << 0);  ///< Prescaler Clear Configuration
        constexpr uint32_t PCIS = (2 << 4);  ///< Prescaler Input Clock Selection
        constexpr uint32_t SUSCFG = (2 << 8);  ///< Suspend Mode Configuration
        constexpr uint32_t MSE0 = (1U << 10);  ///< Slice 0 Multi Channel shadow transfer enable
        constexpr uint32_t MSE1 = (1U << 11);  ///< Slice 1 Multi Channel shadow transfer enable
        constexpr uint32_t MSE2 = (1U << 12);  ///< Slice 2 Multi Channel shadow transfer enable
        constexpr uint32_t MSE3 = (1U << 13);  ///< Slice 3 Multi Channel shadow transfer enable
        constexpr uint32_t MSDE = (2 << 14);  ///< Multi Channel shadow transfer request configuration
    }

    /// GSTAT Register bits
    namespace gstat_bits {
        constexpr uint32_t S0I = (1U << 0);  ///< CC80 IDLE status
        constexpr uint32_t S1I = (1U << 1);  ///< CC81 IDLE status
        constexpr uint32_t S2I = (1U << 2);  ///< CC82 IDLE status
        constexpr uint32_t S3I = (1U << 3);  ///< CC83 IDLE status
        constexpr uint32_t PRB = (1U << 8);  ///< Prescaler Run Bit
        constexpr uint32_t PCRB = (1U << 10);  ///< Parity Checker Run Bit
    }

    /// GIDLS Register bits
    namespace gidls_bits {
        constexpr uint32_t SS0I = (1U << 0);  ///< CC80 IDLE mode set
        constexpr uint32_t SS1I = (1U << 1);  ///< CC81 IDLE mode set
        constexpr uint32_t SS2I = (1U << 2);  ///< CC82 IDLE mode set
        constexpr uint32_t SS3I = (1U << 3);  ///< CC83 IDLE mode set
        constexpr uint32_t CPRB = (1U << 8);  ///< Prescaler# Run Bit Clear
        constexpr uint32_t PSIC = (1U << 9);  ///< Prescaler clear
        constexpr uint32_t CPCH = (1U << 10);  ///< Parity Checker Run bit clear
    }

    /// GIDLC Register bits
    namespace gidlc_bits {
        constexpr uint32_t CS0I = (1U << 0);  ///< CC80 IDLE mode clear
        constexpr uint32_t CS1I = (1U << 1);  ///< CC81 IDLE mode clear
        constexpr uint32_t CS2I = (1U << 2);  ///< CC82 IDLE mode clear
        constexpr uint32_t CS3I = (1U << 3);  ///< CC83 IDLE mode clear
        constexpr uint32_t SPRB = (1U << 8);  ///< Prescaler Run Bit Set
        constexpr uint32_t SPCH = (1U << 10);  ///< Parity Checker run bit set
    }

    /// GCSS Register bits
    namespace gcss_bits {
        constexpr uint32_t S0SE = (1U << 0);  ///< Slice 0 shadow transfer set enable
        constexpr uint32_t S0DSE = (1U << 1);  ///< Slice 0 Dither shadow transfer set enable
        constexpr uint32_t S0PSE = (1U << 2);  ///< Slice 0 Prescaler shadow transfer set enable
        constexpr uint32_t S1SE = (1U << 4);  ///< Slice 1 shadow transfer set enable
        constexpr uint32_t S1DSE = (1U << 5);  ///< Slice 1 Dither shadow transfer set enable
        constexpr uint32_t S1PSE = (1U << 6);  ///< Slice 1 Prescaler shadow transfer set enable
        constexpr uint32_t S2SE = (1U << 8);  ///< Slice 2 shadow transfer set enable
        constexpr uint32_t S2DSE = (1U << 9);  ///< Slice 2 Dither shadow transfer set enable
        constexpr uint32_t S2PSE = (1U << 10);  ///< Slice 2 Prescaler shadow transfer set enable
        constexpr uint32_t S3SE = (1U << 12);  ///< Slice 3 shadow transfer set enable
        constexpr uint32_t S3DSE = (1U << 13);  ///< Slice 3 Dither shadow transfer set enable
        constexpr uint32_t S3PSE = (1U << 14);  ///< Slice 3 Prescaler shadow transfer set enable
        constexpr uint32_t S0ST1S = (1U << 16);  ///< Slice 0 status bit 1 set
        constexpr uint32_t S1ST1S = (1U << 17);  ///< Slice 1 status bit 1 set
        constexpr uint32_t S2ST1S = (1U << 18);  ///< Slice 2 status bit 1 set
        constexpr uint32_t S3ST1S = (1U << 19);  ///< Slice 3 status bit 1 set
        constexpr uint32_t S0ST2S = (1U << 20);  ///< Slice 0 status bit 2 set
        constexpr uint32_t S1ST2S = (1U << 21);  ///< Slice 1 status bit 2 set
        constexpr uint32_t S2ST2S = (1U << 22);  ///< Slice 2 status bit 2 set
        constexpr uint32_t S3ST2S = (1U << 23);  ///< Slice 3 status bit 2 set
    }

    /// GCSC Register bits
    namespace gcsc_bits {
        constexpr uint32_t S0SC = (1U << 0);  ///< Slice 0 shadow transfer request clear
        constexpr uint32_t S0DSC = (1U << 1);  ///< Slice 0 Dither shadow transfer clear
        constexpr uint32_t S0PSC = (1U << 2);  ///< Slice 0 Prescaler shadow transfer clear
        constexpr uint32_t S1SC = (1U << 4);  ///< Slice 1 shadow transfer clear
        constexpr uint32_t S1DSC = (1U << 5);  ///< Slice 1 Dither shadow transfer clear
        constexpr uint32_t S1PSC = (1U << 6);  ///< Slice 1 Prescaler shadow transfer clear
        constexpr uint32_t S2SC = (1U << 8);  ///< Slice 2 shadow transfer clear
        constexpr uint32_t S2DSC = (1U << 9);  ///< Slice 2 Dither shadow transfer clear
        constexpr uint32_t S2PSC = (1U << 10);  ///< Slice 2 Prescaler shadow transfer clear
        constexpr uint32_t S3SC = (1U << 12);  ///< Slice 3 shadow transfer clear
        constexpr uint32_t S3DSC = (1U << 13);  ///< Slice 3 Dither shadow transfer clear
        constexpr uint32_t S3PSC = (1U << 14);  ///< Slice 3 Prescaler shadow transfer clear
        constexpr uint32_t S0ST1C = (1U << 16);  ///< Slice 0 status bit 1 clear
        constexpr uint32_t S1ST1C = (1U << 17);  ///< Slice 1 status bit 1 clear
        constexpr uint32_t S2ST1C = (1U << 18);  ///< Slice 2 status bit 1 clear
        constexpr uint32_t S3ST1C = (1U << 19);  ///< Slice 3 status bit 1 clear
        constexpr uint32_t S0ST2C = (1U << 20);  ///< Slice 0 status bit 2 clear
        constexpr uint32_t S1ST2C = (1U << 21);  ///< Slice 1 status bit 2 clear
        constexpr uint32_t S2ST2C = (1U << 22);  ///< Slice 2 status bit 2 clear
        constexpr uint32_t S3ST2C = (1U << 23);  ///< Slice 3 status bit 2 clear
    }

    /// GCST Register bits
    namespace gcst_bits {
        constexpr uint32_t S0SS = (1U << 0);  ///< Slice 0 shadow transfer status
        constexpr uint32_t S0DSS = (1U << 1);  ///< Slice 0 Dither shadow transfer status
        constexpr uint32_t S0PSS = (1U << 2);  ///< Slice 0 Prescaler shadow transfer status
        constexpr uint32_t S1SS = (1U << 4);  ///< Slice 1 shadow transfer status
        constexpr uint32_t S1DSS = (1U << 5);  ///< Slice 1 Dither shadow transfer status
        constexpr uint32_t S1PSS = (1U << 6);  ///< Slice 1 Prescaler shadow transfer status
        constexpr uint32_t S2SS = (1U << 8);  ///< Slice 2 shadow transfer status
        constexpr uint32_t S2DSS = (1U << 9);  ///< Slice 2 Dither shadow transfer status
        constexpr uint32_t S2PSS = (1U << 10);  ///< Slice 2 Prescaler shadow transfer status
        constexpr uint32_t S3SS = (1U << 12);  ///< Slice 3 shadow transfer status
        constexpr uint32_t S3DSS = (1U << 13);  ///< Slice 3 Dither shadow transfer status
        constexpr uint32_t S3PSS = (1U << 14);  ///< Slice 3 Prescaler shadow transfer status
        constexpr uint32_t CC80ST1 = (1U << 16);  ///< Slice 0 compare channel 1 status bit
        constexpr uint32_t CC81ST1 = (1U << 17);  ///< Slice 1 compare channel 1 status bit
        constexpr uint32_t CC82ST1 = (1U << 18);  ///< Slice 2 compare channel 1 status bit
        constexpr uint32_t CC83ST1 = (1U << 19);  ///< Slice 3 compare channel 1 status bit
        constexpr uint32_t CC80ST2 = (1U << 20);  ///< Slice 0 compare channel 2 status bit
        constexpr uint32_t CC81ST2 = (1U << 21);  ///< Slice 1 compare channel 2 status bit
        constexpr uint32_t CC82ST2 = (1U << 22);  ///< Slice 2 compare channel 2 status bit
        constexpr uint32_t CC83ST2 = (1U << 23);  ///< Slice 3 compare channel 2 status bit
    }

    /// GPCHK Register bits
    namespace gpchk_bits {
        constexpr uint32_t PASE = (1U << 0);  ///< Parity Checker Automatic start/stop
        constexpr uint32_t PACS = (2 << 1);  ///< Parity Checker Automatic start/stop selector
        constexpr uint32_t PISEL = (2 << 3);  ///< Driver Input signal selector
        constexpr uint32_t PCDS = (2 << 5);  ///< Parity Checker Delay Input Selector
        constexpr uint32_t PCTS = (1U << 7);  ///< Parity Checker type selector
        constexpr uint32_t PCST = (1U << 15);  ///< Parity Checker XOR status
        constexpr uint32_t PCSEL0 = (4 << 16);  ///< Parity Checker Slice 0 output selection
        constexpr uint32_t PCSEL1 = (4 << 20);  ///< Parity Checker Slice 1 output selection
        constexpr uint32_t PCSEL2 = (4 << 24);  ///< Parity Checker Slice 2 output selection
        constexpr uint32_t PCSEL3 = (4 << 28);  ///< Parity Checker Slice 3 output selection
    }

    /// MIDR Register bits
    namespace midr_bits {
        constexpr uint32_t MODR = (8 << 0);  ///< Module Revision
        constexpr uint32_t MODT = (8 << 8);  ///< Module Type
        constexpr uint32_t MODN = (16 << 16);  ///< Module Number
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT0_BASE = 0x48028000;
    constexpr uint32_t PORT1_BASE = 0x48028100;
    constexpr uint32_t PORT2_BASE = 0x48028200;
    constexpr uint32_t PORT3_BASE = 0x48028300;
    constexpr uint32_t PORT4_BASE = 0x48028400;
    constexpr uint32_t PORT5_BASE = 0x48028500;
    constexpr uint32_t PORT14_BASE = 0x48028E00;
    constexpr uint32_t PORT15_BASE = 0x48028F00;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t OUT;  ///< Offset: 0x00 - Port 0 Output Register
        volatile uint32_t OMR;  ///< Offset: 0x04 - Port 0 Output Modification Register
        volatile uint32_t IOCR0;  ///< Offset: 0x10 - Port 0 Input/Output Control Register 0
        volatile uint32_t IOCR4;  ///< Offset: 0x14 - Port 0 Input/Output Control Register 4
        volatile uint32_t IOCR8;  ///< Offset: 0x18 - Port 0 Input/Output Control Register 8
        volatile uint32_t IOCR12;  ///< Offset: 0x1C - Port 0 Input/Output Control Register 12
        volatile uint32_t IN;  ///< Offset: 0x24 - Port 0 Input Register
        volatile uint32_t PDR0;  ///< Offset: 0x40 - Port 0 Pad Driver Mode 0 Register
        volatile uint32_t PDR1;  ///< Offset: 0x44 - Port 0 Pad Driver Mode 1 Register
        volatile uint32_t PDISC;  ///< Offset: 0x60 - Port 0 Pin Function Decision Control Register
        volatile uint32_t PPS;  ///< Offset: 0x70 - Port 0 Pin Power Save Register
        volatile uint32_t HWSEL;  ///< Offset: 0x74 - Port 0 Pin Hardware Select Register
    };

    /// Peripheral instances
    inline Registers* PORT0 = reinterpret_cast<Registers*>(PORT0_BASE);
    inline Registers* PORT1 = reinterpret_cast<Registers*>(PORT1_BASE);
    inline Registers* PORT2 = reinterpret_cast<Registers*>(PORT2_BASE);
    inline Registers* PORT3 = reinterpret_cast<Registers*>(PORT3_BASE);
    inline Registers* PORT4 = reinterpret_cast<Registers*>(PORT4_BASE);
    inline Registers* PORT5 = reinterpret_cast<Registers*>(PORT5_BASE);
    inline Registers* PORT14 = reinterpret_cast<Registers*>(PORT14_BASE);
    inline Registers* PORT15 = reinterpret_cast<Registers*>(PORT15_BASE);

    // Bit definitions
    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Port n Output Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Port n Output Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Port n Output Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Port n Output Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Port n Output Bit 4
        constexpr uint32_t P5 = (1U << 5);  ///< Port n Output Bit 5
        constexpr uint32_t P6 = (1U << 6);  ///< Port n Output Bit 6
        constexpr uint32_t P7 = (1U << 7);  ///< Port n Output Bit 7
        constexpr uint32_t P8 = (1U << 8);  ///< Port n Output Bit 8
        constexpr uint32_t P9 = (1U << 9);  ///< Port n Output Bit 9
        constexpr uint32_t P10 = (1U << 10);  ///< Port n Output Bit 10
        constexpr uint32_t P11 = (1U << 11);  ///< Port n Output Bit 11
        constexpr uint32_t P12 = (1U << 12);  ///< Port n Output Bit 12
        constexpr uint32_t P13 = (1U << 13);  ///< Port n Output Bit 13
        constexpr uint32_t P14 = (1U << 14);  ///< Port n Output Bit 14
        constexpr uint32_t P15 = (1U << 15);  ///< Port n Output Bit 15
    }

    /// OMR Register bits
    namespace omr_bits {
        constexpr uint32_t PS0 = (1U << 0);  ///< Port n Set Bit 0
        constexpr uint32_t PS1 = (1U << 1);  ///< Port n Set Bit 1
        constexpr uint32_t PS2 = (1U << 2);  ///< Port n Set Bit 2
        constexpr uint32_t PS3 = (1U << 3);  ///< Port n Set Bit 3
        constexpr uint32_t PS4 = (1U << 4);  ///< Port n Set Bit 4
        constexpr uint32_t PS5 = (1U << 5);  ///< Port n Set Bit 5
        constexpr uint32_t PS6 = (1U << 6);  ///< Port n Set Bit 6
        constexpr uint32_t PS7 = (1U << 7);  ///< Port n Set Bit 7
        constexpr uint32_t PS8 = (1U << 8);  ///< Port n Set Bit 8
        constexpr uint32_t PS9 = (1U << 9);  ///< Port n Set Bit 9
        constexpr uint32_t PS10 = (1U << 10);  ///< Port n Set Bit 10
        constexpr uint32_t PS11 = (1U << 11);  ///< Port n Set Bit 11
        constexpr uint32_t PS12 = (1U << 12);  ///< Port n Set Bit 12
        constexpr uint32_t PS13 = (1U << 13);  ///< Port n Set Bit 13
        constexpr uint32_t PS14 = (1U << 14);  ///< Port n Set Bit 14
        constexpr uint32_t PS15 = (1U << 15);  ///< Port n Set Bit 15
        constexpr uint32_t PR0 = (1U << 16);  ///< Port n Reset Bit 0
        constexpr uint32_t PR1 = (1U << 17);  ///< Port n Reset Bit 1
        constexpr uint32_t PR2 = (1U << 18);  ///< Port n Reset Bit 2
        constexpr uint32_t PR3 = (1U << 19);  ///< Port n Reset Bit 3
        constexpr uint32_t PR4 = (1U << 20);  ///< Port n Reset Bit 4
        constexpr uint32_t PR5 = (1U << 21);  ///< Port n Reset Bit 5
        constexpr uint32_t PR6 = (1U << 22);  ///< Port n Reset Bit 6
        constexpr uint32_t PR7 = (1U << 23);  ///< Port n Reset Bit 7
        constexpr uint32_t PR8 = (1U << 24);  ///< Port n Reset Bit 8
        constexpr uint32_t PR9 = (1U << 25);  ///< Port n Reset Bit 9
        constexpr uint32_t PR10 = (1U << 26);  ///< Port n Reset Bit 10
        constexpr uint32_t PR11 = (1U << 27);  ///< Port n Reset Bit 11
        constexpr uint32_t PR12 = (1U << 28);  ///< Port n Reset Bit 12
        constexpr uint32_t PR13 = (1U << 29);  ///< Port n Reset Bit 13
        constexpr uint32_t PR14 = (1U << 30);  ///< Port n Reset Bit 14
        constexpr uint32_t PR15 = (1U << 31);  ///< Port n Reset Bit 15
    }

    /// IOCR0 Register bits
    namespace iocr0_bits {
        constexpr uint32_t PC0 = (5 << 3);  ///< Port Control for Port n Pin 0 to 3
        constexpr uint32_t PC1 = (5 << 11);  ///< Port Control for Port n Pin 0 to 3
        constexpr uint32_t PC2 = (5 << 19);  ///< Port Control for Port n Pin 0 to 3
        constexpr uint32_t PC3 = (5 << 27);  ///< Port Control for Port n Pin 0 to 3
    }

    /// IOCR4 Register bits
    namespace iocr4_bits {
        constexpr uint32_t PC4 = (5 << 3);  ///< Port Control for Port n Pin 4 to 7
        constexpr uint32_t PC5 = (5 << 11);  ///< Port Control for Port n Pin 4 to 7
        constexpr uint32_t PC6 = (5 << 19);  ///< Port Control for Port n Pin 4 to 7
        constexpr uint32_t PC7 = (5 << 27);  ///< Port Control for Port n Pin 4 to 7
    }

    /// IOCR8 Register bits
    namespace iocr8_bits {
        constexpr uint32_t PC8 = (5 << 3);  ///< Port Control for Port n Pin 8 to 11
        constexpr uint32_t PC9 = (5 << 11);  ///< Port Control for Port n Pin 8 to 11
        constexpr uint32_t PC10 = (5 << 19);  ///< Port Control for Port n Pin 8 to 11
        constexpr uint32_t PC11 = (5 << 27);  ///< Port Control for Port n Pin 8 to 11
    }

    /// IOCR12 Register bits
    namespace iocr12_bits {
        constexpr uint32_t PC12 = (5 << 3);  ///< Port Control for Port n Pin 12 to 15
        constexpr uint32_t PC13 = (5 << 11);  ///< Port Control for Port n Pin 12 to 15
        constexpr uint32_t PC14 = (5 << 19);  ///< Port Control for Port n Pin 12 to 15
        constexpr uint32_t PC15 = (5 << 27);  ///< Port Control for Port n Pin 12 to 15
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Port n Input Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Port n Input Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Port n Input Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Port n Input Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Port n Input Bit 4
        constexpr uint32_t P5 = (1U << 5);  ///< Port n Input Bit 5
        constexpr uint32_t P6 = (1U << 6);  ///< Port n Input Bit 6
        constexpr uint32_t P7 = (1U << 7);  ///< Port n Input Bit 7
        constexpr uint32_t P8 = (1U << 8);  ///< Port n Input Bit 8
        constexpr uint32_t P9 = (1U << 9);  ///< Port n Input Bit 9
        constexpr uint32_t P10 = (1U << 10);  ///< Port n Input Bit 10
        constexpr uint32_t P11 = (1U << 11);  ///< Port n Input Bit 11
        constexpr uint32_t P12 = (1U << 12);  ///< Port n Input Bit 12
        constexpr uint32_t P13 = (1U << 13);  ///< Port n Input Bit 13
        constexpr uint32_t P14 = (1U << 14);  ///< Port n Input Bit 14
        constexpr uint32_t P15 = (1U << 15);  ///< Port n Input Bit 15
    }

    /// PDR0 Register bits
    namespace pdr0_bits {
        constexpr uint32_t PD0 = (3 << 0);  ///< Pad Driver Mode for Pn.0
        constexpr uint32_t PD1 = (3 << 4);  ///< Pad Driver Mode for Pn.1
        constexpr uint32_t PD2 = (3 << 8);  ///< Pad Driver Mode for Pn.2
        constexpr uint32_t PD3 = (3 << 12);  ///< Pad Driver Mode for Pn.3
        constexpr uint32_t PD4 = (3 << 16);  ///< Pad Driver Mode for Pn.4
        constexpr uint32_t PD5 = (3 << 20);  ///< Pad Driver Mode for Pn.5
        constexpr uint32_t PD6 = (3 << 24);  ///< Pad Driver Mode for Pn.6
        constexpr uint32_t PD7 = (3 << 28);  ///< Pad Driver Mode for Pn.7
    }

    /// PDR1 Register bits
    namespace pdr1_bits {
        constexpr uint32_t PD8 = (3 << 0);  ///< Pad Driver Mode for Pn.8
        constexpr uint32_t PD9 = (3 << 4);  ///< Pad Driver Mode for Pn.9
        constexpr uint32_t PD10 = (3 << 8);  ///< Pad Driver Mode for Pn.10
        constexpr uint32_t PD11 = (3 << 12);  ///< Pad Driver Mode for Pn.11
        constexpr uint32_t PD12 = (3 << 16);  ///< Pad Driver Mode for Pn.12
        constexpr uint32_t PD13 = (3 << 20);  ///< Pad Driver Mode for Pn.13
        constexpr uint32_t PD14 = (3 << 24);  ///< Pad Driver Mode for Pn.14
        constexpr uint32_t PD15 = (3 << 28);  ///< Pad Driver Mode for Pn.15
    }

    /// PDISC Register bits
    namespace pdisc_bits {
        constexpr uint32_t PDIS0 = (1U << 0);  ///< Pad Disable for Port n Pin 0
        constexpr uint32_t PDIS1 = (1U << 1);  ///< Pad Disable for Port n Pin 1
        constexpr uint32_t PDIS2 = (1U << 2);  ///< Pad Disable for Port n Pin 2
        constexpr uint32_t PDIS3 = (1U << 3);  ///< Pad Disable for Port n Pin 3
        constexpr uint32_t PDIS4 = (1U << 4);  ///< Pad Disable for Port n Pin 4
        constexpr uint32_t PDIS5 = (1U << 5);  ///< Pad Disable for Port n Pin 5
        constexpr uint32_t PDIS6 = (1U << 6);  ///< Pad Disable for Port n Pin 6
        constexpr uint32_t PDIS7 = (1U << 7);  ///< Pad Disable for Port n Pin 7
        constexpr uint32_t PDIS8 = (1U << 8);  ///< Pad Disable for Port n Pin 8
        constexpr uint32_t PDIS9 = (1U << 9);  ///< Pad Disable for Port n Pin 9
        constexpr uint32_t PDIS10 = (1U << 10);  ///< Pad Disable for Port n Pin 10
        constexpr uint32_t PDIS11 = (1U << 11);  ///< Pad Disable for Port n Pin 11
        constexpr uint32_t PDIS12 = (1U << 12);  ///< Pad Disable for Port n Pin 12
        constexpr uint32_t PDIS13 = (1U << 13);  ///< Pad Disable for Port n Pin 13
        constexpr uint32_t PDIS14 = (1U << 14);  ///< Pad Disable for Port n Pin 14
        constexpr uint32_t PDIS15 = (1U << 15);  ///< Pad Disable for Port n Pin 15
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPS0 = (1U << 0);  ///< Port n Pin Power Save Bit 0
        constexpr uint32_t PPS1 = (1U << 1);  ///< Port n Pin Power Save Bit 1
        constexpr uint32_t PPS2 = (1U << 2);  ///< Port n Pin Power Save Bit 2
        constexpr uint32_t PPS3 = (1U << 3);  ///< Port n Pin Power Save Bit 3
        constexpr uint32_t PPS4 = (1U << 4);  ///< Port n Pin Power Save Bit 4
        constexpr uint32_t PPS5 = (1U << 5);  ///< Port n Pin Power Save Bit 5
        constexpr uint32_t PPS6 = (1U << 6);  ///< Port n Pin Power Save Bit 6
        constexpr uint32_t PPS7 = (1U << 7);  ///< Port n Pin Power Save Bit 7
        constexpr uint32_t PPS8 = (1U << 8);  ///< Port n Pin Power Save Bit 8
        constexpr uint32_t PPS9 = (1U << 9);  ///< Port n Pin Power Save Bit 9
        constexpr uint32_t PPS10 = (1U << 10);  ///< Port n Pin Power Save Bit 10
        constexpr uint32_t PPS11 = (1U << 11);  ///< Port n Pin Power Save Bit 11
        constexpr uint32_t PPS12 = (1U << 12);  ///< Port n Pin Power Save Bit 12
        constexpr uint32_t PPS13 = (1U << 13);  ///< Port n Pin Power Save Bit 13
        constexpr uint32_t PPS14 = (1U << 14);  ///< Port n Pin Power Save Bit 14
        constexpr uint32_t PPS15 = (1U << 15);  ///< Port n Pin Power Save Bit 15
    }

    /// HWSEL Register bits
    namespace hwsel_bits {
        constexpr uint32_t HW0 = (2 << 0);  ///< Port n Pin Hardware Select Bit 0
        constexpr uint32_t HW1 = (2 << 2);  ///< Port n Pin Hardware Select Bit 1
        constexpr uint32_t HW2 = (2 << 4);  ///< Port n Pin Hardware Select Bit 2
        constexpr uint32_t HW3 = (2 << 6);  ///< Port n Pin Hardware Select Bit 3
        constexpr uint32_t HW4 = (2 << 8);  ///< Port n Pin Hardware Select Bit 4
        constexpr uint32_t HW5 = (2 << 10);  ///< Port n Pin Hardware Select Bit 5
        constexpr uint32_t HW6 = (2 << 12);  ///< Port n Pin Hardware Select Bit 6
        constexpr uint32_t HW7 = (2 << 14);  ///< Port n Pin Hardware Select Bit 7
        constexpr uint32_t HW8 = (2 << 16);  ///< Port n Pin Hardware Select Bit 8
        constexpr uint32_t HW9 = (2 << 18);  ///< Port n Pin Hardware Select Bit 9
        constexpr uint32_t HW10 = (2 << 20);  ///< Port n Pin Hardware Select Bit 10
        constexpr uint32_t HW11 = (2 << 22);  ///< Port n Pin Hardware Select Bit 11
        constexpr uint32_t HW12 = (2 << 24);  ///< Port n Pin Hardware Select Bit 12
        constexpr uint32_t HW13 = (2 << 26);  ///< Port n Pin Hardware Select Bit 13
        constexpr uint32_t HW14 = (2 << 28);  ///< Port n Pin Hardware Select Bit 14
        constexpr uint32_t HW15 = (2 << 30);  ///< Port n Pin Hardware Select Bit 15
    }

}


} // namespace alloy::generated::xmc4300

#endif // ALLOY_GENERATED_XMC4300_PERIPHERALS_HPP