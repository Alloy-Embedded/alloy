/// Auto-generated code for XMC4500
/// Generated by Alloy Code Generator
/// Source: infineon_xmc4500.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:22:07
#ifndef ALLOY_GENERATED_XMC4500_PERIPHERALS_HPP
#define ALLOY_GENERATED_XMC4500_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::xmc4500 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// PPB Peripheral
// ============================================================================

namespace ppb {
    /// Base addresses
    constexpr uint32_t PPB_BASE = 0xE000E000;

    /// PPB Register structure
    struct Registers {
        volatile uint32_t ACTLR;  ///< Offset: 0x08 - Auxiliary Control Register
        volatile uint32_t SYST_CSR;  ///< Offset: 0x10 - SysTick Control and Status Register
        volatile uint32_t SYST_RVR;  ///< Offset: 0x14 - SysTick Reload Value Register
        volatile uint32_t SYST_CVR;  ///< Offset: 0x18 - SysTick Current Value Register
        volatile uint32_t SYST_CALIB;  ///< Offset: 0x1C - SysTick Calibration Value Register r
        volatile uint32_t NVIC_ISER0;  ///< Offset: 0x100 - Interrupt Set-enable Register 0
        volatile uint32_t NVIC_ISER1;  ///< Offset: 0x104 - Interrupt Set-enable Register 1
        volatile uint32_t NVIC_ISER2;  ///< Offset: 0x108 - Interrupt Set-enable Register 2
        volatile uint32_t NVIC_ISER3;  ///< Offset: 0x10C - Interrupt Set-enable Register 3
        volatile uint32_t NVIC_ICER0;  ///< Offset: 0x180 - Interrupt Clear-enable Register 0
        volatile uint32_t NVIC_ICER1;  ///< Offset: 0x184 - Interrupt Clear-enable Register 1
        volatile uint32_t NVIC_ICER2;  ///< Offset: 0x188 - Interrupt Clear-enable Register 2
        volatile uint32_t NVIC_ICER3;  ///< Offset: 0x18C - Interrupt Clear-enable Register 3
        volatile uint32_t NVIC_ISPR0;  ///< Offset: 0x200 - Interrupt Set-pending Register 0
        volatile uint32_t NVIC_ISPR1;  ///< Offset: 0x204 - Interrupt Set-pending Register 1
        volatile uint32_t NVIC_ISPR2;  ///< Offset: 0x208 - Interrupt Set-pending Register 2
        volatile uint32_t NVIC_ISPR3;  ///< Offset: 0x20C - Interrupt Set-pending Register 3
        volatile uint32_t NVIC_ICPR0;  ///< Offset: 0x280 - Interrupt Clear-pending Register 0
        volatile uint32_t NVIC_ICPR1;  ///< Offset: 0x284 - Interrupt Clear-pending Register 1
        volatile uint32_t NVIC_ICPR2;  ///< Offset: 0x288 - Interrupt Clear-pending Register 2
        volatile uint32_t NVIC_ICPR3;  ///< Offset: 0x28C - Interrupt Clear-pending Register 3
        volatile uint32_t NVIC_IABR0;  ///< Offset: 0x300 - Interrupt Active Bit Register 0
        volatile uint32_t NVIC_IABR1;  ///< Offset: 0x304 - Interrupt Active Bit Register 1
        volatile uint32_t NVIC_IABR2;  ///< Offset: 0x308 - Interrupt Active Bit Register 2
        volatile uint32_t NVIC_IABR3;  ///< Offset: 0x30C - Interrupt Active Bit Register 3
        volatile uint32_t NVIC_IPR0;  ///< Offset: 0x400 - Interrupt Priority Register 0
        volatile uint32_t NVIC_IPR1;  ///< Offset: 0x404 - Interrupt Priority Register 1
        volatile uint32_t NVIC_IPR2;  ///< Offset: 0x408 - Interrupt Priority Register 2
        volatile uint32_t NVIC_IPR3;  ///< Offset: 0x40C - Interrupt Priority Register 3
        volatile uint32_t NVIC_IPR4;  ///< Offset: 0x410 - Interrupt Priority Register 4
        volatile uint32_t NVIC_IPR5;  ///< Offset: 0x414 - Interrupt Priority Register 5
        volatile uint32_t NVIC_IPR6;  ///< Offset: 0x418 - Interrupt Priority Register 6
        volatile uint32_t NVIC_IPR7;  ///< Offset: 0x41C - Interrupt Priority Register 7
        volatile uint32_t NVIC_IPR8;  ///< Offset: 0x420 - Interrupt Priority Register 8
        volatile uint32_t NVIC_IPR9;  ///< Offset: 0x424 - Interrupt Priority Register 9
        volatile uint32_t NVIC_IPR10;  ///< Offset: 0x428 - Interrupt Priority Register 10
        volatile uint32_t NVIC_IPR11;  ///< Offset: 0x42C - Interrupt Priority Register 11
        volatile uint32_t NVIC_IPR12;  ///< Offset: 0x430 - Interrupt Priority Register 12
        volatile uint32_t NVIC_IPR13;  ///< Offset: 0x434 - Interrupt Priority Register 13
        volatile uint32_t NVIC_IPR14;  ///< Offset: 0x438 - Interrupt Priority Register 14
        volatile uint32_t NVIC_IPR15;  ///< Offset: 0x43C - Interrupt Priority Register 15
        volatile uint32_t NVIC_IPR16;  ///< Offset: 0x440 - Interrupt Priority Register 16
        volatile uint32_t NVIC_IPR17;  ///< Offset: 0x444 - Interrupt Priority Register 17
        volatile uint32_t NVIC_IPR18;  ///< Offset: 0x448 - Interrupt Priority Register 18
        volatile uint32_t NVIC_IPR19;  ///< Offset: 0x44C - Interrupt Priority Register 19
        volatile uint32_t NVIC_IPR20;  ///< Offset: 0x450 - Interrupt Priority Register 20
        volatile uint32_t NVIC_IPR21;  ///< Offset: 0x454 - Interrupt Priority Register 21
        volatile uint32_t NVIC_IPR22;  ///< Offset: 0x458 - Interrupt Priority Register 22
        volatile uint32_t NVIC_IPR23;  ///< Offset: 0x45C - Interrupt Priority Register 23
        volatile uint32_t NVIC_IPR24;  ///< Offset: 0x460 - Interrupt Priority Register 24
        volatile uint32_t NVIC_IPR25;  ///< Offset: 0x464 - Interrupt Priority Register 25
        volatile uint32_t NVIC_IPR26;  ///< Offset: 0x468 - Interrupt Priority Register 26
        volatile uint32_t NVIC_IPR27;  ///< Offset: 0x46C - Interrupt Priority Register 27
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control and State Register
        volatile uint32_t VTOR;  ///< Offset: 0xD08 - Vector Table Offset Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt and Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration and Control Register
        volatile uint32_t SHPR1;  ///< Offset: 0xD18 - System Handler Priority Register 1
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
        volatile uint32_t CFSR;  ///< Offset: 0xD28 - Configurable Fault Status Register
        volatile uint32_t HFSR;  ///< Offset: 0xD2C - HardFault Status Register
        volatile uint32_t MMFAR;  ///< Offset: 0xD34 - MemManage Fault Address Register
        volatile uint32_t BFAR;  ///< Offset: 0xD38 - BusFault Address Register
        volatile uint32_t AFSR;  ///< Offset: 0xD3C - Auxiliary Fault Status Register
        volatile uint32_t CPACR;  ///< Offset: 0xD88 - Coprocessor Access Control Register
        volatile uint32_t MPU_TYPE;  ///< Offset: 0xD90 - MPU Type Register
        volatile uint32_t MPU_CTRL;  ///< Offset: 0xD94 - MPU Control Register
        volatile uint32_t MPU_RNR;  ///< Offset: 0xD98 - MPU Region Number Register
        volatile uint32_t MPU_RBAR;  ///< Offset: 0xD9C - MPU Region Base Address Register
        volatile uint32_t MPU_RASR;  ///< Offset: 0xDA0 - MPU Region Attribute and Size Register
        volatile uint32_t MPU_RBAR_A1;  ///< Offset: 0xDA4 - MPU Region Base Address Register A1
        volatile uint32_t MPU_RASR_A1;  ///< Offset: 0xDA8 - MPU Region Attribute and Size Register A1
        volatile uint32_t MPU_RBAR_A2;  ///< Offset: 0xDAC - MPU Region Base Address Register A2
        volatile uint32_t MPU_RASR_A2;  ///< Offset: 0xDB0 - MPU Region Attribute and Size Register A2
        volatile uint32_t MPU_RBAR_A3;  ///< Offset: 0xDB4 - MPU Region Base Address Register A3
        volatile uint32_t MPU_RASR_A3;  ///< Offset: 0xDB8 - MPU Region Attribute and Size Register A3
        volatile uint32_t STIR;  ///< Offset: 0xF00 - Software Trigger Interrupt Register
        volatile uint32_t FPCCR;  ///< Offset: 0xF34 - Floating-point Context Control Register
        volatile uint32_t FPCAR;  ///< Offset: 0xF38 - Floating-point Context Address Register
        volatile uint32_t FPDSCR;  ///< Offset: 0xF3C - Floating-point Default Status Control Register
    };

    /// Peripheral instances
    inline Registers* PPB = reinterpret_cast<Registers*>(PPB_BASE);

    // Bit definitions
    /// ACTLR Register bits
    namespace actlr_bits {
        constexpr uint32_t DISMCYCINT = (1U << 0);  ///< Disable load/store multiple
        constexpr uint32_t DISDEFWBUF = (1U << 1);  ///< Disable write buffer
        constexpr uint32_t DISFOLD = (1U << 2);  ///< Disable IT folding
        constexpr uint32_t DISFPCA = (1U << 8);  ///< Disable FPCA update
        constexpr uint32_t DISOOFP = (1U << 9);  ///< Disable out of order FP execution
    }

    /// SYST_CSR Register bits
    namespace syst_csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable
        constexpr uint32_t TICKINT = (1U << 1);  ///< Tick Interrupt Enable
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< Indicates the clock source:
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< Counter Flag
    }

    /// SYST_RVR Register bits
    namespace syst_rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Reload Value
    }

    /// SYST_CVR Register bits
    namespace syst_cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current Value
    }

    /// SYST_CALIB Register bits
    namespace syst_calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Ten Milliseconds Reload Value
        constexpr uint32_t SKEW = (1U << 30);  ///< Ten Milliseconds Skewed
        constexpr uint32_t NOREF = (1U << 31);  ///< No Reference Clock
    }

    /// NVIC_ISER0 Register bits
    namespace nvic_iser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set-enable bits
    }

    /// NVIC_ISER1 Register bits
    namespace nvic_iser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set-enable bits
    }

    /// NVIC_ISER2 Register bits
    namespace nvic_iser2_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set-enable bits
    }

    /// NVIC_ISER3 Register bits
    namespace nvic_iser3_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set-enable bits
    }

    /// NVIC_ICER0 Register bits
    namespace nvic_icer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits.
    }

    /// NVIC_ICER1 Register bits
    namespace nvic_icer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits.
    }

    /// NVIC_ICER2 Register bits
    namespace nvic_icer2_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits.
    }

    /// NVIC_ICER3 Register bits
    namespace nvic_icer3_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits.
    }

    /// NVIC_ISPR0 Register bits
    namespace nvic_ispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ISPR1 Register bits
    namespace nvic_ispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ISPR2 Register bits
    namespace nvic_ispr2_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ISPR3 Register bits
    namespace nvic_ispr3_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ICPR0 Register bits
    namespace nvic_icpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ICPR1 Register bits
    namespace nvic_icpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ICPR2 Register bits
    namespace nvic_icpr2_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_ICPR3 Register bits
    namespace nvic_icpr3_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt set-pending bits.
    }

    /// NVIC_IABR0 Register bits
    namespace nvic_iabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags:
    }

    /// NVIC_IABR1 Register bits
    namespace nvic_iabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags:
    }

    /// NVIC_IABR2 Register bits
    namespace nvic_iabr2_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags:
    }

    /// NVIC_IABR3 Register bits
    namespace nvic_iabr3_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags:
    }

    /// NVIC_IPR0 Register bits
    namespace nvic_ipr0_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR1 Register bits
    namespace nvic_ipr1_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR2 Register bits
    namespace nvic_ipr2_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR3 Register bits
    namespace nvic_ipr3_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR4 Register bits
    namespace nvic_ipr4_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR5 Register bits
    namespace nvic_ipr5_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR6 Register bits
    namespace nvic_ipr6_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR7 Register bits
    namespace nvic_ipr7_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR8 Register bits
    namespace nvic_ipr8_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR9 Register bits
    namespace nvic_ipr9_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR10 Register bits
    namespace nvic_ipr10_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR11 Register bits
    namespace nvic_ipr11_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR12 Register bits
    namespace nvic_ipr12_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR13 Register bits
    namespace nvic_ipr13_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR14 Register bits
    namespace nvic_ipr14_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR15 Register bits
    namespace nvic_ipr15_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR16 Register bits
    namespace nvic_ipr16_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR17 Register bits
    namespace nvic_ipr17_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR18 Register bits
    namespace nvic_ipr18_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR19 Register bits
    namespace nvic_ipr19_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR20 Register bits
    namespace nvic_ipr20_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR21 Register bits
    namespace nvic_ipr21_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR22 Register bits
    namespace nvic_ipr22_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR23 Register bits
    namespace nvic_ipr23_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR24 Register bits
    namespace nvic_ipr24_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR25 Register bits
    namespace nvic_ipr25_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR26 Register bits
    namespace nvic_ipr26_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// NVIC_IPR27 Register bits
    namespace nvic_ipr27_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority value 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority value 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority value 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority value 3
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t Revision = (4 << 0);  ///< Revision number
        constexpr uint32_t PartNo = (12 << 4);  ///< Part number of the processor
        constexpr uint32_t Constant = (4 << 16);  ///< Reads as 0xF
        constexpr uint32_t Variant = (4 << 20);  ///< Variant number
        constexpr uint32_t Implementer = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active exception number
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< Return to Base
        constexpr uint32_t VECTPENDING = (6 << 12);  ///< Vector Pending
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick exception clear-pending bit
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick exception set-pending bit
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV clear-pending bit
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV set-pending bit: 0b0=no effect, 0b1=changes PendSV exception state to pending., 0b0=PendSV exception is not pending, 0b1=PendSV exception is pending.,
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI set-pending bit: 0b0=no effect, 0b1=changes NMI exception state to pending., 0b0=NMI exception is not pending, 0b1=NMI exception is pending.,
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (22 << 10);  ///< Vector table base offset field
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTRESET = (1U << 0);  ///< Reserved for Debug use.
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< Reserved for Debug use.
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< System reset request
        constexpr uint32_t PRIGROUP = (3 << 8);  ///< Interrupt priority grouping field
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< Data endianness bit
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< Sleep on Exit
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< Sleep or Deep Sleep
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< Send Event on Pending bit:
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< Non Base Thread Mode Enable
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< User Set Pending Enable
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Unaligned Access Trap Enable
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< Divide by Zero Trap Enable
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< Bus Fault Hard Fault and NMI Ignore
        constexpr uint32_t STKALIGN = (1U << 9);  ///< Stack Alignment
    }

    /// SHPR1 Register bits
    namespace shpr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of system handler 4, MemManage
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of system handler 5, BusFault
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of system handler 6, UsageFault
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11, SVCall
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t MEMFAULTACT = (1U << 0);  ///< MemManage exception active bit
        constexpr uint32_t BUSFAULTACT = (1U << 1);  ///< BusFault exception active bit
        constexpr uint32_t USGFAULTACT = (1U << 3);  ///< UsageFault exception active bit
        constexpr uint32_t SVCALLACT = (1U << 7);  ///< SVCall active bit
        constexpr uint32_t MONITORACT = (1U << 8);  ///< Debug monitor active bit
        constexpr uint32_t PENDSVACT = (1U << 10);  ///< PendSV exception active bit
        constexpr uint32_t SYSTICKACT = (1U << 11);  ///< SysTick exception active bit
        constexpr uint32_t USGFAULTPENDED = (1U << 12);  ///< UsageFault exception pending bit
        constexpr uint32_t MEMFAULTPENDED = (1U << 13);  ///< MemManage exception pending bit
        constexpr uint32_t BUSFAULTPENDED = (1U << 14);  ///< BusFault exception pending bit
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVCall pending bit
        constexpr uint32_t MEMFAULTENA = (1U << 16);  ///< MemManage enable bit
        constexpr uint32_t BUSFAULTENA = (1U << 17);  ///< BusFault enable bit
        constexpr uint32_t USGFAULTENA = (1U << 18);  ///< UsageFault enable bit
    }

    /// CFSR Register bits
    namespace cfsr_bits {
        constexpr uint32_t IACCVIOL = (1U << 0);  ///< Instruction access violation flag
        constexpr uint32_t DACCVIOL = (1U << 1);  ///< Data access violation flag
        constexpr uint32_t MUNSTKERR = (1U << 3);  ///< MemManage fault on unstacking for a return from exception
        constexpr uint32_t MSTKERR = (1U << 4);  ///< MemManage fault on stacking for exception entry
        constexpr uint32_t MLSPERR = (1U << 5);  ///< MemManage fault during floating point lazy state preservation
        constexpr uint32_t MMARVALID = (1U << 7);  ///< MemManage Fault Address Register (MMFAR) valid flag
        constexpr uint32_t IBUSERR = (1U << 8);  ///< Instruction bus error
        constexpr uint32_t PRECISERR = (1U << 9);  ///< Precise data bus error
        constexpr uint32_t IMPRECISERR = (1U << 10);  ///< Imprecise data bus error
        constexpr uint32_t UNSTKERR = (1U << 11);  ///< BusFault on unstacking for a return from exception
        constexpr uint32_t STKERR = (1U << 12);  ///< BusFault on stacking for exception entry
        constexpr uint32_t LSPERR = (1U << 13);  ///< BusFault during floating point lazy state preservation
        constexpr uint32_t BFARVALID = (1U << 15);  ///< BusFault Address Register (BFAR) valid flag
        constexpr uint32_t UNDEFINSTR = (1U << 16);  ///< Undefined instruction UsageFault
        constexpr uint32_t INVSTATE = (1U << 17);  ///< Invalid state UsageFault
        constexpr uint32_t INVPC = (1U << 18);  ///< Invalid PC load UsageFault
        constexpr uint32_t NOCP = (1U << 19);  ///< No coprocessor UsageFault
        constexpr uint32_t UNALIGNED = (1U << 24);  ///< Unaligned access UsageFault
        constexpr uint32_t DIVBYZERO = (1U << 25);  ///< Divide by zero UsageFault
    }

    /// HFSR Register bits
    namespace hfsr_bits {
        constexpr uint32_t VECTTBL = (1U << 1);  ///< BusFault on vector table read
        constexpr uint32_t FORCED = (1U << 30);  ///< Forced HardFault
        constexpr uint32_t DEBUGEVT = (1U << 31);  ///< Reserved for Debug use
    }

    /// MMFAR Register bits
    namespace mmfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address causing the fault
    }

    /// BFAR Register bits
    namespace bfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address causing the fault
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t VALUE = (32 << 0);  ///< Reserved
    }

    /// CPACR Register bits
    namespace cpacr_bits {
        constexpr uint32_t CP10 = (2 << 20);  ///< Access privileges for coprocessor 10
        constexpr uint32_t CP11 = (2 << 22);  ///< Access privileges for coprocessor 11
    }

    /// MPU_TYPE Register bits
    namespace mpu_type_bits {
        constexpr uint32_t SEPARATE = (1U << 0);  ///< Support for unified or separate instruction and date memory maps
        constexpr uint32_t DREGION = (8 << 8);  ///< Number of supported MPU data regions
        constexpr uint32_t IREGION = (8 << 16);  ///< Number of supported MPU instruction regions
    }

    /// MPU_CTRL Register bits
    namespace mpu_ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable MPU
        constexpr uint32_t HFNMIENA = (1U << 1);  ///< Enable the operation of MPU during hard fault, NMI, and FAULTMASK handlers
        constexpr uint32_t PRIVDEFENA = (1U << 2);  ///< Enables privileged software access to the default memory map
    }

    /// MPU_RNR Register bits
    namespace mpu_rnr_bits {
        constexpr uint32_t REGION = (8 << 0);  ///< Region
    }

    /// MPU_RBAR Register bits
    namespace mpu_rbar_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU Region Number valid bit
        constexpr uint32_t ADDR = (23 << 9);  ///< Region base address field
    }

    /// MPU_RASR Register bits
    namespace mpu_rasr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< MPU protection region size
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< Memory access attribute
        constexpr uint32_t C = (1U << 17);  ///< Memory access attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable bit
        constexpr uint32_t TEX = (3 << 19);  ///< Memory access attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission field
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

    /// MPU_RBAR_A1 Register bits
    namespace mpu_rbar_a1_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU Region Number valid bit
        constexpr uint32_t ADDR = (23 << 9);  ///< Region base address field
    }

    /// MPU_RASR_A1 Register bits
    namespace mpu_rasr_a1_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< MPU protection region size
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< Memory access attribute
        constexpr uint32_t C = (1U << 17);  ///< Memory access attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable bit
        constexpr uint32_t TEX = (3 << 19);  ///< Memory access attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission field
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

    /// MPU_RBAR_A2 Register bits
    namespace mpu_rbar_a2_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU Region Number valid bit
        constexpr uint32_t ADDR = (23 << 9);  ///< Region base address field
    }

    /// MPU_RASR_A2 Register bits
    namespace mpu_rasr_a2_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< MPU protection region size
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< Memory access attribute
        constexpr uint32_t C = (1U << 17);  ///< Memory access attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable bit
        constexpr uint32_t TEX = (3 << 19);  ///< Memory access attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission field
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

    /// MPU_RBAR_A3 Register bits
    namespace mpu_rbar_a3_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU Region Number valid bit
        constexpr uint32_t ADDR = (23 << 9);  ///< Region base address field
    }

    /// MPU_RASR_A3 Register bits
    namespace mpu_rasr_a3_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< MPU protection region size
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< Memory access attribute
        constexpr uint32_t C = (1U << 17);  ///< Memory access attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable bit
        constexpr uint32_t TEX = (3 << 19);  ///< Memory access attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission field
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

    /// STIR Register bits
    namespace stir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< Interrupt ID of the interrupt to trigger
    }

    /// FPCCR Register bits
    namespace fpccr_bits {
        constexpr uint32_t LSPACT = (1U << 0);  ///< Lazy State Preservation Active
        constexpr uint32_t USER = (1U << 1);  ///< User allocated Stack Frame
        constexpr uint32_t THREAD = (1U << 3);  ///< Thread Mode allocated Stack Frame
        constexpr uint32_t HFRDY = (1U << 4);  ///< HardFault Ready
        constexpr uint32_t MMRDY = (1U << 5);  ///< MemManage Ready
        constexpr uint32_t BFRDY = (1U << 6);  ///< BusFault Ready
        constexpr uint32_t MONRDY = (1U << 8);  ///< Monitor Ready
        constexpr uint32_t LSPEN = (1U << 30);  ///< Lazy State Preservation Enabled
        constexpr uint32_t ASPEN = (1U << 31);  ///< Automatic State Preservation
    }

    /// FPCAR Register bits
    namespace fpcar_bits {
        constexpr uint32_t ADDRESS = (29 << 3);  ///< Address
    }

    /// FPDSCR Register bits
    namespace fpdscr_bits {
        constexpr uint32_t RMode = (2 << 22);  ///< Default value for FPSCR.RMode
        constexpr uint32_t FZ = (1U << 24);  ///< Default value for FPSCR.FZ
        constexpr uint32_t DN = (1U << 25);  ///< Default value for FPSCR.DN
        constexpr uint32_t AHP = (1U << 26);  ///< Default value for FPSCR.AHP
    }

}

// ============================================================================
// DLR Peripheral
// ============================================================================

namespace dlr {
    /// Base addresses
    constexpr uint32_t DLR_BASE = 0x50004900;

    /// DLR Register structure
    struct Registers {
        volatile uint32_t OVRSTAT;  ///< Offset: 0x00 - Overrun Status
        volatile uint32_t OVRCLR;  ///< Offset: 0x04 - Overrun Clear
        volatile uint32_t SRSEL0;  ///< Offset: 0x08 - Service Request Selection 0
        volatile uint32_t SRSEL1;  ///< Offset: 0x0C - Service Request Selection 1
        volatile uint32_t LNEN;  ///< Offset: 0x10 - Line Enable
    };

    /// Peripheral instances
    inline Registers* DLR = reinterpret_cast<Registers*>(DLR_BASE);

    // Bit definitions
    /// OVRSTAT Register bits
    namespace ovrstat_bits {
        constexpr uint32_t LN0 = (1U << 0);  ///< Line 0 Overrun Status
        constexpr uint32_t LN1 = (1U << 1);  ///< Line 1 Overrun Status
        constexpr uint32_t LN2 = (1U << 2);  ///< Line 2 Overrun Status
        constexpr uint32_t LN3 = (1U << 3);  ///< Line 3 Overrun Status
        constexpr uint32_t LN4 = (1U << 4);  ///< Line 4 Overrun Status
        constexpr uint32_t LN5 = (1U << 5);  ///< Line 5 Overrun Status
        constexpr uint32_t LN6 = (1U << 6);  ///< Line 6 Overrun Status
        constexpr uint32_t LN7 = (1U << 7);  ///< Line 7 Overrun Status
        constexpr uint32_t LN8 = (1U << 8);  ///< Line 8 Overrun Status
        constexpr uint32_t LN9 = (1U << 9);  ///< Line 9 Overrun Status
        constexpr uint32_t LN10 = (1U << 10);  ///< Line 10 Overrun Status
        constexpr uint32_t LN11 = (1U << 11);  ///< Line 11 Overrun Status
    }

    /// OVRCLR Register bits
    namespace ovrclr_bits {
        constexpr uint32_t LN0 = (1U << 0);  ///< Line 0 Overrun Status Clear
        constexpr uint32_t LN1 = (1U << 1);  ///< Line 1 Overrun Status Clear
        constexpr uint32_t LN2 = (1U << 2);  ///< Line 2 Overrun Status Clear
        constexpr uint32_t LN3 = (1U << 3);  ///< Line 3 Overrun Status Clear
        constexpr uint32_t LN4 = (1U << 4);  ///< Line 4 Overrun Status Clear
        constexpr uint32_t LN5 = (1U << 5);  ///< Line 5 Overrun Status Clear
        constexpr uint32_t LN6 = (1U << 6);  ///< Line 6 Overrun Status Clear
        constexpr uint32_t LN7 = (1U << 7);  ///< Line 7 Overrun Status Clear
        constexpr uint32_t LN8 = (1U << 8);  ///< Line 8 Overrun Status Clear
        constexpr uint32_t LN9 = (1U << 9);  ///< Line 9 Overrun Status Clear
        constexpr uint32_t LN10 = (1U << 10);  ///< Line 10 Overrun Status Clear
        constexpr uint32_t LN11 = (1U << 11);  ///< Line 11 Overrun Status Clear
    }

    /// SRSEL0 Register bits
    namespace srsel0_bits {
        constexpr uint32_t RS0 = (4 << 0);  ///< Request Source for Line 0
        constexpr uint32_t RS1 = (4 << 4);  ///< Request Source for Line 1
        constexpr uint32_t RS2 = (4 << 8);  ///< Request Source for Line 2
        constexpr uint32_t RS3 = (4 << 12);  ///< Request Source for Line 3
        constexpr uint32_t RS4 = (4 << 16);  ///< Request Source for Line 4
        constexpr uint32_t RS5 = (4 << 20);  ///< Request Source for Line 5
        constexpr uint32_t RS6 = (4 << 24);  ///< Request Source for Line 6
        constexpr uint32_t RS7 = (4 << 28);  ///< Request Source for Line 7
    }

    /// SRSEL1 Register bits
    namespace srsel1_bits {
        constexpr uint32_t RS8 = (4 << 0);  ///< Request Source for Line 8
        constexpr uint32_t RS9 = (4 << 4);  ///< Request Source for Line 9
        constexpr uint32_t RS10 = (4 << 8);  ///< Request Source for Line 10
        constexpr uint32_t RS11 = (4 << 12);  ///< Request Source for Line 11
    }

    /// LNEN Register bits
    namespace lnen_bits {
        constexpr uint32_t LN0 = (1U << 0);  ///< Line 0 Enable
        constexpr uint32_t LN1 = (1U << 1);  ///< Line 1 Enable
        constexpr uint32_t LN2 = (1U << 2);  ///< Line 2 Enable
        constexpr uint32_t LN3 = (1U << 3);  ///< Line 3 Enable
        constexpr uint32_t LN4 = (1U << 4);  ///< Line 4 Enable
        constexpr uint32_t LN5 = (1U << 5);  ///< Line 5 Enable
        constexpr uint32_t LN6 = (1U << 6);  ///< Line 6 Enable
        constexpr uint32_t LN7 = (1U << 7);  ///< Line 7 Enable
        constexpr uint32_t LN8 = (1U << 8);  ///< Line 8 Enable
        constexpr uint32_t LN9 = (1U << 9);  ///< Line 9 Enable
        constexpr uint32_t LN10 = (1U << 10);  ///< Line 10 Enable
        constexpr uint32_t LN11 = (1U << 11);  ///< Line 11 Enable
    }

}

// ============================================================================
// ERU0 Peripheral
// ============================================================================

namespace eru0 {
    /// Base addresses
    constexpr uint32_t ERU0_BASE = 0x50004800;

    /// ERU0 Register structure
    struct Registers {
        volatile uint32_t EXISEL;  ///< Offset: 0x00 - Event Input Select
        volatile uint32_t EXICON[%s];  ///< Offset: 0x10 - Event Input Control
        volatile uint32_t EXOCON[%s];  ///< Offset: 0x20 - Event Output Trigger Control
    };

    /// Peripheral instances
    inline Registers* ERU0 = reinterpret_cast<Registers*>(ERU0_BASE);

    // Bit definitions
    /// EXISEL Register bits
    namespace exisel_bits {
        constexpr uint32_t EXS0A = (2 << 0);  ///< Event Source Select for A0 (ERS0)
        constexpr uint32_t EXS0B = (2 << 2);  ///< Event Source Select for B0 (ERS0)
        constexpr uint32_t EXS1A = (2 << 4);  ///< Event Source Select for A1 (ERS1)
        constexpr uint32_t EXS1B = (2 << 6);  ///< Event Source Select for B1 (ERS1)
        constexpr uint32_t EXS2A = (2 << 8);  ///< Event Source Select for A2 (ERS2)
        constexpr uint32_t EXS2B = (2 << 10);  ///< Event Source Select for B2 (ERS2)
        constexpr uint32_t EXS3A = (2 << 12);  ///< Event Source Select for A3 (ERS3)
        constexpr uint32_t EXS3B = (2 << 14);  ///< Event Source Select for B3 (ERS3)
    }

    /// EXICON[%s] Register bits
    namespace exicon[%s]_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Output Trigger Pulse Enable for ETLx
        constexpr uint32_t LD = (1U << 1);  ///< Rebuild Level Detection for Status Flag for ETLx
        constexpr uint32_t RE = (1U << 2);  ///< Rising Edge Detection Enable ETLx
        constexpr uint32_t FE = (1U << 3);  ///< Falling Edge Detection Enable ETLx
        constexpr uint32_t OCS = (3 << 4);  ///< Output Channel Select for ETLx Output Trigger Pulse
        constexpr uint32_t FL = (1U << 7);  ///< Status Flag for ETLx
        constexpr uint32_t SS = (2 << 8);  ///< Input Source Select for ERSx
        constexpr uint32_t NA = (1U << 10);  ///< Input A Negation Select for ERSx
        constexpr uint32_t NB = (1U << 11);  ///< Input B Negation Select for ERSx
    }

    /// EXOCON[%s] Register bits
    namespace exocon[%s]_bits {
        constexpr uint32_t ISS = (2 << 0);  ///< Internal Trigger Source Selection
        constexpr uint32_t GEEN = (1U << 2);  ///< Gating Event Enable
        constexpr uint32_t PDR = (1U << 3);  ///< Pattern Detection Result Flag
        constexpr uint32_t GP = (2 << 4);  ///< Gating Selection for Pattern Detection Result
        constexpr uint32_t IPEN0 = (1U << 12);  ///< Pattern Detection Enable for ETL0
        constexpr uint32_t IPEN1 = (1U << 13);  ///< Pattern Detection Enable for ETL1
        constexpr uint32_t IPEN2 = (1U << 14);  ///< Pattern Detection Enable for ETL2
        constexpr uint32_t IPEN3 = (1U << 15);  ///< Pattern Detection Enable for ETL3
    }

}

// ============================================================================
// ERU1 Peripheral
// ============================================================================

namespace eru1 {
    /// Base addresses
    constexpr uint32_t ERU1_BASE = 0x40044000;

    /// ERU1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ERU1 = reinterpret_cast<Registers*>(ERU1_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t GPDMA0_BASE = 0x500142C0;
    constexpr uint32_t GPDMA0_CH0_BASE = 0x50014000;
    constexpr uint32_t GPDMA0_CH1_BASE = 0x50014058;
    constexpr uint32_t GPDMA0_CH2_BASE = 0x500140B0;
    constexpr uint32_t GPDMA0_CH3_BASE = 0x50014108;
    constexpr uint32_t GPDMA0_CH4_BASE = 0x50014160;
    constexpr uint32_t GPDMA0_CH5_BASE = 0x500141B8;
    constexpr uint32_t GPDMA0_CH6_BASE = 0x50014210;
    constexpr uint32_t GPDMA0_CH7_BASE = 0x50014268;
    constexpr uint32_t GPDMA1_BASE = 0x500182C0;
    constexpr uint32_t GPDMA1_CH0_BASE = 0x50018000;
    constexpr uint32_t GPDMA1_CH1_BASE = 0x50018058;
    constexpr uint32_t GPDMA1_CH2_BASE = 0x500180B0;
    constexpr uint32_t GPDMA1_CH3_BASE = 0x50018108;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t RAWTFR;  ///< Offset: 0x00 - Raw IntTfr Status
        volatile uint32_t RAWBLOCK;  ///< Offset: 0x08 - Raw IntBlock Status
        volatile uint32_t RAWSRCTRAN;  ///< Offset: 0x10 - Raw IntSrcTran Status
        volatile uint32_t RAWDSTTRAN;  ///< Offset: 0x18 - Raw IntBlock Status
        volatile uint32_t RAWERR;  ///< Offset: 0x20 - Raw IntErr Status
        volatile uint32_t STATUSTFR;  ///< Offset: 0x28 - IntTfr Status
        volatile uint32_t STATUSBLOCK;  ///< Offset: 0x30 - IntBlock Status
        volatile uint32_t STATUSSRCTRAN;  ///< Offset: 0x38 - IntSrcTran Status
        volatile uint32_t STATUSDSTTRAN;  ///< Offset: 0x40 - IntBlock Status
        volatile uint32_t STATUSERR;  ///< Offset: 0x48 - IntErr Status
        volatile uint32_t MASKTFR;  ///< Offset: 0x50 - Mask for Raw IntTfr Status
        volatile uint32_t MASKBLOCK;  ///< Offset: 0x58 - Mask for Raw IntBlock Status
        volatile uint32_t MASKSRCTRAN;  ///< Offset: 0x60 - Mask for Raw IntSrcTran Status
        volatile uint32_t MASKDSTTRAN;  ///< Offset: 0x68 - Mask for Raw IntBlock Status
        volatile uint32_t MASKERR;  ///< Offset: 0x70 - Mask for Raw IntErr Status
        volatile uint32_t CLEARTFR;  ///< Offset: 0x78 - IntTfr Status
        volatile uint32_t CLEARBLOCK;  ///< Offset: 0x80 - IntBlock Status
        volatile uint32_t CLEARSRCTRAN;  ///< Offset: 0x88 - IntSrcTran Status
        volatile uint32_t CLEARDSTTRAN;  ///< Offset: 0x90 - IntBlock Status
        volatile uint32_t CLEARERR;  ///< Offset: 0x98 - IntErr Status
        volatile uint32_t STATUSINT;  ///< Offset: 0xA0 - Combined Interrupt Status Register
        volatile uint32_t REQSRCREG;  ///< Offset: 0xA8 - Source Software Transaction Request Register
        volatile uint32_t REQDSTREG;  ///< Offset: 0xB0 - Destination Software Transaction Request Register
        volatile uint32_t SGLREQSRCREG;  ///< Offset: 0xB8 - Single Source Transaction Request Register
        volatile uint32_t SGLREQDSTREG;  ///< Offset: 0xC0 - Single Destination Transaction Request Register
        volatile uint32_t LSTSRCREG;  ///< Offset: 0xC8 - Last Source Transaction Request Register
        volatile uint32_t LSTDSTREG;  ///< Offset: 0xD0 - Last Destination Transaction Request Register
        volatile uint32_t DMACFGREG;  ///< Offset: 0xD8 - GPDMA Configuration Register
        volatile uint32_t CHENREG;  ///< Offset: 0xE0 - GPDMA Channel Enable Register
        volatile uint32_t ID;  ///< Offset: 0xE8 - GPDMA0 ID Register
        volatile uint32_t TYPE;  ///< Offset: 0x138 - GPDMA Component Type
        volatile uint32_t VERSION;  ///< Offset: 0x13C - DMA Component Version
    };

    /// Peripheral instances
    inline Registers* GPDMA0 = reinterpret_cast<Registers*>(GPDMA0_BASE);
    inline Registers* GPDMA0_CH0 = reinterpret_cast<Registers*>(GPDMA0_CH0_BASE);
    inline Registers* GPDMA0_CH1 = reinterpret_cast<Registers*>(GPDMA0_CH1_BASE);
    inline Registers* GPDMA0_CH2 = reinterpret_cast<Registers*>(GPDMA0_CH2_BASE);
    inline Registers* GPDMA0_CH3 = reinterpret_cast<Registers*>(GPDMA0_CH3_BASE);
    inline Registers* GPDMA0_CH4 = reinterpret_cast<Registers*>(GPDMA0_CH4_BASE);
    inline Registers* GPDMA0_CH5 = reinterpret_cast<Registers*>(GPDMA0_CH5_BASE);
    inline Registers* GPDMA0_CH6 = reinterpret_cast<Registers*>(GPDMA0_CH6_BASE);
    inline Registers* GPDMA0_CH7 = reinterpret_cast<Registers*>(GPDMA0_CH7_BASE);
    inline Registers* GPDMA1 = reinterpret_cast<Registers*>(GPDMA1_BASE);
    inline Registers* GPDMA1_CH0 = reinterpret_cast<Registers*>(GPDMA1_CH0_BASE);
    inline Registers* GPDMA1_CH1 = reinterpret_cast<Registers*>(GPDMA1_CH1_BASE);
    inline Registers* GPDMA1_CH2 = reinterpret_cast<Registers*>(GPDMA1_CH2_BASE);
    inline Registers* GPDMA1_CH3 = reinterpret_cast<Registers*>(GPDMA1_CH3_BASE);

    // Bit definitions
    /// RAWTFR Register bits
    namespace rawtfr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Raw Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Raw Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Raw Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Raw Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Raw Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Raw Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Raw Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Raw Interrupt Status for channel 7
    }

    /// RAWBLOCK Register bits
    namespace rawblock_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Raw Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Raw Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Raw Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Raw Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Raw Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Raw Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Raw Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Raw Interrupt Status for channel 7
    }

    /// RAWSRCTRAN Register bits
    namespace rawsrctran_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Raw Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Raw Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Raw Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Raw Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Raw Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Raw Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Raw Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Raw Interrupt Status for channel 7
    }

    /// RAWDSTTRAN Register bits
    namespace rawdsttran_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Raw Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Raw Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Raw Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Raw Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Raw Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Raw Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Raw Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Raw Interrupt Status for channel 7
    }

    /// RAWERR Register bits
    namespace rawerr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Raw Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Raw Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Raw Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Raw Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Raw Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Raw Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Raw Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Raw Interrupt Status for channel 7
    }

    /// STATUSTFR Register bits
    namespace statustfr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Interrupt Status for channel 7
    }

    /// STATUSBLOCK Register bits
    namespace statusblock_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Interrupt Status for channel 7
    }

    /// STATUSSRCTRAN Register bits
    namespace statussrctran_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Interrupt Status for channel 7
    }

    /// STATUSDSTTRAN Register bits
    namespace statusdsttran_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Interrupt Status for channel 7
    }

    /// STATUSERR Register bits
    namespace statuserr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Interrupt Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Interrupt Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Interrupt Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Interrupt Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Interrupt Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Interrupt Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Interrupt Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Interrupt Status for channel 7
    }

    /// MASKTFR Register bits
    namespace masktfr_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Write enable for mask bit of channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Write enable for mask bit of channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Write enable for mask bit of channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Write enable for mask bit of channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Write enable for mask bit of channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Write enable for mask bit of channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Write enable for mask bit of channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Write enable for mask bit of channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Mask bit for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Mask bit for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Mask bit for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Mask bit for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Mask bit for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Mask bit for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Mask bit for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Mask bit for channel 7
    }

    /// MASKBLOCK Register bits
    namespace maskblock_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Write enable for mask bit of channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Write enable for mask bit of channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Write enable for mask bit of channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Write enable for mask bit of channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Write enable for mask bit of channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Write enable for mask bit of channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Write enable for mask bit of channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Write enable for mask bit of channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Mask bit for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Mask bit for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Mask bit for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Mask bit for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Mask bit for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Mask bit for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Mask bit for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Mask bit for channel 7
    }

    /// MASKSRCTRAN Register bits
    namespace masksrctran_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Write enable for mask bit of channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Write enable for mask bit of channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Write enable for mask bit of channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Write enable for mask bit of channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Write enable for mask bit of channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Write enable for mask bit of channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Write enable for mask bit of channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Write enable for mask bit of channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Mask bit for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Mask bit for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Mask bit for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Mask bit for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Mask bit for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Mask bit for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Mask bit for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Mask bit for channel 7
    }

    /// MASKDSTTRAN Register bits
    namespace maskdsttran_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Write enable for mask bit of channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Write enable for mask bit of channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Write enable for mask bit of channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Write enable for mask bit of channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Write enable for mask bit of channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Write enable for mask bit of channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Write enable for mask bit of channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Write enable for mask bit of channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Mask bit for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Mask bit for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Mask bit for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Mask bit for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Mask bit for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Mask bit for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Mask bit for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Mask bit for channel 7
    }

    /// MASKERR Register bits
    namespace maskerr_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Write enable for mask bit of channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Write enable for mask bit of channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Write enable for mask bit of channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Write enable for mask bit of channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Write enable for mask bit of channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Write enable for mask bit of channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Write enable for mask bit of channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Write enable for mask bit of channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Mask bit for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Mask bit for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Mask bit for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Mask bit for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Mask bit for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Mask bit for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Mask bit for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Mask bit for channel 7
    }

    /// CLEARTFR Register bits
    namespace cleartfr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Clear Interrupt Status and Raw Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Clear Interrupt Status and Raw Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Clear Interrupt Status and Raw Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Clear Interrupt Status and Raw Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Clear Interrupt Status and Raw Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Clear Interrupt Status and Raw Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Clear Interrupt Status and Raw Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Clear Interrupt Status and Raw Status for channel 7
    }

    /// CLEARBLOCK Register bits
    namespace clearblock_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Clear Interrupt Status and Raw Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Clear Interrupt Status and Raw Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Clear Interrupt Status and Raw Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Clear Interrupt Status and Raw Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Clear Interrupt Status and Raw Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Clear Interrupt Status and Raw Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Clear Interrupt Status and Raw Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Clear Interrupt Status and Raw Status for channel 7
    }

    /// CLEARSRCTRAN Register bits
    namespace clearsrctran_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Clear Interrupt Status and Raw Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Clear Interrupt Status and Raw Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Clear Interrupt Status and Raw Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Clear Interrupt Status and Raw Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Clear Interrupt Status and Raw Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Clear Interrupt Status and Raw Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Clear Interrupt Status and Raw Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Clear Interrupt Status and Raw Status for channel 7
    }

    /// CLEARDSTTRAN Register bits
    namespace cleardsttran_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Clear Interrupt Status and Raw Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Clear Interrupt Status and Raw Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Clear Interrupt Status and Raw Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Clear Interrupt Status and Raw Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Clear Interrupt Status and Raw Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Clear Interrupt Status and Raw Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Clear Interrupt Status and Raw Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Clear Interrupt Status and Raw Status for channel 7
    }

    /// CLEARERR Register bits
    namespace clearerr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Clear Interrupt Status and Raw Status for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Clear Interrupt Status and Raw Status for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Clear Interrupt Status and Raw Status for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Clear Interrupt Status and Raw Status for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Clear Interrupt Status and Raw Status for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Clear Interrupt Status and Raw Status for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Clear Interrupt Status and Raw Status for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Clear Interrupt Status and Raw Status for channel 7
    }

    /// STATUSINT Register bits
    namespace statusint_bits {
        constexpr uint32_t ERR = (1U << 4);  ///< OR of the contents of STATUSERR register
        constexpr uint32_t DSTT = (1U << 3);  ///< OR of the contents of STATUSDSTTRAN register
        constexpr uint32_t SRCT = (1U << 2);  ///< OR of the contents of STATUSSRCTRAN register
        constexpr uint32_t BLOCK = (1U << 1);  ///< OR of the contents of STATUSBLOCK register
        constexpr uint32_t TFR = (1U << 0);  ///< OR of the contents of STATUSTFR register
    }

    /// REQSRCREG Register bits
    namespace reqsrcreg_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Source request write enable for channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Source request write enable for channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Source request write enable for channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Source request write enable for channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Source request write enable for channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Source request write enable for channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Source request write enable for channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Source request write enable for channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Source request for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Source request for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Source request for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Source request for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Source request for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Source request for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Source request for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Source request for channel 7
    }

    /// REQDSTREG Register bits
    namespace reqdstreg_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Source request write enable for channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Source request write enable for channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Source request write enable for channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Source request write enable for channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Source request write enable for channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Source request write enable for channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Source request write enable for channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Source request write enable for channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Source request for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Source request for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Source request for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Source request for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Source request for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Source request for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Source request for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Source request for channel 7
    }

    /// SGLREQSRCREG Register bits
    namespace sglreqsrcreg_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Source request write enable for channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Source request write enable for channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Source request write enable for channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Source request write enable for channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Source request write enable for channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Source request write enable for channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Source request write enable for channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Source request write enable for channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Source request for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Source request for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Source request for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Source request for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Source request for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Source request for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Source request for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Source request for channel 7
    }

    /// SGLREQDSTREG Register bits
    namespace sglreqdstreg_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Source request write enable for channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Source request write enable for channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Source request write enable for channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Source request write enable for channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Source request write enable for channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Source request write enable for channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Source request write enable for channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Source request write enable for channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Source request for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Source request for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Source request for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Source request for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Source request for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Source request for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Source request for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Source request for channel 7
    }

    /// LSTSRCREG Register bits
    namespace lstsrcreg_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Source last transaction request write enable for channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Source last transaction request write enable for channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Source last transaction request write enable for channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Source last transaction request write enable for channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Source last transaction request write enable for channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Source last transaction request write enable for channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Source last transaction request write enable for channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Source last transaction request write enable for channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Source last request for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Source last request for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Source last request for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Source last request for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Source last request for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Source last request for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Source last request for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Source last request for channel 7
    }

    /// LSTDSTREG Register bits
    namespace lstdstreg_bits {
        constexpr uint32_t WE_CH0 = (1U << 8);  ///< Destination last transaction request write enable for channel 0
        constexpr uint32_t WE_CH1 = (1U << 9);  ///< Destination last transaction request write enable for channel 1
        constexpr uint32_t WE_CH2 = (1U << 10);  ///< Destination last transaction request write enable for channel 2
        constexpr uint32_t WE_CH3 = (1U << 11);  ///< Destination last transaction request write enable for channel 3
        constexpr uint32_t WE_CH4 = (1U << 12);  ///< Destination last transaction request write enable for channel 4
        constexpr uint32_t WE_CH5 = (1U << 13);  ///< Destination last transaction request write enable for channel 5
        constexpr uint32_t WE_CH6 = (1U << 14);  ///< Destination last transaction request write enable for channel 6
        constexpr uint32_t WE_CH7 = (1U << 15);  ///< Destination last transaction request write enable for channel 7
        constexpr uint32_t CH0 = (1U << 0);  ///< Destination last request for channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Destination last request for channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Destination last request for channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Destination last request for channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Destination last request for channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Destination last request for channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Destination last request for channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Destination last request for channel 7
    }

    /// DMACFGREG Register bits
    namespace dmacfgreg_bits {
        constexpr uint32_t DMA_EN = (1U << 0);  ///< GPDMA Enable bit.
    }

    /// CHENREG Register bits
    namespace chenreg_bits {
        constexpr uint32_t WE_CH = (8 << 8);  ///< Channel enable write enable
        constexpr uint32_t CH = (8 << 0);  ///< Enables/Disables the channel
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t VALUE = (32 << 0);  ///< Hardcoded GPDMA Peripheral ID
    }

    /// TYPE Register bits
    namespace type_bits {
        constexpr uint32_t VALUE = (32 << 0);  ///< Component Type
    }

    /// VERSION Register bits
    namespace version_bits {
        constexpr uint32_t VALUE = (32 << 0);  ///< Version number of the component
    }

}

// ============================================================================
// FCE Peripheral
// ============================================================================

namespace fce {
    /// Base addresses
    constexpr uint32_t FCE_BASE = 0x50020000;
    constexpr uint32_t FCE_KE0_BASE = 0x50020020;
    constexpr uint32_t FCE_KE1_BASE = 0x50020040;
    constexpr uint32_t FCE_KE2_BASE = 0x50020060;
    constexpr uint32_t FCE_KE3_BASE = 0x50020080;

    /// FCE Register structure
    struct Registers {
        volatile uint32_t CLC;  ///< Offset: 0x00 - Clock Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
    };

    /// Peripheral instances
    inline Registers* FCE = reinterpret_cast<Registers*>(FCE_BASE);
    inline Registers* FCE_KE0 = reinterpret_cast<Registers*>(FCE_KE0_BASE);
    inline Registers* FCE_KE1 = reinterpret_cast<Registers*>(FCE_KE1_BASE);
    inline Registers* FCE_KE2 = reinterpret_cast<Registers*>(FCE_KE2_BASE);
    inline Registers* FCE_KE3 = reinterpret_cast<Registers*>(FCE_KE3_BASE);

    // Bit definitions
    /// CLC Register bits
    namespace clc_bits {
        constexpr uint32_t DISR = (1U << 0);  ///< Module Disable Request Bit
        constexpr uint32_t DISS = (1U << 1);  ///< Module Disable Status Bit
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

}

// ============================================================================
// PBA0 Peripheral
// ============================================================================

namespace pba0 {
    /// Base addresses
    constexpr uint32_t PBA0_BASE = 0x40000000;

    /// PBA0 Register structure
    struct Registers {
        volatile uint32_t STS;  ///< Offset: 0x00 - Peripheral Bridge Status Register
        volatile uint32_t WADDR;  ///< Offset: 0x04 - PBA Write Error Address Register
    };

    /// Peripheral instances
    inline Registers* PBA0 = reinterpret_cast<Registers*>(PBA0_BASE);

    // Bit definitions
    /// STS Register bits
    namespace sts_bits {
        constexpr uint32_t WERR = (1U << 0);  ///< Bufferable Write Access Error
    }

    /// WADDR Register bits
    namespace waddr_bits {
        constexpr uint32_t WADDR = (32 << 0);  ///< Write Error Address
    }

}

// ============================================================================
// PBA1 Peripheral
// ============================================================================

namespace pba1 {
    /// Base addresses
    constexpr uint32_t PBA1_BASE = 0x48000000;

    /// PBA1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* PBA1 = reinterpret_cast<Registers*>(PBA1_BASE);

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH0_BASE = 0x58001000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x1008 - Flash Module Identification Register
        volatile uint32_t FSR;  ///< Offset: 0x1010 - Flash Status Register
        volatile uint32_t FCON;  ///< Offset: 0x1014 - Flash Configuration Register
        volatile uint32_t MARP;  ///< Offset: 0x1018 - Margin Control Register PFLASH
        volatile uint32_t PROCON0;  ///< Offset: 0x1020 - Flash Protection Configuration Register User 0
        volatile uint32_t PROCON1;  ///< Offset: 0x1024 - Flash Protection Configuration Register User 1
        volatile uint32_t PROCON2;  ///< Offset: 0x1028 - Flash Protection Configuration Register User 2
    };

    /// Peripheral instances
    inline Registers* FLASH0 = reinterpret_cast<Registers*>(FLASH0_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// FSR Register bits
    namespace fsr_bits {
        constexpr uint32_t PBUSY = (1U << 0);  ///< Program Flash Busy
        constexpr uint32_t FABUSY = (1U << 1);  ///< Flash Array Busy
        constexpr uint32_t PROG = (1U << 4);  ///< Programming State
        constexpr uint32_t ERASE = (1U << 5);  ///< Erase State
        constexpr uint32_t PFPAGE = (1U << 6);  ///< Program Flash in Page Mode
        constexpr uint32_t PFOPER = (1U << 8);  ///< Program Flash Operation Error
        constexpr uint32_t SQER = (1U << 10);  ///< Command Sequence Error
        constexpr uint32_t PROER = (1U << 11);  ///< Protection Error
        constexpr uint32_t PFSBER = (1U << 12);  ///< PFLASH Single-Bit Error and Correction
        constexpr uint32_t PFDBER = (1U << 14);  ///< PFLASH Double-Bit Error
        constexpr uint32_t PROIN = (1U << 16);  ///< Protection Installed
        constexpr uint32_t RPROIN = (1U << 18);  ///< Read Protection Installed
        constexpr uint32_t RPRODIS = (1U << 19);  ///< Read Protection Disable State
        constexpr uint32_t WPROIN0 = (1U << 21);  ///< Sector Write Protection Installed for User 0
        constexpr uint32_t WPROIN1 = (1U << 22);  ///< Sector Write Protection Installed for User 1
        constexpr uint32_t WPROIN2 = (1U << 23);  ///< Sector OTP Protection Installed for User 2
        constexpr uint32_t WPRODIS0 = (1U << 25);  ///< Sector Write Protection Disabled for User 0
        constexpr uint32_t WPRODIS1 = (1U << 26);  ///< Sector Write Protection Disabled for User 1
        constexpr uint32_t SLM = (1U << 28);  ///< Flash Sleep Mode
        constexpr uint32_t VER = (1U << 31);  ///< Verify Error
    }

    /// FCON Register bits
    namespace fcon_bits {
        constexpr uint32_t WSPFLASH = (4 << 0);  ///< Wait States for read access to PFLASH
        constexpr uint32_t WSECPF = (1U << 4);  ///< Wait State for Error Correction of PFLASH
        constexpr uint32_t IDLE = (1U << 13);  ///< Dynamic Flash Idle
        constexpr uint32_t ESLDIS = (1U << 14);  ///< External Sleep Request Disable
        constexpr uint32_t SLEEP = (1U << 15);  ///< Flash SLEEP
        constexpr uint32_t RPA = (1U << 16);  ///< Read Protection Activated
        constexpr uint32_t DCF = (1U << 17);  ///< Disable Code Fetch from Flash Memory
        constexpr uint32_t DDF = (1U << 18);  ///< Disable Any Data Fetch from Flash
        constexpr uint32_t VOPERM = (1U << 24);  ///< Verify and Operation Error Interrupt Mask
        constexpr uint32_t SQERM = (1U << 25);  ///< Command Sequence Error Interrupt Mask
        constexpr uint32_t PROERM = (1U << 26);  ///< Protection Error Interrupt Mask
        constexpr uint32_t PFSBERM = (1U << 27);  ///< PFLASH Single-Bit Error Interrupt Mask
        constexpr uint32_t PFDBERM = (1U << 29);  ///< PFLASH Double-Bit Error Interrupt Mask
        constexpr uint32_t EOBM = (1U << 31);  ///< End of Busy Interrupt Mask
    }

    /// MARP Register bits
    namespace marp_bits {
        constexpr uint32_t MARGIN = (4 << 0);  ///< PFLASH Margin Selection
        constexpr uint32_t TRAPDIS = (1U << 15);  ///< PFLASH Double-Bit Error Trap Disable
    }

    /// PROCON0 Register bits
    namespace procon0_bits {
        constexpr uint32_t S0L = (1U << 0);  ///< Sector 0 Locked for Write Protection by User 0
        constexpr uint32_t S1L = (1U << 1);  ///< Sector 1 Locked for Write Protection by User 0
        constexpr uint32_t S2L = (1U << 2);  ///< Sector 2 Locked for Write Protection by User 0
        constexpr uint32_t S3L = (1U << 3);  ///< Sector 3 Locked for Write Protection by User 0
        constexpr uint32_t S4L = (1U << 4);  ///< Sector 4 Locked for Write Protection by User 0
        constexpr uint32_t S5L = (1U << 5);  ///< Sector 5 Locked for Write Protection by User 0
        constexpr uint32_t S6L = (1U << 6);  ///< Sector 6 Locked for Write Protection by User 0
        constexpr uint32_t S7L = (1U << 7);  ///< Sector 7 Locked for Write Protection by User 0
        constexpr uint32_t S8L = (1U << 8);  ///< Sector 8 Locked for Write Protection by User 0
        constexpr uint32_t S9L = (1U << 9);  ///< Sector 9 Locked for Write Protection by User 0
        constexpr uint32_t S10_S11L = (1U << 10);  ///< Sectors 10 and 11 Locked for Write Protection by User 0
        constexpr uint32_t RPRO = (1U << 15);  ///< Read Protection Configuration
    }

    /// PROCON1 Register bits
    namespace procon1_bits {
        constexpr uint32_t S0L = (1U << 0);  ///< Sector 0 Locked for Write Protection by User 1
        constexpr uint32_t S1L = (1U << 1);  ///< Sector 1 Locked for Write Protection by User 1
        constexpr uint32_t S2L = (1U << 2);  ///< Sector 2 Locked for Write Protection by User 1
        constexpr uint32_t S3L = (1U << 3);  ///< Sector 3 Locked for Write Protection by User 1
        constexpr uint32_t S4L = (1U << 4);  ///< Sector 4 Locked for Write Protection by User 1
        constexpr uint32_t S5L = (1U << 5);  ///< Sector 5 Locked for Write Protection by User 1
        constexpr uint32_t S6L = (1U << 6);  ///< Sector 6 Locked for Write Protection by User 1
        constexpr uint32_t S7L = (1U << 7);  ///< Sector 7 Locked for Write Protection by User 1
        constexpr uint32_t S8L = (1U << 8);  ///< Sector 8 Locked for Write Protection by User 1
        constexpr uint32_t S9L = (1U << 9);  ///< Sector 9 Locked for Write Protection by User 1
        constexpr uint32_t S10_S11L = (1U << 10);  ///< Sectors 10 and 11 Locked for Write Protection by User 1
    }

    /// PROCON2 Register bits
    namespace procon2_bits {
        constexpr uint32_t S0ROM = (1U << 0);  ///< Sector 0 Locked Forever by User 2
        constexpr uint32_t S1ROM = (1U << 1);  ///< Sector 1 Locked Forever by User 2
        constexpr uint32_t S2ROM = (1U << 2);  ///< Sector 2 Locked Forever by User 2
        constexpr uint32_t S3ROM = (1U << 3);  ///< Sector 3 Locked Forever by User 2
        constexpr uint32_t S4ROM = (1U << 4);  ///< Sector 4 Locked Forever by User 2
        constexpr uint32_t S5ROM = (1U << 5);  ///< Sector 5 Locked Forever by User 2
        constexpr uint32_t S6ROM = (1U << 6);  ///< Sector 6 Locked Forever by User 2
        constexpr uint32_t S7ROM = (1U << 7);  ///< Sector 7 Locked Forever by User 2
        constexpr uint32_t S8ROM = (1U << 8);  ///< Sector 8 Locked Forever by User 2
        constexpr uint32_t S9ROM = (1U << 9);  ///< Sector 9 Locked Forever by User 2
        constexpr uint32_t S10_S11ROM = (1U << 10);  ///< Sectors 10 and 11 Locked Forever by User 2
    }

}

// ============================================================================
// PREF Peripheral
// ============================================================================

namespace pref {
    /// Base addresses
    constexpr uint32_t PREF_BASE = 0x58004000;

    /// PREF Register structure
    struct Registers {
        volatile uint32_t PCON;  ///< Offset: 0x00 - Prefetch Configuration Register
    };

    /// Peripheral instances
    inline Registers* PREF = reinterpret_cast<Registers*>(PREF_BASE);

    // Bit definitions
    /// PCON Register bits
    namespace pcon_bits {
        constexpr uint32_t IBYP = (1U << 0);  ///< Instruction Prefetch Buffer Bypass
        constexpr uint32_t IINV = (1U << 1);  ///< Instruction Prefetch Buffer Invalidate
    }

}

// ============================================================================
// PMU0 Peripheral
// ============================================================================

namespace pmu0 {
    /// Base addresses
    constexpr uint32_t PMU0_BASE = 0x58000508;

    /// PMU0 Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - PMU0 Identification Register
    };

    /// Peripheral instances
    inline Registers* PMU0 = reinterpret_cast<Registers*>(PMU0_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x50008000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - WDT ID Register
        volatile uint32_t CTR;  ///< Offset: 0x04 - WDT Control Register
        volatile uint32_t SRV;  ///< Offset: 0x08 - WDT Service Register
        volatile uint32_t TIM;  ///< Offset: 0x0C - WDT Timer Register
        volatile uint32_t WLB;  ///< Offset: 0x10 - WDT Window Lower Bound Register
        volatile uint32_t WUB;  ///< Offset: 0x14 - WDT Window Upper Bound Register
        volatile uint32_t WDTSTS;  ///< Offset: 0x18 - WDT Status Register
        volatile uint32_t WDTCLR;  ///< Offset: 0x1C - WDT Clear Register
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t ENB = (1U << 0);  ///< Enable
        constexpr uint32_t PRE = (1U << 1);  ///< Pre-warning
        constexpr uint32_t DSP = (1U << 4);  ///< Debug Suspend
        constexpr uint32_t SPW = (8 << 8);  ///< Service Indication Pulse Width
    }

    /// SRV Register bits
    namespace srv_bits {
        constexpr uint32_t SRV = (32 << 0);  ///< Service
    }

    /// TIM Register bits
    namespace tim_bits {
        constexpr uint32_t TIM = (32 << 0);  ///< Timer Value
    }

    /// WLB Register bits
    namespace wlb_bits {
        constexpr uint32_t WLB = (32 << 0);  ///< Window Lower Bound
    }

    /// WUB Register bits
    namespace wub_bits {
        constexpr uint32_t WUB = (32 << 0);  ///< Window Upper Bound
    }

    /// WDTSTS Register bits
    namespace wdtsts_bits {
        constexpr uint32_t ALMS = (1U << 0);  ///< Pre-warning Alarm
    }

    /// WDTCLR Register bits
    namespace wdtclr_bits {
        constexpr uint32_t ALMC = (1U << 0);  ///< Pre-warning Alarm
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x50004A00;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - RTC ID Register
        volatile uint32_t CTR;  ///< Offset: 0x04 - RTC Control Register
        volatile uint32_t RAWSTAT;  ///< Offset: 0x08 - RTC Raw Service Request Register
        volatile uint32_t STSSR;  ///< Offset: 0x0C - RTC Service Request Status Register
        volatile uint32_t MSKSR;  ///< Offset: 0x10 - RTC Service Request Mask Register
        volatile uint32_t CLRSR;  ///< Offset: 0x14 - RTC Clear Service Request Register
        volatile uint32_t ATIM0;  ///< Offset: 0x18 - RTC Alarm Time Register 0
        volatile uint32_t ATIM1;  ///< Offset: 0x1C - RTC Alarm Time Register 1
        volatile uint32_t TIM0;  ///< Offset: 0x20 - RTC Time Register 0
        volatile uint32_t TIM1;  ///< Offset: 0x24 - RTC Time Register 1
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t ENB = (1U << 0);  ///< RTC Module Enable
        constexpr uint32_t TAE = (1U << 2);  ///< Timer Alarm Enable for Hibernation Wake-up
        constexpr uint32_t ESEC = (1U << 8);  ///< Enable Seconds Comparison for Hibernation Wake-up
        constexpr uint32_t EMIC = (1U << 9);  ///< Enable Minutes Comparison for Hibernation Wake-up
        constexpr uint32_t EHOC = (1U << 10);  ///< Enable Hours Comparison for Hibernation Wake-up
        constexpr uint32_t EDAC = (1U << 11);  ///< Enable Days Comparison for Hibernation Wake-up
        constexpr uint32_t EMOC = (1U << 13);  ///< Enable Months Comparison for Hibernation Wake-up
        constexpr uint32_t EYEC = (1U << 14);  ///< Enable Years Comparison for Hibernation Wake-up
        constexpr uint32_t DIV = (16 << 16);  ///< RTC Clock Divider Value
    }

    /// RAWSTAT Register bits
    namespace rawstat_bits {
        constexpr uint32_t RPSE = (1U << 0);  ///< Raw Periodic Seconds Service Request
        constexpr uint32_t RPMI = (1U << 1);  ///< Raw Periodic Minutes Service Request
        constexpr uint32_t RPHO = (1U << 2);  ///< Raw Periodic Hours Service Request
        constexpr uint32_t RPDA = (1U << 3);  ///< Raw Periodic Days Service Request
        constexpr uint32_t RPMO = (1U << 5);  ///< Raw Periodic Months Service Request
        constexpr uint32_t RPYE = (1U << 6);  ///< Raw Periodic Years Service Request
        constexpr uint32_t RAI = (1U << 8);  ///< Raw Alarm Service Request
    }

    /// STSSR Register bits
    namespace stssr_bits {
        constexpr uint32_t SPSE = (1U << 0);  ///< Periodic Seconds Service Request Status after Masking
        constexpr uint32_t SPMI = (1U << 1);  ///< Periodic Minutes Service Request Status after Masking
        constexpr uint32_t SPHO = (1U << 2);  ///< Periodic Hours Service Request Status after Masking
        constexpr uint32_t SPDA = (1U << 3);  ///< Periodic Days Service Request Status after Masking
        constexpr uint32_t SPMO = (1U << 5);  ///< Periodic Months Service Request Status after Masking
        constexpr uint32_t SPYE = (1U << 6);  ///< Periodic Years Service Request Status after Masking
        constexpr uint32_t SAI = (1U << 8);  ///< Alarm Service Request Status after Masking
    }

    /// MSKSR Register bits
    namespace msksr_bits {
        constexpr uint32_t MPSE = (1U << 0);  ///< Periodic Seconds Interrupt Mask
        constexpr uint32_t MPMI = (1U << 1);  ///< Periodic Minutes Interrupt Mask
        constexpr uint32_t MPHO = (1U << 2);  ///< Periodic Hours Interrupt Mask
        constexpr uint32_t MPDA = (1U << 3);  ///< Periodic Days Interrupt Mask
        constexpr uint32_t MPMO = (1U << 5);  ///< Periodic Months Interrupt Mask
        constexpr uint32_t MPYE = (1U << 6);  ///< Periodic Years Interrupt Mask
        constexpr uint32_t MAI = (1U << 8);  ///< Alarm Interrupt Mask
    }

    /// CLRSR Register bits
    namespace clrsr_bits {
        constexpr uint32_t RPSE = (1U << 0);  ///< Periodic Seconds Interrupt Clear
        constexpr uint32_t RPMI = (1U << 1);  ///< Periodic Minutes Interrupt Clear
        constexpr uint32_t RPHO = (1U << 2);  ///< Periodic Hours Interrupt Clear
        constexpr uint32_t RPDA = (1U << 3);  ///< Periodic Days Interrupt Clear
        constexpr uint32_t RPMO = (1U << 5);  ///< Periodic Months Interrupt Clear
        constexpr uint32_t RPYE = (1U << 6);  ///< Periodic Years Interrupt Clear
        constexpr uint32_t RAI = (1U << 8);  ///< Alarm Interrupt Clear
    }

    /// ATIM0 Register bits
    namespace atim0_bits {
        constexpr uint32_t ASE = (6 << 0);  ///< Alarm Seconds Compare Value
        constexpr uint32_t AMI = (6 << 8);  ///< Alarm Minutes Compare Value
        constexpr uint32_t AHO = (5 << 16);  ///< Alarm Hours Compare Value
        constexpr uint32_t ADA = (5 << 24);  ///< Alarm Days Compare Value
    }

    /// ATIM1 Register bits
    namespace atim1_bits {
        constexpr uint32_t AMO = (4 << 8);  ///< Alarm Month Compare Value
        constexpr uint32_t AYE = (16 << 16);  ///< Alarm Year Compare Value
    }

    /// TIM0 Register bits
    namespace tim0_bits {
        constexpr uint32_t SE = (6 << 0);  ///< Seconds Time Value
        constexpr uint32_t MI = (6 << 8);  ///< Minutes Time Value
        constexpr uint32_t HO = (5 << 16);  ///< Hours Time Value
        constexpr uint32_t DA = (5 << 24);  ///< Days Time Value
    }

    /// TIM1 Register bits
    namespace tim1_bits {
        constexpr uint32_t DAWE = (3 << 0);  ///< Days of Week Time Value
        constexpr uint32_t MO = (4 << 8);  ///< Month Time Value
        constexpr uint32_t YE = (16 << 16);  ///< Year Time Value
    }

}

// ============================================================================
// SCU Peripheral
// ============================================================================

namespace scu {
    /// Base addresses
    constexpr uint32_t SCU_CLK_BASE = 0x50004600;
    constexpr uint32_t SCU_OSC_BASE = 0x50004700;
    constexpr uint32_t SCU_PLL_BASE = 0x50004710;
    constexpr uint32_t SCU_GENERAL_BASE = 0x50004000;
    constexpr uint32_t SCU_INTERRUPT_BASE = 0x50004074;
    constexpr uint32_t SCU_PARITY_BASE = 0x5000413C;
    constexpr uint32_t SCU_TRAP_BASE = 0x50004160;
    constexpr uint32_t SCU_HIBERNATE_BASE = 0x50004300;
    constexpr uint32_t SCU_RESET_BASE = 0x50004400;

    /// SCU Register structure
    struct Registers {
        volatile uint32_t CLKSTAT;  ///< Offset: 0x00 - Clock Status Register
        volatile uint32_t CLKSET;  ///< Offset: 0x04 - CLK Set Register
        volatile uint32_t CLKCLR;  ///< Offset: 0x08 - CLK Clear Register
        volatile uint32_t SYSCLKCR;  ///< Offset: 0x0C - System Clock Control Register
        volatile uint32_t CPUCLKCR;  ///< Offset: 0x10 - CPU Clock Control Register
        volatile uint32_t PBCLKCR;  ///< Offset: 0x14 - Peripheral Bus Clock Control Register
        volatile uint32_t USBCLKCR;  ///< Offset: 0x18 - USB Clock Control Register
        volatile uint32_t EBUCLKCR;  ///< Offset: 0x1C - EBU Clock Control Register
        volatile uint32_t CCUCLKCR;  ///< Offset: 0x20 - CCU Clock Control Register
        volatile uint32_t WDTCLKCR;  ///< Offset: 0x24 - WDT Clock Control Register
        volatile uint32_t EXTCLKCR;  ///< Offset: 0x28 - External Clock Control
        volatile uint32_t SLEEPCR;  ///< Offset: 0x30 - Sleep Control Register
        volatile uint32_t DSLEEPCR;  ///< Offset: 0x34 - Deep Sleep Control Register
    };

    /// Peripheral instances
    inline Registers* SCU_CLK = reinterpret_cast<Registers*>(SCU_CLK_BASE);
    inline Registers* SCU_OSC = reinterpret_cast<Registers*>(SCU_OSC_BASE);
    inline Registers* SCU_PLL = reinterpret_cast<Registers*>(SCU_PLL_BASE);
    inline Registers* SCU_GENERAL = reinterpret_cast<Registers*>(SCU_GENERAL_BASE);
    inline Registers* SCU_INTERRUPT = reinterpret_cast<Registers*>(SCU_INTERRUPT_BASE);
    inline Registers* SCU_PARITY = reinterpret_cast<Registers*>(SCU_PARITY_BASE);
    inline Registers* SCU_TRAP = reinterpret_cast<Registers*>(SCU_TRAP_BASE);
    inline Registers* SCU_HIBERNATE = reinterpret_cast<Registers*>(SCU_HIBERNATE_BASE);
    inline Registers* SCU_RESET = reinterpret_cast<Registers*>(SCU_RESET_BASE);

    // Bit definitions
    /// CLKSTAT Register bits
    namespace clkstat_bits {
        constexpr uint32_t USBCST = (1U << 0);  ///< USB Clock Status
        constexpr uint32_t MMCCST = (1U << 1);  ///< MMC Clock Status
        constexpr uint32_t ETH0CST = (1U << 2);  ///< Ethernet Clock Status
        constexpr uint32_t EBUCST = (1U << 3);  ///< EBU Clock Status
        constexpr uint32_t CCUCST = (1U << 4);  ///< CCU Clock Status
        constexpr uint32_t WDTCST = (1U << 5);  ///< WDT Clock Status
    }

    /// CLKSET Register bits
    namespace clkset_bits {
        constexpr uint32_t USBCEN = (1U << 0);  ///< USB Clock Enable
        constexpr uint32_t MMCCEN = (1U << 1);  ///< MMC Clock Enable
        constexpr uint32_t ETH0CEN = (1U << 2);  ///< Ethernet Clock Enable
        constexpr uint32_t EBUCEN = (1U << 3);  ///< EBU Clock Enable
        constexpr uint32_t CCUCEN = (1U << 4);  ///< CCU Clock Enable
        constexpr uint32_t WDTCEN = (1U << 5);  ///< WDT Clock Enable
    }

    /// CLKCLR Register bits
    namespace clkclr_bits {
        constexpr uint32_t USBCDI = (1U << 0);  ///< USB Clock Disable
        constexpr uint32_t MMCCDI = (1U << 1);  ///< MMC Clock Disable
        constexpr uint32_t ETH0CDI = (1U << 2);  ///< Ethernet Clock Disable
        constexpr uint32_t EBUCDI = (1U << 3);  ///< EBU Clock Disable
        constexpr uint32_t CCUCDI = (1U << 4);  ///< CCU Clock Disable
        constexpr uint32_t WDTCDI = (1U << 5);  ///< WDT Clock Disable
    }

    /// SYSCLKCR Register bits
    namespace sysclkcr_bits {
        constexpr uint32_t SYSDIV = (8 << 0);  ///< System Clock Division Value
        constexpr uint32_t SYSSEL = (1U << 16);  ///< System Clock Selection Value
    }

    /// CPUCLKCR Register bits
    namespace cpuclkcr_bits {
        constexpr uint32_t CPUDIV = (1U << 0);  ///< CPU Clock Divider Enable
    }

    /// PBCLKCR Register bits
    namespace pbclkcr_bits {
        constexpr uint32_t PBDIV = (1U << 0);  ///< PB Clock Divider Enable
    }

    /// USBCLKCR Register bits
    namespace usbclkcr_bits {
        constexpr uint32_t USBDIV = (3 << 0);  ///< USB Clock Divider Value
        constexpr uint32_t USBSEL = (1U << 16);  ///< USB Clock Selection Value
    }

    /// EBUCLKCR Register bits
    namespace ebuclkcr_bits {
        constexpr uint32_t EBUDIV = (6 << 0);  ///< EBU Clock Divider Value
    }

    /// CCUCLKCR Register bits
    namespace ccuclkcr_bits {
        constexpr uint32_t CCUDIV = (1U << 0);  ///< CCU Clock Divider Enable
    }

    /// WDTCLKCR Register bits
    namespace wdtclkcr_bits {
        constexpr uint32_t WDTDIV = (8 << 0);  ///< WDT Clock Divider Value
        constexpr uint32_t WDTSEL = (2 << 16);  ///< WDT Clock Selection Value
    }

    /// EXTCLKCR Register bits
    namespace extclkcr_bits {
        constexpr uint32_t ECKSEL = (2 << 0);  ///< External Clock Selection Value
        constexpr uint32_t ECKDIV = (9 << 16);  ///< External Clock Divider Value
    }

    /// SLEEPCR Register bits
    namespace sleepcr_bits {
        constexpr uint32_t SYSSEL = (1U << 0);  ///< System Clock Selection Value
        constexpr uint32_t USBCR = (1U << 16);  ///< USB Clock Control
        constexpr uint32_t MMCCR = (1U << 17);  ///< MMC Clock Control
        constexpr uint32_t ETH0CR = (1U << 18);  ///< Ethernet Clock Control
        constexpr uint32_t EBUCR = (1U << 19);  ///< EBU Clock Control
        constexpr uint32_t CCUCR = (1U << 20);  ///< CCU Clock Control
        constexpr uint32_t WDTCR = (1U << 21);  ///< WDT Clock Control
    }

    /// DSLEEPCR Register bits
    namespace dsleepcr_bits {
        constexpr uint32_t SYSSEL = (2 << 0);  ///< System Clock Selection Value
        constexpr uint32_t FPDN = (1U << 11);  ///< Flash Power Down
        constexpr uint32_t PLLPDN = (1U << 12);  ///< PLL Power Down
        constexpr uint32_t VCOPDN = (1U << 13);  ///< VCO Power Down
        constexpr uint32_t USBCR = (1U << 16);  ///< USB Clock Control
        constexpr uint32_t MMCCR = (1U << 17);  ///< MMC Clock Control
        constexpr uint32_t ETH0CR = (1U << 18);  ///< Ethernet Clock Control
        constexpr uint32_t EBUCR = (1U << 19);  ///< EBU Clock Control
        constexpr uint32_t CCUCR = (1U << 20);  ///< CCU Clock Control
        constexpr uint32_t WDTCR = (1U << 21);  ///< WDT Clock Control
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t SCU_POWER_BASE = 0x50004200;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t PWRSTAT;  ///< Offset: 0x00 - PCU Status Register
        volatile uint32_t PWRSET;  ///< Offset: 0x04 - PCU Set Control Register
        volatile uint32_t PWRCLR;  ///< Offset: 0x08 - PCU Clear Control Register
        volatile uint32_t EVRSTAT;  ///< Offset: 0x10 - EVR Status Register
        volatile uint32_t EVRVADCSTAT;  ///< Offset: 0x14 - EVR VADC Status Register
        volatile uint32_t PWRMON;  ///< Offset: 0x2C - Power Monitor Control
    };

    /// Peripheral instances
    inline Registers* SCU_POWER = reinterpret_cast<Registers*>(SCU_POWER_BASE);

    // Bit definitions
    /// PWRSTAT Register bits
    namespace pwrstat_bits {
        constexpr uint32_t HIBEN = (1U << 0);  ///< Hibernate Domain Enable Status
        constexpr uint32_t USBPHYPDQ = (1U << 16);  ///< USB PHY Transceiver State
        constexpr uint32_t USBOTGEN = (1U << 17);  ///< USB On-The-Go Comparators State
        constexpr uint32_t USBPUWQ = (1U << 18);  ///< USB Weak Pull-Up at PADN State
    }

    /// PWRSET Register bits
    namespace pwrset_bits {
        constexpr uint32_t HIB = (1U << 0);  ///< Set Hibernate Domain Enable
        constexpr uint32_t USBPHYPDQ = (1U << 16);  ///< Set USB PHY Transceiver Disable
        constexpr uint32_t USBOTGEN = (1U << 17);  ///< Set USB On-The-Go Comparators Enable
        constexpr uint32_t USBPUWQ = (1U << 18);  ///< Set USB Weak Pull-Up at PADN Enable
    }

    /// PWRCLR Register bits
    namespace pwrclr_bits {
        constexpr uint32_t HIB = (1U << 0);  ///< Clear Disable Hibernate Domain
        constexpr uint32_t USBPHYPDQ = (1U << 16);  ///< Clear USB PHY Transceiver Disable
        constexpr uint32_t USBOTGEN = (1U << 17);  ///< Clear USB On-The-Go Comparators Enable
        constexpr uint32_t USBPUWQ = (1U << 18);  ///< Clear USB Weak Pull-Up at PADN Enable
    }

    /// EVRSTAT Register bits
    namespace evrstat_bits {
        constexpr uint32_t OV13 = (1U << 1);  ///< Regulator Overvoltage for 1.3 V
    }

    /// EVRVADCSTAT Register bits
    namespace evrvadcstat_bits {
        constexpr uint32_t VADC13V = (8 << 0);  ///< VADC 1.3 V Conversion Result
        constexpr uint32_t VADC33V = (8 << 8);  ///< VADC 3.3 V Conversion Result
    }

    /// PWRMON Register bits
    namespace pwrmon_bits {
        constexpr uint32_t THRS = (8 << 0);  ///< Threshold
        constexpr uint32_t INTV = (8 << 8);  ///< Interval
        constexpr uint32_t ENB = (1U << 16);  ///< Enable
    }

}

// ============================================================================
// LEDTS0 Peripheral
// ============================================================================

namespace ledts0 {
    /// Base addresses
    constexpr uint32_t LEDTS0_BASE = 0x48010000;

    /// LEDTS0 Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - Module Identification Register
        volatile uint32_t GLOBCTL;  ///< Offset: 0x04 - Global Control Register
        volatile uint32_t FNCTL;  ///< Offset: 0x08 - Function Control Register
        volatile uint32_t EVFR;  ///< Offset: 0x0C - Event Flag Register
        volatile uint32_t TSVAL;  ///< Offset: 0x10 - Touch-sense TS-Counter Value
        volatile uint32_t LINE0;  ///< Offset: 0x14 - Line Pattern Register 0
        volatile uint32_t LINE1;  ///< Offset: 0x18 - Line Pattern Register 1
        volatile uint32_t LDCMP0;  ///< Offset: 0x1C - LED Compare Register 0
        volatile uint32_t LDCMP1;  ///< Offset: 0x20 - LED Compare Register 1
        volatile uint32_t TSCMP0;  ///< Offset: 0x24 - Touch-sense Compare Register 0
        volatile uint32_t TSCMP1;  ///< Offset: 0x28 - Touch-sense Compare Register 1
    };

    /// Peripheral instances
    inline Registers* LEDTS0 = reinterpret_cast<Registers*>(LEDTS0_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// GLOBCTL Register bits
    namespace globctl_bits {
        constexpr uint32_t TS_EN = (1U << 0);  ///< Touch-Sense Function Enable
        constexpr uint32_t LD_EN = (1U << 1);  ///< LED Function Enable
        constexpr uint32_t CMTR = (1U << 2);  ///< Clock Master Disable
        constexpr uint32_t ENSYNC = (1U << 3);  ///< Enable Autoscan Time Period Synchronization
        constexpr uint32_t SUSCFG = (1U << 8);  ///< Suspend Request Configuration
        constexpr uint32_t MASKVAL = (3 << 9);  ///< Mask Number of LSB Bits for Event Validation
        constexpr uint32_t FENVAL = (1U << 12);  ///< Enable (Extended) Time Frame Validation
        constexpr uint32_t ITS_EN = (1U << 13);  ///< Enable Time Slice Interrupt
        constexpr uint32_t ITF_EN = (1U << 14);  ///< Enable (Extended) Time Frame Interrupt
        constexpr uint32_t ITP_EN = (1U << 15);  ///< Enable Autoscan Time Period Interrupt
        constexpr uint32_t CLK_PS = (16 << 16);  ///< LEDTS-Counter Clock Pre-Scale Factor
    }

    /// FNCTL Register bits
    namespace fnctl_bits {
        constexpr uint32_t PADT = (3 << 0);  ///< Touch-Sense TSIN Pad Turn
        constexpr uint32_t PADTSW = (1U << 3);  ///< Software Control for Touch-Sense Pad Turn
        constexpr uint32_t EPULL = (1U << 4);  ///< Enable External Pull-up Configuration on Pin COLA
        constexpr uint32_t FNCOL = (3 << 5);  ///< Previous Active Function/LED Column Status
        constexpr uint32_t ACCCNT = (4 << 16);  ///< Accumulate Count on Touch-Sense Input
        constexpr uint32_t TSCCMP = (1U << 20);  ///< Common Compare Enable for Touch-Sense
        constexpr uint32_t TSOEXT = (2 << 21);  ///< Extension for Touch-Sense Output for Pin-Low-Level
        constexpr uint32_t TSCTRR = (1U << 23);  ///< TS-Counter Auto Reset
        constexpr uint32_t TSCTRSAT = (1U << 24);  ///< Saturation of TS-Counter
        constexpr uint32_t NR_TSIN = (3 << 25);  ///< Number of Touch-Sense Input
        constexpr uint32_t COLLEV = (1U << 28);  ///< Active Level of LED Column
        constexpr uint32_t NR_LEDCOL = (3 << 29);  ///< Number of LED Columns
    }

    /// EVFR Register bits
    namespace evfr_bits {
        constexpr uint32_t TSF = (1U << 0);  ///< Time Slice Interrupt Flag
        constexpr uint32_t TFF = (1U << 1);  ///< (Extended) Time Frame Interrupt Flag
        constexpr uint32_t TPF = (1U << 2);  ///< Autoscan Time Period Interrupt Flag
        constexpr uint32_t TSCTROVF = (1U << 3);  ///< TS-Counter Overflow Indication
        constexpr uint32_t CTSF = (1U << 16);  ///< Clear Time Slice Interrupt Flag
        constexpr uint32_t CTFF = (1U << 17);  ///< Clear (Extended) Time Frame Interrupt Flag
        constexpr uint32_t CTPF = (1U << 18);  ///< Clear Autoscan Time Period Interrupt Flag
    }

    /// TSVAL Register bits
    namespace tsval_bits {
        constexpr uint32_t TSCTRVALR = (16 << 0);  ///< Shadow TS-Counter (Read)
        constexpr uint32_t TSCTRVAL = (16 << 16);  ///< TS-Counter Value
    }

    /// LINE0 Register bits
    namespace line0_bits {
        constexpr uint32_t LINE_0 = (8 << 0);  ///< Output on LINE[x]
        constexpr uint32_t LINE_1 = (8 << 8);  ///< Output on LINE[x]
        constexpr uint32_t LINE_2 = (8 << 16);  ///< Output on LINE[x]
        constexpr uint32_t LINE_3 = (8 << 24);  ///< Output on LINE[x]
    }

    /// LINE1 Register bits
    namespace line1_bits {
        constexpr uint32_t LINE_4 = (8 << 0);  ///< Output on LINE[x]
        constexpr uint32_t LINE_5 = (8 << 8);  ///< Output on LINE[x]
        constexpr uint32_t LINE_6 = (8 << 16);  ///< Output on LINE[x]
        constexpr uint32_t LINE_A = (8 << 24);  ///< Output on LINE[x]
    }

    /// LDCMP0 Register bits
    namespace ldcmp0_bits {
        constexpr uint32_t CMP_LD0 = (8 << 0);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD1 = (8 << 8);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD2 = (8 << 16);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD3 = (8 << 24);  ///< Compare Value for LED COL[x]
    }

    /// LDCMP1 Register bits
    namespace ldcmp1_bits {
        constexpr uint32_t CMP_LD4 = (8 << 0);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD5 = (8 << 8);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LD6 = (8 << 16);  ///< Compare Value for LED COL[x]
        constexpr uint32_t CMP_LDA_TSCOM = (8 << 24);  ///< Compare Value for LED COLA / Common Compare Value for Touch-sense Pad Turns
    }

    /// TSCMP0 Register bits
    namespace tscmp0_bits {
        constexpr uint32_t CMP_TS0 = (8 << 0);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS1 = (8 << 8);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS2 = (8 << 16);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS3 = (8 << 24);  ///< Compare Value for Touch-Sense TSIN[x]
    }

    /// TSCMP1 Register bits
    namespace tscmp1_bits {
        constexpr uint32_t CMP_TS4 = (8 << 0);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS5 = (8 << 8);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS6 = (8 << 16);  ///< Compare Value for Touch-Sense TSIN[x]
        constexpr uint32_t CMP_TS7 = (8 << 24);  ///< Compare Value for Touch-Sense TSIN[x]
    }

}

// ============================================================================
// SDIO Peripheral
// ============================================================================

namespace sdio {
    /// Base addresses
    constexpr uint32_t SDMMC_BASE = 0x4801C000;

    /// SDIO Register structure
    struct Registers {
        volatile uint32_t BLOCK_SIZE;  ///< Offset: 0x04 - Block Size Register
        volatile uint32_t BLOCK_COUNT;  ///< Offset: 0x06 - Block Count Register
        volatile uint32_t ARGUMENT1;  ///< Offset: 0x08 - Argument1 Register
        volatile uint32_t TRANSFER_MODE;  ///< Offset: 0x0C - Transfer Mode Register
        volatile uint32_t COMMAND;  ///< Offset: 0x0E - Command Register
        volatile uint32_t RESPONSE0;  ///< Offset: 0x10 - Response 0 Register
        volatile uint32_t RESPONSE2;  ///< Offset: 0x14 - Response 2 Register
        volatile uint32_t RESPONSE4;  ///< Offset: 0x18 - Response 4 Register
        volatile uint32_t RESPONSE6;  ///< Offset: 0x1C - Response 6 Register
        volatile uint32_t DATA_BUFFER;  ///< Offset: 0x20 - Data Buffer Register
        volatile uint32_t PRESENT_STATE;  ///< Offset: 0x24 - Present State Register
        volatile uint32_t HOST_CTRL;  ///< Offset: 0x28 - Host Control Register
        volatile uint32_t POWER_CTRL;  ///< Offset: 0x29 - Power Control Register
        volatile uint32_t BLOCK_GAP_CTRL;  ///< Offset: 0x2A - Block Gap Control Register
        volatile uint32_t WAKEUP_CTRL;  ///< Offset: 0x2B - Wake-up Control Register
        volatile uint32_t CLOCK_CTRL;  ///< Offset: 0x2C - Clock Control Register
        volatile uint32_t TIMEOUT_CTRL;  ///< Offset: 0x2E - Timeout Control Register
        volatile uint32_t SW_RESET;  ///< Offset: 0x2F - Software Reset Register
        volatile uint32_t INT_STATUS_NORM;  ///< Offset: 0x30 - Normal Interrupt Status Register
        volatile uint32_t INT_STATUS_ERR;  ///< Offset: 0x32 - Error Interrupt Status Register
        volatile uint32_t EN_INT_STATUS_NORM;  ///< Offset: 0x34 - Normal Interrupt Status Enable Register
        volatile uint32_t EN_INT_STATUS_ERR;  ///< Offset: 0x36 - Error Interrupt Status Enable Register
        volatile uint32_t EN_INT_SIGNAL_NORM;  ///< Offset: 0x38 - Normal Interrupt Signal Enable Register
        volatile uint32_t EN_INT_SIGNAL_ERR;  ///< Offset: 0x3A - Error Interrupt Signal Enable Register
        volatile uint32_t ACMD_ERR_STATUS;  ///< Offset: 0x3C - Auto CMD Error Status Register
        volatile uint32_t CAPABILITIES;  ///< Offset: 0x40 - Capabilities Register
        volatile uint32_t CAPABILITIES_HI;  ///< Offset: 0x44 - Capabilities Register High
        volatile uint32_t MAX_CURRENT_CAP;  ///< Offset: 0x48 - Maximum Current Capabilities Register
        volatile uint32_t FORCE_EVENT_ACMD_ERR_STATUS;  ///< Offset: 0x50 - Force Event Register for Auto CMD Error Status
        volatile uint32_t FORCE_EVENT_ERR_STATUS;  ///< Offset: 0x52 - Force Event Register for Error Interrupt Status
        volatile uint32_t DEBUG_SEL;  ///< Offset: 0x74 - Debug Selection Register
        volatile uint32_t SPI;  ///< Offset: 0xF0 - SPI Interrupt Support Register
        volatile uint32_t SLOT_INT_STATUS;  ///< Offset: 0xFC - Slot Interrupt Status Register
    };

    /// Peripheral instances
    inline Registers* SDMMC = reinterpret_cast<Registers*>(SDMMC_BASE);

    // Bit definitions
    /// BLOCK_SIZE Register bits
    namespace block_size_bits {
        constexpr uint32_t TX_BLOCK_SIZE_12 = (1U << 15);  ///< Transfer Block Size 12th bit.
        constexpr uint32_t TX_BLOCK_SIZE = (12 << 0);  ///< Transfer Block Size
    }

    /// BLOCK_COUNT Register bits
    namespace block_count_bits {
        constexpr uint32_t BLOCK_COUNT = (16 << 0);  ///< Blocks Count for Current Transfer
    }

    /// ARGUMENT1 Register bits
    namespace argument1_bits {
        constexpr uint32_t ARGUMENT1 = (32 << 0);  ///< Command Argument
    }

    /// TRANSFER_MODE Register bits
    namespace transfer_mode_bits {
        constexpr uint32_t CMD_COMP_ATA = (1U << 6);  ///< Command Completion Signal Enable for CE-ATA Device
        constexpr uint32_t MULTI_BLOCK_SELECT = (1U << 5);  ///< Multi / Single Block Select
        constexpr uint32_t TX_DIR_SELECT = (1U << 4);  ///< Data Transfer Direction Select
        constexpr uint32_t ACMD_EN = (2 << 2);  ///< Auto CMD Enable
        constexpr uint32_t BLOCK_COUNT_EN = (1U << 1);  ///< Block Count Enable
    }

    /// COMMAND Register bits
    namespace command_bits {
        constexpr uint32_t CMD_IND = (6 << 8);  ///< Command Index
        constexpr uint32_t CMD_TYPE = (2 << 6);  ///< Command Type
        constexpr uint32_t DATA_PRESENT_SELECT = (1U << 5);  ///< Data Present Select
        constexpr uint32_t CMD_IND_CHECK_EN = (1U << 4);  ///< Command Index Check Enable
        constexpr uint32_t CMD_CRC_CHECK_EN = (1U << 3);  ///< Command CRC Check Enable
        constexpr uint32_t RESP_TYPE_SELECT = (2 << 0);  ///< Response Type Select
    }

    /// RESPONSE0 Register bits
    namespace response0_bits {
        constexpr uint32_t RESPONSE1 = (16 << 16);  ///< Response1
        constexpr uint32_t RESPONSE0 = (16 << 0);  ///< Response0
    }

    /// RESPONSE2 Register bits
    namespace response2_bits {
        constexpr uint32_t RESPONSE3 = (16 << 16);  ///< Response3
        constexpr uint32_t RESPONSE2 = (16 << 0);  ///< Response2
    }

    /// RESPONSE4 Register bits
    namespace response4_bits {
        constexpr uint32_t RESPONSE5 = (16 << 16);  ///< Response5
        constexpr uint32_t RESPONSE4 = (16 << 0);  ///< Response4
    }

    /// RESPONSE6 Register bits
    namespace response6_bits {
        constexpr uint32_t RESPONSE7 = (16 << 16);  ///< Response7
        constexpr uint32_t RESPONSE6 = (16 << 0);  ///< Response6
    }

    /// DATA_BUFFER Register bits
    namespace data_buffer_bits {
        constexpr uint32_t DATA_BUFFER = (32 << 0);  ///< Data Buffer
    }

    /// PRESENT_STATE Register bits
    namespace present_state_bits {
        constexpr uint32_t DAT_7_4_PIN_LEVEL = (4 << 25);  ///< Line Signal Level
        constexpr uint32_t CMD_LINE_LEVEL = (1U << 24);  ///< CMD Line Signal Level
        constexpr uint32_t DAT_3_0_PIN_LEVEL = (4 << 20);  ///< Line Signal Level
        constexpr uint32_t WRITE_PROTECT_PIN_LEVEL = (1U << 19);  ///< Write Protect Switch Pin Level
        constexpr uint32_t CARD_DETECT_PIN_LEVEL = (1U << 18);  ///< Card Detect Pin Level
        constexpr uint32_t CARD_STATE_STABLE = (1U << 17);  ///< Card State Stable
        constexpr uint32_t CARD_INSERTED = (1U << 16);  ///< Card Inserted
        constexpr uint32_t BUFFER_READ_ENABLE = (1U << 11);  ///< Buffer Read Enable
        constexpr uint32_t BUFFER_WRITE_ENABLE = (1U << 10);  ///< Buffer Write Enable
        constexpr uint32_t READ_TRANSFER_ACTIVE = (1U << 9);  ///< Read Transfer Active
        constexpr uint32_t WRITE_TRANSFER_ACTIVE = (1U << 8);  ///< Write Transfer Active
        constexpr uint32_t DAT_LINE_ACTIVE = (1U << 2);  ///< DAT Line Active
        constexpr uint32_t COMMAND_INHIBIT_DAT = (1U << 1);  ///< Command Inhibit (DAT)
        constexpr uint32_t COMMAND_INHIBIT_CMD = (1U << 0);  ///< Command Inhibit (CMD)
    }

    /// HOST_CTRL Register bits
    namespace host_ctrl_bits {
        constexpr uint32_t CARD_DET_SIGNAL_DETECT = (1U << 7);  ///< Card detect signal detetction
        constexpr uint32_t CARD_DETECT_TEST_LEVEL = (1U << 6);  ///< Card Detect Test Level
        constexpr uint32_t SD_8BIT_MODE = (1U << 5);  ///< Extended Data Transfer Width
        constexpr uint32_t HIGH_SPEED_EN = (1U << 2);  ///< High Speed Enable
        constexpr uint32_t DATA_TX_WIDTH = (1U << 1);  ///< Data Transfer Width (SD1 or SD4)
        constexpr uint32_t LED_CTRL = (1U << 0);  ///< LED Control
    }

    /// POWER_CTRL Register bits
    namespace power_ctrl_bits {
        constexpr uint32_t HARDWARE_RESET = (1U << 4);  ///< Hardware reset
        constexpr uint32_t SD_BUS_VOLTAGE_SEL = (3 << 1);  ///< SD Bus Voltage Select
        constexpr uint32_t SD_BUS_POWER = (1U << 0);  ///< SD Bus Power
    }

    /// BLOCK_GAP_CTRL Register bits
    namespace block_gap_ctrl_bits {
        constexpr uint32_t SPI_MODE = (1U << 4);  ///< SPI_MODE
        constexpr uint32_t INT_AT_BLOCK_GAP = (1U << 3);  ///< Interrupt At Block Gap
        constexpr uint32_t READ_WAIT_CTRL = (1U << 2);  ///< Read Wait Control
        constexpr uint32_t CONTINUE_REQ = (1U << 1);  ///< Continue Request
        constexpr uint32_t STOP_AT_BLOCK_GAP = (1U << 0);  ///< Stop At Block Gap Request
    }

    /// WAKEUP_CTRL Register bits
    namespace wakeup_ctrl_bits {
        constexpr uint32_t WAKEUP_EVENT_EN_REM = (1U << 2);  ///< Wakeup Event Enable On SD Card Removal
        constexpr uint32_t WAKEUP_EVENT_EN_INS = (1U << 1);  ///< Wakeup Event Enable On SD Card Insertion
        constexpr uint32_t WAKEUP_EVENT_EN_INT = (1U << 0);  ///< Wakeup Event Enable On Card Interrupt
    }

    /// CLOCK_CTRL Register bits
    namespace clock_ctrl_bits {
        constexpr uint32_t SDCLK_FREQ_SEL = (8 << 8);  ///< SDCLK Frequency Select
        constexpr uint32_t SDCLOCK_EN = (1U << 2);  ///< SD Clock Enable
        constexpr uint32_t INTERNAL_CLOCK_STABLE = (1U << 1);  ///< Internal Clock Stable
        constexpr uint32_t INTERNAL_CLOCK_EN = (1U << 0);  ///< Internal Clock Enable
    }

    /// TIMEOUT_CTRL Register bits
    namespace timeout_ctrl_bits {
        constexpr uint32_t DAT_TIMEOUT_CNT_VAL = (4 << 0);  ///< Data Timeout Counter Value
    }

    /// SW_RESET Register bits
    namespace sw_reset_bits {
        constexpr uint32_t SW_RST_DAT_LINE = (1U << 2);  ///< Software Reset for DAT Line
        constexpr uint32_t SW_RST_CMD_LINE = (1U << 1);  ///< Software Reset for CMD Line
        constexpr uint32_t SW_RST_ALL = (1U << 0);  ///< Software Reset for All
    }

    /// INT_STATUS_NORM Register bits
    namespace int_status_norm_bits {
        constexpr uint32_t ERR_INT = (1U << 15);  ///< Error Interrupt
        constexpr uint32_t CARD_INT = (1U << 8);  ///< Card Interrupt
        constexpr uint32_t CARD_REMOVAL = (1U << 7);  ///< Card Removal
        constexpr uint32_t CARD_INS = (1U << 6);  ///< Card Insertion
        constexpr uint32_t BUFF_READ_READY = (1U << 5);  ///< Buffer Read Ready
        constexpr uint32_t BUFF_WRITE_READY = (1U << 4);  ///< Buffer Write Ready
        constexpr uint32_t BLOCK_GAP_EVENT = (1U << 2);  ///< Block Gap Event
        constexpr uint32_t TX_COMPLETE = (1U << 1);  ///< Transfer Complete
        constexpr uint32_t CMD_COMPLETE = (1U << 0);  ///< Command Complete
    }

    /// INT_STATUS_ERR Register bits
    namespace int_status_err_bits {
        constexpr uint32_t CEATA_ERR = (1U << 13);  ///< Ceata Error Status
        constexpr uint32_t ACMD_ERR = (1U << 8);  ///< Auto CMD Error
        constexpr uint32_t CURRENT_LIMIT_ERR = (1U << 7);  ///< Current Limit Error
        constexpr uint32_t DATA_END_BIT_ERR = (1U << 6);  ///< Data End Bit Error
        constexpr uint32_t DATA_CRC_ERR = (1U << 5);  ///< Data CRC Error
        constexpr uint32_t DATA_TIMEOUT_ERR = (1U << 4);  ///< Data Timeout Error
        constexpr uint32_t CMD_IND_ERR = (1U << 3);  ///< Command Index Error
        constexpr uint32_t CMD_END_BIT_ERR = (1U << 2);  ///< Command End Bit Error
        constexpr uint32_t CMD_CRC_ERR = (1U << 1);  ///< Command CRC Error
        constexpr uint32_t CMD_TIMEOUT_ERR = (1U << 0);  ///< Command Timeout Error
    }

    /// EN_INT_STATUS_NORM Register bits
    namespace en_int_status_norm_bits {
        constexpr uint32_t FIXED_TO_0 = (1U << 15);  ///< Fixed to 0
        constexpr uint32_t CARD_INT_EN = (1U << 8);  ///< Card Interrupt Status Enable
        constexpr uint32_t CARD_REMOVAL_EN = (1U << 7);  ///< Card Removal Status Enable
        constexpr uint32_t CARD_INS_EN = (1U << 6);  ///< Card Insertion Status Enable
        constexpr uint32_t BUFF_READ_READY_EN = (1U << 5);  ///< Buffer Read Ready Status Enable
        constexpr uint32_t BUFF_WRITE_READY_EN = (1U << 4);  ///< Buffer Write Ready Status Enable
        constexpr uint32_t BLOCK_GAP_EVENT_EN = (1U << 2);  ///< Block Gap Event Status Enable
        constexpr uint32_t TX_COMPLETE_EN = (1U << 1);  ///< Transfer Complete Status Enable
        constexpr uint32_t CMD_COMPLETE_EN = (1U << 0);  ///< Command Complete Status Enable
    }

    /// EN_INT_STATUS_ERR Register bits
    namespace en_int_status_err_bits {
        constexpr uint32_t CEATA_ERR_EN = (1U << 13);  ///< Ceata Error Status Enable
        constexpr uint32_t TARGET_RESP_ERR_EN = (1U << 12);  ///< Target Response Error Status Enable
        constexpr uint32_t ACMD_ERR_EN = (1U << 8);  ///< Auto CMD12 Error Status Enable
        constexpr uint32_t CURRENT_LIMIT_ERR_EN = (1U << 7);  ///< Current Limit Error Status Enable
        constexpr uint32_t DATA_END_BIT_ERR_EN = (1U << 6);  ///< Data End Bit Error Status Enable
        constexpr uint32_t DATA_CRC_ERR_EN = (1U << 5);  ///< Data CRC Error Status Enable
        constexpr uint32_t DATA_TIMEOUT_ERR_EN = (1U << 4);  ///< Data Timeout Error Status Enable
        constexpr uint32_t CMD_IND_ERR_EN = (1U << 3);  ///< Command Index Error Status Enable
        constexpr uint32_t CMD_END_BIT_ERR_EN = (1U << 2);  ///< Command End Bit Error Status Enable
        constexpr uint32_t CMD_CRC_ERR_EN = (1U << 1);  ///< Command CRC Error Status Enable
        constexpr uint32_t CMD_TIMEOUT_ERR_EN = (1U << 0);  ///< Command Timeout Error Status Enable
    }

    /// EN_INT_SIGNAL_NORM Register bits
    namespace en_int_signal_norm_bits {
        constexpr uint32_t FIXED_TO_0 = (1U << 15);  ///< Fixed to 0
        constexpr uint32_t CARD_INT_EN = (1U << 8);  ///< Card Interrupt Signal Enable
        constexpr uint32_t CARD_REMOVAL_EN = (1U << 7);  ///< Card Removal Signal Enable
        constexpr uint32_t CARD_INS_EN = (1U << 6);  ///< Card Insertion Signal Enable
        constexpr uint32_t BUFF_READ_READY_EN = (1U << 5);  ///< Buffer Read Ready Signal Enable
        constexpr uint32_t BUFF_WRITE_READY_EN = (1U << 4);  ///< Buffer Write Ready Signal Enable
        constexpr uint32_t BLOCK_GAP_EVENT_EN = (1U << 2);  ///< Block Gap Event Signal Enable
        constexpr uint32_t TX_COMPLETE_EN = (1U << 1);  ///< Transfer Complete Signal Enable
        constexpr uint32_t CMD_COMPLETE_EN = (1U << 0);  ///< Command Complete Signal Enable
    }

    /// EN_INT_SIGNAL_ERR Register bits
    namespace en_int_signal_err_bits {
        constexpr uint32_t CEATA_ERR_EN = (1U << 13);  ///< Ceata Error Signal Enable
        constexpr uint32_t TARGET_RESP_ERR_EN = (1U << 12);  ///< Target Response Error Signal Enable
        constexpr uint32_t ACMD_ERR_EN = (1U << 8);  ///< Auto CMD12 Error Signal Enable
        constexpr uint32_t CURRENT_LIMIT_ERR_EN = (1U << 7);  ///< Current Limit Error Signal Enable
        constexpr uint32_t DATA_END_BIT_ERR_EN = (1U << 6);  ///< Data End Bit Error Signal Enable
        constexpr uint32_t DATA_CRC_ERR_EN = (1U << 5);  ///< Data CRC Error Signal Enable
        constexpr uint32_t DATA_TIMEOUT_ERR_EN = (1U << 4);  ///< Data Timeout Error Signal Enable
        constexpr uint32_t CMD_IND_ERR_EN = (1U << 3);  ///< Command Index Error Signal Enable
        constexpr uint32_t CMD_END_BIT_ERR_EN = (1U << 2);  ///< Command End Bit Error Signal Enable
        constexpr uint32_t CMD_CRC_ERR_EN = (1U << 1);  ///< Command CRC Error Signal Enable
        constexpr uint32_t CMD_TIMEOUT_ERR_EN = (1U << 0);  ///< Command Timeout Error Signal Enable
    }

    /// ACMD_ERR_STATUS Register bits
    namespace acmd_err_status_bits {
        constexpr uint32_t CMD_NOT_ISSUED_BY_ACMD12_ERR = (1U << 7);  ///< Command Not Issued By Auto CMD12 Error
        constexpr uint32_t ACMD_IND_ERR = (1U << 4);  ///< Auto CMD Index Error
        constexpr uint32_t ACMD_END_BIT_ERR = (1U << 3);  ///< Auto CMD End Bit Error
        constexpr uint32_t ACMD_CRC_ERR = (1U << 2);  ///< Auto CMD CRC Error
        constexpr uint32_t ACMD_TIMEOUT_ERR = (1U << 1);  ///< Auto CMD Timeout Error
        constexpr uint32_t ACMD12_NOT_EXEC_ERR = (1U << 0);  ///< Auto CMD12 Not Executed
    }

    /// CAPABILITIES Register bits
    namespace capabilities_bits {
        constexpr uint32_t TIMEOUT_CLOCK_FREQ = (6 << 0);  ///< Timeout Clock Frequency
        constexpr uint32_t TIMEOUT_CLOCK_UNIT = (1U << 7);  ///< Timeout Clock Unit
        constexpr uint32_t BASE_SD_CLOCK_FREQ = (8 << 8);  ///< Base Clock Frequency for SD Clock
        constexpr uint32_t MAX_BLOCK_LENGTH = (2 << 16);  ///< Max Block Length
        constexpr uint32_t EXT_MEDIA_BUS_SUPPORT = (1U << 18);  ///< Extended Media Bus Support
        constexpr uint32_t ADMA2_SUPPORT = (1U << 19);  ///< ADMA2 Support
        constexpr uint32_t HIGH_SPEED_SUPPORT = (1U << 21);  ///< High Speed Support
        constexpr uint32_t SDMA_SUPPORT = (1U << 22);  ///< SDMA Support
        constexpr uint32_t SUSPEND_RESUME_SUPPORT = (1U << 23);  ///< Suspend / Resume Support
        constexpr uint32_t VOLTAGE_SUPPORT_3_3V = (1U << 24);  ///< Voltage Support 3.3V
        constexpr uint32_t VOLTAGE_SUPPORT_3V = (1U << 25);  ///< Voltage Support 3.0V
        constexpr uint32_t VOLTAGE_SUPPORT_1_8V = (1U << 26);  ///< Voltage Support 1.8V
        constexpr uint32_t SYSBUS_64_SUPPORT = (1U << 28);  ///< 64-bit System Bus Support
        constexpr uint32_t ASYNC_INT_SUPPORT = (1U << 29);  ///< Asynchronous Interrupt Support
        constexpr uint32_t SLOT_TYPE = (2 << 30);  ///< Slot Type
    }

    /// CAPABILITIES_HI Register bits
    namespace capabilities_hi_bits {
        constexpr uint32_t SDR50_SUPPORT = (1U << 0);  ///< SDR50 Support
        constexpr uint32_t SDR104_SUPPORT = (1U << 1);  ///< SDR104 Support
        constexpr uint32_t DDR50_SUPPORT = (1U << 2);  ///< DDR50 Support
        constexpr uint32_t DRV_A_SUPPORT = (1U << 4);  ///< Driver Type A Support
        constexpr uint32_t DRV_C_SUPPORT = (1U << 5);  ///< Driver Type C Support
        constexpr uint32_t DRV_D_SUPPORT = (1U << 6);  ///< Driver Type D Support
        constexpr uint32_t TIM_CNT_RETUNE = (4 << 8);  ///< Timer count for Re-Tuning
        constexpr uint32_t USE_TUNING_SDR50 = (1U << 13);  ///< Use Tuning for SDR50
        constexpr uint32_t RE_TUNING_MODES = (2 << 14);  ///< Re-tuning modes
        constexpr uint32_t CLK_MULT = (8 << 16);  ///< Clock Multiplier
    }

    /// MAX_CURRENT_CAP Register bits
    namespace max_current_cap_bits {
        constexpr uint32_t MAX_CURRENT_FOR_3_3V = (8 << 0);  ///< Maximum Current for 3.3V
    }

    /// FORCE_EVENT_ACMD_ERR_STATUS Register bits
    namespace force_event_acmd_err_status_bits {
        constexpr uint32_t FE_CMD_NOT_ISSUED_ACMD12_ERR = (1U << 7);  ///< Force Event for CMD not issued by Auto CMD12 Error
        constexpr uint32_t FE_ACMD_IND_ERR = (1U << 4);  ///< Force Event for Auto CMD Index Error
        constexpr uint32_t FE_ACMD_END_BIT_ERR = (1U << 3);  ///< Force Event for Auto CMD End bit Error
        constexpr uint32_t FE_ACMD_CRC_ERR = (1U << 2);  ///< Force Event for Auto CMD CRC Error
        constexpr uint32_t FE_ACMD_TIMEOUT_ERR = (1U << 1);  ///< Force Event for Auto CMD timeout Error
        constexpr uint32_t FE_ACMD_NOT_EXEC = (1U << 0);  ///< Force Event for Auto CMD12 NOT Executed
    }

    /// FORCE_EVENT_ERR_STATUS Register bits
    namespace force_event_err_status_bits {
        constexpr uint32_t FE_CEATA_ERR = (1U << 13);  ///< Force Event for Ceata Error
        constexpr uint32_t FE_TARGET_RESPONSE_ERR = (1U << 12);  ///< Force event for Target Response Error
        constexpr uint32_t FE_ACMD12_ERR = (1U << 8);  ///< Force Event for Auto CMD Error
        constexpr uint32_t FE_CURRENT_LIMIT_ERR = (1U << 7);  ///< Force Event for Current Limit Error
        constexpr uint32_t FE_DATA_END_BIT_ERR = (1U << 6);  ///< Force Event for Data End Bit Error
        constexpr uint32_t FE_DATA_CRC_ERR = (1U << 5);  ///< Force Event for Data CRC Error
        constexpr uint32_t FE_DATA_TIMEOUT_ERR = (1U << 4);  ///< Force Event for Data Timeout Error
        constexpr uint32_t FE_CMD_IND_ERR = (1U << 3);  ///< Force Event for Command Index Error
        constexpr uint32_t FE_CMD_END_BIT_ERR = (1U << 2);  ///< Force Event for Command End Bit Error
        constexpr uint32_t FE_CMD_CRC_ERR = (1U << 1);  ///< Force Event for Command CRC Error
        constexpr uint32_t FE_CMD_TIMEOUT_ERR = (1U << 0);  ///< Force Event for Command Timeout Error
    }

    /// DEBUG_SEL Register bits
    namespace debug_sel_bits {
        constexpr uint32_t DEBUG_SEL = (1U << 0);  ///< Debug_sel
    }

    /// SPI Register bits
    namespace spi_bits {
        constexpr uint32_t SPI_INT_SUPPORT = (8 << 0);  ///< SPI INT SUPPORT
    }

    /// SLOT_INT_STATUS Register bits
    namespace slot_int_status_bits {
        constexpr uint32_t SLOT_INT_STATUS = (8 << 0);  ///< Interrupt Signal for Card Slot
    }

}

// ============================================================================
// EBU Peripheral
// ============================================================================

namespace ebu {
    /// Base addresses
    constexpr uint32_t EBU_BASE = 0x58008000;

    /// EBU Register structure
    struct Registers {
        volatile uint32_t CLC;  ///< Offset: 0x00 - EBU Clock Control Register
        volatile uint32_t MODCON;  ///< Offset: 0x04 - EBU Configuration Register
        volatile uint32_t ID;  ///< Offset: 0x08 - EBU Module Identification Register
        volatile uint32_t USERCON;  ///< Offset: 0x0C - EBU Test/Control Configuration Register
        volatile uint32_t ADDRSEL0;  ///< Offset: 0x18 - EBU Address Select Register 0
        volatile uint32_t ADDRSEL1;  ///< Offset: 0x1C - EBU Address Select Register 1
        volatile uint32_t ADDRSEL2;  ///< Offset: 0x20 - EBU Address Select Register 2
        volatile uint32_t ADDRSEL3;  ///< Offset: 0x24 - EBU Address Select Register 3
        volatile uint32_t BUSRCON0;  ///< Offset: 0x28 - EBU Bus Configuration Register
        volatile uint32_t BUSRAP0;  ///< Offset: 0x2C - EBU Bus Read Access Parameter Register
        volatile uint32_t BUSWCON0;  ///< Offset: 0x30 - EBU Bus Write Configuration Register
        volatile uint32_t BUSWAP0;  ///< Offset: 0x34 - EBU Bus Write Access Parameter Register
        volatile uint32_t BUSRCON1;  ///< Offset: 0x38 - EBU Bus Configuration Register
        volatile uint32_t BUSRAP1;  ///< Offset: 0x3C - EBU Bus Read Access Parameter Register
        volatile uint32_t BUSWCON1;  ///< Offset: 0x40 - EBU Bus Write Configuration Register
        volatile uint32_t BUSWAP1;  ///< Offset: 0x44 - EBU Bus Write Access Parameter Register
        volatile uint32_t BUSRCON2;  ///< Offset: 0x48 - EBU Bus Configuration Register
        volatile uint32_t BUSRAP2;  ///< Offset: 0x4C - EBU Bus Read Access Parameter Register
        volatile uint32_t BUSWCON2;  ///< Offset: 0x50 - EBU Bus Write Configuration Register
        volatile uint32_t BUSWAP2;  ///< Offset: 0x54 - EBU Bus Write Access Parameter Register
        volatile uint32_t BUSRCON3;  ///< Offset: 0x58 - EBU Bus Configuration Register
        volatile uint32_t BUSRAP3;  ///< Offset: 0x5C - EBU Bus Read Access Parameter Register
        volatile uint32_t BUSWCON3;  ///< Offset: 0x60 - EBU Bus Write Configuration Register
        volatile uint32_t BUSWAP3;  ///< Offset: 0x64 - EBU Bus Write Access Parameter Register
        volatile uint32_t SDRMCON;  ///< Offset: 0x68 - EBU SDRAM Control Register
        volatile uint32_t SDRMOD;  ///< Offset: 0x6C - EBU SDRAM Mode Register
        volatile uint32_t SDRMREF;  ///< Offset: 0x70 - EBU SDRAM Refresh Control Register
        volatile uint32_t SDRSTAT;  ///< Offset: 0x74 - EBU SDRAM Status Register
    };

    /// Peripheral instances
    inline Registers* EBU = reinterpret_cast<Registers*>(EBU_BASE);

    // Bit definitions
    /// CLC Register bits
    namespace clc_bits {
        constexpr uint32_t DISR = (1U << 0);  ///< EBU Disable Request Bit
        constexpr uint32_t DISS = (1U << 1);  ///< EBU Disable Status Bit
        constexpr uint32_t SYNC = (1U << 16);  ///< EBU Clocking Mode
        constexpr uint32_t DIV2 = (1U << 17);  ///< DIV2 Clocking Mode
        constexpr uint32_t EBUDIV = (2 << 18);  ///< EBU Clock Divide Ratio
        constexpr uint32_t SYNCACK = (1U << 20);  ///< EBU Clocking Mode Status
        constexpr uint32_t DIV2ACK = (1U << 21);  ///< DIV2 Clocking Mode Status
        constexpr uint32_t EBUDIVACK = (2 << 22);  ///< EBU Clock Divide Ratio Status
    }

    /// MODCON Register bits
    namespace modcon_bits {
        constexpr uint32_t STS = (1U << 0);  ///< Memory Status Bit
        constexpr uint32_t LCKABRT = (1U << 1);  ///< Lock Abort
        constexpr uint32_t SDTRI = (1U << 2);  ///< SDRAM Tristate
        constexpr uint32_t EXTLOCK = (1U << 4);  ///< External Bus Lock Control
        constexpr uint32_t ARBSYNC = (1U << 5);  ///< Arbitration Signal Synchronization Control
        constexpr uint32_t ARBMODE = (2 << 6);  ///< Arbitration Mode Selection
        constexpr uint32_t TIMEOUTC = (8 << 8);  ///< Bus Time-out Control
        constexpr uint32_t LOCKTIMEOUT = (8 << 16);  ///< Lock Timeout Counter Preload
        constexpr uint32_t GLOBALCS = (4 << 24);  ///< Global Chip Select Enable
        constexpr uint32_t ACCSINH = (1U << 28);  ///< Access Inhibit request
        constexpr uint32_t ACCSINHACK = (1U << 29);  ///< Access inhibit acknowledge
        constexpr uint32_t ALE = (1U << 31);  ///< ALE Mode
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// USERCON Register bits
    namespace usercon_bits {
        constexpr uint32_t DIP = (1U << 0);  ///< Disable Internal Pipelining
        constexpr uint32_t ADDIO = (9 << 16);  ///< Address Pins to GPIO Mode
        constexpr uint32_t ADVIO = (1U << 25);  ///< ADV Pin to GPIO Mode
    }

    /// ADDRSEL0 Register bits
    namespace addrsel0_bits {
        constexpr uint32_t REGENAB = (1U << 0);  ///< Memory Region Enable
        constexpr uint32_t ALTENAB = (1U << 1);  ///< Alternate Region Enable
        constexpr uint32_t WPROT = (1U << 2);  ///< Memory Region Write Protect
    }

    /// ADDRSEL1 Register bits
    namespace addrsel1_bits {
        constexpr uint32_t REGENAB = (1U << 0);  ///< Memory Region Enable
        constexpr uint32_t ALTENAB = (1U << 1);  ///< Alternate Region Enable
        constexpr uint32_t WPROT = (1U << 2);  ///< Memory Region Write Protect
    }

    /// ADDRSEL2 Register bits
    namespace addrsel2_bits {
        constexpr uint32_t REGENAB = (1U << 0);  ///< Memory Region Enable
        constexpr uint32_t ALTENAB = (1U << 1);  ///< Alternate Region Enable
        constexpr uint32_t WPROT = (1U << 2);  ///< Memory Region Write Protect
    }

    /// ADDRSEL3 Register bits
    namespace addrsel3_bits {
        constexpr uint32_t REGENAB = (1U << 0);  ///< Memory Region Enable
        constexpr uint32_t ALTENAB = (1U << 1);  ///< Alternate Region Enable
        constexpr uint32_t WPROT = (1U << 2);  ///< Memory Region Write Protect
    }

    /// BUSRCON0 Register bits
    namespace busrcon0_bits {
        constexpr uint32_t FETBLEN = (3 << 0);  ///< Burst Length for Synchronous Burst
        constexpr uint32_t FBBMSEL = (1U << 3);  ///< Synchronous burst buffer mode select
        constexpr uint32_t BFSSS = (1U << 4);  ///< Read Single Stage Synchronization:
        constexpr uint32_t FDBKEN = (1U << 5);  ///< Burst FLASH Clock Feedback Enable
        constexpr uint32_t BFCMSEL = (1U << 6);  ///< Burst Flash Clock Mode Select
        constexpr uint32_t NAA = (1U << 7);  ///< Enable flash non-array access workaround
        constexpr uint32_t ECSE = (1U << 16);  ///< Early Chip Select for Synchronous Burst
        constexpr uint32_t EBSE = (1U << 17);  ///< Early Burst Signal Enable for Synchronous Burst
        constexpr uint32_t DBA = (1U << 18);  ///< Disable Burst Address Wrapping
        constexpr uint32_t WAITINV = (1U << 19);  ///< Reversed polarity at WAIT
        constexpr uint32_t BCGEN = (2 << 20);  ///< Byte Control Signal Control
        constexpr uint32_t PORTW = (2 << 22);  ///< Device Addressing Mode
        constexpr uint32_t WAIT = (2 << 24);  ///< External Wait Control: 0=OFF (default after reset)., 1=Asynchronous input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for page load (WAIT with data)., 3=Abort and retry access.,
        constexpr uint32_t AAP = (1U << 26);  ///< Asynchronous Address phase:
        constexpr uint32_t AGEN = (4 << 28);  ///< Device Type for Region
    }

    /// BUSRAP0 Register bits
    namespace busrap0_bits {
        constexpr uint32_t RDDTACS = (4 << 0);  ///< Recovery Cycles between Different Regions
        constexpr uint32_t RDRECOVC = (3 << 4);  ///< Recovery Cycles after Read Accesses
        constexpr uint32_t WAITRDC = (5 << 7);  ///< Programmed Wait States for read accesses
        constexpr uint32_t DATAC = (4 << 12);  ///< Data Hold Cycles for Read Accesses
        constexpr uint32_t EXTCLOCK = (2 << 16);  ///< Frequency of external clock at pin BFCLKO
        constexpr uint32_t EXTDATA = (2 << 18);  ///< Extended data
        constexpr uint32_t CMDDELAY = (4 << 20);  ///< Command Delay Cycles
        constexpr uint32_t AHOLDC = (4 << 24);  ///< Address Hold Cycles
        constexpr uint32_t ADDRC = (4 << 28);  ///< Address Cycles
    }

    /// BUSWCON0 Register bits
    namespace buswcon0_bits {
        constexpr uint32_t FETBLEN = (3 << 0);  ///< Burst Length for Synchronous Burst
        constexpr uint32_t FBBMSEL = (1U << 3);  ///< Synchronous burst buffer mode select
        constexpr uint32_t NAA = (1U << 7);  ///< Enable flash non-array access workaround
        constexpr uint32_t ECSE = (1U << 16);  ///< Early Chip Select for Synchronous Burst
        constexpr uint32_t EBSE = (1U << 17);  ///< Early Burst Signal Enable for Synchronous Burst
        constexpr uint32_t WAITINV = (1U << 19);  ///< Reversed polarity at WAIT
        constexpr uint32_t BCGEN = (2 << 20);  ///< Byte Control Signal Control
        constexpr uint32_t PORTW = (2 << 22);  ///< Device Addressing Mode
        constexpr uint32_t WAIT = (2 << 24);  ///< External Wait Control: 0=OFF (default after reset)., 1=Asynchronous input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for page load (WAIT with data)., 3=Abort and retry access.,
        constexpr uint32_t AAP = (1U << 26);  ///< Asynchronous Address phase:
        constexpr uint32_t LOCKCS = (1U << 27);  ///< Lock Chip Select
        constexpr uint32_t AGEN = (4 << 28);  ///< Device Type for Region
    }

    /// BUSWAP0 Register bits
    namespace buswap0_bits {
        constexpr uint32_t WRDTACS = (4 << 0);  ///< Recovery Cycles between Different Regions
        constexpr uint32_t WRRECOVC = (3 << 4);  ///< Recovery Cycles after Write Accesses
        constexpr uint32_t WAITWRC = (5 << 7);  ///< Programmed Wait States for write accesses
        constexpr uint32_t DATAC = (4 << 12);  ///< Data Hold Cycles for Write Accesses
        constexpr uint32_t EXTCLOCK = (2 << 16);  ///< Frequency of external clock at pin BFCLKO
        constexpr uint32_t EXTDATA = (2 << 18);  ///< Extended data
        constexpr uint32_t CMDDELAY = (4 << 20);  ///< Command Delay Cycles
        constexpr uint32_t AHOLDC = (4 << 24);  ///< Address Hold Cycles
        constexpr uint32_t ADDRC = (4 << 28);  ///< Address Cycles
    }

    /// BUSRCON1 Register bits
    namespace busrcon1_bits {
        constexpr uint32_t FETBLEN = (3 << 0);  ///< Burst Length for Synchronous Burst
        constexpr uint32_t FBBMSEL = (1U << 3);  ///< Synchronous burst buffer mode select
        constexpr uint32_t BFSSS = (1U << 4);  ///< Read Single Stage Synchronization:
        constexpr uint32_t FDBKEN = (1U << 5);  ///< Burst FLASH Clock Feedback Enable
        constexpr uint32_t BFCMSEL = (1U << 6);  ///< Burst Flash Clock Mode Select
        constexpr uint32_t NAA = (1U << 7);  ///< Enable flash non-array access workaround
        constexpr uint32_t ECSE = (1U << 16);  ///< Early Chip Select for Synchronous Burst
        constexpr uint32_t EBSE = (1U << 17);  ///< Early Burst Signal Enable for Synchronous Burst
        constexpr uint32_t DBA = (1U << 18);  ///< Disable Burst Address Wrapping
        constexpr uint32_t WAITINV = (1U << 19);  ///< Reversed polarity at WAIT
        constexpr uint32_t BCGEN = (2 << 20);  ///< Byte Control Signal Control
        constexpr uint32_t PORTW = (2 << 22);  ///< Device Addressing Mode
        constexpr uint32_t WAIT = (2 << 24);  ///< External Wait Control: 0=OFF (default after reset)., 1=Asynchronous input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for page load (WAIT with data)., 3=Abort and retry access.,
        constexpr uint32_t AAP = (1U << 26);  ///< Asynchronous Address phase:
        constexpr uint32_t AGEN = (4 << 28);  ///< Device Type for Region
    }

    /// BUSRAP1 Register bits
    namespace busrap1_bits {
        constexpr uint32_t RDDTACS = (4 << 0);  ///< Recovery Cycles between Different Regions
        constexpr uint32_t RDRECOVC = (3 << 4);  ///< Recovery Cycles after Read Accesses
        constexpr uint32_t WAITRDC = (5 << 7);  ///< Programmed Wait States for read accesses
        constexpr uint32_t DATAC = (4 << 12);  ///< Data Hold Cycles for Read Accesses
        constexpr uint32_t EXTCLOCK = (2 << 16);  ///< Frequency of external clock at pin BFCLKO
        constexpr uint32_t EXTDATA = (2 << 18);  ///< Extended data
        constexpr uint32_t CMDDELAY = (4 << 20);  ///< Command Delay Cycles
        constexpr uint32_t AHOLDC = (4 << 24);  ///< Address Hold Cycles
        constexpr uint32_t ADDRC = (4 << 28);  ///< Address Cycles
    }

    /// BUSWCON1 Register bits
    namespace buswcon1_bits {
        constexpr uint32_t FETBLEN = (3 << 0);  ///< Burst Length for Synchronous Burst
        constexpr uint32_t FBBMSEL = (1U << 3);  ///< Synchronous burst buffer mode select
        constexpr uint32_t NAA = (1U << 7);  ///< Enable flash non-array access workaround
        constexpr uint32_t ECSE = (1U << 16);  ///< Early Chip Select for Synchronous Burst
        constexpr uint32_t EBSE = (1U << 17);  ///< Early Burst Signal Enable for Synchronous Burst
        constexpr uint32_t WAITINV = (1U << 19);  ///< Reversed polarity at WAIT
        constexpr uint32_t BCGEN = (2 << 20);  ///< Byte Control Signal Control
        constexpr uint32_t PORTW = (2 << 22);  ///< Device Addressing Mode
        constexpr uint32_t WAIT = (2 << 24);  ///< External Wait Control: 0=OFF (default after reset)., 1=Asynchronous input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for page load (WAIT with data)., 3=Abort and retry access.,
        constexpr uint32_t AAP = (1U << 26);  ///< Asynchronous Address phase:
        constexpr uint32_t LOCKCS = (1U << 27);  ///< Lock Chip Select
        constexpr uint32_t AGEN = (4 << 28);  ///< Device Type for Region
    }

    /// BUSWAP1 Register bits
    namespace buswap1_bits {
        constexpr uint32_t WRDTACS = (4 << 0);  ///< Recovery Cycles between Different Regions
        constexpr uint32_t WRRECOVC = (3 << 4);  ///< Recovery Cycles after Write Accesses
        constexpr uint32_t WAITWRC = (5 << 7);  ///< Programmed Wait States for write accesses
        constexpr uint32_t DATAC = (4 << 12);  ///< Data Hold Cycles for Write Accesses
        constexpr uint32_t EXTCLOCK = (2 << 16);  ///< Frequency of external clock at pin BFCLKO
        constexpr uint32_t EXTDATA = (2 << 18);  ///< Extended data
        constexpr uint32_t CMDDELAY = (4 << 20);  ///< Command Delay Cycles
        constexpr uint32_t AHOLDC = (4 << 24);  ///< Address Hold Cycles
        constexpr uint32_t ADDRC = (4 << 28);  ///< Address Cycles
    }

    /// BUSRCON2 Register bits
    namespace busrcon2_bits {
        constexpr uint32_t FETBLEN = (3 << 0);  ///< Burst Length for Synchronous Burst
        constexpr uint32_t FBBMSEL = (1U << 3);  ///< Synchronous burst buffer mode select
        constexpr uint32_t BFSSS = (1U << 4);  ///< Read Single Stage Synchronization:
        constexpr uint32_t FDBKEN = (1U << 5);  ///< Burst FLASH Clock Feedback Enable
        constexpr uint32_t BFCMSEL = (1U << 6);  ///< Burst Flash Clock Mode Select
        constexpr uint32_t NAA = (1U << 7);  ///< Enable flash non-array access workaround
        constexpr uint32_t ECSE = (1U << 16);  ///< Early Chip Select for Synchronous Burst
        constexpr uint32_t EBSE = (1U << 17);  ///< Early Burst Signal Enable for Synchronous Burst
        constexpr uint32_t DBA = (1U << 18);  ///< Disable Burst Address Wrapping
        constexpr uint32_t WAITINV = (1U << 19);  ///< Reversed polarity at WAIT
        constexpr uint32_t BCGEN = (2 << 20);  ///< Byte Control Signal Control
        constexpr uint32_t PORTW = (2 << 22);  ///< Device Addressing Mode
        constexpr uint32_t WAIT = (2 << 24);  ///< External Wait Control: 0=OFF (default after reset)., 1=Asynchronous input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for page load (WAIT with data)., 3=Abort and retry access.,
        constexpr uint32_t AAP = (1U << 26);  ///< Asynchronous Address phase:
        constexpr uint32_t AGEN = (4 << 28);  ///< Device Type for Region
    }

    /// BUSRAP2 Register bits
    namespace busrap2_bits {
        constexpr uint32_t RDDTACS = (4 << 0);  ///< Recovery Cycles between Different Regions
        constexpr uint32_t RDRECOVC = (3 << 4);  ///< Recovery Cycles after Read Accesses
        constexpr uint32_t WAITRDC = (5 << 7);  ///< Programmed Wait States for read accesses
        constexpr uint32_t DATAC = (4 << 12);  ///< Data Hold Cycles for Read Accesses
        constexpr uint32_t EXTCLOCK = (2 << 16);  ///< Frequency of external clock at pin BFCLKO
        constexpr uint32_t EXTDATA = (2 << 18);  ///< Extended data
        constexpr uint32_t CMDDELAY = (4 << 20);  ///< Command Delay Cycles
        constexpr uint32_t AHOLDC = (4 << 24);  ///< Address Hold Cycles
        constexpr uint32_t ADDRC = (4 << 28);  ///< Address Cycles
    }

    /// BUSWCON2 Register bits
    namespace buswcon2_bits {
        constexpr uint32_t FETBLEN = (3 << 0);  ///< Burst Length for Synchronous Burst
        constexpr uint32_t FBBMSEL = (1U << 3);  ///< Synchronous burst buffer mode select
        constexpr uint32_t NAA = (1U << 7);  ///< Enable flash non-array access workaround
        constexpr uint32_t ECSE = (1U << 16);  ///< Early Chip Select for Synchronous Burst
        constexpr uint32_t EBSE = (1U << 17);  ///< Early Burst Signal Enable for Synchronous Burst
        constexpr uint32_t WAITINV = (1U << 19);  ///< Reversed polarity at WAIT
        constexpr uint32_t BCGEN = (2 << 20);  ///< Byte Control Signal Control
        constexpr uint32_t PORTW = (2 << 22);  ///< Device Addressing Mode
        constexpr uint32_t WAIT = (2 << 24);  ///< External Wait Control: 0=OFF (default after reset)., 1=Asynchronous input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for page load (WAIT with data)., 3=Abort and retry access.,
        constexpr uint32_t AAP = (1U << 26);  ///< Asynchronous Address phase:
        constexpr uint32_t LOCKCS = (1U << 27);  ///< Lock Chip Select
        constexpr uint32_t AGEN = (4 << 28);  ///< Device Type for Region
    }

    /// BUSWAP2 Register bits
    namespace buswap2_bits {
        constexpr uint32_t WRDTACS = (4 << 0);  ///< Recovery Cycles between Different Regions
        constexpr uint32_t WRRECOVC = (3 << 4);  ///< Recovery Cycles after Write Accesses
        constexpr uint32_t WAITWRC = (5 << 7);  ///< Programmed Wait States for write accesses
        constexpr uint32_t DATAC = (4 << 12);  ///< Data Hold Cycles for Write Accesses
        constexpr uint32_t EXTCLOCK = (2 << 16);  ///< Frequency of external clock at pin BFCLKO
        constexpr uint32_t EXTDATA = (2 << 18);  ///< Extended data
        constexpr uint32_t CMDDELAY = (4 << 20);  ///< Command Delay Cycles
        constexpr uint32_t AHOLDC = (4 << 24);  ///< Address Hold Cycles
        constexpr uint32_t ADDRC = (4 << 28);  ///< Address Cycles
    }

    /// BUSRCON3 Register bits
    namespace busrcon3_bits {
        constexpr uint32_t FETBLEN = (3 << 0);  ///< Burst Length for Synchronous Burst
        constexpr uint32_t FBBMSEL = (1U << 3);  ///< Synchronous burst buffer mode select
        constexpr uint32_t BFSSS = (1U << 4);  ///< Read Single Stage Synchronization:
        constexpr uint32_t FDBKEN = (1U << 5);  ///< Burst FLASH Clock Feedback Enable
        constexpr uint32_t BFCMSEL = (1U << 6);  ///< Burst Flash Clock Mode Select
        constexpr uint32_t NAA = (1U << 7);  ///< Enable flash non-array access workaround
        constexpr uint32_t ECSE = (1U << 16);  ///< Early Chip Select for Synchronous Burst
        constexpr uint32_t EBSE = (1U << 17);  ///< Early Burst Signal Enable for Synchronous Burst
        constexpr uint32_t DBA = (1U << 18);  ///< Disable Burst Address Wrapping
        constexpr uint32_t WAITINV = (1U << 19);  ///< Reversed polarity at WAIT
        constexpr uint32_t BCGEN = (2 << 20);  ///< Byte Control Signal Control
        constexpr uint32_t PORTW = (2 << 22);  ///< Device Addressing Mode
        constexpr uint32_t WAIT = (2 << 24);  ///< External Wait Control: 0=OFF (default after reset)., 1=Asynchronous input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for page load (WAIT with data)., 3=Abort and retry access.,
        constexpr uint32_t AAP = (1U << 26);  ///< Asynchronous Address phase:
        constexpr uint32_t AGEN = (4 << 28);  ///< Device Type for Region
    }

    /// BUSRAP3 Register bits
    namespace busrap3_bits {
        constexpr uint32_t RDDTACS = (4 << 0);  ///< Recovery Cycles between Different Regions
        constexpr uint32_t RDRECOVC = (3 << 4);  ///< Recovery Cycles after Read Accesses
        constexpr uint32_t WAITRDC = (5 << 7);  ///< Programmed Wait States for read accesses
        constexpr uint32_t DATAC = (4 << 12);  ///< Data Hold Cycles for Read Accesses
        constexpr uint32_t EXTCLOCK = (2 << 16);  ///< Frequency of external clock at pin BFCLKO
        constexpr uint32_t EXTDATA = (2 << 18);  ///< Extended data
        constexpr uint32_t CMDDELAY = (4 << 20);  ///< Command Delay Cycles
        constexpr uint32_t AHOLDC = (4 << 24);  ///< Address Hold Cycles
        constexpr uint32_t ADDRC = (4 << 28);  ///< Address Cycles
    }

    /// BUSWCON3 Register bits
    namespace buswcon3_bits {
        constexpr uint32_t FETBLEN = (3 << 0);  ///< Burst Length for Synchronous Burst
        constexpr uint32_t FBBMSEL = (1U << 3);  ///< Synchronous burst buffer mode select
        constexpr uint32_t NAA = (1U << 7);  ///< Enable flash non-array access workaround
        constexpr uint32_t ECSE = (1U << 16);  ///< Early Chip Select for Synchronous Burst
        constexpr uint32_t EBSE = (1U << 17);  ///< Early Burst Signal Enable for Synchronous Burst
        constexpr uint32_t WAITINV = (1U << 19);  ///< Reversed polarity at WAIT
        constexpr uint32_t BCGEN = (2 << 20);  ///< Byte Control Signal Control
        constexpr uint32_t PORTW = (2 << 22);  ///< Device Addressing Mode
        constexpr uint32_t WAIT = (2 << 24);  ///< External Wait Control: 0=OFF (default after reset)., 1=Asynchronous input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for page load (WAIT with data)., 3=Abort and retry access.,
        constexpr uint32_t AAP = (1U << 26);  ///< Asynchronous Address phase:
        constexpr uint32_t LOCKCS = (1U << 27);  ///< Lock Chip Select
        constexpr uint32_t AGEN = (4 << 28);  ///< Device Type for Region
    }

    /// BUSWAP3 Register bits
    namespace buswap3_bits {
        constexpr uint32_t WRDTACS = (4 << 0);  ///< Recovery Cycles between Different Regions
        constexpr uint32_t WRRECOVC = (3 << 4);  ///< Recovery Cycles after Write Accesses
        constexpr uint32_t WAITWRC = (5 << 7);  ///< Programmed Wait States for write accesses
        constexpr uint32_t DATAC = (4 << 12);  ///< Data Hold Cycles for Write Accesses
        constexpr uint32_t EXTCLOCK = (2 << 16);  ///< Frequency of external clock at pin BFCLKO
        constexpr uint32_t EXTDATA = (2 << 18);  ///< Extended data
        constexpr uint32_t CMDDELAY = (4 << 20);  ///< Command Delay Cycles
        constexpr uint32_t AHOLDC = (4 << 24);  ///< Address Hold Cycles
        constexpr uint32_t ADDRC = (4 << 28);  ///< Address Cycles
    }

    /// SDRMCON Register bits
    namespace sdrmcon_bits {
        constexpr uint32_t SDCMSEL = (1U << 31);  ///< SDRAM clock mode select
        constexpr uint32_t PWR_MODE = (2 << 29);  ///< Power Save Mode used for gated clock mode
        constexpr uint32_t CLKDIS = (1U << 28);  ///< Disable SDRAM clock output
        constexpr uint32_t CRCE = (3 << 25);  ///< Row cycle time counter extension
        constexpr uint32_t BANKM = (3 << 22);  ///< Mask for bank tag
        constexpr uint32_t ROWM = (3 << 19);  ///< Mask for row tag
        constexpr uint32_t CRC = (3 << 16);  ///< Row cycle time counter
        constexpr uint32_t CRCD = (2 << 14);  ///< Row to column delay counter
        constexpr uint32_t AWIDTH = (2 << 12);  ///< Width of column address
        constexpr uint32_t CRP = (2 << 10);  ///< Row precharge time counter
        constexpr uint32_t CRSC = (2 << 8);  ///< Mode register set-up time
        constexpr uint32_t CRFSH = (4 << 4);  ///< Initialization refresh commands counter
        constexpr uint32_t CRAS = (4 << 0);  ///< Row to precharge delay counter
    }

    /// SDRMOD Register bits
    namespace sdrmod_bits {
        constexpr uint32_t XBA = (4 << 28);  ///< Extended Operation Bank Select
        constexpr uint32_t XOPM = (12 << 16);  ///< Extended Operation Mode
        constexpr uint32_t COLDSTART = (1U << 15);  ///< SDRAM coldstart
        constexpr uint32_t OPMODE = (7 << 7);  ///< Operation Mode
        constexpr uint32_t CASLAT = (3 << 4);  ///< CAS latency
        constexpr uint32_t BTYP = (1U << 3);  ///< Burst type
        constexpr uint32_t BURSTL = (3 << 0);  ///< Burst length
    }

    /// SDRMREF Register bits
    namespace sdrmref_bits {
        constexpr uint32_t RES_DLY = (3 << 25);  ///< Delay on Power Down Exit
        constexpr uint32_t ARFSH = (1U << 24);  ///< Auto Refresh on Self refresh Exit
        constexpr uint32_t SELFREX_DLY = (8 << 16);  ///< Self Refresh Exit Delay
        constexpr uint32_t ERFSHC = (2 << 14);  ///< Extended Refresh Counter Period
        constexpr uint32_t AUTOSELFR = (1U << 13);  ///< Automatic Self Refresh
        constexpr uint32_t SELFREN = (1U << 12);  ///< Self Refresh Entry
        constexpr uint32_t SELFRENST = (1U << 11);  ///< Self Refresh Entry Status.
        constexpr uint32_t SELFREX = (1U << 10);  ///< Self Refresh Exit (Power Up).
        constexpr uint32_t SELFREXST = (1U << 9);  ///< Self Refresh Exit Status.
        constexpr uint32_t REFRESHR = (3 << 6);  ///< Number of refresh commands
        constexpr uint32_t REFRESHC = (6 << 0);  ///< Refresh counter period
    }

    /// SDRSTAT Register bits
    namespace sdrstat_bits {
        constexpr uint32_t SDERR = (1U << 2);  ///< SDRAM read error
        constexpr uint32_t SDRMBUSY = (1U << 1);  ///< SDRAM Busy
        constexpr uint32_t REFERR = (1U << 0);  ///< SDRAM Refresh Error
    }

}

// ============================================================================
// ETH Peripheral
// ============================================================================

namespace eth {
    /// Base addresses
    constexpr uint32_t ETH0_CON_BASE = 0x50004040;
    constexpr uint32_t ETH0_BASE = 0x5000C000;

    /// ETH Register structure
    struct Registers {
        volatile uint32_t ETH0_CON;  ///< Offset: 0x00 - Ethernet 0 Port Control Register
    };

    /// Peripheral instances
    inline Registers* ETH0_CON = reinterpret_cast<Registers*>(ETH0_CON_BASE);
    inline Registers* ETH0 = reinterpret_cast<Registers*>(ETH0_BASE);

    // Bit definitions
    /// ETH0_CON Register bits
    namespace eth0_con_bits {
        constexpr uint32_t RXD0 = (2 << 0);  ///< MAC Receive Input 0
        constexpr uint32_t RXD1 = (2 << 2);  ///< MAC Receive Input 1
        constexpr uint32_t RXD2 = (2 << 4);  ///< MAC Receive Input 2
        constexpr uint32_t RXD3 = (2 << 6);  ///< MAC Receive Input 3
        constexpr uint32_t CLK_RMII = (2 << 8);  ///< RMII clock input
        constexpr uint32_t CRS_DV = (2 << 10);  ///< CRS_DV input
        constexpr uint32_t CRS = (2 << 12);  ///< CRS input
        constexpr uint32_t RXER = (2 << 14);  ///< RXER Input
        constexpr uint32_t COL = (2 << 16);  ///< COL input
        constexpr uint32_t CLK_TX = (2 << 18);  ///< CLK_TX input
        constexpr uint32_t MDIO = (2 << 22);  ///< MDIO Input Select
        constexpr uint32_t INFSEL = (1U << 26);  ///< Ethernet MAC Interface Selection
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB0_BASE = 0x50040000;
    constexpr uint32_t USB0_EP0_BASE = 0x50040900;
    constexpr uint32_t USB0_EP1_BASE = 0x50040920;
    constexpr uint32_t USB0_EP2_BASE = 0x50040940;
    constexpr uint32_t USB0_EP3_BASE = 0x50040960;
    constexpr uint32_t USB0_EP4_BASE = 0x50040980;
    constexpr uint32_t USB0_EP5_BASE = 0x500409A0;
    constexpr uint32_t USB0_EP6_BASE = 0x500409C0;
    constexpr uint32_t USB0_CH0_BASE = 0x50040500;
    constexpr uint32_t USB0_CH1_BASE = 0x50040520;
    constexpr uint32_t USB0_CH2_BASE = 0x50040540;
    constexpr uint32_t USB0_CH3_BASE = 0x50040560;
    constexpr uint32_t USB0_CH4_BASE = 0x50040580;
    constexpr uint32_t USB0_CH5_BASE = 0x500405A0;
    constexpr uint32_t USB0_CH6_BASE = 0x500405C0;
    constexpr uint32_t USB0_CH7_BASE = 0x500405E0;
    constexpr uint32_t USB0_CH8_BASE = 0x50040600;
    constexpr uint32_t USB0_CH9_BASE = 0x50040620;
    constexpr uint32_t USB0_CH10_BASE = 0x50040640;
    constexpr uint32_t USB0_CH11_BASE = 0x50040660;
    constexpr uint32_t USB0_CH12_BASE = 0x50040680;
    constexpr uint32_t USB0_CH13_BASE = 0x500406A0;

    /// USB Register structure
    struct Registers {
        volatile uint32_t GOTGCTL;  ///< Offset: 0x00 - Control and Status Register
        volatile uint32_t GOTGINT;  ///< Offset: 0x04 - OTG Interrupt Register
        volatile uint32_t GAHBCFG;  ///< Offset: 0x08 - AHB Configuration Register
        volatile uint32_t GUSBCFG;  ///< Offset: 0x0C - USB Configuration Register
        volatile uint32_t GRSTCTL;  ///< Offset: 0x10 - Reset Register
        volatile uint32_t GINTSTS_HOSTMODE;  ///< Offset: 0x14 - Interrupt Register [HOSTMODE]
        volatile uint32_t GINTSTS_DEVICEMODE;  ///< Offset: 0x14 - Interrupt Register [DEVICEMODE]
        volatile uint32_t GINTMSK_HOSTMODE;  ///< Offset: 0x18 - Interrupt Mask Register [HOSTMODE]
        volatile uint32_t GINTMSK_DEVICEMODE;  ///< Offset: 0x18 - Interrupt Mask Register [DEVICEMODE]
        volatile uint32_t GRXSTSR_HOSTMODE;  ///< Offset: 0x1C - Receive Status Debug Read Register [HOSTMODE]
        volatile uint32_t GRXSTSR_DEVICEMODE;  ///< Offset: 0x1C - Receive Status Debug Read Register [DEVICEMODE]
        volatile uint32_t GRXSTSP_HOSTMODE;  ///< Offset: 0x20 - Receive Status Read and Pop Register [HOSTMODE]
        volatile uint32_t GRXSTSP_DEVICEMODE;  ///< Offset: 0x20 - Receive Status Read and Pop Register [DEVICEMODE]
        volatile uint32_t GRXFSIZ;  ///< Offset: 0x24 - Receive FIFO Size Register
        volatile uint32_t GNPTXFSIZ_HOSTMODE;  ///< Offset: 0x28 - Non-Periodic Transmit FIFO Size Register [HOSTMODE]
        volatile uint32_t GNPTXFSIZ_DEVICEMODE;  ///< Offset: 0x28 - Non-Periodic Transmit FIFO Size Register [DEVICEMODE]
        volatile uint32_t GNPTXSTS;  ///< Offset: 0x2C - Non-Periodic Transmit FIFO/Queue Status Register
        volatile uint32_t GUID;  ///< Offset: 0x3C - USB Module Identification Register
        volatile uint32_t GDFIFOCFG;  ///< Offset: 0x5C - Global DFIFO Software Config Register
        volatile uint32_t HPTXFSIZ;  ///< Offset: 0x100 - Host Periodic Transmit FIFO Size Register
        volatile uint32_t DIEPTXF1;  ///< Offset: 0x104 - Device IN Endpoint 1 Transmit FIFO Size Register
        volatile uint32_t DIEPTXF2;  ///< Offset: 0x108 - Device IN Endpoint 2 Transmit FIFO Size Register
        volatile uint32_t DIEPTXF3;  ///< Offset: 0x10C - Device IN Endpoint 3 Transmit FIFO Size Register
        volatile uint32_t DIEPTXF4;  ///< Offset: 0x110 - Device IN Endpoint 4 Transmit FIFO Size Register
        volatile uint32_t DIEPTXF5;  ///< Offset: 0x114 - Device IN Endpoint 5 Transmit FIFO Size Register
        volatile uint32_t DIEPTXF6;  ///< Offset: 0x118 - Device IN Endpoint 6 Transmit FIFO Size Register
        volatile uint32_t HCFG;  ///< Offset: 0x400 - Host Configuration Register
        volatile uint32_t HFIR;  ///< Offset: 0x404 - Host Frame Interval Register
        volatile uint32_t HFNUM;  ///< Offset: 0x408 - Host Frame Number/Frame Time Remaining Register
        volatile uint32_t HPTXSTS;  ///< Offset: 0x410 - Host Periodic Transmit FIFO/ Queue Status Register
        volatile uint32_t HAINT;  ///< Offset: 0x414 - Host All Channels Interrupt Register
        volatile uint32_t HAINTMSK;  ///< Offset: 0x418 - Host All Channels Interrupt Mask Register
        volatile uint32_t HFLBADDR;  ///< Offset: 0x41C - Host Frame List Base Address Register
        volatile uint32_t HPRT;  ///< Offset: 0x440 - Host Port Control and Status Register
        volatile uint32_t DCFG;  ///< Offset: 0x800 - Device Configuration Register
        volatile uint32_t DCTL;  ///< Offset: 0x804 - Device Control Register
        volatile uint32_t DSTS;  ///< Offset: 0x808 - Device Status Register
        volatile uint32_t DIEPMSK;  ///< Offset: 0x810 - Device IN Endpoint Common Interrupt Mask Register
        volatile uint32_t DOEPMSK;  ///< Offset: 0x814 - Device OUT Endpoint Common Interrupt Mask Register
        volatile uint32_t DAINT;  ///< Offset: 0x818 - Device All Endpoints Interrupt Register
        volatile uint32_t DAINTMSK;  ///< Offset: 0x81C - Device All Endpoints Interrupt Mask Register
        volatile uint32_t DVBUSDIS;  ///< Offset: 0x828 - Device VBUS Discharge Time Register
        volatile uint32_t DVBUSPULSE;  ///< Offset: 0x82C - Device VBUS Pulsing Time Register
        volatile uint32_t DIEPEMPMSK;  ///< Offset: 0x834 - Device IN Endpoint FIFO Empty Interrupt Mask Register
        volatile uint32_t PCGCCTL;  ///< Offset: 0xE00 - Power and Clock Gating Control Register
    };

    /// Peripheral instances
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);
    inline Registers* USB0_EP0 = reinterpret_cast<Registers*>(USB0_EP0_BASE);
    inline Registers* USB0_EP1 = reinterpret_cast<Registers*>(USB0_EP1_BASE);
    inline Registers* USB0_EP2 = reinterpret_cast<Registers*>(USB0_EP2_BASE);
    inline Registers* USB0_EP3 = reinterpret_cast<Registers*>(USB0_EP3_BASE);
    inline Registers* USB0_EP4 = reinterpret_cast<Registers*>(USB0_EP4_BASE);
    inline Registers* USB0_EP5 = reinterpret_cast<Registers*>(USB0_EP5_BASE);
    inline Registers* USB0_EP6 = reinterpret_cast<Registers*>(USB0_EP6_BASE);
    inline Registers* USB0_CH0 = reinterpret_cast<Registers*>(USB0_CH0_BASE);
    inline Registers* USB0_CH1 = reinterpret_cast<Registers*>(USB0_CH1_BASE);
    inline Registers* USB0_CH2 = reinterpret_cast<Registers*>(USB0_CH2_BASE);
    inline Registers* USB0_CH3 = reinterpret_cast<Registers*>(USB0_CH3_BASE);
    inline Registers* USB0_CH4 = reinterpret_cast<Registers*>(USB0_CH4_BASE);
    inline Registers* USB0_CH5 = reinterpret_cast<Registers*>(USB0_CH5_BASE);
    inline Registers* USB0_CH6 = reinterpret_cast<Registers*>(USB0_CH6_BASE);
    inline Registers* USB0_CH7 = reinterpret_cast<Registers*>(USB0_CH7_BASE);
    inline Registers* USB0_CH8 = reinterpret_cast<Registers*>(USB0_CH8_BASE);
    inline Registers* USB0_CH9 = reinterpret_cast<Registers*>(USB0_CH9_BASE);
    inline Registers* USB0_CH10 = reinterpret_cast<Registers*>(USB0_CH10_BASE);
    inline Registers* USB0_CH11 = reinterpret_cast<Registers*>(USB0_CH11_BASE);
    inline Registers* USB0_CH12 = reinterpret_cast<Registers*>(USB0_CH12_BASE);
    inline Registers* USB0_CH13 = reinterpret_cast<Registers*>(USB0_CH13_BASE);

    // Bit definitions
    /// GOTGCTL Register bits
    namespace gotgctl_bits {
        constexpr uint32_t SesReqScs = (1U << 0);  ///< Session Request Success
        constexpr uint32_t SesReq = (1U << 1);  ///< Session Request
        constexpr uint32_t VbvalidOvEn = (1U << 2);  ///< VBUS Valid Override Enable
        constexpr uint32_t VbvalidOvVal = (1U << 3);  ///< VBUS Valid Override Value
        constexpr uint32_t AvalidOvEn = (1U << 4);  ///< A-Peripheral Session Valid Override Enable
        constexpr uint32_t AvalidOvVal = (1U << 5);  ///< A-Peripheral Session Valid Override Value
        constexpr uint32_t BvalidOvEn = (1U << 6);  ///< B-Peripheral Session Valid Override Enable
        constexpr uint32_t BvalidOvVal = (1U << 7);  ///< B-Peripheral Session Valid Override Value
        constexpr uint32_t HstNegScs = (1U << 8);  ///< Host Negotiation Success
        constexpr uint32_t HNPReq = (1U << 9);  ///< HNP Request
        constexpr uint32_t HstSetHNPEn = (1U << 10);  ///< Host Set HNP Enable
        constexpr uint32_t DevHNPEn = (1U << 11);  ///< Device HNP Enabled
        constexpr uint32_t ConlDSts = (1U << 16);  ///< Connector ID Status
        constexpr uint32_t DbncTime = (1U << 17);  ///< Long/Short Debounce Time
        constexpr uint32_t ASesVId = (1U << 18);  ///< A-Session Valid
        constexpr uint32_t BSesVld = (1U << 19);  ///< B-Session Valid
        constexpr uint32_t OTGVer = (1U << 20);  ///< OTG Version
    }

    /// GOTGINT Register bits
    namespace gotgint_bits {
        constexpr uint32_t SesEndDet = (1U << 2);  ///< Session End Detected
        constexpr uint32_t SesReqSucStsChng = (1U << 8);  ///< Session Request Success Status Change
        constexpr uint32_t HstNegSucStsChng = (1U << 9);  ///< Host Negotiation Success Status Change
        constexpr uint32_t HstNegDet = (1U << 17);  ///< Host Negotiation Detected
        constexpr uint32_t ADevTOUTChg = (1U << 18);  ///< A-Device Timeout Change
        constexpr uint32_t DbnceDone = (1U << 19);  ///< Debounce Done
    }

    /// GAHBCFG Register bits
    namespace gahbcfg_bits {
        constexpr uint32_t GlblIntrMsk = (1U << 0);  ///< Global Interrupt Mask
        constexpr uint32_t HBstLen = (4 << 1);  ///< Burst Length/Type
        constexpr uint32_t DMAEn = (1U << 5);  ///< DMA Enable
        constexpr uint32_t NPTxFEmpLvl = (1U << 7);  ///< Non-Periodic TxFIFO Empty Level
        constexpr uint32_t PTxFEmpLvl = (1U << 8);  ///< Periodic TxFIFO Empty Level
    }

    /// GUSBCFG Register bits
    namespace gusbcfg_bits {
        constexpr uint32_t TOutCal = (3 << 0);  ///< FS Timeout Calibration
        constexpr uint32_t PHYSel = (1U << 6);  ///< USB 1.1 Full-Speed Serial Transceiver Select
        constexpr uint32_t SRPCap = (1U << 8);  ///< SRP-Capable
        constexpr uint32_t HNPCap = (1U << 9);  ///< HNP-Capable
        constexpr uint32_t USBTrdTim = (4 << 10);  ///< USB Turnaround Time
        constexpr uint32_t OtgI2CSel = (1U << 16);  ///< UTMIFS Interface Select
        constexpr uint32_t TxEndDelay = (1U << 28);  ///< Tx End Delay
        constexpr uint32_t ForceHstMode = (1U << 29);  ///< Force Host Mode
        constexpr uint32_t ForceDevMode = (1U << 30);  ///< Force Device Mode
        constexpr uint32_t CTP = (1U << 31);  ///< Corrupt Tx packet
    }

    /// GRSTCTL Register bits
    namespace grstctl_bits {
        constexpr uint32_t CSftRst = (1U << 0);  ///< Core Soft Reset
        constexpr uint32_t FrmCntrRst = (1U << 2);  ///< Host Frame Counter Reset
        constexpr uint32_t RxFFlsh = (1U << 4);  ///< RxFIFO Flush
        constexpr uint32_t TxFFlsh = (1U << 5);  ///< TxFIFO Flush
        constexpr uint32_t TxFNum = (5 << 6);  ///< TxFIFO Number
        constexpr uint32_t DMAReq = (1U << 30);  ///< DMA Request Signal
        constexpr uint32_t AHBIdle = (1U << 31);  ///< AHB Master Idle
    }

    /// GINTSTS_HOSTMODE Register bits
    namespace gintsts_hostmode_bits {
        constexpr uint32_t CurMod = (1U << 0);  ///< Current Mode of Operation
        constexpr uint32_t ModeMis = (1U << 1);  ///< Mode Mismatch Interrupt
        constexpr uint32_t OTGInt = (1U << 2);  ///< OTG Interrupt
        constexpr uint32_t Sof = (1U << 3);  ///< Start of Frame
        constexpr uint32_t RxFLvl = (1U << 4);  ///< RxFIFO Non-Empty
        constexpr uint32_t incomplP = (1U << 21);  ///< Incomplete Periodic Transfer
        constexpr uint32_t PrtInt = (1U << 24);  ///< Host Port Interrupt
        constexpr uint32_t HChInt = (1U << 25);  ///< Host Channels Interrupt
        constexpr uint32_t PTxFEmp = (1U << 26);  ///< Periodic TxFIFO Empty
        constexpr uint32_t ConIDStsChng = (1U << 28);  ///< Connector ID Status Change
        constexpr uint32_t DisconnInt = (1U << 29);  ///< Disconnect Detected Interrupt
        constexpr uint32_t SessReqInt = (1U << 30);  ///< Session Request/New Session Detected Interrupt
        constexpr uint32_t WkUpInt = (1U << 31);  ///< Resume/Remote Wakeup Detected Interrupt
    }

    /// GINTSTS_DEVICEMODE Register bits
    namespace gintsts_devicemode_bits {
        constexpr uint32_t CurMod = (1U << 0);  ///< Current Mode of Operation
        constexpr uint32_t ModeMis = (1U << 1);  ///< Mode Mismatch Interrupt
        constexpr uint32_t OTGInt = (1U << 2);  ///< OTG Interrupt
        constexpr uint32_t Sof = (1U << 3);  ///< Start of Frame
        constexpr uint32_t RxFLvl = (1U << 4);  ///< RxFIFO Non-Empty
        constexpr uint32_t GINNakEff = (1U << 6);  ///< Global IN Non-Periodic NAK Effective
        constexpr uint32_t GOUTNakEff = (1U << 7);  ///< Global OUT NAK Effective
        constexpr uint32_t ErlySusp = (1U << 10);  ///< Early Suspend
        constexpr uint32_t USBSusp = (1U << 11);  ///< USB Suspend
        constexpr uint32_t USBRst = (1U << 12);  ///< USB Reset
        constexpr uint32_t EnumDone = (1U << 13);  ///< Enumeration Done
        constexpr uint32_t ISOOutDrop = (1U << 14);  ///< Isochronous OUT Packet Dropped Interrupt
        constexpr uint32_t EOPF = (1U << 15);  ///< End of Periodic Frame Interrupt
        constexpr uint32_t IEPInt = (1U << 18);  ///< IN Endpoints Interrupt
        constexpr uint32_t OEPInt = (1U << 19);  ///< OUT Endpoints Interrupt
        constexpr uint32_t incompISOIN = (1U << 20);  ///< Incomplete Isochronous IN Transfer
        constexpr uint32_t incomplSOOUT = (1U << 21);  ///< Incomplete Isochronous OUT Transfer
        constexpr uint32_t ConIDStsChng = (1U << 28);  ///< Connector ID Status Change
        constexpr uint32_t SessReqInt = (1U << 30);  ///< Session Request/New Session Detected Interrupt
        constexpr uint32_t WkUpInt = (1U << 31);  ///< Resume/Remote Wakeup Detected Interrupt
    }

    /// GINTMSK_HOSTMODE Register bits
    namespace gintmsk_hostmode_bits {
        constexpr uint32_t ModeMisMsk = (1U << 1);  ///< Mode Mismatch Interrupt Mask
        constexpr uint32_t OTGIntMsk = (1U << 2);  ///< OTG Interrupt Mask
        constexpr uint32_t SofMsk = (1U << 3);  ///< Start of Frame Mask
        constexpr uint32_t RxFLvlMsk = (1U << 4);  ///< Receive FIFO Non-Empty Mask
        constexpr uint32_t incomplPMsk = (1U << 21);  ///< Incomplete Periodic Transfer Mask
        constexpr uint32_t PrtIntMsk = (1U << 24);  ///< Host Port Interrupt Mask
        constexpr uint32_t HChIntMsk = (1U << 25);  ///< Host Channels Interrupt Mask
        constexpr uint32_t PTxFEmpMsk = (1U << 26);  ///< Periodic TxFIFO Empty Mask
        constexpr uint32_t ConIDStsChngMsk = (1U << 28);  ///< Connector ID Status Change Mask
        constexpr uint32_t DisconnIntMsk = (1U << 29);  ///< Disconnect Detected Interrupt Mask
        constexpr uint32_t SessReqIntMsk = (1U << 30);  ///< Session Request/New Session Detected Interrupt Mask
        constexpr uint32_t WkUpIntMsk = (1U << 31);  ///< Resume/Remote Wakeup Detected Interrupt Mask
    }

    /// GINTMSK_DEVICEMODE Register bits
    namespace gintmsk_devicemode_bits {
        constexpr uint32_t ModeMisMsk = (1U << 1);  ///< Mode Mismatch Interrupt Mask
        constexpr uint32_t OTGIntMsk = (1U << 2);  ///< OTG Interrupt Mask
        constexpr uint32_t SofMsk = (1U << 3);  ///< Start of Frame Mask
        constexpr uint32_t RxFLvlMsk = (1U << 4);  ///< Receive FIFO Non-Empty Mask
        constexpr uint32_t GINNakEffMsk = (1U << 6);  ///< Global Non-periodic IN NAK Effective Mask
        constexpr uint32_t GOUTNakEffMsk = (1U << 7);  ///< Global OUT NAK Effective Mask
        constexpr uint32_t ErlySuspMsk = (1U << 10);  ///< Early Suspend Mask
        constexpr uint32_t USBSuspMsk = (1U << 11);  ///< USB Suspend Mask
        constexpr uint32_t USBRstMsk = (1U << 12);  ///< USB Reset Mask
        constexpr uint32_t EnumDoneMsk = (1U << 13);  ///< Enumeration Done Mask
        constexpr uint32_t ISOOutDropMsk = (1U << 14);  ///< Isochronous OUT Packet Dropped Interrupt Mask
        constexpr uint32_t EOPFMsk = (1U << 15);  ///< End of Periodic Frame Interrupt Mask
        constexpr uint32_t IEPIntMsk = (1U << 18);  ///< IN Endpoints Interrupt Mask
        constexpr uint32_t OEPIntMsk = (1U << 19);  ///< OUT Endpoints Interrupt Mask
        constexpr uint32_t incompISOINMsk = (1U << 20);  ///< Incomplete Isochronous IN Transfer Mask
        constexpr uint32_t incomplSOOUTMsk = (1U << 21);  ///< Incomplete Isochronous OUT Transfer Mask
        constexpr uint32_t ConIDStsChngMsk = (1U << 28);  ///< Connector ID Status Change Mask
        constexpr uint32_t SessReqIntMsk = (1U << 30);  ///< Session Request/New Session Detected Interrupt Mask
        constexpr uint32_t WkUpIntMsk = (1U << 31);  ///< Resume/Remote Wakeup Detected Interrupt Mask
    }

    /// GRXSTSR_HOSTMODE Register bits
    namespace grxstsr_hostmode_bits {
        constexpr uint32_t ChNum = (4 << 0);  ///< Channel Number
        constexpr uint32_t BCnt = (11 << 4);  ///< Byte Count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PktSts = (4 << 17);  ///< Packet Status
    }

    /// GRXSTSR_DEVICEMODE Register bits
    namespace grxstsr_devicemode_bits {
        constexpr uint32_t EPNum = (4 << 0);  ///< Endpoint Number
        constexpr uint32_t BCnt = (11 << 4);  ///< Byte Count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PktSts = (4 << 17);  ///< Packet Status
        constexpr uint32_t FN = (4 << 21);  ///< Frame Number
    }

    /// GRXSTSP_HOSTMODE Register bits
    namespace grxstsp_hostmode_bits {
        constexpr uint32_t ChNum = (4 << 0);  ///< Channel Number
        constexpr uint32_t BCnt = (11 << 4);  ///< Byte Count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PktSts = (4 << 17);  ///< Packet Status
    }

    /// GRXSTSP_DEVICEMODE Register bits
    namespace grxstsp_devicemode_bits {
        constexpr uint32_t EPNum = (4 << 0);  ///< Endpoint Number
        constexpr uint32_t BCnt = (11 << 4);  ///< Byte Count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PktSts = (4 << 17);  ///< Packet Status
        constexpr uint32_t FN = (4 << 21);  ///< Frame Number
    }

    /// GRXFSIZ Register bits
    namespace grxfsiz_bits {
        constexpr uint32_t RxFDep = (16 << 0);  ///< RxFIFO Depth
    }

    /// GNPTXFSIZ_HOSTMODE Register bits
    namespace gnptxfsiz_hostmode_bits {
        constexpr uint32_t NPTxFStAddr = (16 << 0);  ///< Non-periodic Transmit RAM Start Address
        constexpr uint32_t NPTxFDep = (16 << 16);  ///< Non-periodic TxFIFO Depth
    }

    /// GNPTXFSIZ_DEVICEMODE Register bits
    namespace gnptxfsiz_devicemode_bits {
        constexpr uint32_t INEPTxF0StAddr = (16 << 0);  ///< IN Endpoint FIFO0 Transmit RAM Start Address
        constexpr uint32_t INEPTxF0Dep = (16 << 16);  ///< IN Endpoint TxFIFO 0 Depth
    }

    /// GNPTXSTS Register bits
    namespace gnptxsts_bits {
        constexpr uint32_t NPTxFSpcAvail = (16 << 0);  ///< Non-periodic TxFIFO Space Avail
        constexpr uint32_t NPTxQSpcAvail = (8 << 16);  ///< Non-periodic Transmit Request Queue Space Available
        constexpr uint32_t NPTxQTop = (7 << 24);  ///< Top of the Non-periodic Transmit Request Queue
    }

    /// GUID Register bits
    namespace guid_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// GDFIFOCFG Register bits
    namespace gdfifocfg_bits {
        constexpr uint32_t GDFIFOCfg = (16 << 0);  ///< GDFIFOCfg
        constexpr uint32_t EPInfoBaseAddr = (16 << 16);  ///< EPInfoBaseAddr
    }

    /// HPTXFSIZ Register bits
    namespace hptxfsiz_bits {
        constexpr uint32_t PTxFStAddr = (16 << 0);  ///< Host Periodic TxFIFO Start Address
        constexpr uint32_t PTxFSize = (16 << 16);  ///< Host Periodic TxFIFO Depth
    }

    /// DIEPTXF1 Register bits
    namespace dieptxf1_bits {
        constexpr uint32_t INEPnTxFStAddr = (16 << 0);  ///< IN Endpoint FIFOn Transmit RAM Start Address
        constexpr uint32_t INEPnTxFDep = (16 << 16);  ///< IN Endpoint TxFIFO Depth
    }

    /// DIEPTXF2 Register bits
    namespace dieptxf2_bits {
        constexpr uint32_t INEPnTxFStAddr = (16 << 0);  ///< IN Endpoint FIFOn Transmit RAM Start Address
        constexpr uint32_t INEPnTxFDep = (16 << 16);  ///< IN Endpoint TxFIFO Depth
    }

    /// DIEPTXF3 Register bits
    namespace dieptxf3_bits {
        constexpr uint32_t INEPnTxFStAddr = (16 << 0);  ///< IN Endpoint FIFOn Transmit RAM Start Address
        constexpr uint32_t INEPnTxFDep = (16 << 16);  ///< IN Endpoint TxFIFO Depth
    }

    /// DIEPTXF4 Register bits
    namespace dieptxf4_bits {
        constexpr uint32_t INEPnTxFStAddr = (16 << 0);  ///< IN Endpoint FIFOn Transmit RAM Start Address
        constexpr uint32_t INEPnTxFDep = (16 << 16);  ///< IN Endpoint TxFIFO Depth
    }

    /// DIEPTXF5 Register bits
    namespace dieptxf5_bits {
        constexpr uint32_t INEPnTxFStAddr = (16 << 0);  ///< IN Endpoint FIFOn Transmit RAM Start Address
        constexpr uint32_t INEPnTxFDep = (16 << 16);  ///< IN Endpoint TxFIFO Depth
    }

    /// DIEPTXF6 Register bits
    namespace dieptxf6_bits {
        constexpr uint32_t INEPnTxFStAddr = (16 << 0);  ///< IN Endpoint FIFOn Transmit RAM Start Address
        constexpr uint32_t INEPnTxFDep = (16 << 16);  ///< IN Endpoint TxFIFO Depth
    }

    /// HCFG Register bits
    namespace hcfg_bits {
        constexpr uint32_t FSLSPclkSel = (2 << 0);  ///< FS PHY Clock Select
        constexpr uint32_t FSLSSupp = (1U << 2);  ///< FS-Only Support
        constexpr uint32_t DescDMA = (1U << 23);  ///< Enable Scatter/gather DMA in Host mode
        constexpr uint32_t FrListEn = (2 << 24);  ///< Frame List Entries
        constexpr uint32_t PerSchedEna = (1U << 26);  ///< Enable Periodic Scheduling
    }

    /// HFIR Register bits
    namespace hfir_bits {
        constexpr uint32_t FrInt = (16 << 0);  ///< Frame Interval
        constexpr uint32_t HFIRRldCtrl = (1U << 16);  ///< Reload Control
    }

    /// HFNUM Register bits
    namespace hfnum_bits {
        constexpr uint32_t FrNum = (16 << 0);  ///< Frame Number
        constexpr uint32_t FrRem = (16 << 16);  ///< Frame Time Remaining
    }

    /// HPTXSTS Register bits
    namespace hptxsts_bits {
        constexpr uint32_t PTxFSpcAvail = (16 << 0);  ///< Periodic Transmit Data FIFO Space Available
        constexpr uint32_t PTxQSpcAvail = (8 << 16);  ///< Periodic Transmit Request Queue Space Available
        constexpr uint32_t PTxQTop = (8 << 24);  ///< Top of the Periodic Transmit Request Queue
    }

    /// HAINT Register bits
    namespace haint_bits {
        constexpr uint32_t HAINT = (14 << 0);  ///< Channel Interrupts
    }

    /// HAINTMSK Register bits
    namespace haintmsk_bits {
        constexpr uint32_t HAINTMsk = (14 << 0);  ///< Channel Interrupt Mask
    }

    /// HFLBADDR Register bits
    namespace hflbaddr_bits {
        constexpr uint32_t Starting_Address = (32 << 0);  ///< Starting Address
    }

    /// HPRT Register bits
    namespace hprt_bits {
        constexpr uint32_t PrtConnSts = (1U << 0);  ///< Port Connect Status
        constexpr uint32_t PrtConnDet = (1U << 1);  ///< Port Connect Detected
        constexpr uint32_t PrtEna = (1U << 2);  ///< Port Enable
        constexpr uint32_t PrtEnChng = (1U << 3);  ///< Port Enable/Disable Change
        constexpr uint32_t PrtOvrCurrAct = (1U << 4);  ///< Port Overcurrent Active
        constexpr uint32_t PrtOvrCurrChng = (1U << 5);  ///< Port Overcurrent Change
        constexpr uint32_t PrtRes = (1U << 6);  ///< Port Resume
        constexpr uint32_t PrtSusp = (1U << 7);  ///< Port Suspend
        constexpr uint32_t PrtRst = (1U << 8);  ///< Port Reset
        constexpr uint32_t PrtLnSts = (2 << 10);  ///< Port Line Status
        constexpr uint32_t PrtPwr = (1U << 12);  ///< Port Power
        constexpr uint32_t PrtSpd = (2 << 17);  ///< Port Speed
    }

    /// DCFG Register bits
    namespace dcfg_bits {
        constexpr uint32_t DevSpd = (2 << 0);  ///< Device Speed
        constexpr uint32_t NZStsOUTHShk = (1U << 2);  ///< Non-Zero-Length Status OUT Handshake
        constexpr uint32_t DevAddr = (7 << 4);  ///< Device Address
        constexpr uint32_t PerFrInt = (2 << 11);  ///< Periodic Frame Interval
        constexpr uint32_t DescDMA = (1U << 23);  ///< Enable Scatter/Gather DMA in Device mode.
        constexpr uint32_t PerSchIntvl = (2 << 24);  ///< Periodic Scheduling Interval
    }

    /// DCTL Register bits
    namespace dctl_bits {
        constexpr uint32_t RmtWkUpSig = (1U << 0);  ///< Remote Wakeup Signaling
        constexpr uint32_t SftDiscon = (1U << 1);  ///< Soft Disconnect
        constexpr uint32_t GNPINNakSts = (1U << 2);  ///< Global Non-periodic IN NAK Status
        constexpr uint32_t GOUTNakSts = (1U << 3);  ///< Global OUT NAK Status
        constexpr uint32_t SGNPInNak = (1U << 7);  ///< Set Global Non-periodic IN NAK
        constexpr uint32_t CGNPInNak = (1U << 8);  ///< Clear Global Non-periodic IN NAK
        constexpr uint32_t SGOUTNak = (1U << 9);  ///< Set Global OUT NAK
        constexpr uint32_t CGOUTNak = (1U << 10);  ///< Clear Global OUT NAK
        constexpr uint32_t GMC = (2 << 13);  ///< Global Multi Count
        constexpr uint32_t IgnrFrmNum = (1U << 15);  ///< Ignore frame number for isochronous endpoints in case of Scatter/Gather DMA
        constexpr uint32_t NakOnBble = (1U << 16);  ///< Set NAK automatically on babble
    }

    /// DSTS Register bits
    namespace dsts_bits {
        constexpr uint32_t SuspSts = (1U << 0);  ///< Suspend Status
        constexpr uint32_t EnumSpd = (2 << 1);  ///< Enumerated Speed
        constexpr uint32_t ErrticErr = (1U << 3);  ///< Erratic Error
        constexpr uint32_t SOFFN = (14 << 8);  ///< Frame Number of the Received SOF
    }

    /// DIEPMSK Register bits
    namespace diepmsk_bits {
        constexpr uint32_t XferComplMsk = (1U << 0);  ///< Transfer Completed Interrupt Mask
        constexpr uint32_t EPDisbldMsk = (1U << 1);  ///< Endpoint Disabled Interrupt Mask
        constexpr uint32_t AHBErrMsk = (1U << 2);  ///< AHB Error Mask
        constexpr uint32_t TimeOUTMsk = (1U << 3);  ///< Timeout Condition Mask
        constexpr uint32_t INTknTXFEmpMsk = (1U << 4);  ///< IN Token Received When TxFIFO Empty Mask
        constexpr uint32_t INEPNakEffMsk = (1U << 6);  ///< IN Endpoint NAK Effective Mask
        constexpr uint32_t TxfifoUndrnMsk = (1U << 8);  ///< Fifo Underrun Mask
        constexpr uint32_t BNAInIntrMsk = (1U << 9);  ///< BNA Interrupt Mask
        constexpr uint32_t NAKMsk = (1U << 13);  ///< NAK interrupt Mask
    }

    /// DOEPMSK Register bits
    namespace doepmsk_bits {
        constexpr uint32_t XferComplMsk = (1U << 0);  ///< Transfer Completed Interrupt Mask
        constexpr uint32_t EPDisbldMsk = (1U << 1);  ///< Endpoint Disabled Interrupt Mask
        constexpr uint32_t AHBErrMsk = (1U << 2);  ///< AHB Error
        constexpr uint32_t SetUPMsk = (1U << 3);  ///< SETUP Phase Done Mask
        constexpr uint32_t OUTTknEPdisMsk = (1U << 4);  ///< OUT Token Received when Endpoint Disabled Mask
        constexpr uint32_t Back2BackSETup = (1U << 6);  ///< Back-to-Back SETUP Packets Received Mask
        constexpr uint32_t OutPktErrMsk = (1U << 8);  ///< OUT Packet Error Mask
        constexpr uint32_t BnaOutIntrMsk = (1U << 9);  ///< BNA interrupt Mask
        constexpr uint32_t BbleErrMsk = (1U << 12);  ///< Babble Interrupt Mask
        constexpr uint32_t NAKMsk = (1U << 13);  ///< NAK Interrupt Mask
        constexpr uint32_t NYETMsk = (1U << 14);  ///< NYET Interrupt Mask
    }

    /// DAINT Register bits
    namespace daint_bits {
        constexpr uint32_t InEpInt = (16 << 0);  ///< IN Endpoint Interrupt Bits
        constexpr uint32_t OutEPInt = (16 << 16);  ///< OUT Endpoint Interrupt Bits
    }

    /// DAINTMSK Register bits
    namespace daintmsk_bits {
        constexpr uint32_t InEpMsk = (16 << 0);  ///< IN EP Interrupt Mask Bits
        constexpr uint32_t OutEpMsk = (16 << 16);  ///< OUT EP Interrupt Mask Bits
    }

    /// DVBUSDIS Register bits
    namespace dvbusdis_bits {
        constexpr uint32_t DVBUSDis = (16 << 0);  ///< Device Vbus Discharge Time
    }

    /// DVBUSPULSE Register bits
    namespace dvbuspulse_bits {
        constexpr uint32_t DVBUSPulse = (12 << 0);  ///< Device Vbus Pulsing Time
    }

    /// DIEPEMPMSK Register bits
    namespace diepempmsk_bits {
        constexpr uint32_t InEpTxfEmpMsk = (16 << 0);  ///< IN EP Tx FIFO Empty Interrupt Mask Bits
    }

    /// PCGCCTL Register bits
    namespace pcgcctl_bits {
        constexpr uint32_t StopPclk = (1U << 0);  ///< Stop Pclk
        constexpr uint32_t GateHclk = (1U << 1);  ///< Gate Hclk
    }

}

// ============================================================================
// USIC0 Peripheral
// ============================================================================

namespace usic0 {
    /// Base addresses
    constexpr uint32_t USIC0_BASE = 0x40030008;
    constexpr uint32_t USIC0_CH0_BASE = 0x40030000;
    constexpr uint32_t USIC0_CH1_BASE = 0x40030200;

    /// USIC0 Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - Module Identification Register
    };

    /// Peripheral instances
    inline Registers* USIC0 = reinterpret_cast<Registers*>(USIC0_BASE);
    inline Registers* USIC0_CH0 = reinterpret_cast<Registers*>(USIC0_CH0_BASE);
    inline Registers* USIC0_CH1 = reinterpret_cast<Registers*>(USIC0_CH1_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

}

// ============================================================================
// USIC1 Peripheral
// ============================================================================

namespace usic1 {
    /// Base addresses
    constexpr uint32_t USIC1_BASE = 0x48020008;
    constexpr uint32_t USIC1_CH0_BASE = 0x48020000;
    constexpr uint32_t USIC1_CH1_BASE = 0x48020200;

    /// USIC1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* USIC1 = reinterpret_cast<Registers*>(USIC1_BASE);
    inline Registers* USIC1_CH0 = reinterpret_cast<Registers*>(USIC1_CH0_BASE);
    inline Registers* USIC1_CH1 = reinterpret_cast<Registers*>(USIC1_CH1_BASE);

}

// ============================================================================
// USIC2 Peripheral
// ============================================================================

namespace usic2 {
    /// Base addresses
    constexpr uint32_t USIC2_BASE = 0x48024008;
    constexpr uint32_t USIC2_CH0_BASE = 0x48024000;
    constexpr uint32_t USIC2_CH1_BASE = 0x48024200;

    /// USIC2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* USIC2 = reinterpret_cast<Registers*>(USIC2_BASE);
    inline Registers* USIC2_CH0 = reinterpret_cast<Registers*>(USIC2_CH0_BASE);
    inline Registers* USIC2_CH1 = reinterpret_cast<Registers*>(USIC2_CH1_BASE);

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN_BASE = 0x48014000;
    constexpr uint32_t CAN_NODE0_BASE = 0x48014200;
    constexpr uint32_t CAN_NODE1_BASE = 0x48014300;
    constexpr uint32_t CAN_NODE2_BASE = 0x48014400;
    constexpr uint32_t CAN_MO0_BASE = 0x48015000;
    constexpr uint32_t CAN_MO1_BASE = 0x48015020;
    constexpr uint32_t CAN_MO2_BASE = 0x48015040;
    constexpr uint32_t CAN_MO3_BASE = 0x48015060;
    constexpr uint32_t CAN_MO4_BASE = 0x48015080;
    constexpr uint32_t CAN_MO5_BASE = 0x480150A0;
    constexpr uint32_t CAN_MO6_BASE = 0x480150C0;
    constexpr uint32_t CAN_MO7_BASE = 0x480150E0;
    constexpr uint32_t CAN_MO8_BASE = 0x48015100;
    constexpr uint32_t CAN_MO9_BASE = 0x48015120;
    constexpr uint32_t CAN_MO10_BASE = 0x48015140;
    constexpr uint32_t CAN_MO11_BASE = 0x48015160;
    constexpr uint32_t CAN_MO12_BASE = 0x48015180;
    constexpr uint32_t CAN_MO13_BASE = 0x480151A0;
    constexpr uint32_t CAN_MO14_BASE = 0x480151C0;
    constexpr uint32_t CAN_MO15_BASE = 0x480151E0;
    constexpr uint32_t CAN_MO16_BASE = 0x48015200;
    constexpr uint32_t CAN_MO17_BASE = 0x48015220;
    constexpr uint32_t CAN_MO18_BASE = 0x48015240;
    constexpr uint32_t CAN_MO19_BASE = 0x48015260;
    constexpr uint32_t CAN_MO20_BASE = 0x48015280;
    constexpr uint32_t CAN_MO21_BASE = 0x480152A0;
    constexpr uint32_t CAN_MO22_BASE = 0x480152C0;
    constexpr uint32_t CAN_MO23_BASE = 0x480152E0;
    constexpr uint32_t CAN_MO24_BASE = 0x48015300;
    constexpr uint32_t CAN_MO25_BASE = 0x48015320;
    constexpr uint32_t CAN_MO26_BASE = 0x48015340;
    constexpr uint32_t CAN_MO27_BASE = 0x48015360;
    constexpr uint32_t CAN_MO28_BASE = 0x48015380;
    constexpr uint32_t CAN_MO29_BASE = 0x480153A0;
    constexpr uint32_t CAN_MO30_BASE = 0x480153C0;
    constexpr uint32_t CAN_MO31_BASE = 0x480153E0;
    constexpr uint32_t CAN_MO32_BASE = 0x48015400;
    constexpr uint32_t CAN_MO33_BASE = 0x48015420;
    constexpr uint32_t CAN_MO34_BASE = 0x48015440;
    constexpr uint32_t CAN_MO35_BASE = 0x48015460;
    constexpr uint32_t CAN_MO36_BASE = 0x48015480;
    constexpr uint32_t CAN_MO37_BASE = 0x480154A0;
    constexpr uint32_t CAN_MO38_BASE = 0x480154C0;
    constexpr uint32_t CAN_MO39_BASE = 0x480154E0;
    constexpr uint32_t CAN_MO40_BASE = 0x48015500;
    constexpr uint32_t CAN_MO41_BASE = 0x48015520;
    constexpr uint32_t CAN_MO42_BASE = 0x48015540;
    constexpr uint32_t CAN_MO43_BASE = 0x48015560;
    constexpr uint32_t CAN_MO44_BASE = 0x48015580;
    constexpr uint32_t CAN_MO45_BASE = 0x480155A0;
    constexpr uint32_t CAN_MO46_BASE = 0x480155C0;
    constexpr uint32_t CAN_MO47_BASE = 0x480155E0;
    constexpr uint32_t CAN_MO48_BASE = 0x48015600;
    constexpr uint32_t CAN_MO49_BASE = 0x48015620;
    constexpr uint32_t CAN_MO50_BASE = 0x48015640;
    constexpr uint32_t CAN_MO51_BASE = 0x48015660;
    constexpr uint32_t CAN_MO52_BASE = 0x48015680;
    constexpr uint32_t CAN_MO53_BASE = 0x480156A0;
    constexpr uint32_t CAN_MO54_BASE = 0x480156C0;
    constexpr uint32_t CAN_MO55_BASE = 0x480156E0;
    constexpr uint32_t CAN_MO56_BASE = 0x48015700;
    constexpr uint32_t CAN_MO57_BASE = 0x48015720;
    constexpr uint32_t CAN_MO58_BASE = 0x48015740;
    constexpr uint32_t CAN_MO59_BASE = 0x48015760;
    constexpr uint32_t CAN_MO60_BASE = 0x48015780;
    constexpr uint32_t CAN_MO61_BASE = 0x480157A0;
    constexpr uint32_t CAN_MO62_BASE = 0x480157C0;
    constexpr uint32_t CAN_MO63_BASE = 0x480157E0;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t CLC;  ///< Offset: 0x00 - CAN Clock Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t FDR;  ///< Offset: 0x0C - CAN Fractional Divider Register
        volatile uint32_t LIST[%s];  ///< Offset: 0x100 - List Register
        volatile uint32_t MSPND[%s];  ///< Offset: 0x140 - Message Pending Register
        volatile uint32_t MSID[%s];  ///< Offset: 0x180 - Message Index Register
        volatile uint32_t MSIMASK;  ///< Offset: 0x1C0 - Message Index Mask Register
        volatile uint32_t PANCTR;  ///< Offset: 0x1C4 - Panel Control Register
        volatile uint32_t MCR;  ///< Offset: 0x1C8 - Module Control Register
        volatile uint32_t MITR;  ///< Offset: 0x1CC - Module Interrupt Trigger Register
    };

    /// Peripheral instances
    inline Registers* CAN = reinterpret_cast<Registers*>(CAN_BASE);
    inline Registers* CAN_NODE0 = reinterpret_cast<Registers*>(CAN_NODE0_BASE);
    inline Registers* CAN_NODE1 = reinterpret_cast<Registers*>(CAN_NODE1_BASE);
    inline Registers* CAN_NODE2 = reinterpret_cast<Registers*>(CAN_NODE2_BASE);
    inline Registers* CAN_MO0 = reinterpret_cast<Registers*>(CAN_MO0_BASE);
    inline Registers* CAN_MO1 = reinterpret_cast<Registers*>(CAN_MO1_BASE);
    inline Registers* CAN_MO2 = reinterpret_cast<Registers*>(CAN_MO2_BASE);
    inline Registers* CAN_MO3 = reinterpret_cast<Registers*>(CAN_MO3_BASE);
    inline Registers* CAN_MO4 = reinterpret_cast<Registers*>(CAN_MO4_BASE);
    inline Registers* CAN_MO5 = reinterpret_cast<Registers*>(CAN_MO5_BASE);
    inline Registers* CAN_MO6 = reinterpret_cast<Registers*>(CAN_MO6_BASE);
    inline Registers* CAN_MO7 = reinterpret_cast<Registers*>(CAN_MO7_BASE);
    inline Registers* CAN_MO8 = reinterpret_cast<Registers*>(CAN_MO8_BASE);
    inline Registers* CAN_MO9 = reinterpret_cast<Registers*>(CAN_MO9_BASE);
    inline Registers* CAN_MO10 = reinterpret_cast<Registers*>(CAN_MO10_BASE);
    inline Registers* CAN_MO11 = reinterpret_cast<Registers*>(CAN_MO11_BASE);
    inline Registers* CAN_MO12 = reinterpret_cast<Registers*>(CAN_MO12_BASE);
    inline Registers* CAN_MO13 = reinterpret_cast<Registers*>(CAN_MO13_BASE);
    inline Registers* CAN_MO14 = reinterpret_cast<Registers*>(CAN_MO14_BASE);
    inline Registers* CAN_MO15 = reinterpret_cast<Registers*>(CAN_MO15_BASE);
    inline Registers* CAN_MO16 = reinterpret_cast<Registers*>(CAN_MO16_BASE);
    inline Registers* CAN_MO17 = reinterpret_cast<Registers*>(CAN_MO17_BASE);
    inline Registers* CAN_MO18 = reinterpret_cast<Registers*>(CAN_MO18_BASE);
    inline Registers* CAN_MO19 = reinterpret_cast<Registers*>(CAN_MO19_BASE);
    inline Registers* CAN_MO20 = reinterpret_cast<Registers*>(CAN_MO20_BASE);
    inline Registers* CAN_MO21 = reinterpret_cast<Registers*>(CAN_MO21_BASE);
    inline Registers* CAN_MO22 = reinterpret_cast<Registers*>(CAN_MO22_BASE);
    inline Registers* CAN_MO23 = reinterpret_cast<Registers*>(CAN_MO23_BASE);
    inline Registers* CAN_MO24 = reinterpret_cast<Registers*>(CAN_MO24_BASE);
    inline Registers* CAN_MO25 = reinterpret_cast<Registers*>(CAN_MO25_BASE);
    inline Registers* CAN_MO26 = reinterpret_cast<Registers*>(CAN_MO26_BASE);
    inline Registers* CAN_MO27 = reinterpret_cast<Registers*>(CAN_MO27_BASE);
    inline Registers* CAN_MO28 = reinterpret_cast<Registers*>(CAN_MO28_BASE);
    inline Registers* CAN_MO29 = reinterpret_cast<Registers*>(CAN_MO29_BASE);
    inline Registers* CAN_MO30 = reinterpret_cast<Registers*>(CAN_MO30_BASE);
    inline Registers* CAN_MO31 = reinterpret_cast<Registers*>(CAN_MO31_BASE);
    inline Registers* CAN_MO32 = reinterpret_cast<Registers*>(CAN_MO32_BASE);
    inline Registers* CAN_MO33 = reinterpret_cast<Registers*>(CAN_MO33_BASE);
    inline Registers* CAN_MO34 = reinterpret_cast<Registers*>(CAN_MO34_BASE);
    inline Registers* CAN_MO35 = reinterpret_cast<Registers*>(CAN_MO35_BASE);
    inline Registers* CAN_MO36 = reinterpret_cast<Registers*>(CAN_MO36_BASE);
    inline Registers* CAN_MO37 = reinterpret_cast<Registers*>(CAN_MO37_BASE);
    inline Registers* CAN_MO38 = reinterpret_cast<Registers*>(CAN_MO38_BASE);
    inline Registers* CAN_MO39 = reinterpret_cast<Registers*>(CAN_MO39_BASE);
    inline Registers* CAN_MO40 = reinterpret_cast<Registers*>(CAN_MO40_BASE);
    inline Registers* CAN_MO41 = reinterpret_cast<Registers*>(CAN_MO41_BASE);
    inline Registers* CAN_MO42 = reinterpret_cast<Registers*>(CAN_MO42_BASE);
    inline Registers* CAN_MO43 = reinterpret_cast<Registers*>(CAN_MO43_BASE);
    inline Registers* CAN_MO44 = reinterpret_cast<Registers*>(CAN_MO44_BASE);
    inline Registers* CAN_MO45 = reinterpret_cast<Registers*>(CAN_MO45_BASE);
    inline Registers* CAN_MO46 = reinterpret_cast<Registers*>(CAN_MO46_BASE);
    inline Registers* CAN_MO47 = reinterpret_cast<Registers*>(CAN_MO47_BASE);
    inline Registers* CAN_MO48 = reinterpret_cast<Registers*>(CAN_MO48_BASE);
    inline Registers* CAN_MO49 = reinterpret_cast<Registers*>(CAN_MO49_BASE);
    inline Registers* CAN_MO50 = reinterpret_cast<Registers*>(CAN_MO50_BASE);
    inline Registers* CAN_MO51 = reinterpret_cast<Registers*>(CAN_MO51_BASE);
    inline Registers* CAN_MO52 = reinterpret_cast<Registers*>(CAN_MO52_BASE);
    inline Registers* CAN_MO53 = reinterpret_cast<Registers*>(CAN_MO53_BASE);
    inline Registers* CAN_MO54 = reinterpret_cast<Registers*>(CAN_MO54_BASE);
    inline Registers* CAN_MO55 = reinterpret_cast<Registers*>(CAN_MO55_BASE);
    inline Registers* CAN_MO56 = reinterpret_cast<Registers*>(CAN_MO56_BASE);
    inline Registers* CAN_MO57 = reinterpret_cast<Registers*>(CAN_MO57_BASE);
    inline Registers* CAN_MO58 = reinterpret_cast<Registers*>(CAN_MO58_BASE);
    inline Registers* CAN_MO59 = reinterpret_cast<Registers*>(CAN_MO59_BASE);
    inline Registers* CAN_MO60 = reinterpret_cast<Registers*>(CAN_MO60_BASE);
    inline Registers* CAN_MO61 = reinterpret_cast<Registers*>(CAN_MO61_BASE);
    inline Registers* CAN_MO62 = reinterpret_cast<Registers*>(CAN_MO62_BASE);
    inline Registers* CAN_MO63 = reinterpret_cast<Registers*>(CAN_MO63_BASE);

    // Bit definitions
    /// CLC Register bits
    namespace clc_bits {
        constexpr uint32_t DISR = (1U << 0);  ///< Module Disable Request Bit
        constexpr uint32_t DISS = (1U << 1);  ///< Module Disable Status Bit
        constexpr uint32_t EDIS = (1U << 3);  ///< Sleep Mode Enable Control
        constexpr uint32_t SBWE = (1U << 4);  ///< Module Suspend Bit Write Enable for OCDS
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision Number
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number Value
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t STEP = (10 << 0);  ///< Step Value
        constexpr uint32_t SM = (1U << 11);  ///< Suspend Mode
        constexpr uint32_t SC = (2 << 12);  ///< Suspend Control
        constexpr uint32_t DM = (2 << 14);  ///< Divider Mode
        constexpr uint32_t RESULT = (10 << 16);  ///< Result Value
        constexpr uint32_t SUSACK = (1U << 28);  ///< Suspend Mode Acknowledge
        constexpr uint32_t SUSREQ = (1U << 29);  ///< Suspend Mode Request
        constexpr uint32_t ENHW = (1U << 30);  ///< Enable Hardware Clock Control
        constexpr uint32_t DISCLK = (1U << 31);  ///< Disable Clock
    }

    /// LIST[%s] Register bits
    namespace list[%s]_bits {
        constexpr uint32_t BEGIN = (8 << 0);  ///< List Begin
        constexpr uint32_t END = (8 << 8);  ///< List End
        constexpr uint32_t SIZE = (8 << 16);  ///< List Size
        constexpr uint32_t EMPTY = (1U << 24);  ///< List Empty Indication
    }

    /// MSPND[%s] Register bits
    namespace mspnd[%s]_bits {
        constexpr uint32_t PND = (32 << 0);  ///< Message Pending
    }

    /// MSID[%s] Register bits
    namespace msid[%s]_bits {
        constexpr uint32_t INDEX = (6 << 0);  ///< Message Pending Index
    }

    /// MSIMASK Register bits
    namespace msimask_bits {
        constexpr uint32_t IM = (32 << 0);  ///< Message Index Mask
    }

    /// PANCTR Register bits
    namespace panctr_bits {
        constexpr uint32_t PANCMD = (8 << 0);  ///< Panel Command
        constexpr uint32_t BUSY = (1U << 8);  ///< Panel Busy Flag
        constexpr uint32_t RBUSY = (1U << 9);  ///< Result Busy Flag
        constexpr uint32_t PANAR1 = (8 << 16);  ///< Panel Argument 1
        constexpr uint32_t PANAR2 = (8 << 24);  ///< Panel Argument 2
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MPSEL = (4 << 12);  ///< Message Pending Selector
    }

    /// MITR Register bits
    namespace mitr_bits {
        constexpr uint32_t IT = (8 << 0);  ///< Interrupt Trigger
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t VADC_BASE = 0x40004000;
    constexpr uint32_t VADC_G0_BASE = 0x40004400;
    constexpr uint32_t VADC_G1_BASE = 0x40004800;
    constexpr uint32_t VADC_G2_BASE = 0x40004C00;
    constexpr uint32_t VADC_G3_BASE = 0x40005000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CLC;  ///< Offset: 0x00 - Clock Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t OCS;  ///< Offset: 0x28 - OCDS Control and Status Register
        volatile uint32_t GLOBCFG;  ///< Offset: 0x80 - Global Configuration Register
        volatile uint32_t GLOBICLASS[%s];  ///< Offset: 0xA0 - Input Class Register, Global
        volatile uint32_t GLOBBOUND;  ///< Offset: 0xB8 - Global Boundary Select Register
        volatile uint32_t GLOBEFLAG;  ///< Offset: 0xE0 - Global Event Flag Register
        volatile uint32_t GLOBEVNP;  ///< Offset: 0x140 - Global Event Node Pointer Register
        volatile uint32_t GLOBTF;  ///< Offset: 0x160 - Global Test Functions Register
        volatile uint32_t BRSSEL[%s];  ///< Offset: 0x180 - Background Request Source Channel Select Register
        volatile uint32_t BRSPND[%s];  ///< Offset: 0x1C0 - Background Request Source Pending Register
        volatile uint32_t BRSCTRL;  ///< Offset: 0x200 - Background Request Source Control Register
        volatile uint32_t BRSMR;  ///< Offset: 0x204 - Background Request Source Mode Register
        volatile uint32_t GLOBRCR;  ///< Offset: 0x280 - Global Result Control Register
        volatile uint32_t GLOBRES;  ///< Offset: 0x300 - Global Result Register
        volatile uint32_t GLOBRESD;  ///< Offset: 0x380 - Global Result Register, Debug
        volatile uint32_t EMUXSEL;  ///< Offset: 0x3F0 - External Multiplexer Select Register
    };

    /// Peripheral instances
    inline Registers* VADC = reinterpret_cast<Registers*>(VADC_BASE);
    inline Registers* VADC_G0 = reinterpret_cast<Registers*>(VADC_G0_BASE);
    inline Registers* VADC_G1 = reinterpret_cast<Registers*>(VADC_G1_BASE);
    inline Registers* VADC_G2 = reinterpret_cast<Registers*>(VADC_G2_BASE);
    inline Registers* VADC_G3 = reinterpret_cast<Registers*>(VADC_G3_BASE);

    // Bit definitions
    /// CLC Register bits
    namespace clc_bits {
        constexpr uint32_t DISR = (1U << 0);  ///< Module Disable Request Bit
        constexpr uint32_t DISS = (1U << 1);  ///< Module Disable Status Bit
        constexpr uint32_t EDIS = (1U << 3);  ///< Sleep Mode Enable Control
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// OCS Register bits
    namespace ocs_bits {
        constexpr uint32_t TGS = (2 << 0);  ///< Trigger Set for OTGB0/1
        constexpr uint32_t TGB = (1U << 2);  ///< OTGB0/1 Bus Select
        constexpr uint32_t TG_P = (1U << 3);  ///< TGS, TGB Write Protection
        constexpr uint32_t SUS = (4 << 24);  ///< OCDS Suspend Control
        constexpr uint32_t SUS_P = (1U << 28);  ///< SUS Write Protection
        constexpr uint32_t SUSSTA = (1U << 29);  ///< Suspend State
    }

    /// GLOBCFG Register bits
    namespace globcfg_bits {
        constexpr uint32_t DIVA = (5 << 0);  ///< Divider Factor for the Analog Internal Clock
        constexpr uint32_t DCMSB = (1U << 7);  ///< Double Clock for the MSB Conversion
        constexpr uint32_t DIVD = (2 << 8);  ///< Divider Factor for the Arbiter Clock
        constexpr uint32_t DIVWC = (1U << 15);  ///< Write Control for Divider Parameters
        constexpr uint32_t DPCAL0 = (1U << 16);  ///< Disable Post-Calibration
        constexpr uint32_t DPCAL1 = (1U << 17);  ///< Disable Post-Calibration
        constexpr uint32_t DPCAL2 = (1U << 18);  ///< Disable Post-Calibration
        constexpr uint32_t DPCAL3 = (1U << 19);  ///< Disable Post-Calibration
        constexpr uint32_t SUCAL = (1U << 31);  ///< Start-Up Calibration
    }

    /// GLOBICLASS[%s] Register bits
    namespace globiclass[%s]_bits {
        constexpr uint32_t STCS = (5 << 0);  ///< Sample Time Control for Standard Conversions
        constexpr uint32_t CMS = (3 << 8);  ///< Conversion Mode for Standard Conversions
        constexpr uint32_t STCE = (5 << 16);  ///< Sample Time Control for EMUX Conversions
        constexpr uint32_t CME = (3 << 24);  ///< Conversion Mode for EMUX Conversions
    }

    /// GLOBBOUND Register bits
    namespace globbound_bits {
        constexpr uint32_t BOUNDARY0 = (12 << 0);  ///< Boundary Value 0 for Limit Checking
        constexpr uint32_t BOUNDARY1 = (12 << 16);  ///< Boundary Value 1 for Limit Checking
    }

    /// GLOBEFLAG Register bits
    namespace globeflag_bits {
        constexpr uint32_t SEVGLB = (1U << 0);  ///< Source Event (Background)
        constexpr uint32_t REVGLB = (1U << 8);  ///< Global Result Event
        constexpr uint32_t SEVGLBCLR = (1U << 16);  ///< Clear Source Event (Background)
        constexpr uint32_t REVGLBCLR = (1U << 24);  ///< Clear Global Result Event
    }

    /// GLOBEVNP Register bits
    namespace globevnp_bits {
        constexpr uint32_t SEV0NP = (4 << 0);  ///< Service Request Node Pointer Backgr. Source
        constexpr uint32_t REV0NP = (4 << 16);  ///< Service Request Node Pointer Backgr. Result
    }

    /// GLOBTF Register bits
    namespace globtf_bits {
        constexpr uint32_t CDGR = (4 << 4);  ///< Converter Diagnostics Group
        constexpr uint32_t CDEN = (1U << 8);  ///< Converter Diagnostics Enable
        constexpr uint32_t CDSEL = (2 << 9);  ///< Converter Diagnostics Pull-Devices Select
        constexpr uint32_t CDWC = (1U << 15);  ///< Write Control for Conversion Diagnostics
        constexpr uint32_t PDD = (1U << 16);  ///< Pull-Down Diagnostics Enable
        constexpr uint32_t MDWC = (1U << 23);  ///< Write Control for Multiplexer Diagnostics
    }

    /// BRSSEL[%s] Register bits
    namespace brssel[%s]_bits {
        constexpr uint32_t CHSELG0 = (1U << 0);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG1 = (1U << 1);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG2 = (1U << 2);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG3 = (1U << 3);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG4 = (1U << 4);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG5 = (1U << 5);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG6 = (1U << 6);  ///< Channel Selection Group x
        constexpr uint32_t CHSELG7 = (1U << 7);  ///< Channel Selection Group x
    }

    /// BRSPND[%s] Register bits
    namespace brspnd[%s]_bits {
        constexpr uint32_t CHPNDG0 = (1U << 0);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG1 = (1U << 1);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG2 = (1U << 2);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG3 = (1U << 3);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG4 = (1U << 4);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG5 = (1U << 5);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG6 = (1U << 6);  ///< Channels Pending Group x
        constexpr uint32_t CHPNDG7 = (1U << 7);  ///< Channels Pending Group x
    }

    /// BRSCTRL Register bits
    namespace brsctrl_bits {
        constexpr uint32_t XTSEL = (4 << 8);  ///< External Trigger Input Selection
        constexpr uint32_t XTLVL = (1U << 12);  ///< External Trigger Level
        constexpr uint32_t XTMODE = (2 << 13);  ///< Trigger Operating Mode
        constexpr uint32_t XTWC = (1U << 15);  ///< Write Control for Trigger Configuration
        constexpr uint32_t GTSEL = (4 << 16);  ///< Gate Input Selection
        constexpr uint32_t GTLVL = (1U << 20);  ///< Gate Input Level
        constexpr uint32_t GTWC = (1U << 23);  ///< Write Control for Gate Configuration
    }

    /// BRSMR Register bits
    namespace brsmr_bits {
        constexpr uint32_t ENGT = (2 << 0);  ///< Enable Gate
        constexpr uint32_t ENTR = (1U << 2);  ///< Enable External Trigger
        constexpr uint32_t ENSI = (1U << 3);  ///< Enable Source Interrupt
        constexpr uint32_t SCAN = (1U << 4);  ///< Autoscan Enable
        constexpr uint32_t LDM = (1U << 5);  ///< Autoscan Source Load Event Mode
        constexpr uint32_t REQGT = (1U << 7);  ///< Request Gate Level
        constexpr uint32_t CLRPND = (1U << 8);  ///< Clear Pending Bits
        constexpr uint32_t LDEV = (1U << 9);  ///< Generate Load Event
        constexpr uint32_t RPTDIS = (1U << 16);  ///< Repeat Disable
    }

    /// GLOBRCR Register bits
    namespace globrcr_bits {
        constexpr uint32_t DRCTR = (4 << 16);  ///< Data Reduction Control
        constexpr uint32_t WFR = (1U << 24);  ///< Wait-for-Read Mode Enable
        constexpr uint32_t SRGEN = (1U << 31);  ///< Service Request Generation Enable
    }

    /// GLOBRES Register bits
    namespace globres_bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Result of most recent conversion
        constexpr uint32_t GNR = (4 << 16);  ///< Group Number
        constexpr uint32_t CHNR = (5 << 20);  ///< Channel Number
        constexpr uint32_t EMUX = (3 << 25);  ///< External Multiplexer Setting
        constexpr uint32_t CRS = (2 << 28);  ///< Converted Request Source
        constexpr uint32_t FCR = (1U << 30);  ///< Fast Compare Result
        constexpr uint32_t VF = (1U << 31);  ///< Valid Flag
    }

    /// GLOBRESD Register bits
    namespace globresd_bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Result of most recent conversion
        constexpr uint32_t GNR = (4 << 16);  ///< Group Number
        constexpr uint32_t CHNR = (5 << 20);  ///< Channel Number
        constexpr uint32_t EMUX = (3 << 25);  ///< External Multiplexer Setting
        constexpr uint32_t CRS = (2 << 28);  ///< Converted Request Source
        constexpr uint32_t FCR = (1U << 30);  ///< Fast Compare Result
        constexpr uint32_t VF = (1U << 31);  ///< Valid Flag
    }

    /// EMUXSEL Register bits
    namespace emuxsel_bits {
        constexpr uint32_t EMUXGRP0 = (4 << 0);  ///< External Multiplexer Group for Interface x
        constexpr uint32_t EMUXGRP1 = (4 << 4);  ///< External Multiplexer Group for Interface x
    }

}

// ============================================================================
// DSD Peripheral
// ============================================================================

namespace dsd {
    /// Base addresses
    constexpr uint32_t DSD_BASE = 0x40008000;
    constexpr uint32_t DSD_CH0_BASE = 0x40008100;
    constexpr uint32_t DSD_CH1_BASE = 0x40008200;
    constexpr uint32_t DSD_CH2_BASE = 0x40008300;
    constexpr uint32_t DSD_CH3_BASE = 0x40008400;

    /// DSD Register structure
    struct Registers {
        volatile uint32_t CLC;  ///< Offset: 0x00 - Clock Control Register
        volatile uint32_t ID;  ///< Offset: 0x08 - Module Identification Register
        volatile uint32_t OCS;  ///< Offset: 0x28 - OCDS Control and Status Register
        volatile uint32_t GLOBCFG;  ///< Offset: 0x80 - Global Configuration Register
        volatile uint32_t GLOBRC;  ///< Offset: 0x88 - Global Run Control Register
        volatile uint32_t CGCFG;  ///< Offset: 0xA0 - Carrier Generator Configuration Register
        volatile uint32_t EVFLAG;  ///< Offset: 0xE0 - Event Flag Register
        volatile uint32_t EVFLAGCLR;  ///< Offset: 0xE4 - Event Flag Clear Register
    };

    /// Peripheral instances
    inline Registers* DSD = reinterpret_cast<Registers*>(DSD_BASE);
    inline Registers* DSD_CH0 = reinterpret_cast<Registers*>(DSD_CH0_BASE);
    inline Registers* DSD_CH1 = reinterpret_cast<Registers*>(DSD_CH1_BASE);
    inline Registers* DSD_CH2 = reinterpret_cast<Registers*>(DSD_CH2_BASE);
    inline Registers* DSD_CH3 = reinterpret_cast<Registers*>(DSD_CH3_BASE);

    // Bit definitions
    /// CLC Register bits
    namespace clc_bits {
        constexpr uint32_t DISR = (1U << 0);  ///< Module Disable Request Bit
        constexpr uint32_t DISS = (1U << 1);  ///< Module Disable Status Bit
        constexpr uint32_t EDIS = (1U << 3);  ///< Sleep Mode Enable Control
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MOD_REV = (8 << 0);  ///< Module Revision
        constexpr uint32_t MOD_TYPE = (8 << 8);  ///< Module Type
        constexpr uint32_t MOD_NUMBER = (16 << 16);  ///< Module Number
    }

    /// OCS Register bits
    namespace ocs_bits {
        constexpr uint32_t SUS = (4 << 24);  ///< OCDS Suspend Control
        constexpr uint32_t SUS_P = (1U << 28);  ///< SUS Write Protection
        constexpr uint32_t SUSSTA = (1U << 29);  ///< Suspend State
    }

    /// GLOBCFG Register bits
    namespace globcfg_bits {
        constexpr uint32_t MCSEL = (3 << 0);  ///< Modulator Clock Select
    }

    /// GLOBRC Register bits
    namespace globrc_bits {
        constexpr uint32_t CH0RUN = (1U << 0);  ///< Channel 0 Run Control
        constexpr uint32_t CH1RUN = (1U << 1);  ///< Channel 1 Run Control
        constexpr uint32_t CH2RUN = (1U << 2);  ///< Channel 2 Run Control
        constexpr uint32_t CH3RUN = (1U << 3);  ///< Channel 3 Run Control
    }

    /// CGCFG Register bits
    namespace cgcfg_bits {
        constexpr uint32_t CGMOD = (2 << 0);  ///< Carrier Generator Operating Mode
        constexpr uint32_t BREV = (1U << 2);  ///< Bit-Reverse PWM Generation
        constexpr uint32_t SIGPOL = (1U << 3);  ///< Signal Polarity
        constexpr uint32_t DIVCG = (4 << 4);  ///< Divider Factor for the PWM Pattern Signal Generator
        constexpr uint32_t RUN = (1U << 15);  ///< Run Indicator
        constexpr uint32_t BITCOUNT = (5 << 16);  ///< Bit Counter
        constexpr uint32_t STEPCOUNT = (4 << 24);  ///< Step Counter
        constexpr uint32_t STEPS = (1U << 28);  ///< Step Counter Sign
        constexpr uint32_t STEPD = (1U << 29);  ///< Step Counter Direction
        constexpr uint32_t SGNCG = (1U << 30);  ///< Sign Signal from Carrier Generator
    }

    /// EVFLAG Register bits
    namespace evflag_bits {
        constexpr uint32_t RESEV0 = (1U << 0);  ///< Result Event
        constexpr uint32_t RESEV1 = (1U << 1);  ///< Result Event
        constexpr uint32_t RESEV2 = (1U << 2);  ///< Result Event
        constexpr uint32_t RESEV3 = (1U << 3);  ///< Result Event
        constexpr uint32_t ALEV0 = (1U << 16);  ///< Alarm Event
        constexpr uint32_t ALEV1 = (1U << 17);  ///< Alarm Event
        constexpr uint32_t ALEV2 = (1U << 18);  ///< Alarm Event
        constexpr uint32_t ALEV3 = (1U << 19);  ///< Alarm Event
        constexpr uint32_t ALEV4 = (1U << 20);  ///< Alarm Event
        constexpr uint32_t ALEV5 = (1U << 21);  ///< Alarm Event
        constexpr uint32_t ALEV6 = (1U << 22);  ///< Alarm Event
        constexpr uint32_t ALEV7 = (1U << 23);  ///< Alarm Event
        constexpr uint32_t ALEV8 = (1U << 24);  ///< Alarm Event
        constexpr uint32_t ALEV9 = (1U << 25);  ///< Alarm Event
    }

    /// EVFLAGCLR Register bits
    namespace evflagclr_bits {
        constexpr uint32_t RESEC0 = (1U << 0);  ///< Result Event Clear
        constexpr uint32_t RESEC1 = (1U << 1);  ///< Result Event Clear
        constexpr uint32_t RESEC2 = (1U << 2);  ///< Result Event Clear
        constexpr uint32_t RESEC3 = (1U << 3);  ///< Result Event Clear
        constexpr uint32_t ALEC0 = (1U << 16);  ///< Alarm Event Clear
        constexpr uint32_t ALEC1 = (1U << 17);  ///< Alarm Event Clear
        constexpr uint32_t ALEC2 = (1U << 18);  ///< Alarm Event Clear
        constexpr uint32_t ALEC3 = (1U << 19);  ///< Alarm Event Clear
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x48018000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - Module Identification Register
        volatile uint32_t DAC0CFG0;  ///< Offset: 0x04 - DAC0 Configuration Register 0
        volatile uint32_t DAC0CFG1;  ///< Offset: 0x08 - DAC0 Configuration Register 1
        volatile uint32_t DAC1CFG0;  ///< Offset: 0x0C - DAC1 Configuration Register 0
        volatile uint32_t DAC1CFG1;  ///< Offset: 0x10 - DAC1 Configuration Register 1
        volatile uint32_t DAC0DATA;  ///< Offset: 0x14 - DAC0 Data Register
        volatile uint32_t DAC1DATA;  ///< Offset: 0x18 - DAC1 Data Register
        volatile uint32_t DAC01DATA;  ///< Offset: 0x1C - DAC01 Data Register
        volatile uint32_t DAC0PATL;  ///< Offset: 0x20 - DAC0 Lower Pattern Register
        volatile uint32_t DAC0PATH;  ///< Offset: 0x24 - DAC0 Higher Pattern Register
        volatile uint32_t DAC1PATL;  ///< Offset: 0x28 - DAC1 Lower Pattern Register
        volatile uint32_t DAC1PATH;  ///< Offset: 0x2C - DAC1 Higher Pattern Register
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t MODR = (8 << 0);  ///< Module Revision
        constexpr uint32_t MODT = (8 << 8);  ///< Module Type
        constexpr uint32_t MODN = (16 << 16);  ///< Module Number
    }

    /// DAC0CFG0 Register bits
    namespace dac0cfg0_bits {
        constexpr uint32_t FREQ = (20 << 0);  ///< Integer Frequency Divider Value
        constexpr uint32_t MODE = (3 << 20);  ///< Enables and Sets the Mode for DAC0
        constexpr uint32_t SIGN = (1U << 23);  ///< Selects Between Signed and Unsigned DAC0 Mode
        constexpr uint32_t FIFOIND = (2 << 24);  ///< Current write position inside the data FIFO
        constexpr uint32_t FIFOEMP = (1U << 26);  ///< Indicate if the FIFO is empty
        constexpr uint32_t FIFOFUL = (1U << 27);  ///< Indicate if the FIFO is full
        constexpr uint32_t SIGNEN = (1U << 29);  ///< Enable Sign Output of DAC0 Pattern Generator
        constexpr uint32_t SREN = (1U << 30);  ///< Enable DAC0 service request interrupt generation
        constexpr uint32_t RUN = (1U << 31);  ///< RUN indicates the current DAC0 operation status
    }

    /// DAC0CFG1 Register bits
    namespace dac0cfg1_bits {
        constexpr uint32_t SCALE = (3 << 0);  ///< Scale value for up- or downscale of the DAC0 input data in steps by the power of 2 (=shift operation)
        constexpr uint32_t MULDIV = (1U << 3);  ///< Switch between up- and downscale of the DAC0 input data values
        constexpr uint32_t OFFS = (8 << 4);  ///< 8-bit offset value addition
        constexpr uint32_t TRIGSEL = (3 << 12);  ///< Selects one of the eight external trigger sources for DAC0
        constexpr uint32_t DATMOD = (1U << 15);  ///< Switch between independent or simultaneous DAC mode and select the input data register for DAC0 and DAC1
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t TRIGMOD = (2 << 17);  ///< Select the trigger source for channel 0
        constexpr uint32_t ANACFG = (5 << 19);  ///< DAC0 analog configuration/calibration parameters
        constexpr uint32_t ANAEN = (1U << 24);  ///< Enable analog DAC for channel 0
        constexpr uint32_t REFCFGL = (4 << 28);  ///< Lower 4 band-gap configuration/calibration parameters
    }

    /// DAC1CFG0 Register bits
    namespace dac1cfg0_bits {
        constexpr uint32_t FREQ = (20 << 0);  ///< Integer Frequency Divider Value
        constexpr uint32_t MODE = (3 << 20);  ///< Enables and sets the Mode for DAC1
        constexpr uint32_t SIGN = (1U << 23);  ///< Selects between signed and unsigned DAC1 mode
        constexpr uint32_t FIFOIND = (2 << 24);  ///< Current write position inside the data FIFO
        constexpr uint32_t FIFOEMP = (1U << 26);  ///< Indicate if the FIFO is empty
        constexpr uint32_t FIFOFUL = (1U << 27);  ///< Indicate if the FIFO is full
        constexpr uint32_t SIGNEN = (1U << 29);  ///< Enable sign output of DAC1 pattern generator
        constexpr uint32_t SREN = (1U << 30);  ///< Enable DAC1 service request interrupt generation
        constexpr uint32_t RUN = (1U << 31);  ///< RUN indicates the current DAC1 operation status
    }

    /// DAC1CFG1 Register bits
    namespace dac1cfg1_bits {
        constexpr uint32_t SCALE = (3 << 0);  ///< Scale value for up- or downscale of the DAC1 input data in steps by the power of 2 (=shift operation)
        constexpr uint32_t MULDIV = (1U << 3);  ///< Switch between up- and downscale of the DAC1 input data values
        constexpr uint32_t OFFS = (8 << 4);  ///< 8-bit offset value addition
        constexpr uint32_t TRIGSEL = (3 << 12);  ///< Selects one of the eight external trigger sources for DAC1
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t TRIGMOD = (2 << 17);  ///< Select the trigger source for channel 1
        constexpr uint32_t ANACFG = (5 << 19);  ///< DAC1 analog configuration/calibration parameters
        constexpr uint32_t ANAEN = (1U << 24);  ///< Enable analog DAC for channel 1
        constexpr uint32_t REFCFGH = (4 << 28);  ///< Higher 4 band-gap configuration/calibration parameters
    }

    /// DAC0DATA Register bits
    namespace dac0data_bits {
        constexpr uint32_t DATA0 = (12 << 0);  ///< DAC0 Data Bits
    }

    /// DAC1DATA Register bits
    namespace dac1data_bits {
        constexpr uint32_t DATA1 = (12 << 0);  ///< DAC1 Data Bits
    }

    /// DAC01DATA Register bits
    namespace dac01data_bits {
        constexpr uint32_t DATA0 = (12 << 0);  ///< DAC0 Data Bits
        constexpr uint32_t DATA1 = (12 << 16);  ///< DAC1 Data Bits
    }

    /// DAC0PATL Register bits
    namespace dac0patl_bits {
        constexpr uint32_t PAT0 = (5 << 0);  ///< Pattern Number 0 for PATGEN of DAC0
        constexpr uint32_t PAT1 = (5 << 5);  ///< Pattern Number 1 for PATGEN of DAC0
        constexpr uint32_t PAT2 = (5 << 10);  ///< Pattern Number 2 for PATGEN of DAC0
        constexpr uint32_t PAT3 = (5 << 15);  ///< Pattern Number 3 for PATGEN of DAC0
        constexpr uint32_t PAT4 = (5 << 20);  ///< Pattern Number 4 for PATGEN of DAC0
        constexpr uint32_t PAT5 = (5 << 25);  ///< Pattern Number 5 for PATGEN of DAC0
    }

    /// DAC0PATH Register bits
    namespace dac0path_bits {
        constexpr uint32_t PAT6 = (5 << 0);  ///< Pattern Number 6 for PATGEN of DAC0
        constexpr uint32_t PAT7 = (5 << 5);  ///< Pattern Number 7 for PATGEN of DAC0
        constexpr uint32_t PAT8 = (5 << 10);  ///< Pattern Number 8 for PATGEN of DAC0
    }

    /// DAC1PATL Register bits
    namespace dac1patl_bits {
        constexpr uint32_t PAT0 = (5 << 0);  ///< Pattern Number 0 for PATGEN of DAC1
        constexpr uint32_t PAT1 = (5 << 5);  ///< Pattern Number 1 for PATGEN of DAC1
        constexpr uint32_t PAT2 = (5 << 10);  ///< Pattern Number 2 for PATGEN of DAC1
        constexpr uint32_t PAT3 = (5 << 15);  ///< Pattern Number 3 for PATGEN of DAC1
        constexpr uint32_t PAT4 = (5 << 20);  ///< Pattern Number 4 for PATGEN of DAC1
        constexpr uint32_t PAT5 = (5 << 25);  ///< Pattern Number 5 for PATGEN of DAC1
    }

    /// DAC1PATH Register bits
    namespace dac1path_bits {
        constexpr uint32_t PAT6 = (5 << 0);  ///< Pattern Number 6 for PATGEN of DAC1
        constexpr uint32_t PAT7 = (5 << 5);  ///< Pattern Number 7 for PATGEN of DAC1
        constexpr uint32_t PAT8 = (5 << 10);  ///< Pattern Number 8 for PATGEN of DAC1
    }

}

// ============================================================================
// CCU40 Peripheral
// ============================================================================

namespace ccu40 {
    /// Base addresses
    constexpr uint32_t CCU40_BASE = 0x4000C000;
    constexpr uint32_t CCU40_CC40_BASE = 0x4000C100;
    constexpr uint32_t CCU40_CC41_BASE = 0x4000C200;
    constexpr uint32_t CCU40_CC42_BASE = 0x4000C300;
    constexpr uint32_t CCU40_CC43_BASE = 0x4000C400;

    /// CCU40 Register structure
    struct Registers {
        volatile uint32_t GCTRL;  ///< Offset: 0x00 - Global Control Register
        volatile uint32_t GSTAT;  ///< Offset: 0x04 - Global Status Register
        volatile uint32_t GIDLS;  ///< Offset: 0x08 - Global Idle Set
        volatile uint32_t GIDLC;  ///< Offset: 0x0C - Global Idle Clear
        volatile uint32_t GCSS;  ///< Offset: 0x10 - Global Channel Set
        volatile uint32_t GCSC;  ///< Offset: 0x14 - Global Channel Clear
        volatile uint32_t GCST;  ///< Offset: 0x18 - Global Channel Status
        volatile uint32_t ECRD;  ///< Offset: 0x50 - Extended Capture Mode Read
        volatile uint32_t MIDR;  ///< Offset: 0x80 - Module Identification
    };

    /// Peripheral instances
    inline Registers* CCU40 = reinterpret_cast<Registers*>(CCU40_BASE);
    inline Registers* CCU40_CC40 = reinterpret_cast<Registers*>(CCU40_CC40_BASE);
    inline Registers* CCU40_CC41 = reinterpret_cast<Registers*>(CCU40_CC41_BASE);
    inline Registers* CCU40_CC42 = reinterpret_cast<Registers*>(CCU40_CC42_BASE);
    inline Registers* CCU40_CC43 = reinterpret_cast<Registers*>(CCU40_CC43_BASE);

    // Bit definitions
    /// GCTRL Register bits
    namespace gctrl_bits {
        constexpr uint32_t PRBC = (3 << 0);  ///< Prescaler Clear Configuration
        constexpr uint32_t PCIS = (2 << 4);  ///< Prescaler Input Clock Selection
        constexpr uint32_t SUSCFG = (2 << 8);  ///< Suspend Mode Configuration
        constexpr uint32_t MSE0 = (1U << 10);  ///< Slice 0 Multi Channel shadow transfer enable
        constexpr uint32_t MSE1 = (1U << 11);  ///< Slice 1 Multi Channel shadow transfer enable
        constexpr uint32_t MSE2 = (1U << 12);  ///< Slice 2 Multi Channel shadow transfer enable
        constexpr uint32_t MSE3 = (1U << 13);  ///< Slice 3 Multi Channel shadow transfer enable
        constexpr uint32_t MSDE = (2 << 14);  ///< Multi Channel shadow transfer request configuration
    }

    /// GSTAT Register bits
    namespace gstat_bits {
        constexpr uint32_t S0I = (1U << 0);  ///< CC40 IDLE status
        constexpr uint32_t S1I = (1U << 1);  ///< CC41 IDLE status
        constexpr uint32_t S2I = (1U << 2);  ///< CC42 IDLE status
        constexpr uint32_t S3I = (1U << 3);  ///< CC43 IDLE status
        constexpr uint32_t PRB = (1U << 8);  ///< Prescaler Run Bit
    }

    /// GIDLS Register bits
    namespace gidls_bits {
        constexpr uint32_t SS0I = (1U << 0);  ///< CC40 IDLE mode set
        constexpr uint32_t SS1I = (1U << 1);  ///< CC41 IDLE mode set
        constexpr uint32_t SS2I = (1U << 2);  ///< CC42 IDLE mode set
        constexpr uint32_t SS3I = (1U << 3);  ///< CC43 IDLE mode set
        constexpr uint32_t CPRB = (1U << 8);  ///< Prescaler Run Bit Clear
        constexpr uint32_t PSIC = (1U << 9);  ///< Prescaler clear
    }

    /// GIDLC Register bits
    namespace gidlc_bits {
        constexpr uint32_t CS0I = (1U << 0);  ///< CC40 IDLE mode clear
        constexpr uint32_t CS1I = (1U << 1);  ///< CC41 IDLE mode clear
        constexpr uint32_t CS2I = (1U << 2);  ///< CC42 IDLE mode clear
        constexpr uint32_t CS3I = (1U << 3);  ///< CC43 IDLE mode clear
        constexpr uint32_t SPRB = (1U << 8);  ///< Prescaler Run Bit Set
    }

    /// GCSS Register bits
    namespace gcss_bits {
        constexpr uint32_t S0SE = (1U << 0);  ///< Slice 0 shadow transfer set enable
        constexpr uint32_t S0DSE = (1U << 1);  ///< Slice 0 Dither shadow transfer set enable
        constexpr uint32_t S0PSE = (1U << 2);  ///< Slice 0 Prescaler shadow transfer set enable
        constexpr uint32_t S1SE = (1U << 4);  ///< Slice 1 shadow transfer set enable
        constexpr uint32_t S1DSE = (1U << 5);  ///< Slice 1 Dither shadow transfer set enable
        constexpr uint32_t S1PSE = (1U << 6);  ///< Slice 1 Prescaler shadow transfer set enable
        constexpr uint32_t S2SE = (1U << 8);  ///< Slice 2 shadow transfer set enable
        constexpr uint32_t S2DSE = (1U << 9);  ///< Slice 2 Dither shadow transfer set enable
        constexpr uint32_t S2PSE = (1U << 10);  ///< Slice 2 Prescaler shadow transfer set enable
        constexpr uint32_t S3SE = (1U << 12);  ///< Slice 3 shadow transfer set enable
        constexpr uint32_t S3DSE = (1U << 13);  ///< Slice 3 Dither shadow transfer set enable
        constexpr uint32_t S3PSE = (1U << 14);  ///< Slice 3 Prescaler shadow transfer set enable
        constexpr uint32_t S0STS = (1U << 16);  ///< Slice 0 status bit set
        constexpr uint32_t S1STS = (1U << 17);  ///< Slice 1 status bit set
        constexpr uint32_t S2STS = (1U << 18);  ///< Slice 2 status bit set
        constexpr uint32_t S3STS = (1U << 19);  ///< Slice 3 status bit set
    }

    /// GCSC Register bits
    namespace gcsc_bits {
        constexpr uint32_t S0SC = (1U << 0);  ///< Slice 0 shadow transfer clear
        constexpr uint32_t S0DSC = (1U << 1);  ///< Slice 0 Dither shadow transfer clear
        constexpr uint32_t S0PSC = (1U << 2);  ///< Slice 0 Prescaler shadow transfer clear
        constexpr uint32_t S1SC = (1U << 4);  ///< Slice 1 shadow transfer clear
        constexpr uint32_t S1DSC = (1U << 5);  ///< Slice 1 Dither shadow transfer clear
        constexpr uint32_t S1PSC = (1U << 6);  ///< Slice 1 Prescaler shadow transfer clear
        constexpr uint32_t S2SC = (1U << 8);  ///< Slice 2 shadow transfer clear
        constexpr uint32_t S2DSC = (1U << 9);  ///< Slice 2 Dither shadow transfer clear
        constexpr uint32_t S2PSC = (1U << 10);  ///< Slice 2 Prescaler shadow transfer clear
        constexpr uint32_t S3SC = (1U << 12);  ///< Slice 3 shadow transfer clear
        constexpr uint32_t S3DSC = (1U << 13);  ///< Slice 3 Dither shadow transfer clear
        constexpr uint32_t S3PSC = (1U << 14);  ///< Slice 3 Prescaler shadow transfer clear
        constexpr uint32_t S0STC = (1U << 16);  ///< Slice 0 status bit clear
        constexpr uint32_t S1STC = (1U << 17);  ///< Slice 1 status bit clear
        constexpr uint32_t S2STC = (1U << 18);  ///< Slice 2 status bit clear
        constexpr uint32_t S3STC = (1U << 19);  ///< Slice 3 status bit clear
    }

    /// GCST Register bits
    namespace gcst_bits {
        constexpr uint32_t S0SS = (1U << 0);  ///< Slice 0 shadow transfer status
        constexpr uint32_t S0DSS = (1U << 1);  ///< Slice 0 Dither shadow transfer status
        constexpr uint32_t S0PSS = (1U << 2);  ///< Slice 0 Prescaler shadow transfer status
        constexpr uint32_t S1SS = (1U << 4);  ///< Slice 1 shadow transfer status
        constexpr uint32_t S1DSS = (1U << 5);  ///< Slice 1 Dither shadow transfer status
        constexpr uint32_t S1PSS = (1U << 6);  ///< Slice 1 Prescaler shadow transfer status
        constexpr uint32_t S2SS = (1U << 8);  ///< Slice 2 shadow transfer status
        constexpr uint32_t S2DSS = (1U << 9);  ///< Slice 2 Dither shadow transfer status
        constexpr uint32_t S2PSS = (1U << 10);  ///< Slice 2 Prescaler shadow transfer status
        constexpr uint32_t S3SS = (1U << 12);  ///< Slice 3 shadow transfer status
        constexpr uint32_t S3DSS = (1U << 13);  ///< Slice 3 Dither shadow transfer status
        constexpr uint32_t S3PSS = (1U << 14);  ///< Slice 3 Prescaler shadow transfer status
        constexpr uint32_t CC40ST = (1U << 16);  ///< Slice 0 status bit
        constexpr uint32_t CC41ST = (1U << 17);  ///< Slice 1 status bit
        constexpr uint32_t CC42ST = (1U << 18);  ///< Slice 2 status bit
        constexpr uint32_t CC43ST = (1U << 19);  ///< Slice 3 status bit
    }

    /// ECRD Register bits
    namespace ecrd_bits {
        constexpr uint32_t CAPV = (16 << 0);  ///< Timer Capture Value
        constexpr uint32_t FPCV = (4 << 16);  ///< Prescaler Capture value
        constexpr uint32_t SPTR = (2 << 20);  ///< Slice pointer
        constexpr uint32_t VPTR = (2 << 22);  ///< Capture register pointer
        constexpr uint32_t FFL = (1U << 24);  ///< Full Flag
    }

    /// MIDR Register bits
    namespace midr_bits {
        constexpr uint32_t MODR = (8 << 0);  ///< Module Revision
        constexpr uint32_t MODT = (8 << 8);  ///< Module Type
        constexpr uint32_t MODN = (16 << 16);  ///< Module Number
    }

}

// ============================================================================
// CCU41 Peripheral
// ============================================================================

namespace ccu41 {
    /// Base addresses
    constexpr uint32_t CCU41_BASE = 0x40010000;
    constexpr uint32_t CCU41_CC40_BASE = 0x40010100;
    constexpr uint32_t CCU41_CC41_BASE = 0x40010200;
    constexpr uint32_t CCU41_CC42_BASE = 0x40010300;
    constexpr uint32_t CCU41_CC43_BASE = 0x40010400;

    /// CCU41 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CCU41 = reinterpret_cast<Registers*>(CCU41_BASE);
    inline Registers* CCU41_CC40 = reinterpret_cast<Registers*>(CCU41_CC40_BASE);
    inline Registers* CCU41_CC41 = reinterpret_cast<Registers*>(CCU41_CC41_BASE);
    inline Registers* CCU41_CC42 = reinterpret_cast<Registers*>(CCU41_CC42_BASE);
    inline Registers* CCU41_CC43 = reinterpret_cast<Registers*>(CCU41_CC43_BASE);

}

// ============================================================================
// CCU42 Peripheral
// ============================================================================

namespace ccu42 {
    /// Base addresses
    constexpr uint32_t CCU42_BASE = 0x40014000;
    constexpr uint32_t CCU42_CC40_BASE = 0x40014100;
    constexpr uint32_t CCU42_CC41_BASE = 0x40014200;
    constexpr uint32_t CCU42_CC42_BASE = 0x40014300;
    constexpr uint32_t CCU42_CC43_BASE = 0x40014400;

    /// CCU42 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CCU42 = reinterpret_cast<Registers*>(CCU42_BASE);
    inline Registers* CCU42_CC40 = reinterpret_cast<Registers*>(CCU42_CC40_BASE);
    inline Registers* CCU42_CC41 = reinterpret_cast<Registers*>(CCU42_CC41_BASE);
    inline Registers* CCU42_CC42 = reinterpret_cast<Registers*>(CCU42_CC42_BASE);
    inline Registers* CCU42_CC43 = reinterpret_cast<Registers*>(CCU42_CC43_BASE);

}

// ============================================================================
// CCU43 Peripheral
// ============================================================================

namespace ccu43 {
    /// Base addresses
    constexpr uint32_t CCU43_BASE = 0x48004000;
    constexpr uint32_t CCU43_CC40_BASE = 0x48004100;
    constexpr uint32_t CCU43_CC41_BASE = 0x48004200;
    constexpr uint32_t CCU43_CC42_BASE = 0x48004300;
    constexpr uint32_t CCU43_CC43_BASE = 0x48004400;

    /// CCU43 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CCU43 = reinterpret_cast<Registers*>(CCU43_BASE);
    inline Registers* CCU43_CC40 = reinterpret_cast<Registers*>(CCU43_CC40_BASE);
    inline Registers* CCU43_CC41 = reinterpret_cast<Registers*>(CCU43_CC41_BASE);
    inline Registers* CCU43_CC42 = reinterpret_cast<Registers*>(CCU43_CC42_BASE);
    inline Registers* CCU43_CC43 = reinterpret_cast<Registers*>(CCU43_CC43_BASE);

}

// ============================================================================
// CCU80 Peripheral
// ============================================================================

namespace ccu80 {
    /// Base addresses
    constexpr uint32_t CCU80_BASE = 0x40020000;
    constexpr uint32_t CCU80_CC80_BASE = 0x40020100;
    constexpr uint32_t CCU80_CC81_BASE = 0x40020200;
    constexpr uint32_t CCU80_CC82_BASE = 0x40020300;
    constexpr uint32_t CCU80_CC83_BASE = 0x40020400;

    /// CCU80 Register structure
    struct Registers {
        volatile uint32_t GCTRL;  ///< Offset: 0x00 - Global Control Register
        volatile uint32_t GSTAT;  ///< Offset: 0x04 - Global Status Register
        volatile uint32_t GIDLS;  ///< Offset: 0x08 - Global Idle Set
        volatile uint32_t GIDLC;  ///< Offset: 0x0C - Global Idle Clear
        volatile uint32_t GCSS;  ///< Offset: 0x10 - Global Channel Set
        volatile uint32_t GCSC;  ///< Offset: 0x14 - Global Channel Clear
        volatile uint32_t GCST;  ///< Offset: 0x18 - Global Channel status
        volatile uint32_t GPCHK;  ///< Offset: 0x1C - Parity Checker Configuration
        volatile uint32_t ECRD;  ///< Offset: 0x50 - Extended Capture Mode Read
        volatile uint32_t MIDR;  ///< Offset: 0x80 - Module Identification
    };

    /// Peripheral instances
    inline Registers* CCU80 = reinterpret_cast<Registers*>(CCU80_BASE);
    inline Registers* CCU80_CC80 = reinterpret_cast<Registers*>(CCU80_CC80_BASE);
    inline Registers* CCU80_CC81 = reinterpret_cast<Registers*>(CCU80_CC81_BASE);
    inline Registers* CCU80_CC82 = reinterpret_cast<Registers*>(CCU80_CC82_BASE);
    inline Registers* CCU80_CC83 = reinterpret_cast<Registers*>(CCU80_CC83_BASE);

    // Bit definitions
    /// GCTRL Register bits
    namespace gctrl_bits {
        constexpr uint32_t PRBC = (3 << 0);  ///< Prescaler Clear Configuration
        constexpr uint32_t PCIS = (2 << 4);  ///< Prescaler Input Clock Selection
        constexpr uint32_t SUSCFG = (2 << 8);  ///< Suspend Mode Configuration
        constexpr uint32_t MSE0 = (1U << 10);  ///< Slice 0 Multi Channel shadow transfer enable
        constexpr uint32_t MSE1 = (1U << 11);  ///< Slice 1 Multi Channel shadow transfer enable
        constexpr uint32_t MSE2 = (1U << 12);  ///< Slice 2 Multi Channel shadow transfer enable
        constexpr uint32_t MSE3 = (1U << 13);  ///< Slice 3 Multi Channel shadow transfer enable
        constexpr uint32_t MSDE = (2 << 14);  ///< Multi Channel shadow transfer request configuration
    }

    /// GSTAT Register bits
    namespace gstat_bits {
        constexpr uint32_t S0I = (1U << 0);  ///< CC80 IDLE status
        constexpr uint32_t S1I = (1U << 1);  ///< CC81 IDLE status
        constexpr uint32_t S2I = (1U << 2);  ///< CC82 IDLE status
        constexpr uint32_t S3I = (1U << 3);  ///< CC83 IDLE status
        constexpr uint32_t PRB = (1U << 8);  ///< Prescaler Run Bit
        constexpr uint32_t PCRB = (1U << 10);  ///< Parity Checker Run Bit
    }

    /// GIDLS Register bits
    namespace gidls_bits {
        constexpr uint32_t SS0I = (1U << 0);  ///< CC80 IDLE mode set
        constexpr uint32_t SS1I = (1U << 1);  ///< CC81 IDLE mode set
        constexpr uint32_t SS2I = (1U << 2);  ///< CC82 IDLE mode set
        constexpr uint32_t SS3I = (1U << 3);  ///< CC83 IDLE mode set
        constexpr uint32_t CPRB = (1U << 8);  ///< Prescaler# Run Bit Clear
        constexpr uint32_t PSIC = (1U << 9);  ///< Prescaler clear
        constexpr uint32_t CPCH = (1U << 10);  ///< Parity Checker Run bit clear
    }

    /// GIDLC Register bits
    namespace gidlc_bits {
        constexpr uint32_t CS0I = (1U << 0);  ///< CC80 IDLE mode clear
        constexpr uint32_t CS1I = (1U << 1);  ///< CC81 IDLE mode clear
        constexpr uint32_t CS2I = (1U << 2);  ///< CC82 IDLE mode clear
        constexpr uint32_t CS3I = (1U << 3);  ///< CC83 IDLE mode clear
        constexpr uint32_t SPRB = (1U << 8);  ///< Prescaler Run Bit Set
        constexpr uint32_t SPCH = (1U << 10);  ///< Parity Checker run bit set
    }

    /// GCSS Register bits
    namespace gcss_bits {
        constexpr uint32_t S0SE = (1U << 0);  ///< Slice 0 shadow transfer set enable
        constexpr uint32_t S0DSE = (1U << 1);  ///< Slice 0 Dither shadow transfer set enable
        constexpr uint32_t S0PSE = (1U << 2);  ///< Slice 0 Prescaler shadow transfer set enable
        constexpr uint32_t S1SE = (1U << 4);  ///< Slice 1 shadow transfer set enable
        constexpr uint32_t S1DSE = (1U << 5);  ///< Slice 1 Dither shadow transfer set enable
        constexpr uint32_t S1PSE = (1U << 6);  ///< Slice 1 Prescaler shadow transfer set enable
        constexpr uint32_t S2SE = (1U << 8);  ///< Slice 2 shadow transfer set enable
        constexpr uint32_t S2DSE = (1U << 9);  ///< Slice 2 Dither shadow transfer set enable
        constexpr uint32_t S2PSE = (1U << 10);  ///< Slice 2 Prescaler shadow transfer set enable
        constexpr uint32_t S3SE = (1U << 12);  ///< Slice 3 shadow transfer set enable
        constexpr uint32_t S3DSE = (1U << 13);  ///< Slice 3 Dither shadow transfer set enable
        constexpr uint32_t S3PSE = (1U << 14);  ///< Slice 3 Prescaler shadow transfer set enable
        constexpr uint32_t S0ST1S = (1U << 16);  ///< Slice 0 status bit 1 set
        constexpr uint32_t S1ST1S = (1U << 17);  ///< Slice 1 status bit 1 set
        constexpr uint32_t S2ST1S = (1U << 18);  ///< Slice 2 status bit 1 set
        constexpr uint32_t S3ST1S = (1U << 19);  ///< Slice 3 status bit 1 set
        constexpr uint32_t S0ST2S = (1U << 20);  ///< Slice 0 status bit 2 set
        constexpr uint32_t S1ST2S = (1U << 21);  ///< Slice 1 status bit 2 set
        constexpr uint32_t S2ST2S = (1U << 22);  ///< Slice 2 status bit 2 set
        constexpr uint32_t S3ST2S = (1U << 23);  ///< Slice 3 status bit 2 set
    }

    /// GCSC Register bits
    namespace gcsc_bits {
        constexpr uint32_t S0SC = (1U << 0);  ///< Slice 0 shadow transfer request clear
        constexpr uint32_t S0DSC = (1U << 1);  ///< Slice 0 Dither shadow transfer clear
        constexpr uint32_t S0PSC = (1U << 2);  ///< Slice 0 Prescaler shadow transfer clear
        constexpr uint32_t S1SC = (1U << 4);  ///< Slice 1 shadow transfer clear
        constexpr uint32_t S1DSC = (1U << 5);  ///< Slice 1 Dither shadow transfer clear
        constexpr uint32_t S1PSC = (1U << 6);  ///< Slice 1 Prescaler shadow transfer clear
        constexpr uint32_t S2SC = (1U << 8);  ///< Slice 2 shadow transfer clear
        constexpr uint32_t S2DSC = (1U << 9);  ///< Slice 2 Dither shadow transfer clear
        constexpr uint32_t S2PSC = (1U << 10);  ///< Slice 2 Prescaler shadow transfer clear
        constexpr uint32_t S3SC = (1U << 12);  ///< Slice 3 shadow transfer clear
        constexpr uint32_t S3DSC = (1U << 13);  ///< Slice 3 Dither shadow transfer clear
        constexpr uint32_t S3PSC = (1U << 14);  ///< Slice 3 Prescaler shadow transfer clear
        constexpr uint32_t S0ST1C = (1U << 16);  ///< Slice 0 status bit 1 clear
        constexpr uint32_t S1ST1C = (1U << 17);  ///< Slice 1 status bit 1 clear
        constexpr uint32_t S2ST1C = (1U << 18);  ///< Slice 2 status bit 1 clear
        constexpr uint32_t S3ST1C = (1U << 19);  ///< Slice 3 status bit 1 clear
        constexpr uint32_t S0ST2C = (1U << 20);  ///< Slice 0 status bit 2 clear
        constexpr uint32_t S1ST2C = (1U << 21);  ///< Slice 1 status bit 2 clear
        constexpr uint32_t S2ST2C = (1U << 22);  ///< Slice 2 status bit 2 clear
        constexpr uint32_t S3ST2C = (1U << 23);  ///< Slice 3 status bit 2 clear
    }

    /// GCST Register bits
    namespace gcst_bits {
        constexpr uint32_t S0SS = (1U << 0);  ///< Slice 0 shadow transfer status
        constexpr uint32_t S0DSS = (1U << 1);  ///< Slice 0 Dither shadow transfer status
        constexpr uint32_t S0PSS = (1U << 2);  ///< Slice 0 Prescaler shadow transfer status
        constexpr uint32_t S1SS = (1U << 4);  ///< Slice 1 shadow transfer status
        constexpr uint32_t S1DSS = (1U << 5);  ///< Slice 1 Dither shadow transfer status
        constexpr uint32_t S1PSS = (1U << 6);  ///< Slice 1 Prescaler shadow transfer status
        constexpr uint32_t S2SS = (1U << 8);  ///< Slice 2 shadow transfer status
        constexpr uint32_t S2DSS = (1U << 9);  ///< Slice 2 Dither shadow transfer status
        constexpr uint32_t S2PSS = (1U << 10);  ///< Slice 2 Prescaler shadow transfer status
        constexpr uint32_t S3SS = (1U << 12);  ///< Slice 3 shadow transfer status
        constexpr uint32_t S3DSS = (1U << 13);  ///< Slice 3 Dither shadow transfer status
        constexpr uint32_t S3PSS = (1U << 14);  ///< Slice 3 Prescaler shadow transfer status
        constexpr uint32_t CC80ST1 = (1U << 16);  ///< Slice 0 compare channel 1 status bit
        constexpr uint32_t CC81ST1 = (1U << 17);  ///< Slice 1 compare channel 1 status bit
        constexpr uint32_t CC82ST1 = (1U << 18);  ///< Slice 2 compare channel 1 status bit
        constexpr uint32_t CC83ST1 = (1U << 19);  ///< Slice 3 compare channel 1 status bit
        constexpr uint32_t CC80ST2 = (1U << 20);  ///< Slice 0 compare channel 2 status bit
        constexpr uint32_t CC81ST2 = (1U << 21);  ///< Slice 1 compare channel 2 status bit
        constexpr uint32_t CC82ST2 = (1U << 22);  ///< Slice 2 compare channel 2 status bit
        constexpr uint32_t CC83ST2 = (1U << 23);  ///< Slice 3 compare channel 2 status bit
    }

    /// GPCHK Register bits
    namespace gpchk_bits {
        constexpr uint32_t PASE = (1U << 0);  ///< Parity Checker Automatic start/stop
        constexpr uint32_t PACS = (2 << 1);  ///< Parity Checker Automatic start/stop selector
        constexpr uint32_t PISEL = (2 << 3);  ///< Driver Input signal selector
        constexpr uint32_t PCDS = (2 << 5);  ///< Parity Checker Delay Input Selector
        constexpr uint32_t PCTS = (1U << 7);  ///< Parity Checker type selector
        constexpr uint32_t PCST = (1U << 15);  ///< Parity Checker XOR status
        constexpr uint32_t PCSEL0 = (4 << 16);  ///< Parity Checker Slice 0 output selection
        constexpr uint32_t PCSEL1 = (4 << 20);  ///< Parity Checker Slice 1 output selection
        constexpr uint32_t PCSEL2 = (4 << 24);  ///< Parity Checker Slice 2 output selection
        constexpr uint32_t PCSEL3 = (4 << 28);  ///< Parity Checker Slice 3 output selection
    }

    /// ECRD Register bits
    namespace ecrd_bits {
        constexpr uint32_t CAPV = (16 << 0);  ///< Timer Capture Value
        constexpr uint32_t FPCV = (4 << 16);  ///< Prescaler Capture value
        constexpr uint32_t SPTR = (2 << 20);  ///< Slice pointer
        constexpr uint32_t VPTR = (2 << 22);  ///< Capture register pointer
        constexpr uint32_t FFL = (1U << 24);  ///< Full Flag
    }

    /// MIDR Register bits
    namespace midr_bits {
        constexpr uint32_t MODR = (8 << 0);  ///< Module Revision
        constexpr uint32_t MODT = (8 << 8);  ///< Module Type
        constexpr uint32_t MODN = (16 << 16);  ///< Module Number
    }

}

// ============================================================================
// CCU81 Peripheral
// ============================================================================

namespace ccu81 {
    /// Base addresses
    constexpr uint32_t CCU81_BASE = 0x40024000;
    constexpr uint32_t CCU81_CC80_BASE = 0x40024100;
    constexpr uint32_t CCU81_CC81_BASE = 0x40024200;
    constexpr uint32_t CCU81_CC82_BASE = 0x40024300;
    constexpr uint32_t CCU81_CC83_BASE = 0x40024400;

    /// CCU81 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CCU81 = reinterpret_cast<Registers*>(CCU81_BASE);
    inline Registers* CCU81_CC80 = reinterpret_cast<Registers*>(CCU81_CC80_BASE);
    inline Registers* CCU81_CC81 = reinterpret_cast<Registers*>(CCU81_CC81_BASE);
    inline Registers* CCU81_CC82 = reinterpret_cast<Registers*>(CCU81_CC82_BASE);
    inline Registers* CCU81_CC83 = reinterpret_cast<Registers*>(CCU81_CC83_BASE);

}

// ============================================================================
// POSIF0 Peripheral
// ============================================================================

namespace posif0 {
    /// Base addresses
    constexpr uint32_t POSIF0_BASE = 0x40028000;

    /// POSIF0 Register structure
    struct Registers {
        volatile uint32_t PCONF;  ///< Offset: 0x00 - POSIF configuration
        volatile uint32_t PSUS;  ///< Offset: 0x04 - POSIF Suspend Config
        volatile uint32_t PRUNS;  ///< Offset: 0x08 - POSIF Run Bit Set
        volatile uint32_t PRUNC;  ///< Offset: 0x0C - POSIF Run Bit Clear
        volatile uint32_t PRUN;  ///< Offset: 0x10 - POSIF Run Bit Status
        volatile uint32_t MIDR;  ///< Offset: 0x20 - Module Identification register
        volatile uint32_t HALP;  ///< Offset: 0x30 - Hall Sensor Patterns
        volatile uint32_t HALPS;  ///< Offset: 0x34 - Hall Sensor Shadow Patterns
        volatile uint32_t MCM;  ///< Offset: 0x40 - Multi-Channel Pattern
        volatile uint32_t MCSM;  ///< Offset: 0x44 - Multi-Channel Shadow Pattern
        volatile uint32_t MCMS;  ///< Offset: 0x48 - Multi-Channel Pattern Control set
        volatile uint32_t MCMC;  ///< Offset: 0x4C - Multi-Channel Pattern Control clear
        volatile uint32_t MCMF;  ///< Offset: 0x50 - Multi-Channel Pattern Control flag
        volatile uint32_t QDC;  ///< Offset: 0x60 - Quadrature Decoder Control
        volatile uint32_t PFLG;  ///< Offset: 0x70 - POSIF Interrupt Flags
        volatile uint32_t PFLGE;  ///< Offset: 0x74 - POSIF Interrupt Enable
        volatile uint32_t SPFLG;  ///< Offset: 0x78 - POSIF Interrupt Set
        volatile uint32_t RPFLG;  ///< Offset: 0x7C - POSIF Interrupt Clear
        volatile uint32_t PDBG;  ///< Offset: 0x100 - POSIF Debug register
    };

    /// Peripheral instances
    inline Registers* POSIF0 = reinterpret_cast<Registers*>(POSIF0_BASE);

    // Bit definitions
    /// PCONF Register bits
    namespace pconf_bits {
        constexpr uint32_t FSEL = (2 << 0);  ///< Function Selector
        constexpr uint32_t QDCM = (1U << 2);  ///< Position Decoder Mode selection
        constexpr uint32_t HIDG = (1U << 4);  ///< Idle generation enable
        constexpr uint32_t MCUE = (1U << 5);  ///< Multi-Channel Pattern SW update enable
        constexpr uint32_t INSEL0 = (2 << 8);  ///< PhaseA/Hal input 1 selector
        constexpr uint32_t INSEL1 = (2 << 10);  ///< PhaseB/Hall input 2 selector
        constexpr uint32_t INSEL2 = (2 << 12);  ///< Index/Hall input 3 selector
        constexpr uint32_t DSEL = (1U << 16);  ///< Delay Pin selector
        constexpr uint32_t SPES = (1U << 17);  ///< Edge selector for the sampling trigger
        constexpr uint32_t MSETS = (3 << 18);  ///< Pattern update signal select
        constexpr uint32_t MSES = (1U << 21);  ///< Multi-Channel pattern update trigger edge
        constexpr uint32_t MSYNS = (2 << 22);  ///< PWM synchronization signal selector
        constexpr uint32_t EWIS = (2 << 24);  ///< Wrong Hall Event selection
        constexpr uint32_t EWIE = (1U << 26);  ///< External Wrong Hall Event enable
        constexpr uint32_t EWIL = (1U << 27);  ///< External Wrong Hall Event active level
        constexpr uint32_t LPC = (3 << 28);  ///< Low Pass Filters Configuration
    }

    /// PSUS Register bits
    namespace psus_bits {
        constexpr uint32_t QSUS = (2 << 0);  ///< Quadrature Mode Suspend Config
        constexpr uint32_t MSUS = (2 << 2);  ///< Multi-Channel Mode Suspend Config
    }

    /// PRUNS Register bits
    namespace pruns_bits {
        constexpr uint32_t SRB = (1U << 0);  ///< Set Run bit
    }

    /// PRUNC Register bits
    namespace prunc_bits {
        constexpr uint32_t CRB = (1U << 0);  ///< Clear Run bit
        constexpr uint32_t CSM = (1U << 1);  ///< Clear Current internal status
    }

    /// PRUN Register bits
    namespace prun_bits {
        constexpr uint32_t RB = (1U << 0);  ///< Run Bit
    }

    /// MIDR Register bits
    namespace midr_bits {
        constexpr uint32_t MODR = (8 << 0);  ///< Module Revision
        constexpr uint32_t MODT = (8 << 8);  ///< Module Type
        constexpr uint32_t MODN = (16 << 16);  ///< Module Number
    }

    /// HALP Register bits
    namespace halp_bits {
        constexpr uint32_t HCP = (3 << 0);  ///< Hall Current Pattern
        constexpr uint32_t HEP = (3 << 3);  ///< Hall Expected Pattern
    }

    /// HALPS Register bits
    namespace halps_bits {
        constexpr uint32_t HCPS = (3 << 0);  ///< Shadow Hall Current Pattern
        constexpr uint32_t HEPS = (3 << 3);  ///< Shadow Hall expected Pattern
    }

    /// MCM Register bits
    namespace mcm_bits {
        constexpr uint32_t MCMP = (16 << 0);  ///< Multi-Channel Pattern
    }

    /// MCSM Register bits
    namespace mcsm_bits {
        constexpr uint32_t MCMPS = (16 << 0);  ///< Shadow Multi-Channel Pattern
    }

    /// MCMS Register bits
    namespace mcms_bits {
        constexpr uint32_t MNPS = (1U << 0);  ///< Multi-Channel Pattern Update Enable Set
        constexpr uint32_t STHR = (1U << 1);  ///< Hall Pattern Shadow Transfer Request
        constexpr uint32_t STMR = (1U << 2);  ///< Multi-Channel Shadow Transfer Request
    }

    /// MCMC Register bits
    namespace mcmc_bits {
        constexpr uint32_t MNPC = (1U << 0);  ///< Multi-Channel Pattern Update Enable Clear
        constexpr uint32_t MPC = (1U << 1);  ///< Multi-Channel Pattern clear
    }

    /// MCMF Register bits
    namespace mcmf_bits {
        constexpr uint32_t MSS = (1U << 0);  ///< Multi-Channel Pattern update status
    }

    /// QDC Register bits
    namespace qdc_bits {
        constexpr uint32_t PALS = (1U << 0);  ///< Phase A Level selector
        constexpr uint32_t PBLS = (1U << 1);  ///< Phase B Level selector
        constexpr uint32_t PHS = (1U << 2);  ///< Phase signals swap
        constexpr uint32_t ICM = (2 << 4);  ///< Index Marker generations control
        constexpr uint32_t DVAL = (1U << 8);  ///< Current rotation direction
    }

    /// PFLG Register bits
    namespace pflg_bits {
        constexpr uint32_t CHES = (1U << 0);  ///< Correct Hall Event Status
        constexpr uint32_t WHES = (1U << 1);  ///< Wrong Hall Event Status
        constexpr uint32_t HIES = (1U << 2);  ///< Hall Inputs Update Status
        constexpr uint32_t MSTS = (1U << 4);  ///< Multi-Channel pattern shadow transfer status
        constexpr uint32_t INDXS = (1U << 8);  ///< Quadrature Index Status
        constexpr uint32_t ERRS = (1U << 9);  ///< Quadrature Phase Error Status
        constexpr uint32_t CNTS = (1U << 10);  ///< Quadrature CLK Status
        constexpr uint32_t DIRS = (1U << 11);  ///< Quadrature Direction Change
        constexpr uint32_t PCLKS = (1U << 12);  ///< Quadrature Period Clk Status
    }

    /// PFLGE Register bits
    namespace pflge_bits {
        constexpr uint32_t ECHE = (1U << 0);  ///< Correct Hall Event Enable
        constexpr uint32_t EWHE = (1U << 1);  ///< Wrong Hall Event Enable
        constexpr uint32_t EHIE = (1U << 2);  ///< Hall Input Update Enable
        constexpr uint32_t EMST = (1U << 4);  ///< Multi-Channel pattern shadow transfer enable
        constexpr uint32_t EINDX = (1U << 8);  ///< Quadrature Index Event Enable
        constexpr uint32_t EERR = (1U << 9);  ///< Quadrature Phase Error Enable
        constexpr uint32_t ECNT = (1U << 10);  ///< Quadrature CLK interrupt Enable
        constexpr uint32_t EDIR = (1U << 11);  ///< Quadrature direction change interrupt Enable
        constexpr uint32_t EPCLK = (1U << 12);  ///< Quadrature Period CLK interrupt Enable
        constexpr uint32_t CHESEL = (1U << 16);  ///< Correct Hall Event Service Request Selector
        constexpr uint32_t WHESEL = (1U << 17);  ///< Wrong Hall Event Service Request Selector
        constexpr uint32_t HIESEL = (1U << 18);  ///< Hall Inputs Update Event Service Request Selector
        constexpr uint32_t MSTSEL = (1U << 20);  ///< Multi-Channel pattern Update Event Service Request Selector
        constexpr uint32_t INDSEL = (1U << 24);  ///< Quadrature Index Event Service Request Selector
        constexpr uint32_t ERRSEL = (1U << 25);  ///< Quadrature Phase Error Event Service Request Selector
        constexpr uint32_t CNTSEL = (1U << 26);  ///< Quadrature Clock Event Service Request Selector
        constexpr uint32_t DIRSEL = (1U << 27);  ///< Quadrature Direction Update Event Service Request Selector
        constexpr uint32_t PCLSEL = (1U << 28);  ///< Quadrature Period clock Event Service Request Selector
    }

    /// SPFLG Register bits
    namespace spflg_bits {
        constexpr uint32_t SCHE = (1U << 0);  ///< Correct Hall Event flag set
        constexpr uint32_t SWHE = (1U << 1);  ///< Wrong Hall Event flag set
        constexpr uint32_t SHIE = (1U << 2);  ///< Hall Inputs Update Event flag set
        constexpr uint32_t SMST = (1U << 4);  ///< Multi-Channel Pattern shadow transfer flag set
        constexpr uint32_t SINDX = (1U << 8);  ///< Quadrature Index flag set
        constexpr uint32_t SERR = (1U << 9);  ///< Quadrature Phase Error flag set
        constexpr uint32_t SCNT = (1U << 10);  ///< Quadrature CLK flag set
        constexpr uint32_t SDIR = (1U << 11);  ///< Quadrature Direction flag set
        constexpr uint32_t SPCLK = (1U << 12);  ///< Quadrature period clock flag set
    }

    /// RPFLG Register bits
    namespace rpflg_bits {
        constexpr uint32_t RCHE = (1U << 0);  ///< Correct Hall Event flag clear
        constexpr uint32_t RWHE = (1U << 1);  ///< Wrong Hall Event flag clear
        constexpr uint32_t RHIE = (1U << 2);  ///< Hall Inputs Update Event flag clear
        constexpr uint32_t RMST = (1U << 4);  ///< Multi-Channel Pattern shadow transfer flag clear
        constexpr uint32_t RINDX = (1U << 8);  ///< Quadrature Index flag clear
        constexpr uint32_t RERR = (1U << 9);  ///< Quadrature Phase Error flag clear
        constexpr uint32_t RCNT = (1U << 10);  ///< Quadrature CLK flag clear
        constexpr uint32_t RDIR = (1U << 11);  ///< Quadrature Direction flag clear
        constexpr uint32_t RPCLK = (1U << 12);  ///< Quadrature period clock flag clear
    }

    /// PDBG Register bits
    namespace pdbg_bits {
        constexpr uint32_t QCSV = (2 << 0);  ///< Quadrature Decoder Current state
        constexpr uint32_t QPSV = (2 << 2);  ///< Quadrature Decoder Previous state
        constexpr uint32_t IVAL = (1U << 4);  ///< Current Index Value
        constexpr uint32_t HSP = (3 << 5);  ///< Hall Current Sampled Pattern
        constexpr uint32_t LPP0 = (6 << 8);  ///< Actual count of the Low Pass Filter for POSI0
        constexpr uint32_t LPP1 = (6 << 16);  ///< Actual count of the Low Pass Filter for POSI1
        constexpr uint32_t LPP2 = (6 << 22);  ///< Actual count of the Low Pass Filter for POSI2
    }

}

// ============================================================================
// POSIF1 Peripheral
// ============================================================================

namespace posif1 {
    /// Base addresses
    constexpr uint32_t POSIF1_BASE = 0x4002C000;

    /// POSIF1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* POSIF1 = reinterpret_cast<Registers*>(POSIF1_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT0_BASE = 0x48028000;
    constexpr uint32_t PORT1_BASE = 0x48028100;
    constexpr uint32_t PORT2_BASE = 0x48028200;
    constexpr uint32_t PORT3_BASE = 0x48028300;
    constexpr uint32_t PORT4_BASE = 0x48028400;
    constexpr uint32_t PORT5_BASE = 0x48028500;
    constexpr uint32_t PORT6_BASE = 0x48028600;
    constexpr uint32_t PORT14_BASE = 0x48028E00;
    constexpr uint32_t PORT15_BASE = 0x48028F00;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t OUT;  ///< Offset: 0x00 - Port 0 Output Register
        volatile uint32_t OMR;  ///< Offset: 0x04 - Port 0 Output Modification Register
        volatile uint32_t IOCR0;  ///< Offset: 0x10 - Port 0 Input/Output Control Register 0
        volatile uint32_t IOCR4;  ///< Offset: 0x14 - Port 0 Input/Output Control Register 4
        volatile uint32_t IOCR8;  ///< Offset: 0x18 - Port 0 Input/Output Control Register 8
        volatile uint32_t IOCR12;  ///< Offset: 0x1C - Port 0 Input/Output Control Register 12
        volatile uint32_t IN;  ///< Offset: 0x24 - Port 0 Input Register
        volatile uint32_t PDR0;  ///< Offset: 0x40 - Port 0 Pad Driver Mode 0 Register
        volatile uint32_t PDR1;  ///< Offset: 0x44 - Port 0 Pad Driver Mode 1 Register
        volatile uint32_t PDISC;  ///< Offset: 0x60 - Port 0 Pin Function Decision Control Register
        volatile uint32_t PPS;  ///< Offset: 0x70 - Port 0 Pin Power Save Register
        volatile uint32_t HWSEL;  ///< Offset: 0x74 - Port 0 Pin Hardware Select Register
    };

    /// Peripheral instances
    inline Registers* PORT0 = reinterpret_cast<Registers*>(PORT0_BASE);
    inline Registers* PORT1 = reinterpret_cast<Registers*>(PORT1_BASE);
    inline Registers* PORT2 = reinterpret_cast<Registers*>(PORT2_BASE);
    inline Registers* PORT3 = reinterpret_cast<Registers*>(PORT3_BASE);
    inline Registers* PORT4 = reinterpret_cast<Registers*>(PORT4_BASE);
    inline Registers* PORT5 = reinterpret_cast<Registers*>(PORT5_BASE);
    inline Registers* PORT6 = reinterpret_cast<Registers*>(PORT6_BASE);
    inline Registers* PORT14 = reinterpret_cast<Registers*>(PORT14_BASE);
    inline Registers* PORT15 = reinterpret_cast<Registers*>(PORT15_BASE);

    // Bit definitions
    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Port n Output Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Port n Output Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Port n Output Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Port n Output Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Port n Output Bit 4
        constexpr uint32_t P5 = (1U << 5);  ///< Port n Output Bit 5
        constexpr uint32_t P6 = (1U << 6);  ///< Port n Output Bit 6
        constexpr uint32_t P7 = (1U << 7);  ///< Port n Output Bit 7
        constexpr uint32_t P8 = (1U << 8);  ///< Port n Output Bit 8
        constexpr uint32_t P9 = (1U << 9);  ///< Port n Output Bit 9
        constexpr uint32_t P10 = (1U << 10);  ///< Port n Output Bit 10
        constexpr uint32_t P11 = (1U << 11);  ///< Port n Output Bit 11
        constexpr uint32_t P12 = (1U << 12);  ///< Port n Output Bit 12
        constexpr uint32_t P13 = (1U << 13);  ///< Port n Output Bit 13
        constexpr uint32_t P14 = (1U << 14);  ///< Port n Output Bit 14
        constexpr uint32_t P15 = (1U << 15);  ///< Port n Output Bit 15
    }

    /// OMR Register bits
    namespace omr_bits {
        constexpr uint32_t PS0 = (1U << 0);  ///< Port n Set Bit 0
        constexpr uint32_t PS1 = (1U << 1);  ///< Port n Set Bit 1
        constexpr uint32_t PS2 = (1U << 2);  ///< Port n Set Bit 2
        constexpr uint32_t PS3 = (1U << 3);  ///< Port n Set Bit 3
        constexpr uint32_t PS4 = (1U << 4);  ///< Port n Set Bit 4
        constexpr uint32_t PS5 = (1U << 5);  ///< Port n Set Bit 5
        constexpr uint32_t PS6 = (1U << 6);  ///< Port n Set Bit 6
        constexpr uint32_t PS7 = (1U << 7);  ///< Port n Set Bit 7
        constexpr uint32_t PS8 = (1U << 8);  ///< Port n Set Bit 8
        constexpr uint32_t PS9 = (1U << 9);  ///< Port n Set Bit 9
        constexpr uint32_t PS10 = (1U << 10);  ///< Port n Set Bit 10
        constexpr uint32_t PS11 = (1U << 11);  ///< Port n Set Bit 11
        constexpr uint32_t PS12 = (1U << 12);  ///< Port n Set Bit 12
        constexpr uint32_t PS13 = (1U << 13);  ///< Port n Set Bit 13
        constexpr uint32_t PS14 = (1U << 14);  ///< Port n Set Bit 14
        constexpr uint32_t PS15 = (1U << 15);  ///< Port n Set Bit 15
        constexpr uint32_t PR0 = (1U << 16);  ///< Port n Reset Bit 0
        constexpr uint32_t PR1 = (1U << 17);  ///< Port n Reset Bit 1
        constexpr uint32_t PR2 = (1U << 18);  ///< Port n Reset Bit 2
        constexpr uint32_t PR3 = (1U << 19);  ///< Port n Reset Bit 3
        constexpr uint32_t PR4 = (1U << 20);  ///< Port n Reset Bit 4
        constexpr uint32_t PR5 = (1U << 21);  ///< Port n Reset Bit 5
        constexpr uint32_t PR6 = (1U << 22);  ///< Port n Reset Bit 6
        constexpr uint32_t PR7 = (1U << 23);  ///< Port n Reset Bit 7
        constexpr uint32_t PR8 = (1U << 24);  ///< Port n Reset Bit 8
        constexpr uint32_t PR9 = (1U << 25);  ///< Port n Reset Bit 9
        constexpr uint32_t PR10 = (1U << 26);  ///< Port n Reset Bit 10
        constexpr uint32_t PR11 = (1U << 27);  ///< Port n Reset Bit 11
        constexpr uint32_t PR12 = (1U << 28);  ///< Port n Reset Bit 12
        constexpr uint32_t PR13 = (1U << 29);  ///< Port n Reset Bit 13
        constexpr uint32_t PR14 = (1U << 30);  ///< Port n Reset Bit 14
        constexpr uint32_t PR15 = (1U << 31);  ///< Port n Reset Bit 15
    }

    /// IOCR0 Register bits
    namespace iocr0_bits {
        constexpr uint32_t PC0 = (5 << 3);  ///< Port Control for Port n Pin 0 to 3
        constexpr uint32_t PC1 = (5 << 11);  ///< Port Control for Port n Pin 0 to 3
        constexpr uint32_t PC2 = (5 << 19);  ///< Port Control for Port n Pin 0 to 3
        constexpr uint32_t PC3 = (5 << 27);  ///< Port Control for Port n Pin 0 to 3
    }

    /// IOCR4 Register bits
    namespace iocr4_bits {
        constexpr uint32_t PC4 = (5 << 3);  ///< Port Control for Port n Pin 4 to 7
        constexpr uint32_t PC5 = (5 << 11);  ///< Port Control for Port n Pin 4 to 7
        constexpr uint32_t PC6 = (5 << 19);  ///< Port Control for Port n Pin 4 to 7
        constexpr uint32_t PC7 = (5 << 27);  ///< Port Control for Port n Pin 4 to 7
    }

    /// IOCR8 Register bits
    namespace iocr8_bits {
        constexpr uint32_t PC8 = (5 << 3);  ///< Port Control for Port n Pin 8 to 11
        constexpr uint32_t PC9 = (5 << 11);  ///< Port Control for Port n Pin 8 to 11
        constexpr uint32_t PC10 = (5 << 19);  ///< Port Control for Port n Pin 8 to 11
        constexpr uint32_t PC11 = (5 << 27);  ///< Port Control for Port n Pin 8 to 11
    }

    /// IOCR12 Register bits
    namespace iocr12_bits {
        constexpr uint32_t PC12 = (5 << 3);  ///< Port Control for Port n Pin 12 to 15
        constexpr uint32_t PC13 = (5 << 11);  ///< Port Control for Port n Pin 12 to 15
        constexpr uint32_t PC14 = (5 << 19);  ///< Port Control for Port n Pin 12 to 15
        constexpr uint32_t PC15 = (5 << 27);  ///< Port Control for Port n Pin 12 to 15
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Port n Input Bit 0
        constexpr uint32_t P1 = (1U << 1);  ///< Port n Input Bit 1
        constexpr uint32_t P2 = (1U << 2);  ///< Port n Input Bit 2
        constexpr uint32_t P3 = (1U << 3);  ///< Port n Input Bit 3
        constexpr uint32_t P4 = (1U << 4);  ///< Port n Input Bit 4
        constexpr uint32_t P5 = (1U << 5);  ///< Port n Input Bit 5
        constexpr uint32_t P6 = (1U << 6);  ///< Port n Input Bit 6
        constexpr uint32_t P7 = (1U << 7);  ///< Port n Input Bit 7
        constexpr uint32_t P8 = (1U << 8);  ///< Port n Input Bit 8
        constexpr uint32_t P9 = (1U << 9);  ///< Port n Input Bit 9
        constexpr uint32_t P10 = (1U << 10);  ///< Port n Input Bit 10
        constexpr uint32_t P11 = (1U << 11);  ///< Port n Input Bit 11
        constexpr uint32_t P12 = (1U << 12);  ///< Port n Input Bit 12
        constexpr uint32_t P13 = (1U << 13);  ///< Port n Input Bit 13
        constexpr uint32_t P14 = (1U << 14);  ///< Port n Input Bit 14
        constexpr uint32_t P15 = (1U << 15);  ///< Port n Input Bit 15
    }

    /// PDR0 Register bits
    namespace pdr0_bits {
        constexpr uint32_t PD0 = (3 << 0);  ///< Pad Driver Mode for Pn.0
        constexpr uint32_t PD1 = (3 << 4);  ///< Pad Driver Mode for Pn.1
        constexpr uint32_t PD2 = (3 << 8);  ///< Pad Driver Mode for Pn.2
        constexpr uint32_t PD3 = (3 << 12);  ///< Pad Driver Mode for Pn.3
        constexpr uint32_t PD4 = (3 << 16);  ///< Pad Driver Mode for Pn.4
        constexpr uint32_t PD5 = (3 << 20);  ///< Pad Driver Mode for Pn.5
        constexpr uint32_t PD6 = (3 << 24);  ///< Pad Driver Mode for Pn.6
        constexpr uint32_t PD7 = (3 << 28);  ///< Pad Driver Mode for Pn.7
    }

    /// PDR1 Register bits
    namespace pdr1_bits {
        constexpr uint32_t PD8 = (3 << 0);  ///< Pad Driver Mode for Pn.8
        constexpr uint32_t PD9 = (3 << 4);  ///< Pad Driver Mode for Pn.9
        constexpr uint32_t PD10 = (3 << 8);  ///< Pad Driver Mode for Pn.10
        constexpr uint32_t PD11 = (3 << 12);  ///< Pad Driver Mode for Pn.11
        constexpr uint32_t PD12 = (3 << 16);  ///< Pad Driver Mode for Pn.12
        constexpr uint32_t PD13 = (3 << 20);  ///< Pad Driver Mode for Pn.13
        constexpr uint32_t PD14 = (3 << 24);  ///< Pad Driver Mode for Pn.14
        constexpr uint32_t PD15 = (3 << 28);  ///< Pad Driver Mode for Pn.15
    }

    /// PDISC Register bits
    namespace pdisc_bits {
        constexpr uint32_t PDIS0 = (1U << 0);  ///< Pad Disable for Port n Pin 0
        constexpr uint32_t PDIS1 = (1U << 1);  ///< Pad Disable for Port n Pin 1
        constexpr uint32_t PDIS2 = (1U << 2);  ///< Pad Disable for Port n Pin 2
        constexpr uint32_t PDIS3 = (1U << 3);  ///< Pad Disable for Port n Pin 3
        constexpr uint32_t PDIS4 = (1U << 4);  ///< Pad Disable for Port n Pin 4
        constexpr uint32_t PDIS5 = (1U << 5);  ///< Pad Disable for Port n Pin 5
        constexpr uint32_t PDIS6 = (1U << 6);  ///< Pad Disable for Port n Pin 6
        constexpr uint32_t PDIS7 = (1U << 7);  ///< Pad Disable for Port n Pin 7
        constexpr uint32_t PDIS8 = (1U << 8);  ///< Pad Disable for Port n Pin 8
        constexpr uint32_t PDIS9 = (1U << 9);  ///< Pad Disable for Port n Pin 9
        constexpr uint32_t PDIS10 = (1U << 10);  ///< Pad Disable for Port n Pin 10
        constexpr uint32_t PDIS11 = (1U << 11);  ///< Pad Disable for Port n Pin 11
        constexpr uint32_t PDIS12 = (1U << 12);  ///< Pad Disable for Port n Pin 12
        constexpr uint32_t PDIS13 = (1U << 13);  ///< Pad Disable for Port n Pin 13
        constexpr uint32_t PDIS14 = (1U << 14);  ///< Pad Disable for Port n Pin 14
        constexpr uint32_t PDIS15 = (1U << 15);  ///< Pad Disable for Port n Pin 15
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPS0 = (1U << 0);  ///< Port n Pin Power Save Bit 0
        constexpr uint32_t PPS1 = (1U << 1);  ///< Port n Pin Power Save Bit 1
        constexpr uint32_t PPS2 = (1U << 2);  ///< Port n Pin Power Save Bit 2
        constexpr uint32_t PPS3 = (1U << 3);  ///< Port n Pin Power Save Bit 3
        constexpr uint32_t PPS4 = (1U << 4);  ///< Port n Pin Power Save Bit 4
        constexpr uint32_t PPS5 = (1U << 5);  ///< Port n Pin Power Save Bit 5
        constexpr uint32_t PPS6 = (1U << 6);  ///< Port n Pin Power Save Bit 6
        constexpr uint32_t PPS7 = (1U << 7);  ///< Port n Pin Power Save Bit 7
        constexpr uint32_t PPS8 = (1U << 8);  ///< Port n Pin Power Save Bit 8
        constexpr uint32_t PPS9 = (1U << 9);  ///< Port n Pin Power Save Bit 9
        constexpr uint32_t PPS10 = (1U << 10);  ///< Port n Pin Power Save Bit 10
        constexpr uint32_t PPS11 = (1U << 11);  ///< Port n Pin Power Save Bit 11
        constexpr uint32_t PPS12 = (1U << 12);  ///< Port n Pin Power Save Bit 12
        constexpr uint32_t PPS13 = (1U << 13);  ///< Port n Pin Power Save Bit 13
        constexpr uint32_t PPS14 = (1U << 14);  ///< Port n Pin Power Save Bit 14
        constexpr uint32_t PPS15 = (1U << 15);  ///< Port n Pin Power Save Bit 15
    }

    /// HWSEL Register bits
    namespace hwsel_bits {
        constexpr uint32_t HW0 = (2 << 0);  ///< Port n Pin Hardware Select Bit 0
        constexpr uint32_t HW1 = (2 << 2);  ///< Port n Pin Hardware Select Bit 1
        constexpr uint32_t HW2 = (2 << 4);  ///< Port n Pin Hardware Select Bit 2
        constexpr uint32_t HW3 = (2 << 6);  ///< Port n Pin Hardware Select Bit 3
        constexpr uint32_t HW4 = (2 << 8);  ///< Port n Pin Hardware Select Bit 4
        constexpr uint32_t HW5 = (2 << 10);  ///< Port n Pin Hardware Select Bit 5
        constexpr uint32_t HW6 = (2 << 12);  ///< Port n Pin Hardware Select Bit 6
        constexpr uint32_t HW7 = (2 << 14);  ///< Port n Pin Hardware Select Bit 7
        constexpr uint32_t HW8 = (2 << 16);  ///< Port n Pin Hardware Select Bit 8
        constexpr uint32_t HW9 = (2 << 18);  ///< Port n Pin Hardware Select Bit 9
        constexpr uint32_t HW10 = (2 << 20);  ///< Port n Pin Hardware Select Bit 10
        constexpr uint32_t HW11 = (2 << 22);  ///< Port n Pin Hardware Select Bit 11
        constexpr uint32_t HW12 = (2 << 24);  ///< Port n Pin Hardware Select Bit 12
        constexpr uint32_t HW13 = (2 << 26);  ///< Port n Pin Hardware Select Bit 13
        constexpr uint32_t HW14 = (2 << 28);  ///< Port n Pin Hardware Select Bit 14
        constexpr uint32_t HW15 = (2 << 30);  ///< Port n Pin Hardware Select Bit 15
    }

}


} // namespace alloy::generated::xmc4500

#endif // ALLOY_GENERATED_XMC4500_PERIPHERALS_HPP