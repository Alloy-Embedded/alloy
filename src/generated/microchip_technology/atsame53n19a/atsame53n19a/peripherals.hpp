/// Auto-generated code for ATSAME53N19A
/// Generated by Alloy Code Generator
/// Source: atmel_same.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:06
#ifndef ALLOY_GENERATED_ATSAME53N19A_PERIPHERALS_HPP
#define ALLOY_GENERATED_ATSAME53N19A_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::atsame53n19a {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_ac = true;
    constexpr uint32_t num_ac_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 1;
    constexpr bool has_ccl = true;
    constexpr uint32_t num_ccl_instances = 1;
    constexpr bool has_cmcc = true;
    constexpr uint32_t num_cmcc_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_dsu = true;
    constexpr uint32_t num_dsu_instances = 1;
    constexpr bool has_eic = true;
    constexpr uint32_t num_eic_instances = 1;
    constexpr bool has_evsys = true;
    constexpr uint32_t num_evsys_instances = 1;
    constexpr bool has_freqm = true;
    constexpr uint32_t num_freqm_instances = 1;
    constexpr bool has_gclk = true;
    constexpr uint32_t num_gclk_instances = 1;
    constexpr bool has_gmac = true;
    constexpr uint32_t num_gmac_instances = 1;
    constexpr bool has_hmatrix = true;
    constexpr uint32_t num_hmatrix_instances = 1;
    constexpr bool has_icm = true;
    constexpr uint32_t num_icm_instances = 1;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_mclk = true;
    constexpr uint32_t num_mclk_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_oscctrl = true;
    constexpr uint32_t num_oscctrl_instances = 1;
    constexpr bool has_osc32kctrl = true;
    constexpr uint32_t num_osc32kctrl_instances = 1;
    constexpr bool has_pac = true;
    constexpr uint32_t num_pac_instances = 1;
    constexpr bool has_pcc = true;
    constexpr uint32_t num_pcc_instances = 1;
    constexpr bool has_pdec = true;
    constexpr uint32_t num_pdec_instances = 1;
    constexpr bool has_pm = true;
    constexpr uint32_t num_pm_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 1;
    constexpr bool has_ramecc = true;
    constexpr uint32_t num_ramecc_instances = 1;
    constexpr bool has_rstc = true;
    constexpr uint32_t num_rstc_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_sdhc0 = true;
    constexpr uint32_t num_sdhc0_instances = 1;
    constexpr bool has_sdhc1 = true;
    constexpr uint32_t num_sdhc1_instances = 1;
    constexpr bool has_sercom = true;
    constexpr uint32_t num_sercom_instances = 8;
    constexpr bool has_supc = true;
    constexpr uint32_t num_supc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 13;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_coredebug = true;
    constexpr uint32_t num_coredebug_instances = 1;
    constexpr bool has_dwt = true;
    constexpr uint32_t num_dwt_instances = 1;
    constexpr bool has_etm = true;
    constexpr uint32_t num_etm_instances = 1;
    constexpr bool has_fpu = true;
    constexpr uint32_t num_fpu_instances = 1;
    constexpr bool has_itm = true;
    constexpr uint32_t num_itm_instances = 1;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 1;
    constexpr bool has_systick = true;
    constexpr uint32_t num_systick_instances = 1;
    constexpr bool has_systemcontrol = true;
    constexpr uint32_t num_systemcontrol_instances = 1;
    constexpr bool has_tpi = true;
    constexpr uint32_t num_tpi_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct ac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dsu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct evsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct freqm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gclk_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gmac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hmatrix_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct icm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mclk_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct oscctrl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc32kctrl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pdec_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ramecc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rstc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdhc0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdhc1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sercom_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct supc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 13;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct coredebug_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dwt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct etm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct itm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systick_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systemcontrol_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tpi_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 1;
    constexpr uint32_t max_gpio_pins = 16;  // 16 pins per port

    // USART-specific traits
}

// ============================================================================
// AC Peripheral
// ============================================================================

namespace ac {
    /// Base addresses
    constexpr uint32_t AC_BASE = 0x42002000;

    /// AC Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x01 - Control B
        volatile uint32_t EVCTRL;  ///< Offset: 0x02 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x04 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x05 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x06 - Interrupt Flag Status and Clear
        volatile uint32_t STATUSA;  ///< Offset: 0x07 - Status A
        volatile uint32_t STATUSB;  ///< Offset: 0x08 - Status B
        volatile uint32_t DBGCTRL;  ///< Offset: 0x09 - Debug Control
        volatile uint32_t WINCTRL;  ///< Offset: 0x0A - Window Control
        volatile uint32_t SCALER__;  ///< Offset: 0x0C - Scaler n (renamed from SCALER__)
        volatile uint32_t COMPCTRL__;  ///< Offset: 0x10 - Comparator Control n (renamed from COMPCTRL__)
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x20 - Synchronization Busy
        volatile uint32_t CALIB;  ///< Offset: 0x24 - Calibration
    };

    /// Peripheral instances
    inline Registers* AC = reinterpret_cast<Registers*>(AC_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t START0 = (1U << 0);  ///< Comparator 0 Start Comparison
        constexpr uint32_t START1 = (1U << 1);  ///< Comparator 1 Start Comparison
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t COMPEO0 = (1U << 0);  ///< Comparator 0 Event Output Enable
        constexpr uint32_t COMPEO1 = (1U << 1);  ///< Comparator 1 Event Output Enable
        constexpr uint32_t WINEO0 = (1U << 4);  ///< Window 0 Event Output Enable
        constexpr uint32_t COMPEI0 = (1U << 8);  ///< Comparator 0 Event Input Enable
        constexpr uint32_t COMPEI1 = (1U << 9);  ///< Comparator 1 Event Input Enable
        constexpr uint32_t INVEI0 = (1U << 12);  ///< Comparator 0 Input Event Invert Enable
        constexpr uint32_t INVEI1 = (1U << 13);  ///< Comparator 1 Input Event Invert Enable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t COMP0 = (1U << 0);  ///< Comparator 0 Interrupt Enable
        constexpr uint32_t COMP1 = (1U << 1);  ///< Comparator 1 Interrupt Enable
        constexpr uint32_t WIN0 = (1U << 4);  ///< Window 0 Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t COMP0 = (1U << 0);  ///< Comparator 0 Interrupt Enable
        constexpr uint32_t COMP1 = (1U << 1);  ///< Comparator 1 Interrupt Enable
        constexpr uint32_t WIN0 = (1U << 4);  ///< Window 0 Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t COMP0 = (1U << 0);  ///< Comparator 0
        constexpr uint32_t COMP1 = (1U << 1);  ///< Comparator 1
        constexpr uint32_t WIN0 = (1U << 4);  ///< Window 0
    }

    /// STATUSA Register bits
    namespace statusa_bits {
        constexpr uint32_t STATE0 = (1U << 0);  ///< Comparator 0 Current State
        constexpr uint32_t STATE1 = (1U << 1);  ///< Comparator 1 Current State
        constexpr uint32_t WSTATE0 = (2 << 4);  ///< Window 0 Current State
    }

    /// STATUSB Register bits
    namespace statusb_bits {
        constexpr uint32_t READY0 = (1U << 0);  ///< Comparator 0 Ready
        constexpr uint32_t READY1 = (1U << 1);  ///< Comparator 1 Ready
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Debug Run
    }

    /// WINCTRL Register bits
    namespace winctrl_bits {
        constexpr uint32_t WEN0 = (1U << 0);  ///< Window 0 Mode Enable
        constexpr uint32_t WINTSEL0 = (2 << 1);  ///< Window 0 Interrupt Selection
    }

    /// SCALER__ Register bits
    namespace scaler___bits {
        constexpr uint32_t VALUE = (6 << 0);  ///< Scaler Value
    }

    /// COMPCTRL__ Register bits
    namespace compctrl___bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t SINGLE = (1U << 2);  ///< Single-Shot Mode
        constexpr uint32_t INTSEL = (2 << 3);  ///< Interrupt Selection
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t MUXNEG = (3 << 8);  ///< Negative Input Mux Selection
        constexpr uint32_t MUXPOS = (3 << 12);  ///< Positive Input Mux Selection
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap Inputs and Invert
        constexpr uint32_t SPEED = (2 << 16);  ///< Speed Selection
        constexpr uint32_t HYSTEN = (1U << 19);  ///< Hysteresis Enable
        constexpr uint32_t HYST = (2 << 20);  ///< Hysteresis Level
        constexpr uint32_t FLEN = (3 << 24);  ///< Filter Length
        constexpr uint32_t OUT = (2 << 28);  ///< Output
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchronization Busy
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable Synchronization Busy
        constexpr uint32_t WINCTRL = (1U << 2);  ///< WINCTRL Synchronization Busy
        constexpr uint32_t COMPCTRL0 = (1U << 3);  ///< COMPCTRL 0 Synchronization Busy
        constexpr uint32_t COMPCTRL1 = (1U << 4);  ///< COMPCTRL 1 Synchronization Busy
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t BIAS0 = (2 << 0);  ///< COMP0/1 Bias Scaling
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x43001C00;
    constexpr uint32_t ADC1_BASE = 0x43002000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t EVCTRL;  ///< Offset: 0x02 - Event Control
        volatile uint32_t DBGCTRL;  ///< Offset: 0x03 - Debug Control
        volatile uint32_t INPUTCTRL;  ///< Offset: 0x04 - Input Control
        volatile uint32_t CTRLB;  ///< Offset: 0x06 - Control B
        volatile uint32_t REFCTRL;  ///< Offset: 0x08 - Reference Control
        volatile uint32_t AVGCTRL;  ///< Offset: 0x0A - Average Control
        volatile uint32_t SAMPCTRL;  ///< Offset: 0x0B - Sample Time Control
        volatile uint32_t WINLT;  ///< Offset: 0x0C - Window Monitor Lower Threshold
        volatile uint32_t WINUT;  ///< Offset: 0x0E - Window Monitor Upper Threshold
        volatile uint32_t GAINCORR;  ///< Offset: 0x10 - Gain Correction
        volatile uint32_t OFFSETCORR;  ///< Offset: 0x12 - Offset Correction
        volatile uint32_t SWTRIG;  ///< Offset: 0x14 - Software Trigger
        volatile uint32_t INTENCLR;  ///< Offset: 0x2C - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x2D - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x2E - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x2F - Status
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x30 - Synchronization Busy
        volatile uint32_t DSEQDATA;  ///< Offset: 0x34 - DMA Sequencial Data
        volatile uint32_t DSEQCTRL;  ///< Offset: 0x38 - DMA Sequential Control
        volatile uint32_t DSEQSTAT;  ///< Offset: 0x3C - DMA Sequencial Status
        volatile uint32_t RESULT;  ///< Offset: 0x40 - Result Conversion Value
        volatile uint32_t RESS;  ///< Offset: 0x44 - Last Sample Result
        volatile uint32_t CALIB;  ///< Offset: 0x48 - Calibration
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t DUALSEL = (2 << 3);  ///< Dual Mode Trigger Selection
        constexpr uint32_t SLAVEEN = (1U << 5);  ///< Slave Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
        constexpr uint32_t PRESCALER = (3 << 8);  ///< Prescaler Configuration
        constexpr uint32_t R2R = (1U << 15);  ///< Rail to Rail Operation Enable
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t FLUSHEI = (1U << 0);  ///< Flush Event Input Enable
        constexpr uint32_t STARTEI = (1U << 1);  ///< Start Conversion Event Input Enable
        constexpr uint32_t FLUSHINV = (1U << 2);  ///< Flush Event Invert Enable
        constexpr uint32_t STARTINV = (1U << 3);  ///< Start Conversion Event Invert Enable
        constexpr uint32_t RESRDYEO = (1U << 4);  ///< Result Ready Event Out
        constexpr uint32_t WINMONEO = (1U << 5);  ///< Window Monitor Event Out
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Debug Run
    }

    /// INPUTCTRL Register bits
    namespace inputctrl_bits {
        constexpr uint32_t MUXPOS = (5 << 0);  ///< Positive Mux Input Selection
        constexpr uint32_t DIFFMODE = (1U << 7);  ///< Differential Mode
        constexpr uint32_t MUXNEG = (5 << 8);  ///< Negative Mux Input Selection
        constexpr uint32_t DSEQSTOP = (1U << 15);  ///< Stop DMA Sequencing
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t LEFTADJ = (1U << 0);  ///< Left-Adjusted Result
        constexpr uint32_t FREERUN = (1U << 1);  ///< Free Running Mode
        constexpr uint32_t CORREN = (1U << 2);  ///< Digital Correction Logic Enable
        constexpr uint32_t RESSEL = (2 << 3);  ///< Conversion Result Resolution
        constexpr uint32_t WINMODE = (3 << 8);  ///< Window Monitor Mode
        constexpr uint32_t WINSS = (1U << 11);  ///< Window Single Sample
    }

    /// REFCTRL Register bits
    namespace refctrl_bits {
        constexpr uint32_t REFSEL = (4 << 0);  ///< Reference Selection
        constexpr uint32_t REFCOMP = (1U << 7);  ///< Reference Buffer Offset Compensation Enable
    }

    /// AVGCTRL Register bits
    namespace avgctrl_bits {
        constexpr uint32_t SAMPLENUM = (4 << 0);  ///< Number of Samples to be Collected
        constexpr uint32_t ADJRES = (3 << 4);  ///< Adjusting Result / Division Coefficient
    }

    /// SAMPCTRL Register bits
    namespace sampctrl_bits {
        constexpr uint32_t SAMPLEN = (6 << 0);  ///< Sampling Time Length
        constexpr uint32_t OFFCOMP = (1U << 7);  ///< Comparator Offset Compensation Enable
    }

    /// WINLT Register bits
    namespace winlt_bits {
        constexpr uint32_t WINLT = (16 << 0);  ///< Window Lower Threshold
    }

    /// WINUT Register bits
    namespace winut_bits {
        constexpr uint32_t WINUT = (16 << 0);  ///< Window Upper Threshold
    }

    /// GAINCORR Register bits
    namespace gaincorr_bits {
        constexpr uint32_t GAINCORR = (12 << 0);  ///< Gain Correction Value
    }

    /// OFFSETCORR Register bits
    namespace offsetcorr_bits {
        constexpr uint32_t OFFSETCORR = (12 << 0);  ///< Offset Correction Value
    }

    /// SWTRIG Register bits
    namespace swtrig_bits {
        constexpr uint32_t FLUSH = (1U << 0);  ///< ADC Conversion Flush
        constexpr uint32_t START = (1U << 1);  ///< Start ADC Conversion
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t RESRDY = (1U << 0);  ///< Result Ready Interrupt Disable
        constexpr uint32_t OVERRUN = (1U << 1);  ///< Overrun Interrupt Disable
        constexpr uint32_t WINMON = (1U << 2);  ///< Window Monitor Interrupt Disable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t RESRDY = (1U << 0);  ///< Result Ready Interrupt Enable
        constexpr uint32_t OVERRUN = (1U << 1);  ///< Overrun Interrupt Enable
        constexpr uint32_t WINMON = (1U << 2);  ///< Window Monitor Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t RESRDY = (1U << 0);  ///< Result Ready Interrupt Flag
        constexpr uint32_t OVERRUN = (1U << 1);  ///< Overrun Interrupt Flag
        constexpr uint32_t WINMON = (1U << 2);  ///< Window Monitor Interrupt Flag
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t ADCBUSY = (1U << 0);  ///< ADC Busy Status
        constexpr uint32_t WCC = (6 << 2);  ///< Window Comparator Counter
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< SWRST Synchronization Busy
        constexpr uint32_t ENABLE = (1U << 1);  ///< ENABLE Synchronization Busy
        constexpr uint32_t INPUTCTRL = (1U << 2);  ///< Input Control Synchronization Busy
        constexpr uint32_t CTRLB = (1U << 3);  ///< Control B Synchronization Busy
        constexpr uint32_t REFCTRL = (1U << 4);  ///< Reference Control Synchronization Busy
        constexpr uint32_t AVGCTRL = (1U << 5);  ///< Average Control Synchronization Busy
        constexpr uint32_t SAMPCTRL = (1U << 6);  ///< Sampling Time Control Synchronization Busy
        constexpr uint32_t WINLT = (1U << 7);  ///< Window Monitor Lower Threshold Synchronization Busy
        constexpr uint32_t WINUT = (1U << 8);  ///< Window Monitor Upper Threshold Synchronization Busy
        constexpr uint32_t GAINCORR = (1U << 9);  ///< Gain Correction Synchronization Busy
        constexpr uint32_t OFFSETCORR = (1U << 10);  ///< Offset Correction Synchronization Busy
        constexpr uint32_t SWTRIG = (1U << 11);  ///< Software Trigger Synchronization Busy
    }

    /// DSEQDATA Register bits
    namespace dseqdata_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< DMA Sequential Data
    }

    /// DSEQCTRL Register bits
    namespace dseqctrl_bits {
        constexpr uint32_t INPUTCTRL = (1U << 0);  ///< Input Control
        constexpr uint32_t CTRLB = (1U << 1);  ///< Control B
        constexpr uint32_t REFCTRL = (1U << 2);  ///< Reference Control
        constexpr uint32_t AVGCTRL = (1U << 3);  ///< Average Control
        constexpr uint32_t SAMPCTRL = (1U << 4);  ///< Sampling Time Control
        constexpr uint32_t WINLT = (1U << 5);  ///< Window Monitor Lower Threshold
        constexpr uint32_t WINUT = (1U << 6);  ///< Window Monitor Upper Threshold
        constexpr uint32_t GAINCORR = (1U << 7);  ///< Gain Correction
        constexpr uint32_t OFFSETCORR = (1U << 8);  ///< Offset Correction
        constexpr uint32_t AUTOSTART = (1U << 31);  ///< ADC Auto-Start Conversion
    }

    /// DSEQSTAT Register bits
    namespace dseqstat_bits {
        constexpr uint32_t INPUTCTRL = (1U << 0);  ///< Input Control
        constexpr uint32_t CTRLB = (1U << 1);  ///< Control B
        constexpr uint32_t REFCTRL = (1U << 2);  ///< Reference Control
        constexpr uint32_t AVGCTRL = (1U << 3);  ///< Average Control
        constexpr uint32_t SAMPCTRL = (1U << 4);  ///< Sampling Time Control
        constexpr uint32_t WINLT = (1U << 5);  ///< Window Monitor Lower Threshold
        constexpr uint32_t WINUT = (1U << 6);  ///< Window Monitor Upper Threshold
        constexpr uint32_t GAINCORR = (1U << 7);  ///< Gain Correction
        constexpr uint32_t OFFSETCORR = (1U << 8);  ///< Offset Correction
        constexpr uint32_t BUSY = (1U << 31);  ///< DMA Sequencing Busy
    }

    /// RESULT Register bits
    namespace result_bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Result Conversion Value
    }

    /// RESS Register bits
    namespace ress_bits {
        constexpr uint32_t RESS = (16 << 0);  ///< Last ADC conversion result
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t BIASCOMP = (3 << 0);  ///< Bias Comparator Scaling
        constexpr uint32_t BIASR2R = (3 << 4);  ///< Bias R2R Ampli scaling
        constexpr uint32_t BIASREFBUF = (3 << 8);  ///< Bias Reference Buffer Scaling
    }

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x42002400;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x04 - Control B
        volatile uint32_t INTENCLR;  ///< Offset: 0x05 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x06 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x07 - Interrupt Flag Status
        volatile uint32_t DATABUFPTR;  ///< Offset: 0x08 - Data buffer pointer
        volatile uint32_t DBGCTRL;  ///< Offset: 0x09 - Debug control
        volatile uint32_t KEYWORD__;  ///< Offset: 0x0C - Keyword n (renamed from KEYWORD__)
        volatile uint32_t INDATA;  ///< Offset: 0x38 - Indata
        volatile uint32_t INTVECTV__;  ///< Offset: 0x3C - Initialisation Vector n (renamed from INTVECTV__)
        volatile uint32_t HASHKEY__;  ///< Offset: 0x5C - Hash key n (renamed from HASHKEY__)
        volatile uint32_t GHASH__;  ///< Offset: 0x6C - Galois Hash n (renamed from GHASH__)
        volatile uint32_t CIPLEN;  ///< Offset: 0x80 - Cipher Length
        volatile uint32_t RANDSEED;  ///< Offset: 0x84 - Random Seed
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t AESMODE = (3 << 2);  ///< AES Modes of operation
        constexpr uint32_t CFBS = (3 << 5);  ///< Cipher Feedback Block Size
        constexpr uint32_t KEYSIZE = (2 << 8);  ///< Encryption Key Size
        constexpr uint32_t CIPHER = (1U << 10);  ///< Cipher Mode
        constexpr uint32_t STARTMODE = (1U << 11);  ///< Start Mode Select
        constexpr uint32_t LOD = (1U << 12);  ///< Last Output Data Mode
        constexpr uint32_t KEYGEN = (1U << 13);  ///< Last Key Generation
        constexpr uint32_t XORKEY = (1U << 14);  ///< XOR Key Operation
        constexpr uint32_t CTYPE = (4 << 16);  ///< Counter Measure Type
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start Encryption/Decryption
        constexpr uint32_t NEWMSG = (1U << 1);  ///< New message
        constexpr uint32_t EOM = (1U << 2);  ///< End of message
        constexpr uint32_t GFMUL = (1U << 3);  ///< GF Multiplication
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t ENCCMP = (1U << 0);  ///< Encryption Complete Interrupt Enable
        constexpr uint32_t GFMCMP = (1U << 1);  ///< GF Multiplication Complete Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t ENCCMP = (1U << 0);  ///< Encryption Complete Interrupt Enable
        constexpr uint32_t GFMCMP = (1U << 1);  ///< GF Multiplication Complete Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t ENCCMP = (1U << 0);  ///< Encryption Complete
        constexpr uint32_t GFMCMP = (1U << 1);  ///< GF Multiplication Complete
    }

    /// DATABUFPTR Register bits
    namespace databufptr_bits {
        constexpr uint32_t INDATAPTR = (2 << 0);  ///< Input Data Pointer
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Debug Run
    }

}

// ============================================================================
// CCL Peripheral
// ============================================================================

namespace ccl {
    /// Base addresses
    constexpr uint32_t CCL_BASE = 0x42003800;

    /// CCL Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control
        volatile uint32_t SEQCTRL__;  ///< Offset: 0x04 - SEQ Control x (renamed from SEQCTRL__)
        volatile uint32_t LUTCTRL__;  ///< Offset: 0x08 - LUT Control x (renamed from LUTCTRL__)
    };

    /// Peripheral instances
    inline Registers* CCL = reinterpret_cast<Registers*>(CCL_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
    }

    /// SEQCTRL__ Register bits
    namespace seqctrl___bits {
        constexpr uint32_t SEQSEL = (4 << 0);  ///< Sequential Selection
    }

    /// LUTCTRL__ Register bits
    namespace lutctrl___bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< LUT Enable
        constexpr uint32_t FILTSEL = (2 << 4);  ///< Filter Selection
        constexpr uint32_t EDGESEL = (1U << 7);  ///< Edge Selection
        constexpr uint32_t INSEL0 = (4 << 8);  ///< Input Selection 0
        constexpr uint32_t INSEL1 = (4 << 12);  ///< Input Selection 1
        constexpr uint32_t INSEL2 = (4 << 16);  ///< Input Selection 2
        constexpr uint32_t INVEI = (1U << 20);  ///< Inverted Event Input Enable
        constexpr uint32_t LUTEI = (1U << 21);  ///< LUT Event Input Enable
        constexpr uint32_t LUTEO = (1U << 22);  ///< LUT Event Output Enable
        constexpr uint32_t TRUTH = (8 << 24);  ///< Truth Value
    }

}

// ============================================================================
// CMCC Peripheral
// ============================================================================

namespace cmcc {
    /// Base addresses
    constexpr uint32_t CMCC_BASE = 0x41006000;

    /// CMCC Register structure
    struct Registers {
        volatile uint32_t TYPE;  ///< Offset: 0x00 - Cache Type Register
        volatile uint32_t CFG;  ///< Offset: 0x04 - Cache Configuration Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - Cache Control Register
        volatile uint32_t SR;  ///< Offset: 0x0C - Cache Status Register
        volatile uint32_t LCKWAY;  ///< Offset: 0x10 - Cache Lock per Way Register
        volatile uint32_t MAINT0;  ///< Offset: 0x20 - Cache Maintenance Register 0
        volatile uint32_t MAINT1;  ///< Offset: 0x24 - Cache Maintenance Register 1
        volatile uint32_t MCFG;  ///< Offset: 0x28 - Cache Monitor Configuration Register
        volatile uint32_t MEN;  ///< Offset: 0x2C - Cache Monitor Enable Register
        volatile uint32_t MCTRL;  ///< Offset: 0x30 - Cache Monitor Control Register
        volatile uint32_t MSR;  ///< Offset: 0x34 - Cache Monitor Status Register
    };

    /// Peripheral instances
    inline Registers* CMCC = reinterpret_cast<Registers*>(CMCC_BASE);

    // Bit definitions
    /// TYPE Register bits
    namespace type_bits {
        constexpr uint32_t GCLK = (1U << 1);  ///< dynamic Clock Gating supported
        constexpr uint32_t RRP = (1U << 4);  ///< Round Robin Policy supported
        constexpr uint32_t WAYNUM = (2 << 5);  ///< Number of Way
        constexpr uint32_t LCKDOWN = (1U << 7);  ///< Lock Down supported
        constexpr uint32_t CSIZE = (3 << 8);  ///< Cache Size
        constexpr uint32_t CLSIZE = (3 << 11);  ///< Cache Line Size
    }

    /// CFG Register bits
    namespace cfg_bits {
        constexpr uint32_t ICDIS = (1U << 1);  ///< Instruction Cache Disable
        constexpr uint32_t DCDIS = (1U << 2);  ///< Data Cache Disable
        constexpr uint32_t CSIZESW = (3 << 4);  ///< Cache size configured by software
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t CEN = (1U << 0);  ///< Cache Controller Enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t CSTS = (1U << 0);  ///< Cache Controller Status
    }

    /// LCKWAY Register bits
    namespace lckway_bits {
        constexpr uint32_t LCKWAY = (4 << 0);  ///< Lockdown way Register
    }

    /// MAINT0 Register bits
    namespace maint0_bits {
        constexpr uint32_t INVALL = (1U << 0);  ///< Cache Controller invalidate All
    }

    /// MAINT1 Register bits
    namespace maint1_bits {
        constexpr uint32_t INDEX = (8 << 4);  ///< Invalidate Index
        constexpr uint32_t WAY = (4 << 28);  ///< Invalidate Way
    }

    /// MCFG Register bits
    namespace mcfg_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Cache Controller Monitor Counter Mode
    }

    /// MEN Register bits
    namespace men_bits {
        constexpr uint32_t MENABLE = (1U << 0);  ///< Cache Controller Monitor Enable
    }

    /// MCTRL Register bits
    namespace mctrl_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Cache Controller Software Reset
    }

    /// MSR Register bits
    namespace msr_bits {
        constexpr uint32_t EVENT_CNT = (32 << 0);  ///< Monitor Event Counter
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x43002400;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x01 - Control B
        volatile uint32_t EVCTRL;  ///< Offset: 0x02 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x04 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x05 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x06 - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x07 - Status
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x08 - Synchronization Busy
        volatile uint32_t DACCTRL__;  ///< Offset: 0x0C - DAC n Control (renamed from DACCTRL__)
        volatile uint32_t DATA__;  ///< Offset: 0x10 - DAC n Data (renamed from DATA__)
        volatile uint32_t DATABUF__;  ///< Offset: 0x14 - DAC n Data Buffer (renamed from DATABUF__)
        volatile uint32_t DBGCTRL;  ///< Offset: 0x18 - Debug Control
        volatile uint32_t RESULT__;  ///< Offset: 0x1C - Filter Result (renamed from RESULT__)
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable DAC Controller
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t DIFF = (1U << 0);  ///< Differential mode enable
        constexpr uint32_t REFSEL = (2 << 1);  ///< Reference Selection for DAC0/1
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t STARTEI0 = (1U << 0);  ///< Start Conversion Event Input DAC 0
        constexpr uint32_t STARTEI1 = (1U << 1);  ///< Start Conversion Event Input DAC 1
        constexpr uint32_t EMPTYEO0 = (1U << 2);  ///< Data Buffer Empty Event Output DAC 0
        constexpr uint32_t EMPTYEO1 = (1U << 3);  ///< Data Buffer Empty Event Output DAC 1
        constexpr uint32_t INVEI0 = (1U << 4);  ///< Enable Invertion of DAC 0 input event
        constexpr uint32_t INVEI1 = (1U << 5);  ///< Enable Invertion of DAC 1 input event
        constexpr uint32_t RESRDYEO0 = (1U << 6);  ///< Result Ready Event Output 0
        constexpr uint32_t RESRDYEO1 = (1U << 7);  ///< Result Ready Event Output 1
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t UNDERRUN0 = (1U << 0);  ///< Underrun 0 Interrupt Enable
        constexpr uint32_t UNDERRUN1 = (1U << 1);  ///< Underrun 1 Interrupt Enable
        constexpr uint32_t EMPTY0 = (1U << 2);  ///< Data Buffer 0 Empty Interrupt Enable
        constexpr uint32_t EMPTY1 = (1U << 3);  ///< Data Buffer 1 Empty Interrupt Enable
        constexpr uint32_t RESRDY0 = (1U << 4);  ///< Result 0 Ready Interrupt Enable
        constexpr uint32_t RESRDY1 = (1U << 5);  ///< Result 1 Ready Interrupt Enable
        constexpr uint32_t OVERRUN0 = (1U << 6);  ///< Overrun 0 Interrupt Enable
        constexpr uint32_t OVERRUN1 = (1U << 7);  ///< Overrun 1 Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t UNDERRUN0 = (1U << 0);  ///< Underrun 0 Interrupt Enable
        constexpr uint32_t UNDERRUN1 = (1U << 1);  ///< Underrun 1 Interrupt Enable
        constexpr uint32_t EMPTY0 = (1U << 2);  ///< Data Buffer 0 Empty Interrupt Enable
        constexpr uint32_t EMPTY1 = (1U << 3);  ///< Data Buffer 1 Empty Interrupt Enable
        constexpr uint32_t RESRDY0 = (1U << 4);  ///< Result 0 Ready Interrupt Enable
        constexpr uint32_t RESRDY1 = (1U << 5);  ///< Result 1 Ready Interrupt Enable
        constexpr uint32_t OVERRUN0 = (1U << 6);  ///< Overrun 0 Interrupt Enable
        constexpr uint32_t OVERRUN1 = (1U << 7);  ///< Overrun 1 Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t UNDERRUN0 = (1U << 0);  ///< Result 0 Underrun
        constexpr uint32_t UNDERRUN1 = (1U << 1);  ///< Result 1 Underrun
        constexpr uint32_t EMPTY0 = (1U << 2);  ///< Data Buffer 0 Empty
        constexpr uint32_t EMPTY1 = (1U << 3);  ///< Data Buffer 1 Empty
        constexpr uint32_t RESRDY0 = (1U << 4);  ///< Result 0 Ready
        constexpr uint32_t RESRDY1 = (1U << 5);  ///< Result 1 Ready
        constexpr uint32_t OVERRUN0 = (1U << 6);  ///< Result 0 Overrun
        constexpr uint32_t OVERRUN1 = (1U << 7);  ///< Result 1 Overrun
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t READY0 = (1U << 0);  ///< DAC 0 Startup Ready
        constexpr uint32_t READY1 = (1U << 1);  ///< DAC 1 Startup Ready
        constexpr uint32_t EOC0 = (1U << 2);  ///< DAC 0 End of Conversion
        constexpr uint32_t EOC1 = (1U << 3);  ///< DAC 1 End of Conversion
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< DAC Enable Status
        constexpr uint32_t DATA0 = (1U << 2);  ///< Data DAC 0
        constexpr uint32_t DATA1 = (1U << 3);  ///< Data DAC 1
        constexpr uint32_t DATABUF0 = (1U << 4);  ///< Data Buffer DAC 0
        constexpr uint32_t DATABUF1 = (1U << 5);  ///< Data Buffer DAC 1
    }

    /// DACCTRL__ Register bits
    namespace dacctrl___bits {
        constexpr uint32_t LEFTADJ = (1U << 0);  ///< Left Adjusted Data
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable DAC0
        constexpr uint32_t CCTRL = (2 << 2);  ///< Current Control
        constexpr uint32_t FEXT = (1U << 5);  ///< Standalone Filter
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t DITHER = (1U << 7);  ///< Dithering Mode
        constexpr uint32_t REFRESH = (4 << 8);  ///< Refresh period
        constexpr uint32_t OSR = (3 << 13);  ///< Sampling Rate
    }

    /// DATA__ Register bits
    namespace data___bits {
        constexpr uint32_t DATA = (16 << 0);  ///< DAC0 Data
    }

    /// DATABUF__ Register bits
    namespace databuf___bits {
        constexpr uint32_t DATABUF = (16 << 0);  ///< DAC0 Data Buffer
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Debug Run
    }

    /// RESULT__ Register bits
    namespace result___bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Filter Result
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMAC_BASE = 0x4100A000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control
        volatile uint32_t CRCCTRL;  ///< Offset: 0x02 - CRC Control
        volatile uint32_t CRCDATAIN;  ///< Offset: 0x04 - CRC Data Input
        volatile uint32_t CRCCHKSUM;  ///< Offset: 0x08 - CRC Checksum
        volatile uint32_t CRCSTATUS;  ///< Offset: 0x0C - CRC Status
        volatile uint32_t DBGCTRL;  ///< Offset: 0x0D - Debug Control
        volatile uint32_t SWTRIGCTRL;  ///< Offset: 0x10 - Software Trigger Control
        volatile uint32_t PRICTRL0;  ///< Offset: 0x14 - Priority Control 0
        volatile uint32_t INTPEND;  ///< Offset: 0x20 - Interrupt Pending
        volatile uint32_t INTSTATUS;  ///< Offset: 0x24 - Interrupt Status
        volatile uint32_t BUSYCH;  ///< Offset: 0x28 - Busy Channels
        volatile uint32_t PENDCH;  ///< Offset: 0x2C - Pending Channels
        volatile uint32_t ACTIVE;  ///< Offset: 0x30 - Active Channel and Levels
        volatile uint32_t BASEADDR;  ///< Offset: 0x34 - Descriptor Memory Section Base Address
        volatile uint32_t WRBADDR;  ///< Offset: 0x38 - Write-Back Memory Section Base Address
        volatile uint32_t CHCTRLA;  ///< Offset: 0x00 - Channel n Control A
        volatile uint32_t CHCTRLB;  ///< Offset: 0x04 - Channel n Control B
        volatile uint32_t CHPRILVL;  ///< Offset: 0x05 - Channel n Priority Level
        volatile uint32_t CHEVCTRL;  ///< Offset: 0x06 - Channel n Event Control
        volatile uint32_t CHINTENCLR;  ///< Offset: 0x0C - Channel n Interrupt Enable Clear
        volatile uint32_t CHINTENSET;  ///< Offset: 0x0D - Channel n Interrupt Enable Set
        volatile uint32_t CHINTFLAG;  ///< Offset: 0x0E - Channel n Interrupt Flag Status and Clear
        volatile uint32_t CHSTATUS;  ///< Offset: 0x0F - Channel n Status
    };

    /// Peripheral instances
    inline Registers* DMAC = reinterpret_cast<Registers*>(DMAC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t DMAENABLE = (1U << 1);  ///< DMA Enable
        constexpr uint32_t LVLEN0 = (1U << 8);  ///< Priority Level 0 Enable
        constexpr uint32_t LVLEN1 = (1U << 9);  ///< Priority Level 1 Enable
        constexpr uint32_t LVLEN2 = (1U << 10);  ///< Priority Level 2 Enable
        constexpr uint32_t LVLEN3 = (1U << 11);  ///< Priority Level 3 Enable
    }

    /// CRCCTRL Register bits
    namespace crcctrl_bits {
        constexpr uint32_t CRCBEATSIZE = (2 << 0);  ///< CRC Beat Size
        constexpr uint32_t CRCPOLY = (2 << 2);  ///< CRC Polynomial Type
        constexpr uint32_t CRCSRC = (6 << 8);  ///< CRC Input Source
        constexpr uint32_t CRCMODE = (2 << 14);  ///< CRC Operating Mode
    }

    /// CRCDATAIN Register bits
    namespace crcdatain_bits {
        constexpr uint32_t CRCDATAIN = (32 << 0);  ///< CRC Data Input
    }

    /// CRCCHKSUM Register bits
    namespace crcchksum_bits {
        constexpr uint32_t CRCCHKSUM = (32 << 0);  ///< CRC Checksum
    }

    /// CRCSTATUS Register bits
    namespace crcstatus_bits {
        constexpr uint32_t CRCBUSY = (1U << 0);  ///< CRC Module Busy
        constexpr uint32_t CRCZERO = (1U << 1);  ///< CRC Zero
        constexpr uint32_t CRCERR = (1U << 2);  ///< CRC Error
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Debug Run
    }

    /// SWTRIGCTRL Register bits
    namespace swtrigctrl_bits {
        constexpr uint32_t SWTRIG0 = (1U << 0);  ///< Channel 0 Software Trigger
        constexpr uint32_t SWTRIG1 = (1U << 1);  ///< Channel 1 Software Trigger
        constexpr uint32_t SWTRIG2 = (1U << 2);  ///< Channel 2 Software Trigger
        constexpr uint32_t SWTRIG3 = (1U << 3);  ///< Channel 3 Software Trigger
        constexpr uint32_t SWTRIG4 = (1U << 4);  ///< Channel 4 Software Trigger
        constexpr uint32_t SWTRIG5 = (1U << 5);  ///< Channel 5 Software Trigger
        constexpr uint32_t SWTRIG6 = (1U << 6);  ///< Channel 6 Software Trigger
        constexpr uint32_t SWTRIG7 = (1U << 7);  ///< Channel 7 Software Trigger
        constexpr uint32_t SWTRIG8 = (1U << 8);  ///< Channel 8 Software Trigger
        constexpr uint32_t SWTRIG9 = (1U << 9);  ///< Channel 9 Software Trigger
        constexpr uint32_t SWTRIG10 = (1U << 10);  ///< Channel 10 Software Trigger
        constexpr uint32_t SWTRIG11 = (1U << 11);  ///< Channel 11 Software Trigger
        constexpr uint32_t SWTRIG12 = (1U << 12);  ///< Channel 12 Software Trigger
        constexpr uint32_t SWTRIG13 = (1U << 13);  ///< Channel 13 Software Trigger
        constexpr uint32_t SWTRIG14 = (1U << 14);  ///< Channel 14 Software Trigger
        constexpr uint32_t SWTRIG15 = (1U << 15);  ///< Channel 15 Software Trigger
        constexpr uint32_t SWTRIG16 = (1U << 16);  ///< Channel 16 Software Trigger
        constexpr uint32_t SWTRIG17 = (1U << 17);  ///< Channel 17 Software Trigger
        constexpr uint32_t SWTRIG18 = (1U << 18);  ///< Channel 18 Software Trigger
        constexpr uint32_t SWTRIG19 = (1U << 19);  ///< Channel 19 Software Trigger
        constexpr uint32_t SWTRIG20 = (1U << 20);  ///< Channel 20 Software Trigger
        constexpr uint32_t SWTRIG21 = (1U << 21);  ///< Channel 21 Software Trigger
        constexpr uint32_t SWTRIG22 = (1U << 22);  ///< Channel 22 Software Trigger
        constexpr uint32_t SWTRIG23 = (1U << 23);  ///< Channel 23 Software Trigger
        constexpr uint32_t SWTRIG24 = (1U << 24);  ///< Channel 24 Software Trigger
        constexpr uint32_t SWTRIG25 = (1U << 25);  ///< Channel 25 Software Trigger
        constexpr uint32_t SWTRIG26 = (1U << 26);  ///< Channel 26 Software Trigger
        constexpr uint32_t SWTRIG27 = (1U << 27);  ///< Channel 27 Software Trigger
        constexpr uint32_t SWTRIG28 = (1U << 28);  ///< Channel 28 Software Trigger
        constexpr uint32_t SWTRIG29 = (1U << 29);  ///< Channel 29 Software Trigger
        constexpr uint32_t SWTRIG30 = (1U << 30);  ///< Channel 30 Software Trigger
        constexpr uint32_t SWTRIG31 = (1U << 31);  ///< Channel 31 Software Trigger
    }

    /// PRICTRL0 Register bits
    namespace prictrl0_bits {
        constexpr uint32_t LVLPRI0 = (5 << 0);  ///< Level 0 Channel Priority Number
        constexpr uint32_t QOS0 = (2 << 5);  ///< Level 0 Quality of Service
        constexpr uint32_t RRLVLEN0 = (1U << 7);  ///< Level 0 Round-Robin Scheduling Enable
        constexpr uint32_t LVLPRI1 = (5 << 8);  ///< Level 1 Channel Priority Number
        constexpr uint32_t QOS1 = (2 << 13);  ///< Level 1 Quality of Service
        constexpr uint32_t RRLVLEN1 = (1U << 15);  ///< Level 1 Round-Robin Scheduling Enable
        constexpr uint32_t LVLPRI2 = (5 << 16);  ///< Level 2 Channel Priority Number
        constexpr uint32_t QOS2 = (2 << 21);  ///< Level 2 Quality of Service
        constexpr uint32_t RRLVLEN2 = (1U << 23);  ///< Level 2 Round-Robin Scheduling Enable
        constexpr uint32_t LVLPRI3 = (5 << 24);  ///< Level 3 Channel Priority Number
        constexpr uint32_t QOS3 = (2 << 29);  ///< Level 3 Quality of Service
        constexpr uint32_t RRLVLEN3 = (1U << 31);  ///< Level 3 Round-Robin Scheduling Enable
    }

    /// INTPEND Register bits
    namespace intpend_bits {
        constexpr uint32_t ID = (5 << 0);  ///< Channel ID
        constexpr uint32_t TERR = (1U << 8);  ///< Transfer Error
        constexpr uint32_t TCMPL = (1U << 9);  ///< Transfer Complete
        constexpr uint32_t SUSP = (1U << 10);  ///< Channel Suspend
        constexpr uint32_t CRCERR = (1U << 12);  ///< CRC Error
        constexpr uint32_t FERR = (1U << 13);  ///< Fetch Error
        constexpr uint32_t BUSY = (1U << 14);  ///< Busy
        constexpr uint32_t PEND = (1U << 15);  ///< Pending
    }

    /// INTSTATUS Register bits
    namespace intstatus_bits {
        constexpr uint32_t CHINT0 = (1U << 0);  ///< Channel 0 Pending Interrupt
        constexpr uint32_t CHINT1 = (1U << 1);  ///< Channel 1 Pending Interrupt
        constexpr uint32_t CHINT2 = (1U << 2);  ///< Channel 2 Pending Interrupt
        constexpr uint32_t CHINT3 = (1U << 3);  ///< Channel 3 Pending Interrupt
        constexpr uint32_t CHINT4 = (1U << 4);  ///< Channel 4 Pending Interrupt
        constexpr uint32_t CHINT5 = (1U << 5);  ///< Channel 5 Pending Interrupt
        constexpr uint32_t CHINT6 = (1U << 6);  ///< Channel 6 Pending Interrupt
        constexpr uint32_t CHINT7 = (1U << 7);  ///< Channel 7 Pending Interrupt
        constexpr uint32_t CHINT8 = (1U << 8);  ///< Channel 8 Pending Interrupt
        constexpr uint32_t CHINT9 = (1U << 9);  ///< Channel 9 Pending Interrupt
        constexpr uint32_t CHINT10 = (1U << 10);  ///< Channel 10 Pending Interrupt
        constexpr uint32_t CHINT11 = (1U << 11);  ///< Channel 11 Pending Interrupt
        constexpr uint32_t CHINT12 = (1U << 12);  ///< Channel 12 Pending Interrupt
        constexpr uint32_t CHINT13 = (1U << 13);  ///< Channel 13 Pending Interrupt
        constexpr uint32_t CHINT14 = (1U << 14);  ///< Channel 14 Pending Interrupt
        constexpr uint32_t CHINT15 = (1U << 15);  ///< Channel 15 Pending Interrupt
        constexpr uint32_t CHINT16 = (1U << 16);  ///< Channel 16 Pending Interrupt
        constexpr uint32_t CHINT17 = (1U << 17);  ///< Channel 17 Pending Interrupt
        constexpr uint32_t CHINT18 = (1U << 18);  ///< Channel 18 Pending Interrupt
        constexpr uint32_t CHINT19 = (1U << 19);  ///< Channel 19 Pending Interrupt
        constexpr uint32_t CHINT20 = (1U << 20);  ///< Channel 20 Pending Interrupt
        constexpr uint32_t CHINT21 = (1U << 21);  ///< Channel 21 Pending Interrupt
        constexpr uint32_t CHINT22 = (1U << 22);  ///< Channel 22 Pending Interrupt
        constexpr uint32_t CHINT23 = (1U << 23);  ///< Channel 23 Pending Interrupt
        constexpr uint32_t CHINT24 = (1U << 24);  ///< Channel 24 Pending Interrupt
        constexpr uint32_t CHINT25 = (1U << 25);  ///< Channel 25 Pending Interrupt
        constexpr uint32_t CHINT26 = (1U << 26);  ///< Channel 26 Pending Interrupt
        constexpr uint32_t CHINT27 = (1U << 27);  ///< Channel 27 Pending Interrupt
        constexpr uint32_t CHINT28 = (1U << 28);  ///< Channel 28 Pending Interrupt
        constexpr uint32_t CHINT29 = (1U << 29);  ///< Channel 29 Pending Interrupt
        constexpr uint32_t CHINT30 = (1U << 30);  ///< Channel 30 Pending Interrupt
        constexpr uint32_t CHINT31 = (1U << 31);  ///< Channel 31 Pending Interrupt
    }

    /// BUSYCH Register bits
    namespace busych_bits {
        constexpr uint32_t BUSYCH0 = (1U << 0);  ///< Busy Channel 0
        constexpr uint32_t BUSYCH1 = (1U << 1);  ///< Busy Channel 1
        constexpr uint32_t BUSYCH2 = (1U << 2);  ///< Busy Channel 2
        constexpr uint32_t BUSYCH3 = (1U << 3);  ///< Busy Channel 3
        constexpr uint32_t BUSYCH4 = (1U << 4);  ///< Busy Channel 4
        constexpr uint32_t BUSYCH5 = (1U << 5);  ///< Busy Channel 5
        constexpr uint32_t BUSYCH6 = (1U << 6);  ///< Busy Channel 6
        constexpr uint32_t BUSYCH7 = (1U << 7);  ///< Busy Channel 7
        constexpr uint32_t BUSYCH8 = (1U << 8);  ///< Busy Channel 8
        constexpr uint32_t BUSYCH9 = (1U << 9);  ///< Busy Channel 9
        constexpr uint32_t BUSYCH10 = (1U << 10);  ///< Busy Channel 10
        constexpr uint32_t BUSYCH11 = (1U << 11);  ///< Busy Channel 11
        constexpr uint32_t BUSYCH12 = (1U << 12);  ///< Busy Channel 12
        constexpr uint32_t BUSYCH13 = (1U << 13);  ///< Busy Channel 13
        constexpr uint32_t BUSYCH14 = (1U << 14);  ///< Busy Channel 14
        constexpr uint32_t BUSYCH15 = (1U << 15);  ///< Busy Channel 15
        constexpr uint32_t BUSYCH16 = (1U << 16);  ///< Busy Channel 16
        constexpr uint32_t BUSYCH17 = (1U << 17);  ///< Busy Channel 17
        constexpr uint32_t BUSYCH18 = (1U << 18);  ///< Busy Channel 18
        constexpr uint32_t BUSYCH19 = (1U << 19);  ///< Busy Channel 19
        constexpr uint32_t BUSYCH20 = (1U << 20);  ///< Busy Channel 20
        constexpr uint32_t BUSYCH21 = (1U << 21);  ///< Busy Channel 21
        constexpr uint32_t BUSYCH22 = (1U << 22);  ///< Busy Channel 22
        constexpr uint32_t BUSYCH23 = (1U << 23);  ///< Busy Channel 23
        constexpr uint32_t BUSYCH24 = (1U << 24);  ///< Busy Channel 24
        constexpr uint32_t BUSYCH25 = (1U << 25);  ///< Busy Channel 25
        constexpr uint32_t BUSYCH26 = (1U << 26);  ///< Busy Channel 26
        constexpr uint32_t BUSYCH27 = (1U << 27);  ///< Busy Channel 27
        constexpr uint32_t BUSYCH28 = (1U << 28);  ///< Busy Channel 28
        constexpr uint32_t BUSYCH29 = (1U << 29);  ///< Busy Channel 29
        constexpr uint32_t BUSYCH30 = (1U << 30);  ///< Busy Channel 30
        constexpr uint32_t BUSYCH31 = (1U << 31);  ///< Busy Channel 31
    }

    /// PENDCH Register bits
    namespace pendch_bits {
        constexpr uint32_t PENDCH0 = (1U << 0);  ///< Pending Channel 0
        constexpr uint32_t PENDCH1 = (1U << 1);  ///< Pending Channel 1
        constexpr uint32_t PENDCH2 = (1U << 2);  ///< Pending Channel 2
        constexpr uint32_t PENDCH3 = (1U << 3);  ///< Pending Channel 3
        constexpr uint32_t PENDCH4 = (1U << 4);  ///< Pending Channel 4
        constexpr uint32_t PENDCH5 = (1U << 5);  ///< Pending Channel 5
        constexpr uint32_t PENDCH6 = (1U << 6);  ///< Pending Channel 6
        constexpr uint32_t PENDCH7 = (1U << 7);  ///< Pending Channel 7
        constexpr uint32_t PENDCH8 = (1U << 8);  ///< Pending Channel 8
        constexpr uint32_t PENDCH9 = (1U << 9);  ///< Pending Channel 9
        constexpr uint32_t PENDCH10 = (1U << 10);  ///< Pending Channel 10
        constexpr uint32_t PENDCH11 = (1U << 11);  ///< Pending Channel 11
        constexpr uint32_t PENDCH12 = (1U << 12);  ///< Pending Channel 12
        constexpr uint32_t PENDCH13 = (1U << 13);  ///< Pending Channel 13
        constexpr uint32_t PENDCH14 = (1U << 14);  ///< Pending Channel 14
        constexpr uint32_t PENDCH15 = (1U << 15);  ///< Pending Channel 15
        constexpr uint32_t PENDCH16 = (1U << 16);  ///< Pending Channel 16
        constexpr uint32_t PENDCH17 = (1U << 17);  ///< Pending Channel 17
        constexpr uint32_t PENDCH18 = (1U << 18);  ///< Pending Channel 18
        constexpr uint32_t PENDCH19 = (1U << 19);  ///< Pending Channel 19
        constexpr uint32_t PENDCH20 = (1U << 20);  ///< Pending Channel 20
        constexpr uint32_t PENDCH21 = (1U << 21);  ///< Pending Channel 21
        constexpr uint32_t PENDCH22 = (1U << 22);  ///< Pending Channel 22
        constexpr uint32_t PENDCH23 = (1U << 23);  ///< Pending Channel 23
        constexpr uint32_t PENDCH24 = (1U << 24);  ///< Pending Channel 24
        constexpr uint32_t PENDCH25 = (1U << 25);  ///< Pending Channel 25
        constexpr uint32_t PENDCH26 = (1U << 26);  ///< Pending Channel 26
        constexpr uint32_t PENDCH27 = (1U << 27);  ///< Pending Channel 27
        constexpr uint32_t PENDCH28 = (1U << 28);  ///< Pending Channel 28
        constexpr uint32_t PENDCH29 = (1U << 29);  ///< Pending Channel 29
        constexpr uint32_t PENDCH30 = (1U << 30);  ///< Pending Channel 30
        constexpr uint32_t PENDCH31 = (1U << 31);  ///< Pending Channel 31
    }

    /// ACTIVE Register bits
    namespace active_bits {
        constexpr uint32_t LVLEX0 = (1U << 0);  ///< Level 0 Channel Trigger Request Executing
        constexpr uint32_t LVLEX1 = (1U << 1);  ///< Level 1 Channel Trigger Request Executing
        constexpr uint32_t LVLEX2 = (1U << 2);  ///< Level 2 Channel Trigger Request Executing
        constexpr uint32_t LVLEX3 = (1U << 3);  ///< Level 3 Channel Trigger Request Executing
        constexpr uint32_t ID = (5 << 8);  ///< Active Channel ID
        constexpr uint32_t ABUSY = (1U << 15);  ///< Active Channel Busy
        constexpr uint32_t BTCNT = (16 << 16);  ///< Active Channel Block Transfer Count
    }

    /// BASEADDR Register bits
    namespace baseaddr_bits {
        constexpr uint32_t BASEADDR = (32 << 0);  ///< Descriptor Memory Base Address
    }

    /// WRBADDR Register bits
    namespace wrbaddr_bits {
        constexpr uint32_t WRBADDR = (32 << 0);  ///< Write-Back Memory Base Address
    }

    /// CHCTRLA Register bits
    namespace chctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Channel Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Channel Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Channel Run in Standby
        constexpr uint32_t TRIGSRC = (7 << 8);  ///< Trigger Source
        constexpr uint32_t TRIGACT = (2 << 20);  ///< Trigger Action
        constexpr uint32_t BURSTLEN = (4 << 24);  ///< Burst Length
        constexpr uint32_t THRESHOLD = (2 << 28);  ///< FIFO Threshold
    }

    /// CHCTRLB Register bits
    namespace chctrlb_bits {
        constexpr uint32_t CMD = (2 << 0);  ///< Software Command
    }

    /// CHPRILVL Register bits
    namespace chprilvl_bits {
        constexpr uint32_t PRILVL = (2 << 0);  ///< Channel Priority Level
    }

    /// CHEVCTRL Register bits
    namespace chevctrl_bits {
        constexpr uint32_t EVACT = (3 << 0);  ///< Channel Event Input Action
        constexpr uint32_t EVOMODE = (2 << 4);  ///< Channel Event Output Mode
        constexpr uint32_t EVIE = (1U << 6);  ///< Channel Event Input Enable
        constexpr uint32_t EVOE = (1U << 7);  ///< Channel Event Output Enable
    }

    /// CHINTENCLR Register bits
    namespace chintenclr_bits {
        constexpr uint32_t TERR = (1U << 0);  ///< Channel Transfer Error Interrupt Enable
        constexpr uint32_t TCMPL = (1U << 1);  ///< Channel Transfer Complete Interrupt Enable
        constexpr uint32_t SUSP = (1U << 2);  ///< Channel Suspend Interrupt Enable
    }

    /// CHINTENSET Register bits
    namespace chintenset_bits {
        constexpr uint32_t TERR = (1U << 0);  ///< Channel Transfer Error Interrupt Enable
        constexpr uint32_t TCMPL = (1U << 1);  ///< Channel Transfer Complete Interrupt Enable
        constexpr uint32_t SUSP = (1U << 2);  ///< Channel Suspend Interrupt Enable
    }

    /// CHINTFLAG Register bits
    namespace chintflag_bits {
        constexpr uint32_t TERR = (1U << 0);  ///< Channel Transfer Error
        constexpr uint32_t TCMPL = (1U << 1);  ///< Channel Transfer Complete
        constexpr uint32_t SUSP = (1U << 2);  ///< Channel Suspend
    }

    /// CHSTATUS Register bits
    namespace chstatus_bits {
        constexpr uint32_t PEND = (1U << 0);  ///< Channel Pending
        constexpr uint32_t BUSY = (1U << 1);  ///< Channel Busy
        constexpr uint32_t FERR = (1U << 2);  ///< Channel Fetch Error
        constexpr uint32_t CRCERR = (1U << 3);  ///< Channel CRC Error
    }

}

// ============================================================================
// DSU Peripheral
// ============================================================================

namespace dsu {
    /// Base addresses
    constexpr uint32_t DSU_BASE = 0x41002000;

    /// DSU Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control
        volatile uint32_t STATUSA;  ///< Offset: 0x01 - Status A
        volatile uint32_t STATUSB;  ///< Offset: 0x02 - Status B
        volatile uint32_t ADDR;  ///< Offset: 0x04 - Address
        volatile uint32_t LENGTH;  ///< Offset: 0x08 - Length
        volatile uint32_t DATA;  ///< Offset: 0x0C - Data
        volatile uint32_t DCC__;  ///< Offset: 0x10 - Debug Communication Channel n (renamed from DCC__)
        volatile uint32_t DID;  ///< Offset: 0x18 - Device Identification
        volatile uint32_t CFG;  ///< Offset: 0x1C - Configuration
        volatile uint32_t DCFG__;  ///< Offset: 0xF0 - Device Configuration (renamed from DCFG__)
        volatile uint32_t ENTRY0;  ///< Offset: 0x1000 - CoreSight ROM Table Entry 0
        volatile uint32_t ENTRY1;  ///< Offset: 0x1004 - CoreSight ROM Table Entry 1
        volatile uint32_t END;  ///< Offset: 0x1008 - CoreSight ROM Table End
        volatile uint32_t MEMTYPE;  ///< Offset: 0x1FCC - CoreSight ROM Table Memory Type
        volatile uint32_t PID4;  ///< Offset: 0x1FD0 - Peripheral Identification 4
        volatile uint32_t PID5;  ///< Offset: 0x1FD4 - Peripheral Identification 5
        volatile uint32_t PID6;  ///< Offset: 0x1FD8 - Peripheral Identification 6
        volatile uint32_t PID7;  ///< Offset: 0x1FDC - Peripheral Identification 7
        volatile uint32_t PID0;  ///< Offset: 0x1FE0 - Peripheral Identification 0
        volatile uint32_t PID1;  ///< Offset: 0x1FE4 - Peripheral Identification 1
        volatile uint32_t PID2;  ///< Offset: 0x1FE8 - Peripheral Identification 2
        volatile uint32_t PID3;  ///< Offset: 0x1FEC - Peripheral Identification 3
        volatile uint32_t CID0;  ///< Offset: 0x1FF0 - Component Identification 0
        volatile uint32_t CID1;  ///< Offset: 0x1FF4 - Component Identification 1
        volatile uint32_t CID2;  ///< Offset: 0x1FF8 - Component Identification 2
        volatile uint32_t CID3;  ///< Offset: 0x1FFC - Component Identification 3
    };

    /// Peripheral instances
    inline Registers* DSU = reinterpret_cast<Registers*>(DSU_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t CRC = (1U << 2);  ///< 32-bit Cyclic Redundancy Code
        constexpr uint32_t MBIST = (1U << 3);  ///< Memory built-in self-test
        constexpr uint32_t CE = (1U << 4);  ///< Chip-Erase
        constexpr uint32_t ARR = (1U << 6);  ///< Auxiliary Row Read
        constexpr uint32_t SMSA = (1U << 7);  ///< Start Memory Stream Access
    }

    /// STATUSA Register bits
    namespace statusa_bits {
        constexpr uint32_t DONE = (1U << 0);  ///< Done
        constexpr uint32_t CRSTEXT = (1U << 1);  ///< CPU Reset Phase Extension
        constexpr uint32_t BERR = (1U << 2);  ///< Bus Error
        constexpr uint32_t FAIL = (1U << 3);  ///< Failure
        constexpr uint32_t PERR = (1U << 4);  ///< Protection Error
    }

    /// STATUSB Register bits
    namespace statusb_bits {
        constexpr uint32_t PROT = (1U << 0);  ///< Protected
        constexpr uint32_t DBGPRES = (1U << 1);  ///< Debugger Present
        constexpr uint32_t DCCD0 = (1U << 2);  ///< Debug Communication Channel 0 Dirty
        constexpr uint32_t DCCD1 = (1U << 3);  ///< Debug Communication Channel 1 Dirty
        constexpr uint32_t HPE = (1U << 4);  ///< Hot-Plugging Enable
        constexpr uint32_t CELCK = (1U << 5);  ///< Chip Erase Locked
        constexpr uint32_t TDCCD0 = (1U << 6);  ///< Test Debug Communication Channel 0 Dirty
        constexpr uint32_t TDCCD1 = (1U << 7);  ///< Test Debug Communication Channel 1 Dirty
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t AMOD = (2 << 0);  ///< Access Mode
        constexpr uint32_t ADDR = (30 << 2);  ///< Address
    }

    /// LENGTH Register bits
    namespace length_bits {
        constexpr uint32_t LENGTH = (30 << 2);  ///< Length
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// DCC__ Register bits
    namespace dcc___bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// DID Register bits
    namespace did_bits {
        constexpr uint32_t DEVSEL = (8 << 0);  ///< Device Select
        constexpr uint32_t REVISION = (4 << 8);  ///< Revision Number
        constexpr uint32_t DIE = (4 << 12);  ///< Die Number
        constexpr uint32_t SERIES = (6 << 16);  ///< Series
        constexpr uint32_t FAMILY = (5 << 23);  ///< Family
        constexpr uint32_t PROCESSOR = (4 << 28);  ///< Processor
    }

    /// CFG Register bits
    namespace cfg_bits {
        constexpr uint32_t LQOS = (2 << 0);  ///< Latency Quality Of Service
        constexpr uint32_t DCCDMALEVEL = (2 << 2);  ///< DMA Trigger Level
        constexpr uint32_t ETBRAMEN = (1U << 4);  ///< Trace Control
    }

    /// DCFG__ Register bits
    namespace dcfg___bits {
        constexpr uint32_t DCFG = (32 << 0);  ///< Device Configuration
    }

    /// ENTRY0 Register bits
    namespace entry0_bits {
        constexpr uint32_t EPRES = (1U << 0);  ///< Entry Present
        constexpr uint32_t FMT = (1U << 1);  ///< Format
        constexpr uint32_t ADDOFF = (20 << 12);  ///< Address Offset
    }

    /// END Register bits
    namespace end_bits {
        constexpr uint32_t END = (32 << 0);  ///< End Marker
    }

    /// MEMTYPE Register bits
    namespace memtype_bits {
        constexpr uint32_t SMEMP = (1U << 0);  ///< System Memory Present
    }

    /// PID4 Register bits
    namespace pid4_bits {
        constexpr uint32_t JEPCC = (4 << 0);  ///< JEP-106 Continuation Code
        constexpr uint32_t FKBC = (4 << 4);  ///< 4KB count
    }

    /// PID0 Register bits
    namespace pid0_bits {
        constexpr uint32_t PARTNBL = (8 << 0);  ///< Part Number Low
    }

    /// PID1 Register bits
    namespace pid1_bits {
        constexpr uint32_t PARTNBH = (4 << 0);  ///< Part Number High
        constexpr uint32_t JEPIDCL = (4 << 4);  ///< Low part of the JEP-106 Identity Code
    }

    /// PID2 Register bits
    namespace pid2_bits {
        constexpr uint32_t JEPIDCH = (3 << 0);  ///< JEP-106 Identity Code High
        constexpr uint32_t JEPU = (1U << 3);  ///< JEP-106 Identity Code is used
        constexpr uint32_t REVISION = (4 << 4);  ///< Revision Number
    }

    /// PID3 Register bits
    namespace pid3_bits {
        constexpr uint32_t CUSMOD = (4 << 0);  ///< ARM CUSMOD
        constexpr uint32_t REVAND = (4 << 4);  ///< Revision Number
    }

    /// CID0 Register bits
    namespace cid0_bits {
        constexpr uint32_t PREAMBLEB0 = (8 << 0);  ///< Preamble Byte 0
    }

    /// CID1 Register bits
    namespace cid1_bits {
        constexpr uint32_t PREAMBLE = (4 << 0);  ///< Preamble
        constexpr uint32_t CCLASS = (4 << 4);  ///< Component Class
    }

    /// CID2 Register bits
    namespace cid2_bits {
        constexpr uint32_t PREAMBLEB2 = (8 << 0);  ///< Preamble Byte 2
    }

    /// CID3 Register bits
    namespace cid3_bits {
        constexpr uint32_t PREAMBLEB3 = (8 << 0);  ///< Preamble Byte 3
    }

}

// ============================================================================
// EIC Peripheral
// ============================================================================

namespace eic {
    /// Base addresses
    constexpr uint32_t EIC_BASE = 0x40002800;

    /// EIC Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t NMICTRL;  ///< Offset: 0x01 - Non-Maskable Interrupt Control
        volatile uint32_t NMIFLAG;  ///< Offset: 0x02 - Non-Maskable Interrupt Flag Status and Clear
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x04 - Synchronization Busy
        volatile uint32_t EVCTRL;  ///< Offset: 0x08 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x0C - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x10 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x14 - Interrupt Flag Status and Clear
        volatile uint32_t ASYNCH;  ///< Offset: 0x18 - External Interrupt Asynchronous Mode
        volatile uint32_t CONFIG__;  ///< Offset: 0x1C - External Interrupt Sense Configuration (renamed from CONFIG__)
        volatile uint32_t DEBOUNCEN;  ///< Offset: 0x30 - Debouncer Enable
        volatile uint32_t DPRESCALER;  ///< Offset: 0x34 - Debouncer Prescaler
        volatile uint32_t PINSTATE;  ///< Offset: 0x38 - Pin State
    };

    /// Peripheral instances
    inline Registers* EIC = reinterpret_cast<Registers*>(EIC_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t CKSEL = (1U << 4);  ///< Clock Selection
    }

    /// NMICTRL Register bits
    namespace nmictrl_bits {
        constexpr uint32_t NMISENSE = (3 << 0);  ///< Non-Maskable Interrupt Sense Configuration
        constexpr uint32_t NMIFILTEN = (1U << 3);  ///< Non-Maskable Interrupt Filter Enable
        constexpr uint32_t NMIASYNCH = (1U << 4);  ///< Asynchronous Edge Detection Mode
    }

    /// NMIFLAG Register bits
    namespace nmiflag_bits {
        constexpr uint32_t NMI = (1U << 0);  ///< Non-Maskable Interrupt
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchronization Busy Status
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable Synchronization Busy Status
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t EXTINTEO = (16 << 0);  ///< External Interrupt Event Output Enable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t EXTINT = (16 << 0);  ///< External Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t EXTINT = (16 << 0);  ///< External Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t EXTINT = (16 << 0);  ///< External Interrupt
    }

    /// ASYNCH Register bits
    namespace asynch_bits {
        constexpr uint32_t ASYNCH = (16 << 0);  ///< Asynchronous Edge Detection Mode
    }

    /// CONFIG__ Register bits
    namespace config___bits {
        constexpr uint32_t SENSE0 = (3 << 0);  ///< Input Sense Configuration 0
        constexpr uint32_t FILTEN0 = (1U << 3);  ///< Filter Enable 0
        constexpr uint32_t SENSE1 = (3 << 4);  ///< Input Sense Configuration 1
        constexpr uint32_t FILTEN1 = (1U << 7);  ///< Filter Enable 1
        constexpr uint32_t SENSE2 = (3 << 8);  ///< Input Sense Configuration 2
        constexpr uint32_t FILTEN2 = (1U << 11);  ///< Filter Enable 2
        constexpr uint32_t SENSE3 = (3 << 12);  ///< Input Sense Configuration 3
        constexpr uint32_t FILTEN3 = (1U << 15);  ///< Filter Enable 3
        constexpr uint32_t SENSE4 = (3 << 16);  ///< Input Sense Configuration 4
        constexpr uint32_t FILTEN4 = (1U << 19);  ///< Filter Enable 4
        constexpr uint32_t SENSE5 = (3 << 20);  ///< Input Sense Configuration 5
        constexpr uint32_t FILTEN5 = (1U << 23);  ///< Filter Enable 5
        constexpr uint32_t SENSE6 = (3 << 24);  ///< Input Sense Configuration 6
        constexpr uint32_t FILTEN6 = (1U << 27);  ///< Filter Enable 6
        constexpr uint32_t SENSE7 = (3 << 28);  ///< Input Sense Configuration 7
        constexpr uint32_t FILTEN7 = (1U << 31);  ///< Filter Enable 7
    }

    /// DEBOUNCEN Register bits
    namespace debouncen_bits {
        constexpr uint32_t DEBOUNCEN = (16 << 0);  ///< Debouncer Enable
    }

    /// DPRESCALER Register bits
    namespace dprescaler_bits {
        constexpr uint32_t PRESCALER0 = (3 << 0);  ///< Debouncer Prescaler
        constexpr uint32_t STATES0 = (1U << 3);  ///< Debouncer number of states
        constexpr uint32_t PRESCALER1 = (3 << 4);  ///< Debouncer Prescaler
        constexpr uint32_t STATES1 = (1U << 7);  ///< Debouncer number of states
        constexpr uint32_t TICKON = (1U << 16);  ///< Pin Sampler frequency selection
    }

    /// PINSTATE Register bits
    namespace pinstate_bits {
        constexpr uint32_t PINSTATE = (16 << 0);  ///< Pin State
    }

}

// ============================================================================
// EVSYS Peripheral
// ============================================================================

namespace evsys {
    /// Base addresses
    constexpr uint32_t EVSYS_BASE = 0x4100E000;

    /// EVSYS Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control
        volatile uint32_t SWEVT;  ///< Offset: 0x04 - Software Event
        volatile uint32_t PRICTRL;  ///< Offset: 0x08 - Priority Control
        volatile uint32_t INTPEND;  ///< Offset: 0x10 - Channel Pending Interrupt
        volatile uint32_t INTSTATUS;  ///< Offset: 0x14 - Interrupt Status
        volatile uint32_t BUSYCH;  ///< Offset: 0x18 - Busy Channels
        volatile uint32_t READYUSR;  ///< Offset: 0x1C - Ready Users
        volatile uint32_t CHANNEL;  ///< Offset: 0x00 - Channel n Control
        volatile uint32_t CHINTENCLR;  ///< Offset: 0x04 - Channel n Interrupt Enable Clear
        volatile uint32_t CHINTENSET;  ///< Offset: 0x05 - Channel n Interrupt Enable Set
        volatile uint32_t CHINTFLAG;  ///< Offset: 0x06 - Channel n Interrupt Flag Status and Clear
        volatile uint32_t CHSTATUS;  ///< Offset: 0x07 - Channel n Status
        volatile uint32_t USER__;  ///< Offset: 0x120 - User Multiplexer n (renamed from USER__)
    };

    /// Peripheral instances
    inline Registers* EVSYS = reinterpret_cast<Registers*>(EVSYS_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
    }

    /// SWEVT Register bits
    namespace swevt_bits {
        constexpr uint32_t CHANNEL0 = (1U << 0);  ///< Channel 0 Software Selection
        constexpr uint32_t CHANNEL1 = (1U << 1);  ///< Channel 1 Software Selection
        constexpr uint32_t CHANNEL2 = (1U << 2);  ///< Channel 2 Software Selection
        constexpr uint32_t CHANNEL3 = (1U << 3);  ///< Channel 3 Software Selection
        constexpr uint32_t CHANNEL4 = (1U << 4);  ///< Channel 4 Software Selection
        constexpr uint32_t CHANNEL5 = (1U << 5);  ///< Channel 5 Software Selection
        constexpr uint32_t CHANNEL6 = (1U << 6);  ///< Channel 6 Software Selection
        constexpr uint32_t CHANNEL7 = (1U << 7);  ///< Channel 7 Software Selection
        constexpr uint32_t CHANNEL8 = (1U << 8);  ///< Channel 8 Software Selection
        constexpr uint32_t CHANNEL9 = (1U << 9);  ///< Channel 9 Software Selection
        constexpr uint32_t CHANNEL10 = (1U << 10);  ///< Channel 10 Software Selection
        constexpr uint32_t CHANNEL11 = (1U << 11);  ///< Channel 11 Software Selection
        constexpr uint32_t CHANNEL12 = (1U << 12);  ///< Channel 12 Software Selection
        constexpr uint32_t CHANNEL13 = (1U << 13);  ///< Channel 13 Software Selection
        constexpr uint32_t CHANNEL14 = (1U << 14);  ///< Channel 14 Software Selection
        constexpr uint32_t CHANNEL15 = (1U << 15);  ///< Channel 15 Software Selection
        constexpr uint32_t CHANNEL16 = (1U << 16);  ///< Channel 16 Software Selection
        constexpr uint32_t CHANNEL17 = (1U << 17);  ///< Channel 17 Software Selection
        constexpr uint32_t CHANNEL18 = (1U << 18);  ///< Channel 18 Software Selection
        constexpr uint32_t CHANNEL19 = (1U << 19);  ///< Channel 19 Software Selection
        constexpr uint32_t CHANNEL20 = (1U << 20);  ///< Channel 20 Software Selection
        constexpr uint32_t CHANNEL21 = (1U << 21);  ///< Channel 21 Software Selection
        constexpr uint32_t CHANNEL22 = (1U << 22);  ///< Channel 22 Software Selection
        constexpr uint32_t CHANNEL23 = (1U << 23);  ///< Channel 23 Software Selection
        constexpr uint32_t CHANNEL24 = (1U << 24);  ///< Channel 24 Software Selection
        constexpr uint32_t CHANNEL25 = (1U << 25);  ///< Channel 25 Software Selection
        constexpr uint32_t CHANNEL26 = (1U << 26);  ///< Channel 26 Software Selection
        constexpr uint32_t CHANNEL27 = (1U << 27);  ///< Channel 27 Software Selection
        constexpr uint32_t CHANNEL28 = (1U << 28);  ///< Channel 28 Software Selection
        constexpr uint32_t CHANNEL29 = (1U << 29);  ///< Channel 29 Software Selection
        constexpr uint32_t CHANNEL30 = (1U << 30);  ///< Channel 30 Software Selection
        constexpr uint32_t CHANNEL31 = (1U << 31);  ///< Channel 31 Software Selection
    }

    /// PRICTRL Register bits
    namespace prictrl_bits {
        constexpr uint32_t PRI = (4 << 0);  ///< Channel Priority Number
        constexpr uint32_t RREN = (1U << 7);  ///< Round-Robin Scheduling Enable
    }

    /// INTPEND Register bits
    namespace intpend_bits {
        constexpr uint32_t ID = (4 << 0);  ///< Channel ID
        constexpr uint32_t OVR = (1U << 8);  ///< Channel Overrun
        constexpr uint32_t EVD = (1U << 9);  ///< Channel Event Detected
        constexpr uint32_t READY = (1U << 14);  ///< Ready
        constexpr uint32_t BUSY = (1U << 15);  ///< Busy
    }

    /// INTSTATUS Register bits
    namespace intstatus_bits {
        constexpr uint32_t CHINT0 = (1U << 0);  ///< Channel 0 Pending Interrupt
        constexpr uint32_t CHINT1 = (1U << 1);  ///< Channel 1 Pending Interrupt
        constexpr uint32_t CHINT2 = (1U << 2);  ///< Channel 2 Pending Interrupt
        constexpr uint32_t CHINT3 = (1U << 3);  ///< Channel 3 Pending Interrupt
        constexpr uint32_t CHINT4 = (1U << 4);  ///< Channel 4 Pending Interrupt
        constexpr uint32_t CHINT5 = (1U << 5);  ///< Channel 5 Pending Interrupt
        constexpr uint32_t CHINT6 = (1U << 6);  ///< Channel 6 Pending Interrupt
        constexpr uint32_t CHINT7 = (1U << 7);  ///< Channel 7 Pending Interrupt
        constexpr uint32_t CHINT8 = (1U << 8);  ///< Channel 8 Pending Interrupt
        constexpr uint32_t CHINT9 = (1U << 9);  ///< Channel 9 Pending Interrupt
        constexpr uint32_t CHINT10 = (1U << 10);  ///< Channel 10 Pending Interrupt
        constexpr uint32_t CHINT11 = (1U << 11);  ///< Channel 11 Pending Interrupt
    }

    /// BUSYCH Register bits
    namespace busych_bits {
        constexpr uint32_t BUSYCH0 = (1U << 0);  ///< Busy Channel 0
        constexpr uint32_t BUSYCH1 = (1U << 1);  ///< Busy Channel 1
        constexpr uint32_t BUSYCH2 = (1U << 2);  ///< Busy Channel 2
        constexpr uint32_t BUSYCH3 = (1U << 3);  ///< Busy Channel 3
        constexpr uint32_t BUSYCH4 = (1U << 4);  ///< Busy Channel 4
        constexpr uint32_t BUSYCH5 = (1U << 5);  ///< Busy Channel 5
        constexpr uint32_t BUSYCH6 = (1U << 6);  ///< Busy Channel 6
        constexpr uint32_t BUSYCH7 = (1U << 7);  ///< Busy Channel 7
        constexpr uint32_t BUSYCH8 = (1U << 8);  ///< Busy Channel 8
        constexpr uint32_t BUSYCH9 = (1U << 9);  ///< Busy Channel 9
        constexpr uint32_t BUSYCH10 = (1U << 10);  ///< Busy Channel 10
        constexpr uint32_t BUSYCH11 = (1U << 11);  ///< Busy Channel 11
    }

    /// READYUSR Register bits
    namespace readyusr_bits {
        constexpr uint32_t READYUSR0 = (1U << 0);  ///< Ready User for Channel 0
        constexpr uint32_t READYUSR1 = (1U << 1);  ///< Ready User for Channel 1
        constexpr uint32_t READYUSR2 = (1U << 2);  ///< Ready User for Channel 2
        constexpr uint32_t READYUSR3 = (1U << 3);  ///< Ready User for Channel 3
        constexpr uint32_t READYUSR4 = (1U << 4);  ///< Ready User for Channel 4
        constexpr uint32_t READYUSR5 = (1U << 5);  ///< Ready User for Channel 5
        constexpr uint32_t READYUSR6 = (1U << 6);  ///< Ready User for Channel 6
        constexpr uint32_t READYUSR7 = (1U << 7);  ///< Ready User for Channel 7
        constexpr uint32_t READYUSR8 = (1U << 8);  ///< Ready User for Channel 8
        constexpr uint32_t READYUSR9 = (1U << 9);  ///< Ready User for Channel 9
        constexpr uint32_t READYUSR10 = (1U << 10);  ///< Ready User for Channel 10
        constexpr uint32_t READYUSR11 = (1U << 11);  ///< Ready User for Channel 11
    }

    /// CHANNEL Register bits
    namespace channel_bits {
        constexpr uint32_t EVGEN = (7 << 0);  ///< Event Generator Selection
        constexpr uint32_t PATH = (2 << 8);  ///< Path Selection
        constexpr uint32_t EDGSEL = (2 << 10);  ///< Edge Detection Selection
        constexpr uint32_t RUNSTDBY = (1U << 14);  ///< Run in standby
        constexpr uint32_t ONDEMAND = (1U << 15);  ///< Generic Clock On Demand
    }

    /// CHINTENCLR Register bits
    namespace chintenclr_bits {
        constexpr uint32_t OVR = (1U << 0);  ///< Channel Overrun Interrupt Disable
        constexpr uint32_t EVD = (1U << 1);  ///< Channel Event Detected Interrupt Disable
    }

    /// CHINTENSET Register bits
    namespace chintenset_bits {
        constexpr uint32_t OVR = (1U << 0);  ///< Channel Overrun Interrupt Enable
        constexpr uint32_t EVD = (1U << 1);  ///< Channel Event Detected Interrupt Enable
    }

    /// CHINTFLAG Register bits
    namespace chintflag_bits {
        constexpr uint32_t OVR = (1U << 0);  ///< Channel Overrun
        constexpr uint32_t EVD = (1U << 1);  ///< Channel Event Detected
    }

    /// CHSTATUS Register bits
    namespace chstatus_bits {
        constexpr uint32_t RDYUSR = (1U << 0);  ///< Ready User
        constexpr uint32_t BUSYCH = (1U << 1);  ///< Busy Channel
    }

    /// USER__ Register bits
    namespace user___bits {
        constexpr uint32_t CHANNEL = (6 << 0);  ///< Channel Event Selection
    }

}

// ============================================================================
// FREQM Peripheral
// ============================================================================

namespace freqm {
    /// Base addresses
    constexpr uint32_t FREQM_BASE = 0x40002C00;

    /// FREQM Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A Register
        volatile uint32_t CTRLB;  ///< Offset: 0x01 - Control B Register
        volatile uint32_t CFGA;  ///< Offset: 0x02 - Config A register
        volatile uint32_t INTENCLR;  ///< Offset: 0x08 - Interrupt Enable Clear Register
        volatile uint32_t INTENSET;  ///< Offset: 0x09 - Interrupt Enable Set Register
        volatile uint32_t INTFLAG;  ///< Offset: 0x0A - Interrupt Flag Register
        volatile uint32_t STATUS;  ///< Offset: 0x0B - Status Register
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x0C - Synchronization Busy Register
        volatile uint32_t VALUE;  ///< Offset: 0x10 - Count Value Register
    };

    /// Peripheral instances
    inline Registers* FREQM = reinterpret_cast<Registers*>(FREQM_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start Measurement
    }

    /// CFGA Register bits
    namespace cfga_bits {
        constexpr uint32_t REFNUM = (8 << 0);  ///< Number of Reference Clock Cycles
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t DONE = (1U << 0);  ///< Measurement Done Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t DONE = (1U << 0);  ///< Measurement Done Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t DONE = (1U << 0);  ///< Measurement Done
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t BUSY = (1U << 0);  ///< FREQM Status
        constexpr uint32_t OVF = (1U << 1);  ///< Sticky Count Value Overflow
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
    }

    /// VALUE Register bits
    namespace value_bits {
        constexpr uint32_t VALUE = (24 << 0);  ///< Measurement Value
    }

}

// ============================================================================
// GCLK Peripheral
// ============================================================================

namespace gclk {
    /// Base addresses
    constexpr uint32_t GCLK_BASE = 0x40001C00;

    /// GCLK Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x04 - Synchronization Busy
        volatile uint32_t GENCTRL__;  ///< Offset: 0x20 - Generic Clock Generator Control (renamed from GENCTRL__)
        volatile uint32_t PCHCTRL__;  ///< Offset: 0x80 - Peripheral Clock Control (renamed from PCHCTRL__)
    };

    /// Peripheral instances
    inline Registers* GCLK = reinterpret_cast<Registers*>(GCLK_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchroniation Busy bit
        constexpr uint32_t GENCTRL = (12 << 2);  ///< Generic Clock Generator Control n Synchronization Busy bits
    }

    /// GENCTRL__ Register bits
    namespace genctrl___bits {
        constexpr uint32_t SRC = (4 << 0);  ///< Source Select
        constexpr uint32_t GENEN = (1U << 8);  ///< Generic Clock Generator Enable
        constexpr uint32_t IDC = (1U << 9);  ///< Improve Duty Cycle
        constexpr uint32_t OOV = (1U << 10);  ///< Output Off Value
        constexpr uint32_t OE = (1U << 11);  ///< Output Enable
        constexpr uint32_t DIVSEL = (1U << 12);  ///< Divide Selection
        constexpr uint32_t RUNSTDBY = (1U << 13);  ///< Run in Standby
        constexpr uint32_t DIV = (16 << 16);  ///< Division Factor
    }

    /// PCHCTRL__ Register bits
    namespace pchctrl___bits {
        constexpr uint32_t GEN = (4 << 0);  ///< Generic Clock Generator
        constexpr uint32_t CHEN = (1U << 6);  ///< Channel Enable
        constexpr uint32_t WRTLOCK = (1U << 7);  ///< Write Lock
    }

}

// ============================================================================
// GMAC Peripheral
// ============================================================================

namespace gmac {
    /// Base addresses
    constexpr uint32_t GMAC_BASE = 0x42000800;

    /// GMAC Register structure
    struct Registers {
        volatile uint32_t NCR;  ///< Offset: 0x00 - Network Control Register
        volatile uint32_t NCFGR;  ///< Offset: 0x04 - Network Configuration Register
        volatile uint32_t NSR;  ///< Offset: 0x08 - Network Status Register
        volatile uint32_t UR;  ///< Offset: 0x0C - User Register
        volatile uint32_t DCFGR;  ///< Offset: 0x10 - DMA Configuration Register
        volatile uint32_t TSR;  ///< Offset: 0x14 - Transmit Status Register
        volatile uint32_t RBQB;  ///< Offset: 0x18 - Receive Buffer Queue Base Address
        volatile uint32_t TBQB;  ///< Offset: 0x1C - Transmit Buffer Queue Base Address
        volatile uint32_t RSR;  ///< Offset: 0x20 - Receive Status Register
        volatile uint32_t ISR;  ///< Offset: 0x24 - Interrupt Status Register
        volatile uint32_t IER;  ///< Offset: 0x28 - Interrupt Enable Register
        volatile uint32_t IDR;  ///< Offset: 0x2C - Interrupt Disable Register
        volatile uint32_t IMR;  ///< Offset: 0x30 - Interrupt Mask Register
        volatile uint32_t MAN;  ///< Offset: 0x34 - PHY Maintenance Register
        volatile uint32_t RPQ;  ///< Offset: 0x38 - Received Pause Quantum Register
        volatile uint32_t TPQ;  ///< Offset: 0x3C - Transmit Pause Quantum Register
        volatile uint32_t TPSF;  ///< Offset: 0x40 - TX partial store and forward Register
        volatile uint32_t RPSF;  ///< Offset: 0x44 - RX partial store and forward Register
        volatile uint32_t RJFML;  ///< Offset: 0x48 - RX Jumbo Frame Max Length Register
        volatile uint32_t HRB;  ///< Offset: 0x80 - Hash Register Bottom [31:0]
        volatile uint32_t HRT;  ///< Offset: 0x84 - Hash Register Top [63:32]
        volatile uint32_t SAB;  ///< Offset: 0x00 - Specific Address Bottom [31:0] Register
        volatile uint32_t SAT;  ///< Offset: 0x04 - Specific Address Top [47:32] Register
        volatile uint32_t TIDM__;  ///< Offset: 0xA8 - Type ID Match Register (renamed from TIDM__)
        volatile uint32_t WOL;  ///< Offset: 0xB8 - Wake on LAN
        volatile uint32_t IPGS;  ///< Offset: 0xBC - IPG Stretch Register
        volatile uint32_t SVLAN;  ///< Offset: 0xC0 - Stacked VLAN Register
        volatile uint32_t TPFCP;  ///< Offset: 0xC4 - Transmit PFC Pause Register
        volatile uint32_t SAMB1;  ///< Offset: 0xC8 - Specific Address 1 Mask Bottom [31:0] Register
        volatile uint32_t SAMT1;  ///< Offset: 0xCC - Specific Address 1 Mask Top [47:32] Register
        volatile uint32_t NSC;  ///< Offset: 0xDC - Tsu timer comparison nanoseconds Register
        volatile uint32_t SCL;  ///< Offset: 0xE0 - Tsu timer second comparison Register
        volatile uint32_t SCH;  ///< Offset: 0xE4 - Tsu timer second comparison Register
        volatile uint32_t EFTSH;  ///< Offset: 0xE8 - PTP Event Frame Transmitted Seconds High Register
        volatile uint32_t EFRSH;  ///< Offset: 0xEC - PTP Event Frame Received Seconds High Register
        volatile uint32_t PEFTSH;  ///< Offset: 0xF0 - PTP Peer Event Frame Transmitted Seconds High Register
        volatile uint32_t PEFRSH;  ///< Offset: 0xF4 - PTP Peer Event Frame Received Seconds High Register
        volatile uint32_t OTLO;  ///< Offset: 0x100 - Octets Transmitted [31:0] Register
        volatile uint32_t OTHI;  ///< Offset: 0x104 - Octets Transmitted [47:32] Register
        volatile uint32_t FT;  ///< Offset: 0x108 - Frames Transmitted Register
        volatile uint32_t BCFT;  ///< Offset: 0x10C - Broadcast Frames Transmitted Register
        volatile uint32_t MFT;  ///< Offset: 0x110 - Multicast Frames Transmitted Register
        volatile uint32_t PFT;  ///< Offset: 0x114 - Pause Frames Transmitted Register
        volatile uint32_t BFT64;  ///< Offset: 0x118 - 64 Byte Frames Transmitted Register
        volatile uint32_t TBFT127;  ///< Offset: 0x11C - 65 to 127 Byte Frames Transmitted Register
        volatile uint32_t TBFT255;  ///< Offset: 0x120 - 128 to 255 Byte Frames Transmitted Register
        volatile uint32_t TBFT511;  ///< Offset: 0x124 - 256 to 511 Byte Frames Transmitted Register
        volatile uint32_t TBFT1023;  ///< Offset: 0x128 - 512 to 1023 Byte Frames Transmitted Register
        volatile uint32_t TBFT1518;  ///< Offset: 0x12C - 1024 to 1518 Byte Frames Transmitted Register
        volatile uint32_t GTBFT1518;  ///< Offset: 0x130 - Greater Than 1518 Byte Frames Transmitted Register
        volatile uint32_t TUR;  ///< Offset: 0x134 - Transmit Underruns Register
        volatile uint32_t SCF;  ///< Offset: 0x138 - Single Collision Frames Register
        volatile uint32_t MCF;  ///< Offset: 0x13C - Multiple Collision Frames Register
        volatile uint32_t EC;  ///< Offset: 0x140 - Excessive Collisions Register
        volatile uint32_t LC;  ///< Offset: 0x144 - Late Collisions Register
        volatile uint32_t DTF;  ///< Offset: 0x148 - Deferred Transmission Frames Register
        volatile uint32_t CSE;  ///< Offset: 0x14C - Carrier Sense Errors Register
        volatile uint32_t ORLO;  ///< Offset: 0x150 - Octets Received [31:0] Received
        volatile uint32_t ORHI;  ///< Offset: 0x154 - Octets Received [47:32] Received
        volatile uint32_t FR;  ///< Offset: 0x158 - Frames Received Register
        volatile uint32_t BCFR;  ///< Offset: 0x15C - Broadcast Frames Received Register
        volatile uint32_t MFR;  ///< Offset: 0x160 - Multicast Frames Received Register
        volatile uint32_t PFR;  ///< Offset: 0x164 - Pause Frames Received Register
        volatile uint32_t BFR64;  ///< Offset: 0x168 - 64 Byte Frames Received Register
        volatile uint32_t TBFR127;  ///< Offset: 0x16C - 65 to 127 Byte Frames Received Register
        volatile uint32_t TBFR255;  ///< Offset: 0x170 - 128 to 255 Byte Frames Received Register
        volatile uint32_t TBFR511;  ///< Offset: 0x174 - 256 to 511Byte Frames Received Register
        volatile uint32_t TBFR1023;  ///< Offset: 0x178 - 512 to 1023 Byte Frames Received Register
        volatile uint32_t TBFR1518;  ///< Offset: 0x17C - 1024 to 1518 Byte Frames Received Register
        volatile uint32_t TMXBFR;  ///< Offset: 0x180 - 1519 to Maximum Byte Frames Received Register
        volatile uint32_t UFR;  ///< Offset: 0x184 - Undersize Frames Received Register
        volatile uint32_t OFR;  ///< Offset: 0x188 - Oversize Frames Received Register
        volatile uint32_t JR;  ///< Offset: 0x18C - Jabbers Received Register
        volatile uint32_t FCSE;  ///< Offset: 0x190 - Frame Check Sequence Errors Register
        volatile uint32_t LFFE;  ///< Offset: 0x194 - Length Field Frame Errors Register
        volatile uint32_t RSE;  ///< Offset: 0x198 - Receive Symbol Errors Register
        volatile uint32_t AE;  ///< Offset: 0x19C - Alignment Errors Register
        volatile uint32_t RRE;  ///< Offset: 0x1A0 - Receive Resource Errors Register
        volatile uint32_t ROE;  ///< Offset: 0x1A4 - Receive Overrun Register
        volatile uint32_t IHCE;  ///< Offset: 0x1A8 - IP Header Checksum Errors Register
        volatile uint32_t TCE;  ///< Offset: 0x1AC - TCP Checksum Errors Register
        volatile uint32_t UCE;  ///< Offset: 0x1B0 - UDP Checksum Errors Register
        volatile uint32_t TISUBN;  ///< Offset: 0x1BC - 1588 Timer Increment [15:0] Sub-Nanoseconds Register
        volatile uint32_t TSH;  ///< Offset: 0x1C0 - 1588 Timer Seconds High [15:0] Register
        volatile uint32_t TSSSL;  ///< Offset: 0x1C8 - 1588 Timer Sync Strobe Seconds [31:0] Register
        volatile uint32_t TSSN;  ///< Offset: 0x1CC - 1588 Timer Sync Strobe Nanoseconds Register
        volatile uint32_t TSL;  ///< Offset: 0x1D0 - 1588 Timer Seconds [31:0] Register
        volatile uint32_t TN;  ///< Offset: 0x1D4 - 1588 Timer Nanoseconds Register
        volatile uint32_t TA;  ///< Offset: 0x1D8 - 1588 Timer Adjust Register
        volatile uint32_t TI;  ///< Offset: 0x1DC - 1588 Timer Increment Register
        volatile uint32_t EFTSL;  ///< Offset: 0x1E0 - PTP Event Frame Transmitted Seconds Low Register
        volatile uint32_t EFTN;  ///< Offset: 0x1E4 - PTP Event Frame Transmitted Nanoseconds
        volatile uint32_t EFRSL;  ///< Offset: 0x1E8 - PTP Event Frame Received Seconds Low Register
        volatile uint32_t EFRN;  ///< Offset: 0x1EC - PTP Event Frame Received Nanoseconds
        volatile uint32_t PEFTSL;  ///< Offset: 0x1F0 - PTP Peer Event Frame Transmitted Seconds Low Register
        volatile uint32_t PEFTN;  ///< Offset: 0x1F4 - PTP Peer Event Frame Transmitted Nanoseconds
        volatile uint32_t PEFRSL;  ///< Offset: 0x1F8 - PTP Peer Event Frame Received Seconds Low Register
        volatile uint32_t PEFRN;  ///< Offset: 0x1FC - PTP Peer Event Frame Received Nanoseconds
        volatile uint32_t RLPITR;  ///< Offset: 0x270 - Receive LPI transition Register
        volatile uint32_t RLPITI;  ///< Offset: 0x274 - Receive LPI Time Register
        volatile uint32_t TLPITR;  ///< Offset: 0x278 - Receive LPI transition Register
        volatile uint32_t TLPITI;  ///< Offset: 0x27C - Receive LPI Time Register
    };

    /// Peripheral instances
    inline Registers* GMAC = reinterpret_cast<Registers*>(GMAC_BASE);

    // Bit definitions
    /// NCR Register bits
    namespace ncr_bits {
        constexpr uint32_t LBL = (1U << 1);  ///< Loop Back Local
        constexpr uint32_t RXEN = (1U << 2);  ///< Receive Enable
        constexpr uint32_t TXEN = (1U << 3);  ///< Transmit Enable
        constexpr uint32_t MPE = (1U << 4);  ///< Management Port Enable
        constexpr uint32_t CLRSTAT = (1U << 5);  ///< Clear Statistics Registers
        constexpr uint32_t INCSTAT = (1U << 6);  ///< Increment Statistics Registers
        constexpr uint32_t WESTAT = (1U << 7);  ///< Write Enable for Statistics Registers
        constexpr uint32_t BP = (1U << 8);  ///< Back pressure
        constexpr uint32_t TSTART = (1U << 9);  ///< Start Transmission
        constexpr uint32_t THALT = (1U << 10);  ///< Transmit Halt
        constexpr uint32_t TXPF = (1U << 11);  ///< Transmit Pause Frame
        constexpr uint32_t TXZQPF = (1U << 12);  ///< Transmit Zero Quantum Pause Frame
        constexpr uint32_t SRTSM = (1U << 15);  ///< Store Receive Time Stamp to Memory
        constexpr uint32_t ENPBPR = (1U << 16);  ///< Enable PFC Priority-based Pause Reception
        constexpr uint32_t TXPBPF = (1U << 17);  ///< Transmit PFC Priority-based Pause Frame
        constexpr uint32_t FNP = (1U << 18);  ///< Flush Next Packet
        constexpr uint32_t LPI = (1U << 19);  ///< Low Power Idle Enable
    }

    /// NCFGR Register bits
    namespace ncfgr_bits {
        constexpr uint32_t SPD = (1U << 0);  ///< Speed
        constexpr uint32_t FD = (1U << 1);  ///< Full Duplex
        constexpr uint32_t DNVLAN = (1U << 2);  ///< Discard Non-VLAN FRAMES
        constexpr uint32_t JFRAME = (1U << 3);  ///< Jumbo Frame Size
        constexpr uint32_t CAF = (1U << 4);  ///< Copy All Frames
        constexpr uint32_t NBC = (1U << 5);  ///< No Broadcast
        constexpr uint32_t MTIHEN = (1U << 6);  ///< Multicast Hash Enable
        constexpr uint32_t UNIHEN = (1U << 7);  ///< Unicast Hash Enable
        constexpr uint32_t MAXFS = (1U << 8);  ///< 1536 Maximum Frame Size
        constexpr uint32_t RTY = (1U << 12);  ///< Retry Test
        constexpr uint32_t PEN = (1U << 13);  ///< Pause Enable
        constexpr uint32_t RXBUFO = (2 << 14);  ///< Receive Buffer Offset
        constexpr uint32_t LFERD = (1U << 16);  ///< Length Field Error Frame Discard
        constexpr uint32_t RFCS = (1U << 17);  ///< Remove FCS
        constexpr uint32_t CLK = (3 << 18);  ///< MDC CLock Division
        constexpr uint32_t DBW = (2 << 21);  ///< Data Bus Width
        constexpr uint32_t DCPF = (1U << 23);  ///< Disable Copy of Pause Frames
        constexpr uint32_t RXCOEN = (1U << 24);  ///< Receive Checksum Offload Enable
        constexpr uint32_t EFRHD = (1U << 25);  ///< Enable Frames Received in Half Duplex
        constexpr uint32_t IRXFCS = (1U << 26);  ///< Ignore RX FCS
        constexpr uint32_t IPGSEN = (1U << 28);  ///< IP Stretch Enable
        constexpr uint32_t RXBP = (1U << 29);  ///< Receive Bad Preamble
        constexpr uint32_t IRXER = (1U << 30);  ///< Ignore IPG GRXER
    }

    /// NSR Register bits
    namespace nsr_bits {
        constexpr uint32_t MDIO = (1U << 1);  ///< MDIO Input Status
        constexpr uint32_t IDLE = (1U << 2);  ///< PHY Management Logic Idle
    }

    /// UR Register bits
    namespace ur_bits {
        constexpr uint32_t MII = (1U << 0);  ///< MII Mode
    }

    /// DCFGR Register bits
    namespace dcfgr_bits {
        constexpr uint32_t FBLDO = (5 << 0);  ///< Fixed Burst Length for DMA Data Operations:
        constexpr uint32_t ESMA = (1U << 6);  ///< Endian Swap Mode Enable for Management Descriptor Accesses
        constexpr uint32_t ESPA = (1U << 7);  ///< Endian Swap Mode Enable for Packet Data Accesses
        constexpr uint32_t RXBMS = (2 << 8);  ///< Receiver Packet Buffer Memory Size Select
        constexpr uint32_t TXPBMS = (1U << 10);  ///< Transmitter Packet Buffer Memory Size Select
        constexpr uint32_t TXCOEN = (1U << 11);  ///< Transmitter Checksum Generation Offload Enable
        constexpr uint32_t DRBS = (8 << 16);  ///< DMA Receive Buffer Size
        constexpr uint32_t DDRP = (1U << 24);  ///< DMA Discard Receive Packets
    }

    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t UBR = (1U << 0);  ///< Used Bit Read
        constexpr uint32_t COL = (1U << 1);  ///< Collision Occurred
        constexpr uint32_t RLE = (1U << 2);  ///< Retry Limit Exceeded
        constexpr uint32_t TXGO = (1U << 3);  ///< Transmit Go
        constexpr uint32_t TFC = (1U << 4);  ///< Transmit Frame Corruption Due to AHB Error
        constexpr uint32_t TXCOMP = (1U << 5);  ///< Transmit Complete
        constexpr uint32_t UND = (1U << 6);  ///< Transmit Underrun
        constexpr uint32_t HRESP = (1U << 8);  ///< HRESP Not OK
    }

    /// RBQB Register bits
    namespace rbqb_bits {
        constexpr uint32_t ADDR = (30 << 2);  ///< Receive Buffer Queue Base Address
    }

    /// TBQB Register bits
    namespace tbqb_bits {
        constexpr uint32_t ADDR = (30 << 2);  ///< Transmit Buffer Queue Base Address
    }

    /// RSR Register bits
    namespace rsr_bits {
        constexpr uint32_t BNA = (1U << 0);  ///< Buffer Not Available
        constexpr uint32_t REC = (1U << 1);  ///< Frame Received
        constexpr uint32_t RXOVR = (1U << 2);  ///< Receive Overrun
        constexpr uint32_t HNO = (1U << 3);  ///< HRESP Not OK
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t MFS = (1U << 0);  ///< Management Frame Sent
        constexpr uint32_t RCOMP = (1U << 1);  ///< Receive Complete
        constexpr uint32_t RXUBR = (1U << 2);  ///< RX Used Bit Read
        constexpr uint32_t TXUBR = (1U << 3);  ///< TX Used Bit Read
        constexpr uint32_t TUR = (1U << 4);  ///< Transmit Underrun
        constexpr uint32_t RLEX = (1U << 5);  ///< Retry Limit Exceeded
        constexpr uint32_t TFC = (1U << 6);  ///< Transmit Frame Corruption Due to AHB Error
        constexpr uint32_t TCOMP = (1U << 7);  ///< Transmit Complete
        constexpr uint32_t ROVR = (1U << 10);  ///< Receive Overrun
        constexpr uint32_t HRESP = (1U << 11);  ///< HRESP Not OK
        constexpr uint32_t PFNZ = (1U << 12);  ///< Pause Frame with Non-zero Pause Quantum Received
        constexpr uint32_t PTZ = (1U << 13);  ///< Pause Time Zero
        constexpr uint32_t PFTR = (1U << 14);  ///< Pause Frame Transmitted
        constexpr uint32_t DRQFR = (1U << 18);  ///< PTP Delay Request Frame Received
        constexpr uint32_t SFR = (1U << 19);  ///< PTP Sync Frame Received
        constexpr uint32_t DRQFT = (1U << 20);  ///< PTP Delay Request Frame Transmitted
        constexpr uint32_t SFT = (1U << 21);  ///< PTP Sync Frame Transmitted
        constexpr uint32_t PDRQFR = (1U << 22);  ///< PDelay Request Frame Received
        constexpr uint32_t PDRSFR = (1U << 23);  ///< PDelay Response Frame Received
        constexpr uint32_t PDRQFT = (1U << 24);  ///< PDelay Request Frame Transmitted
        constexpr uint32_t PDRSFT = (1U << 25);  ///< PDelay Response Frame Transmitted
        constexpr uint32_t SRI = (1U << 26);  ///< TSU Seconds Register Increment
        constexpr uint32_t WOL = (1U << 28);  ///< Wake On LAN
        constexpr uint32_t TSUCMP = (1U << 29);  ///< Tsu timer comparison
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t MFS = (1U << 0);  ///< Management Frame Sent
        constexpr uint32_t RCOMP = (1U << 1);  ///< Receive Complete
        constexpr uint32_t RXUBR = (1U << 2);  ///< RX Used Bit Read
        constexpr uint32_t TXUBR = (1U << 3);  ///< TX Used Bit Read
        constexpr uint32_t TUR = (1U << 4);  ///< Transmit Underrun
        constexpr uint32_t RLEX = (1U << 5);  ///< Retry Limit Exceeded or Late Collision
        constexpr uint32_t TFC = (1U << 6);  ///< Transmit Frame Corruption Due to AHB Error
        constexpr uint32_t TCOMP = (1U << 7);  ///< Transmit Complete
        constexpr uint32_t ROVR = (1U << 10);  ///< Receive Overrun
        constexpr uint32_t HRESP = (1U << 11);  ///< HRESP Not OK
        constexpr uint32_t PFNZ = (1U << 12);  ///< Pause Frame with Non-zero Pause Quantum Received
        constexpr uint32_t PTZ = (1U << 13);  ///< Pause Time Zero
        constexpr uint32_t PFTR = (1U << 14);  ///< Pause Frame Transmitted
        constexpr uint32_t EXINT = (1U << 15);  ///< External Interrupt
        constexpr uint32_t DRQFR = (1U << 18);  ///< PTP Delay Request Frame Received
        constexpr uint32_t SFR = (1U << 19);  ///< PTP Sync Frame Received
        constexpr uint32_t DRQFT = (1U << 20);  ///< PTP Delay Request Frame Transmitted
        constexpr uint32_t SFT = (1U << 21);  ///< PTP Sync Frame Transmitted
        constexpr uint32_t PDRQFR = (1U << 22);  ///< PDelay Request Frame Received
        constexpr uint32_t PDRSFR = (1U << 23);  ///< PDelay Response Frame Received
        constexpr uint32_t PDRQFT = (1U << 24);  ///< PDelay Request Frame Transmitted
        constexpr uint32_t PDRSFT = (1U << 25);  ///< PDelay Response Frame Transmitted
        constexpr uint32_t SRI = (1U << 26);  ///< TSU Seconds Register Increment
        constexpr uint32_t WOL = (1U << 28);  ///< Wake On LAN
        constexpr uint32_t TSUCMP = (1U << 29);  ///< Tsu timer comparison
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t MFS = (1U << 0);  ///< Management Frame Sent
        constexpr uint32_t RCOMP = (1U << 1);  ///< Receive Complete
        constexpr uint32_t RXUBR = (1U << 2);  ///< RX Used Bit Read
        constexpr uint32_t TXUBR = (1U << 3);  ///< TX Used Bit Read
        constexpr uint32_t TUR = (1U << 4);  ///< Transmit Underrun
        constexpr uint32_t RLEX = (1U << 5);  ///< Retry Limit Exceeded or Late Collision
        constexpr uint32_t TFC = (1U << 6);  ///< Transmit Frame Corruption Due to AHB Error
        constexpr uint32_t TCOMP = (1U << 7);  ///< Transmit Complete
        constexpr uint32_t ROVR = (1U << 10);  ///< Receive Overrun
        constexpr uint32_t HRESP = (1U << 11);  ///< HRESP Not OK
        constexpr uint32_t PFNZ = (1U << 12);  ///< Pause Frame with Non-zero Pause Quantum Received
        constexpr uint32_t PTZ = (1U << 13);  ///< Pause Time Zero
        constexpr uint32_t PFTR = (1U << 14);  ///< Pause Frame Transmitted
        constexpr uint32_t EXINT = (1U << 15);  ///< External Interrupt
        constexpr uint32_t DRQFR = (1U << 18);  ///< PTP Delay Request Frame Received
        constexpr uint32_t SFR = (1U << 19);  ///< PTP Sync Frame Received
        constexpr uint32_t DRQFT = (1U << 20);  ///< PTP Delay Request Frame Transmitted
        constexpr uint32_t SFT = (1U << 21);  ///< PTP Sync Frame Transmitted
        constexpr uint32_t PDRQFR = (1U << 22);  ///< PDelay Request Frame Received
        constexpr uint32_t PDRSFR = (1U << 23);  ///< PDelay Response Frame Received
        constexpr uint32_t PDRQFT = (1U << 24);  ///< PDelay Request Frame Transmitted
        constexpr uint32_t PDRSFT = (1U << 25);  ///< PDelay Response Frame Transmitted
        constexpr uint32_t SRI = (1U << 26);  ///< TSU Seconds Register Increment
        constexpr uint32_t WOL = (1U << 28);  ///< Wake On LAN
        constexpr uint32_t TSUCMP = (1U << 29);  ///< Tsu timer comparison
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t MFS = (1U << 0);  ///< Management Frame Sent
        constexpr uint32_t RCOMP = (1U << 1);  ///< Receive Complete
        constexpr uint32_t RXUBR = (1U << 2);  ///< RX Used Bit Read
        constexpr uint32_t TXUBR = (1U << 3);  ///< TX Used Bit Read
        constexpr uint32_t TUR = (1U << 4);  ///< Transmit Underrun
        constexpr uint32_t RLEX = (1U << 5);  ///< Retry Limit Exceeded
        constexpr uint32_t TFC = (1U << 6);  ///< Transmit Frame Corruption Due to AHB Error
        constexpr uint32_t TCOMP = (1U << 7);  ///< Transmit Complete
        constexpr uint32_t ROVR = (1U << 10);  ///< Receive Overrun
        constexpr uint32_t HRESP = (1U << 11);  ///< HRESP Not OK
        constexpr uint32_t PFNZ = (1U << 12);  ///< Pause Frame with Non-zero Pause Quantum Received
        constexpr uint32_t PTZ = (1U << 13);  ///< Pause Time Zero
        constexpr uint32_t PFTR = (1U << 14);  ///< Pause Frame Transmitted
        constexpr uint32_t EXINT = (1U << 15);  ///< External Interrupt
        constexpr uint32_t DRQFR = (1U << 18);  ///< PTP Delay Request Frame Received
        constexpr uint32_t SFR = (1U << 19);  ///< PTP Sync Frame Received
        constexpr uint32_t DRQFT = (1U << 20);  ///< PTP Delay Request Frame Transmitted
        constexpr uint32_t SFT = (1U << 21);  ///< PTP Sync Frame Transmitted
        constexpr uint32_t PDRQFR = (1U << 22);  ///< PDelay Request Frame Received
        constexpr uint32_t PDRSFR = (1U << 23);  ///< PDelay Response Frame Received
        constexpr uint32_t PDRQFT = (1U << 24);  ///< PDelay Request Frame Transmitted
        constexpr uint32_t PDRSFT = (1U << 25);  ///< PDelay Response Frame Transmitted
        constexpr uint32_t SRI = (1U << 26);  ///< TSU Seconds Register Increment
        constexpr uint32_t WOL = (1U << 28);  ///< Wake On Lan
        constexpr uint32_t TSUCMP = (1U << 29);  ///< Tsu timer comparison
    }

    /// MAN Register bits
    namespace man_bits {
        constexpr uint32_t DATA = (16 << 0);  ///< PHY Data
        constexpr uint32_t WTN = (2 << 16);  ///< Write Ten
        constexpr uint32_t REGA = (5 << 18);  ///< Register Address
        constexpr uint32_t PHYA = (5 << 23);  ///< PHY Address
        constexpr uint32_t OP = (2 << 28);  ///< Operation
        constexpr uint32_t CLTTO = (1U << 30);  ///< Clause 22 Operation
        constexpr uint32_t WZO = (1U << 31);  ///< Write ZERO
    }

    /// RPQ Register bits
    namespace rpq_bits {
        constexpr uint32_t RPQ = (16 << 0);  ///< Received Pause Quantum
    }

    /// TPQ Register bits
    namespace tpq_bits {
        constexpr uint32_t TPQ = (16 << 0);  ///< Transmit Pause Quantum
    }

    /// TPSF Register bits
    namespace tpsf_bits {
        constexpr uint32_t TPB1ADR = (10 << 0);  ///< TX packet buffer address
        constexpr uint32_t ENTXP = (1U << 31);  ///< Enable TX partial store and forward operation
    }

    /// RPSF Register bits
    namespace rpsf_bits {
        constexpr uint32_t RPB1ADR = (10 << 0);  ///< RX packet buffer address
        constexpr uint32_t ENRXP = (1U << 31);  ///< Enable RX partial store and forward operation
    }

    /// RJFML Register bits
    namespace rjfml_bits {
        constexpr uint32_t FML = (14 << 0);  ///< Frame Max Length
    }

    /// HRB Register bits
    namespace hrb_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Hash Address
    }

    /// HRT Register bits
    namespace hrt_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Hash Address
    }

    /// SAB Register bits
    namespace sab_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Specific Address 1
    }

    /// SAT Register bits
    namespace sat_bits {
        constexpr uint32_t ADDR = (16 << 0);  ///< Specific Address 1
    }

    /// TIDM__ Register bits
    namespace tidm___bits {
        constexpr uint32_t TID = (16 << 0);  ///< Type ID Match 1
    }

    /// WOL Register bits
    namespace wol_bits {
        constexpr uint32_t IP = (16 << 0);  ///< IP address
        constexpr uint32_t MAG = (1U << 16);  ///< Event enable
        constexpr uint32_t ARP = (1U << 17);  ///< LAN ARP req
        constexpr uint32_t SA1 = (1U << 18);  ///< WOL specific address reg 1
        constexpr uint32_t MTI = (1U << 19);  ///< WOL LAN multicast
    }

    /// IPGS Register bits
    namespace ipgs_bits {
        constexpr uint32_t FL = (16 << 0);  ///< Frame Length
    }

    /// SVLAN Register bits
    namespace svlan_bits {
        constexpr uint32_t VLAN_TYPE = (16 << 0);  ///< User Defined VLAN_TYPE Field
        constexpr uint32_t ESVLAN = (1U << 31);  ///< Enable Stacked VLAN Processing Mode
    }

    /// TPFCP Register bits
    namespace tpfcp_bits {
        constexpr uint32_t PEV = (8 << 0);  ///< Priority Enable Vector
        constexpr uint32_t PQ = (8 << 8);  ///< Pause Quantum
    }

    /// SAMB1 Register bits
    namespace samb1_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Specific Address 1 Mask
    }

    /// SAMT1 Register bits
    namespace samt1_bits {
        constexpr uint32_t ADDR = (16 << 0);  ///< Specific Address 1 Mask
    }

    /// NSC Register bits
    namespace nsc_bits {
        constexpr uint32_t NANOSEC = (21 << 0);  ///< 1588 Timer Nanosecond comparison value
    }

    /// SCL Register bits
    namespace scl_bits {
        constexpr uint32_t SEC = (32 << 0);  ///< 1588 Timer Second comparison value
    }

    /// SCH Register bits
    namespace sch_bits {
        constexpr uint32_t SEC = (16 << 0);  ///< 1588 Timer Second comparison value
    }

    /// EFTSH Register bits
    namespace eftsh_bits {
        constexpr uint32_t RUD = (16 << 0);  ///< Register Update
    }

    /// EFRSH Register bits
    namespace efrsh_bits {
        constexpr uint32_t RUD = (16 << 0);  ///< Register Update
    }

    /// PEFTSH Register bits
    namespace peftsh_bits {
        constexpr uint32_t RUD = (16 << 0);  ///< Register Update
    }

    /// PEFRSH Register bits
    namespace pefrsh_bits {
        constexpr uint32_t RUD = (16 << 0);  ///< Register Update
    }

    /// OTLO Register bits
    namespace otlo_bits {
        constexpr uint32_t TXO = (32 << 0);  ///< Transmitted Octets
    }

    /// OTHI Register bits
    namespace othi_bits {
        constexpr uint32_t TXO = (16 << 0);  ///< Transmitted Octets
    }

    /// FT Register bits
    namespace ft_bits {
        constexpr uint32_t FTX = (32 << 0);  ///< Frames Transmitted without Error
    }

    /// BCFT Register bits
    namespace bcft_bits {
        constexpr uint32_t BFTX = (32 << 0);  ///< Broadcast Frames Transmitted without Error
    }

    /// MFT Register bits
    namespace mft_bits {
        constexpr uint32_t MFTX = (32 << 0);  ///< Multicast Frames Transmitted without Error
    }

    /// PFT Register bits
    namespace pft_bits {
        constexpr uint32_t PFTX = (16 << 0);  ///< Pause Frames Transmitted Register
    }

    /// BFT64 Register bits
    namespace bft64_bits {
        constexpr uint32_t NFTX = (32 << 0);  ///< 64 Byte Frames Transmitted without Error
    }

    /// TBFT127 Register bits
    namespace tbft127_bits {
        constexpr uint32_t NFTX = (32 << 0);  ///< 65 to 127 Byte Frames Transmitted without Error
    }

    /// TBFT255 Register bits
    namespace tbft255_bits {
        constexpr uint32_t NFTX = (32 << 0);  ///< 128 to 255 Byte Frames Transmitted without Error
    }

    /// TBFT511 Register bits
    namespace tbft511_bits {
        constexpr uint32_t NFTX = (32 << 0);  ///< 256 to 511 Byte Frames Transmitted without Error
    }

    /// TBFT1023 Register bits
    namespace tbft1023_bits {
        constexpr uint32_t NFTX = (32 << 0);  ///< 512 to 1023 Byte Frames Transmitted without Error
    }

    /// TBFT1518 Register bits
    namespace tbft1518_bits {
        constexpr uint32_t NFTX = (32 << 0);  ///< 1024 to 1518 Byte Frames Transmitted without Error
    }

    /// GTBFT1518 Register bits
    namespace gtbft1518_bits {
        constexpr uint32_t NFTX = (32 << 0);  ///< Greater than 1518 Byte Frames Transmitted without Error
    }

    /// TUR Register bits
    namespace tur_bits {
        constexpr uint32_t TXUNR = (10 << 0);  ///< Transmit Underruns
    }

    /// SCF Register bits
    namespace scf_bits {
        constexpr uint32_t SCOL = (18 << 0);  ///< Single Collision
    }

    /// MCF Register bits
    namespace mcf_bits {
        constexpr uint32_t MCOL = (18 << 0);  ///< Multiple Collision
    }

    /// EC Register bits
    namespace ec_bits {
        constexpr uint32_t XCOL = (10 << 0);  ///< Excessive Collisions
    }

    /// LC Register bits
    namespace lc_bits {
        constexpr uint32_t LCOL = (10 << 0);  ///< Late Collisions
    }

    /// DTF Register bits
    namespace dtf_bits {
        constexpr uint32_t DEFT = (18 << 0);  ///< Deferred Transmission
    }

    /// CSE Register bits
    namespace cse_bits {
        constexpr uint32_t CSR = (10 << 0);  ///< Carrier Sense Error
    }

    /// ORLO Register bits
    namespace orlo_bits {
        constexpr uint32_t RXO = (32 << 0);  ///< Received Octets
    }

    /// ORHI Register bits
    namespace orhi_bits {
        constexpr uint32_t RXO = (16 << 0);  ///< Received Octets
    }

    /// FR Register bits
    namespace fr_bits {
        constexpr uint32_t FRX = (32 << 0);  ///< Frames Received without Error
    }

    /// BCFR Register bits
    namespace bcfr_bits {
        constexpr uint32_t BFRX = (32 << 0);  ///< Broadcast Frames Received without Error
    }

    /// MFR Register bits
    namespace mfr_bits {
        constexpr uint32_t MFRX = (32 << 0);  ///< Multicast Frames Received without Error
    }

    /// PFR Register bits
    namespace pfr_bits {
        constexpr uint32_t PFRX = (16 << 0);  ///< Pause Frames Received Register
    }

    /// BFR64 Register bits
    namespace bfr64_bits {
        constexpr uint32_t NFRX = (32 << 0);  ///< 64 Byte Frames Received without Error
    }

    /// TBFR127 Register bits
    namespace tbfr127_bits {
        constexpr uint32_t NFRX = (32 << 0);  ///< 65 to 127 Byte Frames Received without Error
    }

    /// TBFR255 Register bits
    namespace tbfr255_bits {
        constexpr uint32_t NFRX = (32 << 0);  ///< 128 to 255 Byte Frames Received without Error
    }

    /// TBFR511 Register bits
    namespace tbfr511_bits {
        constexpr uint32_t NFRX = (32 << 0);  ///< 256 to 511 Byte Frames Received without Error
    }

    /// TBFR1023 Register bits
    namespace tbfr1023_bits {
        constexpr uint32_t NFRX = (32 << 0);  ///< 512 to 1023 Byte Frames Received without Error
    }

    /// TBFR1518 Register bits
    namespace tbfr1518_bits {
        constexpr uint32_t NFRX = (32 << 0);  ///< 1024 to 1518 Byte Frames Received without Error
    }

    /// TMXBFR Register bits
    namespace tmxbfr_bits {
        constexpr uint32_t NFRX = (32 << 0);  ///< 1519 to Maximum Byte Frames Received without Error
    }

    /// UFR Register bits
    namespace ufr_bits {
        constexpr uint32_t UFRX = (10 << 0);  ///< Undersize Frames Received
    }

    /// OFR Register bits
    namespace ofr_bits {
        constexpr uint32_t OFRX = (10 << 0);  ///< Oversized Frames Received
    }

    /// JR Register bits
    namespace jr_bits {
        constexpr uint32_t JRX = (10 << 0);  ///< Jabbers Received
    }

    /// FCSE Register bits
    namespace fcse_bits {
        constexpr uint32_t FCKR = (10 << 0);  ///< Frame Check Sequence Errors
    }

    /// LFFE Register bits
    namespace lffe_bits {
        constexpr uint32_t LFER = (10 << 0);  ///< Length Field Frame Errors
    }

    /// RSE Register bits
    namespace rse_bits {
        constexpr uint32_t RXSE = (10 << 0);  ///< Receive Symbol Errors
    }

    /// AE Register bits
    namespace ae_bits {
        constexpr uint32_t AER = (10 << 0);  ///< Alignment Errors
    }

    /// RRE Register bits
    namespace rre_bits {
        constexpr uint32_t RXRER = (18 << 0);  ///< Receive Resource Errors
    }

    /// ROE Register bits
    namespace roe_bits {
        constexpr uint32_t RXOVR = (10 << 0);  ///< Receive Overruns
    }

    /// IHCE Register bits
    namespace ihce_bits {
        constexpr uint32_t HCKER = (8 << 0);  ///< IP Header Checksum Errors
    }

    /// TCE Register bits
    namespace tce_bits {
        constexpr uint32_t TCKER = (8 << 0);  ///< TCP Checksum Errors
    }

    /// UCE Register bits
    namespace uce_bits {
        constexpr uint32_t UCKER = (8 << 0);  ///< UDP Checksum Errors
    }

    /// TISUBN Register bits
    namespace tisubn_bits {
        constexpr uint32_t LSBTIR = (16 << 0);  ///< Lower Significant Bits of Timer Increment
    }

    /// TSH Register bits
    namespace tsh_bits {
        constexpr uint32_t TCS = (16 << 0);  ///< Timer Count in Seconds
    }

    /// TSSSL Register bits
    namespace tsssl_bits {
        constexpr uint32_t VTS = (32 << 0);  ///< Value of Timer Seconds Register Capture
    }

    /// TSSN Register bits
    namespace tssn_bits {
        constexpr uint32_t VTN = (30 << 0);  ///< Value Timer Nanoseconds Register Capture
    }

    /// TSL Register bits
    namespace tsl_bits {
        constexpr uint32_t TCS = (32 << 0);  ///< Timer Count in Seconds
    }

    /// TN Register bits
    namespace tn_bits {
        constexpr uint32_t TNS = (30 << 0);  ///< Timer Count in Nanoseconds
    }

    /// TA Register bits
    namespace ta_bits {
        constexpr uint32_t ITDT = (30 << 0);  ///< Increment/Decrement
        constexpr uint32_t ADJ = (1U << 31);  ///< Adjust 1588 Timer
    }

    /// TI Register bits
    namespace ti_bits {
        constexpr uint32_t CNS = (8 << 0);  ///< Count Nanoseconds
        constexpr uint32_t ACNS = (8 << 8);  ///< Alternative Count Nanoseconds
        constexpr uint32_t NIT = (8 << 16);  ///< Number of Increments
    }

    /// EFTSL Register bits
    namespace eftsl_bits {
        constexpr uint32_t RUD = (32 << 0);  ///< Register Update
    }

    /// EFTN Register bits
    namespace eftn_bits {
        constexpr uint32_t RUD = (30 << 0);  ///< Register Update
    }

    /// EFRSL Register bits
    namespace efrsl_bits {
        constexpr uint32_t RUD = (32 << 0);  ///< Register Update
    }

    /// EFRN Register bits
    namespace efrn_bits {
        constexpr uint32_t RUD = (30 << 0);  ///< Register Update
    }

    /// PEFTSL Register bits
    namespace peftsl_bits {
        constexpr uint32_t RUD = (32 << 0);  ///< Register Update
    }

    /// PEFTN Register bits
    namespace peftn_bits {
        constexpr uint32_t RUD = (30 << 0);  ///< Register Update
    }

    /// PEFRSL Register bits
    namespace pefrsl_bits {
        constexpr uint32_t RUD = (32 << 0);  ///< Register Update
    }

    /// PEFRN Register bits
    namespace pefrn_bits {
        constexpr uint32_t RUD = (30 << 0);  ///< Register Update
    }

    /// RLPITR Register bits
    namespace rlpitr_bits {
        constexpr uint32_t RLPITR = (16 << 0);  ///< Count number of times transition from rx normal idle to low power idle
    }

    /// RLPITI Register bits
    namespace rlpiti_bits {
        constexpr uint32_t RLPITI = (24 << 0);  ///< Increment once over 16 ahb clock when LPI indication bit 20 is set in rx mode
    }

    /// TLPITR Register bits
    namespace tlpitr_bits {
        constexpr uint32_t TLPITR = (16 << 0);  ///< Count number of times enable LPI tx bit 20 goes from low to high
    }

    /// TLPITI Register bits
    namespace tlpiti_bits {
        constexpr uint32_t TLPITI = (24 << 0);  ///< Increment once over 16 ahb clock when LPI indication bit 20 is set in tx mode
    }

}

// ============================================================================
// HMATRIX Peripheral
// ============================================================================

namespace hmatrix {
    /// Base addresses
    constexpr uint32_t HMATRIX_BASE = 0x4100C000;

    /// HMATRIX Register structure
    struct Registers {
        volatile uint32_t PRAS;  ///< Offset: 0x00 - Priority A for Slave
        volatile uint32_t PRBS;  ///< Offset: 0x04 - Priority B for Slave
    };

    /// Peripheral instances
    inline Registers* HMATRIX = reinterpret_cast<Registers*>(HMATRIX_BASE);

}

// ============================================================================
// ICM Peripheral
// ============================================================================

namespace icm {
    /// Base addresses
    constexpr uint32_t ICM_BASE = 0x42002C00;

    /// ICM Register structure
    struct Registers {
        volatile uint32_t CFG;  ///< Offset: 0x00 - Configuration
        volatile uint32_t CTRL;  ///< Offset: 0x04 - Control
        volatile uint32_t SR;  ///< Offset: 0x08 - Status
        volatile uint32_t IER;  ///< Offset: 0x10 - Interrupt Enable
        volatile uint32_t IDR;  ///< Offset: 0x14 - Interrupt Disable
        volatile uint32_t IMR;  ///< Offset: 0x18 - Interrupt Mask
        volatile uint32_t ISR;  ///< Offset: 0x1C - Interrupt Status
        volatile uint32_t UASR;  ///< Offset: 0x20 - Undefined Access Status
        volatile uint32_t DSCR;  ///< Offset: 0x30 - Region Descriptor Area Start Address
        volatile uint32_t HASH;  ///< Offset: 0x34 - Region Hash Area Start Address
        volatile uint32_t UIHVAL__;  ///< Offset: 0x38 - User Initial Hash Value n (renamed from UIHVAL__)
    };

    /// Peripheral instances
    inline Registers* ICM = reinterpret_cast<Registers*>(ICM_BASE);

    // Bit definitions
    /// CFG Register bits
    namespace cfg_bits {
        constexpr uint32_t WBDIS = (1U << 0);  ///< Write Back Disable
        constexpr uint32_t EOMDIS = (1U << 1);  ///< End of Monitoring Disable
        constexpr uint32_t SLBDIS = (1U << 2);  ///< Secondary List Branching Disable
        constexpr uint32_t BBC = (4 << 4);  ///< Bus Burden Control
        constexpr uint32_t ASCD = (1U << 8);  ///< Automatic Switch To Compare Digest
        constexpr uint32_t DUALBUFF = (1U << 9);  ///< Dual Input Buffer
        constexpr uint32_t UIHASH = (1U << 12);  ///< User Initial Hash Value
        constexpr uint32_t UALGO = (3 << 13);  ///< User SHA Algorithm
        constexpr uint32_t HAPROT = (6 << 16);  ///< Region Hash Area Protection
        constexpr uint32_t DAPROT = (6 << 24);  ///< Region Descriptor Area Protection
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< ICM Enable
        constexpr uint32_t DISABLE = (1U << 1);  ///< ICM Disable Register
        constexpr uint32_t SWRST = (1U << 2);  ///< Software Reset
        constexpr uint32_t REHASH = (4 << 4);  ///< Recompute Internal Hash
        constexpr uint32_t RMDIS = (4 << 8);  ///< Region Monitoring Disable
        constexpr uint32_t RMEN = (4 << 12);  ///< Region Monitoring Enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< ICM Controller Enable Register
        constexpr uint32_t RAWRMDIS = (4 << 8);  ///< RAW Region Monitoring Disabled Status
        constexpr uint32_t RMDIS = (4 << 12);  ///< Region Monitoring Disabled Status
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t RHC = (4 << 0);  ///< Region Hash Completed Interrupt Enable
        constexpr uint32_t RDM = (4 << 4);  ///< Region Digest Mismatch Interrupt Enable
        constexpr uint32_t RBE = (4 << 8);  ///< Region Bus Error Interrupt Enable
        constexpr uint32_t RWC = (4 << 12);  ///< Region Wrap Condition detected Interrupt Enable
        constexpr uint32_t REC = (4 << 16);  ///< Region End bit Condition Detected Interrupt Enable
        constexpr uint32_t RSU = (4 << 20);  ///< Region Status Updated Interrupt Disable
        constexpr uint32_t URAD = (1U << 24);  ///< Undefined Register Access Detection Interrupt Enable
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t RHC = (4 << 0);  ///< Region Hash Completed Interrupt Disable
        constexpr uint32_t RDM = (4 << 4);  ///< Region Digest Mismatch Interrupt Disable
        constexpr uint32_t RBE = (4 << 8);  ///< Region Bus Error Interrupt Disable
        constexpr uint32_t RWC = (4 << 12);  ///< Region Wrap Condition Detected Interrupt Disable
        constexpr uint32_t REC = (4 << 16);  ///< Region End bit Condition detected Interrupt Disable
        constexpr uint32_t RSU = (4 << 20);  ///< Region Status Updated Interrupt Disable
        constexpr uint32_t URAD = (1U << 24);  ///< Undefined Register Access Detection Interrupt Disable
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t RHC = (4 << 0);  ///< Region Hash Completed Interrupt Mask
        constexpr uint32_t RDM = (4 << 4);  ///< Region Digest Mismatch Interrupt Mask
        constexpr uint32_t RBE = (4 << 8);  ///< Region Bus Error Interrupt Mask
        constexpr uint32_t RWC = (4 << 12);  ///< Region Wrap Condition Detected Interrupt Mask
        constexpr uint32_t REC = (4 << 16);  ///< Region End bit Condition Detected Interrupt Mask
        constexpr uint32_t RSU = (4 << 20);  ///< Region Status Updated Interrupt Mask
        constexpr uint32_t URAD = (1U << 24);  ///< Undefined Register Access Detection Interrupt Mask
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t RHC = (4 << 0);  ///< Region Hash Completed
        constexpr uint32_t RDM = (4 << 4);  ///< Region Digest Mismatch
        constexpr uint32_t RBE = (4 << 8);  ///< Region Bus Error
        constexpr uint32_t RWC = (4 << 12);  ///< Region Wrap Condition Detected
        constexpr uint32_t REC = (4 << 16);  ///< Region End bit Condition Detected
        constexpr uint32_t RSU = (4 << 20);  ///< Region Status Updated Detected
        constexpr uint32_t URAD = (1U << 24);  ///< Undefined Register Access Detection Status
    }

    /// UASR Register bits
    namespace uasr_bits {
        constexpr uint32_t URAT = (3 << 0);  ///< Undefined Register Access Trace
    }

    /// DSCR Register bits
    namespace dscr_bits {
        constexpr uint32_t DASA = (26 << 6);  ///< Descriptor Area Start Address
    }

    /// HASH Register bits
    namespace hash_bits {
        constexpr uint32_t HASA = (25 << 7);  ///< Hash Area Start Address
    }

    /// UIHVAL__ Register bits
    namespace uihval___bits {
        constexpr uint32_t VAL = (32 << 0);  ///< Initial Hash Value
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S_BASE = 0x43002800;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CLKCTRL__;  ///< Offset: 0x04 - Clock Unit n Control (renamed from CLKCTRL__)
        volatile uint32_t INTENCLR;  ///< Offset: 0x0C - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x10 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x14 - Interrupt Flag Status and Clear
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x18 - Synchronization Status
        volatile uint32_t TXCTRL;  ///< Offset: 0x20 - Tx Serializer Control
        volatile uint32_t RXCTRL;  ///< Offset: 0x24 - Rx Serializer Control
        volatile uint32_t TXDATA;  ///< Offset: 0x30 - Tx Data
        volatile uint32_t RXDATA;  ///< Offset: 0x34 - Rx Data
    };

    /// Peripheral instances
    inline Registers* I2S = reinterpret_cast<Registers*>(I2S_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t CKEN0 = (1U << 2);  ///< Clock Unit 0 Enable
        constexpr uint32_t CKEN1 = (1U << 3);  ///< Clock Unit 1 Enable
        constexpr uint32_t TXEN = (1U << 4);  ///< Tx Serializer Enable
        constexpr uint32_t RXEN = (1U << 5);  ///< Rx Serializer Enable
    }

    /// CLKCTRL__ Register bits
    namespace clkctrl___bits {
        constexpr uint32_t SLOTSIZE = (2 << 0);  ///< Slot Size
        constexpr uint32_t NBSLOTS = (3 << 2);  ///< Number of Slots in Frame
        constexpr uint32_t FSWIDTH = (2 << 5);  ///< Frame Sync Width
        constexpr uint32_t BITDELAY = (1U << 7);  ///< Data Delay from Frame Sync
        constexpr uint32_t FSSEL = (1U << 8);  ///< Frame Sync Select
        constexpr uint32_t FSINV = (1U << 9);  ///< Frame Sync Invert
        constexpr uint32_t FSOUTINV = (1U << 10);  ///< Frame Sync Output Invert
        constexpr uint32_t SCKSEL = (1U << 11);  ///< Serial Clock Select
        constexpr uint32_t SCKOUTINV = (1U << 12);  ///< Serial Clock Output Invert
        constexpr uint32_t MCKSEL = (1U << 13);  ///< Master Clock Select
        constexpr uint32_t MCKEN = (1U << 14);  ///< Master Clock Enable
        constexpr uint32_t MCKOUTINV = (1U << 15);  ///< Master Clock Output Invert
        constexpr uint32_t MCKDIV = (6 << 16);  ///< Master Clock Division Factor
        constexpr uint32_t MCKOUTDIV = (6 << 24);  ///< Master Clock Output Division Factor
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t RXRDY0 = (1U << 0);  ///< Receive Ready 0 Interrupt Enable
        constexpr uint32_t RXRDY1 = (1U << 1);  ///< Receive Ready 1 Interrupt Enable
        constexpr uint32_t RXOR0 = (1U << 4);  ///< Receive Overrun 0 Interrupt Enable
        constexpr uint32_t RXOR1 = (1U << 5);  ///< Receive Overrun 1 Interrupt Enable
        constexpr uint32_t TXRDY0 = (1U << 8);  ///< Transmit Ready 0 Interrupt Enable
        constexpr uint32_t TXRDY1 = (1U << 9);  ///< Transmit Ready 1 Interrupt Enable
        constexpr uint32_t TXUR0 = (1U << 12);  ///< Transmit Underrun 0 Interrupt Enable
        constexpr uint32_t TXUR1 = (1U << 13);  ///< Transmit Underrun 1 Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t RXRDY0 = (1U << 0);  ///< Receive Ready 0 Interrupt Enable
        constexpr uint32_t RXRDY1 = (1U << 1);  ///< Receive Ready 1 Interrupt Enable
        constexpr uint32_t RXOR0 = (1U << 4);  ///< Receive Overrun 0 Interrupt Enable
        constexpr uint32_t RXOR1 = (1U << 5);  ///< Receive Overrun 1 Interrupt Enable
        constexpr uint32_t TXRDY0 = (1U << 8);  ///< Transmit Ready 0 Interrupt Enable
        constexpr uint32_t TXRDY1 = (1U << 9);  ///< Transmit Ready 1 Interrupt Enable
        constexpr uint32_t TXUR0 = (1U << 12);  ///< Transmit Underrun 0 Interrupt Enable
        constexpr uint32_t TXUR1 = (1U << 13);  ///< Transmit Underrun 1 Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t RXRDY0 = (1U << 0);  ///< Receive Ready 0
        constexpr uint32_t RXRDY1 = (1U << 1);  ///< Receive Ready 1
        constexpr uint32_t RXOR0 = (1U << 4);  ///< Receive Overrun 0
        constexpr uint32_t RXOR1 = (1U << 5);  ///< Receive Overrun 1
        constexpr uint32_t TXRDY0 = (1U << 8);  ///< Transmit Ready 0
        constexpr uint32_t TXRDY1 = (1U << 9);  ///< Transmit Ready 1
        constexpr uint32_t TXUR0 = (1U << 12);  ///< Transmit Underrun 0
        constexpr uint32_t TXUR1 = (1U << 13);  ///< Transmit Underrun 1
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchronization Status
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable Synchronization Status
        constexpr uint32_t CKEN0 = (1U << 2);  ///< Clock Unit 0 Enable Synchronization Status
        constexpr uint32_t CKEN1 = (1U << 3);  ///< Clock Unit 1 Enable Synchronization Status
        constexpr uint32_t TXEN = (1U << 4);  ///< Tx Serializer Enable Synchronization Status
        constexpr uint32_t RXEN = (1U << 5);  ///< Rx Serializer Enable Synchronization Status
        constexpr uint32_t TXDATA = (1U << 8);  ///< Tx Data Synchronization Status
        constexpr uint32_t RXDATA = (1U << 9);  ///< Rx Data Synchronization Status
    }

    /// TXCTRL Register bits
    namespace txctrl_bits {
        constexpr uint32_t SERMODE = (2 << 0);  ///< Serializer Mode
        constexpr uint32_t TXDEFAULT = (2 << 2);  ///< Line Default Line when Slot Disabled
        constexpr uint32_t TXSAME = (1U << 4);  ///< Transmit Data when Underrun
        constexpr uint32_t CLKSEL = (1U << 5);  ///< Clock Unit Selection
        constexpr uint32_t SLOTADJ = (1U << 7);  ///< Data Slot Formatting Adjust
        constexpr uint32_t DATASIZE = (3 << 8);  ///< Data Word Size
        constexpr uint32_t WORDADJ = (1U << 12);  ///< Data Word Formatting Adjust
        constexpr uint32_t EXTEND = (2 << 13);  ///< Data Formatting Bit Extension
        constexpr uint32_t BITREV = (1U << 15);  ///< Data Formatting Bit Reverse
        constexpr uint32_t SLOTDIS0 = (1U << 16);  ///< Slot 0 Disabled for this Serializer
        constexpr uint32_t SLOTDIS1 = (1U << 17);  ///< Slot 1 Disabled for this Serializer
        constexpr uint32_t SLOTDIS2 = (1U << 18);  ///< Slot 2 Disabled for this Serializer
        constexpr uint32_t SLOTDIS3 = (1U << 19);  ///< Slot 3 Disabled for this Serializer
        constexpr uint32_t SLOTDIS4 = (1U << 20);  ///< Slot 4 Disabled for this Serializer
        constexpr uint32_t SLOTDIS5 = (1U << 21);  ///< Slot 5 Disabled for this Serializer
        constexpr uint32_t SLOTDIS6 = (1U << 22);  ///< Slot 6 Disabled for this Serializer
        constexpr uint32_t SLOTDIS7 = (1U << 23);  ///< Slot 7 Disabled for this Serializer
        constexpr uint32_t MONO = (1U << 24);  ///< Mono Mode
        constexpr uint32_t DMA = (1U << 25);  ///< Single or Multiple DMA Channels
    }

    /// RXCTRL Register bits
    namespace rxctrl_bits {
        constexpr uint32_t SERMODE = (2 << 0);  ///< Serializer Mode
        constexpr uint32_t CLKSEL = (1U << 5);  ///< Clock Unit Selection
        constexpr uint32_t SLOTADJ = (1U << 7);  ///< Data Slot Formatting Adjust
        constexpr uint32_t DATASIZE = (3 << 8);  ///< Data Word Size
        constexpr uint32_t WORDADJ = (1U << 12);  ///< Data Word Formatting Adjust
        constexpr uint32_t EXTEND = (2 << 13);  ///< Data Formatting Bit Extension
        constexpr uint32_t BITREV = (1U << 15);  ///< Data Formatting Bit Reverse
        constexpr uint32_t SLOTDIS0 = (1U << 16);  ///< Slot 0 Disabled for this Serializer
        constexpr uint32_t SLOTDIS1 = (1U << 17);  ///< Slot 1 Disabled for this Serializer
        constexpr uint32_t SLOTDIS2 = (1U << 18);  ///< Slot 2 Disabled for this Serializer
        constexpr uint32_t SLOTDIS3 = (1U << 19);  ///< Slot 3 Disabled for this Serializer
        constexpr uint32_t SLOTDIS4 = (1U << 20);  ///< Slot 4 Disabled for this Serializer
        constexpr uint32_t SLOTDIS5 = (1U << 21);  ///< Slot 5 Disabled for this Serializer
        constexpr uint32_t SLOTDIS6 = (1U << 22);  ///< Slot 6 Disabled for this Serializer
        constexpr uint32_t SLOTDIS7 = (1U << 23);  ///< Slot 7 Disabled for this Serializer
        constexpr uint32_t MONO = (1U << 24);  ///< Mono Mode
        constexpr uint32_t DMA = (1U << 25);  ///< Single or Multiple DMA Channels
        constexpr uint32_t RXLOOP = (1U << 26);  ///< Loop-back Test Mode
    }

    /// TXDATA Register bits
    namespace txdata_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Sample Data
    }

    /// RXDATA Register bits
    namespace rxdata_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Sample Data
    }

}

// ============================================================================
// MCLK Peripheral
// ============================================================================

namespace mclk {
    /// Base addresses
    constexpr uint32_t MCLK_BASE = 0x40000800;

    /// MCLK Register structure
    struct Registers {
        volatile uint32_t INTENCLR;  ///< Offset: 0x01 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x02 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x03 - Interrupt Flag Status and Clear
        volatile uint32_t HSDIV;  ///< Offset: 0x04 - HS Clock Division
        volatile uint32_t CPUDIV;  ///< Offset: 0x05 - CPU Clock Division
        volatile uint32_t AHBMASK;  ///< Offset: 0x10 - AHB Mask
        volatile uint32_t APBAMASK;  ///< Offset: 0x14 - APBA Mask
        volatile uint32_t APBBMASK;  ///< Offset: 0x18 - APBB Mask
        volatile uint32_t APBCMASK;  ///< Offset: 0x1C - APBC Mask
        volatile uint32_t APBDMASK;  ///< Offset: 0x20 - APBD Mask
    };

    /// Peripheral instances
    inline Registers* MCLK = reinterpret_cast<Registers*>(MCLK_BASE);

    // Bit definitions
    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t CKRDY = (1U << 0);  ///< Clock Ready Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t CKRDY = (1U << 0);  ///< Clock Ready Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t CKRDY = (1U << 0);  ///< Clock Ready
    }

    /// HSDIV Register bits
    namespace hsdiv_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< CPU Clock Division Factor
    }

    /// CPUDIV Register bits
    namespace cpudiv_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Low-Power Clock Division Factor
    }

    /// AHBMASK Register bits
    namespace ahbmask_bits {
        constexpr uint32_t HPB0_ = (1U << 0);  ///< HPB0 AHB Clock Mask
        constexpr uint32_t HPB1_ = (1U << 1);  ///< HPB1 AHB Clock Mask
        constexpr uint32_t HPB2_ = (1U << 2);  ///< HPB2 AHB Clock Mask
        constexpr uint32_t HPB3_ = (1U << 3);  ///< HPB3 AHB Clock Mask
        constexpr uint32_t DSU_ = (1U << 4);  ///< DSU AHB Clock Mask
        constexpr uint32_t HMATRIX_ = (1U << 5);  ///< HMATRIX AHB Clock Mask
        constexpr uint32_t NVMCTRL_ = (1U << 6);  ///< NVMCTRL AHB Clock Mask
        constexpr uint32_t HSRAM_ = (1U << 7);  ///< HSRAM AHB Clock Mask
        constexpr uint32_t CMCC_ = (1U << 8);  ///< CMCC AHB Clock Mask
        constexpr uint32_t DMAC_ = (1U << 9);  ///< DMAC AHB Clock Mask
        constexpr uint32_t USB_ = (1U << 10);  ///< USB AHB Clock Mask
        constexpr uint32_t BKUPRAM_ = (1U << 11);  ///< BKUPRAM AHB Clock Mask
        constexpr uint32_t PAC_ = (1U << 12);  ///< PAC AHB Clock Mask
        constexpr uint32_t QSPI_ = (1U << 13);  ///< QSPI AHB Clock Mask
        constexpr uint32_t GMAC_ = (1U << 14);  ///< GMAC AHB Clock Mask
        constexpr uint32_t SDHC0_ = (1U << 15);  ///< SDHC0 AHB Clock Mask
        constexpr uint32_t SDHC1_ = (1U << 16);  ///< SDHC1 AHB Clock Mask
        constexpr uint32_t ICM_ = (1U << 19);  ///< ICM AHB Clock Mask
        constexpr uint32_t PUKCC_ = (1U << 20);  ///< PUKCC AHB Clock Mask
        constexpr uint32_t QSPI_2X_ = (1U << 21);  ///< QSPI_2X AHB Clock Mask
        constexpr uint32_t NVMCTRL_SMEEPROM_ = (1U << 22);  ///< NVMCTRL_SMEEPROM AHB Clock Mask
        constexpr uint32_t NVMCTRL_CACHE_ = (1U << 23);  ///< NVMCTRL_CACHE AHB Clock Mask
    }

    /// APBAMASK Register bits
    namespace apbamask_bits {
        constexpr uint32_t PAC_ = (1U << 0);  ///< PAC APB Clock Enable
        constexpr uint32_t PM_ = (1U << 1);  ///< PM APB Clock Enable
        constexpr uint32_t MCLK_ = (1U << 2);  ///< MCLK APB Clock Enable
        constexpr uint32_t RSTC_ = (1U << 3);  ///< RSTC APB Clock Enable
        constexpr uint32_t OSCCTRL_ = (1U << 4);  ///< OSCCTRL APB Clock Enable
        constexpr uint32_t OSC32KCTRL_ = (1U << 5);  ///< OSC32KCTRL APB Clock Enable
        constexpr uint32_t SUPC_ = (1U << 6);  ///< SUPC APB Clock Enable
        constexpr uint32_t GCLK_ = (1U << 7);  ///< GCLK APB Clock Enable
        constexpr uint32_t WDT_ = (1U << 8);  ///< WDT APB Clock Enable
        constexpr uint32_t RTC_ = (1U << 9);  ///< RTC APB Clock Enable
        constexpr uint32_t EIC_ = (1U << 10);  ///< EIC APB Clock Enable
        constexpr uint32_t FREQM_ = (1U << 11);  ///< FREQM APB Clock Enable
        constexpr uint32_t SERCOM0_ = (1U << 12);  ///< SERCOM0 APB Clock Enable
        constexpr uint32_t SERCOM1_ = (1U << 13);  ///< SERCOM1 APB Clock Enable
        constexpr uint32_t TC0_ = (1U << 14);  ///< TC0 APB Clock Enable
        constexpr uint32_t TC1_ = (1U << 15);  ///< TC1 APB Clock Enable
    }

    /// APBBMASK Register bits
    namespace apbbmask_bits {
        constexpr uint32_t USB_ = (1U << 0);  ///< USB APB Clock Enable
        constexpr uint32_t DSU_ = (1U << 1);  ///< DSU APB Clock Enable
        constexpr uint32_t NVMCTRL_ = (1U << 2);  ///< NVMCTRL APB Clock Enable
        constexpr uint32_t PORT_ = (1U << 4);  ///< PORT APB Clock Enable
        constexpr uint32_t HMATRIX_ = (1U << 6);  ///< HMATRIX APB Clock Enable
        constexpr uint32_t EVSYS_ = (1U << 7);  ///< EVSYS APB Clock Enable
        constexpr uint32_t SERCOM2_ = (1U << 9);  ///< SERCOM2 APB Clock Enable
        constexpr uint32_t SERCOM3_ = (1U << 10);  ///< SERCOM3 APB Clock Enable
        constexpr uint32_t TCC0_ = (1U << 11);  ///< TCC0 APB Clock Enable
        constexpr uint32_t TCC1_ = (1U << 12);  ///< TCC1 APB Clock Enable
        constexpr uint32_t TC2_ = (1U << 13);  ///< TC2 APB Clock Enable
        constexpr uint32_t TC3_ = (1U << 14);  ///< TC3 APB Clock Enable
        constexpr uint32_t RAMECC_ = (1U << 16);  ///< RAMECC APB Clock Enable
    }

    /// APBCMASK Register bits
    namespace apbcmask_bits {
        constexpr uint32_t GMAC_ = (1U << 2);  ///< GMAC APB Clock Enable
        constexpr uint32_t TCC2_ = (1U << 3);  ///< TCC2 APB Clock Enable
        constexpr uint32_t TCC3_ = (1U << 4);  ///< TCC3 APB Clock Enable
        constexpr uint32_t TC4_ = (1U << 5);  ///< TC4 APB Clock Enable
        constexpr uint32_t TC5_ = (1U << 6);  ///< TC5 APB Clock Enable
        constexpr uint32_t PDEC_ = (1U << 7);  ///< PDEC APB Clock Enable
        constexpr uint32_t AC_ = (1U << 8);  ///< AC APB Clock Enable
        constexpr uint32_t AES_ = (1U << 9);  ///< AES APB Clock Enable
        constexpr uint32_t TRNG_ = (1U << 10);  ///< TRNG APB Clock Enable
        constexpr uint32_t ICM_ = (1U << 11);  ///< ICM APB Clock Enable
        constexpr uint32_t QSPI_ = (1U << 13);  ///< QSPI APB Clock Enable
        constexpr uint32_t CCL_ = (1U << 14);  ///< CCL APB Clock Enable
    }

    /// APBDMASK Register bits
    namespace apbdmask_bits {
        constexpr uint32_t SERCOM4_ = (1U << 0);  ///< SERCOM4 APB Clock Enable
        constexpr uint32_t SERCOM5_ = (1U << 1);  ///< SERCOM5 APB Clock Enable
        constexpr uint32_t SERCOM6_ = (1U << 2);  ///< SERCOM6 APB Clock Enable
        constexpr uint32_t SERCOM7_ = (1U << 3);  ///< SERCOM7 APB Clock Enable
        constexpr uint32_t TCC4_ = (1U << 4);  ///< TCC4 APB Clock Enable
        constexpr uint32_t TC6_ = (1U << 5);  ///< TC6 APB Clock Enable
        constexpr uint32_t TC7_ = (1U << 6);  ///< TC7 APB Clock Enable
        constexpr uint32_t ADC0_ = (1U << 7);  ///< ADC0 APB Clock Enable
        constexpr uint32_t ADC1_ = (1U << 8);  ///< ADC1 APB Clock Enable
        constexpr uint32_t DAC_ = (1U << 9);  ///< DAC APB Clock Enable
        constexpr uint32_t I2S_ = (1U << 10);  ///< I2S APB Clock Enable
        constexpr uint32_t PCC_ = (1U << 11);  ///< PCC APB Clock Enable
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t NVMCTRL_BASE = 0x41004000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x04 - Control B
        volatile uint32_t PARAM;  ///< Offset: 0x08 - NVM Parameter
        volatile uint32_t INTENCLR;  ///< Offset: 0x0C - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x0E - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x10 - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x12 - Status
        volatile uint32_t ADDR;  ///< Offset: 0x14 - Address
        volatile uint32_t RUNLOCK;  ///< Offset: 0x18 - Lock Section
        volatile uint32_t PBLDATA__;  ///< Offset: 0x1C - Page Buffer Load Data x (renamed from PBLDATA__)
        volatile uint32_t ECCERR;  ///< Offset: 0x24 - ECC Error Status Register
        volatile uint32_t DBGCTRL;  ///< Offset: 0x28 - Debug Control
        volatile uint32_t SEECFG;  ///< Offset: 0x2A - SmartEEPROM Configuration Register
        volatile uint32_t SEESTAT;  ///< Offset: 0x2C - SmartEEPROM Status Register
    };

    /// Peripheral instances
    inline Registers* NVMCTRL = reinterpret_cast<Registers*>(NVMCTRL_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t AUTOWS = (1U << 2);  ///< Auto Wait State Enable
        constexpr uint32_t SUSPEN = (1U << 3);  ///< Suspend Enable
        constexpr uint32_t WMODE = (2 << 4);  ///< Write Mode
        constexpr uint32_t PRM = (2 << 6);  ///< Power Reduction Mode during Sleep
        constexpr uint32_t RWS = (4 << 8);  ///< NVM Read Wait States
        constexpr uint32_t AHBNS0 = (1U << 12);  ///< Force AHB0 access to NONSEQ, burst transfers are continuously rearbitrated
        constexpr uint32_t AHBNS1 = (1U << 13);  ///< Force AHB1 access to NONSEQ, burst transfers are continuously rearbitrated
        constexpr uint32_t CACHEDIS0 = (1U << 14);  ///< AHB0 Cache Disable
        constexpr uint32_t CACHEDIS1 = (1U << 15);  ///< AHB1 Cache Disable
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t CMD = (7 << 0);  ///< Command
        constexpr uint32_t CMDEX = (8 << 8);  ///< Command Execution
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t NVMP = (16 << 0);  ///< NVM Pages
        constexpr uint32_t PSZ = (3 << 16);  ///< Page Size
        constexpr uint32_t SEE = (1U << 31);  ///< SmartEEPROM Supported
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t DONE = (1U << 0);  ///< Command Done Interrupt Clear
        constexpr uint32_t ADDRE = (1U << 1);  ///< Address Error
        constexpr uint32_t PROGE = (1U << 2);  ///< Programming Error Interrupt Clear
        constexpr uint32_t LOCKE = (1U << 3);  ///< Lock Error Interrupt Clear
        constexpr uint32_t ECCSE = (1U << 4);  ///< ECC Single Error Interrupt Clear
        constexpr uint32_t ECCDE = (1U << 5);  ///< ECC Dual Error Interrupt Clear
        constexpr uint32_t NVME = (1U << 6);  ///< NVM Error Interrupt Clear
        constexpr uint32_t SUSP = (1U << 7);  ///< Suspended Write Or Erase Interrupt Clear
        constexpr uint32_t SEESFULL = (1U << 8);  ///< Active SEES Full Interrupt Clear
        constexpr uint32_t SEESOVF = (1U << 9);  ///< Active SEES Overflow Interrupt Clear
        constexpr uint32_t SEEWRC = (1U << 10);  ///< SEE Write Completed Interrupt Clear
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t DONE = (1U << 0);  ///< Command Done Interrupt Enable
        constexpr uint32_t ADDRE = (1U << 1);  ///< Address Error Interrupt Enable
        constexpr uint32_t PROGE = (1U << 2);  ///< Programming Error Interrupt Enable
        constexpr uint32_t LOCKE = (1U << 3);  ///< Lock Error Interrupt Enable
        constexpr uint32_t ECCSE = (1U << 4);  ///< ECC Single Error Interrupt Enable
        constexpr uint32_t ECCDE = (1U << 5);  ///< ECC Dual Error Interrupt Enable
        constexpr uint32_t NVME = (1U << 6);  ///< NVM Error Interrupt Enable
        constexpr uint32_t SUSP = (1U << 7);  ///< Suspended Write Or Erase Interrupt Enable
        constexpr uint32_t SEESFULL = (1U << 8);  ///< Active SEES Full Interrupt Enable
        constexpr uint32_t SEESOVF = (1U << 9);  ///< Active SEES Overflow Interrupt Enable
        constexpr uint32_t SEEWRC = (1U << 10);  ///< SEE Write Completed Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t DONE = (1U << 0);  ///< Command Done
        constexpr uint32_t ADDRE = (1U << 1);  ///< Address Error
        constexpr uint32_t PROGE = (1U << 2);  ///< Programming Error
        constexpr uint32_t LOCKE = (1U << 3);  ///< Lock Error
        constexpr uint32_t ECCSE = (1U << 4);  ///< ECC Single Error
        constexpr uint32_t ECCDE = (1U << 5);  ///< ECC Dual Error
        constexpr uint32_t NVME = (1U << 6);  ///< NVM Error
        constexpr uint32_t SUSP = (1U << 7);  ///< Suspended Write Or Erase Operation
        constexpr uint32_t SEESFULL = (1U << 8);  ///< Active SEES Full
        constexpr uint32_t SEESOVF = (1U << 9);  ///< Active SEES Overflow
        constexpr uint32_t SEEWRC = (1U << 10);  ///< SEE Write Completed
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Ready to accept a command
        constexpr uint32_t PRM = (1U << 1);  ///< Power Reduction Mode
        constexpr uint32_t LOAD = (1U << 2);  ///< NVM Page Buffer Active Loading
        constexpr uint32_t SUSP = (1U << 3);  ///< NVM Write Or Erase Operation Is Suspended
        constexpr uint32_t AFIRST = (1U << 4);  ///< BANKA First
        constexpr uint32_t BPDIS = (1U << 5);  ///< Boot Loader Protection Disable
        constexpr uint32_t BOOTPROT = (4 << 8);  ///< Boot Loader Protection Size
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (24 << 0);  ///< NVM Address
    }

    /// RUNLOCK Register bits
    namespace runlock_bits {
        constexpr uint32_t RUNLOCK = (32 << 0);  ///< Region Un-Lock Bits
    }

    /// PBLDATA__ Register bits
    namespace pbldata___bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Page Buffer Data
    }

    /// ECCERR Register bits
    namespace eccerr_bits {
        constexpr uint32_t ADDR = (24 << 0);  ///< Error Address
        constexpr uint32_t TYPEL = (2 << 28);  ///< Low Double-Word Error Type
        constexpr uint32_t TYPEH = (2 << 30);  ///< High Double-Word Error Type
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t ECCDIS = (1U << 0);  ///< Debugger ECC Read Disable
        constexpr uint32_t ECCELOG = (1U << 1);  ///< Debugger ECC Error Tracking Mode
    }

    /// SEECFG Register bits
    namespace seecfg_bits {
        constexpr uint32_t WMODE = (1U << 0);  ///< Write Mode
        constexpr uint32_t APRDIS = (1U << 1);  ///< Automatic Page Reallocation Disable
    }

    /// SEESTAT Register bits
    namespace seestat_bits {
        constexpr uint32_t ASEES = (1U << 0);  ///< Active SmartEEPROM Sector
        constexpr uint32_t LOAD = (1U << 1);  ///< Page Buffer Loaded
        constexpr uint32_t BUSY = (1U << 2);  ///< Busy
        constexpr uint32_t LOCK = (1U << 3);  ///< SmartEEPROM Write Access Is Locked
        constexpr uint32_t RLOCK = (1U << 4);  ///< SmartEEPROM Write Access To Register Address Space Is Locked
        constexpr uint32_t SBLK = (4 << 8);  ///< Blocks Number In a Sector
        constexpr uint32_t PSZ = (3 << 16);  ///< SmartEEPROM Page Size
    }

}

// ============================================================================
// OSCCTRL Peripheral
// ============================================================================

namespace oscctrl {
    /// Base addresses
    constexpr uint32_t OSCCTRL_BASE = 0x40001000;

    /// OSCCTRL Register structure
    struct Registers {
        volatile uint32_t EVCTRL;  ///< Offset: 0x00 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x04 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x08 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x0C - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x10 - Status
        volatile uint32_t XOSCCTRL__;  ///< Offset: 0x14 - External Multipurpose Crystal Oscillator Control (renamed from XOSCCTRL__)
        volatile uint32_t DFLLCTRLA;  ///< Offset: 0x1C - DFLL48M Control A
        volatile uint32_t DFLLCTRLB;  ///< Offset: 0x20 - DFLL48M Control B
        volatile uint32_t DFLLVAL;  ///< Offset: 0x24 - DFLL48M Value
        volatile uint32_t DFLLMUL;  ///< Offset: 0x28 - DFLL48M Multiplier
        volatile uint32_t DFLLSYNC;  ///< Offset: 0x2C - DFLL48M Synchronization
        volatile uint32_t DPLLCTRLA;  ///< Offset: 0x00 - DPLL Control A
        volatile uint32_t DPLLRATIO;  ///< Offset: 0x04 - DPLL Ratio Control
        volatile uint32_t DPLLCTRLB;  ///< Offset: 0x08 - DPLL Control B
        volatile uint32_t DPLLSYNCBUSY;  ///< Offset: 0x0C - DPLL Synchronization Busy
        volatile uint32_t DPLLSTATUS;  ///< Offset: 0x10 - DPLL Status
    };

    /// Peripheral instances
    inline Registers* OSCCTRL = reinterpret_cast<Registers*>(OSCCTRL_BASE);

    // Bit definitions
    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t CFDEO0 = (1U << 0);  ///< Clock 0 Failure Detector Event Output Enable
        constexpr uint32_t CFDEO1 = (1U << 1);  ///< Clock 1 Failure Detector Event Output Enable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t XOSCRDY0 = (1U << 0);  ///< XOSC 0 Ready Interrupt Enable
        constexpr uint32_t XOSCRDY1 = (1U << 1);  ///< XOSC 1 Ready Interrupt Enable
        constexpr uint32_t XOSCFAIL0 = (1U << 2);  ///< XOSC 0 Clock Failure Detector Interrupt Enable
        constexpr uint32_t XOSCFAIL1 = (1U << 3);  ///< XOSC 1 Clock Failure Detector Interrupt Enable
        constexpr uint32_t DFLLRDY = (1U << 8);  ///< DFLL Ready Interrupt Enable
        constexpr uint32_t DFLLOOB = (1U << 9);  ///< DFLL Out Of Bounds Interrupt Enable
        constexpr uint32_t DFLLLCKF = (1U << 10);  ///< DFLL Lock Fine Interrupt Enable
        constexpr uint32_t DFLLLCKC = (1U << 11);  ///< DFLL Lock Coarse Interrupt Enable
        constexpr uint32_t DFLLRCS = (1U << 12);  ///< DFLL Reference Clock Stopped Interrupt Enable
        constexpr uint32_t DPLL0LCKR = (1U << 16);  ///< DPLL0 Lock Rise Interrupt Enable
        constexpr uint32_t DPLL0LCKF = (1U << 17);  ///< DPLL0 Lock Fall Interrupt Enable
        constexpr uint32_t DPLL0LTO = (1U << 18);  ///< DPLL0 Lock Timeout Interrupt Enable
        constexpr uint32_t DPLL0LDRTO = (1U << 19);  ///< DPLL0 Loop Divider Ratio Update Complete Interrupt Enable
        constexpr uint32_t DPLL1LCKR = (1U << 24);  ///< DPLL1 Lock Rise Interrupt Enable
        constexpr uint32_t DPLL1LCKF = (1U << 25);  ///< DPLL1 Lock Fall Interrupt Enable
        constexpr uint32_t DPLL1LTO = (1U << 26);  ///< DPLL1 Lock Timeout Interrupt Enable
        constexpr uint32_t DPLL1LDRTO = (1U << 27);  ///< DPLL1 Loop Divider Ratio Update Complete Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t XOSCRDY0 = (1U << 0);  ///< XOSC 0 Ready Interrupt Enable
        constexpr uint32_t XOSCRDY1 = (1U << 1);  ///< XOSC 1 Ready Interrupt Enable
        constexpr uint32_t XOSCFAIL0 = (1U << 2);  ///< XOSC 0 Clock Failure Detector Interrupt Enable
        constexpr uint32_t XOSCFAIL1 = (1U << 3);  ///< XOSC 1 Clock Failure Detector Interrupt Enable
        constexpr uint32_t DFLLRDY = (1U << 8);  ///< DFLL Ready Interrupt Enable
        constexpr uint32_t DFLLOOB = (1U << 9);  ///< DFLL Out Of Bounds Interrupt Enable
        constexpr uint32_t DFLLLCKF = (1U << 10);  ///< DFLL Lock Fine Interrupt Enable
        constexpr uint32_t DFLLLCKC = (1U << 11);  ///< DFLL Lock Coarse Interrupt Enable
        constexpr uint32_t DFLLRCS = (1U << 12);  ///< DFLL Reference Clock Stopped Interrupt Enable
        constexpr uint32_t DPLL0LCKR = (1U << 16);  ///< DPLL0 Lock Rise Interrupt Enable
        constexpr uint32_t DPLL0LCKF = (1U << 17);  ///< DPLL0 Lock Fall Interrupt Enable
        constexpr uint32_t DPLL0LTO = (1U << 18);  ///< DPLL0 Lock Timeout Interrupt Enable
        constexpr uint32_t DPLL0LDRTO = (1U << 19);  ///< DPLL0 Loop Divider Ratio Update Complete Interrupt Enable
        constexpr uint32_t DPLL1LCKR = (1U << 24);  ///< DPLL1 Lock Rise Interrupt Enable
        constexpr uint32_t DPLL1LCKF = (1U << 25);  ///< DPLL1 Lock Fall Interrupt Enable
        constexpr uint32_t DPLL1LTO = (1U << 26);  ///< DPLL1 Lock Timeout Interrupt Enable
        constexpr uint32_t DPLL1LDRTO = (1U << 27);  ///< DPLL1 Loop Divider Ratio Update Complete Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t XOSCRDY0 = (1U << 0);  ///< XOSC 0 Ready
        constexpr uint32_t XOSCRDY1 = (1U << 1);  ///< XOSC 1 Ready
        constexpr uint32_t XOSCFAIL0 = (1U << 2);  ///< XOSC 0 Clock Failure Detector
        constexpr uint32_t XOSCFAIL1 = (1U << 3);  ///< XOSC 1 Clock Failure Detector
        constexpr uint32_t DFLLRDY = (1U << 8);  ///< DFLL Ready
        constexpr uint32_t DFLLOOB = (1U << 9);  ///< DFLL Out Of Bounds
        constexpr uint32_t DFLLLCKF = (1U << 10);  ///< DFLL Lock Fine
        constexpr uint32_t DFLLLCKC = (1U << 11);  ///< DFLL Lock Coarse
        constexpr uint32_t DFLLRCS = (1U << 12);  ///< DFLL Reference Clock Stopped
        constexpr uint32_t DPLL0LCKR = (1U << 16);  ///< DPLL0 Lock Rise
        constexpr uint32_t DPLL0LCKF = (1U << 17);  ///< DPLL0 Lock Fall
        constexpr uint32_t DPLL0LTO = (1U << 18);  ///< DPLL0 Lock Timeout
        constexpr uint32_t DPLL0LDRTO = (1U << 19);  ///< DPLL0 Loop Divider Ratio Update Complete
        constexpr uint32_t DPLL1LCKR = (1U << 24);  ///< DPLL1 Lock Rise
        constexpr uint32_t DPLL1LCKF = (1U << 25);  ///< DPLL1 Lock Fall
        constexpr uint32_t DPLL1LTO = (1U << 26);  ///< DPLL1 Lock Timeout
        constexpr uint32_t DPLL1LDRTO = (1U << 27);  ///< DPLL1 Loop Divider Ratio Update Complete
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t XOSCRDY0 = (1U << 0);  ///< XOSC 0 Ready
        constexpr uint32_t XOSCRDY1 = (1U << 1);  ///< XOSC 1 Ready
        constexpr uint32_t XOSCFAIL0 = (1U << 2);  ///< XOSC 0 Clock Failure Detector
        constexpr uint32_t XOSCFAIL1 = (1U << 3);  ///< XOSC 1 Clock Failure Detector
        constexpr uint32_t XOSCCKSW0 = (1U << 4);  ///< XOSC 0 Clock Switch
        constexpr uint32_t XOSCCKSW1 = (1U << 5);  ///< XOSC 1 Clock Switch
        constexpr uint32_t DFLLRDY = (1U << 8);  ///< DFLL Ready
        constexpr uint32_t DFLLOOB = (1U << 9);  ///< DFLL Out Of Bounds
        constexpr uint32_t DFLLLCKF = (1U << 10);  ///< DFLL Lock Fine
        constexpr uint32_t DFLLLCKC = (1U << 11);  ///< DFLL Lock Coarse
        constexpr uint32_t DFLLRCS = (1U << 12);  ///< DFLL Reference Clock Stopped
        constexpr uint32_t DPLL0LCKR = (1U << 16);  ///< DPLL0 Lock Rise
        constexpr uint32_t DPLL0LCKF = (1U << 17);  ///< DPLL0 Lock Fall
        constexpr uint32_t DPLL0TO = (1U << 18);  ///< DPLL0 Timeout
        constexpr uint32_t DPLL0LDRTO = (1U << 19);  ///< DPLL0 Loop Divider Ratio Update Complete
        constexpr uint32_t DPLL1LCKR = (1U << 24);  ///< DPLL1 Lock Rise
        constexpr uint32_t DPLL1LCKF = (1U << 25);  ///< DPLL1 Lock Fall
        constexpr uint32_t DPLL1TO = (1U << 26);  ///< DPLL1 Timeout
        constexpr uint32_t DPLL1LDRTO = (1U << 27);  ///< DPLL1 Loop Divider Ratio Update Complete
    }

    /// XOSCCTRL__ Register bits
    namespace xoscctrl___bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Oscillator Enable
        constexpr uint32_t XTALEN = (1U << 2);  ///< Crystal Oscillator Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
        constexpr uint32_t LOWBUFGAIN = (1U << 8);  ///< Low Buffer Gain Enable
        constexpr uint32_t IPTAT = (2 << 9);  ///< Oscillator Current Reference
        constexpr uint32_t IMULT = (4 << 11);  ///< Oscillator Current Multiplier
        constexpr uint32_t ENALC = (1U << 15);  ///< Automatic Loop Control Enable
        constexpr uint32_t CFDEN = (1U << 16);  ///< Clock Failure Detector Enable
        constexpr uint32_t SWBEN = (1U << 17);  ///< Xosc Clock Switch Enable
        constexpr uint32_t STARTUP = (4 << 20);  ///< Start-Up Time
        constexpr uint32_t CFDPRESC = (4 << 24);  ///< Clock Failure Detector Prescaler
    }

    /// DFLLCTRLA Register bits
    namespace dfllctrla_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< DFLL Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
    }

    /// DFLLCTRLB Register bits
    namespace dfllctrlb_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< Operating Mode Selection
        constexpr uint32_t STABLE = (1U << 1);  ///< Stable DFLL Frequency
        constexpr uint32_t LLAW = (1U << 2);  ///< Lose Lock After Wake
        constexpr uint32_t USBCRM = (1U << 3);  ///< USB Clock Recovery Mode
        constexpr uint32_t CCDIS = (1U << 4);  ///< Chill Cycle Disable
        constexpr uint32_t QLDIS = (1U << 5);  ///< Quick Lock Disable
        constexpr uint32_t BPLCKC = (1U << 6);  ///< Bypass Coarse Lock
        constexpr uint32_t WAITLOCK = (1U << 7);  ///< Wait Lock
    }

    /// DFLLVAL Register bits
    namespace dfllval_bits {
        constexpr uint32_t FINE = (8 << 0);  ///< Fine Value
        constexpr uint32_t COARSE = (6 << 10);  ///< Coarse Value
        constexpr uint32_t DIFF = (16 << 16);  ///< Multiplication Ratio Difference
    }

    /// DFLLMUL Register bits
    namespace dfllmul_bits {
        constexpr uint32_t MUL = (16 << 0);  ///< DFLL Multiply Factor
        constexpr uint32_t FSTEP = (8 << 16);  ///< Fine Maximum Step
        constexpr uint32_t CSTEP = (6 << 26);  ///< Coarse Maximum Step
    }

    /// DFLLSYNC Register bits
    namespace dfllsync_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< ENABLE Synchronization Busy
        constexpr uint32_t DFLLCTRLB = (1U << 2);  ///< DFLLCTRLB Synchronization Busy
        constexpr uint32_t DFLLVAL = (1U << 3);  ///< DFLLVAL Synchronization Busy
        constexpr uint32_t DFLLMUL = (1U << 4);  ///< DFLLMUL Synchronization Busy
    }

    /// DPLLCTRLA Register bits
    namespace dpllctrla_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< DPLL Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
    }

    /// DPLLRATIO Register bits
    namespace dpllratio_bits {
        constexpr uint32_t LDR = (13 << 0);  ///< Loop Divider Ratio
        constexpr uint32_t LDRFRAC = (5 << 16);  ///< Loop Divider Ratio Fractional Part
    }

    /// DPLLCTRLB Register bits
    namespace dpllctrlb_bits {
        constexpr uint32_t FILTER = (4 << 0);  ///< Proportional Integral Filter Selection
        constexpr uint32_t WUF = (1U << 4);  ///< Wake Up Fast
        constexpr uint32_t REFCLK = (3 << 5);  ///< Reference Clock Selection
        constexpr uint32_t LTIME = (3 << 8);  ///< Lock Time
        constexpr uint32_t LBYPASS = (1U << 11);  ///< Lock Bypass
        constexpr uint32_t DCOFILTER = (3 << 12);  ///< Sigma-Delta DCO Filter Selection
        constexpr uint32_t DCOEN = (1U << 15);  ///< DCO Filter Enable
        constexpr uint32_t DIV = (11 << 16);  ///< Clock Divider
    }

    /// DPLLSYNCBUSY Register bits
    namespace dpllsyncbusy_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< DPLL Enable Synchronization Status
        constexpr uint32_t DPLLRATIO = (1U << 2);  ///< DPLL Loop Divider Ratio Synchronization Status
    }

    /// DPLLSTATUS Register bits
    namespace dpllstatus_bits {
        constexpr uint32_t LOCK = (1U << 0);  ///< DPLL Lock Status
        constexpr uint32_t CLKRDY = (1U << 1);  ///< DPLL Clock Ready
    }

}

// ============================================================================
// OSC32KCTRL Peripheral
// ============================================================================

namespace osc32kctrl {
    /// Base addresses
    constexpr uint32_t OSC32KCTRL_BASE = 0x40001400;

    /// OSC32KCTRL Register structure
    struct Registers {
        volatile uint32_t INTENCLR;  ///< Offset: 0x00 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x04 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x08 - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x0C - Power and Clocks Status
        volatile uint32_t RTCCTRL;  ///< Offset: 0x10 - RTC Clock Selection
        volatile uint32_t XOSC32K;  ///< Offset: 0x14 - 32kHz External Crystal Oscillator (XOSC32K) Control
        volatile uint32_t CFDCTRL;  ///< Offset: 0x16 - Clock Failure Detector Control
        volatile uint32_t EVCTRL;  ///< Offset: 0x17 - Event Control
        volatile uint32_t OSCULP32K;  ///< Offset: 0x1C - 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control
    };

    /// Peripheral instances
    inline Registers* OSC32KCTRL = reinterpret_cast<Registers*>(OSC32KCTRL_BASE);

    // Bit definitions
    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t XOSC32KRDY = (1U << 0);  ///< XOSC32K Ready Interrupt Enable
        constexpr uint32_t XOSC32KFAIL = (1U << 2);  ///< XOSC32K Clock Failure Detector Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t XOSC32KRDY = (1U << 0);  ///< XOSC32K Ready Interrupt Enable
        constexpr uint32_t XOSC32KFAIL = (1U << 2);  ///< XOSC32K Clock Failure Detector Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t XOSC32KRDY = (1U << 0);  ///< XOSC32K Ready
        constexpr uint32_t XOSC32KFAIL = (1U << 2);  ///< XOSC32K Clock Failure Detector
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t XOSC32KRDY = (1U << 0);  ///< XOSC32K Ready
        constexpr uint32_t XOSC32KFAIL = (1U << 2);  ///< XOSC32K Clock Failure Detector
        constexpr uint32_t XOSC32KSW = (1U << 3);  ///< XOSC32K Clock switch
    }

    /// RTCCTRL Register bits
    namespace rtcctrl_bits {
        constexpr uint32_t RTCSEL = (3 << 0);  ///< RTC Clock Selection
    }

    /// XOSC32K Register bits
    namespace xosc32k_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Oscillator Enable
        constexpr uint32_t XTALEN = (1U << 2);  ///< Crystal Oscillator Enable
        constexpr uint32_t EN32K = (1U << 3);  ///< 32kHz Output Enable
        constexpr uint32_t EN1K = (1U << 4);  ///< 1kHz Output Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
        constexpr uint32_t STARTUP = (3 << 8);  ///< Oscillator Start-Up Time
        constexpr uint32_t WRTLOCK = (1U << 12);  ///< Write Lock
        constexpr uint32_t CGM = (2 << 13);  ///< Control Gain Mode
    }

    /// CFDCTRL Register bits
    namespace cfdctrl_bits {
        constexpr uint32_t CFDEN = (1U << 0);  ///< Clock Failure Detector Enable
        constexpr uint32_t SWBACK = (1U << 1);  ///< Clock Switch Back
        constexpr uint32_t CFDPRESC = (1U << 2);  ///< Clock Failure Detector Prescaler
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t CFDEO = (1U << 0);  ///< Clock Failure Detector Event Output Enable
    }

    /// OSCULP32K Register bits
    namespace osculp32k_bits {
        constexpr uint32_t EN32K = (1U << 1);  ///< Enable Out 32k
        constexpr uint32_t EN1K = (1U << 2);  ///< Enable Out 1k
        constexpr uint32_t CALIB = (6 << 8);  ///< Oscillator Calibration
        constexpr uint32_t WRTLOCK = (1U << 15);  ///< Write Lock
    }

}

// ============================================================================
// PAC Peripheral
// ============================================================================

namespace pac {
    /// Base addresses
    constexpr uint32_t PAC_BASE = 0x40000000;

    /// PAC Register structure
    struct Registers {
        volatile uint32_t WRCTRL;  ///< Offset: 0x00 - Write control
        volatile uint32_t EVCTRL;  ///< Offset: 0x04 - Event control
        volatile uint32_t INTENCLR;  ///< Offset: 0x08 - Interrupt enable clear
        volatile uint32_t INTENSET;  ///< Offset: 0x09 - Interrupt enable set
        volatile uint32_t INTFLAGAHB;  ///< Offset: 0x10 - Bridge interrupt flag status
        volatile uint32_t INTFLAGA;  ///< Offset: 0x14 - Peripheral interrupt flag status - Bridge A
        volatile uint32_t INTFLAGB;  ///< Offset: 0x18 - Peripheral interrupt flag status - Bridge B
        volatile uint32_t INTFLAGC;  ///< Offset: 0x1C - Peripheral interrupt flag status - Bridge C
        volatile uint32_t INTFLAGD;  ///< Offset: 0x20 - Peripheral interrupt flag status - Bridge D
        volatile uint32_t STATUSA;  ///< Offset: 0x34 - Peripheral write protection status - Bridge A
        volatile uint32_t STATUSB;  ///< Offset: 0x38 - Peripheral write protection status - Bridge B
        volatile uint32_t STATUSC;  ///< Offset: 0x3C - Peripheral write protection status - Bridge C
        volatile uint32_t STATUSD;  ///< Offset: 0x40 - Peripheral write protection status - Bridge D
    };

    /// Peripheral instances
    inline Registers* PAC = reinterpret_cast<Registers*>(PAC_BASE);

    // Bit definitions
    /// WRCTRL Register bits
    namespace wrctrl_bits {
        constexpr uint32_t PERID = (16 << 0);  ///< Peripheral identifier
        constexpr uint32_t KEY = (8 << 16);  ///< Peripheral access control key
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t ERREO = (1U << 0);  ///< Peripheral acess error event output
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t ERR = (1U << 0);  ///< Peripheral access error interrupt disable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t ERR = (1U << 0);  ///< Peripheral access error interrupt enable
    }

    /// INTFLAGAHB Register bits
    namespace intflagahb_bits {
        constexpr uint32_t FLASH_ = (1U << 0);  ///< FLASH
        constexpr uint32_t FLASH_ALT_ = (1U << 1);  ///< FLASH_ALT
        constexpr uint32_t SEEPROM_ = (1U << 2);  ///< SEEPROM
        constexpr uint32_t RAMCM4S_ = (1U << 3);  ///< RAMCM4S
        constexpr uint32_t RAMPPPDSU_ = (1U << 4);  ///< RAMPPPDSU
        constexpr uint32_t RAMDMAWR_ = (1U << 5);  ///< RAMDMAWR
        constexpr uint32_t RAMDMACICM_ = (1U << 6);  ///< RAMDMACICM
        constexpr uint32_t HPB0_ = (1U << 7);  ///< HPB0
        constexpr uint32_t HPB1_ = (1U << 8);  ///< HPB1
        constexpr uint32_t HPB2_ = (1U << 9);  ///< HPB2
        constexpr uint32_t HPB3_ = (1U << 10);  ///< HPB3
        constexpr uint32_t PUKCC_ = (1U << 11);  ///< PUKCC
        constexpr uint32_t SDHC0_ = (1U << 12);  ///< SDHC0
        constexpr uint32_t SDHC1_ = (1U << 13);  ///< SDHC1
        constexpr uint32_t QSPI_ = (1U << 14);  ///< QSPI
        constexpr uint32_t BKUPRAM_ = (1U << 15);  ///< BKUPRAM
    }

    /// INTFLAGA Register bits
    namespace intflaga_bits {
        constexpr uint32_t PAC_ = (1U << 0);  ///< PAC
        constexpr uint32_t PM_ = (1U << 1);  ///< PM
        constexpr uint32_t MCLK_ = (1U << 2);  ///< MCLK
        constexpr uint32_t RSTC_ = (1U << 3);  ///< RSTC
        constexpr uint32_t OSCCTRL_ = (1U << 4);  ///< OSCCTRL
        constexpr uint32_t OSC32KCTRL_ = (1U << 5);  ///< OSC32KCTRL
        constexpr uint32_t SUPC_ = (1U << 6);  ///< SUPC
        constexpr uint32_t GCLK_ = (1U << 7);  ///< GCLK
        constexpr uint32_t WDT_ = (1U << 8);  ///< WDT
        constexpr uint32_t RTC_ = (1U << 9);  ///< RTC
        constexpr uint32_t EIC_ = (1U << 10);  ///< EIC
        constexpr uint32_t FREQM_ = (1U << 11);  ///< FREQM
        constexpr uint32_t SERCOM0_ = (1U << 12);  ///< SERCOM0
        constexpr uint32_t SERCOM1_ = (1U << 13);  ///< SERCOM1
        constexpr uint32_t TC0_ = (1U << 14);  ///< TC0
        constexpr uint32_t TC1_ = (1U << 15);  ///< TC1
    }

    /// INTFLAGB Register bits
    namespace intflagb_bits {
        constexpr uint32_t USB_ = (1U << 0);  ///< USB
        constexpr uint32_t DSU_ = (1U << 1);  ///< DSU
        constexpr uint32_t NVMCTRL_ = (1U << 2);  ///< NVMCTRL
        constexpr uint32_t CMCC_ = (1U << 3);  ///< CMCC
        constexpr uint32_t PORT_ = (1U << 4);  ///< PORT
        constexpr uint32_t DMAC_ = (1U << 5);  ///< DMAC
        constexpr uint32_t HMATRIX_ = (1U << 6);  ///< HMATRIX
        constexpr uint32_t EVSYS_ = (1U << 7);  ///< EVSYS
        constexpr uint32_t SERCOM2_ = (1U << 9);  ///< SERCOM2
        constexpr uint32_t SERCOM3_ = (1U << 10);  ///< SERCOM3
        constexpr uint32_t TCC0_ = (1U << 11);  ///< TCC0
        constexpr uint32_t TCC1_ = (1U << 12);  ///< TCC1
        constexpr uint32_t TC2_ = (1U << 13);  ///< TC2
        constexpr uint32_t TC3_ = (1U << 14);  ///< TC3
        constexpr uint32_t RAMECC_ = (1U << 16);  ///< RAMECC
    }

    /// INTFLAGC Register bits
    namespace intflagc_bits {
        constexpr uint32_t GMAC_ = (1U << 2);  ///< GMAC
        constexpr uint32_t TCC2_ = (1U << 3);  ///< TCC2
        constexpr uint32_t TCC3_ = (1U << 4);  ///< TCC3
        constexpr uint32_t TC4_ = (1U << 5);  ///< TC4
        constexpr uint32_t TC5_ = (1U << 6);  ///< TC5
        constexpr uint32_t PDEC_ = (1U << 7);  ///< PDEC
        constexpr uint32_t AC_ = (1U << 8);  ///< AC
        constexpr uint32_t AES_ = (1U << 9);  ///< AES
        constexpr uint32_t TRNG_ = (1U << 10);  ///< TRNG
        constexpr uint32_t ICM_ = (1U << 11);  ///< ICM
        constexpr uint32_t PUKCC_ = (1U << 12);  ///< PUKCC
        constexpr uint32_t QSPI_ = (1U << 13);  ///< QSPI
        constexpr uint32_t CCL_ = (1U << 14);  ///< CCL
    }

    /// INTFLAGD Register bits
    namespace intflagd_bits {
        constexpr uint32_t SERCOM4_ = (1U << 0);  ///< SERCOM4
        constexpr uint32_t SERCOM5_ = (1U << 1);  ///< SERCOM5
        constexpr uint32_t SERCOM6_ = (1U << 2);  ///< SERCOM6
        constexpr uint32_t SERCOM7_ = (1U << 3);  ///< SERCOM7
        constexpr uint32_t TCC4_ = (1U << 4);  ///< TCC4
        constexpr uint32_t TC6_ = (1U << 5);  ///< TC6
        constexpr uint32_t TC7_ = (1U << 6);  ///< TC7
        constexpr uint32_t ADC0_ = (1U << 7);  ///< ADC0
        constexpr uint32_t ADC1_ = (1U << 8);  ///< ADC1
        constexpr uint32_t DAC_ = (1U << 9);  ///< DAC
        constexpr uint32_t I2S_ = (1U << 10);  ///< I2S
        constexpr uint32_t PCC_ = (1U << 11);  ///< PCC
    }

    /// STATUSA Register bits
    namespace statusa_bits {
        constexpr uint32_t PAC_ = (1U << 0);  ///< PAC APB Protect Enable
        constexpr uint32_t PM_ = (1U << 1);  ///< PM APB Protect Enable
        constexpr uint32_t MCLK_ = (1U << 2);  ///< MCLK APB Protect Enable
        constexpr uint32_t RSTC_ = (1U << 3);  ///< RSTC APB Protect Enable
        constexpr uint32_t OSCCTRL_ = (1U << 4);  ///< OSCCTRL APB Protect Enable
        constexpr uint32_t OSC32KCTRL_ = (1U << 5);  ///< OSC32KCTRL APB Protect Enable
        constexpr uint32_t SUPC_ = (1U << 6);  ///< SUPC APB Protect Enable
        constexpr uint32_t GCLK_ = (1U << 7);  ///< GCLK APB Protect Enable
        constexpr uint32_t WDT_ = (1U << 8);  ///< WDT APB Protect Enable
        constexpr uint32_t RTC_ = (1U << 9);  ///< RTC APB Protect Enable
        constexpr uint32_t EIC_ = (1U << 10);  ///< EIC APB Protect Enable
        constexpr uint32_t FREQM_ = (1U << 11);  ///< FREQM APB Protect Enable
        constexpr uint32_t SERCOM0_ = (1U << 12);  ///< SERCOM0 APB Protect Enable
        constexpr uint32_t SERCOM1_ = (1U << 13);  ///< SERCOM1 APB Protect Enable
        constexpr uint32_t TC0_ = (1U << 14);  ///< TC0 APB Protect Enable
        constexpr uint32_t TC1_ = (1U << 15);  ///< TC1 APB Protect Enable
    }

    /// STATUSB Register bits
    namespace statusb_bits {
        constexpr uint32_t USB_ = (1U << 0);  ///< USB APB Protect Enable
        constexpr uint32_t DSU_ = (1U << 1);  ///< DSU APB Protect Enable
        constexpr uint32_t NVMCTRL_ = (1U << 2);  ///< NVMCTRL APB Protect Enable
        constexpr uint32_t CMCC_ = (1U << 3);  ///< CMCC APB Protect Enable
        constexpr uint32_t PORT_ = (1U << 4);  ///< PORT APB Protect Enable
        constexpr uint32_t DMAC_ = (1U << 5);  ///< DMAC APB Protect Enable
        constexpr uint32_t HMATRIX_ = (1U << 6);  ///< HMATRIX APB Protect Enable
        constexpr uint32_t EVSYS_ = (1U << 7);  ///< EVSYS APB Protect Enable
        constexpr uint32_t SERCOM2_ = (1U << 9);  ///< SERCOM2 APB Protect Enable
        constexpr uint32_t SERCOM3_ = (1U << 10);  ///< SERCOM3 APB Protect Enable
        constexpr uint32_t TCC0_ = (1U << 11);  ///< TCC0 APB Protect Enable
        constexpr uint32_t TCC1_ = (1U << 12);  ///< TCC1 APB Protect Enable
        constexpr uint32_t TC2_ = (1U << 13);  ///< TC2 APB Protect Enable
        constexpr uint32_t TC3_ = (1U << 14);  ///< TC3 APB Protect Enable
        constexpr uint32_t RAMECC_ = (1U << 16);  ///< RAMECC APB Protect Enable
    }

    /// STATUSC Register bits
    namespace statusc_bits {
        constexpr uint32_t GMAC_ = (1U << 2);  ///< GMAC APB Protect Enable
        constexpr uint32_t TCC2_ = (1U << 3);  ///< TCC2 APB Protect Enable
        constexpr uint32_t TCC3_ = (1U << 4);  ///< TCC3 APB Protect Enable
        constexpr uint32_t TC4_ = (1U << 5);  ///< TC4 APB Protect Enable
        constexpr uint32_t TC5_ = (1U << 6);  ///< TC5 APB Protect Enable
        constexpr uint32_t PDEC_ = (1U << 7);  ///< PDEC APB Protect Enable
        constexpr uint32_t AC_ = (1U << 8);  ///< AC APB Protect Enable
        constexpr uint32_t AES_ = (1U << 9);  ///< AES APB Protect Enable
        constexpr uint32_t TRNG_ = (1U << 10);  ///< TRNG APB Protect Enable
        constexpr uint32_t ICM_ = (1U << 11);  ///< ICM APB Protect Enable
        constexpr uint32_t PUKCC_ = (1U << 12);  ///< PUKCC APB Protect Enable
        constexpr uint32_t QSPI_ = (1U << 13);  ///< QSPI APB Protect Enable
        constexpr uint32_t CCL_ = (1U << 14);  ///< CCL APB Protect Enable
    }

    /// STATUSD Register bits
    namespace statusd_bits {
        constexpr uint32_t SERCOM4_ = (1U << 0);  ///< SERCOM4 APB Protect Enable
        constexpr uint32_t SERCOM5_ = (1U << 1);  ///< SERCOM5 APB Protect Enable
        constexpr uint32_t SERCOM6_ = (1U << 2);  ///< SERCOM6 APB Protect Enable
        constexpr uint32_t SERCOM7_ = (1U << 3);  ///< SERCOM7 APB Protect Enable
        constexpr uint32_t TCC4_ = (1U << 4);  ///< TCC4 APB Protect Enable
        constexpr uint32_t TC6_ = (1U << 5);  ///< TC6 APB Protect Enable
        constexpr uint32_t TC7_ = (1U << 6);  ///< TC7 APB Protect Enable
        constexpr uint32_t ADC0_ = (1U << 7);  ///< ADC0 APB Protect Enable
        constexpr uint32_t ADC1_ = (1U << 8);  ///< ADC1 APB Protect Enable
        constexpr uint32_t DAC_ = (1U << 9);  ///< DAC APB Protect Enable
        constexpr uint32_t I2S_ = (1U << 10);  ///< I2S APB Protect Enable
        constexpr uint32_t PCC_ = (1U << 11);  ///< PCC APB Protect Enable
    }

}

// ============================================================================
// PCC Peripheral
// ============================================================================

namespace pcc {
    /// Base addresses
    constexpr uint32_t PCC_BASE = 0x43002C00;

    /// PCC Register structure
    struct Registers {
        volatile uint32_t MR;  ///< Offset: 0x00 - Mode Register
        volatile uint32_t IER;  ///< Offset: 0x04 - Interrupt Enable Register
        volatile uint32_t IDR;  ///< Offset: 0x08 - Interrupt Disable Register
        volatile uint32_t IMR;  ///< Offset: 0x0C - Interrupt Mask Register
        volatile uint32_t ISR;  ///< Offset: 0x10 - Interrupt Status Register
        volatile uint32_t RHR;  ///< Offset: 0x14 - Reception Holding Register
        volatile uint32_t WPMR;  ///< Offset: 0xE0 - Write Protection Mode Register
        volatile uint32_t WPSR;  ///< Offset: 0xE4 - Write Protection Status Register
    };

    /// Peripheral instances
    inline Registers* PCC = reinterpret_cast<Registers*>(PCC_BASE);

    // Bit definitions
    /// MR Register bits
    namespace mr_bits {
        constexpr uint32_t PCEN = (1U << 0);  ///< Parallel Capture Enable
        constexpr uint32_t DSIZE = (2 << 4);  ///< Data size
        constexpr uint32_t SCALE = (1U << 8);  ///< Scale data
        constexpr uint32_t ALWYS = (1U << 9);  ///< Always Sampling
        constexpr uint32_t HALFS = (1U << 10);  ///< Half Sampling
        constexpr uint32_t FRSTS = (1U << 11);  ///< First sample
        constexpr uint32_t ISIZE = (3 << 16);  ///< Input Data Size
        constexpr uint32_t CID = (2 << 30);  ///< Clear If Disabled
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t DRDY = (1U << 0);  ///< Data Ready Interrupt Enable
        constexpr uint32_t OVRE = (1U << 1);  ///< Overrun Error Interrupt Enable
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t DRDY = (1U << 0);  ///< Data Ready Interrupt Disable
        constexpr uint32_t OVRE = (1U << 1);  ///< Overrun Error Interrupt Disable
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t DRDY = (1U << 0);  ///< Data Ready Interrupt Mask
        constexpr uint32_t OVRE = (1U << 1);  ///< Overrun Error Interrupt Mask
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t DRDY = (1U << 0);  ///< Data Ready Interrupt Status
        constexpr uint32_t OVRE = (1U << 1);  ///< Overrun Error Interrupt Status
    }

    /// RHR Register bits
    namespace rhr_bits {
        constexpr uint32_t RDATA = (32 << 0);  ///< Reception Data
    }

    /// WPMR Register bits
    namespace wpmr_bits {
        constexpr uint32_t WPEN = (1U << 0);  ///< Write Protection Enable
        constexpr uint32_t WPKEY = (24 << 8);  ///< Write Protection Key
    }

    /// WPSR Register bits
    namespace wpsr_bits {
        constexpr uint32_t WPVS = (1U << 0);  ///< Write Protection Violation Source
        constexpr uint32_t WPVSRC = (16 << 8);  ///< Write Protection Violation Status
    }

}

// ============================================================================
// PDEC Peripheral
// ============================================================================

namespace pdec {
    /// Base addresses
    constexpr uint32_t PDEC_BASE = 0x42001C00;

    /// PDEC Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLBCLR;  ///< Offset: 0x04 - Control B Clear
        volatile uint32_t CTRLBSET;  ///< Offset: 0x05 - Control B Set
        volatile uint32_t EVCTRL;  ///< Offset: 0x06 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x08 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x09 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x0A - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x0C - Status
        volatile uint32_t DBGCTRL;  ///< Offset: 0x0F - Debug Control
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x10 - Synchronization Status
        volatile uint32_t PRESC;  ///< Offset: 0x14 - Prescaler Value
        volatile uint32_t FILTER;  ///< Offset: 0x15 - Filter Value
        volatile uint32_t PRESCBUF;  ///< Offset: 0x18 - Prescaler Buffer Value
        volatile uint32_t FILTERBUF;  ///< Offset: 0x19 - Filter Buffer Value
        volatile uint32_t COUNT;  ///< Offset: 0x1C - Counter Value
        volatile uint32_t CC__;  ///< Offset: 0x20 - Channel n Compare Value (renamed from CC__)
        volatile uint32_t CCBUF__;  ///< Offset: 0x30 - Channel Compare Buffer Value (renamed from CCBUF__)
    };

    /// Peripheral instances
    inline Registers* PDEC = reinterpret_cast<Registers*>(PDEC_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t MODE = (2 << 2);  ///< Operation Mode
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t CONF = (3 << 8);  ///< PDEC Configuration
        constexpr uint32_t ALOCK = (1U << 11);  ///< Auto Lock
        constexpr uint32_t SWAP = (1U << 14);  ///< PDEC Phase A and B Swap
        constexpr uint32_t PEREN = (1U << 15);  ///< Period Enable
        constexpr uint32_t PINEN0 = (1U << 16);  ///< PDEC Input From Pin 0 Enable
        constexpr uint32_t PINEN1 = (1U << 17);  ///< PDEC Input From Pin 1 Enable
        constexpr uint32_t PINEN2 = (1U << 18);  ///< PDEC Input From Pin 2 Enable
        constexpr uint32_t PINVEN0 = (1U << 20);  ///< IO Pin 0 Invert Enable
        constexpr uint32_t PINVEN1 = (1U << 21);  ///< IO Pin 1 Invert Enable
        constexpr uint32_t PINVEN2 = (1U << 22);  ///< IO Pin 2 Invert Enable
        constexpr uint32_t ANGULAR = (3 << 24);  ///< Angular Counter Length
        constexpr uint32_t MAXCMP = (4 << 28);  ///< Maximum Consecutive Missing Pulses
    }

    /// CTRLBCLR Register bits
    namespace ctrlbclr_bits {
        constexpr uint32_t LUPD = (1U << 1);  ///< Lock Update
        constexpr uint32_t CMD = (3 << 5);  ///< Command
    }

    /// CTRLBSET Register bits
    namespace ctrlbset_bits {
        constexpr uint32_t LUPD = (1U << 1);  ///< Lock Update
        constexpr uint32_t CMD = (3 << 5);  ///< Command
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t EVACT = (2 << 0);  ///< Event Action
        constexpr uint32_t EVINV = (3 << 2);  ///< Inverted Event Input Enable
        constexpr uint32_t EVEI = (3 << 5);  ///< Event Input Enable
        constexpr uint32_t OVFEO = (1U << 8);  ///< Overflow/Underflow Output Event Enable
        constexpr uint32_t ERREO = (1U << 9);  ///< Error Output Event Enable
        constexpr uint32_t DIREO = (1U << 10);  ///< Direction Output Event Enable
        constexpr uint32_t VLCEO = (1U << 11);  ///< Velocity Output Event Enable
        constexpr uint32_t MCEO0 = (1U << 12);  ///< Match Channel 0 Event Output Enable
        constexpr uint32_t MCEO1 = (1U << 13);  ///< Match Channel 1 Event Output Enable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t OVF = (1U << 0);  ///< Overflow/Underflow Interrupt Disable
        constexpr uint32_t ERR = (1U << 1);  ///< Error Interrupt Disable
        constexpr uint32_t DIR = (1U << 2);  ///< Direction Interrupt Disable
        constexpr uint32_t VLC = (1U << 3);  ///< Velocity Interrupt Disable
        constexpr uint32_t MC0 = (1U << 4);  ///< Channel 0 Compare Match Disable
        constexpr uint32_t MC1 = (1U << 5);  ///< Channel 1 Compare Match Disable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t OVF = (1U << 0);  ///< Overflow/Underflow Interrupt Enable
        constexpr uint32_t ERR = (1U << 1);  ///< Error Interrupt Enable
        constexpr uint32_t DIR = (1U << 2);  ///< Direction Interrupt Enable
        constexpr uint32_t VLC = (1U << 3);  ///< Velocity Interrupt Enable
        constexpr uint32_t MC0 = (1U << 4);  ///< Channel 0 Compare Match Enable
        constexpr uint32_t MC1 = (1U << 5);  ///< Channel 1 Compare Match Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t OVF = (1U << 0);  ///< Overflow/Underflow
        constexpr uint32_t ERR = (1U << 1);  ///< Error
        constexpr uint32_t DIR = (1U << 2);  ///< Direction Change
        constexpr uint32_t VLC = (1U << 3);  ///< Velocity
        constexpr uint32_t MC0 = (1U << 4);  ///< Channel 0 Compare Match
        constexpr uint32_t MC1 = (1U << 5);  ///< Channel 1 Compare Match
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t QERR = (1U << 0);  ///< Quadrature Error Flag
        constexpr uint32_t IDXERR = (1U << 1);  ///< Index Error Flag
        constexpr uint32_t MPERR = (1U << 2);  ///< Missing Pulse Error flag
        constexpr uint32_t WINERR = (1U << 4);  ///< Window Error Flag
        constexpr uint32_t HERR = (1U << 5);  ///< Hall Error Flag
        constexpr uint32_t STOP = (1U << 6);  ///< Stop
        constexpr uint32_t DIR = (1U << 7);  ///< Direction Status Flag
        constexpr uint32_t PRESCBUFV = (1U << 8);  ///< Prescaler Buffer Valid
        constexpr uint32_t FILTERBUFV = (1U << 9);  ///< Filter Buffer Valid
        constexpr uint32_t CCBUFV0 = (1U << 12);  ///< Compare Channel 0 Buffer Valid
        constexpr uint32_t CCBUFV1 = (1U << 13);  ///< Compare Channel 1 Buffer Valid
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Debug Run Mode
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchronization Busy
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable Synchronization Busy
        constexpr uint32_t CTRLB = (1U << 2);  ///< Control B Synchronization Busy
        constexpr uint32_t STATUS = (1U << 3);  ///< Status Synchronization Busy
        constexpr uint32_t PRESC = (1U << 4);  ///< Prescaler Synchronization Busy
        constexpr uint32_t FILTER = (1U << 5);  ///< Filter Synchronization Busy
        constexpr uint32_t COUNT = (1U << 6);  ///< Count Synchronization Busy
        constexpr uint32_t CC0 = (1U << 7);  ///< Compare Channel 0 Synchronization Busy
        constexpr uint32_t CC1 = (1U << 8);  ///< Compare Channel 1 Synchronization Busy
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESC = (4 << 0);  ///< Prescaler Value
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t FILTER = (8 << 0);  ///< Filter Value
    }

    /// PRESCBUF Register bits
    namespace prescbuf_bits {
        constexpr uint32_t PRESCBUF = (4 << 0);  ///< Prescaler Buffer Value
    }

    /// FILTERBUF Register bits
    namespace filterbuf_bits {
        constexpr uint32_t FILTERBUF = (8 << 0);  ///< Filter Buffer Value
    }

    /// COUNT Register bits
    namespace count_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// CC__ Register bits
    namespace cc___bits {
        constexpr uint32_t CC = (16 << 0);  ///< Channel Compare Value
    }

    /// CCBUF__ Register bits
    namespace ccbuf___bits {
        constexpr uint32_t CCBUF = (16 << 0);  ///< Channel Compare Buffer Value
    }

}

// ============================================================================
// PM Peripheral
// ============================================================================

namespace pm {
    /// Base addresses
    constexpr uint32_t PM_BASE = 0x40000400;

    /// PM Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t SLEEPCFG;  ///< Offset: 0x01 - Sleep Configuration
        volatile uint32_t INTENCLR;  ///< Offset: 0x04 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x05 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x06 - Interrupt Flag Status and Clear
        volatile uint32_t STDBYCFG;  ///< Offset: 0x08 - Standby Configuration
        volatile uint32_t HIBCFG;  ///< Offset: 0x09 - Hibernate Configuration
        volatile uint32_t BKUPCFG;  ///< Offset: 0x0A - Backup Configuration
        volatile uint32_t PWSAKDLY;  ///< Offset: 0x12 - Power Switch Acknowledge Delay
    };

    /// Peripheral instances
    inline Registers* PM = reinterpret_cast<Registers*>(PM_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t IORET = (1U << 2);  ///< I/O Retention
    }

    /// SLEEPCFG Register bits
    namespace sleepcfg_bits {
        constexpr uint32_t SLEEPMODE = (3 << 0);  ///< Sleep Mode
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t SLEEPRDY = (1U << 0);  ///< Sleep Mode Entry Ready Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t SLEEPRDY = (1U << 0);  ///< Sleep Mode Entry Ready Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t SLEEPRDY = (1U << 0);  ///< Sleep Mode Entry Ready
    }

    /// STDBYCFG Register bits
    namespace stdbycfg_bits {
        constexpr uint32_t RAMCFG = (2 << 0);  ///< Ram Configuration
        constexpr uint32_t FASTWKUP = (2 << 4);  ///< Fast Wakeup
    }

    /// HIBCFG Register bits
    namespace hibcfg_bits {
        constexpr uint32_t RAMCFG = (2 << 0);  ///< Ram Configuration
        constexpr uint32_t BRAMCFG = (2 << 2);  ///< Backup Ram Configuration
    }

    /// BKUPCFG Register bits
    namespace bkupcfg_bits {
        constexpr uint32_t BRAMCFG = (2 << 0);  ///< Ram Configuration
    }

    /// PWSAKDLY Register bits
    namespace pwsakdly_bits {
        constexpr uint32_t DLYVAL = (7 << 0);  ///< Delay Value
        constexpr uint32_t IGNACK = (1U << 7);  ///< Ignore Acknowledge
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT_BASE = 0x41008000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t DIR;  ///< Offset: 0x00 - Data Direction
        volatile uint32_t DIRCLR;  ///< Offset: 0x04 - Data Direction Clear
        volatile uint32_t DIRSET;  ///< Offset: 0x08 - Data Direction Set
        volatile uint32_t DIRTGL;  ///< Offset: 0x0C - Data Direction Toggle
        volatile uint32_t OUT;  ///< Offset: 0x10 - Data Output Value
        volatile uint32_t OUTCLR;  ///< Offset: 0x14 - Data Output Value Clear
        volatile uint32_t OUTSET;  ///< Offset: 0x18 - Data Output Value Set
        volatile uint32_t OUTTGL;  ///< Offset: 0x1C - Data Output Value Toggle
        volatile uint32_t IN;  ///< Offset: 0x20 - Data Input Value
        volatile uint32_t CTRL;  ///< Offset: 0x24 - Control
        volatile uint32_t WRCONFIG;  ///< Offset: 0x28 - Write Configuration
        volatile uint32_t EVCTRL;  ///< Offset: 0x2C - Event Input Control
        volatile uint32_t PMUX__;  ///< Offset: 0x30 - Peripheral Multiplexing (renamed from PMUX__)
        volatile uint32_t PINCFG__;  ///< Offset: 0x40 - Pin Configuration (renamed from PINCFG__)
    };

    /// Peripheral instances
    inline Registers* PORT = reinterpret_cast<Registers*>(PORT_BASE);

    // Bit definitions
    /// DIR Register bits
    namespace dir_bits {
        constexpr uint32_t DIR = (32 << 0);  ///< Port Data Direction
    }

    /// DIRCLR Register bits
    namespace dirclr_bits {
        constexpr uint32_t DIRCLR = (32 << 0);  ///< Port Data Direction Clear
    }

    /// DIRSET Register bits
    namespace dirset_bits {
        constexpr uint32_t DIRSET = (32 << 0);  ///< Port Data Direction Set
    }

    /// DIRTGL Register bits
    namespace dirtgl_bits {
        constexpr uint32_t DIRTGL = (32 << 0);  ///< Port Data Direction Toggle
    }

    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t OUT = (32 << 0);  ///< PORT Data Output Value
    }

    /// OUTCLR Register bits
    namespace outclr_bits {
        constexpr uint32_t OUTCLR = (32 << 0);  ///< PORT Data Output Value Clear
    }

    /// OUTSET Register bits
    namespace outset_bits {
        constexpr uint32_t OUTSET = (32 << 0);  ///< PORT Data Output Value Set
    }

    /// OUTTGL Register bits
    namespace outtgl_bits {
        constexpr uint32_t OUTTGL = (32 << 0);  ///< PORT Data Output Value Toggle
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t IN = (32 << 0);  ///< PORT Data Input Value
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SAMPLING = (32 << 0);  ///< Input Sampling Mode
    }

    /// WRCONFIG Register bits
    namespace wrconfig_bits {
        constexpr uint32_t PINMASK = (16 << 0);  ///< Pin Mask for Multiple Pin Configuration
        constexpr uint32_t PMUXEN = (1U << 16);  ///< Peripheral Multiplexer Enable
        constexpr uint32_t INEN = (1U << 17);  ///< Input Enable
        constexpr uint32_t PULLEN = (1U << 18);  ///< Pull Enable
        constexpr uint32_t DRVSTR = (1U << 22);  ///< Output Driver Strength Selection
        constexpr uint32_t PMUX = (4 << 24);  ///< Peripheral Multiplexing
        constexpr uint32_t WRPMUX = (1U << 28);  ///< Write PMUX
        constexpr uint32_t WRPINCFG = (1U << 30);  ///< Write PINCFG
        constexpr uint32_t HWSEL = (1U << 31);  ///< Half-Word Select
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t PID0 = (5 << 0);  ///< PORT Event Pin Identifier 0
        constexpr uint32_t EVACT0 = (2 << 5);  ///< PORT Event Action 0
        constexpr uint32_t PORTEI0 = (1U << 7);  ///< PORT Event Input Enable 0
        constexpr uint32_t PID1 = (5 << 8);  ///< PORT Event Pin Identifier 1
        constexpr uint32_t EVACT1 = (2 << 13);  ///< PORT Event Action 1
        constexpr uint32_t PORTEI1 = (1U << 15);  ///< PORT Event Input Enable 1
        constexpr uint32_t PID2 = (5 << 16);  ///< PORT Event Pin Identifier 2
        constexpr uint32_t EVACT2 = (2 << 21);  ///< PORT Event Action 2
        constexpr uint32_t PORTEI2 = (1U << 23);  ///< PORT Event Input Enable 2
        constexpr uint32_t PID3 = (5 << 24);  ///< PORT Event Pin Identifier 3
        constexpr uint32_t EVACT3 = (2 << 29);  ///< PORT Event Action 3
        constexpr uint32_t PORTEI3 = (1U << 31);  ///< PORT Event Input Enable 3
    }

    /// PMUX__ Register bits
    namespace pmux___bits {
        constexpr uint32_t PMUXE = (4 << 0);  ///< Peripheral Multiplexing for Even-Numbered Pin
        constexpr uint32_t PMUXO = (4 << 4);  ///< Peripheral Multiplexing for Odd-Numbered Pin
    }

    /// PINCFG__ Register bits
    namespace pincfg___bits {
        constexpr uint32_t PMUXEN = (1U << 0);  ///< Peripheral Multiplexer Enable
        constexpr uint32_t INEN = (1U << 1);  ///< Input Enable
        constexpr uint32_t PULLEN = (1U << 2);  ///< Pull Enable
        constexpr uint32_t DRVSTR = (1U << 6);  ///< Output Driver Strength Selection
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t QSPI_BASE = 0x42003400;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x04 - Control B
        volatile uint32_t BAUD;  ///< Offset: 0x08 - Baud Rate
        volatile uint32_t RXDATA;  ///< Offset: 0x0C - Receive Data
        volatile uint32_t TXDATA;  ///< Offset: 0x10 - Transmit Data
        volatile uint32_t INTENCLR;  ///< Offset: 0x14 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x18 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x1C - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x20 - Status Register
        volatile uint32_t INSTRADDR;  ///< Offset: 0x30 - Instruction Address
        volatile uint32_t INSTRCTRL;  ///< Offset: 0x34 - Instruction Code
        volatile uint32_t INSTRFRAME;  ///< Offset: 0x38 - Instruction Frame
        volatile uint32_t SCRAMBCTRL;  ///< Offset: 0x40 - Scrambling Mode
        volatile uint32_t SCRAMBKEY;  ///< Offset: 0x44 - Scrambling Key
    };

    /// Peripheral instances
    inline Registers* QSPI = reinterpret_cast<Registers*>(QSPI_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t LASTXFER = (1U << 24);  ///< Last Transfer
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< Serial Memory Mode
        constexpr uint32_t LOOPEN = (1U << 1);  ///< Local Loopback Enable
        constexpr uint32_t WDRBT = (1U << 2);  ///< Wait Data Read Before Transfer
        constexpr uint32_t SMEMREG = (1U << 3);  ///< Serial Memory reg
        constexpr uint32_t CSMODE = (2 << 4);  ///< Chip Select Mode
        constexpr uint32_t DATALEN = (4 << 8);  ///< Data Length
        constexpr uint32_t DLYBCT = (8 << 16);  ///< Delay Between Consecutive Transfers
        constexpr uint32_t DLYCS = (8 << 24);  ///< Minimum Inactive CS Delay
    }

    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t CPOL = (1U << 0);  ///< Clock Polarity
        constexpr uint32_t CPHA = (1U << 1);  ///< Clock Phase
        constexpr uint32_t BAUD = (8 << 8);  ///< Serial Clock Baud Rate
        constexpr uint32_t DLYBS = (8 << 16);  ///< Delay Before SCK
    }

    /// RXDATA Register bits
    namespace rxdata_bits {
        constexpr uint32_t DATA = (16 << 0);  ///< Receive Data
    }

    /// TXDATA Register bits
    namespace txdata_bits {
        constexpr uint32_t DATA = (16 << 0);  ///< Transmit Data
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t RXC = (1U << 0);  ///< Receive Data Register Full Interrupt Disable
        constexpr uint32_t DRE = (1U << 1);  ///< Transmit Data Register Empty Interrupt Disable
        constexpr uint32_t TXC = (1U << 2);  ///< Transmission Complete Interrupt Disable
        constexpr uint32_t ERROR = (1U << 3);  ///< Overrun Error Interrupt Disable
        constexpr uint32_t CSRISE = (1U << 8);  ///< Chip Select Rise Interrupt Disable
        constexpr uint32_t INSTREND = (1U << 10);  ///< Instruction End Interrupt Disable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t RXC = (1U << 0);  ///< Receive Data Register Full Interrupt Enable
        constexpr uint32_t DRE = (1U << 1);  ///< Transmit Data Register Empty Interrupt Enable
        constexpr uint32_t TXC = (1U << 2);  ///< Transmission Complete Interrupt Enable
        constexpr uint32_t ERROR = (1U << 3);  ///< Overrun Error Interrupt Enable
        constexpr uint32_t CSRISE = (1U << 8);  ///< Chip Select Rise Interrupt Enable
        constexpr uint32_t INSTREND = (1U << 10);  ///< Instruction End Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t RXC = (1U << 0);  ///< Receive Data Register Full
        constexpr uint32_t DRE = (1U << 1);  ///< Transmit Data Register Empty
        constexpr uint32_t TXC = (1U << 2);  ///< Transmission Complete
        constexpr uint32_t ERROR = (1U << 3);  ///< Overrun Error
        constexpr uint32_t CSRISE = (1U << 8);  ///< Chip Select Rise
        constexpr uint32_t INSTREND = (1U << 10);  ///< Instruction End
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t CSSTATUS = (1U << 9);  ///< Chip Select
    }

    /// INSTRADDR Register bits
    namespace instraddr_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Instruction Address
    }

    /// INSTRCTRL Register bits
    namespace instrctrl_bits {
        constexpr uint32_t INSTR = (8 << 0);  ///< Instruction Code
        constexpr uint32_t OPTCODE = (8 << 16);  ///< Option Code
    }

    /// INSTRFRAME Register bits
    namespace instrframe_bits {
        constexpr uint32_t WIDTH = (3 << 0);  ///< Instruction Code, Address, Option Code and Data Width
        constexpr uint32_t INSTREN = (1U << 4);  ///< Instruction Enable
        constexpr uint32_t ADDREN = (1U << 5);  ///< Address Enable
        constexpr uint32_t OPTCODEEN = (1U << 6);  ///< Option Enable
        constexpr uint32_t DATAEN = (1U << 7);  ///< Data Enable
        constexpr uint32_t OPTCODELEN = (2 << 8);  ///< Option Code Length
        constexpr uint32_t ADDRLEN = (1U << 10);  ///< Address Length
        constexpr uint32_t TFRTYPE = (2 << 12);  ///< Data Transfer Type
        constexpr uint32_t CRMODE = (1U << 14);  ///< Continuous Read Mode
        constexpr uint32_t DDREN = (1U << 15);  ///< Double Data Rate Enable
        constexpr uint32_t DUMMYLEN = (5 << 16);  ///< Dummy Cycles Length
    }

    /// SCRAMBCTRL Register bits
    namespace scrambctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Scrambling/Unscrambling Enable
        constexpr uint32_t RANDOMDIS = (1U << 1);  ///< Scrambling/Unscrambling Random Value Disable
    }

    /// SCRAMBKEY Register bits
    namespace scrambkey_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Scrambling User Key
    }

}

// ============================================================================
// RAMECC Peripheral
// ============================================================================

namespace ramecc {
    /// Base addresses
    constexpr uint32_t RAMECC_BASE = 0x41020000;

    /// RAMECC Register structure
    struct Registers {
        volatile uint32_t INTENCLR;  ///< Offset: 0x00 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x01 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x02 - Interrupt Flag
        volatile uint32_t STATUS;  ///< Offset: 0x03 - Status
        volatile uint32_t ERRADDR;  ///< Offset: 0x04 - Error Address
        volatile uint32_t DBGCTRL;  ///< Offset: 0x0F - Debug Control
    };

    /// Peripheral instances
    inline Registers* RAMECC = reinterpret_cast<Registers*>(RAMECC_BASE);

    // Bit definitions
    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t SINGLEE = (1U << 0);  ///< Single Bit ECC Error Interrupt Enable Clear
        constexpr uint32_t DUALE = (1U << 1);  ///< Dual Bit ECC Error Interrupt Enable Clear
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t SINGLEE = (1U << 0);  ///< Single Bit ECC Error Interrupt Enable Set
        constexpr uint32_t DUALE = (1U << 1);  ///< Dual Bit ECC Error Interrupt Enable Set
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t SINGLEE = (1U << 0);  ///< Single Bit ECC Error Interrupt
        constexpr uint32_t DUALE = (1U << 1);  ///< Dual Bit ECC Error Interrupt
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t ECCDIS = (1U << 0);  ///< ECC Disable
    }

    /// ERRADDR Register bits
    namespace erraddr_bits {
        constexpr uint32_t ERRADDR = (17 << 0);  ///< Error Address
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t ECCDIS = (1U << 0);  ///< ECC Disable
        constexpr uint32_t ECCELOG = (1U << 1);  ///< ECC Error Log
    }

}

// ============================================================================
// RSTC Peripheral
// ============================================================================

namespace rstc {
    /// Base addresses
    constexpr uint32_t RSTC_BASE = 0x40000C00;

    /// RSTC Register structure
    struct Registers {
        volatile uint32_t RCAUSE;  ///< Offset: 0x00 - Reset Cause
        volatile uint32_t BKUPEXIT;  ///< Offset: 0x02 - Backup Exit Source
    };

    /// Peripheral instances
    inline Registers* RSTC = reinterpret_cast<Registers*>(RSTC_BASE);

    // Bit definitions
    /// RCAUSE Register bits
    namespace rcause_bits {
        constexpr uint32_t POR = (1U << 0);  ///< Power On Reset
        constexpr uint32_t BODCORE = (1U << 1);  ///< Brown Out CORE Detector Reset
        constexpr uint32_t BODVDD = (1U << 2);  ///< Brown Out VDD Detector Reset
        constexpr uint32_t NVM = (1U << 3);  ///< NVM Reset
        constexpr uint32_t EXT = (1U << 4);  ///< External Reset
        constexpr uint32_t WDT = (1U << 5);  ///< Watchdog Reset
        constexpr uint32_t SYST = (1U << 6);  ///< System Reset Request
        constexpr uint32_t BACKUP = (1U << 7);  ///< Backup Reset
    }

    /// BKUPEXIT Register bits
    namespace bkupexit_bits {
        constexpr uint32_t RTC = (1U << 1);  ///< Real Timer Counter Interrupt
        constexpr uint32_t BBPS = (1U << 2);  ///< Battery Backup Power Switch
        constexpr uint32_t HIB = (1U << 7);  ///< Hibernate
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002400;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - MODE2 Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x02 - MODE2 Control B
        volatile uint32_t EVCTRL;  ///< Offset: 0x04 - MODE2 Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x08 - MODE2 Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x0A - MODE2 Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x0C - MODE2 Interrupt Flag Status and Clear
        volatile uint32_t DBGCTRL;  ///< Offset: 0x0E - Debug Control
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x10 - MODE2 Synchronization Busy Status
        volatile uint32_t FREQCORR;  ///< Offset: 0x14 - Frequency Correction
        volatile uint32_t COUNT;  ///< Offset: 0x18 - MODE1 Counter Value
        volatile uint32_t COMP__;  ///< Offset: 0x20 - MODE1 Compare n Value (renamed from COMP__)
        volatile uint32_t GP__;  ///< Offset: 0x40 - General Purpose (renamed from GP__)
        volatile uint32_t TAMPCTRL;  ///< Offset: 0x60 - Tamper Control
        volatile uint32_t TIMESTAMP;  ///< Offset: 0x64 - MODE2 Timestamp
        volatile uint32_t TAMPID;  ///< Offset: 0x68 - Tamper ID
        volatile uint32_t BKUP__;  ///< Offset: 0x80 - Backup (renamed from BKUP__)
        volatile uint32_t PER;  ///< Offset: 0x1C - MODE1 Counter Period
        volatile uint32_t CLOCK;  ///< Offset: 0x18 - MODE2 Clock Value
        volatile uint32_t ALARM0;  ///< Offset: 0x20 - MODE2_ALARM Alarm n Value
        volatile uint32_t MASK0;  ///< Offset: 0x24 - MODE2_ALARM Alarm n Mask
        volatile uint32_t ALARM1;  ///< Offset: 0x28 - MODE2_ALARM Alarm n Value
        volatile uint32_t MASK1;  ///< Offset: 0x2C - MODE2_ALARM Alarm n Mask
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t MODE = (2 << 2);  ///< Operating Mode
        constexpr uint32_t CLKREP = (1U << 6);  ///< Clock Representation
        constexpr uint32_t MATCHCLR = (1U << 7);  ///< Clear on Match
        constexpr uint32_t PRESCALER = (4 << 8);  ///< Prescaler
        constexpr uint32_t BKTRST = (1U << 13);  ///< BKUP Registers Reset On Tamper Enable
        constexpr uint32_t GPTRST = (1U << 14);  ///< GP Registers Reset On Tamper Enable
        constexpr uint32_t CLOCKSYNC = (1U << 15);  ///< Clock Read Synchronization Enable
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t GP0EN = (1U << 0);  ///< General Purpose 0 Enable
        constexpr uint32_t GP2EN = (1U << 1);  ///< General Purpose 2 Enable
        constexpr uint32_t DEBMAJ = (1U << 4);  ///< Debouncer Majority Enable
        constexpr uint32_t DEBASYNC = (1U << 5);  ///< Debouncer Asynchronous Enable
        constexpr uint32_t RTCOUT = (1U << 6);  ///< RTC Output Enable
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA Enable
        constexpr uint32_t DEBF = (3 << 8);  ///< Debounce Freqnuency
        constexpr uint32_t ACTF = (3 << 12);  ///< Active Layer Freqnuency
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t PEREO0 = (1U << 0);  ///< Periodic Interval 0 Event Output Enable
        constexpr uint32_t PEREO1 = (1U << 1);  ///< Periodic Interval 1 Event Output Enable
        constexpr uint32_t PEREO2 = (1U << 2);  ///< Periodic Interval 2 Event Output Enable
        constexpr uint32_t PEREO3 = (1U << 3);  ///< Periodic Interval 3 Event Output Enable
        constexpr uint32_t PEREO4 = (1U << 4);  ///< Periodic Interval 4 Event Output Enable
        constexpr uint32_t PEREO5 = (1U << 5);  ///< Periodic Interval 5 Event Output Enable
        constexpr uint32_t PEREO6 = (1U << 6);  ///< Periodic Interval 6 Event Output Enable
        constexpr uint32_t PEREO7 = (1U << 7);  ///< Periodic Interval 7 Event Output Enable
        constexpr uint32_t ALARMEO0 = (1U << 8);  ///< Alarm 0 Event Output Enable
        constexpr uint32_t ALARMEO1 = (1U << 9);  ///< Alarm 1 Event Output Enable
        constexpr uint32_t TAMPEREO = (1U << 14);  ///< Tamper Event Output Enable
        constexpr uint32_t OVFEO = (1U << 15);  ///< Overflow Event Output Enable
        constexpr uint32_t TAMPEVEI = (1U << 16);  ///< Tamper Event Input Enable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t PER0 = (1U << 0);  ///< Periodic Interval 0 Interrupt Enable
        constexpr uint32_t PER1 = (1U << 1);  ///< Periodic Interval 1 Interrupt Enable
        constexpr uint32_t PER2 = (1U << 2);  ///< Periodic Interval 2 Interrupt Enable
        constexpr uint32_t PER3 = (1U << 3);  ///< Periodic Interval 3 Interrupt Enable
        constexpr uint32_t PER4 = (1U << 4);  ///< Periodic Interval 4 Interrupt Enable
        constexpr uint32_t PER5 = (1U << 5);  ///< Periodic Interval 5 Interrupt Enable
        constexpr uint32_t PER6 = (1U << 6);  ///< Periodic Interval 6 Interrupt Enable
        constexpr uint32_t PER7 = (1U << 7);  ///< Periodic Interval 7 Interrupt Enable
        constexpr uint32_t ALARM0 = (1U << 8);  ///< Alarm 0 Interrupt Enable
        constexpr uint32_t ALARM1 = (1U << 9);  ///< Alarm 1 Interrupt Enable
        constexpr uint32_t TAMPER = (1U << 14);  ///< Tamper Enable
        constexpr uint32_t OVF = (1U << 15);  ///< Overflow Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t PER0 = (1U << 0);  ///< Periodic Interval 0 Enable
        constexpr uint32_t PER1 = (1U << 1);  ///< Periodic Interval 1 Enable
        constexpr uint32_t PER2 = (1U << 2);  ///< Periodic Interval 2 Enable
        constexpr uint32_t PER3 = (1U << 3);  ///< Periodic Interval 3 Enable
        constexpr uint32_t PER4 = (1U << 4);  ///< Periodic Interval 4 Enable
        constexpr uint32_t PER5 = (1U << 5);  ///< Periodic Interval 5 Enable
        constexpr uint32_t PER6 = (1U << 6);  ///< Periodic Interval 6 Enable
        constexpr uint32_t PER7 = (1U << 7);  ///< Periodic Interval 7 Enable
        constexpr uint32_t ALARM0 = (1U << 8);  ///< Alarm 0 Interrupt Enable
        constexpr uint32_t ALARM1 = (1U << 9);  ///< Alarm 1 Interrupt Enable
        constexpr uint32_t TAMPER = (1U << 14);  ///< Tamper Enable
        constexpr uint32_t OVF = (1U << 15);  ///< Overflow Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t PER0 = (1U << 0);  ///< Periodic Interval 0
        constexpr uint32_t PER1 = (1U << 1);  ///< Periodic Interval 1
        constexpr uint32_t PER2 = (1U << 2);  ///< Periodic Interval 2
        constexpr uint32_t PER3 = (1U << 3);  ///< Periodic Interval 3
        constexpr uint32_t PER4 = (1U << 4);  ///< Periodic Interval 4
        constexpr uint32_t PER5 = (1U << 5);  ///< Periodic Interval 5
        constexpr uint32_t PER6 = (1U << 6);  ///< Periodic Interval 6
        constexpr uint32_t PER7 = (1U << 7);  ///< Periodic Interval 7
        constexpr uint32_t ALARM0 = (1U << 8);  ///< Alarm 0
        constexpr uint32_t ALARM1 = (1U << 9);  ///< Alarm 1
        constexpr uint32_t TAMPER = (1U << 14);  ///< Tamper
        constexpr uint32_t OVF = (1U << 15);  ///< Overflow
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Run During Debug
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Bit Busy
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable Bit Busy
        constexpr uint32_t FREQCORR = (1U << 2);  ///< FREQCORR Register Busy
        constexpr uint32_t CLOCK = (1U << 3);  ///< CLOCK Register Busy
        constexpr uint32_t ALARM0 = (1U << 5);  ///< ALARM 0 Register Busy
        constexpr uint32_t ALARM1 = (1U << 6);  ///< ALARM 1 Register Busy
        constexpr uint32_t MASK0 = (1U << 11);  ///< MASK 0 Register Busy
        constexpr uint32_t MASK1 = (1U << 12);  ///< MASK 1 Register Busy
        constexpr uint32_t CLOCKSYNC = (1U << 15);  ///< Clock Synchronization Enable Bit Busy
        constexpr uint32_t GP0 = (1U << 16);  ///< General Purpose 0 Register Busy
        constexpr uint32_t GP1 = (1U << 17);  ///< General Purpose 1 Register Busy
        constexpr uint32_t GP2 = (1U << 18);  ///< General Purpose 2 Register Busy
        constexpr uint32_t GP3 = (1U << 19);  ///< General Purpose 3 Register Busy
    }

    /// FREQCORR Register bits
    namespace freqcorr_bits {
        constexpr uint32_t VALUE = (7 << 0);  ///< Correction Value
        constexpr uint32_t SIGN = (1U << 7);  ///< Correction Sign
    }

    /// COUNT Register bits
    namespace count_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// COMP__ Register bits
    namespace comp___bits {
        constexpr uint32_t COMP = (16 << 0);  ///< Compare Value
    }

    /// GP__ Register bits
    namespace gp___bits {
        constexpr uint32_t GP = (32 << 0);  ///< General Purpose
    }

    /// TAMPCTRL Register bits
    namespace tampctrl_bits {
        constexpr uint32_t IN0ACT = (2 << 0);  ///< Tamper Input 0 Action
        constexpr uint32_t IN1ACT = (2 << 2);  ///< Tamper Input 1 Action
        constexpr uint32_t IN2ACT = (2 << 4);  ///< Tamper Input 2 Action
        constexpr uint32_t IN3ACT = (2 << 6);  ///< Tamper Input 3 Action
        constexpr uint32_t IN4ACT = (2 << 8);  ///< Tamper Input 4 Action
        constexpr uint32_t TAMLVL0 = (1U << 16);  ///< Tamper Level Select 0
        constexpr uint32_t TAMLVL1 = (1U << 17);  ///< Tamper Level Select 1
        constexpr uint32_t TAMLVL2 = (1U << 18);  ///< Tamper Level Select 2
        constexpr uint32_t TAMLVL3 = (1U << 19);  ///< Tamper Level Select 3
        constexpr uint32_t TAMLVL4 = (1U << 20);  ///< Tamper Level Select 4
        constexpr uint32_t DEBNC0 = (1U << 24);  ///< Debouncer Enable 0
        constexpr uint32_t DEBNC1 = (1U << 25);  ///< Debouncer Enable 1
        constexpr uint32_t DEBNC2 = (1U << 26);  ///< Debouncer Enable 2
        constexpr uint32_t DEBNC3 = (1U << 27);  ///< Debouncer Enable 3
        constexpr uint32_t DEBNC4 = (1U << 28);  ///< Debouncer Enable 4
    }

    /// TIMESTAMP Register bits
    namespace timestamp_bits {
        constexpr uint32_t SECOND = (6 << 0);  ///< Second Timestamp Value
        constexpr uint32_t MINUTE = (6 << 6);  ///< Minute Timestamp Value
        constexpr uint32_t HOUR = (5 << 12);  ///< Hour Timestamp Value
        constexpr uint32_t DAY = (5 << 17);  ///< Day Timestamp Value
        constexpr uint32_t MONTH = (4 << 22);  ///< Month Timestamp Value
        constexpr uint32_t YEAR = (6 << 26);  ///< Year Timestamp Value
    }

    /// TAMPID Register bits
    namespace tampid_bits {
        constexpr uint32_t TAMPID0 = (1U << 0);  ///< Tamper Input 0 Detected
        constexpr uint32_t TAMPID1 = (1U << 1);  ///< Tamper Input 1 Detected
        constexpr uint32_t TAMPID2 = (1U << 2);  ///< Tamper Input 2 Detected
        constexpr uint32_t TAMPID3 = (1U << 3);  ///< Tamper Input 3 Detected
        constexpr uint32_t TAMPID4 = (1U << 4);  ///< Tamper Input 4 Detected
        constexpr uint32_t TAMPEVT = (1U << 31);  ///< Tamper Event Detected
    }

    /// BKUP__ Register bits
    namespace bkup___bits {
        constexpr uint32_t BKUP = (32 << 0);  ///< Backup
    }

    /// PER Register bits
    namespace per_bits {
        constexpr uint32_t PER = (16 << 0);  ///< Counter Period
    }

    /// CLOCK Register bits
    namespace clock_bits {
        constexpr uint32_t SECOND = (6 << 0);  ///< Second
        constexpr uint32_t MINUTE = (6 << 6);  ///< Minute
        constexpr uint32_t HOUR = (5 << 12);  ///< Hour
        constexpr uint32_t DAY = (5 << 17);  ///< Day
        constexpr uint32_t MONTH = (4 << 22);  ///< Month
        constexpr uint32_t YEAR = (6 << 26);  ///< Year
    }

    /// ALARM0 Register bits
    namespace alarm0_bits {
        constexpr uint32_t SECOND = (6 << 0);  ///< Second
        constexpr uint32_t MINUTE = (6 << 6);  ///< Minute
        constexpr uint32_t HOUR = (5 << 12);  ///< Hour
        constexpr uint32_t DAY = (5 << 17);  ///< Day
        constexpr uint32_t MONTH = (4 << 22);  ///< Month
        constexpr uint32_t YEAR = (6 << 26);  ///< Year
    }

    /// MASK0 Register bits
    namespace mask0_bits {
        constexpr uint32_t SEL = (3 << 0);  ///< Alarm Mask Selection
    }

    /// ALARM1 Register bits
    namespace alarm1_bits {
        constexpr uint32_t SECOND = (6 << 0);  ///< Second
        constexpr uint32_t MINUTE = (6 << 6);  ///< Minute
        constexpr uint32_t HOUR = (5 << 12);  ///< Hour
        constexpr uint32_t DAY = (5 << 17);  ///< Day
        constexpr uint32_t MONTH = (4 << 22);  ///< Month
        constexpr uint32_t YEAR = (6 << 26);  ///< Year
    }

    /// MASK1 Register bits
    namespace mask1_bits {
        constexpr uint32_t SEL = (3 << 0);  ///< Alarm Mask Selection
    }

}

// ============================================================================
// SDHC0 Peripheral
// ============================================================================

namespace sdhc0 {
    /// Base addresses
    constexpr uint32_t SDHC0_BASE = 0x45000000;

    /// SDHC0 Register structure
    struct Registers {
        volatile uint32_t SSAR;  ///< Offset: 0x00 - SDMA System Address / Argument 2
        volatile uint32_t SSAR_CMD23_MODE;  ///< Offset: 0x00 - SDMA System Address / Argument 2
        volatile uint32_t BSR;  ///< Offset: 0x04 - Block Size
        volatile uint32_t BCR;  ///< Offset: 0x06 - Block Count
        volatile uint32_t ARG1R;  ///< Offset: 0x08 - Argument 1
        volatile uint32_t TMR;  ///< Offset: 0x0C - Transfer Mode
        volatile uint32_t CR;  ///< Offset: 0x0E - Command
        volatile uint32_t RR__;  ///< Offset: 0x10 - Response (renamed from RR__)
        volatile uint32_t BDPR;  ///< Offset: 0x20 - Buffer Data Port
        volatile uint32_t PSR;  ///< Offset: 0x24 - Present State
        volatile uint32_t HC1R;  ///< Offset: 0x28 - Host Control 1
        volatile uint32_t HC1R_EMMC_MODE;  ///< Offset: 0x28 - Host Control 1
        volatile uint32_t PCR;  ///< Offset: 0x29 - Power Control
        volatile uint32_t BGCR;  ///< Offset: 0x2A - Block Gap Control
        volatile uint32_t BGCR_EMMC_MODE;  ///< Offset: 0x2A - Block Gap Control
        volatile uint32_t WCR;  ///< Offset: 0x2B - Wakeup Control
        volatile uint32_t CCR;  ///< Offset: 0x2C - Clock Control
        volatile uint32_t TCR;  ///< Offset: 0x2E - Timeout Control
        volatile uint32_t SRR;  ///< Offset: 0x2F - Software Reset
        volatile uint32_t NISTR;  ///< Offset: 0x30 - Normal Interrupt Status
        volatile uint32_t NISTR_EMMC_MODE;  ///< Offset: 0x30 - Normal Interrupt Status
        volatile uint32_t EISTR;  ///< Offset: 0x32 - Error Interrupt Status
        volatile uint32_t EISTR_EMMC_MODE;  ///< Offset: 0x32 - Error Interrupt Status
        volatile uint32_t NISTER;  ///< Offset: 0x34 - Normal Interrupt Status Enable
        volatile uint32_t NISTER_EMMC_MODE;  ///< Offset: 0x34 - Normal Interrupt Status Enable
        volatile uint32_t EISTER;  ///< Offset: 0x36 - Error Interrupt Status Enable
        volatile uint32_t EISTER_EMMC_MODE;  ///< Offset: 0x36 - Error Interrupt Status Enable
        volatile uint32_t NISIER;  ///< Offset: 0x38 - Normal Interrupt Signal Enable
        volatile uint32_t NISIER_EMMC_MODE;  ///< Offset: 0x38 - Normal Interrupt Signal Enable
        volatile uint32_t EISIER;  ///< Offset: 0x3A - Error Interrupt Signal Enable
        volatile uint32_t EISIER_EMMC_MODE;  ///< Offset: 0x3A - Error Interrupt Signal Enable
        volatile uint32_t ACESR;  ///< Offset: 0x3C - Auto CMD Error Status
        volatile uint32_t HC2R;  ///< Offset: 0x3E - Host Control 2
        volatile uint32_t HC2R_EMMC_MODE;  ///< Offset: 0x3E - Host Control 2
        volatile uint32_t CA0R;  ///< Offset: 0x40 - Capabilities 0
        volatile uint32_t CA1R;  ///< Offset: 0x44 - Capabilities 1
        volatile uint32_t MCCAR;  ///< Offset: 0x48 - Maximum Current Capabilities
        volatile uint32_t FERACES;  ///< Offset: 0x50 - Force Event for Auto CMD Error Status
        volatile uint32_t FEREIS;  ///< Offset: 0x52 - Force Event for Error Interrupt Status
        volatile uint32_t AESR;  ///< Offset: 0x54 - ADMA Error Status
        volatile uint32_t ASAR__;  ///< Offset: 0x58 - ADMA System Address n (renamed from ASAR__)
        volatile uint32_t PVR__;  ///< Offset: 0x60 - Preset Value n (renamed from PVR__)
        volatile uint32_t SISR;  ///< Offset: 0xFC - Slot Interrupt Status
        volatile uint32_t HCVR;  ///< Offset: 0xFE - Host Controller Version
        volatile uint32_t MC1R;  ///< Offset: 0x204 - MMC Control 1
        volatile uint32_t MC2R;  ///< Offset: 0x205 - MMC Control 2
        volatile uint32_t ACR;  ///< Offset: 0x208 - AHB Control
        volatile uint32_t CC2R;  ///< Offset: 0x20C - Clock Control 2
        volatile uint32_t CACR;  ///< Offset: 0x230 - Capabilities Control
        volatile uint32_t DBGR;  ///< Offset: 0x234 - Debug
    };

    /// Peripheral instances
    inline Registers* SDHC0 = reinterpret_cast<Registers*>(SDHC0_BASE);

    // Bit definitions
    /// SSAR Register bits
    namespace ssar_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< SDMA System Address
    }

    /// SSAR_CMD23_MODE Register bits
    namespace ssar_cmd23_mode_bits {
        constexpr uint32_t ARG2 = (32 << 0);  ///< Argument 2
    }

    /// BSR Register bits
    namespace bsr_bits {
        constexpr uint32_t BLOCKSIZE = (10 << 0);  ///< Transfer Block Size
        constexpr uint32_t BOUNDARY = (3 << 12);  ///< SDMA Buffer Boundary
    }

    /// BCR Register bits
    namespace bcr_bits {
        constexpr uint32_t BCNT = (16 << 0);  ///< Blocks Count for Current Transfer
    }

    /// ARG1R Register bits
    namespace arg1r_bits {
        constexpr uint32_t ARG = (32 << 0);  ///< Argument 1
    }

    /// TMR Register bits
    namespace tmr_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t BCEN = (1U << 1);  ///< Block Count Enable
        constexpr uint32_t ACMDEN = (2 << 2);  ///< Auto Command Enable
        constexpr uint32_t DTDSEL = (1U << 4);  ///< Data Transfer Direction Selection
        constexpr uint32_t MSBSEL = (1U << 5);  ///< Multi/Single Block Selection
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RESPTYP = (2 << 0);  ///< Response Type
        constexpr uint32_t CMDCCEN = (1U << 3);  ///< Command CRC Check Enable
        constexpr uint32_t CMDICEN = (1U << 4);  ///< Command Index Check Enable
        constexpr uint32_t DPSEL = (1U << 5);  ///< Data Present Select
        constexpr uint32_t CMDTYP = (2 << 6);  ///< Command Type
        constexpr uint32_t CMDIDX = (6 << 8);  ///< Command Index
    }

    /// RR__ Register bits
    namespace rr___bits {
        constexpr uint32_t CMDRESP = (32 << 0);  ///< Command Response
    }

    /// BDPR Register bits
    namespace bdpr_bits {
        constexpr uint32_t BUFDATA = (32 << 0);  ///< Buffer Data
    }

    /// PSR Register bits
    namespace psr_bits {
        constexpr uint32_t CMDINHC = (1U << 0);  ///< Command Inhibit (CMD)
        constexpr uint32_t CMDINHD = (1U << 1);  ///< Command Inhibit (DAT)
        constexpr uint32_t DLACT = (1U << 2);  ///< DAT Line Active
        constexpr uint32_t RTREQ = (1U << 3);  ///< Re-Tuning Request
        constexpr uint32_t WTACT = (1U << 8);  ///< Write Transfer Active
        constexpr uint32_t RTACT = (1U << 9);  ///< Read Transfer Active
        constexpr uint32_t BUFWREN = (1U << 10);  ///< Buffer Write Enable
        constexpr uint32_t BUFRDEN = (1U << 11);  ///< Buffer Read Enable
        constexpr uint32_t CARDINS = (1U << 16);  ///< Card Inserted
        constexpr uint32_t CARDSS = (1U << 17);  ///< Card State Stable
        constexpr uint32_t CARDDPL = (1U << 18);  ///< Card Detect Pin Level
        constexpr uint32_t WRPPL = (1U << 19);  ///< Write Protect Pin Level
        constexpr uint32_t DATLL = (4 << 20);  ///< DAT[3:0] Line Level
        constexpr uint32_t CMDLL = (1U << 24);  ///< CMD Line Level
    }

    /// HC1R Register bits
    namespace hc1r_bits {
        constexpr uint32_t LEDCTRL = (1U << 0);  ///< LED Control
        constexpr uint32_t DW = (1U << 1);  ///< Data Width
        constexpr uint32_t HSEN = (1U << 2);  ///< High Speed Enable
        constexpr uint32_t DMASEL = (2 << 3);  ///< DMA Select
        constexpr uint32_t CARDDTL = (1U << 6);  ///< Card Detect Test Level
        constexpr uint32_t CARDDSEL = (1U << 7);  ///< Card Detect Signal Selection
    }

    /// HC1R_EMMC_MODE Register bits
    namespace hc1r_emmc_mode_bits {
        constexpr uint32_t DW = (1U << 1);  ///< Data Width
        constexpr uint32_t HSEN = (1U << 2);  ///< High Speed Enable
        constexpr uint32_t DMASEL = (2 << 3);  ///< DMA Select
    }

    /// PCR Register bits
    namespace pcr_bits {
        constexpr uint32_t SDBPWR = (1U << 0);  ///< SD Bus Power
        constexpr uint32_t SDBVSEL = (3 << 1);  ///< SD Bus Voltage Select
    }

    /// BGCR Register bits
    namespace bgcr_bits {
        constexpr uint32_t STPBGR = (1U << 0);  ///< Stop at Block Gap Request
        constexpr uint32_t CONTR = (1U << 1);  ///< Continue Request
        constexpr uint32_t RWCTRL = (1U << 2);  ///< Read Wait Control
        constexpr uint32_t INTBG = (1U << 3);  ///< Interrupt at Block Gap
    }

    /// BGCR_EMMC_MODE Register bits
    namespace bgcr_emmc_mode_bits {
        constexpr uint32_t STPBGR = (1U << 0);  ///< Stop at Block Gap Request
        constexpr uint32_t CONTR = (1U << 1);  ///< Continue Request
    }

    /// WCR Register bits
    namespace wcr_bits {
        constexpr uint32_t WKENCINT = (1U << 0);  ///< Wakeup Event Enable on Card Interrupt
        constexpr uint32_t WKENCINS = (1U << 1);  ///< Wakeup Event Enable on Card Insertion
        constexpr uint32_t WKENCREM = (1U << 2);  ///< Wakeup Event Enable on Card Removal
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t INTCLKEN = (1U << 0);  ///< Internal Clock Enable
        constexpr uint32_t INTCLKS = (1U << 1);  ///< Internal Clock Stable
        constexpr uint32_t SDCLKEN = (1U << 2);  ///< SD Clock Enable
        constexpr uint32_t CLKGSEL = (1U << 5);  ///< Clock Generator Select
        constexpr uint32_t USDCLKFSEL = (2 << 6);  ///< Upper Bits of SDCLK Frequency Select
        constexpr uint32_t SDCLKFSEL = (8 << 8);  ///< SDCLK Frequency Select
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t DTCVAL = (4 << 0);  ///< Data Timeout Counter Value
    }

    /// SRR Register bits
    namespace srr_bits {
        constexpr uint32_t SWRSTALL = (1U << 0);  ///< Software Reset For All
        constexpr uint32_t SWRSTCMD = (1U << 1);  ///< Software Reset For CMD Line
        constexpr uint32_t SWRSTDAT = (1U << 2);  ///< Software Reset For DAT Line
    }

    /// NISTR Register bits
    namespace nistr_bits {
        constexpr uint32_t CMDC = (1U << 0);  ///< Command Complete
        constexpr uint32_t TRFC = (1U << 1);  ///< Transfer Complete
        constexpr uint32_t BLKGE = (1U << 2);  ///< Block Gap Event
        constexpr uint32_t DMAINT = (1U << 3);  ///< DMA Interrupt
        constexpr uint32_t BWRRDY = (1U << 4);  ///< Buffer Write Ready
        constexpr uint32_t BRDRDY = (1U << 5);  ///< Buffer Read Ready
        constexpr uint32_t CINS = (1U << 6);  ///< Card Insertion
        constexpr uint32_t CREM = (1U << 7);  ///< Card Removal
        constexpr uint32_t CINT = (1U << 8);  ///< Card Interrupt
        constexpr uint32_t ERRINT = (1U << 15);  ///< Error Interrupt
    }

    /// NISTR_EMMC_MODE Register bits
    namespace nistr_emmc_mode_bits {
        constexpr uint32_t CMDC = (1U << 0);  ///< Command Complete
        constexpr uint32_t TRFC = (1U << 1);  ///< Transfer Complete
        constexpr uint32_t BLKGE = (1U << 2);  ///< Block Gap Event
        constexpr uint32_t DMAINT = (1U << 3);  ///< DMA Interrupt
        constexpr uint32_t BWRRDY = (1U << 4);  ///< Buffer Write Ready
        constexpr uint32_t BRDRDY = (1U << 5);  ///< Buffer Read Ready
        constexpr uint32_t BOOTAR = (1U << 14);  ///< Boot Acknowledge Received
        constexpr uint32_t ERRINT = (1U << 15);  ///< Error Interrupt
    }

    /// EISTR Register bits
    namespace eistr_bits {
        constexpr uint32_t CMDTEO = (1U << 0);  ///< Command Timeout Error
        constexpr uint32_t CMDCRC = (1U << 1);  ///< Command CRC Error
        constexpr uint32_t CMDEND = (1U << 2);  ///< Command End Bit Error
        constexpr uint32_t CMDIDX = (1U << 3);  ///< Command Index Error
        constexpr uint32_t DATTEO = (1U << 4);  ///< Data Timeout Error
        constexpr uint32_t DATCRC = (1U << 5);  ///< Data CRC Error
        constexpr uint32_t DATEND = (1U << 6);  ///< Data End Bit Error
        constexpr uint32_t CURLIM = (1U << 7);  ///< Current Limit Error
        constexpr uint32_t ACMD = (1U << 8);  ///< Auto CMD Error
        constexpr uint32_t ADMA = (1U << 9);  ///< ADMA Error
    }

    /// EISTR_EMMC_MODE Register bits
    namespace eistr_emmc_mode_bits {
        constexpr uint32_t CMDTEO = (1U << 0);  ///< Command Timeout Error
        constexpr uint32_t CMDCRC = (1U << 1);  ///< Command CRC Error
        constexpr uint32_t CMDEND = (1U << 2);  ///< Command End Bit Error
        constexpr uint32_t CMDIDX = (1U << 3);  ///< Command Index Error
        constexpr uint32_t DATTEO = (1U << 4);  ///< Data Timeout Error
        constexpr uint32_t DATCRC = (1U << 5);  ///< Data CRC Error
        constexpr uint32_t DATEND = (1U << 6);  ///< Data End Bit Error
        constexpr uint32_t CURLIM = (1U << 7);  ///< Current Limit Error
        constexpr uint32_t ACMD = (1U << 8);  ///< Auto CMD Error
        constexpr uint32_t ADMA = (1U << 9);  ///< ADMA Error
        constexpr uint32_t BOOTAE = (1U << 12);  ///< Boot Acknowledge Error
    }

    /// NISTER Register bits
    namespace nister_bits {
        constexpr uint32_t CMDC = (1U << 0);  ///< Command Complete Status Enable
        constexpr uint32_t TRFC = (1U << 1);  ///< Transfer Complete Status Enable
        constexpr uint32_t BLKGE = (1U << 2);  ///< Block Gap Event Status Enable
        constexpr uint32_t DMAINT = (1U << 3);  ///< DMA Interrupt Status Enable
        constexpr uint32_t BWRRDY = (1U << 4);  ///< Buffer Write Ready Status Enable
        constexpr uint32_t BRDRDY = (1U << 5);  ///< Buffer Read Ready Status Enable
        constexpr uint32_t CINS = (1U << 6);  ///< Card Insertion Status Enable
        constexpr uint32_t CREM = (1U << 7);  ///< Card Removal Status Enable
        constexpr uint32_t CINT = (1U << 8);  ///< Card Interrupt Status Enable
    }

    /// NISTER_EMMC_MODE Register bits
    namespace nister_emmc_mode_bits {
        constexpr uint32_t CMDC = (1U << 0);  ///< Command Complete Status Enable
        constexpr uint32_t TRFC = (1U << 1);  ///< Transfer Complete Status Enable
        constexpr uint32_t BLKGE = (1U << 2);  ///< Block Gap Event Status Enable
        constexpr uint32_t DMAINT = (1U << 3);  ///< DMA Interrupt Status Enable
        constexpr uint32_t BWRRDY = (1U << 4);  ///< Buffer Write Ready Status Enable
        constexpr uint32_t BRDRDY = (1U << 5);  ///< Buffer Read Ready Status Enable
        constexpr uint32_t BOOTAR = (1U << 14);  ///< Boot Acknowledge Received Status Enable
    }

    /// EISTER Register bits
    namespace eister_bits {
        constexpr uint32_t CMDTEO = (1U << 0);  ///< Command Timeout Error Status Enable
        constexpr uint32_t CMDCRC = (1U << 1);  ///< Command CRC Error Status Enable
        constexpr uint32_t CMDEND = (1U << 2);  ///< Command End Bit Error Status Enable
        constexpr uint32_t CMDIDX = (1U << 3);  ///< Command Index Error Status Enable
        constexpr uint32_t DATTEO = (1U << 4);  ///< Data Timeout Error Status Enable
        constexpr uint32_t DATCRC = (1U << 5);  ///< Data CRC Error Status Enable
        constexpr uint32_t DATEND = (1U << 6);  ///< Data End Bit Error Status Enable
        constexpr uint32_t CURLIM = (1U << 7);  ///< Current Limit Error Status Enable
        constexpr uint32_t ACMD = (1U << 8);  ///< Auto CMD Error Status Enable
        constexpr uint32_t ADMA = (1U << 9);  ///< ADMA Error Status Enable
    }

    /// EISTER_EMMC_MODE Register bits
    namespace eister_emmc_mode_bits {
        constexpr uint32_t CMDTEO = (1U << 0);  ///< Command Timeout Error Status Enable
        constexpr uint32_t CMDCRC = (1U << 1);  ///< Command CRC Error Status Enable
        constexpr uint32_t CMDEND = (1U << 2);  ///< Command End Bit Error Status Enable
        constexpr uint32_t CMDIDX = (1U << 3);  ///< Command Index Error Status Enable
        constexpr uint32_t DATTEO = (1U << 4);  ///< Data Timeout Error Status Enable
        constexpr uint32_t DATCRC = (1U << 5);  ///< Data CRC Error Status Enable
        constexpr uint32_t DATEND = (1U << 6);  ///< Data End Bit Error Status Enable
        constexpr uint32_t CURLIM = (1U << 7);  ///< Current Limit Error Status Enable
        constexpr uint32_t ACMD = (1U << 8);  ///< Auto CMD Error Status Enable
        constexpr uint32_t ADMA = (1U << 9);  ///< ADMA Error Status Enable
        constexpr uint32_t BOOTAE = (1U << 12);  ///< Boot Acknowledge Error Status Enable
    }

    /// NISIER Register bits
    namespace nisier_bits {
        constexpr uint32_t CMDC = (1U << 0);  ///< Command Complete Signal Enable
        constexpr uint32_t TRFC = (1U << 1);  ///< Transfer Complete Signal Enable
        constexpr uint32_t BLKGE = (1U << 2);  ///< Block Gap Event Signal Enable
        constexpr uint32_t DMAINT = (1U << 3);  ///< DMA Interrupt Signal Enable
        constexpr uint32_t BWRRDY = (1U << 4);  ///< Buffer Write Ready Signal Enable
        constexpr uint32_t BRDRDY = (1U << 5);  ///< Buffer Read Ready Signal Enable
        constexpr uint32_t CINS = (1U << 6);  ///< Card Insertion Signal Enable
        constexpr uint32_t CREM = (1U << 7);  ///< Card Removal Signal Enable
        constexpr uint32_t CINT = (1U << 8);  ///< Card Interrupt Signal Enable
    }

    /// NISIER_EMMC_MODE Register bits
    namespace nisier_emmc_mode_bits {
        constexpr uint32_t CMDC = (1U << 0);  ///< Command Complete Signal Enable
        constexpr uint32_t TRFC = (1U << 1);  ///< Transfer Complete Signal Enable
        constexpr uint32_t BLKGE = (1U << 2);  ///< Block Gap Event Signal Enable
        constexpr uint32_t DMAINT = (1U << 3);  ///< DMA Interrupt Signal Enable
        constexpr uint32_t BWRRDY = (1U << 4);  ///< Buffer Write Ready Signal Enable
        constexpr uint32_t BRDRDY = (1U << 5);  ///< Buffer Read Ready Signal Enable
        constexpr uint32_t BOOTAR = (1U << 14);  ///< Boot Acknowledge Received Signal Enable
    }

    /// EISIER Register bits
    namespace eisier_bits {
        constexpr uint32_t CMDTEO = (1U << 0);  ///< Command Timeout Error Signal Enable
        constexpr uint32_t CMDCRC = (1U << 1);  ///< Command CRC Error Signal Enable
        constexpr uint32_t CMDEND = (1U << 2);  ///< Command End Bit Error Signal Enable
        constexpr uint32_t CMDIDX = (1U << 3);  ///< Command Index Error Signal Enable
        constexpr uint32_t DATTEO = (1U << 4);  ///< Data Timeout Error Signal Enable
        constexpr uint32_t DATCRC = (1U << 5);  ///< Data CRC Error Signal Enable
        constexpr uint32_t DATEND = (1U << 6);  ///< Data End Bit Error Signal Enable
        constexpr uint32_t CURLIM = (1U << 7);  ///< Current Limit Error Signal Enable
        constexpr uint32_t ACMD = (1U << 8);  ///< Auto CMD Error Signal Enable
        constexpr uint32_t ADMA = (1U << 9);  ///< ADMA Error Signal Enable
    }

    /// EISIER_EMMC_MODE Register bits
    namespace eisier_emmc_mode_bits {
        constexpr uint32_t CMDTEO = (1U << 0);  ///< Command Timeout Error Signal Enable
        constexpr uint32_t CMDCRC = (1U << 1);  ///< Command CRC Error Signal Enable
        constexpr uint32_t CMDEND = (1U << 2);  ///< Command End Bit Error Signal Enable
        constexpr uint32_t CMDIDX = (1U << 3);  ///< Command Index Error Signal Enable
        constexpr uint32_t DATTEO = (1U << 4);  ///< Data Timeout Error Signal Enable
        constexpr uint32_t DATCRC = (1U << 5);  ///< Data CRC Error Signal Enable
        constexpr uint32_t DATEND = (1U << 6);  ///< Data End Bit Error Signal Enable
        constexpr uint32_t CURLIM = (1U << 7);  ///< Current Limit Error Signal Enable
        constexpr uint32_t ACMD = (1U << 8);  ///< Auto CMD Error Signal Enable
        constexpr uint32_t ADMA = (1U << 9);  ///< ADMA Error Signal Enable
        constexpr uint32_t BOOTAE = (1U << 12);  ///< Boot Acknowledge Error Signal Enable
    }

    /// ACESR Register bits
    namespace acesr_bits {
        constexpr uint32_t ACMD12NE = (1U << 0);  ///< Auto CMD12 Not Executed
        constexpr uint32_t ACMDTEO = (1U << 1);  ///< Auto CMD Timeout Error
        constexpr uint32_t ACMDCRC = (1U << 2);  ///< Auto CMD CRC Error
        constexpr uint32_t ACMDEND = (1U << 3);  ///< Auto CMD End Bit Error
        constexpr uint32_t ACMDIDX = (1U << 4);  ///< Auto CMD Index Error
        constexpr uint32_t CMDNI = (1U << 7);  ///< Command not Issued By Auto CMD12 Error
    }

    /// HC2R Register bits
    namespace hc2r_bits {
        constexpr uint32_t UHSMS = (3 << 0);  ///< UHS Mode Select
        constexpr uint32_t VS18EN = (1U << 3);  ///< 1.8V Signaling Enable
        constexpr uint32_t DRVSEL = (2 << 4);  ///< Driver Strength Select
        constexpr uint32_t EXTUN = (1U << 6);  ///< Execute Tuning
        constexpr uint32_t SLCKSEL = (1U << 7);  ///< Sampling Clock Select
        constexpr uint32_t ASINTEN = (1U << 14);  ///< Asynchronous Interrupt Enable
        constexpr uint32_t PVALEN = (1U << 15);  ///< Preset Value Enable
    }

    /// HC2R_EMMC_MODE Register bits
    namespace hc2r_emmc_mode_bits {
        constexpr uint32_t HS200EN = (4 << 0);  ///< HS200 Mode Enable
        constexpr uint32_t DRVSEL = (2 << 4);  ///< Driver Strength Select
        constexpr uint32_t EXTUN = (1U << 6);  ///< Execute Tuning
        constexpr uint32_t SLCKSEL = (1U << 7);  ///< Sampling Clock Select
        constexpr uint32_t PVALEN = (1U << 15);  ///< Preset Value Enable
    }

    /// CA0R Register bits
    namespace ca0r_bits {
        constexpr uint32_t TEOCLKF = (6 << 0);  ///< Timeout Clock Frequency
        constexpr uint32_t TEOCLKU = (1U << 7);  ///< Timeout Clock Unit
        constexpr uint32_t BASECLKF = (8 << 8);  ///< Base Clock Frequency
        constexpr uint32_t MAXBLKL = (2 << 16);  ///< Max Block Length
        constexpr uint32_t ED8SUP = (1U << 18);  ///< 8-bit Support for Embedded Device
        constexpr uint32_t ADMA2SUP = (1U << 19);  ///< ADMA2 Support
        constexpr uint32_t HSSUP = (1U << 21);  ///< High Speed Support
        constexpr uint32_t SDMASUP = (1U << 22);  ///< SDMA Support
        constexpr uint32_t SRSUP = (1U << 23);  ///< Suspend/Resume Support
        constexpr uint32_t V33VSUP = (1U << 24);  ///< Voltage Support 3.3V
        constexpr uint32_t V30VSUP = (1U << 25);  ///< Voltage Support 3.0V
        constexpr uint32_t V18VSUP = (1U << 26);  ///< Voltage Support 1.8V
        constexpr uint32_t SB64SUP = (1U << 28);  ///< 64-Bit System Bus Support
        constexpr uint32_t ASINTSUP = (1U << 29);  ///< Asynchronous Interrupt Support
        constexpr uint32_t SLTYPE = (2 << 30);  ///< Slot Type
    }

    /// CA1R Register bits
    namespace ca1r_bits {
        constexpr uint32_t SDR50SUP = (1U << 0);  ///< SDR50 Support
        constexpr uint32_t SDR104SUP = (1U << 1);  ///< SDR104 Support
        constexpr uint32_t DDR50SUP = (1U << 2);  ///< DDR50 Support
        constexpr uint32_t DRVASUP = (1U << 4);  ///< Driver Type A Support
        constexpr uint32_t DRVCSUP = (1U << 5);  ///< Driver Type C Support
        constexpr uint32_t DRVDSUP = (1U << 6);  ///< Driver Type D Support
        constexpr uint32_t TCNTRT = (4 << 8);  ///< Timer Count for Re-Tuning
        constexpr uint32_t TSDR50 = (1U << 13);  ///< Use Tuning for SDR50
        constexpr uint32_t CLKMULT = (8 << 16);  ///< Clock Multiplier
    }

    /// MCCAR Register bits
    namespace mccar_bits {
        constexpr uint32_t MAXCUR33V = (8 << 0);  ///< Maximum Current for 3.3V
        constexpr uint32_t MAXCUR30V = (8 << 8);  ///< Maximum Current for 3.0V
        constexpr uint32_t MAXCUR18V = (8 << 16);  ///< Maximum Current for 1.8V
    }

    /// FERACES Register bits
    namespace feraces_bits {
        constexpr uint32_t ACMD12NE = (1U << 0);  ///< Force Event for Auto CMD12 Not Executed
        constexpr uint32_t ACMDTEO = (1U << 1);  ///< Force Event for Auto CMD Timeout Error
        constexpr uint32_t ACMDCRC = (1U << 2);  ///< Force Event for Auto CMD CRC Error
        constexpr uint32_t ACMDEND = (1U << 3);  ///< Force Event for Auto CMD End Bit Error
        constexpr uint32_t ACMDIDX = (1U << 4);  ///< Force Event for Auto CMD Index Error
        constexpr uint32_t CMDNI = (1U << 7);  ///< Force Event for Command Not Issued By Auto CMD12 Error
    }

    /// FEREIS Register bits
    namespace fereis_bits {
        constexpr uint32_t CMDTEO = (1U << 0);  ///< Force Event for Command Timeout Error
        constexpr uint32_t CMDCRC = (1U << 1);  ///< Force Event for Command CRC Error
        constexpr uint32_t CMDEND = (1U << 2);  ///< Force Event for Command End Bit Error
        constexpr uint32_t CMDIDX = (1U << 3);  ///< Force Event for Command Index Error
        constexpr uint32_t DATTEO = (1U << 4);  ///< Force Event for Data Timeout Error
        constexpr uint32_t DATCRC = (1U << 5);  ///< Force Event for Data CRC Error
        constexpr uint32_t DATEND = (1U << 6);  ///< Force Event for Data End Bit Error
        constexpr uint32_t CURLIM = (1U << 7);  ///< Force Event for Current Limit Error
        constexpr uint32_t ACMD = (1U << 8);  ///< Force Event for Auto CMD Error
        constexpr uint32_t ADMA = (1U << 9);  ///< Force Event for ADMA Error
        constexpr uint32_t BOOTAE = (1U << 12);  ///< Force Event for Boot Acknowledge Error
    }

    /// AESR Register bits
    namespace aesr_bits {
        constexpr uint32_t ERRST = (2 << 0);  ///< ADMA Error State
        constexpr uint32_t LMIS = (1U << 2);  ///< ADMA Length Mismatch Error
    }

    /// ASAR__ Register bits
    namespace asar___bits {
        constexpr uint32_t ADMASA = (32 << 0);  ///< ADMA System Address
    }

    /// PVR__ Register bits
    namespace pvr___bits {
        constexpr uint32_t SDCLKFSEL = (10 << 0);  ///< SDCLK Frequency Select Value for Initialization
        constexpr uint32_t CLKGSEL = (1U << 10);  ///< Clock Generator Select Value for Initialization
        constexpr uint32_t DRVSEL = (2 << 14);  ///< Driver Strength Select Value for Initialization
    }

    /// SISR Register bits
    namespace sisr_bits {
        constexpr uint32_t INTSSL = (1U << 0);  ///< Interrupt Signal for Each Slot
    }

    /// HCVR Register bits
    namespace hcvr_bits {
        constexpr uint32_t SVER = (8 << 0);  ///< Spec Version
        constexpr uint32_t VVER = (8 << 8);  ///< Vendor Version
    }

    /// MC1R Register bits
    namespace mc1r_bits {
        constexpr uint32_t CMDTYP = (2 << 0);  ///< e.MMC Command Type
        constexpr uint32_t DDR = (1U << 3);  ///< e.MMC HSDDR Mode
        constexpr uint32_t OPD = (1U << 4);  ///< e.MMC Open Drain Mode
        constexpr uint32_t BOOTA = (1U << 5);  ///< e.MMC Boot Acknowledge Enable
        constexpr uint32_t RSTN = (1U << 6);  ///< e.MMC Reset Signal
        constexpr uint32_t FCD = (1U << 7);  ///< e.MMC Force Card Detect
    }

    /// MC2R Register bits
    namespace mc2r_bits {
        constexpr uint32_t SRESP = (1U << 0);  ///< e.MMC Abort Wait IRQ
        constexpr uint32_t ABOOT = (1U << 1);  ///< e.MMC Abort Boot
    }

    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t BMAX = (2 << 0);  ///< AHB Maximum Burst
    }

    /// CC2R Register bits
    namespace cc2r_bits {
        constexpr uint32_t FSDCLKD = (1U << 0);  ///< Force SDCK Disabled
    }

    /// CACR Register bits
    namespace cacr_bits {
        constexpr uint32_t CAPWREN = (1U << 0);  ///< Capabilities Registers Write Enable (Required to write the correct frequencies in the Capabilities Registers)
        constexpr uint32_t KEY = (8 << 8);  ///< Key (0x46)
    }

    /// DBGR Register bits
    namespace dbgr_bits {
        constexpr uint32_t NIDBG = (1U << 0);  ///< Non-intrusive debug enable
    }

}

// ============================================================================
// SDHC1 Peripheral
// ============================================================================

namespace sdhc1 {
    /// Base addresses
    constexpr uint32_t SDHC1_BASE = 0x46000000;

    /// SDHC1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SDHC1 = reinterpret_cast<Registers*>(SDHC1_BASE);

}

// ============================================================================
// SERCOM Peripheral
// ============================================================================

namespace sercom {
    /// Base addresses
    constexpr uint32_t SERCOM0_BASE = 0x40003000;
    constexpr uint32_t SERCOM1_BASE = 0x40003400;
    constexpr uint32_t SERCOM2_BASE = 0x41012000;
    constexpr uint32_t SERCOM3_BASE = 0x41014000;
    constexpr uint32_t SERCOM4_BASE = 0x43000000;
    constexpr uint32_t SERCOM5_BASE = 0x43000400;
    constexpr uint32_t SERCOM6_BASE = 0x43000800;
    constexpr uint32_t SERCOM7_BASE = 0x43000C00;

    /// SERCOM Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - USART_INT Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x04 - USART_INT Control B
        volatile uint32_t CTRLC;  ///< Offset: 0x08 - USART_INT Control C
        volatile uint32_t BAUD;  ///< Offset: 0x0C - USART_INT Baud Rate
        volatile uint32_t INTENCLR;  ///< Offset: 0x14 - USART_INT Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x16 - USART_INT Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x18 - USART_INT Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x1A - USART_INT Status
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x1C - USART_INT Synchronization Busy
        volatile uint32_t ADDR;  ///< Offset: 0x24 - SPIM Address
        volatile uint32_t DATA;  ///< Offset: 0x28 - USART_INT Data
        volatile uint32_t DBGCTRL;  ///< Offset: 0x30 - USART_INT Debug Control
        volatile uint32_t LENGTH;  ///< Offset: 0x22 - USART_INT Length
        volatile uint32_t BAUD_FRAC_MODE;  ///< Offset: 0x0C - USART_INT Baud Rate
        volatile uint32_t BAUD_FRACFP_MODE;  ///< Offset: 0x0C - USART_INT Baud Rate
        volatile uint32_t BAUD_USARTFP_MODE;  ///< Offset: 0x0C - USART_INT Baud Rate
        volatile uint32_t RXPL;  ///< Offset: 0x0E - USART_INT Receive Pulse Length
        volatile uint32_t RXERRCNT;  ///< Offset: 0x20 - USART_INT Receive Error Count
    };

    /// Peripheral instances
    inline Registers* SERCOM0 = reinterpret_cast<Registers*>(SERCOM0_BASE);
    inline Registers* SERCOM1 = reinterpret_cast<Registers*>(SERCOM1_BASE);
    inline Registers* SERCOM2 = reinterpret_cast<Registers*>(SERCOM2_BASE);
    inline Registers* SERCOM3 = reinterpret_cast<Registers*>(SERCOM3_BASE);
    inline Registers* SERCOM4 = reinterpret_cast<Registers*>(SERCOM4_BASE);
    inline Registers* SERCOM5 = reinterpret_cast<Registers*>(SERCOM5_BASE);
    inline Registers* SERCOM6 = reinterpret_cast<Registers*>(SERCOM6_BASE);
    inline Registers* SERCOM7 = reinterpret_cast<Registers*>(SERCOM7_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t MODE = (3 << 2);  ///< Operating Mode
        constexpr uint32_t RUNSTDBY = (1U << 7);  ///< Run during Standby
        constexpr uint32_t IBON = (1U << 8);  ///< Immediate Buffer Overflow Notification
        constexpr uint32_t TXINV = (1U << 9);  ///< Transmit Data Invert
        constexpr uint32_t RXINV = (1U << 10);  ///< Receive Data Invert
        constexpr uint32_t SAMPR = (3 << 13);  ///< Sample
        constexpr uint32_t TXPO = (2 << 16);  ///< Transmit Data Pinout
        constexpr uint32_t RXPO = (2 << 20);  ///< Receive Data Pinout
        constexpr uint32_t SAMPA = (2 << 22);  ///< Sample Adjustment
        constexpr uint32_t FORM = (4 << 24);  ///< Frame Format
        constexpr uint32_t CMODE = (1U << 28);  ///< Communication Mode
        constexpr uint32_t CPOL = (1U << 29);  ///< Clock Polarity
        constexpr uint32_t DORD = (1U << 30);  ///< Data Order
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t CHSIZE = (3 << 0);  ///< Character Size
        constexpr uint32_t SBMODE = (1U << 6);  ///< Stop Bit Mode
        constexpr uint32_t COLDEN = (1U << 8);  ///< Collision Detection Enable
        constexpr uint32_t SFDE = (1U << 9);  ///< Start of Frame Detection Enable
        constexpr uint32_t ENC = (1U << 10);  ///< Encoding Format
        constexpr uint32_t PMODE = (1U << 13);  ///< Parity Mode
        constexpr uint32_t TXEN = (1U << 16);  ///< Transmitter Enable
        constexpr uint32_t RXEN = (1U << 17);  ///< Receiver Enable
        constexpr uint32_t LINCMD = (2 << 24);  ///< LIN Command
    }

    /// CTRLC Register bits
    namespace ctrlc_bits {
        constexpr uint32_t GTIME = (3 << 0);  ///< Guard Time
        constexpr uint32_t BRKLEN = (2 << 8);  ///< LIN Master Break Length
        constexpr uint32_t HDRDLY = (2 << 10);  ///< LIN Master Header Delay
        constexpr uint32_t INACK = (1U << 16);  ///< Inhibit Not Acknowledge
        constexpr uint32_t DSNACK = (1U << 17);  ///< Disable Successive NACK
        constexpr uint32_t MAXITER = (3 << 20);  ///< Maximum Iterations
        constexpr uint32_t DATA32B = (2 << 24);  ///< Data 32 Bit
    }

    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t BAUD = (16 << 0);  ///< Baud Rate Value
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t DRE = (1U << 0);  ///< Data Register Empty Interrupt Disable
        constexpr uint32_t TXC = (1U << 1);  ///< Transmit Complete Interrupt Disable
        constexpr uint32_t RXC = (1U << 2);  ///< Receive Complete Interrupt Disable
        constexpr uint32_t RXS = (1U << 3);  ///< Receive Start Interrupt Disable
        constexpr uint32_t CTSIC = (1U << 4);  ///< Clear To Send Input Change Interrupt Disable
        constexpr uint32_t RXBRK = (1U << 5);  ///< Break Received Interrupt Disable
        constexpr uint32_t ERROR = (1U << 7);  ///< Combined Error Interrupt Disable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t DRE = (1U << 0);  ///< Data Register Empty Interrupt Enable
        constexpr uint32_t TXC = (1U << 1);  ///< Transmit Complete Interrupt Enable
        constexpr uint32_t RXC = (1U << 2);  ///< Receive Complete Interrupt Enable
        constexpr uint32_t RXS = (1U << 3);  ///< Receive Start Interrupt Enable
        constexpr uint32_t CTSIC = (1U << 4);  ///< Clear To Send Input Change Interrupt Enable
        constexpr uint32_t RXBRK = (1U << 5);  ///< Break Received Interrupt Enable
        constexpr uint32_t ERROR = (1U << 7);  ///< Combined Error Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t DRE = (1U << 0);  ///< Data Register Empty Interrupt
        constexpr uint32_t TXC = (1U << 1);  ///< Transmit Complete Interrupt
        constexpr uint32_t RXC = (1U << 2);  ///< Receive Complete Interrupt
        constexpr uint32_t RXS = (1U << 3);  ///< Receive Start Interrupt
        constexpr uint32_t CTSIC = (1U << 4);  ///< Clear To Send Input Change Interrupt
        constexpr uint32_t RXBRK = (1U << 5);  ///< Break Received Interrupt
        constexpr uint32_t ERROR = (1U << 7);  ///< Combined Error Interrupt
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t PERR = (1U << 0);  ///< Parity Error
        constexpr uint32_t FERR = (1U << 1);  ///< Frame Error
        constexpr uint32_t BUFOVF = (1U << 2);  ///< Buffer Overflow
        constexpr uint32_t CTS = (1U << 3);  ///< Clear To Send
        constexpr uint32_t ISF = (1U << 4);  ///< Inconsistent Sync Field
        constexpr uint32_t COLL = (1U << 5);  ///< Collision Detected
        constexpr uint32_t TXE = (1U << 6);  ///< Transmitter Empty
        constexpr uint32_t ITER = (1U << 7);  ///< Maximum Number of Repetitions Reached
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchronization Busy
        constexpr uint32_t ENABLE = (1U << 1);  ///< SERCOM Enable Synchronization Busy
        constexpr uint32_t CTRLB = (1U << 2);  ///< CTRLB Synchronization Busy
        constexpr uint32_t RXERRCNT = (1U << 3);  ///< RXERRCNT Synchronization Busy
        constexpr uint32_t LENGTH = (1U << 4);  ///< LENGTH Synchronization Busy
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (8 << 0);  ///< Address Value
        constexpr uint32_t ADDRMASK = (8 << 16);  ///< Address Mask
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data Value
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGSTOP = (1U << 0);  ///< Debug Mode
    }

    /// LENGTH Register bits
    namespace length_bits {
        constexpr uint32_t LEN = (8 << 0);  ///< Data Length
        constexpr uint32_t LENEN = (2 << 8);  ///< Data Length Enable
    }

    /// BAUD_FRAC_MODE Register bits
    namespace baud_frac_mode_bits {
        constexpr uint32_t BAUD = (13 << 0);  ///< Baud Rate Value
        constexpr uint32_t FP = (3 << 13);  ///< Fractional Part
    }

    /// BAUD_FRACFP_MODE Register bits
    namespace baud_fracfp_mode_bits {
        constexpr uint32_t BAUD = (13 << 0);  ///< Baud Rate Value
        constexpr uint32_t FP = (3 << 13);  ///< Fractional Part
    }

    /// BAUD_USARTFP_MODE Register bits
    namespace baud_usartfp_mode_bits {
        constexpr uint32_t BAUD = (16 << 0);  ///< Baud Rate Value
    }

    /// RXPL Register bits
    namespace rxpl_bits {
        constexpr uint32_t RXPL = (8 << 0);  ///< Receive Pulse Length
    }

}

// ============================================================================
// SUPC Peripheral
// ============================================================================

namespace supc {
    /// Base addresses
    constexpr uint32_t SUPC_BASE = 0x40001800;

    /// SUPC Register structure
    struct Registers {
        volatile uint32_t INTENCLR;  ///< Offset: 0x00 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x04 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x08 - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x0C - Power and Clocks Status
        volatile uint32_t BOD33;  ///< Offset: 0x10 - BOD33 Control
        volatile uint32_t VREG;  ///< Offset: 0x18 - VREG Control
        volatile uint32_t VREF;  ///< Offset: 0x1C - VREF Control
        volatile uint32_t BBPS;  ///< Offset: 0x20 - Battery Backup Power Switch
        volatile uint32_t BKOUT;  ///< Offset: 0x24 - Backup Output Control
        volatile uint32_t BKIN;  ///< Offset: 0x28 - Backup Input Control
    };

    /// Peripheral instances
    inline Registers* SUPC = reinterpret_cast<Registers*>(SUPC_BASE);

    // Bit definitions
    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t BOD33RDY = (1U << 0);  ///< BOD33 Ready
        constexpr uint32_t BOD33DET = (1U << 1);  ///< BOD33 Detection
        constexpr uint32_t B33SRDY = (1U << 2);  ///< BOD33 Synchronization Ready
        constexpr uint32_t VREGRDY = (1U << 8);  ///< Voltage Regulator Ready
        constexpr uint32_t VCORERDY = (1U << 10);  ///< VDDCORE Ready
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t BOD33RDY = (1U << 0);  ///< BOD33 Ready
        constexpr uint32_t BOD33DET = (1U << 1);  ///< BOD33 Detection
        constexpr uint32_t B33SRDY = (1U << 2);  ///< BOD33 Synchronization Ready
        constexpr uint32_t VREGRDY = (1U << 8);  ///< Voltage Regulator Ready
        constexpr uint32_t VCORERDY = (1U << 10);  ///< VDDCORE Ready
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t BOD33RDY = (1U << 0);  ///< BOD33 Ready
        constexpr uint32_t BOD33DET = (1U << 1);  ///< BOD33 Detection
        constexpr uint32_t B33SRDY = (1U << 2);  ///< BOD33 Synchronization Ready
        constexpr uint32_t VREGRDY = (1U << 8);  ///< Voltage Regulator Ready
        constexpr uint32_t VCORERDY = (1U << 10);  ///< VDDCORE Ready
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t BOD33RDY = (1U << 0);  ///< BOD33 Ready
        constexpr uint32_t BOD33DET = (1U << 1);  ///< BOD33 Detection
        constexpr uint32_t B33SRDY = (1U << 2);  ///< BOD33 Synchronization Ready
        constexpr uint32_t VREGRDY = (1U << 8);  ///< Voltage Regulator Ready
        constexpr uint32_t VCORERDY = (1U << 10);  ///< VDDCORE Ready
    }

    /// BOD33 Register bits
    namespace bod33_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t ACTION = (2 << 2);  ///< Action when Threshold Crossed
        constexpr uint32_t STDBYCFG = (1U << 4);  ///< Configuration in Standby mode
        constexpr uint32_t RUNSTDBY = (1U << 5);  ///< Run in Standby mode
        constexpr uint32_t RUNHIB = (1U << 6);  ///< Run in Hibernate mode
        constexpr uint32_t RUNBKUP = (1U << 7);  ///< Run in Backup mode
        constexpr uint32_t HYST = (4 << 8);  ///< Hysteresis value
        constexpr uint32_t PSEL = (3 << 12);  ///< Prescaler Select
        constexpr uint32_t LEVEL = (8 << 16);  ///< Threshold Level for VDD
        constexpr uint32_t VBATLEVEL = (8 << 24);  ///< Threshold Level in battery backup sleep mode for VBAT
    }

    /// VREG Register bits
    namespace vreg_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t SEL = (1U << 2);  ///< Voltage Regulator Selection
        constexpr uint32_t RUNBKUP = (1U << 7);  ///< Run in Backup mode
        constexpr uint32_t VSEN = (1U << 16);  ///< Voltage Scaling Enable
        constexpr uint32_t VSPER = (3 << 24);  ///< Voltage Scaling Period
    }

    /// VREF Register bits
    namespace vref_bits {
        constexpr uint32_t TSEN = (1U << 1);  ///< Temperature Sensor Output Enable
        constexpr uint32_t VREFOE = (1U << 2);  ///< Voltage Reference Output Enable
        constexpr uint32_t TSSEL = (1U << 3);  ///< Temperature Sensor Selection
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run during Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Contrl
        constexpr uint32_t SEL = (4 << 16);  ///< Voltage Reference Selection
    }

    /// BBPS Register bits
    namespace bbps_bits {
        constexpr uint32_t CONF = (1U << 0);  ///< Battery Backup Configuration
        constexpr uint32_t WAKEEN = (1U << 2);  ///< Wake Enable
    }

    /// BKOUT Register bits
    namespace bkout_bits {
        constexpr uint32_t ENOUT0 = (1U << 0);  ///< Enable OUT0
        constexpr uint32_t ENOUT1 = (1U << 1);  ///< Enable OUT1
        constexpr uint32_t CLROUT0 = (1U << 8);  ///< Clear OUT0
        constexpr uint32_t CLROUT1 = (1U << 9);  ///< Clear OUT1
        constexpr uint32_t SETOUT0 = (1U << 16);  ///< Set OUT0
        constexpr uint32_t SETOUT1 = (1U << 17);  ///< Set OUT1
        constexpr uint32_t RTCTGLOUT0 = (1U << 24);  ///< RTC Toggle OUT0
        constexpr uint32_t RTCTGLOUT1 = (1U << 25);  ///< RTC Toggle OUT1
    }

    /// BKIN Register bits
    namespace bkin_bits {
        constexpr uint32_t BKIN0 = (1U << 0);  ///< Backup Input 0
        constexpr uint32_t BKIN1 = (1U << 1);  ///< Backup Input 1
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TC0_BASE = 0x40003800;
    constexpr uint32_t TC1_BASE = 0x40003C00;
    constexpr uint32_t TC2_BASE = 0x4101A000;
    constexpr uint32_t TC3_BASE = 0x4101C000;
    constexpr uint32_t TC4_BASE = 0x42001400;
    constexpr uint32_t TC5_BASE = 0x42001800;
    constexpr uint32_t TC6_BASE = 0x43001400;
    constexpr uint32_t TC7_BASE = 0x43001800;
    constexpr uint32_t TCC0_BASE = 0x41016000;
    constexpr uint32_t TCC1_BASE = 0x41018000;
    constexpr uint32_t TCC2_BASE = 0x42000C00;
    constexpr uint32_t TCC3_BASE = 0x42001000;
    constexpr uint32_t TCC4_BASE = 0x43001000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLBCLR;  ///< Offset: 0x04 - Control B Clear
        volatile uint32_t CTRLBSET;  ///< Offset: 0x05 - Control B Set
        volatile uint32_t EVCTRL;  ///< Offset: 0x06 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x08 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x09 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x0A - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x0B - Status
        volatile uint32_t WAVE;  ///< Offset: 0x0C - Waveform Generation Control
        volatile uint32_t DRVCTRL;  ///< Offset: 0x0D - Control C
        volatile uint32_t DBGCTRL;  ///< Offset: 0x0F - Debug Control
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x10 - Synchronization Status
        volatile uint32_t COUNT;  ///< Offset: 0x14 - COUNT32 Count
        volatile uint32_t PER;  ///< Offset: 0x1B - COUNT8 Period
        volatile uint32_t CC__;  ///< Offset: 0x1C - COUNT32 Compare and Capture (renamed from CC__)
        volatile uint32_t PERBUF;  ///< Offset: 0x2F - COUNT8 Period Buffer
        volatile uint32_t CCBUF__;  ///< Offset: 0x30 - COUNT32 Compare and Capture Buffer (renamed from CCBUF__)
    };

    /// Peripheral instances
    inline Registers* TC0 = reinterpret_cast<Registers*>(TC0_BASE);
    inline Registers* TC1 = reinterpret_cast<Registers*>(TC1_BASE);
    inline Registers* TC2 = reinterpret_cast<Registers*>(TC2_BASE);
    inline Registers* TC3 = reinterpret_cast<Registers*>(TC3_BASE);
    inline Registers* TC4 = reinterpret_cast<Registers*>(TC4_BASE);
    inline Registers* TC5 = reinterpret_cast<Registers*>(TC5_BASE);
    inline Registers* TC6 = reinterpret_cast<Registers*>(TC6_BASE);
    inline Registers* TC7 = reinterpret_cast<Registers*>(TC7_BASE);
    inline Registers* TCC0 = reinterpret_cast<Registers*>(TCC0_BASE);
    inline Registers* TCC1 = reinterpret_cast<Registers*>(TCC1_BASE);
    inline Registers* TCC2 = reinterpret_cast<Registers*>(TCC2_BASE);
    inline Registers* TCC3 = reinterpret_cast<Registers*>(TCC3_BASE);
    inline Registers* TCC4 = reinterpret_cast<Registers*>(TCC4_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t MODE = (2 << 2);  ///< Timer Counter Mode
        constexpr uint32_t PRESCSYNC = (2 << 4);  ///< Prescaler and Counter Synchronization
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run during Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< Clock On Demand
        constexpr uint32_t PRESCALER = (3 << 8);  ///< Prescaler
        constexpr uint32_t ALOCK = (1U << 11);  ///< Auto Lock
        constexpr uint32_t CAPTEN0 = (1U << 16);  ///< Capture Channel 0 Enable
        constexpr uint32_t CAPTEN1 = (1U << 17);  ///< Capture Channel 1 Enable
        constexpr uint32_t COPEN0 = (1U << 20);  ///< Capture On Pin 0 Enable
        constexpr uint32_t COPEN1 = (1U << 21);  ///< Capture On Pin 1 Enable
        constexpr uint32_t CAPTMODE0 = (2 << 24);  ///< Capture Mode Channel 0
        constexpr uint32_t CAPTMODE1 = (2 << 27);  ///< Capture mode Channel 1
    }

    /// CTRLBCLR Register bits
    namespace ctrlbclr_bits {
        constexpr uint32_t DIR = (1U << 0);  ///< Counter Direction
        constexpr uint32_t LUPD = (1U << 1);  ///< Lock Update
        constexpr uint32_t ONESHOT = (1U << 2);  ///< One-Shot on Counter
        constexpr uint32_t CMD = (3 << 5);  ///< Command
    }

    /// CTRLBSET Register bits
    namespace ctrlbset_bits {
        constexpr uint32_t DIR = (1U << 0);  ///< Counter Direction
        constexpr uint32_t LUPD = (1U << 1);  ///< Lock Update
        constexpr uint32_t ONESHOT = (1U << 2);  ///< One-Shot on Counter
        constexpr uint32_t CMD = (3 << 5);  ///< Command
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t EVACT = (3 << 0);  ///< Event Action
        constexpr uint32_t TCINV = (1U << 4);  ///< TC Event Input Polarity
        constexpr uint32_t TCEI = (1U << 5);  ///< TC Event Enable
        constexpr uint32_t OVFEO = (1U << 8);  ///< Event Output Enable
        constexpr uint32_t MCEO0 = (1U << 12);  ///< MC Event Output Enable 0
        constexpr uint32_t MCEO1 = (1U << 13);  ///< MC Event Output Enable 1
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t OVF = (1U << 0);  ///< OVF Interrupt Disable
        constexpr uint32_t ERR = (1U << 1);  ///< ERR Interrupt Disable
        constexpr uint32_t MC0 = (1U << 4);  ///< MC Interrupt Disable 0
        constexpr uint32_t MC1 = (1U << 5);  ///< MC Interrupt Disable 1
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t OVF = (1U << 0);  ///< OVF Interrupt Enable
        constexpr uint32_t ERR = (1U << 1);  ///< ERR Interrupt Enable
        constexpr uint32_t MC0 = (1U << 4);  ///< MC Interrupt Enable 0
        constexpr uint32_t MC1 = (1U << 5);  ///< MC Interrupt Enable 1
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t OVF = (1U << 0);  ///< OVF Interrupt Flag
        constexpr uint32_t ERR = (1U << 1);  ///< ERR Interrupt Flag
        constexpr uint32_t MC0 = (1U << 4);  ///< MC Interrupt Flag 0
        constexpr uint32_t MC1 = (1U << 5);  ///< MC Interrupt Flag 1
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STOP = (1U << 0);  ///< Stop Status Flag
        constexpr uint32_t SLAVE = (1U << 1);  ///< Slave Status Flag
        constexpr uint32_t PERBUFV = (1U << 3);  ///< Synchronization Busy Status
        constexpr uint32_t CCBUFV0 = (1U << 4);  ///< Compare channel buffer 0 valid
        constexpr uint32_t CCBUFV1 = (1U << 5);  ///< Compare channel buffer 1 valid
    }

    /// WAVE Register bits
    namespace wave_bits {
        constexpr uint32_t WAVEGEN = (2 << 0);  ///< Waveform Generation Mode
    }

    /// DRVCTRL Register bits
    namespace drvctrl_bits {
        constexpr uint32_t INVEN0 = (1U << 0);  ///< Output Waveform Invert Enable 0
        constexpr uint32_t INVEN1 = (1U << 1);  ///< Output Waveform Invert Enable 1
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Run During Debug
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< swrst
        constexpr uint32_t ENABLE = (1U << 1);  ///< enable
        constexpr uint32_t CTRLB = (1U << 2);  ///< CTRLB
        constexpr uint32_t STATUS = (1U << 3);  ///< STATUS
        constexpr uint32_t COUNT = (1U << 4);  ///< Counter
        constexpr uint32_t PER = (1U << 5);  ///< Period
        constexpr uint32_t CC0 = (1U << 6);  ///< Compare Channel 0
        constexpr uint32_t CC1 = (1U << 7);  ///< Compare Channel 1
    }

    /// COUNT Register bits
    namespace count_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< Counter Value
    }

    /// PER Register bits
    namespace per_bits {
        constexpr uint32_t PER = (8 << 0);  ///< Period Value
    }

    /// CC__ Register bits
    namespace cc___bits {
        constexpr uint32_t CC = (32 << 0);  ///< Counter/Compare Value
    }

    /// PERBUF Register bits
    namespace perbuf_bits {
        constexpr uint32_t PERBUF = (8 << 0);  ///< Period Buffer Value
    }

    /// CCBUF__ Register bits
    namespace ccbuf___bits {
        constexpr uint32_t CCBUF = (32 << 0);  ///< Counter/Compare Buffer Value
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t TRNG_BASE = 0x42002800;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t EVCTRL;  ///< Offset: 0x04 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x08 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x09 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x0A - Interrupt Flag Status and Clear
        volatile uint32_t DATA;  ///< Offset: 0x20 - Output Data
    };

    /// Peripheral instances
    inline Registers* TRNG = reinterpret_cast<Registers*>(TRNG_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t DATARDYEO = (1U << 0);  ///< Data Ready Event Output
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Data Ready Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Data Ready Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Data Ready Interrupt Flag
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Output Data
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_BASE = 0x41000000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x02 - Synchronization Busy
        volatile uint32_t QOSCTRL;  ///< Offset: 0x03 - USB Quality Of Service
        volatile uint32_t CTRLB;  ///< Offset: 0x08 - HOST Control B
        volatile uint32_t DADD;  ///< Offset: 0x0A - DEVICE Device Address
        volatile uint32_t STATUS;  ///< Offset: 0x0C - HOST Status
        volatile uint32_t FSMSTATUS;  ///< Offset: 0x0D - Finite State Machine Status
        volatile uint32_t FNUM;  ///< Offset: 0x10 - HOST Host Frame Number
        volatile uint32_t INTENCLR;  ///< Offset: 0x14 - HOST Host Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x18 - HOST Host Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x1C - HOST Host Interrupt Flag
        volatile uint32_t EPINTSMRY;  ///< Offset: 0x20 - DEVICE End Point Interrupt Summary
        volatile uint32_t DESCADD;  ///< Offset: 0x24 - Descriptor Address
        volatile uint32_t PADCAL;  ///< Offset: 0x28 - USB PAD Calibration
        volatile uint32_t EPCFG;  ///< Offset: 0x00 - DEVICE_ENDPOINT End Point Configuration
        volatile uint32_t EPSTATUSCLR;  ///< Offset: 0x04 - DEVICE_ENDPOINT End Point Pipe Status Clear
        volatile uint32_t EPSTATUSSET;  ///< Offset: 0x05 - DEVICE_ENDPOINT End Point Pipe Status Set
        volatile uint32_t EPSTATUS;  ///< Offset: 0x06 - DEVICE_ENDPOINT End Point Pipe Status
        volatile uint32_t EPINTFLAG;  ///< Offset: 0x07 - DEVICE_ENDPOINT End Point Interrupt Flag
        volatile uint32_t EPINTENCLR;  ///< Offset: 0x08 - DEVICE_ENDPOINT End Point Interrupt Clear Flag
        volatile uint32_t EPINTENSET;  ///< Offset: 0x09 - DEVICE_ENDPOINT End Point Interrupt Set Flag
        volatile uint32_t HSOFC;  ///< Offset: 0x0A - HOST Host Start Of Frame Control
        volatile uint32_t FLENHIGH;  ///< Offset: 0x12 - HOST Host Frame Length
        volatile uint32_t PINTSMRY;  ///< Offset: 0x20 - HOST Pipe Interrupt Summary
        volatile uint32_t PCFG;  ///< Offset: 0x00 - HOST_PIPE End Point Configuration
        volatile uint32_t BINTERVAL;  ///< Offset: 0x03 - HOST_PIPE Bus Access Period of Pipe
        volatile uint32_t PSTATUSCLR;  ///< Offset: 0x04 - HOST_PIPE End Point Pipe Status Clear
        volatile uint32_t PSTATUSSET;  ///< Offset: 0x05 - HOST_PIPE End Point Pipe Status Set
        volatile uint32_t PSTATUS;  ///< Offset: 0x06 - HOST_PIPE End Point Pipe Status
        volatile uint32_t PINTFLAG;  ///< Offset: 0x07 - HOST_PIPE Pipe Interrupt Flag
        volatile uint32_t PINTENCLR;  ///< Offset: 0x08 - HOST_PIPE Pipe Interrupt Flag Clear
        volatile uint32_t PINTENSET;  ///< Offset: 0x09 - HOST_PIPE Pipe Interrupt Flag Set
    };

    /// Peripheral instances
    inline Registers* USB = reinterpret_cast<Registers*>(USB_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t RUNSTDBY = (1U << 2);  ///< Run in Standby Mode
        constexpr uint32_t MODE = (1U << 7);  ///< Operating Mode
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchronization Busy
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable Synchronization Busy
    }

    /// QOSCTRL Register bits
    namespace qosctrl_bits {
        constexpr uint32_t CQOS = (2 << 0);  ///< Configuration Quality of Service
        constexpr uint32_t DQOS = (2 << 2);  ///< Data Quality of Service
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t RESUME = (1U << 1);  ///< Send USB Resume
        constexpr uint32_t SPDCONF = (2 << 2);  ///< Speed Configuration for Host
        constexpr uint32_t AUTORESUME = (1U << 4);  ///< Auto Resume Enable
        constexpr uint32_t TSTJ = (1U << 5);  ///< Test mode J
        constexpr uint32_t TSTK = (1U << 6);  ///< Test mode K
        constexpr uint32_t SOFE = (1U << 8);  ///< Start of Frame Generation Enable
        constexpr uint32_t BUSRESET = (1U << 9);  ///< Send USB Reset
        constexpr uint32_t VBUSOK = (1U << 10);  ///< VBUS is OK
        constexpr uint32_t L1RESUME = (1U << 11);  ///< Send L1 Resume
    }

    /// DADD Register bits
    namespace dadd_bits {
        constexpr uint32_t DADD = (7 << 0);  ///< Device Address
        constexpr uint32_t ADDEN = (1U << 7);  ///< Device Address Enable
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SPEED = (2 << 2);  ///< Speed Status
        constexpr uint32_t LINESTATE = (2 << 6);  ///< USB Line State Status
    }

    /// FSMSTATUS Register bits
    namespace fsmstatus_bits {
        constexpr uint32_t FSMSTATE = (7 << 0);  ///< Fine State Machine Status
    }

    /// FNUM Register bits
    namespace fnum_bits {
        constexpr uint32_t MFNUM = (3 << 0);  ///< Micro Frame Number
        constexpr uint32_t FNUM = (11 << 3);  ///< Frame Number
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t HSOF = (1U << 2);  ///< Host Start Of Frame Interrupt Disable
        constexpr uint32_t RST = (1U << 3);  ///< BUS Reset Interrupt Disable
        constexpr uint32_t WAKEUP = (1U << 4);  ///< Wake Up Interrupt Disable
        constexpr uint32_t DNRSM = (1U << 5);  ///< DownStream to Device Interrupt Disable
        constexpr uint32_t UPRSM = (1U << 6);  ///< Upstream Resume from Device Interrupt Disable
        constexpr uint32_t RAMACER = (1U << 7);  ///< Ram Access Interrupt Disable
        constexpr uint32_t DCONN = (1U << 8);  ///< Device Connection Interrupt Disable
        constexpr uint32_t DDISC = (1U << 9);  ///< Device Disconnection Interrupt Disable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t HSOF = (1U << 2);  ///< Host Start Of Frame Interrupt Enable
        constexpr uint32_t RST = (1U << 3);  ///< Bus Reset Interrupt Enable
        constexpr uint32_t WAKEUP = (1U << 4);  ///< Wake Up Interrupt Enable
        constexpr uint32_t DNRSM = (1U << 5);  ///< DownStream to the Device Interrupt Enable
        constexpr uint32_t UPRSM = (1U << 6);  ///< Upstream Resume fromthe device Interrupt Enable
        constexpr uint32_t RAMACER = (1U << 7);  ///< Ram Access Interrupt Enable
        constexpr uint32_t DCONN = (1U << 8);  ///< Link Power Management Interrupt Enable
        constexpr uint32_t DDISC = (1U << 9);  ///< Device Disconnection Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t HSOF = (1U << 2);  ///< Host Start Of Frame
        constexpr uint32_t RST = (1U << 3);  ///< Bus Reset
        constexpr uint32_t WAKEUP = (1U << 4);  ///< Wake Up
        constexpr uint32_t DNRSM = (1U << 5);  ///< Downstream
        constexpr uint32_t UPRSM = (1U << 6);  ///< Upstream Resume from the Device
        constexpr uint32_t RAMACER = (1U << 7);  ///< Ram Access
        constexpr uint32_t DCONN = (1U << 8);  ///< Device Connection
        constexpr uint32_t DDISC = (1U << 9);  ///< Device Disconnection
    }

    /// EPINTSMRY Register bits
    namespace epintsmry_bits {
        constexpr uint32_t EPINT0 = (1U << 0);  ///< End Point 0 Interrupt
        constexpr uint32_t EPINT1 = (1U << 1);  ///< End Point 1 Interrupt
        constexpr uint32_t EPINT2 = (1U << 2);  ///< End Point 2 Interrupt
        constexpr uint32_t EPINT3 = (1U << 3);  ///< End Point 3 Interrupt
        constexpr uint32_t EPINT4 = (1U << 4);  ///< End Point 4 Interrupt
        constexpr uint32_t EPINT5 = (1U << 5);  ///< End Point 5 Interrupt
        constexpr uint32_t EPINT6 = (1U << 6);  ///< End Point 6 Interrupt
        constexpr uint32_t EPINT7 = (1U << 7);  ///< End Point 7 Interrupt
    }

    /// DESCADD Register bits
    namespace descadd_bits {
        constexpr uint32_t DESCADD = (32 << 0);  ///< Descriptor Address Value
    }

    /// PADCAL Register bits
    namespace padcal_bits {
        constexpr uint32_t TRANSP = (5 << 0);  ///< USB Pad Transp calibration
        constexpr uint32_t TRANSN = (5 << 6);  ///< USB Pad Transn calibration
        constexpr uint32_t TRIM = (3 << 12);  ///< USB Pad Trim calibration
    }

    /// EPCFG Register bits
    namespace epcfg_bits {
        constexpr uint32_t EPTYPE0 = (3 << 0);  ///< End Point Type0
        constexpr uint32_t EPTYPE1 = (3 << 4);  ///< End Point Type1
        constexpr uint32_t NYETDIS = (1U << 7);  ///< NYET Token Disable
    }

    /// EPSTATUSCLR Register bits
    namespace epstatusclr_bits {
        constexpr uint32_t DTGLOUT = (1U << 0);  ///< Data Toggle OUT Clear
        constexpr uint32_t DTGLIN = (1U << 1);  ///< Data Toggle IN Clear
        constexpr uint32_t CURBK = (1U << 2);  ///< Current Bank Clear
        constexpr uint32_t STALLRQ0 = (1U << 4);  ///< Stall 0 Request Clear
        constexpr uint32_t STALLRQ1 = (1U << 5);  ///< Stall 1 Request Clear
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 Ready Clear
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 Ready Clear
    }

    /// EPSTATUSSET Register bits
    namespace epstatusset_bits {
        constexpr uint32_t DTGLOUT = (1U << 0);  ///< Data Toggle OUT Set
        constexpr uint32_t DTGLIN = (1U << 1);  ///< Data Toggle IN Set
        constexpr uint32_t CURBK = (1U << 2);  ///< Current Bank Set
        constexpr uint32_t STALLRQ0 = (1U << 4);  ///< Stall 0 Request Set
        constexpr uint32_t STALLRQ1 = (1U << 5);  ///< Stall 1 Request Set
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 Ready Set
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 Ready Set
    }

    /// EPSTATUS Register bits
    namespace epstatus_bits {
        constexpr uint32_t DTGLOUT = (1U << 0);  ///< Data Toggle Out
        constexpr uint32_t DTGLIN = (1U << 1);  ///< Data Toggle In
        constexpr uint32_t CURBK = (1U << 2);  ///< Current Bank
        constexpr uint32_t STALLRQ0 = (1U << 4);  ///< Stall 0 Request
        constexpr uint32_t STALLRQ1 = (1U << 5);  ///< Stall 1 Request
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 ready
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 ready
    }

    /// EPINTFLAG Register bits
    namespace epintflag_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1
        constexpr uint32_t TRFAIL0 = (1U << 2);  ///< Error Flow 0
        constexpr uint32_t TRFAIL1 = (1U << 3);  ///< Error Flow 1
        constexpr uint32_t RXSTP = (1U << 4);  ///< Received Setup
        constexpr uint32_t STALL0 = (1U << 5);  ///< Stall 0 In/out
        constexpr uint32_t STALL1 = (1U << 6);  ///< Stall 1 In/out
    }

    /// EPINTENCLR Register bits
    namespace epintenclr_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0 Interrupt Disable
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1 Interrupt Disable
        constexpr uint32_t TRFAIL0 = (1U << 2);  ///< Error Flow 0 Interrupt Disable
        constexpr uint32_t TRFAIL1 = (1U << 3);  ///< Error Flow 1 Interrupt Disable
        constexpr uint32_t RXSTP = (1U << 4);  ///< Received Setup Interrupt Disable
        constexpr uint32_t STALL0 = (1U << 5);  ///< Stall 0 In/Out Interrupt Disable
        constexpr uint32_t STALL1 = (1U << 6);  ///< Stall 1 In/Out Interrupt Disable
    }

    /// EPINTENSET Register bits
    namespace epintenset_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0 Interrupt Enable
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1 Interrupt Enable
        constexpr uint32_t TRFAIL0 = (1U << 2);  ///< Error Flow 0 Interrupt Enable
        constexpr uint32_t TRFAIL1 = (1U << 3);  ///< Error Flow 1 Interrupt Enable
        constexpr uint32_t RXSTP = (1U << 4);  ///< Received Setup Interrupt Enable
        constexpr uint32_t STALL0 = (1U << 5);  ///< Stall 0 In/out Interrupt enable
        constexpr uint32_t STALL1 = (1U << 6);  ///< Stall 1 In/out Interrupt enable
    }

    /// HSOFC Register bits
    namespace hsofc_bits {
        constexpr uint32_t FLENC = (4 << 0);  ///< Frame Length Control
        constexpr uint32_t FLENCE = (1U << 7);  ///< Frame Length Control Enable
    }

    /// FLENHIGH Register bits
    namespace flenhigh_bits {
        constexpr uint32_t FLENHIGH = (8 << 0);  ///< Frame Length
    }

    /// PINTSMRY Register bits
    namespace pintsmry_bits {
        constexpr uint32_t EPINT0 = (1U << 0);  ///< Pipe 0 Interrupt
        constexpr uint32_t EPINT1 = (1U << 1);  ///< Pipe 1 Interrupt
        constexpr uint32_t EPINT2 = (1U << 2);  ///< Pipe 2 Interrupt
        constexpr uint32_t EPINT3 = (1U << 3);  ///< Pipe 3 Interrupt
        constexpr uint32_t EPINT4 = (1U << 4);  ///< Pipe 4 Interrupt
        constexpr uint32_t EPINT5 = (1U << 5);  ///< Pipe 5 Interrupt
        constexpr uint32_t EPINT6 = (1U << 6);  ///< Pipe 6 Interrupt
        constexpr uint32_t EPINT7 = (1U << 7);  ///< Pipe 7 Interrupt
    }

    /// PCFG Register bits
    namespace pcfg_bits {
        constexpr uint32_t PTOKEN = (2 << 0);  ///< Pipe Token
        constexpr uint32_t BK = (1U << 2);  ///< Pipe Bank
        constexpr uint32_t PTYPE = (3 << 3);  ///< Pipe Type
    }

    /// BINTERVAL Register bits
    namespace binterval_bits {
        constexpr uint32_t BITINTERVAL = (8 << 0);  ///< Bit Interval
    }

    /// PSTATUSCLR Register bits
    namespace pstatusclr_bits {
        constexpr uint32_t DTGL = (1U << 0);  ///< Data Toggle clear
        constexpr uint32_t CURBK = (1U << 2);  ///< Curren Bank clear
        constexpr uint32_t PFREEZE = (1U << 4);  ///< Pipe Freeze Clear
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 Ready Clear
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 Ready Clear
    }

    /// PSTATUSSET Register bits
    namespace pstatusset_bits {
        constexpr uint32_t DTGL = (1U << 0);  ///< Data Toggle Set
        constexpr uint32_t CURBK = (1U << 2);  ///< Current Bank Set
        constexpr uint32_t PFREEZE = (1U << 4);  ///< Pipe Freeze Set
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 Ready Set
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 Ready Set
    }

    /// PSTATUS Register bits
    namespace pstatus_bits {
        constexpr uint32_t DTGL = (1U << 0);  ///< Data Toggle
        constexpr uint32_t CURBK = (1U << 2);  ///< Current Bank
        constexpr uint32_t PFREEZE = (1U << 4);  ///< Pipe Freeze
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 ready
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 ready
    }

    /// PINTFLAG Register bits
    namespace pintflag_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0 Interrupt Flag
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1 Interrupt Flag
        constexpr uint32_t TRFAIL = (1U << 2);  ///< Error Flow Interrupt Flag
        constexpr uint32_t PERR = (1U << 3);  ///< Pipe Error Interrupt Flag
        constexpr uint32_t TXSTP = (1U << 4);  ///< Transmit Setup Interrupt Flag
        constexpr uint32_t STALL = (1U << 5);  ///< Stall Interrupt Flag
    }

    /// PINTENCLR Register bits
    namespace pintenclr_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0 Disable
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1 Disable
        constexpr uint32_t TRFAIL = (1U << 2);  ///< Error Flow Interrupt Disable
        constexpr uint32_t PERR = (1U << 3);  ///< Pipe Error Interrupt Disable
        constexpr uint32_t TXSTP = (1U << 4);  ///< Transmit Setup Interrupt Disable
        constexpr uint32_t STALL = (1U << 5);  ///< Stall Inetrrupt Disable
    }

    /// PINTENSET Register bits
    namespace pintenset_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0 Interrupt Enable
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1 Interrupt Enable
        constexpr uint32_t TRFAIL = (1U << 2);  ///< Error Flow Interrupt Enable
        constexpr uint32_t PERR = (1U << 3);  ///< Pipe Error Interrupt Enable
        constexpr uint32_t TXSTP = (1U << 4);  ///< Transmit Setup Interrupt Enable
        constexpr uint32_t STALL = (1U << 5);  ///< Stall Interrupt Enable
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40002000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control
        volatile uint32_t CONFIG;  ///< Offset: 0x01 - Configuration
        volatile uint32_t EWCTRL;  ///< Offset: 0x02 - Early Warning Interrupt Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x04 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x05 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x06 - Interrupt Flag Status and Clear
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x08 - Synchronization Busy
        volatile uint32_t CLEAR;  ///< Offset: 0x0C - Clear
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t WEN = (1U << 2);  ///< Watchdog Timer Window Mode Enable
        constexpr uint32_t ALWAYSON = (1U << 7);  ///< Always-On
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t PER = (4 << 0);  ///< Time-Out Period
        constexpr uint32_t WINDOW = (4 << 4);  ///< Window Mode Time-Out Period
    }

    /// EWCTRL Register bits
    namespace ewctrl_bits {
        constexpr uint32_t EWOFFSET = (4 << 0);  ///< Early Warning Interrupt Time Offset
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t EW = (1U << 0);  ///< Early Warning Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t EW = (1U << 0);  ///< Early Warning Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t EW = (1U << 0);  ///< Early Warning
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable Synchronization Busy
        constexpr uint32_t WEN = (1U << 2);  ///< Window Enable Synchronization Busy
        constexpr uint32_t ALWAYSON = (1U << 3);  ///< Always-On Synchronization Busy
        constexpr uint32_t CLEAR = (1U << 4);  ///< Clear Synchronization Busy
    }

    /// CLEAR Register bits
    namespace clear_bits {
        constexpr uint32_t CLEAR = (8 << 0);  ///< Watchdog Clear
    }

}

// ============================================================================
// CoreDebug Peripheral
// ============================================================================

namespace coredebug {
    /// Base addresses
    constexpr uint32_t CoreDebug_BASE = 0xE000EDF0;

    /// CoreDebug Register structure
    struct Registers {
        volatile uint32_t DHCSR;  ///< Offset: 0x00 - Debug Halting Control and Status Register
        volatile uint32_t DCRSR;  ///< Offset: 0x04 - Debug Core Register Selector Register
        volatile uint32_t DCRDR;  ///< Offset: 0x08 - Debug Core Register Data Register
        volatile uint32_t DEMCR;  ///< Offset: 0x0C - Debug Exception and Monitor Control Register
    };

    /// Peripheral instances
    inline Registers* CoreDebug = reinterpret_cast<Registers*>(CoreDebug_BASE);

    // Bit definitions
    /// DHCSR Register bits
    namespace dhcsr_bits {
        constexpr uint32_t C_DEBUGEN = (1U << 0);  ///< C_DEBUGEN
        constexpr uint32_t C_HALT = (1U << 1);  ///< C_HALT
        constexpr uint32_t C_STEP = (1U << 2);  ///< C_STEP
        constexpr uint32_t C_MASKINTS = (1U << 3);  ///< C_MASKINTS
        constexpr uint32_t C_SNAPSTALL = (1U << 5);  ///< C_SNAPSTALL
        constexpr uint32_t S_REGRDY = (1U << 16);  ///< S_REGRDY
        constexpr uint32_t S_HALT = (1U << 17);  ///< S_HALT
        constexpr uint32_t S_SLEEP = (1U << 18);  ///< S_SLEEP
        constexpr uint32_t S_LOCKUP = (1U << 19);  ///< S_LOCKUP
        constexpr uint32_t S_RETIRE_ST = (1U << 24);  ///< S_RETIRE_ST
        constexpr uint32_t S_RESET_ST = (1U << 25);  ///< S_RESET_ST
        constexpr uint32_t DBGKEY = (16 << 16);  ///< DBGKEY
    }

    /// DCRSR Register bits
    namespace dcrsr_bits {
        constexpr uint32_t REGSEL = (5 << 0);  ///< REGSEL
        constexpr uint32_t REGWnR = (1U << 16);  ///< REGWnR
    }

    /// DEMCR Register bits
    namespace demcr_bits {
        constexpr uint32_t VC_CORERESET = (1U << 0);  ///< VC_CORERESET
        constexpr uint32_t VC_MMERR = (1U << 4);  ///< VC_MMERR
        constexpr uint32_t VC_NOCPERR = (1U << 5);  ///< VC_NOCPERR
        constexpr uint32_t VC_CHKERR = (1U << 6);  ///< VC_CHKERR
        constexpr uint32_t VC_STATERR = (1U << 7);  ///< VC_STATERR
        constexpr uint32_t VC_BUSERR = (1U << 8);  ///< VC_BUSERR
        constexpr uint32_t VC_INTERR = (1U << 9);  ///< VC_INTERR
        constexpr uint32_t VC_HARDERR = (1U << 10);  ///< VC_HARDERR
        constexpr uint32_t MON_EN = (1U << 16);  ///< MON_EN
        constexpr uint32_t MON_PEND = (1U << 17);  ///< MON_PEND
        constexpr uint32_t MON_STEP = (1U << 18);  ///< MON_STEP
        constexpr uint32_t MON_REQ = (1U << 19);  ///< MON_REQ
        constexpr uint32_t TRCENA = (1U << 24);  ///< TRCENA
    }

}

// ============================================================================
// DWT Peripheral
// ============================================================================

namespace dwt {
    /// Base addresses
    constexpr uint32_t DWT_BASE = 0xE0001000;

    /// DWT Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t CYCCNT;  ///< Offset: 0x04 - Cycle Count Register
        volatile uint32_t CPICNT;  ///< Offset: 0x08 - CPI Count Register
        volatile uint32_t EXCCNT;  ///< Offset: 0x0C - Exception Overhead Count Register
        volatile uint32_t SLEEPCNT;  ///< Offset: 0x10 - Sleep Count Register
        volatile uint32_t LSUCNT;  ///< Offset: 0x14 - LSU Count Register
        volatile uint32_t FOLDCNT;  ///< Offset: 0x18 - Folded-instruction Count Register
        volatile uint32_t PCSR;  ///< Offset: 0x1C - Program Counter Sample Register
        volatile uint32_t COMP0;  ///< Offset: 0x20 - Comparator Register 0
        volatile uint32_t MASK0;  ///< Offset: 0x24 - Mask Register 0
        volatile uint32_t FUNCTION0;  ///< Offset: 0x28 - Function Register 0
        volatile uint32_t COMP1;  ///< Offset: 0x30 - Comparator Register 1
        volatile uint32_t MASK1;  ///< Offset: 0x34 - Mask Register 1
        volatile uint32_t FUNCTION1;  ///< Offset: 0x38 - Function Register 1
        volatile uint32_t COMP2;  ///< Offset: 0x40 - Comparator Register 2
        volatile uint32_t MASK2;  ///< Offset: 0x44 - Mask Register 2
        volatile uint32_t FUNCTION2;  ///< Offset: 0x48 - Function Register 2
        volatile uint32_t COMP3;  ///< Offset: 0x50 - Comparator Register 3
        volatile uint32_t MASK3;  ///< Offset: 0x54 - Mask Register 3
        volatile uint32_t FUNCTION3;  ///< Offset: 0x58 - Function Register 3
    };

    /// Peripheral instances
    inline Registers* DWT = reinterpret_cast<Registers*>(DWT_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t CYCCNTENA = (1U << 0);  ///< CYCCNTENA
        constexpr uint32_t POSTPRESET = (4 << 1);  ///< POSTPRESET
        constexpr uint32_t POSTINIT = (4 << 5);  ///< POSTINIT
        constexpr uint32_t CYCTAP = (1U << 9);  ///< CYCTAP
        constexpr uint32_t SYNCTAP = (2 << 10);  ///< SYNCTAP
        constexpr uint32_t PCSAMPLENA = (1U << 12);  ///< PCSAMPLENA
        constexpr uint32_t EXCTRCENA = (1U << 16);  ///< EXCTRCENA
        constexpr uint32_t CPIEVTENA = (1U << 17);  ///< CPIEVTENA
        constexpr uint32_t EXCEVTENA = (1U << 18);  ///< EXCEVTENA
        constexpr uint32_t SLEEPEVTENA = (1U << 19);  ///< SLEEPEVTENA
        constexpr uint32_t LSUEVTENA = (1U << 20);  ///< LSUEVTENA
        constexpr uint32_t FOLDEVTENA = (1U << 21);  ///< FOLDEVTENA
        constexpr uint32_t CYCEVTENA = (1U << 22);  ///< CYCEVTENA
        constexpr uint32_t NOPRFCNT = (1U << 24);  ///< NOPRFCNT
        constexpr uint32_t NOCYCCNT = (1U << 25);  ///< NOCYCCNT
        constexpr uint32_t NOEXTTRIG = (1U << 26);  ///< NOEXTTRIG
        constexpr uint32_t NOTRCPKT = (1U << 27);  ///< NOTRCPKT
        constexpr uint32_t NUMCOMP = (4 << 28);  ///< NUMCOMP
    }

    /// CPICNT Register bits
    namespace cpicnt_bits {
        constexpr uint32_t CPICNT = (8 << 0);  ///< CPICNT
    }

    /// EXCCNT Register bits
    namespace exccnt_bits {
        constexpr uint32_t EXCCNT = (8 << 0);  ///< EXCCNT
    }

    /// SLEEPCNT Register bits
    namespace sleepcnt_bits {
        constexpr uint32_t SLEEPCNT = (8 << 0);  ///< SLEEPCNT
    }

    /// LSUCNT Register bits
    namespace lsucnt_bits {
        constexpr uint32_t LSUCNT = (8 << 0);  ///< LSUCNT
    }

    /// FOLDCNT Register bits
    namespace foldcnt_bits {
        constexpr uint32_t FOLDCNT = (8 << 0);  ///< FOLDCNT
    }

    /// MASK0 Register bits
    namespace mask0_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< MASK
    }

    /// FUNCTION0 Register bits
    namespace function0_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< FUNCTION
        constexpr uint32_t EMITRANGE = (1U << 5);  ///< EMITRANGE
        constexpr uint32_t CYCMATCH = (1U << 7);  ///< CYCMATCH
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< DATAVMATCH
        constexpr uint32_t LNK1ENA = (1U << 9);  ///< LNK1ENA
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< DATAVSIZE
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< DATAVADDR0
        constexpr uint32_t DATAVADDR1 = (4 << 16);  ///< DATAVADDR1
        constexpr uint32_t MATCHED = (1U << 24);  ///< MATCHED
    }

    /// MASK1 Register bits
    namespace mask1_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< MASK
    }

    /// FUNCTION1 Register bits
    namespace function1_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< FUNCTION
        constexpr uint32_t EMITRANGE = (1U << 5);  ///< EMITRANGE
        constexpr uint32_t CYCMATCH = (1U << 7);  ///< CYCMATCH
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< DATAVMATCH
        constexpr uint32_t LNK1ENA = (1U << 9);  ///< LNK1ENA
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< DATAVSIZE
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< DATAVADDR0
        constexpr uint32_t DATAVADDR1 = (4 << 16);  ///< DATAVADDR1
        constexpr uint32_t MATCHED = (1U << 24);  ///< MATCHED
    }

    /// MASK2 Register bits
    namespace mask2_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< MASK
    }

    /// FUNCTION2 Register bits
    namespace function2_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< FUNCTION
        constexpr uint32_t EMITRANGE = (1U << 5);  ///< EMITRANGE
        constexpr uint32_t CYCMATCH = (1U << 7);  ///< CYCMATCH
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< DATAVMATCH
        constexpr uint32_t LNK1ENA = (1U << 9);  ///< LNK1ENA
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< DATAVSIZE
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< DATAVADDR0
        constexpr uint32_t DATAVADDR1 = (4 << 16);  ///< DATAVADDR1
        constexpr uint32_t MATCHED = (1U << 24);  ///< MATCHED
    }

    /// MASK3 Register bits
    namespace mask3_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< MASK
    }

    /// FUNCTION3 Register bits
    namespace function3_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< FUNCTION
        constexpr uint32_t EMITRANGE = (1U << 5);  ///< EMITRANGE
        constexpr uint32_t CYCMATCH = (1U << 7);  ///< CYCMATCH
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< DATAVMATCH
        constexpr uint32_t LNK1ENA = (1U << 9);  ///< LNK1ENA
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< DATAVSIZE
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< DATAVADDR0
        constexpr uint32_t DATAVADDR1 = (4 << 16);  ///< DATAVADDR1
        constexpr uint32_t MATCHED = (1U << 24);  ///< MATCHED
    }

}

// ============================================================================
// ETM Peripheral
// ============================================================================

namespace etm {
    /// Base addresses
    constexpr uint32_t ETM_BASE = 0xE0041000;

    /// ETM Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - ETM Main Control Register
        volatile uint32_t CCR;  ///< Offset: 0x04 - ETM Configuration Code Register
        volatile uint32_t TRIGGER;  ///< Offset: 0x08 - ETM Trigger Event Register
        volatile uint32_t SR;  ///< Offset: 0x10 - ETM Status Register
        volatile uint32_t SCR;  ///< Offset: 0x14 - ETM System Configuration Register
        volatile uint32_t TEEVR;  ///< Offset: 0x20 - ETM TraceEnable Event Register
        volatile uint32_t TECR1;  ///< Offset: 0x24 - ETM TraceEnable Control 1 Register
        volatile uint32_t FFLR;  ///< Offset: 0x28 - ETM FIFO Full Level Register
        volatile uint32_t CNTRLDVR1;  ///< Offset: 0x140 - ETM Free-running Counter Reload Value
        volatile uint32_t SYNCFR;  ///< Offset: 0x1E0 - ETM Synchronization Frequency Register
        volatile uint32_t IDR;  ///< Offset: 0x1E4 - ETM ID Register
        volatile uint32_t CCER;  ///< Offset: 0x1E8 - ETM Configuration Code Extension Register
        volatile uint32_t TESSEICR;  ///< Offset: 0x1F0 - ETM TraceEnable Start/Stop EmbeddedICE Control Register
        volatile uint32_t TSEVT;  ///< Offset: 0x1F8 - ETM TimeStamp Event Register
        volatile uint32_t TRACEIDR;  ///< Offset: 0x200 - ETM CoreSight Trace ID Register
        volatile uint32_t IDR2;  ///< Offset: 0x208 - ETM ID Register 2
        volatile uint32_t PDSR;  ///< Offset: 0x314 - ETM Device Power-Down Status Register
        volatile uint32_t ITMISCIN;  ///< Offset: 0xEE0 - ETM Integration Test Miscellaneous Inputs
        volatile uint32_t ITTRIGOUT;  ///< Offset: 0xEE8 - ETM Integration Test Trigger Out
        volatile uint32_t ITATBCTR2;  ///< Offset: 0xEF0 - ETM Integration Test ATB Control 2
        volatile uint32_t ITATBCTR0;  ///< Offset: 0xEF8 - ETM Integration Test ATB Control 0
        volatile uint32_t ITCTRL;  ///< Offset: 0xF00 - ETM Integration Mode Control Register
        volatile uint32_t CLAIMSET;  ///< Offset: 0xFA0 - ETM Claim Tag Set Register
        volatile uint32_t CLAIMCLR;  ///< Offset: 0xFA4 - ETM Claim Tag Clear Register
        volatile uint32_t LAR;  ///< Offset: 0xFB0 - ETM Lock Access Register
        volatile uint32_t LSR;  ///< Offset: 0xFB4 - ETM Lock Status Register
        volatile uint32_t AUTHSTATUS;  ///< Offset: 0xFB8 - ETM Authentication Status Register
        volatile uint32_t DEVTYPE;  ///< Offset: 0xFCC - ETM CoreSight Device Type Register
        volatile uint32_t PIDR4;  ///< Offset: 0xFD0 - ETM Peripheral Identification Register #4
        volatile uint32_t PIDR5;  ///< Offset: 0xFD4 - ETM Peripheral Identification Register #5
        volatile uint32_t PIDR6;  ///< Offset: 0xFD8 - ETM Peripheral Identification Register #6
        volatile uint32_t PIDR7;  ///< Offset: 0xFDC - ETM Peripheral Identification Register #7
        volatile uint32_t PIDR0;  ///< Offset: 0xFE0 - ETM Peripheral Identification Register #0
        volatile uint32_t PIDR1;  ///< Offset: 0xFE4 - ETM Peripheral Identification Register #1
        volatile uint32_t PIDR2;  ///< Offset: 0xFE8 - ETM Peripheral Identification Register #2
        volatile uint32_t PIDR3;  ///< Offset: 0xFEC - ETM Peripheral Identification Register #3
        volatile uint32_t CIDR0;  ///< Offset: 0xFF0 - ETM Component Identification Register #0
        volatile uint32_t CIDR1;  ///< Offset: 0xFF4 - ETM Component Identification Register #1
        volatile uint32_t CIDR2;  ///< Offset: 0xFF8 - ETM Component Identification Register #2
        volatile uint32_t CIDR3;  ///< Offset: 0xFFC - ETM Component Identification Register #3
    };

    /// Peripheral instances
    inline Registers* ETM = reinterpret_cast<Registers*>(ETM_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ETMPD = (1U << 0);  ///< ETM Power Down
        constexpr uint32_t PORTSIZE = (3 << 4);  ///< Port Size bits 2:0
        constexpr uint32_t STALL = (1U << 7);  ///< Stall Processor
        constexpr uint32_t BROUT = (1U << 8);  ///< Branch Output
        constexpr uint32_t DBGRQ = (1U << 9);  ///< Debug Request Control
        constexpr uint32_t PROG = (1U << 10);  ///< ETM Programming
        constexpr uint32_t PORTSEL = (1U << 11);  ///< ETM Port Select
        constexpr uint32_t PORTMODE2 = (1U << 13);  ///< Port Mode bit 2
        constexpr uint32_t PORTMODE = (2 << 16);  ///< Port Mode bits 1:0
        constexpr uint32_t PORTSIZE3 = (1U << 21);  ///< Port Size bit 3
        constexpr uint32_t TSEN = (1U << 28);  ///< TimeStamp Enable
    }

    /// ITCTRL Register bits
    namespace itctrl_bits {
        constexpr uint32_t INTEGRATION = (1U << 0);  ///< INTEGRATION
    }

    /// LSR Register bits
    namespace lsr_bits {
        constexpr uint32_t Present = (1U << 0);  ///< Present
        constexpr uint32_t Access = (1U << 1);  ///< Access
        constexpr uint32_t ByteAcc = (1U << 2);  ///< ByteAcc
    }

}

// ============================================================================
// FPU Peripheral
// ============================================================================

namespace fpu {
    /// Base addresses
    constexpr uint32_t FPU_BASE = 0xE000EF30;

    /// FPU Register structure
    struct Registers {
        volatile uint32_t FPCCR;  ///< Offset: 0x04 - Floating-Point Context Control Register
        volatile uint32_t FPCAR;  ///< Offset: 0x08 - Floating-Point Context Address Register
        volatile uint32_t FPDSCR;  ///< Offset: 0x0C - Floating-Point Default Status Control Register
        volatile uint32_t MVFR0;  ///< Offset: 0x10 - Media and FP Feature Register 0
        volatile uint32_t MVFR1;  ///< Offset: 0x14 - Media and FP Feature Register 1
    };

    /// Peripheral instances
    inline Registers* FPU = reinterpret_cast<Registers*>(FPU_BASE);

    // Bit definitions
    /// FPCCR Register bits
    namespace fpccr_bits {
        constexpr uint32_t LSPACT = (1U << 0);  ///< LSPACT
        constexpr uint32_t USER = (1U << 1);  ///< USER
        constexpr uint32_t THREAD = (1U << 3);  ///< THREAD
        constexpr uint32_t HFRDY = (1U << 4);  ///< HFRDY
        constexpr uint32_t MMRDY = (1U << 5);  ///< MMRDY
        constexpr uint32_t BFRDY = (1U << 6);  ///< BFRDY
        constexpr uint32_t MONRDY = (1U << 8);  ///< MONRDY
        constexpr uint32_t LSPEN = (1U << 30);  ///< LSPEN
        constexpr uint32_t ASPEN = (1U << 31);  ///< ASPEN
    }

    /// FPCAR Register bits
    namespace fpcar_bits {
        constexpr uint32_t ADDRESS = (29 << 3);  ///< Address for FP registers in exception stack frame
    }

    /// FPDSCR Register bits
    namespace fpdscr_bits {
        constexpr uint32_t RMODE = (2 << 22);  ///< Default value for FPSCR.RMODE
        constexpr uint32_t FZ = (1U << 24);  ///< Default value for FPSCR.FZ
        constexpr uint32_t DN = (1U << 25);  ///< Default value for FPSCR.DN
        constexpr uint32_t AHP = (1U << 26);  ///< Default value for FPSCR.AHP
    }

    /// MVFR0 Register bits
    namespace mvfr0_bits {
        constexpr uint32_t A_SIMD_registers = (4 << 0);  ///< A_SIMD_registers
        constexpr uint32_t Single_precision = (4 << 4);  ///< Single_precision
        constexpr uint32_t Double_precision = (4 << 8);  ///< Double_precision
        constexpr uint32_t FP_excep_trapping = (4 << 12);  ///< FP_excep_trapping
        constexpr uint32_t Divide = (4 << 16);  ///< Divide
        constexpr uint32_t Square_root = (4 << 20);  ///< Square_root
        constexpr uint32_t Short_vectors = (4 << 24);  ///< Short_vectors
        constexpr uint32_t FP_rounding_modes = (4 << 28);  ///< FP_rounding_modes
    }

    /// MVFR1 Register bits
    namespace mvfr1_bits {
        constexpr uint32_t FtZ_mode = (4 << 0);  ///< FtZ_mode
        constexpr uint32_t D_NaN_mode = (4 << 4);  ///< D_NaN_mode
        constexpr uint32_t FP_HPFP = (4 << 24);  ///< FP_HPFP
        constexpr uint32_t FP_fused_MAC = (4 << 28);  ///< FP_fused_MAC
    }

}

// ============================================================================
// ITM Peripheral
// ============================================================================

namespace itm {
    /// Base addresses
    constexpr uint32_t ITM_BASE = 0xE0000000;

    /// ITM Register structure
    struct Registers {
        volatile uint32_t PORT_WORD_MODE__;  ///< Offset: 0x00 - ITM Stimulus Port Registers (renamed from PORT_WORD_MODE__)
        volatile uint32_t PORT_BYTE_MODE__;  ///< Offset: 0x00 - ITM Stimulus Port Registers (renamed from PORT_BYTE_MODE__)
        volatile uint32_t PORT_HWORD_MODE__;  ///< Offset: 0x00 - ITM Stimulus Port Registers (renamed from PORT_HWORD_MODE__)
        volatile uint32_t TER;  ///< Offset: 0xE00 - ITM Trace Enable Register
        volatile uint32_t TPR;  ///< Offset: 0xE40 - ITM Trace Privilege Register
        volatile uint32_t TCR;  ///< Offset: 0xE80 - ITM Trace Control Register
        volatile uint32_t IWR;  ///< Offset: 0xEF8 - ITM Integration Write Register
        volatile uint32_t IRR;  ///< Offset: 0xEFC - ITM Integration Read Register
    };

    /// Peripheral instances
    inline Registers* ITM = reinterpret_cast<Registers*>(ITM_BASE);

    // Bit definitions
    /// PORT_WORD_MODE__ Register bits
    namespace port_word_mode___bits {
        constexpr uint32_t PORT = (32 << 0);  ///< PORT
    }

    /// PORT_BYTE_MODE__ Register bits
    namespace port_byte_mode___bits {
        constexpr uint32_t PORT = (8 << 0);  ///< PORT
    }

    /// PORT_HWORD_MODE__ Register bits
    namespace port_hword_mode___bits {
        constexpr uint32_t PORT = (16 << 0);  ///< PORT
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t PRIVMASK = (4 << 0);  ///< PRIVMASK
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t ITMENA = (1U << 0);  ///< ITMENA
        constexpr uint32_t TSENA = (1U << 1);  ///< TSENA
        constexpr uint32_t SYNCENA = (1U << 2);  ///< SYNCENA
        constexpr uint32_t DWTENA = (1U << 3);  ///< DWTENA
        constexpr uint32_t SWOENA = (1U << 4);  ///< SWOENA
        constexpr uint32_t STALLENA = (1U << 5);  ///< STALLENA
        constexpr uint32_t TSPrescale = (2 << 8);  ///< TSPrescale
        constexpr uint32_t GTSFREQ = (2 << 10);  ///< GTSFREQ
        constexpr uint32_t TraceBusID = (7 << 16);  ///< TraceBusID
        constexpr uint32_t BUSY = (1U << 23);  ///< BUSY
    }

    /// IWR Register bits
    namespace iwr_bits {
        constexpr uint32_t ATVALIDM = (1U << 0);  ///< ATVALIDM
    }

    /// IRR Register bits
    namespace irr_bits {
        constexpr uint32_t ATREADYM = (1U << 0);  ///< ATREADYM
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0xE000ED90;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t TYPE;  ///< Offset: 0x00 - MPU Type Register
        volatile uint32_t CTRL;  ///< Offset: 0x04 - MPU Control Register
        volatile uint32_t RNR;  ///< Offset: 0x08 - MPU Region Number Register
        volatile uint32_t RBAR;  ///< Offset: 0x0C - MPU Region Base Address Register
        volatile uint32_t RASR;  ///< Offset: 0x10 - MPU Region Attribute and Size Register
        volatile uint32_t RBAR_A1;  ///< Offset: 0x14 - MPU Alias 1 Region Base Address Register
        volatile uint32_t RASR_A1;  ///< Offset: 0x18 - MPU Alias 1 Region Attribute and Size Register
        volatile uint32_t RBAR_A2;  ///< Offset: 0x1C - MPU Alias 2 Region Base Address Register
        volatile uint32_t RASR_A2;  ///< Offset: 0x20 - MPU Alias 2 Region Attribute and Size Register
        volatile uint32_t RBAR_A3;  ///< Offset: 0x24 - MPU Alias 3 Region Base Address Register
        volatile uint32_t RASR_A3;  ///< Offset: 0x28 - MPU Alias 3 Region Attribute and Size Register
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// TYPE Register bits
    namespace type_bits {
        constexpr uint32_t SEPARATE = (1U << 0);  ///< Separate instruction and Data Memory MapsRegions
        constexpr uint32_t DREGION = (8 << 8);  ///< Number of Data Regions
        constexpr uint32_t IREGION = (8 << 16);  ///< Number of Instruction Regions
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< MPU Enable
        constexpr uint32_t HFNMIENA = (1U << 1);  ///< Enable Hard Fault and NMI handlers
        constexpr uint32_t PRIVDEFENA = (1U << 2);  ///< Enables privileged software access to default memory map
    }

    /// RNR Register bits
    namespace rnr_bits {
        constexpr uint32_t REGION = (8 << 0);  ///< Region referenced by RBAR and RASR
    }

    /// RBAR Register bits
    namespace rbar_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< Region number
        constexpr uint32_t VALID = (1U << 4);  ///< Region number valid
        constexpr uint32_t ADDR = (27 << 5);  ///< Region base address
    }

    /// RASR Register bits
    namespace rasr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region Enable
        constexpr uint32_t SIZE = (1U << 1);  ///< Region Size
        constexpr uint32_t SRD = (8 << 8);  ///< Sub-region disable
        constexpr uint32_t B = (1U << 16);  ///< Bufferable bit
        constexpr uint32_t C = (1U << 17);  ///< Cacheable bit
        constexpr uint32_t S = (1U << 18);  ///< Shareable bit
        constexpr uint32_t TEX = (3 << 19);  ///< TEX bit
        constexpr uint32_t AP = (3 << 24);  ///< Access Permission
        constexpr uint32_t XN = (1U << 28);  ///< Execute Never Attribute
    }

    /// RBAR_A1 Register bits
    namespace rbar_a1_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< Region number
        constexpr uint32_t VALID = (1U << 4);  ///< Region number valid
        constexpr uint32_t ADDR = (27 << 5);  ///< Region base address
    }

    /// RASR_A1 Register bits
    namespace rasr_a1_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region Enable
        constexpr uint32_t SIZE = (1U << 1);  ///< Region Size
        constexpr uint32_t SRD = (8 << 8);  ///< Sub-region disable
        constexpr uint32_t B = (1U << 16);  ///< Bufferable bit
        constexpr uint32_t C = (1U << 17);  ///< Cacheable bit
        constexpr uint32_t S = (1U << 18);  ///< Shareable bit
        constexpr uint32_t TEX = (3 << 19);  ///< TEX bit
        constexpr uint32_t AP = (3 << 24);  ///< Access Permission
        constexpr uint32_t XN = (1U << 28);  ///< Execute Never Attribute
    }

    /// RBAR_A2 Register bits
    namespace rbar_a2_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< Region number
        constexpr uint32_t VALID = (1U << 4);  ///< Region number valid
        constexpr uint32_t ADDR = (27 << 5);  ///< Region base address
    }

    /// RASR_A2 Register bits
    namespace rasr_a2_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region Enable
        constexpr uint32_t SIZE = (1U << 1);  ///< Region Size
        constexpr uint32_t SRD = (8 << 8);  ///< Sub-region disable
        constexpr uint32_t B = (1U << 16);  ///< Bufferable bit
        constexpr uint32_t C = (1U << 17);  ///< Cacheable bit
        constexpr uint32_t S = (1U << 18);  ///< Shareable bit
        constexpr uint32_t TEX = (3 << 19);  ///< TEX bit
        constexpr uint32_t AP = (3 << 24);  ///< Access Permission
        constexpr uint32_t XN = (1U << 28);  ///< Execute Never Attribute
    }

    /// RBAR_A3 Register bits
    namespace rbar_a3_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< Region number
        constexpr uint32_t VALID = (1U << 4);  ///< Region number valid
        constexpr uint32_t ADDR = (27 << 5);  ///< Region base address
    }

    /// RASR_A3 Register bits
    namespace rasr_a3_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region Enable
        constexpr uint32_t SIZE = (1U << 1);  ///< Region Size
        constexpr uint32_t SRD = (8 << 8);  ///< Sub-region disable
        constexpr uint32_t B = (1U << 16);  ///< Bufferable bit
        constexpr uint32_t C = (1U << 17);  ///< Cacheable bit
        constexpr uint32_t S = (1U << 18);  ///< Shareable bit
        constexpr uint32_t TEX = (3 << 19);  ///< TEX bit
        constexpr uint32_t AP = (3 << 24);  ///< Access Permission
        constexpr uint32_t XN = (1U << 28);  ///< Execute Never Attribute
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t ISER__;  ///< Offset: 0x00 - Interrupt Set Enable Register (renamed from ISER__)
        volatile uint32_t ICER__;  ///< Offset: 0x80 - Interrupt Clear Enable Register (renamed from ICER__)
        volatile uint32_t ISPR__;  ///< Offset: 0x100 - Interrupt Set Pending Register (renamed from ISPR__)
        volatile uint32_t ICPR__;  ///< Offset: 0x180 - Interrupt Clear Pending Register (renamed from ICPR__)
        volatile uint32_t IABR__;  ///< Offset: 0x200 - Interrupt Active Bit Register (renamed from IABR__)
        volatile uint32_t IP__;  ///< Offset: 0x300 - Interrupt Priority Register n (renamed from IP__)
        volatile uint32_t STIR;  ///< Offset: 0xE00 - Software Trigger Interrupt Register
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

    // Bit definitions
    /// ISER__ Register bits
    namespace iser___bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// ICER__ Register bits
    namespace icer___bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// ISPR__ Register bits
    namespace ispr___bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// ICPR__ Register bits
    namespace icpr___bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// IABR__ Register bits
    namespace iabr___bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active bits
    }

    /// IP__ Register bits
    namespace ip___bits {
        constexpr uint32_t PRI0 = (3 << 0);  ///< Priority of interrupt n
    }

    /// STIR Register bits
    namespace stir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< Interrupt ID to trigger
    }

}

// ============================================================================
// SysTick Peripheral
// ============================================================================

namespace systick {
    /// Base addresses
    constexpr uint32_t SysTick_BASE = 0xE000E010;

    /// SysTick Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - SysTick Control and Status Register
        volatile uint32_t RVR;  ///< Offset: 0x04 - SysTick Reload Value Register
        volatile uint32_t CVR;  ///< Offset: 0x08 - SysTick Current Value Register
        volatile uint32_t CALIB;  ///< Offset: 0x0C - SysTick Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* SysTick = reinterpret_cast<Registers*>(SysTick_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< SysTick Counter Enable
        constexpr uint32_t TICKINT = (1U << 1);  ///< SysTick Exception Request Enable
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< Clock Source 0=external, 1=processor
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< Timer counted to 0 since last read of register
    }

    /// RVR Register bits
    namespace rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Value to load into the SysTick Current Value Register when the counter reaches 0
    }

    /// CVR Register bits
    namespace cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current value at the time the register is accessed
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Reload value to use for 10ms timing
        constexpr uint32_t SKEW = (1U << 30);  ///< TENMS is rounded from non-integer ratio
        constexpr uint32_t NOREF = (1U << 31);  ///< No Separate Reference Clock
    }

}

// ============================================================================
// SystemControl Peripheral
// ============================================================================

namespace systemcontrol {
    /// Base addresses
    constexpr uint32_t SystemControl_BASE = 0xE000E000;

    /// SystemControl Register structure
    struct Registers {
        volatile uint32_t ICTR;  ///< Offset: 0x04 - Interrupt Controller Type Register
        volatile uint32_t ACTLR;  ///< Offset: 0x08 - Auxiliary Control Register
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control and State Register
        volatile uint32_t VTOR;  ///< Offset: 0xD08 - Vector Table Offset Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt and Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration and Control Register
        volatile uint32_t SHPR1;  ///< Offset: 0xD18 - System Handler Priority Register 1
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
        volatile uint32_t CFSR;  ///< Offset: 0xD28 - Configurable Fault Status Register
        volatile uint32_t HFSR;  ///< Offset: 0xD2C - HardFault Status Register
        volatile uint32_t DFSR;  ///< Offset: 0xD30 - Debug Fault Status Register
        volatile uint32_t MMFAR;  ///< Offset: 0xD34 - MemManage Fault Address Register
        volatile uint32_t BFAR;  ///< Offset: 0xD38 - BusFault Address Register
        volatile uint32_t AFSR;  ///< Offset: 0xD3C - Auxiliary Fault Status Register
        volatile uint32_t PFR__;  ///< Offset: 0xD40 - Processor Feature Register (renamed from PFR__)
        volatile uint32_t DFR;  ///< Offset: 0xD48 - Debug Feature Register
        volatile uint32_t ADR;  ///< Offset: 0xD4C - Auxiliary Feature Register
        volatile uint32_t MMFR__;  ///< Offset: 0xD50 - Memory Model Feature Register (renamed from MMFR__)
        volatile uint32_t ISAR__;  ///< Offset: 0xD60 - Instruction Set Attributes Register (renamed from ISAR__)
        volatile uint32_t CPACR;  ///< Offset: 0xD88 - Coprocessor Access Control Register
    };

    /// Peripheral instances
    inline Registers* SystemControl = reinterpret_cast<Registers*>(SystemControl_BASE);

    // Bit definitions
    /// ICTR Register bits
    namespace ictr_bits {
        constexpr uint32_t INTLINESNUM = (4 << 0);  ///< INTLINESNUM
    }

    /// ACTLR Register bits
    namespace actlr_bits {
        constexpr uint32_t DISMCYCINT = (1U << 0);  ///< Disable interruption of LDM/STM instructions
        constexpr uint32_t DISDEFWBUF = (1U << 1);  ///< Disable wruite buffer use during default memory map accesses
        constexpr uint32_t DISFOLD = (1U << 2);  ///< Disable IT folding
        constexpr uint32_t DISFPCA = (1U << 8);  ///< Disable automatic update of CONTROL.FPCA
        constexpr uint32_t DISOOFP = (1U << 9);  ///< Disable out-of-order FP instructions
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t REVISION = (4 << 0);  ///< Processor revision number
        constexpr uint32_t PARTNO = (12 << 4);  ///< Process Part Number, 0xC24=Cortex-M4
        constexpr uint32_t CONSTANT = (4 << 16);  ///< Constant
        constexpr uint32_t VARIANT = (4 << 20);  ///< Variant number
        constexpr uint32_t IMPLEMENTER = (8 << 24);  ///< Implementer code, 0x41=ARM
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active exception number
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< No preempted active exceptions to execute
        constexpr uint32_t VECTPENDING = (6 << 12);  ///< Exception number of the highest priority pending enabled exception
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag
        constexpr uint32_t ISRPREEMPT = (1U << 23);  ///< Debug only
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick clear-pending bit
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick set-pending bit
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV clear-pending bit
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV set-pending bit
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI set-pending bit
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (25 << 7);  ///< Vector table base offset
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTRESET = (1U << 0);  ///< Must write 0
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< Must write 0
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< System Reset Request
        constexpr uint32_t PRIGROUP = (3 << 8);  ///< Interrupt priority grouping
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< Data endianness, 0=little, 1=big
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< Sleep-on-exit on handler return
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< Deep Sleep used as low power mode
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< Send Event on Pending bit
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< Indicates how processor enters Thread mode
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< Enables unprivileged software access to STIR register
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Enables unaligned access traps
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< Enables divide by 0 trap
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< Ignore LDM/STM BusFault for -1/-2 priority handlers
        constexpr uint32_t STKALIGN = (1U << 9);  ///< Indicates stack alignment on exception entry
    }

    /// SHPR1 Register bits
    namespace shpr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of system handler 4, MemManage
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of system handler 5, BusFault
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of system handler 6, UsageFault
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11, SVCall
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14, PendSV
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15, SysTick exception
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t MEMFAULTACT = (1U << 0);  ///< MemManage exception active bit
        constexpr uint32_t BUSFAULTACT = (1U << 1);  ///< BusFault exception active bit
        constexpr uint32_t USGFAULTACT = (1U << 3);  ///< UsageFault exception active bit
        constexpr uint32_t SVCALLACT = (1U << 7);  ///< SVCall active bit
        constexpr uint32_t MONITORACT = (1U << 8);  ///< DebugMonitor exception active bit
        constexpr uint32_t PENDSVACT = (1U << 10);  ///< PendSV exception active bit
        constexpr uint32_t SYSTICKACT = (1U << 11);  ///< SysTick exception active bit
        constexpr uint32_t USGFAULTPENDED = (1U << 12);  ///< UsageFault exception pending bit
        constexpr uint32_t MEMFAULTPENDED = (1U << 13);  ///< MemManage exception pending bit
        constexpr uint32_t BUSFAULTPENDED = (1U << 14);  ///< BusFault exception pending bit
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVCall pending bit
        constexpr uint32_t MEMFAULTENA = (1U << 16);  ///< MemManage enable bit
        constexpr uint32_t BUSFAULTENA = (1U << 17);  ///< BusFault enable bit
        constexpr uint32_t USGFAULTENA = (1U << 18);  ///< UsageFault enable bit
    }

    /// CFSR Register bits
    namespace cfsr_bits {
        constexpr uint32_t IACCVIOL = (1U << 0);  ///< Instruction access violation
        constexpr uint32_t DACCVIOL = (1U << 1);  ///< Data access violation
        constexpr uint32_t MUNSTKERR = (1U << 3);  ///< MemManage Fault on unstacking for exception return
        constexpr uint32_t MSTKERR = (1U << 4);  ///< MemManage Fault on stacking for exception entry
        constexpr uint32_t MLSPERR = (1U << 5);  ///< MemManager Fault occured during FP lazy state preservation
        constexpr uint32_t MMARVALID = (1U << 7);  ///< MemManage Fault Address Register valid
        constexpr uint32_t IBUSERR = (1U << 8);  ///< Instruction bus error
        constexpr uint32_t PRECISERR = (1U << 9);  ///< Precise data bus error
        constexpr uint32_t IMPRECISERR = (1U << 10);  ///< Imprecise data bus error
        constexpr uint32_t UNSTKERR = (1U << 11);  ///< BusFault on unstacking for exception return
        constexpr uint32_t STKERR = (1U << 12);  ///< BusFault on stacking for exception entry
        constexpr uint32_t LSPERR = (1U << 13);  ///< BusFault occured during FP lazy state preservation
        constexpr uint32_t BFARVALID = (1U << 15);  ///< BusFault Address Register valid
        constexpr uint32_t UNDEFINSTR = (1U << 16);  ///< Undefined instruction UsageFault
        constexpr uint32_t INVSTATE = (1U << 17);  ///< Invalid state UsageFault
        constexpr uint32_t INVPC = (1U << 18);  ///< Invalid PC load UsageFault
        constexpr uint32_t NOCP = (1U << 19);  ///< No coprocessor UsageFault
        constexpr uint32_t UNALIGNED = (1U << 24);  ///< Unaligned access UsageFault
        constexpr uint32_t DIVBYZERO = (1U << 25);  ///< Divide by zero UsageFault
    }

    /// HFSR Register bits
    namespace hfsr_bits {
        constexpr uint32_t VECTTBL = (1U << 1);  ///< BusFault on a Vector Table read during exception processing
        constexpr uint32_t FORCED = (1U << 30);  ///< Forced Hard Fault
        constexpr uint32_t DEBUGEVT = (1U << 31);  ///< Debug: always write 0
    }

    /// DFSR Register bits
    namespace dfsr_bits {
        constexpr uint32_t HALTED = (1U << 0);  ///< HALTED
        constexpr uint32_t BKPT = (1U << 1);  ///< BKPT
        constexpr uint32_t DWTTRAP = (1U << 2);  ///< DWTTRAP
        constexpr uint32_t VCATCH = (1U << 3);  ///< VCATCH
        constexpr uint32_t EXTERNAL = (1U << 4);  ///< EXTERNAL
    }

    /// MMFAR Register bits
    namespace mmfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address that generated the MemManage fault
    }

    /// BFAR Register bits
    namespace bfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address that generated the BusFault
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t IMPDEF = (32 << 0);  ///< AUXFAULT input signals
    }

    /// CPACR Register bits
    namespace cpacr_bits {
        constexpr uint32_t CP10 = (2 << 20);  ///< Access privileges for coprocessor 10
        constexpr uint32_t CP11 = (2 << 22);  ///< Access privileges for coprocessor 11
    }

}

// ============================================================================
// TPI Peripheral
// ============================================================================

namespace tpi {
    /// Base addresses
    constexpr uint32_t TPI_BASE = 0xE0040000;

    /// TPI Register structure
    struct Registers {
        volatile uint32_t SSPSR;  ///< Offset: 0x00 - Supported Parallel Port Size Register
        volatile uint32_t CSPSR;  ///< Offset: 0x04 - Current Parallel Port Size Register
        volatile uint32_t ACPR;  ///< Offset: 0x10 - Asynchronous Clock Prescaler Register
        volatile uint32_t SPPR;  ///< Offset: 0xF0 - Selected Pin Protocol Register
        volatile uint32_t FFSR;  ///< Offset: 0x300 - Formatter and Flush Status Register
        volatile uint32_t FFCR;  ///< Offset: 0x304 - Formatter and Flush Control Register
        volatile uint32_t FSCR;  ///< Offset: 0x308 - Formatter Synchronization Counter Register
        volatile uint32_t TRIGGER;  ///< Offset: 0xEE8 - TRIGGER
        volatile uint32_t FIFO0;  ///< Offset: 0xEEC - Integration ETM Data
        volatile uint32_t ITATBCTR2;  ///< Offset: 0xEF0 - ITATBCTR2
        volatile uint32_t ITATBCTR0;  ///< Offset: 0xEF8 - ITATBCTR0
        volatile uint32_t FIFO1;  ///< Offset: 0xEFC - Integration ITM Data
        volatile uint32_t ITCTRL;  ///< Offset: 0xF00 - Integration Mode Control
        volatile uint32_t CLAIMSET;  ///< Offset: 0xFA0 - Claim tag set
        volatile uint32_t CLAIMCLR;  ///< Offset: 0xFA4 - Claim tag clear
        volatile uint32_t DEVID;  ///< Offset: 0xFC8 - TPIU_DEVID
        volatile uint32_t DEVTYPE;  ///< Offset: 0xFCC - TPIU_DEVTYPE
    };

    /// Peripheral instances
    inline Registers* TPI = reinterpret_cast<Registers*>(TPI_BASE);

    // Bit definitions
    /// ACPR Register bits
    namespace acpr_bits {
        constexpr uint32_t PRESCALER = (13 << 0);  ///< PRESCALER
    }

    /// SPPR Register bits
    namespace sppr_bits {
        constexpr uint32_t TXMODE = (2 << 0);  ///< TXMODE
    }

    /// FFSR Register bits
    namespace ffsr_bits {
        constexpr uint32_t FlInProg = (1U << 0);  ///< FlInProg
        constexpr uint32_t FtStopped = (1U << 1);  ///< FtStopped
        constexpr uint32_t TCPresent = (1U << 2);  ///< TCPresent
        constexpr uint32_t FtNonStop = (1U << 3);  ///< FtNonStop
    }

    /// FFCR Register bits
    namespace ffcr_bits {
        constexpr uint32_t EnFCont = (1U << 1);  ///< EnFCont
        constexpr uint32_t TrigIn = (1U << 8);  ///< TrigIn
    }

    /// TRIGGER Register bits
    namespace trigger_bits {
        constexpr uint32_t TRIGGER = (1U << 0);  ///< TRIGGER
    }

    /// FIFO0 Register bits
    namespace fifo0_bits {
        constexpr uint32_t ETM0 = (8 << 0);  ///< ETM0
        constexpr uint32_t ETM1 = (8 << 8);  ///< ETM1
        constexpr uint32_t ETM2 = (8 << 16);  ///< ETM2
        constexpr uint32_t ETM_bytecount = (2 << 24);  ///< ETM_bytecount
        constexpr uint32_t ETM_ATVALID = (1U << 26);  ///< ETM_ATVALID
        constexpr uint32_t ITM_bytecount = (2 << 27);  ///< ITM_bytecount
        constexpr uint32_t ITM_ATVALID = (1U << 29);  ///< ITM_ATVALID
    }

    /// ITATBCTR2 Register bits
    namespace itatbctr2_bits {
        constexpr uint32_t ATREADY = (1U << 0);  ///< ATREADY
    }

    /// ITATBCTR0 Register bits
    namespace itatbctr0_bits {
        constexpr uint32_t ATREADY = (1U << 0);  ///< ATREADY
    }

    /// FIFO1 Register bits
    namespace fifo1_bits {
        constexpr uint32_t ITM0 = (8 << 0);  ///< ITM0
        constexpr uint32_t ITM1 = (8 << 8);  ///< ITM1
        constexpr uint32_t ITM2 = (8 << 16);  ///< ITM2
        constexpr uint32_t ETM_bytecount = (2 << 24);  ///< ETM_bytecount
        constexpr uint32_t ETM_ATVALID = (1U << 26);  ///< ETM_ATVALID
        constexpr uint32_t ITM_bytecount = (2 << 27);  ///< ITM_bytecount
        constexpr uint32_t ITM_ATVALID = (1U << 29);  ///< ITM_ATVALID
    }

    /// ITCTRL Register bits
    namespace itctrl_bits {
        constexpr uint32_t Mode = (1U << 0);  ///< Mode
    }

    /// DEVID Register bits
    namespace devid_bits {
        constexpr uint32_t NrTraceInput = (1U << 0);  ///< NrTraceInput
        constexpr uint32_t AsynClkIn = (1U << 5);  ///< AsynClkIn
        constexpr uint32_t MinBufSz = (3 << 6);  ///< MinBufSz
        constexpr uint32_t PTINVALID = (1U << 9);  ///< PTINVALID
        constexpr uint32_t MANCVALID = (1U << 10);  ///< MANCVALID
        constexpr uint32_t NRZVALID = (1U << 11);  ///< NRZVALID
    }

    /// DEVTYPE Register bits
    namespace devtype_bits {
        constexpr uint32_t SubType = (4 << 0);  ///< SubType
        constexpr uint32_t MajorType = (4 << 4);  ///< MajorType
    }

}


} // namespace alloy::generated::atsame53n19a

#endif // ALLOY_GENERATED_ATSAME53N19A_PERIPHERALS_HPP