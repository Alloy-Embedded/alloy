/// Auto-generated code for ATSAMD21J18A
/// Generated by Alloy Code Generator
/// Source: atmel_samd.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:33
#ifndef ALLOY_GENERATED_ATSAMD21J18A_PERIPHERALS_HPP
#define ALLOY_GENERATED_ATSAMD21J18A_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::atsamd21j18a {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_ac = true;
    constexpr uint32_t num_ac_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_dsu = true;
    constexpr uint32_t num_dsu_instances = 1;
    constexpr bool has_eic = true;
    constexpr uint32_t num_eic_instances = 1;
    constexpr bool has_evsys = true;
    constexpr uint32_t num_evsys_instances = 1;
    constexpr bool has_gclk = true;
    constexpr uint32_t num_gclk_instances = 1;
    constexpr bool has_hmatrix = true;
    constexpr uint32_t num_hmatrix_instances = 1;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_mtb = true;
    constexpr uint32_t num_mtb_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_pac0 = true;
    constexpr uint32_t num_pac0_instances = 1;
    constexpr bool has_pac1 = true;
    constexpr uint32_t num_pac1_instances = 1;
    constexpr bool has_pac2 = true;
    constexpr uint32_t num_pac2_instances = 1;
    constexpr bool has_pm = true;
    constexpr uint32_t num_pm_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 2;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_sercom = true;
    constexpr uint32_t num_sercom_instances = 6;
    constexpr bool has_sysctrl = true;
    constexpr uint32_t num_sysctrl_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 8;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct ac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dsu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct evsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gclk_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hmatrix_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pac0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pac1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pac2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sercom_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct sysctrl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 2;
    constexpr uint32_t max_gpio_pins = 32;  // 16 pins per port

    // USART-specific traits
}

// ============================================================================
// AC Peripheral
// ============================================================================

namespace ac {
    /// Base addresses
    constexpr uint32_t AC_BASE = 0x42004400;

    /// AC Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x01 - Control B
        volatile uint32_t EVCTRL;  ///< Offset: 0x02 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x04 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x05 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x06 - Interrupt Flag Status and Clear
        volatile uint32_t STATUSA;  ///< Offset: 0x08 - Status A
        volatile uint32_t STATUSB;  ///< Offset: 0x09 - Status B
        volatile uint32_t STATUSC;  ///< Offset: 0x0A - Status C
        volatile uint32_t WINCTRL;  ///< Offset: 0x0C - Window Control
        volatile uint32_t COMPCTRL%s;  ///< Offset: 0x10 - Comparator Control n
        volatile uint32_t SCALER%s;  ///< Offset: 0x20 - Scaler n
    };

    /// Peripheral instances
    inline Registers* AC = reinterpret_cast<Registers*>(AC_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t RUNSTDBY = (1U << 2);  ///< Run in Standby
        constexpr uint32_t LPMUX = (1U << 7);  ///< Low-Power Mux
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t START0 = (1U << 0);  ///< Comparator 0 Start Comparison
        constexpr uint32_t START1 = (1U << 1);  ///< Comparator 1 Start Comparison
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t COMPEO0 = (1U << 0);  ///< Comparator 0 Event Output Enable
        constexpr uint32_t COMPEO1 = (1U << 1);  ///< Comparator 1 Event Output Enable
        constexpr uint32_t WINEO0 = (1U << 4);  ///< Window 0 Event Output Enable
        constexpr uint32_t COMPEI0 = (1U << 8);  ///< Comparator 0 Event Input
        constexpr uint32_t COMPEI1 = (1U << 9);  ///< Comparator 1 Event Input
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t COMP0 = (1U << 0);  ///< Comparator 0 Interrupt Enable
        constexpr uint32_t COMP1 = (1U << 1);  ///< Comparator 1 Interrupt Enable
        constexpr uint32_t WIN0 = (1U << 4);  ///< Window 0 Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t COMP0 = (1U << 0);  ///< Comparator 0 Interrupt Enable
        constexpr uint32_t COMP1 = (1U << 1);  ///< Comparator 1 Interrupt Enable
        constexpr uint32_t WIN0 = (1U << 4);  ///< Window 0 Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t COMP0 = (1U << 0);  ///< Comparator 0
        constexpr uint32_t COMP1 = (1U << 1);  ///< Comparator 1
        constexpr uint32_t WIN0 = (1U << 4);  ///< Window 0
    }

    /// STATUSA Register bits
    namespace statusa_bits {
        constexpr uint32_t STATE0 = (1U << 0);  ///< Comparator 0 Current State
        constexpr uint32_t STATE1 = (1U << 1);  ///< Comparator 1 Current State
        constexpr uint32_t WSTATE0 = (2 << 4);  ///< Window 0 Current State
    }

    /// STATUSB Register bits
    namespace statusb_bits {
        constexpr uint32_t READY0 = (1U << 0);  ///< Comparator 0 Ready
        constexpr uint32_t READY1 = (1U << 1);  ///< Comparator 1 Ready
        constexpr uint32_t SYNCBUSY = (1U << 7);  ///< Synchronization Busy
    }

    /// STATUSC Register bits
    namespace statusc_bits {
        constexpr uint32_t STATE0 = (1U << 0);  ///< Comparator 0 Current State
        constexpr uint32_t STATE1 = (1U << 1);  ///< Comparator 1 Current State
        constexpr uint32_t WSTATE0 = (2 << 4);  ///< Window 0 Current State
    }

    /// WINCTRL Register bits
    namespace winctrl_bits {
        constexpr uint32_t WEN0 = (1U << 0);  ///< Window 0 Mode Enable
        constexpr uint32_t WINTSEL0 = (2 << 1);  ///< Window 0 Interrupt Selection
    }

    /// COMPCTRL%s Register bits
    namespace compctrl%s_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable
        constexpr uint32_t SINGLE = (1U << 1);  ///< Single-Shot Mode
        constexpr uint32_t SPEED = (2 << 2);  ///< Speed Selection
        constexpr uint32_t INTSEL = (2 << 5);  ///< Interrupt Selection
        constexpr uint32_t MUXNEG = (3 << 8);  ///< Negative Input Mux Selection
        constexpr uint32_t MUXPOS = (2 << 12);  ///< Positive Input Mux Selection
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap Inputs and Invert
        constexpr uint32_t OUT = (2 << 16);  ///< Output
        constexpr uint32_t HYST = (1U << 19);  ///< Hysteresis Enable
        constexpr uint32_t FLEN = (3 << 24);  ///< Filter Length
    }

    /// SCALER%s Register bits
    namespace scaler%s_bits {
        constexpr uint32_t VALUE = (6 << 0);  ///< Scaler Value
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x42004000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t REFCTRL;  ///< Offset: 0x01 - Reference Control
        volatile uint32_t AVGCTRL;  ///< Offset: 0x02 - Average Control
        volatile uint32_t SAMPCTRL;  ///< Offset: 0x03 - Sampling Time Control
        volatile uint32_t CTRLB;  ///< Offset: 0x04 - Control B
        volatile uint32_t WINCTRL;  ///< Offset: 0x08 - Window Monitor Control
        volatile uint32_t SWTRIG;  ///< Offset: 0x0C - Software Trigger
        volatile uint32_t INPUTCTRL;  ///< Offset: 0x10 - Input Control
        volatile uint32_t EVCTRL;  ///< Offset: 0x14 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x16 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x17 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x18 - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x19 - Status
        volatile uint32_t RESULT;  ///< Offset: 0x1A - Result
        volatile uint32_t WINLT;  ///< Offset: 0x1C - Window Monitor Lower Threshold
        volatile uint32_t WINUT;  ///< Offset: 0x20 - Window Monitor Upper Threshold
        volatile uint32_t GAINCORR;  ///< Offset: 0x24 - Gain Correction
        volatile uint32_t OFFSETCORR;  ///< Offset: 0x26 - Offset Correction
        volatile uint32_t CALIB;  ///< Offset: 0x28 - Calibration
        volatile uint32_t DBGCTRL;  ///< Offset: 0x2A - Debug Control
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t RUNSTDBY = (1U << 2);  ///< Run in Standby
    }

    /// REFCTRL Register bits
    namespace refctrl_bits {
        constexpr uint32_t REFSEL = (4 << 0);  ///< Reference Selection
        constexpr uint32_t REFCOMP = (1U << 7);  ///< Reference Buffer Offset Compensation Enable
    }

    /// AVGCTRL Register bits
    namespace avgctrl_bits {
        constexpr uint32_t SAMPLENUM = (4 << 0);  ///< Number of Samples to be Collected
        constexpr uint32_t ADJRES = (3 << 4);  ///< Adjusting Result / Division Coefficient
    }

    /// SAMPCTRL Register bits
    namespace sampctrl_bits {
        constexpr uint32_t SAMPLEN = (6 << 0);  ///< Sampling Time Length
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t DIFFMODE = (1U << 0);  ///< Differential Mode
        constexpr uint32_t LEFTADJ = (1U << 1);  ///< Left-Adjusted Result
        constexpr uint32_t FREERUN = (1U << 2);  ///< Free Running Mode
        constexpr uint32_t CORREN = (1U << 3);  ///< Digital Correction Logic Enabled
        constexpr uint32_t RESSEL = (2 << 4);  ///< Conversion Result Resolution
        constexpr uint32_t PRESCALER = (3 << 8);  ///< Prescaler Configuration
    }

    /// WINCTRL Register bits
    namespace winctrl_bits {
        constexpr uint32_t WINMODE = (3 << 0);  ///< Window Monitor Mode
    }

    /// SWTRIG Register bits
    namespace swtrig_bits {
        constexpr uint32_t FLUSH = (1U << 0);  ///< ADC Conversion Flush
        constexpr uint32_t START = (1U << 1);  ///< ADC Start Conversion
    }

    /// INPUTCTRL Register bits
    namespace inputctrl_bits {
        constexpr uint32_t MUXPOS = (5 << 0);  ///< Positive Mux Input Selection
        constexpr uint32_t MUXNEG = (5 << 8);  ///< Negative Mux Input Selection
        constexpr uint32_t INPUTSCAN = (4 << 16);  ///< Number of Input Channels Included in Scan
        constexpr uint32_t INPUTOFFSET = (4 << 20);  ///< Positive Mux Setting Offset
        constexpr uint32_t GAIN = (4 << 24);  ///< Gain Factor Selection
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t STARTEI = (1U << 0);  ///< Start Conversion Event In
        constexpr uint32_t SYNCEI = (1U << 1);  ///< Synchronization Event In
        constexpr uint32_t RESRDYEO = (1U << 4);  ///< Result Ready Event Out
        constexpr uint32_t WINMONEO = (1U << 5);  ///< Window Monitor Event Out
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t RESRDY = (1U << 0);  ///< Result Ready Interrupt Enable
        constexpr uint32_t OVERRUN = (1U << 1);  ///< Overrun Interrupt Enable
        constexpr uint32_t WINMON = (1U << 2);  ///< Window Monitor Interrupt Enable
        constexpr uint32_t SYNCRDY = (1U << 3);  ///< Synchronization Ready Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t RESRDY = (1U << 0);  ///< Result Ready Interrupt Enable
        constexpr uint32_t OVERRUN = (1U << 1);  ///< Overrun Interrupt Enable
        constexpr uint32_t WINMON = (1U << 2);  ///< Window Monitor Interrupt Enable
        constexpr uint32_t SYNCRDY = (1U << 3);  ///< Synchronization Ready Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t RESRDY = (1U << 0);  ///< Result Ready
        constexpr uint32_t OVERRUN = (1U << 1);  ///< Overrun
        constexpr uint32_t WINMON = (1U << 2);  ///< Window Monitor
        constexpr uint32_t SYNCRDY = (1U << 3);  ///< Synchronization Ready
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SYNCBUSY = (1U << 7);  ///< Synchronization Busy
    }

    /// RESULT Register bits
    namespace result_bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Result Conversion Value
    }

    /// WINLT Register bits
    namespace winlt_bits {
        constexpr uint32_t WINLT = (16 << 0);  ///< Window Lower Threshold
    }

    /// WINUT Register bits
    namespace winut_bits {
        constexpr uint32_t WINUT = (16 << 0);  ///< Window Upper Threshold
    }

    /// GAINCORR Register bits
    namespace gaincorr_bits {
        constexpr uint32_t GAINCORR = (12 << 0);  ///< Gain Correction Value
    }

    /// OFFSETCORR Register bits
    namespace offsetcorr_bits {
        constexpr uint32_t OFFSETCORR = (12 << 0);  ///< Offset Correction Value
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t LINEARITY_CAL = (8 << 0);  ///< Linearity Calibration Value
        constexpr uint32_t BIAS_CAL = (3 << 8);  ///< Bias Calibration Value
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Debug Run
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x42004800;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x01 - Control B
        volatile uint32_t EVCTRL;  ///< Offset: 0x02 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x04 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x05 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x06 - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x07 - Status
        volatile uint32_t DATA;  ///< Offset: 0x08 - Data
        volatile uint32_t DATABUF;  ///< Offset: 0x0C - Data Buffer
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t RUNSTDBY = (1U << 2);  ///< Run in Standby
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t EOEN = (1U << 0);  ///< External Output Enable
        constexpr uint32_t IOEN = (1U << 1);  ///< Internal Output Enable
        constexpr uint32_t LEFTADJ = (1U << 2);  ///< Left Adjusted Data
        constexpr uint32_t VPD = (1U << 3);  ///< Voltage Pump Disable
        constexpr uint32_t BDWP = (1U << 4);  ///< Bypass DATABUF Write Protection
        constexpr uint32_t REFSEL = (2 << 6);  ///< Reference Selection
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t STARTEI = (1U << 0);  ///< Start Conversion Event Input
        constexpr uint32_t EMPTYEO = (1U << 1);  ///< Data Buffer Empty Event Output
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t UNDERRUN = (1U << 0);  ///< Underrun Interrupt Enable
        constexpr uint32_t EMPTY = (1U << 1);  ///< Data Buffer Empty Interrupt Enable
        constexpr uint32_t SYNCRDY = (1U << 2);  ///< Synchronization Ready Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t UNDERRUN = (1U << 0);  ///< Underrun Interrupt Enable
        constexpr uint32_t EMPTY = (1U << 1);  ///< Data Buffer Empty Interrupt Enable
        constexpr uint32_t SYNCRDY = (1U << 2);  ///< Synchronization Ready Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t UNDERRUN = (1U << 0);  ///< Underrun
        constexpr uint32_t EMPTY = (1U << 1);  ///< Data Buffer Empty
        constexpr uint32_t SYNCRDY = (1U << 2);  ///< Synchronization Ready
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SYNCBUSY = (1U << 7);  ///< Synchronization Busy Status
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (16 << 0);  ///< Data value to be converted
    }

    /// DATABUF Register bits
    namespace databuf_bits {
        constexpr uint32_t DATABUF = (16 << 0);  ///< Data Buffer
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMAC_BASE = 0x41004800;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control
        volatile uint32_t CRCCTRL;  ///< Offset: 0x02 - CRC Control
        volatile uint32_t CRCDATAIN;  ///< Offset: 0x04 - CRC Data Input
        volatile uint32_t CRCCHKSUM;  ///< Offset: 0x08 - CRC Checksum
        volatile uint32_t CRCSTATUS;  ///< Offset: 0x0C - CRC Status
        volatile uint32_t DBGCTRL;  ///< Offset: 0x0D - Debug Control
        volatile uint32_t QOSCTRL;  ///< Offset: 0x0E - QOS Control
        volatile uint32_t SWTRIGCTRL;  ///< Offset: 0x10 - Software Trigger Control
        volatile uint32_t PRICTRL0;  ///< Offset: 0x14 - Priority Control 0
        volatile uint32_t INTPEND;  ///< Offset: 0x20 - Interrupt Pending
        volatile uint32_t INTSTATUS;  ///< Offset: 0x24 - Interrupt Status
        volatile uint32_t BUSYCH;  ///< Offset: 0x28 - Busy Channels
        volatile uint32_t PENDCH;  ///< Offset: 0x2C - Pending Channels
        volatile uint32_t ACTIVE;  ///< Offset: 0x30 - Active Channel and Levels
        volatile uint32_t BASEADDR;  ///< Offset: 0x34 - Descriptor Memory Section Base Address
        volatile uint32_t WRBADDR;  ///< Offset: 0x38 - Write-Back Memory Section Base Address
        volatile uint32_t CHID;  ///< Offset: 0x3F - Channel ID
        volatile uint32_t CHCTRLA;  ///< Offset: 0x40 - Channel Control A
        volatile uint32_t CHCTRLB;  ///< Offset: 0x44 - Channel Control B
        volatile uint32_t CHINTENCLR;  ///< Offset: 0x4C - Channel Interrupt Enable Clear
        volatile uint32_t CHINTENSET;  ///< Offset: 0x4D - Channel Interrupt Enable Set
        volatile uint32_t CHINTFLAG;  ///< Offset: 0x4E - Channel Interrupt Flag Status and Clear
        volatile uint32_t CHSTATUS;  ///< Offset: 0x4F - Channel Status
    };

    /// Peripheral instances
    inline Registers* DMAC = reinterpret_cast<Registers*>(DMAC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t DMAENABLE = (1U << 1);  ///< DMA Enable
        constexpr uint32_t CRCENABLE = (1U << 2);  ///< CRC Enable
        constexpr uint32_t LVLEN0 = (1U << 8);  ///< Priority Level 0 Enable
        constexpr uint32_t LVLEN1 = (1U << 9);  ///< Priority Level 1 Enable
        constexpr uint32_t LVLEN2 = (1U << 10);  ///< Priority Level 2 Enable
        constexpr uint32_t LVLEN3 = (1U << 11);  ///< Priority Level 3 Enable
    }

    /// CRCCTRL Register bits
    namespace crcctrl_bits {
        constexpr uint32_t CRCBEATSIZE = (2 << 0);  ///< CRC Beat Size
        constexpr uint32_t CRCPOLY = (2 << 2);  ///< CRC Polynomial Type
        constexpr uint32_t CRCSRC = (6 << 8);  ///< CRC Input Source
    }

    /// CRCDATAIN Register bits
    namespace crcdatain_bits {
        constexpr uint32_t CRCDATAIN = (32 << 0);  ///< CRC Data Input
    }

    /// CRCCHKSUM Register bits
    namespace crcchksum_bits {
        constexpr uint32_t CRCCHKSUM = (32 << 0);  ///< CRC Checksum
    }

    /// CRCSTATUS Register bits
    namespace crcstatus_bits {
        constexpr uint32_t CRCBUSY = (1U << 0);  ///< CRC Module Busy
        constexpr uint32_t CRCZERO = (1U << 1);  ///< CRC Zero
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Debug Run
    }

    /// QOSCTRL Register bits
    namespace qosctrl_bits {
        constexpr uint32_t WRBQOS = (2 << 0);  ///< Write-Back Quality of Service
        constexpr uint32_t FQOS = (2 << 2);  ///< Fetch Quality of Service
        constexpr uint32_t DQOS = (2 << 4);  ///< Data Transfer Quality of Service
    }

    /// SWTRIGCTRL Register bits
    namespace swtrigctrl_bits {
        constexpr uint32_t SWTRIG0 = (1U << 0);  ///< Channel 0 Software Trigger
        constexpr uint32_t SWTRIG1 = (1U << 1);  ///< Channel 1 Software Trigger
        constexpr uint32_t SWTRIG2 = (1U << 2);  ///< Channel 2 Software Trigger
        constexpr uint32_t SWTRIG3 = (1U << 3);  ///< Channel 3 Software Trigger
        constexpr uint32_t SWTRIG4 = (1U << 4);  ///< Channel 4 Software Trigger
        constexpr uint32_t SWTRIG5 = (1U << 5);  ///< Channel 5 Software Trigger
        constexpr uint32_t SWTRIG6 = (1U << 6);  ///< Channel 6 Software Trigger
        constexpr uint32_t SWTRIG7 = (1U << 7);  ///< Channel 7 Software Trigger
        constexpr uint32_t SWTRIG8 = (1U << 8);  ///< Channel 8 Software Trigger
        constexpr uint32_t SWTRIG9 = (1U << 9);  ///< Channel 9 Software Trigger
        constexpr uint32_t SWTRIG10 = (1U << 10);  ///< Channel 10 Software Trigger
        constexpr uint32_t SWTRIG11 = (1U << 11);  ///< Channel 11 Software Trigger
    }

    /// PRICTRL0 Register bits
    namespace prictrl0_bits {
        constexpr uint32_t LVLPRI0 = (4 << 0);  ///< Level 0 Channel Priority Number
        constexpr uint32_t RRLVLEN0 = (1U << 7);  ///< Level 0 Round-Robin Scheduling Enable
        constexpr uint32_t LVLPRI1 = (4 << 8);  ///< Level 1 Channel Priority Number
        constexpr uint32_t RRLVLEN1 = (1U << 15);  ///< Level 1 Round-Robin Scheduling Enable
        constexpr uint32_t LVLPRI2 = (4 << 16);  ///< Level 2 Channel Priority Number
        constexpr uint32_t RRLVLEN2 = (1U << 23);  ///< Level 2 Round-Robin Scheduling Enable
        constexpr uint32_t LVLPRI3 = (4 << 24);  ///< Level 3 Channel Priority Number
        constexpr uint32_t RRLVLEN3 = (1U << 31);  ///< Level 3 Round-Robin Scheduling Enable
    }

    /// INTPEND Register bits
    namespace intpend_bits {
        constexpr uint32_t ID = (4 << 0);  ///< Channel ID
        constexpr uint32_t TERR = (1U << 8);  ///< Transfer Error
        constexpr uint32_t TCMPL = (1U << 9);  ///< Transfer Complete
        constexpr uint32_t SUSP = (1U << 10);  ///< Channel Suspend
        constexpr uint32_t FERR = (1U << 13);  ///< Fetch Error
        constexpr uint32_t BUSY = (1U << 14);  ///< Busy
        constexpr uint32_t PEND = (1U << 15);  ///< Pending
    }

    /// INTSTATUS Register bits
    namespace intstatus_bits {
        constexpr uint32_t CHINT0 = (1U << 0);  ///< Channel 0 Pending Interrupt
        constexpr uint32_t CHINT1 = (1U << 1);  ///< Channel 1 Pending Interrupt
        constexpr uint32_t CHINT2 = (1U << 2);  ///< Channel 2 Pending Interrupt
        constexpr uint32_t CHINT3 = (1U << 3);  ///< Channel 3 Pending Interrupt
        constexpr uint32_t CHINT4 = (1U << 4);  ///< Channel 4 Pending Interrupt
        constexpr uint32_t CHINT5 = (1U << 5);  ///< Channel 5 Pending Interrupt
        constexpr uint32_t CHINT6 = (1U << 6);  ///< Channel 6 Pending Interrupt
        constexpr uint32_t CHINT7 = (1U << 7);  ///< Channel 7 Pending Interrupt
        constexpr uint32_t CHINT8 = (1U << 8);  ///< Channel 8 Pending Interrupt
        constexpr uint32_t CHINT9 = (1U << 9);  ///< Channel 9 Pending Interrupt
        constexpr uint32_t CHINT10 = (1U << 10);  ///< Channel 10 Pending Interrupt
        constexpr uint32_t CHINT11 = (1U << 11);  ///< Channel 11 Pending Interrupt
    }

    /// BUSYCH Register bits
    namespace busych_bits {
        constexpr uint32_t BUSYCH0 = (1U << 0);  ///< Busy Channel 0
        constexpr uint32_t BUSYCH1 = (1U << 1);  ///< Busy Channel 1
        constexpr uint32_t BUSYCH2 = (1U << 2);  ///< Busy Channel 2
        constexpr uint32_t BUSYCH3 = (1U << 3);  ///< Busy Channel 3
        constexpr uint32_t BUSYCH4 = (1U << 4);  ///< Busy Channel 4
        constexpr uint32_t BUSYCH5 = (1U << 5);  ///< Busy Channel 5
        constexpr uint32_t BUSYCH6 = (1U << 6);  ///< Busy Channel 6
        constexpr uint32_t BUSYCH7 = (1U << 7);  ///< Busy Channel 7
        constexpr uint32_t BUSYCH8 = (1U << 8);  ///< Busy Channel 8
        constexpr uint32_t BUSYCH9 = (1U << 9);  ///< Busy Channel 9
        constexpr uint32_t BUSYCH10 = (1U << 10);  ///< Busy Channel 10
        constexpr uint32_t BUSYCH11 = (1U << 11);  ///< Busy Channel 11
    }

    /// PENDCH Register bits
    namespace pendch_bits {
        constexpr uint32_t PENDCH0 = (1U << 0);  ///< Pending Channel 0
        constexpr uint32_t PENDCH1 = (1U << 1);  ///< Pending Channel 1
        constexpr uint32_t PENDCH2 = (1U << 2);  ///< Pending Channel 2
        constexpr uint32_t PENDCH3 = (1U << 3);  ///< Pending Channel 3
        constexpr uint32_t PENDCH4 = (1U << 4);  ///< Pending Channel 4
        constexpr uint32_t PENDCH5 = (1U << 5);  ///< Pending Channel 5
        constexpr uint32_t PENDCH6 = (1U << 6);  ///< Pending Channel 6
        constexpr uint32_t PENDCH7 = (1U << 7);  ///< Pending Channel 7
        constexpr uint32_t PENDCH8 = (1U << 8);  ///< Pending Channel 8
        constexpr uint32_t PENDCH9 = (1U << 9);  ///< Pending Channel 9
        constexpr uint32_t PENDCH10 = (1U << 10);  ///< Pending Channel 10
        constexpr uint32_t PENDCH11 = (1U << 11);  ///< Pending Channel 11
    }

    /// ACTIVE Register bits
    namespace active_bits {
        constexpr uint32_t LVLEX0 = (1U << 0);  ///< Level 0 Channel Trigger Request Executing
        constexpr uint32_t LVLEX1 = (1U << 1);  ///< Level 1 Channel Trigger Request Executing
        constexpr uint32_t LVLEX2 = (1U << 2);  ///< Level 2 Channel Trigger Request Executing
        constexpr uint32_t LVLEX3 = (1U << 3);  ///< Level 3 Channel Trigger Request Executing
        constexpr uint32_t ID = (5 << 8);  ///< Active Channel ID
        constexpr uint32_t ABUSY = (1U << 15);  ///< Active Channel Busy
        constexpr uint32_t BTCNT = (16 << 16);  ///< Active Channel Block Transfer Count
    }

    /// BASEADDR Register bits
    namespace baseaddr_bits {
        constexpr uint32_t BASEADDR = (32 << 0);  ///< Descriptor Memory Base Address
    }

    /// WRBADDR Register bits
    namespace wrbaddr_bits {
        constexpr uint32_t WRBADDR = (32 << 0);  ///< Write-Back Memory Base Address
    }

    /// CHID Register bits
    namespace chid_bits {
        constexpr uint32_t ID = (4 << 0);  ///< Channel ID
    }

    /// CHCTRLA Register bits
    namespace chctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Channel Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Channel Enable
    }

    /// CHCTRLB Register bits
    namespace chctrlb_bits {
        constexpr uint32_t EVACT = (3 << 0);  ///< Event Input Action
        constexpr uint32_t EVIE = (1U << 3);  ///< Channel Event Input Enable
        constexpr uint32_t EVOE = (1U << 4);  ///< Channel Event Output Enable
        constexpr uint32_t LVL = (2 << 5);  ///< Channel Arbitration Level
        constexpr uint32_t TRIGSRC = (6 << 8);  ///< Trigger Source
        constexpr uint32_t TRIGACT = (2 << 22);  ///< Trigger Action
        constexpr uint32_t CMD = (2 << 24);  ///< Software Command
    }

    /// CHINTENCLR Register bits
    namespace chintenclr_bits {
        constexpr uint32_t TERR = (1U << 0);  ///< Channel Transfer Error Interrupt Enable
        constexpr uint32_t TCMPL = (1U << 1);  ///< Channel Transfer Complete Interrupt Enable
        constexpr uint32_t SUSP = (1U << 2);  ///< Channel Suspend Interrupt Enable
    }

    /// CHINTENSET Register bits
    namespace chintenset_bits {
        constexpr uint32_t TERR = (1U << 0);  ///< Channel Transfer Error Interrupt Enable
        constexpr uint32_t TCMPL = (1U << 1);  ///< Channel Transfer Complete Interrupt Enable
        constexpr uint32_t SUSP = (1U << 2);  ///< Channel Suspend Interrupt Enable
    }

    /// CHINTFLAG Register bits
    namespace chintflag_bits {
        constexpr uint32_t TERR = (1U << 0);  ///< Channel Transfer Error
        constexpr uint32_t TCMPL = (1U << 1);  ///< Channel Transfer Complete
        constexpr uint32_t SUSP = (1U << 2);  ///< Channel Suspend
    }

    /// CHSTATUS Register bits
    namespace chstatus_bits {
        constexpr uint32_t PEND = (1U << 0);  ///< Channel Pending
        constexpr uint32_t BUSY = (1U << 1);  ///< Channel Busy
        constexpr uint32_t FERR = (1U << 2);  ///< Channel Fetch Error
    }

}

// ============================================================================
// DSU Peripheral
// ============================================================================

namespace dsu {
    /// Base addresses
    constexpr uint32_t DSU_BASE = 0x41002000;

    /// DSU Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control
        volatile uint32_t STATUSA;  ///< Offset: 0x01 - Status A
        volatile uint32_t STATUSB;  ///< Offset: 0x02 - Status B
        volatile uint32_t ADDR;  ///< Offset: 0x04 - Address
        volatile uint32_t LENGTH;  ///< Offset: 0x08 - Length
        volatile uint32_t DATA;  ///< Offset: 0x0C - Data
        volatile uint32_t DCC%s;  ///< Offset: 0x10 - Debug Communication Channel n
        volatile uint32_t DID;  ///< Offset: 0x18 - Device Identification
        volatile uint32_t ENTRY;  ///< Offset: 0x1000 - CoreSight ROM Table Entry 0
        volatile uint32_t ENTRY1;  ///< Offset: 0x1004 - CoreSight ROM Table Entry 1
        volatile uint32_t END;  ///< Offset: 0x1008 - CoreSight ROM Table End
        volatile uint32_t MEMTYPE;  ///< Offset: 0x1FCC - CoreSight ROM Table Memory Type
        volatile uint32_t PID4;  ///< Offset: 0x1FD0 - Peripheral Identification 4
        volatile uint32_t PID0;  ///< Offset: 0x1FE0 - Peripheral Identification 0
        volatile uint32_t PID1;  ///< Offset: 0x1FE4 - Peripheral Identification 1
        volatile uint32_t PID2;  ///< Offset: 0x1FE8 - Peripheral Identification 2
        volatile uint32_t PID3;  ///< Offset: 0x1FEC - Peripheral Identification 3
        volatile uint32_t CID0;  ///< Offset: 0x1FF0 - Component Identification 0
        volatile uint32_t CID1;  ///< Offset: 0x1FF4 - Component Identification 1
        volatile uint32_t CID2;  ///< Offset: 0x1FF8 - Component Identification 2
        volatile uint32_t CID3;  ///< Offset: 0x1FFC - Component Identification 3
    };

    /// Peripheral instances
    inline Registers* DSU = reinterpret_cast<Registers*>(DSU_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t CRC = (1U << 2);  ///< 32-bit Cyclic Redundancy Check
        constexpr uint32_t MBIST = (1U << 3);  ///< Memory Built-In Self-Test
        constexpr uint32_t CE = (1U << 4);  ///< Chip Erase
    }

    /// STATUSA Register bits
    namespace statusa_bits {
        constexpr uint32_t DONE = (1U << 0);  ///< Done
        constexpr uint32_t CRSTEXT = (1U << 1);  ///< CPU Reset Phase Extension
        constexpr uint32_t BERR = (1U << 2);  ///< Bus Error
        constexpr uint32_t FAIL = (1U << 3);  ///< Failure
        constexpr uint32_t PERR = (1U << 4);  ///< Protection Error
    }

    /// STATUSB Register bits
    namespace statusb_bits {
        constexpr uint32_t PROT = (1U << 0);  ///< Protected
        constexpr uint32_t DBGPRES = (1U << 1);  ///< Debugger Present
        constexpr uint32_t DCCD0 = (1U << 2);  ///< Debug Communication Channel 0 Dirty
        constexpr uint32_t DCCD1 = (1U << 3);  ///< Debug Communication Channel 1 Dirty
        constexpr uint32_t HPE = (1U << 4);  ///< Hot-Plugging Enable
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (30 << 2);  ///< Address
    }

    /// LENGTH Register bits
    namespace length_bits {
        constexpr uint32_t LENGTH = (30 << 2);  ///< Length
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// DCC%s Register bits
    namespace dcc%s_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// DID Register bits
    namespace did_bits {
        constexpr uint32_t DEVSEL = (8 << 0);  ///< Device Select
        constexpr uint32_t REVISION = (4 << 8);  ///< Revision
        constexpr uint32_t DIE = (4 << 12);  ///< Die Identification
        constexpr uint32_t SERIES = (6 << 16);  ///< Product Series
        constexpr uint32_t FAMILY = (5 << 23);  ///< Product Family
        constexpr uint32_t PROCESSOR = (4 << 28);  ///< Processor
    }

    /// ENTRY Register bits
    namespace entry_bits {
        constexpr uint32_t EPRES = (1U << 0);  ///< Entry Present
        constexpr uint32_t FMT = (1U << 1);  ///< Format
        constexpr uint32_t ADDOFF = (20 << 12);  ///< Address Offset
    }

    /// END Register bits
    namespace end_bits {
        constexpr uint32_t END = (32 << 0);  ///< End Marker
    }

    /// MEMTYPE Register bits
    namespace memtype_bits {
        constexpr uint32_t SMEMP = (1U << 0);  ///< System Memory Present
    }

    /// PID4 Register bits
    namespace pid4_bits {
        constexpr uint32_t JEPCC = (4 << 0);  ///< JEP-106 Continuation Code
        constexpr uint32_t FKBC = (4 << 4);  ///< 4KB Count
    }

    /// PID0 Register bits
    namespace pid0_bits {
        constexpr uint32_t PARTNBL = (8 << 0);  ///< Part Number Low
    }

    /// PID1 Register bits
    namespace pid1_bits {
        constexpr uint32_t PARTNBH = (4 << 0);  ///< Part Number High
        constexpr uint32_t JEPIDCL = (4 << 4);  ///< Low part of the JEP-106 Identity Code
    }

    /// PID2 Register bits
    namespace pid2_bits {
        constexpr uint32_t JEPIDCH = (3 << 0);  ///< JEP-106 Identity Code High
        constexpr uint32_t JEPU = (1U << 3);  ///< JEP-106 Identity Code is used
        constexpr uint32_t REVISION = (4 << 4);  ///< Revision Number
    }

    /// PID3 Register bits
    namespace pid3_bits {
        constexpr uint32_t CUSMOD = (4 << 0);  ///< ARM CUSMOD
        constexpr uint32_t REVAND = (4 << 4);  ///< Revision Number
    }

    /// CID0 Register bits
    namespace cid0_bits {
        constexpr uint32_t PREAMBLEB0 = (8 << 0);  ///< Preamble Byte 0
    }

    /// CID1 Register bits
    namespace cid1_bits {
        constexpr uint32_t PREAMBLE = (4 << 0);  ///< Preamble
        constexpr uint32_t CCLASS = (4 << 4);  ///< Component Class
    }

    /// CID2 Register bits
    namespace cid2_bits {
        constexpr uint32_t PREAMBLEB2 = (8 << 0);  ///< Preamble Byte 2
    }

    /// CID3 Register bits
    namespace cid3_bits {
        constexpr uint32_t PREAMBLEB3 = (8 << 0);  ///< Preamble Byte 3
    }

}

// ============================================================================
// EIC Peripheral
// ============================================================================

namespace eic {
    /// Base addresses
    constexpr uint32_t EIC_BASE = 0x40001800;

    /// EIC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control
        volatile uint32_t STATUS;  ///< Offset: 0x01 - Status
        volatile uint32_t NMICTRL;  ///< Offset: 0x02 - Non-Maskable Interrupt Control
        volatile uint32_t NMIFLAG;  ///< Offset: 0x03 - Non-Maskable Interrupt Flag Status and Clear
        volatile uint32_t EVCTRL;  ///< Offset: 0x04 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x08 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x0C - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x10 - Interrupt Flag Status and Clear
        volatile uint32_t WAKEUP;  ///< Offset: 0x14 - Wake-Up Enable
        volatile uint32_t CONFIG%s;  ///< Offset: 0x18 - Configuration n
    };

    /// Peripheral instances
    inline Registers* EIC = reinterpret_cast<Registers*>(EIC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SYNCBUSY = (1U << 7);  ///< Synchronization Busy
    }

    /// NMICTRL Register bits
    namespace nmictrl_bits {
        constexpr uint32_t NMISENSE = (3 << 0);  ///< Non-Maskable Interrupt Sense
        constexpr uint32_t NMIFILTEN = (1U << 3);  ///< Non-Maskable Interrupt Filter Enable
    }

    /// NMIFLAG Register bits
    namespace nmiflag_bits {
        constexpr uint32_t NMI = (1U << 0);  ///< Non-Maskable Interrupt
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t EXTINTEO0 = (1U << 0);  ///< External Interrupt 0 Event Output Enable
        constexpr uint32_t EXTINTEO1 = (1U << 1);  ///< External Interrupt 1 Event Output Enable
        constexpr uint32_t EXTINTEO2 = (1U << 2);  ///< External Interrupt 2 Event Output Enable
        constexpr uint32_t EXTINTEO3 = (1U << 3);  ///< External Interrupt 3 Event Output Enable
        constexpr uint32_t EXTINTEO4 = (1U << 4);  ///< External Interrupt 4 Event Output Enable
        constexpr uint32_t EXTINTEO5 = (1U << 5);  ///< External Interrupt 5 Event Output Enable
        constexpr uint32_t EXTINTEO6 = (1U << 6);  ///< External Interrupt 6 Event Output Enable
        constexpr uint32_t EXTINTEO7 = (1U << 7);  ///< External Interrupt 7 Event Output Enable
        constexpr uint32_t EXTINTEO8 = (1U << 8);  ///< External Interrupt 8 Event Output Enable
        constexpr uint32_t EXTINTEO9 = (1U << 9);  ///< External Interrupt 9 Event Output Enable
        constexpr uint32_t EXTINTEO10 = (1U << 10);  ///< External Interrupt 10 Event Output Enable
        constexpr uint32_t EXTINTEO11 = (1U << 11);  ///< External Interrupt 11 Event Output Enable
        constexpr uint32_t EXTINTEO12 = (1U << 12);  ///< External Interrupt 12 Event Output Enable
        constexpr uint32_t EXTINTEO13 = (1U << 13);  ///< External Interrupt 13 Event Output Enable
        constexpr uint32_t EXTINTEO14 = (1U << 14);  ///< External Interrupt 14 Event Output Enable
        constexpr uint32_t EXTINTEO15 = (1U << 15);  ///< External Interrupt 15 Event Output Enable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t EXTINT0 = (1U << 0);  ///< External Interrupt 0 Enable
        constexpr uint32_t EXTINT1 = (1U << 1);  ///< External Interrupt 1 Enable
        constexpr uint32_t EXTINT2 = (1U << 2);  ///< External Interrupt 2 Enable
        constexpr uint32_t EXTINT3 = (1U << 3);  ///< External Interrupt 3 Enable
        constexpr uint32_t EXTINT4 = (1U << 4);  ///< External Interrupt 4 Enable
        constexpr uint32_t EXTINT5 = (1U << 5);  ///< External Interrupt 5 Enable
        constexpr uint32_t EXTINT6 = (1U << 6);  ///< External Interrupt 6 Enable
        constexpr uint32_t EXTINT7 = (1U << 7);  ///< External Interrupt 7 Enable
        constexpr uint32_t EXTINT8 = (1U << 8);  ///< External Interrupt 8 Enable
        constexpr uint32_t EXTINT9 = (1U << 9);  ///< External Interrupt 9 Enable
        constexpr uint32_t EXTINT10 = (1U << 10);  ///< External Interrupt 10 Enable
        constexpr uint32_t EXTINT11 = (1U << 11);  ///< External Interrupt 11 Enable
        constexpr uint32_t EXTINT12 = (1U << 12);  ///< External Interrupt 12 Enable
        constexpr uint32_t EXTINT13 = (1U << 13);  ///< External Interrupt 13 Enable
        constexpr uint32_t EXTINT14 = (1U << 14);  ///< External Interrupt 14 Enable
        constexpr uint32_t EXTINT15 = (1U << 15);  ///< External Interrupt 15 Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t EXTINT0 = (1U << 0);  ///< External Interrupt 0 Enable
        constexpr uint32_t EXTINT1 = (1U << 1);  ///< External Interrupt 1 Enable
        constexpr uint32_t EXTINT2 = (1U << 2);  ///< External Interrupt 2 Enable
        constexpr uint32_t EXTINT3 = (1U << 3);  ///< External Interrupt 3 Enable
        constexpr uint32_t EXTINT4 = (1U << 4);  ///< External Interrupt 4 Enable
        constexpr uint32_t EXTINT5 = (1U << 5);  ///< External Interrupt 5 Enable
        constexpr uint32_t EXTINT6 = (1U << 6);  ///< External Interrupt 6 Enable
        constexpr uint32_t EXTINT7 = (1U << 7);  ///< External Interrupt 7 Enable
        constexpr uint32_t EXTINT8 = (1U << 8);  ///< External Interrupt 8 Enable
        constexpr uint32_t EXTINT9 = (1U << 9);  ///< External Interrupt 9 Enable
        constexpr uint32_t EXTINT10 = (1U << 10);  ///< External Interrupt 10 Enable
        constexpr uint32_t EXTINT11 = (1U << 11);  ///< External Interrupt 11 Enable
        constexpr uint32_t EXTINT12 = (1U << 12);  ///< External Interrupt 12 Enable
        constexpr uint32_t EXTINT13 = (1U << 13);  ///< External Interrupt 13 Enable
        constexpr uint32_t EXTINT14 = (1U << 14);  ///< External Interrupt 14 Enable
        constexpr uint32_t EXTINT15 = (1U << 15);  ///< External Interrupt 15 Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t EXTINT0 = (1U << 0);  ///< External Interrupt 0
        constexpr uint32_t EXTINT1 = (1U << 1);  ///< External Interrupt 1
        constexpr uint32_t EXTINT2 = (1U << 2);  ///< External Interrupt 2
        constexpr uint32_t EXTINT3 = (1U << 3);  ///< External Interrupt 3
        constexpr uint32_t EXTINT4 = (1U << 4);  ///< External Interrupt 4
        constexpr uint32_t EXTINT5 = (1U << 5);  ///< External Interrupt 5
        constexpr uint32_t EXTINT6 = (1U << 6);  ///< External Interrupt 6
        constexpr uint32_t EXTINT7 = (1U << 7);  ///< External Interrupt 7
        constexpr uint32_t EXTINT8 = (1U << 8);  ///< External Interrupt 8
        constexpr uint32_t EXTINT9 = (1U << 9);  ///< External Interrupt 9
        constexpr uint32_t EXTINT10 = (1U << 10);  ///< External Interrupt 10
        constexpr uint32_t EXTINT11 = (1U << 11);  ///< External Interrupt 11
        constexpr uint32_t EXTINT12 = (1U << 12);  ///< External Interrupt 12
        constexpr uint32_t EXTINT13 = (1U << 13);  ///< External Interrupt 13
        constexpr uint32_t EXTINT14 = (1U << 14);  ///< External Interrupt 14
        constexpr uint32_t EXTINT15 = (1U << 15);  ///< External Interrupt 15
    }

    /// WAKEUP Register bits
    namespace wakeup_bits {
        constexpr uint32_t WAKEUPEN0 = (1U << 0);  ///< External Interrupt 0 Wake-up Enable
        constexpr uint32_t WAKEUPEN1 = (1U << 1);  ///< External Interrupt 1 Wake-up Enable
        constexpr uint32_t WAKEUPEN2 = (1U << 2);  ///< External Interrupt 2 Wake-up Enable
        constexpr uint32_t WAKEUPEN3 = (1U << 3);  ///< External Interrupt 3 Wake-up Enable
        constexpr uint32_t WAKEUPEN4 = (1U << 4);  ///< External Interrupt 4 Wake-up Enable
        constexpr uint32_t WAKEUPEN5 = (1U << 5);  ///< External Interrupt 5 Wake-up Enable
        constexpr uint32_t WAKEUPEN6 = (1U << 6);  ///< External Interrupt 6 Wake-up Enable
        constexpr uint32_t WAKEUPEN7 = (1U << 7);  ///< External Interrupt 7 Wake-up Enable
        constexpr uint32_t WAKEUPEN8 = (1U << 8);  ///< External Interrupt 8 Wake-up Enable
        constexpr uint32_t WAKEUPEN9 = (1U << 9);  ///< External Interrupt 9 Wake-up Enable
        constexpr uint32_t WAKEUPEN10 = (1U << 10);  ///< External Interrupt 10 Wake-up Enable
        constexpr uint32_t WAKEUPEN11 = (1U << 11);  ///< External Interrupt 11 Wake-up Enable
        constexpr uint32_t WAKEUPEN12 = (1U << 12);  ///< External Interrupt 12 Wake-up Enable
        constexpr uint32_t WAKEUPEN13 = (1U << 13);  ///< External Interrupt 13 Wake-up Enable
        constexpr uint32_t WAKEUPEN14 = (1U << 14);  ///< External Interrupt 14 Wake-up Enable
        constexpr uint32_t WAKEUPEN15 = (1U << 15);  ///< External Interrupt 15 Wake-up Enable
    }

    /// CONFIG%s Register bits
    namespace config%s_bits {
        constexpr uint32_t SENSE0 = (3 << 0);  ///< Input Sense 0 Configuration
        constexpr uint32_t FILTEN0 = (1U << 3);  ///< Filter 0 Enable
        constexpr uint32_t SENSE1 = (3 << 4);  ///< Input Sense 1 Configuration
        constexpr uint32_t FILTEN1 = (1U << 7);  ///< Filter 1 Enable
        constexpr uint32_t SENSE2 = (3 << 8);  ///< Input Sense 2 Configuration
        constexpr uint32_t FILTEN2 = (1U << 11);  ///< Filter 2 Enable
        constexpr uint32_t SENSE3 = (3 << 12);  ///< Input Sense 3 Configuration
        constexpr uint32_t FILTEN3 = (1U << 15);  ///< Filter 3 Enable
        constexpr uint32_t SENSE4 = (3 << 16);  ///< Input Sense 4 Configuration
        constexpr uint32_t FILTEN4 = (1U << 19);  ///< Filter 4 Enable
        constexpr uint32_t SENSE5 = (3 << 20);  ///< Input Sense 5 Configuration
        constexpr uint32_t FILTEN5 = (1U << 23);  ///< Filter 5 Enable
        constexpr uint32_t SENSE6 = (3 << 24);  ///< Input Sense 6 Configuration
        constexpr uint32_t FILTEN6 = (1U << 27);  ///< Filter 6 Enable
        constexpr uint32_t SENSE7 = (3 << 28);  ///< Input Sense 7 Configuration
        constexpr uint32_t FILTEN7 = (1U << 31);  ///< Filter 7 Enable
    }

}

// ============================================================================
// EVSYS Peripheral
// ============================================================================

namespace evsys {
    /// Base addresses
    constexpr uint32_t EVSYS_BASE = 0x42000400;

    /// EVSYS Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control
        volatile uint32_t CHANNEL;  ///< Offset: 0x04 - Channel
        volatile uint32_t USER;  ///< Offset: 0x08 - User Multiplexer
        volatile uint32_t CHSTATUS;  ///< Offset: 0x0C - Channel Status
        volatile uint32_t INTENCLR;  ///< Offset: 0x10 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x14 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x18 - Interrupt Flag Status and Clear
    };

    /// Peripheral instances
    inline Registers* EVSYS = reinterpret_cast<Registers*>(EVSYS_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t GCLKREQ = (1U << 4);  ///< Generic Clock Requests
    }

    /// CHANNEL Register bits
    namespace channel_bits {
        constexpr uint32_t CHANNEL = (4 << 0);  ///< Channel Selection
        constexpr uint32_t SWEVT = (1U << 8);  ///< Software Event
        constexpr uint32_t EVGEN = (7 << 16);  ///< Event Generator Selection
        constexpr uint32_t PATH = (2 << 24);  ///< Path Selection
        constexpr uint32_t EDGSEL = (2 << 26);  ///< Edge Detection Selection
    }

    /// USER Register bits
    namespace user_bits {
        constexpr uint32_t USER = (5 << 0);  ///< User Multiplexer Selection
        constexpr uint32_t CHANNEL = (5 << 8);  ///< Channel Event Selection
    }

    /// CHSTATUS Register bits
    namespace chstatus_bits {
        constexpr uint32_t USRRDY0 = (1U << 0);  ///< Channel 0 User Ready
        constexpr uint32_t USRRDY1 = (1U << 1);  ///< Channel 1 User Ready
        constexpr uint32_t USRRDY2 = (1U << 2);  ///< Channel 2 User Ready
        constexpr uint32_t USRRDY3 = (1U << 3);  ///< Channel 3 User Ready
        constexpr uint32_t USRRDY4 = (1U << 4);  ///< Channel 4 User Ready
        constexpr uint32_t USRRDY5 = (1U << 5);  ///< Channel 5 User Ready
        constexpr uint32_t USRRDY6 = (1U << 6);  ///< Channel 6 User Ready
        constexpr uint32_t USRRDY7 = (1U << 7);  ///< Channel 7 User Ready
        constexpr uint32_t CHBUSY0 = (1U << 8);  ///< Channel 0 Busy
        constexpr uint32_t CHBUSY1 = (1U << 9);  ///< Channel 1 Busy
        constexpr uint32_t CHBUSY2 = (1U << 10);  ///< Channel 2 Busy
        constexpr uint32_t CHBUSY3 = (1U << 11);  ///< Channel 3 Busy
        constexpr uint32_t CHBUSY4 = (1U << 12);  ///< Channel 4 Busy
        constexpr uint32_t CHBUSY5 = (1U << 13);  ///< Channel 5 Busy
        constexpr uint32_t CHBUSY6 = (1U << 14);  ///< Channel 6 Busy
        constexpr uint32_t CHBUSY7 = (1U << 15);  ///< Channel 7 Busy
        constexpr uint32_t USRRDY8 = (1U << 16);  ///< Channel 8 User Ready
        constexpr uint32_t USRRDY9 = (1U << 17);  ///< Channel 9 User Ready
        constexpr uint32_t USRRDY10 = (1U << 18);  ///< Channel 10 User Ready
        constexpr uint32_t USRRDY11 = (1U << 19);  ///< Channel 11 User Ready
        constexpr uint32_t CHBUSY8 = (1U << 24);  ///< Channel 8 Busy
        constexpr uint32_t CHBUSY9 = (1U << 25);  ///< Channel 9 Busy
        constexpr uint32_t CHBUSY10 = (1U << 26);  ///< Channel 10 Busy
        constexpr uint32_t CHBUSY11 = (1U << 27);  ///< Channel 11 Busy
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t OVR0 = (1U << 0);  ///< Channel 0 Overrun Interrupt Enable
        constexpr uint32_t OVR1 = (1U << 1);  ///< Channel 1 Overrun Interrupt Enable
        constexpr uint32_t OVR2 = (1U << 2);  ///< Channel 2 Overrun Interrupt Enable
        constexpr uint32_t OVR3 = (1U << 3);  ///< Channel 3 Overrun Interrupt Enable
        constexpr uint32_t OVR4 = (1U << 4);  ///< Channel 4 Overrun Interrupt Enable
        constexpr uint32_t OVR5 = (1U << 5);  ///< Channel 5 Overrun Interrupt Enable
        constexpr uint32_t OVR6 = (1U << 6);  ///< Channel 6 Overrun Interrupt Enable
        constexpr uint32_t OVR7 = (1U << 7);  ///< Channel 7 Overrun Interrupt Enable
        constexpr uint32_t EVD0 = (1U << 8);  ///< Channel 0 Event Detection Interrupt Enable
        constexpr uint32_t EVD1 = (1U << 9);  ///< Channel 1 Event Detection Interrupt Enable
        constexpr uint32_t EVD2 = (1U << 10);  ///< Channel 2 Event Detection Interrupt Enable
        constexpr uint32_t EVD3 = (1U << 11);  ///< Channel 3 Event Detection Interrupt Enable
        constexpr uint32_t EVD4 = (1U << 12);  ///< Channel 4 Event Detection Interrupt Enable
        constexpr uint32_t EVD5 = (1U << 13);  ///< Channel 5 Event Detection Interrupt Enable
        constexpr uint32_t EVD6 = (1U << 14);  ///< Channel 6 Event Detection Interrupt Enable
        constexpr uint32_t EVD7 = (1U << 15);  ///< Channel 7 Event Detection Interrupt Enable
        constexpr uint32_t OVR8 = (1U << 16);  ///< Channel 8 Overrun Interrupt Enable
        constexpr uint32_t OVR9 = (1U << 17);  ///< Channel 9 Overrun Interrupt Enable
        constexpr uint32_t OVR10 = (1U << 18);  ///< Channel 10 Overrun Interrupt Enable
        constexpr uint32_t OVR11 = (1U << 19);  ///< Channel 11 Overrun Interrupt Enable
        constexpr uint32_t EVD8 = (1U << 24);  ///< Channel 8 Event Detection Interrupt Enable
        constexpr uint32_t EVD9 = (1U << 25);  ///< Channel 9 Event Detection Interrupt Enable
        constexpr uint32_t EVD10 = (1U << 26);  ///< Channel 10 Event Detection Interrupt Enable
        constexpr uint32_t EVD11 = (1U << 27);  ///< Channel 11 Event Detection Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t OVR0 = (1U << 0);  ///< Channel 0 Overrun Interrupt Enable
        constexpr uint32_t OVR1 = (1U << 1);  ///< Channel 1 Overrun Interrupt Enable
        constexpr uint32_t OVR2 = (1U << 2);  ///< Channel 2 Overrun Interrupt Enable
        constexpr uint32_t OVR3 = (1U << 3);  ///< Channel 3 Overrun Interrupt Enable
        constexpr uint32_t OVR4 = (1U << 4);  ///< Channel 4 Overrun Interrupt Enable
        constexpr uint32_t OVR5 = (1U << 5);  ///< Channel 5 Overrun Interrupt Enable
        constexpr uint32_t OVR6 = (1U << 6);  ///< Channel 6 Overrun Interrupt Enable
        constexpr uint32_t OVR7 = (1U << 7);  ///< Channel 7 Overrun Interrupt Enable
        constexpr uint32_t EVD0 = (1U << 8);  ///< Channel 0 Event Detection Interrupt Enable
        constexpr uint32_t EVD1 = (1U << 9);  ///< Channel 1 Event Detection Interrupt Enable
        constexpr uint32_t EVD2 = (1U << 10);  ///< Channel 2 Event Detection Interrupt Enable
        constexpr uint32_t EVD3 = (1U << 11);  ///< Channel 3 Event Detection Interrupt Enable
        constexpr uint32_t EVD4 = (1U << 12);  ///< Channel 4 Event Detection Interrupt Enable
        constexpr uint32_t EVD5 = (1U << 13);  ///< Channel 5 Event Detection Interrupt Enable
        constexpr uint32_t EVD6 = (1U << 14);  ///< Channel 6 Event Detection Interrupt Enable
        constexpr uint32_t EVD7 = (1U << 15);  ///< Channel 7 Event Detection Interrupt Enable
        constexpr uint32_t OVR8 = (1U << 16);  ///< Channel 8 Overrun Interrupt Enable
        constexpr uint32_t OVR9 = (1U << 17);  ///< Channel 9 Overrun Interrupt Enable
        constexpr uint32_t OVR10 = (1U << 18);  ///< Channel 10 Overrun Interrupt Enable
        constexpr uint32_t OVR11 = (1U << 19);  ///< Channel 11 Overrun Interrupt Enable
        constexpr uint32_t EVD8 = (1U << 24);  ///< Channel 8 Event Detection Interrupt Enable
        constexpr uint32_t EVD9 = (1U << 25);  ///< Channel 9 Event Detection Interrupt Enable
        constexpr uint32_t EVD10 = (1U << 26);  ///< Channel 10 Event Detection Interrupt Enable
        constexpr uint32_t EVD11 = (1U << 27);  ///< Channel 11 Event Detection Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t OVR0 = (1U << 0);  ///< Channel 0 Overrun
        constexpr uint32_t OVR1 = (1U << 1);  ///< Channel 1 Overrun
        constexpr uint32_t OVR2 = (1U << 2);  ///< Channel 2 Overrun
        constexpr uint32_t OVR3 = (1U << 3);  ///< Channel 3 Overrun
        constexpr uint32_t OVR4 = (1U << 4);  ///< Channel 4 Overrun
        constexpr uint32_t OVR5 = (1U << 5);  ///< Channel 5 Overrun
        constexpr uint32_t OVR6 = (1U << 6);  ///< Channel 6 Overrun
        constexpr uint32_t OVR7 = (1U << 7);  ///< Channel 7 Overrun
        constexpr uint32_t EVD0 = (1U << 8);  ///< Channel 0 Event Detection
        constexpr uint32_t EVD1 = (1U << 9);  ///< Channel 1 Event Detection
        constexpr uint32_t EVD2 = (1U << 10);  ///< Channel 2 Event Detection
        constexpr uint32_t EVD3 = (1U << 11);  ///< Channel 3 Event Detection
        constexpr uint32_t EVD4 = (1U << 12);  ///< Channel 4 Event Detection
        constexpr uint32_t EVD5 = (1U << 13);  ///< Channel 5 Event Detection
        constexpr uint32_t EVD6 = (1U << 14);  ///< Channel 6 Event Detection
        constexpr uint32_t EVD7 = (1U << 15);  ///< Channel 7 Event Detection
        constexpr uint32_t OVR8 = (1U << 16);  ///< Channel 8 Overrun
        constexpr uint32_t OVR9 = (1U << 17);  ///< Channel 9 Overrun
        constexpr uint32_t OVR10 = (1U << 18);  ///< Channel 10 Overrun
        constexpr uint32_t OVR11 = (1U << 19);  ///< Channel 11 Overrun
        constexpr uint32_t EVD8 = (1U << 24);  ///< Channel 8 Event Detection
        constexpr uint32_t EVD9 = (1U << 25);  ///< Channel 9 Event Detection
        constexpr uint32_t EVD10 = (1U << 26);  ///< Channel 10 Event Detection
        constexpr uint32_t EVD11 = (1U << 27);  ///< Channel 11 Event Detection
    }

}

// ============================================================================
// GCLK Peripheral
// ============================================================================

namespace gclk {
    /// Base addresses
    constexpr uint32_t GCLK_BASE = 0x40000C00;

    /// GCLK Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control
        volatile uint32_t STATUS;  ///< Offset: 0x01 - Status
        volatile uint32_t CLKCTRL;  ///< Offset: 0x02 - Generic Clock Control
        volatile uint32_t GENCTRL;  ///< Offset: 0x04 - Generic Clock Generator Control
        volatile uint32_t GENDIV;  ///< Offset: 0x08 - Generic Clock Generator Division
    };

    /// Peripheral instances
    inline Registers* GCLK = reinterpret_cast<Registers*>(GCLK_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SYNCBUSY = (1U << 7);  ///< Synchronization Busy Status
    }

    /// CLKCTRL Register bits
    namespace clkctrl_bits {
        constexpr uint32_t ID = (6 << 0);  ///< Generic Clock Selection ID
        constexpr uint32_t GEN = (4 << 8);  ///< Generic Clock Generator
        constexpr uint32_t CLKEN = (1U << 14);  ///< Clock Enable
        constexpr uint32_t WRTLOCK = (1U << 15);  ///< Write Lock
    }

    /// GENCTRL Register bits
    namespace genctrl_bits {
        constexpr uint32_t ID = (4 << 0);  ///< Generic Clock Generator Selection
        constexpr uint32_t SRC = (5 << 8);  ///< Source Select
        constexpr uint32_t GENEN = (1U << 16);  ///< Generic Clock Generator Enable
        constexpr uint32_t IDC = (1U << 17);  ///< Improve Duty Cycle
        constexpr uint32_t OOV = (1U << 18);  ///< Output Off Value
        constexpr uint32_t OE = (1U << 19);  ///< Output Enable
        constexpr uint32_t DIVSEL = (1U << 20);  ///< Divide Selection
        constexpr uint32_t RUNSTDBY = (1U << 21);  ///< Run in Standby
    }

    /// GENDIV Register bits
    namespace gendiv_bits {
        constexpr uint32_t ID = (4 << 0);  ///< Generic Clock Generator Selection
        constexpr uint32_t DIV = (16 << 8);  ///< Division Factor
    }

}

// ============================================================================
// HMATRIX Peripheral
// ============================================================================

namespace hmatrix {
    /// Base addresses
    constexpr uint32_t HMATRIX_BASE = 0x41007000;

    /// HMATRIX Register structure
    struct Registers {
        volatile uint32_t PRAS%s;  ///< Offset: 0x80 - Priority A for Slave
        volatile uint32_t PRBS%s;  ///< Offset: 0x84 - Priority B for Slave
        volatile uint32_t SFR%s;  ///< Offset: 0x110 - Special Function
    };

    /// Peripheral instances
    inline Registers* HMATRIX = reinterpret_cast<Registers*>(HMATRIX_BASE);

    // Bit definitions
    /// SFR%s Register bits
    namespace sfr%s_bits {
        constexpr uint32_t SFR = (32 << 0);  ///< Special Function Register
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S_BASE = 0x42005000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CLKCTRL%s;  ///< Offset: 0x04 - Clock Unit n Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x0C - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x10 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x14 - Interrupt Flag Status and Clear
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x18 - Synchronization Status
        volatile uint32_t SERCTRL%s;  ///< Offset: 0x20 - Serializer n Control
        volatile uint32_t DATA%s;  ///< Offset: 0x30 - Data n
    };

    /// Peripheral instances
    inline Registers* I2S = reinterpret_cast<Registers*>(I2S_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t CKEN0 = (1U << 2);  ///< Clock Unit 0 Enable
        constexpr uint32_t CKEN1 = (1U << 3);  ///< Clock Unit 1 Enable
        constexpr uint32_t SEREN0 = (1U << 4);  ///< Serializer 0 Enable
        constexpr uint32_t SEREN1 = (1U << 5);  ///< Serializer 1 Enable
    }

    /// CLKCTRL%s Register bits
    namespace clkctrl%s_bits {
        constexpr uint32_t SLOTSIZE = (2 << 0);  ///< Slot Size
        constexpr uint32_t NBSLOTS = (3 << 2);  ///< Number of Slots in Frame
        constexpr uint32_t FSWIDTH = (2 << 5);  ///< Frame Sync Width
        constexpr uint32_t BITDELAY = (1U << 7);  ///< Data Delay from Frame Sync
        constexpr uint32_t FSSEL = (1U << 8);  ///< Frame Sync Select
        constexpr uint32_t FSINV = (1U << 11);  ///< Frame Sync Invert
        constexpr uint32_t SCKSEL = (1U << 12);  ///< Serial Clock Select
        constexpr uint32_t MCKSEL = (1U << 16);  ///< Master Clock Select
        constexpr uint32_t MCKEN = (1U << 18);  ///< Master Clock Enable
        constexpr uint32_t MCKDIV = (5 << 19);  ///< Master Clock Division Factor
        constexpr uint32_t MCKOUTDIV = (5 << 24);  ///< Master Clock Output Division Factor
        constexpr uint32_t FSOUTINV = (1U << 29);  ///< Frame Sync Output Invert
        constexpr uint32_t SCKOUTINV = (1U << 30);  ///< Serial Clock Output Invert
        constexpr uint32_t MCKOUTINV = (1U << 31);  ///< Master Clock Output Invert
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t RXRDY0 = (1U << 0);  ///< Receive Ready 0 Interrupt Enable
        constexpr uint32_t RXRDY1 = (1U << 1);  ///< Receive Ready 1 Interrupt Enable
        constexpr uint32_t RXOR0 = (1U << 4);  ///< Receive Overrun 0 Interrupt Enable
        constexpr uint32_t RXOR1 = (1U << 5);  ///< Receive Overrun 1 Interrupt Enable
        constexpr uint32_t TXRDY0 = (1U << 8);  ///< Transmit Ready 0 Interrupt Enable
        constexpr uint32_t TXRDY1 = (1U << 9);  ///< Transmit Ready 1 Interrupt Enable
        constexpr uint32_t TXUR0 = (1U << 12);  ///< Transmit Underrun 0 Interrupt Enable
        constexpr uint32_t TXUR1 = (1U << 13);  ///< Transmit Underrun 1 Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t RXRDY0 = (1U << 0);  ///< Receive Ready 0 Interrupt Enable
        constexpr uint32_t RXRDY1 = (1U << 1);  ///< Receive Ready 1 Interrupt Enable
        constexpr uint32_t RXOR0 = (1U << 4);  ///< Receive Overrun 0 Interrupt Enable
        constexpr uint32_t RXOR1 = (1U << 5);  ///< Receive Overrun 1 Interrupt Enable
        constexpr uint32_t TXRDY0 = (1U << 8);  ///< Transmit Ready 0 Interrupt Enable
        constexpr uint32_t TXRDY1 = (1U << 9);  ///< Transmit Ready 1 Interrupt Enable
        constexpr uint32_t TXUR0 = (1U << 12);  ///< Transmit Underrun 0 Interrupt Enable
        constexpr uint32_t TXUR1 = (1U << 13);  ///< Transmit Underrun 1 Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t RXRDY0 = (1U << 0);  ///< Receive Ready 0
        constexpr uint32_t RXRDY1 = (1U << 1);  ///< Receive Ready 1
        constexpr uint32_t RXOR0 = (1U << 4);  ///< Receive Overrun 0
        constexpr uint32_t RXOR1 = (1U << 5);  ///< Receive Overrun 1
        constexpr uint32_t TXRDY0 = (1U << 8);  ///< Transmit Ready 0
        constexpr uint32_t TXRDY1 = (1U << 9);  ///< Transmit Ready 1
        constexpr uint32_t TXUR0 = (1U << 12);  ///< Transmit Underrun 0
        constexpr uint32_t TXUR1 = (1U << 13);  ///< Transmit Underrun 1
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchronization Status
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable Synchronization Status
        constexpr uint32_t CKEN0 = (1U << 2);  ///< Clock Unit 0 Enable Synchronization Status
        constexpr uint32_t CKEN1 = (1U << 3);  ///< Clock Unit 1 Enable Synchronization Status
        constexpr uint32_t SEREN0 = (1U << 4);  ///< Serializer 0 Enable Synchronization Status
        constexpr uint32_t SEREN1 = (1U << 5);  ///< Serializer 1 Enable Synchronization Status
        constexpr uint32_t DATA0 = (1U << 8);  ///< Data 0 Synchronization Status
        constexpr uint32_t DATA1 = (1U << 9);  ///< Data 1 Synchronization Status
    }

    /// SERCTRL%s Register bits
    namespace serctrl%s_bits {
        constexpr uint32_t SERMODE = (2 << 0);  ///< Serializer Mode
        constexpr uint32_t TXDEFAULT = (2 << 2);  ///< Line Default Line when Slot Disabled
        constexpr uint32_t TXSAME = (1U << 4);  ///< Transmit Data when Underrun
        constexpr uint32_t CLKSEL = (1U << 5);  ///< Clock Unit Selection
        constexpr uint32_t SLOTADJ = (1U << 7);  ///< Data Slot Formatting Adjust
        constexpr uint32_t DATASIZE = (3 << 8);  ///< Data Word Size
        constexpr uint32_t WORDADJ = (1U << 12);  ///< Data Word Formatting Adjust
        constexpr uint32_t EXTEND = (2 << 13);  ///< Data Formatting Bit Extension
        constexpr uint32_t BITREV = (1U << 15);  ///< Data Formatting Bit Reverse
        constexpr uint32_t SLOTDIS0 = (1U << 16);  ///< Slot 0 Disabled for this Serializer
        constexpr uint32_t SLOTDIS1 = (1U << 17);  ///< Slot 1 Disabled for this Serializer
        constexpr uint32_t SLOTDIS2 = (1U << 18);  ///< Slot 2 Disabled for this Serializer
        constexpr uint32_t SLOTDIS3 = (1U << 19);  ///< Slot 3 Disabled for this Serializer
        constexpr uint32_t SLOTDIS4 = (1U << 20);  ///< Slot 4 Disabled for this Serializer
        constexpr uint32_t SLOTDIS5 = (1U << 21);  ///< Slot 5 Disabled for this Serializer
        constexpr uint32_t SLOTDIS6 = (1U << 22);  ///< Slot 6 Disabled for this Serializer
        constexpr uint32_t SLOTDIS7 = (1U << 23);  ///< Slot 7 Disabled for this Serializer
        constexpr uint32_t MONO = (1U << 24);  ///< Mono Mode
        constexpr uint32_t DMA = (1U << 25);  ///< Single or Multiple DMA Channels
        constexpr uint32_t RXLOOP = (1U << 26);  ///< Loop-back Test Mode
    }

    /// DATA%s Register bits
    namespace data%s_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Sample Data
    }

}

// ============================================================================
// MTB Peripheral
// ============================================================================

namespace mtb {
    /// Base addresses
    constexpr uint32_t MTB_BASE = 0x41006000;

    /// MTB Register structure
    struct Registers {
        volatile uint32_t POSITION;  ///< Offset: 0x00 - MTB Position
        volatile uint32_t MASTER;  ///< Offset: 0x04 - MTB Master
        volatile uint32_t FLOW;  ///< Offset: 0x08 - MTB Flow
        volatile uint32_t BASE;  ///< Offset: 0x0C - MTB Base
        volatile uint32_t ITCTRL;  ///< Offset: 0xF00 - MTB Integration Mode Control
        volatile uint32_t CLAIMSET;  ///< Offset: 0xFA0 - MTB Claim Set
        volatile uint32_t CLAIMCLR;  ///< Offset: 0xFA4 - MTB Claim Clear
        volatile uint32_t LOCKACCESS;  ///< Offset: 0xFB0 - MTB Lock Access
        volatile uint32_t LOCKSTATUS;  ///< Offset: 0xFB4 - MTB Lock Status
        volatile uint32_t AUTHSTATUS;  ///< Offset: 0xFB8 - MTB Authentication Status
        volatile uint32_t DEVARCH;  ///< Offset: 0xFBC - MTB Device Architecture
        volatile uint32_t DEVID;  ///< Offset: 0xFC8 - MTB Device Configuration
        volatile uint32_t DEVTYPE;  ///< Offset: 0xFCC - MTB Device Type
        volatile uint32_t PID4;  ///< Offset: 0xFD0 - CoreSight
        volatile uint32_t PID5;  ///< Offset: 0xFD4 - CoreSight
        volatile uint32_t PID6;  ///< Offset: 0xFD8 - CoreSight
        volatile uint32_t PID7;  ///< Offset: 0xFDC - CoreSight
        volatile uint32_t PID0;  ///< Offset: 0xFE0 - CoreSight
        volatile uint32_t PID1;  ///< Offset: 0xFE4 - CoreSight
        volatile uint32_t PID2;  ///< Offset: 0xFE8 - CoreSight
        volatile uint32_t PID3;  ///< Offset: 0xFEC - CoreSight
        volatile uint32_t CID0;  ///< Offset: 0xFF0 - CoreSight
        volatile uint32_t CID1;  ///< Offset: 0xFF4 - CoreSight
        volatile uint32_t CID2;  ///< Offset: 0xFF8 - CoreSight
        volatile uint32_t CID3;  ///< Offset: 0xFFC - CoreSight
    };

    /// Peripheral instances
    inline Registers* MTB = reinterpret_cast<Registers*>(MTB_BASE);

    // Bit definitions
    /// POSITION Register bits
    namespace position_bits {
        constexpr uint32_t WRAP = (1U << 2);  ///< Pointer Value Wraps
        constexpr uint32_t POINTER = (29 << 3);  ///< Trace Packet Location Pointer
    }

    /// MASTER Register bits
    namespace master_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< Maximum Value of the Trace Buffer in SRAM
        constexpr uint32_t TSTARTEN = (1U << 5);  ///< Trace Start Input Enable
        constexpr uint32_t TSTOPEN = (1U << 6);  ///< Trace Stop Input Enable
        constexpr uint32_t SFRWPRIV = (1U << 7);  ///< Special Function Register Write Privilege
        constexpr uint32_t RAMPRIV = (1U << 8);  ///< SRAM Privilege
        constexpr uint32_t HALTREQ = (1U << 9);  ///< Halt Request
        constexpr uint32_t EN = (1U << 31);  ///< Main Trace Enable
    }

    /// FLOW Register bits
    namespace flow_bits {
        constexpr uint32_t AUTOSTOP = (1U << 0);  ///< Auto Stop Tracing
        constexpr uint32_t AUTOHALT = (1U << 1);  ///< Auto Halt Request
        constexpr uint32_t WATERMARK = (29 << 3);  ///< Watermark value
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t NVMCTRL_BASE = 0x41004000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x04 - Control B
        volatile uint32_t PARAM;  ///< Offset: 0x08 - NVM Parameter
        volatile uint32_t INTENCLR;  ///< Offset: 0x0C - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x10 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x14 - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x18 - Status
        volatile uint32_t ADDR;  ///< Offset: 0x1C - Address
        volatile uint32_t LOCK;  ///< Offset: 0x20 - Lock Section
    };

    /// Peripheral instances
    inline Registers* NVMCTRL = reinterpret_cast<Registers*>(NVMCTRL_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t CMD = (7 << 0);  ///< Command
        constexpr uint32_t CMDEX = (8 << 8);  ///< Command Execution
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t RWS = (4 << 1);  ///< NVM Read Wait States
        constexpr uint32_t MANW = (1U << 7);  ///< Manual Write
        constexpr uint32_t SLEEPPRM = (2 << 8);  ///< Power Reduction Mode during Sleep
        constexpr uint32_t READMODE = (2 << 16);  ///< NVMCTRL Read Mode
        constexpr uint32_t CACHEDIS = (1U << 18);  ///< Cache Disable
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t NVMP = (16 << 0);  ///< NVM Pages
        constexpr uint32_t PSZ = (3 << 16);  ///< Page Size
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 0);  ///< NVM Ready Interrupt Enable
        constexpr uint32_t ERROR = (1U << 1);  ///< Error Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 0);  ///< NVM Ready Interrupt Enable
        constexpr uint32_t ERROR = (1U << 1);  ///< Error Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t READY = (1U << 0);  ///< NVM Ready
        constexpr uint32_t ERROR = (1U << 1);  ///< Error
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t PRM = (1U << 0);  ///< Power Reduction Mode
        constexpr uint32_t LOAD = (1U << 1);  ///< NVM Page Buffer Active Loading
        constexpr uint32_t PROGE = (1U << 2);  ///< Programming Error Status
        constexpr uint32_t LOCKE = (1U << 3);  ///< Lock Error Status
        constexpr uint32_t NVME = (1U << 4);  ///< NVM Error
        constexpr uint32_t SB = (1U << 8);  ///< Security Bit Status
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (22 << 0);  ///< NVM Address
    }

    /// LOCK Register bits
    namespace lock_bits {
        constexpr uint32_t LOCK = (16 << 0);  ///< Region Lock Bits
    }

}

// ============================================================================
// PAC0 Peripheral
// ============================================================================

namespace pac0 {
    /// Base addresses
    constexpr uint32_t PAC0_BASE = 0x40000000;

    /// PAC0 Register structure
    struct Registers {
        volatile uint32_t WPCLR;  ///< Offset: 0x00 - Write Protection Clear
        volatile uint32_t WPSET;  ///< Offset: 0x04 - Write Protection Set
    };

    /// Peripheral instances
    inline Registers* PAC0 = reinterpret_cast<Registers*>(PAC0_BASE);

    // Bit definitions
    /// WPCLR Register bits
    namespace wpclr_bits {
        constexpr uint32_t WP = (31 << 1);  ///< Write Protection Clear
    }

    /// WPSET Register bits
    namespace wpset_bits {
        constexpr uint32_t WP = (31 << 1);  ///< Write Protection Set
    }

}

// ============================================================================
// PAC1 Peripheral
// ============================================================================

namespace pac1 {
    /// Base addresses
    constexpr uint32_t PAC1_BASE = 0x41000000;

    /// PAC1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* PAC1 = reinterpret_cast<Registers*>(PAC1_BASE);

}

// ============================================================================
// PAC2 Peripheral
// ============================================================================

namespace pac2 {
    /// Base addresses
    constexpr uint32_t PAC2_BASE = 0x42000000;

    /// PAC2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* PAC2 = reinterpret_cast<Registers*>(PAC2_BASE);

}

// ============================================================================
// PM Peripheral
// ============================================================================

namespace pm {
    /// Base addresses
    constexpr uint32_t PM_BASE = 0x40000400;

    /// PM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control
        volatile uint32_t SLEEP;  ///< Offset: 0x01 - Sleep Mode
        volatile uint32_t CPUSEL;  ///< Offset: 0x08 - CPU Clock Select
        volatile uint32_t APBASEL;  ///< Offset: 0x09 - APBA Clock Select
        volatile uint32_t APBBSEL;  ///< Offset: 0x0A - APBB Clock Select
        volatile uint32_t APBCSEL;  ///< Offset: 0x0B - APBC Clock Select
        volatile uint32_t AHBMASK;  ///< Offset: 0x14 - AHB Mask
        volatile uint32_t APBAMASK;  ///< Offset: 0x18 - APBA Mask
        volatile uint32_t APBBMASK;  ///< Offset: 0x1C - APBB Mask
        volatile uint32_t APBCMASK;  ///< Offset: 0x20 - APBC Mask
        volatile uint32_t INTENCLR;  ///< Offset: 0x34 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x35 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x36 - Interrupt Flag Status and Clear
        volatile uint32_t RCAUSE;  ///< Offset: 0x38 - Reset Cause
    };

    /// Peripheral instances
    inline Registers* PM = reinterpret_cast<Registers*>(PM_BASE);

    // Bit definitions
    /// SLEEP Register bits
    namespace sleep_bits {
        constexpr uint32_t IDLE = (2 << 0);  ///< Idle Mode Configuration
    }

    /// CPUSEL Register bits
    namespace cpusel_bits {
        constexpr uint32_t CPUDIV = (3 << 0);  ///< CPU Prescaler Selection
    }

    /// APBASEL Register bits
    namespace apbasel_bits {
        constexpr uint32_t APBADIV = (3 << 0);  ///< APBA Prescaler Selection
    }

    /// APBBSEL Register bits
    namespace apbbsel_bits {
        constexpr uint32_t APBBDIV = (3 << 0);  ///< APBB Prescaler Selection
    }

    /// APBCSEL Register bits
    namespace apbcsel_bits {
        constexpr uint32_t APBCDIV = (3 << 0);  ///< APBC Prescaler Selection
    }

    /// AHBMASK Register bits
    namespace ahbmask_bits {
        constexpr uint32_t HPB0_ = (1U << 0);  ///< HPB0 AHB Clock Mask
        constexpr uint32_t HPB1_ = (1U << 1);  ///< HPB1 AHB Clock Mask
        constexpr uint32_t HPB2_ = (1U << 2);  ///< HPB2 AHB Clock Mask
        constexpr uint32_t DSU_ = (1U << 3);  ///< DSU AHB Clock Mask
        constexpr uint32_t NVMCTRL_ = (1U << 4);  ///< NVMCTRL AHB Clock Mask
        constexpr uint32_t DMAC_ = (1U << 5);  ///< DMAC AHB Clock Mask
        constexpr uint32_t USB_ = (1U << 6);  ///< USB AHB Clock Mask
    }

    /// APBAMASK Register bits
    namespace apbamask_bits {
        constexpr uint32_t PAC0_ = (1U << 0);  ///< PAC0 APB Clock Enable
        constexpr uint32_t PM_ = (1U << 1);  ///< PM APB Clock Enable
        constexpr uint32_t SYSCTRL_ = (1U << 2);  ///< SYSCTRL APB Clock Enable
        constexpr uint32_t GCLK_ = (1U << 3);  ///< GCLK APB Clock Enable
        constexpr uint32_t WDT_ = (1U << 4);  ///< WDT APB Clock Enable
        constexpr uint32_t RTC_ = (1U << 5);  ///< RTC APB Clock Enable
        constexpr uint32_t EIC_ = (1U << 6);  ///< EIC APB Clock Enable
    }

    /// APBBMASK Register bits
    namespace apbbmask_bits {
        constexpr uint32_t PAC1_ = (1U << 0);  ///< PAC1 APB Clock Enable
        constexpr uint32_t DSU_ = (1U << 1);  ///< DSU APB Clock Enable
        constexpr uint32_t NVMCTRL_ = (1U << 2);  ///< NVMCTRL APB Clock Enable
        constexpr uint32_t PORT_ = (1U << 3);  ///< PORT APB Clock Enable
        constexpr uint32_t DMAC_ = (1U << 4);  ///< DMAC APB Clock Enable
        constexpr uint32_t USB_ = (1U << 5);  ///< USB APB Clock Enable
        constexpr uint32_t HMATRIX_ = (1U << 6);  ///< HMATRIX APB Clock Enable
    }

    /// APBCMASK Register bits
    namespace apbcmask_bits {
        constexpr uint32_t PAC2_ = (1U << 0);  ///< PAC2 APB Clock Enable
        constexpr uint32_t EVSYS_ = (1U << 1);  ///< EVSYS APB Clock Enable
        constexpr uint32_t SERCOM0_ = (1U << 2);  ///< SERCOM0 APB Clock Enable
        constexpr uint32_t SERCOM1_ = (1U << 3);  ///< SERCOM1 APB Clock Enable
        constexpr uint32_t SERCOM2_ = (1U << 4);  ///< SERCOM2 APB Clock Enable
        constexpr uint32_t SERCOM3_ = (1U << 5);  ///< SERCOM3 APB Clock Enable
        constexpr uint32_t SERCOM4_ = (1U << 6);  ///< SERCOM4 APB Clock Enable
        constexpr uint32_t SERCOM5_ = (1U << 7);  ///< SERCOM5 APB Clock Enable
        constexpr uint32_t TCC0_ = (1U << 8);  ///< TCC0 APB Clock Enable
        constexpr uint32_t TCC1_ = (1U << 9);  ///< TCC1 APB Clock Enable
        constexpr uint32_t TCC2_ = (1U << 10);  ///< TCC2 APB Clock Enable
        constexpr uint32_t TC3_ = (1U << 11);  ///< TC3 APB Clock Enable
        constexpr uint32_t TC4_ = (1U << 12);  ///< TC4 APB Clock Enable
        constexpr uint32_t TC5_ = (1U << 13);  ///< TC5 APB Clock Enable
        constexpr uint32_t TC6_ = (1U << 14);  ///< TC6 APB Clock Enable
        constexpr uint32_t TC7_ = (1U << 15);  ///< TC7 APB Clock Enable
        constexpr uint32_t ADC_ = (1U << 16);  ///< ADC APB Clock Enable
        constexpr uint32_t AC_ = (1U << 17);  ///< AC APB Clock Enable
        constexpr uint32_t DAC_ = (1U << 18);  ///< DAC APB Clock Enable
        constexpr uint32_t PTC_ = (1U << 19);  ///< PTC APB Clock Enable
        constexpr uint32_t I2S_ = (1U << 20);  ///< I2S APB Clock Enable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t CKRDY = (1U << 0);  ///< Clock Ready Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t CKRDY = (1U << 0);  ///< Clock Ready Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t CKRDY = (1U << 0);  ///< Clock Ready
    }

    /// RCAUSE Register bits
    namespace rcause_bits {
        constexpr uint32_t POR = (1U << 0);  ///< Power On Reset
        constexpr uint32_t BOD12 = (1U << 1);  ///< Brown Out 12 Detector Reset
        constexpr uint32_t BOD33 = (1U << 2);  ///< Brown Out 33 Detector Reset
        constexpr uint32_t EXT = (1U << 4);  ///< External Reset
        constexpr uint32_t WDT = (1U << 5);  ///< Watchdog Reset
        constexpr uint32_t SYST = (1U << 6);  ///< System Reset Request
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT_BASE = 0x41004400;
    constexpr uint32_t PORT_IOBUS_BASE = 0x60000000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t DIR%s;  ///< Offset: 0x00 - Data Direction
        volatile uint32_t DIRCLR%s;  ///< Offset: 0x04 - Data Direction Clear
        volatile uint32_t DIRSET%s;  ///< Offset: 0x08 - Data Direction Set
        volatile uint32_t DIRTGL%s;  ///< Offset: 0x0C - Data Direction Toggle
        volatile uint32_t OUT%s;  ///< Offset: 0x10 - Data Output Value
        volatile uint32_t OUTCLR%s;  ///< Offset: 0x14 - Data Output Value Clear
        volatile uint32_t OUTSET%s;  ///< Offset: 0x18 - Data Output Value Set
        volatile uint32_t OUTTGL%s;  ///< Offset: 0x1C - Data Output Value Toggle
        volatile uint32_t IN%s;  ///< Offset: 0x20 - Data Input Value
        volatile uint32_t CTRL%s;  ///< Offset: 0x24 - Control
        volatile uint32_t WRCONFIG%s;  ///< Offset: 0x28 - Write Configuration
        volatile uint32_t PMUX0_%s;  ///< Offset: 0x30 - Peripheral Multiplexing n - Group 0
        volatile uint32_t PMUX1_%s;  ///< Offset: 0xB0 - Peripheral Multiplexing n - Group 1
        volatile uint32_t PINCFG0_%s;  ///< Offset: 0x40 - Pin Configuration n - Group 0
        volatile uint32_t PINCFG1_%s;  ///< Offset: 0xC0 - Pin Configuration n - Group 1
    };

    /// Peripheral instances
    inline Registers* PORT = reinterpret_cast<Registers*>(PORT_BASE);
    inline Registers* PORT_IOBUS = reinterpret_cast<Registers*>(PORT_IOBUS_BASE);

    // Bit definitions
    /// DIR%s Register bits
    namespace dir%s_bits {
        constexpr uint32_t DIR = (32 << 0);  ///< Port Data Direction
    }

    /// DIRCLR%s Register bits
    namespace dirclr%s_bits {
        constexpr uint32_t DIRCLR = (32 << 0);  ///< Port Data Direction Clear
    }

    /// DIRSET%s Register bits
    namespace dirset%s_bits {
        constexpr uint32_t DIRSET = (32 << 0);  ///< Port Data Direction Set
    }

    /// DIRTGL%s Register bits
    namespace dirtgl%s_bits {
        constexpr uint32_t DIRTGL = (32 << 0);  ///< Port Data Direction Toggle
    }

    /// OUT%s Register bits
    namespace out%s_bits {
        constexpr uint32_t OUT = (32 << 0);  ///< Port Data Output Value
    }

    /// OUTCLR%s Register bits
    namespace outclr%s_bits {
        constexpr uint32_t OUTCLR = (32 << 0);  ///< Port Data Output Value Clear
    }

    /// OUTSET%s Register bits
    namespace outset%s_bits {
        constexpr uint32_t OUTSET = (32 << 0);  ///< Port Data Output Value Set
    }

    /// OUTTGL%s Register bits
    namespace outtgl%s_bits {
        constexpr uint32_t OUTTGL = (32 << 0);  ///< Port Data Output Value Toggle
    }

    /// IN%s Register bits
    namespace in%s_bits {
        constexpr uint32_t IN = (32 << 0);  ///< Port Data Input Value
    }

    /// CTRL%s Register bits
    namespace ctrl%s_bits {
        constexpr uint32_t SAMPLING = (32 << 0);  ///< Input Sampling Mode
    }

    /// WRCONFIG%s Register bits
    namespace wrconfig%s_bits {
        constexpr uint32_t PINMASK = (16 << 0);  ///< Pin Mask for Multiple Pin Configuration
        constexpr uint32_t PMUXEN = (1U << 16);  ///< Peripheral Multiplexer Enable
        constexpr uint32_t INEN = (1U << 17);  ///< Input Enable
        constexpr uint32_t PULLEN = (1U << 18);  ///< Pull Enable
        constexpr uint32_t DRVSTR = (1U << 22);  ///< Output Driver Strength Selection
        constexpr uint32_t PMUX = (4 << 24);  ///< Peripheral Multiplexing
        constexpr uint32_t WRPMUX = (1U << 28);  ///< Write PMUX
        constexpr uint32_t WRPINCFG = (1U << 30);  ///< Write PINCFG
        constexpr uint32_t HWSEL = (1U << 31);  ///< Half-Word Select
    }

    /// PMUX0_%s Register bits
    namespace pmux0_%s_bits {
        constexpr uint32_t PMUXE = (4 << 0);  ///< Peripheral Multiplexing Even
        constexpr uint32_t PMUXO = (4 << 4);  ///< Peripheral Multiplexing Odd
    }

    /// PINCFG0_%s Register bits
    namespace pincfg0_%s_bits {
        constexpr uint32_t PMUXEN = (1U << 0);  ///< Peripheral Multiplexer Enable
        constexpr uint32_t INEN = (1U << 1);  ///< Input Enable
        constexpr uint32_t PULLEN = (1U << 2);  ///< Pull Enable
        constexpr uint32_t DRVSTR = (1U << 6);  ///< Output Driver Strength Selection
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40001400;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - MODE2 Control
        volatile uint32_t READREQ;  ///< Offset: 0x02 - Read Request
        volatile uint32_t EVCTRL;  ///< Offset: 0x04 - MODE2 Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x06 - MODE2 Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x07 - MODE2 Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x08 - MODE2 Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x0A - Status
        volatile uint32_t DBGCTRL;  ///< Offset: 0x0B - Debug Control
        volatile uint32_t FREQCORR;  ///< Offset: 0x0C - Frequency Correction
        volatile uint32_t COUNT;  ///< Offset: 0x10 - MODE1 Counter Value
        volatile uint32_t COMP%s;  ///< Offset: 0x18 - MODE1 Compare n Value
        volatile uint32_t PER;  ///< Offset: 0x14 - MODE1 Counter Period
        volatile uint32_t CLOCK;  ///< Offset: 0x10 - MODE2 Clock Value
        volatile uint32_t ALARM%s;  ///< Offset: 0x18 - MODE2 Alarm n Value
        volatile uint32_t MASK%s;  ///< Offset: 0x1C - MODE2 Alarm n Mask
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t MODE = (2 << 2);  ///< Operating Mode
        constexpr uint32_t CLKREP = (1U << 6);  ///< Clock Representation
        constexpr uint32_t MATCHCLR = (1U << 7);  ///< Clear on Match
        constexpr uint32_t PRESCALER = (4 << 8);  ///< Prescaler
    }

    /// READREQ Register bits
    namespace readreq_bits {
        constexpr uint32_t ADDR = (6 << 0);  ///< Address
        constexpr uint32_t RCONT = (1U << 14);  ///< Read Continuously
        constexpr uint32_t RREQ = (1U << 15);  ///< Read Request
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t PEREO0 = (1U << 0);  ///< Periodic Interval 0 Event Output Enable
        constexpr uint32_t PEREO1 = (1U << 1);  ///< Periodic Interval 1 Event Output Enable
        constexpr uint32_t PEREO2 = (1U << 2);  ///< Periodic Interval 2 Event Output Enable
        constexpr uint32_t PEREO3 = (1U << 3);  ///< Periodic Interval 3 Event Output Enable
        constexpr uint32_t PEREO4 = (1U << 4);  ///< Periodic Interval 4 Event Output Enable
        constexpr uint32_t PEREO5 = (1U << 5);  ///< Periodic Interval 5 Event Output Enable
        constexpr uint32_t PEREO6 = (1U << 6);  ///< Periodic Interval 6 Event Output Enable
        constexpr uint32_t PEREO7 = (1U << 7);  ///< Periodic Interval 7 Event Output Enable
        constexpr uint32_t ALARMEO0 = (1U << 8);  ///< Alarm 0 Event Output Enable
        constexpr uint32_t OVFEO = (1U << 15);  ///< Overflow Event Output Enable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t ALARM0 = (1U << 0);  ///< Alarm 0 Interrupt Enable
        constexpr uint32_t SYNCRDY = (1U << 6);  ///< Synchronization Ready Interrupt Enable
        constexpr uint32_t OVF = (1U << 7);  ///< Overflow Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t ALARM0 = (1U << 0);  ///< Alarm 0 Interrupt Enable
        constexpr uint32_t SYNCRDY = (1U << 6);  ///< Synchronization Ready Interrupt Enable
        constexpr uint32_t OVF = (1U << 7);  ///< Overflow Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t ALARM0 = (1U << 0);  ///< Alarm 0
        constexpr uint32_t SYNCRDY = (1U << 6);  ///< Synchronization Ready
        constexpr uint32_t OVF = (1U << 7);  ///< Overflow
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SYNCBUSY = (1U << 7);  ///< Synchronization Busy
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Run During Debug
    }

    /// FREQCORR Register bits
    namespace freqcorr_bits {
        constexpr uint32_t VALUE = (7 << 0);  ///< Correction Value
        constexpr uint32_t SIGN = (1U << 7);  ///< Correction Sign
    }

    /// COUNT Register bits
    namespace count_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// COMP%s Register bits
    namespace comp%s_bits {
        constexpr uint32_t COMP = (16 << 0);  ///< Compare Value
    }

    /// PER Register bits
    namespace per_bits {
        constexpr uint32_t PER = (16 << 0);  ///< Counter Period
    }

    /// CLOCK Register bits
    namespace clock_bits {
        constexpr uint32_t SECOND = (6 << 0);  ///< Second
        constexpr uint32_t MINUTE = (6 << 6);  ///< Minute
        constexpr uint32_t HOUR = (5 << 12);  ///< Hour
        constexpr uint32_t DAY = (5 << 17);  ///< Day
        constexpr uint32_t MONTH = (4 << 22);  ///< Month
        constexpr uint32_t YEAR = (6 << 26);  ///< Year
    }

    /// ALARM%s Register bits
    namespace alarm%s_bits {
        constexpr uint32_t SECOND = (6 << 0);  ///< Second
        constexpr uint32_t MINUTE = (6 << 6);  ///< Minute
        constexpr uint32_t HOUR = (5 << 12);  ///< Hour
        constexpr uint32_t DAY = (5 << 17);  ///< Day
        constexpr uint32_t MONTH = (4 << 22);  ///< Month
        constexpr uint32_t YEAR = (6 << 26);  ///< Year
    }

    /// MASK%s Register bits
    namespace mask%s_bits {
        constexpr uint32_t SEL = (3 << 0);  ///< Alarm Mask Selection
    }

}

// ============================================================================
// SERCOM Peripheral
// ============================================================================

namespace sercom {
    /// Base addresses
    constexpr uint32_t SERCOM0_BASE = 0x42000800;
    constexpr uint32_t SERCOM1_BASE = 0x42000C00;
    constexpr uint32_t SERCOM2_BASE = 0x42001000;
    constexpr uint32_t SERCOM3_BASE = 0x42001400;
    constexpr uint32_t SERCOM4_BASE = 0x42001800;
    constexpr uint32_t SERCOM5_BASE = 0x42001C00;

    /// SERCOM Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - USART Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x04 - USART Control B
        volatile uint32_t BAUD;  ///< Offset: 0x0C - USART Baud Rate
        volatile uint32_t INTENCLR;  ///< Offset: 0x14 - USART Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x16 - USART Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x18 - USART Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x1A - USART Status
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x1C - USART Syncbusy
        volatile uint32_t ADDR;  ///< Offset: 0x24 - SPI Address
        volatile uint32_t DATA;  ///< Offset: 0x28 - USART Data
        volatile uint32_t DBGCTRL;  ///< Offset: 0x30 - USART Debug Control
        volatile uint32_t BAUD_FRAC_MODE;  ///< Offset: 0x0C - USART Baud Rate
        volatile uint32_t BAUD_FRACFP_MODE;  ///< Offset: 0x0C - USART Baud Rate
        volatile uint32_t BAUD_USARTFP_MODE;  ///< Offset: 0x0C - USART Baud Rate
        volatile uint32_t RXPL;  ///< Offset: 0x0E - USART Receive Pulse Length
    };

    /// Peripheral instances
    inline Registers* SERCOM0 = reinterpret_cast<Registers*>(SERCOM0_BASE);
    inline Registers* SERCOM1 = reinterpret_cast<Registers*>(SERCOM1_BASE);
    inline Registers* SERCOM2 = reinterpret_cast<Registers*>(SERCOM2_BASE);
    inline Registers* SERCOM3 = reinterpret_cast<Registers*>(SERCOM3_BASE);
    inline Registers* SERCOM4 = reinterpret_cast<Registers*>(SERCOM4_BASE);
    inline Registers* SERCOM5 = reinterpret_cast<Registers*>(SERCOM5_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t MODE = (3 << 2);  ///< Operating Mode
        constexpr uint32_t RUNSTDBY = (1U << 7);  ///< Run during Standby
        constexpr uint32_t IBON = (1U << 8);  ///< Immediate Buffer Overflow Notification
        constexpr uint32_t SAMPR = (3 << 13);  ///< Sample
        constexpr uint32_t TXPO = (2 << 16);  ///< Transmit Data Pinout
        constexpr uint32_t RXPO = (2 << 20);  ///< Receive Data Pinout
        constexpr uint32_t SAMPA = (2 << 22);  ///< Sample Adjustment
        constexpr uint32_t FORM = (4 << 24);  ///< Frame Format
        constexpr uint32_t CMODE = (1U << 28);  ///< Communication Mode
        constexpr uint32_t CPOL = (1U << 29);  ///< Clock Polarity
        constexpr uint32_t DORD = (1U << 30);  ///< Data Order
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t CHSIZE = (3 << 0);  ///< Character Size
        constexpr uint32_t SBMODE = (1U << 6);  ///< Stop Bit Mode
        constexpr uint32_t COLDEN = (1U << 8);  ///< Collision Detection Enable
        constexpr uint32_t SFDE = (1U << 9);  ///< Start of Frame Detection Enable
        constexpr uint32_t ENC = (1U << 10);  ///< Encoding Format
        constexpr uint32_t PMODE = (1U << 13);  ///< Parity Mode
        constexpr uint32_t TXEN = (1U << 16);  ///< Transmitter Enable
        constexpr uint32_t RXEN = (1U << 17);  ///< Receiver Enable
    }

    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t BAUD = (16 << 0);  ///< Baud Rate Value
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t DRE = (1U << 0);  ///< Data Register Empty Interrupt Disable
        constexpr uint32_t TXC = (1U << 1);  ///< Transmit Complete Interrupt Disable
        constexpr uint32_t RXC = (1U << 2);  ///< Receive Complete Interrupt Disable
        constexpr uint32_t RXS = (1U << 3);  ///< Receive Start Interrupt Disable
        constexpr uint32_t CTSIC = (1U << 4);  ///< Clear To Send Input Change Interrupt Disable
        constexpr uint32_t RXBRK = (1U << 5);  ///< Break Received Interrupt Disable
        constexpr uint32_t ERROR = (1U << 7);  ///< Combined Error Interrupt Disable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t DRE = (1U << 0);  ///< Data Register Empty Interrupt Enable
        constexpr uint32_t TXC = (1U << 1);  ///< Transmit Complete Interrupt Enable
        constexpr uint32_t RXC = (1U << 2);  ///< Receive Complete Interrupt Enable
        constexpr uint32_t RXS = (1U << 3);  ///< Receive Start Interrupt Enable
        constexpr uint32_t CTSIC = (1U << 4);  ///< Clear To Send Input Change Interrupt Enable
        constexpr uint32_t RXBRK = (1U << 5);  ///< Break Received Interrupt Enable
        constexpr uint32_t ERROR = (1U << 7);  ///< Combined Error Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t DRE = (1U << 0);  ///< Data Register Empty Interrupt
        constexpr uint32_t TXC = (1U << 1);  ///< Transmit Complete Interrupt
        constexpr uint32_t RXC = (1U << 2);  ///< Receive Complete Interrupt
        constexpr uint32_t RXS = (1U << 3);  ///< Receive Start Interrupt
        constexpr uint32_t CTSIC = (1U << 4);  ///< Clear To Send Input Change Interrupt
        constexpr uint32_t RXBRK = (1U << 5);  ///< Break Received Interrupt
        constexpr uint32_t ERROR = (1U << 7);  ///< Combined Error Interrupt
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t PERR = (1U << 0);  ///< Parity Error
        constexpr uint32_t FERR = (1U << 1);  ///< Frame Error
        constexpr uint32_t BUFOVF = (1U << 2);  ///< Buffer Overflow
        constexpr uint32_t CTS = (1U << 3);  ///< Clear To Send
        constexpr uint32_t ISF = (1U << 4);  ///< Inconsistent Sync Field
        constexpr uint32_t COLL = (1U << 5);  ///< Collision Detected
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchronization Busy
        constexpr uint32_t ENABLE = (1U << 1);  ///< SERCOM Enable Synchronization Busy
        constexpr uint32_t CTRLB = (1U << 2);  ///< CTRLB Synchronization Busy
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (8 << 0);  ///< Address Value
        constexpr uint32_t ADDRMASK = (8 << 16);  ///< Address Mask
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (9 << 0);  ///< Data Value
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGSTOP = (1U << 0);  ///< Debug Mode
    }

    /// BAUD_FRAC_MODE Register bits
    namespace baud_frac_mode_bits {
        constexpr uint32_t BAUD = (13 << 0);  ///< Baud Rate Value
        constexpr uint32_t FP = (3 << 13);  ///< Fractional Part
    }

    /// BAUD_FRACFP_MODE Register bits
    namespace baud_fracfp_mode_bits {
        constexpr uint32_t BAUD = (13 << 0);  ///< Baud Rate Value
        constexpr uint32_t FP = (3 << 13);  ///< Fractional Part
    }

    /// BAUD_USARTFP_MODE Register bits
    namespace baud_usartfp_mode_bits {
        constexpr uint32_t BAUD = (16 << 0);  ///< Baud Rate Value
    }

    /// RXPL Register bits
    namespace rxpl_bits {
        constexpr uint32_t RXPL = (8 << 0);  ///< Receive Pulse Length
    }

}

// ============================================================================
// SYSCTRL Peripheral
// ============================================================================

namespace sysctrl {
    /// Base addresses
    constexpr uint32_t SYSCTRL_BASE = 0x40000800;

    /// SYSCTRL Register structure
    struct Registers {
        volatile uint32_t INTENCLR;  ///< Offset: 0x00 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x04 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x08 - Interrupt Flag Status and Clear
        volatile uint32_t PCLKSR;  ///< Offset: 0x0C - Power and Clocks Status
        volatile uint32_t XOSC;  ///< Offset: 0x10 - External Multipurpose Crystal Oscillator (XOSC) Control
        volatile uint32_t XOSC32K;  ///< Offset: 0x14 - 32kHz External Crystal Oscillator (XOSC32K) Control
        volatile uint32_t OSC32K;  ///< Offset: 0x18 - 32kHz Internal Oscillator (OSC32K) Control
        volatile uint32_t OSCULP32K;  ///< Offset: 0x1C - 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control
        volatile uint32_t OSC8M;  ///< Offset: 0x20 - 8MHz Internal Oscillator (OSC8M) Control
        volatile uint32_t DFLLCTRL;  ///< Offset: 0x24 - DFLL48M Control
        volatile uint32_t DFLLVAL;  ///< Offset: 0x28 - DFLL48M Value
        volatile uint32_t DFLLMUL;  ///< Offset: 0x2C - DFLL48M Multiplier
        volatile uint32_t DFLLSYNC;  ///< Offset: 0x30 - DFLL48M Synchronization
        volatile uint32_t BOD33;  ///< Offset: 0x34 - 3.3V Brown-Out Detector (BOD33) Control
        volatile uint32_t VREG;  ///< Offset: 0x3C - Voltage Regulator System (VREG) Control
        volatile uint32_t VREF;  ///< Offset: 0x40 - Voltage References System (VREF) Control
        volatile uint32_t DPLLCTRLA;  ///< Offset: 0x44 - DPLL Control A
        volatile uint32_t DPLLRATIO;  ///< Offset: 0x48 - DPLL Ratio Control
        volatile uint32_t DPLLCTRLB;  ///< Offset: 0x4C - DPLL Control B
        volatile uint32_t DPLLSTATUS;  ///< Offset: 0x50 - DPLL Status
    };

    /// Peripheral instances
    inline Registers* SYSCTRL = reinterpret_cast<Registers*>(SYSCTRL_BASE);

    // Bit definitions
    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t XOSCRDY = (1U << 0);  ///< XOSC Ready Interrupt Enable
        constexpr uint32_t XOSC32KRDY = (1U << 1);  ///< XOSC32K Ready Interrupt Enable
        constexpr uint32_t OSC32KRDY = (1U << 2);  ///< OSC32K Ready Interrupt Enable
        constexpr uint32_t OSC8MRDY = (1U << 3);  ///< OSC8M Ready Interrupt Enable
        constexpr uint32_t DFLLRDY = (1U << 4);  ///< DFLL Ready Interrupt Enable
        constexpr uint32_t DFLLOOB = (1U << 5);  ///< DFLL Out Of Bounds Interrupt Enable
        constexpr uint32_t DFLLLCKF = (1U << 6);  ///< DFLL Lock Fine Interrupt Enable
        constexpr uint32_t DFLLLCKC = (1U << 7);  ///< DFLL Lock Coarse Interrupt Enable
        constexpr uint32_t DFLLRCS = (1U << 8);  ///< DFLL Reference Clock Stopped Interrupt Enable
        constexpr uint32_t BOD33RDY = (1U << 9);  ///< BOD33 Ready Interrupt Enable
        constexpr uint32_t BOD33DET = (1U << 10);  ///< BOD33 Detection Interrupt Enable
        constexpr uint32_t B33SRDY = (1U << 11);  ///< BOD33 Synchronization Ready Interrupt Enable
        constexpr uint32_t DPLLLCKR = (1U << 15);  ///< DPLL Lock Rise Interrupt Enable
        constexpr uint32_t DPLLLCKF = (1U << 16);  ///< DPLL Lock Fall Interrupt Enable
        constexpr uint32_t DPLLLTO = (1U << 17);  ///< DPLL Lock Timeout Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t XOSCRDY = (1U << 0);  ///< XOSC Ready Interrupt Enable
        constexpr uint32_t XOSC32KRDY = (1U << 1);  ///< XOSC32K Ready Interrupt Enable
        constexpr uint32_t OSC32KRDY = (1U << 2);  ///< OSC32K Ready Interrupt Enable
        constexpr uint32_t OSC8MRDY = (1U << 3);  ///< OSC8M Ready Interrupt Enable
        constexpr uint32_t DFLLRDY = (1U << 4);  ///< DFLL Ready Interrupt Enable
        constexpr uint32_t DFLLOOB = (1U << 5);  ///< DFLL Out Of Bounds Interrupt Enable
        constexpr uint32_t DFLLLCKF = (1U << 6);  ///< DFLL Lock Fine Interrupt Enable
        constexpr uint32_t DFLLLCKC = (1U << 7);  ///< DFLL Lock Coarse Interrupt Enable
        constexpr uint32_t DFLLRCS = (1U << 8);  ///< DFLL Reference Clock Stopped Interrupt Enable
        constexpr uint32_t BOD33RDY = (1U << 9);  ///< BOD33 Ready Interrupt Enable
        constexpr uint32_t BOD33DET = (1U << 10);  ///< BOD33 Detection Interrupt Enable
        constexpr uint32_t B33SRDY = (1U << 11);  ///< BOD33 Synchronization Ready Interrupt Enable
        constexpr uint32_t DPLLLCKR = (1U << 15);  ///< DPLL Lock Rise Interrupt Enable
        constexpr uint32_t DPLLLCKF = (1U << 16);  ///< DPLL Lock Fall Interrupt Enable
        constexpr uint32_t DPLLLTO = (1U << 17);  ///< DPLL Lock Timeout Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t XOSCRDY = (1U << 0);  ///< XOSC Ready
        constexpr uint32_t XOSC32KRDY = (1U << 1);  ///< XOSC32K Ready
        constexpr uint32_t OSC32KRDY = (1U << 2);  ///< OSC32K Ready
        constexpr uint32_t OSC8MRDY = (1U << 3);  ///< OSC8M Ready
        constexpr uint32_t DFLLRDY = (1U << 4);  ///< DFLL Ready
        constexpr uint32_t DFLLOOB = (1U << 5);  ///< DFLL Out Of Bounds
        constexpr uint32_t DFLLLCKF = (1U << 6);  ///< DFLL Lock Fine
        constexpr uint32_t DFLLLCKC = (1U << 7);  ///< DFLL Lock Coarse
        constexpr uint32_t DFLLRCS = (1U << 8);  ///< DFLL Reference Clock Stopped
        constexpr uint32_t BOD33RDY = (1U << 9);  ///< BOD33 Ready
        constexpr uint32_t BOD33DET = (1U << 10);  ///< BOD33 Detection
        constexpr uint32_t B33SRDY = (1U << 11);  ///< BOD33 Synchronization Ready
        constexpr uint32_t DPLLLCKR = (1U << 15);  ///< DPLL Lock Rise
        constexpr uint32_t DPLLLCKF = (1U << 16);  ///< DPLL Lock Fall
        constexpr uint32_t DPLLLTO = (1U << 17);  ///< DPLL Lock Timeout
    }

    /// PCLKSR Register bits
    namespace pclksr_bits {
        constexpr uint32_t XOSCRDY = (1U << 0);  ///< XOSC Ready
        constexpr uint32_t XOSC32KRDY = (1U << 1);  ///< XOSC32K Ready
        constexpr uint32_t OSC32KRDY = (1U << 2);  ///< OSC32K Ready
        constexpr uint32_t OSC8MRDY = (1U << 3);  ///< OSC8M Ready
        constexpr uint32_t DFLLRDY = (1U << 4);  ///< DFLL Ready
        constexpr uint32_t DFLLOOB = (1U << 5);  ///< DFLL Out Of Bounds
        constexpr uint32_t DFLLLCKF = (1U << 6);  ///< DFLL Lock Fine
        constexpr uint32_t DFLLLCKC = (1U << 7);  ///< DFLL Lock Coarse
        constexpr uint32_t DFLLRCS = (1U << 8);  ///< DFLL Reference Clock Stopped
        constexpr uint32_t BOD33RDY = (1U << 9);  ///< BOD33 Ready
        constexpr uint32_t BOD33DET = (1U << 10);  ///< BOD33 Detection
        constexpr uint32_t B33SRDY = (1U << 11);  ///< BOD33 Synchronization Ready
        constexpr uint32_t DPLLLCKR = (1U << 15);  ///< DPLL Lock Rise
        constexpr uint32_t DPLLLCKF = (1U << 16);  ///< DPLL Lock Fall
        constexpr uint32_t DPLLLTO = (1U << 17);  ///< DPLL Lock Timeout
    }

    /// XOSC Register bits
    namespace xosc_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Oscillator Enable
        constexpr uint32_t XTALEN = (1U << 2);  ///< Crystal Oscillator Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
        constexpr uint32_t GAIN = (3 << 8);  ///< Oscillator Gain
        constexpr uint32_t AMPGC = (1U << 11);  ///< Automatic Amplitude Gain Control
        constexpr uint32_t STARTUP = (4 << 12);  ///< Start-Up Time
    }

    /// XOSC32K Register bits
    namespace xosc32k_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Oscillator Enable
        constexpr uint32_t XTALEN = (1U << 2);  ///< Crystal Oscillator Enable
        constexpr uint32_t EN32K = (1U << 3);  ///< 32kHz Output Enable
        constexpr uint32_t EN1K = (1U << 4);  ///< 1kHz Output Enable
        constexpr uint32_t AAMPEN = (1U << 5);  ///< Automatic Amplitude Control Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
        constexpr uint32_t STARTUP = (3 << 8);  ///< Oscillator Start-Up Time
        constexpr uint32_t WRTLOCK = (1U << 12);  ///< Write Lock
    }

    /// OSC32K Register bits
    namespace osc32k_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Oscillator Enable
        constexpr uint32_t EN32K = (1U << 2);  ///< 32kHz Output Enable
        constexpr uint32_t EN1K = (1U << 3);  ///< 1kHz Output Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
        constexpr uint32_t STARTUP = (3 << 8);  ///< Oscillator Start-Up Time
        constexpr uint32_t WRTLOCK = (1U << 12);  ///< Write Lock
        constexpr uint32_t CALIB = (7 << 16);  ///< Oscillator Calibration
    }

    /// OSCULP32K Register bits
    namespace osculp32k_bits {
        constexpr uint32_t CALIB = (5 << 0);  ///< Oscillator Calibration
        constexpr uint32_t WRTLOCK = (1U << 7);  ///< Write Lock
    }

    /// OSC8M Register bits
    namespace osc8m_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Oscillator Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
        constexpr uint32_t PRESC = (2 << 8);  ///< Oscillator Prescaler
        constexpr uint32_t CALIB = (12 << 16);  ///< Oscillator Calibration
        constexpr uint32_t FRANGE = (2 << 30);  ///< Oscillator Frequency Range
    }

    /// DFLLCTRL Register bits
    namespace dfllctrl_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< DFLL Enable
        constexpr uint32_t MODE = (1U << 2);  ///< Operating Mode Selection
        constexpr uint32_t STABLE = (1U << 3);  ///< Stable DFLL Frequency
        constexpr uint32_t LLAW = (1U << 4);  ///< Lose Lock After Wake
        constexpr uint32_t USBCRM = (1U << 5);  ///< USB Clock Recovery Mode
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
        constexpr uint32_t CCDIS = (1U << 8);  ///< Chill Cycle Disable
        constexpr uint32_t QLDIS = (1U << 9);  ///< Quick Lock Disable
        constexpr uint32_t BPLCKC = (1U << 10);  ///< Bypass Coarse Lock
        constexpr uint32_t WAITLOCK = (1U << 11);  ///< Wait Lock
    }

    /// DFLLVAL Register bits
    namespace dfllval_bits {
        constexpr uint32_t FINE = (10 << 0);  ///< Fine Value
        constexpr uint32_t COARSE = (6 << 10);  ///< Coarse Value
        constexpr uint32_t DIFF = (16 << 16);  ///< Multiplication Ratio Difference
    }

    /// DFLLMUL Register bits
    namespace dfllmul_bits {
        constexpr uint32_t MUL = (16 << 0);  ///< DFLL Multiply Factor
        constexpr uint32_t FSTEP = (10 << 16);  ///< Fine Maximum Step
        constexpr uint32_t CSTEP = (6 << 26);  ///< Coarse Maximum Step
    }

    /// DFLLSYNC Register bits
    namespace dfllsync_bits {
        constexpr uint32_t READREQ = (1U << 7);  ///< Read Request
    }

    /// BOD33 Register bits
    namespace bod33_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t HYST = (1U << 2);  ///< Hysteresis
        constexpr uint32_t ACTION = (2 << 3);  ///< BOD33 Action
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t MODE = (1U << 8);  ///< Operation Mode
        constexpr uint32_t CEN = (1U << 9);  ///< Clock Enable
        constexpr uint32_t PSEL = (4 << 12);  ///< Prescaler Select
        constexpr uint32_t LEVEL = (6 << 16);  ///< BOD33 Threshold Level
    }

    /// VREG Register bits
    namespace vreg_bits {
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t FORCELDO = (1U << 13);  ///< Force LDO Voltage Regulator
    }

    /// VREF Register bits
    namespace vref_bits {
        constexpr uint32_t TSEN = (1U << 1);  ///< Temperature Sensor Enable
        constexpr uint32_t BGOUTEN = (1U << 2);  ///< Bandgap Output Enable
        constexpr uint32_t CALIB = (11 << 16);  ///< Bandgap Voltage Generator Calibration
    }

    /// DPLLCTRLA Register bits
    namespace dpllctrla_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< DPLL Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Clock Activation
    }

    /// DPLLRATIO Register bits
    namespace dpllratio_bits {
        constexpr uint32_t LDR = (12 << 0);  ///< Loop Divider Ratio
        constexpr uint32_t LDRFRAC = (4 << 16);  ///< Loop Divider Ratio Fractional Part
    }

    /// DPLLCTRLB Register bits
    namespace dpllctrlb_bits {
        constexpr uint32_t FILTER = (2 << 0);  ///< Proportional Integral Filter Selection
        constexpr uint32_t LPEN = (1U << 2);  ///< Low-Power Enable
        constexpr uint32_t WUF = (1U << 3);  ///< Wake Up Fast
        constexpr uint32_t REFCLK = (2 << 4);  ///< Reference Clock Selection
        constexpr uint32_t LTIME = (3 << 8);  ///< Lock Time
        constexpr uint32_t LBYPASS = (1U << 12);  ///< Lock Bypass
        constexpr uint32_t DIV = (11 << 16);  ///< Clock Divider
    }

    /// DPLLSTATUS Register bits
    namespace dpllstatus_bits {
        constexpr uint32_t LOCK = (1U << 0);  ///< DPLL Lock Status
        constexpr uint32_t CLKRDY = (1U << 1);  ///< Output Clock Ready
        constexpr uint32_t ENABLE = (1U << 2);  ///< DPLL Enable
        constexpr uint32_t DIV = (1U << 3);  ///< Divider Enable
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TC3_BASE = 0x42002C00;
    constexpr uint32_t TC4_BASE = 0x42003000;
    constexpr uint32_t TC5_BASE = 0x42003400;
    constexpr uint32_t TC6_BASE = 0x42003800;
    constexpr uint32_t TC7_BASE = 0x42003C00;
    constexpr uint32_t TCC0_BASE = 0x42002000;
    constexpr uint32_t TCC1_BASE = 0x42002400;
    constexpr uint32_t TCC2_BASE = 0x42002800;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t READREQ;  ///< Offset: 0x02 - Read Request
        volatile uint32_t CTRLBCLR;  ///< Offset: 0x04 - Control B Clear
        volatile uint32_t CTRLBSET;  ///< Offset: 0x05 - Control B Set
        volatile uint32_t CTRLC;  ///< Offset: 0x06 - Control C
        volatile uint32_t DBGCTRL;  ///< Offset: 0x08 - Debug Control
        volatile uint32_t EVCTRL;  ///< Offset: 0x0A - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x0C - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x0D - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x0E - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x0F - Status
        volatile uint32_t COUNT;  ///< Offset: 0x10 - COUNT32 Counter Value
        volatile uint32_t PER;  ///< Offset: 0x14 - COUNT8 Period Value
        volatile uint32_t CC%s;  ///< Offset: 0x18 - COUNT32 Compare/Capture
    };

    /// Peripheral instances
    inline Registers* TC3 = reinterpret_cast<Registers*>(TC3_BASE);
    inline Registers* TC4 = reinterpret_cast<Registers*>(TC4_BASE);
    inline Registers* TC5 = reinterpret_cast<Registers*>(TC5_BASE);
    inline Registers* TC6 = reinterpret_cast<Registers*>(TC6_BASE);
    inline Registers* TC7 = reinterpret_cast<Registers*>(TC7_BASE);
    inline Registers* TCC0 = reinterpret_cast<Registers*>(TCC0_BASE);
    inline Registers* TCC1 = reinterpret_cast<Registers*>(TCC1_BASE);
    inline Registers* TCC2 = reinterpret_cast<Registers*>(TCC2_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t MODE = (2 << 2);  ///< TC Mode
        constexpr uint32_t WAVEGEN = (2 << 5);  ///< Waveform Generation Operation
        constexpr uint32_t PRESCALER = (3 << 8);  ///< Prescaler
        constexpr uint32_t RUNSTDBY = (1U << 11);  ///< Run in Standby
        constexpr uint32_t PRESCSYNC = (2 << 12);  ///< Prescaler and Counter Synchronization
    }

    /// READREQ Register bits
    namespace readreq_bits {
        constexpr uint32_t ADDR = (5 << 0);  ///< Address
        constexpr uint32_t RCONT = (1U << 14);  ///< Read Continuously
        constexpr uint32_t RREQ = (1U << 15);  ///< Read Request
    }

    /// CTRLBCLR Register bits
    namespace ctrlbclr_bits {
        constexpr uint32_t DIR = (1U << 0);  ///< Counter Direction
        constexpr uint32_t ONESHOT = (1U << 2);  ///< One-Shot
        constexpr uint32_t CMD = (2 << 6);  ///< Command
    }

    /// CTRLBSET Register bits
    namespace ctrlbset_bits {
        constexpr uint32_t DIR = (1U << 0);  ///< Counter Direction
        constexpr uint32_t ONESHOT = (1U << 2);  ///< One-Shot
        constexpr uint32_t CMD = (2 << 6);  ///< Command
    }

    /// CTRLC Register bits
    namespace ctrlc_bits {
        constexpr uint32_t INVEN0 = (1U << 0);  ///< Output Waveform 0 Invert Enable
        constexpr uint32_t INVEN1 = (1U << 1);  ///< Output Waveform 1 Invert Enable
        constexpr uint32_t CPTEN0 = (1U << 4);  ///< Capture Channel 0 Enable
        constexpr uint32_t CPTEN1 = (1U << 5);  ///< Capture Channel 1 Enable
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Debug Run Mode
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t EVACT = (3 << 0);  ///< Event Action
        constexpr uint32_t TCINV = (1U << 4);  ///< TC Inverted Event Input
        constexpr uint32_t TCEI = (1U << 5);  ///< TC Event Input
        constexpr uint32_t OVFEO = (1U << 8);  ///< Overflow/Underflow Event Output Enable
        constexpr uint32_t MCEO0 = (1U << 12);  ///< Match or Capture Channel 0 Event Output Enable
        constexpr uint32_t MCEO1 = (1U << 13);  ///< Match or Capture Channel 1 Event Output Enable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t OVF = (1U << 0);  ///< Overflow Interrupt Enable
        constexpr uint32_t ERR = (1U << 1);  ///< Error Interrupt Enable
        constexpr uint32_t SYNCRDY = (1U << 3);  ///< Synchronization Ready Interrupt Enable
        constexpr uint32_t MC0 = (1U << 4);  ///< Match or Capture Channel 0 Interrupt Enable
        constexpr uint32_t MC1 = (1U << 5);  ///< Match or Capture Channel 1 Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t OVF = (1U << 0);  ///< Overflow Interrupt Enable
        constexpr uint32_t ERR = (1U << 1);  ///< Error Interrupt Enable
        constexpr uint32_t SYNCRDY = (1U << 3);  ///< Synchronization Ready Interrupt Enable
        constexpr uint32_t MC0 = (1U << 4);  ///< Match or Capture Channel 0 Interrupt Enable
        constexpr uint32_t MC1 = (1U << 5);  ///< Match or Capture Channel 1 Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t OVF = (1U << 0);  ///< Overflow
        constexpr uint32_t ERR = (1U << 1);  ///< Error
        constexpr uint32_t SYNCRDY = (1U << 3);  ///< Synchronization Ready
        constexpr uint32_t MC0 = (1U << 4);  ///< Match or Capture Channel 0
        constexpr uint32_t MC1 = (1U << 5);  ///< Match or Capture Channel 1
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STOP = (1U << 3);  ///< Stop
        constexpr uint32_t SLAVE = (1U << 4);  ///< Slave
        constexpr uint32_t SYNCBUSY = (1U << 7);  ///< Synchronization Busy
    }

    /// COUNT Register bits
    namespace count_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< Count Value
    }

    /// PER Register bits
    namespace per_bits {
        constexpr uint32_t PER = (8 << 0);  ///< Period Value
    }

    /// CC%s Register bits
    namespace cc%s_bits {
        constexpr uint32_t CC = (32 << 0);  ///< Compare/Capture Value
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_BASE = 0x41005000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x02 - Synchronization Busy
        volatile uint32_t QOSCTRL;  ///< Offset: 0x03 - USB Quality Of Service
        volatile uint32_t CTRLB;  ///< Offset: 0x08 - HOST Control B
        volatile uint32_t DADD;  ///< Offset: 0x0A - DEVICE Device Address
        volatile uint32_t STATUS;  ///< Offset: 0x0C - HOST Status
        volatile uint32_t FSMSTATUS;  ///< Offset: 0x0D - Finite State Machine Status
        volatile uint32_t FNUM;  ///< Offset: 0x10 - HOST Host Frame Number
        volatile uint32_t INTENCLR;  ///< Offset: 0x14 - HOST Host Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x18 - HOST Host Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x1C - HOST Host Interrupt Flag
        volatile uint32_t EPINTSMRY;  ///< Offset: 0x20 - DEVICE End Point Interrupt Summary
        volatile uint32_t DESCADD;  ///< Offset: 0x24 - Descriptor Address
        volatile uint32_t PADCAL;  ///< Offset: 0x28 - USB PAD Calibration
        volatile uint32_t EPCFG%s;  ///< Offset: 0x100 - DEVICE End Point Configuration
        volatile uint32_t EPSTATUSCLR%s;  ///< Offset: 0x104 - DEVICE End Point Pipe Status Clear
        volatile uint32_t EPSTATUSSET%s;  ///< Offset: 0x105 - DEVICE End Point Pipe Status Set
        volatile uint32_t EPSTATUS%s;  ///< Offset: 0x106 - DEVICE End Point Pipe Status
        volatile uint32_t EPINTFLAG%s;  ///< Offset: 0x107 - DEVICE End Point Interrupt Flag
        volatile uint32_t EPINTENCLR%s;  ///< Offset: 0x108 - DEVICE End Point Interrupt Clear Flag
        volatile uint32_t EPINTENSET%s;  ///< Offset: 0x109 - DEVICE End Point Interrupt Set Flag
        volatile uint32_t HSOFC;  ///< Offset: 0x0A - HOST Host Start Of Frame Control
        volatile uint32_t FLENHIGH;  ///< Offset: 0x12 - HOST Host Frame Length
        volatile uint32_t PINTSMRY;  ///< Offset: 0x20 - HOST Pipe Interrupt Summary
        volatile uint32_t PCFG%s;  ///< Offset: 0x100 - HOST End Point Configuration
        volatile uint32_t BINTERVAL%s;  ///< Offset: 0x103 - HOST Bus Access Period of Pipe
        volatile uint32_t PSTATUSCLR%s;  ///< Offset: 0x104 - HOST End Point Pipe Status Clear
        volatile uint32_t PSTATUSSET%s;  ///< Offset: 0x105 - HOST End Point Pipe Status Set
        volatile uint32_t PSTATUS%s;  ///< Offset: 0x106 - HOST End Point Pipe Status
        volatile uint32_t PINTFLAG%s;  ///< Offset: 0x107 - HOST Pipe Interrupt Flag
        volatile uint32_t PINTENCLR%s;  ///< Offset: 0x108 - HOST Pipe Interrupt Flag Clear
        volatile uint32_t PINTENSET%s;  ///< Offset: 0x109 - HOST Pipe Interrupt Flag Set
    };

    /// Peripheral instances
    inline Registers* USB = reinterpret_cast<Registers*>(USB_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t RUNSTDBY = (1U << 2);  ///< Run in Standby Mode
        constexpr uint32_t MODE = (1U << 7);  ///< Operating Mode
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchronization Busy
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable Synchronization Busy
    }

    /// QOSCTRL Register bits
    namespace qosctrl_bits {
        constexpr uint32_t CQOS = (2 << 0);  ///< Configuration Quality of Service
        constexpr uint32_t DQOS = (2 << 2);  ///< Data Quality of Service
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t RESUME = (1U << 1);  ///< Send USB Resume
        constexpr uint32_t SPDCONF = (2 << 2);  ///< Speed Configuration for Host
        constexpr uint32_t TSTJ = (1U << 5);  ///< Test mode J
        constexpr uint32_t TSTK = (1U << 6);  ///< Test mode K
        constexpr uint32_t SOFE = (1U << 8);  ///< Start of Frame Generation Enable
        constexpr uint32_t BUSRESET = (1U << 9);  ///< Send USB Reset
        constexpr uint32_t VBUSOK = (1U << 10);  ///< VBUS is OK
        constexpr uint32_t L1RESUME = (1U << 11);  ///< Send L1 Resume
    }

    /// DADD Register bits
    namespace dadd_bits {
        constexpr uint32_t DADD = (7 << 0);  ///< Device Address
        constexpr uint32_t ADDEN = (1U << 7);  ///< Device Address Enable
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SPEED = (2 << 2);  ///< Speed Status
        constexpr uint32_t LINESTATE = (2 << 6);  ///< USB Line State Status
    }

    /// FSMSTATUS Register bits
    namespace fsmstatus_bits {
        constexpr uint32_t FSMSTATE = (7 << 0);  ///< Fine State Machine Status
    }

    /// FNUM Register bits
    namespace fnum_bits {
        constexpr uint32_t MFNUM = (3 << 0);  ///< Micro Frame Number
        constexpr uint32_t FNUM = (11 << 3);  ///< Frame Number
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t HSOF = (1U << 2);  ///< Host Start Of Frame Interrupt Disable
        constexpr uint32_t RST = (1U << 3);  ///< BUS Reset Interrupt Disable
        constexpr uint32_t WAKEUP = (1U << 4);  ///< Wake Up Interrupt Disable
        constexpr uint32_t DNRSM = (1U << 5);  ///< DownStream to Device Interrupt Disable
        constexpr uint32_t UPRSM = (1U << 6);  ///< Upstream Resume from Device Interrupt Disable
        constexpr uint32_t RAMACER = (1U << 7);  ///< Ram Access Interrupt Disable
        constexpr uint32_t DCONN = (1U << 8);  ///< Device Connection Interrupt Disable
        constexpr uint32_t DDISC = (1U << 9);  ///< Device Disconnection Interrupt Disable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t HSOF = (1U << 2);  ///< Host Start Of Frame Interrupt Enable
        constexpr uint32_t RST = (1U << 3);  ///< Bus Reset Interrupt Enable
        constexpr uint32_t WAKEUP = (1U << 4);  ///< Wake Up Interrupt Enable
        constexpr uint32_t DNRSM = (1U << 5);  ///< DownStream to the Device Interrupt Enable
        constexpr uint32_t UPRSM = (1U << 6);  ///< Upstream Resume fromthe device Interrupt Enable
        constexpr uint32_t RAMACER = (1U << 7);  ///< Ram Access Interrupt Enable
        constexpr uint32_t DCONN = (1U << 8);  ///< Link Power Management Interrupt Enable
        constexpr uint32_t DDISC = (1U << 9);  ///< Device Disconnection Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t HSOF = (1U << 2);  ///< Host Start Of Frame
        constexpr uint32_t RST = (1U << 3);  ///< Bus Reset
        constexpr uint32_t WAKEUP = (1U << 4);  ///< Wake Up
        constexpr uint32_t DNRSM = (1U << 5);  ///< Downstream
        constexpr uint32_t UPRSM = (1U << 6);  ///< Upstream Resume from the Device
        constexpr uint32_t RAMACER = (1U << 7);  ///< Ram Access
        constexpr uint32_t DCONN = (1U << 8);  ///< Device Connection
        constexpr uint32_t DDISC = (1U << 9);  ///< Device Disconnection
    }

    /// EPINTSMRY Register bits
    namespace epintsmry_bits {
        constexpr uint32_t EPINT0 = (1U << 0);  ///< End Point 0 Interrupt
        constexpr uint32_t EPINT1 = (1U << 1);  ///< End Point 1 Interrupt
        constexpr uint32_t EPINT2 = (1U << 2);  ///< End Point 2 Interrupt
        constexpr uint32_t EPINT3 = (1U << 3);  ///< End Point 3 Interrupt
        constexpr uint32_t EPINT4 = (1U << 4);  ///< End Point 4 Interrupt
        constexpr uint32_t EPINT5 = (1U << 5);  ///< End Point 5 Interrupt
        constexpr uint32_t EPINT6 = (1U << 6);  ///< End Point 6 Interrupt
        constexpr uint32_t EPINT7 = (1U << 7);  ///< End Point 7 Interrupt
    }

    /// DESCADD Register bits
    namespace descadd_bits {
        constexpr uint32_t DESCADD = (32 << 0);  ///< Descriptor Address Value
    }

    /// PADCAL Register bits
    namespace padcal_bits {
        constexpr uint32_t TRANSP = (5 << 0);  ///< USB Pad Transp calibration
        constexpr uint32_t TRANSN = (5 << 6);  ///< USB Pad Transn calibration
        constexpr uint32_t TRIM = (3 << 12);  ///< USB Pad Trim calibration
    }

    /// EPCFG%s Register bits
    namespace epcfg%s_bits {
        constexpr uint32_t EPTYPE0 = (3 << 0);  ///< End Point Type0
        constexpr uint32_t EPTYPE1 = (3 << 4);  ///< End Point Type1
        constexpr uint32_t NYETDIS = (1U << 7);  ///< NYET Token Disable
    }

    /// EPSTATUSCLR%s Register bits
    namespace epstatusclr%s_bits {
        constexpr uint32_t DTGLOUT = (1U << 0);  ///< Data Toggle OUT Clear
        constexpr uint32_t DTGLIN = (1U << 1);  ///< Data Toggle IN Clear
        constexpr uint32_t CURBK = (1U << 2);  ///< Curren Bank Clear
        constexpr uint32_t STALLRQ0 = (1U << 4);  ///< Stall 0 Request Clear
        constexpr uint32_t STALLRQ1 = (1U << 5);  ///< Stall 1 Request Clear
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 Ready Clear
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 Ready Clear
    }

    /// EPSTATUSSET%s Register bits
    namespace epstatusset%s_bits {
        constexpr uint32_t DTGLOUT = (1U << 0);  ///< Data Toggle OUT Set
        constexpr uint32_t DTGLIN = (1U << 1);  ///< Data Toggle IN Set
        constexpr uint32_t CURBK = (1U << 2);  ///< Current Bank Set
        constexpr uint32_t STALLRQ0 = (1U << 4);  ///< Stall 0 Request Set
        constexpr uint32_t STALLRQ1 = (1U << 5);  ///< Stall 1 Request Set
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 Ready Set
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 Ready Set
    }

    /// EPSTATUS%s Register bits
    namespace epstatus%s_bits {
        constexpr uint32_t DTGLOUT = (1U << 0);  ///< Data Toggle Out
        constexpr uint32_t DTGLIN = (1U << 1);  ///< Data Toggle In
        constexpr uint32_t CURBK = (1U << 2);  ///< Current Bank
        constexpr uint32_t STALLRQ0 = (1U << 4);  ///< Stall 0 Request
        constexpr uint32_t STALLRQ1 = (1U << 5);  ///< Stall 1 Request
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 ready
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 ready
    }

    /// EPINTFLAG%s Register bits
    namespace epintflag%s_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1
        constexpr uint32_t TRFAIL0 = (1U << 2);  ///< Error Flow 0
        constexpr uint32_t TRFAIL1 = (1U << 3);  ///< Error Flow 1
        constexpr uint32_t RXSTP = (1U << 4);  ///< Received Setup
        constexpr uint32_t STALL0 = (1U << 5);  ///< Stall 0 In/out
        constexpr uint32_t STALL1 = (1U << 6);  ///< Stall 1 In/out
    }

    /// EPINTENCLR%s Register bits
    namespace epintenclr%s_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0 Interrupt Disable
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1 Interrupt Disable
        constexpr uint32_t TRFAIL0 = (1U << 2);  ///< Error Flow 0 Interrupt Disable
        constexpr uint32_t TRFAIL1 = (1U << 3);  ///< Error Flow 1 Interrupt Disable
        constexpr uint32_t RXSTP = (1U << 4);  ///< Received Setup Interrupt Disable
        constexpr uint32_t STALL0 = (1U << 5);  ///< Stall 0 In/Out Interrupt Disable
        constexpr uint32_t STALL1 = (1U << 6);  ///< Stall 1 In/Out Interrupt Disable
    }

    /// EPINTENSET%s Register bits
    namespace epintenset%s_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0 Interrupt Enable
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1 Interrupt Enable
        constexpr uint32_t TRFAIL0 = (1U << 2);  ///< Error Flow 0 Interrupt Enable
        constexpr uint32_t TRFAIL1 = (1U << 3);  ///< Error Flow 1 Interrupt Enable
        constexpr uint32_t RXSTP = (1U << 4);  ///< Received Setup Interrupt Enable
        constexpr uint32_t STALL0 = (1U << 5);  ///< Stall 0 In/out Interrupt enable
        constexpr uint32_t STALL1 = (1U << 6);  ///< Stall 1 In/out Interrupt enable
    }

    /// HSOFC Register bits
    namespace hsofc_bits {
        constexpr uint32_t FLENC = (4 << 0);  ///< Frame Length Control
        constexpr uint32_t FLENCE = (1U << 7);  ///< Frame Length Control Enable
    }

    /// FLENHIGH Register bits
    namespace flenhigh_bits {
        constexpr uint32_t FLENHIGH = (8 << 0);  ///< Frame Length
    }

    /// PINTSMRY Register bits
    namespace pintsmry_bits {
        constexpr uint32_t EPINT0 = (1U << 0);  ///< Pipe 0 Interrupt
        constexpr uint32_t EPINT1 = (1U << 1);  ///< Pipe 1 Interrupt
        constexpr uint32_t EPINT2 = (1U << 2);  ///< Pipe 2 Interrupt
        constexpr uint32_t EPINT3 = (1U << 3);  ///< Pipe 3 Interrupt
        constexpr uint32_t EPINT4 = (1U << 4);  ///< Pipe 4 Interrupt
        constexpr uint32_t EPINT5 = (1U << 5);  ///< Pipe 5 Interrupt
        constexpr uint32_t EPINT6 = (1U << 6);  ///< Pipe 6 Interrupt
        constexpr uint32_t EPINT7 = (1U << 7);  ///< Pipe 7 Interrupt
    }

    /// PCFG%s Register bits
    namespace pcfg%s_bits {
        constexpr uint32_t PTOKEN = (2 << 0);  ///< Pipe Token
        constexpr uint32_t BK = (1U << 2);  ///< Pipe Bank
        constexpr uint32_t PTYPE = (3 << 3);  ///< Pipe Type
    }

    /// BINTERVAL%s Register bits
    namespace binterval%s_bits {
        constexpr uint32_t BITINTERVAL = (8 << 0);  ///< Bit Interval
    }

    /// PSTATUSCLR%s Register bits
    namespace pstatusclr%s_bits {
        constexpr uint32_t DTGL = (1U << 0);  ///< Data Toggle clear
        constexpr uint32_t CURBK = (1U << 2);  ///< Curren Bank clear
        constexpr uint32_t PFREEZE = (1U << 4);  ///< Pipe Freeze Clear
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 Ready Clear
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 Ready Clear
    }

    /// PSTATUSSET%s Register bits
    namespace pstatusset%s_bits {
        constexpr uint32_t DTGL = (1U << 0);  ///< Data Toggle Set
        constexpr uint32_t CURBK = (1U << 2);  ///< Current Bank Set
        constexpr uint32_t PFREEZE = (1U << 4);  ///< Pipe Freeze Set
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 Ready Set
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 Ready Set
    }

    /// PSTATUS%s Register bits
    namespace pstatus%s_bits {
        constexpr uint32_t DTGL = (1U << 0);  ///< Data Toggle
        constexpr uint32_t CURBK = (1U << 2);  ///< Current Bank
        constexpr uint32_t PFREEZE = (1U << 4);  ///< Pipe Freeze
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 ready
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 ready
    }

    /// PINTFLAG%s Register bits
    namespace pintflag%s_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0 Interrupt Flag
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1 Interrupt Flag
        constexpr uint32_t TRFAIL = (1U << 2);  ///< Error Flow Interrupt Flag
        constexpr uint32_t PERR = (1U << 3);  ///< Pipe Error Interrupt Flag
        constexpr uint32_t TXSTP = (1U << 4);  ///< Transmit Setup Interrupt Flag
        constexpr uint32_t STALL = (1U << 5);  ///< Stall Interrupt Flag
    }

    /// PINTENCLR%s Register bits
    namespace pintenclr%s_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0 Disable
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1 Disable
        constexpr uint32_t TRFAIL = (1U << 2);  ///< Error Flow Interrupt Disable
        constexpr uint32_t PERR = (1U << 3);  ///< Pipe Error Interrupt Disable
        constexpr uint32_t TXSTP = (1U << 4);  ///< Transmit Setup Interrupt Disable
        constexpr uint32_t STALL = (1U << 5);  ///< Stall Inetrrupt Disable
    }

    /// PINTENSET%s Register bits
    namespace pintenset%s_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0 Interrupt Enable
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1 Interrupt Enable
        constexpr uint32_t TRFAIL = (1U << 2);  ///< Error Flow Interrupt Enable
        constexpr uint32_t PERR = (1U << 3);  ///< Pipe Error Interrupt Enable
        constexpr uint32_t TXSTP = (1U << 4);  ///< Transmit Setup Interrupt Enable
        constexpr uint32_t STALL = (1U << 5);  ///< Stall Interrupt Enable
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40001000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control
        volatile uint32_t CONFIG;  ///< Offset: 0x01 - Configuration
        volatile uint32_t EWCTRL;  ///< Offset: 0x02 - Early Warning Interrupt Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x04 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x05 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x06 - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x07 - Status
        volatile uint32_t CLEAR;  ///< Offset: 0x08 - Clear
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t WEN = (1U << 2);  ///< Watchdog Timer Window Mode Enable
        constexpr uint32_t ALWAYSON = (1U << 7);  ///< Always-On
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t PER = (4 << 0);  ///< Time-Out Period
        constexpr uint32_t WINDOW = (4 << 4);  ///< Window Mode Time-Out Period
    }

    /// EWCTRL Register bits
    namespace ewctrl_bits {
        constexpr uint32_t EWOFFSET = (4 << 0);  ///< Early Warning Interrupt Time Offset
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t EW = (1U << 0);  ///< Early Warning Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t EW = (1U << 0);  ///< Early Warning Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t EW = (1U << 0);  ///< Early Warning
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SYNCBUSY = (1U << 7);  ///< Synchronization Busy
    }

    /// CLEAR Register bits
    namespace clear_bits {
        constexpr uint32_t CLEAR = (8 << 0);  ///< Watchdog Clear
    }

}


} // namespace alloy::generated::atsamd21j18a

#endif // ALLOY_GENERATED_ATSAMD21J18A_PERIPHERALS_HPP