/// Auto-generated code for ATSAML22N16A
/// Generated by Alloy Code Generator
/// Source: atmel_saml.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:01:07
#ifndef ALLOY_GENERATED_ATSAML22N16A_PERIPHERALS_HPP
#define ALLOY_GENERATED_ATSAML22N16A_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::atsaml22n16a {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_ac = true;
    constexpr uint32_t num_ac_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 1;
    constexpr bool has_ccl = true;
    constexpr uint32_t num_ccl_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_dsu = true;
    constexpr uint32_t num_dsu_instances = 1;
    constexpr bool has_eic = true;
    constexpr uint32_t num_eic_instances = 1;
    constexpr bool has_evsys = true;
    constexpr uint32_t num_evsys_instances = 1;
    constexpr bool has_freqm = true;
    constexpr uint32_t num_freqm_instances = 1;
    constexpr bool has_gclk = true;
    constexpr uint32_t num_gclk_instances = 1;
    constexpr bool has_mclk = true;
    constexpr uint32_t num_mclk_instances = 1;
    constexpr bool has_mtb = true;
    constexpr uint32_t num_mtb_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_oscctrl = true;
    constexpr uint32_t num_oscctrl_instances = 1;
    constexpr bool has_osc32kctrl = true;
    constexpr uint32_t num_osc32kctrl_instances = 1;
    constexpr bool has_pac = true;
    constexpr uint32_t num_pac_instances = 1;
    constexpr bool has_pm = true;
    constexpr uint32_t num_pm_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 2;
    constexpr bool has_rstc = true;
    constexpr uint32_t num_rstc_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_sercom = true;
    constexpr uint32_t num_sercom_instances = 6;
    constexpr bool has_slcd = true;
    constexpr uint32_t num_slcd_instances = 1;
    constexpr bool has_supc = true;
    constexpr uint32_t num_supc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 5;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct ac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dsu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct evsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct freqm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gclk_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mclk_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct oscctrl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc32kctrl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rstc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sercom_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct slcd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct supc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 2;
    constexpr uint32_t max_gpio_pins = 32;  // 16 pins per port

    // USART-specific traits
}

// ============================================================================
// AC Peripheral
// ============================================================================

namespace ac {
    /// Base addresses
    constexpr uint32_t AC_BASE = 0x42003400;

    /// AC Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x01 - Control B
        volatile uint32_t EVCTRL;  ///< Offset: 0x02 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x04 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x05 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x06 - Interrupt Flag Status and Clear
        volatile uint32_t STATUSA;  ///< Offset: 0x07 - Status A
        volatile uint32_t STATUSB;  ///< Offset: 0x08 - Status B
        volatile uint32_t DBGCTRL;  ///< Offset: 0x09 - Debug Control
        volatile uint32_t WINCTRL;  ///< Offset: 0x0A - Window Control
        volatile uint32_t SCALER%s;  ///< Offset: 0x0C - Scaler n
        volatile uint32_t COMPCTRL%s;  ///< Offset: 0x10 - Comparator Control n
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x20 - Synchronization Busy
    };

    /// Peripheral instances
    inline Registers* AC = reinterpret_cast<Registers*>(AC_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t START0 = (1U << 0);  ///< Comparator 0 Start Comparison
        constexpr uint32_t START1 = (1U << 1);  ///< Comparator 1 Start Comparison
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t COMPEO0 = (1U << 0);  ///< Comparator 0 Event Output Enable
        constexpr uint32_t COMPEO1 = (1U << 1);  ///< Comparator 1 Event Output Enable
        constexpr uint32_t WINEO0 = (1U << 4);  ///< Window 0 Event Output Enable
        constexpr uint32_t COMPEI0 = (1U << 8);  ///< Comparator 0 Event Input Enable
        constexpr uint32_t COMPEI1 = (1U << 9);  ///< Comparator 1 Event Input Enable
        constexpr uint32_t INVEI0 = (1U << 12);  ///< Comparator 0 Input Event Invert Enable
        constexpr uint32_t INVEI1 = (1U << 13);  ///< Comparator 1 Input Event Invert Enable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t COMP0 = (1U << 0);  ///< Comparator 0 Interrupt Enable
        constexpr uint32_t COMP1 = (1U << 1);  ///< Comparator 1 Interrupt Enable
        constexpr uint32_t WIN0 = (1U << 4);  ///< Window 0 Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t COMP0 = (1U << 0);  ///< Comparator 0 Interrupt Enable
        constexpr uint32_t COMP1 = (1U << 1);  ///< Comparator 1 Interrupt Enable
        constexpr uint32_t WIN0 = (1U << 4);  ///< Window 0 Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t COMP0 = (1U << 0);  ///< Comparator 0
        constexpr uint32_t COMP1 = (1U << 1);  ///< Comparator 1
        constexpr uint32_t WIN0 = (1U << 4);  ///< Window 0
    }

    /// STATUSA Register bits
    namespace statusa_bits {
        constexpr uint32_t STATE0 = (1U << 0);  ///< Comparator 0 Current State
        constexpr uint32_t STATE1 = (1U << 1);  ///< Comparator 1 Current State
        constexpr uint32_t WSTATE0 = (2 << 4);  ///< Window 0 Current State
    }

    /// STATUSB Register bits
    namespace statusb_bits {
        constexpr uint32_t READY0 = (1U << 0);  ///< Comparator 0 Ready
        constexpr uint32_t READY1 = (1U << 1);  ///< Comparator 1 Ready
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Debug Run
    }

    /// WINCTRL Register bits
    namespace winctrl_bits {
        constexpr uint32_t WEN0 = (1U << 0);  ///< Window 0 Mode Enable
        constexpr uint32_t WINTSEL0 = (2 << 1);  ///< Window 0 Interrupt Selection
    }

    /// SCALER%s Register bits
    namespace scaler%s_bits {
        constexpr uint32_t VALUE = (6 << 0);  ///< Scaler Value
    }

    /// COMPCTRL%s Register bits
    namespace compctrl%s_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t SINGLE = (1U << 2);  ///< Single-Shot Mode
        constexpr uint32_t INTSEL = (2 << 3);  ///< Interrupt Selection
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t MUXNEG = (3 << 8);  ///< Negative Input Mux Selection
        constexpr uint32_t MUXPOS = (3 << 12);  ///< Positive Input Mux Selection
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap Inputs and Invert
        constexpr uint32_t SPEED = (2 << 16);  ///< Speed Selection
        constexpr uint32_t HYSTEN = (1U << 19);  ///< Hysteresis Enable
        constexpr uint32_t HYST = (2 << 20);  ///< Hysteresis Level
        constexpr uint32_t FLEN = (3 << 24);  ///< Filter Length
        constexpr uint32_t OUT = (2 << 28);  ///< Output
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchronization Busy
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable Synchronization Busy
        constexpr uint32_t WINCTRL = (1U << 2);  ///< WINCTRL Synchronization Busy
        constexpr uint32_t COMPCTRL0 = (1U << 3);  ///< COMPCTRL 0 Synchronization Busy
        constexpr uint32_t COMPCTRL1 = (1U << 4);  ///< COMPCTRL 1 Synchronization Busy
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x42003000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x01 - Control B
        volatile uint32_t REFCTRL;  ///< Offset: 0x02 - Reference Control
        volatile uint32_t EVCTRL;  ///< Offset: 0x03 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x04 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x05 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x06 - Interrupt Flag Status and Clear
        volatile uint32_t SEQSTATUS;  ///< Offset: 0x07 - Sequence Status
        volatile uint32_t INPUTCTRL;  ///< Offset: 0x08 - Input Control
        volatile uint32_t CTRLC;  ///< Offset: 0x0A - Control C
        volatile uint32_t AVGCTRL;  ///< Offset: 0x0C - Average Control
        volatile uint32_t SAMPCTRL;  ///< Offset: 0x0D - Sample Time Control
        volatile uint32_t WINLT;  ///< Offset: 0x0E - Window Monitor Lower Threshold
        volatile uint32_t WINUT;  ///< Offset: 0x10 - Window Monitor Upper Threshold
        volatile uint32_t GAINCORR;  ///< Offset: 0x12 - Gain Correction
        volatile uint32_t OFFSETCORR;  ///< Offset: 0x14 - Offset Correction
        volatile uint32_t SWTRIG;  ///< Offset: 0x18 - Software Trigger
        volatile uint32_t DBGCTRL;  ///< Offset: 0x1C - Debug Control
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x20 - Synchronization Busy
        volatile uint32_t RESULT;  ///< Offset: 0x24 - Result
        volatile uint32_t SEQCTRL;  ///< Offset: 0x28 - Sequence Control
        volatile uint32_t CALIB;  ///< Offset: 0x2C - Calibration
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run During Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t PRESCALER = (3 << 0);  ///< Prescaler Configuration
    }

    /// REFCTRL Register bits
    namespace refctrl_bits {
        constexpr uint32_t REFSEL = (4 << 0);  ///< Reference Selection
        constexpr uint32_t REFCOMP = (1U << 7);  ///< Reference Buffer Offset Compensation Enable
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t FLUSHEI = (1U << 0);  ///< Flush Event Input Enable
        constexpr uint32_t STARTEI = (1U << 1);  ///< Start Conversion Event Input Enable
        constexpr uint32_t FLUSHINV = (1U << 2);  ///< Flush Event Invert Enable
        constexpr uint32_t STARTINV = (1U << 3);  ///< Satrt Event Invert Enable
        constexpr uint32_t RESRDYEO = (1U << 4);  ///< Result Ready Event Out
        constexpr uint32_t WINMONEO = (1U << 5);  ///< Window Monitor Event Out
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t RESRDY = (1U << 0);  ///< Result Ready Interrupt Disable
        constexpr uint32_t OVERRUN = (1U << 1);  ///< Overrun Interrupt Disable
        constexpr uint32_t WINMON = (1U << 2);  ///< Window Monitor Interrupt Disable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t RESRDY = (1U << 0);  ///< Result Ready Interrupt Enable
        constexpr uint32_t OVERRUN = (1U << 1);  ///< Overrun Interrupt Enable
        constexpr uint32_t WINMON = (1U << 2);  ///< Window Monitor Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t RESRDY = (1U << 0);  ///< Result Ready Interrupt Flag
        constexpr uint32_t OVERRUN = (1U << 1);  ///< Overrun Interrupt Flag
        constexpr uint32_t WINMON = (1U << 2);  ///< Window Monitor Interrupt Flag
    }

    /// SEQSTATUS Register bits
    namespace seqstatus_bits {
        constexpr uint32_t SEQSTATE = (5 << 0);  ///< Sequence State
        constexpr uint32_t SEQBUSY = (1U << 7);  ///< Sequence Busy
    }

    /// INPUTCTRL Register bits
    namespace inputctrl_bits {
        constexpr uint32_t MUXPOS = (5 << 0);  ///< Positive Mux Input Selection
        constexpr uint32_t MUXNEG = (5 << 8);  ///< Negative Mux Input Selection
    }

    /// CTRLC Register bits
    namespace ctrlc_bits {
        constexpr uint32_t DIFFMODE = (1U << 0);  ///< Differential Mode
        constexpr uint32_t LEFTADJ = (1U << 1);  ///< Left-Adjusted Result
        constexpr uint32_t FREERUN = (1U << 2);  ///< Free Running Mode
        constexpr uint32_t CORREN = (1U << 3);  ///< Digital Correction Logic Enable
        constexpr uint32_t RESSEL = (2 << 4);  ///< Conversion Result Resolution
        constexpr uint32_t R2R = (1U << 7);  ///< Rail-to-Rail mode enable
        constexpr uint32_t WINMODE = (3 << 8);  ///< Window Monitor Mode
        constexpr uint32_t DUALSEL = (2 << 12);  ///< Dual Mode Trigger Selection
    }

    /// AVGCTRL Register bits
    namespace avgctrl_bits {
        constexpr uint32_t SAMPLENUM = (4 << 0);  ///< Number of Samples to be Collected
        constexpr uint32_t ADJRES = (3 << 4);  ///< Adjusting Result / Division Coefficient
    }

    /// SAMPCTRL Register bits
    namespace sampctrl_bits {
        constexpr uint32_t SAMPLEN = (6 << 0);  ///< Sampling Time Length
        constexpr uint32_t OFFCOMP = (1U << 7);  ///< Comparator Offset Compensation Enable
    }

    /// WINLT Register bits
    namespace winlt_bits {
        constexpr uint32_t WINLT = (16 << 0);  ///< Window Lower Threshold
    }

    /// WINUT Register bits
    namespace winut_bits {
        constexpr uint32_t WINUT = (16 << 0);  ///< Window Upper Threshold
    }

    /// GAINCORR Register bits
    namespace gaincorr_bits {
        constexpr uint32_t GAINCORR = (12 << 0);  ///< Gain Correction Value
    }

    /// OFFSETCORR Register bits
    namespace offsetcorr_bits {
        constexpr uint32_t OFFSETCORR = (12 << 0);  ///< Offset Correction Value
    }

    /// SWTRIG Register bits
    namespace swtrig_bits {
        constexpr uint32_t FLUSH = (1U << 0);  ///< ADC Flush
        constexpr uint32_t START = (1U << 1);  ///< Start ADC Conversion
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Debug Run
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< SWRST Synchronization Busy
        constexpr uint32_t ENABLE = (1U << 1);  ///< ENABLE Synchronization Busy
        constexpr uint32_t INPUTCTRL = (1U << 2);  ///< INPUTCTRL Synchronization Busy
        constexpr uint32_t CTRLC = (1U << 3);  ///< CTRLC Synchronization Busy
        constexpr uint32_t AVGCTRL = (1U << 4);  ///< AVGCTRL Synchronization Busy
        constexpr uint32_t SAMPCTRL = (1U << 5);  ///< SAMPCTRL Synchronization Busy
        constexpr uint32_t WINLT = (1U << 6);  ///< WINLT Synchronization Busy
        constexpr uint32_t WINUT = (1U << 7);  ///< WINUT Synchronization Busy
        constexpr uint32_t GAINCORR = (1U << 8);  ///< GAINCORR Synchronization Busy
        constexpr uint32_t OFFSETCORR = (1U << 9);  ///< OFFSETCTRL Synchronization Busy
        constexpr uint32_t SWTRIG = (1U << 10);  ///< SWTRG Synchronization Busy
    }

    /// RESULT Register bits
    namespace result_bits {
        constexpr uint32_t RESULT = (16 << 0);  ///< Result Value
    }

    /// SEQCTRL Register bits
    namespace seqctrl_bits {
        constexpr uint32_t SEQEN = (32 << 0);  ///< Enable Positive Input in the Sequence
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t BIASCOMP = (3 << 0);  ///< Bias Comparator Scaling
        constexpr uint32_t BIASREFBUF = (3 << 8);  ///< Bias Reference Buffer Scaling
    }

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x42004000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x04 - Control B
        volatile uint32_t INTENCLR;  ///< Offset: 0x05 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x06 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x07 - Interrupt Flag Status
        volatile uint32_t DATABUFPTR;  ///< Offset: 0x08 - Data buffer pointer
        volatile uint32_t DBGCTRL;  ///< Offset: 0x09 - Debug control
        volatile uint32_t KEYWORD%s;  ///< Offset: 0x0C - Keyword n
        volatile uint32_t INDATA;  ///< Offset: 0x38 - Indata
        volatile uint32_t INTVECTV%s;  ///< Offset: 0x3C - Initialisation Vector n
        volatile uint32_t HASHKEY%s;  ///< Offset: 0x5C - Hash key n
        volatile uint32_t GHASH%s;  ///< Offset: 0x6C - Galois Hash n
        volatile uint32_t CIPLEN;  ///< Offset: 0x80 - Cipher Length
        volatile uint32_t RANDSEED;  ///< Offset: 0x84 - Random Seed
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t AESMODE = (3 << 2);  ///< AES Modes of operation
        constexpr uint32_t CFBS = (3 << 5);  ///< CFB Types
        constexpr uint32_t KEYSIZE = (2 << 8);  ///< Keysize
        constexpr uint32_t CIPHER = (1U << 10);  ///< Cipher mode
        constexpr uint32_t STARTMODE = (1U << 11);  ///< Start mode
        constexpr uint32_t LOD = (1U << 12);  ///< LOD Enable
        constexpr uint32_t KEYGEN = (1U << 13);  ///< Last key generation
        constexpr uint32_t XORKEY = (1U << 14);  ///< Xor Key operation
        constexpr uint32_t CTYPE = (4 << 16);  ///< Counter measure types
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t START = (1U << 0);  ///< Manual Start
        constexpr uint32_t NEWMSG = (1U << 1);  ///< New message
        constexpr uint32_t EOM = (1U << 2);  ///< End of message
        constexpr uint32_t GFMUL = (1U << 3);  ///< GF Multiplication
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t ENCCMP = (1U << 0);  ///< Encryption Complete
        constexpr uint32_t GFMCMP = (1U << 1);  ///< GF Multiplication Complete
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t ENCCMP = (1U << 0);  ///< Encryption Complete
        constexpr uint32_t GFMCMP = (1U << 1);  ///< GF Multiplication Complete
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t ENCCMP = (1U << 0);  ///< Encryption Complete
        constexpr uint32_t GFMCMP = (1U << 1);  ///< GF Multiplication Complete
    }

    /// DATABUFPTR Register bits
    namespace databufptr_bits {
        constexpr uint32_t INDATAPTR = (2 << 0);  ///< Input Data Pointer
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Debug Run
    }

}

// ============================================================================
// CCL Peripheral
// ============================================================================

namespace ccl {
    /// Base addresses
    constexpr uint32_t CCL_BASE = 0x42004800;

    /// CCL Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control
        volatile uint32_t SEQCTRL%s;  ///< Offset: 0x04 - SEQ Control x
        volatile uint32_t LUTCTRL%s;  ///< Offset: 0x08 - LUT Control x
    };

    /// Peripheral instances
    inline Registers* CCL = reinterpret_cast<Registers*>(CCL_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run during Standby
    }

    /// SEQCTRL%s Register bits
    namespace seqctrl%s_bits {
        constexpr uint32_t SEQSEL = (4 << 0);  ///< Sequential Selection
    }

    /// LUTCTRL%s Register bits
    namespace lutctrl%s_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< LUT Enable
        constexpr uint32_t FILTSEL = (2 << 4);  ///< Filter Selection
        constexpr uint32_t EDGESEL = (1U << 7);  ///< Edge Selection
        constexpr uint32_t INSEL0 = (4 << 8);  ///< Input Selection 0
        constexpr uint32_t INSEL1 = (4 << 12);  ///< Input Selection 1
        constexpr uint32_t INSEL2 = (4 << 16);  ///< Input Selection 2
        constexpr uint32_t INVEI = (1U << 20);  ///< Input Event Invert
        constexpr uint32_t LUTEI = (1U << 21);  ///< Event Input Enable
        constexpr uint32_t LUTEO = (1U << 22);  ///< Event Output Enable
        constexpr uint32_t TRUTH = (8 << 24);  ///< Truth Value
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMAC_BASE = 0x41008000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control
        volatile uint32_t CRCCTRL;  ///< Offset: 0x02 - CRC Control
        volatile uint32_t CRCDATAIN;  ///< Offset: 0x04 - CRC Data Input
        volatile uint32_t CRCCHKSUM;  ///< Offset: 0x08 - CRC Checksum
        volatile uint32_t CRCSTATUS;  ///< Offset: 0x0C - CRC Status
        volatile uint32_t DBGCTRL;  ///< Offset: 0x0D - Debug Control
        volatile uint32_t QOSCTRL;  ///< Offset: 0x0E - QOS Control
        volatile uint32_t SWTRIGCTRL;  ///< Offset: 0x10 - Software Trigger Control
        volatile uint32_t PRICTRL0;  ///< Offset: 0x14 - Priority Control 0
        volatile uint32_t INTPEND;  ///< Offset: 0x20 - Interrupt Pending
        volatile uint32_t INTSTATUS;  ///< Offset: 0x24 - Interrupt Status
        volatile uint32_t BUSYCH;  ///< Offset: 0x28 - Busy Channels
        volatile uint32_t PENDCH;  ///< Offset: 0x2C - Pending Channels
        volatile uint32_t ACTIVE;  ///< Offset: 0x30 - Active Channel and Levels
        volatile uint32_t BASEADDR;  ///< Offset: 0x34 - Descriptor Memory Section Base Address
        volatile uint32_t WRBADDR;  ///< Offset: 0x38 - Write-Back Memory Section Base Address
        volatile uint32_t CHID;  ///< Offset: 0x3F - Channel ID
        volatile uint32_t CHCTRLA;  ///< Offset: 0x40 - Channel Control A
        volatile uint32_t CHCTRLB;  ///< Offset: 0x44 - Channel Control B
        volatile uint32_t CHINTENCLR;  ///< Offset: 0x4C - Channel Interrupt Enable Clear
        volatile uint32_t CHINTENSET;  ///< Offset: 0x4D - Channel Interrupt Enable Set
        volatile uint32_t CHINTFLAG;  ///< Offset: 0x4E - Channel Interrupt Flag Status and Clear
        volatile uint32_t CHSTATUS;  ///< Offset: 0x4F - Channel Status
    };

    /// Peripheral instances
    inline Registers* DMAC = reinterpret_cast<Registers*>(DMAC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t DMAENABLE = (1U << 1);  ///< DMA Enable
        constexpr uint32_t CRCENABLE = (1U << 2);  ///< CRC Enable
        constexpr uint32_t LVLEN0 = (1U << 8);  ///< Priority Level 0 Enable
        constexpr uint32_t LVLEN1 = (1U << 9);  ///< Priority Level 1 Enable
        constexpr uint32_t LVLEN2 = (1U << 10);  ///< Priority Level 2 Enable
        constexpr uint32_t LVLEN3 = (1U << 11);  ///< Priority Level 3 Enable
    }

    /// CRCCTRL Register bits
    namespace crcctrl_bits {
        constexpr uint32_t CRCBEATSIZE = (2 << 0);  ///< CRC Beat Size
        constexpr uint32_t CRCPOLY = (2 << 2);  ///< CRC Polynomial Type
        constexpr uint32_t CRCSRC = (6 << 8);  ///< CRC Input Source
    }

    /// CRCDATAIN Register bits
    namespace crcdatain_bits {
        constexpr uint32_t CRCDATAIN = (32 << 0);  ///< CRC Data Input
    }

    /// CRCCHKSUM Register bits
    namespace crcchksum_bits {
        constexpr uint32_t CRCCHKSUM = (32 << 0);  ///< CRC Checksum
    }

    /// CRCSTATUS Register bits
    namespace crcstatus_bits {
        constexpr uint32_t CRCBUSY = (1U << 0);  ///< CRC Module Busy
        constexpr uint32_t CRCZERO = (1U << 1);  ///< CRC Zero
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Debug Run
    }

    /// QOSCTRL Register bits
    namespace qosctrl_bits {
        constexpr uint32_t WRBQOS = (2 << 0);  ///< Write-Back Quality of Service
        constexpr uint32_t FQOS = (2 << 2);  ///< Fetch Quality of Service
        constexpr uint32_t DQOS = (2 << 4);  ///< Data Transfer Quality of Service
    }

    /// SWTRIGCTRL Register bits
    namespace swtrigctrl_bits {
        constexpr uint32_t SWTRIG0 = (1U << 0);  ///< Channel 0 Software Trigger
        constexpr uint32_t SWTRIG1 = (1U << 1);  ///< Channel 1 Software Trigger
        constexpr uint32_t SWTRIG2 = (1U << 2);  ///< Channel 2 Software Trigger
        constexpr uint32_t SWTRIG3 = (1U << 3);  ///< Channel 3 Software Trigger
        constexpr uint32_t SWTRIG4 = (1U << 4);  ///< Channel 4 Software Trigger
        constexpr uint32_t SWTRIG5 = (1U << 5);  ///< Channel 5 Software Trigger
        constexpr uint32_t SWTRIG6 = (1U << 6);  ///< Channel 6 Software Trigger
        constexpr uint32_t SWTRIG7 = (1U << 7);  ///< Channel 7 Software Trigger
        constexpr uint32_t SWTRIG8 = (1U << 8);  ///< Channel 8 Software Trigger
        constexpr uint32_t SWTRIG9 = (1U << 9);  ///< Channel 9 Software Trigger
        constexpr uint32_t SWTRIG10 = (1U << 10);  ///< Channel 10 Software Trigger
        constexpr uint32_t SWTRIG11 = (1U << 11);  ///< Channel 11 Software Trigger
        constexpr uint32_t SWTRIG12 = (1U << 12);  ///< Channel 12 Software Trigger
        constexpr uint32_t SWTRIG13 = (1U << 13);  ///< Channel 13 Software Trigger
        constexpr uint32_t SWTRIG14 = (1U << 14);  ///< Channel 14 Software Trigger
        constexpr uint32_t SWTRIG15 = (1U << 15);  ///< Channel 15 Software Trigger
    }

    /// PRICTRL0 Register bits
    namespace prictrl0_bits {
        constexpr uint32_t LVLPRI0 = (4 << 0);  ///< Level 0 Channel Priority Number
        constexpr uint32_t RRLVLEN0 = (1U << 7);  ///< Level 0 Round-Robin Scheduling Enable
        constexpr uint32_t LVLPRI1 = (4 << 8);  ///< Level 1 Channel Priority Number
        constexpr uint32_t RRLVLEN1 = (1U << 15);  ///< Level 1 Round-Robin Scheduling Enable
        constexpr uint32_t LVLPRI2 = (4 << 16);  ///< Level 2 Channel Priority Number
        constexpr uint32_t RRLVLEN2 = (1U << 23);  ///< Level 2 Round-Robin Scheduling Enable
        constexpr uint32_t LVLPRI3 = (4 << 24);  ///< Level 3 Channel Priority Number
        constexpr uint32_t RRLVLEN3 = (1U << 31);  ///< Level 3 Round-Robin Scheduling Enable
    }

    /// INTPEND Register bits
    namespace intpend_bits {
        constexpr uint32_t ID = (4 << 0);  ///< Channel ID
        constexpr uint32_t TERR = (1U << 8);  ///< Transfer Error
        constexpr uint32_t TCMPL = (1U << 9);  ///< Transfer Complete
        constexpr uint32_t SUSP = (1U << 10);  ///< Channel Suspend
        constexpr uint32_t FERR = (1U << 13);  ///< Fetch Error
        constexpr uint32_t BUSY = (1U << 14);  ///< Busy
        constexpr uint32_t PEND = (1U << 15);  ///< Pending
    }

    /// INTSTATUS Register bits
    namespace intstatus_bits {
        constexpr uint32_t CHINT0 = (1U << 0);  ///< Channel 0 Pending Interrupt
        constexpr uint32_t CHINT1 = (1U << 1);  ///< Channel 1 Pending Interrupt
        constexpr uint32_t CHINT2 = (1U << 2);  ///< Channel 2 Pending Interrupt
        constexpr uint32_t CHINT3 = (1U << 3);  ///< Channel 3 Pending Interrupt
        constexpr uint32_t CHINT4 = (1U << 4);  ///< Channel 4 Pending Interrupt
        constexpr uint32_t CHINT5 = (1U << 5);  ///< Channel 5 Pending Interrupt
        constexpr uint32_t CHINT6 = (1U << 6);  ///< Channel 6 Pending Interrupt
        constexpr uint32_t CHINT7 = (1U << 7);  ///< Channel 7 Pending Interrupt
        constexpr uint32_t CHINT8 = (1U << 8);  ///< Channel 8 Pending Interrupt
        constexpr uint32_t CHINT9 = (1U << 9);  ///< Channel 9 Pending Interrupt
        constexpr uint32_t CHINT10 = (1U << 10);  ///< Channel 10 Pending Interrupt
        constexpr uint32_t CHINT11 = (1U << 11);  ///< Channel 11 Pending Interrupt
        constexpr uint32_t CHINT12 = (1U << 12);  ///< Channel 12 Pending Interrupt
        constexpr uint32_t CHINT13 = (1U << 13);  ///< Channel 13 Pending Interrupt
        constexpr uint32_t CHINT14 = (1U << 14);  ///< Channel 14 Pending Interrupt
        constexpr uint32_t CHINT15 = (1U << 15);  ///< Channel 15 Pending Interrupt
    }

    /// BUSYCH Register bits
    namespace busych_bits {
        constexpr uint32_t BUSYCH0 = (1U << 0);  ///< Busy Channel 0
        constexpr uint32_t BUSYCH1 = (1U << 1);  ///< Busy Channel 1
        constexpr uint32_t BUSYCH2 = (1U << 2);  ///< Busy Channel 2
        constexpr uint32_t BUSYCH3 = (1U << 3);  ///< Busy Channel 3
        constexpr uint32_t BUSYCH4 = (1U << 4);  ///< Busy Channel 4
        constexpr uint32_t BUSYCH5 = (1U << 5);  ///< Busy Channel 5
        constexpr uint32_t BUSYCH6 = (1U << 6);  ///< Busy Channel 6
        constexpr uint32_t BUSYCH7 = (1U << 7);  ///< Busy Channel 7
        constexpr uint32_t BUSYCH8 = (1U << 8);  ///< Busy Channel 8
        constexpr uint32_t BUSYCH9 = (1U << 9);  ///< Busy Channel 9
        constexpr uint32_t BUSYCH10 = (1U << 10);  ///< Busy Channel 10
        constexpr uint32_t BUSYCH11 = (1U << 11);  ///< Busy Channel 11
        constexpr uint32_t BUSYCH12 = (1U << 12);  ///< Busy Channel 12
        constexpr uint32_t BUSYCH13 = (1U << 13);  ///< Busy Channel 13
        constexpr uint32_t BUSYCH14 = (1U << 14);  ///< Busy Channel 14
        constexpr uint32_t BUSYCH15 = (1U << 15);  ///< Busy Channel 15
    }

    /// PENDCH Register bits
    namespace pendch_bits {
        constexpr uint32_t PENDCH0 = (1U << 0);  ///< Pending Channel 0
        constexpr uint32_t PENDCH1 = (1U << 1);  ///< Pending Channel 1
        constexpr uint32_t PENDCH2 = (1U << 2);  ///< Pending Channel 2
        constexpr uint32_t PENDCH3 = (1U << 3);  ///< Pending Channel 3
        constexpr uint32_t PENDCH4 = (1U << 4);  ///< Pending Channel 4
        constexpr uint32_t PENDCH5 = (1U << 5);  ///< Pending Channel 5
        constexpr uint32_t PENDCH6 = (1U << 6);  ///< Pending Channel 6
        constexpr uint32_t PENDCH7 = (1U << 7);  ///< Pending Channel 7
        constexpr uint32_t PENDCH8 = (1U << 8);  ///< Pending Channel 8
        constexpr uint32_t PENDCH9 = (1U << 9);  ///< Pending Channel 9
        constexpr uint32_t PENDCH10 = (1U << 10);  ///< Pending Channel 10
        constexpr uint32_t PENDCH11 = (1U << 11);  ///< Pending Channel 11
        constexpr uint32_t PENDCH12 = (1U << 12);  ///< Pending Channel 12
        constexpr uint32_t PENDCH13 = (1U << 13);  ///< Pending Channel 13
        constexpr uint32_t PENDCH14 = (1U << 14);  ///< Pending Channel 14
        constexpr uint32_t PENDCH15 = (1U << 15);  ///< Pending Channel 15
    }

    /// ACTIVE Register bits
    namespace active_bits {
        constexpr uint32_t LVLEX0 = (1U << 0);  ///< Level 0 Channel Trigger Request Executing
        constexpr uint32_t LVLEX1 = (1U << 1);  ///< Level 1 Channel Trigger Request Executing
        constexpr uint32_t LVLEX2 = (1U << 2);  ///< Level 2 Channel Trigger Request Executing
        constexpr uint32_t LVLEX3 = (1U << 3);  ///< Level 3 Channel Trigger Request Executing
        constexpr uint32_t ID = (5 << 8);  ///< Active Channel ID
        constexpr uint32_t ABUSY = (1U << 15);  ///< Active Channel Busy
        constexpr uint32_t BTCNT = (16 << 16);  ///< Active Channel Block Transfer Count
    }

    /// BASEADDR Register bits
    namespace baseaddr_bits {
        constexpr uint32_t BASEADDR = (32 << 0);  ///< Descriptor Memory Base Address
    }

    /// WRBADDR Register bits
    namespace wrbaddr_bits {
        constexpr uint32_t WRBADDR = (32 << 0);  ///< Write-Back Memory Base Address
    }

    /// CHID Register bits
    namespace chid_bits {
        constexpr uint32_t ID = (4 << 0);  ///< Channel ID
    }

    /// CHCTRLA Register bits
    namespace chctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Channel Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Channel Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Channel run in standby
    }

    /// CHCTRLB Register bits
    namespace chctrlb_bits {
        constexpr uint32_t EVACT = (3 << 0);  ///< Event Input Action
        constexpr uint32_t EVIE = (1U << 3);  ///< Channel Event Input Enable
        constexpr uint32_t EVOE = (1U << 4);  ///< Channel Event Output Enable
        constexpr uint32_t LVL = (2 << 5);  ///< Channel Arbitration Level
        constexpr uint32_t TRIGSRC = (6 << 8);  ///< Trigger Source
        constexpr uint32_t TRIGACT = (2 << 22);  ///< Trigger Action
        constexpr uint32_t CMD = (2 << 24);  ///< Software Command
    }

    /// CHINTENCLR Register bits
    namespace chintenclr_bits {
        constexpr uint32_t TERR = (1U << 0);  ///< Channel Transfer Error Interrupt Enable
        constexpr uint32_t TCMPL = (1U << 1);  ///< Channel Transfer Complete Interrupt Enable
        constexpr uint32_t SUSP = (1U << 2);  ///< Channel Suspend Interrupt Enable
    }

    /// CHINTENSET Register bits
    namespace chintenset_bits {
        constexpr uint32_t TERR = (1U << 0);  ///< Channel Transfer Error Interrupt Enable
        constexpr uint32_t TCMPL = (1U << 1);  ///< Channel Transfer Complete Interrupt Enable
        constexpr uint32_t SUSP = (1U << 2);  ///< Channel Suspend Interrupt Enable
    }

    /// CHINTFLAG Register bits
    namespace chintflag_bits {
        constexpr uint32_t TERR = (1U << 0);  ///< Channel Transfer Error
        constexpr uint32_t TCMPL = (1U << 1);  ///< Channel Transfer Complete
        constexpr uint32_t SUSP = (1U << 2);  ///< Channel Suspend
    }

    /// CHSTATUS Register bits
    namespace chstatus_bits {
        constexpr uint32_t PEND = (1U << 0);  ///< Channel Pending
        constexpr uint32_t BUSY = (1U << 1);  ///< Channel Busy
        constexpr uint32_t FERR = (1U << 2);  ///< Channel Fetch Error
    }

}

// ============================================================================
// DSU Peripheral
// ============================================================================

namespace dsu {
    /// Base addresses
    constexpr uint32_t DSU_BASE = 0x41002000;

    /// DSU Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control
        volatile uint32_t STATUSA;  ///< Offset: 0x01 - Status A
        volatile uint32_t STATUSB;  ///< Offset: 0x02 - Status B
        volatile uint32_t ADDR;  ///< Offset: 0x04 - Address
        volatile uint32_t LENGTH;  ///< Offset: 0x08 - Length
        volatile uint32_t DATA;  ///< Offset: 0x0C - Data
        volatile uint32_t DCC%s;  ///< Offset: 0x10 - Debug Communication Channel n
        volatile uint32_t DID;  ///< Offset: 0x18 - Device Identification
        volatile uint32_t DCFG%s;  ///< Offset: 0xF0 - Device Configuration
        volatile uint32_t ENTRY0;  ///< Offset: 0x1000 - CoreSight ROM Table Entry 0
        volatile uint32_t ENTRY1;  ///< Offset: 0x1004 - CoreSight ROM Table Entry 1
        volatile uint32_t END;  ///< Offset: 0x1008 - CoreSight ROM Table End
        volatile uint32_t MEMTYPE;  ///< Offset: 0x1FCC - CoreSight ROM Table Memory Type
        volatile uint32_t PID4;  ///< Offset: 0x1FD0 - Peripheral Identification 4
        volatile uint32_t PID5;  ///< Offset: 0x1FD4 - Peripheral Identification 5
        volatile uint32_t PID6;  ///< Offset: 0x1FD8 - Peripheral Identification 6
        volatile uint32_t PID7;  ///< Offset: 0x1FDC - Peripheral Identification 7
        volatile uint32_t PID0;  ///< Offset: 0x1FE0 - Peripheral Identification 0
        volatile uint32_t PID1;  ///< Offset: 0x1FE4 - Peripheral Identification 1
        volatile uint32_t PID2;  ///< Offset: 0x1FE8 - Peripheral Identification 2
        volatile uint32_t PID3;  ///< Offset: 0x1FEC - Peripheral Identification 3
        volatile uint32_t CID0;  ///< Offset: 0x1FF0 - Component Identification 0
        volatile uint32_t CID1;  ///< Offset: 0x1FF4 - Component Identification 1
        volatile uint32_t CID2;  ///< Offset: 0x1FF8 - Component Identification 2
        volatile uint32_t CID3;  ///< Offset: 0x1FFC - Component Identification 3
    };

    /// Peripheral instances
    inline Registers* DSU = reinterpret_cast<Registers*>(DSU_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t CRC = (1U << 2);  ///< 32-bit Cyclic Redundancy Code
        constexpr uint32_t MBIST = (1U << 3);  ///< Memory built-in self-test
        constexpr uint32_t CE = (1U << 4);  ///< Chip-Erase
        constexpr uint32_t ARR = (1U << 6);  ///< Auxiliary Row Read
        constexpr uint32_t SMSA = (1U << 7);  ///< Start Memory Stream Access
    }

    /// STATUSA Register bits
    namespace statusa_bits {
        constexpr uint32_t DONE = (1U << 0);  ///< Done
        constexpr uint32_t CRSTEXT = (1U << 1);  ///< CPU Reset Phase Extension
        constexpr uint32_t BERR = (1U << 2);  ///< Bus Error
        constexpr uint32_t FAIL = (1U << 3);  ///< Failure
        constexpr uint32_t PERR = (1U << 4);  ///< Protection Error
    }

    /// STATUSB Register bits
    namespace statusb_bits {
        constexpr uint32_t PROT = (1U << 0);  ///< Protected
        constexpr uint32_t DBGPRES = (1U << 1);  ///< Debugger Present
        constexpr uint32_t DCCD0 = (1U << 2);  ///< Debug Communication Channel 0 Dirty
        constexpr uint32_t DCCD1 = (1U << 3);  ///< Debug Communication Channel 1 Dirty
        constexpr uint32_t HPE = (1U << 4);  ///< Hot-Plugging Enable
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t AMOD = (2 << 0);  ///< Access Mode
        constexpr uint32_t ADDR = (30 << 2);  ///< Address
    }

    /// LENGTH Register bits
    namespace length_bits {
        constexpr uint32_t LENGTH = (30 << 2);  ///< Length
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// DCC%s Register bits
    namespace dcc%s_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// DID Register bits
    namespace did_bits {
        constexpr uint32_t DEVSEL = (8 << 0);  ///< Device Select
        constexpr uint32_t REVISION = (4 << 8);  ///< Revision Number
        constexpr uint32_t DIE = (4 << 12);  ///< Die Number
        constexpr uint32_t SERIES = (6 << 16);  ///< Series
        constexpr uint32_t FAMILY = (5 << 23);  ///< Family
        constexpr uint32_t PROCESSOR = (4 << 28);  ///< Processor
    }

    /// DCFG%s Register bits
    namespace dcfg%s_bits {
        constexpr uint32_t DCFG = (32 << 0);  ///< Device Configuration
    }

    /// ENTRY0 Register bits
    namespace entry0_bits {
        constexpr uint32_t EPRES = (1U << 0);  ///< Entry Present
        constexpr uint32_t FMT = (1U << 1);  ///< Format
        constexpr uint32_t ADDOFF = (20 << 12);  ///< Address Offset
    }

    /// END Register bits
    namespace end_bits {
        constexpr uint32_t END = (32 << 0);  ///< End Marker
    }

    /// MEMTYPE Register bits
    namespace memtype_bits {
        constexpr uint32_t SMEMP = (1U << 0);  ///< System Memory Present
    }

    /// PID4 Register bits
    namespace pid4_bits {
        constexpr uint32_t JEPCC = (4 << 0);  ///< JEP-106 Continuation Code
        constexpr uint32_t FKBC = (4 << 4);  ///< 4KB count
    }

    /// PID0 Register bits
    namespace pid0_bits {
        constexpr uint32_t PARTNBL = (8 << 0);  ///< Part Number Low
    }

    /// PID1 Register bits
    namespace pid1_bits {
        constexpr uint32_t PARTNBH = (4 << 0);  ///< Part Number High
        constexpr uint32_t JEPIDCL = (4 << 4);  ///< Low part of the JEP-106 Identity Code
    }

    /// PID2 Register bits
    namespace pid2_bits {
        constexpr uint32_t JEPIDCH = (3 << 0);  ///< JEP-106 Identity Code High
        constexpr uint32_t JEPU = (1U << 3);  ///< JEP-106 Identity Code is used
        constexpr uint32_t REVISION = (4 << 4);  ///< Revision Number
    }

    /// PID3 Register bits
    namespace pid3_bits {
        constexpr uint32_t CUSMOD = (4 << 0);  ///< ARM CUSMOD
        constexpr uint32_t REVAND = (4 << 4);  ///< Revision Number
    }

    /// CID0 Register bits
    namespace cid0_bits {
        constexpr uint32_t PREAMBLEB0 = (8 << 0);  ///< Preamble Byte 0
    }

    /// CID1 Register bits
    namespace cid1_bits {
        constexpr uint32_t PREAMBLE = (4 << 0);  ///< Preamble
        constexpr uint32_t CCLASS = (4 << 4);  ///< Component Class
    }

    /// CID2 Register bits
    namespace cid2_bits {
        constexpr uint32_t PREAMBLEB2 = (8 << 0);  ///< Preamble Byte 2
    }

    /// CID3 Register bits
    namespace cid3_bits {
        constexpr uint32_t PREAMBLEB3 = (8 << 0);  ///< Preamble Byte 3
    }

}

// ============================================================================
// EIC Peripheral
// ============================================================================

namespace eic {
    /// Base addresses
    constexpr uint32_t EIC_BASE = 0x40002800;

    /// EIC Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control
        volatile uint32_t NMICTRL;  ///< Offset: 0x01 - NMI Control
        volatile uint32_t NMIFLAG;  ///< Offset: 0x02 - NMI Interrupt Flag
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x04 - Syncbusy register
        volatile uint32_t EVCTRL;  ///< Offset: 0x08 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x0C - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x10 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x14 - Interrupt Flag Status and Clear
        volatile uint32_t ASYNCH;  ///< Offset: 0x18 - EIC Asynchronous edge Detection Enable
        volatile uint32_t CONFIG%s;  ///< Offset: 0x1C - Configuration n
    };

    /// Peripheral instances
    inline Registers* EIC = reinterpret_cast<Registers*>(EIC_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t CKSEL = (1U << 4);  ///< Clock Selection
    }

    /// NMICTRL Register bits
    namespace nmictrl_bits {
        constexpr uint32_t NMISENSE = (3 << 0);  ///< NMI Input Sense Configuration
        constexpr uint32_t NMIFILTEN = (1U << 3);  ///< NMI Filter Enable
        constexpr uint32_t NMIASYNCH = (1U << 4);  ///< NMI Asynchronous edge Detection Enable
    }

    /// NMIFLAG Register bits
    namespace nmiflag_bits {
        constexpr uint32_t NMI = (1U << 0);  ///< NMI Interrupt Flag
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software reset synchronisation
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable synchronisation
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t EXTINTEO = (16 << 0);  ///< External Interrupt Event Output Enable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t EXTINT = (16 << 0);  ///< External Interrupt Disable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t EXTINT = (16 << 0);  ///< External Interrupt Disable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t EXTINT = (16 << 0);  ///< External Interrupt Flag
    }

    /// ASYNCH Register bits
    namespace asynch_bits {
        constexpr uint32_t ASYNCH = (16 << 0);  ///< EIC Asynchronous edge Detection Enable
    }

    /// CONFIG%s Register bits
    namespace config%s_bits {
        constexpr uint32_t SENSE0 = (3 << 0);  ///< Input Sense Configuration 0
        constexpr uint32_t FILTEN0 = (1U << 3);  ///< Filter Enable 0
        constexpr uint32_t SENSE1 = (3 << 4);  ///< Input Sense Configuration 1
        constexpr uint32_t FILTEN1 = (1U << 7);  ///< Filter Enable 1
        constexpr uint32_t SENSE2 = (3 << 8);  ///< Input Sense Configuration 2
        constexpr uint32_t FILTEN2 = (1U << 11);  ///< Filter Enable 2
        constexpr uint32_t SENSE3 = (3 << 12);  ///< Input Sense Configuration 3
        constexpr uint32_t FILTEN3 = (1U << 15);  ///< Filter Enable 3
        constexpr uint32_t SENSE4 = (3 << 16);  ///< Input Sense Configuration 4
        constexpr uint32_t FILTEN4 = (1U << 19);  ///< Filter Enable 4
        constexpr uint32_t SENSE5 = (3 << 20);  ///< Input Sense Configuration 5
        constexpr uint32_t FILTEN5 = (1U << 23);  ///< Filter Enable 5
        constexpr uint32_t SENSE6 = (3 << 24);  ///< Input Sense Configuration 6
        constexpr uint32_t FILTEN6 = (1U << 27);  ///< Filter Enable 6
        constexpr uint32_t SENSE7 = (3 << 28);  ///< Input Sense Configuration 7
        constexpr uint32_t FILTEN7 = (1U << 31);  ///< Filter Enable 7
    }

}

// ============================================================================
// EVSYS Peripheral
// ============================================================================

namespace evsys {
    /// Base addresses
    constexpr uint32_t EVSYS_BASE = 0x42000000;

    /// EVSYS Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control
        volatile uint32_t CHSTATUS;  ///< Offset: 0x0C - Channel Status
        volatile uint32_t INTENCLR;  ///< Offset: 0x10 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x14 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x18 - Interrupt Flag Status and Clear
        volatile uint32_t SWEVT;  ///< Offset: 0x1C - Software Event
        volatile uint32_t CHANNEL%s;  ///< Offset: 0x20 - Channel n
        volatile uint32_t USER%s;  ///< Offset: 0x80 - User Multiplexer n
    };

    /// Peripheral instances
    inline Registers* EVSYS = reinterpret_cast<Registers*>(EVSYS_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
    }

    /// CHSTATUS Register bits
    namespace chstatus_bits {
        constexpr uint32_t USRRDY0 = (1U << 0);  ///< Channel 0 User Ready
        constexpr uint32_t USRRDY1 = (1U << 1);  ///< Channel 1 User Ready
        constexpr uint32_t USRRDY2 = (1U << 2);  ///< Channel 2 User Ready
        constexpr uint32_t USRRDY3 = (1U << 3);  ///< Channel 3 User Ready
        constexpr uint32_t USRRDY4 = (1U << 4);  ///< Channel 4 User Ready
        constexpr uint32_t USRRDY5 = (1U << 5);  ///< Channel 5 User Ready
        constexpr uint32_t USRRDY6 = (1U << 6);  ///< Channel 6 User Ready
        constexpr uint32_t USRRDY7 = (1U << 7);  ///< Channel 7 User Ready
        constexpr uint32_t CHBUSY0 = (1U << 16);  ///< Channel 0 Busy
        constexpr uint32_t CHBUSY1 = (1U << 17);  ///< Channel 1 Busy
        constexpr uint32_t CHBUSY2 = (1U << 18);  ///< Channel 2 Busy
        constexpr uint32_t CHBUSY3 = (1U << 19);  ///< Channel 3 Busy
        constexpr uint32_t CHBUSY4 = (1U << 20);  ///< Channel 4 Busy
        constexpr uint32_t CHBUSY5 = (1U << 21);  ///< Channel 5 Busy
        constexpr uint32_t CHBUSY6 = (1U << 22);  ///< Channel 6 Busy
        constexpr uint32_t CHBUSY7 = (1U << 23);  ///< Channel 7 Busy
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t OVR0 = (1U << 0);  ///< Channel 0 Overrun Interrupt Enable
        constexpr uint32_t OVR1 = (1U << 1);  ///< Channel 1 Overrun Interrupt Enable
        constexpr uint32_t OVR2 = (1U << 2);  ///< Channel 2 Overrun Interrupt Enable
        constexpr uint32_t OVR3 = (1U << 3);  ///< Channel 3 Overrun Interrupt Enable
        constexpr uint32_t OVR4 = (1U << 4);  ///< Channel 4 Overrun Interrupt Enable
        constexpr uint32_t OVR5 = (1U << 5);  ///< Channel 5 Overrun Interrupt Enable
        constexpr uint32_t OVR6 = (1U << 6);  ///< Channel 6 Overrun Interrupt Enable
        constexpr uint32_t OVR7 = (1U << 7);  ///< Channel 7 Overrun Interrupt Enable
        constexpr uint32_t EVD0 = (1U << 16);  ///< Channel 0 Event Detection Interrupt Enable
        constexpr uint32_t EVD1 = (1U << 17);  ///< Channel 1 Event Detection Interrupt Enable
        constexpr uint32_t EVD2 = (1U << 18);  ///< Channel 2 Event Detection Interrupt Enable
        constexpr uint32_t EVD3 = (1U << 19);  ///< Channel 3 Event Detection Interrupt Enable
        constexpr uint32_t EVD4 = (1U << 20);  ///< Channel 4 Event Detection Interrupt Enable
        constexpr uint32_t EVD5 = (1U << 21);  ///< Channel 5 Event Detection Interrupt Enable
        constexpr uint32_t EVD6 = (1U << 22);  ///< Channel 6 Event Detection Interrupt Enable
        constexpr uint32_t EVD7 = (1U << 23);  ///< Channel 7 Event Detection Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t OVR0 = (1U << 0);  ///< Channel 0 Overrun Interrupt Enable
        constexpr uint32_t OVR1 = (1U << 1);  ///< Channel 1 Overrun Interrupt Enable
        constexpr uint32_t OVR2 = (1U << 2);  ///< Channel 2 Overrun Interrupt Enable
        constexpr uint32_t OVR3 = (1U << 3);  ///< Channel 3 Overrun Interrupt Enable
        constexpr uint32_t OVR4 = (1U << 4);  ///< Channel 4 Overrun Interrupt Enable
        constexpr uint32_t OVR5 = (1U << 5);  ///< Channel 5 Overrun Interrupt Enable
        constexpr uint32_t OVR6 = (1U << 6);  ///< Channel 6 Overrun Interrupt Enable
        constexpr uint32_t OVR7 = (1U << 7);  ///< Channel 7 Overrun Interrupt Enable
        constexpr uint32_t EVD0 = (1U << 16);  ///< Channel 0 Event Detection Interrupt Enable
        constexpr uint32_t EVD1 = (1U << 17);  ///< Channel 1 Event Detection Interrupt Enable
        constexpr uint32_t EVD2 = (1U << 18);  ///< Channel 2 Event Detection Interrupt Enable
        constexpr uint32_t EVD3 = (1U << 19);  ///< Channel 3 Event Detection Interrupt Enable
        constexpr uint32_t EVD4 = (1U << 20);  ///< Channel 4 Event Detection Interrupt Enable
        constexpr uint32_t EVD5 = (1U << 21);  ///< Channel 5 Event Detection Interrupt Enable
        constexpr uint32_t EVD6 = (1U << 22);  ///< Channel 6 Event Detection Interrupt Enable
        constexpr uint32_t EVD7 = (1U << 23);  ///< Channel 7 Event Detection Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t OVR0 = (1U << 0);  ///< Channel 0 Overrun
        constexpr uint32_t OVR1 = (1U << 1);  ///< Channel 1 Overrun
        constexpr uint32_t OVR2 = (1U << 2);  ///< Channel 2 Overrun
        constexpr uint32_t OVR3 = (1U << 3);  ///< Channel 3 Overrun
        constexpr uint32_t OVR4 = (1U << 4);  ///< Channel 4 Overrun
        constexpr uint32_t OVR5 = (1U << 5);  ///< Channel 5 Overrun
        constexpr uint32_t OVR6 = (1U << 6);  ///< Channel 6 Overrun
        constexpr uint32_t OVR7 = (1U << 7);  ///< Channel 7 Overrun
        constexpr uint32_t EVD0 = (1U << 16);  ///< Channel 0 Event Detection
        constexpr uint32_t EVD1 = (1U << 17);  ///< Channel 1 Event Detection
        constexpr uint32_t EVD2 = (1U << 18);  ///< Channel 2 Event Detection
        constexpr uint32_t EVD3 = (1U << 19);  ///< Channel 3 Event Detection
        constexpr uint32_t EVD4 = (1U << 20);  ///< Channel 4 Event Detection
        constexpr uint32_t EVD5 = (1U << 21);  ///< Channel 5 Event Detection
        constexpr uint32_t EVD6 = (1U << 22);  ///< Channel 6 Event Detection
        constexpr uint32_t EVD7 = (1U << 23);  ///< Channel 7 Event Detection
    }

    /// SWEVT Register bits
    namespace swevt_bits {
        constexpr uint32_t CHANNEL0 = (1U << 0);  ///< Channel 0 Software Selection
        constexpr uint32_t CHANNEL1 = (1U << 1);  ///< Channel 1 Software Selection
        constexpr uint32_t CHANNEL2 = (1U << 2);  ///< Channel 2 Software Selection
        constexpr uint32_t CHANNEL3 = (1U << 3);  ///< Channel 3 Software Selection
        constexpr uint32_t CHANNEL4 = (1U << 4);  ///< Channel 4 Software Selection
        constexpr uint32_t CHANNEL5 = (1U << 5);  ///< Channel 5 Software Selection
        constexpr uint32_t CHANNEL6 = (1U << 6);  ///< Channel 6 Software Selection
        constexpr uint32_t CHANNEL7 = (1U << 7);  ///< Channel 7 Software Selection
    }

    /// CHANNEL%s Register bits
    namespace channel%s_bits {
        constexpr uint32_t EVGEN = (7 << 0);  ///< Event Generator Selection
        constexpr uint32_t PATH = (2 << 8);  ///< Path Selection
        constexpr uint32_t EDGSEL = (2 << 10);  ///< Edge Detection Selection
        constexpr uint32_t RUNSTDBY = (1U << 14);  ///< Run in standby
        constexpr uint32_t ONDEMAND = (1U << 15);  ///< Generic Clock On Demand
    }

    /// USER%s Register bits
    namespace user%s_bits {
        constexpr uint32_t CHANNEL = (4 << 0);  ///< Channel Event Selection
    }

}

// ============================================================================
// FREQM Peripheral
// ============================================================================

namespace freqm {
    /// Base addresses
    constexpr uint32_t FREQM_BASE = 0x40002C00;

    /// FREQM Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A Register
        volatile uint32_t CTRLB;  ///< Offset: 0x01 - Control B Register
        volatile uint32_t CFGA;  ///< Offset: 0x02 - Config A register
        volatile uint32_t INTENCLR;  ///< Offset: 0x08 - Interrupt Enable Clear Register
        volatile uint32_t INTENSET;  ///< Offset: 0x09 - Interrupt Enable Set Register
        volatile uint32_t INTFLAG;  ///< Offset: 0x0A - Interrupt Flag Register
        volatile uint32_t STATUS;  ///< Offset: 0x0B - Status Register
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x0C - Synchronization Busy Register
        volatile uint32_t VALUE;  ///< Offset: 0x10 - Count Value Register
    };

    /// Peripheral instances
    inline Registers* FREQM = reinterpret_cast<Registers*>(FREQM_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start Measurement
    }

    /// CFGA Register bits
    namespace cfga_bits {
        constexpr uint32_t REFNUM = (8 << 0);  ///< Number of Reference Clock Cycles
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t DONE = (1U << 0);  ///< Measurement Done Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t DONE = (1U << 0);  ///< Measurement Done Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t DONE = (1U << 0);  ///< Measurement Done
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t BUSY = (1U << 0);  ///< FREQM Status
        constexpr uint32_t OVF = (1U << 1);  ///< Sticky Count Value Overflow
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
    }

    /// VALUE Register bits
    namespace value_bits {
        constexpr uint32_t VALUE = (24 << 0);  ///< Measurement Value
    }

}

// ============================================================================
// GCLK Peripheral
// ============================================================================

namespace gclk {
    /// Base addresses
    constexpr uint32_t GCLK_BASE = 0x40001C00;

    /// GCLK Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x04 - Synchronization Busy
        volatile uint32_t GENCTRL%s;  ///< Offset: 0x20 - Generic Clock Generator Control
        volatile uint32_t PCHCTRL%s;  ///< Offset: 0x80 - Peripheral Clock Control
    };

    /// Peripheral instances
    inline Registers* GCLK = reinterpret_cast<Registers*>(GCLK_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchroniation Busy bit
        constexpr uint32_t GENCTRL0 = (1U << 2);  ///< Generic Clock Generator Control 0 Synchronization Busy bits
        constexpr uint32_t GENCTRL1 = (1U << 3);  ///< Generic Clock Generator Control 1 Synchronization Busy bits
        constexpr uint32_t GENCTRL2 = (1U << 4);  ///< Generic Clock Generator Control 2 Synchronization Busy bits
        constexpr uint32_t GENCTRL3 = (1U << 5);  ///< Generic Clock Generator Control 3 Synchronization Busy bits
        constexpr uint32_t GENCTRL4 = (1U << 6);  ///< Generic Clock Generator Control 4 Synchronization Busy bits
    }

    /// GENCTRL%s Register bits
    namespace genctrl%s_bits {
        constexpr uint32_t SRC = (3 << 0);  ///< Source Select
        constexpr uint32_t GENEN = (1U << 8);  ///< Generic Clock Generator Enable
        constexpr uint32_t IDC = (1U << 9);  ///< Improve Duty Cycle
        constexpr uint32_t OOV = (1U << 10);  ///< Output Off Value
        constexpr uint32_t OE = (1U << 11);  ///< Output Enable
        constexpr uint32_t DIVSEL = (1U << 12);  ///< Divide Selection
        constexpr uint32_t RUNSTDBY = (1U << 13);  ///< Run in Standby
        constexpr uint32_t DIV = (16 << 16);  ///< Division Factor
    }

    /// PCHCTRL%s Register bits
    namespace pchctrl%s_bits {
        constexpr uint32_t GEN = (3 << 0);  ///< Generic Clock Generator
        constexpr uint32_t CHEN = (1U << 6);  ///< Channel Enable
        constexpr uint32_t WRTLOCK = (1U << 7);  ///< Write Lock
    }

}

// ============================================================================
// MCLK Peripheral
// ============================================================================

namespace mclk {
    /// Base addresses
    constexpr uint32_t MCLK_BASE = 0x40000800;

    /// MCLK Register structure
    struct Registers {
        volatile uint32_t INTENCLR;  ///< Offset: 0x01 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x02 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x03 - Interrupt Flag Status and Clear
        volatile uint32_t CPUDIV;  ///< Offset: 0x04 - CPU Clock Division
        volatile uint32_t BUPDIV;  ///< Offset: 0x06 - Backup Clock Division
        volatile uint32_t AHBMASK;  ///< Offset: 0x10 - AHB Mask
        volatile uint32_t APBAMASK;  ///< Offset: 0x14 - APBA Mask
        volatile uint32_t APBBMASK;  ///< Offset: 0x18 - APBB Mask
        volatile uint32_t APBCMASK;  ///< Offset: 0x1C - APBC Mask
    };

    /// Peripheral instances
    inline Registers* MCLK = reinterpret_cast<Registers*>(MCLK_BASE);

    // Bit definitions
    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t CKRDY = (1U << 0);  ///< Clock Ready Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t CKRDY = (1U << 0);  ///< Clock Ready Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t CKRDY = (1U << 0);  ///< Clock Ready
    }

    /// CPUDIV Register bits
    namespace cpudiv_bits {
        constexpr uint32_t CPUDIV = (8 << 0);  ///< CPU Clock Division Factor
    }

    /// BUPDIV Register bits
    namespace bupdiv_bits {
        constexpr uint32_t BUPDIV = (8 << 0);  ///< Backup Clock Division Factor
    }

    /// AHBMASK Register bits
    namespace ahbmask_bits {
        constexpr uint32_t HPB0_ = (1U << 0);  ///< HPB0 AHB Clock Mask
        constexpr uint32_t HPB1_ = (1U << 1);  ///< HPB1 AHB Clock Mask
        constexpr uint32_t HPB2_ = (1U << 2);  ///< HPB2 AHB Clock Mask
        constexpr uint32_t DMAC_ = (1U << 3);  ///< DMAC AHB Clock Mask
        constexpr uint32_t USB_ = (1U << 4);  ///< USB AHB Clock Mask
        constexpr uint32_t DSU_ = (1U << 5);  ///< DSU AHB Clock Mask
        constexpr uint32_t PAC_ = (1U << 7);  ///< PAC AHB Clock Mask
        constexpr uint32_t NVMCTRL_ = (1U << 8);  ///< NVMCTRL AHB Clock Mask
        constexpr uint32_t HSRAM_ = (1U << 9);  ///< HSRAM AHB Clock Mask
        constexpr uint32_t NVMCTRL_PICACHU_ = (1U << 10);  ///< NVMCTRL_PICACHU AHB Clock Mask
    }

    /// APBAMASK Register bits
    namespace apbamask_bits {
        constexpr uint32_t PAC_ = (1U << 0);  ///< PAC APB Clock Enable
        constexpr uint32_t PM_ = (1U << 1);  ///< PM APB Clock Enable
        constexpr uint32_t MCLK_ = (1U << 2);  ///< MCLK APB Clock Enable
        constexpr uint32_t RSTC_ = (1U << 3);  ///< RSTC APB Clock Enable
        constexpr uint32_t OSCCTRL_ = (1U << 4);  ///< OSCCTRL APB Clock Enable
        constexpr uint32_t OSC32KCTRL_ = (1U << 5);  ///< OSC32KCTRL APB Clock Enable
        constexpr uint32_t SUPC_ = (1U << 6);  ///< SUPC APB Clock Enable
        constexpr uint32_t GCLK_ = (1U << 7);  ///< GCLK APB Clock Enable
        constexpr uint32_t WDT_ = (1U << 8);  ///< WDT APB Clock Enable
        constexpr uint32_t RTC_ = (1U << 9);  ///< RTC APB Clock Enable
        constexpr uint32_t EIC_ = (1U << 10);  ///< EIC APB Clock Enable
        constexpr uint32_t FREQM_ = (1U << 11);  ///< FREQM APB Clock Enable
    }

    /// APBBMASK Register bits
    namespace apbbmask_bits {
        constexpr uint32_t USB_ = (1U << 0);  ///< USB APB Clock Enable
        constexpr uint32_t DSU_ = (1U << 1);  ///< DSU APB Clock Enable
        constexpr uint32_t NVMCTRL_ = (1U << 2);  ///< NVMCTRL APB Clock Enable
        constexpr uint32_t PORT_ = (1U << 3);  ///< PORT APB Clock Enable
    }

    /// APBCMASK Register bits
    namespace apbcmask_bits {
        constexpr uint32_t EVSYS_ = (1U << 0);  ///< EVSYS APB Clock Enable
        constexpr uint32_t SERCOM0_ = (1U << 1);  ///< SERCOM0 APB Clock Enable
        constexpr uint32_t SERCOM1_ = (1U << 2);  ///< SERCOM1 APB Clock Enable
        constexpr uint32_t SERCOM2_ = (1U << 3);  ///< SERCOM2 APB Clock Enable
        constexpr uint32_t SERCOM3_ = (1U << 4);  ///< SERCOM3 APB Clock Enable
        constexpr uint32_t SERCOM4_ = (1U << 5);  ///< SERCOM4 APB Clock Enable
        constexpr uint32_t SERCOM5_ = (1U << 6);  ///< SERCOM5 APB Clock Enable
        constexpr uint32_t TCC0_ = (1U << 7);  ///< TCC0 APB Clock Enable
        constexpr uint32_t TC0_ = (1U << 8);  ///< TC0 APB Clock Enable
        constexpr uint32_t TC1_ = (1U << 9);  ///< TC1 APB Clock Enable
        constexpr uint32_t TC2_ = (1U << 10);  ///< TC2 APB Clock Enable
        constexpr uint32_t TC3_ = (1U << 11);  ///< TC3 APB Clock Enable
        constexpr uint32_t ADC_ = (1U << 12);  ///< ADC APB Clock Enable
        constexpr uint32_t AC_ = (1U << 13);  ///< AC APB Clock Enable
        constexpr uint32_t PTC_ = (1U << 14);  ///< PTC APB Clock Enable
        constexpr uint32_t SLCD_ = (1U << 15);  ///< SLCD APB Clock Enable
        constexpr uint32_t AES_ = (1U << 16);  ///< AES APB Clock Enable
        constexpr uint32_t TRNG_ = (1U << 17);  ///< TRNG APB Clock Enable
        constexpr uint32_t CCL_ = (1U << 18);  ///< CCL APB Clock Enable
    }

}

// ============================================================================
// MTB Peripheral
// ============================================================================

namespace mtb {
    /// Base addresses
    constexpr uint32_t MTB_BASE = 0x4100A000;

    /// MTB Register structure
    struct Registers {
        volatile uint32_t POSITION;  ///< Offset: 0x00 - MTB Position
        volatile uint32_t MASTER;  ///< Offset: 0x04 - MTB Master
        volatile uint32_t FLOW;  ///< Offset: 0x08 - MTB Flow
        volatile uint32_t BASE;  ///< Offset: 0x0C - MTB Base
        volatile uint32_t ITCTRL;  ///< Offset: 0xF00 - MTB Integration Mode Control
        volatile uint32_t CLAIMSET;  ///< Offset: 0xFA0 - MTB Claim Set
        volatile uint32_t CLAIMCLR;  ///< Offset: 0xFA4 - MTB Claim Clear
        volatile uint32_t LOCKACCESS;  ///< Offset: 0xFB0 - MTB Lock Access
        volatile uint32_t LOCKSTATUS;  ///< Offset: 0xFB4 - MTB Lock Status
        volatile uint32_t AUTHSTATUS;  ///< Offset: 0xFB8 - MTB Authentication Status
        volatile uint32_t DEVARCH;  ///< Offset: 0xFBC - MTB Device Architecture
        volatile uint32_t DEVID;  ///< Offset: 0xFC8 - MTB Device Configuration
        volatile uint32_t DEVTYPE;  ///< Offset: 0xFCC - MTB Device Type
        volatile uint32_t PID4;  ///< Offset: 0xFD0 - Peripheral Identification 4
        volatile uint32_t PID5;  ///< Offset: 0xFD4 - Peripheral Identification 5
        volatile uint32_t PID6;  ///< Offset: 0xFD8 - Peripheral Identification 6
        volatile uint32_t PID7;  ///< Offset: 0xFDC - Peripheral Identification 7
        volatile uint32_t PID0;  ///< Offset: 0xFE0 - Peripheral Identification 0
        volatile uint32_t PID1;  ///< Offset: 0xFE4 - Peripheral Identification 1
        volatile uint32_t PID2;  ///< Offset: 0xFE8 - Peripheral Identification 2
        volatile uint32_t PID3;  ///< Offset: 0xFEC - Peripheral Identification 3
        volatile uint32_t CID0;  ///< Offset: 0xFF0 - Component Identification 0
        volatile uint32_t CID1;  ///< Offset: 0xFF4 - Component Identification 1
        volatile uint32_t CID2;  ///< Offset: 0xFF8 - Component Identification 2
        volatile uint32_t CID3;  ///< Offset: 0xFFC - Component Identification 3
    };

    /// Peripheral instances
    inline Registers* MTB = reinterpret_cast<Registers*>(MTB_BASE);

    // Bit definitions
    /// POSITION Register bits
    namespace position_bits {
        constexpr uint32_t WRAP = (1U << 2);  ///< Pointer Value Wraps
        constexpr uint32_t POINTER = (29 << 3);  ///< Trace Packet Location Pointer
    }

    /// MASTER Register bits
    namespace master_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< Maximum Value of the Trace Buffer in SRAM
        constexpr uint32_t TSTARTEN = (1U << 5);  ///< Trace Start Input Enable
        constexpr uint32_t TSTOPEN = (1U << 6);  ///< Trace Stop Input Enable
        constexpr uint32_t SFRWPRIV = (1U << 7);  ///< Special Function Register Write Privilege
        constexpr uint32_t RAMPRIV = (1U << 8);  ///< SRAM Privilege
        constexpr uint32_t HALTREQ = (1U << 9);  ///< Halt Request
        constexpr uint32_t EN = (1U << 31);  ///< Main Trace Enable
    }

    /// FLOW Register bits
    namespace flow_bits {
        constexpr uint32_t AUTOSTOP = (1U << 0);  ///< Auto Stop Tracing
        constexpr uint32_t AUTOHALT = (1U << 1);  ///< Auto Halt Request
        constexpr uint32_t WATERMARK = (29 << 3);  ///< Watermark value
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t NVMCTRL_BASE = 0x41004000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x04 - Control B
        volatile uint32_t PARAM;  ///< Offset: 0x08 - NVM Parameter
        volatile uint32_t INTENCLR;  ///< Offset: 0x0C - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x10 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x14 - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x18 - Status
        volatile uint32_t ADDR;  ///< Offset: 0x1C - Address
        volatile uint32_t LOCK;  ///< Offset: 0x20 - Lock Section
    };

    /// Peripheral instances
    inline Registers* NVMCTRL = reinterpret_cast<Registers*>(NVMCTRL_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t CMD = (7 << 0);  ///< Command
        constexpr uint32_t CMDEX = (8 << 8);  ///< Command Execution
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t RWS = (4 << 1);  ///< NVM Read Wait States
        constexpr uint32_t MANW = (1U << 7);  ///< Manual Write
        constexpr uint32_t SLEEPPRM = (2 << 8);  ///< Power Reduction Mode during Sleep
        constexpr uint32_t FWUP = (1U << 11);  ///< fast wake-up
        constexpr uint32_t READMODE = (2 << 16);  ///< NVMCTRL Read Mode
        constexpr uint32_t CACHEDIS = (1U << 18);  ///< Cache Disable
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t NVMP = (16 << 0);  ///< NVM Pages
        constexpr uint32_t PSZ = (3 << 16);  ///< Page Size
        constexpr uint32_t RWWEEP = (12 << 20);  ///< RWW EEPROM Pages
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 0);  ///< NVM Ready Interrupt Enable
        constexpr uint32_t ERROR = (1U << 1);  ///< Error Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 0);  ///< NVM Ready Interrupt Enable
        constexpr uint32_t ERROR = (1U << 1);  ///< Error Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t READY = (1U << 0);  ///< NVM Ready
        constexpr uint32_t ERROR = (1U << 1);  ///< Error
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t PRM = (1U << 0);  ///< Power Reduction Mode
        constexpr uint32_t LOAD = (1U << 1);  ///< NVM Page Buffer Active Loading
        constexpr uint32_t PROGE = (1U << 2);  ///< Programming Error Status
        constexpr uint32_t LOCKE = (1U << 3);  ///< Lock Error Status
        constexpr uint32_t NVME = (1U << 4);  ///< NVM Error
        constexpr uint32_t SB = (1U << 8);  ///< Security Bit Status
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (22 << 0);  ///< NVM Address
    }

    /// LOCK Register bits
    namespace lock_bits {
        constexpr uint32_t LOCK = (16 << 0);  ///< Region Lock Bits
    }

}

// ============================================================================
// OSCCTRL Peripheral
// ============================================================================

namespace oscctrl {
    /// Base addresses
    constexpr uint32_t OSCCTRL_BASE = 0x40001000;

    /// OSCCTRL Register structure
    struct Registers {
        volatile uint32_t INTENCLR;  ///< Offset: 0x00 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x04 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x08 - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x0C - Power and Clocks Status
        volatile uint32_t XOSCCTRL;  ///< Offset: 0x10 - External Multipurpose Crystal Oscillator (XOSC) Control
        volatile uint32_t CFDPRESC;  ///< Offset: 0x12 - Cloc Failure Detector Prescaler
        volatile uint32_t EVCTRL;  ///< Offset: 0x13 - Event Control
        volatile uint32_t OSC16MCTRL;  ///< Offset: 0x14 - 16MHz Internal Oscillator (OSC16M) Control
        volatile uint32_t DFLLCTRL;  ///< Offset: 0x18 - DFLL48M Control
        volatile uint32_t DFLLVAL;  ///< Offset: 0x1C - DFLL48M Value
        volatile uint32_t DFLLMUL;  ///< Offset: 0x20 - DFLL48M Multiplier
        volatile uint32_t DFLLSYNC;  ///< Offset: 0x24 - DFLL48M Synchronization
        volatile uint32_t DPLLCTRLA;  ///< Offset: 0x28 - DPLL Control
        volatile uint32_t DPLLRATIO;  ///< Offset: 0x2C - DPLL Ratio Control
        volatile uint32_t DPLLCTRLB;  ///< Offset: 0x30 - Digital Core Configuration
        volatile uint32_t DPLLPRESC;  ///< Offset: 0x34 - DPLL Prescaler
        volatile uint32_t DPLLSYNCBUSY;  ///< Offset: 0x38 - DPLL Synchronization Busy
        volatile uint32_t DPLLSTATUS;  ///< Offset: 0x3C - DPLL Status
    };

    /// Peripheral instances
    inline Registers* OSCCTRL = reinterpret_cast<Registers*>(OSCCTRL_BASE);

    // Bit definitions
    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t XOSCRDY = (1U << 0);  ///< XOSC Ready Interrupt Enable
        constexpr uint32_t XOSCFAIL = (1U << 1);  ///< XOSC Clock Failure Detector Interrupt Enable
        constexpr uint32_t OSC16MRDY = (1U << 4);  ///< OSC16M Ready Interrupt Enable
        constexpr uint32_t DFLLRDY = (1U << 8);  ///< DFLL Ready Interrupt Enable
        constexpr uint32_t DFLLOOB = (1U << 9);  ///< DFLL Out Of Bounds Interrupt Enable
        constexpr uint32_t DFLLLCKF = (1U << 10);  ///< DFLL Lock Fine Interrupt Enable
        constexpr uint32_t DFLLLCKC = (1U << 11);  ///< DFLL Lock Coarse Interrupt Enable
        constexpr uint32_t DFLLRCS = (1U << 12);  ///< DFLL Reference Clock Stopped Interrupt Enable
        constexpr uint32_t DPLLLCKR = (1U << 16);  ///< DPLL Lock Rise Interrupt Enable
        constexpr uint32_t DPLLLCKF = (1U << 17);  ///< DPLL Lock Fall Interrupt Enable
        constexpr uint32_t DPLLLTO = (1U << 18);  ///< DPLL Time Out Interrupt Enable
        constexpr uint32_t DPLLLDRTO = (1U << 19);  ///< DPLL Ratio Ready Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t XOSCRDY = (1U << 0);  ///< XOSC Ready Interrupt Enable
        constexpr uint32_t XOSCFAIL = (1U << 1);  ///< XOSC Clock Failure Detector Interrupt Enable
        constexpr uint32_t OSC16MRDY = (1U << 4);  ///< OSC16M Ready Interrupt Enable
        constexpr uint32_t DFLLRDY = (1U << 8);  ///< DFLL Ready Interrupt Enable
        constexpr uint32_t DFLLOOB = (1U << 9);  ///< DFLL Out Of Bounds Interrupt Enable
        constexpr uint32_t DFLLLCKF = (1U << 10);  ///< DFLL Lock Fine Interrupt Enable
        constexpr uint32_t DFLLLCKC = (1U << 11);  ///< DFLL Lock Coarse Interrupt Enable
        constexpr uint32_t DFLLRCS = (1U << 12);  ///< DFLL Reference Clock Stopped Interrupt Enable
        constexpr uint32_t DPLLLCKR = (1U << 16);  ///< DPLL Lock Rise Interrupt Enable
        constexpr uint32_t DPLLLCKF = (1U << 17);  ///< DPLL Lock Fall Interrupt Enable
        constexpr uint32_t DPLLLTO = (1U << 18);  ///< DPLL Time Out Interrupt Enable
        constexpr uint32_t DPLLLDRTO = (1U << 19);  ///< DPLL Ratio Ready Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t XOSCRDY = (1U << 0);  ///< XOSC Ready
        constexpr uint32_t XOSCFAIL = (1U << 1);  ///< XOSC Clock Failure Detector
        constexpr uint32_t OSC16MRDY = (1U << 4);  ///< OSC16M Ready
        constexpr uint32_t DFLLRDY = (1U << 8);  ///< DFLL Ready
        constexpr uint32_t DFLLOOB = (1U << 9);  ///< DFLL Out Of Bounds
        constexpr uint32_t DFLLLCKF = (1U << 10);  ///< DFLL Lock Fine
        constexpr uint32_t DFLLLCKC = (1U << 11);  ///< DFLL Lock Coarse
        constexpr uint32_t DFLLRCS = (1U << 12);  ///< DFLL Reference Clock Stopped
        constexpr uint32_t DPLLLCKR = (1U << 16);  ///< DPLL Lock Rise
        constexpr uint32_t DPLLLCKF = (1U << 17);  ///< DPLL Lock Fall
        constexpr uint32_t DPLLLTO = (1U << 18);  ///< DPLL Timeout
        constexpr uint32_t DPLLLDRTO = (1U << 19);  ///< DPLL Ratio Ready
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t XOSCRDY = (1U << 0);  ///< XOSC Ready
        constexpr uint32_t XOSCFAIL = (1U << 1);  ///< XOSC Clock Failure Detector
        constexpr uint32_t XOSCCKSW = (1U << 2);  ///< XOSC Clock Switch
        constexpr uint32_t OSC16MRDY = (1U << 4);  ///< OSC16M Ready
        constexpr uint32_t DFLLRDY = (1U << 8);  ///< DFLL Ready
        constexpr uint32_t DFLLOOB = (1U << 9);  ///< DFLL Out Of Bounds
        constexpr uint32_t DFLLLCKF = (1U << 10);  ///< DFLL Lock Fine
        constexpr uint32_t DFLLLCKC = (1U << 11);  ///< DFLL Lock Coarse
        constexpr uint32_t DFLLRCS = (1U << 12);  ///< DFLL Reference Clock Stopped
        constexpr uint32_t DPLLLCKR = (1U << 16);  ///< DPLL Lock Rise
        constexpr uint32_t DPLLLCKF = (1U << 17);  ///< DPLL Lock Fall
        constexpr uint32_t DPLLTO = (1U << 18);  ///< DPLL Timeout
        constexpr uint32_t DPLLLDRTO = (1U << 19);  ///< DPLL Ratio Ready
    }

    /// XOSCCTRL Register bits
    namespace xoscctrl_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Oscillator Enable
        constexpr uint32_t XTALEN = (1U << 2);  ///< Crystal Oscillator Enable
        constexpr uint32_t CFDEN = (1U << 3);  ///< Xosc Clock Failure Detecteor Enable
        constexpr uint32_t SWBEN = (1U << 4);  ///< Xosc Clock Switch Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
        constexpr uint32_t GAIN = (3 << 8);  ///< Oscillator Gain
        constexpr uint32_t AMPGC = (1U << 11);  ///< Automatic Amplitude Gain Control
        constexpr uint32_t STARTUP = (4 << 12);  ///< Start-Up Time
    }

    /// CFDPRESC Register bits
    namespace cfdpresc_bits {
        constexpr uint32_t CFDPRESC = (3 << 0);  ///< Clock Failure Detector Prescaler
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t CFDEO = (1U << 0);  ///< Clock Failure Detector Event Output Enable
    }

    /// OSC16MCTRL Register bits
    namespace osc16mctrl_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Oscillator Enable
        constexpr uint32_t FSEL = (2 << 2);  ///< Oscillator Frequency Select
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
    }

    /// DFLLCTRL Register bits
    namespace dfllctrl_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< DFLL Enable
        constexpr uint32_t MODE = (1U << 2);  ///< Operating Mode Selection
        constexpr uint32_t STABLE = (1U << 3);  ///< Stable DFLL Frequency
        constexpr uint32_t LLAW = (1U << 4);  ///< Lose Lock After Wake
        constexpr uint32_t USBCRM = (1U << 5);  ///< USB Clock Recovery Mode
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
        constexpr uint32_t CCDIS = (1U << 8);  ///< Chill Cycle Disable
        constexpr uint32_t QLDIS = (1U << 9);  ///< Quick Lock Disable
        constexpr uint32_t BPLCKC = (1U << 10);  ///< Bypass Coarse Lock
        constexpr uint32_t WAITLOCK = (1U << 11);  ///< Wait Lock
    }

    /// DFLLVAL Register bits
    namespace dfllval_bits {
        constexpr uint32_t FINE = (10 << 0);  ///< Fine Value
        constexpr uint32_t COARSE = (6 << 10);  ///< Coarse Value
        constexpr uint32_t DIFF = (16 << 16);  ///< Multiplication Ratio Difference
    }

    /// DFLLMUL Register bits
    namespace dfllmul_bits {
        constexpr uint32_t MUL = (16 << 0);  ///< DFLL Multiply Factor
        constexpr uint32_t FSTEP = (10 << 16);  ///< Fine Maximum Step
        constexpr uint32_t CSTEP = (6 << 26);  ///< Coarse Maximum Step
    }

    /// DFLLSYNC Register bits
    namespace dfllsync_bits {
        constexpr uint32_t READREQ = (1U << 7);  ///< Read Request
    }

    /// DPLLCTRLA Register bits
    namespace dpllctrla_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand
    }

    /// DPLLRATIO Register bits
    namespace dpllratio_bits {
        constexpr uint32_t LDR = (12 << 0);  ///< Loop Divider Ratio
        constexpr uint32_t LDRFRAC = (4 << 16);  ///< Loop Divider Ratio Fractional Part
    }

    /// DPLLCTRLB Register bits
    namespace dpllctrlb_bits {
        constexpr uint32_t FILTER = (2 << 0);  ///< Proportional Integral Filter Selection
        constexpr uint32_t LPEN = (1U << 2);  ///< Low-Power Enable
        constexpr uint32_t WUF = (1U << 3);  ///< Wake Up Fast
        constexpr uint32_t REFCLK = (2 << 4);  ///< Reference Clock Selection
        constexpr uint32_t LTIME = (3 << 8);  ///< Lock Time
        constexpr uint32_t LBYPASS = (1U << 12);  ///< Lock Bypass
        constexpr uint32_t DIV = (11 << 16);  ///< Clock Divider
    }

    /// DPLLPRESC Register bits
    namespace dpllpresc_bits {
        constexpr uint32_t PRESC = (2 << 0);  ///< Output Clock Prescaler
    }

    /// DPLLSYNCBUSY Register bits
    namespace dpllsyncbusy_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< DPLL Enable Synchronization Status
        constexpr uint32_t DPLLRATIO = (1U << 2);  ///< DPLL Ratio Synchronization Status
        constexpr uint32_t DPLLPRESC = (1U << 3);  ///< DPLL Prescaler Synchronization Status
    }

    /// DPLLSTATUS Register bits
    namespace dpllstatus_bits {
        constexpr uint32_t LOCK = (1U << 0);  ///< DPLL Lock Status
        constexpr uint32_t CLKRDY = (1U << 1);  ///< DPLL Clock Ready
    }

}

// ============================================================================
// OSC32KCTRL Peripheral
// ============================================================================

namespace osc32kctrl {
    /// Base addresses
    constexpr uint32_t OSC32KCTRL_BASE = 0x40001400;

    /// OSC32KCTRL Register structure
    struct Registers {
        volatile uint32_t INTENCLR;  ///< Offset: 0x00 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x04 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x08 - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x0C - Power and Clocks Status
        volatile uint32_t RTCCTRL;  ///< Offset: 0x10 - RTC Clock Selection
        volatile uint32_t SLCDCTRL;  ///< Offset: 0x11 - SLCD Clock Selection
        volatile uint32_t XOSC32K;  ///< Offset: 0x14 - 32kHz External Crystal Oscillator (XOSC32K) Control
        volatile uint32_t CFDCTRL;  ///< Offset: 0x16 - Clock Failure Detector Control
        volatile uint32_t EVCTRL;  ///< Offset: 0x17 - Event Control
        volatile uint32_t OSCULP32K;  ///< Offset: 0x1C - 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control
    };

    /// Peripheral instances
    inline Registers* OSC32KCTRL = reinterpret_cast<Registers*>(OSC32KCTRL_BASE);

    // Bit definitions
    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t XOSC32KRDY = (1U << 0);  ///< XOSC32K Ready Interrupt Enable
        constexpr uint32_t CLKFAIL = (1U << 2);  ///< XOSC32K Clock Failure Detector Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t XOSC32KRDY = (1U << 0);  ///< XOSC32K Ready Interrupt Enable
        constexpr uint32_t CLKFAIL = (1U << 2);  ///< XOSC32K Clock Failure Detector Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t XOSC32KRDY = (1U << 0);  ///< XOSC32K Ready
        constexpr uint32_t CLKFAIL = (1U << 2);  ///< XOSC32K Clock Failure Detector
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t XOSC32KRDY = (1U << 0);  ///< XOSC32K Ready
        constexpr uint32_t CLKFAIL = (1U << 2);  ///< XOSC32K Clock Failure Detector
        constexpr uint32_t CLKSW = (1U << 3);  ///< XOSC32K Clock switch
    }

    /// RTCCTRL Register bits
    namespace rtcctrl_bits {
        constexpr uint32_t RTCSEL = (3 << 0);  ///< RTC Clock Selection
    }

    /// SLCDCTRL Register bits
    namespace slcdctrl_bits {
        constexpr uint32_t SLCDSEL = (1U << 0);  ///< SLCD Clock Selection
    }

    /// XOSC32K Register bits
    namespace xosc32k_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Oscillator Enable
        constexpr uint32_t XTALEN = (1U << 2);  ///< Crystal Oscillator Enable
        constexpr uint32_t EN32K = (1U << 3);  ///< 32kHz Output Enable
        constexpr uint32_t EN1K = (1U << 4);  ///< 1kHz Output Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Control
        constexpr uint32_t STARTUP = (3 << 8);  ///< Oscillator Start-Up Time
        constexpr uint32_t WRTLOCK = (1U << 12);  ///< Write Lock
    }

    /// CFDCTRL Register bits
    namespace cfdctrl_bits {
        constexpr uint32_t CFDEN = (1U << 0);  ///< Clock Failure Detector Enable
        constexpr uint32_t SWBACK = (1U << 1);  ///< Clock Switch Back
        constexpr uint32_t CFDPRESC = (1U << 2);  ///< Clock Failure Detector Prescaler
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t CFDEO = (1U << 0);  ///< Clock Failure Detector Event Output Enable
    }

    /// OSCULP32K Register bits
    namespace osculp32k_bits {
        constexpr uint32_t EN32K = (1U << 1);  ///< Enable Out 32k
        constexpr uint32_t EN1K = (1U << 2);  ///< Enable Out 1k
        constexpr uint32_t CALIB = (5 << 8);  ///< Oscillator Calibration
        constexpr uint32_t WRTLOCK = (1U << 15);  ///< Write Lock
    }

}

// ============================================================================
// PAC Peripheral
// ============================================================================

namespace pac {
    /// Base addresses
    constexpr uint32_t PAC_BASE = 0x40000000;

    /// PAC Register structure
    struct Registers {
        volatile uint32_t WRCTRL;  ///< Offset: 0x00 - Write control
        volatile uint32_t EVCTRL;  ///< Offset: 0x04 - Event control
        volatile uint32_t INTENCLR;  ///< Offset: 0x08 - Interrupt enable clear
        volatile uint32_t INTENSET;  ///< Offset: 0x09 - Interrupt enable set
        volatile uint32_t INTFLAGAHB;  ///< Offset: 0x10 - Bridge interrupt flag status
        volatile uint32_t INTFLAGA;  ///< Offset: 0x14 - Peripheral interrupt flag status - Bridge A
        volatile uint32_t INTFLAGB;  ///< Offset: 0x18 - Peripheral interrupt flag status - Bridge B
        volatile uint32_t INTFLAGC;  ///< Offset: 0x1C - Peripheral interrupt flag status - Bridge C
        volatile uint32_t STATUSA;  ///< Offset: 0x34 - Peripheral write protection status - Bridge A
        volatile uint32_t STATUSB;  ///< Offset: 0x38 - Peripheral write protection status - Bridge B
        volatile uint32_t STATUSC;  ///< Offset: 0x3C - Peripheral write protection status - Bridge C
    };

    /// Peripheral instances
    inline Registers* PAC = reinterpret_cast<Registers*>(PAC_BASE);

    // Bit definitions
    /// WRCTRL Register bits
    namespace wrctrl_bits {
        constexpr uint32_t PERID = (16 << 0);  ///< Peripheral identifier
        constexpr uint32_t KEY = (8 << 16);  ///< Peripheral access control key
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t ERREO = (1U << 0);  ///< Peripheral acess error event output
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t ERR = (1U << 0);  ///< Peripheral access error interrupt disable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t ERR = (1U << 0);  ///< Peripheral access error interrupt enable
    }

    /// INTFLAGAHB Register bits
    namespace intflagahb_bits {
        constexpr uint32_t FLASH_ = (1U << 0);  ///< FLASH
        constexpr uint32_t HSRAMCM0P_ = (1U << 1);  ///< HSRAMCM0P
        constexpr uint32_t HSRAMDSU_ = (1U << 2);  ///< HSRAMDSU
        constexpr uint32_t HPB1_ = (1U << 3);  ///< HPB1
        constexpr uint32_t HPB0_ = (1U << 4);  ///< HPB0
        constexpr uint32_t HPB2_ = (1U << 5);  ///< HPB2
        constexpr uint32_t HSRAMDMAC_ = (1U << 6);  ///< HSRAMDMAC
    }

    /// INTFLAGA Register bits
    namespace intflaga_bits {
        constexpr uint32_t PAC_ = (1U << 0);  ///< PAC
        constexpr uint32_t PM_ = (1U << 1);  ///< PM
        constexpr uint32_t MCLK_ = (1U << 2);  ///< MCLK
        constexpr uint32_t RSTC_ = (1U << 3);  ///< RSTC
        constexpr uint32_t OSCCTRL_ = (1U << 4);  ///< OSCCTRL
        constexpr uint32_t OSC32KCTRL_ = (1U << 5);  ///< OSC32KCTRL
        constexpr uint32_t SUPC_ = (1U << 6);  ///< SUPC
        constexpr uint32_t GCLK_ = (1U << 7);  ///< GCLK
        constexpr uint32_t WDT_ = (1U << 8);  ///< WDT
        constexpr uint32_t RTC_ = (1U << 9);  ///< RTC
        constexpr uint32_t EIC_ = (1U << 10);  ///< EIC
        constexpr uint32_t FREQM_ = (1U << 11);  ///< FREQM
    }

    /// INTFLAGB Register bits
    namespace intflagb_bits {
        constexpr uint32_t USB_ = (1U << 0);  ///< USB
        constexpr uint32_t DSU_ = (1U << 1);  ///< DSU
        constexpr uint32_t NVMCTRL_ = (1U << 2);  ///< NVMCTRL
        constexpr uint32_t PORT_ = (1U << 3);  ///< PORT
        constexpr uint32_t DMAC_ = (1U << 4);  ///< DMAC
        constexpr uint32_t MTB_ = (1U << 5);  ///< MTB
    }

    /// INTFLAGC Register bits
    namespace intflagc_bits {
        constexpr uint32_t EVSYS_ = (1U << 0);  ///< EVSYS
        constexpr uint32_t SERCOM0_ = (1U << 1);  ///< SERCOM0
        constexpr uint32_t SERCOM1_ = (1U << 2);  ///< SERCOM1
        constexpr uint32_t SERCOM2_ = (1U << 3);  ///< SERCOM2
        constexpr uint32_t SERCOM3_ = (1U << 4);  ///< SERCOM3
        constexpr uint32_t SERCOM4_ = (1U << 5);  ///< SERCOM4
        constexpr uint32_t SERCOM5_ = (1U << 6);  ///< SERCOM5
        constexpr uint32_t TCC0_ = (1U << 7);  ///< TCC0
        constexpr uint32_t TC0_ = (1U << 8);  ///< TC0
        constexpr uint32_t TC1_ = (1U << 9);  ///< TC1
        constexpr uint32_t TC2_ = (1U << 10);  ///< TC2
        constexpr uint32_t TC3_ = (1U << 11);  ///< TC3
        constexpr uint32_t ADC_ = (1U << 12);  ///< ADC
        constexpr uint32_t AC_ = (1U << 13);  ///< AC
        constexpr uint32_t PTC_ = (1U << 14);  ///< PTC
        constexpr uint32_t SLCD_ = (1U << 15);  ///< SLCD
        constexpr uint32_t AES_ = (1U << 16);  ///< AES
        constexpr uint32_t TRNG_ = (1U << 17);  ///< TRNG
        constexpr uint32_t CCL_ = (1U << 18);  ///< CCL
    }

    /// STATUSA Register bits
    namespace statusa_bits {
        constexpr uint32_t PAC_ = (1U << 0);  ///< PAC APB Protect Enable
        constexpr uint32_t PM_ = (1U << 1);  ///< PM APB Protect Enable
        constexpr uint32_t MCLK_ = (1U << 2);  ///< MCLK APB Protect Enable
        constexpr uint32_t RSTC_ = (1U << 3);  ///< RSTC APB Protect Enable
        constexpr uint32_t OSCCTRL_ = (1U << 4);  ///< OSCCTRL APB Protect Enable
        constexpr uint32_t OSC32KCTRL_ = (1U << 5);  ///< OSC32KCTRL APB Protect Enable
        constexpr uint32_t SUPC_ = (1U << 6);  ///< SUPC APB Protect Enable
        constexpr uint32_t GCLK_ = (1U << 7);  ///< GCLK APB Protect Enable
        constexpr uint32_t WDT_ = (1U << 8);  ///< WDT APB Protect Enable
        constexpr uint32_t RTC_ = (1U << 9);  ///< RTC APB Protect Enable
        constexpr uint32_t EIC_ = (1U << 10);  ///< EIC APB Protect Enable
        constexpr uint32_t FREQM_ = (1U << 11);  ///< FREQM APB Protect Enable
    }

    /// STATUSB Register bits
    namespace statusb_bits {
        constexpr uint32_t USB_ = (1U << 0);  ///< USB APB Protect Enable
        constexpr uint32_t DSU_ = (1U << 1);  ///< DSU APB Protect Enable
        constexpr uint32_t NVMCTRL_ = (1U << 2);  ///< NVMCTRL APB Protect Enable
        constexpr uint32_t PORT_ = (1U << 3);  ///< PORT APB Protect Enable
        constexpr uint32_t DMAC_ = (1U << 4);  ///< DMAC APB Protect Enable
        constexpr uint32_t MTB_ = (1U << 5);  ///< MTB APB Protect Enable
    }

    /// STATUSC Register bits
    namespace statusc_bits {
        constexpr uint32_t EVSYS_ = (1U << 0);  ///< EVSYS APB Protect Enable
        constexpr uint32_t SERCOM0_ = (1U << 1);  ///< SERCOM0 APB Protect Enable
        constexpr uint32_t SERCOM1_ = (1U << 2);  ///< SERCOM1 APB Protect Enable
        constexpr uint32_t SERCOM2_ = (1U << 3);  ///< SERCOM2 APB Protect Enable
        constexpr uint32_t SERCOM3_ = (1U << 4);  ///< SERCOM3 APB Protect Enable
        constexpr uint32_t SERCOM4_ = (1U << 5);  ///< SERCOM4 APB Protect Enable
        constexpr uint32_t SERCOM5_ = (1U << 6);  ///< SERCOM5 APB Protect Enable
        constexpr uint32_t TCC0_ = (1U << 7);  ///< TCC0 APB Protect Enable
        constexpr uint32_t TC0_ = (1U << 8);  ///< TC0 APB Protect Enable
        constexpr uint32_t TC1_ = (1U << 9);  ///< TC1 APB Protect Enable
        constexpr uint32_t TC2_ = (1U << 10);  ///< TC2 APB Protect Enable
        constexpr uint32_t TC3_ = (1U << 11);  ///< TC3 APB Protect Enable
        constexpr uint32_t ADC_ = (1U << 12);  ///< ADC APB Protect Enable
        constexpr uint32_t AC_ = (1U << 13);  ///< AC APB Protect Enable
        constexpr uint32_t PTC_ = (1U << 14);  ///< PTC APB Protect Enable
        constexpr uint32_t SLCD_ = (1U << 15);  ///< SLCD APB Protect Enable
        constexpr uint32_t AES_ = (1U << 16);  ///< AES APB Protect Enable
        constexpr uint32_t TRNG_ = (1U << 17);  ///< TRNG APB Protect Enable
        constexpr uint32_t CCL_ = (1U << 18);  ///< CCL APB Protect Enable
    }

}

// ============================================================================
// PM Peripheral
// ============================================================================

namespace pm {
    /// Base addresses
    constexpr uint32_t PM_BASE = 0x40000400;

    /// PM Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t SLEEPCFG;  ///< Offset: 0x01 - Sleep Configuration
        volatile uint32_t PLCFG;  ///< Offset: 0x02 - Performance Level Configuration
        volatile uint32_t INTENCLR;  ///< Offset: 0x04 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x05 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x06 - Interrupt Flag Status and Clear
        volatile uint32_t STDBYCFG;  ///< Offset: 0x08 - Standby Configuration
    };

    /// Peripheral instances
    inline Registers* PM = reinterpret_cast<Registers*>(PM_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t IORET = (1U << 2);  ///< I/O Retention
    }

    /// SLEEPCFG Register bits
    namespace sleepcfg_bits {
        constexpr uint32_t SLEEPMODE = (3 << 0);  ///< Sleep Mode
    }

    /// PLCFG Register bits
    namespace plcfg_bits {
        constexpr uint32_t PLSEL = (2 << 0);  ///< Performance Level Select
        constexpr uint32_t PLDIS = (1U << 7);  ///< Performance Level Disable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t PLRDY = (1U << 0);  ///< Performance Level Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t PLRDY = (1U << 0);  ///< Performance Level Ready interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t PLRDY = (1U << 0);  ///< Performance Level Ready
    }

    /// STDBYCFG Register bits
    namespace stdbycfg_bits {
        constexpr uint32_t VREGSMOD = (2 << 6);  ///< Voltage Regulator Standby mode
        constexpr uint32_t BBIASHS = (2 << 10);  ///< Back Bias for HMCRAMCHS
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT_BASE = 0x41006000;
    constexpr uint32_t PORT_IOBUS_BASE = 0x60000000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t DIR%s;  ///< Offset: 0x00 - Data Direction
        volatile uint32_t DIRCLR%s;  ///< Offset: 0x04 - Data Direction Clear
        volatile uint32_t DIRSET%s;  ///< Offset: 0x08 - Data Direction Set
        volatile uint32_t DIRTGL%s;  ///< Offset: 0x0C - Data Direction Toggle
        volatile uint32_t OUT%s;  ///< Offset: 0x10 - Data Output Value
        volatile uint32_t OUTCLR%s;  ///< Offset: 0x14 - Data Output Value Clear
        volatile uint32_t OUTSET%s;  ///< Offset: 0x18 - Data Output Value Set
        volatile uint32_t OUTTGL%s;  ///< Offset: 0x1C - Data Output Value Toggle
        volatile uint32_t IN%s;  ///< Offset: 0x20 - Data Input Value
        volatile uint32_t CTRL%s;  ///< Offset: 0x24 - Control
        volatile uint32_t WRCONFIG%s;  ///< Offset: 0x28 - Write Configuration
        volatile uint32_t EVCTRL%s;  ///< Offset: 0x2C - Event Input Control
        volatile uint32_t PMUX0_%s;  ///< Offset: 0x30 - Peripheral Multiplexing n - Group 0
        volatile uint32_t PMUX1_%s;  ///< Offset: 0xB0 - Peripheral Multiplexing n - Group 1
        volatile uint32_t PMUX2_%s;  ///< Offset: 0x130 - Peripheral Multiplexing n - Group 2
        volatile uint32_t PINCFG0_%s;  ///< Offset: 0x40 - Pin Configuration n - Group 0
        volatile uint32_t PINCFG1_%s;  ///< Offset: 0xC0 - Pin Configuration n - Group 1
        volatile uint32_t PINCFG2_%s;  ///< Offset: 0x140 - Pin Configuration n - Group 2
    };

    /// Peripheral instances
    inline Registers* PORT = reinterpret_cast<Registers*>(PORT_BASE);
    inline Registers* PORT_IOBUS = reinterpret_cast<Registers*>(PORT_IOBUS_BASE);

    // Bit definitions
    /// CTRL%s Register bits
    namespace ctrl%s_bits {
        constexpr uint32_t SAMPLING = (32 << 0);  ///< Input Sampling Mode
    }

    /// WRCONFIG%s Register bits
    namespace wrconfig%s_bits {
        constexpr uint32_t PINMASK = (16 << 0);  ///< Pin Mask for Multiple Pin Configuration
        constexpr uint32_t PMUXEN = (1U << 16);  ///< Select Peripheral Multiplexer
        constexpr uint32_t INEN = (1U << 17);  ///< Input Enable
        constexpr uint32_t PULLEN = (1U << 18);  ///< Pull Enable
        constexpr uint32_t DRVSTR = (1U << 22);  ///< Output Driver Strength Selection
        constexpr uint32_t PMUX = (4 << 24);  ///< Peripheral Multiplexing Template
        constexpr uint32_t WRPMUX = (1U << 28);  ///< Write PMUX Registers
        constexpr uint32_t WRPINCFG = (1U << 30);  ///< Write PINCFG Registers
        constexpr uint32_t HWSEL = (1U << 31);  ///< Half-Word Select
    }

    /// EVCTRL%s Register bits
    namespace evctrl%s_bits {
        constexpr uint32_t PID0 = (5 << 0);  ///< Port Event Pin Identifier 0
        constexpr uint32_t EVACT0 = (2 << 5);  ///< Port Event Action 0
        constexpr uint32_t PORTEI0 = (1U << 7);  ///< Port Event Enable Input 0
        constexpr uint32_t PID1 = (5 << 8);  ///< Port Event Pin Identifier 1
        constexpr uint32_t EVACT1 = (2 << 13);  ///< Port Event Action 1
        constexpr uint32_t PORTEI1 = (1U << 15);  ///< Port Event Enable Input 1
        constexpr uint32_t PID2 = (5 << 16);  ///< Port Event Pin Identifier 2
        constexpr uint32_t EVACT2 = (2 << 21);  ///< Port Event Action 2
        constexpr uint32_t PORTEI2 = (1U << 23);  ///< Port Event Enable Input 2
        constexpr uint32_t PID3 = (5 << 24);  ///< Port Event Pin Identifier 3
        constexpr uint32_t EVACT3 = (2 << 29);  ///< Port Event Action 3
        constexpr uint32_t PORTEI3 = (1U << 31);  ///< Port Event Enable Input 3
    }

    /// PMUX0_%s Register bits
    namespace pmux0_%s_bits {
        constexpr uint32_t PMUXE = (4 << 0);  ///< Peripheral Multiplexing for Even-Numbered Pin
        constexpr uint32_t PMUXO = (4 << 4);  ///< Peripheral Multiplexing for Odd-Numbered Pin
    }

    /// PINCFG0_%s Register bits
    namespace pincfg0_%s_bits {
        constexpr uint32_t PMUXEN = (1U << 0);  ///< Select Peripheral Multiplexer
        constexpr uint32_t INEN = (1U << 1);  ///< Input Enable
        constexpr uint32_t PULLEN = (1U << 2);  ///< Pull Enable
        constexpr uint32_t DRVSTR = (1U << 6);  ///< Output Driver Strength Selection
    }

}

// ============================================================================
// RSTC Peripheral
// ============================================================================

namespace rstc {
    /// Base addresses
    constexpr uint32_t RSTC_BASE = 0x40000C00;

    /// RSTC Register structure
    struct Registers {
        volatile uint32_t RCAUSE;  ///< Offset: 0x00 - Reset Cause
        volatile uint32_t BKUPEXIT;  ///< Offset: 0x02 - Backup Exit Source
    };

    /// Peripheral instances
    inline Registers* RSTC = reinterpret_cast<Registers*>(RSTC_BASE);

    // Bit definitions
    /// RCAUSE Register bits
    namespace rcause_bits {
        constexpr uint32_t POR = (1U << 0);  ///< Power On Reset
        constexpr uint32_t BODCORE = (1U << 1);  ///< Brown Out CORE Detector Reset
        constexpr uint32_t BODVDD = (1U << 2);  ///< Brown Out VDD Detector Reset
        constexpr uint32_t EXT = (1U << 4);  ///< External Reset
        constexpr uint32_t WDT = (1U << 5);  ///< Watchdog Reset
        constexpr uint32_t SYST = (1U << 6);  ///< System Reset Request
        constexpr uint32_t BACKUP = (1U << 7);  ///< Backup Reset
    }

    /// BKUPEXIT Register bits
    namespace bkupexit_bits {
        constexpr uint32_t RTC = (1U << 1);  ///< Real Timer Counter Interrupt
        constexpr uint32_t BBPS = (1U << 2);  ///< Battery Backup Power Switch
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002400;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - MODE2 Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x02 - MODE2 Control B
        volatile uint32_t EVCTRL;  ///< Offset: 0x04 - MODE2 Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x08 - MODE2 Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x0A - MODE2 Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x0C - MODE2 Interrupt Flag Status and Clear
        volatile uint32_t DBGCTRL;  ///< Offset: 0x0E - Debug Control
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x10 - MODE2 Synchronization Busy Status
        volatile uint32_t FREQCORR;  ///< Offset: 0x14 - Frequency Correction
        volatile uint32_t COUNT;  ///< Offset: 0x18 - MODE1 Counter Value
        volatile uint32_t COMP%s;  ///< Offset: 0x20 - MODE1 Compare n Value
        volatile uint32_t GP%s;  ///< Offset: 0x40 - General Purpose
        volatile uint32_t TAMPCTRL;  ///< Offset: 0x60 - Tamper Control
        volatile uint32_t TIMESTAMP;  ///< Offset: 0x64 - MODE2 Timestamp
        volatile uint32_t TAMPID;  ///< Offset: 0x68 - Tamper ID
        volatile uint32_t BKUP%s;  ///< Offset: 0x80 - Backup
        volatile uint32_t PER;  ///< Offset: 0x1C - MODE1 Counter Period
        volatile uint32_t CLOCK;  ///< Offset: 0x18 - MODE2 Clock Value
        volatile uint32_t ALARM%s;  ///< Offset: 0x20 - MODE2 Alarm n Value
        volatile uint32_t MASK%s;  ///< Offset: 0x24 - MODE2 Alarm n Mask
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t MODE = (2 << 2);  ///< Operating Mode
        constexpr uint32_t CLKREP = (1U << 6);  ///< Clock Representation
        constexpr uint32_t MATCHCLR = (1U << 7);  ///< Clear on Match
        constexpr uint32_t PRESCALER = (4 << 8);  ///< Prescaler
        constexpr uint32_t BKTRST = (1U << 13);  ///< BKUP Registers Reset On Tamper Enable
        constexpr uint32_t GPTRST = (1U << 14);  ///< GP Registers Reset On Tamper Enable
        constexpr uint32_t CLOCKSYNC = (1U << 15);  ///< Clock Read Synchronization Enable
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t GP0EN = (1U << 0);  ///< General Purpose 0 Enable
        constexpr uint32_t DEBMAJ = (1U << 4);  ///< Debouncer Majority Enable
        constexpr uint32_t DEBASYNC = (1U << 5);  ///< Debouncer Asynchronous Enable
        constexpr uint32_t RTCOUT = (1U << 6);  ///< RTC Output Enable
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA Enable
        constexpr uint32_t DEBF = (3 << 8);  ///< Debounce Freqnuency
        constexpr uint32_t ACTF = (3 << 12);  ///< Active Layer Freqnuency
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t PEREO0 = (1U << 0);  ///< Periodic Interval 0 Event Output Enable
        constexpr uint32_t PEREO1 = (1U << 1);  ///< Periodic Interval 1 Event Output Enable
        constexpr uint32_t PEREO2 = (1U << 2);  ///< Periodic Interval 2 Event Output Enable
        constexpr uint32_t PEREO3 = (1U << 3);  ///< Periodic Interval 3 Event Output Enable
        constexpr uint32_t PEREO4 = (1U << 4);  ///< Periodic Interval 4 Event Output Enable
        constexpr uint32_t PEREO5 = (1U << 5);  ///< Periodic Interval 5 Event Output Enable
        constexpr uint32_t PEREO6 = (1U << 6);  ///< Periodic Interval 6 Event Output Enable
        constexpr uint32_t PEREO7 = (1U << 7);  ///< Periodic Interval 7 Event Output Enable
        constexpr uint32_t ALARMEO0 = (1U << 8);  ///< Alarm 0 Event Output Enable
        constexpr uint32_t TAMPEREO = (1U << 14);  ///< Tamper Event Output Enable
        constexpr uint32_t OVFEO = (1U << 15);  ///< Overflow Event Output Enable
        constexpr uint32_t TAMPEVEI = (1U << 16);  ///< Tamper Event Input Enable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t PER0 = (1U << 0);  ///< Periodic Interval 0 Interrupt Enable
        constexpr uint32_t PER1 = (1U << 1);  ///< Periodic Interval 1 Interrupt Enable
        constexpr uint32_t PER2 = (1U << 2);  ///< Periodic Interval 2 Interrupt Enable
        constexpr uint32_t PER3 = (1U << 3);  ///< Periodic Interval 3 Interrupt Enable
        constexpr uint32_t PER4 = (1U << 4);  ///< Periodic Interval 4 Interrupt Enable
        constexpr uint32_t PER5 = (1U << 5);  ///< Periodic Interval 5 Interrupt Enable
        constexpr uint32_t PER6 = (1U << 6);  ///< Periodic Interval 6 Interrupt Enable
        constexpr uint32_t PER7 = (1U << 7);  ///< Periodic Interval 7 Interrupt Enable
        constexpr uint32_t ALARM0 = (1U << 8);  ///< Alarm 0 Interrupt Enable
        constexpr uint32_t TAMPER = (1U << 14);  ///< Tamper Enable
        constexpr uint32_t OVF = (1U << 15);  ///< Overflow Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t PER0 = (1U << 0);  ///< Periodic Interval 0 Enable
        constexpr uint32_t PER1 = (1U << 1);  ///< Periodic Interval 1 Enable
        constexpr uint32_t PER2 = (1U << 2);  ///< Periodic Interval 2 Enable
        constexpr uint32_t PER3 = (1U << 3);  ///< Periodic Interval 3 Enable
        constexpr uint32_t PER4 = (1U << 4);  ///< Periodic Interval 4 Enable
        constexpr uint32_t PER5 = (1U << 5);  ///< Periodic Interval 5 Enable
        constexpr uint32_t PER6 = (1U << 6);  ///< Periodic Interval 6 Enable
        constexpr uint32_t PER7 = (1U << 7);  ///< Periodic Interval 7 Enable
        constexpr uint32_t ALARM0 = (1U << 8);  ///< Alarm 0 Interrupt Enable
        constexpr uint32_t TAMPER = (1U << 14);  ///< Tamper Enable
        constexpr uint32_t OVF = (1U << 15);  ///< Overflow Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t PER0 = (1U << 0);  ///< Periodic Interval 0
        constexpr uint32_t PER1 = (1U << 1);  ///< Periodic Interval 1
        constexpr uint32_t PER2 = (1U << 2);  ///< Periodic Interval 2
        constexpr uint32_t PER3 = (1U << 3);  ///< Periodic Interval 3
        constexpr uint32_t PER4 = (1U << 4);  ///< Periodic Interval 4
        constexpr uint32_t PER5 = (1U << 5);  ///< Periodic Interval 5
        constexpr uint32_t PER6 = (1U << 6);  ///< Periodic Interval 6
        constexpr uint32_t PER7 = (1U << 7);  ///< Periodic Interval 7
        constexpr uint32_t ALARM0 = (1U << 8);  ///< Alarm 0
        constexpr uint32_t TAMPER = (1U << 14);  ///< Tamper
        constexpr uint32_t OVF = (1U << 15);  ///< Overflow
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Run During Debug
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Bit Busy
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable Bit Busy
        constexpr uint32_t FREQCORR = (1U << 2);  ///< FREQCORR Register Busy
        constexpr uint32_t CLOCK = (1U << 3);  ///< CLOCK Register Busy
        constexpr uint32_t ALARM0 = (1U << 5);  ///< ALARM 0 Register Busy
        constexpr uint32_t MASK0 = (1U << 11);  ///< MASK 0 Register Busy
        constexpr uint32_t CLOCKSYNC = (1U << 15);  ///< Clock Synchronization Enable Bit Busy
        constexpr uint32_t GP0 = (1U << 16);  ///< General Purpose 0 Register Busy
        constexpr uint32_t GP1 = (1U << 17);  ///< General Purpose 1 Register Busy
    }

    /// FREQCORR Register bits
    namespace freqcorr_bits {
        constexpr uint32_t VALUE = (7 << 0);  ///< Correction Value
        constexpr uint32_t SIGN = (1U << 7);  ///< Correction Sign
    }

    /// COUNT Register bits
    namespace count_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// COMP%s Register bits
    namespace comp%s_bits {
        constexpr uint32_t COMP = (16 << 0);  ///< Compare Value
    }

    /// GP%s Register bits
    namespace gp%s_bits {
        constexpr uint32_t GP = (32 << 0);  ///< General Purpose
    }

    /// TAMPCTRL Register bits
    namespace tampctrl_bits {
        constexpr uint32_t IN0ACT = (2 << 0);  ///< Tamper Input 0 Action
        constexpr uint32_t IN1ACT = (2 << 2);  ///< Tamper Input 1 Action
        constexpr uint32_t IN2ACT = (2 << 4);  ///< Tamper Input 2 Action
        constexpr uint32_t IN3ACT = (2 << 6);  ///< Tamper Input 3 Action
        constexpr uint32_t IN4ACT = (2 << 8);  ///< Tamper Input 4 Action
        constexpr uint32_t TAMLVL0 = (1U << 16);  ///< Tamper Level Select 0
        constexpr uint32_t TAMLVL1 = (1U << 17);  ///< Tamper Level Select 1
        constexpr uint32_t TAMLVL2 = (1U << 18);  ///< Tamper Level Select 2
        constexpr uint32_t TAMLVL3 = (1U << 19);  ///< Tamper Level Select 3
        constexpr uint32_t TAMLVL4 = (1U << 20);  ///< Tamper Level Select 4
        constexpr uint32_t DEBNC0 = (1U << 24);  ///< Debouncer Enable 0
        constexpr uint32_t DEBNC1 = (1U << 25);  ///< Debouncer Enable 1
        constexpr uint32_t DEBNC2 = (1U << 26);  ///< Debouncer Enable 2
        constexpr uint32_t DEBNC3 = (1U << 27);  ///< Debouncer Enable 3
        constexpr uint32_t DEBNC4 = (1U << 28);  ///< Debouncer Enable 4
    }

    /// TIMESTAMP Register bits
    namespace timestamp_bits {
        constexpr uint32_t SECOND = (6 << 0);  ///< Second Timestamp Value
        constexpr uint32_t MINUTE = (6 << 6);  ///< Minute Timestamp Value
        constexpr uint32_t HOUR = (5 << 12);  ///< Hour Timestamp Value
        constexpr uint32_t DAY = (5 << 17);  ///< Day Timestamp Value
        constexpr uint32_t MONTH = (4 << 22);  ///< Month Timestamp Value
        constexpr uint32_t YEAR = (6 << 26);  ///< Year Timestamp Value
    }

    /// TAMPID Register bits
    namespace tampid_bits {
        constexpr uint32_t TAMPID0 = (1U << 0);  ///< Tamper Input 0 Detected
        constexpr uint32_t TAMPID1 = (1U << 1);  ///< Tamper Input 1 Detected
        constexpr uint32_t TAMPID2 = (1U << 2);  ///< Tamper Input 2 Detected
        constexpr uint32_t TAMPID3 = (1U << 3);  ///< Tamper Input 3 Detected
        constexpr uint32_t TAMPID4 = (1U << 4);  ///< Tamper Input 4 Detected
        constexpr uint32_t TAMPEVT = (1U << 31);  ///< Tamper Event Detected
    }

    /// BKUP%s Register bits
    namespace bkup%s_bits {
        constexpr uint32_t BKUP = (32 << 0);  ///< Backup
    }

    /// PER Register bits
    namespace per_bits {
        constexpr uint32_t PER = (16 << 0);  ///< Counter Period
    }

    /// CLOCK Register bits
    namespace clock_bits {
        constexpr uint32_t SECOND = (6 << 0);  ///< Second
        constexpr uint32_t MINUTE = (6 << 6);  ///< Minute
        constexpr uint32_t HOUR = (5 << 12);  ///< Hour
        constexpr uint32_t DAY = (5 << 17);  ///< Day
        constexpr uint32_t MONTH = (4 << 22);  ///< Month
        constexpr uint32_t YEAR = (6 << 26);  ///< Year
    }

    /// ALARM%s Register bits
    namespace alarm%s_bits {
        constexpr uint32_t SECOND = (6 << 0);  ///< Second
        constexpr uint32_t MINUTE = (6 << 6);  ///< Minute
        constexpr uint32_t HOUR = (5 << 12);  ///< Hour
        constexpr uint32_t DAY = (5 << 17);  ///< Day
        constexpr uint32_t MONTH = (4 << 22);  ///< Month
        constexpr uint32_t YEAR = (6 << 26);  ///< Year
    }

    /// MASK%s Register bits
    namespace mask%s_bits {
        constexpr uint32_t SEL = (3 << 0);  ///< Alarm Mask Selection
    }

}

// ============================================================================
// SERCOM Peripheral
// ============================================================================

namespace sercom {
    /// Base addresses
    constexpr uint32_t SERCOM0_BASE = 0x42000400;
    constexpr uint32_t SERCOM1_BASE = 0x42000800;
    constexpr uint32_t SERCOM2_BASE = 0x42000C00;
    constexpr uint32_t SERCOM3_BASE = 0x42001000;
    constexpr uint32_t SERCOM4_BASE = 0x42001400;
    constexpr uint32_t SERCOM5_BASE = 0x42001800;

    /// SERCOM Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - USART Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x04 - USART Control B
        volatile uint32_t BAUD;  ///< Offset: 0x0C - USART Baud Rate
        volatile uint32_t INTENCLR;  ///< Offset: 0x14 - USART Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x16 - USART Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x18 - USART Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x1A - USART Status
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x1C - USART Synchronization Busy
        volatile uint32_t ADDR;  ///< Offset: 0x24 - SPI Address
        volatile uint32_t DATA;  ///< Offset: 0x28 - USART Data
        volatile uint32_t DBGCTRL;  ///< Offset: 0x30 - USART Debug Control
        volatile uint32_t CTRLC;  ///< Offset: 0x08 - USART Control C
        volatile uint32_t BAUD_FRAC_MODE;  ///< Offset: 0x0C - USART Baud Rate
        volatile uint32_t BAUD_FRACFP_MODE;  ///< Offset: 0x0C - USART Baud Rate
        volatile uint32_t BAUD_USARTFP_MODE;  ///< Offset: 0x0C - USART Baud Rate
        volatile uint32_t RXPL;  ///< Offset: 0x0E - USART Receive Pulse Length
        volatile uint32_t RXERRCNT;  ///< Offset: 0x20 - USART Receive Error Count
    };

    /// Peripheral instances
    inline Registers* SERCOM0 = reinterpret_cast<Registers*>(SERCOM0_BASE);
    inline Registers* SERCOM1 = reinterpret_cast<Registers*>(SERCOM1_BASE);
    inline Registers* SERCOM2 = reinterpret_cast<Registers*>(SERCOM2_BASE);
    inline Registers* SERCOM3 = reinterpret_cast<Registers*>(SERCOM3_BASE);
    inline Registers* SERCOM4 = reinterpret_cast<Registers*>(SERCOM4_BASE);
    inline Registers* SERCOM5 = reinterpret_cast<Registers*>(SERCOM5_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t MODE = (3 << 2);  ///< Operating Mode
        constexpr uint32_t RUNSTDBY = (1U << 7);  ///< Run during Standby
        constexpr uint32_t IBON = (1U << 8);  ///< Immediate Buffer Overflow Notification
        constexpr uint32_t TXINV = (1U << 9);  ///< Transmit Data Invert
        constexpr uint32_t RXINV = (1U << 10);  ///< Receive Data Invert
        constexpr uint32_t SAMPR = (3 << 13);  ///< Sample
        constexpr uint32_t TXPO = (2 << 16);  ///< Transmit Data Pinout
        constexpr uint32_t RXPO = (2 << 20);  ///< Receive Data Pinout
        constexpr uint32_t SAMPA = (2 << 22);  ///< Sample Adjustment
        constexpr uint32_t FORM = (4 << 24);  ///< Frame Format
        constexpr uint32_t CMODE = (1U << 28);  ///< Communication Mode
        constexpr uint32_t CPOL = (1U << 29);  ///< Clock Polarity
        constexpr uint32_t DORD = (1U << 30);  ///< Data Order
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t CHSIZE = (3 << 0);  ///< Character Size
        constexpr uint32_t SBMODE = (1U << 6);  ///< Stop Bit Mode
        constexpr uint32_t COLDEN = (1U << 8);  ///< Collision Detection Enable
        constexpr uint32_t SFDE = (1U << 9);  ///< Start of Frame Detection Enable
        constexpr uint32_t ENC = (1U << 10);  ///< Encoding Format
        constexpr uint32_t PMODE = (1U << 13);  ///< Parity Mode
        constexpr uint32_t TXEN = (1U << 16);  ///< Transmitter Enable
        constexpr uint32_t RXEN = (1U << 17);  ///< Receiver Enable
    }

    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t BAUD = (16 << 0);  ///< Baud Rate Value
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t DRE = (1U << 0);  ///< Data Register Empty Interrupt Disable
        constexpr uint32_t TXC = (1U << 1);  ///< Transmit Complete Interrupt Disable
        constexpr uint32_t RXC = (1U << 2);  ///< Receive Complete Interrupt Disable
        constexpr uint32_t RXS = (1U << 3);  ///< Receive Start Interrupt Disable
        constexpr uint32_t CTSIC = (1U << 4);  ///< Clear To Send Input Change Interrupt Disable
        constexpr uint32_t RXBRK = (1U << 5);  ///< Break Received Interrupt Disable
        constexpr uint32_t ERROR = (1U << 7);  ///< Combined Error Interrupt Disable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t DRE = (1U << 0);  ///< Data Register Empty Interrupt Enable
        constexpr uint32_t TXC = (1U << 1);  ///< Transmit Complete Interrupt Enable
        constexpr uint32_t RXC = (1U << 2);  ///< Receive Complete Interrupt Enable
        constexpr uint32_t RXS = (1U << 3);  ///< Receive Start Interrupt Enable
        constexpr uint32_t CTSIC = (1U << 4);  ///< Clear To Send Input Change Interrupt Enable
        constexpr uint32_t RXBRK = (1U << 5);  ///< Break Received Interrupt Enable
        constexpr uint32_t ERROR = (1U << 7);  ///< Combined Error Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t DRE = (1U << 0);  ///< Data Register Empty Interrupt
        constexpr uint32_t TXC = (1U << 1);  ///< Transmit Complete Interrupt
        constexpr uint32_t RXC = (1U << 2);  ///< Receive Complete Interrupt
        constexpr uint32_t RXS = (1U << 3);  ///< Receive Start Interrupt
        constexpr uint32_t CTSIC = (1U << 4);  ///< Clear To Send Input Change Interrupt
        constexpr uint32_t RXBRK = (1U << 5);  ///< Break Received Interrupt
        constexpr uint32_t ERROR = (1U << 7);  ///< Combined Error Interrupt
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t PERR = (1U << 0);  ///< Parity Error
        constexpr uint32_t FERR = (1U << 1);  ///< Frame Error
        constexpr uint32_t BUFOVF = (1U << 2);  ///< Buffer Overflow
        constexpr uint32_t CTS = (1U << 3);  ///< Clear To Send
        constexpr uint32_t ISF = (1U << 4);  ///< Inconsistent Sync Field
        constexpr uint32_t COLL = (1U << 5);  ///< Collision Detected
        constexpr uint32_t TXE = (1U << 6);  ///< Transmitter Empty
        constexpr uint32_t ITER = (1U << 7);  ///< Maximum Number of Repetitions Reached
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchronization Busy
        constexpr uint32_t ENABLE = (1U << 1);  ///< SERCOM Enable Synchronization Busy
        constexpr uint32_t CTRLB = (1U << 2);  ///< CTRLB Synchronization Busy
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (8 << 0);  ///< Address Value
        constexpr uint32_t ADDRMASK = (8 << 16);  ///< Address Mask
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (9 << 0);  ///< Data Value
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGSTOP = (1U << 0);  ///< Debug Mode
    }

    /// CTRLC Register bits
    namespace ctrlc_bits {
        constexpr uint32_t GTIME = (3 << 0);  ///< Guard Time
        constexpr uint32_t INACK = (1U << 16);  ///< Inhibit Not Acknowledge
        constexpr uint32_t DSNACK = (1U << 17);  ///< Disable Successive NACK
        constexpr uint32_t MAXITER = (3 << 20);  ///< Maximum Iterations
    }

    /// BAUD_FRAC_MODE Register bits
    namespace baud_frac_mode_bits {
        constexpr uint32_t BAUD = (13 << 0);  ///< Baud Rate Value
        constexpr uint32_t FP = (3 << 13);  ///< Fractional Part
    }

    /// BAUD_FRACFP_MODE Register bits
    namespace baud_fracfp_mode_bits {
        constexpr uint32_t BAUD = (13 << 0);  ///< Baud Rate Value
        constexpr uint32_t FP = (3 << 13);  ///< Fractional Part
    }

    /// BAUD_USARTFP_MODE Register bits
    namespace baud_usartfp_mode_bits {
        constexpr uint32_t BAUD = (16 << 0);  ///< Baud Rate Value
    }

    /// RXPL Register bits
    namespace rxpl_bits {
        constexpr uint32_t RXPL = (8 << 0);  ///< Receive Pulse Length
    }

}

// ============================================================================
// SLCD Peripheral
// ============================================================================

namespace slcd {
    /// Base addresses
    constexpr uint32_t SLCD_BASE = 0x42003C00;

    /// SLCD Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLB;  ///< Offset: 0x04 - Control B
        volatile uint32_t CTRLC;  ///< Offset: 0x06 - Control C
        volatile uint32_t CTRLD;  ///< Offset: 0x08 - Control D
        volatile uint32_t EVCTRL;  ///< Offset: 0x0C - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x0D - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x0E - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x0F - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x10 - Status
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x14 - Synchronization Busy
        volatile uint32_t FC0;  ///< Offset: 0x18 - Frame Counter 0 Configuration
        volatile uint32_t FC1;  ///< Offset: 0x19 - Frame Counter 1 Configuration
        volatile uint32_t FC2;  ///< Offset: 0x1A - Frame Counter 2 Configuration
        volatile uint32_t LPENL;  ///< Offset: 0x1C - LCD Pin Enable Low
        volatile uint32_t LPENH;  ///< Offset: 0x20 - LCD Pin Enable High
        volatile uint32_t SDATAL0;  ///< Offset: 0x24 - Segments Data Low for COM0 Line
        volatile uint32_t SDATAH0;  ///< Offset: 0x28 - Segments Data High for COM0 Line
        volatile uint32_t SDATAL1;  ///< Offset: 0x2C - Segments Data Low for COM1 Line
        volatile uint32_t SDATAH1;  ///< Offset: 0x30 - Segments Data High for COM1 Line
        volatile uint32_t SDATAL2;  ///< Offset: 0x34 - Segments Data Low for COM2 Line
        volatile uint32_t SDATAH2;  ///< Offset: 0x38 - Segments Data High for COM2 Line
        volatile uint32_t SDATAL3;  ///< Offset: 0x3C - Segments Data Low for COM3 Line
        volatile uint32_t SDATAH3;  ///< Offset: 0x40 - Segments Data High for COM3 Line
        volatile uint32_t SDATAL4;  ///< Offset: 0x44 - Segments Data Low for COM4 Line
        volatile uint32_t SDATAH4;  ///< Offset: 0x48 - Segments Data High for COM4 Line
        volatile uint32_t SDATAL5;  ///< Offset: 0x4C - Segments Data Low for COM5 Line
        volatile uint32_t SDATAH5;  ///< Offset: 0x50 - Segments Data High for COM5 Line
        volatile uint32_t SDATAL6;  ///< Offset: 0x54 - Segments Data Low for COM6 Line
        volatile uint32_t SDATAH6;  ///< Offset: 0x58 - Segments Data High for COM6 Line
        volatile uint32_t SDATAL7;  ///< Offset: 0x5C - Segments Data Low for COM7 Line
        volatile uint32_t SDATAH7;  ///< Offset: 0x60 - Segments Data High for COM7 Line
        volatile uint32_t ISDATA;  ///< Offset: 0x64 - Indirect Segments Data Access
        volatile uint32_t BCFG;  ///< Offset: 0x68 - Blink Configuration
        volatile uint32_t CSRCFG;  ///< Offset: 0x6C - Circular Shift Register Configuration
        volatile uint32_t CMCFG;  ///< Offset: 0x70 - Character Mapping Configuration
        volatile uint32_t ACMCFG;  ///< Offset: 0x74 - Automated Character Mapping Configuration
        volatile uint32_t ABMCFG;  ///< Offset: 0x78 - Automated Bit Mapping Configuration
        volatile uint32_t CMDATA;  ///< Offset: 0x7C - Character Mapping Segments Data
        volatile uint32_t CMDMASK;  ///< Offset: 0x80 - Character Mapping Segments Data Mask
        volatile uint32_t CMINDEX;  ///< Offset: 0x84 - Character Mapping SEG/COM Index
    };

    /// Peripheral instances
    inline Registers* SLCD = reinterpret_cast<Registers*>(SLCD_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t DUTY = (3 << 2);  ///< Duty Ratio
        constexpr uint32_t WMOD = (1U << 5);  ///< Waveform Mode
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
        constexpr uint32_t PRESC = (2 << 8);  ///< Clock Prescaler
        constexpr uint32_t CKDIV = (3 << 12);  ///< Clock Divider
        constexpr uint32_t BIAS = (2 << 16);  ///< Bias Setting
        constexpr uint32_t XVLCD = (1U << 19);  ///< External VLCD
        constexpr uint32_t PRF = (2 << 20);  ///< Power Refresh Frequency
        constexpr uint32_t DMFCS = (2 << 22);  ///< Display Memory Update Frame Counter Selection
        constexpr uint32_t RRF = (3 << 24);  ///< Reference Refresh Frequency
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t BBD = (4 << 0);  ///< Bias Buffer Enable Duration
        constexpr uint32_t BBEN = (1U << 7);  ///< Bias Buffer Enable
        constexpr uint32_t LRD = (4 << 8);  ///< Low Resistance Enable Duration
        constexpr uint32_t LREN = (1U << 15);  ///< Low Resistance Enable
    }

    /// CTRLC Register bits
    namespace ctrlc_bits {
        constexpr uint32_t CLEAR = (1U << 0);  ///< Clear Display Memory
        constexpr uint32_t LOCK = (1U << 1);  ///< Lock Shadow Memory
        constexpr uint32_t ABMEN = (1U << 2);  ///< Automated Bit Mapping Enable
        constexpr uint32_t ACMEN = (1U << 3);  ///< Automated Character Mapping Enable
        constexpr uint32_t CTST = (4 << 4);  ///< Contrast Adjustment
        constexpr uint32_t LPPM = (2 << 8);  ///< LCD Power Macro Power mode
    }

    /// CTRLD Register bits
    namespace ctrld_bits {
        constexpr uint32_t BLANK = (1U << 0);  ///< Blank LCD
        constexpr uint32_t BLINK = (1U << 1);  ///< Blinking Enable
        constexpr uint32_t CSREN = (1U << 2);  ///< Circular Shift Register Enable
        constexpr uint32_t FC0EN = (1U << 4);  ///< Frame Counter 0 Enable
        constexpr uint32_t FC1EN = (1U << 5);  ///< Frame Counter 1 Enable
        constexpr uint32_t FC2EN = (1U << 6);  ///< Frame Counter 2 Enable
        constexpr uint32_t DISPEN = (1U << 7);  ///< Display enable
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t FC0OEO = (1U << 0);  ///< Frame Counter 0 Overflow Event Output Enable
        constexpr uint32_t FC1OEO = (1U << 1);  ///< Frame Counter 1 Overflow Event Output Enable
        constexpr uint32_t FC2OEO = (1U << 2);  ///< Frame Counter 2 Overflow Event Output Enable
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t FC0O = (1U << 0);  ///< Frame Counter 0 Overflow Interrupt Disable
        constexpr uint32_t FC1O = (1U << 1);  ///< Frame Counter 1 Overflow Interrupt Disable
        constexpr uint32_t FC2O = (1U << 2);  ///< Frame Counter 2 Overflow Interrupt Disable
        constexpr uint32_t VLCDRT = (1U << 3);  ///< VLCD Ready Toggle Interrupt Disable
        constexpr uint32_t VLCDST = (1U << 4);  ///< VLCD Status Toggle Interrupt Disable
        constexpr uint32_t PRST = (1U << 5);  ///< Pump Run Status Toggle Interrupt Disable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t FC0O = (1U << 0);  ///< Frame Counter 0 Overflow Interrupt Enable
        constexpr uint32_t FC1O = (1U << 1);  ///< Frame Counter 1 Overflow Interrupt Enable
        constexpr uint32_t FC2O = (1U << 2);  ///< Frame Counter 2 Overflow Interrupt Enable
        constexpr uint32_t VLCDRT = (1U << 3);  ///< VLCD Ready Toggle Interrupt Enable
        constexpr uint32_t VLCDST = (1U << 4);  ///< VLCD Status Toggle Interrupt Enable
        constexpr uint32_t PRST = (1U << 5);  ///< Pump Run Status Toggle Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t FC0O = (1U << 0);  ///< Frame Counter 0 Overflow
        constexpr uint32_t FC1O = (1U << 1);  ///< Frame Counter 1 Overflow
        constexpr uint32_t FC2O = (1U << 2);  ///< Frame Counter 2 Overflow
        constexpr uint32_t VLCDRT = (1U << 3);  ///< VLCD Ready Toggle
        constexpr uint32_t VLCDST = (1U << 4);  ///< VLCD Status Toggle
        constexpr uint32_t PRST = (1U << 5);  ///< Pump Run Status Toggle
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t VLCDR = (1U << 0);  ///< VLCD Ready
        constexpr uint32_t PRUN = (1U << 1);  ///< LCD Charge Pump is Running
        constexpr uint32_t VLCDS = (1U << 2);  ///< VLCD Status
        constexpr uint32_t CMWRBUSY = (1U << 3);  ///< Character mapping write busy
        constexpr uint32_t ACMBUSY = (1U << 4);  ///< ACM state machine busy
        constexpr uint32_t ABMBUSY = (1U << 5);  ///< ABM state machine busy
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t CTRLD = (1U << 2);  ///< Control D
    }

    /// FC0 Register bits
    namespace fc0_bits {
        constexpr uint32_t OVF = (5 << 0);  ///< Frame Counter Overflow Value
        constexpr uint32_t PB = (1U << 7);  ///< Prescaler Bypass
    }

    /// FC1 Register bits
    namespace fc1_bits {
        constexpr uint32_t OVF = (5 << 0);  ///< Frame Counter Overflow Value
        constexpr uint32_t PB = (1U << 7);  ///< Prescaler Bypass
    }

    /// FC2 Register bits
    namespace fc2_bits {
        constexpr uint32_t OVF = (5 << 0);  ///< Frame Counter Overflow Value
        constexpr uint32_t PB = (1U << 7);  ///< Prescaler Bypass
    }

    /// LPENL Register bits
    namespace lpenl_bits {
        constexpr uint32_t LPEN = (32 << 0);  ///< LCD Pin Enable
    }

    /// LPENH Register bits
    namespace lpenh_bits {
        constexpr uint32_t LPEN = (20 << 0);  ///< LCD Pin Enable
    }

    /// SDATAL0 Register bits
    namespace sdatal0_bits {
        constexpr uint32_t SDATA = (32 << 0);  ///< Segments Data
    }

    /// SDATAH0 Register bits
    namespace sdatah0_bits {
        constexpr uint32_t SDATA = (12 << 0);  ///< Segments Data
    }

    /// SDATAL1 Register bits
    namespace sdatal1_bits {
        constexpr uint32_t SDATA = (32 << 0);  ///< Segments Data
    }

    /// SDATAH1 Register bits
    namespace sdatah1_bits {
        constexpr uint32_t SDATA = (12 << 0);  ///< Segments Data
    }

    /// SDATAL2 Register bits
    namespace sdatal2_bits {
        constexpr uint32_t SDATA = (32 << 0);  ///< Segments Data
    }

    /// SDATAH2 Register bits
    namespace sdatah2_bits {
        constexpr uint32_t SDATA = (12 << 0);  ///< Segments Data
    }

    /// SDATAL3 Register bits
    namespace sdatal3_bits {
        constexpr uint32_t SDATA = (32 << 0);  ///< Segments Data
    }

    /// SDATAH3 Register bits
    namespace sdatah3_bits {
        constexpr uint32_t SDATA = (12 << 0);  ///< Segments Data
    }

    /// SDATAL4 Register bits
    namespace sdatal4_bits {
        constexpr uint32_t SDATA = (32 << 0);  ///< Segments Data
    }

    /// SDATAH4 Register bits
    namespace sdatah4_bits {
        constexpr uint32_t SDATA = (10 << 0);  ///< Segments Data
    }

    /// SDATAL5 Register bits
    namespace sdatal5_bits {
        constexpr uint32_t SDATA = (32 << 0);  ///< Segments Data
    }

    /// SDATAH5 Register bits
    namespace sdatah5_bits {
        constexpr uint32_t SDATA = (10 << 0);  ///< Segments Data
    }

    /// SDATAL6 Register bits
    namespace sdatal6_bits {
        constexpr uint32_t SDATA = (32 << 0);  ///< Segments Data
    }

    /// SDATAH6 Register bits
    namespace sdatah6_bits {
        constexpr uint32_t SDATA = (8 << 0);  ///< Segments Data
    }

    /// SDATAL7 Register bits
    namespace sdatal7_bits {
        constexpr uint32_t SDATA = (32 << 0);  ///< Segments Data
    }

    /// SDATAH7 Register bits
    namespace sdatah7_bits {
        constexpr uint32_t SDATA = (8 << 0);  ///< Segments Data
    }

    /// ISDATA Register bits
    namespace isdata_bits {
        constexpr uint32_t SDATA = (8 << 0);  ///< Segments Data
        constexpr uint32_t SDMASK = (8 << 8);  ///< Segments Data Mask
        constexpr uint32_t OFF = (6 << 16);  ///< Byte Offset
    }

    /// BCFG Register bits
    namespace bcfg_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< Blinking Mode
        constexpr uint32_t FCS = (2 << 1);  ///< Frame Counter Selection
        constexpr uint32_t BSS0 = (8 << 8);  ///< Blink Segment Selection 0
        constexpr uint32_t BSS1 = (8 << 16);  ///< Blink Segment Selection 1
    }

    /// CSRCFG Register bits
    namespace csrcfg_bits {
        constexpr uint32_t DIR = (1U << 0);  ///< Direction
        constexpr uint32_t FCS = (2 << 1);  ///< Frame Counter Selection
        constexpr uint32_t SIZE = (4 << 4);  ///< Circular Shift Register Size
        constexpr uint32_t DATA = (16 << 8);  ///< Circular Shift Register Value
    }

    /// CMCFG Register bits
    namespace cmcfg_bits {
        constexpr uint32_t NSEG = (3 << 0);  ///< Number of SEG lines
        constexpr uint32_t DEC = (1U << 3);  ///< Decrement SEG Line Index
    }

    /// ACMCFG Register bits
    namespace acmcfg_bits {
        constexpr uint32_t NCOM = (3 << 0);  ///< COM Lines per Row
        constexpr uint32_t NDIG = (4 << 4);  ///< Number of Digit
        constexpr uint32_t STEPS = (8 << 8);  ///< Scrolling Steps
        constexpr uint32_t NDROW = (6 << 16);  ///< Number of Digit per Row
        constexpr uint32_t MODE = (1U << 23);  ///< Mode
        constexpr uint32_t STSEG = (6 << 24);  ///< Start SEG Line
        constexpr uint32_t FCS = (2 << 30);  ///< Frame Counter Selection
    }

    /// ABMCFG Register bits
    namespace abmcfg_bits {
        constexpr uint32_t FCS = (2 << 0);  ///< Frame Counter Selection
        constexpr uint32_t SIZE = (6 << 2);  ///< Size
    }

    /// CMDATA Register bits
    namespace cmdata_bits {
        constexpr uint32_t SDATA = (24 << 0);  ///< Segments Data
    }

    /// CMDMASK Register bits
    namespace cmdmask_bits {
        constexpr uint32_t SDMASK = (24 << 0);  ///< Segments Data Mask
    }

    /// CMINDEX Register bits
    namespace cmindex_bits {
        constexpr uint32_t SINDEX = (6 << 0);  ///< SEG Line Index
        constexpr uint32_t CINDEX = (3 << 8);  ///< COM Line Index
    }

}

// ============================================================================
// SUPC Peripheral
// ============================================================================

namespace supc {
    /// Base addresses
    constexpr uint32_t SUPC_BASE = 0x40001800;

    /// SUPC Register structure
    struct Registers {
        volatile uint32_t INTENCLR;  ///< Offset: 0x00 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x04 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x08 - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x0C - Power and Clocks Status
        volatile uint32_t BOD33;  ///< Offset: 0x10 - BOD33 Control
        volatile uint32_t BOD12;  ///< Offset: 0x14 - BOD12 Control
        volatile uint32_t VREG;  ///< Offset: 0x18 - VREG Control
        volatile uint32_t VREF;  ///< Offset: 0x1C - VREF Control
        volatile uint32_t BBPS;  ///< Offset: 0x20 - Battery Backup Power Switch
        volatile uint32_t BKOUT;  ///< Offset: 0x24 - Backup Output Control
        volatile uint32_t BKIN;  ///< Offset: 0x28 - Backup Input Control
    };

    /// Peripheral instances
    inline Registers* SUPC = reinterpret_cast<Registers*>(SUPC_BASE);

    // Bit definitions
    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t BOD33RDY = (1U << 0);  ///< BOD33 Ready
        constexpr uint32_t BOD33DET = (1U << 1);  ///< BOD33 Detection
        constexpr uint32_t B33SRDY = (1U << 2);  ///< BOD33 Synchronization Ready
        constexpr uint32_t BOD12RDY = (1U << 3);  ///< BOD12 Ready
        constexpr uint32_t BOD12DET = (1U << 4);  ///< BOD12 Detection
        constexpr uint32_t B12SRDY = (1U << 5);  ///< BOD12 Synchronization Ready
        constexpr uint32_t VREGRDY = (1U << 8);  ///< Voltage Regulator Ready
        constexpr uint32_t APWSRDY = (1U << 9);  ///< Automatic Power Switch Ready
        constexpr uint32_t VCORERDY = (1U << 10);  ///< VDDCORE Ready
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t BOD33RDY = (1U << 0);  ///< BOD33 Ready
        constexpr uint32_t BOD33DET = (1U << 1);  ///< BOD33 Detection
        constexpr uint32_t B33SRDY = (1U << 2);  ///< BOD33 Synchronization Ready
        constexpr uint32_t BOD12RDY = (1U << 3);  ///< BOD12 Ready
        constexpr uint32_t BOD12DET = (1U << 4);  ///< BOD12 Detection
        constexpr uint32_t B12SRDY = (1U << 5);  ///< BOD12 Synchronization Ready
        constexpr uint32_t VREGRDY = (1U << 8);  ///< Voltage Regulator Ready
        constexpr uint32_t APWSRDY = (1U << 9);  ///< Automatic Power Switch Ready
        constexpr uint32_t VCORERDY = (1U << 10);  ///< VDDCORE Ready
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t BOD33RDY = (1U << 0);  ///< BOD33 Ready
        constexpr uint32_t BOD33DET = (1U << 1);  ///< BOD33 Detection
        constexpr uint32_t B33SRDY = (1U << 2);  ///< BOD33 Synchronization Ready
        constexpr uint32_t BOD12RDY = (1U << 3);  ///< BOD12 Ready
        constexpr uint32_t BOD12DET = (1U << 4);  ///< BOD12 Detection
        constexpr uint32_t B12SRDY = (1U << 5);  ///< BOD12 Synchronization Ready
        constexpr uint32_t VREGRDY = (1U << 8);  ///< Voltage Regulator Ready
        constexpr uint32_t APWSRDY = (1U << 9);  ///< Automatic Power Switch Ready
        constexpr uint32_t VCORERDY = (1U << 10);  ///< VDDCORE Ready
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t BOD33RDY = (1U << 0);  ///< BOD33 Ready
        constexpr uint32_t BOD33DET = (1U << 1);  ///< BOD33 Detection
        constexpr uint32_t B33SRDY = (1U << 2);  ///< BOD33 Synchronization Ready
        constexpr uint32_t BOD12RDY = (1U << 3);  ///< BOD12 Ready
        constexpr uint32_t BOD12DET = (1U << 4);  ///< BOD12 Detection
        constexpr uint32_t B12SRDY = (1U << 5);  ///< BOD12 Synchronization Ready
        constexpr uint32_t VREGRDY = (1U << 8);  ///< Voltage Regulator Ready
        constexpr uint32_t APWSRDY = (1U << 9);  ///< Automatic Power Switch Ready
        constexpr uint32_t VCORERDY = (1U << 10);  ///< VDDCORE Ready
        constexpr uint32_t BBPS = (1U << 11);  ///< Battery Backup Power Switch
    }

    /// BOD33 Register bits
    namespace bod33_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t HYST = (1U << 2);  ///< Hysteresis Enable
        constexpr uint32_t ACTION = (2 << 3);  ///< Action when Threshold Crossed
        constexpr uint32_t STDBYCFG = (1U << 5);  ///< Configuration in Standby mode
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run during Standby
        constexpr uint32_t RUNBKUP = (1U << 7);  ///< Configuration in Backup mode
        constexpr uint32_t ACTCFG = (1U << 8);  ///< Configuration in Active mode
        constexpr uint32_t VMON = (1U << 10);  ///< Voltage Monitored in active and standby mode
        constexpr uint32_t PSEL = (4 << 12);  ///< Prescaler Select
        constexpr uint32_t LEVEL = (6 << 16);  ///< Threshold Level for VDD
        constexpr uint32_t BKUPLEVEL = (6 << 24);  ///< Threshold Level in backup sleep mode or for VBAT
    }

    /// BOD12 Register bits
    namespace bod12_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t HYST = (1U << 2);  ///< Hysteresis Enable
        constexpr uint32_t ACTION = (2 << 3);  ///< Action when Threshold Crossed
        constexpr uint32_t STDBYCFG = (1U << 5);  ///< Configuration in Standby mode
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run during Standby
        constexpr uint32_t ACTCFG = (1U << 8);  ///< Configuration in Active mode
        constexpr uint32_t PSEL = (4 << 12);  ///< Prescaler Select
        constexpr uint32_t LEVEL = (6 << 16);  ///< Threshold Level
    }

    /// VREG Register bits
    namespace vreg_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t SEL = (2 << 2);  ///< Voltage Regulator Selection in active mode
        constexpr uint32_t STDBYPL0 = (1U << 5);  ///< Standby in PL0
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run during Standby
        constexpr uint32_t LPEFF = (1U << 8);  ///< Low Power efficiency
        constexpr uint32_t VSVSTEP = (4 << 16);  ///< Voltage Scaling Voltage Step
        constexpr uint32_t VSPER = (8 << 24);  ///< Voltage Scaling Period
    }

    /// VREF Register bits
    namespace vref_bits {
        constexpr uint32_t TSEN = (1U << 1);  ///< Temperature Sensor Output Enable
        constexpr uint32_t VREFOE = (1U << 2);  ///< Voltage Reference Output Enable
        constexpr uint32_t TSSEL = (1U << 3);  ///< Temperature Sensor Selection
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run during Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< On Demand Contrl
        constexpr uint32_t SEL = (4 << 16);  ///< Voltage Reference Selection
    }

    /// BBPS Register bits
    namespace bbps_bits {
        constexpr uint32_t CONF = (2 << 0);  ///< Battery Backup Configuration
        constexpr uint32_t WAKEEN = (1U << 2);  ///< Wake Enable
        constexpr uint32_t PSOKEN = (1U << 3);  ///< Power Supply OK Enable
    }

    /// BKOUT Register bits
    namespace bkout_bits {
        constexpr uint32_t EN = (2 << 0);  ///< Enable Output
        constexpr uint32_t CLR = (2 << 8);  ///< Clear Output
        constexpr uint32_t SET = (2 << 16);  ///< Set Output
        constexpr uint32_t RTCTGL = (2 << 24);  ///< RTC Toggle Output
    }

    /// BKIN Register bits
    namespace bkin_bits {
        constexpr uint32_t BKIN = (8 << 0);  ///< Backup Input Value
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TC0_BASE = 0x42002000;
    constexpr uint32_t TC1_BASE = 0x42002400;
    constexpr uint32_t TC2_BASE = 0x42002800;
    constexpr uint32_t TC3_BASE = 0x42002C00;
    constexpr uint32_t TCC0_BASE = 0x42001C00;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t CTRLBCLR;  ///< Offset: 0x04 - Control B Clear
        volatile uint32_t CTRLBSET;  ///< Offset: 0x05 - Control B Set
        volatile uint32_t EVCTRL;  ///< Offset: 0x06 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x08 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x09 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x0A - Interrupt Flag Status and Clear
        volatile uint32_t STATUS;  ///< Offset: 0x0B - Status
        volatile uint32_t WAVE;  ///< Offset: 0x0C - Waveform Generation Control
        volatile uint32_t DRVCTRL;  ///< Offset: 0x0D - Control C
        volatile uint32_t DBGCTRL;  ///< Offset: 0x0F - Debug Control
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x10 - Synchronization Status
        volatile uint32_t COUNT;  ///< Offset: 0x14 - COUNT32 Count
        volatile uint32_t PER;  ///< Offset: 0x1B - COUNT8 Period
        volatile uint32_t CC%s;  ///< Offset: 0x1C - COUNT32 Compare and Capture
        volatile uint32_t PERBUF;  ///< Offset: 0x2F - COUNT8 Period Buffer
        volatile uint32_t CCBUF%s;  ///< Offset: 0x30 - COUNT32 Compare and Capture Buffer
    };

    /// Peripheral instances
    inline Registers* TC0 = reinterpret_cast<Registers*>(TC0_BASE);
    inline Registers* TC1 = reinterpret_cast<Registers*>(TC1_BASE);
    inline Registers* TC2 = reinterpret_cast<Registers*>(TC2_BASE);
    inline Registers* TC3 = reinterpret_cast<Registers*>(TC3_BASE);
    inline Registers* TCC0 = reinterpret_cast<Registers*>(TCC0_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t MODE = (2 << 2);  ///< Timer Counter Mode
        constexpr uint32_t PRESCSYNC = (2 << 4);  ///< Prescaler and Counter Synchronization
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run during Standby
        constexpr uint32_t ONDEMAND = (1U << 7);  ///< Clock On Demand
        constexpr uint32_t PRESCALER = (3 << 8);  ///< Prescaler
        constexpr uint32_t ALOCK = (1U << 11);  ///< Auto Lock
        constexpr uint32_t CAPTEN0 = (1U << 16);  ///< Capture Channel 0 Enable
        constexpr uint32_t CAPTEN1 = (1U << 17);  ///< Capture Channel 1 Enable
        constexpr uint32_t COPEN0 = (1U << 20);  ///< Capture On Pin 0 Enable
        constexpr uint32_t COPEN1 = (1U << 21);  ///< Capture On Pin 1 Enable
    }

    /// CTRLBCLR Register bits
    namespace ctrlbclr_bits {
        constexpr uint32_t DIR = (1U << 0);  ///< Counter Direction
        constexpr uint32_t LUPD = (1U << 1);  ///< Lock Update
        constexpr uint32_t ONESHOT = (1U << 2);  ///< One-Shot on Counter
        constexpr uint32_t CMD = (3 << 5);  ///< Command
    }

    /// CTRLBSET Register bits
    namespace ctrlbset_bits {
        constexpr uint32_t DIR = (1U << 0);  ///< Counter Direction
        constexpr uint32_t LUPD = (1U << 1);  ///< Lock Update
        constexpr uint32_t ONESHOT = (1U << 2);  ///< One-Shot on Counter
        constexpr uint32_t CMD = (3 << 5);  ///< Command
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t EVACT = (3 << 0);  ///< Event Action
        constexpr uint32_t TCINV = (1U << 4);  ///< TC Event Input Polarity
        constexpr uint32_t TCEI = (1U << 5);  ///< TC Event Enable
        constexpr uint32_t OVFEO = (1U << 8);  ///< Event Output Enable
        constexpr uint32_t MCEO0 = (1U << 12);  ///< MC Event Output Enable 0
        constexpr uint32_t MCEO1 = (1U << 13);  ///< MC Event Output Enable 1
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t OVF = (1U << 0);  ///< OVF Interrupt Disable
        constexpr uint32_t ERR = (1U << 1);  ///< ERR Interrupt Disable
        constexpr uint32_t MC0 = (1U << 4);  ///< MC Interrupt Disable 0
        constexpr uint32_t MC1 = (1U << 5);  ///< MC Interrupt Disable 1
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t OVF = (1U << 0);  ///< OVF Interrupt Enable
        constexpr uint32_t ERR = (1U << 1);  ///< ERR Interrupt Enable
        constexpr uint32_t MC0 = (1U << 4);  ///< MC Interrupt Enable 0
        constexpr uint32_t MC1 = (1U << 5);  ///< MC Interrupt Enable 1
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t OVF = (1U << 0);  ///< OVF Interrupt Flag
        constexpr uint32_t ERR = (1U << 1);  ///< ERR Interrupt Flag
        constexpr uint32_t MC0 = (1U << 4);  ///< MC Interrupt Flag 0
        constexpr uint32_t MC1 = (1U << 5);  ///< MC Interrupt Flag 1
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STOP = (1U << 0);  ///< Stop Status Flag
        constexpr uint32_t SLAVE = (1U << 1);  ///< Slave Status Flag
        constexpr uint32_t PERBUFV = (1U << 3);  ///< Synchronization Busy Status
        constexpr uint32_t CCBUFV0 = (1U << 4);  ///< Compare channel buffer 0 valid
        constexpr uint32_t CCBUFV1 = (1U << 5);  ///< Compare channel buffer 1 valid
    }

    /// WAVE Register bits
    namespace wave_bits {
        constexpr uint32_t WAVEGEN = (2 << 0);  ///< Waveform Generation Mode
    }

    /// DRVCTRL Register bits
    namespace drvctrl_bits {
        constexpr uint32_t INVEN0 = (1U << 0);  ///< Output Waveform Invert Enable 0
        constexpr uint32_t INVEN1 = (1U << 1);  ///< Output Waveform Invert Enable 1
    }

    /// DBGCTRL Register bits
    namespace dbgctrl_bits {
        constexpr uint32_t DBGRUN = (1U << 0);  ///< Run During Debug
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< swrst
        constexpr uint32_t ENABLE = (1U << 1);  ///< enable
        constexpr uint32_t CTRLB = (1U << 2);  ///< CTRLB
        constexpr uint32_t STATUS = (1U << 3);  ///< STATUS
        constexpr uint32_t COUNT = (1U << 4);  ///< Counter
        constexpr uint32_t PER = (1U << 5);  ///< Period
        constexpr uint32_t CC0 = (1U << 6);  ///< Compare Channel 0
        constexpr uint32_t CC1 = (1U << 7);  ///< Compare Channel 1
    }

    /// COUNT Register bits
    namespace count_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< Counter Value
    }

    /// PER Register bits
    namespace per_bits {
        constexpr uint32_t PER = (8 << 0);  ///< Period Value
    }

    /// CC%s Register bits
    namespace cc%s_bits {
        constexpr uint32_t CC = (32 << 0);  ///< Counter/Compare Value
    }

    /// PERBUF Register bits
    namespace perbuf_bits {
        constexpr uint32_t PERBUF = (8 << 0);  ///< Period Buffer Value
    }

    /// CCBUF%s Register bits
    namespace ccbuf%s_bits {
        constexpr uint32_t CCBUF = (32 << 0);  ///< Counter/Compare Buffer Value
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t TRNG_BASE = 0x42004400;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t EVCTRL;  ///< Offset: 0x04 - Event Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x08 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x09 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x0A - Interrupt Flag Status and Clear
        volatile uint32_t DATA;  ///< Offset: 0x20 - Output Data
    };

    /// Peripheral instances
    inline Registers* TRNG = reinterpret_cast<Registers*>(TRNG_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t RUNSTDBY = (1U << 6);  ///< Run in Standby
    }

    /// EVCTRL Register bits
    namespace evctrl_bits {
        constexpr uint32_t DATARDYEO = (1U << 0);  ///< Data Ready Event Output
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Data Ready Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Data Ready Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Data Ready Interrupt Flag
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Output Data
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_BASE = 0x41000000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control A
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x02 - Synchronization Busy
        volatile uint32_t QOSCTRL;  ///< Offset: 0x03 - USB Quality Of Service
        volatile uint32_t CTRLB;  ///< Offset: 0x08 - DEVICE Control B
        volatile uint32_t DADD;  ///< Offset: 0x0A - DEVICE Device Address
        volatile uint32_t STATUS;  ///< Offset: 0x0C - DEVICE Status
        volatile uint32_t FSMSTATUS;  ///< Offset: 0x0D - Finite State Machine Status
        volatile uint32_t FNUM;  ///< Offset: 0x10 - DEVICE Device Frame Number
        volatile uint32_t INTENCLR;  ///< Offset: 0x14 - DEVICE Device Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x18 - DEVICE Device Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x1C - DEVICE Device Interrupt Flag
        volatile uint32_t EPINTSMRY;  ///< Offset: 0x20 - DEVICE End Point Interrupt Summary
        volatile uint32_t DESCADD;  ///< Offset: 0x24 - Descriptor Address
        volatile uint32_t PADCAL;  ///< Offset: 0x28 - USB PAD Calibration
        volatile uint32_t EPCFG%s;  ///< Offset: 0x100 - DEVICE End Point Configuration
        volatile uint32_t EPSTATUSCLR%s;  ///< Offset: 0x104 - DEVICE End Point Pipe Status Clear
        volatile uint32_t EPSTATUSSET%s;  ///< Offset: 0x105 - DEVICE End Point Pipe Status Set
        volatile uint32_t EPSTATUS%s;  ///< Offset: 0x106 - DEVICE End Point Pipe Status
        volatile uint32_t EPINTFLAG%s;  ///< Offset: 0x107 - DEVICE End Point Interrupt Flag
        volatile uint32_t EPINTENCLR%s;  ///< Offset: 0x108 - DEVICE End Point Interrupt Clear Flag
        volatile uint32_t EPINTENSET%s;  ///< Offset: 0x109 - DEVICE End Point Interrupt Set Flag
    };

    /// Peripheral instances
    inline Registers* USB = reinterpret_cast<Registers*>(USB_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t RUNSTDBY = (1U << 2);  ///< Run in Standby Mode
        constexpr uint32_t MODE = (1U << 7);  ///< Operating Mode
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset Synchronization Busy
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable Synchronization Busy
    }

    /// QOSCTRL Register bits
    namespace qosctrl_bits {
        constexpr uint32_t CQOS = (2 << 0);  ///< Configuration Quality of Service
        constexpr uint32_t DQOS = (2 << 2);  ///< Data Quality of Service
    }

    /// CTRLB Register bits
    namespace ctrlb_bits {
        constexpr uint32_t DETACH = (1U << 0);  ///< Detach
        constexpr uint32_t UPRSM = (1U << 1);  ///< Upstream Resume
        constexpr uint32_t SPDCONF = (2 << 2);  ///< Speed Configuration
        constexpr uint32_t NREPLY = (1U << 4);  ///< No Reply
        constexpr uint32_t TSTJ = (1U << 5);  ///< Test mode J
        constexpr uint32_t TSTK = (1U << 6);  ///< Test mode K
        constexpr uint32_t TSTPCKT = (1U << 7);  ///< Test packet mode
        constexpr uint32_t OPMODE2 = (1U << 8);  ///< Specific Operational Mode
        constexpr uint32_t GNAK = (1U << 9);  ///< Global NAK
        constexpr uint32_t LPMHDSK = (2 << 10);  ///< Link Power Management Handshake
    }

    /// DADD Register bits
    namespace dadd_bits {
        constexpr uint32_t DADD = (7 << 0);  ///< Device Address
        constexpr uint32_t ADDEN = (1U << 7);  ///< Device Address Enable
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SPEED = (2 << 2);  ///< Speed Status
        constexpr uint32_t LINESTATE = (2 << 6);  ///< USB Line State Status
    }

    /// FSMSTATUS Register bits
    namespace fsmstatus_bits {
        constexpr uint32_t FSMSTATE = (7 << 0);  ///< Fine State Machine Status
    }

    /// FNUM Register bits
    namespace fnum_bits {
        constexpr uint32_t MFNUM = (3 << 0);  ///< Micro Frame Number
        constexpr uint32_t FNUM = (11 << 3);  ///< Frame Number
        constexpr uint32_t FNCERR = (1U << 15);  ///< Frame Number CRC Error
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t SUSPEND = (1U << 0);  ///< Suspend Interrupt Enable
        constexpr uint32_t MSOF = (1U << 1);  ///< Micro Start of Frame Interrupt Enable in High Speed Mode
        constexpr uint32_t SOF = (1U << 2);  ///< Start Of Frame Interrupt Enable
        constexpr uint32_t EORST = (1U << 3);  ///< End of Reset Interrupt Enable
        constexpr uint32_t WAKEUP = (1U << 4);  ///< Wake Up Interrupt Enable
        constexpr uint32_t EORSM = (1U << 5);  ///< End Of Resume Interrupt Enable
        constexpr uint32_t UPRSM = (1U << 6);  ///< Upstream Resume Interrupt Enable
        constexpr uint32_t RAMACER = (1U << 7);  ///< Ram Access Interrupt Enable
        constexpr uint32_t LPMNYET = (1U << 8);  ///< Link Power Management Not Yet Interrupt Enable
        constexpr uint32_t LPMSUSP = (1U << 9);  ///< Link Power Management Suspend Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t SUSPEND = (1U << 0);  ///< Suspend Interrupt Enable
        constexpr uint32_t MSOF = (1U << 1);  ///< Micro Start of Frame Interrupt Enable in High Speed Mode
        constexpr uint32_t SOF = (1U << 2);  ///< Start Of Frame Interrupt Enable
        constexpr uint32_t EORST = (1U << 3);  ///< End of Reset Interrupt Enable
        constexpr uint32_t WAKEUP = (1U << 4);  ///< Wake Up Interrupt Enable
        constexpr uint32_t EORSM = (1U << 5);  ///< End Of Resume Interrupt Enable
        constexpr uint32_t UPRSM = (1U << 6);  ///< Upstream Resume Interrupt Enable
        constexpr uint32_t RAMACER = (1U << 7);  ///< Ram Access Interrupt Enable
        constexpr uint32_t LPMNYET = (1U << 8);  ///< Link Power Management Not Yet Interrupt Enable
        constexpr uint32_t LPMSUSP = (1U << 9);  ///< Link Power Management Suspend Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t SUSPEND = (1U << 0);  ///< Suspend
        constexpr uint32_t MSOF = (1U << 1);  ///< Micro Start of Frame in High Speed Mode
        constexpr uint32_t SOF = (1U << 2);  ///< Start Of Frame
        constexpr uint32_t EORST = (1U << 3);  ///< End of Reset
        constexpr uint32_t WAKEUP = (1U << 4);  ///< Wake Up
        constexpr uint32_t EORSM = (1U << 5);  ///< End Of Resume
        constexpr uint32_t UPRSM = (1U << 6);  ///< Upstream Resume
        constexpr uint32_t RAMACER = (1U << 7);  ///< Ram Access
        constexpr uint32_t LPMNYET = (1U << 8);  ///< Link Power Management Not Yet
        constexpr uint32_t LPMSUSP = (1U << 9);  ///< Link Power Management Suspend
    }

    /// EPINTSMRY Register bits
    namespace epintsmry_bits {
        constexpr uint32_t EPINT0 = (1U << 0);  ///< End Point 0 Interrupt
        constexpr uint32_t EPINT1 = (1U << 1);  ///< End Point 1 Interrupt
        constexpr uint32_t EPINT2 = (1U << 2);  ///< End Point 2 Interrupt
        constexpr uint32_t EPINT3 = (1U << 3);  ///< End Point 3 Interrupt
        constexpr uint32_t EPINT4 = (1U << 4);  ///< End Point 4 Interrupt
        constexpr uint32_t EPINT5 = (1U << 5);  ///< End Point 5 Interrupt
        constexpr uint32_t EPINT6 = (1U << 6);  ///< End Point 6 Interrupt
        constexpr uint32_t EPINT7 = (1U << 7);  ///< End Point 7 Interrupt
    }

    /// DESCADD Register bits
    namespace descadd_bits {
        constexpr uint32_t DESCADD = (32 << 0);  ///< Descriptor Address Value
    }

    /// PADCAL Register bits
    namespace padcal_bits {
        constexpr uint32_t TRANSP = (5 << 0);  ///< USB Pad Transp calibration
        constexpr uint32_t TRANSN = (5 << 6);  ///< USB Pad Transn calibration
        constexpr uint32_t TRIM = (3 << 12);  ///< USB Pad Trim calibration
    }

    /// EPCFG%s Register bits
    namespace epcfg%s_bits {
        constexpr uint32_t EPTYPE0 = (3 << 0);  ///< End Point Type0
        constexpr uint32_t EPTYPE1 = (3 << 4);  ///< End Point Type1
        constexpr uint32_t NYETDIS = (1U << 7);  ///< NYET Token Disable
    }

    /// EPSTATUSCLR%s Register bits
    namespace epstatusclr%s_bits {
        constexpr uint32_t DTGLOUT = (1U << 0);  ///< Data Toggle OUT Clear
        constexpr uint32_t DTGLIN = (1U << 1);  ///< Data Toggle IN Clear
        constexpr uint32_t CURBK = (1U << 2);  ///< Current Bank Clear
        constexpr uint32_t STALLRQ0 = (1U << 4);  ///< Stall 0 Request Clear
        constexpr uint32_t STALLRQ1 = (1U << 5);  ///< Stall 1 Request Clear
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 Ready Clear
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 Ready Clear
    }

    /// EPSTATUSSET%s Register bits
    namespace epstatusset%s_bits {
        constexpr uint32_t DTGLOUT = (1U << 0);  ///< Data Toggle OUT Set
        constexpr uint32_t DTGLIN = (1U << 1);  ///< Data Toggle IN Set
        constexpr uint32_t CURBK = (1U << 2);  ///< Current Bank Set
        constexpr uint32_t STALLRQ0 = (1U << 4);  ///< Stall 0 Request Set
        constexpr uint32_t STALLRQ1 = (1U << 5);  ///< Stall 1 Request Set
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 Ready Set
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 Ready Set
    }

    /// EPSTATUS%s Register bits
    namespace epstatus%s_bits {
        constexpr uint32_t DTGLOUT = (1U << 0);  ///< Data Toggle Out
        constexpr uint32_t DTGLIN = (1U << 1);  ///< Data Toggle In
        constexpr uint32_t CURBK = (1U << 2);  ///< Current Bank
        constexpr uint32_t STALLRQ0 = (1U << 4);  ///< Stall 0 Request
        constexpr uint32_t STALLRQ1 = (1U << 5);  ///< Stall 1 Request
        constexpr uint32_t BK0RDY = (1U << 6);  ///< Bank 0 ready
        constexpr uint32_t BK1RDY = (1U << 7);  ///< Bank 1 ready
    }

    /// EPINTFLAG%s Register bits
    namespace epintflag%s_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1
        constexpr uint32_t TRFAIL0 = (1U << 2);  ///< Error Flow 0
        constexpr uint32_t TRFAIL1 = (1U << 3);  ///< Error Flow 1
        constexpr uint32_t RXSTP = (1U << 4);  ///< Received Setup
        constexpr uint32_t STALL0 = (1U << 5);  ///< Stall 0 In/out
        constexpr uint32_t STALL1 = (1U << 6);  ///< Stall 1 In/out
    }

    /// EPINTENCLR%s Register bits
    namespace epintenclr%s_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0 Interrupt Disable
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1 Interrupt Disable
        constexpr uint32_t TRFAIL0 = (1U << 2);  ///< Error Flow 0 Interrupt Disable
        constexpr uint32_t TRFAIL1 = (1U << 3);  ///< Error Flow 1 Interrupt Disable
        constexpr uint32_t RXSTP = (1U << 4);  ///< Received Setup Interrupt Disable
        constexpr uint32_t STALL0 = (1U << 5);  ///< Stall 0 In/Out Interrupt Disable
        constexpr uint32_t STALL1 = (1U << 6);  ///< Stall 1 In/Out Interrupt Disable
    }

    /// EPINTENSET%s Register bits
    namespace epintenset%s_bits {
        constexpr uint32_t TRCPT0 = (1U << 0);  ///< Transfer Complete 0 Interrupt Enable
        constexpr uint32_t TRCPT1 = (1U << 1);  ///< Transfer Complete 1 Interrupt Enable
        constexpr uint32_t TRFAIL0 = (1U << 2);  ///< Error Flow 0 Interrupt Enable
        constexpr uint32_t TRFAIL1 = (1U << 3);  ///< Error Flow 1 Interrupt Enable
        constexpr uint32_t RXSTP = (1U << 4);  ///< Received Setup Interrupt Enable
        constexpr uint32_t STALL0 = (1U << 5);  ///< Stall 0 In/out Interrupt enable
        constexpr uint32_t STALL1 = (1U << 6);  ///< Stall 1 In/out Interrupt enable
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40002000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t CTRLA;  ///< Offset: 0x00 - Control
        volatile uint32_t CONFIG;  ///< Offset: 0x01 - Configuration
        volatile uint32_t EWCTRL;  ///< Offset: 0x02 - Early Warning Interrupt Control
        volatile uint32_t INTENCLR;  ///< Offset: 0x04 - Interrupt Enable Clear
        volatile uint32_t INTENSET;  ///< Offset: 0x05 - Interrupt Enable Set
        volatile uint32_t INTFLAG;  ///< Offset: 0x06 - Interrupt Flag Status and Clear
        volatile uint32_t SYNCBUSY;  ///< Offset: 0x08 - Synchronization Busy
        volatile uint32_t CLEAR;  ///< Offset: 0x0C - Clear
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// CTRLA Register bits
    namespace ctrla_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable
        constexpr uint32_t WEN = (1U << 2);  ///< Watchdog Timer Window Mode Enable
        constexpr uint32_t ALWAYSON = (1U << 7);  ///< Always-On
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t PER = (4 << 0);  ///< Time-Out Period
        constexpr uint32_t WINDOW = (4 << 4);  ///< Window Mode Time-Out Period
    }

    /// EWCTRL Register bits
    namespace ewctrl_bits {
        constexpr uint32_t EWOFFSET = (4 << 0);  ///< Early Warning Interrupt Time Offset
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t EW = (1U << 0);  ///< Early Warning Interrupt Enable
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t EW = (1U << 0);  ///< Early Warning Interrupt Enable
    }

    /// INTFLAG Register bits
    namespace intflag_bits {
        constexpr uint32_t EW = (1U << 0);  ///< Early Warning
    }

    /// SYNCBUSY Register bits
    namespace syncbusy_bits {
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enable Busy
        constexpr uint32_t WEN = (1U << 2);  ///< Window Enable Busy
        constexpr uint32_t ALWAYSON = (1U << 3);  ///< Always-On Busy
        constexpr uint32_t CLEAR = (1U << 4);  ///< Clear Busy
    }

    /// CLEAR Register bits
    namespace clear_bits {
        constexpr uint32_t CLEAR = (8 << 0);  ///< Watchdog Clear
    }

}


} // namespace alloy::generated::atsaml22n16a

#endif // ALLOY_GENERATED_ATSAML22N16A_PERIPHERALS_HPP