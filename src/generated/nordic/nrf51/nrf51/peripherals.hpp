/// Auto-generated code for nrf51
/// Generated by Alloy Code Generator
/// Source: nordic_nrf51.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:54
#ifndef ALLOY_GENERATED_NRF51_PERIPHERALS_HPP
#define ALLOY_GENERATED_NRF51_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::nrf51 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_radio = true;
    constexpr uint32_t num_radio_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 2;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 3;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 2;
    constexpr bool has_temp = true;
    constexpr uint32_t num_temp_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_ecb = true;
    constexpr uint32_t num_ecb_instances = 1;
    constexpr bool has_aar = true;
    constexpr uint32_t num_aar_instances = 1;
    constexpr bool has_ccm = true;
    constexpr uint32_t num_ccm_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_qdec = true;
    constexpr uint32_t num_qdec_instances = 1;
    constexpr bool has_lpcomp = true;
    constexpr uint32_t num_lpcomp_instances = 1;
    constexpr bool has_swi = true;
    constexpr uint32_t num_swi_instances = 1;
    constexpr bool has_nvmc = true;
    constexpr uint32_t num_nvmc_instances = 1;
    constexpr bool has_ppi = true;
    constexpr uint32_t num_ppi_instances = 1;
    constexpr bool has_ficr = true;
    constexpr uint32_t num_ficr_instances = 1;
    constexpr bool has_uicr = true;
    constexpr uint32_t num_uicr_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct radio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct temp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ecb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aar_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct qdec_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lpcomp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ppi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ficr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct uicr_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 2;
    constexpr uint32_t max_gpio_pins = 32;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t POWER_BASE = 0x40000000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t TASKS_CONSTLAT;  ///< Offset: 0x78 - Enable constant latency mode.
        volatile uint32_t TASKS_LOWPWR;  ///< Offset: 0x7C - Enable low power mode (variable latency).
        volatile uint32_t EVENTS_POFWARN;  ///< Offset: 0x108 - Power failure warning.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t RESETREAS;  ///< Offset: 0x400 - Reset reason.
        volatile uint32_t RAMSTATUS;  ///< Offset: 0x428 - Ram status register.
        volatile uint32_t SYSTEMOFF;  ///< Offset: 0x500 - System off register.
        volatile uint32_t POFCON;  ///< Offset: 0x510 - Power failure configuration.
        volatile uint32_t GPREGRET;  ///< Offset: 0x51C - General purpose retention register. This register is a...
        volatile uint32_t RAMON;  ///< Offset: 0x524 - Ram on/off.
        volatile uint32_t RESET;  ///< Offset: 0x544 - Pin reset functionality configuration register. This...
        volatile uint32_t RAMONB;  ///< Offset: 0x554 - Ram on/off.
        volatile uint32_t DCDCEN;  ///< Offset: 0x578 - DCDC converter enable configuration register.
        volatile uint32_t DCDCFORCE;  ///< Offset: 0xA08 - DCDC power-up force register.
    };

    /// Peripheral instances
    inline Registers* POWER = reinterpret_cast<Registers*>(POWER_BASE);

    // Bit definitions
    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t POFWARN = (1U << 2);  ///< Enable interrupt on POFWARN event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t POFWARN = (1U << 2);  ///< Disable interrupt on POFWARN event.
    }

    /// RESETREAS Register bits
    namespace resetreas_bits {
        constexpr uint32_t RESETPIN = (1U << 0);  ///< Reset from pin-reset detected.
        constexpr uint32_t DOG = (1U << 1);  ///< Reset from watchdog detected.
        constexpr uint32_t SREQ = (1U << 2);  ///< Reset from AIRCR.SYSRESETREQ detected.
        constexpr uint32_t LOCKUP = (1U << 3);  ///< Reset from CPU lock-up detected.
        constexpr uint32_t OFF = (1U << 16);  ///< Reset from wake-up from OFF mode detected by the use of DETECT signal from GPIO.
        constexpr uint32_t LPCOMP = (1U << 17);  ///< Reset from wake-up from OFF mode detected by the use of ANADETECT signal from LPCOMP.
        constexpr uint32_t DIF = (1U << 18);  ///< Reset from wake-up from OFF mode detected by entering into debug interface mode.
    }

    /// RAMSTATUS Register bits
    namespace ramstatus_bits {
        constexpr uint32_t RAMBLOCK0 = (1U << 0);  ///< RAM block 0 status.
        constexpr uint32_t RAMBLOCK1 = (1U << 1);  ///< RAM block 1 status.
        constexpr uint32_t RAMBLOCK2 = (1U << 2);  ///< RAM block 2 status.
        constexpr uint32_t RAMBLOCK3 = (1U << 3);  ///< RAM block 3 status.
    }

    /// SYSTEMOFF Register bits
    namespace systemoff_bits {
        constexpr uint32_t SYSTEMOFF = (1U << 0);  ///< Enter system off mode.
    }

    /// POFCON Register bits
    namespace pofcon_bits {
        constexpr uint32_t POF = (1U << 0);  ///< Power failure comparator enable.
        constexpr uint32_t THRESHOLD = (2 << 1);  ///< Set threshold level.
    }

    /// GPREGRET Register bits
    namespace gpregret_bits {
        constexpr uint32_t GPREGRET = (8 << 0);  ///< General purpose retention register.
    }

    /// RAMON Register bits
    namespace ramon_bits {
        constexpr uint32_t ONRAM0 = (1U << 0);  ///< RAM block 0 behaviour in ON mode.
        constexpr uint32_t ONRAM1 = (1U << 1);  ///< RAM block 1 behaviour in ON mode.
        constexpr uint32_t OFFRAM0 = (1U << 16);  ///< RAM block 0 behaviour in OFF mode.
        constexpr uint32_t OFFRAM1 = (1U << 17);  ///< RAM block 1 behaviour in OFF mode.
    }

    /// RESET Register bits
    namespace reset_bits {
        constexpr uint32_t RESET = (1U << 0);  ///< Enable or disable pin reset in debug interface mode.
    }

    /// RAMONB Register bits
    namespace ramonb_bits {
        constexpr uint32_t ONRAM2 = (1U << 0);  ///< RAM block 2 behaviour in ON mode.
        constexpr uint32_t ONRAM3 = (1U << 1);  ///< RAM block 3 behaviour in ON mode.
        constexpr uint32_t OFFRAM2 = (1U << 16);  ///< RAM block 2 behaviour in OFF mode.
        constexpr uint32_t OFFRAM3 = (1U << 17);  ///< RAM block 3 behaviour in OFF mode.
    }

    /// DCDCEN Register bits
    namespace dcdcen_bits {
        constexpr uint32_t DCDCEN = (1U << 0);  ///< Enable DCDC converter.
    }

    /// DCDCFORCE Register bits
    namespace dcdcforce_bits {
        constexpr uint32_t FORCEOFF = (1U << 0);  ///< DCDC power-up force off.
        constexpr uint32_t FORCEON = (1U << 1);  ///< DCDC power-up force on.
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t CLOCK_BASE = 0x40000000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t TASKS_HFCLKSTART;  ///< Offset: 0x00 - Start HFCLK clock source.
        volatile uint32_t TASKS_HFCLKSTOP;  ///< Offset: 0x04 - Stop HFCLK clock source.
        volatile uint32_t TASKS_LFCLKSTART;  ///< Offset: 0x08 - Start LFCLK clock source.
        volatile uint32_t TASKS_LFCLKSTOP;  ///< Offset: 0x0C - Stop LFCLK clock source.
        volatile uint32_t TASKS_CAL;  ///< Offset: 0x10 - Start calibration of LFCLK RC oscillator.
        volatile uint32_t TASKS_CTSTART;  ///< Offset: 0x14 - Start calibration timer.
        volatile uint32_t TASKS_CTSTOP;  ///< Offset: 0x18 - Stop calibration timer.
        volatile uint32_t EVENTS_HFCLKSTARTED;  ///< Offset: 0x100 - HFCLK oscillator started.
        volatile uint32_t EVENTS_LFCLKSTARTED;  ///< Offset: 0x104 - LFCLK oscillator started.
        volatile uint32_t EVENTS_DONE;  ///< Offset: 0x10C - Calibration of LFCLK RC oscillator completed.
        volatile uint32_t EVENTS_CTTO;  ///< Offset: 0x110 - Calibration timer timeout.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t HFCLKRUN;  ///< Offset: 0x408 - Task HFCLKSTART trigger status.
        volatile uint32_t HFCLKSTAT;  ///< Offset: 0x40C - High frequency clock status.
        volatile uint32_t LFCLKRUN;  ///< Offset: 0x414 - Task LFCLKSTART triggered status.
        volatile uint32_t LFCLKSTAT;  ///< Offset: 0x418 - Low frequency clock status.
        volatile uint32_t LFCLKSRCCOPY;  ///< Offset: 0x41C - Clock source for the LFCLK clock, set when task...
        volatile uint32_t LFCLKSRC;  ///< Offset: 0x518 - Clock source for the LFCLK clock.
        volatile uint32_t CTIV;  ///< Offset: 0x538 - Calibration timer interval.
        volatile uint32_t XTALFREQ;  ///< Offset: 0x550 - Crystal frequency.
    };

    /// Peripheral instances
    inline Registers* CLOCK = reinterpret_cast<Registers*>(CLOCK_BASE);

    // Bit definitions
    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Enable interrupt on HFCLKSTARTED event.
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Enable interrupt on LFCLKSTARTED event.
        constexpr uint32_t DONE = (1U << 3);  ///< Enable interrupt on DONE event.
        constexpr uint32_t CTTO = (1U << 4);  ///< Enable interrupt on CTTO event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Disable interrupt on HFCLKSTARTED event.
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Disable interrupt on LFCLKSTARTED event.
        constexpr uint32_t DONE = (1U << 3);  ///< Disable interrupt on DONE event.
        constexpr uint32_t CTTO = (1U << 4);  ///< Disable interrupt on CTTO event.
    }

    /// HFCLKRUN Register bits
    namespace hfclkrun_bits {
        constexpr uint32_t STATUS = (1U << 0);  ///< Task HFCLKSTART trigger status.
    }

    /// HFCLKSTAT Register bits
    namespace hfclkstat_bits {
        constexpr uint32_t SRC = (1U << 0);  ///< Active clock source for the HF clock.
        constexpr uint32_t STATE = (1U << 16);  ///< State for the HFCLK.
    }

    /// LFCLKRUN Register bits
    namespace lfclkrun_bits {
        constexpr uint32_t STATUS = (1U << 0);  ///< Task LFCLKSTART triggered status.
    }

    /// LFCLKSTAT Register bits
    namespace lfclkstat_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Active clock source for the LF clock.
        constexpr uint32_t STATE = (1U << 16);  ///< State for the LF clock.
    }

    /// LFCLKSRCCOPY Register bits
    namespace lfclksrccopy_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Clock source for the LFCLK clock, set when task LKCLKSTART is triggered.
    }

    /// LFCLKSRC Register bits
    namespace lfclksrc_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Clock source.
    }

    /// CTIV Register bits
    namespace ctiv_bits {
        constexpr uint32_t CTIV = (7 << 0);  ///< Calibration timer interval in 0.25s resolution.
    }

    /// XTALFREQ Register bits
    namespace xtalfreq_bits {
        constexpr uint32_t XTALFREQ = (8 << 0);  ///< External Xtal frequency selection.
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0x40000000;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t PERR0;  ///< Offset: 0x528 - Configuration of peripherals in mpu regions.
        volatile uint32_t RLENR0;  ///< Offset: 0x52C - Length of RAM region 0.
        volatile uint32_t PROTENSET0;  ///< Offset: 0x600 - Erase and write protection bit enable set register.
        volatile uint32_t PROTENSET1;  ///< Offset: 0x604 - Erase and write protection bit enable set register.
        volatile uint32_t DISABLEINDEBUG;  ///< Offset: 0x608 - Disable erase and write protection mechanism in debug mode.
        volatile uint32_t PROTBLOCKSIZE;  ///< Offset: 0x60C - Erase and write protection block size.
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// PERR0 Register bits
    namespace perr0_bits {
        constexpr uint32_t POWER_CLOCK = (1U << 0);  ///< POWER_CLOCK region configuration.
        constexpr uint32_t RADIO = (1U << 1);  ///< RADIO region configuration.
        constexpr uint32_t UART0 = (1U << 2);  ///< UART0 region configuration.
        constexpr uint32_t SPI0_TWI0 = (1U << 3);  ///< SPI0 and TWI0 region configuration.
        constexpr uint32_t SPI1_TWI1 = (1U << 4);  ///< SPI1 and TWI1 region configuration.
        constexpr uint32_t GPIOTE = (1U << 6);  ///< GPIOTE region configuration.
        constexpr uint32_t ADC = (1U << 7);  ///< ADC region configuration.
        constexpr uint32_t TIMER0 = (1U << 8);  ///< TIMER0 region configuration.
        constexpr uint32_t TIMER1 = (1U << 9);  ///< TIMER1 region configuration.
        constexpr uint32_t TIMER2 = (1U << 10);  ///< TIMER2 region configuration.
        constexpr uint32_t RTC0 = (1U << 11);  ///< RTC0 region configuration.
        constexpr uint32_t TEMP = (1U << 12);  ///< TEMP region configuration.
        constexpr uint32_t RNG = (1U << 13);  ///< RNG region configuration.
        constexpr uint32_t ECB = (1U << 14);  ///< ECB region configuration.
        constexpr uint32_t CCM_AAR = (1U << 15);  ///< CCM and AAR region configuration.
        constexpr uint32_t WDT = (1U << 16);  ///< WDT region configuration.
        constexpr uint32_t RTC1 = (1U << 17);  ///< RTC1 region configuration.
        constexpr uint32_t QDEC = (1U << 18);  ///< QDEC region configuration.
        constexpr uint32_t LPCOMP = (1U << 19);  ///< LPCOMP region configuration.
        constexpr uint32_t NVMC = (1U << 30);  ///< NVMC region configuration.
        constexpr uint32_t PPI = (1U << 31);  ///< PPI region configuration.
    }

    /// PROTENSET0 Register bits
    namespace protenset0_bits {
        constexpr uint32_t PROTREG0 = (1U << 0);  ///< Protection enable for region 0.
        constexpr uint32_t PROTREG1 = (1U << 1);  ///< Protection enable for region 1.
        constexpr uint32_t PROTREG2 = (1U << 2);  ///< Protection enable for region 2.
        constexpr uint32_t PROTREG3 = (1U << 3);  ///< Protection enable for region 3.
        constexpr uint32_t PROTREG4 = (1U << 4);  ///< Protection enable for region 4.
        constexpr uint32_t PROTREG5 = (1U << 5);  ///< Protection enable for region 5.
        constexpr uint32_t PROTREG6 = (1U << 6);  ///< Protection enable for region 6.
        constexpr uint32_t PROTREG7 = (1U << 7);  ///< Protection enable for region 7.
        constexpr uint32_t PROTREG8 = (1U << 8);  ///< Protection enable for region 8.
        constexpr uint32_t PROTREG9 = (1U << 9);  ///< Protection enable for region 9.
        constexpr uint32_t PROTREG10 = (1U << 10);  ///< Protection enable for region 10.
        constexpr uint32_t PROTREG11 = (1U << 11);  ///< Protection enable for region 11.
        constexpr uint32_t PROTREG12 = (1U << 12);  ///< Protection enable for region 12.
        constexpr uint32_t PROTREG13 = (1U << 13);  ///< Protection enable for region 13.
        constexpr uint32_t PROTREG14 = (1U << 14);  ///< Protection enable for region 14.
        constexpr uint32_t PROTREG15 = (1U << 15);  ///< Protection enable for region 15.
        constexpr uint32_t PROTREG16 = (1U << 16);  ///< Protection enable for region 16.
        constexpr uint32_t PROTREG17 = (1U << 17);  ///< Protection enable for region 17.
        constexpr uint32_t PROTREG18 = (1U << 18);  ///< Protection enable for region 18.
        constexpr uint32_t PROTREG19 = (1U << 19);  ///< Protection enable for region 19.
        constexpr uint32_t PROTREG20 = (1U << 20);  ///< Protection enable for region 20.
        constexpr uint32_t PROTREG21 = (1U << 21);  ///< Protection enable for region 21.
        constexpr uint32_t PROTREG22 = (1U << 22);  ///< Protection enable for region 22.
        constexpr uint32_t PROTREG23 = (1U << 23);  ///< Protection enable for region 23.
        constexpr uint32_t PROTREG24 = (1U << 24);  ///< Protection enable for region 24.
        constexpr uint32_t PROTREG25 = (1U << 25);  ///< Protection enable for region 25.
        constexpr uint32_t PROTREG26 = (1U << 26);  ///< Protection enable for region 26.
        constexpr uint32_t PROTREG27 = (1U << 27);  ///< Protection enable for region 27.
        constexpr uint32_t PROTREG28 = (1U << 28);  ///< Protection enable for region 28.
        constexpr uint32_t PROTREG29 = (1U << 29);  ///< Protection enable for region 29.
        constexpr uint32_t PROTREG30 = (1U << 30);  ///< Protection enable for region 30.
        constexpr uint32_t PROTREG31 = (1U << 31);  ///< Protection enable for region 31.
    }

    /// PROTENSET1 Register bits
    namespace protenset1_bits {
        constexpr uint32_t PROTREG32 = (1U << 0);  ///< Protection enable for region 32.
        constexpr uint32_t PROTREG33 = (1U << 1);  ///< Protection enable for region 33.
        constexpr uint32_t PROTREG34 = (1U << 2);  ///< Protection enable for region 34.
        constexpr uint32_t PROTREG35 = (1U << 3);  ///< Protection enable for region 35.
        constexpr uint32_t PROTREG36 = (1U << 4);  ///< Protection enable for region 36.
        constexpr uint32_t PROTREG37 = (1U << 5);  ///< Protection enable for region 37.
        constexpr uint32_t PROTREG38 = (1U << 6);  ///< Protection enable for region 38.
        constexpr uint32_t PROTREG39 = (1U << 7);  ///< Protection enable for region 39.
        constexpr uint32_t PROTREG40 = (1U << 8);  ///< Protection enable for region 40.
        constexpr uint32_t PROTREG41 = (1U << 9);  ///< Protection enable for region 41.
        constexpr uint32_t PROTREG42 = (1U << 10);  ///< Protection enable for region 42.
        constexpr uint32_t PROTREG43 = (1U << 11);  ///< Protection enable for region 43.
        constexpr uint32_t PROTREG44 = (1U << 12);  ///< Protection enable for region 44.
        constexpr uint32_t PROTREG45 = (1U << 13);  ///< Protection enable for region 45.
        constexpr uint32_t PROTREG46 = (1U << 14);  ///< Protection enable for region 46.
        constexpr uint32_t PROTREG47 = (1U << 15);  ///< Protection enable for region 47.
        constexpr uint32_t PROTREG48 = (1U << 16);  ///< Protection enable for region 48.
        constexpr uint32_t PROTREG49 = (1U << 17);  ///< Protection enable for region 49.
        constexpr uint32_t PROTREG50 = (1U << 18);  ///< Protection enable for region 50.
        constexpr uint32_t PROTREG51 = (1U << 19);  ///< Protection enable for region 51.
        constexpr uint32_t PROTREG52 = (1U << 20);  ///< Protection enable for region 52.
        constexpr uint32_t PROTREG53 = (1U << 21);  ///< Protection enable for region 53.
        constexpr uint32_t PROTREG54 = (1U << 22);  ///< Protection enable for region 54.
        constexpr uint32_t PROTREG55 = (1U << 23);  ///< Protection enable for region 55.
        constexpr uint32_t PROTREG56 = (1U << 24);  ///< Protection enable for region 56.
        constexpr uint32_t PROTREG57 = (1U << 25);  ///< Protection enable for region 57.
        constexpr uint32_t PROTREG58 = (1U << 26);  ///< Protection enable for region 58.
        constexpr uint32_t PROTREG59 = (1U << 27);  ///< Protection enable for region 59.
        constexpr uint32_t PROTREG60 = (1U << 28);  ///< Protection enable for region 60.
        constexpr uint32_t PROTREG61 = (1U << 29);  ///< Protection enable for region 61.
        constexpr uint32_t PROTREG62 = (1U << 30);  ///< Protection enable for region 62.
        constexpr uint32_t PROTREG63 = (1U << 31);  ///< Protection enable for region 63.
    }

    /// DISABLEINDEBUG Register bits
    namespace disableindebug_bits {
        constexpr uint32_t DISABLEINDEBUG = (1U << 0);  ///< Disable protection mechanism in debug mode.
    }

    /// PROTBLOCKSIZE Register bits
    namespace protblocksize_bits {
        constexpr uint32_t PROTBLOCKSIZE = (2 << 0);  ///< Erase and write protection block size.
    }

}

// ============================================================================
// RADIO Peripheral
// ============================================================================

namespace radio {
    /// Base addresses
    constexpr uint32_t RADIO_BASE = 0x40001000;

    /// RADIO Register structure
    struct Registers {
        volatile uint32_t TASKS_TXEN;  ///< Offset: 0x00 - Enable radio in TX mode.
        volatile uint32_t TASKS_RXEN;  ///< Offset: 0x04 - Enable radio in RX mode.
        volatile uint32_t TASKS_START;  ///< Offset: 0x08 - Start radio.
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x0C - Stop radio.
        volatile uint32_t TASKS_DISABLE;  ///< Offset: 0x10 - Disable radio.
        volatile uint32_t TASKS_RSSISTART;  ///< Offset: 0x14 - Start the RSSI and take one sample of the receive signal...
        volatile uint32_t TASKS_RSSISTOP;  ///< Offset: 0x18 - Stop the RSSI measurement.
        volatile uint32_t TASKS_BCSTART;  ///< Offset: 0x1C - Start the bit counter.
        volatile uint32_t TASKS_BCSTOP;  ///< Offset: 0x20 - Stop the bit counter.
        volatile uint32_t EVENTS_READY;  ///< Offset: 0x100 - Ready event.
        volatile uint32_t EVENTS_ADDRESS;  ///< Offset: 0x104 - Address event.
        volatile uint32_t EVENTS_PAYLOAD;  ///< Offset: 0x108 - Payload event.
        volatile uint32_t EVENTS_END;  ///< Offset: 0x10C - End event.
        volatile uint32_t EVENTS_DISABLED;  ///< Offset: 0x110 - Disable event.
        volatile uint32_t EVENTS_DEVMATCH;  ///< Offset: 0x114 - A device address match occurred on the last received packet.
        volatile uint32_t EVENTS_DEVMISS;  ///< Offset: 0x118 - No device address match occurred on the last received packet.
        volatile uint32_t EVENTS_RSSIEND;  ///< Offset: 0x11C - Sampling of the receive signal strength complete. A new...
        volatile uint32_t EVENTS_BCMATCH;  ///< Offset: 0x128 - Bit counter reached bit count value specified in BCC register.
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts for the radio.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t CRCSTATUS;  ///< Offset: 0x400 - CRC status of received packet.
        volatile uint32_t RXMATCH;  ///< Offset: 0x408 - Received address.
        volatile uint32_t RXCRC;  ///< Offset: 0x40C - Received CRC.
        volatile uint32_t DAI;  ///< Offset: 0x410 - Device address match index.
        volatile uint32_t PACKETPTR;  ///< Offset: 0x504 - Packet pointer. Decision point: START task.
        volatile uint32_t FREQUENCY;  ///< Offset: 0x508 - Frequency.
        volatile uint32_t TXPOWER;  ///< Offset: 0x50C - Output power.
        volatile uint32_t MODE;  ///< Offset: 0x510 - Data rate and modulation.
        volatile uint32_t PCNF0;  ///< Offset: 0x514 - Packet configuration 0.
        volatile uint32_t PCNF1;  ///< Offset: 0x518 - Packet configuration 1.
        volatile uint32_t BASE0;  ///< Offset: 0x51C - Radio base address 0. Decision point: START task.
        volatile uint32_t BASE1;  ///< Offset: 0x520 - Radio base address 1. Decision point: START task.
        volatile uint32_t PREFIX0;  ///< Offset: 0x524 - Prefixes bytes for logical addresses 0 to 3.
        volatile uint32_t PREFIX1;  ///< Offset: 0x528 - Prefixes bytes for logical addresses 4 to 7.
        volatile uint32_t TXADDRESS;  ///< Offset: 0x52C - Transmit address select.
        volatile uint32_t RXADDRESSES;  ///< Offset: 0x530 - Receive address select.
        volatile uint32_t CRCCNF;  ///< Offset: 0x534 - CRC configuration.
        volatile uint32_t CRCPOLY;  ///< Offset: 0x538 - CRC polynomial.
        volatile uint32_t CRCINIT;  ///< Offset: 0x53C - CRC initial value.
        volatile uint32_t TEST;  ///< Offset: 0x540 - Test features enable register.
        volatile uint32_t TIFS;  ///< Offset: 0x544 - Inter Frame Spacing in microseconds.
        volatile uint32_t RSSISAMPLE;  ///< Offset: 0x548 - RSSI sample.
        volatile uint32_t STATE;  ///< Offset: 0x550 - Current radio state.
        volatile uint32_t DATAWHITEIV;  ///< Offset: 0x554 - Data whitening initial value.
        volatile uint32_t BCC;  ///< Offset: 0x560 - Bit counter compare.
        volatile uint32_t DAB[%s];  ///< Offset: 0x600 - Device address base segment.
        volatile uint32_t DAP[%s];  ///< Offset: 0x620 - Device address prefix.
        volatile uint32_t DACNF;  ///< Offset: 0x640 - Device address match configuration.
        volatile uint32_t OVERRIDE0;  ///< Offset: 0x724 - Trim value override register 0.
        volatile uint32_t OVERRIDE1;  ///< Offset: 0x728 - Trim value override register 1.
        volatile uint32_t OVERRIDE2;  ///< Offset: 0x72C - Trim value override register 2.
        volatile uint32_t OVERRIDE3;  ///< Offset: 0x730 - Trim value override register 3.
        volatile uint32_t OVERRIDE4;  ///< Offset: 0x734 - Trim value override register 4.
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* RADIO = reinterpret_cast<Registers*>(RADIO_BASE);

    // Bit definitions
    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t READY_START = (1U << 0);  ///< Shortcut between READY event and START task.
        constexpr uint32_t END_DISABLE = (1U << 1);  ///< Shortcut between END event and DISABLE task.
        constexpr uint32_t DISABLED_TXEN = (1U << 2);  ///< Shortcut between DISABLED event and TXEN task.
        constexpr uint32_t DISABLED_RXEN = (1U << 3);  ///< Shortcut between DISABLED event and RXEN task.
        constexpr uint32_t ADDRESS_RSSISTART = (1U << 4);  ///< Shortcut between ADDRESS event and RSSISTART task.
        constexpr uint32_t END_START = (1U << 5);  ///< Shortcut between END event and START task.
        constexpr uint32_t ADDRESS_BCSTART = (1U << 6);  ///< Shortcut between ADDRESS event and BCSTART task.
        constexpr uint32_t DISABLED_RSSISTOP = (1U << 8);  ///< Shortcut between DISABLED event and RSSISTOP task.
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Enable interrupt on READY event.
        constexpr uint32_t ADDRESS = (1U << 1);  ///< Enable interrupt on ADDRESS event.
        constexpr uint32_t PAYLOAD = (1U << 2);  ///< Enable interrupt on PAYLOAD event.
        constexpr uint32_t END = (1U << 3);  ///< Enable interrupt on END event.
        constexpr uint32_t DISABLED = (1U << 4);  ///< Enable interrupt on DISABLED event.
        constexpr uint32_t DEVMATCH = (1U << 5);  ///< Enable interrupt on DEVMATCH event.
        constexpr uint32_t DEVMISS = (1U << 6);  ///< Enable interrupt on DEVMISS event.
        constexpr uint32_t RSSIEND = (1U << 7);  ///< Enable interrupt on RSSIEND event.
        constexpr uint32_t BCMATCH = (1U << 10);  ///< Enable interrupt on BCMATCH event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Disable interrupt on READY event.
        constexpr uint32_t ADDRESS = (1U << 1);  ///< Disable interrupt on ADDRESS event.
        constexpr uint32_t PAYLOAD = (1U << 2);  ///< Disable interrupt on PAYLOAD event.
        constexpr uint32_t END = (1U << 3);  ///< Disable interrupt on END event.
        constexpr uint32_t DISABLED = (1U << 4);  ///< Disable interrupt on DISABLED event.
        constexpr uint32_t DEVMATCH = (1U << 5);  ///< Disable interrupt on DEVMATCH event.
        constexpr uint32_t DEVMISS = (1U << 6);  ///< Disable interrupt on DEVMISS event.
        constexpr uint32_t RSSIEND = (1U << 7);  ///< Disable interrupt on RSSIEND event.
        constexpr uint32_t BCMATCH = (1U << 10);  ///< Disable interrupt on BCMATCH event.
    }

    /// CRCSTATUS Register bits
    namespace crcstatus_bits {
        constexpr uint32_t CRCSTATUS = (1U << 0);  ///< CRC status of received packet.
    }

    /// RXMATCH Register bits
    namespace rxmatch_bits {
        constexpr uint32_t RXMATCH = (3 << 0);  ///< Logical address in which previous packet was received.
    }

    /// RXCRC Register bits
    namespace rxcrc_bits {
        constexpr uint32_t RXCRC = (24 << 0);  ///< CRC field of previously received packet.
    }

    /// DAI Register bits
    namespace dai_bits {
        constexpr uint32_t DAI = (3 << 0);  ///< Index (n) of device address (see DAB[n] and DAP[n]) that obtained an address match.
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (7 << 0);  ///< Radio channel frequency offset in MHz: RF Frequency = 2400 + FREQUENCY (MHz). Decision point: TXEN or RXEN task.
    }

    /// TXPOWER Register bits
    namespace txpower_bits {
        constexpr uint32_t TXPOWER = (8 << 0);  ///< Radio output power. Decision point: TXEN task.
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Radio data rate and modulation setting. Decision point: TXEN or RXEN task.
    }

    /// PCNF0 Register bits
    namespace pcnf0_bits {
        constexpr uint32_t LFLEN = (4 << 0);  ///< Length of length field in number of bits. Decision point: START task.
        constexpr uint32_t S0LEN = (1U << 8);  ///< Length of S0 field in number of bytes. Decision point: START task.
        constexpr uint32_t S1LEN = (4 << 16);  ///< Length of S1 field in number of bits. Decision point: START task.
    }

    /// PCNF1 Register bits
    namespace pcnf1_bits {
        constexpr uint32_t MAXLEN = (8 << 0);  ///< Maximum length of packet payload in number of bytes.
        constexpr uint32_t STATLEN = (8 << 8);  ///< Static length in number of bytes. Decision point: START task.
        constexpr uint32_t BALEN = (3 << 16);  ///< Base address length in number of bytes. Decision point: START task.
        constexpr uint32_t ENDIAN = (1U << 24);  ///< On air endianness of packet length field. Decision point: START task.
        constexpr uint32_t WHITEEN = (1U << 25);  ///< Packet whitening enable.
    }

    /// PREFIX0 Register bits
    namespace prefix0_bits {
        constexpr uint32_t AP0 = (8 << 0);  ///< Address prefix 0. Decision point: START task.
        constexpr uint32_t AP1 = (8 << 8);  ///< Address prefix 1. Decision point: START task.
        constexpr uint32_t AP2 = (8 << 16);  ///< Address prefix 2. Decision point: START task.
        constexpr uint32_t AP3 = (8 << 24);  ///< Address prefix 3. Decision point: START task.
    }

    /// PREFIX1 Register bits
    namespace prefix1_bits {
        constexpr uint32_t AP4 = (8 << 0);  ///< Address prefix 4. Decision point: START task.
        constexpr uint32_t AP5 = (8 << 8);  ///< Address prefix 5. Decision point: START task.
        constexpr uint32_t AP6 = (8 << 16);  ///< Address prefix 6. Decision point: START task.
        constexpr uint32_t AP7 = (8 << 24);  ///< Address prefix 7. Decision point: START task.
    }

    /// TXADDRESS Register bits
    namespace txaddress_bits {
        constexpr uint32_t TXADDRESS = (3 << 0);  ///< Logical address to be used when transmitting a packet. Decision point: START task.
    }

    /// RXADDRESSES Register bits
    namespace rxaddresses_bits {
        constexpr uint32_t ADDR0 = (1U << 0);  ///< Enable reception on logical address 0. Decision point: START task.
        constexpr uint32_t ADDR1 = (1U << 1);  ///< Enable reception on logical address 1. Decision point: START task.
        constexpr uint32_t ADDR2 = (1U << 2);  ///< Enable reception on logical address 2. Decision point: START task.
        constexpr uint32_t ADDR3 = (1U << 3);  ///< Enable reception on logical address 3. Decision point: START task.
        constexpr uint32_t ADDR4 = (1U << 4);  ///< Enable reception on logical address 4. Decision point: START task.
        constexpr uint32_t ADDR5 = (1U << 5);  ///< Enable reception on logical address 5. Decision point: START task.
        constexpr uint32_t ADDR6 = (1U << 6);  ///< Enable reception on logical address 6. Decision point: START task.
        constexpr uint32_t ADDR7 = (1U << 7);  ///< Enable reception on logical address 7. Decision point: START task.
    }

    /// CRCCNF Register bits
    namespace crccnf_bits {
        constexpr uint32_t LEN = (2 << 0);  ///< CRC length. Decision point: START task.
        constexpr uint32_t SKIPADDR = (1U << 8);  ///< Leave packet address field out of the CRC calculation. Decision point: START task.
    }

    /// CRCPOLY Register bits
    namespace crcpoly_bits {
        constexpr uint32_t CRCPOLY = (24 << 0);  ///< CRC polynomial. Decision point: START task.
    }

    /// CRCINIT Register bits
    namespace crcinit_bits {
        constexpr uint32_t CRCINIT = (24 << 0);  ///< Initial value for CRC calculation. Decision point: START task.
    }

    /// TEST Register bits
    namespace test_bits {
        constexpr uint32_t CONSTCARRIER = (1U << 0);  ///< Constant carrier. Decision point: TXEN task.
        constexpr uint32_t PLLLOCK = (1U << 1);  ///< PLL lock. Decision point: TXEN or RXEN task.
    }

    /// TIFS Register bits
    namespace tifs_bits {
        constexpr uint32_t TIFS = (8 << 0);  ///< Inter frame spacing in microseconds. Decision point: START rask
    }

    /// RSSISAMPLE Register bits
    namespace rssisample_bits {
        constexpr uint32_t RSSISAMPLE = (7 << 0);  ///< RSSI sample result. The result is read as a positive value so that ReceivedSignalStrength = -RSSISAMPLE dBm
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t STATE = (4 << 0);  ///< Current radio state.
    }

    /// DATAWHITEIV Register bits
    namespace datawhiteiv_bits {
        constexpr uint32_t DATAWHITEIV = (7 << 0);  ///< Data whitening initial value. Bit 0 corresponds to Position 0 of the LSFR, Bit 1 to position 5... Decision point: TXEN or RXEN task.
    }

    /// DAP[%s] Register bits
    namespace dap[%s]_bits {
        constexpr uint32_t DAP = (16 << 0);  ///< Device address prefix.
    }

    /// DACNF Register bits
    namespace dacnf_bits {
        constexpr uint32_t ENA0 = (1U << 0);  ///< Enable or disable device address matching using device address 0.
        constexpr uint32_t ENA1 = (1U << 1);  ///< Enable or disable device address matching using device address 1.
        constexpr uint32_t ENA2 = (1U << 2);  ///< Enable or disable device address matching using device address 2.
        constexpr uint32_t ENA3 = (1U << 3);  ///< Enable or disable device address matching using device address 3.
        constexpr uint32_t ENA4 = (1U << 4);  ///< Enable or disable device address matching using device address 4.
        constexpr uint32_t ENA5 = (1U << 5);  ///< Enable or disable device address matching using device address 5.
        constexpr uint32_t ENA6 = (1U << 6);  ///< Enable or disable device address matching using device address 6.
        constexpr uint32_t ENA7 = (1U << 7);  ///< Enable or disable device address matching using device address 7.
        constexpr uint32_t TXADD0 = (1U << 8);  ///< TxAdd for device address 0.
        constexpr uint32_t TXADD1 = (1U << 9);  ///< TxAdd for device address 1.
        constexpr uint32_t TXADD2 = (1U << 10);  ///< TxAdd for device address 2.
        constexpr uint32_t TXADD3 = (1U << 11);  ///< TxAdd for device address 3.
        constexpr uint32_t TXADD4 = (1U << 12);  ///< TxAdd for device address 4.
        constexpr uint32_t TXADD5 = (1U << 13);  ///< TxAdd for device address 5.
        constexpr uint32_t TXADD6 = (1U << 14);  ///< TxAdd for device address 6.
        constexpr uint32_t TXADD7 = (1U << 15);  ///< TxAdd for device address 7.
    }

    /// OVERRIDE0 Register bits
    namespace override0_bits {
        constexpr uint32_t OVERRIDE0 = (32 << 0);  ///< Trim value override 0.
    }

    /// OVERRIDE1 Register bits
    namespace override1_bits {
        constexpr uint32_t OVERRIDE1 = (32 << 0);  ///< Trim value override 1.
    }

    /// OVERRIDE2 Register bits
    namespace override2_bits {
        constexpr uint32_t OVERRIDE2 = (32 << 0);  ///< Trim value override 2.
    }

    /// OVERRIDE3 Register bits
    namespace override3_bits {
        constexpr uint32_t OVERRIDE3 = (32 << 0);  ///< Trim value override 3.
    }

    /// OVERRIDE4 Register bits
    namespace override4_bits {
        constexpr uint32_t OVERRIDE4 = (28 << 0);  ///< Trim value override 4.
        constexpr uint32_t ENABLE = (1U << 31);  ///< Enable or disable override of default trim values.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x40002000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTRX;  ///< Offset: 0x00 - Start UART receiver.
        volatile uint32_t TASKS_STOPRX;  ///< Offset: 0x04 - Stop UART receiver.
        volatile uint32_t TASKS_STARTTX;  ///< Offset: 0x08 - Start UART transmitter.
        volatile uint32_t TASKS_STOPTX;  ///< Offset: 0x0C - Stop UART transmitter.
        volatile uint32_t TASKS_SUSPEND;  ///< Offset: 0x1C - Suspend UART.
        volatile uint32_t EVENTS_CTS;  ///< Offset: 0x100 - CTS activated.
        volatile uint32_t EVENTS_NCTS;  ///< Offset: 0x104 - CTS deactivated.
        volatile uint32_t EVENTS_RXDRDY;  ///< Offset: 0x108 - Data received in RXD.
        volatile uint32_t EVENTS_TXDRDY;  ///< Offset: 0x11C - Data sent from TXD.
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x124 - Error detected.
        volatile uint32_t EVENTS_RXTO;  ///< Offset: 0x144 - Receiver timeout.
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts for UART.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t ERRORSRC;  ///< Offset: 0x480 - Error source. Write error field to 1 to clear error.
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable UART and acquire IOs.
        volatile uint32_t PSELRTS;  ///< Offset: 0x508 - Pin select for RTS.
        volatile uint32_t PSELTXD;  ///< Offset: 0x50C - Pin select for TXD.
        volatile uint32_t PSELCTS;  ///< Offset: 0x510 - Pin select for CTS.
        volatile uint32_t PSELRXD;  ///< Offset: 0x514 - Pin select for RXD.
        volatile uint32_t RXD;  ///< Offset: 0x518 - RXD register. On read action the buffer pointer is...
        volatile uint32_t TXD;  ///< Offset: 0x51C - TXD register.
        volatile uint32_t BAUDRATE;  ///< Offset: 0x524 - UART Baudrate.
        volatile uint32_t CONFIG;  ///< Offset: 0x56C - Configuration of parity and hardware flow control register.
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);

    // Bit definitions
    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t CTS_STARTRX = (1U << 3);  ///< Shortcut between CTS event and STARTRX task.
        constexpr uint32_t NCTS_STOPRX = (1U << 4);  ///< Shortcut between NCTS event and STOPRX task.
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t CTS = (1U << 0);  ///< Enable interrupt on CTS event.
        constexpr uint32_t NCTS = (1U << 1);  ///< Enable interrupt on NCTS event.
        constexpr uint32_t RXDRDY = (1U << 2);  ///< Enable interrupt on RXRDY event.
        constexpr uint32_t TXDRDY = (1U << 7);  ///< Enable interrupt on TXRDY event.
        constexpr uint32_t ERROR = (1U << 9);  ///< Enable interrupt on ERROR event.
        constexpr uint32_t RXTO = (1U << 17);  ///< Enable interrupt on RXTO event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t CTS = (1U << 0);  ///< Disable interrupt on CTS event.
        constexpr uint32_t NCTS = (1U << 1);  ///< Disable interrupt on NCTS event.
        constexpr uint32_t RXDRDY = (1U << 2);  ///< Disable interrupt on RXRDY event.
        constexpr uint32_t TXDRDY = (1U << 7);  ///< Disable interrupt on TXRDY event.
        constexpr uint32_t ERROR = (1U << 9);  ///< Disable interrupt on ERROR event.
        constexpr uint32_t RXTO = (1U << 17);  ///< Disable interrupt on RXTO event.
    }

    /// ERRORSRC Register bits
    namespace errorsrc_bits {
        constexpr uint32_t OVERRUN = (1U << 0);  ///< A start bit is received while the previous data still lies in RXD. (Data loss).
        constexpr uint32_t PARITY = (1U << 1);  ///< A character with bad parity is received. Only checked if HW parity control is enabled.
        constexpr uint32_t FRAMING = (1U << 2);  ///< A valid stop bit is not detected on the serial data input after all bits in a character have been received.
        constexpr uint32_t BREAK = (1U << 3);  ///< The serial data input is '0' for longer than the length of a data frame.
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (3 << 0);  ///< Enable or disable UART and acquire IOs.
    }

    /// RXD Register bits
    namespace rxd_bits {
        constexpr uint32_t RXD = (8 << 0);  ///< RX data from previous transfer. Double buffered.
    }

    /// TXD Register bits
    namespace txd_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< TX data for transfer.
    }

    /// BAUDRATE Register bits
    namespace baudrate_bits {
        constexpr uint32_t BAUDRATE = (32 << 0);  ///< UART baudrate.
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t HWFC = (1U << 0);  ///< Hardware flow control.
        constexpr uint32_t PARITY = (3 << 1);  ///< Include parity bit.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40003000;
    constexpr uint32_t SPI1_BASE = 0x40004000;
    constexpr uint32_t SPIS1_BASE = 0x40004000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t EVENTS_READY;  ///< Offset: 0x108 - TXD byte sent and RXD byte received.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable SPI.
        volatile uint32_t PSELSCK;  ///< Offset: 0x508 - Pin select for SCK.
        volatile uint32_t PSELMOSI;  ///< Offset: 0x50C - Pin select for MOSI.
        volatile uint32_t PSELMISO;  ///< Offset: 0x510 - Pin select for MISO.
        volatile uint32_t RXD;  ///< Offset: 0x518 - RX data.
        volatile uint32_t TXD;  ///< Offset: 0x51C - TX data.
        volatile uint32_t FREQUENCY;  ///< Offset: 0x524 - SPI frequency
        volatile uint32_t CONFIG;  ///< Offset: 0x554 - Configuration register.
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPIS1 = reinterpret_cast<Registers*>(SPIS1_BASE);

    // Bit definitions
    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 2);  ///< Enable interrupt on READY event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 2);  ///< Disable interrupt on READY event.
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (3 << 0);  ///< Enable or disable SPI.
    }

    /// RXD Register bits
    namespace rxd_bits {
        constexpr uint32_t RXD = (8 << 0);  ///< RX data from last transfer.
    }

    /// TXD Register bits
    namespace txd_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< TX data for next transfer.
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (32 << 0);  ///< SPI data rate.
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t ORDER = (1U << 0);  ///< Bit order.
        constexpr uint32_t CPHA = (1U << 1);  ///< Serial clock (SCK) phase.
        constexpr uint32_t CPOL = (1U << 2);  ///< Serial clock (SCK) polarity.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t TWI0_BASE = 0x40003000;
    constexpr uint32_t TWI1_BASE = 0x40004000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTRX;  ///< Offset: 0x00 - Start 2-Wire master receive sequence.
        volatile uint32_t TASKS_STARTTX;  ///< Offset: 0x08 - Start 2-Wire master transmit sequence.
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x14 - Stop 2-Wire transaction.
        volatile uint32_t TASKS_SUSPEND;  ///< Offset: 0x1C - Suspend 2-Wire transaction.
        volatile uint32_t TASKS_RESUME;  ///< Offset: 0x20 - Resume 2-Wire transaction.
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - Two-wire stopped.
        volatile uint32_t EVENTS_RXDREADY;  ///< Offset: 0x108 - Two-wire ready to deliver new RXD byte received.
        volatile uint32_t EVENTS_TXDSENT;  ///< Offset: 0x11C - Two-wire finished sending last TXD byte.
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x124 - Two-wire error detected.
        volatile uint32_t EVENTS_BB;  ///< Offset: 0x138 - Two-wire byte boundary.
        volatile uint32_t EVENTS_SUSPENDED;  ///< Offset: 0x148 - Two-wire suspended.
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts for TWI.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t ERRORSRC;  ///< Offset: 0x4C4 - Two-wire error source. Write error field to 1 to clear error.
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable two-wire master.
        volatile uint32_t PSELSCL;  ///< Offset: 0x508 - Pin select for SCL.
        volatile uint32_t PSELSDA;  ///< Offset: 0x50C - Pin select for SDA.
        volatile uint32_t RXD;  ///< Offset: 0x518 - RX data register.
        volatile uint32_t TXD;  ///< Offset: 0x51C - TX data register.
        volatile uint32_t FREQUENCY;  ///< Offset: 0x524 - Two-wire frequency.
        volatile uint32_t ADDRESS;  ///< Offset: 0x588 - Address used in the two-wire transfer.
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* TWI0 = reinterpret_cast<Registers*>(TWI0_BASE);
    inline Registers* TWI1 = reinterpret_cast<Registers*>(TWI1_BASE);

    // Bit definitions
    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t BB_SUSPEND = (1U << 0);  ///< Shortcut between BB event and the SUSPEND task.
        constexpr uint32_t BB_STOP = (1U << 1);  ///< Shortcut between BB event and the STOP task.
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Enable interrupt on STOPPED event.
        constexpr uint32_t RXDREADY = (1U << 2);  ///< Enable interrupt on READY event.
        constexpr uint32_t TXDSENT = (1U << 7);  ///< Enable interrupt on TXDSENT event.
        constexpr uint32_t ERROR = (1U << 9);  ///< Enable interrupt on ERROR event.
        constexpr uint32_t BB = (1U << 14);  ///< Enable interrupt on BB event.
        constexpr uint32_t SUSPENDED = (1U << 18);  ///< Enable interrupt on SUSPENDED event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Disable interrupt on STOPPED event.
        constexpr uint32_t RXDREADY = (1U << 2);  ///< Disable interrupt on RXDREADY event.
        constexpr uint32_t TXDSENT = (1U << 7);  ///< Disable interrupt on TXDSENT event.
        constexpr uint32_t ERROR = (1U << 9);  ///< Disable interrupt on ERROR event.
        constexpr uint32_t BB = (1U << 14);  ///< Disable interrupt on BB event.
        constexpr uint32_t SUSPENDED = (1U << 18);  ///< Disable interrupt on SUSPENDED event.
    }

    /// ERRORSRC Register bits
    namespace errorsrc_bits {
        constexpr uint32_t OVERRUN = (1U << 0);  ///< Byte received in RXD register before read of the last received byte (data loss).
        constexpr uint32_t ANACK = (1U << 1);  ///< NACK received after sending the address.
        constexpr uint32_t DNACK = (1U << 2);  ///< NACK received after sending a data byte.
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (3 << 0);  ///< Enable or disable W2M
    }

    /// RXD Register bits
    namespace rxd_bits {
        constexpr uint32_t RXD = (8 << 0);  ///< RX data from last transfer.
    }

    /// TXD Register bits
    namespace txd_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< TX data for next transfer.
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (32 << 0);  ///< Two-wire master clock frequency.
    }

    /// ADDRESS Register bits
    namespace address_bits {
        constexpr uint32_t ADDRESS = (7 << 0);  ///< Two-wire address.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOTE_BASE = 0x40006000;
    constexpr uint32_t GPIO_BASE = 0x50000000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t TASKS_OUT[%s];  ///< Offset: 0x00 - Tasks asssociated with GPIOTE channels.
        volatile uint32_t EVENTS_IN[%s];  ///< Offset: 0x100 - Tasks asssociated with GPIOTE channels.
        volatile uint32_t EVENTS_PORT;  ///< Offset: 0x17C - Event generated from multiple pins.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t CONFIG[%s];  ///< Offset: 0x510 - Channel configuration registers.
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* GPIOTE = reinterpret_cast<Registers*>(GPIOTE_BASE);
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);

    // Bit definitions
    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t IN0 = (1U << 0);  ///< Enable interrupt on IN[0] event.
        constexpr uint32_t IN1 = (1U << 1);  ///< Enable interrupt on IN[1] event.
        constexpr uint32_t IN2 = (1U << 2);  ///< Enable interrupt on IN[2] event.
        constexpr uint32_t IN3 = (1U << 3);  ///< Enable interrupt on IN[3] event.
        constexpr uint32_t PORT = (1U << 31);  ///< Enable interrupt on PORT event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t IN0 = (1U << 0);  ///< Disable interrupt on IN[0] event.
        constexpr uint32_t IN1 = (1U << 1);  ///< Disable interrupt on IN[1] event.
        constexpr uint32_t IN2 = (1U << 2);  ///< Disable interrupt on IN[2] event.
        constexpr uint32_t IN3 = (1U << 3);  ///< Disable interrupt on IN[3] event.
        constexpr uint32_t PORT = (1U << 31);  ///< Disable interrupt on PORT event.
    }

    /// CONFIG[%s] Register bits
    namespace config[%s]_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Mode
        constexpr uint32_t PSEL = (5 << 8);  ///< Pin select.
        constexpr uint32_t POLARITY = (2 << 16);  ///< Effects on output when in Task mode, or events on input that generates an event.
        constexpr uint32_t OUTINIT = (1U << 20);  ///< Initial value of the output when the GPIOTE channel is configured as a Task.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40007000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start an ADC conversion.
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop ADC.
        volatile uint32_t EVENTS_END;  ///< Offset: 0x100 - ADC conversion complete.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t BUSY;  ///< Offset: 0x400 - ADC busy register.
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - ADC enable.
        volatile uint32_t CONFIG;  ///< Offset: 0x504 - ADC configuration register.
        volatile uint32_t RESULT;  ///< Offset: 0x508 - Result of ADC conversion.
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t END = (1U << 0);  ///< Enable interrupt on END event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t END = (1U << 0);  ///< Disable interrupt on END event.
    }

    /// BUSY Register bits
    namespace busy_bits {
        constexpr uint32_t BUSY = (1U << 0);  ///< ADC busy register.
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (2 << 0);  ///< ADC enable.
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t RES = (2 << 0);  ///< ADC resolution.
        constexpr uint32_t INPSEL = (3 << 2);  ///< ADC input selection.
        constexpr uint32_t REFSEL = (2 << 5);  ///< ADC reference selection.
        constexpr uint32_t PSEL = (8 << 8);  ///< ADC analog pin selection.
        constexpr uint32_t EXTREFSEL = (2 << 16);  ///< ADC external reference pin selection.
    }

    /// RESULT Register bits
    namespace result_bits {
        constexpr uint32_t RESULT = (10 << 0);  ///< Result of ADC conversion.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER0_BASE = 0x40008000;
    constexpr uint32_t TIMER1_BASE = 0x40009000;
    constexpr uint32_t TIMER2_BASE = 0x4000A000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start Timer.
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop Timer.
        volatile uint32_t TASKS_COUNT;  ///< Offset: 0x08 - Increment Timer (In counter mode).
        volatile uint32_t TASKS_CLEAR;  ///< Offset: 0x0C - Clear timer.
        volatile uint32_t TASKS_SHUTDOWN;  ///< Offset: 0x10 - Shutdown timer.
        volatile uint32_t TASKS_CAPTURE[%s];  ///< Offset: 0x40 - Capture Timer value to CC[n] registers.
        volatile uint32_t EVENTS_COMPARE[%s];  ///< Offset: 0x140 - Compare event on CC[n] match.
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts for Timer.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t MODE;  ///< Offset: 0x504 - Timer Mode selection.
        volatile uint32_t BITMODE;  ///< Offset: 0x508 - Sets timer behaviour.
        volatile uint32_t PRESCALER;  ///< Offset: 0x510 - 4-bit prescaler to source clock frequency (max value 9)....
        volatile uint32_t CC[%s];  ///< Offset: 0x540 - Capture/compare registers.
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* TIMER0 = reinterpret_cast<Registers*>(TIMER0_BASE);
    inline Registers* TIMER1 = reinterpret_cast<Registers*>(TIMER1_BASE);
    inline Registers* TIMER2 = reinterpret_cast<Registers*>(TIMER2_BASE);

    // Bit definitions
    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t COMPARE0_CLEAR = (1U << 0);  ///< Shortcut between CC[0] event and the CLEAR task.
        constexpr uint32_t COMPARE1_CLEAR = (1U << 1);  ///< Shortcut between CC[1] event and the CLEAR task.
        constexpr uint32_t COMPARE2_CLEAR = (1U << 2);  ///< Shortcut between CC[2] event and the CLEAR task.
        constexpr uint32_t COMPARE3_CLEAR = (1U << 3);  ///< Shortcut between CC[3] event and the CLEAR task.
        constexpr uint32_t COMPARE0_STOP = (1U << 8);  ///< Shortcut between CC[0] event and the STOP task.
        constexpr uint32_t COMPARE1_STOP = (1U << 9);  ///< Shortcut between CC[1] event and the STOP task.
        constexpr uint32_t COMPARE2_STOP = (1U << 10);  ///< Shortcut between CC[2] event and the STOP task.
        constexpr uint32_t COMPARE3_STOP = (1U << 11);  ///< Shortcut between CC[3] event and the STOP task.
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Enable interrupt on COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Enable interrupt on COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Enable interrupt on COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Enable interrupt on COMPARE[3]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Disable interrupt on COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Disable interrupt on COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Disable interrupt on COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Disable interrupt on COMPARE[3]
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< Select Normal or Counter mode.
    }

    /// BITMODE Register bits
    namespace bitmode_bits {
        constexpr uint32_t BITMODE = (2 << 0);  ///< Sets timer behaviour ro be like the implementation of a timer with width as indicated.
    }

    /// PRESCALER Register bits
    namespace prescaler_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< Timer PRESCALER value. Max value is 9.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC0_BASE = 0x4000B000;
    constexpr uint32_t RTC1_BASE = 0x40011000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start RTC Counter.
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop RTC Counter.
        volatile uint32_t TASKS_CLEAR;  ///< Offset: 0x08 - Clear RTC Counter.
        volatile uint32_t TASKS_TRIGOVRFLW;  ///< Offset: 0x0C - Set COUNTER to 0xFFFFFFF0.
        volatile uint32_t EVENTS_TICK;  ///< Offset: 0x100 - Event on COUNTER increment.
        volatile uint32_t EVENTS_OVRFLW;  ///< Offset: 0x104 - Event on COUNTER overflow.
        volatile uint32_t EVENTS_COMPARE[%s];  ///< Offset: 0x140 - Compare event on CC[n] match.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t EVTEN;  ///< Offset: 0x340 - Configures event enable routing to PPI for each RTC event.
        volatile uint32_t EVTENSET;  ///< Offset: 0x344 - Enable events routing to PPI. The reading of this...
        volatile uint32_t EVTENCLR;  ///< Offset: 0x348 - Disable events routing to PPI. The reading of this...
        volatile uint32_t COUNTER;  ///< Offset: 0x504 - Current COUNTER value.
        volatile uint32_t PRESCALER;  ///< Offset: 0x508 - 12-bit prescaler for COUNTER frequency...
        volatile uint32_t CC[%s];  ///< Offset: 0x540 - Capture/compare registers.
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* RTC0 = reinterpret_cast<Registers*>(RTC0_BASE);
    inline Registers* RTC1 = reinterpret_cast<Registers*>(RTC1_BASE);

    // Bit definitions
    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Enable interrupt on TICK event.
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Enable interrupt on OVRFLW event.
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Enable interrupt on COMPARE[0] event.
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Enable interrupt on COMPARE[1] event.
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Enable interrupt on COMPARE[2] event.
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Enable interrupt on COMPARE[3] event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Disable interrupt on TICK event.
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Disable interrupt on OVRFLW event.
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Disable interrupt on COMPARE[0] event.
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Disable interrupt on COMPARE[1] event.
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Disable interrupt on COMPARE[2] event.
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Disable interrupt on COMPARE[3] event.
    }

    /// EVTEN Register bits
    namespace evten_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< TICK event enable.
        constexpr uint32_t OVRFLW = (1U << 1);  ///< OVRFLW event enable.
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< COMPARE[0] event enable.
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< COMPARE[1] event enable.
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< COMPARE[2] event enable.
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< COMPARE[3] event enable.
    }

    /// EVTENSET Register bits
    namespace evtenset_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Enable routing to PPI of TICK event.
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Enable routing to PPI of OVRFLW event.
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Enable routing to PPI of COMPARE[0] event.
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Enable routing to PPI of COMPARE[1] event.
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Enable routing to PPI of COMPARE[2] event.
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Enable routing to PPI of COMPARE[3] event.
    }

    /// EVTENCLR Register bits
    namespace evtenclr_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Disable routing to PPI of TICK event.
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Disable routing to PPI of OVRFLW event.
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Disable routing to PPI of COMPARE[0] event.
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Disable routing to PPI of COMPARE[1] event.
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Disable routing to PPI of COMPARE[2] event.
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Disable routing to PPI of COMPARE[3] event.
    }

    /// COUNTER Register bits
    namespace counter_bits {
        constexpr uint32_t COUNTER = (24 << 0);  ///< Counter value.
    }

    /// PRESCALER Register bits
    namespace prescaler_bits {
        constexpr uint32_t PRESCALER = (12 << 0);  ///< RTC PRESCALER value.
    }

    /// CC[%s] Register bits
    namespace cc[%s]_bits {
        constexpr uint32_t COMPARE = (24 << 0);  ///< Compare value.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// TEMP Peripheral
// ============================================================================

namespace temp {
    /// Base addresses
    constexpr uint32_t TEMP_BASE = 0x4000C000;

    /// TEMP Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start temperature measurement.
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop temperature measurement.
        volatile uint32_t EVENTS_DATARDY;  ///< Offset: 0x100 - Temperature measurement complete, data ready event.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t TEMP;  ///< Offset: 0x508 - Die temperature in degC, 2's complement format, 0.25...
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* TEMP = reinterpret_cast<Registers*>(TEMP_BASE);

    // Bit definitions
    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Enable interrupt on DATARDY event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Disable interrupt on DATARDY event.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x4000D000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start the random number generator.
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop the random number generator.
        volatile uint32_t EVENTS_VALRDY;  ///< Offset: 0x100 - New random number generated and written to VALUE register.
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts for the RNG.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register
        volatile uint32_t CONFIG;  ///< Offset: 0x504 - Configuration register.
        volatile uint32_t VALUE;  ///< Offset: 0x508 - RNG random number.
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

    // Bit definitions
    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t VALRDY_STOP = (1U << 0);  ///< Shortcut between VALRDY event and STOP task.
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t VALRDY = (1U << 0);  ///< Enable interrupt on VALRDY event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t VALRDY = (1U << 0);  ///< Disable interrupt on VALRDY event.
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t DERCEN = (1U << 0);  ///< Digital error correction enable.
    }

    /// VALUE Register bits
    namespace value_bits {
        constexpr uint32_t VALUE = (8 << 0);  ///< Generated random number.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// ECB Peripheral
// ============================================================================

namespace ecb {
    /// Base addresses
    constexpr uint32_t ECB_BASE = 0x4000E000;

    /// ECB Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTECB;  ///< Offset: 0x00 - Start ECB block encrypt. If a crypto operation is...
        volatile uint32_t TASKS_STOPECB;  ///< Offset: 0x04 - Stop current ECB encryption. If a crypto operation is...
        volatile uint32_t EVENTS_ENDECB;  ///< Offset: 0x100 - ECB block encrypt complete.
        volatile uint32_t EVENTS_ERRORECB;  ///< Offset: 0x104 - ECB block encrypt aborted due to a STOPECB task or due...
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t ECBDATAPTR;  ///< Offset: 0x504 - ECB block encrypt memory pointer.
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* ECB = reinterpret_cast<Registers*>(ECB_BASE);

    // Bit definitions
    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t ENDECB = (1U << 0);  ///< Enable interrupt on ENDECB event.
        constexpr uint32_t ERRORECB = (1U << 1);  ///< Enable interrupt on ERRORECB event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t ENDECB = (1U << 0);  ///< Disable interrupt on ENDECB event.
        constexpr uint32_t ERRORECB = (1U << 1);  ///< Disable interrupt on ERRORECB event.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// AAR Peripheral
// ============================================================================

namespace aar {
    /// Base addresses
    constexpr uint32_t AAR_BASE = 0x4000F000;

    /// AAR Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start resolving addresses based on IRKs specified in the...
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x08 - Stop resolving addresses.
        volatile uint32_t EVENTS_END;  ///< Offset: 0x100 - Address resolution procedure completed.
        volatile uint32_t EVENTS_RESOLVED;  ///< Offset: 0x104 - Address resolved.
        volatile uint32_t EVENTS_NOTRESOLVED;  ///< Offset: 0x108 - Address not resolved.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t STATUS;  ///< Offset: 0x400 - Resolution status.
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable AAR.
        volatile uint32_t NIRK;  ///< Offset: 0x504 - Number of Identity root Keys in the IRK data structure.
        volatile uint32_t IRKPTR;  ///< Offset: 0x508 - Pointer to the IRK data structure.
        volatile uint32_t ADDRPTR;  ///< Offset: 0x510 - Pointer to the resolvable address (6 bytes).
        volatile uint32_t SCRATCHPTR;  ///< Offset: 0x514 - Pointer to a scratch data area used for temporary...
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* AAR = reinterpret_cast<Registers*>(AAR_BASE);

    // Bit definitions
    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t END = (1U << 0);  ///< Enable interrupt on END event.
        constexpr uint32_t RESOLVED = (1U << 1);  ///< Enable interrupt on RESOLVED event.
        constexpr uint32_t NOTRESOLVED = (1U << 2);  ///< Enable interrupt on NOTRESOLVED event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t END = (1U << 0);  ///< Disable interrupt on ENDKSGEN event.
        constexpr uint32_t RESOLVED = (1U << 1);  ///< Disable interrupt on RESOLVED event.
        constexpr uint32_t NOTRESOLVED = (1U << 2);  ///< Disable interrupt on NOTRESOLVED event.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATUS = (4 << 0);  ///< The IRK used last time an address was resolved.
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (2 << 0);  ///< Enable AAR.
    }

    /// NIRK Register bits
    namespace nirk_bits {
        constexpr uint32_t NIRK = (5 << 0);  ///< Number of Identity root Keys in the IRK data structure.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// CCM Peripheral
// ============================================================================

namespace ccm {
    /// Base addresses
    constexpr uint32_t CCM_BASE = 0x4000F000;

    /// CCM Register structure
    struct Registers {
        volatile uint32_t TASKS_KSGEN;  ///< Offset: 0x00 - Start generation of key-stream. This operation will stop...
        volatile uint32_t TASKS_CRYPT;  ///< Offset: 0x04 - Start encrypt/decrypt. This operation will stop by...
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x08 - Stop encrypt/decrypt.
        volatile uint32_t EVENTS_ENDKSGEN;  ///< Offset: 0x100 - Keystream generation completed.
        volatile uint32_t EVENTS_ENDCRYPT;  ///< Offset: 0x104 - Encrypt/decrypt completed.
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x108 - Error happened.
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts for the CCM.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t MICSTATUS;  ///< Offset: 0x400 - CCM RX MIC check result.
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - CCM enable.
        volatile uint32_t MODE;  ///< Offset: 0x504 - Operation mode.
        volatile uint32_t CNFPTR;  ///< Offset: 0x508 - Pointer to a data structure holding AES key and NONCE vector.
        volatile uint32_t INPTR;  ///< Offset: 0x50C - Pointer to the input packet.
        volatile uint32_t OUTPTR;  ///< Offset: 0x510 - Pointer to the output packet.
        volatile uint32_t SCRATCHPTR;  ///< Offset: 0x514 - Pointer to a scratch data area used for temporary...
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* CCM = reinterpret_cast<Registers*>(CCM_BASE);

    // Bit definitions
    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t ENDKSGEN_CRYPT = (1U << 0);  ///< Shortcut between ENDKSGEN event and CRYPT task.
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t ENDKSGEN = (1U << 0);  ///< Enable interrupt on ENDKSGEN event.
        constexpr uint32_t ENDCRYPT = (1U << 1);  ///< Enable interrupt on ENDCRYPT event.
        constexpr uint32_t ERROR = (1U << 2);  ///< Enable interrupt on ERROR event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t ENDKSGEN = (1U << 0);  ///< Disable interrupt on ENDKSGEN event.
        constexpr uint32_t ENDCRYPT = (1U << 1);  ///< Disable interrupt on ENDCRYPT event.
        constexpr uint32_t ERROR = (1U << 2);  ///< Disable interrupt on ERROR event.
    }

    /// MICSTATUS Register bits
    namespace micstatus_bits {
        constexpr uint32_t MICSTATUS = (1U << 0);  ///< Result of the MIC check performed during the previous CCM RX STARTCRYPT
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (2 << 0);  ///< CCM enable.
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< CCM mode operation.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40010000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start the watchdog.
        volatile uint32_t EVENTS_TIMEOUT;  ///< Offset: 0x100 - Watchdog timeout.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t RUNSTATUS;  ///< Offset: 0x400 - Watchdog running status.
        volatile uint32_t REQSTATUS;  ///< Offset: 0x404 - Request status.
        volatile uint32_t CRV;  ///< Offset: 0x504 - Counter reload value in number of 32kiHz clock cycles.
        volatile uint32_t RREN;  ///< Offset: 0x508 - Reload request enable.
        volatile uint32_t CONFIG;  ///< Offset: 0x50C - Configuration register.
        volatile uint32_t RR[%s];  ///< Offset: 0x600 - Reload requests registers.
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TIMEOUT = (1U << 0);  ///< Enable interrupt on TIMEOUT event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TIMEOUT = (1U << 0);  ///< Disable interrupt on TIMEOUT event.
    }

    /// RUNSTATUS Register bits
    namespace runstatus_bits {
        constexpr uint32_t RUNSTATUS = (1U << 0);  ///< Watchdog running status.
    }

    /// REQSTATUS Register bits
    namespace reqstatus_bits {
        constexpr uint32_t RR0 = (1U << 0);  ///< Request status for RR[0].
        constexpr uint32_t RR1 = (1U << 1);  ///< Request status for RR[1].
        constexpr uint32_t RR2 = (1U << 2);  ///< Request status for RR[2].
        constexpr uint32_t RR3 = (1U << 3);  ///< Request status for RR[3].
        constexpr uint32_t RR4 = (1U << 4);  ///< Request status for RR[4].
        constexpr uint32_t RR5 = (1U << 5);  ///< Request status for RR[5].
        constexpr uint32_t RR6 = (1U << 6);  ///< Request status for RR[6].
        constexpr uint32_t RR7 = (1U << 7);  ///< Request status for RR[7].
    }

    /// RREN Register bits
    namespace rren_bits {
        constexpr uint32_t RR0 = (1U << 0);  ///< Enable or disable RR[0] register.
        constexpr uint32_t RR1 = (1U << 1);  ///< Enable or disable RR[1] register.
        constexpr uint32_t RR2 = (1U << 2);  ///< Enable or disable RR[2] register.
        constexpr uint32_t RR3 = (1U << 3);  ///< Enable or disable RR[3] register.
        constexpr uint32_t RR4 = (1U << 4);  ///< Enable or disable RR[4] register.
        constexpr uint32_t RR5 = (1U << 5);  ///< Enable or disable RR[5] register.
        constexpr uint32_t RR6 = (1U << 6);  ///< Enable or disable RR[6] register.
        constexpr uint32_t RR7 = (1U << 7);  ///< Enable or disable RR[7] register.
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t SLEEP = (1U << 0);  ///< Configure the watchdog to pause or not while the CPU is sleeping.
        constexpr uint32_t HALT = (1U << 3);  ///< Configure the watchdog to pause or not while the CPU is halted by the debugger.
    }

    /// RR[%s] Register bits
    namespace rr[%s]_bits {
        constexpr uint32_t RR = (32 << 0);  ///< Reload register.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// QDEC Peripheral
// ============================================================================

namespace qdec {
    /// Base addresses
    constexpr uint32_t QDEC_BASE = 0x40012000;

    /// QDEC Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start the quadrature decoder.
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop the quadrature decoder.
        volatile uint32_t TASKS_READCLRACC;  ///< Offset: 0x08 - Transfers the content from ACC registers to ACCREAD...
        volatile uint32_t EVENTS_SAMPLERDY;  ///< Offset: 0x100 - A new sample is written to the sample register.
        volatile uint32_t EVENTS_REPORTRDY;  ///< Offset: 0x104 - REPORTPER number of samples accumulated in ACC register,...
        volatile uint32_t EVENTS_ACCOF;  ///< Offset: 0x108 - ACC or ACCDBL register overflow.
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts for the QDEC.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable the QDEC.
        volatile uint32_t LEDPOL;  ///< Offset: 0x504 - LED output pin polarity.
        volatile uint32_t SAMPLEPER;  ///< Offset: 0x508 - Sample period.
        volatile uint32_t SAMPLE;  ///< Offset: 0x50C - Motion sample value.
        volatile uint32_t REPORTPER;  ///< Offset: 0x510 - Number of samples to generate an EVENT_REPORTRDY.
        volatile uint32_t ACC;  ///< Offset: 0x514 - Accumulated valid transitions register.
        volatile uint32_t ACCREAD;  ///< Offset: 0x518 - Snapshot of ACC register. Value generated by the...
        volatile uint32_t PSELLED;  ///< Offset: 0x51C - Pin select for LED output.
        volatile uint32_t PSELA;  ///< Offset: 0x520 - Pin select for phase A input.
        volatile uint32_t PSELB;  ///< Offset: 0x524 - Pin select for phase B input.
        volatile uint32_t DBFEN;  ///< Offset: 0x528 - Enable debouncer input filters.
        volatile uint32_t LEDPRE;  ///< Offset: 0x540 - Time LED is switched ON before the sample.
        volatile uint32_t ACCDBL;  ///< Offset: 0x544 - Accumulated double (error) transitions register.
        volatile uint32_t ACCDBLREAD;  ///< Offset: 0x548 - Snapshot of ACCDBL register. Value generated by the...
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* QDEC = reinterpret_cast<Registers*>(QDEC_BASE);

    // Bit definitions
    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t REPORTRDY_READCLRACC = (1U << 0);  ///< Shortcut between REPORTRDY event and READCLRACC task.
        constexpr uint32_t SAMPLERDY_STOP = (1U << 1);  ///< Shortcut between SAMPLERDY event and STOP task.
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t SAMPLERDY = (1U << 0);  ///< Enable interrupt on SAMPLERDY event.
        constexpr uint32_t REPORTRDY = (1U << 1);  ///< Enable interrupt on REPORTRDY event.
        constexpr uint32_t ACCOF = (1U << 2);  ///< Enable interrupt on ACCOF event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t SAMPLERDY = (1U << 0);  ///< Disable interrupt on SAMPLERDY event.
        constexpr uint32_t REPORTRDY = (1U << 1);  ///< Disable interrupt on REPORTRDY event.
        constexpr uint32_t ACCOF = (1U << 2);  ///< Disable interrupt on ACCOF event.
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable QDEC.
    }

    /// LEDPOL Register bits
    namespace ledpol_bits {
        constexpr uint32_t LEDPOL = (1U << 0);  ///< LED output pin polarity.
    }

    /// SAMPLEPER Register bits
    namespace sampleper_bits {
        constexpr uint32_t SAMPLEPER = (3 << 0);  ///< Sample period.
    }

    /// SAMPLE Register bits
    namespace sample_bits {
        constexpr uint32_t SAMPLE = (32 << 0);  ///< Last sample taken in compliment to 2.
    }

    /// REPORTPER Register bits
    namespace reportper_bits {
        constexpr uint32_t REPORTPER = (3 << 0);  ///< Number of samples to generate an EVENT_REPORTRDY.
    }

    /// DBFEN Register bits
    namespace dbfen_bits {
        constexpr uint32_t DBFEN = (1U << 0);  ///< Enable debounce input filters.
    }

    /// LEDPRE Register bits
    namespace ledpre_bits {
        constexpr uint32_t LEDPRE = (9 << 0);  ///< Period in us the LED in switched on prior to sampling.
    }

    /// ACCDBL Register bits
    namespace accdbl_bits {
        constexpr uint32_t ACCDBL = (4 << 0);  ///< Accumulated double (error) transitions.
    }

    /// ACCDBLREAD Register bits
    namespace accdblread_bits {
        constexpr uint32_t ACCDBLREAD = (4 << 0);  ///< Snapshot of accumulated double (error) transitions.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// LPCOMP Peripheral
// ============================================================================

namespace lpcomp {
    /// Base addresses
    constexpr uint32_t LPCOMP_BASE = 0x40013000;

    /// LPCOMP Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start the comparator.
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop the comparator.
        volatile uint32_t TASKS_SAMPLE;  ///< Offset: 0x08 - Sample comparator value.
        volatile uint32_t EVENTS_READY;  ///< Offset: 0x100 - LPCOMP is ready and output is valid.
        volatile uint32_t EVENTS_DOWN;  ///< Offset: 0x104 - Input voltage crossed the threshold going down.
        volatile uint32_t EVENTS_UP;  ///< Offset: 0x108 - Input voltage crossed the threshold going up.
        volatile uint32_t EVENTS_CROSS;  ///< Offset: 0x10C - Input voltage crossed the threshold in any direction.
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts for the LPCOMP.
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Interrupt enable set register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Interrupt enable clear register.
        volatile uint32_t RESULT;  ///< Offset: 0x400 - Result of last compare.
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable the LPCOMP.
        volatile uint32_t PSEL;  ///< Offset: 0x504 - Input pin select.
        volatile uint32_t REFSEL;  ///< Offset: 0x508 - Reference select.
        volatile uint32_t EXTREFSEL;  ///< Offset: 0x50C - External reference select.
        volatile uint32_t ANADETECT;  ///< Offset: 0x520 - Analog detect configuration.
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control.
    };

    /// Peripheral instances
    inline Registers* LPCOMP = reinterpret_cast<Registers*>(LPCOMP_BASE);

    // Bit definitions
    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t READY_SAMPLE = (1U << 0);  ///< Shortcut between READY event and SAMPLE task.
        constexpr uint32_t READY_STOP = (1U << 1);  ///< Shortcut between RADY event and STOP task.
        constexpr uint32_t DOWN_STOP = (1U << 2);  ///< Shortcut between DOWN event and STOP task.
        constexpr uint32_t UP_STOP = (1U << 3);  ///< Shortcut between UP event and STOP task.
        constexpr uint32_t CROSS_STOP = (1U << 4);  ///< Shortcut between CROSS event and STOP task.
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Enable interrupt on READY event.
        constexpr uint32_t DOWN = (1U << 1);  ///< Enable interrupt on DOWN event.
        constexpr uint32_t UP = (1U << 2);  ///< Enable interrupt on UP event.
        constexpr uint32_t CROSS = (1U << 3);  ///< Enable interrupt on CROSS event.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Disable interrupt on READY event.
        constexpr uint32_t DOWN = (1U << 1);  ///< Disable interrupt on DOWN event.
        constexpr uint32_t UP = (1U << 2);  ///< Disable interrupt on UP event.
        constexpr uint32_t CROSS = (1U << 3);  ///< Disable interrupt on CROSS event.
    }

    /// RESULT Register bits
    namespace result_bits {
        constexpr uint32_t RESULT = (1U << 0);  ///< Result of last compare. Decision point SAMPLE task.
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (2 << 0);  ///< Enable or disable LPCOMP.
    }

    /// PSEL Register bits
    namespace psel_bits {
        constexpr uint32_t PSEL = (3 << 0);  ///< Analog input pin select.
    }

    /// REFSEL Register bits
    namespace refsel_bits {
        constexpr uint32_t REFSEL = (3 << 0);  ///< Reference select.
    }

    /// EXTREFSEL Register bits
    namespace extrefsel_bits {
        constexpr uint32_t EXTREFSEL = (1U << 0);  ///< External analog reference pin selection.
    }

    /// ANADETECT Register bits
    namespace anadetect_bits {
        constexpr uint32_t ANADETECT = (2 << 0);  ///< Analog detect configuration.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control.
    }

}

// ============================================================================
// SWI Peripheral
// ============================================================================

namespace swi {
    /// Base addresses
    constexpr uint32_t SWI_BASE = 0x40014000;

    /// SWI Register structure
    struct Registers {
        volatile uint32_t UNUSED;  ///< Offset: 0x00 - Unused.
    };

    /// Peripheral instances
    inline Registers* SWI = reinterpret_cast<Registers*>(SWI_BASE);

}

// ============================================================================
// NVMC Peripheral
// ============================================================================

namespace nvmc {
    /// Base addresses
    constexpr uint32_t NVMC_BASE = 0x4001E000;

    /// NVMC Register structure
    struct Registers {
        volatile uint32_t READY;  ///< Offset: 0x400 - Ready flag.
        volatile uint32_t CONFIG;  ///< Offset: 0x504 - Configuration register.
        volatile uint32_t ERASEPAGE;  ///< Offset: 0x508 - Register for erasing a non-protected non-volatile memory page.
        volatile uint32_t ERASEPCR1;  ///< Offset: 0x508 - Register for erasing a non-protected non-volatile memory page.
        volatile uint32_t ERASEALL;  ///< Offset: 0x50C - Register for erasing all non-volatile user memory.
        volatile uint32_t ERASEPCR0;  ///< Offset: 0x510 - Register for erasing a protected non-volatile memory page.
        volatile uint32_t ERASEUICR;  ///< Offset: 0x514 - Register for start erasing User Information...
    };

    /// Peripheral instances
    inline Registers* NVMC = reinterpret_cast<Registers*>(NVMC_BASE);

    // Bit definitions
    /// READY Register bits
    namespace ready_bits {
        constexpr uint32_t READY = (1U << 0);  ///< NVMC ready.
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t WEN = (2 << 0);  ///< Program write enable.
    }

    /// ERASEALL Register bits
    namespace eraseall_bits {
        constexpr uint32_t ERASEALL = (1U << 0);  ///< Starts the erasing of all user NVM (code region 0/1 and UICR registers).
    }

    /// ERASEUICR Register bits
    namespace eraseuicr_bits {
        constexpr uint32_t ERASEUICR = (1U << 0);  ///< It can only be used when all contents of code region 1 are erased.
    }

}

// ============================================================================
// PPI Peripheral
// ============================================================================

namespace ppi {
    /// Base addresses
    constexpr uint32_t PPI_BASE = 0x4001F000;

    /// PPI Register structure
    struct Registers {
        volatile uint32_t EN;  ///< Offset: 0x00 - Enable channel group.
        volatile uint32_t DIS;  ///< Offset: 0x04 - Disable channel group.
        volatile uint32_t CHEN;  ///< Offset: 0x500 - Channel enable.
        volatile uint32_t CHENSET;  ///< Offset: 0x504 - Channel enable set.
        volatile uint32_t CHENCLR;  ///< Offset: 0x508 - Channel enable clear.
        volatile uint32_t EEP;  ///< Offset: 0x00 - Channel event end-point.
        volatile uint32_t TEP;  ///< Offset: 0x04 - Channel task end-point.
        volatile uint32_t CHG[%s];  ///< Offset: 0x800 - Channel group configuration.
    };

    /// Peripheral instances
    inline Registers* PPI = reinterpret_cast<Registers*>(PPI_BASE);

    // Bit definitions
    /// CHEN Register bits
    namespace chen_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Enable PPI channel 0.
        constexpr uint32_t CH1 = (1U << 1);  ///< Enable PPI channel 1.
        constexpr uint32_t CH2 = (1U << 2);  ///< Enable PPI channel 2.
        constexpr uint32_t CH3 = (1U << 3);  ///< Enable PPI channel 3.
        constexpr uint32_t CH4 = (1U << 4);  ///< Enable PPI channel 4.
        constexpr uint32_t CH5 = (1U << 5);  ///< Enable PPI channel 5.
        constexpr uint32_t CH6 = (1U << 6);  ///< Enable PPI channel 6.
        constexpr uint32_t CH7 = (1U << 7);  ///< Enable PPI channel 7.
        constexpr uint32_t CH8 = (1U << 8);  ///< Enable PPI channel 8.
        constexpr uint32_t CH9 = (1U << 9);  ///< Enable PPI channel 9.
        constexpr uint32_t CH10 = (1U << 10);  ///< Enable PPI channel 10.
        constexpr uint32_t CH11 = (1U << 11);  ///< Enable PPI channel 11.
        constexpr uint32_t CH12 = (1U << 12);  ///< Enable PPI channel 12.
        constexpr uint32_t CH13 = (1U << 13);  ///< Enable PPI channel 13.
        constexpr uint32_t CH14 = (1U << 14);  ///< Enable PPI channel 14.
        constexpr uint32_t CH15 = (1U << 15);  ///< Enable PPI channel 15.
        constexpr uint32_t CH20 = (1U << 20);  ///< Enable PPI channel 20.
        constexpr uint32_t CH21 = (1U << 21);  ///< Enable PPI channel 21.
        constexpr uint32_t CH22 = (1U << 22);  ///< Enable PPI channel 22.
        constexpr uint32_t CH23 = (1U << 23);  ///< Enable PPI channel 23.
        constexpr uint32_t CH24 = (1U << 24);  ///< Enable PPI channel 24.
        constexpr uint32_t CH25 = (1U << 25);  ///< Enable PPI channel 25.
        constexpr uint32_t CH26 = (1U << 26);  ///< Enable PPI channel 26.
        constexpr uint32_t CH27 = (1U << 27);  ///< Enable PPI channel 27.
        constexpr uint32_t CH28 = (1U << 28);  ///< Enable PPI channel 28.
        constexpr uint32_t CH29 = (1U << 29);  ///< Enable PPI channel 29.
        constexpr uint32_t CH30 = (1U << 30);  ///< Enable PPI channel 30.
        constexpr uint32_t CH31 = (1U << 31);  ///< Enable PPI channel 31.
    }

    /// CHENSET Register bits
    namespace chenset_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Enable PPI channel 0.
        constexpr uint32_t CH1 = (1U << 1);  ///< Enable PPI channel 1.
        constexpr uint32_t CH2 = (1U << 2);  ///< Enable PPI channel 2.
        constexpr uint32_t CH3 = (1U << 3);  ///< Enable PPI channel 3.
        constexpr uint32_t CH4 = (1U << 4);  ///< Enable PPI channel 4.
        constexpr uint32_t CH5 = (1U << 5);  ///< Enable PPI channel 5.
        constexpr uint32_t CH6 = (1U << 6);  ///< Enable PPI channel 6.
        constexpr uint32_t CH7 = (1U << 7);  ///< Enable PPI channel 7.
        constexpr uint32_t CH8 = (1U << 8);  ///< Enable PPI channel 8.
        constexpr uint32_t CH9 = (1U << 9);  ///< Enable PPI channel 9.
        constexpr uint32_t CH10 = (1U << 10);  ///< Enable PPI channel 10.
        constexpr uint32_t CH11 = (1U << 11);  ///< Enable PPI channel 11.
        constexpr uint32_t CH12 = (1U << 12);  ///< Enable PPI channel 12.
        constexpr uint32_t CH13 = (1U << 13);  ///< Enable PPI channel 13.
        constexpr uint32_t CH14 = (1U << 14);  ///< Enable PPI channel 14.
        constexpr uint32_t CH15 = (1U << 15);  ///< Enable PPI channel 15.
        constexpr uint32_t CH20 = (1U << 20);  ///< Enable PPI channel 20.
        constexpr uint32_t CH21 = (1U << 21);  ///< Enable PPI channel 21.
        constexpr uint32_t CH22 = (1U << 22);  ///< Enable PPI channel 22.
        constexpr uint32_t CH23 = (1U << 23);  ///< Enable PPI channel 23.
        constexpr uint32_t CH24 = (1U << 24);  ///< Enable PPI channel 24.
        constexpr uint32_t CH25 = (1U << 25);  ///< Enable PPI channel 25.
        constexpr uint32_t CH26 = (1U << 26);  ///< Enable PPI channel 26.
        constexpr uint32_t CH27 = (1U << 27);  ///< Enable PPI channel 27.
        constexpr uint32_t CH28 = (1U << 28);  ///< Enable PPI channel 28.
        constexpr uint32_t CH29 = (1U << 29);  ///< Enable PPI channel 29.
        constexpr uint32_t CH30 = (1U << 30);  ///< Enable PPI channel 30.
        constexpr uint32_t CH31 = (1U << 31);  ///< Enable PPI channel 31.
    }

    /// CHENCLR Register bits
    namespace chenclr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Disable PPI channel 0.
        constexpr uint32_t CH1 = (1U << 1);  ///< Disable PPI channel 1.
        constexpr uint32_t CH2 = (1U << 2);  ///< Disable PPI channel 2.
        constexpr uint32_t CH3 = (1U << 3);  ///< Disable PPI channel 3.
        constexpr uint32_t CH4 = (1U << 4);  ///< Disable PPI channel 4.
        constexpr uint32_t CH5 = (1U << 5);  ///< Disable PPI channel 5.
        constexpr uint32_t CH6 = (1U << 6);  ///< Disable PPI channel 6.
        constexpr uint32_t CH7 = (1U << 7);  ///< Disable PPI channel 7.
        constexpr uint32_t CH8 = (1U << 8);  ///< Disable PPI channel 8.
        constexpr uint32_t CH9 = (1U << 9);  ///< Disable PPI channel 9.
        constexpr uint32_t CH10 = (1U << 10);  ///< Disable PPI channel 10.
        constexpr uint32_t CH11 = (1U << 11);  ///< Disable PPI channel 11.
        constexpr uint32_t CH12 = (1U << 12);  ///< Disable PPI channel 12.
        constexpr uint32_t CH13 = (1U << 13);  ///< Disable PPI channel 13.
        constexpr uint32_t CH14 = (1U << 14);  ///< Disable PPI channel 14.
        constexpr uint32_t CH15 = (1U << 15);  ///< Disable PPI channel 15.
        constexpr uint32_t CH20 = (1U << 20);  ///< Disable PPI channel 20.
        constexpr uint32_t CH21 = (1U << 21);  ///< Disable PPI channel 21.
        constexpr uint32_t CH22 = (1U << 22);  ///< Disable PPI channel 22.
        constexpr uint32_t CH23 = (1U << 23);  ///< Disable PPI channel 23.
        constexpr uint32_t CH24 = (1U << 24);  ///< Disable PPI channel 24.
        constexpr uint32_t CH25 = (1U << 25);  ///< Disable PPI channel 25.
        constexpr uint32_t CH26 = (1U << 26);  ///< Disable PPI channel 26.
        constexpr uint32_t CH27 = (1U << 27);  ///< Disable PPI channel 27.
        constexpr uint32_t CH28 = (1U << 28);  ///< Disable PPI channel 28.
        constexpr uint32_t CH29 = (1U << 29);  ///< Disable PPI channel 29.
        constexpr uint32_t CH30 = (1U << 30);  ///< Disable PPI channel 30.
        constexpr uint32_t CH31 = (1U << 31);  ///< Disable PPI channel 31.
    }

    /// CHG[%s] Register bits
    namespace chg[%s]_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Include CH0 in channel group.
        constexpr uint32_t CH1 = (1U << 1);  ///< Include CH1 in channel group.
        constexpr uint32_t CH2 = (1U << 2);  ///< Include CH2 in channel group.
        constexpr uint32_t CH3 = (1U << 3);  ///< Include CH3 in channel group.
        constexpr uint32_t CH4 = (1U << 4);  ///< Include CH4 in channel group.
        constexpr uint32_t CH5 = (1U << 5);  ///< Include CH5 in channel group.
        constexpr uint32_t CH6 = (1U << 6);  ///< Include CH6 in channel group.
        constexpr uint32_t CH7 = (1U << 7);  ///< Include CH7 in channel group.
        constexpr uint32_t CH8 = (1U << 8);  ///< Include CH8 in channel group.
        constexpr uint32_t CH9 = (1U << 9);  ///< Include CH9 in channel group.
        constexpr uint32_t CH10 = (1U << 10);  ///< Include CH10 in channel group.
        constexpr uint32_t CH11 = (1U << 11);  ///< Include CH11 in channel group.
        constexpr uint32_t CH12 = (1U << 12);  ///< Include CH12 in channel group.
        constexpr uint32_t CH13 = (1U << 13);  ///< Include CH13 in channel group.
        constexpr uint32_t CH14 = (1U << 14);  ///< Include CH14 in channel group.
        constexpr uint32_t CH15 = (1U << 15);  ///< Include CH15 in channel group.
        constexpr uint32_t CH20 = (1U << 20);  ///< Include CH20 in channel group.
        constexpr uint32_t CH21 = (1U << 21);  ///< Include CH21 in channel group.
        constexpr uint32_t CH22 = (1U << 22);  ///< Include CH22 in channel group.
        constexpr uint32_t CH23 = (1U << 23);  ///< Include CH23 in channel group.
        constexpr uint32_t CH24 = (1U << 24);  ///< Include CH24 in channel group.
        constexpr uint32_t CH25 = (1U << 25);  ///< Include CH25 in channel group.
        constexpr uint32_t CH26 = (1U << 26);  ///< Include CH26 in channel group.
        constexpr uint32_t CH27 = (1U << 27);  ///< Include CH27 in channel group.
        constexpr uint32_t CH28 = (1U << 28);  ///< Include CH28 in channel group.
        constexpr uint32_t CH29 = (1U << 29);  ///< Include CH29 in channel group.
        constexpr uint32_t CH30 = (1U << 30);  ///< Include CH30 in channel group.
        constexpr uint32_t CH31 = (1U << 31);  ///< Include CH31 in channel group.
    }

}

// ============================================================================
// FICR Peripheral
// ============================================================================

namespace ficr {
    /// Base addresses
    constexpr uint32_t FICR_BASE = 0x10000000;

    /// FICR Register structure
    struct Registers {
        volatile uint32_t CODEPAGESIZE;  ///< Offset: 0x10 - Code memory page size in bytes.
        volatile uint32_t CODESIZE;  ///< Offset: 0x14 - Code memory size in pages.
        volatile uint32_t CLENR0;  ///< Offset: 0x28 - Length of code region 0 in bytes.
        volatile uint32_t PPFC;  ///< Offset: 0x2C - Pre-programmed factory code present.
        volatile uint32_t NUMRAMBLOCK;  ///< Offset: 0x34 - Number of individualy controllable RAM blocks.
        volatile uint32_t SIZERAMBLOCKS;  ///< Offset: 0x38 - Size of RAM blocks in bytes.
        volatile uint32_t SIZERAMBLOCK[%s];  ///< Offset: 0x38 - Deprecated array of size of RAM block in bytes. This...
        volatile uint32_t CONFIGID;  ///< Offset: 0x5C - Configuration identifier.
        volatile uint32_t DEVICEID[%s];  ///< Offset: 0x60 - Device identifier.
        volatile uint32_t ER[%s];  ///< Offset: 0x80 - Encryption root.
        volatile uint32_t IR[%s];  ///< Offset: 0x90 - Identity root.
        volatile uint32_t DEVICEADDRTYPE;  ///< Offset: 0xA0 - Device address type.
        volatile uint32_t DEVICEADDR[%s];  ///< Offset: 0xA4 - Device address.
        volatile uint32_t OVERRIDEEN;  ///< Offset: 0xAC - Radio calibration override enable.
        volatile uint32_t NRF_1MBIT[%s];  ///< Offset: 0xB0 - Override values for the OVERRIDEn registers in RADIO for...
        volatile uint32_t BLE_1MBIT[%s];  ///< Offset: 0xEC - Override values for the OVERRIDEn registers in RADIO for...
    };

    /// Peripheral instances
    inline Registers* FICR = reinterpret_cast<Registers*>(FICR_BASE);

    // Bit definitions
    /// PPFC Register bits
    namespace ppfc_bits {
        constexpr uint32_t PPFC = (8 << 0);  ///< Pre-programmed factory code present.
    }

    /// CONFIGID Register bits
    namespace configid_bits {
        constexpr uint32_t HWID = (16 << 0);  ///< Hardware Identification Number.
        constexpr uint32_t FWID = (16 << 16);  ///< Firmware Identification Number pre-loaded into the flash.
    }

    /// DEVICEADDRTYPE Register bits
    namespace deviceaddrtype_bits {
        constexpr uint32_t DEVICEADDRTYPE = (1U << 0);  ///< Device address type.
    }

    /// OVERRIDEEN Register bits
    namespace overrideen_bits {
        constexpr uint32_t NRF_1MBIT = (1U << 0);  ///< Override default values for NRF_1Mbit mode.
        constexpr uint32_t BLE_1MBIT = (1U << 3);  ///< Override default values for BLE_1Mbit mode.
    }

}

// ============================================================================
// UICR Peripheral
// ============================================================================

namespace uicr {
    /// Base addresses
    constexpr uint32_t UICR_BASE = 0x10001000;

    /// UICR Register structure
    struct Registers {
        volatile uint32_t CLENR0;  ///< Offset: 0x00 - Length of code region 0.
        volatile uint32_t RBPCONF;  ///< Offset: 0x04 - Readback protection configuration.
        volatile uint32_t XTALFREQ;  ///< Offset: 0x08 - Reset value for CLOCK XTALFREQ register.
        volatile uint32_t FWID;  ///< Offset: 0x10 - Firmware ID.
        volatile uint32_t BOOTLOADERADDR;  ///< Offset: 0x14 - Bootloader start address.
        volatile uint32_t NRFFW[%s];  ///< Offset: 0x14 - Reserved for Nordic firmware design.
        volatile uint32_t NRFHW[%s];  ///< Offset: 0x50 - Reserved for Nordic hardware design.
        volatile uint32_t CUSTOMER[%s];  ///< Offset: 0x80 - Reserved for customer.
    };

    /// Peripheral instances
    inline Registers* UICR = reinterpret_cast<Registers*>(UICR_BASE);

    // Bit definitions
    /// RBPCONF Register bits
    namespace rbpconf_bits {
        constexpr uint32_t PR0 = (8 << 0);  ///< Readback protect region 0. Will be ignored if pre-programmed factory code is present on the chip.
        constexpr uint32_t PALL = (8 << 8);  ///< Readback protect all code in the device.
    }

    /// XTALFREQ Register bits
    namespace xtalfreq_bits {
        constexpr uint32_t XTALFREQ = (8 << 0);  ///< Reset value for CLOCK XTALFREQ register.
    }

    /// FWID Register bits
    namespace fwid_bits {
        constexpr uint32_t FWID = (16 << 0);  ///< Identification number for the firmware loaded into the chip.
    }

}


} // namespace alloy::generated::nrf51

#endif // ALLOY_GENERATED_NRF51_PERIPHERALS_HPP