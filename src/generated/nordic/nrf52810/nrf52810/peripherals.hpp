/// Auto-generated code for nrf52810
/// Generated by Alloy Code Generator
/// Source: nordic_nrf52810.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:50
#ifndef ALLOY_GENERATED_NRF52810_PERIPHERALS_HPP
#define ALLOY_GENERATED_NRF52810_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::nrf52810 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_ficr = true;
    constexpr uint32_t num_ficr_instances = 1;
    constexpr bool has_uicr = true;
    constexpr uint32_t num_uicr_instances = 1;
    constexpr bool has_bprot = true;
    constexpr uint32_t num_bprot_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_p0 = true;
    constexpr uint32_t num_p0_instances = 1;
    constexpr bool has_radio = true;
    constexpr uint32_t num_radio_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 3;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 3;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 2;
    constexpr bool has_temp = true;
    constexpr uint32_t num_temp_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_ecb = true;
    constexpr uint32_t num_ecb_instances = 1;
    constexpr bool has_aar = true;
    constexpr uint32_t num_aar_instances = 1;
    constexpr bool has_ccm = true;
    constexpr uint32_t num_ccm_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_qdec = true;
    constexpr uint32_t num_qdec_instances = 1;
    constexpr bool has_comp = true;
    constexpr uint32_t num_comp_instances = 1;
    constexpr bool has_egu0 = true;
    constexpr uint32_t num_egu0_instances = 1;
    constexpr bool has_swi0 = true;
    constexpr uint32_t num_swi0_instances = 1;
    constexpr bool has_egu1 = true;
    constexpr uint32_t num_egu1_instances = 1;
    constexpr bool has_swi1 = true;
    constexpr uint32_t num_swi1_instances = 1;
    constexpr bool has_swi2 = true;
    constexpr uint32_t num_swi2_instances = 1;
    constexpr bool has_swi3 = true;
    constexpr uint32_t num_swi3_instances = 1;
    constexpr bool has_swi4 = true;
    constexpr uint32_t num_swi4_instances = 1;
    constexpr bool has_swi5 = true;
    constexpr uint32_t num_swi5_instances = 1;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 1;
    constexpr bool has_pdm = true;
    constexpr uint32_t num_pdm_instances = 1;
    constexpr bool has_nvmc = true;
    constexpr uint32_t num_nvmc_instances = 1;
    constexpr bool has_ppi = true;
    constexpr uint32_t num_ppi_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct ficr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct uicr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bprot_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct p0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct radio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct temp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ecb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aar_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct qdec_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct comp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct egu0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct egu1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi5_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pdm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ppi_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 1;
    constexpr uint32_t max_gpio_pins = 16;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uarte0 = true;
}

// ============================================================================
// FICR Peripheral
// ============================================================================

namespace ficr {
    /// Base addresses
    constexpr uint32_t FICR_BASE = 0x10000000;

    /// FICR Register structure
    struct Registers {
        volatile uint32_t CODEPAGESIZE;  ///< Offset: 0x10 - Code memory page size
        volatile uint32_t CODESIZE;  ///< Offset: 0x14 - Code memory size
        volatile uint32_t DEVICEID[%s];  ///< Offset: 0x60 - Description collection: Device identifier
        volatile uint32_t ER[%s];  ///< Offset: 0x80 - Description collection: Encryption root, word n
        volatile uint32_t IR[%s];  ///< Offset: 0x90 - Description collection: Identity root, word n
        volatile uint32_t DEVICEADDRTYPE;  ///< Offset: 0xA0 - Device address type
        volatile uint32_t DEVICEADDR[%s];  ///< Offset: 0xA4 - Description collection: Device address n
        volatile uint32_t PART;  ///< Offset: 0x00 - Part code
        volatile uint32_t VARIANT;  ///< Offset: 0x04 - Part variant, hardware version and production configuration
        volatile uint32_t PACKAGE;  ///< Offset: 0x08 - Package option
        volatile uint32_t RAM;  ///< Offset: 0x0C - RAM variant
        volatile uint32_t FLASH;  ///< Offset: 0x10 - Flash variant
        volatile uint32_t A0;  ///< Offset: 0x00 - Slope definition A0
        volatile uint32_t A1;  ///< Offset: 0x04 - Slope definition A1
        volatile uint32_t A2;  ///< Offset: 0x08 - Slope definition A2
        volatile uint32_t A3;  ///< Offset: 0x0C - Slope definition A3
        volatile uint32_t A4;  ///< Offset: 0x10 - Slope definition A4
        volatile uint32_t A5;  ///< Offset: 0x14 - Slope definition A5
        volatile uint32_t B0;  ///< Offset: 0x18 - Y-intercept B0
        volatile uint32_t B1;  ///< Offset: 0x1C - Y-intercept B1
        volatile uint32_t B2;  ///< Offset: 0x20 - Y-intercept B2
        volatile uint32_t B3;  ///< Offset: 0x24 - Y-intercept B3
        volatile uint32_t B4;  ///< Offset: 0x28 - Y-intercept B4
        volatile uint32_t B5;  ///< Offset: 0x2C - Y-intercept B5
        volatile uint32_t T0;  ///< Offset: 0x30 - Segment end T0
        volatile uint32_t T1;  ///< Offset: 0x34 - Segment end T1
        volatile uint32_t T2;  ///< Offset: 0x38 - Segment end T2
        volatile uint32_t T3;  ///< Offset: 0x3C - Segment end T3
        volatile uint32_t T4;  ///< Offset: 0x40 - Segment end T4
    };

    /// Peripheral instances
    inline Registers* FICR = reinterpret_cast<Registers*>(FICR_BASE);

    // Bit definitions
    /// CODEPAGESIZE Register bits
    namespace codepagesize_bits {
        constexpr uint32_t CODEPAGESIZE = (32 << 0);  ///< Code memory page size
    }

    /// CODESIZE Register bits
    namespace codesize_bits {
        constexpr uint32_t CODESIZE = (32 << 0);  ///< Code memory size in number of pages
    }

    /// DEVICEID[%s] Register bits
    namespace deviceid[%s]_bits {
        constexpr uint32_t DEVICEID = (32 << 0);  ///< 64 bit unique device identifier
    }

    /// ER[%s] Register bits
    namespace er[%s]_bits {
        constexpr uint32_t ER = (32 << 0);  ///< Encryption root, word n
    }

    /// IR[%s] Register bits
    namespace ir[%s]_bits {
        constexpr uint32_t IR = (32 << 0);  ///< Identity root, word n
    }

    /// DEVICEADDRTYPE Register bits
    namespace deviceaddrtype_bits {
        constexpr uint32_t DEVICEADDRTYPE = (1U << 0);  ///< Device address type
    }

    /// DEVICEADDR[%s] Register bits
    namespace deviceaddr[%s]_bits {
        constexpr uint32_t DEVICEADDR = (32 << 0);  ///< 48 bit device address
    }

    /// PART Register bits
    namespace part_bits {
        constexpr uint32_t PART = (32 << 0);  ///< Part code
    }

    /// VARIANT Register bits
    namespace variant_bits {
        constexpr uint32_t VARIANT = (32 << 0);  ///< Part variant, hardware version and production configuration, encoded as ASCII
    }

    /// PACKAGE Register bits
    namespace package_bits {
        constexpr uint32_t PACKAGE = (32 << 0);  ///< Package option
    }

    /// RAM Register bits
    namespace ram_bits {
        constexpr uint32_t RAM = (32 << 0);  ///< RAM variant
    }

    /// FLASH Register bits
    namespace flash_bits {
        constexpr uint32_t FLASH = (32 << 0);  ///< Flash variant
    }

    /// A0 Register bits
    namespace a0_bits {
        constexpr uint32_t A = (12 << 0);  ///< A (slope definition) register
    }

    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t A = (12 << 0);  ///< A (slope definition) register
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t A = (12 << 0);  ///< A (slope definition) register
    }

    /// A3 Register bits
    namespace a3_bits {
        constexpr uint32_t A = (12 << 0);  ///< A (slope definition) register
    }

    /// A4 Register bits
    namespace a4_bits {
        constexpr uint32_t A = (12 << 0);  ///< A (slope definition) register
    }

    /// A5 Register bits
    namespace a5_bits {
        constexpr uint32_t A = (12 << 0);  ///< A (slope definition) register
    }

    /// B0 Register bits
    namespace b0_bits {
        constexpr uint32_t B = (14 << 0);  ///< B (y-intercept)
    }

    /// B1 Register bits
    namespace b1_bits {
        constexpr uint32_t B = (14 << 0);  ///< B (y-intercept)
    }

    /// B2 Register bits
    namespace b2_bits {
        constexpr uint32_t B = (14 << 0);  ///< B (y-intercept)
    }

    /// B3 Register bits
    namespace b3_bits {
        constexpr uint32_t B = (14 << 0);  ///< B (y-intercept)
    }

    /// B4 Register bits
    namespace b4_bits {
        constexpr uint32_t B = (14 << 0);  ///< B (y-intercept)
    }

    /// B5 Register bits
    namespace b5_bits {
        constexpr uint32_t B = (14 << 0);  ///< B (y-intercept)
    }

    /// T0 Register bits
    namespace t0_bits {
        constexpr uint32_t T = (8 << 0);  ///< T (segment end) register
    }

    /// T1 Register bits
    namespace t1_bits {
        constexpr uint32_t T = (8 << 0);  ///< T (segment end) register
    }

    /// T2 Register bits
    namespace t2_bits {
        constexpr uint32_t T = (8 << 0);  ///< T (segment end) register
    }

    /// T3 Register bits
    namespace t3_bits {
        constexpr uint32_t T = (8 << 0);  ///< T (segment end) register
    }

    /// T4 Register bits
    namespace t4_bits {
        constexpr uint32_t T = (8 << 0);  ///< T (segment end) register
    }

}

// ============================================================================
// UICR Peripheral
// ============================================================================

namespace uicr {
    /// Base addresses
    constexpr uint32_t UICR_BASE = 0x10001000;

    /// UICR Register structure
    struct Registers {
        volatile uint32_t NRFFW[%s];  ///< Offset: 0x14 - Description collection: Reserved for Nordic firmware design
        volatile uint32_t NRFHW[%s];  ///< Offset: 0x50 - Description collection: Reserved for Nordic hardware design
        volatile uint32_t CUSTOMER[%s];  ///< Offset: 0x80 - Description collection: Reserved for customer
        volatile uint32_t PSELRESET[%s];  ///< Offset: 0x200 - Description collection: Mapping of the nRESET function...
        volatile uint32_t APPROTECT;  ///< Offset: 0x208 - Access port protection
    };

    /// Peripheral instances
    inline Registers* UICR = reinterpret_cast<Registers*>(UICR_BASE);

    // Bit definitions
    /// NRFFW[%s] Register bits
    namespace nrffw[%s]_bits {
        constexpr uint32_t NRFFW = (32 << 0);  ///< Reserved for Nordic firmware design
    }

    /// NRFHW[%s] Register bits
    namespace nrfhw[%s]_bits {
        constexpr uint32_t NRFHW = (32 << 0);  ///< Reserved for Nordic hardware design
    }

    /// CUSTOMER[%s] Register bits
    namespace customer[%s]_bits {
        constexpr uint32_t CUSTOMER = (32 << 0);  ///< Reserved for customer
    }

    /// PSELRESET[%s] Register bits
    namespace pselreset[%s]_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< GPIO pin number onto which nRESET is exposed
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// APPROTECT Register bits
    namespace approtect_bits {
        constexpr uint32_t PALL = (8 << 0);  ///< Enable or disable access port protection.
    }

}

// ============================================================================
// BPROT Peripheral
// ============================================================================

namespace bprot {
    /// Base addresses
    constexpr uint32_t BPROT_BASE = 0x40000000;

    /// BPROT Register structure
    struct Registers {
        volatile uint32_t CONFIG0;  ///< Offset: 0x600 - Block protect configuration register 0
        volatile uint32_t CONFIG1;  ///< Offset: 0x604 - Block protect configuration register 1
        volatile uint32_t DISABLEINDEBUG;  ///< Offset: 0x608 - Disable protection mechanism in debug mode
    };

    /// Peripheral instances
    inline Registers* BPROT = reinterpret_cast<Registers*>(BPROT_BASE);

    // Bit definitions
    /// CONFIG0 Register bits
    namespace config0_bits {
        constexpr uint32_t REGION0 = (1U << 0);  ///< Enable protection for region 0. Write '0' has no effect.
        constexpr uint32_t REGION1 = (1U << 1);  ///< Enable protection for region 1. Write '0' has no effect.
        constexpr uint32_t REGION2 = (1U << 2);  ///< Enable protection for region 2. Write '0' has no effect.
        constexpr uint32_t REGION3 = (1U << 3);  ///< Enable protection for region 3. Write '0' has no effect.
        constexpr uint32_t REGION4 = (1U << 4);  ///< Enable protection for region 4. Write '0' has no effect.
        constexpr uint32_t REGION5 = (1U << 5);  ///< Enable protection for region 5. Write '0' has no effect.
        constexpr uint32_t REGION6 = (1U << 6);  ///< Enable protection for region 6. Write '0' has no effect.
        constexpr uint32_t REGION7 = (1U << 7);  ///< Enable protection for region 7. Write '0' has no effect.
        constexpr uint32_t REGION8 = (1U << 8);  ///< Enable protection for region 8. Write '0' has no effect.
        constexpr uint32_t REGION9 = (1U << 9);  ///< Enable protection for region 9. Write '0' has no effect.
        constexpr uint32_t REGION10 = (1U << 10);  ///< Enable protection for region 10. Write '0' has no effect.
        constexpr uint32_t REGION11 = (1U << 11);  ///< Enable protection for region 11. Write '0' has no effect.
        constexpr uint32_t REGION12 = (1U << 12);  ///< Enable protection for region 12. Write '0' has no effect.
        constexpr uint32_t REGION13 = (1U << 13);  ///< Enable protection for region 13. Write '0' has no effect.
        constexpr uint32_t REGION14 = (1U << 14);  ///< Enable protection for region 14. Write '0' has no effect.
        constexpr uint32_t REGION15 = (1U << 15);  ///< Enable protection for region 15. Write '0' has no effect.
        constexpr uint32_t REGION16 = (1U << 16);  ///< Enable protection for region 16. Write '0' has no effect.
        constexpr uint32_t REGION17 = (1U << 17);  ///< Enable protection for region 17. Write '0' has no effect.
        constexpr uint32_t REGION18 = (1U << 18);  ///< Enable protection for region 18. Write '0' has no effect.
        constexpr uint32_t REGION19 = (1U << 19);  ///< Enable protection for region 19. Write '0' has no effect.
        constexpr uint32_t REGION20 = (1U << 20);  ///< Enable protection for region 20. Write '0' has no effect.
        constexpr uint32_t REGION21 = (1U << 21);  ///< Enable protection for region 21. Write '0' has no effect.
        constexpr uint32_t REGION22 = (1U << 22);  ///< Enable protection for region 22. Write '0' has no effect.
        constexpr uint32_t REGION23 = (1U << 23);  ///< Enable protection for region 23. Write '0' has no effect.
        constexpr uint32_t REGION24 = (1U << 24);  ///< Enable protection for region 24. Write '0' has no effect.
        constexpr uint32_t REGION25 = (1U << 25);  ///< Enable protection for region 25. Write '0' has no effect.
        constexpr uint32_t REGION26 = (1U << 26);  ///< Enable protection for region 26. Write '0' has no effect.
        constexpr uint32_t REGION27 = (1U << 27);  ///< Enable protection for region 27. Write '0' has no effect.
        constexpr uint32_t REGION28 = (1U << 28);  ///< Enable protection for region 28. Write '0' has no effect.
        constexpr uint32_t REGION29 = (1U << 29);  ///< Enable protection for region 29. Write '0' has no effect.
        constexpr uint32_t REGION30 = (1U << 30);  ///< Enable protection for region 30. Write '0' has no effect.
        constexpr uint32_t REGION31 = (1U << 31);  ///< Enable protection for region 31. Write '0' has no effect.
    }

    /// CONFIG1 Register bits
    namespace config1_bits {
        constexpr uint32_t REGION32 = (1U << 0);  ///< Enable protection for region 32. Write '0' has no effect.
        constexpr uint32_t REGION33 = (1U << 1);  ///< Enable protection for region 33. Write '0' has no effect.
        constexpr uint32_t REGION34 = (1U << 2);  ///< Enable protection for region 34. Write '0' has no effect.
        constexpr uint32_t REGION35 = (1U << 3);  ///< Enable protection for region 35. Write '0' has no effect.
        constexpr uint32_t REGION36 = (1U << 4);  ///< Enable protection for region 36. Write '0' has no effect.
        constexpr uint32_t REGION37 = (1U << 5);  ///< Enable protection for region 37. Write '0' has no effect.
        constexpr uint32_t REGION38 = (1U << 6);  ///< Enable protection for region 38. Write '0' has no effect.
        constexpr uint32_t REGION39 = (1U << 7);  ///< Enable protection for region 39. Write '0' has no effect.
        constexpr uint32_t REGION40 = (1U << 8);  ///< Enable protection for region 40. Write '0' has no effect.
        constexpr uint32_t REGION41 = (1U << 9);  ///< Enable protection for region 41. Write '0' has no effect.
        constexpr uint32_t REGION42 = (1U << 10);  ///< Enable protection for region 42. Write '0' has no effect.
        constexpr uint32_t REGION43 = (1U << 11);  ///< Enable protection for region 43. Write '0' has no effect.
        constexpr uint32_t REGION44 = (1U << 12);  ///< Enable protection for region 44. Write '0' has no effect.
        constexpr uint32_t REGION45 = (1U << 13);  ///< Enable protection for region 45. Write '0' has no effect.
        constexpr uint32_t REGION46 = (1U << 14);  ///< Enable protection for region 46. Write '0' has no effect.
        constexpr uint32_t REGION47 = (1U << 15);  ///< Enable protection for region 47. Write '0' has no effect.
    }

    /// DISABLEINDEBUG Register bits
    namespace disableindebug_bits {
        constexpr uint32_t DISABLEINDEBUG = (1U << 0);  ///< Disable the protection mechanism for NVM regions while in debug mode. This register will only disable the protection mechanism if the device is in debug mode.
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t CLOCK_BASE = 0x40000000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t TASKS_HFCLKSTART;  ///< Offset: 0x00 - Start HFCLK crystal oscillator
        volatile uint32_t TASKS_HFCLKSTOP;  ///< Offset: 0x04 - Stop HFCLK crystal oscillator
        volatile uint32_t TASKS_LFCLKSTART;  ///< Offset: 0x08 - Start LFCLK source
        volatile uint32_t TASKS_LFCLKSTOP;  ///< Offset: 0x0C - Stop LFCLK source
        volatile uint32_t TASKS_CAL;  ///< Offset: 0x10 - Start calibration of LFRC oscillator
        volatile uint32_t TASKS_CTSTART;  ///< Offset: 0x14 - Start calibration timer
        volatile uint32_t TASKS_CTSTOP;  ///< Offset: 0x18 - Stop calibration timer
        volatile uint32_t EVENTS_HFCLKSTARTED;  ///< Offset: 0x100 - HFCLK oscillator started
        volatile uint32_t EVENTS_LFCLKSTARTED;  ///< Offset: 0x104 - LFCLK started
        volatile uint32_t EVENTS_DONE;  ///< Offset: 0x10C - Calibration of LFCLK RC oscillator complete event
        volatile uint32_t EVENTS_CTTO;  ///< Offset: 0x110 - Calibration timer timeout
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t HFCLKRUN;  ///< Offset: 0x408 - Status indicating that HFCLKSTART task has been triggered
        volatile uint32_t HFCLKSTAT;  ///< Offset: 0x40C - HFCLK status
        volatile uint32_t LFCLKRUN;  ///< Offset: 0x414 - Status indicating that LFCLKSTART task has been triggered
        volatile uint32_t LFCLKSTAT;  ///< Offset: 0x418 - LFCLK status
        volatile uint32_t LFCLKSRCCOPY;  ///< Offset: 0x41C - Copy of LFCLKSRC register, set when LFCLKSTART task was triggered
        volatile uint32_t LFCLKSRC;  ///< Offset: 0x518 - Clock source for the LFCLK
        volatile uint32_t CTIV;  ///< Offset: 0x538 - Calibration timer interval
    };

    /// Peripheral instances
    inline Registers* CLOCK = reinterpret_cast<Registers*>(CLOCK_BASE);

    // Bit definitions
    /// TASKS_HFCLKSTART Register bits
    namespace tasks_hfclkstart_bits {
        constexpr uint32_t TASKS_HFCLKSTART = (1U << 0);  ///< Start HFCLK crystal oscillator
    }

    /// TASKS_HFCLKSTOP Register bits
    namespace tasks_hfclkstop_bits {
        constexpr uint32_t TASKS_HFCLKSTOP = (1U << 0);  ///< Stop HFCLK crystal oscillator
    }

    /// TASKS_LFCLKSTART Register bits
    namespace tasks_lfclkstart_bits {
        constexpr uint32_t TASKS_LFCLKSTART = (1U << 0);  ///< Start LFCLK source
    }

    /// TASKS_LFCLKSTOP Register bits
    namespace tasks_lfclkstop_bits {
        constexpr uint32_t TASKS_LFCLKSTOP = (1U << 0);  ///< Stop LFCLK source
    }

    /// TASKS_CAL Register bits
    namespace tasks_cal_bits {
        constexpr uint32_t TASKS_CAL = (1U << 0);  ///< Start calibration of LFRC oscillator
    }

    /// TASKS_CTSTART Register bits
    namespace tasks_ctstart_bits {
        constexpr uint32_t TASKS_CTSTART = (1U << 0);  ///< Start calibration timer
    }

    /// TASKS_CTSTOP Register bits
    namespace tasks_ctstop_bits {
        constexpr uint32_t TASKS_CTSTOP = (1U << 0);  ///< Stop calibration timer
    }

    /// EVENTS_HFCLKSTARTED Register bits
    namespace events_hfclkstarted_bits {
        constexpr uint32_t EVENTS_HFCLKSTARTED = (1U << 0);  ///< HFCLK oscillator started
    }

    /// EVENTS_LFCLKSTARTED Register bits
    namespace events_lfclkstarted_bits {
        constexpr uint32_t EVENTS_LFCLKSTARTED = (1U << 0);  ///< LFCLK started
    }

    /// EVENTS_DONE Register bits
    namespace events_done_bits {
        constexpr uint32_t EVENTS_DONE = (1U << 0);  ///< Calibration of LFCLK RC oscillator complete event
    }

    /// EVENTS_CTTO Register bits
    namespace events_ctto_bits {
        constexpr uint32_t EVENTS_CTTO = (1U << 0);  ///< Calibration timer timeout
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Write '1' to enable interrupt for event HFCLKSTARTED
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Write '1' to enable interrupt for event LFCLKSTARTED
        constexpr uint32_t DONE = (1U << 3);  ///< Write '1' to enable interrupt for event DONE
        constexpr uint32_t CTTO = (1U << 4);  ///< Write '1' to enable interrupt for event CTTO
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Write '1' to disable interrupt for event HFCLKSTARTED
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Write '1' to disable interrupt for event LFCLKSTARTED
        constexpr uint32_t DONE = (1U << 3);  ///< Write '1' to disable interrupt for event DONE
        constexpr uint32_t CTTO = (1U << 4);  ///< Write '1' to disable interrupt for event CTTO
    }

    /// HFCLKRUN Register bits
    namespace hfclkrun_bits {
        constexpr uint32_t STATUS = (1U << 0);  ///< HFCLKSTART task triggered or not
    }

    /// HFCLKSTAT Register bits
    namespace hfclkstat_bits {
        constexpr uint32_t SRC = (1U << 0);  ///< Source of HFCLK
        constexpr uint32_t STATE = (1U << 16);  ///< HFCLK state
    }

    /// LFCLKRUN Register bits
    namespace lfclkrun_bits {
        constexpr uint32_t STATUS = (1U << 0);  ///< LFCLKSTART task triggered or not
    }

    /// LFCLKSTAT Register bits
    namespace lfclkstat_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Source of LFCLK
        constexpr uint32_t STATE = (1U << 16);  ///< LFCLK state
    }

    /// LFCLKSRCCOPY Register bits
    namespace lfclksrccopy_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Clock source
    }

    /// LFCLKSRC Register bits
    namespace lfclksrc_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Clock source
        constexpr uint32_t BYPASS = (1U << 16);  ///< Enable or disable bypass of LFCLK crystal oscillator with external clock source
        constexpr uint32_t EXTERNAL = (1U << 17);  ///< Enable or disable external source for LFCLK
    }

    /// CTIV Register bits
    namespace ctiv_bits {
        constexpr uint32_t CTIV = (7 << 0);  ///< Calibration timer interval in multiple of 0.25 seconds. Range: 0.25 seconds to 31.75 seconds.
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t POWER_BASE = 0x40000000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t TASKS_CONSTLAT;  ///< Offset: 0x78 - Enable Constant Latency mode
        volatile uint32_t TASKS_LOWPWR;  ///< Offset: 0x7C - Enable Low-power mode (variable latency)
        volatile uint32_t EVENTS_POFWARN;  ///< Offset: 0x108 - Power failure warning
        volatile uint32_t EVENTS_SLEEPENTER;  ///< Offset: 0x114 - CPU entered WFI/WFE sleep
        volatile uint32_t EVENTS_SLEEPEXIT;  ///< Offset: 0x118 - CPU exited WFI/WFE sleep
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t RESETREAS;  ///< Offset: 0x400 - Reset reason
        volatile uint32_t SYSTEMOFF;  ///< Offset: 0x500 - System OFF register
        volatile uint32_t POFCON;  ///< Offset: 0x510 - Power failure comparator configuration
        volatile uint32_t GPREGRET;  ///< Offset: 0x51C - General purpose retention register
        volatile uint32_t GPREGRET2;  ///< Offset: 0x520 - General purpose retention register
        volatile uint32_t DCDCEN;  ///< Offset: 0x578 - DC/DC enable register
        volatile uint32_t POWER;  ///< Offset: 0x00 - Description cluster: RAMn power control register. The...
        volatile uint32_t POWERSET;  ///< Offset: 0x04 - Description cluster: RAMn power control set register
        volatile uint32_t POWERCLR;  ///< Offset: 0x08 - Description cluster: RAMn power control clear register
    };

    /// Peripheral instances
    inline Registers* POWER = reinterpret_cast<Registers*>(POWER_BASE);

    // Bit definitions
    /// TASKS_CONSTLAT Register bits
    namespace tasks_constlat_bits {
        constexpr uint32_t TASKS_CONSTLAT = (1U << 0);  ///< Enable Constant Latency mode
    }

    /// TASKS_LOWPWR Register bits
    namespace tasks_lowpwr_bits {
        constexpr uint32_t TASKS_LOWPWR = (1U << 0);  ///< Enable Low-power mode (variable latency)
    }

    /// EVENTS_POFWARN Register bits
    namespace events_pofwarn_bits {
        constexpr uint32_t EVENTS_POFWARN = (1U << 0);  ///< Power failure warning
    }

    /// EVENTS_SLEEPENTER Register bits
    namespace events_sleepenter_bits {
        constexpr uint32_t EVENTS_SLEEPENTER = (1U << 0);  ///< CPU entered WFI/WFE sleep
    }

    /// EVENTS_SLEEPEXIT Register bits
    namespace events_sleepexit_bits {
        constexpr uint32_t EVENTS_SLEEPEXIT = (1U << 0);  ///< CPU exited WFI/WFE sleep
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t POFWARN = (1U << 2);  ///< Write '1' to enable interrupt for event POFWARN
        constexpr uint32_t SLEEPENTER = (1U << 5);  ///< Write '1' to enable interrupt for event SLEEPENTER
        constexpr uint32_t SLEEPEXIT = (1U << 6);  ///< Write '1' to enable interrupt for event SLEEPEXIT
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t POFWARN = (1U << 2);  ///< Write '1' to disable interrupt for event POFWARN
        constexpr uint32_t SLEEPENTER = (1U << 5);  ///< Write '1' to disable interrupt for event SLEEPENTER
        constexpr uint32_t SLEEPEXIT = (1U << 6);  ///< Write '1' to disable interrupt for event SLEEPEXIT
    }

    /// RESETREAS Register bits
    namespace resetreas_bits {
        constexpr uint32_t RESETPIN = (1U << 0);  ///< Reset from pin-reset detected
        constexpr uint32_t DOG = (1U << 1);  ///< Reset from watchdog detected
        constexpr uint32_t SREQ = (1U << 2);  ///< Reset from soft reset detected
        constexpr uint32_t LOCKUP = (1U << 3);  ///< Reset from CPU lock-up detected
        constexpr uint32_t OFF = (1U << 16);  ///< Reset due to wake up from System OFF mode when wakeup is triggered from DETECT signal from GPIO
        constexpr uint32_t DIF = (1U << 18);  ///< Reset due to wake up from System OFF mode when wakeup is triggered from entering into debug interface mode
    }

    /// SYSTEMOFF Register bits
    namespace systemoff_bits {
        constexpr uint32_t SYSTEMOFF = (1U << 0);  ///< Enable System OFF mode
    }

    /// POFCON Register bits
    namespace pofcon_bits {
        constexpr uint32_t POF = (1U << 0);  ///< Enable or disable power failure comparator
        constexpr uint32_t THRESHOLD = (4 << 1);  ///< Power failure comparator threshold setting
    }

    /// GPREGRET Register bits
    namespace gpregret_bits {
        constexpr uint32_t GPREGRET = (8 << 0);  ///< General purpose retention register
    }

    /// GPREGRET2 Register bits
    namespace gpregret2_bits {
        constexpr uint32_t GPREGRET = (8 << 0);  ///< General purpose retention register
    }

    /// DCDCEN Register bits
    namespace dcdcen_bits {
        constexpr uint32_t DCDCEN = (1U << 0);  ///< Enable or disable DC/DC converter
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t S0POWER = (1U << 0);  ///< Keep RAM section S0 ON or OFF in System ON mode.
        constexpr uint32_t S1POWER = (1U << 1);  ///< Keep RAM section S1 ON or OFF in System ON mode.
        constexpr uint32_t S0RETENTION = (1U << 16);  ///< Keep retention on RAM section S0 when RAM section is in OFF
        constexpr uint32_t S1RETENTION = (1U << 17);  ///< Keep retention on RAM section S1 when RAM section is in OFF
    }

    /// POWERSET Register bits
    namespace powerset_bits {
        constexpr uint32_t S0POWER = (1U << 0);  ///< Keep RAM section S0 of RAMn on or off in System ON mode
        constexpr uint32_t S1POWER = (1U << 1);  ///< Keep RAM section S1 of RAMn on or off in System ON mode
        constexpr uint32_t S0RETENTION = (1U << 16);  ///< Keep retention on RAM section S0 when RAM section is switched off
        constexpr uint32_t S1RETENTION = (1U << 17);  ///< Keep retention on RAM section S1 when RAM section is switched off
    }

    /// POWERCLR Register bits
    namespace powerclr_bits {
        constexpr uint32_t S0POWER = (1U << 0);  ///< Keep RAM section S0 of RAMn on or off in System ON mode
        constexpr uint32_t S1POWER = (1U << 1);  ///< Keep RAM section S1 of RAMn on or off in System ON mode
        constexpr uint32_t S0RETENTION = (1U << 16);  ///< Keep retention on RAM section S0 when RAM section is switched off
        constexpr uint32_t S1RETENTION = (1U << 17);  ///< Keep retention on RAM section S1 when RAM section is switched off
    }

}

// ============================================================================
// P0 Peripheral
// ============================================================================

namespace p0 {
    /// Base addresses
    constexpr uint32_t P0_BASE = 0x50000000;

    /// P0 Register structure
    struct Registers {
        volatile uint32_t OUT;  ///< Offset: 0x504 - Write GPIO port
        volatile uint32_t OUTSET;  ///< Offset: 0x508 - Set individual bits in GPIO port
        volatile uint32_t OUTCLR;  ///< Offset: 0x50C - Clear individual bits in GPIO port
        volatile uint32_t IN;  ///< Offset: 0x510 - Read GPIO port
        volatile uint32_t DIR;  ///< Offset: 0x514 - Direction of GPIO pins
        volatile uint32_t DIRSET;  ///< Offset: 0x518 - DIR set register
        volatile uint32_t DIRCLR;  ///< Offset: 0x51C - DIR clear register
        volatile uint32_t LATCH;  ///< Offset: 0x520 - Latch register indicating what GPIO pins that have met...
        volatile uint32_t DETECTMODE;  ///< Offset: 0x524 - Select between default DETECT signal behaviour and LDETECT mode
        volatile uint32_t PIN_CNF[%s];  ///< Offset: 0x700 - Description collection: Configuration of GPIO pins
    };

    /// Peripheral instances
    inline Registers* P0 = reinterpret_cast<Registers*>(P0_BASE);

    // Bit definitions
    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// OUTSET Register bits
    namespace outset_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// OUTCLR Register bits
    namespace outclr_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// DIR Register bits
    namespace dir_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// DIRSET Register bits
    namespace dirset_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Set as output pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Set as output pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Set as output pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Set as output pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Set as output pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Set as output pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Set as output pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Set as output pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Set as output pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Set as output pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Set as output pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Set as output pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Set as output pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Set as output pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Set as output pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Set as output pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Set as output pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Set as output pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Set as output pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Set as output pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Set as output pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Set as output pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Set as output pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Set as output pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Set as output pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Set as output pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Set as output pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Set as output pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Set as output pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Set as output pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Set as output pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Set as output pin 31
    }

    /// DIRCLR Register bits
    namespace dirclr_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Set as input pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Set as input pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Set as input pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Set as input pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Set as input pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Set as input pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Set as input pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Set as input pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Set as input pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Set as input pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Set as input pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Set as input pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Set as input pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Set as input pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Set as input pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Set as input pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Set as input pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Set as input pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Set as input pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Set as input pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Set as input pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Set as input pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Set as input pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Set as input pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Set as input pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Set as input pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Set as input pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Set as input pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Set as input pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Set as input pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Set as input pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Set as input pin 31
    }

    /// LATCH Register bits
    namespace latch_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Status on whether PIN0 has met criteria set in PIN_CNF0.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN1 = (1U << 1);  ///< Status on whether PIN1 has met criteria set in PIN_CNF1.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN2 = (1U << 2);  ///< Status on whether PIN2 has met criteria set in PIN_CNF2.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN3 = (1U << 3);  ///< Status on whether PIN3 has met criteria set in PIN_CNF3.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN4 = (1U << 4);  ///< Status on whether PIN4 has met criteria set in PIN_CNF4.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN5 = (1U << 5);  ///< Status on whether PIN5 has met criteria set in PIN_CNF5.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN6 = (1U << 6);  ///< Status on whether PIN6 has met criteria set in PIN_CNF6.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN7 = (1U << 7);  ///< Status on whether PIN7 has met criteria set in PIN_CNF7.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN8 = (1U << 8);  ///< Status on whether PIN8 has met criteria set in PIN_CNF8.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN9 = (1U << 9);  ///< Status on whether PIN9 has met criteria set in PIN_CNF9.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN10 = (1U << 10);  ///< Status on whether PIN10 has met criteria set in PIN_CNF10.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN11 = (1U << 11);  ///< Status on whether PIN11 has met criteria set in PIN_CNF11.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN12 = (1U << 12);  ///< Status on whether PIN12 has met criteria set in PIN_CNF12.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN13 = (1U << 13);  ///< Status on whether PIN13 has met criteria set in PIN_CNF13.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN14 = (1U << 14);  ///< Status on whether PIN14 has met criteria set in PIN_CNF14.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN15 = (1U << 15);  ///< Status on whether PIN15 has met criteria set in PIN_CNF15.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN16 = (1U << 16);  ///< Status on whether PIN16 has met criteria set in PIN_CNF16.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN17 = (1U << 17);  ///< Status on whether PIN17 has met criteria set in PIN_CNF17.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN18 = (1U << 18);  ///< Status on whether PIN18 has met criteria set in PIN_CNF18.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN19 = (1U << 19);  ///< Status on whether PIN19 has met criteria set in PIN_CNF19.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN20 = (1U << 20);  ///< Status on whether PIN20 has met criteria set in PIN_CNF20.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN21 = (1U << 21);  ///< Status on whether PIN21 has met criteria set in PIN_CNF21.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN22 = (1U << 22);  ///< Status on whether PIN22 has met criteria set in PIN_CNF22.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN23 = (1U << 23);  ///< Status on whether PIN23 has met criteria set in PIN_CNF23.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN24 = (1U << 24);  ///< Status on whether PIN24 has met criteria set in PIN_CNF24.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN25 = (1U << 25);  ///< Status on whether PIN25 has met criteria set in PIN_CNF25.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN26 = (1U << 26);  ///< Status on whether PIN26 has met criteria set in PIN_CNF26.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN27 = (1U << 27);  ///< Status on whether PIN27 has met criteria set in PIN_CNF27.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN28 = (1U << 28);  ///< Status on whether PIN28 has met criteria set in PIN_CNF28.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN29 = (1U << 29);  ///< Status on whether PIN29 has met criteria set in PIN_CNF29.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN30 = (1U << 30);  ///< Status on whether PIN30 has met criteria set in PIN_CNF30.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN31 = (1U << 31);  ///< Status on whether PIN31 has met criteria set in PIN_CNF31.SENSE register. Write '1' to clear.
    }

    /// DETECTMODE Register bits
    namespace detectmode_bits {
        constexpr uint32_t DETECTMODE = (1U << 0);  ///< Select between default DETECT signal behaviour and LDETECT mode
    }

    /// PIN_CNF[%s] Register bits
    namespace pin_cnf[%s]_bits {
        constexpr uint32_t DIR = (1U << 0);  ///< Pin direction. Same physical register as DIR register
        constexpr uint32_t INPUT = (1U << 1);  ///< Connect or disconnect input buffer
        constexpr uint32_t PULL = (2 << 2);  ///< Pull configuration
        constexpr uint32_t DRIVE = (3 << 8);  ///< Drive configuration
        constexpr uint32_t SENSE = (2 << 16);  ///< Pin sensing mechanism
    }

}

// ============================================================================
// RADIO Peripheral
// ============================================================================

namespace radio {
    /// Base addresses
    constexpr uint32_t RADIO_BASE = 0x40001000;

    /// RADIO Register structure
    struct Registers {
        volatile uint32_t TASKS_TXEN;  ///< Offset: 0x00 - Enable RADIO in TX mode
        volatile uint32_t TASKS_RXEN;  ///< Offset: 0x04 - Enable RADIO in RX mode
        volatile uint32_t TASKS_START;  ///< Offset: 0x08 - Start RADIO
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x0C - Stop RADIO
        volatile uint32_t TASKS_DISABLE;  ///< Offset: 0x10 - Disable RADIO
        volatile uint32_t TASKS_RSSISTART;  ///< Offset: 0x14 - Start the RSSI and take one single sample of the receive...
        volatile uint32_t TASKS_RSSISTOP;  ///< Offset: 0x18 - Stop the RSSI measurement
        volatile uint32_t TASKS_BCSTART;  ///< Offset: 0x1C - Start the bit counter
        volatile uint32_t TASKS_BCSTOP;  ///< Offset: 0x20 - Stop the bit counter
        volatile uint32_t EVENTS_READY;  ///< Offset: 0x100 - RADIO has ramped up and is ready to be started
        volatile uint32_t EVENTS_ADDRESS;  ///< Offset: 0x104 - Address sent or received
        volatile uint32_t EVENTS_PAYLOAD;  ///< Offset: 0x108 - Packet payload sent or received
        volatile uint32_t EVENTS_END;  ///< Offset: 0x10C - Packet sent or received
        volatile uint32_t EVENTS_DISABLED;  ///< Offset: 0x110 - RADIO has been disabled
        volatile uint32_t EVENTS_DEVMATCH;  ///< Offset: 0x114 - A device address match occurred on the last received packet
        volatile uint32_t EVENTS_DEVMISS;  ///< Offset: 0x118 - No device address match occurred on the last received packet
        volatile uint32_t EVENTS_RSSIEND;  ///< Offset: 0x11C - Sampling of receive signal strength complete.
        volatile uint32_t EVENTS_BCMATCH;  ///< Offset: 0x128 - Bit counter reached bit count value.
        volatile uint32_t EVENTS_CRCOK;  ///< Offset: 0x130 - Packet received with CRC ok
        volatile uint32_t EVENTS_CRCERROR;  ///< Offset: 0x134 - Packet received with CRC error
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t CRCSTATUS;  ///< Offset: 0x400 - CRC status
        volatile uint32_t RXMATCH;  ///< Offset: 0x408 - Received address
        volatile uint32_t RXCRC;  ///< Offset: 0x40C - CRC field of previously received packet
        volatile uint32_t DAI;  ///< Offset: 0x410 - Device address match index
        volatile uint32_t PACKETPTR;  ///< Offset: 0x504 - Packet pointer
        volatile uint32_t FREQUENCY;  ///< Offset: 0x508 - Frequency
        volatile uint32_t TXPOWER;  ///< Offset: 0x50C - Output power
        volatile uint32_t MODE;  ///< Offset: 0x510 - Data rate and modulation
        volatile uint32_t PCNF0;  ///< Offset: 0x514 - Packet configuration register 0
        volatile uint32_t PCNF1;  ///< Offset: 0x518 - Packet configuration register 1
        volatile uint32_t BASE0;  ///< Offset: 0x51C - Base address 0
        volatile uint32_t BASE1;  ///< Offset: 0x520 - Base address 1
        volatile uint32_t PREFIX0;  ///< Offset: 0x524 - Prefixes bytes for logical addresses 0-3
        volatile uint32_t PREFIX1;  ///< Offset: 0x528 - Prefixes bytes for logical addresses 4-7
        volatile uint32_t TXADDRESS;  ///< Offset: 0x52C - Transmit address select
        volatile uint32_t RXADDRESSES;  ///< Offset: 0x530 - Receive address select
        volatile uint32_t CRCCNF;  ///< Offset: 0x534 - CRC configuration
        volatile uint32_t CRCPOLY;  ///< Offset: 0x538 - CRC polynomial
        volatile uint32_t CRCINIT;  ///< Offset: 0x53C - CRC initial value
        volatile uint32_t TIFS;  ///< Offset: 0x544 - Inter Frame Spacing in us
        volatile uint32_t RSSISAMPLE;  ///< Offset: 0x548 - RSSI sample
        volatile uint32_t STATE;  ///< Offset: 0x550 - Current radio state
        volatile uint32_t DATAWHITEIV;  ///< Offset: 0x554 - Data whitening initial value
        volatile uint32_t BCC;  ///< Offset: 0x560 - Bit counter compare
        volatile uint32_t DAB[%s];  ///< Offset: 0x600 - Description collection: Device address base segment n
        volatile uint32_t DAP[%s];  ///< Offset: 0x620 - Description collection: Device address prefix n
        volatile uint32_t DACNF;  ///< Offset: 0x640 - Device address match configuration
        volatile uint32_t MODECNF0;  ///< Offset: 0x650 - Radio mode configuration register 0
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control
    };

    /// Peripheral instances
    inline Registers* RADIO = reinterpret_cast<Registers*>(RADIO_BASE);

    // Bit definitions
    /// TASKS_TXEN Register bits
    namespace tasks_txen_bits {
        constexpr uint32_t TASKS_TXEN = (1U << 0);  ///< Enable RADIO in TX mode
    }

    /// TASKS_RXEN Register bits
    namespace tasks_rxen_bits {
        constexpr uint32_t TASKS_RXEN = (1U << 0);  ///< Enable RADIO in RX mode
    }

    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start RADIO
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop RADIO
    }

    /// TASKS_DISABLE Register bits
    namespace tasks_disable_bits {
        constexpr uint32_t TASKS_DISABLE = (1U << 0);  ///< Disable RADIO
    }

    /// TASKS_RSSISTART Register bits
    namespace tasks_rssistart_bits {
        constexpr uint32_t TASKS_RSSISTART = (1U << 0);  ///< Start the RSSI and take one single sample of the receive signal strength.
    }

    /// TASKS_RSSISTOP Register bits
    namespace tasks_rssistop_bits {
        constexpr uint32_t TASKS_RSSISTOP = (1U << 0);  ///< Stop the RSSI measurement
    }

    /// TASKS_BCSTART Register bits
    namespace tasks_bcstart_bits {
        constexpr uint32_t TASKS_BCSTART = (1U << 0);  ///< Start the bit counter
    }

    /// TASKS_BCSTOP Register bits
    namespace tasks_bcstop_bits {
        constexpr uint32_t TASKS_BCSTOP = (1U << 0);  ///< Stop the bit counter
    }

    /// EVENTS_READY Register bits
    namespace events_ready_bits {
        constexpr uint32_t EVENTS_READY = (1U << 0);  ///< RADIO has ramped up and is ready to be started
    }

    /// EVENTS_ADDRESS Register bits
    namespace events_address_bits {
        constexpr uint32_t EVENTS_ADDRESS = (1U << 0);  ///< Address sent or received
    }

    /// EVENTS_PAYLOAD Register bits
    namespace events_payload_bits {
        constexpr uint32_t EVENTS_PAYLOAD = (1U << 0);  ///< Packet payload sent or received
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< Packet sent or received
    }

    /// EVENTS_DISABLED Register bits
    namespace events_disabled_bits {
        constexpr uint32_t EVENTS_DISABLED = (1U << 0);  ///< RADIO has been disabled
    }

    /// EVENTS_DEVMATCH Register bits
    namespace events_devmatch_bits {
        constexpr uint32_t EVENTS_DEVMATCH = (1U << 0);  ///< A device address match occurred on the last received packet
    }

    /// EVENTS_DEVMISS Register bits
    namespace events_devmiss_bits {
        constexpr uint32_t EVENTS_DEVMISS = (1U << 0);  ///< No device address match occurred on the last received packet
    }

    /// EVENTS_RSSIEND Register bits
    namespace events_rssiend_bits {
        constexpr uint32_t EVENTS_RSSIEND = (1U << 0);  ///< Sampling of receive signal strength complete.
    }

    /// EVENTS_BCMATCH Register bits
    namespace events_bcmatch_bits {
        constexpr uint32_t EVENTS_BCMATCH = (1U << 0);  ///< Bit counter reached bit count value.
    }

    /// EVENTS_CRCOK Register bits
    namespace events_crcok_bits {
        constexpr uint32_t EVENTS_CRCOK = (1U << 0);  ///< Packet received with CRC ok
    }

    /// EVENTS_CRCERROR Register bits
    namespace events_crcerror_bits {
        constexpr uint32_t EVENTS_CRCERROR = (1U << 0);  ///< Packet received with CRC error
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t READY_START = (1U << 0);  ///< Shortcut between event READY and task START
        constexpr uint32_t END_DISABLE = (1U << 1);  ///< Shortcut between event END and task DISABLE
        constexpr uint32_t DISABLED_TXEN = (1U << 2);  ///< Shortcut between event DISABLED and task TXEN
        constexpr uint32_t DISABLED_RXEN = (1U << 3);  ///< Shortcut between event DISABLED and task RXEN
        constexpr uint32_t ADDRESS_RSSISTART = (1U << 4);  ///< Shortcut between event ADDRESS and task RSSISTART
        constexpr uint32_t END_START = (1U << 5);  ///< Shortcut between event END and task START
        constexpr uint32_t ADDRESS_BCSTART = (1U << 6);  ///< Shortcut between event ADDRESS and task BCSTART
        constexpr uint32_t DISABLED_RSSISTOP = (1U << 8);  ///< Shortcut between event DISABLED and task RSSISTOP
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to enable interrupt for event READY
        constexpr uint32_t ADDRESS = (1U << 1);  ///< Write '1' to enable interrupt for event ADDRESS
        constexpr uint32_t PAYLOAD = (1U << 2);  ///< Write '1' to enable interrupt for event PAYLOAD
        constexpr uint32_t END = (1U << 3);  ///< Write '1' to enable interrupt for event END
        constexpr uint32_t DISABLED = (1U << 4);  ///< Write '1' to enable interrupt for event DISABLED
        constexpr uint32_t DEVMATCH = (1U << 5);  ///< Write '1' to enable interrupt for event DEVMATCH
        constexpr uint32_t DEVMISS = (1U << 6);  ///< Write '1' to enable interrupt for event DEVMISS
        constexpr uint32_t RSSIEND = (1U << 7);  ///< Write '1' to enable interrupt for event RSSIEND
        constexpr uint32_t BCMATCH = (1U << 10);  ///< Write '1' to enable interrupt for event BCMATCH
        constexpr uint32_t CRCOK = (1U << 12);  ///< Write '1' to enable interrupt for event CRCOK
        constexpr uint32_t CRCERROR = (1U << 13);  ///< Write '1' to enable interrupt for event CRCERROR
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to disable interrupt for event READY
        constexpr uint32_t ADDRESS = (1U << 1);  ///< Write '1' to disable interrupt for event ADDRESS
        constexpr uint32_t PAYLOAD = (1U << 2);  ///< Write '1' to disable interrupt for event PAYLOAD
        constexpr uint32_t END = (1U << 3);  ///< Write '1' to disable interrupt for event END
        constexpr uint32_t DISABLED = (1U << 4);  ///< Write '1' to disable interrupt for event DISABLED
        constexpr uint32_t DEVMATCH = (1U << 5);  ///< Write '1' to disable interrupt for event DEVMATCH
        constexpr uint32_t DEVMISS = (1U << 6);  ///< Write '1' to disable interrupt for event DEVMISS
        constexpr uint32_t RSSIEND = (1U << 7);  ///< Write '1' to disable interrupt for event RSSIEND
        constexpr uint32_t BCMATCH = (1U << 10);  ///< Write '1' to disable interrupt for event BCMATCH
        constexpr uint32_t CRCOK = (1U << 12);  ///< Write '1' to disable interrupt for event CRCOK
        constexpr uint32_t CRCERROR = (1U << 13);  ///< Write '1' to disable interrupt for event CRCERROR
    }

    /// CRCSTATUS Register bits
    namespace crcstatus_bits {
        constexpr uint32_t CRCSTATUS = (1U << 0);  ///< CRC status of packet received
    }

    /// RXMATCH Register bits
    namespace rxmatch_bits {
        constexpr uint32_t RXMATCH = (3 << 0);  ///< Received address
    }

    /// RXCRC Register bits
    namespace rxcrc_bits {
        constexpr uint32_t RXCRC = (24 << 0);  ///< CRC field of previously received packet
    }

    /// DAI Register bits
    namespace dai_bits {
        constexpr uint32_t DAI = (3 << 0);  ///< Device address match index
    }

    /// PACKETPTR Register bits
    namespace packetptr_bits {
        constexpr uint32_t PACKETPTR = (32 << 0);  ///< Packet pointer
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (7 << 0);  ///< Radio channel frequency
        constexpr uint32_t MAP = (1U << 8);  ///< Channel map selection.
    }

    /// TXPOWER Register bits
    namespace txpower_bits {
        constexpr uint32_t TXPOWER = (8 << 0);  ///< RADIO output power.
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (4 << 0);  ///< Radio data rate and modulation setting. The radio supports Frequency-shift Keying (FSK) modulation.
    }

    /// PCNF0 Register bits
    namespace pcnf0_bits {
        constexpr uint32_t LFLEN = (4 << 0);  ///< Length on air of LENGTH field in number of bits.
        constexpr uint32_t S0LEN = (1U << 8);  ///< Length on air of S0 field in number of bytes.
        constexpr uint32_t S1LEN = (4 << 16);  ///< Length on air of S1 field in number of bits.
        constexpr uint32_t S1INCL = (1U << 20);  ///< Include or exclude S1 field in RAM
        constexpr uint32_t PLEN = (1U << 24);  ///< Length of preamble on air. Decision point: TASKS_START task
    }

    /// PCNF1 Register bits
    namespace pcnf1_bits {
        constexpr uint32_t MAXLEN = (8 << 0);  ///< Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN.
        constexpr uint32_t STATLEN = (8 << 8);  ///< Static length in number of bytes
        constexpr uint32_t BALEN = (3 << 16);  ///< Base address length in number of bytes
        constexpr uint32_t ENDIAN = (1U << 24);  ///< On air endianness of packet, this applies to the S0, LENGTH, S1 and the PAYLOAD fields.
        constexpr uint32_t WHITEEN = (1U << 25);  ///< Enable or disable packet whitening
    }

    /// BASE0 Register bits
    namespace base0_bits {
        constexpr uint32_t BASE0 = (32 << 0);  ///< Base address 0
    }

    /// BASE1 Register bits
    namespace base1_bits {
        constexpr uint32_t BASE1 = (32 << 0);  ///< Base address 1
    }

    /// PREFIX0 Register bits
    namespace prefix0_bits {
        constexpr uint32_t AP0 = (8 << 0);  ///< Address prefix 0.
        constexpr uint32_t AP1 = (8 << 8);  ///< Address prefix 1.
        constexpr uint32_t AP2 = (8 << 16);  ///< Address prefix 2.
        constexpr uint32_t AP3 = (8 << 24);  ///< Address prefix 3.
    }

    /// PREFIX1 Register bits
    namespace prefix1_bits {
        constexpr uint32_t AP4 = (8 << 0);  ///< Address prefix 4.
        constexpr uint32_t AP5 = (8 << 8);  ///< Address prefix 5.
        constexpr uint32_t AP6 = (8 << 16);  ///< Address prefix 6.
        constexpr uint32_t AP7 = (8 << 24);  ///< Address prefix 7.
    }

    /// TXADDRESS Register bits
    namespace txaddress_bits {
        constexpr uint32_t TXADDRESS = (3 << 0);  ///< Transmit address select
    }

    /// RXADDRESSES Register bits
    namespace rxaddresses_bits {
        constexpr uint32_t ADDR0 = (1U << 0);  ///< Enable or disable reception on logical address 0.
        constexpr uint32_t ADDR1 = (1U << 1);  ///< Enable or disable reception on logical address 1.
        constexpr uint32_t ADDR2 = (1U << 2);  ///< Enable or disable reception on logical address 2.
        constexpr uint32_t ADDR3 = (1U << 3);  ///< Enable or disable reception on logical address 3.
        constexpr uint32_t ADDR4 = (1U << 4);  ///< Enable or disable reception on logical address 4.
        constexpr uint32_t ADDR5 = (1U << 5);  ///< Enable or disable reception on logical address 5.
        constexpr uint32_t ADDR6 = (1U << 6);  ///< Enable or disable reception on logical address 6.
        constexpr uint32_t ADDR7 = (1U << 7);  ///< Enable or disable reception on logical address 7.
    }

    /// CRCCNF Register bits
    namespace crccnf_bits {
        constexpr uint32_t LEN = (2 << 0);  ///< CRC length in number of bytes.
        constexpr uint32_t SKIPADDR = (1U << 8);  ///< Include or exclude packet address field out of CRC calculation.
    }

    /// CRCPOLY Register bits
    namespace crcpoly_bits {
        constexpr uint32_t CRCPOLY = (24 << 0);  ///< CRC polynomial
    }

    /// CRCINIT Register bits
    namespace crcinit_bits {
        constexpr uint32_t CRCINIT = (24 << 0);  ///< CRC initial value
    }

    /// TIFS Register bits
    namespace tifs_bits {
        constexpr uint32_t TIFS = (8 << 0);  ///< Inter Frame Spacing in us
    }

    /// RSSISAMPLE Register bits
    namespace rssisample_bits {
        constexpr uint32_t RSSISAMPLE = (7 << 0);  ///< RSSI sample
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t STATE = (4 << 0);  ///< Current radio state
    }

    /// DATAWHITEIV Register bits
    namespace datawhiteiv_bits {
        constexpr uint32_t DATAWHITEIV = (7 << 0);  ///< Data whitening initial value. Bit 6 is hard-wired to '1', writing '0' to it has no effect, and it will always be read back and used by the device as '1'.
    }

    /// BCC Register bits
    namespace bcc_bits {
        constexpr uint32_t BCC = (32 << 0);  ///< Bit counter compare
    }

    /// DAB[%s] Register bits
    namespace dab[%s]_bits {
        constexpr uint32_t DAB = (32 << 0);  ///< Device address base segment n
    }

    /// DAP[%s] Register bits
    namespace dap[%s]_bits {
        constexpr uint32_t DAP = (16 << 0);  ///< Device address prefix n
    }

    /// DACNF Register bits
    namespace dacnf_bits {
        constexpr uint32_t ENA0 = (1U << 0);  ///< Enable or disable device address matching using device address 0
        constexpr uint32_t ENA1 = (1U << 1);  ///< Enable or disable device address matching using device address 1
        constexpr uint32_t ENA2 = (1U << 2);  ///< Enable or disable device address matching using device address 2
        constexpr uint32_t ENA3 = (1U << 3);  ///< Enable or disable device address matching using device address 3
        constexpr uint32_t ENA4 = (1U << 4);  ///< Enable or disable device address matching using device address 4
        constexpr uint32_t ENA5 = (1U << 5);  ///< Enable or disable device address matching using device address 5
        constexpr uint32_t ENA6 = (1U << 6);  ///< Enable or disable device address matching using device address 6
        constexpr uint32_t ENA7 = (1U << 7);  ///< Enable or disable device address matching using device address 7
        constexpr uint32_t TXADD0 = (1U << 8);  ///< TxAdd for device address 0
        constexpr uint32_t TXADD1 = (1U << 9);  ///< TxAdd for device address 1
        constexpr uint32_t TXADD2 = (1U << 10);  ///< TxAdd for device address 2
        constexpr uint32_t TXADD3 = (1U << 11);  ///< TxAdd for device address 3
        constexpr uint32_t TXADD4 = (1U << 12);  ///< TxAdd for device address 4
        constexpr uint32_t TXADD5 = (1U << 13);  ///< TxAdd for device address 5
        constexpr uint32_t TXADD6 = (1U << 14);  ///< TxAdd for device address 6
        constexpr uint32_t TXADD7 = (1U << 15);  ///< TxAdd for device address 7
    }

    /// MODECNF0 Register bits
    namespace modecnf0_bits {
        constexpr uint32_t RU = (1U << 0);  ///< Radio ramp-up time
        constexpr uint32_t DTX = (2 << 8);  ///< Default TX value
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control. The peripheral and its registers will be reset to its initial state by switching the peripheral off and then back on again.
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x40002000;
    constexpr uint32_t UARTE0_BASE = 0x40002000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTRX;  ///< Offset: 0x00 - Start UART receiver
        volatile uint32_t TASKS_STOPRX;  ///< Offset: 0x04 - Stop UART receiver
        volatile uint32_t TASKS_STARTTX;  ///< Offset: 0x08 - Start UART transmitter
        volatile uint32_t TASKS_STOPTX;  ///< Offset: 0x0C - Stop UART transmitter
        volatile uint32_t TASKS_SUSPEND;  ///< Offset: 0x1C - Suspend UART
        volatile uint32_t EVENTS_CTS;  ///< Offset: 0x100 - CTS is activated (set low). Clear To Send.
        volatile uint32_t EVENTS_NCTS;  ///< Offset: 0x104 - CTS is deactivated (set high). Not Clear To Send.
        volatile uint32_t EVENTS_RXDRDY;  ///< Offset: 0x108 - Data received in RXD
        volatile uint32_t EVENTS_TXDRDY;  ///< Offset: 0x11C - Data sent from TXD
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x124 - Error detected
        volatile uint32_t EVENTS_RXTO;  ///< Offset: 0x144 - Receiver timeout
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ERRORSRC;  ///< Offset: 0x480 - Error source
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable UART
        volatile uint32_t RTS;  ///< Offset: 0x00 - Pin select for RTS
        volatile uint32_t TXD;  ///< Offset: 0x51C - TXD register
        volatile uint32_t CTS;  ///< Offset: 0x08 - Pin select for CTS
        volatile uint32_t RXD;  ///< Offset: 0x518 - RXD register
        volatile uint32_t BAUDRATE;  ///< Offset: 0x524 - Baud rate. Accuracy depends on the HFCLK source selected.
        volatile uint32_t CONFIG;  ///< Offset: 0x56C - Configuration of parity and hardware flow control
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UARTE0 = reinterpret_cast<Registers*>(UARTE0_BASE);

    // Bit definitions
    /// TASKS_STARTRX Register bits
    namespace tasks_startrx_bits {
        constexpr uint32_t TASKS_STARTRX = (1U << 0);  ///< Start UART receiver
    }

    /// TASKS_STOPRX Register bits
    namespace tasks_stoprx_bits {
        constexpr uint32_t TASKS_STOPRX = (1U << 0);  ///< Stop UART receiver
    }

    /// TASKS_STARTTX Register bits
    namespace tasks_starttx_bits {
        constexpr uint32_t TASKS_STARTTX = (1U << 0);  ///< Start UART transmitter
    }

    /// TASKS_STOPTX Register bits
    namespace tasks_stoptx_bits {
        constexpr uint32_t TASKS_STOPTX = (1U << 0);  ///< Stop UART transmitter
    }

    /// TASKS_SUSPEND Register bits
    namespace tasks_suspend_bits {
        constexpr uint32_t TASKS_SUSPEND = (1U << 0);  ///< Suspend UART
    }

    /// EVENTS_CTS Register bits
    namespace events_cts_bits {
        constexpr uint32_t EVENTS_CTS = (1U << 0);  ///< CTS is activated (set low). Clear To Send.
    }

    /// EVENTS_NCTS Register bits
    namespace events_ncts_bits {
        constexpr uint32_t EVENTS_NCTS = (1U << 0);  ///< CTS is deactivated (set high). Not Clear To Send.
    }

    /// EVENTS_RXDRDY Register bits
    namespace events_rxdrdy_bits {
        constexpr uint32_t EVENTS_RXDRDY = (1U << 0);  ///< Data received in RXD
    }

    /// EVENTS_TXDRDY Register bits
    namespace events_txdrdy_bits {
        constexpr uint32_t EVENTS_TXDRDY = (1U << 0);  ///< Data sent from TXD
    }

    /// EVENTS_ERROR Register bits
    namespace events_error_bits {
        constexpr uint32_t EVENTS_ERROR = (1U << 0);  ///< Error detected
    }

    /// EVENTS_RXTO Register bits
    namespace events_rxto_bits {
        constexpr uint32_t EVENTS_RXTO = (1U << 0);  ///< Receiver timeout
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t CTS_STARTRX = (1U << 3);  ///< Shortcut between event CTS and task STARTRX
        constexpr uint32_t NCTS_STOPRX = (1U << 4);  ///< Shortcut between event NCTS and task STOPRX
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t CTS = (1U << 0);  ///< Write '1' to enable interrupt for event CTS
        constexpr uint32_t NCTS = (1U << 1);  ///< Write '1' to enable interrupt for event NCTS
        constexpr uint32_t RXDRDY = (1U << 2);  ///< Write '1' to enable interrupt for event RXDRDY
        constexpr uint32_t TXDRDY = (1U << 7);  ///< Write '1' to enable interrupt for event TXDRDY
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to enable interrupt for event ERROR
        constexpr uint32_t RXTO = (1U << 17);  ///< Write '1' to enable interrupt for event RXTO
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t CTS = (1U << 0);  ///< Write '1' to disable interrupt for event CTS
        constexpr uint32_t NCTS = (1U << 1);  ///< Write '1' to disable interrupt for event NCTS
        constexpr uint32_t RXDRDY = (1U << 2);  ///< Write '1' to disable interrupt for event RXDRDY
        constexpr uint32_t TXDRDY = (1U << 7);  ///< Write '1' to disable interrupt for event TXDRDY
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to disable interrupt for event ERROR
        constexpr uint32_t RXTO = (1U << 17);  ///< Write '1' to disable interrupt for event RXTO
    }

    /// ERRORSRC Register bits
    namespace errorsrc_bits {
        constexpr uint32_t OVERRUN = (1U << 0);  ///< Overrun error
        constexpr uint32_t PARITY = (1U << 1);  ///< Parity error
        constexpr uint32_t FRAMING = (1U << 2);  ///< Framing error occurred
        constexpr uint32_t BREAK = (1U << 3);  ///< Break condition
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (4 << 0);  ///< Enable or disable UART
    }

    /// RTS Register bits
    namespace rts_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// TXD Register bits
    namespace txd_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< TX data to be transferred
    }

    /// CTS Register bits
    namespace cts_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// RXD Register bits
    namespace rxd_bits {
        constexpr uint32_t RXD = (8 << 0);  ///< RX data received in previous transfers, double buffered
    }

    /// BAUDRATE Register bits
    namespace baudrate_bits {
        constexpr uint32_t BAUDRATE = (32 << 0);  ///< Baud rate
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t HWFC = (1U << 0);  ///< Hardware flow control
        constexpr uint32_t PARITY = (3 << 1);  ///< Parity
        constexpr uint32_t STOP = (1U << 4);  ///< Stop bits
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t TWI0_BASE = 0x40003000;
    constexpr uint32_t TWIM0_BASE = 0x40003000;
    constexpr uint32_t TWIS0_BASE = 0x40003000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTRX;  ///< Offset: 0x00 - Start TWI receive sequence
        volatile uint32_t TASKS_STARTTX;  ///< Offset: 0x08 - Start TWI transmit sequence
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x14 - Stop TWI transaction
        volatile uint32_t TASKS_SUSPEND;  ///< Offset: 0x1C - Suspend TWI transaction
        volatile uint32_t TASKS_RESUME;  ///< Offset: 0x20 - Resume TWI transaction
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - TWI stopped
        volatile uint32_t EVENTS_RXDREADY;  ///< Offset: 0x108 - TWI RXD byte received
        volatile uint32_t EVENTS_TXDSENT;  ///< Offset: 0x11C - TWI TXD byte sent
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x124 - TWI error
        volatile uint32_t EVENTS_BB;  ///< Offset: 0x138 - TWI byte boundary, generated before each byte that is...
        volatile uint32_t EVENTS_SUSPENDED;  ///< Offset: 0x148 - TWI entered the suspended state
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ERRORSRC;  ///< Offset: 0x4C4 - Error source
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable TWI
        volatile uint32_t SCL;  ///< Offset: 0x00 - Pin select for SCL
        volatile uint32_t SDA;  ///< Offset: 0x04 - Pin select for SDA
        volatile uint32_t RXD;  ///< Offset: 0x518 - RXD register
        volatile uint32_t TXD;  ///< Offset: 0x51C - TXD register
        volatile uint32_t FREQUENCY;  ///< Offset: 0x524 - TWI frequency. Accuracy depends on the HFCLK source selected.
        volatile uint32_t ADDRESS;  ///< Offset: 0x588 - Address used in the TWI transfer
    };

    /// Peripheral instances
    inline Registers* TWI0 = reinterpret_cast<Registers*>(TWI0_BASE);
    inline Registers* TWIM0 = reinterpret_cast<Registers*>(TWIM0_BASE);
    inline Registers* TWIS0 = reinterpret_cast<Registers*>(TWIS0_BASE);

    // Bit definitions
    /// TASKS_STARTRX Register bits
    namespace tasks_startrx_bits {
        constexpr uint32_t TASKS_STARTRX = (1U << 0);  ///< Start TWI receive sequence
    }

    /// TASKS_STARTTX Register bits
    namespace tasks_starttx_bits {
        constexpr uint32_t TASKS_STARTTX = (1U << 0);  ///< Start TWI transmit sequence
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop TWI transaction
    }

    /// TASKS_SUSPEND Register bits
    namespace tasks_suspend_bits {
        constexpr uint32_t TASKS_SUSPEND = (1U << 0);  ///< Suspend TWI transaction
    }

    /// TASKS_RESUME Register bits
    namespace tasks_resume_bits {
        constexpr uint32_t TASKS_RESUME = (1U << 0);  ///< Resume TWI transaction
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< TWI stopped
    }

    /// EVENTS_RXDREADY Register bits
    namespace events_rxdready_bits {
        constexpr uint32_t EVENTS_RXDREADY = (1U << 0);  ///< TWI RXD byte received
    }

    /// EVENTS_TXDSENT Register bits
    namespace events_txdsent_bits {
        constexpr uint32_t EVENTS_TXDSENT = (1U << 0);  ///< TWI TXD byte sent
    }

    /// EVENTS_ERROR Register bits
    namespace events_error_bits {
        constexpr uint32_t EVENTS_ERROR = (1U << 0);  ///< TWI error
    }

    /// EVENTS_BB Register bits
    namespace events_bb_bits {
        constexpr uint32_t EVENTS_BB = (1U << 0);  ///< TWI byte boundary, generated before each byte that is sent or received
    }

    /// EVENTS_SUSPENDED Register bits
    namespace events_suspended_bits {
        constexpr uint32_t EVENTS_SUSPENDED = (1U << 0);  ///< TWI entered the suspended state
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t BB_SUSPEND = (1U << 0);  ///< Shortcut between event BB and task SUSPEND
        constexpr uint32_t BB_STOP = (1U << 1);  ///< Shortcut between event BB and task STOP
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t RXDREADY = (1U << 2);  ///< Write '1' to enable interrupt for event RXDREADY
        constexpr uint32_t TXDSENT = (1U << 7);  ///< Write '1' to enable interrupt for event TXDSENT
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to enable interrupt for event ERROR
        constexpr uint32_t BB = (1U << 14);  ///< Write '1' to enable interrupt for event BB
        constexpr uint32_t SUSPENDED = (1U << 18);  ///< Write '1' to enable interrupt for event SUSPENDED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t RXDREADY = (1U << 2);  ///< Write '1' to disable interrupt for event RXDREADY
        constexpr uint32_t TXDSENT = (1U << 7);  ///< Write '1' to disable interrupt for event TXDSENT
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to disable interrupt for event ERROR
        constexpr uint32_t BB = (1U << 14);  ///< Write '1' to disable interrupt for event BB
        constexpr uint32_t SUSPENDED = (1U << 18);  ///< Write '1' to disable interrupt for event SUSPENDED
    }

    /// ERRORSRC Register bits
    namespace errorsrc_bits {
        constexpr uint32_t OVERRUN = (1U << 0);  ///< Overrun error
        constexpr uint32_t ANACK = (1U << 1);  ///< NACK received after sending the address (write '1' to clear)
        constexpr uint32_t DNACK = (1U << 2);  ///< NACK received after sending a data byte (write '1' to clear)
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (4 << 0);  ///< Enable or disable TWI
    }

    /// SCL Register bits
    namespace scl_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// SDA Register bits
    namespace sda_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// RXD Register bits
    namespace rxd_bits {
        constexpr uint32_t RXD = (8 << 0);  ///< RXD register
    }

    /// TXD Register bits
    namespace txd_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< TXD register
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (32 << 0);  ///< TWI master clock frequency
    }

    /// ADDRESS Register bits
    namespace address_bits {
        constexpr uint32_t ADDRESS = (7 << 0);  ///< Address used in the TWI transfer
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40004000;
    constexpr uint32_t SPIM0_BASE = 0x40004000;
    constexpr uint32_t SPIS0_BASE = 0x40004000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t EVENTS_READY;  ///< Offset: 0x108 - TXD byte sent and RXD byte received
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable SPI
        volatile uint32_t SCK;  ///< Offset: 0x00 - Pin select for SCK
        volatile uint32_t MOSI;  ///< Offset: 0x04 - Pin select for MOSI signal
        volatile uint32_t MISO;  ///< Offset: 0x08 - Pin select for MISO signal
        volatile uint32_t RXD;  ///< Offset: 0x518 - RXD register
        volatile uint32_t TXD;  ///< Offset: 0x51C - TXD register
        volatile uint32_t FREQUENCY;  ///< Offset: 0x524 - SPI frequency. Accuracy depends on the HFCLK source selected.
        volatile uint32_t CONFIG;  ///< Offset: 0x554 - Configuration register
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPIM0 = reinterpret_cast<Registers*>(SPIM0_BASE);
    inline Registers* SPIS0 = reinterpret_cast<Registers*>(SPIS0_BASE);

    // Bit definitions
    /// EVENTS_READY Register bits
    namespace events_ready_bits {
        constexpr uint32_t EVENTS_READY = (1U << 0);  ///< TXD byte sent and RXD byte received
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 2);  ///< Write '1' to enable interrupt for event READY
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 2);  ///< Write '1' to disable interrupt for event READY
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (4 << 0);  ///< Enable or disable SPI
    }

    /// SCK Register bits
    namespace sck_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// MOSI Register bits
    namespace mosi_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// MISO Register bits
    namespace miso_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// RXD Register bits
    namespace rxd_bits {
        constexpr uint32_t RXD = (8 << 0);  ///< RX data received. Double buffered
    }

    /// TXD Register bits
    namespace txd_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< TX data to send. Double buffered
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (32 << 0);  ///< SPI master data rate
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t ORDER = (1U << 0);  ///< Bit order
        constexpr uint32_t CPHA = (1U << 1);  ///< Serial clock (SCK) phase
        constexpr uint32_t CPOL = (1U << 2);  ///< Serial clock (SCK) polarity
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOTE_BASE = 0x40006000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t TASKS_OUT[%s];  ///< Offset: 0x00 - Description collection: Task for writing to pin...
        volatile uint32_t TASKS_SET[%s];  ///< Offset: 0x30 - Description collection: Task for writing to pin...
        volatile uint32_t TASKS_CLR[%s];  ///< Offset: 0x60 - Description collection: Task for writing to pin...
        volatile uint32_t EVENTS_IN[%s];  ///< Offset: 0x100 - Description collection: Event generated from pin...
        volatile uint32_t EVENTS_PORT;  ///< Offset: 0x17C - Event generated from multiple input GPIO pins with SENSE...
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t CONFIG[%s];  ///< Offset: 0x510 - Description collection: Configuration for OUT[n], SET[n]...
    };

    /// Peripheral instances
    inline Registers* GPIOTE = reinterpret_cast<Registers*>(GPIOTE_BASE);

    // Bit definitions
    /// TASKS_OUT[%s] Register bits
    namespace tasks_out[%s]_bits {
        constexpr uint32_t TASKS_OUT = (1U << 0);  ///< Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is configured in CONFIG[n].POLARITY.
    }

    /// TASKS_SET[%s] Register bits
    namespace tasks_set[%s]_bits {
        constexpr uint32_t TASKS_SET = (1U << 0);  ///< Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it high.
    }

    /// TASKS_CLR[%s] Register bits
    namespace tasks_clr[%s]_bits {
        constexpr uint32_t TASKS_CLR = (1U << 0);  ///< Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it low.
    }

    /// EVENTS_IN[%s] Register bits
    namespace events_in[%s]_bits {
        constexpr uint32_t EVENTS_IN = (1U << 0);  ///< Event generated from pin specified in CONFIG[n].PSEL
    }

    /// EVENTS_PORT Register bits
    namespace events_port_bits {
        constexpr uint32_t EVENTS_PORT = (1U << 0);  ///< Event generated from multiple input GPIO pins with SENSE mechanism enabled
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t IN0 = (1U << 0);  ///< Write '1' to enable interrupt for event IN[0]
        constexpr uint32_t IN1 = (1U << 1);  ///< Write '1' to enable interrupt for event IN[1]
        constexpr uint32_t IN2 = (1U << 2);  ///< Write '1' to enable interrupt for event IN[2]
        constexpr uint32_t IN3 = (1U << 3);  ///< Write '1' to enable interrupt for event IN[3]
        constexpr uint32_t IN4 = (1U << 4);  ///< Write '1' to enable interrupt for event IN[4]
        constexpr uint32_t IN5 = (1U << 5);  ///< Write '1' to enable interrupt for event IN[5]
        constexpr uint32_t IN6 = (1U << 6);  ///< Write '1' to enable interrupt for event IN[6]
        constexpr uint32_t IN7 = (1U << 7);  ///< Write '1' to enable interrupt for event IN[7]
        constexpr uint32_t PORT = (1U << 31);  ///< Write '1' to enable interrupt for event PORT
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t IN0 = (1U << 0);  ///< Write '1' to disable interrupt for event IN[0]
        constexpr uint32_t IN1 = (1U << 1);  ///< Write '1' to disable interrupt for event IN[1]
        constexpr uint32_t IN2 = (1U << 2);  ///< Write '1' to disable interrupt for event IN[2]
        constexpr uint32_t IN3 = (1U << 3);  ///< Write '1' to disable interrupt for event IN[3]
        constexpr uint32_t IN4 = (1U << 4);  ///< Write '1' to disable interrupt for event IN[4]
        constexpr uint32_t IN5 = (1U << 5);  ///< Write '1' to disable interrupt for event IN[5]
        constexpr uint32_t IN6 = (1U << 6);  ///< Write '1' to disable interrupt for event IN[6]
        constexpr uint32_t IN7 = (1U << 7);  ///< Write '1' to disable interrupt for event IN[7]
        constexpr uint32_t PORT = (1U << 31);  ///< Write '1' to disable interrupt for event PORT
    }

    /// CONFIG[%s] Register bits
    namespace config[%s]_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Mode
        constexpr uint32_t PSEL = (5 << 8);  ///< GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event
        constexpr uint32_t POLARITY = (2 << 16);  ///< When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event.
        constexpr uint32_t OUTINIT = (1U << 20);  ///< When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect.
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t SAADC_BASE = 0x40007000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start the ADC and prepare the result buffer in RAM
        volatile uint32_t TASKS_SAMPLE;  ///< Offset: 0x04 - Take one ADC sample, if scan is enabled all channels are sampled
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x08 - Stop the ADC and terminate any on-going conversion
        volatile uint32_t TASKS_CALIBRATEOFFSET;  ///< Offset: 0x0C - Starts offset auto-calibration
        volatile uint32_t EVENTS_STARTED;  ///< Offset: 0x100 - The ADC has started
        volatile uint32_t EVENTS_END;  ///< Offset: 0x104 - The ADC has filled up the Result buffer
        volatile uint32_t EVENTS_DONE;  ///< Offset: 0x108 - A conversion task has been completed. Depending on the...
        volatile uint32_t EVENTS_RESULTDONE;  ///< Offset: 0x10C - A result is ready to get transferred to RAM.
        volatile uint32_t EVENTS_CALIBRATEDONE;  ///< Offset: 0x110 - Calibration is complete
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x114 - The ADC has stopped
        volatile uint32_t LIMITH;  ///< Offset: 0x00 - Description cluster: Last results is equal or above...
        volatile uint32_t LIMITL;  ///< Offset: 0x04 - Description cluster: Last results is equal or below...
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t STATUS;  ///< Offset: 0x400 - Status
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable or disable ADC
        volatile uint32_t PSELP;  ///< Offset: 0x00 - Description cluster: Input positive pin selection for CH[n]
        volatile uint32_t PSELN;  ///< Offset: 0x04 - Description cluster: Input negative pin selection for CH[n]
        volatile uint32_t CONFIG;  ///< Offset: 0x08 - Description cluster: Input configuration for CH[n]
        volatile uint32_t LIMIT;  ///< Offset: 0x0C - Description cluster: High/low limits for event...
        volatile uint32_t RESOLUTION;  ///< Offset: 0x5F0 - Resolution configuration
        volatile uint32_t OVERSAMPLE;  ///< Offset: 0x5F4 - Oversampling configuration. OVERSAMPLE should not be...
        volatile uint32_t SAMPLERATE;  ///< Offset: 0x5F8 - Controls normal or continuous sample rate
        volatile uint32_t PTR;  ///< Offset: 0x00 - Data pointer
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Maximum number of buffer words to transfer
        volatile uint32_t AMOUNT;  ///< Offset: 0x08 - Number of buffer words transferred since last START
    };

    /// Peripheral instances
    inline Registers* SAADC = reinterpret_cast<Registers*>(SAADC_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start the ADC and prepare the result buffer in RAM
    }

    /// TASKS_SAMPLE Register bits
    namespace tasks_sample_bits {
        constexpr uint32_t TASKS_SAMPLE = (1U << 0);  ///< Take one ADC sample, if scan is enabled all channels are sampled
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop the ADC and terminate any on-going conversion
    }

    /// TASKS_CALIBRATEOFFSET Register bits
    namespace tasks_calibrateoffset_bits {
        constexpr uint32_t TASKS_CALIBRATEOFFSET = (1U << 0);  ///< Starts offset auto-calibration
    }

    /// EVENTS_STARTED Register bits
    namespace events_started_bits {
        constexpr uint32_t EVENTS_STARTED = (1U << 0);  ///< The ADC has started
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< The ADC has filled up the Result buffer
    }

    /// EVENTS_DONE Register bits
    namespace events_done_bits {
        constexpr uint32_t EVENTS_DONE = (1U << 0);  ///< A conversion task has been completed. Depending on the mode, multiple conversions might be needed for a result to be transferred to RAM.
    }

    /// EVENTS_RESULTDONE Register bits
    namespace events_resultdone_bits {
        constexpr uint32_t EVENTS_RESULTDONE = (1U << 0);  ///< A result is ready to get transferred to RAM.
    }

    /// EVENTS_CALIBRATEDONE Register bits
    namespace events_calibratedone_bits {
        constexpr uint32_t EVENTS_CALIBRATEDONE = (1U << 0);  ///< Calibration is complete
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< The ADC has stopped
    }

    /// LIMITH Register bits
    namespace limith_bits {
        constexpr uint32_t LIMITH = (1U << 0);  ///< Last results is equal or above CH[n].LIMIT.HIGH
    }

    /// LIMITL Register bits
    namespace limitl_bits {
        constexpr uint32_t LIMITL = (1U << 0);  ///< Last results is equal or below CH[n].LIMIT.LOW
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Enable or disable interrupt for event STARTED
        constexpr uint32_t END = (1U << 1);  ///< Enable or disable interrupt for event END
        constexpr uint32_t DONE = (1U << 2);  ///< Enable or disable interrupt for event DONE
        constexpr uint32_t RESULTDONE = (1U << 3);  ///< Enable or disable interrupt for event RESULTDONE
        constexpr uint32_t CALIBRATEDONE = (1U << 4);  ///< Enable or disable interrupt for event CALIBRATEDONE
        constexpr uint32_t STOPPED = (1U << 5);  ///< Enable or disable interrupt for event STOPPED
        constexpr uint32_t CH0LIMITH = (1U << 6);  ///< Enable or disable interrupt for event CH0LIMITH
        constexpr uint32_t CH0LIMITL = (1U << 7);  ///< Enable or disable interrupt for event CH0LIMITL
        constexpr uint32_t CH1LIMITH = (1U << 8);  ///< Enable or disable interrupt for event CH1LIMITH
        constexpr uint32_t CH1LIMITL = (1U << 9);  ///< Enable or disable interrupt for event CH1LIMITL
        constexpr uint32_t CH2LIMITH = (1U << 10);  ///< Enable or disable interrupt for event CH2LIMITH
        constexpr uint32_t CH2LIMITL = (1U << 11);  ///< Enable or disable interrupt for event CH2LIMITL
        constexpr uint32_t CH3LIMITH = (1U << 12);  ///< Enable or disable interrupt for event CH3LIMITH
        constexpr uint32_t CH3LIMITL = (1U << 13);  ///< Enable or disable interrupt for event CH3LIMITL
        constexpr uint32_t CH4LIMITH = (1U << 14);  ///< Enable or disable interrupt for event CH4LIMITH
        constexpr uint32_t CH4LIMITL = (1U << 15);  ///< Enable or disable interrupt for event CH4LIMITL
        constexpr uint32_t CH5LIMITH = (1U << 16);  ///< Enable or disable interrupt for event CH5LIMITH
        constexpr uint32_t CH5LIMITL = (1U << 17);  ///< Enable or disable interrupt for event CH5LIMITL
        constexpr uint32_t CH6LIMITH = (1U << 18);  ///< Enable or disable interrupt for event CH6LIMITH
        constexpr uint32_t CH6LIMITL = (1U << 19);  ///< Enable or disable interrupt for event CH6LIMITL
        constexpr uint32_t CH7LIMITH = (1U << 20);  ///< Enable or disable interrupt for event CH7LIMITH
        constexpr uint32_t CH7LIMITL = (1U << 21);  ///< Enable or disable interrupt for event CH7LIMITL
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Write '1' to enable interrupt for event STARTED
        constexpr uint32_t END = (1U << 1);  ///< Write '1' to enable interrupt for event END
        constexpr uint32_t DONE = (1U << 2);  ///< Write '1' to enable interrupt for event DONE
        constexpr uint32_t RESULTDONE = (1U << 3);  ///< Write '1' to enable interrupt for event RESULTDONE
        constexpr uint32_t CALIBRATEDONE = (1U << 4);  ///< Write '1' to enable interrupt for event CALIBRATEDONE
        constexpr uint32_t STOPPED = (1U << 5);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t CH0LIMITH = (1U << 6);  ///< Write '1' to enable interrupt for event CH0LIMITH
        constexpr uint32_t CH0LIMITL = (1U << 7);  ///< Write '1' to enable interrupt for event CH0LIMITL
        constexpr uint32_t CH1LIMITH = (1U << 8);  ///< Write '1' to enable interrupt for event CH1LIMITH
        constexpr uint32_t CH1LIMITL = (1U << 9);  ///< Write '1' to enable interrupt for event CH1LIMITL
        constexpr uint32_t CH2LIMITH = (1U << 10);  ///< Write '1' to enable interrupt for event CH2LIMITH
        constexpr uint32_t CH2LIMITL = (1U << 11);  ///< Write '1' to enable interrupt for event CH2LIMITL
        constexpr uint32_t CH3LIMITH = (1U << 12);  ///< Write '1' to enable interrupt for event CH3LIMITH
        constexpr uint32_t CH3LIMITL = (1U << 13);  ///< Write '1' to enable interrupt for event CH3LIMITL
        constexpr uint32_t CH4LIMITH = (1U << 14);  ///< Write '1' to enable interrupt for event CH4LIMITH
        constexpr uint32_t CH4LIMITL = (1U << 15);  ///< Write '1' to enable interrupt for event CH4LIMITL
        constexpr uint32_t CH5LIMITH = (1U << 16);  ///< Write '1' to enable interrupt for event CH5LIMITH
        constexpr uint32_t CH5LIMITL = (1U << 17);  ///< Write '1' to enable interrupt for event CH5LIMITL
        constexpr uint32_t CH6LIMITH = (1U << 18);  ///< Write '1' to enable interrupt for event CH6LIMITH
        constexpr uint32_t CH6LIMITL = (1U << 19);  ///< Write '1' to enable interrupt for event CH6LIMITL
        constexpr uint32_t CH7LIMITH = (1U << 20);  ///< Write '1' to enable interrupt for event CH7LIMITH
        constexpr uint32_t CH7LIMITL = (1U << 21);  ///< Write '1' to enable interrupt for event CH7LIMITL
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Write '1' to disable interrupt for event STARTED
        constexpr uint32_t END = (1U << 1);  ///< Write '1' to disable interrupt for event END
        constexpr uint32_t DONE = (1U << 2);  ///< Write '1' to disable interrupt for event DONE
        constexpr uint32_t RESULTDONE = (1U << 3);  ///< Write '1' to disable interrupt for event RESULTDONE
        constexpr uint32_t CALIBRATEDONE = (1U << 4);  ///< Write '1' to disable interrupt for event CALIBRATEDONE
        constexpr uint32_t STOPPED = (1U << 5);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t CH0LIMITH = (1U << 6);  ///< Write '1' to disable interrupt for event CH0LIMITH
        constexpr uint32_t CH0LIMITL = (1U << 7);  ///< Write '1' to disable interrupt for event CH0LIMITL
        constexpr uint32_t CH1LIMITH = (1U << 8);  ///< Write '1' to disable interrupt for event CH1LIMITH
        constexpr uint32_t CH1LIMITL = (1U << 9);  ///< Write '1' to disable interrupt for event CH1LIMITL
        constexpr uint32_t CH2LIMITH = (1U << 10);  ///< Write '1' to disable interrupt for event CH2LIMITH
        constexpr uint32_t CH2LIMITL = (1U << 11);  ///< Write '1' to disable interrupt for event CH2LIMITL
        constexpr uint32_t CH3LIMITH = (1U << 12);  ///< Write '1' to disable interrupt for event CH3LIMITH
        constexpr uint32_t CH3LIMITL = (1U << 13);  ///< Write '1' to disable interrupt for event CH3LIMITL
        constexpr uint32_t CH4LIMITH = (1U << 14);  ///< Write '1' to disable interrupt for event CH4LIMITH
        constexpr uint32_t CH4LIMITL = (1U << 15);  ///< Write '1' to disable interrupt for event CH4LIMITL
        constexpr uint32_t CH5LIMITH = (1U << 16);  ///< Write '1' to disable interrupt for event CH5LIMITH
        constexpr uint32_t CH5LIMITL = (1U << 17);  ///< Write '1' to disable interrupt for event CH5LIMITL
        constexpr uint32_t CH6LIMITH = (1U << 18);  ///< Write '1' to disable interrupt for event CH6LIMITH
        constexpr uint32_t CH6LIMITL = (1U << 19);  ///< Write '1' to disable interrupt for event CH6LIMITL
        constexpr uint32_t CH7LIMITH = (1U << 20);  ///< Write '1' to disable interrupt for event CH7LIMITH
        constexpr uint32_t CH7LIMITL = (1U << 21);  ///< Write '1' to disable interrupt for event CH7LIMITL
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATUS = (1U << 0);  ///< Status
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable ADC
    }

    /// PSELP Register bits
    namespace pselp_bits {
        constexpr uint32_t PSELP = (5 << 0);  ///< Analog positive input channel
    }

    /// PSELN Register bits
    namespace pseln_bits {
        constexpr uint32_t PSELN = (5 << 0);  ///< Analog negative input, enables differential channel
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t RESP = (2 << 0);  ///< Positive channel resistor control
        constexpr uint32_t RESN = (2 << 4);  ///< Negative channel resistor control
        constexpr uint32_t GAIN = (3 << 8);  ///< Gain control
        constexpr uint32_t REFSEL = (1U << 12);  ///< Reference control
        constexpr uint32_t TACQ = (3 << 16);  ///< Acquisition time, the time the ADC uses to sample the input voltage
        constexpr uint32_t MODE = (1U << 20);  ///< Enable differential mode
        constexpr uint32_t BURST = (1U << 24);  ///< Enable burst mode
    }

    /// LIMIT Register bits
    namespace limit_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low level limit
        constexpr uint32_t HIGH = (16 << 16);  ///< High level limit
    }

    /// RESOLUTION Register bits
    namespace resolution_bits {
        constexpr uint32_t VAL = (3 << 0);  ///< Set the resolution
    }

    /// OVERSAMPLE Register bits
    namespace oversample_bits {
        constexpr uint32_t OVERSAMPLE = (4 << 0);  ///< Oversample control
    }

    /// SAMPLERATE Register bits
    namespace samplerate_bits {
        constexpr uint32_t CC = (11 << 0);  ///< Capture and compare value. Sample rate is 16 MHz/CC
        constexpr uint32_t MODE = (1U << 12);  ///< Select mode for sample rate control
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Data pointer
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t MAXCNT = (15 << 0);  ///< Maximum number of buffer words to transfer
    }

    /// AMOUNT Register bits
    namespace amount_bits {
        constexpr uint32_t AMOUNT = (15 << 0);  ///< Number of buffer words transferred since last START. This register can be read after an END or STOPPED event.
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER0_BASE = 0x40008000;
    constexpr uint32_t TIMER1_BASE = 0x40009000;
    constexpr uint32_t TIMER2_BASE = 0x4000A000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start Timer
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop Timer
        volatile uint32_t TASKS_COUNT;  ///< Offset: 0x08 - Increment Timer (Counter mode only)
        volatile uint32_t TASKS_CLEAR;  ///< Offset: 0x0C - Clear time
        volatile uint32_t TASKS_SHUTDOWN;  ///< Offset: 0x10 - Deprecated register - Shut down timer
        volatile uint32_t TASKS_CAPTURE[%s];  ///< Offset: 0x40 - Description collection: Capture Timer value to CC[n] register
        volatile uint32_t EVENTS_COMPARE[%s];  ///< Offset: 0x140 - Description collection: Compare event on CC[n] match
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t MODE;  ///< Offset: 0x504 - Timer mode selection
        volatile uint32_t BITMODE;  ///< Offset: 0x508 - Configure the number of bits used by the TIMER
        volatile uint32_t PRESCALER;  ///< Offset: 0x510 - Timer prescaler register
        volatile uint32_t CC[%s];  ///< Offset: 0x540 - Description collection: Capture/Compare register n
    };

    /// Peripheral instances
    inline Registers* TIMER0 = reinterpret_cast<Registers*>(TIMER0_BASE);
    inline Registers* TIMER1 = reinterpret_cast<Registers*>(TIMER1_BASE);
    inline Registers* TIMER2 = reinterpret_cast<Registers*>(TIMER2_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start Timer
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop Timer
    }

    /// TASKS_COUNT Register bits
    namespace tasks_count_bits {
        constexpr uint32_t TASKS_COUNT = (1U << 0);  ///< Increment Timer (Counter mode only)
    }

    /// TASKS_CLEAR Register bits
    namespace tasks_clear_bits {
        constexpr uint32_t TASKS_CLEAR = (1U << 0);  ///< Clear time
    }

    /// TASKS_SHUTDOWN Register bits
    namespace tasks_shutdown_bits {
        constexpr uint32_t TASKS_SHUTDOWN = (1U << 0);  ///< Deprecated field - Shut down timer
    }

    /// TASKS_CAPTURE[%s] Register bits
    namespace tasks_capture[%s]_bits {
        constexpr uint32_t TASKS_CAPTURE = (1U << 0);  ///< Capture Timer value to CC[n] register
    }

    /// EVENTS_COMPARE[%s] Register bits
    namespace events_compare[%s]_bits {
        constexpr uint32_t EVENTS_COMPARE = (1U << 0);  ///< Compare event on CC[n] match
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t COMPARE0_CLEAR = (1U << 0);  ///< Shortcut between event COMPARE[0] and task CLEAR
        constexpr uint32_t COMPARE1_CLEAR = (1U << 1);  ///< Shortcut between event COMPARE[1] and task CLEAR
        constexpr uint32_t COMPARE2_CLEAR = (1U << 2);  ///< Shortcut between event COMPARE[2] and task CLEAR
        constexpr uint32_t COMPARE3_CLEAR = (1U << 3);  ///< Shortcut between event COMPARE[3] and task CLEAR
        constexpr uint32_t COMPARE4_CLEAR = (1U << 4);  ///< Shortcut between event COMPARE[4] and task CLEAR
        constexpr uint32_t COMPARE5_CLEAR = (1U << 5);  ///< Shortcut between event COMPARE[5] and task CLEAR
        constexpr uint32_t COMPARE0_STOP = (1U << 8);  ///< Shortcut between event COMPARE[0] and task STOP
        constexpr uint32_t COMPARE1_STOP = (1U << 9);  ///< Shortcut between event COMPARE[1] and task STOP
        constexpr uint32_t COMPARE2_STOP = (1U << 10);  ///< Shortcut between event COMPARE[2] and task STOP
        constexpr uint32_t COMPARE3_STOP = (1U << 11);  ///< Shortcut between event COMPARE[3] and task STOP
        constexpr uint32_t COMPARE4_STOP = (1U << 12);  ///< Shortcut between event COMPARE[4] and task STOP
        constexpr uint32_t COMPARE5_STOP = (1U << 13);  ///< Shortcut between event COMPARE[5] and task STOP
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to enable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to enable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to enable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to enable interrupt for event COMPARE[3]
        constexpr uint32_t COMPARE4 = (1U << 20);  ///< Write '1' to enable interrupt for event COMPARE[4]
        constexpr uint32_t COMPARE5 = (1U << 21);  ///< Write '1' to enable interrupt for event COMPARE[5]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to disable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to disable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to disable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to disable interrupt for event COMPARE[3]
        constexpr uint32_t COMPARE4 = (1U << 20);  ///< Write '1' to disable interrupt for event COMPARE[4]
        constexpr uint32_t COMPARE5 = (1U << 21);  ///< Write '1' to disable interrupt for event COMPARE[5]
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Timer mode
    }

    /// BITMODE Register bits
    namespace bitmode_bits {
        constexpr uint32_t BITMODE = (2 << 0);  ///< Timer bit width
    }

    /// PRESCALER Register bits
    namespace prescaler_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< Prescaler value
    }

    /// CC[%s] Register bits
    namespace cc[%s]_bits {
        constexpr uint32_t CC = (32 << 0);  ///< Capture/Compare value
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC0_BASE = 0x4000B000;
    constexpr uint32_t RTC1_BASE = 0x40011000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start RTC COUNTER
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop RTC COUNTER
        volatile uint32_t TASKS_CLEAR;  ///< Offset: 0x08 - Clear RTC COUNTER
        volatile uint32_t TASKS_TRIGOVRFLW;  ///< Offset: 0x0C - Set COUNTER to 0xFFFFF0
        volatile uint32_t EVENTS_TICK;  ///< Offset: 0x100 - Event on COUNTER increment
        volatile uint32_t EVENTS_OVRFLW;  ///< Offset: 0x104 - Event on COUNTER overflow
        volatile uint32_t EVENTS_COMPARE[%s];  ///< Offset: 0x140 - Description collection: Compare event on CC[n] match
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t EVTEN;  ///< Offset: 0x340 - Enable or disable event routing
        volatile uint32_t EVTENSET;  ///< Offset: 0x344 - Enable event routing
        volatile uint32_t EVTENCLR;  ///< Offset: 0x348 - Disable event routing
        volatile uint32_t COUNTER;  ///< Offset: 0x504 - Current COUNTER value
        volatile uint32_t PRESCALER;  ///< Offset: 0x508 - 12 bit prescaler for COUNTER frequency...
        volatile uint32_t CC[%s];  ///< Offset: 0x540 - Description collection: Compare register n
    };

    /// Peripheral instances
    inline Registers* RTC0 = reinterpret_cast<Registers*>(RTC0_BASE);
    inline Registers* RTC1 = reinterpret_cast<Registers*>(RTC1_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start RTC COUNTER
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop RTC COUNTER
    }

    /// TASKS_CLEAR Register bits
    namespace tasks_clear_bits {
        constexpr uint32_t TASKS_CLEAR = (1U << 0);  ///< Clear RTC COUNTER
    }

    /// TASKS_TRIGOVRFLW Register bits
    namespace tasks_trigovrflw_bits {
        constexpr uint32_t TASKS_TRIGOVRFLW = (1U << 0);  ///< Set COUNTER to 0xFFFFF0
    }

    /// EVENTS_TICK Register bits
    namespace events_tick_bits {
        constexpr uint32_t EVENTS_TICK = (1U << 0);  ///< Event on COUNTER increment
    }

    /// EVENTS_OVRFLW Register bits
    namespace events_ovrflw_bits {
        constexpr uint32_t EVENTS_OVRFLW = (1U << 0);  ///< Event on COUNTER overflow
    }

    /// EVENTS_COMPARE[%s] Register bits
    namespace events_compare[%s]_bits {
        constexpr uint32_t EVENTS_COMPARE = (1U << 0);  ///< Compare event on CC[n] match
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to enable interrupt for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to enable interrupt for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to enable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to enable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to enable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to enable interrupt for event COMPARE[3]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to disable interrupt for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to disable interrupt for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to disable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to disable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to disable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to disable interrupt for event COMPARE[3]
    }

    /// EVTEN Register bits
    namespace evten_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Enable or disable event routing for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Enable or disable event routing for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Enable or disable event routing for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Enable or disable event routing for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Enable or disable event routing for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Enable or disable event routing for event COMPARE[3]
    }

    /// EVTENSET Register bits
    namespace evtenset_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to enable event routing for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to enable event routing for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to enable event routing for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to enable event routing for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to enable event routing for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to enable event routing for event COMPARE[3]
    }

    /// EVTENCLR Register bits
    namespace evtenclr_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to disable event routing for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to disable event routing for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to disable event routing for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to disable event routing for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to disable event routing for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to disable event routing for event COMPARE[3]
    }

    /// COUNTER Register bits
    namespace counter_bits {
        constexpr uint32_t COUNTER = (24 << 0);  ///< Counter value
    }

    /// PRESCALER Register bits
    namespace prescaler_bits {
        constexpr uint32_t PRESCALER = (12 << 0);  ///< Prescaler value
    }

    /// CC[%s] Register bits
    namespace cc[%s]_bits {
        constexpr uint32_t COMPARE = (24 << 0);  ///< Compare value
    }

}

// ============================================================================
// TEMP Peripheral
// ============================================================================

namespace temp {
    /// Base addresses
    constexpr uint32_t TEMP_BASE = 0x4000C000;

    /// TEMP Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start temperature measurement
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop temperature measurement
        volatile uint32_t EVENTS_DATARDY;  ///< Offset: 0x100 - Temperature measurement complete, data ready
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t TEMP;  ///< Offset: 0x508 - Temperature in degC (0.25deg steps)
        volatile uint32_t A0;  ///< Offset: 0x520 - Slope of 1st piece wise linear function
        volatile uint32_t A1;  ///< Offset: 0x524 - Slope of 2nd piece wise linear function
        volatile uint32_t A2;  ///< Offset: 0x528 - Slope of 3rd piece wise linear function
        volatile uint32_t A3;  ///< Offset: 0x52C - Slope of 4th piece wise linear function
        volatile uint32_t A4;  ///< Offset: 0x530 - Slope of 5th piece wise linear function
        volatile uint32_t A5;  ///< Offset: 0x534 - Slope of 6th piece wise linear function
        volatile uint32_t B0;  ///< Offset: 0x540 - y-intercept of 1st piece wise linear function
        volatile uint32_t B1;  ///< Offset: 0x544 - y-intercept of 2nd piece wise linear function
        volatile uint32_t B2;  ///< Offset: 0x548 - y-intercept of 3rd piece wise linear function
        volatile uint32_t B3;  ///< Offset: 0x54C - y-intercept of 4th piece wise linear function
        volatile uint32_t B4;  ///< Offset: 0x550 - y-intercept of 5th piece wise linear function
        volatile uint32_t B5;  ///< Offset: 0x554 - y-intercept of 6th piece wise linear function
        volatile uint32_t T0;  ///< Offset: 0x560 - End point of 1st piece wise linear function
        volatile uint32_t T1;  ///< Offset: 0x564 - End point of 2nd piece wise linear function
        volatile uint32_t T2;  ///< Offset: 0x568 - End point of 3rd piece wise linear function
        volatile uint32_t T3;  ///< Offset: 0x56C - End point of 4th piece wise linear function
        volatile uint32_t T4;  ///< Offset: 0x570 - End point of 5th piece wise linear function
    };

    /// Peripheral instances
    inline Registers* TEMP = reinterpret_cast<Registers*>(TEMP_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start temperature measurement
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop temperature measurement
    }

    /// EVENTS_DATARDY Register bits
    namespace events_datardy_bits {
        constexpr uint32_t EVENTS_DATARDY = (1U << 0);  ///< Temperature measurement complete, data ready
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Write '1' to enable interrupt for event DATARDY
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Write '1' to disable interrupt for event DATARDY
    }

    /// TEMP Register bits
    namespace temp_bits {
        constexpr uint32_t TEMP = (32 << 0);  ///< Temperature in degC (0.25deg steps)
    }

    /// A0 Register bits
    namespace a0_bits {
        constexpr uint32_t A0 = (12 << 0);  ///< Slope of 1st piece wise linear function
    }

    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t A1 = (12 << 0);  ///< Slope of 2nd piece wise linear function
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t A2 = (12 << 0);  ///< Slope of 3rd piece wise linear function
    }

    /// A3 Register bits
    namespace a3_bits {
        constexpr uint32_t A3 = (12 << 0);  ///< Slope of 4th piece wise linear function
    }

    /// A4 Register bits
    namespace a4_bits {
        constexpr uint32_t A4 = (12 << 0);  ///< Slope of 5th piece wise linear function
    }

    /// A5 Register bits
    namespace a5_bits {
        constexpr uint32_t A5 = (12 << 0);  ///< Slope of 6th piece wise linear function
    }

    /// B0 Register bits
    namespace b0_bits {
        constexpr uint32_t B0 = (14 << 0);  ///< y-intercept of 1st piece wise linear function
    }

    /// B1 Register bits
    namespace b1_bits {
        constexpr uint32_t B1 = (14 << 0);  ///< y-intercept of 2nd piece wise linear function
    }

    /// B2 Register bits
    namespace b2_bits {
        constexpr uint32_t B2 = (14 << 0);  ///< y-intercept of 3rd piece wise linear function
    }

    /// B3 Register bits
    namespace b3_bits {
        constexpr uint32_t B3 = (14 << 0);  ///< y-intercept of 4th piece wise linear function
    }

    /// B4 Register bits
    namespace b4_bits {
        constexpr uint32_t B4 = (14 << 0);  ///< y-intercept of 5th piece wise linear function
    }

    /// B5 Register bits
    namespace b5_bits {
        constexpr uint32_t B5 = (14 << 0);  ///< y-intercept of 6th piece wise linear function
    }

    /// T0 Register bits
    namespace t0_bits {
        constexpr uint32_t T0 = (8 << 0);  ///< End point of 1st piece wise linear function
    }

    /// T1 Register bits
    namespace t1_bits {
        constexpr uint32_t T1 = (8 << 0);  ///< End point of 2nd piece wise linear function
    }

    /// T2 Register bits
    namespace t2_bits {
        constexpr uint32_t T2 = (8 << 0);  ///< End point of 3rd piece wise linear function
    }

    /// T3 Register bits
    namespace t3_bits {
        constexpr uint32_t T3 = (8 << 0);  ///< End point of 4th piece wise linear function
    }

    /// T4 Register bits
    namespace t4_bits {
        constexpr uint32_t T4 = (8 << 0);  ///< End point of 5th piece wise linear function
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x4000D000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Task starting the random number generator
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Task stopping the random number generator
        volatile uint32_t EVENTS_VALRDY;  ///< Offset: 0x100 - Event being generated for every new random number...
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t CONFIG;  ///< Offset: 0x504 - Configuration register
        volatile uint32_t VALUE;  ///< Offset: 0x508 - Output random number
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Task starting the random number generator
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Task stopping the random number generator
    }

    /// EVENTS_VALRDY Register bits
    namespace events_valrdy_bits {
        constexpr uint32_t EVENTS_VALRDY = (1U << 0);  ///< Event being generated for every new random number written to the VALUE register
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t VALRDY_STOP = (1U << 0);  ///< Shortcut between event VALRDY and task STOP
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t VALRDY = (1U << 0);  ///< Write '1' to enable interrupt for event VALRDY
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t VALRDY = (1U << 0);  ///< Write '1' to disable interrupt for event VALRDY
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t DERCEN = (1U << 0);  ///< Bias correction
    }

    /// VALUE Register bits
    namespace value_bits {
        constexpr uint32_t VALUE = (8 << 0);  ///< Generated random number
    }

}

// ============================================================================
// ECB Peripheral
// ============================================================================

namespace ecb {
    /// Base addresses
    constexpr uint32_t ECB_BASE = 0x4000E000;

    /// ECB Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTECB;  ///< Offset: 0x00 - Start ECB block encrypt
        volatile uint32_t TASKS_STOPECB;  ///< Offset: 0x04 - Abort a possible executing ECB operation
        volatile uint32_t EVENTS_ENDECB;  ///< Offset: 0x100 - ECB block encrypt complete
        volatile uint32_t EVENTS_ERRORECB;  ///< Offset: 0x104 - ECB block encrypt aborted because of a STOPECB task or...
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ECBDATAPTR;  ///< Offset: 0x504 - ECB block encrypt memory pointers
    };

    /// Peripheral instances
    inline Registers* ECB = reinterpret_cast<Registers*>(ECB_BASE);

    // Bit definitions
    /// TASKS_STARTECB Register bits
    namespace tasks_startecb_bits {
        constexpr uint32_t TASKS_STARTECB = (1U << 0);  ///< Start ECB block encrypt
    }

    /// TASKS_STOPECB Register bits
    namespace tasks_stopecb_bits {
        constexpr uint32_t TASKS_STOPECB = (1U << 0);  ///< Abort a possible executing ECB operation
    }

    /// EVENTS_ENDECB Register bits
    namespace events_endecb_bits {
        constexpr uint32_t EVENTS_ENDECB = (1U << 0);  ///< ECB block encrypt complete
    }

    /// EVENTS_ERRORECB Register bits
    namespace events_errorecb_bits {
        constexpr uint32_t EVENTS_ERRORECB = (1U << 0);  ///< ECB block encrypt aborted because of a STOPECB task or due to an error
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t ENDECB = (1U << 0);  ///< Write '1' to enable interrupt for event ENDECB
        constexpr uint32_t ERRORECB = (1U << 1);  ///< Write '1' to enable interrupt for event ERRORECB
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t ENDECB = (1U << 0);  ///< Write '1' to disable interrupt for event ENDECB
        constexpr uint32_t ERRORECB = (1U << 1);  ///< Write '1' to disable interrupt for event ERRORECB
    }

    /// ECBDATAPTR Register bits
    namespace ecbdataptr_bits {
        constexpr uint32_t ECBDATAPTR = (32 << 0);  ///< Pointer to the ECB data structure (see Table 1 ECB data structure overview)
    }

}

// ============================================================================
// AAR Peripheral
// ============================================================================

namespace aar {
    /// Base addresses
    constexpr uint32_t AAR_BASE = 0x4000F000;

    /// AAR Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start resolving addresses based on IRKs specified in the...
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x08 - Stop resolving addresses
        volatile uint32_t EVENTS_END;  ///< Offset: 0x100 - Address resolution procedure complete
        volatile uint32_t EVENTS_RESOLVED;  ///< Offset: 0x104 - Address resolved
        volatile uint32_t EVENTS_NOTRESOLVED;  ///< Offset: 0x108 - Address not resolved
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t STATUS;  ///< Offset: 0x400 - Resolution status
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable AAR
        volatile uint32_t NIRK;  ///< Offset: 0x504 - Number of IRKs
        volatile uint32_t IRKPTR;  ///< Offset: 0x508 - Pointer to IRK data structure
        volatile uint32_t ADDRPTR;  ///< Offset: 0x510 - Pointer to the resolvable address
        volatile uint32_t SCRATCHPTR;  ///< Offset: 0x514 - Pointer to data area used for temporary storage
    };

    /// Peripheral instances
    inline Registers* AAR = reinterpret_cast<Registers*>(AAR_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start resolving addresses based on IRKs specified in the IRK data structure
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop resolving addresses
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< Address resolution procedure complete
    }

    /// EVENTS_RESOLVED Register bits
    namespace events_resolved_bits {
        constexpr uint32_t EVENTS_RESOLVED = (1U << 0);  ///< Address resolved
    }

    /// EVENTS_NOTRESOLVED Register bits
    namespace events_notresolved_bits {
        constexpr uint32_t EVENTS_NOTRESOLVED = (1U << 0);  ///< Address not resolved
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t END = (1U << 0);  ///< Write '1' to enable interrupt for event END
        constexpr uint32_t RESOLVED = (1U << 1);  ///< Write '1' to enable interrupt for event RESOLVED
        constexpr uint32_t NOTRESOLVED = (1U << 2);  ///< Write '1' to enable interrupt for event NOTRESOLVED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t END = (1U << 0);  ///< Write '1' to disable interrupt for event END
        constexpr uint32_t RESOLVED = (1U << 1);  ///< Write '1' to disable interrupt for event RESOLVED
        constexpr uint32_t NOTRESOLVED = (1U << 2);  ///< Write '1' to disable interrupt for event NOTRESOLVED
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATUS = (4 << 0);  ///< The IRK that was used last time an address was resolved
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (2 << 0);  ///< Enable or disable AAR
    }

    /// NIRK Register bits
    namespace nirk_bits {
        constexpr uint32_t NIRK = (5 << 0);  ///< Number of Identity root keys available in the IRK data structure
    }

    /// IRKPTR Register bits
    namespace irkptr_bits {
        constexpr uint32_t IRKPTR = (32 << 0);  ///< Pointer to the IRK data structure
    }

    /// ADDRPTR Register bits
    namespace addrptr_bits {
        constexpr uint32_t ADDRPTR = (32 << 0);  ///< Pointer to the resolvable address (6-bytes)
    }

    /// SCRATCHPTR Register bits
    namespace scratchptr_bits {
        constexpr uint32_t SCRATCHPTR = (32 << 0);  ///< Pointer to a scratch data area used for temporary storage during resolution.A space of minimum 3 bytes must be reserved.
    }

}

// ============================================================================
// CCM Peripheral
// ============================================================================

namespace ccm {
    /// Base addresses
    constexpr uint32_t CCM_BASE = 0x4000F000;

    /// CCM Register structure
    struct Registers {
        volatile uint32_t TASKS_KSGEN;  ///< Offset: 0x00 - Start generation of key-stream. This operation will stop...
        volatile uint32_t TASKS_CRYPT;  ///< Offset: 0x04 - Start encryption/decryption. This operation will stop by...
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x08 - Stop encryption/decryption
        volatile uint32_t TASKS_RATEOVERRIDE;  ///< Offset: 0x0C - Override DATARATE setting in MODE register with the...
        volatile uint32_t EVENTS_ENDKSGEN;  ///< Offset: 0x100 - Key-stream generation complete
        volatile uint32_t EVENTS_ENDCRYPT;  ///< Offset: 0x104 - Encrypt/decrypt complete
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x108 - Deprecated register - CCM error event
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t MICSTATUS;  ///< Offset: 0x400 - MIC check result
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable
        volatile uint32_t MODE;  ///< Offset: 0x504 - Operation mode
        volatile uint32_t CNFPTR;  ///< Offset: 0x508 - Pointer to data structure holding AES key and NONCE vector
        volatile uint32_t INPTR;  ///< Offset: 0x50C - Input pointer
        volatile uint32_t OUTPTR;  ///< Offset: 0x510 - Output pointer
        volatile uint32_t SCRATCHPTR;  ///< Offset: 0x514 - Pointer to data area used for temporary storage
        volatile uint32_t MAXPACKETSIZE;  ///< Offset: 0x518 - Length of key-stream generated when MODE.LENGTH = Extended.
        volatile uint32_t RATEOVERRIDE;  ///< Offset: 0x51C - Data rate override setting.
    };

    /// Peripheral instances
    inline Registers* CCM = reinterpret_cast<Registers*>(CCM_BASE);

    // Bit definitions
    /// TASKS_KSGEN Register bits
    namespace tasks_ksgen_bits {
        constexpr uint32_t TASKS_KSGEN = (1U << 0);  ///< Start generation of key-stream. This operation will stop by itself when completed.
    }

    /// TASKS_CRYPT Register bits
    namespace tasks_crypt_bits {
        constexpr uint32_t TASKS_CRYPT = (1U << 0);  ///< Start encryption/decryption. This operation will stop by itself when completed.
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop encryption/decryption
    }

    /// TASKS_RATEOVERRIDE Register bits
    namespace tasks_rateoverride_bits {
        constexpr uint32_t TASKS_RATEOVERRIDE = (1U << 0);  ///< Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption
    }

    /// EVENTS_ENDKSGEN Register bits
    namespace events_endksgen_bits {
        constexpr uint32_t EVENTS_ENDKSGEN = (1U << 0);  ///< Key-stream generation complete
    }

    /// EVENTS_ENDCRYPT Register bits
    namespace events_endcrypt_bits {
        constexpr uint32_t EVENTS_ENDCRYPT = (1U << 0);  ///< Encrypt/decrypt complete
    }

    /// EVENTS_ERROR Register bits
    namespace events_error_bits {
        constexpr uint32_t EVENTS_ERROR = (1U << 0);  ///< Deprecated field - CCM error event
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t ENDKSGEN_CRYPT = (1U << 0);  ///< Shortcut between event ENDKSGEN and task CRYPT
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t ENDKSGEN = (1U << 0);  ///< Write '1' to enable interrupt for event ENDKSGEN
        constexpr uint32_t ENDCRYPT = (1U << 1);  ///< Write '1' to enable interrupt for event ENDCRYPT
        constexpr uint32_t ERROR = (1U << 2);  ///< Deprecated intsetfield - Write '1' to enable interrupt for event ERROR
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t ENDKSGEN = (1U << 0);  ///< Write '1' to disable interrupt for event ENDKSGEN
        constexpr uint32_t ENDCRYPT = (1U << 1);  ///< Write '1' to disable interrupt for event ENDCRYPT
        constexpr uint32_t ERROR = (1U << 2);  ///< Deprecated intclrfield - Write '1' to disable interrupt for event ERROR
    }

    /// MICSTATUS Register bits
    namespace micstatus_bits {
        constexpr uint32_t MICSTATUS = (1U << 0);  ///< The result of the MIC check performed during the previous decryption operation
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (2 << 0);  ///< Enable or disable CCM
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< The mode of operation to be used. The settings in this register apply whenever either the KSGEN or CRYPT tasks are triggered.
        constexpr uint32_t DATARATE = (2 << 16);  ///< Radio data rate that the CCM shall run synchronous with
        constexpr uint32_t LENGTH = (1U << 24);  ///< Packet length configuration
    }

    /// CNFPTR Register bits
    namespace cnfptr_bits {
        constexpr uint32_t CNFPTR = (32 << 0);  ///< Pointer to the data structure holding the AES key and the CCM NONCE vector (see Table 1 CCM data structure overview)
    }

    /// INPTR Register bits
    namespace inptr_bits {
        constexpr uint32_t INPTR = (32 << 0);  ///< Input pointer
    }

    /// OUTPTR Register bits
    namespace outptr_bits {
        constexpr uint32_t OUTPTR = (32 << 0);  ///< Output pointer
    }

    /// SCRATCHPTR Register bits
    namespace scratchptr_bits {
        constexpr uint32_t SCRATCHPTR = (32 << 0);  ///< Pointer to a scratch data area used for temporary storage during key-stream generation, MIC generation and encryption/decryption.
    }

    /// MAXPACKETSIZE Register bits
    namespace maxpacketsize_bits {
        constexpr uint32_t MAXPACKETSIZE = (8 << 0);  ///< Length of key-stream generated when MODE.LENGTH = Extended. This value must be greater or equal to the subsequent packet payload to be encrypted/decrypted.
    }

    /// RATEOVERRIDE Register bits
    namespace rateoverride_bits {
        constexpr uint32_t RATEOVERRIDE = (2 << 0);  ///< Data rate override setting.
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40010000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start the watchdog
        volatile uint32_t EVENTS_TIMEOUT;  ///< Offset: 0x100 - Watchdog timeout
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t RUNSTATUS;  ///< Offset: 0x400 - Run status
        volatile uint32_t REQSTATUS;  ///< Offset: 0x404 - Request status
        volatile uint32_t CRV;  ///< Offset: 0x504 - Counter reload value
        volatile uint32_t RREN;  ///< Offset: 0x508 - Enable register for reload request registers
        volatile uint32_t CONFIG;  ///< Offset: 0x50C - Configuration register
        volatile uint32_t RR[%s];  ///< Offset: 0x600 - Description collection: Reload request n
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start the watchdog
    }

    /// EVENTS_TIMEOUT Register bits
    namespace events_timeout_bits {
        constexpr uint32_t EVENTS_TIMEOUT = (1U << 0);  ///< Watchdog timeout
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TIMEOUT = (1U << 0);  ///< Write '1' to enable interrupt for event TIMEOUT
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TIMEOUT = (1U << 0);  ///< Write '1' to disable interrupt for event TIMEOUT
    }

    /// RUNSTATUS Register bits
    namespace runstatus_bits {
        constexpr uint32_t RUNSTATUS = (1U << 0);  ///< Indicates whether or not the watchdog is running
    }

    /// REQSTATUS Register bits
    namespace reqstatus_bits {
        constexpr uint32_t RR0 = (1U << 0);  ///< Request status for RR[0] register
        constexpr uint32_t RR1 = (1U << 1);  ///< Request status for RR[1] register
        constexpr uint32_t RR2 = (1U << 2);  ///< Request status for RR[2] register
        constexpr uint32_t RR3 = (1U << 3);  ///< Request status for RR[3] register
        constexpr uint32_t RR4 = (1U << 4);  ///< Request status for RR[4] register
        constexpr uint32_t RR5 = (1U << 5);  ///< Request status for RR[5] register
        constexpr uint32_t RR6 = (1U << 6);  ///< Request status for RR[6] register
        constexpr uint32_t RR7 = (1U << 7);  ///< Request status for RR[7] register
    }

    /// CRV Register bits
    namespace crv_bits {
        constexpr uint32_t CRV = (32 << 0);  ///< Counter reload value in number of cycles of the 32.768 kHz clock
    }

    /// RREN Register bits
    namespace rren_bits {
        constexpr uint32_t RR0 = (1U << 0);  ///< Enable or disable RR[0] register
        constexpr uint32_t RR1 = (1U << 1);  ///< Enable or disable RR[1] register
        constexpr uint32_t RR2 = (1U << 2);  ///< Enable or disable RR[2] register
        constexpr uint32_t RR3 = (1U << 3);  ///< Enable or disable RR[3] register
        constexpr uint32_t RR4 = (1U << 4);  ///< Enable or disable RR[4] register
        constexpr uint32_t RR5 = (1U << 5);  ///< Enable or disable RR[5] register
        constexpr uint32_t RR6 = (1U << 6);  ///< Enable or disable RR[6] register
        constexpr uint32_t RR7 = (1U << 7);  ///< Enable or disable RR[7] register
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t SLEEP = (1U << 0);  ///< Configure the watchdog to either be paused, or kept running, while the CPU is sleeping
        constexpr uint32_t HALT = (1U << 3);  ///< Configure the watchdog to either be paused, or kept running, while the CPU is halted by the debugger
    }

    /// RR[%s] Register bits
    namespace rr[%s]_bits {
        constexpr uint32_t RR = (32 << 0);  ///< Reload request register
    }

}

// ============================================================================
// QDEC Peripheral
// ============================================================================

namespace qdec {
    /// Base addresses
    constexpr uint32_t QDEC_BASE = 0x40012000;

    /// QDEC Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Task starting the quadrature decoder
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Task stopping the quadrature decoder
        volatile uint32_t TASKS_READCLRACC;  ///< Offset: 0x08 - Read and clear ACC and ACCDBL
        volatile uint32_t TASKS_RDCLRACC;  ///< Offset: 0x0C - Read and clear ACC
        volatile uint32_t TASKS_RDCLRDBL;  ///< Offset: 0x10 - Read and clear ACCDBL
        volatile uint32_t EVENTS_SAMPLERDY;  ///< Offset: 0x100 - Event being generated for every new sample value written...
        volatile uint32_t EVENTS_REPORTRDY;  ///< Offset: 0x104 - Non-null report ready
        volatile uint32_t EVENTS_ACCOF;  ///< Offset: 0x108 - ACC or ACCDBL register overflow
        volatile uint32_t EVENTS_DBLRDY;  ///< Offset: 0x10C - Double displacement(s) detected
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x110 - QDEC has been stopped
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable the quadrature decoder
        volatile uint32_t LEDPOL;  ///< Offset: 0x504 - LED output pin polarity
        volatile uint32_t SAMPLEPER;  ///< Offset: 0x508 - Sample period
        volatile uint32_t SAMPLE;  ///< Offset: 0x50C - Motion sample value
        volatile uint32_t REPORTPER;  ///< Offset: 0x510 - Number of samples to be taken before REPORTRDY and...
        volatile uint32_t ACC;  ///< Offset: 0x514 - Register accumulating the valid transitions
        volatile uint32_t ACCREAD;  ///< Offset: 0x518 - Snapshot of the ACC register, updated by the READCLRACC...
        volatile uint32_t LED;  ///< Offset: 0x00 - Pin select for LED signal
        volatile uint32_t A;  ///< Offset: 0x04 - Pin select for A signal
        volatile uint32_t B;  ///< Offset: 0x08 - Pin select for B signal
        volatile uint32_t DBFEN;  ///< Offset: 0x528 - Enable input debounce filters
        volatile uint32_t LEDPRE;  ///< Offset: 0x540 - Time period the LED is switched ON prior to sampling
        volatile uint32_t ACCDBL;  ///< Offset: 0x544 - Register accumulating the number of detected double transitions
        volatile uint32_t ACCDBLREAD;  ///< Offset: 0x548 - Snapshot of the ACCDBL, updated by the READCLRACC or...
    };

    /// Peripheral instances
    inline Registers* QDEC = reinterpret_cast<Registers*>(QDEC_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Task starting the quadrature decoder
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Task stopping the quadrature decoder
    }

    /// TASKS_READCLRACC Register bits
    namespace tasks_readclracc_bits {
        constexpr uint32_t TASKS_READCLRACC = (1U << 0);  ///< Read and clear ACC and ACCDBL
    }

    /// TASKS_RDCLRACC Register bits
    namespace tasks_rdclracc_bits {
        constexpr uint32_t TASKS_RDCLRACC = (1U << 0);  ///< Read and clear ACC
    }

    /// TASKS_RDCLRDBL Register bits
    namespace tasks_rdclrdbl_bits {
        constexpr uint32_t TASKS_RDCLRDBL = (1U << 0);  ///< Read and clear ACCDBL
    }

    /// EVENTS_SAMPLERDY Register bits
    namespace events_samplerdy_bits {
        constexpr uint32_t EVENTS_SAMPLERDY = (1U << 0);  ///< Event being generated for every new sample value written to the SAMPLE register
    }

    /// EVENTS_REPORTRDY Register bits
    namespace events_reportrdy_bits {
        constexpr uint32_t EVENTS_REPORTRDY = (1U << 0);  ///< Non-null report ready
    }

    /// EVENTS_ACCOF Register bits
    namespace events_accof_bits {
        constexpr uint32_t EVENTS_ACCOF = (1U << 0);  ///< ACC or ACCDBL register overflow
    }

    /// EVENTS_DBLRDY Register bits
    namespace events_dblrdy_bits {
        constexpr uint32_t EVENTS_DBLRDY = (1U << 0);  ///< Double displacement(s) detected
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< QDEC has been stopped
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t REPORTRDY_READCLRACC = (1U << 0);  ///< Shortcut between event REPORTRDY and task READCLRACC
        constexpr uint32_t SAMPLERDY_STOP = (1U << 1);  ///< Shortcut between event SAMPLERDY and task STOP
        constexpr uint32_t REPORTRDY_RDCLRACC = (1U << 2);  ///< Shortcut between event REPORTRDY and task RDCLRACC
        constexpr uint32_t REPORTRDY_STOP = (1U << 3);  ///< Shortcut between event REPORTRDY and task STOP
        constexpr uint32_t DBLRDY_RDCLRDBL = (1U << 4);  ///< Shortcut between event DBLRDY and task RDCLRDBL
        constexpr uint32_t DBLRDY_STOP = (1U << 5);  ///< Shortcut between event DBLRDY and task STOP
        constexpr uint32_t SAMPLERDY_READCLRACC = (1U << 6);  ///< Shortcut between event SAMPLERDY and task READCLRACC
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t SAMPLERDY = (1U << 0);  ///< Write '1' to enable interrupt for event SAMPLERDY
        constexpr uint32_t REPORTRDY = (1U << 1);  ///< Write '1' to enable interrupt for event REPORTRDY
        constexpr uint32_t ACCOF = (1U << 2);  ///< Write '1' to enable interrupt for event ACCOF
        constexpr uint32_t DBLRDY = (1U << 3);  ///< Write '1' to enable interrupt for event DBLRDY
        constexpr uint32_t STOPPED = (1U << 4);  ///< Write '1' to enable interrupt for event STOPPED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t SAMPLERDY = (1U << 0);  ///< Write '1' to disable interrupt for event SAMPLERDY
        constexpr uint32_t REPORTRDY = (1U << 1);  ///< Write '1' to disable interrupt for event REPORTRDY
        constexpr uint32_t ACCOF = (1U << 2);  ///< Write '1' to disable interrupt for event ACCOF
        constexpr uint32_t DBLRDY = (1U << 3);  ///< Write '1' to disable interrupt for event DBLRDY
        constexpr uint32_t STOPPED = (1U << 4);  ///< Write '1' to disable interrupt for event STOPPED
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable the quadrature decoder
    }

    /// LEDPOL Register bits
    namespace ledpol_bits {
        constexpr uint32_t LEDPOL = (1U << 0);  ///< LED output pin polarity
    }

    /// SAMPLEPER Register bits
    namespace sampleper_bits {
        constexpr uint32_t SAMPLEPER = (4 << 0);  ///< Sample period. The SAMPLE register will be updated for every new sample
    }

    /// SAMPLE Register bits
    namespace sample_bits {
        constexpr uint32_t SAMPLE = (32 << 0);  ///< Last motion sample
    }

    /// REPORTPER Register bits
    namespace reportper_bits {
        constexpr uint32_t REPORTPER = (4 << 0);  ///< Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated
    }

    /// ACC Register bits
    namespace acc_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< Register accumulating all valid samples (not double transition) read from the SAMPLE register
    }

    /// ACCREAD Register bits
    namespace accread_bits {
        constexpr uint32_t ACCREAD = (32 << 0);  ///< Snapshot of the ACC register.
    }

    /// LED Register bits
    namespace led_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// A Register bits
    namespace a_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// B Register bits
    namespace b_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// DBFEN Register bits
    namespace dbfen_bits {
        constexpr uint32_t DBFEN = (1U << 0);  ///< Enable input debounce filters
    }

    /// LEDPRE Register bits
    namespace ledpre_bits {
        constexpr uint32_t LEDPRE = (9 << 0);  ///< Period in us the LED is switched on prior to sampling
    }

    /// ACCDBL Register bits
    namespace accdbl_bits {
        constexpr uint32_t ACCDBL = (4 << 0);  ///< Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 ).
    }

    /// ACCDBLREAD Register bits
    namespace accdblread_bits {
        constexpr uint32_t ACCDBLREAD = (4 << 0);  ///< Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered.
    }

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMP_BASE = 0x40013000;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start comparator
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop comparator
        volatile uint32_t TASKS_SAMPLE;  ///< Offset: 0x08 - Sample comparator value
        volatile uint32_t EVENTS_READY;  ///< Offset: 0x100 - COMP is ready and output is valid
        volatile uint32_t EVENTS_DOWN;  ///< Offset: 0x104 - Downward crossing
        volatile uint32_t EVENTS_UP;  ///< Offset: 0x108 - Upward crossing
        volatile uint32_t EVENTS_CROSS;  ///< Offset: 0x10C - Downward or upward crossing
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t RESULT;  ///< Offset: 0x400 - Compare result
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - COMP enable
        volatile uint32_t PSEL;  ///< Offset: 0x504 - Pin select
        volatile uint32_t REFSEL;  ///< Offset: 0x508 - Reference source select for single-ended mode
        volatile uint32_t EXTREFSEL;  ///< Offset: 0x50C - External reference select
        volatile uint32_t TH;  ///< Offset: 0x530 - Threshold configuration for hysteresis unit
        volatile uint32_t MODE;  ///< Offset: 0x534 - Mode configuration
        volatile uint32_t HYST;  ///< Offset: 0x538 - Comparator hysteresis enable
    };

    /// Peripheral instances
    inline Registers* COMP = reinterpret_cast<Registers*>(COMP_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start comparator
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop comparator
    }

    /// TASKS_SAMPLE Register bits
    namespace tasks_sample_bits {
        constexpr uint32_t TASKS_SAMPLE = (1U << 0);  ///< Sample comparator value
    }

    /// EVENTS_READY Register bits
    namespace events_ready_bits {
        constexpr uint32_t EVENTS_READY = (1U << 0);  ///< COMP is ready and output is valid
    }

    /// EVENTS_DOWN Register bits
    namespace events_down_bits {
        constexpr uint32_t EVENTS_DOWN = (1U << 0);  ///< Downward crossing
    }

    /// EVENTS_UP Register bits
    namespace events_up_bits {
        constexpr uint32_t EVENTS_UP = (1U << 0);  ///< Upward crossing
    }

    /// EVENTS_CROSS Register bits
    namespace events_cross_bits {
        constexpr uint32_t EVENTS_CROSS = (1U << 0);  ///< Downward or upward crossing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t READY_SAMPLE = (1U << 0);  ///< Shortcut between event READY and task SAMPLE
        constexpr uint32_t READY_STOP = (1U << 1);  ///< Shortcut between event READY and task STOP
        constexpr uint32_t DOWN_STOP = (1U << 2);  ///< Shortcut between event DOWN and task STOP
        constexpr uint32_t UP_STOP = (1U << 3);  ///< Shortcut between event UP and task STOP
        constexpr uint32_t CROSS_STOP = (1U << 4);  ///< Shortcut between event CROSS and task STOP
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Enable or disable interrupt for event READY
        constexpr uint32_t DOWN = (1U << 1);  ///< Enable or disable interrupt for event DOWN
        constexpr uint32_t UP = (1U << 2);  ///< Enable or disable interrupt for event UP
        constexpr uint32_t CROSS = (1U << 3);  ///< Enable or disable interrupt for event CROSS
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to enable interrupt for event READY
        constexpr uint32_t DOWN = (1U << 1);  ///< Write '1' to enable interrupt for event DOWN
        constexpr uint32_t UP = (1U << 2);  ///< Write '1' to enable interrupt for event UP
        constexpr uint32_t CROSS = (1U << 3);  ///< Write '1' to enable interrupt for event CROSS
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to disable interrupt for event READY
        constexpr uint32_t DOWN = (1U << 1);  ///< Write '1' to disable interrupt for event DOWN
        constexpr uint32_t UP = (1U << 2);  ///< Write '1' to disable interrupt for event UP
        constexpr uint32_t CROSS = (1U << 3);  ///< Write '1' to disable interrupt for event CROSS
    }

    /// RESULT Register bits
    namespace result_bits {
        constexpr uint32_t RESULT = (1U << 0);  ///< Result of last compare. Decision point SAMPLE task.
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (2 << 0);  ///< Enable or disable COMP
    }

    /// PSEL Register bits
    namespace psel_bits {
        constexpr uint32_t PSEL = (3 << 0);  ///< Analog pin select
    }

    /// REFSEL Register bits
    namespace refsel_bits {
        constexpr uint32_t REFSEL = (3 << 0);  ///< Reference select
    }

    /// EXTREFSEL Register bits
    namespace extrefsel_bits {
        constexpr uint32_t EXTREFSEL = (3 << 0);  ///< External analog reference select
    }

    /// TH Register bits
    namespace th_bits {
        constexpr uint32_t THDOWN = (6 << 0);  ///< VDOWN = (THDOWN+1)/64*VREF
        constexpr uint32_t THUP = (6 << 8);  ///< VUP = (THUP+1)/64*VREF
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t SP = (2 << 0);  ///< Speed and power modes
        constexpr uint32_t MAIN = (1U << 8);  ///< Main operation modes
    }

    /// HYST Register bits
    namespace hyst_bits {
        constexpr uint32_t HYST = (1U << 0);  ///< Comparator hysteresis
    }

}

// ============================================================================
// EGU0 Peripheral
// ============================================================================

namespace egu0 {
    /// Base addresses
    constexpr uint32_t EGU0_BASE = 0x40014000;

    /// EGU0 Register structure
    struct Registers {
        volatile uint32_t TASKS_TRIGGER[%s];  ///< Offset: 0x00 - Description collection: Trigger n for triggering the...
        volatile uint32_t EVENTS_TRIGGERED[%s];  ///< Offset: 0x100 - Description collection: Event number n generated by...
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
    };

    /// Peripheral instances
    inline Registers* EGU0 = reinterpret_cast<Registers*>(EGU0_BASE);

    // Bit definitions
    /// TASKS_TRIGGER[%s] Register bits
    namespace tasks_trigger[%s]_bits {
        constexpr uint32_t TASKS_TRIGGER = (1U << 0);  ///< Trigger n for triggering the corresponding TRIGGERED[n] event
    }

    /// EVENTS_TRIGGERED[%s] Register bits
    namespace events_triggered[%s]_bits {
        constexpr uint32_t EVENTS_TRIGGERED = (1U << 0);  ///< Event number n generated by triggering the corresponding TRIGGER[n] task
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t TRIGGERED0 = (1U << 0);  ///< Enable or disable interrupt for event TRIGGERED[0]
        constexpr uint32_t TRIGGERED1 = (1U << 1);  ///< Enable or disable interrupt for event TRIGGERED[1]
        constexpr uint32_t TRIGGERED2 = (1U << 2);  ///< Enable or disable interrupt for event TRIGGERED[2]
        constexpr uint32_t TRIGGERED3 = (1U << 3);  ///< Enable or disable interrupt for event TRIGGERED[3]
        constexpr uint32_t TRIGGERED4 = (1U << 4);  ///< Enable or disable interrupt for event TRIGGERED[4]
        constexpr uint32_t TRIGGERED5 = (1U << 5);  ///< Enable or disable interrupt for event TRIGGERED[5]
        constexpr uint32_t TRIGGERED6 = (1U << 6);  ///< Enable or disable interrupt for event TRIGGERED[6]
        constexpr uint32_t TRIGGERED7 = (1U << 7);  ///< Enable or disable interrupt for event TRIGGERED[7]
        constexpr uint32_t TRIGGERED8 = (1U << 8);  ///< Enable or disable interrupt for event TRIGGERED[8]
        constexpr uint32_t TRIGGERED9 = (1U << 9);  ///< Enable or disable interrupt for event TRIGGERED[9]
        constexpr uint32_t TRIGGERED10 = (1U << 10);  ///< Enable or disable interrupt for event TRIGGERED[10]
        constexpr uint32_t TRIGGERED11 = (1U << 11);  ///< Enable or disable interrupt for event TRIGGERED[11]
        constexpr uint32_t TRIGGERED12 = (1U << 12);  ///< Enable or disable interrupt for event TRIGGERED[12]
        constexpr uint32_t TRIGGERED13 = (1U << 13);  ///< Enable or disable interrupt for event TRIGGERED[13]
        constexpr uint32_t TRIGGERED14 = (1U << 14);  ///< Enable or disable interrupt for event TRIGGERED[14]
        constexpr uint32_t TRIGGERED15 = (1U << 15);  ///< Enable or disable interrupt for event TRIGGERED[15]
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TRIGGERED0 = (1U << 0);  ///< Write '1' to enable interrupt for event TRIGGERED[0]
        constexpr uint32_t TRIGGERED1 = (1U << 1);  ///< Write '1' to enable interrupt for event TRIGGERED[1]
        constexpr uint32_t TRIGGERED2 = (1U << 2);  ///< Write '1' to enable interrupt for event TRIGGERED[2]
        constexpr uint32_t TRIGGERED3 = (1U << 3);  ///< Write '1' to enable interrupt for event TRIGGERED[3]
        constexpr uint32_t TRIGGERED4 = (1U << 4);  ///< Write '1' to enable interrupt for event TRIGGERED[4]
        constexpr uint32_t TRIGGERED5 = (1U << 5);  ///< Write '1' to enable interrupt for event TRIGGERED[5]
        constexpr uint32_t TRIGGERED6 = (1U << 6);  ///< Write '1' to enable interrupt for event TRIGGERED[6]
        constexpr uint32_t TRIGGERED7 = (1U << 7);  ///< Write '1' to enable interrupt for event TRIGGERED[7]
        constexpr uint32_t TRIGGERED8 = (1U << 8);  ///< Write '1' to enable interrupt for event TRIGGERED[8]
        constexpr uint32_t TRIGGERED9 = (1U << 9);  ///< Write '1' to enable interrupt for event TRIGGERED[9]
        constexpr uint32_t TRIGGERED10 = (1U << 10);  ///< Write '1' to enable interrupt for event TRIGGERED[10]
        constexpr uint32_t TRIGGERED11 = (1U << 11);  ///< Write '1' to enable interrupt for event TRIGGERED[11]
        constexpr uint32_t TRIGGERED12 = (1U << 12);  ///< Write '1' to enable interrupt for event TRIGGERED[12]
        constexpr uint32_t TRIGGERED13 = (1U << 13);  ///< Write '1' to enable interrupt for event TRIGGERED[13]
        constexpr uint32_t TRIGGERED14 = (1U << 14);  ///< Write '1' to enable interrupt for event TRIGGERED[14]
        constexpr uint32_t TRIGGERED15 = (1U << 15);  ///< Write '1' to enable interrupt for event TRIGGERED[15]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TRIGGERED0 = (1U << 0);  ///< Write '1' to disable interrupt for event TRIGGERED[0]
        constexpr uint32_t TRIGGERED1 = (1U << 1);  ///< Write '1' to disable interrupt for event TRIGGERED[1]
        constexpr uint32_t TRIGGERED2 = (1U << 2);  ///< Write '1' to disable interrupt for event TRIGGERED[2]
        constexpr uint32_t TRIGGERED3 = (1U << 3);  ///< Write '1' to disable interrupt for event TRIGGERED[3]
        constexpr uint32_t TRIGGERED4 = (1U << 4);  ///< Write '1' to disable interrupt for event TRIGGERED[4]
        constexpr uint32_t TRIGGERED5 = (1U << 5);  ///< Write '1' to disable interrupt for event TRIGGERED[5]
        constexpr uint32_t TRIGGERED6 = (1U << 6);  ///< Write '1' to disable interrupt for event TRIGGERED[6]
        constexpr uint32_t TRIGGERED7 = (1U << 7);  ///< Write '1' to disable interrupt for event TRIGGERED[7]
        constexpr uint32_t TRIGGERED8 = (1U << 8);  ///< Write '1' to disable interrupt for event TRIGGERED[8]
        constexpr uint32_t TRIGGERED9 = (1U << 9);  ///< Write '1' to disable interrupt for event TRIGGERED[9]
        constexpr uint32_t TRIGGERED10 = (1U << 10);  ///< Write '1' to disable interrupt for event TRIGGERED[10]
        constexpr uint32_t TRIGGERED11 = (1U << 11);  ///< Write '1' to disable interrupt for event TRIGGERED[11]
        constexpr uint32_t TRIGGERED12 = (1U << 12);  ///< Write '1' to disable interrupt for event TRIGGERED[12]
        constexpr uint32_t TRIGGERED13 = (1U << 13);  ///< Write '1' to disable interrupt for event TRIGGERED[13]
        constexpr uint32_t TRIGGERED14 = (1U << 14);  ///< Write '1' to disable interrupt for event TRIGGERED[14]
        constexpr uint32_t TRIGGERED15 = (1U << 15);  ///< Write '1' to disable interrupt for event TRIGGERED[15]
    }

}

// ============================================================================
// SWI0 Peripheral
// ============================================================================

namespace swi0 {
    /// Base addresses
    constexpr uint32_t SWI0_BASE = 0x40014000;

    /// SWI0 Register structure
    struct Registers {
        volatile uint32_t UNUSED;  ///< Offset: 0x00 - Unused.
    };

    /// Peripheral instances
    inline Registers* SWI0 = reinterpret_cast<Registers*>(SWI0_BASE);

}

// ============================================================================
// EGU1 Peripheral
// ============================================================================

namespace egu1 {
    /// Base addresses
    constexpr uint32_t EGU1_BASE = 0x40015000;

    /// EGU1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* EGU1 = reinterpret_cast<Registers*>(EGU1_BASE);

}

// ============================================================================
// SWI1 Peripheral
// ============================================================================

namespace swi1 {
    /// Base addresses
    constexpr uint32_t SWI1_BASE = 0x40015000;

    /// SWI1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SWI1 = reinterpret_cast<Registers*>(SWI1_BASE);

}

// ============================================================================
// SWI2 Peripheral
// ============================================================================

namespace swi2 {
    /// Base addresses
    constexpr uint32_t SWI2_BASE = 0x40016000;

    /// SWI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SWI2 = reinterpret_cast<Registers*>(SWI2_BASE);

}

// ============================================================================
// SWI3 Peripheral
// ============================================================================

namespace swi3 {
    /// Base addresses
    constexpr uint32_t SWI3_BASE = 0x40017000;

    /// SWI3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SWI3 = reinterpret_cast<Registers*>(SWI3_BASE);

}

// ============================================================================
// SWI4 Peripheral
// ============================================================================

namespace swi4 {
    /// Base addresses
    constexpr uint32_t SWI4_BASE = 0x40018000;

    /// SWI4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SWI4 = reinterpret_cast<Registers*>(SWI4_BASE);

}

// ============================================================================
// SWI5 Peripheral
// ============================================================================

namespace swi5 {
    /// Base addresses
    constexpr uint32_t SWI5_BASE = 0x40019000;

    /// SWI5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SWI5 = reinterpret_cast<Registers*>(SWI5_BASE);

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t PWM0_BASE = 0x4001C000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stops PWM pulse generation on all channels at the end of...
        volatile uint32_t TASKS_SEQSTART[%s];  ///< Offset: 0x08 - Description collection: Loads the first PWM value on all...
        volatile uint32_t TASKS_NEXTSTEP;  ///< Offset: 0x10 - Steps by one value in the current sequence on all...
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - Response to STOP task, emitted when PWM pulses are no...
        volatile uint32_t EVENTS_SEQSTARTED[%s];  ///< Offset: 0x108 - Description collection: First PWM period started on sequence n
        volatile uint32_t EVENTS_SEQEND[%s];  ///< Offset: 0x110 - Description collection: Emitted at end of every sequence...
        volatile uint32_t EVENTS_PWMPERIODEND;  ///< Offset: 0x118 - Emitted at the end of each PWM period
        volatile uint32_t EVENTS_LOOPSDONE;  ///< Offset: 0x11C - Concatenated sequences have been played the amount of...
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - PWM module enable register
        volatile uint32_t MODE;  ///< Offset: 0x504 - Selects operating mode of the wave counter
        volatile uint32_t COUNTERTOP;  ///< Offset: 0x508 - Value up to which the pulse generator counter counts
        volatile uint32_t PRESCALER;  ///< Offset: 0x50C - Configuration for PWM_CLK
        volatile uint32_t DECODER;  ///< Offset: 0x510 - Configuration of the decoder
        volatile uint32_t LOOP;  ///< Offset: 0x514 - Number of playbacks of a loop
        volatile uint32_t PTR;  ///< Offset: 0x00 - Description cluster: Beginning address in RAM of this sequence
        volatile uint32_t CNT;  ///< Offset: 0x04 - Description cluster: Number of values (duty cycles) in...
        volatile uint32_t REFRESH;  ///< Offset: 0x08 - Description cluster: Number of additional PWM periods...
        volatile uint32_t ENDDELAY;  ///< Offset: 0x0C - Description cluster: Time added after the sequence
        volatile uint32_t OUT[%s];  ///< Offset: 0x00 - Description collection: Output pin select for PWM channel n
    };

    /// Peripheral instances
    inline Registers* PWM0 = reinterpret_cast<Registers*>(PWM0_BASE);

    // Bit definitions
    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
    }

    /// TASKS_SEQSTART[%s] Register bits
    namespace tasks_seqstart[%s]_bits {
        constexpr uint32_t TASKS_SEQSTART = (1U << 0);  ///< Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
    }

    /// TASKS_NEXTSTEP Register bits
    namespace tasks_nextstep_bits {
        constexpr uint32_t TASKS_NEXTSTEP = (1U << 0);  ///< Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< Response to STOP task, emitted when PWM pulses are no longer generated
    }

    /// EVENTS_SEQSTARTED[%s] Register bits
    namespace events_seqstarted[%s]_bits {
        constexpr uint32_t EVENTS_SEQSTARTED = (1U << 0);  ///< First PWM period started on sequence n
    }

    /// EVENTS_SEQEND[%s] Register bits
    namespace events_seqend[%s]_bits {
        constexpr uint32_t EVENTS_SEQEND = (1U << 0);  ///< Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
    }

    /// EVENTS_PWMPERIODEND Register bits
    namespace events_pwmperiodend_bits {
        constexpr uint32_t EVENTS_PWMPERIODEND = (1U << 0);  ///< Emitted at the end of each PWM period
    }

    /// EVENTS_LOOPSDONE Register bits
    namespace events_loopsdone_bits {
        constexpr uint32_t EVENTS_LOOPSDONE = (1U << 0);  ///< Concatenated sequences have been played the amount of times defined in LOOP.CNT
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t SEQEND0_STOP = (1U << 0);  ///< Shortcut between event SEQEND[0] and task STOP
        constexpr uint32_t SEQEND1_STOP = (1U << 1);  ///< Shortcut between event SEQEND[1] and task STOP
        constexpr uint32_t LOOPSDONE_SEQSTART0 = (1U << 2);  ///< Shortcut between event LOOPSDONE and task SEQSTART[0]
        constexpr uint32_t LOOPSDONE_SEQSTART1 = (1U << 3);  ///< Shortcut between event LOOPSDONE and task SEQSTART[1]
        constexpr uint32_t LOOPSDONE_STOP = (1U << 4);  ///< Shortcut between event LOOPSDONE and task STOP
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Enable or disable interrupt for event STOPPED
        constexpr uint32_t SEQSTARTED0 = (1U << 2);  ///< Enable or disable interrupt for event SEQSTARTED[0]
        constexpr uint32_t SEQSTARTED1 = (1U << 3);  ///< Enable or disable interrupt for event SEQSTARTED[1]
        constexpr uint32_t SEQEND0 = (1U << 4);  ///< Enable or disable interrupt for event SEQEND[0]
        constexpr uint32_t SEQEND1 = (1U << 5);  ///< Enable or disable interrupt for event SEQEND[1]
        constexpr uint32_t PWMPERIODEND = (1U << 6);  ///< Enable or disable interrupt for event PWMPERIODEND
        constexpr uint32_t LOOPSDONE = (1U << 7);  ///< Enable or disable interrupt for event LOOPSDONE
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t SEQSTARTED0 = (1U << 2);  ///< Write '1' to enable interrupt for event SEQSTARTED[0]
        constexpr uint32_t SEQSTARTED1 = (1U << 3);  ///< Write '1' to enable interrupt for event SEQSTARTED[1]
        constexpr uint32_t SEQEND0 = (1U << 4);  ///< Write '1' to enable interrupt for event SEQEND[0]
        constexpr uint32_t SEQEND1 = (1U << 5);  ///< Write '1' to enable interrupt for event SEQEND[1]
        constexpr uint32_t PWMPERIODEND = (1U << 6);  ///< Write '1' to enable interrupt for event PWMPERIODEND
        constexpr uint32_t LOOPSDONE = (1U << 7);  ///< Write '1' to enable interrupt for event LOOPSDONE
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t SEQSTARTED0 = (1U << 2);  ///< Write '1' to disable interrupt for event SEQSTARTED[0]
        constexpr uint32_t SEQSTARTED1 = (1U << 3);  ///< Write '1' to disable interrupt for event SEQSTARTED[1]
        constexpr uint32_t SEQEND0 = (1U << 4);  ///< Write '1' to disable interrupt for event SEQEND[0]
        constexpr uint32_t SEQEND1 = (1U << 5);  ///< Write '1' to disable interrupt for event SEQEND[1]
        constexpr uint32_t PWMPERIODEND = (1U << 6);  ///< Write '1' to disable interrupt for event PWMPERIODEND
        constexpr uint32_t LOOPSDONE = (1U << 7);  ///< Write '1' to disable interrupt for event LOOPSDONE
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable PWM module
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t UPDOWN = (1U << 0);  ///< Selects up mode or up-and-down mode for the counter
    }

    /// COUNTERTOP Register bits
    namespace countertop_bits {
        constexpr uint32_t COUNTERTOP = (15 << 0);  ///< Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used.
    }

    /// PRESCALER Register bits
    namespace prescaler_bits {
        constexpr uint32_t PRESCALER = (3 << 0);  ///< Prescaler of PWM_CLK
    }

    /// DECODER Register bits
    namespace decoder_bits {
        constexpr uint32_t LOAD = (2 << 0);  ///< How a sequence is read from RAM and spread to the compare register
        constexpr uint32_t MODE = (1U << 8);  ///< Selects source for advancing the active sequence
    }

    /// LOOP Register bits
    namespace loop_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Number of playbacks of pattern cycles
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Beginning address in RAM of this sequence
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (15 << 0);  ///< Number of values (duty cycles) in this sequence
    }

    /// REFRESH Register bits
    namespace refresh_bits {
        constexpr uint32_t CNT = (24 << 0);  ///< Number of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)
    }

    /// ENDDELAY Register bits
    namespace enddelay_bits {
        constexpr uint32_t CNT = (24 << 0);  ///< Time added after the sequence in PWM periods
    }

    /// OUT[%s] Register bits
    namespace out[%s]_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

}

// ============================================================================
// PDM Peripheral
// ============================================================================

namespace pdm {
    /// Base addresses
    constexpr uint32_t PDM_BASE = 0x4001D000;

    /// PDM Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Starts continuous PDM transfer
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stops PDM transfer
        volatile uint32_t EVENTS_STARTED;  ///< Offset: 0x100 - PDM transfer has started
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - PDM transfer has finished
        volatile uint32_t EVENTS_END;  ///< Offset: 0x108 - The PDM has written the last sample specified by...
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - PDM module enable register
        volatile uint32_t PDMCLKCTRL;  ///< Offset: 0x504 - PDM clock generator control
        volatile uint32_t MODE;  ///< Offset: 0x508 - Defines the routing of the connected PDM microphones' signals
        volatile uint32_t GAINL;  ///< Offset: 0x518 - Left output gain adjustment
        volatile uint32_t GAINR;  ///< Offset: 0x51C - Right output gain adjustment
        volatile uint32_t CLK;  ///< Offset: 0x00 - Pin number configuration for PDM CLK signal
        volatile uint32_t DIN;  ///< Offset: 0x04 - Pin number configuration for PDM DIN signal
        volatile uint32_t PTR;  ///< Offset: 0x00 - RAM address pointer to write samples to with EasyDMA
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Number of samples to allocate memory for in EasyDMA mode
    };

    /// Peripheral instances
    inline Registers* PDM = reinterpret_cast<Registers*>(PDM_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Starts continuous PDM transfer
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stops PDM transfer
    }

    /// EVENTS_STARTED Register bits
    namespace events_started_bits {
        constexpr uint32_t EVENTS_STARTED = (1U << 0);  ///< PDM transfer has started
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< PDM transfer has finished
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Enable or disable interrupt for event STARTED
        constexpr uint32_t STOPPED = (1U << 1);  ///< Enable or disable interrupt for event STOPPED
        constexpr uint32_t END = (1U << 2);  ///< Enable or disable interrupt for event END
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Write '1' to enable interrupt for event STARTED
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t END = (1U << 2);  ///< Write '1' to enable interrupt for event END
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Write '1' to disable interrupt for event STARTED
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t END = (1U << 2);  ///< Write '1' to disable interrupt for event END
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable PDM module
    }

    /// PDMCLKCTRL Register bits
    namespace pdmclkctrl_bits {
        constexpr uint32_t FREQ = (32 << 0);  ///< PDM_CLK frequency
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t OPERATION = (1U << 0);  ///< Mono or stereo operation
        constexpr uint32_t EDGE = (1U << 1);  ///< Defines on which PDM_CLK edge Left (or mono) is sampled
    }

    /// GAINL Register bits
    namespace gainl_bits {
        constexpr uint32_t GAINL = (7 << 0);  ///< Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00 -20 dB gain adjust 0x01 -19.5 dB gain adjust (...) 0x27 -0.5 dB gain adjust 0x28 0 dB gain adjust 0x29 +0.5 dB gain adjust (...) 0x4F +19.5 dB gain adjust 0x50 +20 dB gain adjust
    }

    /// GAINR Register bits
    namespace gainr_bits {
        constexpr uint32_t GAINR = (8 << 0);  ///< Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// DIN Register bits
    namespace din_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t SAMPLEPTR = (32 << 0);  ///< Address to write PDM samples to over DMA
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t BUFFSIZE = (15 << 0);  ///< Length of DMA RAM allocation in number of samples
    }

}

// ============================================================================
// NVMC Peripheral
// ============================================================================

namespace nvmc {
    /// Base addresses
    constexpr uint32_t NVMC_BASE = 0x4001E000;

    /// NVMC Register structure
    struct Registers {
        volatile uint32_t READY;  ///< Offset: 0x400 - Ready flag
        volatile uint32_t CONFIG;  ///< Offset: 0x504 - Configuration register
        volatile uint32_t ERASEPAGE;  ///< Offset: 0x508 - Register for erasing a page in code area
        volatile uint32_t ERASEPCR1;  ///< Offset: 0x508 - Deprecated register - Register for erasing a page in...
        volatile uint32_t ERASEALL;  ///< Offset: 0x50C - Register for erasing all non-volatile user memory
        volatile uint32_t ERASEPCR0;  ///< Offset: 0x510 - Deprecated register - Register for erasing a page in...
        volatile uint32_t ERASEUICR;  ///< Offset: 0x514 - Register for erasing user information configuration registers
        volatile uint32_t ERASEPAGEPARTIAL;  ///< Offset: 0x518 - Register for partial erase of a page in code area
        volatile uint32_t ERASEPAGEPARTIALCFG;  ///< Offset: 0x51C - Register for partial erase configuration
    };

    /// Peripheral instances
    inline Registers* NVMC = reinterpret_cast<Registers*>(NVMC_BASE);

    // Bit definitions
    /// READY Register bits
    namespace ready_bits {
        constexpr uint32_t READY = (1U << 0);  ///< NVMC is ready or busy
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t WEN = (2 << 0);  ///< Program memory access mode. It is strongly recommended to activate erase and write modes only when they are actively used.
    }

    /// ERASEPAGE Register bits
    namespace erasepage_bits {
        constexpr uint32_t ERASEPAGE = (32 << 0);  ///< Register for starting erase of a page in code area.
    }

    /// ERASEPCR1 Register bits
    namespace erasepcr1_bits {
        constexpr uint32_t ERASEPCR1 = (32 << 0);  ///< Register for erasing a page in code area. Equivalent to ERASEPAGE.
    }

    /// ERASEALL Register bits
    namespace eraseall_bits {
        constexpr uint32_t ERASEALL = (1U << 0);  ///< Erase all non-volatile memory including UICR registers. Note that the erase must be enabled using CONFIG.WEN before the non-volatile memory can be erased.
    }

    /// ERASEPCR0 Register bits
    namespace erasepcr0_bits {
        constexpr uint32_t ERASEPCR0 = (32 << 0);  ///< Register for starting erase of a page in code area. Equivalent to ERASEPAGE.
    }

    /// ERASEUICR Register bits
    namespace eraseuicr_bits {
        constexpr uint32_t ERASEUICR = (1U << 0);  ///< Register starting erase of all user information configuration registers. Note that the erase must be enabled using CONFIG.WEN before the UICR can be erased.
    }

    /// ERASEPAGEPARTIAL Register bits
    namespace erasepagepartial_bits {
        constexpr uint32_t ERASEPAGEPARTIAL = (32 << 0);  ///< Register for starting partial erase of a page in code area
    }

    /// ERASEPAGEPARTIALCFG Register bits
    namespace erasepagepartialcfg_bits {
        constexpr uint32_t DURATION = (7 << 0);  ///< Duration of the partial erase in milliseconds
    }

}

// ============================================================================
// PPI Peripheral
// ============================================================================

namespace ppi {
    /// Base addresses
    constexpr uint32_t PPI_BASE = 0x4001F000;

    /// PPI Register structure
    struct Registers {
        volatile uint32_t EN;  ///< Offset: 0x00 - Description cluster: Enable channel group n
        volatile uint32_t DIS;  ///< Offset: 0x04 - Description cluster: Disable channel group n
        volatile uint32_t CHEN;  ///< Offset: 0x500 - Channel enable register
        volatile uint32_t CHENSET;  ///< Offset: 0x504 - Channel enable set register
        volatile uint32_t CHENCLR;  ///< Offset: 0x508 - Channel enable clear register
        volatile uint32_t EEP;  ///< Offset: 0x00 - Description cluster: Channel n event end-point
        volatile uint32_t TEP;  ///< Offset: 0x00 - Description cluster: Channel n task end-point
        volatile uint32_t CHG[%s];  ///< Offset: 0x800 - Description collection: Channel group n
    };

    /// Peripheral instances
    inline Registers* PPI = reinterpret_cast<Registers*>(PPI_BASE);

    // Bit definitions
    /// EN Register bits
    namespace en_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable channel group n
    }

    /// DIS Register bits
    namespace dis_bits {
        constexpr uint32_t DIS = (1U << 0);  ///< Disable channel group n
    }

    /// CHEN Register bits
    namespace chen_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Enable or disable channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Enable or disable channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Enable or disable channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Enable or disable channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Enable or disable channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Enable or disable channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Enable or disable channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Enable or disable channel 7
        constexpr uint32_t CH8 = (1U << 8);  ///< Enable or disable channel 8
        constexpr uint32_t CH9 = (1U << 9);  ///< Enable or disable channel 9
        constexpr uint32_t CH10 = (1U << 10);  ///< Enable or disable channel 10
        constexpr uint32_t CH11 = (1U << 11);  ///< Enable or disable channel 11
        constexpr uint32_t CH12 = (1U << 12);  ///< Enable or disable channel 12
        constexpr uint32_t CH13 = (1U << 13);  ///< Enable or disable channel 13
        constexpr uint32_t CH14 = (1U << 14);  ///< Enable or disable channel 14
        constexpr uint32_t CH15 = (1U << 15);  ///< Enable or disable channel 15
        constexpr uint32_t CH16 = (1U << 16);  ///< Enable or disable channel 16
        constexpr uint32_t CH17 = (1U << 17);  ///< Enable or disable channel 17
        constexpr uint32_t CH18 = (1U << 18);  ///< Enable or disable channel 18
        constexpr uint32_t CH19 = (1U << 19);  ///< Enable or disable channel 19
        constexpr uint32_t CH20 = (1U << 20);  ///< Enable or disable channel 20
        constexpr uint32_t CH21 = (1U << 21);  ///< Enable or disable channel 21
        constexpr uint32_t CH22 = (1U << 22);  ///< Enable or disable channel 22
        constexpr uint32_t CH23 = (1U << 23);  ///< Enable or disable channel 23
        constexpr uint32_t CH24 = (1U << 24);  ///< Enable or disable channel 24
        constexpr uint32_t CH25 = (1U << 25);  ///< Enable or disable channel 25
        constexpr uint32_t CH26 = (1U << 26);  ///< Enable or disable channel 26
        constexpr uint32_t CH27 = (1U << 27);  ///< Enable or disable channel 27
        constexpr uint32_t CH28 = (1U << 28);  ///< Enable or disable channel 28
        constexpr uint32_t CH29 = (1U << 29);  ///< Enable or disable channel 29
        constexpr uint32_t CH30 = (1U << 30);  ///< Enable or disable channel 30
        constexpr uint32_t CH31 = (1U << 31);  ///< Enable or disable channel 31
    }

    /// CHENSET Register bits
    namespace chenset_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Channel 0 enable set register. Writing '0' has no effect
        constexpr uint32_t CH1 = (1U << 1);  ///< Channel 1 enable set register. Writing '0' has no effect
        constexpr uint32_t CH2 = (1U << 2);  ///< Channel 2 enable set register. Writing '0' has no effect
        constexpr uint32_t CH3 = (1U << 3);  ///< Channel 3 enable set register. Writing '0' has no effect
        constexpr uint32_t CH4 = (1U << 4);  ///< Channel 4 enable set register. Writing '0' has no effect
        constexpr uint32_t CH5 = (1U << 5);  ///< Channel 5 enable set register. Writing '0' has no effect
        constexpr uint32_t CH6 = (1U << 6);  ///< Channel 6 enable set register. Writing '0' has no effect
        constexpr uint32_t CH7 = (1U << 7);  ///< Channel 7 enable set register. Writing '0' has no effect
        constexpr uint32_t CH8 = (1U << 8);  ///< Channel 8 enable set register. Writing '0' has no effect
        constexpr uint32_t CH9 = (1U << 9);  ///< Channel 9 enable set register. Writing '0' has no effect
        constexpr uint32_t CH10 = (1U << 10);  ///< Channel 10 enable set register. Writing '0' has no effect
        constexpr uint32_t CH11 = (1U << 11);  ///< Channel 11 enable set register. Writing '0' has no effect
        constexpr uint32_t CH12 = (1U << 12);  ///< Channel 12 enable set register. Writing '0' has no effect
        constexpr uint32_t CH13 = (1U << 13);  ///< Channel 13 enable set register. Writing '0' has no effect
        constexpr uint32_t CH14 = (1U << 14);  ///< Channel 14 enable set register. Writing '0' has no effect
        constexpr uint32_t CH15 = (1U << 15);  ///< Channel 15 enable set register. Writing '0' has no effect
        constexpr uint32_t CH16 = (1U << 16);  ///< Channel 16 enable set register. Writing '0' has no effect
        constexpr uint32_t CH17 = (1U << 17);  ///< Channel 17 enable set register. Writing '0' has no effect
        constexpr uint32_t CH18 = (1U << 18);  ///< Channel 18 enable set register. Writing '0' has no effect
        constexpr uint32_t CH19 = (1U << 19);  ///< Channel 19 enable set register. Writing '0' has no effect
        constexpr uint32_t CH20 = (1U << 20);  ///< Channel 20 enable set register. Writing '0' has no effect
        constexpr uint32_t CH21 = (1U << 21);  ///< Channel 21 enable set register. Writing '0' has no effect
        constexpr uint32_t CH22 = (1U << 22);  ///< Channel 22 enable set register. Writing '0' has no effect
        constexpr uint32_t CH23 = (1U << 23);  ///< Channel 23 enable set register. Writing '0' has no effect
        constexpr uint32_t CH24 = (1U << 24);  ///< Channel 24 enable set register. Writing '0' has no effect
        constexpr uint32_t CH25 = (1U << 25);  ///< Channel 25 enable set register. Writing '0' has no effect
        constexpr uint32_t CH26 = (1U << 26);  ///< Channel 26 enable set register. Writing '0' has no effect
        constexpr uint32_t CH27 = (1U << 27);  ///< Channel 27 enable set register. Writing '0' has no effect
        constexpr uint32_t CH28 = (1U << 28);  ///< Channel 28 enable set register. Writing '0' has no effect
        constexpr uint32_t CH29 = (1U << 29);  ///< Channel 29 enable set register. Writing '0' has no effect
        constexpr uint32_t CH30 = (1U << 30);  ///< Channel 30 enable set register. Writing '0' has no effect
        constexpr uint32_t CH31 = (1U << 31);  ///< Channel 31 enable set register. Writing '0' has no effect
    }

    /// CHENCLR Register bits
    namespace chenclr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Channel 0 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH1 = (1U << 1);  ///< Channel 1 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH2 = (1U << 2);  ///< Channel 2 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH3 = (1U << 3);  ///< Channel 3 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH4 = (1U << 4);  ///< Channel 4 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH5 = (1U << 5);  ///< Channel 5 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH6 = (1U << 6);  ///< Channel 6 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH7 = (1U << 7);  ///< Channel 7 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH8 = (1U << 8);  ///< Channel 8 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH9 = (1U << 9);  ///< Channel 9 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH10 = (1U << 10);  ///< Channel 10 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH11 = (1U << 11);  ///< Channel 11 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH12 = (1U << 12);  ///< Channel 12 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH13 = (1U << 13);  ///< Channel 13 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH14 = (1U << 14);  ///< Channel 14 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH15 = (1U << 15);  ///< Channel 15 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH16 = (1U << 16);  ///< Channel 16 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH17 = (1U << 17);  ///< Channel 17 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH18 = (1U << 18);  ///< Channel 18 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH19 = (1U << 19);  ///< Channel 19 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH20 = (1U << 20);  ///< Channel 20 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH21 = (1U << 21);  ///< Channel 21 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH22 = (1U << 22);  ///< Channel 22 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH23 = (1U << 23);  ///< Channel 23 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH24 = (1U << 24);  ///< Channel 24 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH25 = (1U << 25);  ///< Channel 25 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH26 = (1U << 26);  ///< Channel 26 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH27 = (1U << 27);  ///< Channel 27 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH28 = (1U << 28);  ///< Channel 28 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH29 = (1U << 29);  ///< Channel 29 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH30 = (1U << 30);  ///< Channel 30 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH31 = (1U << 31);  ///< Channel 31 enable clear register. Writing '0' has no effect
    }

    /// EEP Register bits
    namespace eep_bits {
        constexpr uint32_t EEP = (32 << 0);  ///< Pointer to event register. Accepts only addresses to registers from the Event group.
    }

    /// TEP Register bits
    namespace tep_bits {
        constexpr uint32_t TEP = (32 << 0);  ///< Pointer to task register
    }

    /// CHG[%s] Register bits
    namespace chg[%s]_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Include or exclude channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Include or exclude channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Include or exclude channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Include or exclude channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Include or exclude channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Include or exclude channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Include or exclude channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Include or exclude channel 7
        constexpr uint32_t CH8 = (1U << 8);  ///< Include or exclude channel 8
        constexpr uint32_t CH9 = (1U << 9);  ///< Include or exclude channel 9
        constexpr uint32_t CH10 = (1U << 10);  ///< Include or exclude channel 10
        constexpr uint32_t CH11 = (1U << 11);  ///< Include or exclude channel 11
        constexpr uint32_t CH12 = (1U << 12);  ///< Include or exclude channel 12
        constexpr uint32_t CH13 = (1U << 13);  ///< Include or exclude channel 13
        constexpr uint32_t CH14 = (1U << 14);  ///< Include or exclude channel 14
        constexpr uint32_t CH15 = (1U << 15);  ///< Include or exclude channel 15
        constexpr uint32_t CH16 = (1U << 16);  ///< Include or exclude channel 16
        constexpr uint32_t CH17 = (1U << 17);  ///< Include or exclude channel 17
        constexpr uint32_t CH18 = (1U << 18);  ///< Include or exclude channel 18
        constexpr uint32_t CH19 = (1U << 19);  ///< Include or exclude channel 19
        constexpr uint32_t CH20 = (1U << 20);  ///< Include or exclude channel 20
        constexpr uint32_t CH21 = (1U << 21);  ///< Include or exclude channel 21
        constexpr uint32_t CH22 = (1U << 22);  ///< Include or exclude channel 22
        constexpr uint32_t CH23 = (1U << 23);  ///< Include or exclude channel 23
        constexpr uint32_t CH24 = (1U << 24);  ///< Include or exclude channel 24
        constexpr uint32_t CH25 = (1U << 25);  ///< Include or exclude channel 25
        constexpr uint32_t CH26 = (1U << 26);  ///< Include or exclude channel 26
        constexpr uint32_t CH27 = (1U << 27);  ///< Include or exclude channel 27
        constexpr uint32_t CH28 = (1U << 28);  ///< Include or exclude channel 28
        constexpr uint32_t CH29 = (1U << 29);  ///< Include or exclude channel 29
        constexpr uint32_t CH30 = (1U << 30);  ///< Include or exclude channel 30
        constexpr uint32_t CH31 = (1U << 31);  ///< Include or exclude channel 31
    }

}


} // namespace alloy::generated::nrf52810

#endif // ALLOY_GENERATED_NRF52810_PERIPHERALS_HPP