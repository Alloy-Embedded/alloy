/// Auto-generated code for nrf52840
/// Generated by Alloy Code Generator
/// Source: nordic_nrf52840.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:43:58
#ifndef ALLOY_GENERATED_NRF52840_PERIPHERALS_HPP
#define ALLOY_GENERATED_NRF52840_PERIPHERALS_HPP

#include <stdint.h>

namespace alloy::generated::nrf52840 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_ficr = true;
    constexpr uint32_t num_ficr_instances = 1;
    constexpr bool has_uicr = true;
    constexpr uint32_t num_uicr_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_p0 = true;
    constexpr uint32_t num_p0_instances = 1;
    constexpr bool has_p1 = true;
    constexpr uint32_t num_p1_instances = 1;
    constexpr bool has_radio = true;
    constexpr uint32_t num_radio_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 3;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 11;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 6;
    constexpr bool has_nfct = true;
    constexpr uint32_t num_nfct_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 5;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 3;
    constexpr bool has_temp = true;
    constexpr uint32_t num_temp_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_ecb = true;
    constexpr uint32_t num_ecb_instances = 1;
    constexpr bool has_aar = true;
    constexpr uint32_t num_aar_instances = 1;
    constexpr bool has_ccm = true;
    constexpr uint32_t num_ccm_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_qdec = true;
    constexpr uint32_t num_qdec_instances = 1;
    constexpr bool has_comp = true;
    constexpr uint32_t num_comp_instances = 1;
    constexpr bool has_lpcomp = true;
    constexpr uint32_t num_lpcomp_instances = 1;
    constexpr bool has_egu0 = true;
    constexpr uint32_t num_egu0_instances = 1;
    constexpr bool has_swi0 = true;
    constexpr uint32_t num_swi0_instances = 1;
    constexpr bool has_egu1 = true;
    constexpr uint32_t num_egu1_instances = 1;
    constexpr bool has_swi1 = true;
    constexpr uint32_t num_swi1_instances = 1;
    constexpr bool has_egu2 = true;
    constexpr uint32_t num_egu2_instances = 1;
    constexpr bool has_swi2 = true;
    constexpr uint32_t num_swi2_instances = 1;
    constexpr bool has_egu3 = true;
    constexpr uint32_t num_egu3_instances = 1;
    constexpr bool has_swi3 = true;
    constexpr uint32_t num_swi3_instances = 1;
    constexpr bool has_egu4 = true;
    constexpr uint32_t num_egu4_instances = 1;
    constexpr bool has_swi4 = true;
    constexpr uint32_t num_swi4_instances = 1;
    constexpr bool has_egu5 = true;
    constexpr uint32_t num_egu5_instances = 1;
    constexpr bool has_swi5 = true;
    constexpr uint32_t num_swi5_instances = 1;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 4;
    constexpr bool has_pdm = true;
    constexpr uint32_t num_pdm_instances = 1;
    constexpr bool has_acl = true;
    constexpr uint32_t num_acl_instances = 1;
    constexpr bool has_nvmc = true;
    constexpr uint32_t num_nvmc_instances = 1;
    constexpr bool has_ppi = true;
    constexpr uint32_t num_ppi_instances = 1;
    constexpr bool has_mwu = true;
    constexpr uint32_t num_mwu_instances = 1;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_fpu = true;
    constexpr uint32_t num_fpu_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_cc = true;
    constexpr uint32_t num_cc_instances = 1;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct ficr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct uicr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct p0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct p1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct radio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 11;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct nfct_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct temp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ecb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aar_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct qdec_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct comp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lpcomp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct egu0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct egu1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct egu2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct egu3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct egu4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct egu5_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi5_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct pdm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct acl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ppi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mwu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 1;
    constexpr uint32_t max_gpio_pins = 16;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uarte0 = true;
    constexpr bool has_uarte1 = true;
}

// ============================================================================
// FICR Peripheral
// ============================================================================

namespace ficr {
    /// Base addresses
    constexpr uint32_t FICR_BASE = 0x10000000;

    /// FICR Register structure
    struct Registers {
        volatile uint32_t CODEPAGESIZE;  ///< Offset: 0x10 - Code memory page size
        volatile uint32_t CODESIZE;  ///< Offset: 0x14 - Code memory size
        volatile uint32_t DEVICEID__;  ///< Offset: 0x60 - Description collection: Device identifier (renamed from DEVICEID__)
        volatile uint32_t ER__;  ///< Offset: 0x80 - Description collection: Encryption root, word n (renamed from ER__)
        volatile uint32_t IR__;  ///< Offset: 0x90 - Description collection: Identity Root, word n (renamed from IR__)
        volatile uint32_t DEVICEADDRTYPE;  ///< Offset: 0xA0 - Device address type
        volatile uint32_t DEVICEADDR__;  ///< Offset: 0xA4 - Description collection: Device address n (renamed from DEVICEADDR__)
        volatile uint32_t PART;  ///< Offset: 0x00 - Part code
        volatile uint32_t VARIANT;  ///< Offset: 0x04 - Build code (hardware version and production configuration)
        volatile uint32_t PACKAGE;  ///< Offset: 0x08 - Package option
        volatile uint32_t RAM;  ///< Offset: 0x0C - RAM variant
        volatile uint32_t FLASH;  ///< Offset: 0x10 - Flash variant
        volatile uint32_t PRODTEST__;  ///< Offset: 0x350 - Description collection: Production test signature n (renamed from PRODTEST__)
        volatile uint32_t A0;  ///< Offset: 0x00 - Slope definition A0
        volatile uint32_t A1;  ///< Offset: 0x04 - Slope definition A1
        volatile uint32_t A2;  ///< Offset: 0x08 - Slope definition A2
        volatile uint32_t A3;  ///< Offset: 0x0C - Slope definition A3
        volatile uint32_t A4;  ///< Offset: 0x10 - Slope definition A4
        volatile uint32_t A5;  ///< Offset: 0x14 - Slope definition A5
        volatile uint32_t B0;  ///< Offset: 0x18 - Y-intercept B0
        volatile uint32_t B1;  ///< Offset: 0x1C - Y-intercept B1
        volatile uint32_t B2;  ///< Offset: 0x20 - Y-intercept B2
        volatile uint32_t B3;  ///< Offset: 0x24 - Y-intercept B3
        volatile uint32_t B4;  ///< Offset: 0x28 - Y-intercept B4
        volatile uint32_t B5;  ///< Offset: 0x2C - Y-intercept B5
        volatile uint32_t T0;  ///< Offset: 0x30 - Segment end T0
        volatile uint32_t T1;  ///< Offset: 0x34 - Segment end T1
        volatile uint32_t T2;  ///< Offset: 0x38 - Segment end T2
        volatile uint32_t T3;  ///< Offset: 0x3C - Segment end T3
        volatile uint32_t T4;  ///< Offset: 0x40 - Segment end T4
        volatile uint32_t TAGHEADER0;  ///< Offset: 0x00 - Default header for NFC tag. Software can read these...
        volatile uint32_t TAGHEADER1;  ///< Offset: 0x04 - Default header for NFC tag. Software can read these...
        volatile uint32_t TAGHEADER2;  ///< Offset: 0x08 - Default header for NFC tag. Software can read these...
        volatile uint32_t TAGHEADER3;  ///< Offset: 0x0C - Default header for NFC tag. Software can read these...
        volatile uint32_t BYTES;  ///< Offset: 0x00 - Amount of bytes for the required entropy bits
        volatile uint32_t RCCUTOFF;  ///< Offset: 0x04 - Repetition counter cutoff
        volatile uint32_t APCUTOFF;  ///< Offset: 0x08 - Adaptive proportion cutoff
        volatile uint32_t STARTUP;  ///< Offset: 0x0C - Amount of bytes for the startup tests
        volatile uint32_t ROSC1;  ///< Offset: 0x10 - Sample count for ring oscillator 1
        volatile uint32_t ROSC2;  ///< Offset: 0x14 - Sample count for ring oscillator 2
        volatile uint32_t ROSC3;  ///< Offset: 0x18 - Sample count for ring oscillator 3
        volatile uint32_t ROSC4;  ///< Offset: 0x1C - Sample count for ring oscillator 4
    };

    /// Peripheral instances
    inline Registers* FICR = reinterpret_cast<Registers*>(FICR_BASE);

    // Bit definitions
    /// CODEPAGESIZE Register bits
    namespace codepagesize_bits {
        constexpr uint32_t CODEPAGESIZE = (32 << 0);  ///< Code memory page size
    }

    /// CODESIZE Register bits
    namespace codesize_bits {
        constexpr uint32_t CODESIZE = (32 << 0);  ///< Code memory size in number of pages
    }

    /// DEVICEID__ Register bits
    namespace deviceid___bits {
        constexpr uint32_t DEVICEID = (32 << 0);  ///< 64 bit unique device identifier
    }

    /// ER__ Register bits
    namespace er___bits {
        constexpr uint32_t ER = (32 << 0);  ///< Encryption root, word n
    }

    /// IR__ Register bits
    namespace ir___bits {
        constexpr uint32_t IR = (32 << 0);  ///< Identity Root, word n
    }

    /// DEVICEADDRTYPE Register bits
    namespace deviceaddrtype_bits {
        constexpr uint32_t DEVICEADDRTYPE = (1U << 0);  ///< Device address type
    }

    /// DEVICEADDR__ Register bits
    namespace deviceaddr___bits {
        constexpr uint32_t DEVICEADDR = (32 << 0);  ///< 48 bit device address
    }

    /// PART Register bits
    namespace part_bits {
        constexpr uint32_t PART = (32 << 0);  ///< Part code
    }

    /// VARIANT Register bits
    namespace variant_bits {
        constexpr uint32_t VARIANT = (32 << 0);  ///< Build code (hardware version and production configuration). Encoded as ASCII.
    }

    /// PACKAGE Register bits
    namespace package_bits {
        constexpr uint32_t PACKAGE = (32 << 0);  ///< Package option
    }

    /// RAM Register bits
    namespace ram_bits {
        constexpr uint32_t RAM = (32 << 0);  ///< RAM variant
    }

    /// FLASH Register bits
    namespace flash_bits {
        constexpr uint32_t FLASH = (32 << 0);  ///< Flash variant
    }

    /// PRODTEST__ Register bits
    namespace prodtest___bits {
        constexpr uint32_t PRODTEST = (32 << 0);  ///< Production test signature n
    }

    /// A0 Register bits
    namespace a0_bits {
        constexpr uint32_t A = (12 << 0);  ///< A (slope definition) register.
    }

    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t A = (12 << 0);  ///< A (slope definition) register.
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t A = (12 << 0);  ///< A (slope definition) register.
    }

    /// A3 Register bits
    namespace a3_bits {
        constexpr uint32_t A = (12 << 0);  ///< A (slope definition) register.
    }

    /// A4 Register bits
    namespace a4_bits {
        constexpr uint32_t A = (12 << 0);  ///< A (slope definition) register.
    }

    /// A5 Register bits
    namespace a5_bits {
        constexpr uint32_t A = (12 << 0);  ///< A (slope definition) register.
    }

    /// B0 Register bits
    namespace b0_bits {
        constexpr uint32_t B = (14 << 0);  ///< B (y-intercept)
    }

    /// B1 Register bits
    namespace b1_bits {
        constexpr uint32_t B = (14 << 0);  ///< B (y-intercept)
    }

    /// B2 Register bits
    namespace b2_bits {
        constexpr uint32_t B = (14 << 0);  ///< B (y-intercept)
    }

    /// B3 Register bits
    namespace b3_bits {
        constexpr uint32_t B = (14 << 0);  ///< B (y-intercept)
    }

    /// B4 Register bits
    namespace b4_bits {
        constexpr uint32_t B = (14 << 0);  ///< B (y-intercept)
    }

    /// B5 Register bits
    namespace b5_bits {
        constexpr uint32_t B = (14 << 0);  ///< B (y-intercept)
    }

    /// T0 Register bits
    namespace t0_bits {
        constexpr uint32_t T = (8 << 0);  ///< T (segment end) register
    }

    /// T1 Register bits
    namespace t1_bits {
        constexpr uint32_t T = (8 << 0);  ///< T (segment end) register
    }

    /// T2 Register bits
    namespace t2_bits {
        constexpr uint32_t T = (8 << 0);  ///< T (segment end) register
    }

    /// T3 Register bits
    namespace t3_bits {
        constexpr uint32_t T = (8 << 0);  ///< T (segment end) register
    }

    /// T4 Register bits
    namespace t4_bits {
        constexpr uint32_t T = (8 << 0);  ///< T (segment end) register
    }

    /// TAGHEADER0 Register bits
    namespace tagheader0_bits {
        constexpr uint32_t MFGID = (8 << 0);  ///< Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F
        constexpr uint32_t UD1 = (8 << 8);  ///< Unique identifier byte 1
        constexpr uint32_t UD2 = (8 << 16);  ///< Unique identifier byte 2
        constexpr uint32_t UD3 = (8 << 24);  ///< Unique identifier byte 3
    }

    /// TAGHEADER1 Register bits
    namespace tagheader1_bits {
        constexpr uint32_t UD4 = (8 << 0);  ///< Unique identifier byte 4
        constexpr uint32_t UD5 = (8 << 8);  ///< Unique identifier byte 5
        constexpr uint32_t UD6 = (8 << 16);  ///< Unique identifier byte 6
        constexpr uint32_t UD7 = (8 << 24);  ///< Unique identifier byte 7
    }

    /// TAGHEADER2 Register bits
    namespace tagheader2_bits {
        constexpr uint32_t UD8 = (8 << 0);  ///< Unique identifier byte 8
        constexpr uint32_t UD9 = (8 << 8);  ///< Unique identifier byte 9
        constexpr uint32_t UD10 = (8 << 16);  ///< Unique identifier byte 10
        constexpr uint32_t UD11 = (8 << 24);  ///< Unique identifier byte 11
    }

    /// TAGHEADER3 Register bits
    namespace tagheader3_bits {
        constexpr uint32_t UD12 = (8 << 0);  ///< Unique identifier byte 12
        constexpr uint32_t UD13 = (8 << 8);  ///< Unique identifier byte 13
        constexpr uint32_t UD14 = (8 << 16);  ///< Unique identifier byte 14
        constexpr uint32_t UD15 = (8 << 24);  ///< Unique identifier byte 15
    }

    /// BYTES Register bits
    namespace bytes_bits {
        constexpr uint32_t BYTES = (32 << 0);  ///< Amount of bytes for the required entropy bits
    }

    /// RCCUTOFF Register bits
    namespace rccutoff_bits {
        constexpr uint32_t RCCUTOFF = (32 << 0);  ///< Repetition counter cutoff
    }

    /// APCUTOFF Register bits
    namespace apcutoff_bits {
        constexpr uint32_t APCUTOFF = (32 << 0);  ///< Adaptive proportion cutoff
    }

    /// STARTUP Register bits
    namespace startup_bits {
        constexpr uint32_t STARTUP = (32 << 0);  ///< Amount of bytes for the startup tests
    }

    /// ROSC1 Register bits
    namespace rosc1_bits {
        constexpr uint32_t ROSC1 = (32 << 0);  ///< Sample count for ring oscillator 1
    }

    /// ROSC2 Register bits
    namespace rosc2_bits {
        constexpr uint32_t ROSC2 = (32 << 0);  ///< Sample count for ring oscillator 2
    }

    /// ROSC3 Register bits
    namespace rosc3_bits {
        constexpr uint32_t ROSC3 = (32 << 0);  ///< Sample count for ring oscillator 3
    }

    /// ROSC4 Register bits
    namespace rosc4_bits {
        constexpr uint32_t ROSC4 = (32 << 0);  ///< Sample count for ring oscillator 4
    }

}

// ============================================================================
// UICR Peripheral
// ============================================================================

namespace uicr {
    /// Base addresses
    constexpr uint32_t UICR_BASE = 0x10001000;

    /// UICR Register structure
    struct Registers {
        volatile uint32_t NRFFW__;  ///< Offset: 0x14 - Description collection: Reserved for Nordic firmware design (renamed from NRFFW__)
        volatile uint32_t NRFHW__;  ///< Offset: 0x50 - Description collection: Reserved for Nordic hardware design (renamed from NRFHW__)
        volatile uint32_t CUSTOMER__;  ///< Offset: 0x80 - Description collection: Reserved for customer (renamed from CUSTOMER__)
        volatile uint32_t PSELRESET__;  ///< Offset: 0x200 - Description collection: Mapping of the nRESET function... (renamed from PSELRESET__)
        volatile uint32_t APPROTECT;  ///< Offset: 0x208 - Access port protection
        volatile uint32_t NFCPINS;  ///< Offset: 0x20C - Setting of pins dedicated to NFC functionality: NFC...
        volatile uint32_t DEBUGCTRL;  ///< Offset: 0x210 - Processor debug control
        volatile uint32_t REGOUT0;  ///< Offset: 0x304 - GPIO reference voltage / external output supply voltage...
    };

    /// Peripheral instances
    inline Registers* UICR = reinterpret_cast<Registers*>(UICR_BASE);

    // Bit definitions
    /// NRFFW__ Register bits
    namespace nrffw___bits {
        constexpr uint32_t NRFFW = (32 << 0);  ///< Reserved for Nordic firmware design
    }

    /// NRFHW__ Register bits
    namespace nrfhw___bits {
        constexpr uint32_t NRFHW = (32 << 0);  ///< Reserved for Nordic hardware design
    }

    /// CUSTOMER__ Register bits
    namespace customer___bits {
        constexpr uint32_t CUSTOMER = (32 << 0);  ///< Reserved for customer
    }

    /// PSELRESET__ Register bits
    namespace pselreset___bits {
        constexpr uint32_t PIN = (5 << 0);  ///< GPIO pin number onto which nRESET is exposed
        constexpr uint32_t PORT = (1U << 5);  ///< Port number onto which nRESET is exposed
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// APPROTECT Register bits
    namespace approtect_bits {
        constexpr uint32_t PALL = (8 << 0);  ///< Enable or disable access port protection.
    }

    /// NFCPINS Register bits
    namespace nfcpins_bits {
        constexpr uint32_t PROTECT = (1U << 0);  ///< Setting of pins dedicated to NFC functionality
    }

    /// DEBUGCTRL Register bits
    namespace debugctrl_bits {
        constexpr uint32_t CPUNIDEN = (8 << 0);  ///< Configure CPU non-intrusive debug features
        constexpr uint32_t CPUFPBEN = (8 << 8);  ///< Configure CPU flash patch and breakpoint (FPB) unit behavior
    }

    /// REGOUT0 Register bits
    namespace regout0_bits {
        constexpr uint32_t VOUT = (3 << 0);  ///< Output voltage from of REG0 regulator stage. The maximum output voltage from this stage is given as VDDH - VEXDIF.
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t CLOCK_BASE = 0x40000000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t TASKS_HFCLKSTART;  ///< Offset: 0x00 - Start HFXO crystal oscillator
        volatile uint32_t TASKS_HFCLKSTOP;  ///< Offset: 0x04 - Stop HFXO crystal oscillator
        volatile uint32_t TASKS_LFCLKSTART;  ///< Offset: 0x08 - Start LFCLK
        volatile uint32_t TASKS_LFCLKSTOP;  ///< Offset: 0x0C - Stop LFCLK
        volatile uint32_t TASKS_CAL;  ///< Offset: 0x10 - Start calibration of LFRC
        volatile uint32_t TASKS_CTSTART;  ///< Offset: 0x14 - Start calibration timer
        volatile uint32_t TASKS_CTSTOP;  ///< Offset: 0x18 - Stop calibration timer
        volatile uint32_t EVENTS_HFCLKSTARTED;  ///< Offset: 0x100 - HFXO crystal oscillator started
        volatile uint32_t EVENTS_LFCLKSTARTED;  ///< Offset: 0x104 - LFCLK started
        volatile uint32_t EVENTS_DONE;  ///< Offset: 0x10C - Calibration of LFRC completed
        volatile uint32_t EVENTS_CTTO;  ///< Offset: 0x110 - Calibration timer timeout
        volatile uint32_t EVENTS_CTSTARTED;  ///< Offset: 0x128 - Calibration timer has been started and is ready to...
        volatile uint32_t EVENTS_CTSTOPPED;  ///< Offset: 0x12C - Calibration timer has been stopped and is ready to...
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t HFCLKRUN;  ///< Offset: 0x408 - Status indicating that HFCLKSTART task has been triggered
        volatile uint32_t HFCLKSTAT;  ///< Offset: 0x40C - HFCLK status
        volatile uint32_t LFCLKRUN;  ///< Offset: 0x414 - Status indicating that LFCLKSTART task has been triggered
        volatile uint32_t LFCLKSTAT;  ///< Offset: 0x418 - LFCLK status
        volatile uint32_t LFCLKSRCCOPY;  ///< Offset: 0x41C - Copy of LFCLKSRC register, set when LFCLKSTART task was triggered
        volatile uint32_t LFCLKSRC;  ///< Offset: 0x518 - Clock source for the LFCLK
        volatile uint32_t HFXODEBOUNCE;  ///< Offset: 0x528 - HFXO debounce time. The HFXO is started by triggering...
        volatile uint32_t CTIV;  ///< Offset: 0x538 - Calibration timer interval
        volatile uint32_t TRACECONFIG;  ///< Offset: 0x55C - Clocking options for the trace port debug interface
        volatile uint32_t LFRCMODE;  ///< Offset: 0x5B4 - LFRC mode configuration
    };

    /// Peripheral instances
    inline Registers* CLOCK = reinterpret_cast<Registers*>(CLOCK_BASE);

    // Bit definitions
    /// TASKS_HFCLKSTART Register bits
    namespace tasks_hfclkstart_bits {
        constexpr uint32_t TASKS_HFCLKSTART = (1U << 0);  ///< Start HFXO crystal oscillator
    }

    /// TASKS_HFCLKSTOP Register bits
    namespace tasks_hfclkstop_bits {
        constexpr uint32_t TASKS_HFCLKSTOP = (1U << 0);  ///< Stop HFXO crystal oscillator
    }

    /// TASKS_LFCLKSTART Register bits
    namespace tasks_lfclkstart_bits {
        constexpr uint32_t TASKS_LFCLKSTART = (1U << 0);  ///< Start LFCLK
    }

    /// TASKS_LFCLKSTOP Register bits
    namespace tasks_lfclkstop_bits {
        constexpr uint32_t TASKS_LFCLKSTOP = (1U << 0);  ///< Stop LFCLK
    }

    /// TASKS_CAL Register bits
    namespace tasks_cal_bits {
        constexpr uint32_t TASKS_CAL = (1U << 0);  ///< Start calibration of LFRC
    }

    /// TASKS_CTSTART Register bits
    namespace tasks_ctstart_bits {
        constexpr uint32_t TASKS_CTSTART = (1U << 0);  ///< Start calibration timer
    }

    /// TASKS_CTSTOP Register bits
    namespace tasks_ctstop_bits {
        constexpr uint32_t TASKS_CTSTOP = (1U << 0);  ///< Stop calibration timer
    }

    /// EVENTS_HFCLKSTARTED Register bits
    namespace events_hfclkstarted_bits {
        constexpr uint32_t EVENTS_HFCLKSTARTED = (1U << 0);  ///< HFXO crystal oscillator started
    }

    /// EVENTS_LFCLKSTARTED Register bits
    namespace events_lfclkstarted_bits {
        constexpr uint32_t EVENTS_LFCLKSTARTED = (1U << 0);  ///< LFCLK started
    }

    /// EVENTS_DONE Register bits
    namespace events_done_bits {
        constexpr uint32_t EVENTS_DONE = (1U << 0);  ///< Calibration of LFRC completed
    }

    /// EVENTS_CTTO Register bits
    namespace events_ctto_bits {
        constexpr uint32_t EVENTS_CTTO = (1U << 0);  ///< Calibration timer timeout
    }

    /// EVENTS_CTSTARTED Register bits
    namespace events_ctstarted_bits {
        constexpr uint32_t EVENTS_CTSTARTED = (1U << 0);  ///< Calibration timer has been started and is ready to process new tasks
    }

    /// EVENTS_CTSTOPPED Register bits
    namespace events_ctstopped_bits {
        constexpr uint32_t EVENTS_CTSTOPPED = (1U << 0);  ///< Calibration timer has been stopped and is ready to process new tasks
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Write '1' to enable interrupt for event HFCLKSTARTED
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Write '1' to enable interrupt for event LFCLKSTARTED
        constexpr uint32_t DONE = (1U << 3);  ///< Write '1' to enable interrupt for event DONE
        constexpr uint32_t CTTO = (1U << 4);  ///< Write '1' to enable interrupt for event CTTO
        constexpr uint32_t CTSTARTED = (1U << 10);  ///< Write '1' to enable interrupt for event CTSTARTED
        constexpr uint32_t CTSTOPPED = (1U << 11);  ///< Write '1' to enable interrupt for event CTSTOPPED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Write '1' to disable interrupt for event HFCLKSTARTED
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Write '1' to disable interrupt for event LFCLKSTARTED
        constexpr uint32_t DONE = (1U << 3);  ///< Write '1' to disable interrupt for event DONE
        constexpr uint32_t CTTO = (1U << 4);  ///< Write '1' to disable interrupt for event CTTO
        constexpr uint32_t CTSTARTED = (1U << 10);  ///< Write '1' to disable interrupt for event CTSTARTED
        constexpr uint32_t CTSTOPPED = (1U << 11);  ///< Write '1' to disable interrupt for event CTSTOPPED
    }

    /// HFCLKRUN Register bits
    namespace hfclkrun_bits {
        constexpr uint32_t STATUS = (1U << 0);  ///< HFCLKSTART task triggered or not
    }

    /// HFCLKSTAT Register bits
    namespace hfclkstat_bits {
        constexpr uint32_t SRC = (1U << 0);  ///< Source of HFCLK
        constexpr uint32_t STATE = (1U << 16);  ///< HFCLK state
    }

    /// LFCLKRUN Register bits
    namespace lfclkrun_bits {
        constexpr uint32_t STATUS = (1U << 0);  ///< LFCLKSTART task triggered or not
    }

    /// LFCLKSTAT Register bits
    namespace lfclkstat_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Source of LFCLK
        constexpr uint32_t STATE = (1U << 16);  ///< LFCLK state
    }

    /// LFCLKSRCCOPY Register bits
    namespace lfclksrccopy_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Clock source
    }

    /// LFCLKSRC Register bits
    namespace lfclksrc_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Clock source
        constexpr uint32_t BYPASS = (1U << 16);  ///< Enable or disable bypass of LFCLK crystal oscillator with external clock source
        constexpr uint32_t EXTERNAL = (1U << 17);  ///< Enable or disable external source for LFCLK
    }

    /// HFXODEBOUNCE Register bits
    namespace hfxodebounce_bits {
        constexpr uint32_t HFXODEBOUNCE = (8 << 0);  ///< HFXO debounce time. Debounce time = HFXODEBOUNCE * 16 us.
    }

    /// CTIV Register bits
    namespace ctiv_bits {
        constexpr uint32_t CTIV = (7 << 0);  ///< Calibration timer interval in multiple of 0.25 seconds. Range: 0.25 seconds to 31.75 seconds.
    }

    /// TRACECONFIG Register bits
    namespace traceconfig_bits {
        constexpr uint32_t TRACEPORTSPEED = (2 << 0);  ///< Speed of trace port clock. Note that the TRACECLK pin will output this clock divided by two.
        constexpr uint32_t TRACEMUX = (2 << 16);  ///< Pin multiplexing of trace signals. See pin assignment chapter for more details.
    }

    /// LFRCMODE Register bits
    namespace lfrcmode_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< Set LFRC mode
        constexpr uint32_t STATUS = (1U << 16);  ///< Active LFRC mode. This field is read only.
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t POWER_BASE = 0x40000000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t TASKS_CONSTLAT;  ///< Offset: 0x78 - Enable Constant Latency mode
        volatile uint32_t TASKS_LOWPWR;  ///< Offset: 0x7C - Enable Low-power mode (variable latency)
        volatile uint32_t EVENTS_POFWARN;  ///< Offset: 0x108 - Power failure warning
        volatile uint32_t EVENTS_SLEEPENTER;  ///< Offset: 0x114 - CPU entered WFI/WFE sleep
        volatile uint32_t EVENTS_SLEEPEXIT;  ///< Offset: 0x118 - CPU exited WFI/WFE sleep
        volatile uint32_t EVENTS_USBDETECTED;  ///< Offset: 0x11C - Voltage supply detected on VBUS
        volatile uint32_t EVENTS_USBREMOVED;  ///< Offset: 0x120 - Voltage supply removed from VBUS
        volatile uint32_t EVENTS_USBPWRRDY;  ///< Offset: 0x124 - USB 3.3 V supply ready
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t RESETREAS;  ///< Offset: 0x400 - Reset reason
        volatile uint32_t RAMSTATUS;  ///< Offset: 0x428 - Deprecated register - RAM status register
        volatile uint32_t USBREGSTATUS;  ///< Offset: 0x438 - USB supply status
        volatile uint32_t SYSTEMOFF;  ///< Offset: 0x500 - System OFF register
        volatile uint32_t POFCON;  ///< Offset: 0x510 - Power-fail comparator configuration
        volatile uint32_t GPREGRET;  ///< Offset: 0x51C - General purpose retention register
        volatile uint32_t GPREGRET2;  ///< Offset: 0x520 - General purpose retention register
        volatile uint32_t DCDCEN;  ///< Offset: 0x578 - Enable DC/DC converter for REG1 stage
        volatile uint32_t DCDCEN0;  ///< Offset: 0x580 - Enable DC/DC converter for REG0 stage
        volatile uint32_t MAINREGSTATUS;  ///< Offset: 0x640 - Main supply status
        volatile uint32_t POWER;  ///< Offset: 0x00 - Description cluster: RAMn power control register
        volatile uint32_t POWERSET;  ///< Offset: 0x04 - Description cluster: RAMn power control set register
        volatile uint32_t POWERCLR;  ///< Offset: 0x08 - Description cluster: RAMn power control clear register
    };

    /// Peripheral instances
    inline Registers* POWER = reinterpret_cast<Registers*>(POWER_BASE);

    // Bit definitions
    /// TASKS_CONSTLAT Register bits
    namespace tasks_constlat_bits {
        constexpr uint32_t TASKS_CONSTLAT = (1U << 0);  ///< Enable Constant Latency mode
    }

    /// TASKS_LOWPWR Register bits
    namespace tasks_lowpwr_bits {
        constexpr uint32_t TASKS_LOWPWR = (1U << 0);  ///< Enable Low-power mode (variable latency)
    }

    /// EVENTS_POFWARN Register bits
    namespace events_pofwarn_bits {
        constexpr uint32_t EVENTS_POFWARN = (1U << 0);  ///< Power failure warning
    }

    /// EVENTS_SLEEPENTER Register bits
    namespace events_sleepenter_bits {
        constexpr uint32_t EVENTS_SLEEPENTER = (1U << 0);  ///< CPU entered WFI/WFE sleep
    }

    /// EVENTS_SLEEPEXIT Register bits
    namespace events_sleepexit_bits {
        constexpr uint32_t EVENTS_SLEEPEXIT = (1U << 0);  ///< CPU exited WFI/WFE sleep
    }

    /// EVENTS_USBDETECTED Register bits
    namespace events_usbdetected_bits {
        constexpr uint32_t EVENTS_USBDETECTED = (1U << 0);  ///< Voltage supply detected on VBUS
    }

    /// EVENTS_USBREMOVED Register bits
    namespace events_usbremoved_bits {
        constexpr uint32_t EVENTS_USBREMOVED = (1U << 0);  ///< Voltage supply removed from VBUS
    }

    /// EVENTS_USBPWRRDY Register bits
    namespace events_usbpwrrdy_bits {
        constexpr uint32_t EVENTS_USBPWRRDY = (1U << 0);  ///< USB 3.3 V supply ready
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t POFWARN = (1U << 2);  ///< Write '1' to enable interrupt for event POFWARN
        constexpr uint32_t SLEEPENTER = (1U << 5);  ///< Write '1' to enable interrupt for event SLEEPENTER
        constexpr uint32_t SLEEPEXIT = (1U << 6);  ///< Write '1' to enable interrupt for event SLEEPEXIT
        constexpr uint32_t USBDETECTED = (1U << 7);  ///< Write '1' to enable interrupt for event USBDETECTED
        constexpr uint32_t USBREMOVED = (1U << 8);  ///< Write '1' to enable interrupt for event USBREMOVED
        constexpr uint32_t USBPWRRDY = (1U << 9);  ///< Write '1' to enable interrupt for event USBPWRRDY
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t POFWARN = (1U << 2);  ///< Write '1' to disable interrupt for event POFWARN
        constexpr uint32_t SLEEPENTER = (1U << 5);  ///< Write '1' to disable interrupt for event SLEEPENTER
        constexpr uint32_t SLEEPEXIT = (1U << 6);  ///< Write '1' to disable interrupt for event SLEEPEXIT
        constexpr uint32_t USBDETECTED = (1U << 7);  ///< Write '1' to disable interrupt for event USBDETECTED
        constexpr uint32_t USBREMOVED = (1U << 8);  ///< Write '1' to disable interrupt for event USBREMOVED
        constexpr uint32_t USBPWRRDY = (1U << 9);  ///< Write '1' to disable interrupt for event USBPWRRDY
    }

    /// RESETREAS Register bits
    namespace resetreas_bits {
        constexpr uint32_t RESETPIN = (1U << 0);  ///< Reset from pin-reset detected
        constexpr uint32_t DOG = (1U << 1);  ///< Reset from watchdog detected
        constexpr uint32_t SREQ = (1U << 2);  ///< Reset from soft reset detected
        constexpr uint32_t LOCKUP = (1U << 3);  ///< Reset from CPU lock-up detected
        constexpr uint32_t OFF = (1U << 16);  ///< Reset due to wake up from System OFF mode when wakeup is triggered from DETECT signal from GPIO
        constexpr uint32_t LPCOMP = (1U << 17);  ///< Reset due to wake up from System OFF mode when wakeup is triggered from ANADETECT signal from LPCOMP
        constexpr uint32_t DIF = (1U << 18);  ///< Reset due to wake up from System OFF mode when wakeup is triggered from entering into debug interface mode
        constexpr uint32_t NFC = (1U << 19);  ///< Reset due to wake up from System OFF mode by NFC field detect
        constexpr uint32_t VBUS = (1U << 20);  ///< Reset due to wake up from System OFF mode by VBUS rising into valid range
    }

    /// RAMSTATUS Register bits
    namespace ramstatus_bits {
        constexpr uint32_t RAMBLOCK0 = (1U << 0);  ///< RAM block 0 is on or off/powering up
        constexpr uint32_t RAMBLOCK1 = (1U << 1);  ///< RAM block 1 is on or off/powering up
        constexpr uint32_t RAMBLOCK2 = (1U << 2);  ///< RAM block 2 is on or off/powering up
        constexpr uint32_t RAMBLOCK3 = (1U << 3);  ///< RAM block 3 is on or off/powering up
    }

    /// USBREGSTATUS Register bits
    namespace usbregstatus_bits {
        constexpr uint32_t VBUSDETECT = (1U << 0);  ///< VBUS input detection status (USBDETECTED and USBREMOVED events are derived from this information)
        constexpr uint32_t OUTPUTRDY = (1U << 1);  ///< USB supply output settling time elapsed
    }

    /// SYSTEMOFF Register bits
    namespace systemoff_bits {
        constexpr uint32_t SYSTEMOFF = (1U << 0);  ///< Enable System OFF mode
    }

    /// POFCON Register bits
    namespace pofcon_bits {
        constexpr uint32_t POF = (1U << 0);  ///< Enable or disable power failure warning
        constexpr uint32_t THRESHOLD = (4 << 1);  ///< Power-fail comparator threshold setting. This setting applies both for normal voltage mode (supply connected to both VDD and VDDH) and high voltage mode (supply connected to VDDH only). Values 0-3 set threshold below 1.7 V and should not be used as brown out detection will be activated before power failure warning on such low voltages.
        constexpr uint32_t THRESHOLDVDDH = (4 << 8);  ///< Power-fail comparator threshold setting for high voltage mode (supply connected to VDDH only). This setting does not apply for normal voltage mode (supply connected to both VDD and VDDH).
    }

    /// GPREGRET Register bits
    namespace gpregret_bits {
        constexpr uint32_t GPREGRET = (8 << 0);  ///< General purpose retention register
    }

    /// GPREGRET2 Register bits
    namespace gpregret2_bits {
        constexpr uint32_t GPREGRET = (8 << 0);  ///< General purpose retention register
    }

    /// DCDCEN Register bits
    namespace dcdcen_bits {
        constexpr uint32_t DCDCEN = (1U << 0);  ///< Enable DC/DC converter for REG1 stage.
    }

    /// DCDCEN0 Register bits
    namespace dcdcen0_bits {
        constexpr uint32_t DCDCEN = (1U << 0);  ///< Enable DC/DC converter for REG0 stage.
    }

    /// MAINREGSTATUS Register bits
    namespace mainregstatus_bits {
        constexpr uint32_t MAINREGSTATUS = (1U << 0);  ///< Main supply status
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t S0POWER = (1U << 0);  ///< Keep RAM section S0 on or off in System ON mode.
        constexpr uint32_t S1POWER = (1U << 1);  ///< Keep RAM section S1 on or off in System ON mode.
        constexpr uint32_t S2POWER = (1U << 2);  ///< Keep RAM section S2 on or off in System ON mode.
        constexpr uint32_t S3POWER = (1U << 3);  ///< Keep RAM section S3 on or off in System ON mode.
        constexpr uint32_t S4POWER = (1U << 4);  ///< Keep RAM section S4 on or off in System ON mode.
        constexpr uint32_t S5POWER = (1U << 5);  ///< Keep RAM section S5 on or off in System ON mode.
        constexpr uint32_t S6POWER = (1U << 6);  ///< Keep RAM section S6 on or off in System ON mode.
        constexpr uint32_t S7POWER = (1U << 7);  ///< Keep RAM section S7 on or off in System ON mode.
        constexpr uint32_t S8POWER = (1U << 8);  ///< Keep RAM section S8 on or off in System ON mode.
        constexpr uint32_t S9POWER = (1U << 9);  ///< Keep RAM section S9 on or off in System ON mode.
        constexpr uint32_t S10POWER = (1U << 10);  ///< Keep RAM section S10 on or off in System ON mode.
        constexpr uint32_t S11POWER = (1U << 11);  ///< Keep RAM section S11 on or off in System ON mode.
        constexpr uint32_t S12POWER = (1U << 12);  ///< Keep RAM section S12 on or off in System ON mode.
        constexpr uint32_t S13POWER = (1U << 13);  ///< Keep RAM section S13 on or off in System ON mode.
        constexpr uint32_t S14POWER = (1U << 14);  ///< Keep RAM section S14 on or off in System ON mode.
        constexpr uint32_t S15POWER = (1U << 15);  ///< Keep RAM section S15 on or off in System ON mode.
        constexpr uint32_t S0RETENTION = (1U << 16);  ///< Keep retention on RAM section S0 when RAM section is off
        constexpr uint32_t S1RETENTION = (1U << 17);  ///< Keep retention on RAM section S1 when RAM section is off
        constexpr uint32_t S2RETENTION = (1U << 18);  ///< Keep retention on RAM section S2 when RAM section is off
        constexpr uint32_t S3RETENTION = (1U << 19);  ///< Keep retention on RAM section S3 when RAM section is off
        constexpr uint32_t S4RETENTION = (1U << 20);  ///< Keep retention on RAM section S4 when RAM section is off
        constexpr uint32_t S5RETENTION = (1U << 21);  ///< Keep retention on RAM section S5 when RAM section is off
        constexpr uint32_t S6RETENTION = (1U << 22);  ///< Keep retention on RAM section S6 when RAM section is off
        constexpr uint32_t S7RETENTION = (1U << 23);  ///< Keep retention on RAM section S7 when RAM section is off
        constexpr uint32_t S8RETENTION = (1U << 24);  ///< Keep retention on RAM section S8 when RAM section is off
        constexpr uint32_t S9RETENTION = (1U << 25);  ///< Keep retention on RAM section S9 when RAM section is off
        constexpr uint32_t S10RETENTION = (1U << 26);  ///< Keep retention on RAM section S10 when RAM section is off
        constexpr uint32_t S11RETENTION = (1U << 27);  ///< Keep retention on RAM section S11 when RAM section is off
        constexpr uint32_t S12RETENTION = (1U << 28);  ///< Keep retention on RAM section S12 when RAM section is off
        constexpr uint32_t S13RETENTION = (1U << 29);  ///< Keep retention on RAM section S13 when RAM section is off
        constexpr uint32_t S14RETENTION = (1U << 30);  ///< Keep retention on RAM section S14 when RAM section is off
        constexpr uint32_t S15RETENTION = (1U << 31);  ///< Keep retention on RAM section S15 when RAM section is off
    }

    /// POWERSET Register bits
    namespace powerset_bits {
        constexpr uint32_t S0POWER = (1U << 0);  ///< Keep RAM section S0 of RAMn on or off in System ON mode
        constexpr uint32_t S1POWER = (1U << 1);  ///< Keep RAM section S1 of RAMn on or off in System ON mode
        constexpr uint32_t S2POWER = (1U << 2);  ///< Keep RAM section S2 of RAMn on or off in System ON mode
        constexpr uint32_t S3POWER = (1U << 3);  ///< Keep RAM section S3 of RAMn on or off in System ON mode
        constexpr uint32_t S4POWER = (1U << 4);  ///< Keep RAM section S4 of RAMn on or off in System ON mode
        constexpr uint32_t S5POWER = (1U << 5);  ///< Keep RAM section S5 of RAMn on or off in System ON mode
        constexpr uint32_t S6POWER = (1U << 6);  ///< Keep RAM section S6 of RAMn on or off in System ON mode
        constexpr uint32_t S7POWER = (1U << 7);  ///< Keep RAM section S7 of RAMn on or off in System ON mode
        constexpr uint32_t S8POWER = (1U << 8);  ///< Keep RAM section S8 of RAMn on or off in System ON mode
        constexpr uint32_t S9POWER = (1U << 9);  ///< Keep RAM section S9 of RAMn on or off in System ON mode
        constexpr uint32_t S10POWER = (1U << 10);  ///< Keep RAM section S10 of RAMn on or off in System ON mode
        constexpr uint32_t S11POWER = (1U << 11);  ///< Keep RAM section S11 of RAMn on or off in System ON mode
        constexpr uint32_t S12POWER = (1U << 12);  ///< Keep RAM section S12 of RAMn on or off in System ON mode
        constexpr uint32_t S13POWER = (1U << 13);  ///< Keep RAM section S13 of RAMn on or off in System ON mode
        constexpr uint32_t S14POWER = (1U << 14);  ///< Keep RAM section S14 of RAMn on or off in System ON mode
        constexpr uint32_t S15POWER = (1U << 15);  ///< Keep RAM section S15 of RAMn on or off in System ON mode
        constexpr uint32_t S0RETENTION = (1U << 16);  ///< Keep retention on RAM section S0 when RAM section is switched off
        constexpr uint32_t S1RETENTION = (1U << 17);  ///< Keep retention on RAM section S1 when RAM section is switched off
        constexpr uint32_t S2RETENTION = (1U << 18);  ///< Keep retention on RAM section S2 when RAM section is switched off
        constexpr uint32_t S3RETENTION = (1U << 19);  ///< Keep retention on RAM section S3 when RAM section is switched off
        constexpr uint32_t S4RETENTION = (1U << 20);  ///< Keep retention on RAM section S4 when RAM section is switched off
        constexpr uint32_t S5RETENTION = (1U << 21);  ///< Keep retention on RAM section S5 when RAM section is switched off
        constexpr uint32_t S6RETENTION = (1U << 22);  ///< Keep retention on RAM section S6 when RAM section is switched off
        constexpr uint32_t S7RETENTION = (1U << 23);  ///< Keep retention on RAM section S7 when RAM section is switched off
        constexpr uint32_t S8RETENTION = (1U << 24);  ///< Keep retention on RAM section S8 when RAM section is switched off
        constexpr uint32_t S9RETENTION = (1U << 25);  ///< Keep retention on RAM section S9 when RAM section is switched off
        constexpr uint32_t S10RETENTION = (1U << 26);  ///< Keep retention on RAM section S10 when RAM section is switched off
        constexpr uint32_t S11RETENTION = (1U << 27);  ///< Keep retention on RAM section S11 when RAM section is switched off
        constexpr uint32_t S12RETENTION = (1U << 28);  ///< Keep retention on RAM section S12 when RAM section is switched off
        constexpr uint32_t S13RETENTION = (1U << 29);  ///< Keep retention on RAM section S13 when RAM section is switched off
        constexpr uint32_t S14RETENTION = (1U << 30);  ///< Keep retention on RAM section S14 when RAM section is switched off
        constexpr uint32_t S15RETENTION = (1U << 31);  ///< Keep retention on RAM section S15 when RAM section is switched off
    }

    /// POWERCLR Register bits
    namespace powerclr_bits {
        constexpr uint32_t S0POWER = (1U << 0);  ///< Keep RAM section S0 of RAMn on or off in System ON mode
        constexpr uint32_t S1POWER = (1U << 1);  ///< Keep RAM section S1 of RAMn on or off in System ON mode
        constexpr uint32_t S2POWER = (1U << 2);  ///< Keep RAM section S2 of RAMn on or off in System ON mode
        constexpr uint32_t S3POWER = (1U << 3);  ///< Keep RAM section S3 of RAMn on or off in System ON mode
        constexpr uint32_t S4POWER = (1U << 4);  ///< Keep RAM section S4 of RAMn on or off in System ON mode
        constexpr uint32_t S5POWER = (1U << 5);  ///< Keep RAM section S5 of RAMn on or off in System ON mode
        constexpr uint32_t S6POWER = (1U << 6);  ///< Keep RAM section S6 of RAMn on or off in System ON mode
        constexpr uint32_t S7POWER = (1U << 7);  ///< Keep RAM section S7 of RAMn on or off in System ON mode
        constexpr uint32_t S8POWER = (1U << 8);  ///< Keep RAM section S8 of RAMn on or off in System ON mode
        constexpr uint32_t S9POWER = (1U << 9);  ///< Keep RAM section S9 of RAMn on or off in System ON mode
        constexpr uint32_t S10POWER = (1U << 10);  ///< Keep RAM section S10 of RAMn on or off in System ON mode
        constexpr uint32_t S11POWER = (1U << 11);  ///< Keep RAM section S11 of RAMn on or off in System ON mode
        constexpr uint32_t S12POWER = (1U << 12);  ///< Keep RAM section S12 of RAMn on or off in System ON mode
        constexpr uint32_t S13POWER = (1U << 13);  ///< Keep RAM section S13 of RAMn on or off in System ON mode
        constexpr uint32_t S14POWER = (1U << 14);  ///< Keep RAM section S14 of RAMn on or off in System ON mode
        constexpr uint32_t S15POWER = (1U << 15);  ///< Keep RAM section S15 of RAMn on or off in System ON mode
        constexpr uint32_t S0RETENTION = (1U << 16);  ///< Keep retention on RAM section S0 when RAM section is switched off
        constexpr uint32_t S1RETENTION = (1U << 17);  ///< Keep retention on RAM section S1 when RAM section is switched off
        constexpr uint32_t S2RETENTION = (1U << 18);  ///< Keep retention on RAM section S2 when RAM section is switched off
        constexpr uint32_t S3RETENTION = (1U << 19);  ///< Keep retention on RAM section S3 when RAM section is switched off
        constexpr uint32_t S4RETENTION = (1U << 20);  ///< Keep retention on RAM section S4 when RAM section is switched off
        constexpr uint32_t S5RETENTION = (1U << 21);  ///< Keep retention on RAM section S5 when RAM section is switched off
        constexpr uint32_t S6RETENTION = (1U << 22);  ///< Keep retention on RAM section S6 when RAM section is switched off
        constexpr uint32_t S7RETENTION = (1U << 23);  ///< Keep retention on RAM section S7 when RAM section is switched off
        constexpr uint32_t S8RETENTION = (1U << 24);  ///< Keep retention on RAM section S8 when RAM section is switched off
        constexpr uint32_t S9RETENTION = (1U << 25);  ///< Keep retention on RAM section S9 when RAM section is switched off
        constexpr uint32_t S10RETENTION = (1U << 26);  ///< Keep retention on RAM section S10 when RAM section is switched off
        constexpr uint32_t S11RETENTION = (1U << 27);  ///< Keep retention on RAM section S11 when RAM section is switched off
        constexpr uint32_t S12RETENTION = (1U << 28);  ///< Keep retention on RAM section S12 when RAM section is switched off
        constexpr uint32_t S13RETENTION = (1U << 29);  ///< Keep retention on RAM section S13 when RAM section is switched off
        constexpr uint32_t S14RETENTION = (1U << 30);  ///< Keep retention on RAM section S14 when RAM section is switched off
        constexpr uint32_t S15RETENTION = (1U << 31);  ///< Keep retention on RAM section S15 when RAM section is switched off
    }

}

// ============================================================================
// P0 Peripheral
// ============================================================================

namespace p0 {
    /// Base addresses
    constexpr uint32_t P0_BASE = 0x50000000;

    /// P0 Register structure
    struct Registers {
        volatile uint32_t OUT;  ///< Offset: 0x504 - Write GPIO port
        volatile uint32_t OUTSET;  ///< Offset: 0x508 - Set individual bits in GPIO port
        volatile uint32_t OUTCLR;  ///< Offset: 0x50C - Clear individual bits in GPIO port
        volatile uint32_t IN;  ///< Offset: 0x510 - Read GPIO port
        volatile uint32_t DIR;  ///< Offset: 0x514 - Direction of GPIO pins
        volatile uint32_t DIRSET;  ///< Offset: 0x518 - DIR set register
        volatile uint32_t DIRCLR;  ///< Offset: 0x51C - DIR clear register
        volatile uint32_t LATCH;  ///< Offset: 0x520 - Latch register indicating what GPIO pins that have met...
        volatile uint32_t DETECTMODE;  ///< Offset: 0x524 - Select between default DETECT signal behaviour and LDETECT mode
        volatile uint32_t PIN_CNF__;  ///< Offset: 0x700 - Description collection: Configuration of GPIO pins (renamed from PIN_CNF__)
    };

    /// Peripheral instances
    inline Registers* P0 = reinterpret_cast<Registers*>(P0_BASE);

    // Bit definitions
    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// OUTSET Register bits
    namespace outset_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// OUTCLR Register bits
    namespace outclr_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// DIR Register bits
    namespace dir_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// DIRSET Register bits
    namespace dirset_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Set as output pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Set as output pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Set as output pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Set as output pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Set as output pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Set as output pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Set as output pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Set as output pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Set as output pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Set as output pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Set as output pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Set as output pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Set as output pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Set as output pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Set as output pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Set as output pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Set as output pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Set as output pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Set as output pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Set as output pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Set as output pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Set as output pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Set as output pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Set as output pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Set as output pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Set as output pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Set as output pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Set as output pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Set as output pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Set as output pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Set as output pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Set as output pin 31
    }

    /// DIRCLR Register bits
    namespace dirclr_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Set as input pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Set as input pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Set as input pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Set as input pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Set as input pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Set as input pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Set as input pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Set as input pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Set as input pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Set as input pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Set as input pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Set as input pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Set as input pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Set as input pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Set as input pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Set as input pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Set as input pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Set as input pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Set as input pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Set as input pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Set as input pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Set as input pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Set as input pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Set as input pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Set as input pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Set as input pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Set as input pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Set as input pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Set as input pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Set as input pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Set as input pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Set as input pin 31
    }

    /// LATCH Register bits
    namespace latch_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Status on whether PIN0 has met criteria set in PIN_CNF0.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN1 = (1U << 1);  ///< Status on whether PIN1 has met criteria set in PIN_CNF1.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN2 = (1U << 2);  ///< Status on whether PIN2 has met criteria set in PIN_CNF2.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN3 = (1U << 3);  ///< Status on whether PIN3 has met criteria set in PIN_CNF3.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN4 = (1U << 4);  ///< Status on whether PIN4 has met criteria set in PIN_CNF4.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN5 = (1U << 5);  ///< Status on whether PIN5 has met criteria set in PIN_CNF5.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN6 = (1U << 6);  ///< Status on whether PIN6 has met criteria set in PIN_CNF6.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN7 = (1U << 7);  ///< Status on whether PIN7 has met criteria set in PIN_CNF7.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN8 = (1U << 8);  ///< Status on whether PIN8 has met criteria set in PIN_CNF8.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN9 = (1U << 9);  ///< Status on whether PIN9 has met criteria set in PIN_CNF9.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN10 = (1U << 10);  ///< Status on whether PIN10 has met criteria set in PIN_CNF10.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN11 = (1U << 11);  ///< Status on whether PIN11 has met criteria set in PIN_CNF11.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN12 = (1U << 12);  ///< Status on whether PIN12 has met criteria set in PIN_CNF12.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN13 = (1U << 13);  ///< Status on whether PIN13 has met criteria set in PIN_CNF13.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN14 = (1U << 14);  ///< Status on whether PIN14 has met criteria set in PIN_CNF14.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN15 = (1U << 15);  ///< Status on whether PIN15 has met criteria set in PIN_CNF15.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN16 = (1U << 16);  ///< Status on whether PIN16 has met criteria set in PIN_CNF16.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN17 = (1U << 17);  ///< Status on whether PIN17 has met criteria set in PIN_CNF17.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN18 = (1U << 18);  ///< Status on whether PIN18 has met criteria set in PIN_CNF18.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN19 = (1U << 19);  ///< Status on whether PIN19 has met criteria set in PIN_CNF19.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN20 = (1U << 20);  ///< Status on whether PIN20 has met criteria set in PIN_CNF20.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN21 = (1U << 21);  ///< Status on whether PIN21 has met criteria set in PIN_CNF21.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN22 = (1U << 22);  ///< Status on whether PIN22 has met criteria set in PIN_CNF22.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN23 = (1U << 23);  ///< Status on whether PIN23 has met criteria set in PIN_CNF23.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN24 = (1U << 24);  ///< Status on whether PIN24 has met criteria set in PIN_CNF24.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN25 = (1U << 25);  ///< Status on whether PIN25 has met criteria set in PIN_CNF25.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN26 = (1U << 26);  ///< Status on whether PIN26 has met criteria set in PIN_CNF26.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN27 = (1U << 27);  ///< Status on whether PIN27 has met criteria set in PIN_CNF27.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN28 = (1U << 28);  ///< Status on whether PIN28 has met criteria set in PIN_CNF28.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN29 = (1U << 29);  ///< Status on whether PIN29 has met criteria set in PIN_CNF29.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN30 = (1U << 30);  ///< Status on whether PIN30 has met criteria set in PIN_CNF30.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN31 = (1U << 31);  ///< Status on whether PIN31 has met criteria set in PIN_CNF31.SENSE register. Write '1' to clear.
    }

    /// DETECTMODE Register bits
    namespace detectmode_bits {
        constexpr uint32_t DETECTMODE = (1U << 0);  ///< Select between default DETECT signal behaviour and LDETECT mode
    }

    /// PIN_CNF__ Register bits
    namespace pin_cnf___bits {
        constexpr uint32_t DIR = (1U << 0);  ///< Pin direction. Same physical register as DIR register
        constexpr uint32_t INPUT = (1U << 1);  ///< Connect or disconnect input buffer
        constexpr uint32_t PULL = (2 << 2);  ///< Pull configuration
        constexpr uint32_t DRIVE = (3 << 8);  ///< Drive configuration
        constexpr uint32_t SENSE = (2 << 16);  ///< Pin sensing mechanism
    }

}

// ============================================================================
// P1 Peripheral
// ============================================================================

namespace p1 {
    /// Base addresses
    constexpr uint32_t P1_BASE = 0x50000300;

    /// P1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* P1 = reinterpret_cast<Registers*>(P1_BASE);

}

// ============================================================================
// RADIO Peripheral
// ============================================================================

namespace radio {
    /// Base addresses
    constexpr uint32_t RADIO_BASE = 0x40001000;

    /// RADIO Register structure
    struct Registers {
        volatile uint32_t TASKS_TXEN;  ///< Offset: 0x00 - Enable RADIO in TX mode
        volatile uint32_t TASKS_RXEN;  ///< Offset: 0x04 - Enable RADIO in RX mode
        volatile uint32_t TASKS_START;  ///< Offset: 0x08 - Start RADIO
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x0C - Stop RADIO
        volatile uint32_t TASKS_DISABLE;  ///< Offset: 0x10 - Disable RADIO
        volatile uint32_t TASKS_RSSISTART;  ///< Offset: 0x14 - Start the RSSI and take one single sample of the receive...
        volatile uint32_t TASKS_RSSISTOP;  ///< Offset: 0x18 - Stop the RSSI measurement
        volatile uint32_t TASKS_BCSTART;  ///< Offset: 0x1C - Start the bit counter
        volatile uint32_t TASKS_BCSTOP;  ///< Offset: 0x20 - Stop the bit counter
        volatile uint32_t TASKS_EDSTART;  ///< Offset: 0x24 - Start the energy detect measurement used in IEEE 802.15.4 mode
        volatile uint32_t TASKS_EDSTOP;  ///< Offset: 0x28 - Stop the energy detect measurement
        volatile uint32_t TASKS_CCASTART;  ///< Offset: 0x2C - Start the clear channel assessment used in IEEE 802.15.4 mode
        volatile uint32_t TASKS_CCASTOP;  ///< Offset: 0x30 - Stop the clear channel assessment
        volatile uint32_t EVENTS_READY;  ///< Offset: 0x100 - RADIO has ramped up and is ready to be started
        volatile uint32_t EVENTS_ADDRESS;  ///< Offset: 0x104 - Address sent or received
        volatile uint32_t EVENTS_PAYLOAD;  ///< Offset: 0x108 - Packet payload sent or received
        volatile uint32_t EVENTS_END;  ///< Offset: 0x10C - Packet sent or received
        volatile uint32_t EVENTS_DISABLED;  ///< Offset: 0x110 - RADIO has been disabled
        volatile uint32_t EVENTS_DEVMATCH;  ///< Offset: 0x114 - A device address match occurred on the last received packet
        volatile uint32_t EVENTS_DEVMISS;  ///< Offset: 0x118 - No device address match occurred on the last received packet
        volatile uint32_t EVENTS_RSSIEND;  ///< Offset: 0x11C - Sampling of receive signal strength complete
        volatile uint32_t EVENTS_BCMATCH;  ///< Offset: 0x128 - Bit counter reached bit count value
        volatile uint32_t EVENTS_CRCOK;  ///< Offset: 0x130 - Packet received with CRC ok
        volatile uint32_t EVENTS_CRCERROR;  ///< Offset: 0x134 - Packet received with CRC error
        volatile uint32_t EVENTS_FRAMESTART;  ///< Offset: 0x138 - IEEE 802.15.4 length field received
        volatile uint32_t EVENTS_EDEND;  ///< Offset: 0x13C - Sampling of energy detection complete. A new ED sample...
        volatile uint32_t EVENTS_EDSTOPPED;  ///< Offset: 0x140 - The sampling of energy detection has stopped
        volatile uint32_t EVENTS_CCAIDLE;  ///< Offset: 0x144 - Wireless medium in idle - clear to send
        volatile uint32_t EVENTS_CCABUSY;  ///< Offset: 0x148 - Wireless medium busy - do not send
        volatile uint32_t EVENTS_CCASTOPPED;  ///< Offset: 0x14C - The CCA has stopped
        volatile uint32_t EVENTS_RATEBOOST;  ///< Offset: 0x150 - Ble_LR CI field received, receive mode is changed from...
        volatile uint32_t EVENTS_TXREADY;  ///< Offset: 0x154 - RADIO has ramped up and is ready to be started TX path
        volatile uint32_t EVENTS_RXREADY;  ///< Offset: 0x158 - RADIO has ramped up and is ready to be started RX path
        volatile uint32_t EVENTS_MHRMATCH;  ///< Offset: 0x15C - MAC header match found
        volatile uint32_t EVENTS_SYNC;  ///< Offset: 0x168 - Preamble indicator.
        volatile uint32_t EVENTS_PHYEND;  ///< Offset: 0x16C - Generated in Ble_LR125Kbit, Ble_LR500Kbit and...
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t CRCSTATUS;  ///< Offset: 0x400 - CRC status
        volatile uint32_t RXMATCH;  ///< Offset: 0x408 - Received address
        volatile uint32_t RXCRC;  ///< Offset: 0x40C - CRC field of previously received packet
        volatile uint32_t DAI;  ///< Offset: 0x410 - Device address match index
        volatile uint32_t PDUSTAT;  ///< Offset: 0x414 - Payload status
        volatile uint32_t PACKETPTR;  ///< Offset: 0x504 - Packet pointer
        volatile uint32_t FREQUENCY;  ///< Offset: 0x508 - Frequency
        volatile uint32_t TXPOWER;  ///< Offset: 0x50C - Output power
        volatile uint32_t MODE;  ///< Offset: 0x510 - Data rate and modulation
        volatile uint32_t PCNF0;  ///< Offset: 0x514 - Packet configuration register 0
        volatile uint32_t PCNF1;  ///< Offset: 0x518 - Packet configuration register 1
        volatile uint32_t BASE0;  ///< Offset: 0x51C - Base address 0
        volatile uint32_t BASE1;  ///< Offset: 0x520 - Base address 1
        volatile uint32_t PREFIX0;  ///< Offset: 0x524 - Prefixes bytes for logical addresses 0-3
        volatile uint32_t PREFIX1;  ///< Offset: 0x528 - Prefixes bytes for logical addresses 4-7
        volatile uint32_t TXADDRESS;  ///< Offset: 0x52C - Transmit address select
        volatile uint32_t RXADDRESSES;  ///< Offset: 0x530 - Receive address select
        volatile uint32_t CRCCNF;  ///< Offset: 0x534 - CRC configuration
        volatile uint32_t CRCPOLY;  ///< Offset: 0x538 - CRC polynomial
        volatile uint32_t CRCINIT;  ///< Offset: 0x53C - CRC initial value
        volatile uint32_t TIFS;  ///< Offset: 0x544 - Interframe spacing in us
        volatile uint32_t RSSISAMPLE;  ///< Offset: 0x548 - RSSI sample
        volatile uint32_t STATE;  ///< Offset: 0x550 - Current radio state
        volatile uint32_t DATAWHITEIV;  ///< Offset: 0x554 - Data whitening initial value
        volatile uint32_t BCC;  ///< Offset: 0x560 - Bit counter compare
        volatile uint32_t DAB__;  ///< Offset: 0x600 - Description collection: Device address base segment n (renamed from DAB__)
        volatile uint32_t DAP__;  ///< Offset: 0x620 - Description collection: Device address prefix n (renamed from DAP__)
        volatile uint32_t DACNF;  ///< Offset: 0x640 - Device address match configuration
        volatile uint32_t MHRMATCHCONF;  ///< Offset: 0x644 - Search pattern configuration
        volatile uint32_t MHRMATCHMAS;  ///< Offset: 0x648 - Pattern mask
        volatile uint32_t MODECNF0;  ///< Offset: 0x650 - Radio mode configuration register 0
        volatile uint32_t SFD;  ///< Offset: 0x660 - IEEE 802.15.4 start of frame delimiter
        volatile uint32_t EDCNT;  ///< Offset: 0x664 - IEEE 802.15.4 energy detect loop count
        volatile uint32_t EDSAMPLE;  ///< Offset: 0x668 - IEEE 802.15.4 energy detect level
        volatile uint32_t CCACTRL;  ///< Offset: 0x66C - IEEE 802.15.4 clear channel assessment control
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control
    };

    /// Peripheral instances
    inline Registers* RADIO = reinterpret_cast<Registers*>(RADIO_BASE);

    // Bit definitions
    /// TASKS_TXEN Register bits
    namespace tasks_txen_bits {
        constexpr uint32_t TASKS_TXEN = (1U << 0);  ///< Enable RADIO in TX mode
    }

    /// TASKS_RXEN Register bits
    namespace tasks_rxen_bits {
        constexpr uint32_t TASKS_RXEN = (1U << 0);  ///< Enable RADIO in RX mode
    }

    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start RADIO
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop RADIO
    }

    /// TASKS_DISABLE Register bits
    namespace tasks_disable_bits {
        constexpr uint32_t TASKS_DISABLE = (1U << 0);  ///< Disable RADIO
    }

    /// TASKS_RSSISTART Register bits
    namespace tasks_rssistart_bits {
        constexpr uint32_t TASKS_RSSISTART = (1U << 0);  ///< Start the RSSI and take one single sample of the receive signal strength
    }

    /// TASKS_RSSISTOP Register bits
    namespace tasks_rssistop_bits {
        constexpr uint32_t TASKS_RSSISTOP = (1U << 0);  ///< Stop the RSSI measurement
    }

    /// TASKS_BCSTART Register bits
    namespace tasks_bcstart_bits {
        constexpr uint32_t TASKS_BCSTART = (1U << 0);  ///< Start the bit counter
    }

    /// TASKS_BCSTOP Register bits
    namespace tasks_bcstop_bits {
        constexpr uint32_t TASKS_BCSTOP = (1U << 0);  ///< Stop the bit counter
    }

    /// TASKS_EDSTART Register bits
    namespace tasks_edstart_bits {
        constexpr uint32_t TASKS_EDSTART = (1U << 0);  ///< Start the energy detect measurement used in IEEE 802.15.4 mode
    }

    /// TASKS_EDSTOP Register bits
    namespace tasks_edstop_bits {
        constexpr uint32_t TASKS_EDSTOP = (1U << 0);  ///< Stop the energy detect measurement
    }

    /// TASKS_CCASTART Register bits
    namespace tasks_ccastart_bits {
        constexpr uint32_t TASKS_CCASTART = (1U << 0);  ///< Start the clear channel assessment used in IEEE 802.15.4 mode
    }

    /// TASKS_CCASTOP Register bits
    namespace tasks_ccastop_bits {
        constexpr uint32_t TASKS_CCASTOP = (1U << 0);  ///< Stop the clear channel assessment
    }

    /// EVENTS_READY Register bits
    namespace events_ready_bits {
        constexpr uint32_t EVENTS_READY = (1U << 0);  ///< RADIO has ramped up and is ready to be started
    }

    /// EVENTS_ADDRESS Register bits
    namespace events_address_bits {
        constexpr uint32_t EVENTS_ADDRESS = (1U << 0);  ///< Address sent or received
    }

    /// EVENTS_PAYLOAD Register bits
    namespace events_payload_bits {
        constexpr uint32_t EVENTS_PAYLOAD = (1U << 0);  ///< Packet payload sent or received
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< Packet sent or received
    }

    /// EVENTS_DISABLED Register bits
    namespace events_disabled_bits {
        constexpr uint32_t EVENTS_DISABLED = (1U << 0);  ///< RADIO has been disabled
    }

    /// EVENTS_DEVMATCH Register bits
    namespace events_devmatch_bits {
        constexpr uint32_t EVENTS_DEVMATCH = (1U << 0);  ///< A device address match occurred on the last received packet
    }

    /// EVENTS_DEVMISS Register bits
    namespace events_devmiss_bits {
        constexpr uint32_t EVENTS_DEVMISS = (1U << 0);  ///< No device address match occurred on the last received packet
    }

    /// EVENTS_RSSIEND Register bits
    namespace events_rssiend_bits {
        constexpr uint32_t EVENTS_RSSIEND = (1U << 0);  ///< Sampling of receive signal strength complete
    }

    /// EVENTS_BCMATCH Register bits
    namespace events_bcmatch_bits {
        constexpr uint32_t EVENTS_BCMATCH = (1U << 0);  ///< Bit counter reached bit count value
    }

    /// EVENTS_CRCOK Register bits
    namespace events_crcok_bits {
        constexpr uint32_t EVENTS_CRCOK = (1U << 0);  ///< Packet received with CRC ok
    }

    /// EVENTS_CRCERROR Register bits
    namespace events_crcerror_bits {
        constexpr uint32_t EVENTS_CRCERROR = (1U << 0);  ///< Packet received with CRC error
    }

    /// EVENTS_FRAMESTART Register bits
    namespace events_framestart_bits {
        constexpr uint32_t EVENTS_FRAMESTART = (1U << 0);  ///< IEEE 802.15.4 length field received
    }

    /// EVENTS_EDEND Register bits
    namespace events_edend_bits {
        constexpr uint32_t EVENTS_EDEND = (1U << 0);  ///< Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register.
    }

    /// EVENTS_EDSTOPPED Register bits
    namespace events_edstopped_bits {
        constexpr uint32_t EVENTS_EDSTOPPED = (1U << 0);  ///< The sampling of energy detection has stopped
    }

    /// EVENTS_CCAIDLE Register bits
    namespace events_ccaidle_bits {
        constexpr uint32_t EVENTS_CCAIDLE = (1U << 0);  ///< Wireless medium in idle - clear to send
    }

    /// EVENTS_CCABUSY Register bits
    namespace events_ccabusy_bits {
        constexpr uint32_t EVENTS_CCABUSY = (1U << 0);  ///< Wireless medium busy - do not send
    }

    /// EVENTS_CCASTOPPED Register bits
    namespace events_ccastopped_bits {
        constexpr uint32_t EVENTS_CCASTOPPED = (1U << 0);  ///< The CCA has stopped
    }

    /// EVENTS_RATEBOOST Register bits
    namespace events_rateboost_bits {
        constexpr uint32_t EVENTS_RATEBOOST = (1U << 0);  ///< Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit.
    }

    /// EVENTS_TXREADY Register bits
    namespace events_txready_bits {
        constexpr uint32_t EVENTS_TXREADY = (1U << 0);  ///< RADIO has ramped up and is ready to be started TX path
    }

    /// EVENTS_RXREADY Register bits
    namespace events_rxready_bits {
        constexpr uint32_t EVENTS_RXREADY = (1U << 0);  ///< RADIO has ramped up and is ready to be started RX path
    }

    /// EVENTS_MHRMATCH Register bits
    namespace events_mhrmatch_bits {
        constexpr uint32_t EVENTS_MHRMATCH = (1U << 0);  ///< MAC header match found
    }

    /// EVENTS_SYNC Register bits
    namespace events_sync_bits {
        constexpr uint32_t EVENTS_SYNC = (1U << 0);  ///< Preamble indicator.
    }

    /// EVENTS_PHYEND Register bits
    namespace events_phyend_bits {
        constexpr uint32_t EVENTS_PHYEND = (1U << 0);  ///< Generated in Ble_LR125Kbit, Ble_LR500Kbit and Ieee802154_250Kbit modes when last bit is sent on air.
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t READY_START = (1U << 0);  ///< Shortcut between event READY and task START
        constexpr uint32_t END_DISABLE = (1U << 1);  ///< Shortcut between event END and task DISABLE
        constexpr uint32_t DISABLED_TXEN = (1U << 2);  ///< Shortcut between event DISABLED and task TXEN
        constexpr uint32_t DISABLED_RXEN = (1U << 3);  ///< Shortcut between event DISABLED and task RXEN
        constexpr uint32_t ADDRESS_RSSISTART = (1U << 4);  ///< Shortcut between event ADDRESS and task RSSISTART
        constexpr uint32_t END_START = (1U << 5);  ///< Shortcut between event END and task START
        constexpr uint32_t ADDRESS_BCSTART = (1U << 6);  ///< Shortcut between event ADDRESS and task BCSTART
        constexpr uint32_t DISABLED_RSSISTOP = (1U << 8);  ///< Shortcut between event DISABLED and task RSSISTOP
        constexpr uint32_t RXREADY_CCASTART = (1U << 11);  ///< Shortcut between event RXREADY and task CCASTART
        constexpr uint32_t CCAIDLE_TXEN = (1U << 12);  ///< Shortcut between event CCAIDLE and task TXEN
        constexpr uint32_t CCABUSY_DISABLE = (1U << 13);  ///< Shortcut between event CCABUSY and task DISABLE
        constexpr uint32_t FRAMESTART_BCSTART = (1U << 14);  ///< Shortcut between event FRAMESTART and task BCSTART
        constexpr uint32_t READY_EDSTART = (1U << 15);  ///< Shortcut between event READY and task EDSTART
        constexpr uint32_t EDEND_DISABLE = (1U << 16);  ///< Shortcut between event EDEND and task DISABLE
        constexpr uint32_t CCAIDLE_STOP = (1U << 17);  ///< Shortcut between event CCAIDLE and task STOP
        constexpr uint32_t TXREADY_START = (1U << 18);  ///< Shortcut between event TXREADY and task START
        constexpr uint32_t RXREADY_START = (1U << 19);  ///< Shortcut between event RXREADY and task START
        constexpr uint32_t PHYEND_DISABLE = (1U << 20);  ///< Shortcut between event PHYEND and task DISABLE
        constexpr uint32_t PHYEND_START = (1U << 21);  ///< Shortcut between event PHYEND and task START
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to enable interrupt for event READY
        constexpr uint32_t ADDRESS = (1U << 1);  ///< Write '1' to enable interrupt for event ADDRESS
        constexpr uint32_t PAYLOAD = (1U << 2);  ///< Write '1' to enable interrupt for event PAYLOAD
        constexpr uint32_t END = (1U << 3);  ///< Write '1' to enable interrupt for event END
        constexpr uint32_t DISABLED = (1U << 4);  ///< Write '1' to enable interrupt for event DISABLED
        constexpr uint32_t DEVMATCH = (1U << 5);  ///< Write '1' to enable interrupt for event DEVMATCH
        constexpr uint32_t DEVMISS = (1U << 6);  ///< Write '1' to enable interrupt for event DEVMISS
        constexpr uint32_t RSSIEND = (1U << 7);  ///< Write '1' to enable interrupt for event RSSIEND
        constexpr uint32_t BCMATCH = (1U << 10);  ///< Write '1' to enable interrupt for event BCMATCH
        constexpr uint32_t CRCOK = (1U << 12);  ///< Write '1' to enable interrupt for event CRCOK
        constexpr uint32_t CRCERROR = (1U << 13);  ///< Write '1' to enable interrupt for event CRCERROR
        constexpr uint32_t FRAMESTART = (1U << 14);  ///< Write '1' to enable interrupt for event FRAMESTART
        constexpr uint32_t EDEND = (1U << 15);  ///< Write '1' to enable interrupt for event EDEND
        constexpr uint32_t EDSTOPPED = (1U << 16);  ///< Write '1' to enable interrupt for event EDSTOPPED
        constexpr uint32_t CCAIDLE = (1U << 17);  ///< Write '1' to enable interrupt for event CCAIDLE
        constexpr uint32_t CCABUSY = (1U << 18);  ///< Write '1' to enable interrupt for event CCABUSY
        constexpr uint32_t CCASTOPPED = (1U << 19);  ///< Write '1' to enable interrupt for event CCASTOPPED
        constexpr uint32_t RATEBOOST = (1U << 20);  ///< Write '1' to enable interrupt for event RATEBOOST
        constexpr uint32_t TXREADY = (1U << 21);  ///< Write '1' to enable interrupt for event TXREADY
        constexpr uint32_t RXREADY = (1U << 22);  ///< Write '1' to enable interrupt for event RXREADY
        constexpr uint32_t MHRMATCH = (1U << 23);  ///< Write '1' to enable interrupt for event MHRMATCH
        constexpr uint32_t SYNC = (1U << 26);  ///< Write '1' to enable interrupt for event SYNC
        constexpr uint32_t PHYEND = (1U << 27);  ///< Write '1' to enable interrupt for event PHYEND
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to disable interrupt for event READY
        constexpr uint32_t ADDRESS = (1U << 1);  ///< Write '1' to disable interrupt for event ADDRESS
        constexpr uint32_t PAYLOAD = (1U << 2);  ///< Write '1' to disable interrupt for event PAYLOAD
        constexpr uint32_t END = (1U << 3);  ///< Write '1' to disable interrupt for event END
        constexpr uint32_t DISABLED = (1U << 4);  ///< Write '1' to disable interrupt for event DISABLED
        constexpr uint32_t DEVMATCH = (1U << 5);  ///< Write '1' to disable interrupt for event DEVMATCH
        constexpr uint32_t DEVMISS = (1U << 6);  ///< Write '1' to disable interrupt for event DEVMISS
        constexpr uint32_t RSSIEND = (1U << 7);  ///< Write '1' to disable interrupt for event RSSIEND
        constexpr uint32_t BCMATCH = (1U << 10);  ///< Write '1' to disable interrupt for event BCMATCH
        constexpr uint32_t CRCOK = (1U << 12);  ///< Write '1' to disable interrupt for event CRCOK
        constexpr uint32_t CRCERROR = (1U << 13);  ///< Write '1' to disable interrupt for event CRCERROR
        constexpr uint32_t FRAMESTART = (1U << 14);  ///< Write '1' to disable interrupt for event FRAMESTART
        constexpr uint32_t EDEND = (1U << 15);  ///< Write '1' to disable interrupt for event EDEND
        constexpr uint32_t EDSTOPPED = (1U << 16);  ///< Write '1' to disable interrupt for event EDSTOPPED
        constexpr uint32_t CCAIDLE = (1U << 17);  ///< Write '1' to disable interrupt for event CCAIDLE
        constexpr uint32_t CCABUSY = (1U << 18);  ///< Write '1' to disable interrupt for event CCABUSY
        constexpr uint32_t CCASTOPPED = (1U << 19);  ///< Write '1' to disable interrupt for event CCASTOPPED
        constexpr uint32_t RATEBOOST = (1U << 20);  ///< Write '1' to disable interrupt for event RATEBOOST
        constexpr uint32_t TXREADY = (1U << 21);  ///< Write '1' to disable interrupt for event TXREADY
        constexpr uint32_t RXREADY = (1U << 22);  ///< Write '1' to disable interrupt for event RXREADY
        constexpr uint32_t MHRMATCH = (1U << 23);  ///< Write '1' to disable interrupt for event MHRMATCH
        constexpr uint32_t SYNC = (1U << 26);  ///< Write '1' to disable interrupt for event SYNC
        constexpr uint32_t PHYEND = (1U << 27);  ///< Write '1' to disable interrupt for event PHYEND
    }

    /// CRCSTATUS Register bits
    namespace crcstatus_bits {
        constexpr uint32_t CRCSTATUS = (1U << 0);  ///< CRC status of packet received
    }

    /// RXMATCH Register bits
    namespace rxmatch_bits {
        constexpr uint32_t RXMATCH = (3 << 0);  ///< Received address
    }

    /// RXCRC Register bits
    namespace rxcrc_bits {
        constexpr uint32_t RXCRC = (24 << 0);  ///< CRC field of previously received packet
    }

    /// DAI Register bits
    namespace dai_bits {
        constexpr uint32_t DAI = (3 << 0);  ///< Device address match index
    }

    /// PDUSTAT Register bits
    namespace pdustat_bits {
        constexpr uint32_t PDUSTAT = (1U << 0);  ///< Status on payload length vs. PCNF1.MAXLEN
        constexpr uint32_t CISTAT = (2 << 1);  ///< Status on what rate packet is received with in Long Range
    }

    /// PACKETPTR Register bits
    namespace packetptr_bits {
        constexpr uint32_t PACKETPTR = (32 << 0);  ///< Packet pointer
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (7 << 0);  ///< Radio channel frequency
        constexpr uint32_t MAP = (1U << 8);  ///< Channel map selection.
    }

    /// TXPOWER Register bits
    namespace txpower_bits {
        constexpr uint32_t TXPOWER = (8 << 0);  ///< RADIO output power
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (4 << 0);  ///< Radio data rate and modulation setting. The radio supports frequency-shift keying (FSK) modulation.
    }

    /// PCNF0 Register bits
    namespace pcnf0_bits {
        constexpr uint32_t LFLEN = (4 << 0);  ///< Length on air of LENGTH field in number of bits.
        constexpr uint32_t S0LEN = (1U << 8);  ///< Length on air of S0 field in number of bytes.
        constexpr uint32_t S1LEN = (4 << 16);  ///< Length on air of S1 field in number of bits.
        constexpr uint32_t S1INCL = (1U << 20);  ///< Include or exclude S1 field in RAM
        constexpr uint32_t CILEN = (2 << 22);  ///< Length of code indicator - long range
        constexpr uint32_t PLEN = (2 << 24);  ///< Length of preamble on air. Decision point: TASKS_START task
        constexpr uint32_t CRCINC = (1U << 26);  ///< Indicates if LENGTH field contains CRC or not
        constexpr uint32_t TERMLEN = (2 << 29);  ///< Length of TERM field in Long Range operation
    }

    /// PCNF1 Register bits
    namespace pcnf1_bits {
        constexpr uint32_t MAXLEN = (8 << 0);  ///< Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN.
        constexpr uint32_t STATLEN = (8 << 8);  ///< Static length in number of bytes
        constexpr uint32_t BALEN = (3 << 16);  ///< Base address length in number of bytes
        constexpr uint32_t ENDIAN = (1U << 24);  ///< On air endianness of packet, this applies to the S0, LENGTH, S1 and the PAYLOAD fields.
        constexpr uint32_t WHITEEN = (1U << 25);  ///< Enable or disable packet whitening
    }

    /// BASE0 Register bits
    namespace base0_bits {
        constexpr uint32_t BASE0 = (32 << 0);  ///< Base address 0
    }

    /// BASE1 Register bits
    namespace base1_bits {
        constexpr uint32_t BASE1 = (32 << 0);  ///< Base address 1
    }

    /// PREFIX0 Register bits
    namespace prefix0_bits {
        constexpr uint32_t AP0 = (8 << 0);  ///< Address prefix 0.
        constexpr uint32_t AP1 = (8 << 8);  ///< Address prefix 1.
        constexpr uint32_t AP2 = (8 << 16);  ///< Address prefix 2.
        constexpr uint32_t AP3 = (8 << 24);  ///< Address prefix 3.
    }

    /// PREFIX1 Register bits
    namespace prefix1_bits {
        constexpr uint32_t AP4 = (8 << 0);  ///< Address prefix 4.
        constexpr uint32_t AP5 = (8 << 8);  ///< Address prefix 5.
        constexpr uint32_t AP6 = (8 << 16);  ///< Address prefix 6.
        constexpr uint32_t AP7 = (8 << 24);  ///< Address prefix 7.
    }

    /// TXADDRESS Register bits
    namespace txaddress_bits {
        constexpr uint32_t TXADDRESS = (3 << 0);  ///< Transmit address select
    }

    /// RXADDRESSES Register bits
    namespace rxaddresses_bits {
        constexpr uint32_t ADDR0 = (1U << 0);  ///< Enable or disable reception on logical address 0.
        constexpr uint32_t ADDR1 = (1U << 1);  ///< Enable or disable reception on logical address 1.
        constexpr uint32_t ADDR2 = (1U << 2);  ///< Enable or disable reception on logical address 2.
        constexpr uint32_t ADDR3 = (1U << 3);  ///< Enable or disable reception on logical address 3.
        constexpr uint32_t ADDR4 = (1U << 4);  ///< Enable or disable reception on logical address 4.
        constexpr uint32_t ADDR5 = (1U << 5);  ///< Enable or disable reception on logical address 5.
        constexpr uint32_t ADDR6 = (1U << 6);  ///< Enable or disable reception on logical address 6.
        constexpr uint32_t ADDR7 = (1U << 7);  ///< Enable or disable reception on logical address 7.
    }

    /// CRCCNF Register bits
    namespace crccnf_bits {
        constexpr uint32_t LEN = (2 << 0);  ///< CRC length in number of bytes.
        constexpr uint32_t SKIPADDR = (2 << 8);  ///< Include or exclude packet address field out of CRC calculation.
    }

    /// CRCPOLY Register bits
    namespace crcpoly_bits {
        constexpr uint32_t CRCPOLY = (24 << 0);  ///< CRC polynomial
    }

    /// CRCINIT Register bits
    namespace crcinit_bits {
        constexpr uint32_t CRCINIT = (24 << 0);  ///< CRC initial value
    }

    /// TIFS Register bits
    namespace tifs_bits {
        constexpr uint32_t TIFS = (10 << 0);  ///< Interframe spacing in us
    }

    /// RSSISAMPLE Register bits
    namespace rssisample_bits {
        constexpr uint32_t RSSISAMPLE = (7 << 0);  ///< RSSI sample
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t STATE = (4 << 0);  ///< Current radio state
    }

    /// DATAWHITEIV Register bits
    namespace datawhiteiv_bits {
        constexpr uint32_t DATAWHITEIV = (7 << 0);  ///< Data whitening initial value. Bit 6 is hard-wired to '1', writing '0' to it has no effect, and it will always be read back and used by the device as '1'.
    }

    /// BCC Register bits
    namespace bcc_bits {
        constexpr uint32_t BCC = (32 << 0);  ///< Bit counter compare
    }

    /// DAB__ Register bits
    namespace dab___bits {
        constexpr uint32_t DAB = (32 << 0);  ///< Device address base segment n
    }

    /// DAP__ Register bits
    namespace dap___bits {
        constexpr uint32_t DAP = (16 << 0);  ///< Device address prefix n
    }

    /// DACNF Register bits
    namespace dacnf_bits {
        constexpr uint32_t ENA0 = (1U << 0);  ///< Enable or disable device address matching using device address 0
        constexpr uint32_t ENA1 = (1U << 1);  ///< Enable or disable device address matching using device address 1
        constexpr uint32_t ENA2 = (1U << 2);  ///< Enable or disable device address matching using device address 2
        constexpr uint32_t ENA3 = (1U << 3);  ///< Enable or disable device address matching using device address 3
        constexpr uint32_t ENA4 = (1U << 4);  ///< Enable or disable device address matching using device address 4
        constexpr uint32_t ENA5 = (1U << 5);  ///< Enable or disable device address matching using device address 5
        constexpr uint32_t ENA6 = (1U << 6);  ///< Enable or disable device address matching using device address 6
        constexpr uint32_t ENA7 = (1U << 7);  ///< Enable or disable device address matching using device address 7
        constexpr uint32_t TXADD0 = (1U << 8);  ///< TxAdd for device address 0
        constexpr uint32_t TXADD1 = (1U << 9);  ///< TxAdd for device address 1
        constexpr uint32_t TXADD2 = (1U << 10);  ///< TxAdd for device address 2
        constexpr uint32_t TXADD3 = (1U << 11);  ///< TxAdd for device address 3
        constexpr uint32_t TXADD4 = (1U << 12);  ///< TxAdd for device address 4
        constexpr uint32_t TXADD5 = (1U << 13);  ///< TxAdd for device address 5
        constexpr uint32_t TXADD6 = (1U << 14);  ///< TxAdd for device address 6
        constexpr uint32_t TXADD7 = (1U << 15);  ///< TxAdd for device address 7
    }

    /// MHRMATCHCONF Register bits
    namespace mhrmatchconf_bits {
        constexpr uint32_t MHRMATCHCONF = (32 << 0);  ///< Search pattern configuration
    }

    /// MHRMATCHMAS Register bits
    namespace mhrmatchmas_bits {
        constexpr uint32_t MHRMATCHMAS = (32 << 0);  ///< Pattern mask
    }

    /// MODECNF0 Register bits
    namespace modecnf0_bits {
        constexpr uint32_t RU = (1U << 0);  ///< Radio ramp-up time
        constexpr uint32_t DTX = (2 << 8);  ///< Default TX value
    }

    /// SFD Register bits
    namespace sfd_bits {
        constexpr uint32_t SFD = (8 << 0);  ///< IEEE 802.15.4 start of frame delimiter
    }

    /// EDCNT Register bits
    namespace edcnt_bits {
        constexpr uint32_t EDCNT = (21 << 0);  ///< IEEE 802.15.4 energy detect loop count
    }

    /// EDSAMPLE Register bits
    namespace edsample_bits {
        constexpr uint32_t EDLVL = (8 << 0);  ///< IEEE 802.15.4 energy detect level
    }

    /// CCACTRL Register bits
    namespace ccactrl_bits {
        constexpr uint32_t CCAMODE = (3 << 0);  ///< CCA mode of operation
        constexpr uint32_t CCAEDTHRES = (8 << 8);  ///< CCA energy busy threshold. Used in all the CCA modes except CarrierMode.
        constexpr uint32_t CCACORRTHRES = (8 << 16);  ///< CCA correlator busy threshold. Only relevant to CarrierMode, CarrierAndEdMode and CarrierOrEdMode.
        constexpr uint32_t CCACORRCNT = (8 << 24);  ///< Limit for occurances above CCACORRTHRES. When not equal to zero the corrolator based signal detect is enabled.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control. The peripheral and its registers will be reset to its initial state by switching the peripheral off and then back on again.
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x40002000;
    constexpr uint32_t UARTE0_BASE = 0x40002000;
    constexpr uint32_t UARTE1_BASE = 0x40028000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTRX;  ///< Offset: 0x00 - Start UART receiver
        volatile uint32_t TASKS_STOPRX;  ///< Offset: 0x04 - Stop UART receiver
        volatile uint32_t TASKS_STARTTX;  ///< Offset: 0x08 - Start UART transmitter
        volatile uint32_t TASKS_STOPTX;  ///< Offset: 0x0C - Stop UART transmitter
        volatile uint32_t TASKS_SUSPEND;  ///< Offset: 0x1C - Suspend UART
        volatile uint32_t EVENTS_CTS;  ///< Offset: 0x100 - CTS is activated (set low). Clear To Send.
        volatile uint32_t EVENTS_NCTS;  ///< Offset: 0x104 - CTS is deactivated (set high). Not Clear To Send.
        volatile uint32_t EVENTS_RXDRDY;  ///< Offset: 0x108 - Data received in RXD
        volatile uint32_t EVENTS_TXDRDY;  ///< Offset: 0x11C - Data sent from TXD
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x124 - Error detected
        volatile uint32_t EVENTS_RXTO;  ///< Offset: 0x144 - Receiver timeout
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ERRORSRC;  ///< Offset: 0x480 - Error source
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable UART
        volatile uint32_t RTS;  ///< Offset: 0x00 - Pin select for RTS
        volatile uint32_t TXD;  ///< Offset: 0x51C - TXD register
        volatile uint32_t CTS;  ///< Offset: 0x08 - Pin select for CTS
        volatile uint32_t RXD;  ///< Offset: 0x518 - RXD register
        volatile uint32_t BAUDRATE;  ///< Offset: 0x524 - Baud rate. Accuracy depends on the HFCLK source selected.
        volatile uint32_t CONFIG;  ///< Offset: 0x56C - Configuration of parity and hardware flow control
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UARTE0 = reinterpret_cast<Registers*>(UARTE0_BASE);
    inline Registers* UARTE1 = reinterpret_cast<Registers*>(UARTE1_BASE);

    // Bit definitions
    /// TASKS_STARTRX Register bits
    namespace tasks_startrx_bits {
        constexpr uint32_t TASKS_STARTRX = (1U << 0);  ///< Start UART receiver
    }

    /// TASKS_STOPRX Register bits
    namespace tasks_stoprx_bits {
        constexpr uint32_t TASKS_STOPRX = (1U << 0);  ///< Stop UART receiver
    }

    /// TASKS_STARTTX Register bits
    namespace tasks_starttx_bits {
        constexpr uint32_t TASKS_STARTTX = (1U << 0);  ///< Start UART transmitter
    }

    /// TASKS_STOPTX Register bits
    namespace tasks_stoptx_bits {
        constexpr uint32_t TASKS_STOPTX = (1U << 0);  ///< Stop UART transmitter
    }

    /// TASKS_SUSPEND Register bits
    namespace tasks_suspend_bits {
        constexpr uint32_t TASKS_SUSPEND = (1U << 0);  ///< Suspend UART
    }

    /// EVENTS_CTS Register bits
    namespace events_cts_bits {
        constexpr uint32_t EVENTS_CTS = (1U << 0);  ///< CTS is activated (set low). Clear To Send.
    }

    /// EVENTS_NCTS Register bits
    namespace events_ncts_bits {
        constexpr uint32_t EVENTS_NCTS = (1U << 0);  ///< CTS is deactivated (set high). Not Clear To Send.
    }

    /// EVENTS_RXDRDY Register bits
    namespace events_rxdrdy_bits {
        constexpr uint32_t EVENTS_RXDRDY = (1U << 0);  ///< Data received in RXD
    }

    /// EVENTS_TXDRDY Register bits
    namespace events_txdrdy_bits {
        constexpr uint32_t EVENTS_TXDRDY = (1U << 0);  ///< Data sent from TXD
    }

    /// EVENTS_ERROR Register bits
    namespace events_error_bits {
        constexpr uint32_t EVENTS_ERROR = (1U << 0);  ///< Error detected
    }

    /// EVENTS_RXTO Register bits
    namespace events_rxto_bits {
        constexpr uint32_t EVENTS_RXTO = (1U << 0);  ///< Receiver timeout
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t CTS_STARTRX = (1U << 3);  ///< Shortcut between event CTS and task STARTRX
        constexpr uint32_t NCTS_STOPRX = (1U << 4);  ///< Shortcut between event NCTS and task STOPRX
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t CTS = (1U << 0);  ///< Write '1' to enable interrupt for event CTS
        constexpr uint32_t NCTS = (1U << 1);  ///< Write '1' to enable interrupt for event NCTS
        constexpr uint32_t RXDRDY = (1U << 2);  ///< Write '1' to enable interrupt for event RXDRDY
        constexpr uint32_t TXDRDY = (1U << 7);  ///< Write '1' to enable interrupt for event TXDRDY
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to enable interrupt for event ERROR
        constexpr uint32_t RXTO = (1U << 17);  ///< Write '1' to enable interrupt for event RXTO
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t CTS = (1U << 0);  ///< Write '1' to disable interrupt for event CTS
        constexpr uint32_t NCTS = (1U << 1);  ///< Write '1' to disable interrupt for event NCTS
        constexpr uint32_t RXDRDY = (1U << 2);  ///< Write '1' to disable interrupt for event RXDRDY
        constexpr uint32_t TXDRDY = (1U << 7);  ///< Write '1' to disable interrupt for event TXDRDY
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to disable interrupt for event ERROR
        constexpr uint32_t RXTO = (1U << 17);  ///< Write '1' to disable interrupt for event RXTO
    }

    /// ERRORSRC Register bits
    namespace errorsrc_bits {
        constexpr uint32_t OVERRUN = (1U << 0);  ///< Overrun error
        constexpr uint32_t PARITY = (1U << 1);  ///< Parity error
        constexpr uint32_t FRAMING = (1U << 2);  ///< Framing error occurred
        constexpr uint32_t BREAK_ = (1U << 3);  ///< Break condition (renamed from BREAK_)
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (4 << 0);  ///< Enable or disable UART
    }

    /// RTS Register bits
    namespace rts_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// TXD Register bits
    namespace txd_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< TX data to be transferred
    }

    /// CTS Register bits
    namespace cts_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// RXD Register bits
    namespace rxd_bits {
        constexpr uint32_t RXD = (8 << 0);  ///< RX data received in previous transfers, double buffered
    }

    /// BAUDRATE Register bits
    namespace baudrate_bits {
        constexpr uint32_t BAUDRATE = (32 << 0);  ///< Baud rate
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t HWFC = (1U << 0);  ///< Hardware flow control
        constexpr uint32_t PARITY = (3 << 1);  ///< Parity
        constexpr uint32_t STOP = (1U << 4);  ///< Stop bits
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40003000;
    constexpr uint32_t SPIM0_BASE = 0x40003000;
    constexpr uint32_t SPIS0_BASE = 0x40003000;
    constexpr uint32_t SPI1_BASE = 0x40004000;
    constexpr uint32_t SPIM1_BASE = 0x40004000;
    constexpr uint32_t SPIS1_BASE = 0x40004000;
    constexpr uint32_t SPI2_BASE = 0x40023000;
    constexpr uint32_t SPIM2_BASE = 0x40023000;
    constexpr uint32_t SPIS2_BASE = 0x40023000;
    constexpr uint32_t QSPI_BASE = 0x40029000;
    constexpr uint32_t SPIM3_BASE = 0x4002F000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t EVENTS_READY;  ///< Offset: 0x108 - TXD byte sent and RXD byte received
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable SPI
        volatile uint32_t SCK;  ///< Offset: 0x00 - Pin select for SCK
        volatile uint32_t MOSI;  ///< Offset: 0x04 - Pin select for MOSI signal
        volatile uint32_t MISO;  ///< Offset: 0x08 - Pin select for MISO signal
        volatile uint32_t RXD;  ///< Offset: 0x518 - RXD register
        volatile uint32_t TXD;  ///< Offset: 0x51C - TXD register
        volatile uint32_t FREQUENCY;  ///< Offset: 0x524 - SPI frequency. Accuracy depends on the HFCLK source selected.
        volatile uint32_t CONFIG;  ///< Offset: 0x554 - Configuration register
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPIM0 = reinterpret_cast<Registers*>(SPIM0_BASE);
    inline Registers* SPIS0 = reinterpret_cast<Registers*>(SPIS0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPIM1 = reinterpret_cast<Registers*>(SPIM1_BASE);
    inline Registers* SPIS1 = reinterpret_cast<Registers*>(SPIS1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SPIM2 = reinterpret_cast<Registers*>(SPIM2_BASE);
    inline Registers* SPIS2 = reinterpret_cast<Registers*>(SPIS2_BASE);
    inline Registers* QSPI = reinterpret_cast<Registers*>(QSPI_BASE);
    inline Registers* SPIM3 = reinterpret_cast<Registers*>(SPIM3_BASE);

    // Bit definitions
    /// EVENTS_READY Register bits
    namespace events_ready_bits {
        constexpr uint32_t EVENTS_READY = (1U << 0);  ///< TXD byte sent and RXD byte received
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 2);  ///< Write '1' to enable interrupt for event READY
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 2);  ///< Write '1' to disable interrupt for event READY
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (4 << 0);  ///< Enable or disable SPI
    }

    /// SCK Register bits
    namespace sck_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// MOSI Register bits
    namespace mosi_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// MISO Register bits
    namespace miso_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// RXD Register bits
    namespace rxd_bits {
        constexpr uint32_t RXD = (8 << 0);  ///< RX data received. Double buffered
    }

    /// TXD Register bits
    namespace txd_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< TX data to send. Double buffered
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (32 << 0);  ///< SPI master data rate
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t ORDER = (1U << 0);  ///< Bit order
        constexpr uint32_t CPHA = (1U << 1);  ///< Serial clock (SCK) phase
        constexpr uint32_t CPOL = (1U << 2);  ///< Serial clock (SCK) polarity
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t TWI0_BASE = 0x40003000;
    constexpr uint32_t TWIM0_BASE = 0x40003000;
    constexpr uint32_t TWIS0_BASE = 0x40003000;
    constexpr uint32_t TWI1_BASE = 0x40004000;
    constexpr uint32_t TWIM1_BASE = 0x40004000;
    constexpr uint32_t TWIS1_BASE = 0x40004000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTRX;  ///< Offset: 0x00 - Start TWI receive sequence
        volatile uint32_t TASKS_STARTTX;  ///< Offset: 0x08 - Start TWI transmit sequence
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x14 - Stop TWI transaction
        volatile uint32_t TASKS_SUSPEND;  ///< Offset: 0x1C - Suspend TWI transaction
        volatile uint32_t TASKS_RESUME;  ///< Offset: 0x20 - Resume TWI transaction
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - TWI stopped
        volatile uint32_t EVENTS_RXDREADY;  ///< Offset: 0x108 - TWI RXD byte received
        volatile uint32_t EVENTS_TXDSENT;  ///< Offset: 0x11C - TWI TXD byte sent
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x124 - TWI error
        volatile uint32_t EVENTS_BB;  ///< Offset: 0x138 - TWI byte boundary, generated before each byte that is...
        volatile uint32_t EVENTS_SUSPENDED;  ///< Offset: 0x148 - TWI entered the suspended state
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ERRORSRC;  ///< Offset: 0x4C4 - Error source
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable TWI
        volatile uint32_t SCL;  ///< Offset: 0x00 - Pin select for SCL
        volatile uint32_t SDA;  ///< Offset: 0x04 - Pin select for SDA
        volatile uint32_t RXD;  ///< Offset: 0x518 - RXD register
        volatile uint32_t TXD;  ///< Offset: 0x51C - TXD register
        volatile uint32_t FREQUENCY;  ///< Offset: 0x524 - TWI frequency. Accuracy depends on the HFCLK source selected.
        volatile uint32_t ADDRESS;  ///< Offset: 0x588 - Address used in the TWI transfer
    };

    /// Peripheral instances
    inline Registers* TWI0 = reinterpret_cast<Registers*>(TWI0_BASE);
    inline Registers* TWIM0 = reinterpret_cast<Registers*>(TWIM0_BASE);
    inline Registers* TWIS0 = reinterpret_cast<Registers*>(TWIS0_BASE);
    inline Registers* TWI1 = reinterpret_cast<Registers*>(TWI1_BASE);
    inline Registers* TWIM1 = reinterpret_cast<Registers*>(TWIM1_BASE);
    inline Registers* TWIS1 = reinterpret_cast<Registers*>(TWIS1_BASE);

    // Bit definitions
    /// TASKS_STARTRX Register bits
    namespace tasks_startrx_bits {
        constexpr uint32_t TASKS_STARTRX = (1U << 0);  ///< Start TWI receive sequence
    }

    /// TASKS_STARTTX Register bits
    namespace tasks_starttx_bits {
        constexpr uint32_t TASKS_STARTTX = (1U << 0);  ///< Start TWI transmit sequence
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop TWI transaction
    }

    /// TASKS_SUSPEND Register bits
    namespace tasks_suspend_bits {
        constexpr uint32_t TASKS_SUSPEND = (1U << 0);  ///< Suspend TWI transaction
    }

    /// TASKS_RESUME Register bits
    namespace tasks_resume_bits {
        constexpr uint32_t TASKS_RESUME = (1U << 0);  ///< Resume TWI transaction
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< TWI stopped
    }

    /// EVENTS_RXDREADY Register bits
    namespace events_rxdready_bits {
        constexpr uint32_t EVENTS_RXDREADY = (1U << 0);  ///< TWI RXD byte received
    }

    /// EVENTS_TXDSENT Register bits
    namespace events_txdsent_bits {
        constexpr uint32_t EVENTS_TXDSENT = (1U << 0);  ///< TWI TXD byte sent
    }

    /// EVENTS_ERROR Register bits
    namespace events_error_bits {
        constexpr uint32_t EVENTS_ERROR = (1U << 0);  ///< TWI error
    }

    /// EVENTS_BB Register bits
    namespace events_bb_bits {
        constexpr uint32_t EVENTS_BB = (1U << 0);  ///< TWI byte boundary, generated before each byte that is sent or received
    }

    /// EVENTS_SUSPENDED Register bits
    namespace events_suspended_bits {
        constexpr uint32_t EVENTS_SUSPENDED = (1U << 0);  ///< TWI entered the suspended state
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t BB_SUSPEND = (1U << 0);  ///< Shortcut between event BB and task SUSPEND
        constexpr uint32_t BB_STOP = (1U << 1);  ///< Shortcut between event BB and task STOP
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t RXDREADY = (1U << 2);  ///< Write '1' to enable interrupt for event RXDREADY
        constexpr uint32_t TXDSENT = (1U << 7);  ///< Write '1' to enable interrupt for event TXDSENT
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to enable interrupt for event ERROR
        constexpr uint32_t BB = (1U << 14);  ///< Write '1' to enable interrupt for event BB
        constexpr uint32_t SUSPENDED = (1U << 18);  ///< Write '1' to enable interrupt for event SUSPENDED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t RXDREADY = (1U << 2);  ///< Write '1' to disable interrupt for event RXDREADY
        constexpr uint32_t TXDSENT = (1U << 7);  ///< Write '1' to disable interrupt for event TXDSENT
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to disable interrupt for event ERROR
        constexpr uint32_t BB = (1U << 14);  ///< Write '1' to disable interrupt for event BB
        constexpr uint32_t SUSPENDED = (1U << 18);  ///< Write '1' to disable interrupt for event SUSPENDED
    }

    /// ERRORSRC Register bits
    namespace errorsrc_bits {
        constexpr uint32_t OVERRUN = (1U << 0);  ///< Overrun error
        constexpr uint32_t ANACK = (1U << 1);  ///< NACK received after sending the address (write '1' to clear)
        constexpr uint32_t DNACK = (1U << 2);  ///< NACK received after sending a data byte (write '1' to clear)
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (4 << 0);  ///< Enable or disable TWI
    }

    /// SCL Register bits
    namespace scl_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// SDA Register bits
    namespace sda_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// RXD Register bits
    namespace rxd_bits {
        constexpr uint32_t RXD = (8 << 0);  ///< RXD register
    }

    /// TXD Register bits
    namespace txd_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< TXD register
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (32 << 0);  ///< TWI master clock frequency
    }

    /// ADDRESS Register bits
    namespace address_bits {
        constexpr uint32_t ADDRESS = (7 << 0);  ///< Address used in the TWI transfer
    }

}

// ============================================================================
// NFCT Peripheral
// ============================================================================

namespace nfct {
    /// Base addresses
    constexpr uint32_t NFCT_BASE = 0x40005000;

    /// NFCT Register structure
    struct Registers {
        volatile uint32_t TASKS_ACTIVATE;  ///< Offset: 0x00 - Activate NFCT peripheral for incoming and outgoing...
        volatile uint32_t TASKS_DISABLE;  ///< Offset: 0x04 - Disable NFCT peripheral
        volatile uint32_t TASKS_SENSE;  ///< Offset: 0x08 - Enable NFC sense field mode, change state to sense mode
        volatile uint32_t TASKS_STARTTX;  ///< Offset: 0x0C - Start transmission of an outgoing frame, change state to transmit
        volatile uint32_t TASKS_ENABLERXDATA;  ///< Offset: 0x1C - Initializes the EasyDMA for receive.
        volatile uint32_t TASKS_GOIDLE;  ///< Offset: 0x24 - Force state machine to IDLE state
        volatile uint32_t TASKS_GOSLEEP;  ///< Offset: 0x28 - Force state machine to SLEEP_A state
        volatile uint32_t EVENTS_READY;  ///< Offset: 0x100 - The NFCT peripheral is ready to receive and send frames
        volatile uint32_t EVENTS_FIELDDETECTED;  ///< Offset: 0x104 - Remote NFC field detected
        volatile uint32_t EVENTS_FIELDLOST;  ///< Offset: 0x108 - Remote NFC field lost
        volatile uint32_t EVENTS_TXFRAMESTART;  ///< Offset: 0x10C - Marks the start of the first symbol of a transmitted frame
        volatile uint32_t EVENTS_TXFRAMEEND;  ///< Offset: 0x110 - Marks the end of the last transmitted on-air symbol of a frame
        volatile uint32_t EVENTS_RXFRAMESTART;  ///< Offset: 0x114 - Marks the end of the first symbol of a received frame
        volatile uint32_t EVENTS_RXFRAMEEND;  ///< Offset: 0x118 - Received data has been checked (CRC, parity) and...
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x11C - NFC error reported. The ERRORSTATUS register contains...
        volatile uint32_t EVENTS_RXERROR;  ///< Offset: 0x128 - NFC RX frame error reported. The FRAMESTATUS.RX register...
        volatile uint32_t EVENTS_ENDRX;  ///< Offset: 0x12C - RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full.
        volatile uint32_t EVENTS_ENDTX;  ///< Offset: 0x130 - Transmission of data in RAM has ended, and EasyDMA has...
        volatile uint32_t EVENTS_AUTOCOLRESSTARTED;  ///< Offset: 0x138 - Auto collision resolution process has started
        volatile uint32_t EVENTS_COLLISION;  ///< Offset: 0x148 - NFC auto collision resolution error reported.
        volatile uint32_t EVENTS_SELECTED;  ///< Offset: 0x14C - NFC auto collision resolution successfully completed
        volatile uint32_t EVENTS_STARTED;  ///< Offset: 0x150 - EasyDMA is ready to receive or send frames.
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ERRORSTATUS;  ///< Offset: 0x404 - NFC Error Status register
        volatile uint32_t RX;  ///< Offset: 0x00 - Result of last incoming frame
        volatile uint32_t NFCTAGSTATE;  ///< Offset: 0x410 - NfcTag state register
        volatile uint32_t SLEEPSTATE;  ///< Offset: 0x420 - Sleep state during automatic collision resolution
        volatile uint32_t FIELDPRESENT;  ///< Offset: 0x43C - Indicates the presence or not of a valid field
        volatile uint32_t FRAMEDELAYMIN;  ///< Offset: 0x504 - Minimum frame delay
        volatile uint32_t FRAMEDELAYMAX;  ///< Offset: 0x508 - Maximum frame delay
        volatile uint32_t FRAMEDELAYMODE;  ///< Offset: 0x50C - Configuration register for the Frame Delay Timer
        volatile uint32_t PACKETPTR;  ///< Offset: 0x510 - Packet pointer for TXD and RXD data storage in Data RAM
        volatile uint32_t MAXLEN;  ///< Offset: 0x514 - Size of the RAM buffer allocated to TXD and RXD data storage each
        volatile uint32_t FRAMECONFIG;  ///< Offset: 0x00 - Configuration of incoming frames
        volatile uint32_t AMOUNT;  ///< Offset: 0x04 - Size of last incoming frame
        volatile uint32_t NFCID1_LAST;  ///< Offset: 0x590 - Last NFCID1 part (4, 7 or 10 bytes ID)
        volatile uint32_t NFCID1_2ND_LAST;  ///< Offset: 0x594 - Second last NFCID1 part (7 or 10 bytes ID)
        volatile uint32_t NFCID1_3RD_LAST;  ///< Offset: 0x598 - Third last NFCID1 part (10 bytes ID)
        volatile uint32_t AUTOCOLRESCONFIG;  ///< Offset: 0x59C - Controls the auto collision resolution function. This...
        volatile uint32_t SENSRES;  ///< Offset: 0x5A0 - NFC-A SENS_RES auto-response settings
        volatile uint32_t SELRES;  ///< Offset: 0x5A4 - NFC-A SEL_RES auto-response settings
    };

    /// Peripheral instances
    inline Registers* NFCT = reinterpret_cast<Registers*>(NFCT_BASE);

    // Bit definitions
    /// TASKS_ACTIVATE Register bits
    namespace tasks_activate_bits {
        constexpr uint32_t TASKS_ACTIVATE = (1U << 0);  ///< Activate NFCT peripheral for incoming and outgoing frames, change state to activated
    }

    /// TASKS_DISABLE Register bits
    namespace tasks_disable_bits {
        constexpr uint32_t TASKS_DISABLE = (1U << 0);  ///< Disable NFCT peripheral
    }

    /// TASKS_SENSE Register bits
    namespace tasks_sense_bits {
        constexpr uint32_t TASKS_SENSE = (1U << 0);  ///< Enable NFC sense field mode, change state to sense mode
    }

    /// TASKS_STARTTX Register bits
    namespace tasks_starttx_bits {
        constexpr uint32_t TASKS_STARTTX = (1U << 0);  ///< Start transmission of an outgoing frame, change state to transmit
    }

    /// TASKS_ENABLERXDATA Register bits
    namespace tasks_enablerxdata_bits {
        constexpr uint32_t TASKS_ENABLERXDATA = (1U << 0);  ///< Initializes the EasyDMA for receive.
    }

    /// TASKS_GOIDLE Register bits
    namespace tasks_goidle_bits {
        constexpr uint32_t TASKS_GOIDLE = (1U << 0);  ///< Force state machine to IDLE state
    }

    /// TASKS_GOSLEEP Register bits
    namespace tasks_gosleep_bits {
        constexpr uint32_t TASKS_GOSLEEP = (1U << 0);  ///< Force state machine to SLEEP_A state
    }

    /// EVENTS_READY Register bits
    namespace events_ready_bits {
        constexpr uint32_t EVENTS_READY = (1U << 0);  ///< The NFCT peripheral is ready to receive and send frames
    }

    /// EVENTS_FIELDDETECTED Register bits
    namespace events_fielddetected_bits {
        constexpr uint32_t EVENTS_FIELDDETECTED = (1U << 0);  ///< Remote NFC field detected
    }

    /// EVENTS_FIELDLOST Register bits
    namespace events_fieldlost_bits {
        constexpr uint32_t EVENTS_FIELDLOST = (1U << 0);  ///< Remote NFC field lost
    }

    /// EVENTS_TXFRAMESTART Register bits
    namespace events_txframestart_bits {
        constexpr uint32_t EVENTS_TXFRAMESTART = (1U << 0);  ///< Marks the start of the first symbol of a transmitted frame
    }

    /// EVENTS_TXFRAMEEND Register bits
    namespace events_txframeend_bits {
        constexpr uint32_t EVENTS_TXFRAMEEND = (1U << 0);  ///< Marks the end of the last transmitted on-air symbol of a frame
    }

    /// EVENTS_RXFRAMESTART Register bits
    namespace events_rxframestart_bits {
        constexpr uint32_t EVENTS_RXFRAMESTART = (1U << 0);  ///< Marks the end of the first symbol of a received frame
    }

    /// EVENTS_RXFRAMEEND Register bits
    namespace events_rxframeend_bits {
        constexpr uint32_t EVENTS_RXFRAMEEND = (1U << 0);  ///< Received data has been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer
    }

    /// EVENTS_ERROR Register bits
    namespace events_error_bits {
        constexpr uint32_t EVENTS_ERROR = (1U << 0);  ///< NFC error reported. The ERRORSTATUS register contains details on the source of the error.
    }

    /// EVENTS_RXERROR Register bits
    namespace events_rxerror_bits {
        constexpr uint32_t EVENTS_RXERROR = (1U << 0);  ///< NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error.
    }

    /// EVENTS_ENDRX Register bits
    namespace events_endrx_bits {
        constexpr uint32_t EVENTS_ENDRX = (1U << 0);  ///< RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full.
    }

    /// EVENTS_ENDTX Register bits
    namespace events_endtx_bits {
        constexpr uint32_t EVENTS_ENDTX = (1U << 0);  ///< Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer
    }

    /// EVENTS_AUTOCOLRESSTARTED Register bits
    namespace events_autocolresstarted_bits {
        constexpr uint32_t EVENTS_AUTOCOLRESSTARTED = (1U << 0);  ///< Auto collision resolution process has started
    }

    /// EVENTS_COLLISION Register bits
    namespace events_collision_bits {
        constexpr uint32_t EVENTS_COLLISION = (1U << 0);  ///< NFC auto collision resolution error reported.
    }

    /// EVENTS_SELECTED Register bits
    namespace events_selected_bits {
        constexpr uint32_t EVENTS_SELECTED = (1U << 0);  ///< NFC auto collision resolution successfully completed
    }

    /// EVENTS_STARTED Register bits
    namespace events_started_bits {
        constexpr uint32_t EVENTS_STARTED = (1U << 0);  ///< EasyDMA is ready to receive or send frames.
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t FIELDDETECTED_ACTIVATE = (1U << 0);  ///< Shortcut between event FIELDDETECTED and task ACTIVATE
        constexpr uint32_t FIELDLOST_SENSE = (1U << 1);  ///< Shortcut between event FIELDLOST and task SENSE
        constexpr uint32_t TXFRAMEEND_ENABLERXDATA = (1U << 5);  ///< Shortcut between event TXFRAMEEND and task ENABLERXDATA
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Enable or disable interrupt for event READY
        constexpr uint32_t FIELDDETECTED = (1U << 1);  ///< Enable or disable interrupt for event FIELDDETECTED
        constexpr uint32_t FIELDLOST = (1U << 2);  ///< Enable or disable interrupt for event FIELDLOST
        constexpr uint32_t TXFRAMESTART = (1U << 3);  ///< Enable or disable interrupt for event TXFRAMESTART
        constexpr uint32_t TXFRAMEEND = (1U << 4);  ///< Enable or disable interrupt for event TXFRAMEEND
        constexpr uint32_t RXFRAMESTART = (1U << 5);  ///< Enable or disable interrupt for event RXFRAMESTART
        constexpr uint32_t RXFRAMEEND = (1U << 6);  ///< Enable or disable interrupt for event RXFRAMEEND
        constexpr uint32_t ERROR = (1U << 7);  ///< Enable or disable interrupt for event ERROR
        constexpr uint32_t RXERROR = (1U << 10);  ///< Enable or disable interrupt for event RXERROR
        constexpr uint32_t ENDRX = (1U << 11);  ///< Enable or disable interrupt for event ENDRX
        constexpr uint32_t ENDTX = (1U << 12);  ///< Enable or disable interrupt for event ENDTX
        constexpr uint32_t AUTOCOLRESSTARTED = (1U << 14);  ///< Enable or disable interrupt for event AUTOCOLRESSTARTED
        constexpr uint32_t COLLISION = (1U << 18);  ///< Enable or disable interrupt for event COLLISION
        constexpr uint32_t SELECTED = (1U << 19);  ///< Enable or disable interrupt for event SELECTED
        constexpr uint32_t STARTED = (1U << 20);  ///< Enable or disable interrupt for event STARTED
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to enable interrupt for event READY
        constexpr uint32_t FIELDDETECTED = (1U << 1);  ///< Write '1' to enable interrupt for event FIELDDETECTED
        constexpr uint32_t FIELDLOST = (1U << 2);  ///< Write '1' to enable interrupt for event FIELDLOST
        constexpr uint32_t TXFRAMESTART = (1U << 3);  ///< Write '1' to enable interrupt for event TXFRAMESTART
        constexpr uint32_t TXFRAMEEND = (1U << 4);  ///< Write '1' to enable interrupt for event TXFRAMEEND
        constexpr uint32_t RXFRAMESTART = (1U << 5);  ///< Write '1' to enable interrupt for event RXFRAMESTART
        constexpr uint32_t RXFRAMEEND = (1U << 6);  ///< Write '1' to enable interrupt for event RXFRAMEEND
        constexpr uint32_t ERROR = (1U << 7);  ///< Write '1' to enable interrupt for event ERROR
        constexpr uint32_t RXERROR = (1U << 10);  ///< Write '1' to enable interrupt for event RXERROR
        constexpr uint32_t ENDRX = (1U << 11);  ///< Write '1' to enable interrupt for event ENDRX
        constexpr uint32_t ENDTX = (1U << 12);  ///< Write '1' to enable interrupt for event ENDTX
        constexpr uint32_t AUTOCOLRESSTARTED = (1U << 14);  ///< Write '1' to enable interrupt for event AUTOCOLRESSTARTED
        constexpr uint32_t COLLISION = (1U << 18);  ///< Write '1' to enable interrupt for event COLLISION
        constexpr uint32_t SELECTED = (1U << 19);  ///< Write '1' to enable interrupt for event SELECTED
        constexpr uint32_t STARTED = (1U << 20);  ///< Write '1' to enable interrupt for event STARTED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to disable interrupt for event READY
        constexpr uint32_t FIELDDETECTED = (1U << 1);  ///< Write '1' to disable interrupt for event FIELDDETECTED
        constexpr uint32_t FIELDLOST = (1U << 2);  ///< Write '1' to disable interrupt for event FIELDLOST
        constexpr uint32_t TXFRAMESTART = (1U << 3);  ///< Write '1' to disable interrupt for event TXFRAMESTART
        constexpr uint32_t TXFRAMEEND = (1U << 4);  ///< Write '1' to disable interrupt for event TXFRAMEEND
        constexpr uint32_t RXFRAMESTART = (1U << 5);  ///< Write '1' to disable interrupt for event RXFRAMESTART
        constexpr uint32_t RXFRAMEEND = (1U << 6);  ///< Write '1' to disable interrupt for event RXFRAMEEND
        constexpr uint32_t ERROR = (1U << 7);  ///< Write '1' to disable interrupt for event ERROR
        constexpr uint32_t RXERROR = (1U << 10);  ///< Write '1' to disable interrupt for event RXERROR
        constexpr uint32_t ENDRX = (1U << 11);  ///< Write '1' to disable interrupt for event ENDRX
        constexpr uint32_t ENDTX = (1U << 12);  ///< Write '1' to disable interrupt for event ENDTX
        constexpr uint32_t AUTOCOLRESSTARTED = (1U << 14);  ///< Write '1' to disable interrupt for event AUTOCOLRESSTARTED
        constexpr uint32_t COLLISION = (1U << 18);  ///< Write '1' to disable interrupt for event COLLISION
        constexpr uint32_t SELECTED = (1U << 19);  ///< Write '1' to disable interrupt for event SELECTED
        constexpr uint32_t STARTED = (1U << 20);  ///< Write '1' to disable interrupt for event STARTED
    }

    /// ERRORSTATUS Register bits
    namespace errorstatus_bits {
        constexpr uint32_t FRAMEDELAYTIMEOUT = (1U << 0);  ///< No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX
    }

    /// RX Register bits
    namespace rx_bits {
        constexpr uint32_t CRCERROR = (1U << 0);  ///< No valid end of frame (EoF) detected
        constexpr uint32_t PARITYSTATUS = (1U << 2);  ///< Parity status of received frame
        constexpr uint32_t OVERRUN = (1U << 3);  ///< Overrun detected
    }

    /// NFCTAGSTATE Register bits
    namespace nfctagstate_bits {
        constexpr uint32_t NFCTAGSTATE = (3 << 0);  ///< NfcTag state
    }

    /// SLEEPSTATE Register bits
    namespace sleepstate_bits {
        constexpr uint32_t SLEEPSTATE = (1U << 0);  ///< Reflects the sleep state during automatic collision resolution. Set to IDLE by a GOIDLE task. Set to SLEEP_A when a valid SLEEP_REQ frame is received or by a GOSLEEP task.
    }

    /// FIELDPRESENT Register bits
    namespace fieldpresent_bits {
        constexpr uint32_t FIELDPRESENT = (1U << 0);  ///< Indicates if a valid field is present. Available only in the activated state.
        constexpr uint32_t LOCKDETECT = (1U << 1);  ///< Indicates if the low level has locked to the field
    }

    /// FRAMEDELAYMIN Register bits
    namespace framedelaymin_bits {
        constexpr uint32_t FRAMEDELAYMIN = (16 << 0);  ///< Minimum frame delay in number of 13.56 MHz clocks
    }

    /// FRAMEDELAYMAX Register bits
    namespace framedelaymax_bits {
        constexpr uint32_t FRAMEDELAYMAX = (20 << 0);  ///< Maximum frame delay in number of 13.56 MHz clocks
    }

    /// FRAMEDELAYMODE Register bits
    namespace framedelaymode_bits {
        constexpr uint32_t FRAMEDELAYMODE = (2 << 0);  ///< Configuration register for the Frame Delay Timer
    }

    /// PACKETPTR Register bits
    namespace packetptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Packet pointer for TXD and RXD data storage in Data RAM. This address is a byte-aligned RAM address.
    }

    /// MAXLEN Register bits
    namespace maxlen_bits {
        constexpr uint32_t MAXLEN = (9 << 0);  ///< Size of the RAM buffer allocated to TXD and RXD data storage each
    }

    /// FRAMECONFIG Register bits
    namespace frameconfig_bits {
        constexpr uint32_t PARITY = (1U << 0);  ///< Indicates if parity expected in RX frame
        constexpr uint32_t SOF = (1U << 2);  ///< SoF expected or not in RX frames
        constexpr uint32_t CRCMODERX = (1U << 4);  ///< CRC mode for incoming frames
    }

    /// AMOUNT Register bits
    namespace amount_bits {
        constexpr uint32_t RXDATABITS = (3 << 0);  ///< Number of bits in the last byte in the frame, if less than 8 (including CRC, but excluding parity and SoF/EoF framing).
        constexpr uint32_t RXDATABYTES = (9 << 3);  ///< Number of complete bytes received in the frame (including CRC, but excluding parity and SoF/EoF framing)
    }

    /// NFCID1_LAST Register bits
    namespace nfcid1_last_bits {
        constexpr uint32_t NFCID1_Z = (8 << 0);  ///< NFCID1 byte Z (very last byte sent)
        constexpr uint32_t NFCID1_Y = (8 << 8);  ///< NFCID1 byte Y
        constexpr uint32_t NFCID1_X = (8 << 16);  ///< NFCID1 byte X
        constexpr uint32_t NFCID1_W = (8 << 24);  ///< NFCID1 byte W
    }

    /// NFCID1_2ND_LAST Register bits
    namespace nfcid1_2nd_last_bits {
        constexpr uint32_t NFCID1_V = (8 << 0);  ///< NFCID1 byte V
        constexpr uint32_t NFCID1_U = (8 << 8);  ///< NFCID1 byte U
        constexpr uint32_t NFCID1_T = (8 << 16);  ///< NFCID1 byte T
    }

    /// NFCID1_3RD_LAST Register bits
    namespace nfcid1_3rd_last_bits {
        constexpr uint32_t NFCID1_S = (8 << 0);  ///< NFCID1 byte S
        constexpr uint32_t NFCID1_R = (8 << 8);  ///< NFCID1 byte R
        constexpr uint32_t NFCID1_Q = (8 << 16);  ///< NFCID1 byte Q
    }

    /// AUTOCOLRESCONFIG Register bits
    namespace autocolresconfig_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< Enables/disables auto collision resolution
    }

    /// SENSRES Register bits
    namespace sensres_bits {
        constexpr uint32_t BITFRAMESDD = (5 << 0);  ///< Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification
        constexpr uint32_t RFU5 = (1U << 5);  ///< Reserved for future use. Shall be 0.
        constexpr uint32_t NFCIDSIZE = (2 << 6);  ///< NFCID1 size. This value is used by the auto collision resolution engine.
        constexpr uint32_t PLATFCONFIG = (4 << 8);  ///< Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification
        constexpr uint32_t RFU74 = (4 << 12);  ///< Reserved for future use. Shall be 0.
    }

    /// SELRES Register bits
    namespace selres_bits {
        constexpr uint32_t RFU10 = (2 << 0);  ///< Reserved for future use. Shall be 0.
        constexpr uint32_t CASCADE = (1U << 2);  ///< Cascade as defined by the b3 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification (controlled by hardware, shall be 0)
        constexpr uint32_t RFU43 = (2 << 3);  ///< Reserved for future use. Shall be 0.
        constexpr uint32_t PROTOCOL = (2 << 5);  ///< Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification
        constexpr uint32_t RFU7 = (1U << 7);  ///< Reserved for future use. Shall be 0.
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOTE_BASE = 0x40006000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t TASKS_OUT__;  ///< Offset: 0x00 - Description collection: Task for writing to pin... (renamed from TASKS_OUT__)
        volatile uint32_t TASKS_SET__;  ///< Offset: 0x30 - Description collection: Task for writing to pin... (renamed from TASKS_SET__)
        volatile uint32_t TASKS_CLR__;  ///< Offset: 0x60 - Description collection: Task for writing to pin... (renamed from TASKS_CLR__)
        volatile uint32_t EVENTS_IN__;  ///< Offset: 0x100 - Description collection: Event generated from pin... (renamed from EVENTS_IN__)
        volatile uint32_t EVENTS_PORT;  ///< Offset: 0x17C - Event generated from multiple input GPIO pins with SENSE...
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t CONFIG__;  ///< Offset: 0x510 - Description collection: Configuration for OUT[n], SET[n]... (renamed from CONFIG__)
    };

    /// Peripheral instances
    inline Registers* GPIOTE = reinterpret_cast<Registers*>(GPIOTE_BASE);

    // Bit definitions
    /// TASKS_OUT__ Register bits
    namespace tasks_out___bits {
        constexpr uint32_t TASKS_OUT = (1U << 0);  ///< Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is configured in CONFIG[n].POLARITY.
    }

    /// TASKS_SET__ Register bits
    namespace tasks_set___bits {
        constexpr uint32_t TASKS_SET = (1U << 0);  ///< Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it high.
    }

    /// TASKS_CLR__ Register bits
    namespace tasks_clr___bits {
        constexpr uint32_t TASKS_CLR = (1U << 0);  ///< Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it low.
    }

    /// EVENTS_IN__ Register bits
    namespace events_in___bits {
        constexpr uint32_t EVENTS_IN = (1U << 0);  ///< Event generated from pin specified in CONFIG[n].PSEL
    }

    /// EVENTS_PORT Register bits
    namespace events_port_bits {
        constexpr uint32_t EVENTS_PORT = (1U << 0);  ///< Event generated from multiple input GPIO pins with SENSE mechanism enabled
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t IN0 = (1U << 0);  ///< Write '1' to enable interrupt for event IN[0]
        constexpr uint32_t IN1 = (1U << 1);  ///< Write '1' to enable interrupt for event IN[1]
        constexpr uint32_t IN2 = (1U << 2);  ///< Write '1' to enable interrupt for event IN[2]
        constexpr uint32_t IN3 = (1U << 3);  ///< Write '1' to enable interrupt for event IN[3]
        constexpr uint32_t IN4 = (1U << 4);  ///< Write '1' to enable interrupt for event IN[4]
        constexpr uint32_t IN5 = (1U << 5);  ///< Write '1' to enable interrupt for event IN[5]
        constexpr uint32_t IN6 = (1U << 6);  ///< Write '1' to enable interrupt for event IN[6]
        constexpr uint32_t IN7 = (1U << 7);  ///< Write '1' to enable interrupt for event IN[7]
        constexpr uint32_t PORT = (1U << 31);  ///< Write '1' to enable interrupt for event PORT
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t IN0 = (1U << 0);  ///< Write '1' to disable interrupt for event IN[0]
        constexpr uint32_t IN1 = (1U << 1);  ///< Write '1' to disable interrupt for event IN[1]
        constexpr uint32_t IN2 = (1U << 2);  ///< Write '1' to disable interrupt for event IN[2]
        constexpr uint32_t IN3 = (1U << 3);  ///< Write '1' to disable interrupt for event IN[3]
        constexpr uint32_t IN4 = (1U << 4);  ///< Write '1' to disable interrupt for event IN[4]
        constexpr uint32_t IN5 = (1U << 5);  ///< Write '1' to disable interrupt for event IN[5]
        constexpr uint32_t IN6 = (1U << 6);  ///< Write '1' to disable interrupt for event IN[6]
        constexpr uint32_t IN7 = (1U << 7);  ///< Write '1' to disable interrupt for event IN[7]
        constexpr uint32_t PORT = (1U << 31);  ///< Write '1' to disable interrupt for event PORT
    }

    /// CONFIG__ Register bits
    namespace config___bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Mode
        constexpr uint32_t PSEL = (5 << 8);  ///< GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event
        constexpr uint32_t PORT = (1U << 13);  ///< Port number
        constexpr uint32_t POLARITY = (2 << 16);  ///< When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event.
        constexpr uint32_t OUTINIT = (1U << 20);  ///< When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect.
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t SAADC_BASE = 0x40007000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Starts the SAADC and prepares the result buffer in RAM
        volatile uint32_t TASKS_SAMPLE;  ///< Offset: 0x04 - Takes one SAADC sample
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x08 - Stops the SAADC and terminates all on-going conversions
        volatile uint32_t TASKS_CALIBRATEOFFSET;  ///< Offset: 0x0C - Starts offset auto-calibration
        volatile uint32_t EVENTS_STARTED;  ///< Offset: 0x100 - The SAADC has started
        volatile uint32_t EVENTS_END;  ///< Offset: 0x104 - The SAADC has filled up the result buffer
        volatile uint32_t EVENTS_DONE;  ///< Offset: 0x108 - A conversion task has been completed. Depending on the...
        volatile uint32_t EVENTS_RESULTDONE;  ///< Offset: 0x10C - Result ready for transfer to RAM
        volatile uint32_t EVENTS_CALIBRATEDONE;  ///< Offset: 0x110 - Calibration is complete
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x114 - The SAADC has stopped
        volatile uint32_t LIMITH;  ///< Offset: 0x00 - Description cluster: Last result is equal or above...
        volatile uint32_t LIMITL;  ///< Offset: 0x04 - Description cluster: Last result is equal or below...
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t STATUS;  ///< Offset: 0x400 - Status
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable or disable SAADC
        volatile uint32_t PSELP;  ///< Offset: 0x00 - Description cluster: Input positive pin selection for CH[n]
        volatile uint32_t PSELN;  ///< Offset: 0x04 - Description cluster: Input negative pin selection for CH[n]
        volatile uint32_t CONFIG;  ///< Offset: 0x08 - Description cluster: Input configuration for CH[n]
        volatile uint32_t LIMIT;  ///< Offset: 0x0C - Description cluster: High/low limits for event...
        volatile uint32_t RESOLUTION;  ///< Offset: 0x5F0 - Resolution configuration
        volatile uint32_t OVERSAMPLE;  ///< Offset: 0x5F4 - Oversampling configuration. The RESOLUTION is applied...
        volatile uint32_t SAMPLERATE;  ///< Offset: 0x5F8 - Controls normal or continuous sample rate
        volatile uint32_t PTR;  ///< Offset: 0x00 - Data pointer
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Maximum number of 16-bit samples to be written to output...
        volatile uint32_t AMOUNT;  ///< Offset: 0x08 - Number of 16-bit samples written to output RAM buffer...
    };

    /// Peripheral instances
    inline Registers* SAADC = reinterpret_cast<Registers*>(SAADC_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Starts the SAADC and prepares the result buffer in RAM
    }

    /// TASKS_SAMPLE Register bits
    namespace tasks_sample_bits {
        constexpr uint32_t TASKS_SAMPLE = (1U << 0);  ///< Takes one SAADC sample
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stops the SAADC and terminates all on-going conversions
    }

    /// TASKS_CALIBRATEOFFSET Register bits
    namespace tasks_calibrateoffset_bits {
        constexpr uint32_t TASKS_CALIBRATEOFFSET = (1U << 0);  ///< Starts offset auto-calibration
    }

    /// EVENTS_STARTED Register bits
    namespace events_started_bits {
        constexpr uint32_t EVENTS_STARTED = (1U << 0);  ///< The SAADC has started
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< The SAADC has filled up the result buffer
    }

    /// EVENTS_DONE Register bits
    namespace events_done_bits {
        constexpr uint32_t EVENTS_DONE = (1U << 0);  ///< A conversion task has been completed. Depending on the configuration, multiple conversions might be needed for a result to be transferred to RAM.
    }

    /// EVENTS_RESULTDONE Register bits
    namespace events_resultdone_bits {
        constexpr uint32_t EVENTS_RESULTDONE = (1U << 0);  ///< Result ready for transfer to RAM
    }

    /// EVENTS_CALIBRATEDONE Register bits
    namespace events_calibratedone_bits {
        constexpr uint32_t EVENTS_CALIBRATEDONE = (1U << 0);  ///< Calibration is complete
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< The SAADC has stopped
    }

    /// LIMITH Register bits
    namespace limith_bits {
        constexpr uint32_t LIMITH = (1U << 0);  ///< Last result is equal or above CH[n].LIMIT.HIGH
    }

    /// LIMITL Register bits
    namespace limitl_bits {
        constexpr uint32_t LIMITL = (1U << 0);  ///< Last result is equal or below CH[n].LIMIT.LOW
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Enable or disable interrupt for event STARTED
        constexpr uint32_t END = (1U << 1);  ///< Enable or disable interrupt for event END
        constexpr uint32_t DONE = (1U << 2);  ///< Enable or disable interrupt for event DONE
        constexpr uint32_t RESULTDONE = (1U << 3);  ///< Enable or disable interrupt for event RESULTDONE
        constexpr uint32_t CALIBRATEDONE = (1U << 4);  ///< Enable or disable interrupt for event CALIBRATEDONE
        constexpr uint32_t STOPPED = (1U << 5);  ///< Enable or disable interrupt for event STOPPED
        constexpr uint32_t CH0LIMITH = (1U << 6);  ///< Enable or disable interrupt for event CH0LIMITH
        constexpr uint32_t CH0LIMITL = (1U << 7);  ///< Enable or disable interrupt for event CH0LIMITL
        constexpr uint32_t CH1LIMITH = (1U << 8);  ///< Enable or disable interrupt for event CH1LIMITH
        constexpr uint32_t CH1LIMITL = (1U << 9);  ///< Enable or disable interrupt for event CH1LIMITL
        constexpr uint32_t CH2LIMITH = (1U << 10);  ///< Enable or disable interrupt for event CH2LIMITH
        constexpr uint32_t CH2LIMITL = (1U << 11);  ///< Enable or disable interrupt for event CH2LIMITL
        constexpr uint32_t CH3LIMITH = (1U << 12);  ///< Enable or disable interrupt for event CH3LIMITH
        constexpr uint32_t CH3LIMITL = (1U << 13);  ///< Enable or disable interrupt for event CH3LIMITL
        constexpr uint32_t CH4LIMITH = (1U << 14);  ///< Enable or disable interrupt for event CH4LIMITH
        constexpr uint32_t CH4LIMITL = (1U << 15);  ///< Enable or disable interrupt for event CH4LIMITL
        constexpr uint32_t CH5LIMITH = (1U << 16);  ///< Enable or disable interrupt for event CH5LIMITH
        constexpr uint32_t CH5LIMITL = (1U << 17);  ///< Enable or disable interrupt for event CH5LIMITL
        constexpr uint32_t CH6LIMITH = (1U << 18);  ///< Enable or disable interrupt for event CH6LIMITH
        constexpr uint32_t CH6LIMITL = (1U << 19);  ///< Enable or disable interrupt for event CH6LIMITL
        constexpr uint32_t CH7LIMITH = (1U << 20);  ///< Enable or disable interrupt for event CH7LIMITH
        constexpr uint32_t CH7LIMITL = (1U << 21);  ///< Enable or disable interrupt for event CH7LIMITL
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Write '1' to enable interrupt for event STARTED
        constexpr uint32_t END = (1U << 1);  ///< Write '1' to enable interrupt for event END
        constexpr uint32_t DONE = (1U << 2);  ///< Write '1' to enable interrupt for event DONE
        constexpr uint32_t RESULTDONE = (1U << 3);  ///< Write '1' to enable interrupt for event RESULTDONE
        constexpr uint32_t CALIBRATEDONE = (1U << 4);  ///< Write '1' to enable interrupt for event CALIBRATEDONE
        constexpr uint32_t STOPPED = (1U << 5);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t CH0LIMITH = (1U << 6);  ///< Write '1' to enable interrupt for event CH0LIMITH
        constexpr uint32_t CH0LIMITL = (1U << 7);  ///< Write '1' to enable interrupt for event CH0LIMITL
        constexpr uint32_t CH1LIMITH = (1U << 8);  ///< Write '1' to enable interrupt for event CH1LIMITH
        constexpr uint32_t CH1LIMITL = (1U << 9);  ///< Write '1' to enable interrupt for event CH1LIMITL
        constexpr uint32_t CH2LIMITH = (1U << 10);  ///< Write '1' to enable interrupt for event CH2LIMITH
        constexpr uint32_t CH2LIMITL = (1U << 11);  ///< Write '1' to enable interrupt for event CH2LIMITL
        constexpr uint32_t CH3LIMITH = (1U << 12);  ///< Write '1' to enable interrupt for event CH3LIMITH
        constexpr uint32_t CH3LIMITL = (1U << 13);  ///< Write '1' to enable interrupt for event CH3LIMITL
        constexpr uint32_t CH4LIMITH = (1U << 14);  ///< Write '1' to enable interrupt for event CH4LIMITH
        constexpr uint32_t CH4LIMITL = (1U << 15);  ///< Write '1' to enable interrupt for event CH4LIMITL
        constexpr uint32_t CH5LIMITH = (1U << 16);  ///< Write '1' to enable interrupt for event CH5LIMITH
        constexpr uint32_t CH5LIMITL = (1U << 17);  ///< Write '1' to enable interrupt for event CH5LIMITL
        constexpr uint32_t CH6LIMITH = (1U << 18);  ///< Write '1' to enable interrupt for event CH6LIMITH
        constexpr uint32_t CH6LIMITL = (1U << 19);  ///< Write '1' to enable interrupt for event CH6LIMITL
        constexpr uint32_t CH7LIMITH = (1U << 20);  ///< Write '1' to enable interrupt for event CH7LIMITH
        constexpr uint32_t CH7LIMITL = (1U << 21);  ///< Write '1' to enable interrupt for event CH7LIMITL
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Write '1' to disable interrupt for event STARTED
        constexpr uint32_t END = (1U << 1);  ///< Write '1' to disable interrupt for event END
        constexpr uint32_t DONE = (1U << 2);  ///< Write '1' to disable interrupt for event DONE
        constexpr uint32_t RESULTDONE = (1U << 3);  ///< Write '1' to disable interrupt for event RESULTDONE
        constexpr uint32_t CALIBRATEDONE = (1U << 4);  ///< Write '1' to disable interrupt for event CALIBRATEDONE
        constexpr uint32_t STOPPED = (1U << 5);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t CH0LIMITH = (1U << 6);  ///< Write '1' to disable interrupt for event CH0LIMITH
        constexpr uint32_t CH0LIMITL = (1U << 7);  ///< Write '1' to disable interrupt for event CH0LIMITL
        constexpr uint32_t CH1LIMITH = (1U << 8);  ///< Write '1' to disable interrupt for event CH1LIMITH
        constexpr uint32_t CH1LIMITL = (1U << 9);  ///< Write '1' to disable interrupt for event CH1LIMITL
        constexpr uint32_t CH2LIMITH = (1U << 10);  ///< Write '1' to disable interrupt for event CH2LIMITH
        constexpr uint32_t CH2LIMITL = (1U << 11);  ///< Write '1' to disable interrupt for event CH2LIMITL
        constexpr uint32_t CH3LIMITH = (1U << 12);  ///< Write '1' to disable interrupt for event CH3LIMITH
        constexpr uint32_t CH3LIMITL = (1U << 13);  ///< Write '1' to disable interrupt for event CH3LIMITL
        constexpr uint32_t CH4LIMITH = (1U << 14);  ///< Write '1' to disable interrupt for event CH4LIMITH
        constexpr uint32_t CH4LIMITL = (1U << 15);  ///< Write '1' to disable interrupt for event CH4LIMITL
        constexpr uint32_t CH5LIMITH = (1U << 16);  ///< Write '1' to disable interrupt for event CH5LIMITH
        constexpr uint32_t CH5LIMITL = (1U << 17);  ///< Write '1' to disable interrupt for event CH5LIMITL
        constexpr uint32_t CH6LIMITH = (1U << 18);  ///< Write '1' to disable interrupt for event CH6LIMITH
        constexpr uint32_t CH6LIMITL = (1U << 19);  ///< Write '1' to disable interrupt for event CH6LIMITL
        constexpr uint32_t CH7LIMITH = (1U << 20);  ///< Write '1' to disable interrupt for event CH7LIMITH
        constexpr uint32_t CH7LIMITL = (1U << 21);  ///< Write '1' to disable interrupt for event CH7LIMITL
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATUS = (1U << 0);  ///< Status
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable SAADC
    }

    /// PSELP Register bits
    namespace pselp_bits {
        constexpr uint32_t PSELP = (5 << 0);  ///< Analog positive input channel
    }

    /// PSELN Register bits
    namespace pseln_bits {
        constexpr uint32_t PSELN = (5 << 0);  ///< Analog negative input, enables differential channel
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t RESP = (2 << 0);  ///< Positive channel resistor control
        constexpr uint32_t RESN = (2 << 4);  ///< Negative channel resistor control
        constexpr uint32_t GAIN = (3 << 8);  ///< Gain control
        constexpr uint32_t REFSEL = (1U << 12);  ///< Reference control
        constexpr uint32_t TACQ = (3 << 16);  ///< Acquisition time, the time the SAADC uses to sample the input voltage
        constexpr uint32_t MODE = (1U << 20);  ///< Enable differential mode
        constexpr uint32_t BURST = (1U << 24);  ///< Enable burst mode
    }

    /// LIMIT Register bits
    namespace limit_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low level limit
        constexpr uint32_t HIGH = (16 << 16);  ///< High level limit
    }

    /// RESOLUTION Register bits
    namespace resolution_bits {
        constexpr uint32_t VAL = (3 << 0);  ///< Set the resolution
    }

    /// OVERSAMPLE Register bits
    namespace oversample_bits {
        constexpr uint32_t OVERSAMPLE = (4 << 0);  ///< Oversample control
    }

    /// SAMPLERATE Register bits
    namespace samplerate_bits {
        constexpr uint32_t CC = (11 << 0);  ///< Capture and compare value. Sample rate is 16 MHz/CC
        constexpr uint32_t MODE = (1U << 12);  ///< Select mode for sample rate control
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Data pointer
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t MAXCNT = (15 << 0);  ///< Maximum number of 16-bit samples to be written to output RAM buffer
    }

    /// AMOUNT Register bits
    namespace amount_bits {
        constexpr uint32_t AMOUNT = (15 << 0);  ///< Number of 16-bit samples written to output RAM buffer since the previous START task. This register can be read after an END or STOPPED event.
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER0_BASE = 0x40008000;
    constexpr uint32_t TIMER1_BASE = 0x40009000;
    constexpr uint32_t TIMER2_BASE = 0x4000A000;
    constexpr uint32_t TIMER3_BASE = 0x4001A000;
    constexpr uint32_t TIMER4_BASE = 0x4001B000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start Timer
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop Timer
        volatile uint32_t TASKS_COUNT;  ///< Offset: 0x08 - Increment Timer (Counter mode only)
        volatile uint32_t TASKS_CLEAR;  ///< Offset: 0x0C - Clear time
        volatile uint32_t TASKS_SHUTDOWN;  ///< Offset: 0x10 - Deprecated register - Shut down timer
        volatile uint32_t TASKS_CAPTURE__;  ///< Offset: 0x40 - Description collection: Capture Timer value to CC[n] register (renamed from TASKS_CAPTURE__)
        volatile uint32_t EVENTS_COMPARE__;  ///< Offset: 0x140 - Description collection: Compare event on CC[n] match (renamed from EVENTS_COMPARE__)
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t MODE;  ///< Offset: 0x504 - Timer mode selection
        volatile uint32_t BITMODE;  ///< Offset: 0x508 - Configure the number of bits used by the TIMER
        volatile uint32_t PRESCALER;  ///< Offset: 0x510 - Timer prescaler register
        volatile uint32_t CC__;  ///< Offset: 0x540 - Description collection: Capture/Compare register n (renamed from CC__)
    };

    /// Peripheral instances
    inline Registers* TIMER0 = reinterpret_cast<Registers*>(TIMER0_BASE);
    inline Registers* TIMER1 = reinterpret_cast<Registers*>(TIMER1_BASE);
    inline Registers* TIMER2 = reinterpret_cast<Registers*>(TIMER2_BASE);
    inline Registers* TIMER3 = reinterpret_cast<Registers*>(TIMER3_BASE);
    inline Registers* TIMER4 = reinterpret_cast<Registers*>(TIMER4_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start Timer
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop Timer
    }

    /// TASKS_COUNT Register bits
    namespace tasks_count_bits {
        constexpr uint32_t TASKS_COUNT = (1U << 0);  ///< Increment Timer (Counter mode only)
    }

    /// TASKS_CLEAR Register bits
    namespace tasks_clear_bits {
        constexpr uint32_t TASKS_CLEAR = (1U << 0);  ///< Clear time
    }

    /// TASKS_SHUTDOWN Register bits
    namespace tasks_shutdown_bits {
        constexpr uint32_t TASKS_SHUTDOWN = (1U << 0);  ///< Deprecated field - Shut down timer
    }

    /// TASKS_CAPTURE__ Register bits
    namespace tasks_capture___bits {
        constexpr uint32_t TASKS_CAPTURE = (1U << 0);  ///< Capture Timer value to CC[n] register
    }

    /// EVENTS_COMPARE__ Register bits
    namespace events_compare___bits {
        constexpr uint32_t EVENTS_COMPARE = (1U << 0);  ///< Compare event on CC[n] match
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t COMPARE0_CLEAR = (1U << 0);  ///< Shortcut between event COMPARE[0] and task CLEAR
        constexpr uint32_t COMPARE1_CLEAR = (1U << 1);  ///< Shortcut between event COMPARE[1] and task CLEAR
        constexpr uint32_t COMPARE2_CLEAR = (1U << 2);  ///< Shortcut between event COMPARE[2] and task CLEAR
        constexpr uint32_t COMPARE3_CLEAR = (1U << 3);  ///< Shortcut between event COMPARE[3] and task CLEAR
        constexpr uint32_t COMPARE4_CLEAR = (1U << 4);  ///< Shortcut between event COMPARE[4] and task CLEAR
        constexpr uint32_t COMPARE5_CLEAR = (1U << 5);  ///< Shortcut between event COMPARE[5] and task CLEAR
        constexpr uint32_t COMPARE0_STOP = (1U << 8);  ///< Shortcut between event COMPARE[0] and task STOP
        constexpr uint32_t COMPARE1_STOP = (1U << 9);  ///< Shortcut between event COMPARE[1] and task STOP
        constexpr uint32_t COMPARE2_STOP = (1U << 10);  ///< Shortcut between event COMPARE[2] and task STOP
        constexpr uint32_t COMPARE3_STOP = (1U << 11);  ///< Shortcut between event COMPARE[3] and task STOP
        constexpr uint32_t COMPARE4_STOP = (1U << 12);  ///< Shortcut between event COMPARE[4] and task STOP
        constexpr uint32_t COMPARE5_STOP = (1U << 13);  ///< Shortcut between event COMPARE[5] and task STOP
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to enable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to enable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to enable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to enable interrupt for event COMPARE[3]
        constexpr uint32_t COMPARE4 = (1U << 20);  ///< Write '1' to enable interrupt for event COMPARE[4]
        constexpr uint32_t COMPARE5 = (1U << 21);  ///< Write '1' to enable interrupt for event COMPARE[5]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to disable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to disable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to disable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to disable interrupt for event COMPARE[3]
        constexpr uint32_t COMPARE4 = (1U << 20);  ///< Write '1' to disable interrupt for event COMPARE[4]
        constexpr uint32_t COMPARE5 = (1U << 21);  ///< Write '1' to disable interrupt for event COMPARE[5]
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Timer mode
    }

    /// BITMODE Register bits
    namespace bitmode_bits {
        constexpr uint32_t BITMODE = (2 << 0);  ///< Timer bit width
    }

    /// PRESCALER Register bits
    namespace prescaler_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< Prescaler value
    }

    /// CC__ Register bits
    namespace cc___bits {
        constexpr uint32_t CC = (32 << 0);  ///< Capture/Compare value
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC0_BASE = 0x4000B000;
    constexpr uint32_t RTC1_BASE = 0x40011000;
    constexpr uint32_t RTC2_BASE = 0x40024000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start RTC COUNTER
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop RTC COUNTER
        volatile uint32_t TASKS_CLEAR;  ///< Offset: 0x08 - Clear RTC COUNTER
        volatile uint32_t TASKS_TRIGOVRFLW;  ///< Offset: 0x0C - Set COUNTER to 0xFFFFF0
        volatile uint32_t EVENTS_TICK;  ///< Offset: 0x100 - Event on COUNTER increment
        volatile uint32_t EVENTS_OVRFLW;  ///< Offset: 0x104 - Event on COUNTER overflow
        volatile uint32_t EVENTS_COMPARE__;  ///< Offset: 0x140 - Description collection: Compare event on CC[n] match (renamed from EVENTS_COMPARE__)
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t EVTEN;  ///< Offset: 0x340 - Enable or disable event routing
        volatile uint32_t EVTENSET;  ///< Offset: 0x344 - Enable event routing
        volatile uint32_t EVTENCLR;  ///< Offset: 0x348 - Disable event routing
        volatile uint32_t COUNTER;  ///< Offset: 0x504 - Current COUNTER value
        volatile uint32_t PRESCALER;  ///< Offset: 0x508 - 12 bit prescaler for COUNTER frequency...
        volatile uint32_t CC__;  ///< Offset: 0x540 - Description collection: Compare register n (renamed from CC__)
    };

    /// Peripheral instances
    inline Registers* RTC0 = reinterpret_cast<Registers*>(RTC0_BASE);
    inline Registers* RTC1 = reinterpret_cast<Registers*>(RTC1_BASE);
    inline Registers* RTC2 = reinterpret_cast<Registers*>(RTC2_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start RTC COUNTER
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop RTC COUNTER
    }

    /// TASKS_CLEAR Register bits
    namespace tasks_clear_bits {
        constexpr uint32_t TASKS_CLEAR = (1U << 0);  ///< Clear RTC COUNTER
    }

    /// TASKS_TRIGOVRFLW Register bits
    namespace tasks_trigovrflw_bits {
        constexpr uint32_t TASKS_TRIGOVRFLW = (1U << 0);  ///< Set COUNTER to 0xFFFFF0
    }

    /// EVENTS_TICK Register bits
    namespace events_tick_bits {
        constexpr uint32_t EVENTS_TICK = (1U << 0);  ///< Event on COUNTER increment
    }

    /// EVENTS_OVRFLW Register bits
    namespace events_ovrflw_bits {
        constexpr uint32_t EVENTS_OVRFLW = (1U << 0);  ///< Event on COUNTER overflow
    }

    /// EVENTS_COMPARE__ Register bits
    namespace events_compare___bits {
        constexpr uint32_t EVENTS_COMPARE = (1U << 0);  ///< Compare event on CC[n] match
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to enable interrupt for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to enable interrupt for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to enable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to enable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to enable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to enable interrupt for event COMPARE[3]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to disable interrupt for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to disable interrupt for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to disable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to disable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to disable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to disable interrupt for event COMPARE[3]
    }

    /// EVTEN Register bits
    namespace evten_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Enable or disable event routing for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Enable or disable event routing for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Enable or disable event routing for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Enable or disable event routing for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Enable or disable event routing for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Enable or disable event routing for event COMPARE[3]
    }

    /// EVTENSET Register bits
    namespace evtenset_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to enable event routing for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to enable event routing for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to enable event routing for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to enable event routing for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to enable event routing for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to enable event routing for event COMPARE[3]
    }

    /// EVTENCLR Register bits
    namespace evtenclr_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to disable event routing for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to disable event routing for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to disable event routing for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to disable event routing for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to disable event routing for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to disable event routing for event COMPARE[3]
    }

    /// COUNTER Register bits
    namespace counter_bits {
        constexpr uint32_t COUNTER = (24 << 0);  ///< Counter value
    }

    /// PRESCALER Register bits
    namespace prescaler_bits {
        constexpr uint32_t PRESCALER = (12 << 0);  ///< Prescaler value
    }

    /// CC__ Register bits
    namespace cc___bits {
        constexpr uint32_t COMPARE = (24 << 0);  ///< Compare value
    }

}

// ============================================================================
// TEMP Peripheral
// ============================================================================

namespace temp {
    /// Base addresses
    constexpr uint32_t TEMP_BASE = 0x4000C000;

    /// TEMP Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start temperature measurement
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop temperature measurement
        volatile uint32_t EVENTS_DATARDY;  ///< Offset: 0x100 - Temperature measurement complete, data ready
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t TEMP;  ///< Offset: 0x508 - Temperature in degC (0.25deg steps)
        volatile uint32_t A0;  ///< Offset: 0x520 - Slope of 1st piece wise linear function
        volatile uint32_t A1;  ///< Offset: 0x524 - Slope of 2nd piece wise linear function
        volatile uint32_t A2;  ///< Offset: 0x528 - Slope of 3rd piece wise linear function
        volatile uint32_t A3;  ///< Offset: 0x52C - Slope of 4th piece wise linear function
        volatile uint32_t A4;  ///< Offset: 0x530 - Slope of 5th piece wise linear function
        volatile uint32_t A5;  ///< Offset: 0x534 - Slope of 6th piece wise linear function
        volatile uint32_t B0;  ///< Offset: 0x540 - y-intercept of 1st piece wise linear function
        volatile uint32_t B1;  ///< Offset: 0x544 - y-intercept of 2nd piece wise linear function
        volatile uint32_t B2;  ///< Offset: 0x548 - y-intercept of 3rd piece wise linear function
        volatile uint32_t B3;  ///< Offset: 0x54C - y-intercept of 4th piece wise linear function
        volatile uint32_t B4;  ///< Offset: 0x550 - y-intercept of 5th piece wise linear function
        volatile uint32_t B5;  ///< Offset: 0x554 - y-intercept of 6th piece wise linear function
        volatile uint32_t T0;  ///< Offset: 0x560 - End point of 1st piece wise linear function
        volatile uint32_t T1;  ///< Offset: 0x564 - End point of 2nd piece wise linear function
        volatile uint32_t T2;  ///< Offset: 0x568 - End point of 3rd piece wise linear function
        volatile uint32_t T3;  ///< Offset: 0x56C - End point of 4th piece wise linear function
        volatile uint32_t T4;  ///< Offset: 0x570 - End point of 5th piece wise linear function
    };

    /// Peripheral instances
    inline Registers* TEMP = reinterpret_cast<Registers*>(TEMP_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start temperature measurement
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop temperature measurement
    }

    /// EVENTS_DATARDY Register bits
    namespace events_datardy_bits {
        constexpr uint32_t EVENTS_DATARDY = (1U << 0);  ///< Temperature measurement complete, data ready
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Write '1' to enable interrupt for event DATARDY
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Write '1' to disable interrupt for event DATARDY
    }

    /// TEMP Register bits
    namespace temp_bits {
        constexpr uint32_t TEMP = (32 << 0);  ///< Temperature in degC (0.25deg steps)
    }

    /// A0 Register bits
    namespace a0_bits {
        constexpr uint32_t A0 = (12 << 0);  ///< Slope of 1st piece wise linear function
    }

    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t A1 = (12 << 0);  ///< Slope of 2nd piece wise linear function
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t A2 = (12 << 0);  ///< Slope of 3rd piece wise linear function
    }

    /// A3 Register bits
    namespace a3_bits {
        constexpr uint32_t A3 = (12 << 0);  ///< Slope of 4th piece wise linear function
    }

    /// A4 Register bits
    namespace a4_bits {
        constexpr uint32_t A4 = (12 << 0);  ///< Slope of 5th piece wise linear function
    }

    /// A5 Register bits
    namespace a5_bits {
        constexpr uint32_t A5 = (12 << 0);  ///< Slope of 6th piece wise linear function
    }

    /// B0 Register bits
    namespace b0_bits {
        constexpr uint32_t B0 = (14 << 0);  ///< y-intercept of 1st piece wise linear function
    }

    /// B1 Register bits
    namespace b1_bits {
        constexpr uint32_t B1 = (14 << 0);  ///< y-intercept of 2nd piece wise linear function
    }

    /// B2 Register bits
    namespace b2_bits {
        constexpr uint32_t B2 = (14 << 0);  ///< y-intercept of 3rd piece wise linear function
    }

    /// B3 Register bits
    namespace b3_bits {
        constexpr uint32_t B3 = (14 << 0);  ///< y-intercept of 4th piece wise linear function
    }

    /// B4 Register bits
    namespace b4_bits {
        constexpr uint32_t B4 = (14 << 0);  ///< y-intercept of 5th piece wise linear function
    }

    /// B5 Register bits
    namespace b5_bits {
        constexpr uint32_t B5 = (14 << 0);  ///< y-intercept of 6th piece wise linear function
    }

    /// T0 Register bits
    namespace t0_bits {
        constexpr uint32_t T0 = (8 << 0);  ///< End point of 1st piece wise linear function
    }

    /// T1 Register bits
    namespace t1_bits {
        constexpr uint32_t T1 = (8 << 0);  ///< End point of 2nd piece wise linear function
    }

    /// T2 Register bits
    namespace t2_bits {
        constexpr uint32_t T2 = (8 << 0);  ///< End point of 3rd piece wise linear function
    }

    /// T3 Register bits
    namespace t3_bits {
        constexpr uint32_t T3 = (8 << 0);  ///< End point of 4th piece wise linear function
    }

    /// T4 Register bits
    namespace t4_bits {
        constexpr uint32_t T4 = (8 << 0);  ///< End point of 5th piece wise linear function
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x4000D000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Task starting the random number generator
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Task stopping the random number generator
        volatile uint32_t EVENTS_VALRDY;  ///< Offset: 0x100 - Event being generated for every new random number...
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t CONFIG;  ///< Offset: 0x504 - Configuration register
        volatile uint32_t VALUE;  ///< Offset: 0x508 - Output random number
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Task starting the random number generator
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Task stopping the random number generator
    }

    /// EVENTS_VALRDY Register bits
    namespace events_valrdy_bits {
        constexpr uint32_t EVENTS_VALRDY = (1U << 0);  ///< Event being generated for every new random number written to the VALUE register
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t VALRDY_STOP = (1U << 0);  ///< Shortcut between event VALRDY and task STOP
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t VALRDY = (1U << 0);  ///< Write '1' to enable interrupt for event VALRDY
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t VALRDY = (1U << 0);  ///< Write '1' to disable interrupt for event VALRDY
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t DERCEN = (1U << 0);  ///< Bias correction
    }

    /// VALUE Register bits
    namespace value_bits {
        constexpr uint32_t VALUE = (8 << 0);  ///< Generated random number
    }

}

// ============================================================================
// ECB Peripheral
// ============================================================================

namespace ecb {
    /// Base addresses
    constexpr uint32_t ECB_BASE = 0x4000E000;

    /// ECB Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTECB;  ///< Offset: 0x00 - Start ECB block encrypt
        volatile uint32_t TASKS_STOPECB;  ///< Offset: 0x04 - Abort a possible executing ECB operation
        volatile uint32_t EVENTS_ENDECB;  ///< Offset: 0x100 - ECB block encrypt complete
        volatile uint32_t EVENTS_ERRORECB;  ///< Offset: 0x104 - ECB block encrypt aborted because of a STOPECB task or...
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ECBDATAPTR;  ///< Offset: 0x504 - ECB block encrypt memory pointers
    };

    /// Peripheral instances
    inline Registers* ECB = reinterpret_cast<Registers*>(ECB_BASE);

    // Bit definitions
    /// TASKS_STARTECB Register bits
    namespace tasks_startecb_bits {
        constexpr uint32_t TASKS_STARTECB = (1U << 0);  ///< Start ECB block encrypt
    }

    /// TASKS_STOPECB Register bits
    namespace tasks_stopecb_bits {
        constexpr uint32_t TASKS_STOPECB = (1U << 0);  ///< Abort a possible executing ECB operation
    }

    /// EVENTS_ENDECB Register bits
    namespace events_endecb_bits {
        constexpr uint32_t EVENTS_ENDECB = (1U << 0);  ///< ECB block encrypt complete
    }

    /// EVENTS_ERRORECB Register bits
    namespace events_errorecb_bits {
        constexpr uint32_t EVENTS_ERRORECB = (1U << 0);  ///< ECB block encrypt aborted because of a STOPECB task or due to an error
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t ENDECB = (1U << 0);  ///< Write '1' to enable interrupt for event ENDECB
        constexpr uint32_t ERRORECB = (1U << 1);  ///< Write '1' to enable interrupt for event ERRORECB
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t ENDECB = (1U << 0);  ///< Write '1' to disable interrupt for event ENDECB
        constexpr uint32_t ERRORECB = (1U << 1);  ///< Write '1' to disable interrupt for event ERRORECB
    }

    /// ECBDATAPTR Register bits
    namespace ecbdataptr_bits {
        constexpr uint32_t ECBDATAPTR = (32 << 0);  ///< Pointer to the ECB data structure (see Table 1 ECB data structure overview)
    }

}

// ============================================================================
// AAR Peripheral
// ============================================================================

namespace aar {
    /// Base addresses
    constexpr uint32_t AAR_BASE = 0x4000F000;

    /// AAR Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start resolving addresses based on IRKs specified in the...
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x08 - Stop resolving addresses
        volatile uint32_t EVENTS_END;  ///< Offset: 0x100 - Address resolution procedure complete
        volatile uint32_t EVENTS_RESOLVED;  ///< Offset: 0x104 - Address resolved
        volatile uint32_t EVENTS_NOTRESOLVED;  ///< Offset: 0x108 - Address not resolved
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t STATUS;  ///< Offset: 0x400 - Resolution status
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable AAR
        volatile uint32_t NIRK;  ///< Offset: 0x504 - Number of IRKs
        volatile uint32_t IRKPTR;  ///< Offset: 0x508 - Pointer to IRK data structure
        volatile uint32_t ADDRPTR;  ///< Offset: 0x510 - Pointer to the resolvable address
        volatile uint32_t SCRATCHPTR;  ///< Offset: 0x514 - Pointer to data area used for temporary storage
    };

    /// Peripheral instances
    inline Registers* AAR = reinterpret_cast<Registers*>(AAR_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start resolving addresses based on IRKs specified in the IRK data structure
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop resolving addresses
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< Address resolution procedure complete
    }

    /// EVENTS_RESOLVED Register bits
    namespace events_resolved_bits {
        constexpr uint32_t EVENTS_RESOLVED = (1U << 0);  ///< Address resolved
    }

    /// EVENTS_NOTRESOLVED Register bits
    namespace events_notresolved_bits {
        constexpr uint32_t EVENTS_NOTRESOLVED = (1U << 0);  ///< Address not resolved
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t END = (1U << 0);  ///< Write '1' to enable interrupt for event END
        constexpr uint32_t RESOLVED = (1U << 1);  ///< Write '1' to enable interrupt for event RESOLVED
        constexpr uint32_t NOTRESOLVED = (1U << 2);  ///< Write '1' to enable interrupt for event NOTRESOLVED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t END = (1U << 0);  ///< Write '1' to disable interrupt for event END
        constexpr uint32_t RESOLVED = (1U << 1);  ///< Write '1' to disable interrupt for event RESOLVED
        constexpr uint32_t NOTRESOLVED = (1U << 2);  ///< Write '1' to disable interrupt for event NOTRESOLVED
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATUS = (4 << 0);  ///< The IRK that was used last time an address was resolved
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (2 << 0);  ///< Enable or disable AAR
    }

    /// NIRK Register bits
    namespace nirk_bits {
        constexpr uint32_t NIRK = (5 << 0);  ///< Number of Identity root keys available in the IRK data structure
    }

    /// IRKPTR Register bits
    namespace irkptr_bits {
        constexpr uint32_t IRKPTR = (32 << 0);  ///< Pointer to the IRK data structure
    }

    /// ADDRPTR Register bits
    namespace addrptr_bits {
        constexpr uint32_t ADDRPTR = (32 << 0);  ///< Pointer to the resolvable address (6-bytes)
    }

    /// SCRATCHPTR Register bits
    namespace scratchptr_bits {
        constexpr uint32_t SCRATCHPTR = (32 << 0);  ///< Pointer to a scratch data area used for temporary storage during resolution. A space of minimum 3 bytes must be reserved.
    }

}

// ============================================================================
// CCM Peripheral
// ============================================================================

namespace ccm {
    /// Base addresses
    constexpr uint32_t CCM_BASE = 0x4000F000;

    /// CCM Register structure
    struct Registers {
        volatile uint32_t TASKS_KSGEN;  ///< Offset: 0x00 - Start generation of key-stream. This operation will stop...
        volatile uint32_t TASKS_CRYPT;  ///< Offset: 0x04 - Start encryption/decryption. This operation will stop by...
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x08 - Stop encryption/decryption
        volatile uint32_t TASKS_RATEOVERRIDE;  ///< Offset: 0x0C - Override DATARATE setting in MODE register with the...
        volatile uint32_t EVENTS_ENDKSGEN;  ///< Offset: 0x100 - Key-stream generation complete
        volatile uint32_t EVENTS_ENDCRYPT;  ///< Offset: 0x104 - Encrypt/decrypt complete
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x108 - Deprecated register - CCM error event
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t MICSTATUS;  ///< Offset: 0x400 - MIC check result
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable
        volatile uint32_t MODE;  ///< Offset: 0x504 - Operation mode
        volatile uint32_t CNFPTR;  ///< Offset: 0x508 - Pointer to data structure holding AES key and NONCE vector
        volatile uint32_t INPTR;  ///< Offset: 0x50C - Input pointer
        volatile uint32_t OUTPTR;  ///< Offset: 0x510 - Output pointer
        volatile uint32_t SCRATCHPTR;  ///< Offset: 0x514 - Pointer to data area used for temporary storage
        volatile uint32_t MAXPACKETSIZE;  ///< Offset: 0x518 - Length of key-stream generated when MODE.LENGTH = Extended.
        volatile uint32_t RATEOVERRIDE;  ///< Offset: 0x51C - Data rate override setting.
    };

    /// Peripheral instances
    inline Registers* CCM = reinterpret_cast<Registers*>(CCM_BASE);

    // Bit definitions
    /// TASKS_KSGEN Register bits
    namespace tasks_ksgen_bits {
        constexpr uint32_t TASKS_KSGEN = (1U << 0);  ///< Start generation of key-stream. This operation will stop by itself when completed.
    }

    /// TASKS_CRYPT Register bits
    namespace tasks_crypt_bits {
        constexpr uint32_t TASKS_CRYPT = (1U << 0);  ///< Start encryption/decryption. This operation will stop by itself when completed.
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop encryption/decryption
    }

    /// TASKS_RATEOVERRIDE Register bits
    namespace tasks_rateoverride_bits {
        constexpr uint32_t TASKS_RATEOVERRIDE = (1U << 0);  ///< Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption
    }

    /// EVENTS_ENDKSGEN Register bits
    namespace events_endksgen_bits {
        constexpr uint32_t EVENTS_ENDKSGEN = (1U << 0);  ///< Key-stream generation complete
    }

    /// EVENTS_ENDCRYPT Register bits
    namespace events_endcrypt_bits {
        constexpr uint32_t EVENTS_ENDCRYPT = (1U << 0);  ///< Encrypt/decrypt complete
    }

    /// EVENTS_ERROR Register bits
    namespace events_error_bits {
        constexpr uint32_t EVENTS_ERROR = (1U << 0);  ///< Deprecated field - CCM error event
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t ENDKSGEN_CRYPT = (1U << 0);  ///< Shortcut between event ENDKSGEN and task CRYPT
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t ENDKSGEN = (1U << 0);  ///< Write '1' to enable interrupt for event ENDKSGEN
        constexpr uint32_t ENDCRYPT = (1U << 1);  ///< Write '1' to enable interrupt for event ENDCRYPT
        constexpr uint32_t ERROR = (1U << 2);  ///< Deprecated intsetfield - Write '1' to enable interrupt for event ERROR
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t ENDKSGEN = (1U << 0);  ///< Write '1' to disable interrupt for event ENDKSGEN
        constexpr uint32_t ENDCRYPT = (1U << 1);  ///< Write '1' to disable interrupt for event ENDCRYPT
        constexpr uint32_t ERROR = (1U << 2);  ///< Deprecated intclrfield - Write '1' to disable interrupt for event ERROR
    }

    /// MICSTATUS Register bits
    namespace micstatus_bits {
        constexpr uint32_t MICSTATUS = (1U << 0);  ///< The result of the MIC check performed during the previous decryption operation
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (2 << 0);  ///< Enable or disable CCM
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< The mode of operation to be used. The settings in this register apply whenever either the KSGEN or CRYPT tasks are triggered.
        constexpr uint32_t DATARATE = (2 << 16);  ///< Radio data rate that the CCM shall run synchronous with
        constexpr uint32_t LENGTH = (1U << 24);  ///< Packet length configuration
    }

    /// CNFPTR Register bits
    namespace cnfptr_bits {
        constexpr uint32_t CNFPTR = (32 << 0);  ///< Pointer to the data structure holding the AES key and the CCM NONCE vector (see Table 1 CCM data structure overview)
    }

    /// INPTR Register bits
    namespace inptr_bits {
        constexpr uint32_t INPTR = (32 << 0);  ///< Input pointer
    }

    /// OUTPTR Register bits
    namespace outptr_bits {
        constexpr uint32_t OUTPTR = (32 << 0);  ///< Output pointer
    }

    /// SCRATCHPTR Register bits
    namespace scratchptr_bits {
        constexpr uint32_t SCRATCHPTR = (32 << 0);  ///< Pointer to a scratch data area used for temporary storage during key-stream generation, MIC generation and encryption/decryption.
    }

    /// MAXPACKETSIZE Register bits
    namespace maxpacketsize_bits {
        constexpr uint32_t MAXPACKETSIZE = (8 << 0);  ///< Length of key-stream generated when MODE.LENGTH = Extended. This value must be greater or equal to the subsequent packet payload to be encrypted/decrypted.
    }

    /// RATEOVERRIDE Register bits
    namespace rateoverride_bits {
        constexpr uint32_t RATEOVERRIDE = (2 << 0);  ///< Data rate override setting.
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40010000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start the watchdog
        volatile uint32_t EVENTS_TIMEOUT;  ///< Offset: 0x100 - Watchdog timeout
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t RUNSTATUS;  ///< Offset: 0x400 - Run status
        volatile uint32_t REQSTATUS;  ///< Offset: 0x404 - Request status
        volatile uint32_t CRV;  ///< Offset: 0x504 - Counter reload value
        volatile uint32_t RREN;  ///< Offset: 0x508 - Enable register for reload request registers
        volatile uint32_t CONFIG;  ///< Offset: 0x50C - Configuration register
        volatile uint32_t RR__;  ///< Offset: 0x600 - Description collection: Reload request n (renamed from RR__)
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start the watchdog
    }

    /// EVENTS_TIMEOUT Register bits
    namespace events_timeout_bits {
        constexpr uint32_t EVENTS_TIMEOUT = (1U << 0);  ///< Watchdog timeout
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TIMEOUT = (1U << 0);  ///< Write '1' to enable interrupt for event TIMEOUT
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TIMEOUT = (1U << 0);  ///< Write '1' to disable interrupt for event TIMEOUT
    }

    /// RUNSTATUS Register bits
    namespace runstatus_bits {
        constexpr uint32_t RUNSTATUS = (1U << 0);  ///< Indicates whether or not the watchdog is running
    }

    /// REQSTATUS Register bits
    namespace reqstatus_bits {
        constexpr uint32_t RR0 = (1U << 0);  ///< Request status for RR[0] register
        constexpr uint32_t RR1 = (1U << 1);  ///< Request status for RR[1] register
        constexpr uint32_t RR2 = (1U << 2);  ///< Request status for RR[2] register
        constexpr uint32_t RR3 = (1U << 3);  ///< Request status for RR[3] register
        constexpr uint32_t RR4 = (1U << 4);  ///< Request status for RR[4] register
        constexpr uint32_t RR5 = (1U << 5);  ///< Request status for RR[5] register
        constexpr uint32_t RR6 = (1U << 6);  ///< Request status for RR[6] register
        constexpr uint32_t RR7 = (1U << 7);  ///< Request status for RR[7] register
    }

    /// CRV Register bits
    namespace crv_bits {
        constexpr uint32_t CRV = (32 << 0);  ///< Counter reload value in number of cycles of the 32.768 kHz clock
    }

    /// RREN Register bits
    namespace rren_bits {
        constexpr uint32_t RR0 = (1U << 0);  ///< Enable or disable RR[0] register
        constexpr uint32_t RR1 = (1U << 1);  ///< Enable or disable RR[1] register
        constexpr uint32_t RR2 = (1U << 2);  ///< Enable or disable RR[2] register
        constexpr uint32_t RR3 = (1U << 3);  ///< Enable or disable RR[3] register
        constexpr uint32_t RR4 = (1U << 4);  ///< Enable or disable RR[4] register
        constexpr uint32_t RR5 = (1U << 5);  ///< Enable or disable RR[5] register
        constexpr uint32_t RR6 = (1U << 6);  ///< Enable or disable RR[6] register
        constexpr uint32_t RR7 = (1U << 7);  ///< Enable or disable RR[7] register
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t SLEEP = (1U << 0);  ///< Configure the watchdog to either be paused, or kept running, while the CPU is sleeping
        constexpr uint32_t HALT = (1U << 3);  ///< Configure the watchdog to either be paused, or kept running, while the CPU is halted by the debugger
    }

    /// RR__ Register bits
    namespace rr___bits {
        constexpr uint32_t RR = (32 << 0);  ///< Reload request register
    }

}

// ============================================================================
// QDEC Peripheral
// ============================================================================

namespace qdec {
    /// Base addresses
    constexpr uint32_t QDEC_BASE = 0x40012000;

    /// QDEC Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Task starting the quadrature decoder
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Task stopping the quadrature decoder
        volatile uint32_t TASKS_READCLRACC;  ///< Offset: 0x08 - Read and clear ACC and ACCDBL
        volatile uint32_t TASKS_RDCLRACC;  ///< Offset: 0x0C - Read and clear ACC
        volatile uint32_t TASKS_RDCLRDBL;  ///< Offset: 0x10 - Read and clear ACCDBL
        volatile uint32_t EVENTS_SAMPLERDY;  ///< Offset: 0x100 - Event being generated for every new sample value written...
        volatile uint32_t EVENTS_REPORTRDY;  ///< Offset: 0x104 - Non-null report ready
        volatile uint32_t EVENTS_ACCOF;  ///< Offset: 0x108 - ACC or ACCDBL register overflow
        volatile uint32_t EVENTS_DBLRDY;  ///< Offset: 0x10C - Double displacement(s) detected
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x110 - QDEC has been stopped
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable the quadrature decoder
        volatile uint32_t LEDPOL;  ///< Offset: 0x504 - LED output pin polarity
        volatile uint32_t SAMPLEPER;  ///< Offset: 0x508 - Sample period
        volatile uint32_t SAMPLE;  ///< Offset: 0x50C - Motion sample value
        volatile uint32_t REPORTPER;  ///< Offset: 0x510 - Number of samples to be taken before REPORTRDY and...
        volatile uint32_t ACC;  ///< Offset: 0x514 - Register accumulating the valid transitions
        volatile uint32_t ACCREAD;  ///< Offset: 0x518 - Snapshot of the ACC register, updated by the READCLRACC...
        volatile uint32_t LED;  ///< Offset: 0x00 - Pin select for LED signal
        volatile uint32_t A;  ///< Offset: 0x04 - Pin select for A signal
        volatile uint32_t B;  ///< Offset: 0x08 - Pin select for B signal
        volatile uint32_t DBFEN;  ///< Offset: 0x528 - Enable input debounce filters
        volatile uint32_t LEDPRE;  ///< Offset: 0x540 - Time period the LED is switched ON prior to sampling
        volatile uint32_t ACCDBL;  ///< Offset: 0x544 - Register accumulating the number of detected double transitions
        volatile uint32_t ACCDBLREAD;  ///< Offset: 0x548 - Snapshot of the ACCDBL, updated by the READCLRACC or...
    };

    /// Peripheral instances
    inline Registers* QDEC = reinterpret_cast<Registers*>(QDEC_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Task starting the quadrature decoder
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Task stopping the quadrature decoder
    }

    /// TASKS_READCLRACC Register bits
    namespace tasks_readclracc_bits {
        constexpr uint32_t TASKS_READCLRACC = (1U << 0);  ///< Read and clear ACC and ACCDBL
    }

    /// TASKS_RDCLRACC Register bits
    namespace tasks_rdclracc_bits {
        constexpr uint32_t TASKS_RDCLRACC = (1U << 0);  ///< Read and clear ACC
    }

    /// TASKS_RDCLRDBL Register bits
    namespace tasks_rdclrdbl_bits {
        constexpr uint32_t TASKS_RDCLRDBL = (1U << 0);  ///< Read and clear ACCDBL
    }

    /// EVENTS_SAMPLERDY Register bits
    namespace events_samplerdy_bits {
        constexpr uint32_t EVENTS_SAMPLERDY = (1U << 0);  ///< Event being generated for every new sample value written to the SAMPLE register
    }

    /// EVENTS_REPORTRDY Register bits
    namespace events_reportrdy_bits {
        constexpr uint32_t EVENTS_REPORTRDY = (1U << 0);  ///< Non-null report ready
    }

    /// EVENTS_ACCOF Register bits
    namespace events_accof_bits {
        constexpr uint32_t EVENTS_ACCOF = (1U << 0);  ///< ACC or ACCDBL register overflow
    }

    /// EVENTS_DBLRDY Register bits
    namespace events_dblrdy_bits {
        constexpr uint32_t EVENTS_DBLRDY = (1U << 0);  ///< Double displacement(s) detected
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< QDEC has been stopped
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t REPORTRDY_READCLRACC = (1U << 0);  ///< Shortcut between event REPORTRDY and task READCLRACC
        constexpr uint32_t SAMPLERDY_STOP = (1U << 1);  ///< Shortcut between event SAMPLERDY and task STOP
        constexpr uint32_t REPORTRDY_RDCLRACC = (1U << 2);  ///< Shortcut between event REPORTRDY and task RDCLRACC
        constexpr uint32_t REPORTRDY_STOP = (1U << 3);  ///< Shortcut between event REPORTRDY and task STOP
        constexpr uint32_t DBLRDY_RDCLRDBL = (1U << 4);  ///< Shortcut between event DBLRDY and task RDCLRDBL
        constexpr uint32_t DBLRDY_STOP = (1U << 5);  ///< Shortcut between event DBLRDY and task STOP
        constexpr uint32_t SAMPLERDY_READCLRACC = (1U << 6);  ///< Shortcut between event SAMPLERDY and task READCLRACC
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t SAMPLERDY = (1U << 0);  ///< Write '1' to enable interrupt for event SAMPLERDY
        constexpr uint32_t REPORTRDY = (1U << 1);  ///< Write '1' to enable interrupt for event REPORTRDY
        constexpr uint32_t ACCOF = (1U << 2);  ///< Write '1' to enable interrupt for event ACCOF
        constexpr uint32_t DBLRDY = (1U << 3);  ///< Write '1' to enable interrupt for event DBLRDY
        constexpr uint32_t STOPPED = (1U << 4);  ///< Write '1' to enable interrupt for event STOPPED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t SAMPLERDY = (1U << 0);  ///< Write '1' to disable interrupt for event SAMPLERDY
        constexpr uint32_t REPORTRDY = (1U << 1);  ///< Write '1' to disable interrupt for event REPORTRDY
        constexpr uint32_t ACCOF = (1U << 2);  ///< Write '1' to disable interrupt for event ACCOF
        constexpr uint32_t DBLRDY = (1U << 3);  ///< Write '1' to disable interrupt for event DBLRDY
        constexpr uint32_t STOPPED = (1U << 4);  ///< Write '1' to disable interrupt for event STOPPED
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable the quadrature decoder
    }

    /// LEDPOL Register bits
    namespace ledpol_bits {
        constexpr uint32_t LEDPOL = (1U << 0);  ///< LED output pin polarity
    }

    /// SAMPLEPER Register bits
    namespace sampleper_bits {
        constexpr uint32_t SAMPLEPER = (4 << 0);  ///< Sample period. The SAMPLE register will be updated for every new sample
    }

    /// SAMPLE Register bits
    namespace sample_bits {
        constexpr uint32_t SAMPLE = (32 << 0);  ///< Last motion sample
    }

    /// REPORTPER Register bits
    namespace reportper_bits {
        constexpr uint32_t REPORTPER = (4 << 0);  ///< Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated
    }

    /// ACC Register bits
    namespace acc_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< Register accumulating all valid samples (not double transition) read from the SAMPLE register
    }

    /// ACCREAD Register bits
    namespace accread_bits {
        constexpr uint32_t ACCREAD = (32 << 0);  ///< Snapshot of the ACC register.
    }

    /// LED Register bits
    namespace led_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// A Register bits
    namespace a_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// B Register bits
    namespace b_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// DBFEN Register bits
    namespace dbfen_bits {
        constexpr uint32_t DBFEN = (1U << 0);  ///< Enable input debounce filters
    }

    /// LEDPRE Register bits
    namespace ledpre_bits {
        constexpr uint32_t LEDPRE = (9 << 0);  ///< Period in us the LED is switched on prior to sampling
    }

    /// ACCDBL Register bits
    namespace accdbl_bits {
        constexpr uint32_t ACCDBL = (4 << 0);  ///< Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 ).
    }

    /// ACCDBLREAD Register bits
    namespace accdblread_bits {
        constexpr uint32_t ACCDBLREAD = (4 << 0);  ///< Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered.
    }

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMP_BASE = 0x40013000;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start comparator
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop comparator
        volatile uint32_t TASKS_SAMPLE;  ///< Offset: 0x08 - Sample comparator value
        volatile uint32_t EVENTS_READY;  ///< Offset: 0x100 - COMP is ready and output is valid
        volatile uint32_t EVENTS_DOWN;  ///< Offset: 0x104 - Downward crossing
        volatile uint32_t EVENTS_UP;  ///< Offset: 0x108 - Upward crossing
        volatile uint32_t EVENTS_CROSS;  ///< Offset: 0x10C - Downward or upward crossing
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t RESULT;  ///< Offset: 0x400 - Compare result
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - COMP enable
        volatile uint32_t PSEL;  ///< Offset: 0x504 - Pin select
        volatile uint32_t REFSEL;  ///< Offset: 0x508 - Reference source select for single-ended mode
        volatile uint32_t EXTREFSEL;  ///< Offset: 0x50C - External reference select
        volatile uint32_t TH;  ///< Offset: 0x530 - Threshold configuration for hysteresis unit
        volatile uint32_t MODE;  ///< Offset: 0x534 - Mode configuration
        volatile uint32_t HYST;  ///< Offset: 0x538 - Comparator hysteresis enable
    };

    /// Peripheral instances
    inline Registers* COMP = reinterpret_cast<Registers*>(COMP_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start comparator
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop comparator
    }

    /// TASKS_SAMPLE Register bits
    namespace tasks_sample_bits {
        constexpr uint32_t TASKS_SAMPLE = (1U << 0);  ///< Sample comparator value
    }

    /// EVENTS_READY Register bits
    namespace events_ready_bits {
        constexpr uint32_t EVENTS_READY = (1U << 0);  ///< COMP is ready and output is valid
    }

    /// EVENTS_DOWN Register bits
    namespace events_down_bits {
        constexpr uint32_t EVENTS_DOWN = (1U << 0);  ///< Downward crossing
    }

    /// EVENTS_UP Register bits
    namespace events_up_bits {
        constexpr uint32_t EVENTS_UP = (1U << 0);  ///< Upward crossing
    }

    /// EVENTS_CROSS Register bits
    namespace events_cross_bits {
        constexpr uint32_t EVENTS_CROSS = (1U << 0);  ///< Downward or upward crossing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t READY_SAMPLE = (1U << 0);  ///< Shortcut between event READY and task SAMPLE
        constexpr uint32_t READY_STOP = (1U << 1);  ///< Shortcut between event READY and task STOP
        constexpr uint32_t DOWN_STOP = (1U << 2);  ///< Shortcut between event DOWN and task STOP
        constexpr uint32_t UP_STOP = (1U << 3);  ///< Shortcut between event UP and task STOP
        constexpr uint32_t CROSS_STOP = (1U << 4);  ///< Shortcut between event CROSS and task STOP
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Enable or disable interrupt for event READY
        constexpr uint32_t DOWN = (1U << 1);  ///< Enable or disable interrupt for event DOWN
        constexpr uint32_t UP = (1U << 2);  ///< Enable or disable interrupt for event UP
        constexpr uint32_t CROSS = (1U << 3);  ///< Enable or disable interrupt for event CROSS
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to enable interrupt for event READY
        constexpr uint32_t DOWN = (1U << 1);  ///< Write '1' to enable interrupt for event DOWN
        constexpr uint32_t UP = (1U << 2);  ///< Write '1' to enable interrupt for event UP
        constexpr uint32_t CROSS = (1U << 3);  ///< Write '1' to enable interrupt for event CROSS
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to disable interrupt for event READY
        constexpr uint32_t DOWN = (1U << 1);  ///< Write '1' to disable interrupt for event DOWN
        constexpr uint32_t UP = (1U << 2);  ///< Write '1' to disable interrupt for event UP
        constexpr uint32_t CROSS = (1U << 3);  ///< Write '1' to disable interrupt for event CROSS
    }

    /// RESULT Register bits
    namespace result_bits {
        constexpr uint32_t RESULT = (1U << 0);  ///< Result of last compare. Decision point SAMPLE task.
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (2 << 0);  ///< Enable or disable COMP
    }

    /// PSEL Register bits
    namespace psel_bits {
        constexpr uint32_t PSEL = (3 << 0);  ///< Analog pin select
    }

    /// REFSEL Register bits
    namespace refsel_bits {
        constexpr uint32_t REFSEL = (3 << 0);  ///< Reference select
    }

    /// EXTREFSEL Register bits
    namespace extrefsel_bits {
        constexpr uint32_t EXTREFSEL = (3 << 0);  ///< External analog reference select
    }

    /// TH Register bits
    namespace th_bits {
        constexpr uint32_t THDOWN = (6 << 0);  ///< VDOWN = (THDOWN+1)/64*VREF
        constexpr uint32_t THUP = (6 << 8);  ///< VUP = (THUP+1)/64*VREF
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t SP = (2 << 0);  ///< Speed and power modes
        constexpr uint32_t MAIN = (1U << 8);  ///< Main operation modes
    }

    /// HYST Register bits
    namespace hyst_bits {
        constexpr uint32_t HYST = (1U << 0);  ///< Comparator hysteresis
    }

}

// ============================================================================
// LPCOMP Peripheral
// ============================================================================

namespace lpcomp {
    /// Base addresses
    constexpr uint32_t LPCOMP_BASE = 0x40013000;

    /// LPCOMP Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start comparator
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop comparator
        volatile uint32_t TASKS_SAMPLE;  ///< Offset: 0x08 - Sample comparator value
        volatile uint32_t EVENTS_READY;  ///< Offset: 0x100 - LPCOMP is ready and output is valid
        volatile uint32_t EVENTS_DOWN;  ///< Offset: 0x104 - Downward crossing
        volatile uint32_t EVENTS_UP;  ///< Offset: 0x108 - Upward crossing
        volatile uint32_t EVENTS_CROSS;  ///< Offset: 0x10C - Downward or upward crossing
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t RESULT;  ///< Offset: 0x400 - Compare result
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable LPCOMP
        volatile uint32_t PSEL;  ///< Offset: 0x504 - Input pin select
        volatile uint32_t REFSEL;  ///< Offset: 0x508 - Reference select
        volatile uint32_t EXTREFSEL;  ///< Offset: 0x50C - External reference select
        volatile uint32_t ANADETECT;  ///< Offset: 0x520 - Analog detect configuration
        volatile uint32_t HYST;  ///< Offset: 0x538 - Comparator hysteresis enable
    };

    /// Peripheral instances
    inline Registers* LPCOMP = reinterpret_cast<Registers*>(LPCOMP_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start comparator
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop comparator
    }

    /// TASKS_SAMPLE Register bits
    namespace tasks_sample_bits {
        constexpr uint32_t TASKS_SAMPLE = (1U << 0);  ///< Sample comparator value
    }

    /// EVENTS_READY Register bits
    namespace events_ready_bits {
        constexpr uint32_t EVENTS_READY = (1U << 0);  ///< LPCOMP is ready and output is valid
    }

    /// EVENTS_DOWN Register bits
    namespace events_down_bits {
        constexpr uint32_t EVENTS_DOWN = (1U << 0);  ///< Downward crossing
    }

    /// EVENTS_UP Register bits
    namespace events_up_bits {
        constexpr uint32_t EVENTS_UP = (1U << 0);  ///< Upward crossing
    }

    /// EVENTS_CROSS Register bits
    namespace events_cross_bits {
        constexpr uint32_t EVENTS_CROSS = (1U << 0);  ///< Downward or upward crossing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t READY_SAMPLE = (1U << 0);  ///< Shortcut between event READY and task SAMPLE
        constexpr uint32_t READY_STOP = (1U << 1);  ///< Shortcut between event READY and task STOP
        constexpr uint32_t DOWN_STOP = (1U << 2);  ///< Shortcut between event DOWN and task STOP
        constexpr uint32_t UP_STOP = (1U << 3);  ///< Shortcut between event UP and task STOP
        constexpr uint32_t CROSS_STOP = (1U << 4);  ///< Shortcut between event CROSS and task STOP
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to enable interrupt for event READY
        constexpr uint32_t DOWN = (1U << 1);  ///< Write '1' to enable interrupt for event DOWN
        constexpr uint32_t UP = (1U << 2);  ///< Write '1' to enable interrupt for event UP
        constexpr uint32_t CROSS = (1U << 3);  ///< Write '1' to enable interrupt for event CROSS
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to disable interrupt for event READY
        constexpr uint32_t DOWN = (1U << 1);  ///< Write '1' to disable interrupt for event DOWN
        constexpr uint32_t UP = (1U << 2);  ///< Write '1' to disable interrupt for event UP
        constexpr uint32_t CROSS = (1U << 3);  ///< Write '1' to disable interrupt for event CROSS
    }

    /// RESULT Register bits
    namespace result_bits {
        constexpr uint32_t RESULT = (1U << 0);  ///< Result of last compare. Decision point SAMPLE task.
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (2 << 0);  ///< Enable or disable LPCOMP
    }

    /// PSEL Register bits
    namespace psel_bits {
        constexpr uint32_t PSEL = (3 << 0);  ///< Analog pin select
    }

    /// REFSEL Register bits
    namespace refsel_bits {
        constexpr uint32_t REFSEL = (4 << 0);  ///< Reference select
    }

    /// EXTREFSEL Register bits
    namespace extrefsel_bits {
        constexpr uint32_t EXTREFSEL = (1U << 0);  ///< External analog reference select
    }

    /// ANADETECT Register bits
    namespace anadetect_bits {
        constexpr uint32_t ANADETECT = (2 << 0);  ///< Analog detect configuration
    }

    /// HYST Register bits
    namespace hyst_bits {
        constexpr uint32_t HYST = (1U << 0);  ///< Comparator hysteresis enable
    }

}

// ============================================================================
// EGU0 Peripheral
// ============================================================================

namespace egu0 {
    /// Base addresses
    constexpr uint32_t EGU0_BASE = 0x40014000;

    /// EGU0 Register structure
    struct Registers {
        volatile uint32_t TASKS_TRIGGER__;  ///< Offset: 0x00 - Description collection: Trigger n for triggering the... (renamed from TASKS_TRIGGER__)
        volatile uint32_t EVENTS_TRIGGERED__;  ///< Offset: 0x100 - Description collection: Event number n generated by... (renamed from EVENTS_TRIGGERED__)
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
    };

    /// Peripheral instances
    inline Registers* EGU0 = reinterpret_cast<Registers*>(EGU0_BASE);

    // Bit definitions
    /// TASKS_TRIGGER__ Register bits
    namespace tasks_trigger___bits {
        constexpr uint32_t TASKS_TRIGGER = (1U << 0);  ///< Trigger n for triggering the corresponding TRIGGERED[n] event
    }

    /// EVENTS_TRIGGERED__ Register bits
    namespace events_triggered___bits {
        constexpr uint32_t EVENTS_TRIGGERED = (1U << 0);  ///< Event number n generated by triggering the corresponding TRIGGER[n] task
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t TRIGGERED0 = (1U << 0);  ///< Enable or disable interrupt for event TRIGGERED[0]
        constexpr uint32_t TRIGGERED1 = (1U << 1);  ///< Enable or disable interrupt for event TRIGGERED[1]
        constexpr uint32_t TRIGGERED2 = (1U << 2);  ///< Enable or disable interrupt for event TRIGGERED[2]
        constexpr uint32_t TRIGGERED3 = (1U << 3);  ///< Enable or disable interrupt for event TRIGGERED[3]
        constexpr uint32_t TRIGGERED4 = (1U << 4);  ///< Enable or disable interrupt for event TRIGGERED[4]
        constexpr uint32_t TRIGGERED5 = (1U << 5);  ///< Enable or disable interrupt for event TRIGGERED[5]
        constexpr uint32_t TRIGGERED6 = (1U << 6);  ///< Enable or disable interrupt for event TRIGGERED[6]
        constexpr uint32_t TRIGGERED7 = (1U << 7);  ///< Enable or disable interrupt for event TRIGGERED[7]
        constexpr uint32_t TRIGGERED8 = (1U << 8);  ///< Enable or disable interrupt for event TRIGGERED[8]
        constexpr uint32_t TRIGGERED9 = (1U << 9);  ///< Enable or disable interrupt for event TRIGGERED[9]
        constexpr uint32_t TRIGGERED10 = (1U << 10);  ///< Enable or disable interrupt for event TRIGGERED[10]
        constexpr uint32_t TRIGGERED11 = (1U << 11);  ///< Enable or disable interrupt for event TRIGGERED[11]
        constexpr uint32_t TRIGGERED12 = (1U << 12);  ///< Enable or disable interrupt for event TRIGGERED[12]
        constexpr uint32_t TRIGGERED13 = (1U << 13);  ///< Enable or disable interrupt for event TRIGGERED[13]
        constexpr uint32_t TRIGGERED14 = (1U << 14);  ///< Enable or disable interrupt for event TRIGGERED[14]
        constexpr uint32_t TRIGGERED15 = (1U << 15);  ///< Enable or disable interrupt for event TRIGGERED[15]
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TRIGGERED0 = (1U << 0);  ///< Write '1' to enable interrupt for event TRIGGERED[0]
        constexpr uint32_t TRIGGERED1 = (1U << 1);  ///< Write '1' to enable interrupt for event TRIGGERED[1]
        constexpr uint32_t TRIGGERED2 = (1U << 2);  ///< Write '1' to enable interrupt for event TRIGGERED[2]
        constexpr uint32_t TRIGGERED3 = (1U << 3);  ///< Write '1' to enable interrupt for event TRIGGERED[3]
        constexpr uint32_t TRIGGERED4 = (1U << 4);  ///< Write '1' to enable interrupt for event TRIGGERED[4]
        constexpr uint32_t TRIGGERED5 = (1U << 5);  ///< Write '1' to enable interrupt for event TRIGGERED[5]
        constexpr uint32_t TRIGGERED6 = (1U << 6);  ///< Write '1' to enable interrupt for event TRIGGERED[6]
        constexpr uint32_t TRIGGERED7 = (1U << 7);  ///< Write '1' to enable interrupt for event TRIGGERED[7]
        constexpr uint32_t TRIGGERED8 = (1U << 8);  ///< Write '1' to enable interrupt for event TRIGGERED[8]
        constexpr uint32_t TRIGGERED9 = (1U << 9);  ///< Write '1' to enable interrupt for event TRIGGERED[9]
        constexpr uint32_t TRIGGERED10 = (1U << 10);  ///< Write '1' to enable interrupt for event TRIGGERED[10]
        constexpr uint32_t TRIGGERED11 = (1U << 11);  ///< Write '1' to enable interrupt for event TRIGGERED[11]
        constexpr uint32_t TRIGGERED12 = (1U << 12);  ///< Write '1' to enable interrupt for event TRIGGERED[12]
        constexpr uint32_t TRIGGERED13 = (1U << 13);  ///< Write '1' to enable interrupt for event TRIGGERED[13]
        constexpr uint32_t TRIGGERED14 = (1U << 14);  ///< Write '1' to enable interrupt for event TRIGGERED[14]
        constexpr uint32_t TRIGGERED15 = (1U << 15);  ///< Write '1' to enable interrupt for event TRIGGERED[15]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TRIGGERED0 = (1U << 0);  ///< Write '1' to disable interrupt for event TRIGGERED[0]
        constexpr uint32_t TRIGGERED1 = (1U << 1);  ///< Write '1' to disable interrupt for event TRIGGERED[1]
        constexpr uint32_t TRIGGERED2 = (1U << 2);  ///< Write '1' to disable interrupt for event TRIGGERED[2]
        constexpr uint32_t TRIGGERED3 = (1U << 3);  ///< Write '1' to disable interrupt for event TRIGGERED[3]
        constexpr uint32_t TRIGGERED4 = (1U << 4);  ///< Write '1' to disable interrupt for event TRIGGERED[4]
        constexpr uint32_t TRIGGERED5 = (1U << 5);  ///< Write '1' to disable interrupt for event TRIGGERED[5]
        constexpr uint32_t TRIGGERED6 = (1U << 6);  ///< Write '1' to disable interrupt for event TRIGGERED[6]
        constexpr uint32_t TRIGGERED7 = (1U << 7);  ///< Write '1' to disable interrupt for event TRIGGERED[7]
        constexpr uint32_t TRIGGERED8 = (1U << 8);  ///< Write '1' to disable interrupt for event TRIGGERED[8]
        constexpr uint32_t TRIGGERED9 = (1U << 9);  ///< Write '1' to disable interrupt for event TRIGGERED[9]
        constexpr uint32_t TRIGGERED10 = (1U << 10);  ///< Write '1' to disable interrupt for event TRIGGERED[10]
        constexpr uint32_t TRIGGERED11 = (1U << 11);  ///< Write '1' to disable interrupt for event TRIGGERED[11]
        constexpr uint32_t TRIGGERED12 = (1U << 12);  ///< Write '1' to disable interrupt for event TRIGGERED[12]
        constexpr uint32_t TRIGGERED13 = (1U << 13);  ///< Write '1' to disable interrupt for event TRIGGERED[13]
        constexpr uint32_t TRIGGERED14 = (1U << 14);  ///< Write '1' to disable interrupt for event TRIGGERED[14]
        constexpr uint32_t TRIGGERED15 = (1U << 15);  ///< Write '1' to disable interrupt for event TRIGGERED[15]
    }

}

// ============================================================================
// SWI0 Peripheral
// ============================================================================

namespace swi0 {
    /// Base addresses
    constexpr uint32_t SWI0_BASE = 0x40014000;

    /// SWI0 Register structure
    struct Registers {
        volatile uint32_t UNUSED;  ///< Offset: 0x00 - Unused.
    };

    /// Peripheral instances
    inline Registers* SWI0 = reinterpret_cast<Registers*>(SWI0_BASE);

}

// ============================================================================
// EGU1 Peripheral
// ============================================================================

namespace egu1 {
    /// Base addresses
    constexpr uint32_t EGU1_BASE = 0x40015000;

    /// EGU1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* EGU1 = reinterpret_cast<Registers*>(EGU1_BASE);

}

// ============================================================================
// SWI1 Peripheral
// ============================================================================

namespace swi1 {
    /// Base addresses
    constexpr uint32_t SWI1_BASE = 0x40015000;

    /// SWI1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SWI1 = reinterpret_cast<Registers*>(SWI1_BASE);

}

// ============================================================================
// EGU2 Peripheral
// ============================================================================

namespace egu2 {
    /// Base addresses
    constexpr uint32_t EGU2_BASE = 0x40016000;

    /// EGU2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* EGU2 = reinterpret_cast<Registers*>(EGU2_BASE);

}

// ============================================================================
// SWI2 Peripheral
// ============================================================================

namespace swi2 {
    /// Base addresses
    constexpr uint32_t SWI2_BASE = 0x40016000;

    /// SWI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SWI2 = reinterpret_cast<Registers*>(SWI2_BASE);

}

// ============================================================================
// EGU3 Peripheral
// ============================================================================

namespace egu3 {
    /// Base addresses
    constexpr uint32_t EGU3_BASE = 0x40017000;

    /// EGU3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* EGU3 = reinterpret_cast<Registers*>(EGU3_BASE);

}

// ============================================================================
// SWI3 Peripheral
// ============================================================================

namespace swi3 {
    /// Base addresses
    constexpr uint32_t SWI3_BASE = 0x40017000;

    /// SWI3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SWI3 = reinterpret_cast<Registers*>(SWI3_BASE);

}

// ============================================================================
// EGU4 Peripheral
// ============================================================================

namespace egu4 {
    /// Base addresses
    constexpr uint32_t EGU4_BASE = 0x40018000;

    /// EGU4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* EGU4 = reinterpret_cast<Registers*>(EGU4_BASE);

}

// ============================================================================
// SWI4 Peripheral
// ============================================================================

namespace swi4 {
    /// Base addresses
    constexpr uint32_t SWI4_BASE = 0x40018000;

    /// SWI4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SWI4 = reinterpret_cast<Registers*>(SWI4_BASE);

}

// ============================================================================
// EGU5 Peripheral
// ============================================================================

namespace egu5 {
    /// Base addresses
    constexpr uint32_t EGU5_BASE = 0x40019000;

    /// EGU5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* EGU5 = reinterpret_cast<Registers*>(EGU5_BASE);

}

// ============================================================================
// SWI5 Peripheral
// ============================================================================

namespace swi5 {
    /// Base addresses
    constexpr uint32_t SWI5_BASE = 0x40019000;

    /// SWI5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SWI5 = reinterpret_cast<Registers*>(SWI5_BASE);

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t PWM0_BASE = 0x4001C000;
    constexpr uint32_t PWM1_BASE = 0x40021000;
    constexpr uint32_t PWM2_BASE = 0x40022000;
    constexpr uint32_t PWM3_BASE = 0x4002D000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stops PWM pulse generation on all channels at the end of...
        volatile uint32_t TASKS_SEQSTART__;  ///< Offset: 0x08 - Description collection: Loads the first PWM value on all... (renamed from TASKS_SEQSTART__)
        volatile uint32_t TASKS_NEXTSTEP;  ///< Offset: 0x10 - Steps by one value in the current sequence on all...
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - Response to STOP task, emitted when PWM pulses are no...
        volatile uint32_t EVENTS_SEQSTARTED__;  ///< Offset: 0x108 - Description collection: First PWM period started on sequence n (renamed from EVENTS_SEQSTARTED__)
        volatile uint32_t EVENTS_SEQEND__;  ///< Offset: 0x110 - Description collection: Emitted at end of every sequence... (renamed from EVENTS_SEQEND__)
        volatile uint32_t EVENTS_PWMPERIODEND;  ///< Offset: 0x118 - Emitted at the end of each PWM period
        volatile uint32_t EVENTS_LOOPSDONE;  ///< Offset: 0x11C - Concatenated sequences have been played the amount of...
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - PWM module enable register
        volatile uint32_t MODE;  ///< Offset: 0x504 - Selects operating mode of the wave counter
        volatile uint32_t COUNTERTOP;  ///< Offset: 0x508 - Value up to which the pulse generator counter counts
        volatile uint32_t PRESCALER;  ///< Offset: 0x50C - Configuration for PWM_CLK
        volatile uint32_t DECODER;  ///< Offset: 0x510 - Configuration of the decoder
        volatile uint32_t LOOP;  ///< Offset: 0x514 - Number of playbacks of a loop
        volatile uint32_t PTR;  ///< Offset: 0x00 - Description cluster: Beginning address in RAM of this sequence
        volatile uint32_t CNT;  ///< Offset: 0x04 - Description cluster: Number of values (duty cycles) in...
        volatile uint32_t REFRESH;  ///< Offset: 0x08 - Description cluster: Number of additional PWM periods...
        volatile uint32_t ENDDELAY;  ///< Offset: 0x0C - Description cluster: Time added after the sequence
        volatile uint32_t OUT__;  ///< Offset: 0x00 - Description collection: Output pin select for PWM channel n (renamed from OUT__)
    };

    /// Peripheral instances
    inline Registers* PWM0 = reinterpret_cast<Registers*>(PWM0_BASE);
    inline Registers* PWM1 = reinterpret_cast<Registers*>(PWM1_BASE);
    inline Registers* PWM2 = reinterpret_cast<Registers*>(PWM2_BASE);
    inline Registers* PWM3 = reinterpret_cast<Registers*>(PWM3_BASE);

    // Bit definitions
    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
    }

    /// TASKS_SEQSTART__ Register bits
    namespace tasks_seqstart___bits {
        constexpr uint32_t TASKS_SEQSTART = (1U << 0);  ///< Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
    }

    /// TASKS_NEXTSTEP Register bits
    namespace tasks_nextstep_bits {
        constexpr uint32_t TASKS_NEXTSTEP = (1U << 0);  ///< Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< Response to STOP task, emitted when PWM pulses are no longer generated
    }

    /// EVENTS_SEQSTARTED__ Register bits
    namespace events_seqstarted___bits {
        constexpr uint32_t EVENTS_SEQSTARTED = (1U << 0);  ///< First PWM period started on sequence n
    }

    /// EVENTS_SEQEND__ Register bits
    namespace events_seqend___bits {
        constexpr uint32_t EVENTS_SEQEND = (1U << 0);  ///< Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
    }

    /// EVENTS_PWMPERIODEND Register bits
    namespace events_pwmperiodend_bits {
        constexpr uint32_t EVENTS_PWMPERIODEND = (1U << 0);  ///< Emitted at the end of each PWM period
    }

    /// EVENTS_LOOPSDONE Register bits
    namespace events_loopsdone_bits {
        constexpr uint32_t EVENTS_LOOPSDONE = (1U << 0);  ///< Concatenated sequences have been played the amount of times defined in LOOP.CNT
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t SEQEND0_STOP = (1U << 0);  ///< Shortcut between event SEQEND[0] and task STOP
        constexpr uint32_t SEQEND1_STOP = (1U << 1);  ///< Shortcut between event SEQEND[1] and task STOP
        constexpr uint32_t LOOPSDONE_SEQSTART0 = (1U << 2);  ///< Shortcut between event LOOPSDONE and task SEQSTART[0]
        constexpr uint32_t LOOPSDONE_SEQSTART1 = (1U << 3);  ///< Shortcut between event LOOPSDONE and task SEQSTART[1]
        constexpr uint32_t LOOPSDONE_STOP = (1U << 4);  ///< Shortcut between event LOOPSDONE and task STOP
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Enable or disable interrupt for event STOPPED
        constexpr uint32_t SEQSTARTED0 = (1U << 2);  ///< Enable or disable interrupt for event SEQSTARTED[0]
        constexpr uint32_t SEQSTARTED1 = (1U << 3);  ///< Enable or disable interrupt for event SEQSTARTED[1]
        constexpr uint32_t SEQEND0 = (1U << 4);  ///< Enable or disable interrupt for event SEQEND[0]
        constexpr uint32_t SEQEND1 = (1U << 5);  ///< Enable or disable interrupt for event SEQEND[1]
        constexpr uint32_t PWMPERIODEND = (1U << 6);  ///< Enable or disable interrupt for event PWMPERIODEND
        constexpr uint32_t LOOPSDONE = (1U << 7);  ///< Enable or disable interrupt for event LOOPSDONE
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t SEQSTARTED0 = (1U << 2);  ///< Write '1' to enable interrupt for event SEQSTARTED[0]
        constexpr uint32_t SEQSTARTED1 = (1U << 3);  ///< Write '1' to enable interrupt for event SEQSTARTED[1]
        constexpr uint32_t SEQEND0 = (1U << 4);  ///< Write '1' to enable interrupt for event SEQEND[0]
        constexpr uint32_t SEQEND1 = (1U << 5);  ///< Write '1' to enable interrupt for event SEQEND[1]
        constexpr uint32_t PWMPERIODEND = (1U << 6);  ///< Write '1' to enable interrupt for event PWMPERIODEND
        constexpr uint32_t LOOPSDONE = (1U << 7);  ///< Write '1' to enable interrupt for event LOOPSDONE
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t SEQSTARTED0 = (1U << 2);  ///< Write '1' to disable interrupt for event SEQSTARTED[0]
        constexpr uint32_t SEQSTARTED1 = (1U << 3);  ///< Write '1' to disable interrupt for event SEQSTARTED[1]
        constexpr uint32_t SEQEND0 = (1U << 4);  ///< Write '1' to disable interrupt for event SEQEND[0]
        constexpr uint32_t SEQEND1 = (1U << 5);  ///< Write '1' to disable interrupt for event SEQEND[1]
        constexpr uint32_t PWMPERIODEND = (1U << 6);  ///< Write '1' to disable interrupt for event PWMPERIODEND
        constexpr uint32_t LOOPSDONE = (1U << 7);  ///< Write '1' to disable interrupt for event LOOPSDONE
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable PWM module
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t UPDOWN = (1U << 0);  ///< Selects up mode or up-and-down mode for the counter
    }

    /// COUNTERTOP Register bits
    namespace countertop_bits {
        constexpr uint32_t COUNTERTOP = (15 << 0);  ///< Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used.
    }

    /// PRESCALER Register bits
    namespace prescaler_bits {
        constexpr uint32_t PRESCALER = (3 << 0);  ///< Prescaler of PWM_CLK
    }

    /// DECODER Register bits
    namespace decoder_bits {
        constexpr uint32_t LOAD = (2 << 0);  ///< How a sequence is read from RAM and spread to the compare register
        constexpr uint32_t MODE = (1U << 8);  ///< Selects source for advancing the active sequence
    }

    /// LOOP Register bits
    namespace loop_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Number of playbacks of pattern cycles
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Beginning address in RAM of this sequence
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (15 << 0);  ///< Number of values (duty cycles) in this sequence
    }

    /// REFRESH Register bits
    namespace refresh_bits {
        constexpr uint32_t CNT = (24 << 0);  ///< Number of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)
    }

    /// ENDDELAY Register bits
    namespace enddelay_bits {
        constexpr uint32_t CNT = (24 << 0);  ///< Time added after the sequence in PWM periods
    }

    /// OUT__ Register bits
    namespace out___bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

}

// ============================================================================
// PDM Peripheral
// ============================================================================

namespace pdm {
    /// Base addresses
    constexpr uint32_t PDM_BASE = 0x4001D000;

    /// PDM Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Starts continuous PDM transfer
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stops PDM transfer
        volatile uint32_t EVENTS_STARTED;  ///< Offset: 0x100 - PDM transfer has started
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - PDM transfer has finished
        volatile uint32_t EVENTS_END;  ///< Offset: 0x108 - The PDM has written the last sample specified by...
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - PDM module enable register
        volatile uint32_t PDMCLKCTRL;  ///< Offset: 0x504 - PDM clock generator control
        volatile uint32_t MODE;  ///< Offset: 0x508 - Defines the routing of the connected PDM microphones' signals
        volatile uint32_t GAINL;  ///< Offset: 0x518 - Left output gain adjustment
        volatile uint32_t GAINR;  ///< Offset: 0x51C - Right output gain adjustment
        volatile uint32_t RATIO;  ///< Offset: 0x520 - Selects the ratio between PDM_CLK and output sample...
        volatile uint32_t CLK;  ///< Offset: 0x00 - Pin number configuration for PDM CLK signal
        volatile uint32_t DIN;  ///< Offset: 0x04 - Pin number configuration for PDM DIN signal
        volatile uint32_t PTR;  ///< Offset: 0x00 - RAM address pointer to write samples to with EasyDMA
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Number of samples to allocate memory for in EasyDMA mode
    };

    /// Peripheral instances
    inline Registers* PDM = reinterpret_cast<Registers*>(PDM_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Starts continuous PDM transfer
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stops PDM transfer
    }

    /// EVENTS_STARTED Register bits
    namespace events_started_bits {
        constexpr uint32_t EVENTS_STARTED = (1U << 0);  ///< PDM transfer has started
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< PDM transfer has finished
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Enable or disable interrupt for event STARTED
        constexpr uint32_t STOPPED = (1U << 1);  ///< Enable or disable interrupt for event STOPPED
        constexpr uint32_t END = (1U << 2);  ///< Enable or disable interrupt for event END
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Write '1' to enable interrupt for event STARTED
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t END = (1U << 2);  ///< Write '1' to enable interrupt for event END
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Write '1' to disable interrupt for event STARTED
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t END = (1U << 2);  ///< Write '1' to disable interrupt for event END
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable PDM module
    }

    /// PDMCLKCTRL Register bits
    namespace pdmclkctrl_bits {
        constexpr uint32_t FREQ = (32 << 0);  ///< PDM_CLK frequency
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t OPERATION = (1U << 0);  ///< Mono or stereo operation
        constexpr uint32_t EDGE = (1U << 1);  ///< Defines on which PDM_CLK edge Left (or mono) is sampled
    }

    /// GAINL Register bits
    namespace gainl_bits {
        constexpr uint32_t GAINL = (7 << 0);  ///< Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00 -20 dB gain adjust 0x01 -19.5 dB gain adjust (...) 0x27 -0.5 dB gain adjust 0x28 0 dB gain adjust 0x29 +0.5 dB gain adjust (...) 0x4F +19.5 dB gain adjust 0x50 +20 dB gain adjust
    }

    /// GAINR Register bits
    namespace gainr_bits {
        constexpr uint32_t GAINR = (7 << 0);  ///< Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)
    }

    /// RATIO Register bits
    namespace ratio_bits {
        constexpr uint32_t RATIO = (1U << 0);  ///< Selects the ratio between PDM_CLK and output sample rate
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// DIN Register bits
    namespace din_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t SAMPLEPTR = (32 << 0);  ///< Address to write PDM samples to over DMA
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t BUFFSIZE = (15 << 0);  ///< Length of DMA RAM allocation in number of samples
    }

}

// ============================================================================
// ACL Peripheral
// ============================================================================

namespace acl {
    /// Base addresses
    constexpr uint32_t ACL_BASE = 0x4001E000;

    /// ACL Register structure
    struct Registers {
        volatile uint32_t ADDR;  ///< Offset: 0x00 - Description cluster: Configure the word-aligned start...
        volatile uint32_t SIZE;  ///< Offset: 0x04 - Description cluster: Size of region to protect counting...
        volatile uint32_t PERM;  ///< Offset: 0x08 - Description cluster: Access permissions for region n as...
    };

    /// Peripheral instances
    inline Registers* ACL = reinterpret_cast<Registers*>(ACL_BASE);

    // Bit definitions
    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Valid word-aligned start address of region n to protect. Address must point to a flash page boundary.
    }

    /// SIZE Register bits
    namespace size_bits {
        constexpr uint32_t SIZE = (32 << 0);  ///< Size of flash region n in bytes. Must be a multiple of the flash page size, and the maximum region size is limited to 512 kB.
    }

    /// PERM Register bits
    namespace perm_bits {
        constexpr uint32_t WRITE = (1U << 1);  ///< Configure write and erase permissions for region n. Write '0' has no effect.
        constexpr uint32_t READ = (1U << 2);  ///< Configure read permissions for region n. Write '0' has no effect.
    }

}

// ============================================================================
// NVMC Peripheral
// ============================================================================

namespace nvmc {
    /// Base addresses
    constexpr uint32_t NVMC_BASE = 0x4001E000;

    /// NVMC Register structure
    struct Registers {
        volatile uint32_t READY;  ///< Offset: 0x400 - Ready flag
        volatile uint32_t READYNEXT;  ///< Offset: 0x408 - Ready flag
        volatile uint32_t CONFIG;  ///< Offset: 0x504 - Configuration register
        volatile uint32_t ERASEPAGE;  ///< Offset: 0x508 - Register for erasing a page in code area
        volatile uint32_t ERASEPCR1;  ///< Offset: 0x508 - Deprecated register - Register for erasing a page in...
        volatile uint32_t ERASEALL;  ///< Offset: 0x50C - Register for erasing all non-volatile user memory
        volatile uint32_t ERASEPCR0;  ///< Offset: 0x510 - Deprecated register - Register for erasing a page in...
        volatile uint32_t ERASEUICR;  ///< Offset: 0x514 - Register for erasing user information configuration registers
        volatile uint32_t ERASEPAGEPARTIAL;  ///< Offset: 0x518 - Register for partial erase of a page in code area
        volatile uint32_t ERASEPAGEPARTIALCFG;  ///< Offset: 0x51C - Register for partial erase configuration
        volatile uint32_t ICACHECNF;  ///< Offset: 0x540 - I-code cache configuration register.
        volatile uint32_t IHIT;  ///< Offset: 0x548 - I-code cache hit counter.
        volatile uint32_t IMISS;  ///< Offset: 0x54C - I-code cache miss counter.
    };

    /// Peripheral instances
    inline Registers* NVMC = reinterpret_cast<Registers*>(NVMC_BASE);

    // Bit definitions
    /// READY Register bits
    namespace ready_bits {
        constexpr uint32_t READY = (1U << 0);  ///< NVMC is ready or busy
    }

    /// READYNEXT Register bits
    namespace readynext_bits {
        constexpr uint32_t READYNEXT = (1U << 0);  ///< NVMC can accept a new write operation
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t WEN = (2 << 0);  ///< Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated.
    }

    /// ERASEPAGE Register bits
    namespace erasepage_bits {
        constexpr uint32_t ERASEPAGE = (32 << 0);  ///< Register for starting erase of a page in code area
    }

    /// ERASEPCR1 Register bits
    namespace erasepcr1_bits {
        constexpr uint32_t ERASEPCR1 = (32 << 0);  ///< Register for erasing a page in code area. Equivalent to ERASEPAGE.
    }

    /// ERASEALL Register bits
    namespace eraseall_bits {
        constexpr uint32_t ERASEALL = (1U << 0);  ///< Erase all non-volatile memory including UICR registers. Note that the erase must be enabled using CONFIG.WEN before the non-volatile memory can be erased.
    }

    /// ERASEPCR0 Register bits
    namespace erasepcr0_bits {
        constexpr uint32_t ERASEPCR0 = (32 << 0);  ///< Register for starting erase of a page in code area. Equivalent to ERASEPAGE.
    }

    /// ERASEUICR Register bits
    namespace eraseuicr_bits {
        constexpr uint32_t ERASEUICR = (1U << 0);  ///< Register starting erase of all user information configuration registers. Note that the erase must be enabled using CONFIG.WEN before the UICR can be erased.
    }

    /// ERASEPAGEPARTIAL Register bits
    namespace erasepagepartial_bits {
        constexpr uint32_t ERASEPAGEPARTIAL = (32 << 0);  ///< Register for starting partial erase of a page in code area
    }

    /// ERASEPAGEPARTIALCFG Register bits
    namespace erasepagepartialcfg_bits {
        constexpr uint32_t DURATION = (7 << 0);  ///< Duration of the partial erase in milliseconds
    }

    /// ICACHECNF Register bits
    namespace icachecnf_bits {
        constexpr uint32_t CACHEEN = (1U << 0);  ///< Cache enable
        constexpr uint32_t CACHEPROFEN = (1U << 8);  ///< Cache profiling enable
    }

    /// IHIT Register bits
    namespace ihit_bits {
        constexpr uint32_t HITS = (32 << 0);  ///< Number of cache hits
    }

    /// IMISS Register bits
    namespace imiss_bits {
        constexpr uint32_t MISSES = (32 << 0);  ///< Number of cache misses
    }

}

// ============================================================================
// PPI Peripheral
// ============================================================================

namespace ppi {
    /// Base addresses
    constexpr uint32_t PPI_BASE = 0x4001F000;

    /// PPI Register structure
    struct Registers {
        volatile uint32_t EN;  ///< Offset: 0x00 - Description cluster: Enable channel group n
        volatile uint32_t DIS;  ///< Offset: 0x04 - Description cluster: Disable channel group n
        volatile uint32_t CHEN;  ///< Offset: 0x500 - Channel enable register
        volatile uint32_t CHENSET;  ///< Offset: 0x504 - Channel enable set register
        volatile uint32_t CHENCLR;  ///< Offset: 0x508 - Channel enable clear register
        volatile uint32_t EEP;  ///< Offset: 0x00 - Description cluster: Channel n event end-point
        volatile uint32_t TEP;  ///< Offset: 0x00 - Description cluster: Channel n task end-point
        volatile uint32_t CHG__;  ///< Offset: 0x800 - Description collection: Channel group n (renamed from CHG__)
    };

    /// Peripheral instances
    inline Registers* PPI = reinterpret_cast<Registers*>(PPI_BASE);

    // Bit definitions
    /// EN Register bits
    namespace en_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable channel group n
    }

    /// DIS Register bits
    namespace dis_bits {
        constexpr uint32_t DIS = (1U << 0);  ///< Disable channel group n
    }

    /// CHEN Register bits
    namespace chen_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Enable or disable channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Enable or disable channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Enable or disable channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Enable or disable channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Enable or disable channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Enable or disable channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Enable or disable channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Enable or disable channel 7
        constexpr uint32_t CH8 = (1U << 8);  ///< Enable or disable channel 8
        constexpr uint32_t CH9 = (1U << 9);  ///< Enable or disable channel 9
        constexpr uint32_t CH10 = (1U << 10);  ///< Enable or disable channel 10
        constexpr uint32_t CH11 = (1U << 11);  ///< Enable or disable channel 11
        constexpr uint32_t CH12 = (1U << 12);  ///< Enable or disable channel 12
        constexpr uint32_t CH13 = (1U << 13);  ///< Enable or disable channel 13
        constexpr uint32_t CH14 = (1U << 14);  ///< Enable or disable channel 14
        constexpr uint32_t CH15 = (1U << 15);  ///< Enable or disable channel 15
        constexpr uint32_t CH16 = (1U << 16);  ///< Enable or disable channel 16
        constexpr uint32_t CH17 = (1U << 17);  ///< Enable or disable channel 17
        constexpr uint32_t CH18 = (1U << 18);  ///< Enable or disable channel 18
        constexpr uint32_t CH19 = (1U << 19);  ///< Enable or disable channel 19
        constexpr uint32_t CH20 = (1U << 20);  ///< Enable or disable channel 20
        constexpr uint32_t CH21 = (1U << 21);  ///< Enable or disable channel 21
        constexpr uint32_t CH22 = (1U << 22);  ///< Enable or disable channel 22
        constexpr uint32_t CH23 = (1U << 23);  ///< Enable or disable channel 23
        constexpr uint32_t CH24 = (1U << 24);  ///< Enable or disable channel 24
        constexpr uint32_t CH25 = (1U << 25);  ///< Enable or disable channel 25
        constexpr uint32_t CH26 = (1U << 26);  ///< Enable or disable channel 26
        constexpr uint32_t CH27 = (1U << 27);  ///< Enable or disable channel 27
        constexpr uint32_t CH28 = (1U << 28);  ///< Enable or disable channel 28
        constexpr uint32_t CH29 = (1U << 29);  ///< Enable or disable channel 29
        constexpr uint32_t CH30 = (1U << 30);  ///< Enable or disable channel 30
        constexpr uint32_t CH31 = (1U << 31);  ///< Enable or disable channel 31
    }

    /// CHENSET Register bits
    namespace chenset_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Channel 0 enable set register. Writing '0' has no effect
        constexpr uint32_t CH1 = (1U << 1);  ///< Channel 1 enable set register. Writing '0' has no effect
        constexpr uint32_t CH2 = (1U << 2);  ///< Channel 2 enable set register. Writing '0' has no effect
        constexpr uint32_t CH3 = (1U << 3);  ///< Channel 3 enable set register. Writing '0' has no effect
        constexpr uint32_t CH4 = (1U << 4);  ///< Channel 4 enable set register. Writing '0' has no effect
        constexpr uint32_t CH5 = (1U << 5);  ///< Channel 5 enable set register. Writing '0' has no effect
        constexpr uint32_t CH6 = (1U << 6);  ///< Channel 6 enable set register. Writing '0' has no effect
        constexpr uint32_t CH7 = (1U << 7);  ///< Channel 7 enable set register. Writing '0' has no effect
        constexpr uint32_t CH8 = (1U << 8);  ///< Channel 8 enable set register. Writing '0' has no effect
        constexpr uint32_t CH9 = (1U << 9);  ///< Channel 9 enable set register. Writing '0' has no effect
        constexpr uint32_t CH10 = (1U << 10);  ///< Channel 10 enable set register. Writing '0' has no effect
        constexpr uint32_t CH11 = (1U << 11);  ///< Channel 11 enable set register. Writing '0' has no effect
        constexpr uint32_t CH12 = (1U << 12);  ///< Channel 12 enable set register. Writing '0' has no effect
        constexpr uint32_t CH13 = (1U << 13);  ///< Channel 13 enable set register. Writing '0' has no effect
        constexpr uint32_t CH14 = (1U << 14);  ///< Channel 14 enable set register. Writing '0' has no effect
        constexpr uint32_t CH15 = (1U << 15);  ///< Channel 15 enable set register. Writing '0' has no effect
        constexpr uint32_t CH16 = (1U << 16);  ///< Channel 16 enable set register. Writing '0' has no effect
        constexpr uint32_t CH17 = (1U << 17);  ///< Channel 17 enable set register. Writing '0' has no effect
        constexpr uint32_t CH18 = (1U << 18);  ///< Channel 18 enable set register. Writing '0' has no effect
        constexpr uint32_t CH19 = (1U << 19);  ///< Channel 19 enable set register. Writing '0' has no effect
        constexpr uint32_t CH20 = (1U << 20);  ///< Channel 20 enable set register. Writing '0' has no effect
        constexpr uint32_t CH21 = (1U << 21);  ///< Channel 21 enable set register. Writing '0' has no effect
        constexpr uint32_t CH22 = (1U << 22);  ///< Channel 22 enable set register. Writing '0' has no effect
        constexpr uint32_t CH23 = (1U << 23);  ///< Channel 23 enable set register. Writing '0' has no effect
        constexpr uint32_t CH24 = (1U << 24);  ///< Channel 24 enable set register. Writing '0' has no effect
        constexpr uint32_t CH25 = (1U << 25);  ///< Channel 25 enable set register. Writing '0' has no effect
        constexpr uint32_t CH26 = (1U << 26);  ///< Channel 26 enable set register. Writing '0' has no effect
        constexpr uint32_t CH27 = (1U << 27);  ///< Channel 27 enable set register. Writing '0' has no effect
        constexpr uint32_t CH28 = (1U << 28);  ///< Channel 28 enable set register. Writing '0' has no effect
        constexpr uint32_t CH29 = (1U << 29);  ///< Channel 29 enable set register. Writing '0' has no effect
        constexpr uint32_t CH30 = (1U << 30);  ///< Channel 30 enable set register. Writing '0' has no effect
        constexpr uint32_t CH31 = (1U << 31);  ///< Channel 31 enable set register. Writing '0' has no effect
    }

    /// CHENCLR Register bits
    namespace chenclr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Channel 0 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH1 = (1U << 1);  ///< Channel 1 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH2 = (1U << 2);  ///< Channel 2 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH3 = (1U << 3);  ///< Channel 3 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH4 = (1U << 4);  ///< Channel 4 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH5 = (1U << 5);  ///< Channel 5 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH6 = (1U << 6);  ///< Channel 6 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH7 = (1U << 7);  ///< Channel 7 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH8 = (1U << 8);  ///< Channel 8 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH9 = (1U << 9);  ///< Channel 9 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH10 = (1U << 10);  ///< Channel 10 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH11 = (1U << 11);  ///< Channel 11 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH12 = (1U << 12);  ///< Channel 12 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH13 = (1U << 13);  ///< Channel 13 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH14 = (1U << 14);  ///< Channel 14 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH15 = (1U << 15);  ///< Channel 15 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH16 = (1U << 16);  ///< Channel 16 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH17 = (1U << 17);  ///< Channel 17 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH18 = (1U << 18);  ///< Channel 18 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH19 = (1U << 19);  ///< Channel 19 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH20 = (1U << 20);  ///< Channel 20 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH21 = (1U << 21);  ///< Channel 21 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH22 = (1U << 22);  ///< Channel 22 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH23 = (1U << 23);  ///< Channel 23 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH24 = (1U << 24);  ///< Channel 24 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH25 = (1U << 25);  ///< Channel 25 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH26 = (1U << 26);  ///< Channel 26 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH27 = (1U << 27);  ///< Channel 27 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH28 = (1U << 28);  ///< Channel 28 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH29 = (1U << 29);  ///< Channel 29 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH30 = (1U << 30);  ///< Channel 30 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH31 = (1U << 31);  ///< Channel 31 enable clear register. Writing '0' has no effect
    }

    /// EEP Register bits
    namespace eep_bits {
        constexpr uint32_t EEP = (32 << 0);  ///< Pointer to event register. Accepts only addresses to registers from the Event group.
    }

    /// TEP Register bits
    namespace tep_bits {
        constexpr uint32_t TEP = (32 << 0);  ///< Pointer to task register
    }

    /// CHG__ Register bits
    namespace chg___bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Include or exclude channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Include or exclude channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Include or exclude channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Include or exclude channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Include or exclude channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Include or exclude channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Include or exclude channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Include or exclude channel 7
        constexpr uint32_t CH8 = (1U << 8);  ///< Include or exclude channel 8
        constexpr uint32_t CH9 = (1U << 9);  ///< Include or exclude channel 9
        constexpr uint32_t CH10 = (1U << 10);  ///< Include or exclude channel 10
        constexpr uint32_t CH11 = (1U << 11);  ///< Include or exclude channel 11
        constexpr uint32_t CH12 = (1U << 12);  ///< Include or exclude channel 12
        constexpr uint32_t CH13 = (1U << 13);  ///< Include or exclude channel 13
        constexpr uint32_t CH14 = (1U << 14);  ///< Include or exclude channel 14
        constexpr uint32_t CH15 = (1U << 15);  ///< Include or exclude channel 15
        constexpr uint32_t CH16 = (1U << 16);  ///< Include or exclude channel 16
        constexpr uint32_t CH17 = (1U << 17);  ///< Include or exclude channel 17
        constexpr uint32_t CH18 = (1U << 18);  ///< Include or exclude channel 18
        constexpr uint32_t CH19 = (1U << 19);  ///< Include or exclude channel 19
        constexpr uint32_t CH20 = (1U << 20);  ///< Include or exclude channel 20
        constexpr uint32_t CH21 = (1U << 21);  ///< Include or exclude channel 21
        constexpr uint32_t CH22 = (1U << 22);  ///< Include or exclude channel 22
        constexpr uint32_t CH23 = (1U << 23);  ///< Include or exclude channel 23
        constexpr uint32_t CH24 = (1U << 24);  ///< Include or exclude channel 24
        constexpr uint32_t CH25 = (1U << 25);  ///< Include or exclude channel 25
        constexpr uint32_t CH26 = (1U << 26);  ///< Include or exclude channel 26
        constexpr uint32_t CH27 = (1U << 27);  ///< Include or exclude channel 27
        constexpr uint32_t CH28 = (1U << 28);  ///< Include or exclude channel 28
        constexpr uint32_t CH29 = (1U << 29);  ///< Include or exclude channel 29
        constexpr uint32_t CH30 = (1U << 30);  ///< Include or exclude channel 30
        constexpr uint32_t CH31 = (1U << 31);  ///< Include or exclude channel 31
    }

}

// ============================================================================
// MWU Peripheral
// ============================================================================

namespace mwu {
    /// Base addresses
    constexpr uint32_t MWU_BASE = 0x40020000;

    /// MWU Register structure
    struct Registers {
        volatile uint32_t WA;  ///< Offset: 0x00 - Description cluster: Write access to peripheral region n detected
        volatile uint32_t RA;  ///< Offset: 0x04 - Description cluster: Read access to peripheral region n detected
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t NMIEN;  ///< Offset: 0x320 - Enable or disable interrupt
        volatile uint32_t NMIENSET;  ///< Offset: 0x324 - Enable interrupt
        volatile uint32_t NMIENCLR;  ///< Offset: 0x328 - Disable interrupt
        volatile uint32_t SUBSTATWA;  ///< Offset: 0x00 - Description cluster: Source of event/interrupt in region...
        volatile uint32_t SUBSTATRA;  ///< Offset: 0x04 - Description cluster: Source of event/interrupt in region...
        volatile uint32_t REGIONEN;  ///< Offset: 0x510 - Enable/disable regions watch
        volatile uint32_t REGIONENSET;  ///< Offset: 0x514 - Enable regions watch
        volatile uint32_t REGIONENCLR;  ///< Offset: 0x518 - Disable regions watch
        volatile uint32_t START;  ///< Offset: 0x00 - Description cluster: Reserved for future use
        volatile uint32_t END;  ///< Offset: 0x04 - Description cluster: Reserved for future use
        volatile uint32_t SUBS;  ///< Offset: 0x08 - Description cluster: Subregions of region n
    };

    /// Peripheral instances
    inline Registers* MWU = reinterpret_cast<Registers*>(MWU_BASE);

    // Bit definitions
    /// WA Register bits
    namespace wa_bits {
        constexpr uint32_t WA = (1U << 0);  ///< Write access to peripheral region n detected
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RA = (1U << 0);  ///< Read access to peripheral region n detected
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t REGION0WA = (1U << 0);  ///< Enable or disable interrupt for event REGION0WA
        constexpr uint32_t REGION0RA = (1U << 1);  ///< Enable or disable interrupt for event REGION0RA
        constexpr uint32_t REGION1WA = (1U << 2);  ///< Enable or disable interrupt for event REGION1WA
        constexpr uint32_t REGION1RA = (1U << 3);  ///< Enable or disable interrupt for event REGION1RA
        constexpr uint32_t REGION2WA = (1U << 4);  ///< Enable or disable interrupt for event REGION2WA
        constexpr uint32_t REGION2RA = (1U << 5);  ///< Enable or disable interrupt for event REGION2RA
        constexpr uint32_t REGION3WA = (1U << 6);  ///< Enable or disable interrupt for event REGION3WA
        constexpr uint32_t REGION3RA = (1U << 7);  ///< Enable or disable interrupt for event REGION3RA
        constexpr uint32_t PREGION0WA = (1U << 24);  ///< Enable or disable interrupt for event PREGION0WA
        constexpr uint32_t PREGION0RA = (1U << 25);  ///< Enable or disable interrupt for event PREGION0RA
        constexpr uint32_t PREGION1WA = (1U << 26);  ///< Enable or disable interrupt for event PREGION1WA
        constexpr uint32_t PREGION1RA = (1U << 27);  ///< Enable or disable interrupt for event PREGION1RA
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t REGION0WA = (1U << 0);  ///< Write '1' to enable interrupt for event REGION0WA
        constexpr uint32_t REGION0RA = (1U << 1);  ///< Write '1' to enable interrupt for event REGION0RA
        constexpr uint32_t REGION1WA = (1U << 2);  ///< Write '1' to enable interrupt for event REGION1WA
        constexpr uint32_t REGION1RA = (1U << 3);  ///< Write '1' to enable interrupt for event REGION1RA
        constexpr uint32_t REGION2WA = (1U << 4);  ///< Write '1' to enable interrupt for event REGION2WA
        constexpr uint32_t REGION2RA = (1U << 5);  ///< Write '1' to enable interrupt for event REGION2RA
        constexpr uint32_t REGION3WA = (1U << 6);  ///< Write '1' to enable interrupt for event REGION3WA
        constexpr uint32_t REGION3RA = (1U << 7);  ///< Write '1' to enable interrupt for event REGION3RA
        constexpr uint32_t PREGION0WA = (1U << 24);  ///< Write '1' to enable interrupt for event PREGION0WA
        constexpr uint32_t PREGION0RA = (1U << 25);  ///< Write '1' to enable interrupt for event PREGION0RA
        constexpr uint32_t PREGION1WA = (1U << 26);  ///< Write '1' to enable interrupt for event PREGION1WA
        constexpr uint32_t PREGION1RA = (1U << 27);  ///< Write '1' to enable interrupt for event PREGION1RA
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t REGION0WA = (1U << 0);  ///< Write '1' to disable interrupt for event REGION0WA
        constexpr uint32_t REGION0RA = (1U << 1);  ///< Write '1' to disable interrupt for event REGION0RA
        constexpr uint32_t REGION1WA = (1U << 2);  ///< Write '1' to disable interrupt for event REGION1WA
        constexpr uint32_t REGION1RA = (1U << 3);  ///< Write '1' to disable interrupt for event REGION1RA
        constexpr uint32_t REGION2WA = (1U << 4);  ///< Write '1' to disable interrupt for event REGION2WA
        constexpr uint32_t REGION2RA = (1U << 5);  ///< Write '1' to disable interrupt for event REGION2RA
        constexpr uint32_t REGION3WA = (1U << 6);  ///< Write '1' to disable interrupt for event REGION3WA
        constexpr uint32_t REGION3RA = (1U << 7);  ///< Write '1' to disable interrupt for event REGION3RA
        constexpr uint32_t PREGION0WA = (1U << 24);  ///< Write '1' to disable interrupt for event PREGION0WA
        constexpr uint32_t PREGION0RA = (1U << 25);  ///< Write '1' to disable interrupt for event PREGION0RA
        constexpr uint32_t PREGION1WA = (1U << 26);  ///< Write '1' to disable interrupt for event PREGION1WA
        constexpr uint32_t PREGION1RA = (1U << 27);  ///< Write '1' to disable interrupt for event PREGION1RA
    }

    /// NMIEN Register bits
    namespace nmien_bits {
        constexpr uint32_t REGION0WA = (1U << 0);  ///< Enable or disable interrupt for event REGION0WA
        constexpr uint32_t REGION0RA = (1U << 1);  ///< Enable or disable interrupt for event REGION0RA
        constexpr uint32_t REGION1WA = (1U << 2);  ///< Enable or disable interrupt for event REGION1WA
        constexpr uint32_t REGION1RA = (1U << 3);  ///< Enable or disable interrupt for event REGION1RA
        constexpr uint32_t REGION2WA = (1U << 4);  ///< Enable or disable interrupt for event REGION2WA
        constexpr uint32_t REGION2RA = (1U << 5);  ///< Enable or disable interrupt for event REGION2RA
        constexpr uint32_t REGION3WA = (1U << 6);  ///< Enable or disable interrupt for event REGION3WA
        constexpr uint32_t REGION3RA = (1U << 7);  ///< Enable or disable interrupt for event REGION3RA
        constexpr uint32_t PREGION0WA = (1U << 24);  ///< Enable or disable interrupt for event PREGION0WA
        constexpr uint32_t PREGION0RA = (1U << 25);  ///< Enable or disable interrupt for event PREGION0RA
        constexpr uint32_t PREGION1WA = (1U << 26);  ///< Enable or disable interrupt for event PREGION1WA
        constexpr uint32_t PREGION1RA = (1U << 27);  ///< Enable or disable interrupt for event PREGION1RA
    }

    /// NMIENSET Register bits
    namespace nmienset_bits {
        constexpr uint32_t REGION0WA = (1U << 0);  ///< Write '1' to enable interrupt for event REGION0WA
        constexpr uint32_t REGION0RA = (1U << 1);  ///< Write '1' to enable interrupt for event REGION0RA
        constexpr uint32_t REGION1WA = (1U << 2);  ///< Write '1' to enable interrupt for event REGION1WA
        constexpr uint32_t REGION1RA = (1U << 3);  ///< Write '1' to enable interrupt for event REGION1RA
        constexpr uint32_t REGION2WA = (1U << 4);  ///< Write '1' to enable interrupt for event REGION2WA
        constexpr uint32_t REGION2RA = (1U << 5);  ///< Write '1' to enable interrupt for event REGION2RA
        constexpr uint32_t REGION3WA = (1U << 6);  ///< Write '1' to enable interrupt for event REGION3WA
        constexpr uint32_t REGION3RA = (1U << 7);  ///< Write '1' to enable interrupt for event REGION3RA
        constexpr uint32_t PREGION0WA = (1U << 24);  ///< Write '1' to enable interrupt for event PREGION0WA
        constexpr uint32_t PREGION0RA = (1U << 25);  ///< Write '1' to enable interrupt for event PREGION0RA
        constexpr uint32_t PREGION1WA = (1U << 26);  ///< Write '1' to enable interrupt for event PREGION1WA
        constexpr uint32_t PREGION1RA = (1U << 27);  ///< Write '1' to enable interrupt for event PREGION1RA
    }

    /// NMIENCLR Register bits
    namespace nmienclr_bits {
        constexpr uint32_t REGION0WA = (1U << 0);  ///< Write '1' to disable interrupt for event REGION0WA
        constexpr uint32_t REGION0RA = (1U << 1);  ///< Write '1' to disable interrupt for event REGION0RA
        constexpr uint32_t REGION1WA = (1U << 2);  ///< Write '1' to disable interrupt for event REGION1WA
        constexpr uint32_t REGION1RA = (1U << 3);  ///< Write '1' to disable interrupt for event REGION1RA
        constexpr uint32_t REGION2WA = (1U << 4);  ///< Write '1' to disable interrupt for event REGION2WA
        constexpr uint32_t REGION2RA = (1U << 5);  ///< Write '1' to disable interrupt for event REGION2RA
        constexpr uint32_t REGION3WA = (1U << 6);  ///< Write '1' to disable interrupt for event REGION3WA
        constexpr uint32_t REGION3RA = (1U << 7);  ///< Write '1' to disable interrupt for event REGION3RA
        constexpr uint32_t PREGION0WA = (1U << 24);  ///< Write '1' to disable interrupt for event PREGION0WA
        constexpr uint32_t PREGION0RA = (1U << 25);  ///< Write '1' to disable interrupt for event PREGION0RA
        constexpr uint32_t PREGION1WA = (1U << 26);  ///< Write '1' to disable interrupt for event PREGION1WA
        constexpr uint32_t PREGION1RA = (1U << 27);  ///< Write '1' to disable interrupt for event PREGION1RA
    }

    /// SUBSTATWA Register bits
    namespace substatwa_bits {
        constexpr uint32_t SR0 = (1U << 0);  ///< Subregion 0 in region n (write '1' to clear)
        constexpr uint32_t SR1 = (1U << 1);  ///< Subregion 1 in region n (write '1' to clear)
        constexpr uint32_t SR2 = (1U << 2);  ///< Subregion 2 in region n (write '1' to clear)
        constexpr uint32_t SR3 = (1U << 3);  ///< Subregion 3 in region n (write '1' to clear)
        constexpr uint32_t SR4 = (1U << 4);  ///< Subregion 4 in region n (write '1' to clear)
        constexpr uint32_t SR5 = (1U << 5);  ///< Subregion 5 in region n (write '1' to clear)
        constexpr uint32_t SR6 = (1U << 6);  ///< Subregion 6 in region n (write '1' to clear)
        constexpr uint32_t SR7 = (1U << 7);  ///< Subregion 7 in region n (write '1' to clear)
        constexpr uint32_t SR8 = (1U << 8);  ///< Subregion 8 in region n (write '1' to clear)
        constexpr uint32_t SR9 = (1U << 9);  ///< Subregion 9 in region n (write '1' to clear)
        constexpr uint32_t SR10 = (1U << 10);  ///< Subregion 10 in region n (write '1' to clear)
        constexpr uint32_t SR11 = (1U << 11);  ///< Subregion 11 in region n (write '1' to clear)
        constexpr uint32_t SR12 = (1U << 12);  ///< Subregion 12 in region n (write '1' to clear)
        constexpr uint32_t SR13 = (1U << 13);  ///< Subregion 13 in region n (write '1' to clear)
        constexpr uint32_t SR14 = (1U << 14);  ///< Subregion 14 in region n (write '1' to clear)
        constexpr uint32_t SR15 = (1U << 15);  ///< Subregion 15 in region n (write '1' to clear)
        constexpr uint32_t SR16 = (1U << 16);  ///< Subregion 16 in region n (write '1' to clear)
        constexpr uint32_t SR17 = (1U << 17);  ///< Subregion 17 in region n (write '1' to clear)
        constexpr uint32_t SR18 = (1U << 18);  ///< Subregion 18 in region n (write '1' to clear)
        constexpr uint32_t SR19 = (1U << 19);  ///< Subregion 19 in region n (write '1' to clear)
        constexpr uint32_t SR20 = (1U << 20);  ///< Subregion 20 in region n (write '1' to clear)
        constexpr uint32_t SR21 = (1U << 21);  ///< Subregion 21 in region n (write '1' to clear)
        constexpr uint32_t SR22 = (1U << 22);  ///< Subregion 22 in region n (write '1' to clear)
        constexpr uint32_t SR23 = (1U << 23);  ///< Subregion 23 in region n (write '1' to clear)
        constexpr uint32_t SR24 = (1U << 24);  ///< Subregion 24 in region n (write '1' to clear)
        constexpr uint32_t SR25 = (1U << 25);  ///< Subregion 25 in region n (write '1' to clear)
        constexpr uint32_t SR26 = (1U << 26);  ///< Subregion 26 in region n (write '1' to clear)
        constexpr uint32_t SR27 = (1U << 27);  ///< Subregion 27 in region n (write '1' to clear)
        constexpr uint32_t SR28 = (1U << 28);  ///< Subregion 28 in region n (write '1' to clear)
        constexpr uint32_t SR29 = (1U << 29);  ///< Subregion 29 in region n (write '1' to clear)
        constexpr uint32_t SR30 = (1U << 30);  ///< Subregion 30 in region n (write '1' to clear)
        constexpr uint32_t SR31 = (1U << 31);  ///< Subregion 31 in region n (write '1' to clear)
    }

    /// SUBSTATRA Register bits
    namespace substatra_bits {
        constexpr uint32_t SR0 = (1U << 0);  ///< Subregion 0 in region n (write '1' to clear)
        constexpr uint32_t SR1 = (1U << 1);  ///< Subregion 1 in region n (write '1' to clear)
        constexpr uint32_t SR2 = (1U << 2);  ///< Subregion 2 in region n (write '1' to clear)
        constexpr uint32_t SR3 = (1U << 3);  ///< Subregion 3 in region n (write '1' to clear)
        constexpr uint32_t SR4 = (1U << 4);  ///< Subregion 4 in region n (write '1' to clear)
        constexpr uint32_t SR5 = (1U << 5);  ///< Subregion 5 in region n (write '1' to clear)
        constexpr uint32_t SR6 = (1U << 6);  ///< Subregion 6 in region n (write '1' to clear)
        constexpr uint32_t SR7 = (1U << 7);  ///< Subregion 7 in region n (write '1' to clear)
        constexpr uint32_t SR8 = (1U << 8);  ///< Subregion 8 in region n (write '1' to clear)
        constexpr uint32_t SR9 = (1U << 9);  ///< Subregion 9 in region n (write '1' to clear)
        constexpr uint32_t SR10 = (1U << 10);  ///< Subregion 10 in region n (write '1' to clear)
        constexpr uint32_t SR11 = (1U << 11);  ///< Subregion 11 in region n (write '1' to clear)
        constexpr uint32_t SR12 = (1U << 12);  ///< Subregion 12 in region n (write '1' to clear)
        constexpr uint32_t SR13 = (1U << 13);  ///< Subregion 13 in region n (write '1' to clear)
        constexpr uint32_t SR14 = (1U << 14);  ///< Subregion 14 in region n (write '1' to clear)
        constexpr uint32_t SR15 = (1U << 15);  ///< Subregion 15 in region n (write '1' to clear)
        constexpr uint32_t SR16 = (1U << 16);  ///< Subregion 16 in region n (write '1' to clear)
        constexpr uint32_t SR17 = (1U << 17);  ///< Subregion 17 in region n (write '1' to clear)
        constexpr uint32_t SR18 = (1U << 18);  ///< Subregion 18 in region n (write '1' to clear)
        constexpr uint32_t SR19 = (1U << 19);  ///< Subregion 19 in region n (write '1' to clear)
        constexpr uint32_t SR20 = (1U << 20);  ///< Subregion 20 in region n (write '1' to clear)
        constexpr uint32_t SR21 = (1U << 21);  ///< Subregion 21 in region n (write '1' to clear)
        constexpr uint32_t SR22 = (1U << 22);  ///< Subregion 22 in region n (write '1' to clear)
        constexpr uint32_t SR23 = (1U << 23);  ///< Subregion 23 in region n (write '1' to clear)
        constexpr uint32_t SR24 = (1U << 24);  ///< Subregion 24 in region n (write '1' to clear)
        constexpr uint32_t SR25 = (1U << 25);  ///< Subregion 25 in region n (write '1' to clear)
        constexpr uint32_t SR26 = (1U << 26);  ///< Subregion 26 in region n (write '1' to clear)
        constexpr uint32_t SR27 = (1U << 27);  ///< Subregion 27 in region n (write '1' to clear)
        constexpr uint32_t SR28 = (1U << 28);  ///< Subregion 28 in region n (write '1' to clear)
        constexpr uint32_t SR29 = (1U << 29);  ///< Subregion 29 in region n (write '1' to clear)
        constexpr uint32_t SR30 = (1U << 30);  ///< Subregion 30 in region n (write '1' to clear)
        constexpr uint32_t SR31 = (1U << 31);  ///< Subregion 31 in region n (write '1' to clear)
    }

    /// REGIONEN Register bits
    namespace regionen_bits {
        constexpr uint32_t RGN0WA = (1U << 0);  ///< Enable/disable write access watch in region[0]
        constexpr uint32_t RGN0RA = (1U << 1);  ///< Enable/disable read access watch in region[0]
        constexpr uint32_t RGN1WA = (1U << 2);  ///< Enable/disable write access watch in region[1]
        constexpr uint32_t RGN1RA = (1U << 3);  ///< Enable/disable read access watch in region[1]
        constexpr uint32_t RGN2WA = (1U << 4);  ///< Enable/disable write access watch in region[2]
        constexpr uint32_t RGN2RA = (1U << 5);  ///< Enable/disable read access watch in region[2]
        constexpr uint32_t RGN3WA = (1U << 6);  ///< Enable/disable write access watch in region[3]
        constexpr uint32_t RGN3RA = (1U << 7);  ///< Enable/disable read access watch in region[3]
        constexpr uint32_t PRGN0WA = (1U << 24);  ///< Enable/disable write access watch in PREGION[0]
        constexpr uint32_t PRGN0RA = (1U << 25);  ///< Enable/disable read access watch in PREGION[0]
        constexpr uint32_t PRGN1WA = (1U << 26);  ///< Enable/disable write access watch in PREGION[1]
        constexpr uint32_t PRGN1RA = (1U << 27);  ///< Enable/disable read access watch in PREGION[1]
    }

    /// REGIONENSET Register bits
    namespace regionenset_bits {
        constexpr uint32_t RGN0WA = (1U << 0);  ///< Enable write access watch in region[0]
        constexpr uint32_t RGN0RA = (1U << 1);  ///< Enable read access watch in region[0]
        constexpr uint32_t RGN1WA = (1U << 2);  ///< Enable write access watch in region[1]
        constexpr uint32_t RGN1RA = (1U << 3);  ///< Enable read access watch in region[1]
        constexpr uint32_t RGN2WA = (1U << 4);  ///< Enable write access watch in region[2]
        constexpr uint32_t RGN2RA = (1U << 5);  ///< Enable read access watch in region[2]
        constexpr uint32_t RGN3WA = (1U << 6);  ///< Enable write access watch in region[3]
        constexpr uint32_t RGN3RA = (1U << 7);  ///< Enable read access watch in region[3]
        constexpr uint32_t PRGN0WA = (1U << 24);  ///< Enable write access watch in PREGION[0]
        constexpr uint32_t PRGN0RA = (1U << 25);  ///< Enable read access watch in PREGION[0]
        constexpr uint32_t PRGN1WA = (1U << 26);  ///< Enable write access watch in PREGION[1]
        constexpr uint32_t PRGN1RA = (1U << 27);  ///< Enable read access watch in PREGION[1]
    }

    /// REGIONENCLR Register bits
    namespace regionenclr_bits {
        constexpr uint32_t RGN0WA = (1U << 0);  ///< Disable write access watch in region[0]
        constexpr uint32_t RGN0RA = (1U << 1);  ///< Disable read access watch in region[0]
        constexpr uint32_t RGN1WA = (1U << 2);  ///< Disable write access watch in region[1]
        constexpr uint32_t RGN1RA = (1U << 3);  ///< Disable read access watch in region[1]
        constexpr uint32_t RGN2WA = (1U << 4);  ///< Disable write access watch in region[2]
        constexpr uint32_t RGN2RA = (1U << 5);  ///< Disable read access watch in region[2]
        constexpr uint32_t RGN3WA = (1U << 6);  ///< Disable write access watch in region[3]
        constexpr uint32_t RGN3RA = (1U << 7);  ///< Disable read access watch in region[3]
        constexpr uint32_t PRGN0WA = (1U << 24);  ///< Disable write access watch in PREGION[0]
        constexpr uint32_t PRGN0RA = (1U << 25);  ///< Disable read access watch in PREGION[0]
        constexpr uint32_t PRGN1WA = (1U << 26);  ///< Disable write access watch in PREGION[1]
        constexpr uint32_t PRGN1RA = (1U << 27);  ///< Disable read access watch in PREGION[1]
    }

    /// START Register bits
    namespace start_bits {
        constexpr uint32_t START = (32 << 0);  ///< Reserved for future use
    }

    /// END Register bits
    namespace end_bits {
        constexpr uint32_t END = (32 << 0);  ///< Reserved for future use
    }

    /// SUBS Register bits
    namespace subs_bits {
        constexpr uint32_t SR0 = (1U << 0);  ///< Include or exclude subregion 0 in region
        constexpr uint32_t SR1 = (1U << 1);  ///< Include or exclude subregion 1 in region
        constexpr uint32_t SR2 = (1U << 2);  ///< Include or exclude subregion 2 in region
        constexpr uint32_t SR3 = (1U << 3);  ///< Include or exclude subregion 3 in region
        constexpr uint32_t SR4 = (1U << 4);  ///< Include or exclude subregion 4 in region
        constexpr uint32_t SR5 = (1U << 5);  ///< Include or exclude subregion 5 in region
        constexpr uint32_t SR6 = (1U << 6);  ///< Include or exclude subregion 6 in region
        constexpr uint32_t SR7 = (1U << 7);  ///< Include or exclude subregion 7 in region
        constexpr uint32_t SR8 = (1U << 8);  ///< Include or exclude subregion 8 in region
        constexpr uint32_t SR9 = (1U << 9);  ///< Include or exclude subregion 9 in region
        constexpr uint32_t SR10 = (1U << 10);  ///< Include or exclude subregion 10 in region
        constexpr uint32_t SR11 = (1U << 11);  ///< Include or exclude subregion 11 in region
        constexpr uint32_t SR12 = (1U << 12);  ///< Include or exclude subregion 12 in region
        constexpr uint32_t SR13 = (1U << 13);  ///< Include or exclude subregion 13 in region
        constexpr uint32_t SR14 = (1U << 14);  ///< Include or exclude subregion 14 in region
        constexpr uint32_t SR15 = (1U << 15);  ///< Include or exclude subregion 15 in region
        constexpr uint32_t SR16 = (1U << 16);  ///< Include or exclude subregion 16 in region
        constexpr uint32_t SR17 = (1U << 17);  ///< Include or exclude subregion 17 in region
        constexpr uint32_t SR18 = (1U << 18);  ///< Include or exclude subregion 18 in region
        constexpr uint32_t SR19 = (1U << 19);  ///< Include or exclude subregion 19 in region
        constexpr uint32_t SR20 = (1U << 20);  ///< Include or exclude subregion 20 in region
        constexpr uint32_t SR21 = (1U << 21);  ///< Include or exclude subregion 21 in region
        constexpr uint32_t SR22 = (1U << 22);  ///< Include or exclude subregion 22 in region
        constexpr uint32_t SR23 = (1U << 23);  ///< Include or exclude subregion 23 in region
        constexpr uint32_t SR24 = (1U << 24);  ///< Include or exclude subregion 24 in region
        constexpr uint32_t SR25 = (1U << 25);  ///< Include or exclude subregion 25 in region
        constexpr uint32_t SR26 = (1U << 26);  ///< Include or exclude subregion 26 in region
        constexpr uint32_t SR27 = (1U << 27);  ///< Include or exclude subregion 27 in region
        constexpr uint32_t SR28 = (1U << 28);  ///< Include or exclude subregion 28 in region
        constexpr uint32_t SR29 = (1U << 29);  ///< Include or exclude subregion 29 in region
        constexpr uint32_t SR30 = (1U << 30);  ///< Include or exclude subregion 30 in region
        constexpr uint32_t SR31 = (1U << 31);  ///< Include or exclude subregion 31 in region
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S_BASE = 0x40025000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Starts continuous I2S transfer. Also starts MCK...
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stops I2S transfer. Also stops MCK generator. Triggering...
        volatile uint32_t EVENTS_RXPTRUPD;  ///< Offset: 0x104 - The RXD.PTR register has been copied to internal...
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x108 - I2S transfer stopped.
        volatile uint32_t EVENTS_TXPTRUPD;  ///< Offset: 0x114 - The TDX.PTR register has been copied to internal...
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable I2S module.
        volatile uint32_t MODE;  ///< Offset: 0x00 - I2S mode.
        volatile uint32_t RXEN;  ///< Offset: 0x04 - Reception (RX) enable.
        volatile uint32_t TXEN;  ///< Offset: 0x08 - Transmission (TX) enable.
        volatile uint32_t MCKEN;  ///< Offset: 0x0C - Master clock generator enable.
        volatile uint32_t MCKFREQ;  ///< Offset: 0x10 - Master clock generator frequency.
        volatile uint32_t RATIO;  ///< Offset: 0x14 - MCK / LRCK ratio.
        volatile uint32_t SWIDTH;  ///< Offset: 0x18 - Sample width.
        volatile uint32_t ALIGN;  ///< Offset: 0x1C - Alignment of sample within a frame.
        volatile uint32_t FORMAT;  ///< Offset: 0x20 - Frame format.
        volatile uint32_t CHANNELS;  ///< Offset: 0x24 - Enable channels.
        volatile uint32_t PTR;  ///< Offset: 0x00 - Transmit buffer RAM start address.
        volatile uint32_t MAXCNT;  ///< Offset: 0x00 - Size of RXD and TXD buffers.
        volatile uint32_t MCK;  ///< Offset: 0x00 - Pin select for MCK signal.
        volatile uint32_t SCK;  ///< Offset: 0x04 - Pin select for SCK signal.
        volatile uint32_t LRCK;  ///< Offset: 0x08 - Pin select for LRCK signal.
        volatile uint32_t SDIN;  ///< Offset: 0x0C - Pin select for SDIN signal.
        volatile uint32_t SDOUT;  ///< Offset: 0x10 - Pin select for SDOUT signal.
    };

    /// Peripheral instances
    inline Registers* I2S = reinterpret_cast<Registers*>(I2S_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Starts continuous I2S transfer. Also starts MCK generator when this is enabled.
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stops I2S transfer. Also stops MCK generator. Triggering this task will cause the STOPPED event to be generated.
    }

    /// EVENTS_RXPTRUPD Register bits
    namespace events_rxptrupd_bits {
        constexpr uint32_t EVENTS_RXPTRUPD = (1U << 0);  ///< The RXD.PTR register has been copied to internal double-buffers. When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words that are received on the SDIN pin.
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< I2S transfer stopped.
    }

    /// EVENTS_TXPTRUPD Register bits
    namespace events_txptrupd_bits {
        constexpr uint32_t EVENTS_TXPTRUPD = (1U << 0);  ///< The TDX.PTR register has been copied to internal double-buffers. When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin.
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t RXPTRUPD = (1U << 1);  ///< Enable or disable interrupt for event RXPTRUPD
        constexpr uint32_t STOPPED = (1U << 2);  ///< Enable or disable interrupt for event STOPPED
        constexpr uint32_t TXPTRUPD = (1U << 5);  ///< Enable or disable interrupt for event TXPTRUPD
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t RXPTRUPD = (1U << 1);  ///< Write '1' to enable interrupt for event RXPTRUPD
        constexpr uint32_t STOPPED = (1U << 2);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t TXPTRUPD = (1U << 5);  ///< Write '1' to enable interrupt for event TXPTRUPD
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t RXPTRUPD = (1U << 1);  ///< Write '1' to disable interrupt for event RXPTRUPD
        constexpr uint32_t STOPPED = (1U << 2);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t TXPTRUPD = (1U << 5);  ///< Write '1' to disable interrupt for event TXPTRUPD
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable I2S module.
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< I2S mode.
    }

    /// RXEN Register bits
    namespace rxen_bits {
        constexpr uint32_t RXEN = (1U << 0);  ///< Reception (RX) enable.
    }

    /// TXEN Register bits
    namespace txen_bits {
        constexpr uint32_t TXEN = (1U << 0);  ///< Transmission (TX) enable.
    }

    /// MCKEN Register bits
    namespace mcken_bits {
        constexpr uint32_t MCKEN = (1U << 0);  ///< Master clock generator enable.
    }

    /// MCKFREQ Register bits
    namespace mckfreq_bits {
        constexpr uint32_t MCKFREQ = (32 << 0);  ///< Master clock generator frequency.
    }

    /// RATIO Register bits
    namespace ratio_bits {
        constexpr uint32_t RATIO = (4 << 0);  ///< MCK / LRCK ratio.
    }

    /// SWIDTH Register bits
    namespace swidth_bits {
        constexpr uint32_t SWIDTH = (2 << 0);  ///< Sample width.
    }

    /// ALIGN Register bits
    namespace align_bits {
        constexpr uint32_t ALIGN = (1U << 0);  ///< Alignment of sample within a frame.
    }

    /// FORMAT Register bits
    namespace format_bits {
        constexpr uint32_t FORMAT = (1U << 0);  ///< Frame format.
    }

    /// CHANNELS Register bits
    namespace channels_bits {
        constexpr uint32_t CHANNELS = (2 << 0);  ///< Enable channels.
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Transmit buffer Data RAM start address. When transmitting, words containing samples will be fetched from this address. This address is a word aligned Data RAM address.
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t MAXCNT = (14 << 0);  ///< Size of RXD and TXD buffers in number of 32 bit words.
    }

    /// MCK Register bits
    namespace mck_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// SCK Register bits
    namespace sck_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// LRCK Register bits
    namespace lrck_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// SDIN Register bits
    namespace sdin_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// SDOUT Register bits
    namespace sdout_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

}

// ============================================================================
// FPU Peripheral
// ============================================================================

namespace fpu {
    /// Base addresses
    constexpr uint32_t FPU_BASE = 0x40026000;

    /// FPU Register structure
    struct Registers {
        volatile uint32_t UNUSED;  ///< Offset: 0x00 - Unused.
    };

    /// Peripheral instances
    inline Registers* FPU = reinterpret_cast<Registers*>(FPU_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USBD_BASE = 0x40027000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTEPIN__;  ///< Offset: 0x04 - Description collection: Captures the EPIN[n].PTR and... (renamed from TASKS_STARTEPIN__)
        volatile uint32_t TASKS_STARTISOIN;  ///< Offset: 0x24 - Captures the ISOIN.PTR and ISOIN.MAXCNT registers...
        volatile uint32_t TASKS_STARTEPOUT__;  ///< Offset: 0x28 - Description collection: Captures the EPOUT[n].PTR and... (renamed from TASKS_STARTEPOUT__)
        volatile uint32_t TASKS_STARTISOOUT;  ///< Offset: 0x48 - Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers...
        volatile uint32_t TASKS_EP0RCVOUT;  ///< Offset: 0x4C - Allows OUT data stage on control endpoint 0
        volatile uint32_t TASKS_EP0STATUS;  ///< Offset: 0x50 - Allows status stage on control endpoint 0
        volatile uint32_t TASKS_EP0STALL;  ///< Offset: 0x54 - Stalls data and status stage on control endpoint 0
        volatile uint32_t TASKS_DPDMDRIVE;  ///< Offset: 0x58 - Forces D+ and D- lines into the state defined in the...
        volatile uint32_t TASKS_DPDMNODRIVE;  ///< Offset: 0x5C - Stops forcing D+ and D- lines into any state (USB engine...
        volatile uint32_t EVENTS_USBRESET;  ///< Offset: 0x100 - Signals that a USB reset condition has been detected on USB lines
        volatile uint32_t EVENTS_STARTED;  ///< Offset: 0x104 - Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or...
        volatile uint32_t EVENTS_ENDEPIN__;  ///< Offset: 0x108 - Description collection: The whole EPIN[n] buffer has... (renamed from EVENTS_ENDEPIN__)
        volatile uint32_t EVENTS_EP0DATADONE;  ///< Offset: 0x128 - An acknowledged data transfer has taken place on the...
        volatile uint32_t EVENTS_ENDISOIN;  ///< Offset: 0x12C - The whole ISOIN buffer has been consumed. The RAM buffer...
        volatile uint32_t EVENTS_ENDEPOUT__;  ///< Offset: 0x130 - Description collection: The whole EPOUT[n] buffer has... (renamed from EVENTS_ENDEPOUT__)
        volatile uint32_t EVENTS_ENDISOOUT;  ///< Offset: 0x150 - The whole ISOOUT buffer has been consumed. The RAM...
        volatile uint32_t EVENTS_SOF;  ///< Offset: 0x154 - Signals that a SOF (start of frame) condition has been...
        volatile uint32_t EVENTS_USBEVENT;  ///< Offset: 0x158 - An event or an error not covered by specific events has...
        volatile uint32_t EVENTS_EP0SETUP;  ///< Offset: 0x15C - A valid SETUP token has been received (and acknowledged)...
        volatile uint32_t EVENTS_EPDATA;  ///< Offset: 0x160 - A data transfer has occurred on a data endpoint,...
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t EVENTCAUSE;  ///< Offset: 0x400 - Details on what caused the USBEVENT event
        volatile uint32_t EPIN__;  ///< Offset: 0x00 - Description collection: IN endpoint halted status. Can... (renamed from EPIN__)
        volatile uint32_t EPOUT__;  ///< Offset: 0x00 - Description collection: Number of bytes received last in... (renamed from EPOUT__)
        volatile uint32_t EPSTATUS;  ///< Offset: 0x468 - Provides information on which endpoint's EasyDMA...
        volatile uint32_t EPDATASTATUS;  ///< Offset: 0x46C - Provides information on which endpoint(s) an...
        volatile uint32_t USBADDR;  ///< Offset: 0x470 - Device USB address
        volatile uint32_t BMREQUESTTYPE;  ///< Offset: 0x480 - SETUP data, byte 0, bmRequestType
        volatile uint32_t BREQUEST;  ///< Offset: 0x484 - SETUP data, byte 1, bRequest
        volatile uint32_t WVALUEL;  ///< Offset: 0x488 - SETUP data, byte 2, LSB of wValue
        volatile uint32_t WVALUEH;  ///< Offset: 0x48C - SETUP data, byte 3, MSB of wValue
        volatile uint32_t WINDEXL;  ///< Offset: 0x490 - SETUP data, byte 4, LSB of wIndex
        volatile uint32_t WINDEXH;  ///< Offset: 0x494 - SETUP data, byte 5, MSB of wIndex
        volatile uint32_t WLENGTHL;  ///< Offset: 0x498 - SETUP data, byte 6, LSB of wLength
        volatile uint32_t WLENGTHH;  ///< Offset: 0x49C - SETUP data, byte 7, MSB of wLength
        volatile uint32_t ISOOUT;  ///< Offset: 0x20 - Number of bytes received last on this ISO OUT data endpoint
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable USB
        volatile uint32_t USBPULLUP;  ///< Offset: 0x504 - Control of the USB pull-up
        volatile uint32_t DPDMVALUE;  ///< Offset: 0x508 - State D+ and D- lines will be forced into by the...
        volatile uint32_t DTOGGLE;  ///< Offset: 0x50C - Data toggle control and status
        volatile uint32_t EPINEN;  ///< Offset: 0x510 - Endpoint IN enable
        volatile uint32_t EPOUTEN;  ///< Offset: 0x514 - Endpoint OUT enable
        volatile uint32_t EPSTALL;  ///< Offset: 0x518 - STALL endpoints
        volatile uint32_t ISOSPLIT;  ///< Offset: 0x51C - Controls the split of ISO buffers
        volatile uint32_t FRAMECNTR;  ///< Offset: 0x520 - Returns the current value of the start of frame counter
        volatile uint32_t LOWPOWER;  ///< Offset: 0x52C - Controls USBD peripheral low power mode during USB suspend
        volatile uint32_t ISOINCONFIG;  ///< Offset: 0x530 - Controls the response of the ISO IN endpoint to an IN...
        volatile uint32_t PTR;  ///< Offset: 0x00 - Data pointer
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Maximum number of bytes to transfer
        volatile uint32_t AMOUNT;  ///< Offset: 0x08 - Number of bytes transferred in the last transaction
    };

    /// Peripheral instances
    inline Registers* USBD = reinterpret_cast<Registers*>(USBD_BASE);

    // Bit definitions
    /// TASKS_STARTEPIN__ Register bits
    namespace tasks_startepin___bits {
        constexpr uint32_t TASKS_STARTEPIN = (1U << 0);  ///< Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host
    }

    /// TASKS_STARTISOIN Register bits
    namespace tasks_startisoin_bits {
        constexpr uint32_t TASKS_STARTISOIN = (1U << 0);  ///< Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and enables sending data on ISO endpoint
    }

    /// TASKS_STARTEPOUT__ Register bits
    namespace tasks_startepout___bits {
        constexpr uint32_t TASKS_STARTEPOUT = (1U << 0);  ///< Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host
    }

    /// TASKS_STARTISOOUT Register bits
    namespace tasks_startisoout_bits {
        constexpr uint32_t TASKS_STARTISOOUT = (1U << 0);  ///< Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and enables receiving of data on ISO endpoint
    }

    /// TASKS_EP0RCVOUT Register bits
    namespace tasks_ep0rcvout_bits {
        constexpr uint32_t TASKS_EP0RCVOUT = (1U << 0);  ///< Allows OUT data stage on control endpoint 0
    }

    /// TASKS_EP0STATUS Register bits
    namespace tasks_ep0status_bits {
        constexpr uint32_t TASKS_EP0STATUS = (1U << 0);  ///< Allows status stage on control endpoint 0
    }

    /// TASKS_EP0STALL Register bits
    namespace tasks_ep0stall_bits {
        constexpr uint32_t TASKS_EP0STALL = (1U << 0);  ///< Stalls data and status stage on control endpoint 0
    }

    /// TASKS_DPDMDRIVE Register bits
    namespace tasks_dpdmdrive_bits {
        constexpr uint32_t TASKS_DPDMDRIVE = (1U << 0);  ///< Forces D+ and D- lines into the state defined in the DPDMVALUE register
    }

    /// TASKS_DPDMNODRIVE Register bits
    namespace tasks_dpdmnodrive_bits {
        constexpr uint32_t TASKS_DPDMNODRIVE = (1U << 0);  ///< Stops forcing D+ and D- lines into any state (USB engine takes control)
    }

    /// EVENTS_USBRESET Register bits
    namespace events_usbreset_bits {
        constexpr uint32_t EVENTS_USBRESET = (1U << 0);  ///< Signals that a USB reset condition has been detected on USB lines
    }

    /// EVENTS_STARTED Register bits
    namespace events_started_bits {
        constexpr uint32_t EVENTS_STARTED = (1U << 0);  ///< Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register
    }

    /// EVENTS_ENDEPIN__ Register bits
    namespace events_endepin___bits {
        constexpr uint32_t EVENTS_ENDEPIN = (1U << 0);  ///< The whole EPIN[n] buffer has been consumed. The RAM buffer can be accessed safely by software.
    }

    /// EVENTS_EP0DATADONE Register bits
    namespace events_ep0datadone_bits {
        constexpr uint32_t EVENTS_EP0DATADONE = (1U << 0);  ///< An acknowledged data transfer has taken place on the control endpoint
    }

    /// EVENTS_ENDISOIN Register bits
    namespace events_endisoin_bits {
        constexpr uint32_t EVENTS_ENDISOIN = (1U << 0);  ///< The whole ISOIN buffer has been consumed. The RAM buffer can be accessed safely by software.
    }

    /// EVENTS_ENDEPOUT__ Register bits
    namespace events_endepout___bits {
        constexpr uint32_t EVENTS_ENDEPOUT = (1U << 0);  ///< The whole EPOUT[n] buffer has been consumed. The RAM buffer can be accessed safely by software.
    }

    /// EVENTS_ENDISOOUT Register bits
    namespace events_endisoout_bits {
        constexpr uint32_t EVENTS_ENDISOOUT = (1U << 0);  ///< The whole ISOOUT buffer has been consumed. The RAM buffer can be accessed safely by software.
    }

    /// EVENTS_SOF Register bits
    namespace events_sof_bits {
        constexpr uint32_t EVENTS_SOF = (1U << 0);  ///< Signals that a SOF (start of frame) condition has been detected on USB lines
    }

    /// EVENTS_USBEVENT Register bits
    namespace events_usbevent_bits {
        constexpr uint32_t EVENTS_USBEVENT = (1U << 0);  ///< An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause.
    }

    /// EVENTS_EP0SETUP Register bits
    namespace events_ep0setup_bits {
        constexpr uint32_t EVENTS_EP0SETUP = (1U << 0);  ///< A valid SETUP token has been received (and acknowledged) on the control endpoint
    }

    /// EVENTS_EPDATA Register bits
    namespace events_epdata_bits {
        constexpr uint32_t EVENTS_EPDATA = (1U << 0);  ///< A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t EP0DATADONE_STARTEPIN0 = (1U << 0);  ///< Shortcut between event EP0DATADONE and task STARTEPIN[0]
        constexpr uint32_t EP0DATADONE_STARTEPOUT0 = (1U << 1);  ///< Shortcut between event EP0DATADONE and task STARTEPOUT[0]
        constexpr uint32_t EP0DATADONE_EP0STATUS = (1U << 2);  ///< Shortcut between event EP0DATADONE and task EP0STATUS
        constexpr uint32_t ENDEPOUT0_EP0STATUS = (1U << 3);  ///< Shortcut between event ENDEPOUT[0] and task EP0STATUS
        constexpr uint32_t ENDEPOUT0_EP0RCVOUT = (1U << 4);  ///< Shortcut between event ENDEPOUT[0] and task EP0RCVOUT
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t USBRESET = (1U << 0);  ///< Enable or disable interrupt for event USBRESET
        constexpr uint32_t STARTED = (1U << 1);  ///< Enable or disable interrupt for event STARTED
        constexpr uint32_t ENDEPIN0 = (1U << 2);  ///< Enable or disable interrupt for event ENDEPIN[0]
        constexpr uint32_t ENDEPIN1 = (1U << 3);  ///< Enable or disable interrupt for event ENDEPIN[1]
        constexpr uint32_t ENDEPIN2 = (1U << 4);  ///< Enable or disable interrupt for event ENDEPIN[2]
        constexpr uint32_t ENDEPIN3 = (1U << 5);  ///< Enable or disable interrupt for event ENDEPIN[3]
        constexpr uint32_t ENDEPIN4 = (1U << 6);  ///< Enable or disable interrupt for event ENDEPIN[4]
        constexpr uint32_t ENDEPIN5 = (1U << 7);  ///< Enable or disable interrupt for event ENDEPIN[5]
        constexpr uint32_t ENDEPIN6 = (1U << 8);  ///< Enable or disable interrupt for event ENDEPIN[6]
        constexpr uint32_t ENDEPIN7 = (1U << 9);  ///< Enable or disable interrupt for event ENDEPIN[7]
        constexpr uint32_t EP0DATADONE = (1U << 10);  ///< Enable or disable interrupt for event EP0DATADONE
        constexpr uint32_t ENDISOIN = (1U << 11);  ///< Enable or disable interrupt for event ENDISOIN
        constexpr uint32_t ENDEPOUT0 = (1U << 12);  ///< Enable or disable interrupt for event ENDEPOUT[0]
        constexpr uint32_t ENDEPOUT1 = (1U << 13);  ///< Enable or disable interrupt for event ENDEPOUT[1]
        constexpr uint32_t ENDEPOUT2 = (1U << 14);  ///< Enable or disable interrupt for event ENDEPOUT[2]
        constexpr uint32_t ENDEPOUT3 = (1U << 15);  ///< Enable or disable interrupt for event ENDEPOUT[3]
        constexpr uint32_t ENDEPOUT4 = (1U << 16);  ///< Enable or disable interrupt for event ENDEPOUT[4]
        constexpr uint32_t ENDEPOUT5 = (1U << 17);  ///< Enable or disable interrupt for event ENDEPOUT[5]
        constexpr uint32_t ENDEPOUT6 = (1U << 18);  ///< Enable or disable interrupt for event ENDEPOUT[6]
        constexpr uint32_t ENDEPOUT7 = (1U << 19);  ///< Enable or disable interrupt for event ENDEPOUT[7]
        constexpr uint32_t ENDISOOUT = (1U << 20);  ///< Enable or disable interrupt for event ENDISOOUT
        constexpr uint32_t SOF = (1U << 21);  ///< Enable or disable interrupt for event SOF
        constexpr uint32_t USBEVENT = (1U << 22);  ///< Enable or disable interrupt for event USBEVENT
        constexpr uint32_t EP0SETUP = (1U << 23);  ///< Enable or disable interrupt for event EP0SETUP
        constexpr uint32_t EPDATA = (1U << 24);  ///< Enable or disable interrupt for event EPDATA
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t USBRESET = (1U << 0);  ///< Write '1' to enable interrupt for event USBRESET
        constexpr uint32_t STARTED = (1U << 1);  ///< Write '1' to enable interrupt for event STARTED
        constexpr uint32_t ENDEPIN0 = (1U << 2);  ///< Write '1' to enable interrupt for event ENDEPIN[0]
        constexpr uint32_t ENDEPIN1 = (1U << 3);  ///< Write '1' to enable interrupt for event ENDEPIN[1]
        constexpr uint32_t ENDEPIN2 = (1U << 4);  ///< Write '1' to enable interrupt for event ENDEPIN[2]
        constexpr uint32_t ENDEPIN3 = (1U << 5);  ///< Write '1' to enable interrupt for event ENDEPIN[3]
        constexpr uint32_t ENDEPIN4 = (1U << 6);  ///< Write '1' to enable interrupt for event ENDEPIN[4]
        constexpr uint32_t ENDEPIN5 = (1U << 7);  ///< Write '1' to enable interrupt for event ENDEPIN[5]
        constexpr uint32_t ENDEPIN6 = (1U << 8);  ///< Write '1' to enable interrupt for event ENDEPIN[6]
        constexpr uint32_t ENDEPIN7 = (1U << 9);  ///< Write '1' to enable interrupt for event ENDEPIN[7]
        constexpr uint32_t EP0DATADONE = (1U << 10);  ///< Write '1' to enable interrupt for event EP0DATADONE
        constexpr uint32_t ENDISOIN = (1U << 11);  ///< Write '1' to enable interrupt for event ENDISOIN
        constexpr uint32_t ENDEPOUT0 = (1U << 12);  ///< Write '1' to enable interrupt for event ENDEPOUT[0]
        constexpr uint32_t ENDEPOUT1 = (1U << 13);  ///< Write '1' to enable interrupt for event ENDEPOUT[1]
        constexpr uint32_t ENDEPOUT2 = (1U << 14);  ///< Write '1' to enable interrupt for event ENDEPOUT[2]
        constexpr uint32_t ENDEPOUT3 = (1U << 15);  ///< Write '1' to enable interrupt for event ENDEPOUT[3]
        constexpr uint32_t ENDEPOUT4 = (1U << 16);  ///< Write '1' to enable interrupt for event ENDEPOUT[4]
        constexpr uint32_t ENDEPOUT5 = (1U << 17);  ///< Write '1' to enable interrupt for event ENDEPOUT[5]
        constexpr uint32_t ENDEPOUT6 = (1U << 18);  ///< Write '1' to enable interrupt for event ENDEPOUT[6]
        constexpr uint32_t ENDEPOUT7 = (1U << 19);  ///< Write '1' to enable interrupt for event ENDEPOUT[7]
        constexpr uint32_t ENDISOOUT = (1U << 20);  ///< Write '1' to enable interrupt for event ENDISOOUT
        constexpr uint32_t SOF = (1U << 21);  ///< Write '1' to enable interrupt for event SOF
        constexpr uint32_t USBEVENT = (1U << 22);  ///< Write '1' to enable interrupt for event USBEVENT
        constexpr uint32_t EP0SETUP = (1U << 23);  ///< Write '1' to enable interrupt for event EP0SETUP
        constexpr uint32_t EPDATA = (1U << 24);  ///< Write '1' to enable interrupt for event EPDATA
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t USBRESET = (1U << 0);  ///< Write '1' to disable interrupt for event USBRESET
        constexpr uint32_t STARTED = (1U << 1);  ///< Write '1' to disable interrupt for event STARTED
        constexpr uint32_t ENDEPIN0 = (1U << 2);  ///< Write '1' to disable interrupt for event ENDEPIN[0]
        constexpr uint32_t ENDEPIN1 = (1U << 3);  ///< Write '1' to disable interrupt for event ENDEPIN[1]
        constexpr uint32_t ENDEPIN2 = (1U << 4);  ///< Write '1' to disable interrupt for event ENDEPIN[2]
        constexpr uint32_t ENDEPIN3 = (1U << 5);  ///< Write '1' to disable interrupt for event ENDEPIN[3]
        constexpr uint32_t ENDEPIN4 = (1U << 6);  ///< Write '1' to disable interrupt for event ENDEPIN[4]
        constexpr uint32_t ENDEPIN5 = (1U << 7);  ///< Write '1' to disable interrupt for event ENDEPIN[5]
        constexpr uint32_t ENDEPIN6 = (1U << 8);  ///< Write '1' to disable interrupt for event ENDEPIN[6]
        constexpr uint32_t ENDEPIN7 = (1U << 9);  ///< Write '1' to disable interrupt for event ENDEPIN[7]
        constexpr uint32_t EP0DATADONE = (1U << 10);  ///< Write '1' to disable interrupt for event EP0DATADONE
        constexpr uint32_t ENDISOIN = (1U << 11);  ///< Write '1' to disable interrupt for event ENDISOIN
        constexpr uint32_t ENDEPOUT0 = (1U << 12);  ///< Write '1' to disable interrupt for event ENDEPOUT[0]
        constexpr uint32_t ENDEPOUT1 = (1U << 13);  ///< Write '1' to disable interrupt for event ENDEPOUT[1]
        constexpr uint32_t ENDEPOUT2 = (1U << 14);  ///< Write '1' to disable interrupt for event ENDEPOUT[2]
        constexpr uint32_t ENDEPOUT3 = (1U << 15);  ///< Write '1' to disable interrupt for event ENDEPOUT[3]
        constexpr uint32_t ENDEPOUT4 = (1U << 16);  ///< Write '1' to disable interrupt for event ENDEPOUT[4]
        constexpr uint32_t ENDEPOUT5 = (1U << 17);  ///< Write '1' to disable interrupt for event ENDEPOUT[5]
        constexpr uint32_t ENDEPOUT6 = (1U << 18);  ///< Write '1' to disable interrupt for event ENDEPOUT[6]
        constexpr uint32_t ENDEPOUT7 = (1U << 19);  ///< Write '1' to disable interrupt for event ENDEPOUT[7]
        constexpr uint32_t ENDISOOUT = (1U << 20);  ///< Write '1' to disable interrupt for event ENDISOOUT
        constexpr uint32_t SOF = (1U << 21);  ///< Write '1' to disable interrupt for event SOF
        constexpr uint32_t USBEVENT = (1U << 22);  ///< Write '1' to disable interrupt for event USBEVENT
        constexpr uint32_t EP0SETUP = (1U << 23);  ///< Write '1' to disable interrupt for event EP0SETUP
        constexpr uint32_t EPDATA = (1U << 24);  ///< Write '1' to disable interrupt for event EPDATA
    }

    /// EVENTCAUSE Register bits
    namespace eventcause_bits {
        constexpr uint32_t ISOOUTCRC = (1U << 0);  ///< CRC error was detected on isochronous OUT endpoint 8. Write '1' to clear.
        constexpr uint32_t SUSPEND = (1U << 8);  ///< Signals that USB lines have been idle long enough for the device to enter suspend. Write '1' to clear.
        constexpr uint32_t RESUME = (1U << 9);  ///< Signals that a RESUME condition (K state or activity restart) has been detected on USB lines. Write '1' to clear.
        constexpr uint32_t USBWUALLOWED = (1U << 10);  ///< USB MAC has been woken up and operational. Write '1' to clear.
        constexpr uint32_t READY = (1U << 11);  ///< USB device is ready for normal operation. Write '1' to clear.
    }

    /// EPIN__ Register bits
    namespace epin___bits {
        constexpr uint32_t GETSTATUS = (16 << 0);  ///< IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint.
    }

    /// EPOUT__ Register bits
    namespace epout___bits {
        constexpr uint32_t SIZE = (7 << 0);  ///< Number of bytes received last in the data stage of this OUT endpoint
    }

    /// EPSTATUS Register bits
    namespace epstatus_bits {
        constexpr uint32_t EPIN0 = (1U << 0);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPIN1 = (1U << 1);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPIN2 = (1U << 2);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPIN3 = (1U << 3);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPIN4 = (1U << 4);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPIN5 = (1U << 5);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPIN6 = (1U << 6);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPIN7 = (1U << 7);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPIN8 = (1U << 8);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPOUT0 = (1U << 16);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPOUT1 = (1U << 17);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPOUT2 = (1U << 18);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPOUT3 = (1U << 19);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPOUT4 = (1U << 20);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPOUT5 = (1U << 21);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPOUT6 = (1U << 22);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPOUT7 = (1U << 23);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        constexpr uint32_t EPOUT8 = (1U << 24);  ///< Captured state of endpoint's EasyDMA registers. Write '1' to clear.
    }

    /// EPDATASTATUS Register bits
    namespace epdatastatus_bits {
        constexpr uint32_t EPIN1 = (1U << 1);  ///< Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        constexpr uint32_t EPIN2 = (1U << 2);  ///< Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        constexpr uint32_t EPIN3 = (1U << 3);  ///< Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        constexpr uint32_t EPIN4 = (1U << 4);  ///< Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        constexpr uint32_t EPIN5 = (1U << 5);  ///< Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        constexpr uint32_t EPIN6 = (1U << 6);  ///< Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        constexpr uint32_t EPIN7 = (1U << 7);  ///< Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        constexpr uint32_t EPOUT1 = (1U << 17);  ///< Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
        constexpr uint32_t EPOUT2 = (1U << 18);  ///< Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
        constexpr uint32_t EPOUT3 = (1U << 19);  ///< Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
        constexpr uint32_t EPOUT4 = (1U << 20);  ///< Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
        constexpr uint32_t EPOUT5 = (1U << 21);  ///< Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
        constexpr uint32_t EPOUT6 = (1U << 22);  ///< Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
        constexpr uint32_t EPOUT7 = (1U << 23);  ///< Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
    }

    /// USBADDR Register bits
    namespace usbaddr_bits {
        constexpr uint32_t ADDR = (7 << 0);  ///< Device USB address
    }

    /// BMREQUESTTYPE Register bits
    namespace bmrequesttype_bits {
        constexpr uint32_t RECIPIENT = (5 << 0);  ///< Data transfer type
        constexpr uint32_t TYPE = (2 << 5);  ///< Data transfer type
        constexpr uint32_t DIRECTION = (1U << 7);  ///< Data transfer direction
    }

    /// BREQUEST Register bits
    namespace brequest_bits {
        constexpr uint32_t BREQUEST = (8 << 0);  ///< SETUP data, byte 1, bRequest. Values provided for standard requests only, user must implement class and vendor values.
    }

    /// WVALUEL Register bits
    namespace wvaluel_bits {
        constexpr uint32_t WVALUEL = (8 << 0);  ///< SETUP data, byte 2, LSB of wValue
    }

    /// WVALUEH Register bits
    namespace wvalueh_bits {
        constexpr uint32_t WVALUEH = (8 << 0);  ///< SETUP data, byte 3, MSB of wValue
    }

    /// WINDEXL Register bits
    namespace windexl_bits {
        constexpr uint32_t WINDEXL = (8 << 0);  ///< SETUP data, byte 4, LSB of wIndex
    }

    /// WINDEXH Register bits
    namespace windexh_bits {
        constexpr uint32_t WINDEXH = (8 << 0);  ///< SETUP data, byte 5, MSB of wIndex
    }

    /// WLENGTHL Register bits
    namespace wlengthl_bits {
        constexpr uint32_t WLENGTHL = (8 << 0);  ///< SETUP data, byte 6, LSB of wLength
    }

    /// WLENGTHH Register bits
    namespace wlengthh_bits {
        constexpr uint32_t WLENGTHH = (8 << 0);  ///< SETUP data, byte 7, MSB of wLength
    }

    /// ISOOUT Register bits
    namespace isoout_bits {
        constexpr uint32_t SIZE = (10 << 0);  ///< Number of bytes received last on this ISO OUT data endpoint
        constexpr uint32_t ZERO = (1U << 16);  ///< Zero-length data packet received
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable USB
    }

    /// USBPULLUP Register bits
    namespace usbpullup_bits {
        constexpr uint32_t CONNECT = (1U << 0);  ///< Control of the USB pull-up on the D+ line
    }

    /// DPDMVALUE Register bits
    namespace dpdmvalue_bits {
        constexpr uint32_t STATE = (5 << 0);  ///< State D+ and D- lines will be forced into by the DPDMDRIVE task
    }

    /// DTOGGLE Register bits
    namespace dtoggle_bits {
        constexpr uint32_t EP = (3 << 0);  ///< Select bulk endpoint number
        constexpr uint32_t IO = (1U << 7);  ///< Selects IN or OUT endpoint
        constexpr uint32_t VALUE = (2 << 8);  ///< Data toggle value
    }

    /// EPINEN Register bits
    namespace epinen_bits {
        constexpr uint32_t IN0 = (1U << 0);  ///< Enable IN endpoint 0
        constexpr uint32_t IN1 = (1U << 1);  ///< Enable IN endpoint 1
        constexpr uint32_t IN2 = (1U << 2);  ///< Enable IN endpoint 2
        constexpr uint32_t IN3 = (1U << 3);  ///< Enable IN endpoint 3
        constexpr uint32_t IN4 = (1U << 4);  ///< Enable IN endpoint 4
        constexpr uint32_t IN5 = (1U << 5);  ///< Enable IN endpoint 5
        constexpr uint32_t IN6 = (1U << 6);  ///< Enable IN endpoint 6
        constexpr uint32_t IN7 = (1U << 7);  ///< Enable IN endpoint 7
        constexpr uint32_t ISOIN = (1U << 8);  ///< Enable ISO IN endpoint
    }

    /// EPOUTEN Register bits
    namespace epouten_bits {
        constexpr uint32_t OUT0 = (1U << 0);  ///< Enable OUT endpoint 0
        constexpr uint32_t OUT1 = (1U << 1);  ///< Enable OUT endpoint 1
        constexpr uint32_t OUT2 = (1U << 2);  ///< Enable OUT endpoint 2
        constexpr uint32_t OUT3 = (1U << 3);  ///< Enable OUT endpoint 3
        constexpr uint32_t OUT4 = (1U << 4);  ///< Enable OUT endpoint 4
        constexpr uint32_t OUT5 = (1U << 5);  ///< Enable OUT endpoint 5
        constexpr uint32_t OUT6 = (1U << 6);  ///< Enable OUT endpoint 6
        constexpr uint32_t OUT7 = (1U << 7);  ///< Enable OUT endpoint 7
        constexpr uint32_t ISOOUT = (1U << 8);  ///< Enable ISO OUT endpoint 8
    }

    /// EPSTALL Register bits
    namespace epstall_bits {
        constexpr uint32_t EP = (3 << 0);  ///< Select endpoint number
        constexpr uint32_t IO = (1U << 7);  ///< Selects IN or OUT endpoint
        constexpr uint32_t STALL = (1U << 8);  ///< Stall selected endpoint
    }

    /// ISOSPLIT Register bits
    namespace isosplit_bits {
        constexpr uint32_t SPLIT = (16 << 0);  ///< Controls the split of ISO buffers
    }

    /// FRAMECNTR Register bits
    namespace framecntr_bits {
        constexpr uint32_t FRAMECNTR = (11 << 0);  ///< Returns the current value of the start of frame counter
    }

    /// LOWPOWER Register bits
    namespace lowpower_bits {
        constexpr uint32_t LOWPOWER = (1U << 0);  ///< Controls USBD peripheral low-power mode during USB suspend
    }

    /// ISOINCONFIG Register bits
    namespace isoinconfig_bits {
        constexpr uint32_t RESPONSE = (1U << 0);  ///< Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Data pointer. Accepts any address in Data RAM.
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t MAXCNT = (10 << 0);  ///< Maximum number of bytes to transfer
    }

    /// AMOUNT Register bits
    namespace amount_bits {
        constexpr uint32_t AMOUNT = (10 << 0);  ///< Number of bytes transferred in the last transaction
    }

}

// ============================================================================
// CC Peripheral
// ============================================================================

namespace cc {
    /// Base addresses
    constexpr uint32_t CC_HOST_RGF_BASE = 0x5002A000;

    /// CC Register structure
    struct Registers {
        volatile uint32_t HOST_CRYPTOKEY_SEL;  ///< Offset: 0x1A38 - AES hardware key select
        volatile uint32_t HOST_IOT_KPRTL_LOCK;  ///< Offset: 0x1A4C - This write-once register is the K_PRTL lock register....
        volatile uint32_t HOST_IOT_KDR0;  ///< Offset: 0x1A50 - This register holds bits 31:0 of K_DR. The value of this...
        volatile uint32_t HOST_IOT_KDR1;  ///< Offset: 0x1A54 - This register holds bits 63:32 of K_DR. The value of...
        volatile uint32_t HOST_IOT_KDR2;  ///< Offset: 0x1A58 - This register holds bits 95:64 of K_DR. The value of...
        volatile uint32_t HOST_IOT_KDR3;  ///< Offset: 0x1A5C - This register holds bits 127:96 of K_DR. The value of...
        volatile uint32_t HOST_IOT_LCS;  ///< Offset: 0x1A60 - Controls lifecycle state (LCS) for CRYPTOCELL subsystem
    };

    /// Peripheral instances
    inline Registers* CC_HOST_RGF = reinterpret_cast<Registers*>(CC_HOST_RGF_BASE);

    // Bit definitions
    /// HOST_CRYPTOKEY_SEL Register bits
    namespace host_cryptokey_sel_bits {
        constexpr uint32_t HOST_CRYPTOKEY_SEL = (2 << 0);  ///< Select the source of the HW key that is used by the AES engine
    }

    /// HOST_IOT_KPRTL_LOCK Register bits
    namespace host_iot_kprtl_lock_bits {
        constexpr uint32_t HOST_IOT_KPRTL_LOCK = (1U << 0);  ///< This register is the K_PRTL lock register. When this register is set, K_PRTL can not be used and a zeroed key will be used instead. The value of this register is saved in the CRYPTOCELL AO power domain.
    }

    /// HOST_IOT_KDR0 Register bits
    namespace host_iot_kdr0_bits {
        constexpr uint32_t HOST_IOT_KDR0 = (32 << 0);  ///< Write: K_DR bits 31:0 Read: 0x00000000 when 128-bit K_DR key value is not yet retained in the CRYPTOCELL AO power domain Read: 0x00000001 when 128-bit K_DR key value is successfully retained in the CRYPTOCELL AO power domain
    }

    /// HOST_IOT_KDR1 Register bits
    namespace host_iot_kdr1_bits {
        constexpr uint32_t HOST_IOT_KDR1 = (32 << 0);  ///< K_DR bits 63:32
    }

    /// HOST_IOT_KDR2 Register bits
    namespace host_iot_kdr2_bits {
        constexpr uint32_t HOST_IOT_KDR2 = (32 << 0);  ///< K_DR bits 95:64
    }

    /// HOST_IOT_KDR3 Register bits
    namespace host_iot_kdr3_bits {
        constexpr uint32_t HOST_IOT_KDR3 = (32 << 0);  ///< K_DR bits 127:96
    }

    /// HOST_IOT_LCS Register bits
    namespace host_iot_lcs_bits {
        constexpr uint32_t LCS = (3 << 0);  ///< Lifecycle state value. This field is write-once per reset.
        constexpr uint32_t LCS_IS_VALID = (1U << 8);  ///< This field is read-only and indicates if CRYPTOCELL LCS has been successfully configured since last reset
    }

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t CRYPTOCELL_BASE = 0x5002A000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable CRYPTOCELL subsystem
    };

    /// Peripheral instances
    inline Registers* CRYPTOCELL = reinterpret_cast<Registers*>(CRYPTOCELL_BASE);

    // Bit definitions
    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable the CRYPTOCELL subsystem
    }

}


} // namespace alloy::generated::nrf52840

#endif // ALLOY_GENERATED_NRF52840_PERIPHERALS_HPP