/// Auto-generated code for nrf5340_network
/// Generated by Alloy Code Generator
/// Source: nordic_nrf5340.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:01:06
#ifndef ALLOY_GENERATED_NRF5340_NETWORK_PERIPHERALS_HPP
#define ALLOY_GENERATED_NRF5340_NETWORK_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::nrf5340_network {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_ficr = true;
    constexpr uint32_t num_ficr_instances = 1;
    constexpr bool has_uicr = true;
    constexpr uint32_t num_uicr_instances = 1;
    constexpr bool has_cti = true;
    constexpr uint32_t num_cti_instances = 1;
    constexpr bool has_dcnf = true;
    constexpr uint32_t num_dcnf_instances = 1;
    constexpr bool has_vreqctrl = true;
    constexpr uint32_t num_vreqctrl_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_reset = true;
    constexpr uint32_t num_reset_instances = 1;
    constexpr bool has_ctrlap = true;
    constexpr uint32_t num_ctrlap_instances = 1;
    constexpr bool has_radio = true;
    constexpr uint32_t num_radio_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 3;
    constexpr bool has_ecb = true;
    constexpr uint32_t num_ecb_instances = 1;
    constexpr bool has_aar = true;
    constexpr uint32_t num_aar_instances = 1;
    constexpr bool has_ccm = true;
    constexpr uint32_t num_ccm_instances = 1;
    constexpr bool has_dppic = true;
    constexpr uint32_t num_dppic_instances = 1;
    constexpr bool has_temp = true;
    constexpr uint32_t num_temp_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 2;
    constexpr bool has_ipc = true;
    constexpr uint32_t num_ipc_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 1;
    constexpr bool has_egu0 = true;
    constexpr uint32_t num_egu0_instances = 1;
    constexpr bool has_swi0 = true;
    constexpr uint32_t num_swi0_instances = 1;
    constexpr bool has_swi1 = true;
    constexpr uint32_t num_swi1_instances = 1;
    constexpr bool has_swi2 = true;
    constexpr uint32_t num_swi2_instances = 1;
    constexpr bool has_swi3 = true;
    constexpr uint32_t num_swi3_instances = 1;
    constexpr bool has_appmutex = true;
    constexpr uint32_t num_appmutex_instances = 2;
    constexpr bool has_acl = true;
    constexpr uint32_t num_acl_instances = 1;
    constexpr bool has_nvmc = true;
    constexpr uint32_t num_nvmc_instances = 1;
    constexpr bool has_vmc = true;
    constexpr uint32_t num_vmc_instances = 1;
    constexpr bool has_p0 = true;
    constexpr uint32_t num_p0_instances = 1;
    constexpr bool has_p1 = true;
    constexpr uint32_t num_p1_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct ficr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct uicr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcnf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vreqctrl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct reset_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ctrlap_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct radio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct ecb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aar_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dppic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct temp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ipc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct egu0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swi3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct appmutex_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct acl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct p0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct p1_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 1;
    constexpr uint32_t max_gpio_pins = 16;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uarte0_ns = true;
}

// ============================================================================
// FICR Peripheral
// ============================================================================

namespace ficr {
    /// Base addresses
    constexpr uint32_t FICR_NS_BASE = 0x01FF0000;

    /// FICR Register structure
    struct Registers {
        volatile uint32_t CONFIGID;  ///< Offset: 0x00 - Configuration identifier
        volatile uint32_t DEVICEID[%s];  ///< Offset: 0x04 - Description collection: Device identifier
        volatile uint32_t PART;  ///< Offset: 0x0C - Part code
        volatile uint32_t VARIANT;  ///< Offset: 0x10 - Part Variant, Hardware version and Production configuration
        volatile uint32_t PACKAGE;  ///< Offset: 0x14 - Package option
        volatile uint32_t RAM;  ///< Offset: 0x18 - RAM variant
        volatile uint32_t FLASH;  ///< Offset: 0x1C - Flash variant
        volatile uint32_t CODEPAGESIZE;  ///< Offset: 0x20 - Code memory page size in bytes
        volatile uint32_t CODESIZE;  ///< Offset: 0x24 - Code memory size
        volatile uint32_t DEVICETYPE;  ///< Offset: 0x28 - Device type
        volatile uint32_t ER[%s];  ///< Offset: 0x280 - Description collection: Encryption Root, word n
        volatile uint32_t IR[%s];  ///< Offset: 0x290 - Description collection: Identity Root, word n
        volatile uint32_t DEVICEADDRTYPE;  ///< Offset: 0x2A0 - Device address type
        volatile uint32_t DEVICEADDR[%s];  ///< Offset: 0x2A4 - Description collection: Device address n
        volatile uint32_t ADDR;  ///< Offset: 0x00 - Description cluster: Address
        volatile uint32_t DATA;  ///< Offset: 0x04 - Description cluster: Data
    };

    /// Peripheral instances
    inline Registers* FICR_NS = reinterpret_cast<Registers*>(FICR_NS_BASE);

    // Bit definitions
    /// CONFIGID Register bits
    namespace configid_bits {
        constexpr uint32_t HWID = (16 << 0);  ///< Identification number for the HW
    }

    /// DEVICEID[%s] Register bits
    namespace deviceid[%s]_bits {
        constexpr uint32_t DEVICEID = (32 << 0);  ///< 64 bit unique device identifier
    }

    /// PART Register bits
    namespace part_bits {
        constexpr uint32_t PART = (32 << 0);  ///< Part code
    }

    /// VARIANT Register bits
    namespace variant_bits {
        constexpr uint32_t VARIANT = (32 << 0);  ///< Part Variant, Hardware version and Production configuration, encoded as ASCII
    }

    /// PACKAGE Register bits
    namespace package_bits {
        constexpr uint32_t PACKAGE = (32 << 0);  ///< Package option
    }

    /// RAM Register bits
    namespace ram_bits {
        constexpr uint32_t RAM = (32 << 0);  ///< RAM variant
    }

    /// FLASH Register bits
    namespace flash_bits {
        constexpr uint32_t FLASH = (32 << 0);  ///< Flash variant
    }

    /// CODEPAGESIZE Register bits
    namespace codepagesize_bits {
        constexpr uint32_t CODEPAGESIZE = (32 << 0);  ///< Code memory page size in bytes
    }

    /// CODESIZE Register bits
    namespace codesize_bits {
        constexpr uint32_t CODESIZE = (32 << 0);  ///< Code memory size in number of pages
    }

    /// DEVICETYPE Register bits
    namespace devicetype_bits {
        constexpr uint32_t DEVICETYPE = (32 << 0);  ///< Device type
    }

    /// ER[%s] Register bits
    namespace er[%s]_bits {
        constexpr uint32_t ER = (32 << 0);  ///< Encryption Root, word n
    }

    /// IR[%s] Register bits
    namespace ir[%s]_bits {
        constexpr uint32_t IR = (32 << 0);  ///< Identity Root, word n
    }

    /// DEVICEADDRTYPE Register bits
    namespace deviceaddrtype_bits {
        constexpr uint32_t DEVICEADDRTYPE = (1U << 0);  ///< Device address type
    }

    /// DEVICEADDR[%s] Register bits
    namespace deviceaddr[%s]_bits {
        constexpr uint32_t DEVICEADDR = (32 << 0);  ///< 48 bit device address
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t Address = (32 << 0);  ///< Address
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t Data = (32 << 0);  ///< Data
    }

}

// ============================================================================
// UICR Peripheral
// ============================================================================

namespace uicr {
    /// Base addresses
    constexpr uint32_t UICR_NS_BASE = 0x01FF8000;

    /// UICR Register structure
    struct Registers {
        volatile uint32_t APPROTECT;  ///< Offset: 0x00 - Access port protection
        volatile uint32_t ERASEPROTECT;  ///< Offset: 0x04 - Erase protection
        volatile uint32_t NRFFW[%s];  ///< Offset: 0x200 - Description collection: Reserved for Nordic firmware design
        volatile uint32_t CUSTOMER[%s];  ///< Offset: 0x300 - Description collection: Reserved for customer
    };

    /// Peripheral instances
    inline Registers* UICR_NS = reinterpret_cast<Registers*>(UICR_NS_BASE);

    // Bit definitions
    /// APPROTECT Register bits
    namespace approtect_bits {
        constexpr uint32_t PALL = (32 << 0);  ///< Blocks debugger read/write access to all CPU registers and memory mapped addresses.
    }

    /// ERASEPROTECT Register bits
    namespace eraseprotect_bits {
        constexpr uint32_t PALL = (32 << 0);  ///< Blocks NVMC ERASEALL and CTRLAP ERASEALL functionality. Using any value except Unprotected will lead to the protection being enabled.
    }

    /// NRFFW[%s] Register bits
    namespace nrffw[%s]_bits {
        constexpr uint32_t NRFFW = (32 << 0);  ///< Reserved for Nordic firmware design
    }

    /// CUSTOMER[%s] Register bits
    namespace customer[%s]_bits {
        constexpr uint32_t CUSTOMER = (32 << 0);  ///< Reserved for customer
    }

}

// ============================================================================
// CTI Peripheral
// ============================================================================

namespace cti {
    /// Base addresses
    constexpr uint32_t CTI_NS_BASE = 0xE0042000;

    /// CTI Register structure
    struct Registers {
        volatile uint32_t CTICONTROL;  ///< Offset: 0x00 - CTI Control register
        volatile uint32_t CTIINTACK;  ///< Offset: 0x10 - CTI Interrupt Acknowledge register
        volatile uint32_t CTIAPPSET;  ///< Offset: 0x14 - CTI Application Trigger Set register
        volatile uint32_t CTIAPPCLEAR;  ///< Offset: 0x18 - CTI Application Trigger Clear register
        volatile uint32_t CTIAPPPULSE;  ///< Offset: 0x1C - CTI Application Pulse register
        volatile uint32_t CTIINEN[%s];  ///< Offset: 0x20 - Description collection: CTI Trigger input
        volatile uint32_t CTIOUTEN[%s];  ///< Offset: 0xA0 - Description collection: CTI Trigger output
        volatile uint32_t CTITRIGINSTATUS;  ///< Offset: 0x130 - CTI Trigger In Status register
        volatile uint32_t CTITRIGOUTSTATUS;  ///< Offset: 0x134 - CTI Trigger Out Status register
        volatile uint32_t CTICHINSTATUS;  ///< Offset: 0x138 - CTI Channel In Status register
        volatile uint32_t CTIGATE;  ///< Offset: 0x140 - Enable CTI Channel Gate register
        volatile uint32_t DEVARCH;  ///< Offset: 0xFBC - Device Architecture register
        volatile uint32_t DEVID;  ///< Offset: 0xFC8 - Device Configuration register
        volatile uint32_t DEVTYPE;  ///< Offset: 0xFCC - Device Type Identifier register
        volatile uint32_t PIDR4;  ///< Offset: 0xFD0 - Peripheral ID4 Register
        volatile uint32_t PIDR5;  ///< Offset: 0xFD4 - Peripheral ID5 register
        volatile uint32_t PIDR6;  ///< Offset: 0xFD8 - Peripheral ID6 register
        volatile uint32_t PIDR7;  ///< Offset: 0xFDC - Peripheral ID7 register
        volatile uint32_t PIDR0;  ///< Offset: 0xFE0 - Peripheral ID0 Register
        volatile uint32_t PIDR1;  ///< Offset: 0xFE4 - Peripheral ID1 Register
        volatile uint32_t PIDR2;  ///< Offset: 0xFE8 - Peripheral ID2 Register
        volatile uint32_t PIDR3;  ///< Offset: 0xFEC - Peripheral ID3 Register
        volatile uint32_t CIDR0;  ///< Offset: 0xFF0 - Component ID0 Register
        volatile uint32_t CIDR1;  ///< Offset: 0xFF4 - Component ID1 Register
        volatile uint32_t CIDR2;  ///< Offset: 0xFF8 - Component ID2 Register
        volatile uint32_t CIDR3;  ///< Offset: 0xFFC - Component ID3 Register
    };

    /// Peripheral instances
    inline Registers* CTI_NS = reinterpret_cast<Registers*>(CTI_NS_BASE);

    // Bit definitions
    /// CTICONTROL Register bits
    namespace cticontrol_bits {
        constexpr uint32_t GLBEN = (1U << 0);  ///< Enables or disables the CTI.
    }

    /// CTIINTACK Register bits
    namespace ctiintack_bits {
        constexpr uint32_t DEBUGREQ = (1U << 0);  ///< Processor debug request
        constexpr uint32_t CPURESTART = (1U << 1);  ///< Processor Restart
        constexpr uint32_t UNUSED0 = (1U << 2);  ///< N/A
        constexpr uint32_t UNUSED1 = (1U << 3);  ///< N/A
        constexpr uint32_t UNUSED2 = (1U << 4);  ///< N/A
        constexpr uint32_t UNUSED3 = (1U << 5);  ///< N/A
        constexpr uint32_t UNUSED4 = (1U << 6);  ///< N/A
        constexpr uint32_t UNUSED5 = (1U << 7);  ///< N/A
    }

    /// CTIAPPSET Register bits
    namespace ctiappset_bits {
        constexpr uint32_t APPSET_0 = (1U << 0);  ///< Application trigger event for channel 0.
        constexpr uint32_t APPSET_1 = (1U << 1);  ///< Application trigger event for channel 1.
        constexpr uint32_t APPSET_2 = (1U << 2);  ///< Application trigger event for channel 2.
        constexpr uint32_t APPSET_3 = (1U << 3);  ///< Application trigger event for channel 3.
    }

    /// CTIAPPCLEAR Register bits
    namespace ctiappclear_bits {
        constexpr uint32_t APPCLEAR_0 = (1U << 0);  ///< Sets the corresponding bits in the CTIAPPSET to 0. There is one bit of the register for each channel.
        constexpr uint32_t APPCLEAR_1 = (1U << 1);  ///< Sets the corresponding bits in the CTIAPPSET to 0. There is one bit of the register for each channel.
        constexpr uint32_t APPCLEAR_2 = (1U << 2);  ///< Sets the corresponding bits in the CTIAPPSET to 0. There is one bit of the register for each channel.
        constexpr uint32_t APPCLEAR_3 = (1U << 3);  ///< Sets the corresponding bits in the CTIAPPSET to 0. There is one bit of the register for each channel.
    }

    /// CTIAPPPULSE Register bits
    namespace ctiapppulse_bits {
        constexpr uint32_t APPULSE_0 = (1U << 0);  ///< Setting a bit HIGH generates a channel event pulse for the selected channel. There is one bit of the register for each channel.
        constexpr uint32_t APPULSE_1 = (1U << 1);  ///< Setting a bit HIGH generates a channel event pulse for the selected channel. There is one bit of the register for each channel.
        constexpr uint32_t APPULSE_2 = (1U << 2);  ///< Setting a bit HIGH generates a channel event pulse for the selected channel. There is one bit of the register for each channel.
        constexpr uint32_t APPULSE_3 = (1U << 3);  ///< Setting a bit HIGH generates a channel event pulse for the selected channel. There is one bit of the register for each channel.
    }

    /// CTIINEN[%s] Register bits
    namespace ctiinen[%s]_bits {
        constexpr uint32_t TRIGINEN_0 = (1U << 0);  ///< Enables a cross trigger event to channel 0 when a ctitrigin input is activated.
        constexpr uint32_t TRIGINEN_1 = (1U << 1);  ///< Enables a cross trigger event to channel 1 when a ctitrigin input is activated.
        constexpr uint32_t TRIGINEN_2 = (1U << 2);  ///< Enables a cross trigger event to channel 2 when a ctitrigin input is activated.
        constexpr uint32_t TRIGINEN_3 = (1U << 3);  ///< Enables a cross trigger event to channel 3 when a ctitrigin input is activated.
    }

    /// CTIOUTEN[%s] Register bits
    namespace ctiouten[%s]_bits {
        constexpr uint32_t TRIGOUTEN_0 = (1U << 0);  ///< Enables a cross trigger event to ctitrigout when channel 0 is activated.
        constexpr uint32_t TRIGOUTEN_1 = (1U << 1);  ///< Enables a cross trigger event to ctitrigout when channel 1 is activated.
        constexpr uint32_t TRIGOUTEN_2 = (1U << 2);  ///< Enables a cross trigger event to ctitrigout when channel 2 is activated.
        constexpr uint32_t TRIGOUTEN_3 = (1U << 3);  ///< Enables a cross trigger event to ctitrigout when channel 3 is activated.
    }

    /// CTITRIGINSTATUS Register bits
    namespace ctitriginstatus_bits {
        constexpr uint32_t CPUHALTED = (1U << 0);  ///< Processor Halted
        constexpr uint32_t DWTCOMPOUT0 = (1U << 1);  ///< DWT Comparator Output 0
        constexpr uint32_t DWTCOMPOUT1 = (1U << 2);  ///< DWT Comparator Output 1
        constexpr uint32_t DWTCOMPOUT2 = (1U << 3);  ///< DWT Comparator Output 2
        constexpr uint32_t UNUSED0 = (1U << 4);  ///< N/A
        constexpr uint32_t UNUSED1 = (1U << 5);  ///< N/A
        constexpr uint32_t UNUSED2 = (1U << 6);  ///< N/A
        constexpr uint32_t UNUSED3 = (1U << 7);  ///< N/A
    }

    /// CTITRIGOUTSTATUS Register bits
    namespace ctitrigoutstatus_bits {
        constexpr uint32_t DEBUGREQ = (1U << 0);  ///< Processor debug request
        constexpr uint32_t CPURESTART = (1U << 1);  ///< Processor Restart
        constexpr uint32_t UNUSED0 = (1U << 2);  ///< N/A
        constexpr uint32_t UNUSED1 = (1U << 3);  ///< N/A
        constexpr uint32_t UNUSED2 = (1U << 4);  ///< N/A
        constexpr uint32_t UNUSED3 = (1U << 5);  ///< N/A
        constexpr uint32_t UNUSED4 = (1U << 6);  ///< N/A
        constexpr uint32_t UNUSED5 = (1U << 7);  ///< N/A
    }

    /// CTICHINSTATUS Register bits
    namespace ctichinstatus_bits {
        constexpr uint32_t CTICHINSTATUS_0 = (1U << 0);  ///< Shows the status of the ctitrigin 0 input.
        constexpr uint32_t CTICHINSTATUS_1 = (1U << 1);  ///< Shows the status of the ctitrigin 1 input.
        constexpr uint32_t CTICHINSTATUS_2 = (1U << 2);  ///< Shows the status of the ctitrigin 2 input.
        constexpr uint32_t CTICHINSTATUS_3 = (1U << 3);  ///< Shows the status of the ctitrigin 3 input.
    }

    /// CTIGATE Register bits
    namespace ctigate_bits {
        constexpr uint32_t CTIGATEEN_0 = (1U << 0);  ///< Enable ctichout0.
        constexpr uint32_t CTIGATEEN_1 = (1U << 1);  ///< Enable ctichout1.
        constexpr uint32_t CTIGATEEN_2 = (1U << 2);  ///< Enable ctichout2.
        constexpr uint32_t CTIGATEEN_3 = (1U << 3);  ///< Enable ctichout3.
    }

    /// DEVARCH Register bits
    namespace devarch_bits {
        constexpr uint32_t Architecture = (1U << 0);  ///< Contains the CTI device architecture.
    }

    /// DEVID Register bits
    namespace devid_bits {
        constexpr uint32_t EXTMUXNUM = (5 << 0);  ///< Indicates the number of multiplexers available on Trigger Inputs and Trigger Outputs that are using asicctl. The default value of 0b00000 indicates that no multiplexing is present.
        constexpr uint32_t NUMTRIG = (8 << 8);  ///< Number of ECT triggers available.
        constexpr uint32_t NUMCH = (4 << 16);  ///< Number of ECT channels available.
    }

    /// DEVTYPE Register bits
    namespace devtype_bits {
        constexpr uint32_t MAJOR = (4 << 0);  ///< Major classification of the type of the debug component as specified in the Arm Architecture Specification for this debug and trace component.
        constexpr uint32_t SUB = (4 << 4);  ///< Sub-classification of the type of the debug component as specified in the Arm Architecture Specification within the major classification as specified in the MAJOR field.
    }

    /// PIDR4 Register bits
    namespace pidr4_bits {
        constexpr uint32_t DES_2 = (4 << 0);  ///< Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.
        constexpr uint32_t SIZE = (4 << 4);  ///< Always 0b0000. Indicates that the device only occupies 4KB of memory.
    }

    /// PIDR0 Register bits
    namespace pidr0_bits {
        constexpr uint32_t PART_0 = (8 << 0);  ///< Bits[7:0] of the 12-bit part number of the component. The designer of the component assigns this part number.
    }

    /// PIDR1 Register bits
    namespace pidr1_bits {
        constexpr uint32_t PART_1 = (4 << 0);  ///< Bits[11:8] of the 12-bit part number of the component. The designer of the component assigns this part number.
        constexpr uint32_t DES_0 = (4 << 4);  ///< Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.
    }

    /// PIDR2 Register bits
    namespace pidr2_bits {
        constexpr uint32_t DES_1 = (3 << 0);  ///< Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.
        constexpr uint32_t JEDEC = (1U << 3);  ///< Always 1. Indicates that the JEDEC-assigned designer ID is used.
        constexpr uint32_t REVISION = (4 << 4);  ///< Peripheral revision
    }

    /// PIDR3 Register bits
    namespace pidr3_bits {
        constexpr uint32_t CMOD = (4 << 0);  ///< Customer Modified. Indicates whether the customer has modified the behavior of the component. In most cases, this field is 0b0000. Customers change this value when they make authorized modifications to this component.
        constexpr uint32_t REVAND = (4 << 4);  ///< Indicates minor errata fixes specific to the revision of the component being used, for example metal fixes after implementation. In most cases, this field is 0b0000. Arm recommends that the component designers ensure that a metal fix can change this field if required, for example, by driving it from registers that reset to 0b0000.
    }

    /// CIDR0 Register bits
    namespace cidr0_bits {
        constexpr uint32_t PRMBL_0 = (8 << 0);  ///< Preamble[0]. Contains bits[7:0] of the component identification code.
    }

    /// CIDR1 Register bits
    namespace cidr1_bits {
        constexpr uint32_t PRMBL_1 = (4 << 0);  ///< Preamble[1]. Contains bits[11:8] of the component identification code.
        constexpr uint32_t CLASS = (4 << 4);  ///< Class of the component, for example, whether the component is a ROM table or a generic CoreSight component. Contains bits[15:12] of the component identification code
    }

    /// CIDR2 Register bits
    namespace cidr2_bits {
        constexpr uint32_t PRMBL_2 = (8 << 0);  ///< Preamble[2]. Contains bits[23:16] of the component identification code.
    }

    /// CIDR3 Register bits
    namespace cidr3_bits {
        constexpr uint32_t PRMBL_3 = (8 << 0);  ///< Preamble[3]. Contains bits[31:24] of the component identification code.
    }

}

// ============================================================================
// DCNF Peripheral
// ============================================================================

namespace dcnf {
    /// Base addresses
    constexpr uint32_t DCNF_NS_BASE = 0x41000000;

    /// DCNF Register structure
    struct Registers {
        volatile uint32_t CPUID;  ///< Offset: 0x420 - CPU ID of this subsystem
    };

    /// Peripheral instances
    inline Registers* DCNF_NS = reinterpret_cast<Registers*>(DCNF_NS_BASE);

    // Bit definitions
    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t CPUID = (8 << 0);  ///< CPU ID
    }

}

// ============================================================================
// VREQCTRL Peripheral
// ============================================================================

namespace vreqctrl {
    /// Base addresses
    constexpr uint32_t VREQCTRL_NS_BASE = 0x41004000;

    /// VREQCTRL Register structure
    struct Registers {
        volatile uint32_t VREQH;  ///< Offset: 0x00 - Request high voltage on RADIO After requesting high...
        volatile uint32_t VREQHREADY;  ///< Offset: 0x08 - High voltage on RADIO is ready
    };

    /// Peripheral instances
    inline Registers* VREQCTRL_NS = reinterpret_cast<Registers*>(VREQCTRL_NS_BASE);

    // Bit definitions
    /// VREQH Register bits
    namespace vreqh_bits {
        constexpr uint32_t VREQH = (1U << 0);  ///< Request high voltage
    }

    /// VREQHREADY Register bits
    namespace vreqhready_bits {
        constexpr uint32_t READY = (1U << 0);  ///< RADIO is ready to operate on high voltage
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t CLOCK_NS_BASE = 0x41005000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t TASKS_HFCLKSTART;  ///< Offset: 0x00 - Start HFCLK128M/HFCLK64M source as selected in HFCLKSRC
        volatile uint32_t TASKS_HFCLKSTOP;  ///< Offset: 0x04 - Stop HFCLK128M/HFCLK64M source
        volatile uint32_t TASKS_LFCLKSTART;  ///< Offset: 0x08 - Start LFCLK source as selected in LFCLKSRC
        volatile uint32_t TASKS_LFCLKSTOP;  ///< Offset: 0x0C - Stop LFCLK source
        volatile uint32_t TASKS_CAL;  ///< Offset: 0x10 - Start calibration of LFRC oscillator
        volatile uint32_t SUBSCRIBE_HFCLKSTART;  ///< Offset: 0x80 - Subscribe configuration for task HFCLKSTART
        volatile uint32_t SUBSCRIBE_HFCLKSTOP;  ///< Offset: 0x84 - Subscribe configuration for task HFCLKSTOP
        volatile uint32_t SUBSCRIBE_LFCLKSTART;  ///< Offset: 0x88 - Subscribe configuration for task LFCLKSTART
        volatile uint32_t SUBSCRIBE_LFCLKSTOP;  ///< Offset: 0x8C - Subscribe configuration for task LFCLKSTOP
        volatile uint32_t SUBSCRIBE_CAL;  ///< Offset: 0x90 - Subscribe configuration for task CAL
        volatile uint32_t EVENTS_HFCLKSTARTED;  ///< Offset: 0x100 - HFCLK128M/HFCLK64M source started
        volatile uint32_t EVENTS_LFCLKSTARTED;  ///< Offset: 0x104 - LFCLK source started
        volatile uint32_t EVENTS_DONE;  ///< Offset: 0x11C - Calibration of LFRC oscillator complete event
        volatile uint32_t PUBLISH_HFCLKSTARTED;  ///< Offset: 0x180 - Publish configuration for event HFCLKSTARTED
        volatile uint32_t PUBLISH_LFCLKSTARTED;  ///< Offset: 0x184 - Publish configuration for event LFCLKSTARTED
        volatile uint32_t PUBLISH_DONE;  ///< Offset: 0x19C - Publish configuration for event DONE
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t INTPEND;  ///< Offset: 0x30C - Pending interrupts
        volatile uint32_t HFCLKRUN;  ///< Offset: 0x408 - Status indicating that HFCLKSTART task has been triggered
        volatile uint32_t HFCLKSTAT;  ///< Offset: 0x40C - Status indicating which HFCLK128M/HFCLK64M source is...
        volatile uint32_t LFCLKRUN;  ///< Offset: 0x414 - Status indicating that LFCLKSTART task has been triggered
        volatile uint32_t LFCLKSTAT;  ///< Offset: 0x418 - Status indicating which LFCLK source is running This...
        volatile uint32_t LFCLKSRCCOPY;  ///< Offset: 0x41C - Copy of LFCLKSRC register, set when LFCLKSTART task was triggered
        volatile uint32_t HFCLKSRC;  ///< Offset: 0x514 - Clock source for HFCLK128M/HFCLK64M
        volatile uint32_t LFCLKSRC;  ///< Offset: 0x518 - Clock source for LFCLK
        volatile uint32_t HFCLKCTRL;  ///< Offset: 0x558 - HFCLK128M frequency configuration
        volatile uint32_t HFCLKALWAYSRUN;  ///< Offset: 0x570 - Automatic or manual control of HFCLK128M/HFCLK64M
        volatile uint32_t LFCLKALWAYSRUN;  ///< Offset: 0x574 - Automatic or manual control of LFCLK
    };

    /// Peripheral instances
    inline Registers* CLOCK_NS = reinterpret_cast<Registers*>(CLOCK_NS_BASE);

    // Bit definitions
    /// TASKS_HFCLKSTART Register bits
    namespace tasks_hfclkstart_bits {
        constexpr uint32_t TASKS_HFCLKSTART = (1U << 0);  ///< Start HFCLK128M/HFCLK64M source as selected in HFCLKSRC
    }

    /// TASKS_HFCLKSTOP Register bits
    namespace tasks_hfclkstop_bits {
        constexpr uint32_t TASKS_HFCLKSTOP = (1U << 0);  ///< Stop HFCLK128M/HFCLK64M source
    }

    /// TASKS_LFCLKSTART Register bits
    namespace tasks_lfclkstart_bits {
        constexpr uint32_t TASKS_LFCLKSTART = (1U << 0);  ///< Start LFCLK source as selected in LFCLKSRC
    }

    /// TASKS_LFCLKSTOP Register bits
    namespace tasks_lfclkstop_bits {
        constexpr uint32_t TASKS_LFCLKSTOP = (1U << 0);  ///< Stop LFCLK source
    }

    /// TASKS_CAL Register bits
    namespace tasks_cal_bits {
        constexpr uint32_t TASKS_CAL = (1U << 0);  ///< Start calibration of LFRC oscillator
    }

    /// SUBSCRIBE_HFCLKSTART Register bits
    namespace subscribe_hfclkstart_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task HFCLKSTART will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_HFCLKSTOP Register bits
    namespace subscribe_hfclkstop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task HFCLKSTOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_LFCLKSTART Register bits
    namespace subscribe_lfclkstart_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task LFCLKSTART will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_LFCLKSTOP Register bits
    namespace subscribe_lfclkstop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task LFCLKSTOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CAL Register bits
    namespace subscribe_cal_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task CAL will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_HFCLKSTARTED Register bits
    namespace events_hfclkstarted_bits {
        constexpr uint32_t EVENTS_HFCLKSTARTED = (1U << 0);  ///< HFCLK128M/HFCLK64M source started
    }

    /// EVENTS_LFCLKSTARTED Register bits
    namespace events_lfclkstarted_bits {
        constexpr uint32_t EVENTS_LFCLKSTARTED = (1U << 0);  ///< LFCLK source started
    }

    /// EVENTS_DONE Register bits
    namespace events_done_bits {
        constexpr uint32_t EVENTS_DONE = (1U << 0);  ///< Calibration of LFRC oscillator complete event
    }

    /// PUBLISH_HFCLKSTARTED Register bits
    namespace publish_hfclkstarted_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event HFCLKSTARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_LFCLKSTARTED Register bits
    namespace publish_lfclkstarted_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event LFCLKSTARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_DONE Register bits
    namespace publish_done_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event DONE will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Enable or disable interrupt for event HFCLKSTARTED
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Enable or disable interrupt for event LFCLKSTARTED
        constexpr uint32_t DONE = (1U << 7);  ///< Enable or disable interrupt for event DONE
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Write '1' to enable interrupt for event HFCLKSTARTED
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Write '1' to enable interrupt for event LFCLKSTARTED
        constexpr uint32_t DONE = (1U << 7);  ///< Write '1' to enable interrupt for event DONE
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Write '1' to disable interrupt for event HFCLKSTARTED
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Write '1' to disable interrupt for event LFCLKSTARTED
        constexpr uint32_t DONE = (1U << 7);  ///< Write '1' to disable interrupt for event DONE
    }

    /// INTPEND Register bits
    namespace intpend_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Read pending status of interrupt for event HFCLKSTARTED
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Read pending status of interrupt for event LFCLKSTARTED
        constexpr uint32_t DONE = (1U << 7);  ///< Read pending status of interrupt for event DONE
    }

    /// HFCLKRUN Register bits
    namespace hfclkrun_bits {
        constexpr uint32_t STATUS = (1U << 0);  ///< HFCLKSTART task triggered or not
    }

    /// HFCLKSTAT Register bits
    namespace hfclkstat_bits {
        constexpr uint32_t SRC = (1U << 0);  ///< Active clock source
        constexpr uint32_t ALWAYSRUNNING = (1U << 4);  ///< ALWAYSRUN activated
        constexpr uint32_t STATE = (1U << 16);  ///< HFCLK state
    }

    /// LFCLKRUN Register bits
    namespace lfclkrun_bits {
        constexpr uint32_t STATUS = (1U << 0);  ///< LFCLKSTART task triggered or not
    }

    /// LFCLKSTAT Register bits
    namespace lfclkstat_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Active clock source
        constexpr uint32_t ALWAYSRUNNING = (1U << 4);  ///< ALWAYSRUN activated
        constexpr uint32_t STATE = (1U << 16);  ///< LFCLK state
    }

    /// LFCLKSRCCOPY Register bits
    namespace lfclksrccopy_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Clock source
    }

    /// HFCLKSRC Register bits
    namespace hfclksrc_bits {
        constexpr uint32_t SRC = (1U << 0);  ///< Select which HFCLK source is started by the HFCLKSTART task
    }

    /// LFCLKSRC Register bits
    namespace lfclksrc_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Select which LFCLK source is started by the LFCLKSTART task
    }

    /// HFCLKCTRL Register bits
    namespace hfclkctrl_bits {
        constexpr uint32_t HCLK = (2 << 0);  ///< High frequency clock HCLK
    }

    /// HFCLKALWAYSRUN Register bits
    namespace hfclkalwaysrun_bits {
        constexpr uint32_t ALWAYSRUN = (1U << 0);  ///< Ensure clock is always running
    }

    /// LFCLKALWAYSRUN Register bits
    namespace lfclkalwaysrun_bits {
        constexpr uint32_t ALWAYSRUN = (1U << 0);  ///< Ensure clock is always running
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t POWER_NS_BASE = 0x41005000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t TASKS_CONSTLAT;  ///< Offset: 0x78 - Enable Constant Latency mode
        volatile uint32_t TASKS_LOWPWR;  ///< Offset: 0x7C - Enable Low-Power mode (variable latency)
        volatile uint32_t SUBSCRIBE_CONSTLAT;  ///< Offset: 0xF8 - Subscribe configuration for task CONSTLAT
        volatile uint32_t SUBSCRIBE_LOWPWR;  ///< Offset: 0xFC - Subscribe configuration for task LOWPWR
        volatile uint32_t EVENTS_POFWARN;  ///< Offset: 0x108 - Power failure warning
        volatile uint32_t EVENTS_SLEEPENTER;  ///< Offset: 0x114 - CPU entered WFI/WFE sleep
        volatile uint32_t EVENTS_SLEEPEXIT;  ///< Offset: 0x118 - CPU exited WFI/WFE sleep
        volatile uint32_t PUBLISH_POFWARN;  ///< Offset: 0x188 - Publish configuration for event POFWARN
        volatile uint32_t PUBLISH_SLEEPENTER;  ///< Offset: 0x194 - Publish configuration for event SLEEPENTER
        volatile uint32_t PUBLISH_SLEEPEXIT;  ///< Offset: 0x198 - Publish configuration for event SLEEPEXIT
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t GPREGRET[%s];  ///< Offset: 0x51C - Description collection: General purpose retention register
    };

    /// Peripheral instances
    inline Registers* POWER_NS = reinterpret_cast<Registers*>(POWER_NS_BASE);

    // Bit definitions
    /// TASKS_CONSTLAT Register bits
    namespace tasks_constlat_bits {
        constexpr uint32_t TASKS_CONSTLAT = (1U << 0);  ///< Enable Constant Latency mode
    }

    /// TASKS_LOWPWR Register bits
    namespace tasks_lowpwr_bits {
        constexpr uint32_t TASKS_LOWPWR = (1U << 0);  ///< Enable Low-Power mode (variable latency)
    }

    /// SUBSCRIBE_CONSTLAT Register bits
    namespace subscribe_constlat_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task CONSTLAT will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_LOWPWR Register bits
    namespace subscribe_lowpwr_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task LOWPWR will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_POFWARN Register bits
    namespace events_pofwarn_bits {
        constexpr uint32_t EVENTS_POFWARN = (1U << 0);  ///< Power failure warning
    }

    /// EVENTS_SLEEPENTER Register bits
    namespace events_sleepenter_bits {
        constexpr uint32_t EVENTS_SLEEPENTER = (1U << 0);  ///< CPU entered WFI/WFE sleep
    }

    /// EVENTS_SLEEPEXIT Register bits
    namespace events_sleepexit_bits {
        constexpr uint32_t EVENTS_SLEEPEXIT = (1U << 0);  ///< CPU exited WFI/WFE sleep
    }

    /// PUBLISH_POFWARN Register bits
    namespace publish_pofwarn_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event POFWARN will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_SLEEPENTER Register bits
    namespace publish_sleepenter_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event SLEEPENTER will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_SLEEPEXIT Register bits
    namespace publish_sleepexit_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event SLEEPEXIT will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t POFWARN = (1U << 2);  ///< Enable or disable interrupt for event POFWARN
        constexpr uint32_t SLEEPENTER = (1U << 5);  ///< Enable or disable interrupt for event SLEEPENTER
        constexpr uint32_t SLEEPEXIT = (1U << 6);  ///< Enable or disable interrupt for event SLEEPEXIT
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t POFWARN = (1U << 2);  ///< Write '1' to enable interrupt for event POFWARN
        constexpr uint32_t SLEEPENTER = (1U << 5);  ///< Write '1' to enable interrupt for event SLEEPENTER
        constexpr uint32_t SLEEPEXIT = (1U << 6);  ///< Write '1' to enable interrupt for event SLEEPEXIT
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t POFWARN = (1U << 2);  ///< Write '1' to disable interrupt for event POFWARN
        constexpr uint32_t SLEEPENTER = (1U << 5);  ///< Write '1' to disable interrupt for event SLEEPENTER
        constexpr uint32_t SLEEPEXIT = (1U << 6);  ///< Write '1' to disable interrupt for event SLEEPEXIT
    }

    /// GPREGRET[%s] Register bits
    namespace gpregret[%s]_bits {
        constexpr uint32_t GPREGRET = (8 << 0);  ///< General purpose retention register
    }

}

// ============================================================================
// RESET Peripheral
// ============================================================================

namespace reset {
    /// Base addresses
    constexpr uint32_t RESET_NS_BASE = 0x41005000;

    /// RESET Register structure
    struct Registers {
        volatile uint32_t RESETREAS;  ///< Offset: 0x400 - Reset reason
    };

    /// Peripheral instances
    inline Registers* RESET_NS = reinterpret_cast<Registers*>(RESET_NS_BASE);

    // Bit definitions
    /// RESETREAS Register bits
    namespace resetreas_bits {
        constexpr uint32_t RESETPIN = (1U << 0);  ///< Reset from pin reset detected
        constexpr uint32_t DOG0 = (1U << 1);  ///< Reset from application watchdog timer 0 detected
        constexpr uint32_t CTRLAP = (1U << 2);  ///< Reset from application CTRL-AP detected
        constexpr uint32_t SREQ = (1U << 3);  ///< Reset from application soft reset detected
        constexpr uint32_t LOCKUP = (1U << 4);  ///< Reset from application CPU lockup detected
        constexpr uint32_t OFF = (1U << 5);  ///< Reset due to wakeup from System OFF mode when wakeup is triggered by DETECT signal from GPIO
        constexpr uint32_t LPCOMP = (1U << 6);  ///< Reset due to wakeup from System OFF mode when wakeup is triggered by ANADETECT signal from LPCOMP
        constexpr uint32_t DIF = (1U << 7);  ///< Reset due to wakeup from System OFF mode when wakeup is triggered by entering the Debug Interface mode
        constexpr uint32_t LSREQ = (1U << 16);  ///< Reset from network soft reset detected
        constexpr uint32_t LLOCKUP = (1U << 17);  ///< Reset from network CPU lockup detected
        constexpr uint32_t LDOG = (1U << 18);  ///< Reset from network watchdog timer detected
        constexpr uint32_t MFORCEOFF = (1U << 23);  ///< Force-OFF reset from application core detected
        constexpr uint32_t NFC = (1U << 24);  ///< Reset after wakeup from System OFF mode due to NFC field being detected
        constexpr uint32_t DOG1 = (1U << 25);  ///< Reset from application watchdog timer 1 detected
        constexpr uint32_t VBUS = (1U << 26);  ///< Reset after wakeup from System OFF mode due to VBUS rising into valid range
        constexpr uint32_t LCTRLAP = (1U << 27);  ///< Reset from network CTRL-AP detected
    }

}

// ============================================================================
// CTRLAP Peripheral
// ============================================================================

namespace ctrlap {
    /// Base addresses
    constexpr uint32_t CTRLAP_NS_BASE = 0x41006000;

    /// CTRLAP Register structure
    struct Registers {
        volatile uint32_t RXDATA;  ///< Offset: 0x00 - Data sent from the debugger to the CPU.
        volatile uint32_t RXSTATUS;  ///< Offset: 0x04 - This register shows a status that indicates if data sent...
        volatile uint32_t TXDATA;  ///< Offset: 0x80 - Data sent from the CPU to the debugger.
        volatile uint32_t TXSTATUS;  ///< Offset: 0x84 - This register shows a status that indicates if the data...
        volatile uint32_t LOCK;  ///< Offset: 0x00 - This register locks the APPROTECT.DISABLE register from...
        volatile uint32_t DISABLE;  ///< Offset: 0x04 - This register disables the APPROTECT register and...
        volatile uint32_t STATUS;  ///< Offset: 0x600 - Status bits for CTRL-AP peripheral.
    };

    /// Peripheral instances
    inline Registers* CTRLAP_NS = reinterpret_cast<Registers*>(CTRLAP_NS_BASE);

    // Bit definitions
    /// RXDATA Register bits
    namespace rxdata_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Data received from debugger
    }

    /// RXSTATUS Register bits
    namespace rxstatus_bits {
        constexpr uint32_t RXSTATUS = (1U << 0);  ///< Status of data in register RXDATA
    }

    /// TXDATA Register bits
    namespace txdata_bits {
        constexpr uint32_t TXDATA = (32 << 0);  ///< Data sent to debugger
    }

    /// TXSTATUS Register bits
    namespace txstatus_bits {
        constexpr uint32_t TXSTATUS = (1U << 0);  ///< Status of data in register TXDATA
    }

    /// LOCK Register bits
    namespace lock_bits {
        constexpr uint32_t LOCK = (1U << 0);  ///< Lock the APPROTECT.DISABLE register from being written to until next reset
    }

    /// DISABLE Register bits
    namespace disable_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< If the value of the KEY field is non-zero, and the KEY fields match on both the CPU and debugger sides, disable APPROTECT and enable debug access to non-secure mode until the next pin reset, brown-out reset, power-on reset, or watchog timer reset. After reset the debugger side register has a fixed KEY value. To enable debug access, both CTRL-AP and UICR.APPROTECT protection needs to be disabled.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t UICRAPPROTECT = (1U << 0);  ///< Status bit for UICR part of access port protection at last reset.
        constexpr uint32_t DBGIFACEMODE = (1U << 2);  ///< Status bit for device debug interface mode
    }

}

// ============================================================================
// RADIO Peripheral
// ============================================================================

namespace radio {
    /// Base addresses
    constexpr uint32_t RADIO_NS_BASE = 0x41008000;

    /// RADIO Register structure
    struct Registers {
        volatile uint32_t TASKS_TXEN;  ///< Offset: 0x00 - Enable RADIO in TX mode
        volatile uint32_t TASKS_RXEN;  ///< Offset: 0x04 - Enable RADIO in RX mode
        volatile uint32_t TASKS_START;  ///< Offset: 0x08 - Start RADIO
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x0C - Stop RADIO
        volatile uint32_t TASKS_DISABLE;  ///< Offset: 0x10 - Disable RADIO
        volatile uint32_t TASKS_RSSISTART;  ///< Offset: 0x14 - Start the RSSI and take one single sample of the receive...
        volatile uint32_t TASKS_RSSISTOP;  ///< Offset: 0x18 - Stop the RSSI measurement
        volatile uint32_t TASKS_BCSTART;  ///< Offset: 0x1C - Start the bit counter
        volatile uint32_t TASKS_BCSTOP;  ///< Offset: 0x20 - Stop the bit counter
        volatile uint32_t TASKS_EDSTART;  ///< Offset: 0x24 - Start the energy detect measurement used in IEEE 802.15.4 mode
        volatile uint32_t TASKS_EDSTOP;  ///< Offset: 0x28 - Stop the energy detect measurement
        volatile uint32_t TASKS_CCASTART;  ///< Offset: 0x2C - Start the clear channel assessment used in IEEE 802.15.4 mode
        volatile uint32_t TASKS_CCASTOP;  ///< Offset: 0x30 - Stop the clear channel assessment
        volatile uint32_t SUBSCRIBE_TXEN;  ///< Offset: 0x80 - Subscribe configuration for task TXEN
        volatile uint32_t SUBSCRIBE_RXEN;  ///< Offset: 0x84 - Subscribe configuration for task RXEN
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x88 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x8C - Subscribe configuration for task STOP
        volatile uint32_t SUBSCRIBE_DISABLE;  ///< Offset: 0x90 - Subscribe configuration for task DISABLE
        volatile uint32_t SUBSCRIBE_RSSISTART;  ///< Offset: 0x94 - Subscribe configuration for task RSSISTART
        volatile uint32_t SUBSCRIBE_RSSISTOP;  ///< Offset: 0x98 - Subscribe configuration for task RSSISTOP
        volatile uint32_t SUBSCRIBE_BCSTART;  ///< Offset: 0x9C - Subscribe configuration for task BCSTART
        volatile uint32_t SUBSCRIBE_BCSTOP;  ///< Offset: 0xA0 - Subscribe configuration for task BCSTOP
        volatile uint32_t SUBSCRIBE_EDSTART;  ///< Offset: 0xA4 - Subscribe configuration for task EDSTART
        volatile uint32_t SUBSCRIBE_EDSTOP;  ///< Offset: 0xA8 - Subscribe configuration for task EDSTOP
        volatile uint32_t SUBSCRIBE_CCASTART;  ///< Offset: 0xAC - Subscribe configuration for task CCASTART
        volatile uint32_t SUBSCRIBE_CCASTOP;  ///< Offset: 0xB0 - Subscribe configuration for task CCASTOP
        volatile uint32_t EVENTS_READY;  ///< Offset: 0x100 - RADIO has ramped up and is ready to be started
        volatile uint32_t EVENTS_ADDRESS;  ///< Offset: 0x104 - Address sent or received
        volatile uint32_t EVENTS_PAYLOAD;  ///< Offset: 0x108 - Packet payload sent or received
        volatile uint32_t EVENTS_END;  ///< Offset: 0x10C - Packet sent or received
        volatile uint32_t EVENTS_DISABLED;  ///< Offset: 0x110 - RADIO has been disabled
        volatile uint32_t EVENTS_DEVMATCH;  ///< Offset: 0x114 - A device address match occurred on the last received packet
        volatile uint32_t EVENTS_DEVMISS;  ///< Offset: 0x118 - No device address match occurred on the last received packet
        volatile uint32_t EVENTS_RSSIEND;  ///< Offset: 0x11C - Sampling of receive signal strength complete
        volatile uint32_t EVENTS_BCMATCH;  ///< Offset: 0x128 - Bit counter reached bit count value
        volatile uint32_t EVENTS_CRCOK;  ///< Offset: 0x130 - Packet received with CRC ok
        volatile uint32_t EVENTS_CRCERROR;  ///< Offset: 0x134 - Packet received with CRC error
        volatile uint32_t EVENTS_FRAMESTART;  ///< Offset: 0x138 - IEEE 802.15.4 length field received
        volatile uint32_t EVENTS_EDEND;  ///< Offset: 0x13C - Sampling of energy detection complete. A new ED sample...
        volatile uint32_t EVENTS_EDSTOPPED;  ///< Offset: 0x140 - The sampling of energy detection has stopped
        volatile uint32_t EVENTS_CCAIDLE;  ///< Offset: 0x144 - Wireless medium in idle - clear to send
        volatile uint32_t EVENTS_CCABUSY;  ///< Offset: 0x148 - Wireless medium busy - do not send
        volatile uint32_t EVENTS_CCASTOPPED;  ///< Offset: 0x14C - The CCA has stopped
        volatile uint32_t EVENTS_RATEBOOST;  ///< Offset: 0x150 - Ble_LR CI field received, receive mode is changed from...
        volatile uint32_t EVENTS_TXREADY;  ///< Offset: 0x154 - RADIO has ramped up and is ready to be started TX path
        volatile uint32_t EVENTS_RXREADY;  ///< Offset: 0x158 - RADIO has ramped up and is ready to be started RX path
        volatile uint32_t EVENTS_MHRMATCH;  ///< Offset: 0x15C - MAC header match found
        volatile uint32_t EVENTS_SYNC;  ///< Offset: 0x168 - Preamble indicator
        volatile uint32_t EVENTS_PHYEND;  ///< Offset: 0x16C - Generated when last bit is sent on air, or received from air
        volatile uint32_t EVENTS_CTEPRESENT;  ///< Offset: 0x170 - CTE is present (early warning right after receiving CTEInfo byte)
        volatile uint32_t PUBLISH_READY;  ///< Offset: 0x180 - Publish configuration for event READY
        volatile uint32_t PUBLISH_ADDRESS;  ///< Offset: 0x184 - Publish configuration for event ADDRESS
        volatile uint32_t PUBLISH_PAYLOAD;  ///< Offset: 0x188 - Publish configuration for event PAYLOAD
        volatile uint32_t PUBLISH_END;  ///< Offset: 0x18C - Publish configuration for event END
        volatile uint32_t PUBLISH_DISABLED;  ///< Offset: 0x190 - Publish configuration for event DISABLED
        volatile uint32_t PUBLISH_DEVMATCH;  ///< Offset: 0x194 - Publish configuration for event DEVMATCH
        volatile uint32_t PUBLISH_DEVMISS;  ///< Offset: 0x198 - Publish configuration for event DEVMISS
        volatile uint32_t PUBLISH_RSSIEND;  ///< Offset: 0x19C - Publish configuration for event RSSIEND
        volatile uint32_t PUBLISH_BCMATCH;  ///< Offset: 0x1A8 - Publish configuration for event BCMATCH
        volatile uint32_t PUBLISH_CRCOK;  ///< Offset: 0x1B0 - Publish configuration for event CRCOK
        volatile uint32_t PUBLISH_CRCERROR;  ///< Offset: 0x1B4 - Publish configuration for event CRCERROR
        volatile uint32_t PUBLISH_FRAMESTART;  ///< Offset: 0x1B8 - Publish configuration for event FRAMESTART
        volatile uint32_t PUBLISH_EDEND;  ///< Offset: 0x1BC - Publish configuration for event EDEND
        volatile uint32_t PUBLISH_EDSTOPPED;  ///< Offset: 0x1C0 - Publish configuration for event EDSTOPPED
        volatile uint32_t PUBLISH_CCAIDLE;  ///< Offset: 0x1C4 - Publish configuration for event CCAIDLE
        volatile uint32_t PUBLISH_CCABUSY;  ///< Offset: 0x1C8 - Publish configuration for event CCABUSY
        volatile uint32_t PUBLISH_CCASTOPPED;  ///< Offset: 0x1CC - Publish configuration for event CCASTOPPED
        volatile uint32_t PUBLISH_RATEBOOST;  ///< Offset: 0x1D0 - Publish configuration for event RATEBOOST
        volatile uint32_t PUBLISH_TXREADY;  ///< Offset: 0x1D4 - Publish configuration for event TXREADY
        volatile uint32_t PUBLISH_RXREADY;  ///< Offset: 0x1D8 - Publish configuration for event RXREADY
        volatile uint32_t PUBLISH_MHRMATCH;  ///< Offset: 0x1DC - Publish configuration for event MHRMATCH
        volatile uint32_t PUBLISH_SYNC;  ///< Offset: 0x1E8 - Publish configuration for event SYNC
        volatile uint32_t PUBLISH_PHYEND;  ///< Offset: 0x1EC - Publish configuration for event PHYEND
        volatile uint32_t PUBLISH_CTEPRESENT;  ///< Offset: 0x1F0 - Publish configuration for event CTEPRESENT
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t CRCSTATUS;  ///< Offset: 0x400 - CRC status
        volatile uint32_t RXMATCH;  ///< Offset: 0x408 - Received address
        volatile uint32_t RXCRC;  ///< Offset: 0x40C - CRC field of previously received packet
        volatile uint32_t DAI;  ///< Offset: 0x410 - Device address match index
        volatile uint32_t PDUSTAT;  ///< Offset: 0x414 - Payload status
        volatile uint32_t CTESTATUS;  ///< Offset: 0x44C - CTEInfo parsed from received packet
        volatile uint32_t DFESTATUS;  ///< Offset: 0x458 - DFE status information
        volatile uint32_t PACKETPTR;  ///< Offset: 0x504 - Packet pointer
        volatile uint32_t FREQUENCY;  ///< Offset: 0x508 - Frequency
        volatile uint32_t TXPOWER;  ///< Offset: 0x50C - Output power
        volatile uint32_t MODE;  ///< Offset: 0x510 - Data rate and modulation
        volatile uint32_t PCNF0;  ///< Offset: 0x514 - Packet configuration register 0
        volatile uint32_t PCNF1;  ///< Offset: 0x518 - Packet configuration register 1
        volatile uint32_t BASE0;  ///< Offset: 0x51C - Base address 0
        volatile uint32_t BASE1;  ///< Offset: 0x520 - Base address 1
        volatile uint32_t PREFIX0;  ///< Offset: 0x524 - Prefixes bytes for logical addresses 0-3
        volatile uint32_t PREFIX1;  ///< Offset: 0x528 - Prefixes bytes for logical addresses 4-7
        volatile uint32_t TXADDRESS;  ///< Offset: 0x52C - Transmit address select
        volatile uint32_t RXADDRESSES;  ///< Offset: 0x530 - Receive address select
        volatile uint32_t CRCCNF;  ///< Offset: 0x534 - CRC configuration
        volatile uint32_t CRCPOLY;  ///< Offset: 0x538 - CRC polynomial
        volatile uint32_t CRCINIT;  ///< Offset: 0x53C - CRC initial value
        volatile uint32_t TIFS;  ///< Offset: 0x544 - Interframe spacing in us
        volatile uint32_t RSSISAMPLE;  ///< Offset: 0x548 - RSSI sample
        volatile uint32_t STATE;  ///< Offset: 0x550 - Current radio state
        volatile uint32_t DATAWHITEIV;  ///< Offset: 0x554 - Data whitening initial value
        volatile uint32_t BCC;  ///< Offset: 0x560 - Bit counter compare
        volatile uint32_t DAB[%s];  ///< Offset: 0x600 - Description collection: Device address base segment n
        volatile uint32_t DAP[%s];  ///< Offset: 0x620 - Description collection: Device address prefix n
        volatile uint32_t DACNF;  ///< Offset: 0x640 - Device address match configuration
        volatile uint32_t MHRMATCHCONF;  ///< Offset: 0x644 - Search pattern configuration
        volatile uint32_t MHRMATCHMAS;  ///< Offset: 0x648 - Pattern mask
        volatile uint32_t MODECNF0;  ///< Offset: 0x650 - Radio mode configuration register 0
        volatile uint32_t SFD;  ///< Offset: 0x660 - IEEE 802.15.4 start of frame delimiter
        volatile uint32_t EDCNT;  ///< Offset: 0x664 - IEEE 802.15.4 energy detect loop count
        volatile uint32_t EDSAMPLE;  ///< Offset: 0x668 - IEEE 802.15.4 energy detect level
        volatile uint32_t CCACTRL;  ///< Offset: 0x66C - IEEE 802.15.4 clear channel assessment control
        volatile uint32_t DFEMODE;  ///< Offset: 0x900 - Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure (AOD)
        volatile uint32_t CTEINLINECONF;  ///< Offset: 0x904 - Configuration for CTE inline mode
        volatile uint32_t DFECTRL1;  ///< Offset: 0x910 - Various configuration for Direction finding
        volatile uint32_t DFECTRL2;  ///< Offset: 0x914 - Start offset for Direction finding
        volatile uint32_t SWITCHPATTERN;  ///< Offset: 0x928 - GPIO patterns to be used for each antenna
        volatile uint32_t CLEARPATTERN;  ///< Offset: 0x92C - Clear the GPIO pattern array for antenna control
        volatile uint32_t DFEGPIO[%s];  ///< Offset: 0x00 - Description collection: Pin select for DFE pin n
        volatile uint32_t PTR;  ///< Offset: 0x00 - Data pointer
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Maximum number of buffer words to transfer
        volatile uint32_t AMOUNT;  ///< Offset: 0x08 - Number of samples transferred in the last transaction
        volatile uint32_t POWER;  ///< Offset: 0xFFC - Peripheral power control
    };

    /// Peripheral instances
    inline Registers* RADIO_NS = reinterpret_cast<Registers*>(RADIO_NS_BASE);

    // Bit definitions
    /// TASKS_TXEN Register bits
    namespace tasks_txen_bits {
        constexpr uint32_t TASKS_TXEN = (1U << 0);  ///< Enable RADIO in TX mode
    }

    /// TASKS_RXEN Register bits
    namespace tasks_rxen_bits {
        constexpr uint32_t TASKS_RXEN = (1U << 0);  ///< Enable RADIO in RX mode
    }

    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start RADIO
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop RADIO
    }

    /// TASKS_DISABLE Register bits
    namespace tasks_disable_bits {
        constexpr uint32_t TASKS_DISABLE = (1U << 0);  ///< Disable RADIO
    }

    /// TASKS_RSSISTART Register bits
    namespace tasks_rssistart_bits {
        constexpr uint32_t TASKS_RSSISTART = (1U << 0);  ///< Start the RSSI and take one single sample of the receive signal strength
    }

    /// TASKS_RSSISTOP Register bits
    namespace tasks_rssistop_bits {
        constexpr uint32_t TASKS_RSSISTOP = (1U << 0);  ///< Stop the RSSI measurement
    }

    /// TASKS_BCSTART Register bits
    namespace tasks_bcstart_bits {
        constexpr uint32_t TASKS_BCSTART = (1U << 0);  ///< Start the bit counter
    }

    /// TASKS_BCSTOP Register bits
    namespace tasks_bcstop_bits {
        constexpr uint32_t TASKS_BCSTOP = (1U << 0);  ///< Stop the bit counter
    }

    /// TASKS_EDSTART Register bits
    namespace tasks_edstart_bits {
        constexpr uint32_t TASKS_EDSTART = (1U << 0);  ///< Start the energy detect measurement used in IEEE 802.15.4 mode
    }

    /// TASKS_EDSTOP Register bits
    namespace tasks_edstop_bits {
        constexpr uint32_t TASKS_EDSTOP = (1U << 0);  ///< Stop the energy detect measurement
    }

    /// TASKS_CCASTART Register bits
    namespace tasks_ccastart_bits {
        constexpr uint32_t TASKS_CCASTART = (1U << 0);  ///< Start the clear channel assessment used in IEEE 802.15.4 mode
    }

    /// TASKS_CCASTOP Register bits
    namespace tasks_ccastop_bits {
        constexpr uint32_t TASKS_CCASTOP = (1U << 0);  ///< Stop the clear channel assessment
    }

    /// SUBSCRIBE_TXEN Register bits
    namespace subscribe_txen_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task TXEN will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_RXEN Register bits
    namespace subscribe_rxen_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task RXEN will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_DISABLE Register bits
    namespace subscribe_disable_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task DISABLE will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_RSSISTART Register bits
    namespace subscribe_rssistart_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task RSSISTART will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_RSSISTOP Register bits
    namespace subscribe_rssistop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task RSSISTOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_BCSTART Register bits
    namespace subscribe_bcstart_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task BCSTART will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_BCSTOP Register bits
    namespace subscribe_bcstop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task BCSTOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_EDSTART Register bits
    namespace subscribe_edstart_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task EDSTART will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_EDSTOP Register bits
    namespace subscribe_edstop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task EDSTOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CCASTART Register bits
    namespace subscribe_ccastart_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task CCASTART will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CCASTOP Register bits
    namespace subscribe_ccastop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task CCASTOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_READY Register bits
    namespace events_ready_bits {
        constexpr uint32_t EVENTS_READY = (1U << 0);  ///< RADIO has ramped up and is ready to be started
    }

    /// EVENTS_ADDRESS Register bits
    namespace events_address_bits {
        constexpr uint32_t EVENTS_ADDRESS = (1U << 0);  ///< Address sent or received
    }

    /// EVENTS_PAYLOAD Register bits
    namespace events_payload_bits {
        constexpr uint32_t EVENTS_PAYLOAD = (1U << 0);  ///< Packet payload sent or received
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< Packet sent or received
    }

    /// EVENTS_DISABLED Register bits
    namespace events_disabled_bits {
        constexpr uint32_t EVENTS_DISABLED = (1U << 0);  ///< RADIO has been disabled
    }

    /// EVENTS_DEVMATCH Register bits
    namespace events_devmatch_bits {
        constexpr uint32_t EVENTS_DEVMATCH = (1U << 0);  ///< A device address match occurred on the last received packet
    }

    /// EVENTS_DEVMISS Register bits
    namespace events_devmiss_bits {
        constexpr uint32_t EVENTS_DEVMISS = (1U << 0);  ///< No device address match occurred on the last received packet
    }

    /// EVENTS_RSSIEND Register bits
    namespace events_rssiend_bits {
        constexpr uint32_t EVENTS_RSSIEND = (1U << 0);  ///< Sampling of receive signal strength complete
    }

    /// EVENTS_BCMATCH Register bits
    namespace events_bcmatch_bits {
        constexpr uint32_t EVENTS_BCMATCH = (1U << 0);  ///< Bit counter reached bit count value
    }

    /// EVENTS_CRCOK Register bits
    namespace events_crcok_bits {
        constexpr uint32_t EVENTS_CRCOK = (1U << 0);  ///< Packet received with CRC ok
    }

    /// EVENTS_CRCERROR Register bits
    namespace events_crcerror_bits {
        constexpr uint32_t EVENTS_CRCERROR = (1U << 0);  ///< Packet received with CRC error
    }

    /// EVENTS_FRAMESTART Register bits
    namespace events_framestart_bits {
        constexpr uint32_t EVENTS_FRAMESTART = (1U << 0);  ///< IEEE 802.15.4 length field received
    }

    /// EVENTS_EDEND Register bits
    namespace events_edend_bits {
        constexpr uint32_t EVENTS_EDEND = (1U << 0);  ///< Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register.
    }

    /// EVENTS_EDSTOPPED Register bits
    namespace events_edstopped_bits {
        constexpr uint32_t EVENTS_EDSTOPPED = (1U << 0);  ///< The sampling of energy detection has stopped
    }

    /// EVENTS_CCAIDLE Register bits
    namespace events_ccaidle_bits {
        constexpr uint32_t EVENTS_CCAIDLE = (1U << 0);  ///< Wireless medium in idle - clear to send
    }

    /// EVENTS_CCABUSY Register bits
    namespace events_ccabusy_bits {
        constexpr uint32_t EVENTS_CCABUSY = (1U << 0);  ///< Wireless medium busy - do not send
    }

    /// EVENTS_CCASTOPPED Register bits
    namespace events_ccastopped_bits {
        constexpr uint32_t EVENTS_CCASTOPPED = (1U << 0);  ///< The CCA has stopped
    }

    /// EVENTS_RATEBOOST Register bits
    namespace events_rateboost_bits {
        constexpr uint32_t EVENTS_RATEBOOST = (1U << 0);  ///< Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit.
    }

    /// EVENTS_TXREADY Register bits
    namespace events_txready_bits {
        constexpr uint32_t EVENTS_TXREADY = (1U << 0);  ///< RADIO has ramped up and is ready to be started TX path
    }

    /// EVENTS_RXREADY Register bits
    namespace events_rxready_bits {
        constexpr uint32_t EVENTS_RXREADY = (1U << 0);  ///< RADIO has ramped up and is ready to be started RX path
    }

    /// EVENTS_MHRMATCH Register bits
    namespace events_mhrmatch_bits {
        constexpr uint32_t EVENTS_MHRMATCH = (1U << 0);  ///< MAC header match found
    }

    /// EVENTS_SYNC Register bits
    namespace events_sync_bits {
        constexpr uint32_t EVENTS_SYNC = (1U << 0);  ///< Preamble indicator
    }

    /// EVENTS_PHYEND Register bits
    namespace events_phyend_bits {
        constexpr uint32_t EVENTS_PHYEND = (1U << 0);  ///< Generated when last bit is sent on air, or received from air
    }

    /// EVENTS_CTEPRESENT Register bits
    namespace events_ctepresent_bits {
        constexpr uint32_t EVENTS_CTEPRESENT = (1U << 0);  ///< CTE is present (early warning right after receiving CTEInfo byte)
    }

    /// PUBLISH_READY Register bits
    namespace publish_ready_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event READY will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ADDRESS Register bits
    namespace publish_address_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event ADDRESS will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_PAYLOAD Register bits
    namespace publish_payload_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event PAYLOAD will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_END Register bits
    namespace publish_end_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event END will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_DISABLED Register bits
    namespace publish_disabled_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event DISABLED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_DEVMATCH Register bits
    namespace publish_devmatch_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event DEVMATCH will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_DEVMISS Register bits
    namespace publish_devmiss_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event DEVMISS will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_RSSIEND Register bits
    namespace publish_rssiend_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event RSSIEND will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_BCMATCH Register bits
    namespace publish_bcmatch_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event BCMATCH will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_CRCOK Register bits
    namespace publish_crcok_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event CRCOK will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_CRCERROR Register bits
    namespace publish_crcerror_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event CRCERROR will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_FRAMESTART Register bits
    namespace publish_framestart_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event FRAMESTART will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_EDEND Register bits
    namespace publish_edend_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event EDEND will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_EDSTOPPED Register bits
    namespace publish_edstopped_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event EDSTOPPED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_CCAIDLE Register bits
    namespace publish_ccaidle_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event CCAIDLE will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_CCABUSY Register bits
    namespace publish_ccabusy_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event CCABUSY will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_CCASTOPPED Register bits
    namespace publish_ccastopped_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event CCASTOPPED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_RATEBOOST Register bits
    namespace publish_rateboost_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event RATEBOOST will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_TXREADY Register bits
    namespace publish_txready_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event TXREADY will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_RXREADY Register bits
    namespace publish_rxready_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event RXREADY will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_MHRMATCH Register bits
    namespace publish_mhrmatch_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event MHRMATCH will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_SYNC Register bits
    namespace publish_sync_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event SYNC will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_PHYEND Register bits
    namespace publish_phyend_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event PHYEND will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_CTEPRESENT Register bits
    namespace publish_ctepresent_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event CTEPRESENT will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t READY_START = (1U << 0);  ///< Shortcut between event READY and task START
        constexpr uint32_t END_DISABLE = (1U << 1);  ///< Shortcut between event END and task DISABLE
        constexpr uint32_t DISABLED_TXEN = (1U << 2);  ///< Shortcut between event DISABLED and task TXEN
        constexpr uint32_t DISABLED_RXEN = (1U << 3);  ///< Shortcut between event DISABLED and task RXEN
        constexpr uint32_t ADDRESS_RSSISTART = (1U << 4);  ///< Shortcut between event ADDRESS and task RSSISTART
        constexpr uint32_t END_START = (1U << 5);  ///< Shortcut between event END and task START
        constexpr uint32_t ADDRESS_BCSTART = (1U << 6);  ///< Shortcut between event ADDRESS and task BCSTART
        constexpr uint32_t DISABLED_RSSISTOP = (1U << 8);  ///< Shortcut between event DISABLED and task RSSISTOP
        constexpr uint32_t RXREADY_CCASTART = (1U << 11);  ///< Shortcut between event RXREADY and task CCASTART
        constexpr uint32_t CCAIDLE_TXEN = (1U << 12);  ///< Shortcut between event CCAIDLE and task TXEN
        constexpr uint32_t CCABUSY_DISABLE = (1U << 13);  ///< Shortcut between event CCABUSY and task DISABLE
        constexpr uint32_t FRAMESTART_BCSTART = (1U << 14);  ///< Shortcut between event FRAMESTART and task BCSTART
        constexpr uint32_t READY_EDSTART = (1U << 15);  ///< Shortcut between event READY and task EDSTART
        constexpr uint32_t EDEND_DISABLE = (1U << 16);  ///< Shortcut between event EDEND and task DISABLE
        constexpr uint32_t CCAIDLE_STOP = (1U << 17);  ///< Shortcut between event CCAIDLE and task STOP
        constexpr uint32_t TXREADY_START = (1U << 18);  ///< Shortcut between event TXREADY and task START
        constexpr uint32_t RXREADY_START = (1U << 19);  ///< Shortcut between event RXREADY and task START
        constexpr uint32_t PHYEND_DISABLE = (1U << 20);  ///< Shortcut between event PHYEND and task DISABLE
        constexpr uint32_t PHYEND_START = (1U << 21);  ///< Shortcut between event PHYEND and task START
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to enable interrupt for event READY
        constexpr uint32_t ADDRESS = (1U << 1);  ///< Write '1' to enable interrupt for event ADDRESS
        constexpr uint32_t PAYLOAD = (1U << 2);  ///< Write '1' to enable interrupt for event PAYLOAD
        constexpr uint32_t END = (1U << 3);  ///< Write '1' to enable interrupt for event END
        constexpr uint32_t DISABLED = (1U << 4);  ///< Write '1' to enable interrupt for event DISABLED
        constexpr uint32_t DEVMATCH = (1U << 5);  ///< Write '1' to enable interrupt for event DEVMATCH
        constexpr uint32_t DEVMISS = (1U << 6);  ///< Write '1' to enable interrupt for event DEVMISS
        constexpr uint32_t RSSIEND = (1U << 7);  ///< Write '1' to enable interrupt for event RSSIEND
        constexpr uint32_t BCMATCH = (1U << 10);  ///< Write '1' to enable interrupt for event BCMATCH
        constexpr uint32_t CRCOK = (1U << 12);  ///< Write '1' to enable interrupt for event CRCOK
        constexpr uint32_t CRCERROR = (1U << 13);  ///< Write '1' to enable interrupt for event CRCERROR
        constexpr uint32_t FRAMESTART = (1U << 14);  ///< Write '1' to enable interrupt for event FRAMESTART
        constexpr uint32_t EDEND = (1U << 15);  ///< Write '1' to enable interrupt for event EDEND
        constexpr uint32_t EDSTOPPED = (1U << 16);  ///< Write '1' to enable interrupt for event EDSTOPPED
        constexpr uint32_t CCAIDLE = (1U << 17);  ///< Write '1' to enable interrupt for event CCAIDLE
        constexpr uint32_t CCABUSY = (1U << 18);  ///< Write '1' to enable interrupt for event CCABUSY
        constexpr uint32_t CCASTOPPED = (1U << 19);  ///< Write '1' to enable interrupt for event CCASTOPPED
        constexpr uint32_t RATEBOOST = (1U << 20);  ///< Write '1' to enable interrupt for event RATEBOOST
        constexpr uint32_t TXREADY = (1U << 21);  ///< Write '1' to enable interrupt for event TXREADY
        constexpr uint32_t RXREADY = (1U << 22);  ///< Write '1' to enable interrupt for event RXREADY
        constexpr uint32_t MHRMATCH = (1U << 23);  ///< Write '1' to enable interrupt for event MHRMATCH
        constexpr uint32_t SYNC = (1U << 26);  ///< Write '1' to enable interrupt for event SYNC
        constexpr uint32_t PHYEND = (1U << 27);  ///< Write '1' to enable interrupt for event PHYEND
        constexpr uint32_t CTEPRESENT = (1U << 28);  ///< Write '1' to enable interrupt for event CTEPRESENT
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t READY = (1U << 0);  ///< Write '1' to disable interrupt for event READY
        constexpr uint32_t ADDRESS = (1U << 1);  ///< Write '1' to disable interrupt for event ADDRESS
        constexpr uint32_t PAYLOAD = (1U << 2);  ///< Write '1' to disable interrupt for event PAYLOAD
        constexpr uint32_t END = (1U << 3);  ///< Write '1' to disable interrupt for event END
        constexpr uint32_t DISABLED = (1U << 4);  ///< Write '1' to disable interrupt for event DISABLED
        constexpr uint32_t DEVMATCH = (1U << 5);  ///< Write '1' to disable interrupt for event DEVMATCH
        constexpr uint32_t DEVMISS = (1U << 6);  ///< Write '1' to disable interrupt for event DEVMISS
        constexpr uint32_t RSSIEND = (1U << 7);  ///< Write '1' to disable interrupt for event RSSIEND
        constexpr uint32_t BCMATCH = (1U << 10);  ///< Write '1' to disable interrupt for event BCMATCH
        constexpr uint32_t CRCOK = (1U << 12);  ///< Write '1' to disable interrupt for event CRCOK
        constexpr uint32_t CRCERROR = (1U << 13);  ///< Write '1' to disable interrupt for event CRCERROR
        constexpr uint32_t FRAMESTART = (1U << 14);  ///< Write '1' to disable interrupt for event FRAMESTART
        constexpr uint32_t EDEND = (1U << 15);  ///< Write '1' to disable interrupt for event EDEND
        constexpr uint32_t EDSTOPPED = (1U << 16);  ///< Write '1' to disable interrupt for event EDSTOPPED
        constexpr uint32_t CCAIDLE = (1U << 17);  ///< Write '1' to disable interrupt for event CCAIDLE
        constexpr uint32_t CCABUSY = (1U << 18);  ///< Write '1' to disable interrupt for event CCABUSY
        constexpr uint32_t CCASTOPPED = (1U << 19);  ///< Write '1' to disable interrupt for event CCASTOPPED
        constexpr uint32_t RATEBOOST = (1U << 20);  ///< Write '1' to disable interrupt for event RATEBOOST
        constexpr uint32_t TXREADY = (1U << 21);  ///< Write '1' to disable interrupt for event TXREADY
        constexpr uint32_t RXREADY = (1U << 22);  ///< Write '1' to disable interrupt for event RXREADY
        constexpr uint32_t MHRMATCH = (1U << 23);  ///< Write '1' to disable interrupt for event MHRMATCH
        constexpr uint32_t SYNC = (1U << 26);  ///< Write '1' to disable interrupt for event SYNC
        constexpr uint32_t PHYEND = (1U << 27);  ///< Write '1' to disable interrupt for event PHYEND
        constexpr uint32_t CTEPRESENT = (1U << 28);  ///< Write '1' to disable interrupt for event CTEPRESENT
    }

    /// CRCSTATUS Register bits
    namespace crcstatus_bits {
        constexpr uint32_t CRCSTATUS = (1U << 0);  ///< CRC status of packet received
    }

    /// RXMATCH Register bits
    namespace rxmatch_bits {
        constexpr uint32_t RXMATCH = (3 << 0);  ///< Received address
    }

    /// RXCRC Register bits
    namespace rxcrc_bits {
        constexpr uint32_t RXCRC = (24 << 0);  ///< CRC field of previously received packet
    }

    /// DAI Register bits
    namespace dai_bits {
        constexpr uint32_t DAI = (3 << 0);  ///< Device address match index
    }

    /// PDUSTAT Register bits
    namespace pdustat_bits {
        constexpr uint32_t PDUSTAT = (1U << 0);  ///< Status on payload length vs. PCNF1.MAXLEN
        constexpr uint32_t CISTAT = (2 << 1);  ///< Status on what rate packet is received with in Long Range
    }

    /// CTESTATUS Register bits
    namespace ctestatus_bits {
        constexpr uint32_t CTETIME = (5 << 0);  ///< CTETime parsed from packet
        constexpr uint32_t RFU = (1U << 5);  ///< RFU parsed from packet
        constexpr uint32_t CTETYPE = (2 << 6);  ///< CTEType parsed from packet
    }

    /// DFESTATUS Register bits
    namespace dfestatus_bits {
        constexpr uint32_t SWITCHINGSTATE = (3 << 0);  ///< Internal state of switching state machine
        constexpr uint32_t SAMPLINGSTATE = (1U << 4);  ///< Internal state of sampling state machine
    }

    /// PACKETPTR Register bits
    namespace packetptr_bits {
        constexpr uint32_t PACKETPTR = (32 << 0);  ///< Packet pointer
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (7 << 0);  ///< Radio channel frequency
        constexpr uint32_t MAP = (1U << 8);  ///< Channel map selection
    }

    /// TXPOWER Register bits
    namespace txpower_bits {
        constexpr uint32_t TXPOWER = (8 << 0);  ///< RADIO output power
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (4 << 0);  ///< Radio data rate and modulation setting. The radio supports frequency-shift keying (FSK) modulation.
    }

    /// PCNF0 Register bits
    namespace pcnf0_bits {
        constexpr uint32_t LFLEN = (4 << 0);  ///< Length on air of LENGTH field in number of bits
        constexpr uint32_t S0LEN = (1U << 8);  ///< Length on air of S0 field in number of bytes
        constexpr uint32_t S1LEN = (4 << 16);  ///< Length on air of S1 field in number of bits
        constexpr uint32_t S1INCL = (1U << 20);  ///< Include or exclude S1 field in RAM
        constexpr uint32_t CILEN = (2 << 22);  ///< Length of code indicator - Long Range
        constexpr uint32_t PLEN = (2 << 24);  ///< Length of preamble on air. Decision point: TASKS_START task
        constexpr uint32_t CRCINC = (1U << 26);  ///< Indicates if LENGTH field contains CRC or not
        constexpr uint32_t TERMLEN = (2 << 29);  ///< Length of TERM field in Long Range operation
    }

    /// PCNF1 Register bits
    namespace pcnf1_bits {
        constexpr uint32_t MAXLEN = (8 << 0);  ///< Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN.
        constexpr uint32_t STATLEN = (8 << 8);  ///< Static length in number of bytes
        constexpr uint32_t BALEN = (3 << 16);  ///< Base address length in number of bytes
        constexpr uint32_t ENDIAN = (1U << 24);  ///< On-air endianness of packet, this applies to the S0, LENGTH, S1, and the PAYLOAD fields.
        constexpr uint32_t WHITEEN = (1U << 25);  ///< Enable or disable packet whitening
    }

    /// BASE0 Register bits
    namespace base0_bits {
        constexpr uint32_t BASE0 = (32 << 0);  ///< Base address 0
    }

    /// BASE1 Register bits
    namespace base1_bits {
        constexpr uint32_t BASE1 = (32 << 0);  ///< Base address 1
    }

    /// PREFIX0 Register bits
    namespace prefix0_bits {
        constexpr uint32_t AP0 = (8 << 0);  ///< Address prefix 0.
        constexpr uint32_t AP1 = (8 << 8);  ///< Address prefix 1.
        constexpr uint32_t AP2 = (8 << 16);  ///< Address prefix 2.
        constexpr uint32_t AP3 = (8 << 24);  ///< Address prefix 3.
    }

    /// PREFIX1 Register bits
    namespace prefix1_bits {
        constexpr uint32_t AP4 = (8 << 0);  ///< Address prefix 4.
        constexpr uint32_t AP5 = (8 << 8);  ///< Address prefix 5.
        constexpr uint32_t AP6 = (8 << 16);  ///< Address prefix 6.
        constexpr uint32_t AP7 = (8 << 24);  ///< Address prefix 7.
    }

    /// TXADDRESS Register bits
    namespace txaddress_bits {
        constexpr uint32_t TXADDRESS = (3 << 0);  ///< Transmit address select
    }

    /// RXADDRESSES Register bits
    namespace rxaddresses_bits {
        constexpr uint32_t ADDR0 = (1U << 0);  ///< Enable or disable reception on logical address 0.
        constexpr uint32_t ADDR1 = (1U << 1);  ///< Enable or disable reception on logical address 1.
        constexpr uint32_t ADDR2 = (1U << 2);  ///< Enable or disable reception on logical address 2.
        constexpr uint32_t ADDR3 = (1U << 3);  ///< Enable or disable reception on logical address 3.
        constexpr uint32_t ADDR4 = (1U << 4);  ///< Enable or disable reception on logical address 4.
        constexpr uint32_t ADDR5 = (1U << 5);  ///< Enable or disable reception on logical address 5.
        constexpr uint32_t ADDR6 = (1U << 6);  ///< Enable or disable reception on logical address 6.
        constexpr uint32_t ADDR7 = (1U << 7);  ///< Enable or disable reception on logical address 7.
    }

    /// CRCCNF Register bits
    namespace crccnf_bits {
        constexpr uint32_t LEN = (2 << 0);  ///< CRC length in number of bytes For MODE Ble_LR125Kbit and Ble_LR500Kbit, only LEN set to 3 is supported
        constexpr uint32_t SKIPADDR = (2 << 8);  ///< Include or exclude packet address field out of CRC calculation.
    }

    /// CRCPOLY Register bits
    namespace crcpoly_bits {
        constexpr uint32_t CRCPOLY = (24 << 0);  ///< CRC polynomial
    }

    /// CRCINIT Register bits
    namespace crcinit_bits {
        constexpr uint32_t CRCINIT = (24 << 0);  ///< CRC initial value
    }

    /// TIFS Register bits
    namespace tifs_bits {
        constexpr uint32_t TIFS = (10 << 0);  ///< Interframe spacing in us.
    }

    /// RSSISAMPLE Register bits
    namespace rssisample_bits {
        constexpr uint32_t RSSISAMPLE = (7 << 0);  ///< RSSI sample.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t STATE = (4 << 0);  ///< Current radio state
    }

    /// DATAWHITEIV Register bits
    namespace datawhiteiv_bits {
        constexpr uint32_t DATAWHITEIV = (7 << 0);  ///< Data whitening initial value. Bit 6 is hardwired to '1', writing '0' to it has no effect, and it will always be read back and used by the device as '1'.
    }

    /// BCC Register bits
    namespace bcc_bits {
        constexpr uint32_t BCC = (32 << 0);  ///< Bit counter compare
    }

    /// DAB[%s] Register bits
    namespace dab[%s]_bits {
        constexpr uint32_t DAB = (32 << 0);  ///< Device address base segment n
    }

    /// DAP[%s] Register bits
    namespace dap[%s]_bits {
        constexpr uint32_t DAP = (16 << 0);  ///< Device address prefix n
    }

    /// DACNF Register bits
    namespace dacnf_bits {
        constexpr uint32_t ENA0 = (1U << 0);  ///< Enable or disable device address matching using device address 0
        constexpr uint32_t ENA1 = (1U << 1);  ///< Enable or disable device address matching using device address 1
        constexpr uint32_t ENA2 = (1U << 2);  ///< Enable or disable device address matching using device address 2
        constexpr uint32_t ENA3 = (1U << 3);  ///< Enable or disable device address matching using device address 3
        constexpr uint32_t ENA4 = (1U << 4);  ///< Enable or disable device address matching using device address 4
        constexpr uint32_t ENA5 = (1U << 5);  ///< Enable or disable device address matching using device address 5
        constexpr uint32_t ENA6 = (1U << 6);  ///< Enable or disable device address matching using device address 6
        constexpr uint32_t ENA7 = (1U << 7);  ///< Enable or disable device address matching using device address 7
        constexpr uint32_t TXADD0 = (1U << 8);  ///< TxAdd for device address 0
        constexpr uint32_t TXADD1 = (1U << 9);  ///< TxAdd for device address 1
        constexpr uint32_t TXADD2 = (1U << 10);  ///< TxAdd for device address 2
        constexpr uint32_t TXADD3 = (1U << 11);  ///< TxAdd for device address 3
        constexpr uint32_t TXADD4 = (1U << 12);  ///< TxAdd for device address 4
        constexpr uint32_t TXADD5 = (1U << 13);  ///< TxAdd for device address 5
        constexpr uint32_t TXADD6 = (1U << 14);  ///< TxAdd for device address 6
        constexpr uint32_t TXADD7 = (1U << 15);  ///< TxAdd for device address 7
    }

    /// MHRMATCHCONF Register bits
    namespace mhrmatchconf_bits {
        constexpr uint32_t MHRMATCHCONF = (32 << 0);  ///< Search pattern configuration
    }

    /// MHRMATCHMAS Register bits
    namespace mhrmatchmas_bits {
        constexpr uint32_t MHRMATCHMAS = (32 << 0);  ///< Pattern mask
    }

    /// MODECNF0 Register bits
    namespace modecnf0_bits {
        constexpr uint32_t RU = (1U << 0);  ///< Radio ramp-up time
        constexpr uint32_t DTX = (2 << 8);  ///< Default TX value
    }

    /// SFD Register bits
    namespace sfd_bits {
        constexpr uint32_t SFD = (8 << 0);  ///< IEEE 802.15.4 start of frame delimiter
    }

    /// EDCNT Register bits
    namespace edcnt_bits {
        constexpr uint32_t EDCNT = (21 << 0);  ///< IEEE 802.15.4 energy detect loop count
    }

    /// EDSAMPLE Register bits
    namespace edsample_bits {
        constexpr uint32_t EDLVL = (8 << 0);  ///< IEEE 802.15.4 energy detect level
    }

    /// CCACTRL Register bits
    namespace ccactrl_bits {
        constexpr uint32_t CCAMODE = (3 << 0);  ///< CCA mode of operation
        constexpr uint32_t CCAEDTHRES = (8 << 8);  ///< CCA energy busy threshold. Used in all the CCA modes except CarrierMode.
        constexpr uint32_t CCACORRTHRES = (8 << 16);  ///< CCA correlator busy threshold. Only relevant to CarrierMode, CarrierAndEdMode, and CarrierOrEdMode.
        constexpr uint32_t CCACORRCNT = (8 << 24);  ///< Limit for occurances above CCACORRTHRES. When not equal to zero the corrolator based signal detect is enabled.
    }

    /// DFEMODE Register bits
    namespace dfemode_bits {
        constexpr uint32_t DFEOPMODE = (2 << 0);  ///< Direction finding operation mode
    }

    /// CTEINLINECONF Register bits
    namespace cteinlineconf_bits {
        constexpr uint32_t CTEINLINECTRLEN = (1U << 0);  ///< Enable parsing of CTEInfo from received packet in BLE modes
        constexpr uint32_t CTEINFOINS1 = (1U << 3);  ///< CTEInfo is S1 byte or not
        constexpr uint32_t CTEERRORHANDLING = (1U << 4);  ///< Sampling/switching if CRC is not OK
        constexpr uint32_t CTETIMEVALIDRANGE = (2 << 6);  ///< Max range of CTETime
        constexpr uint32_t CTEINLINERXMODE1US = (3 << 10);  ///< Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set.
        constexpr uint32_t CTEINLINERXMODE2US = (3 << 13);  ///< Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set.
        constexpr uint32_t S0CONF = (8 << 16);  ///< S0 bit pattern to match
        constexpr uint32_t S0MASK = (8 << 24);  ///< S0 bit mask to set which bit to match
    }

    /// DFECTRL1 Register bits
    namespace dfectrl1_bits {
        constexpr uint32_t NUMBEROF8US = (6 << 0);  ///< Length of the AoA/AoD procedure in number of 8 us units
        constexpr uint32_t DFEINEXTENSION = (1U << 7);  ///< Add CTE extension and do antenna switching/sampling in this extension
        constexpr uint32_t TSWITCHSPACING = (3 << 8);  ///< Interval between every time the antenna is changed in the SWITCHING state
        constexpr uint32_t TSAMPLESPACINGREF = (3 << 12);  ///< Interval between samples in the REFERENCE period
        constexpr uint32_t SAMPLETYPE = (1U << 15);  ///< Whether to sample I/Q or magnitude/phase
        constexpr uint32_t TSAMPLESPACING = (3 << 16);  ///< Interval between samples in the SWITCHING period when CTEINLINECTRLEN is 0
        constexpr uint32_t REPEATPATTERN = (4 << 20);  ///< Repeat each individual antenna pattern N times sequentially, i.e. P0, P0, P1, P1, P2, P2, P3, P3, etc.
        constexpr uint32_t AGCBACKOFFGAIN = (4 << 24);  ///< Gain will be lowered by the specified number of gain steps at the start of CTE
    }

    /// DFECTRL2 Register bits
    namespace dfectrl2_bits {
        constexpr uint32_t TSWITCHOFFSET = (13 << 0);  ///< Signed value offset after the end of the CRC before starting switching in number of 16 MHz clock cycles
        constexpr uint32_t TSAMPLEOFFSET = (12 << 16);  ///< Signed value offset in number of 16 MHz clock cycles for fine tuning of the sampling instant for all IQ samples. With TSAMPLEOFFSET=0 the first sample is taken immediately at the start of the reference period
    }

    /// SWITCHPATTERN Register bits
    namespace switchpattern_bits {
        constexpr uint32_t SWITCHPATTERN = (8 << 0);  ///< Fill array of GPIO patterns for antenna control.
    }

    /// CLEARPATTERN Register bits
    namespace clearpattern_bits {
        constexpr uint32_t CLEARPATTERN = (1U << 0);  ///< Clears GPIO pattern array for antenna control
    }

    /// DFEGPIO[%s] Register bits
    namespace dfegpio[%s]_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Data pointer
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t MAXCNT = (14 << 0);  ///< Maximum number of buffer words to transfer
    }

    /// AMOUNT Register bits
    namespace amount_bits {
        constexpr uint32_t AMOUNT = (16 << 0);  ///< Number of samples transferred in the last transaction
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t POWER = (1U << 0);  ///< Peripheral power control. The peripheral and its registers will be reset to its initial state by switching the peripheral off and then back on again.
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_NS_BASE = 0x41009000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Task starting the random number generator
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Task stopping the random number generator
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x80 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x84 - Subscribe configuration for task STOP
        volatile uint32_t EVENTS_VALRDY;  ///< Offset: 0x100 - Event being generated for every new random number...
        volatile uint32_t PUBLISH_VALRDY;  ///< Offset: 0x180 - Publish configuration for event VALRDY
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t CONFIG;  ///< Offset: 0x504 - Configuration register
        volatile uint32_t VALUE;  ///< Offset: 0x508 - Output random number
    };

    /// Peripheral instances
    inline Registers* RNG_NS = reinterpret_cast<Registers*>(RNG_NS_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Task starting the random number generator
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Task stopping the random number generator
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_VALRDY Register bits
    namespace events_valrdy_bits {
        constexpr uint32_t EVENTS_VALRDY = (1U << 0);  ///< Event being generated for every new random number written to the VALUE register
    }

    /// PUBLISH_VALRDY Register bits
    namespace publish_valrdy_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event VALRDY will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t VALRDY_STOP = (1U << 0);  ///< Shortcut between event VALRDY and task STOP
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t VALRDY = (1U << 0);  ///< Write '1' to enable interrupt for event VALRDY
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t VALRDY = (1U << 0);  ///< Write '1' to disable interrupt for event VALRDY
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t DERCEN = (1U << 0);  ///< Bias correction
    }

    /// VALUE Register bits
    namespace value_bits {
        constexpr uint32_t VALUE = (8 << 0);  ///< Generated random number
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOTE_NS_BASE = 0x4100A000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t TASKS_OUT[%s];  ///< Offset: 0x00 - Description collection: Task for writing to pin...
        volatile uint32_t TASKS_SET[%s];  ///< Offset: 0x30 - Description collection: Task for writing to pin...
        volatile uint32_t TASKS_CLR[%s];  ///< Offset: 0x60 - Description collection: Task for writing to pin...
        volatile uint32_t SUBSCRIBE_OUT[%s];  ///< Offset: 0x80 - Description collection: Subscribe configuration for task OUT[n]
        volatile uint32_t SUBSCRIBE_SET[%s];  ///< Offset: 0xB0 - Description collection: Subscribe configuration for task SET[n]
        volatile uint32_t SUBSCRIBE_CLR[%s];  ///< Offset: 0xE0 - Description collection: Subscribe configuration for task CLR[n]
        volatile uint32_t EVENTS_IN[%s];  ///< Offset: 0x100 - Description collection: Event generated from pin...
        volatile uint32_t EVENTS_PORT;  ///< Offset: 0x17C - Event generated from multiple input GPIO pins with SENSE...
        volatile uint32_t PUBLISH_IN[%s];  ///< Offset: 0x180 - Description collection: Publish configuration for event IN[n]
        volatile uint32_t PUBLISH_PORT;  ///< Offset: 0x1FC - Publish configuration for event PORT
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t LATENCY;  ///< Offset: 0x504 - Latency selection for Event mode (MODE=Event) with...
        volatile uint32_t CONFIG[%s];  ///< Offset: 0x510 - Description collection: Configuration for OUT[n],...
    };

    /// Peripheral instances
    inline Registers* GPIOTE_NS = reinterpret_cast<Registers*>(GPIOTE_NS_BASE);

    // Bit definitions
    /// TASKS_OUT[%s] Register bits
    namespace tasks_out[%s]_bits {
        constexpr uint32_t TASKS_OUT = (1U << 0);  ///< Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is configured in CONFIG[n].POLARITY.
    }

    /// TASKS_SET[%s] Register bits
    namespace tasks_set[%s]_bits {
        constexpr uint32_t TASKS_SET = (1U << 0);  ///< Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it high.
    }

    /// TASKS_CLR[%s] Register bits
    namespace tasks_clr[%s]_bits {
        constexpr uint32_t TASKS_CLR = (1U << 0);  ///< Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it low.
    }

    /// SUBSCRIBE_OUT[%s] Register bits
    namespace subscribe_out[%s]_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task OUT[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_SET[%s] Register bits
    namespace subscribe_set[%s]_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task SET[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CLR[%s] Register bits
    namespace subscribe_clr[%s]_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task CLR[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_IN[%s] Register bits
    namespace events_in[%s]_bits {
        constexpr uint32_t EVENTS_IN = (1U << 0);  ///< Event generated from pin specified in CONFIG[n].PSEL
    }

    /// EVENTS_PORT Register bits
    namespace events_port_bits {
        constexpr uint32_t EVENTS_PORT = (1U << 0);  ///< Event generated from multiple input GPIO pins with SENSE mechanism enabled
    }

    /// PUBLISH_IN[%s] Register bits
    namespace publish_in[%s]_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event IN[n] will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_PORT Register bits
    namespace publish_port_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event PORT will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t IN0 = (1U << 0);  ///< Write '1' to enable interrupt for event IN[0]
        constexpr uint32_t IN1 = (1U << 1);  ///< Write '1' to enable interrupt for event IN[1]
        constexpr uint32_t IN2 = (1U << 2);  ///< Write '1' to enable interrupt for event IN[2]
        constexpr uint32_t IN3 = (1U << 3);  ///< Write '1' to enable interrupt for event IN[3]
        constexpr uint32_t IN4 = (1U << 4);  ///< Write '1' to enable interrupt for event IN[4]
        constexpr uint32_t IN5 = (1U << 5);  ///< Write '1' to enable interrupt for event IN[5]
        constexpr uint32_t IN6 = (1U << 6);  ///< Write '1' to enable interrupt for event IN[6]
        constexpr uint32_t IN7 = (1U << 7);  ///< Write '1' to enable interrupt for event IN[7]
        constexpr uint32_t PORT = (1U << 31);  ///< Write '1' to enable interrupt for event PORT
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t IN0 = (1U << 0);  ///< Write '1' to disable interrupt for event IN[0]
        constexpr uint32_t IN1 = (1U << 1);  ///< Write '1' to disable interrupt for event IN[1]
        constexpr uint32_t IN2 = (1U << 2);  ///< Write '1' to disable interrupt for event IN[2]
        constexpr uint32_t IN3 = (1U << 3);  ///< Write '1' to disable interrupt for event IN[3]
        constexpr uint32_t IN4 = (1U << 4);  ///< Write '1' to disable interrupt for event IN[4]
        constexpr uint32_t IN5 = (1U << 5);  ///< Write '1' to disable interrupt for event IN[5]
        constexpr uint32_t IN6 = (1U << 6);  ///< Write '1' to disable interrupt for event IN[6]
        constexpr uint32_t IN7 = (1U << 7);  ///< Write '1' to disable interrupt for event IN[7]
        constexpr uint32_t PORT = (1U << 31);  ///< Write '1' to disable interrupt for event PORT
    }

    /// LATENCY Register bits
    namespace latency_bits {
        constexpr uint32_t LATENCY = (1U << 0);  ///< Latency setting
    }

    /// CONFIG[%s] Register bits
    namespace config[%s]_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Mode
        constexpr uint32_t PSEL = (5 << 8);  ///< GPIO number associated with SET[n], CLR[n], and OUT[n] tasks and IN[n] event
        constexpr uint32_t PORT = (1U << 13);  ///< Port number
        constexpr uint32_t POLARITY = (2 << 16);  ///< When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event.
        constexpr uint32_t OUTINIT = (1U << 20);  ///< When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect.
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_NS_BASE = 0x4100B000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start WDT
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop WDT
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x80 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x84 - Subscribe configuration for task STOP
        volatile uint32_t EVENTS_TIMEOUT;  ///< Offset: 0x100 - Watchdog timeout
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - Watchdog stopped
        volatile uint32_t PUBLISH_TIMEOUT;  ///< Offset: 0x180 - Publish configuration for event TIMEOUT
        volatile uint32_t PUBLISH_STOPPED;  ///< Offset: 0x184 - Publish configuration for event STOPPED
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t NMIENSET;  ///< Offset: 0x324 - Enable interrupt
        volatile uint32_t NMIENCLR;  ///< Offset: 0x328 - Disable interrupt
        volatile uint32_t RUNSTATUS;  ///< Offset: 0x400 - Run status
        volatile uint32_t REQSTATUS;  ///< Offset: 0x404 - Request status
        volatile uint32_t CRV;  ///< Offset: 0x504 - Counter reload value
        volatile uint32_t RREN;  ///< Offset: 0x508 - Enable register for reload request registers
        volatile uint32_t CONFIG;  ///< Offset: 0x50C - Configuration register
        volatile uint32_t TSEN;  ///< Offset: 0x520 - Task stop enable
        volatile uint32_t RR[%s];  ///< Offset: 0x600 - Description collection: Reload request n
    };

    /// Peripheral instances
    inline Registers* WDT_NS = reinterpret_cast<Registers*>(WDT_NS_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start WDT
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop WDT
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_TIMEOUT Register bits
    namespace events_timeout_bits {
        constexpr uint32_t EVENTS_TIMEOUT = (1U << 0);  ///< Watchdog timeout
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< Watchdog stopped
    }

    /// PUBLISH_TIMEOUT Register bits
    namespace publish_timeout_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event TIMEOUT will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_STOPPED Register bits
    namespace publish_stopped_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event STOPPED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TIMEOUT = (1U << 0);  ///< Write '1' to enable interrupt for event TIMEOUT
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TIMEOUT = (1U << 0);  ///< Write '1' to disable interrupt for event TIMEOUT
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
    }

    /// NMIENSET Register bits
    namespace nmienset_bits {
        constexpr uint32_t TIMEOUT = (1U << 0);  ///< Write '1' to enable interrupt for event TIMEOUT
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
    }

    /// NMIENCLR Register bits
    namespace nmienclr_bits {
        constexpr uint32_t TIMEOUT = (1U << 0);  ///< Write '1' to disable interrupt for event TIMEOUT
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
    }

    /// RUNSTATUS Register bits
    namespace runstatus_bits {
        constexpr uint32_t RUNSTATUSWDT = (1U << 0);  ///< Indicates whether or not WDT is running
    }

    /// REQSTATUS Register bits
    namespace reqstatus_bits {
        constexpr uint32_t RR0 = (1U << 0);  ///< Request status for RR[0] register
        constexpr uint32_t RR1 = (1U << 1);  ///< Request status for RR[1] register
        constexpr uint32_t RR2 = (1U << 2);  ///< Request status for RR[2] register
        constexpr uint32_t RR3 = (1U << 3);  ///< Request status for RR[3] register
        constexpr uint32_t RR4 = (1U << 4);  ///< Request status for RR[4] register
        constexpr uint32_t RR5 = (1U << 5);  ///< Request status for RR[5] register
        constexpr uint32_t RR6 = (1U << 6);  ///< Request status for RR[6] register
        constexpr uint32_t RR7 = (1U << 7);  ///< Request status for RR[7] register
    }

    /// CRV Register bits
    namespace crv_bits {
        constexpr uint32_t CRV = (32 << 0);  ///< Counter reload value in number of cycles of the 32.768 kHz clock
    }

    /// RREN Register bits
    namespace rren_bits {
        constexpr uint32_t RR0 = (1U << 0);  ///< Enable or disable RR[0] register
        constexpr uint32_t RR1 = (1U << 1);  ///< Enable or disable RR[1] register
        constexpr uint32_t RR2 = (1U << 2);  ///< Enable or disable RR[2] register
        constexpr uint32_t RR3 = (1U << 3);  ///< Enable or disable RR[3] register
        constexpr uint32_t RR4 = (1U << 4);  ///< Enable or disable RR[4] register
        constexpr uint32_t RR5 = (1U << 5);  ///< Enable or disable RR[5] register
        constexpr uint32_t RR6 = (1U << 6);  ///< Enable or disable RR[6] register
        constexpr uint32_t RR7 = (1U << 7);  ///< Enable or disable RR[7] register
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t SLEEP = (1U << 0);  ///< Configure WDT to either be paused, or kept running, while the CPU is sleeping
        constexpr uint32_t HALT = (1U << 3);  ///< Configure WDT to either be paused, or kept running, while the CPU is halted by the debugger
        constexpr uint32_t STOPEN = (1U << 6);  ///< Allow stopping WDT
    }

    /// TSEN Register bits
    namespace tsen_bits {
        constexpr uint32_t TSEN = (32 << 0);  ///< Allow stopping WDT
    }

    /// RR[%s] Register bits
    namespace rr[%s]_bits {
        constexpr uint32_t RR = (32 << 0);  ///< Reload request register
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER0_NS_BASE = 0x4100C000;
    constexpr uint32_t TIMER1_NS_BASE = 0x41018000;
    constexpr uint32_t TIMER2_NS_BASE = 0x41019000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start Timer
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop Timer
        volatile uint32_t TASKS_COUNT;  ///< Offset: 0x08 - Increment Timer (Counter mode only)
        volatile uint32_t TASKS_CLEAR;  ///< Offset: 0x0C - Clear time
        volatile uint32_t TASKS_SHUTDOWN;  ///< Offset: 0x10 - Deprecated register - Shut down timer
        volatile uint32_t TASKS_CAPTURE[%s];  ///< Offset: 0x40 - Description collection: Capture Timer value to CC[n] register
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x80 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x84 - Subscribe configuration for task STOP
        volatile uint32_t SUBSCRIBE_COUNT;  ///< Offset: 0x88 - Subscribe configuration for task COUNT
        volatile uint32_t SUBSCRIBE_CLEAR;  ///< Offset: 0x8C - Subscribe configuration for task CLEAR
        volatile uint32_t SUBSCRIBE_SHUTDOWN;  ///< Offset: 0x90 - Deprecated register - Subscribe configuration for task SHUTDOWN
        volatile uint32_t SUBSCRIBE_CAPTURE[%s];  ///< Offset: 0xC0 - Description collection: Subscribe configuration for task...
        volatile uint32_t EVENTS_COMPARE[%s];  ///< Offset: 0x140 - Description collection: Compare event on CC[n] match
        volatile uint32_t PUBLISH_COMPARE[%s];  ///< Offset: 0x1C0 - Description collection: Publish configuration for event...
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t MODE;  ///< Offset: 0x504 - Timer mode selection
        volatile uint32_t BITMODE;  ///< Offset: 0x508 - Configure the number of bits used by the TIMER
        volatile uint32_t PRESCALER;  ///< Offset: 0x510 - Timer prescaler register
        volatile uint32_t CC[%s];  ///< Offset: 0x540 - Description collection: Capture/Compare register n
        volatile uint32_t ONESHOTEN[%s];  ///< Offset: 0x580 - Description collection: Enable one-shot operation for...
    };

    /// Peripheral instances
    inline Registers* TIMER0_NS = reinterpret_cast<Registers*>(TIMER0_NS_BASE);
    inline Registers* TIMER1_NS = reinterpret_cast<Registers*>(TIMER1_NS_BASE);
    inline Registers* TIMER2_NS = reinterpret_cast<Registers*>(TIMER2_NS_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start Timer
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop Timer
    }

    /// TASKS_COUNT Register bits
    namespace tasks_count_bits {
        constexpr uint32_t TASKS_COUNT = (1U << 0);  ///< Increment Timer (Counter mode only)
    }

    /// TASKS_CLEAR Register bits
    namespace tasks_clear_bits {
        constexpr uint32_t TASKS_CLEAR = (1U << 0);  ///< Clear time
    }

    /// TASKS_SHUTDOWN Register bits
    namespace tasks_shutdown_bits {
        constexpr uint32_t TASKS_SHUTDOWN = (1U << 0);  ///< Deprecated field - Shut down timer
    }

    /// TASKS_CAPTURE[%s] Register bits
    namespace tasks_capture[%s]_bits {
        constexpr uint32_t TASKS_CAPTURE = (1U << 0);  ///< Capture Timer value to CC[n] register
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_COUNT Register bits
    namespace subscribe_count_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task COUNT will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CLEAR Register bits
    namespace subscribe_clear_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task CLEAR will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_SHUTDOWN Register bits
    namespace subscribe_shutdown_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task SHUTDOWN will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CAPTURE[%s] Register bits
    namespace subscribe_capture[%s]_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task CAPTURE[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_COMPARE[%s] Register bits
    namespace events_compare[%s]_bits {
        constexpr uint32_t EVENTS_COMPARE = (1U << 0);  ///< Compare event on CC[n] match
    }

    /// PUBLISH_COMPARE[%s] Register bits
    namespace publish_compare[%s]_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event COMPARE[n] will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t COMPARE0_CLEAR = (1U << 0);  ///< Shortcut between event COMPARE[0] and task CLEAR
        constexpr uint32_t COMPARE1_CLEAR = (1U << 1);  ///< Shortcut between event COMPARE[1] and task CLEAR
        constexpr uint32_t COMPARE2_CLEAR = (1U << 2);  ///< Shortcut between event COMPARE[2] and task CLEAR
        constexpr uint32_t COMPARE3_CLEAR = (1U << 3);  ///< Shortcut between event COMPARE[3] and task CLEAR
        constexpr uint32_t COMPARE4_CLEAR = (1U << 4);  ///< Shortcut between event COMPARE[4] and task CLEAR
        constexpr uint32_t COMPARE5_CLEAR = (1U << 5);  ///< Shortcut between event COMPARE[5] and task CLEAR
        constexpr uint32_t COMPARE6_CLEAR = (1U << 6);  ///< Shortcut between event COMPARE[6] and task CLEAR
        constexpr uint32_t COMPARE7_CLEAR = (1U << 7);  ///< Shortcut between event COMPARE[7] and task CLEAR
        constexpr uint32_t COMPARE0_STOP = (1U << 16);  ///< Shortcut between event COMPARE[0] and task STOP
        constexpr uint32_t COMPARE1_STOP = (1U << 17);  ///< Shortcut between event COMPARE[1] and task STOP
        constexpr uint32_t COMPARE2_STOP = (1U << 18);  ///< Shortcut between event COMPARE[2] and task STOP
        constexpr uint32_t COMPARE3_STOP = (1U << 19);  ///< Shortcut between event COMPARE[3] and task STOP
        constexpr uint32_t COMPARE4_STOP = (1U << 20);  ///< Shortcut between event COMPARE[4] and task STOP
        constexpr uint32_t COMPARE5_STOP = (1U << 21);  ///< Shortcut between event COMPARE[5] and task STOP
        constexpr uint32_t COMPARE6_STOP = (1U << 22);  ///< Shortcut between event COMPARE[6] and task STOP
        constexpr uint32_t COMPARE7_STOP = (1U << 23);  ///< Shortcut between event COMPARE[7] and task STOP
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Enable or disable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Enable or disable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Enable or disable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Enable or disable interrupt for event COMPARE[3]
        constexpr uint32_t COMPARE4 = (1U << 20);  ///< Enable or disable interrupt for event COMPARE[4]
        constexpr uint32_t COMPARE5 = (1U << 21);  ///< Enable or disable interrupt for event COMPARE[5]
        constexpr uint32_t COMPARE6 = (1U << 22);  ///< Enable or disable interrupt for event COMPARE[6]
        constexpr uint32_t COMPARE7 = (1U << 23);  ///< Enable or disable interrupt for event COMPARE[7]
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to enable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to enable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to enable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to enable interrupt for event COMPARE[3]
        constexpr uint32_t COMPARE4 = (1U << 20);  ///< Write '1' to enable interrupt for event COMPARE[4]
        constexpr uint32_t COMPARE5 = (1U << 21);  ///< Write '1' to enable interrupt for event COMPARE[5]
        constexpr uint32_t COMPARE6 = (1U << 22);  ///< Write '1' to enable interrupt for event COMPARE[6]
        constexpr uint32_t COMPARE7 = (1U << 23);  ///< Write '1' to enable interrupt for event COMPARE[7]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to disable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to disable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to disable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to disable interrupt for event COMPARE[3]
        constexpr uint32_t COMPARE4 = (1U << 20);  ///< Write '1' to disable interrupt for event COMPARE[4]
        constexpr uint32_t COMPARE5 = (1U << 21);  ///< Write '1' to disable interrupt for event COMPARE[5]
        constexpr uint32_t COMPARE6 = (1U << 22);  ///< Write '1' to disable interrupt for event COMPARE[6]
        constexpr uint32_t COMPARE7 = (1U << 23);  ///< Write '1' to disable interrupt for event COMPARE[7]
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Timer mode
    }

    /// BITMODE Register bits
    namespace bitmode_bits {
        constexpr uint32_t BITMODE = (2 << 0);  ///< Timer bit width
    }

    /// PRESCALER Register bits
    namespace prescaler_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< Prescaler value
    }

    /// CC[%s] Register bits
    namespace cc[%s]_bits {
        constexpr uint32_t CC = (32 << 0);  ///< Capture/Compare value
    }

    /// ONESHOTEN[%s] Register bits
    namespace oneshoten[%s]_bits {
        constexpr uint32_t ONESHOTEN = (1U << 0);  ///< Enable one-shot operation
    }

}

// ============================================================================
// ECB Peripheral
// ============================================================================

namespace ecb {
    /// Base addresses
    constexpr uint32_t ECB_NS_BASE = 0x4100D000;

    /// ECB Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTECB;  ///< Offset: 0x00 - Start ECB block encrypt
        volatile uint32_t TASKS_STOPECB;  ///< Offset: 0x04 - Abort a possible executing ECB operation
        volatile uint32_t SUBSCRIBE_STARTECB;  ///< Offset: 0x80 - Subscribe configuration for task STARTECB
        volatile uint32_t SUBSCRIBE_STOPECB;  ///< Offset: 0x84 - Subscribe configuration for task STOPECB
        volatile uint32_t EVENTS_ENDECB;  ///< Offset: 0x100 - ECB block encrypt complete
        volatile uint32_t EVENTS_ERRORECB;  ///< Offset: 0x104 - ECB block encrypt aborted because of a STOPECB task or...
        volatile uint32_t PUBLISH_ENDECB;  ///< Offset: 0x180 - Publish configuration for event ENDECB
        volatile uint32_t PUBLISH_ERRORECB;  ///< Offset: 0x184 - Publish configuration for event ERRORECB
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ECBDATAPTR;  ///< Offset: 0x504 - ECB block encrypt memory pointers
    };

    /// Peripheral instances
    inline Registers* ECB_NS = reinterpret_cast<Registers*>(ECB_NS_BASE);

    // Bit definitions
    /// TASKS_STARTECB Register bits
    namespace tasks_startecb_bits {
        constexpr uint32_t TASKS_STARTECB = (1U << 0);  ///< Start ECB block encrypt
    }

    /// TASKS_STOPECB Register bits
    namespace tasks_stopecb_bits {
        constexpr uint32_t TASKS_STOPECB = (1U << 0);  ///< Abort a possible executing ECB operation
    }

    /// SUBSCRIBE_STARTECB Register bits
    namespace subscribe_startecb_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STARTECB will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOPECB Register bits
    namespace subscribe_stopecb_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STOPECB will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_ENDECB Register bits
    namespace events_endecb_bits {
        constexpr uint32_t EVENTS_ENDECB = (1U << 0);  ///< ECB block encrypt complete
    }

    /// EVENTS_ERRORECB Register bits
    namespace events_errorecb_bits {
        constexpr uint32_t EVENTS_ERRORECB = (1U << 0);  ///< ECB block encrypt aborted because of a STOPECB task or due to an error
    }

    /// PUBLISH_ENDECB Register bits
    namespace publish_endecb_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event ENDECB will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ERRORECB Register bits
    namespace publish_errorecb_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event ERRORECB will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t ENDECB = (1U << 0);  ///< Write '1' to enable interrupt for event ENDECB
        constexpr uint32_t ERRORECB = (1U << 1);  ///< Write '1' to enable interrupt for event ERRORECB
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t ENDECB = (1U << 0);  ///< Write '1' to disable interrupt for event ENDECB
        constexpr uint32_t ERRORECB = (1U << 1);  ///< Write '1' to disable interrupt for event ERRORECB
    }

    /// ECBDATAPTR Register bits
    namespace ecbdataptr_bits {
        constexpr uint32_t ECBDATAPTR = (32 << 0);  ///< Pointer to the ECB data structure (see Table 1 ECB data structure overview)
    }

}

// ============================================================================
// AAR Peripheral
// ============================================================================

namespace aar {
    /// Base addresses
    constexpr uint32_t AAR_NS_BASE = 0x4100E000;

    /// AAR Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start resolving addresses based on IRKs specified in the...
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x08 - Stop resolving addresses
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x80 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x88 - Subscribe configuration for task STOP
        volatile uint32_t EVENTS_END;  ///< Offset: 0x100 - Address resolution procedure complete
        volatile uint32_t EVENTS_RESOLVED;  ///< Offset: 0x104 - Address resolved
        volatile uint32_t EVENTS_NOTRESOLVED;  ///< Offset: 0x108 - Address not resolved
        volatile uint32_t PUBLISH_END;  ///< Offset: 0x180 - Publish configuration for event END
        volatile uint32_t PUBLISH_RESOLVED;  ///< Offset: 0x184 - Publish configuration for event RESOLVED
        volatile uint32_t PUBLISH_NOTRESOLVED;  ///< Offset: 0x188 - Publish configuration for event NOTRESOLVED
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t STATUS;  ///< Offset: 0x400 - Resolution status
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable AAR
        volatile uint32_t NIRK;  ///< Offset: 0x504 - Number of IRKs
        volatile uint32_t IRKPTR;  ///< Offset: 0x508 - Pointer to IRK data structure
        volatile uint32_t ADDRPTR;  ///< Offset: 0x510 - Pointer to the resolvable address
        volatile uint32_t SCRATCHPTR;  ///< Offset: 0x514 - Pointer to data area used for temporary storage
    };

    /// Peripheral instances
    inline Registers* AAR_NS = reinterpret_cast<Registers*>(AAR_NS_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start resolving addresses based on IRKs specified in the IRK data structure
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop resolving addresses
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< Address resolution procedure complete
    }

    /// EVENTS_RESOLVED Register bits
    namespace events_resolved_bits {
        constexpr uint32_t EVENTS_RESOLVED = (1U << 0);  ///< Address resolved
    }

    /// EVENTS_NOTRESOLVED Register bits
    namespace events_notresolved_bits {
        constexpr uint32_t EVENTS_NOTRESOLVED = (1U << 0);  ///< Address not resolved
    }

    /// PUBLISH_END Register bits
    namespace publish_end_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event END will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_RESOLVED Register bits
    namespace publish_resolved_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event RESOLVED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_NOTRESOLVED Register bits
    namespace publish_notresolved_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event NOTRESOLVED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t END = (1U << 0);  ///< Write '1' to enable interrupt for event END
        constexpr uint32_t RESOLVED = (1U << 1);  ///< Write '1' to enable interrupt for event RESOLVED
        constexpr uint32_t NOTRESOLVED = (1U << 2);  ///< Write '1' to enable interrupt for event NOTRESOLVED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t END = (1U << 0);  ///< Write '1' to disable interrupt for event END
        constexpr uint32_t RESOLVED = (1U << 1);  ///< Write '1' to disable interrupt for event RESOLVED
        constexpr uint32_t NOTRESOLVED = (1U << 2);  ///< Write '1' to disable interrupt for event NOTRESOLVED
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATUS = (4 << 0);  ///< The IRK that was used last time an address was resolved
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (2 << 0);  ///< Enable or disable AAR
    }

    /// NIRK Register bits
    namespace nirk_bits {
        constexpr uint32_t NIRK = (5 << 0);  ///< Number of Identity Root Keys available in the IRK data structure
    }

    /// IRKPTR Register bits
    namespace irkptr_bits {
        constexpr uint32_t IRKPTR = (32 << 0);  ///< Pointer to the IRK data structure
    }

    /// ADDRPTR Register bits
    namespace addrptr_bits {
        constexpr uint32_t ADDRPTR = (32 << 0);  ///< Pointer to the resolvable address (6-bytes)
    }

    /// SCRATCHPTR Register bits
    namespace scratchptr_bits {
        constexpr uint32_t SCRATCHPTR = (32 << 0);  ///< Pointer to a scratch data area used for temporary storage during resolution. A space of minimum 3 bytes must be reserved.
    }

}

// ============================================================================
// CCM Peripheral
// ============================================================================

namespace ccm {
    /// Base addresses
    constexpr uint32_t CCM_NS_BASE = 0x4100E000;

    /// CCM Register structure
    struct Registers {
        volatile uint32_t TASKS_KSGEN;  ///< Offset: 0x00 - Start generation of keystream. This operation will stop...
        volatile uint32_t TASKS_CRYPT;  ///< Offset: 0x04 - Start encryption/decryption. This operation will stop by...
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x08 - Stop encryption/decryption
        volatile uint32_t TASKS_RATEOVERRIDE;  ///< Offset: 0x0C - Override DATARATE setting in MODE register with the...
        volatile uint32_t SUBSCRIBE_KSGEN;  ///< Offset: 0x80 - Subscribe configuration for task KSGEN
        volatile uint32_t SUBSCRIBE_CRYPT;  ///< Offset: 0x84 - Subscribe configuration for task CRYPT
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x88 - Subscribe configuration for task STOP
        volatile uint32_t SUBSCRIBE_RATEOVERRIDE;  ///< Offset: 0x8C - Subscribe configuration for task RATEOVERRIDE
        volatile uint32_t EVENTS_ENDKSGEN;  ///< Offset: 0x100 - Keystream generation complete
        volatile uint32_t EVENTS_ENDCRYPT;  ///< Offset: 0x104 - Encrypt/decrypt complete
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x108 - Deprecated register - CCM error event
        volatile uint32_t PUBLISH_ENDKSGEN;  ///< Offset: 0x180 - Publish configuration for event ENDKSGEN
        volatile uint32_t PUBLISH_ENDCRYPT;  ///< Offset: 0x184 - Publish configuration for event ENDCRYPT
        volatile uint32_t PUBLISH_ERROR;  ///< Offset: 0x188 - Deprecated register - Publish configuration for event ERROR
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t MICSTATUS;  ///< Offset: 0x400 - MIC check result
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable
        volatile uint32_t MODE;  ///< Offset: 0x504 - Operation mode
        volatile uint32_t CNFPTR;  ///< Offset: 0x508 - Pointer to data structure holding the AES key and the...
        volatile uint32_t INPTR;  ///< Offset: 0x50C - Input pointer
        volatile uint32_t OUTPTR;  ///< Offset: 0x510 - Output pointer
        volatile uint32_t SCRATCHPTR;  ///< Offset: 0x514 - Pointer to data area used for temporary storage
        volatile uint32_t MAXPACKETSIZE;  ///< Offset: 0x518 - Length of keystream generated when MODE.LENGTH = Extended
        volatile uint32_t RATEOVERRIDE;  ///< Offset: 0x51C - Data rate override setting.
        volatile uint32_t HEADERMASK;  ///< Offset: 0x520 - Header (S0) mask.
    };

    /// Peripheral instances
    inline Registers* CCM_NS = reinterpret_cast<Registers*>(CCM_NS_BASE);

    // Bit definitions
    /// TASKS_KSGEN Register bits
    namespace tasks_ksgen_bits {
        constexpr uint32_t TASKS_KSGEN = (1U << 0);  ///< Start generation of keystream. This operation will stop by itself when completed.
    }

    /// TASKS_CRYPT Register bits
    namespace tasks_crypt_bits {
        constexpr uint32_t TASKS_CRYPT = (1U << 0);  ///< Start encryption/decryption. This operation will stop by itself when completed.
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop encryption/decryption
    }

    /// TASKS_RATEOVERRIDE Register bits
    namespace tasks_rateoverride_bits {
        constexpr uint32_t TASKS_RATEOVERRIDE = (1U << 0);  ///< Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption
    }

    /// SUBSCRIBE_KSGEN Register bits
    namespace subscribe_ksgen_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task KSGEN will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CRYPT Register bits
    namespace subscribe_crypt_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task CRYPT will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_RATEOVERRIDE Register bits
    namespace subscribe_rateoverride_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task RATEOVERRIDE will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_ENDKSGEN Register bits
    namespace events_endksgen_bits {
        constexpr uint32_t EVENTS_ENDKSGEN = (1U << 0);  ///< Keystream generation complete
    }

    /// EVENTS_ENDCRYPT Register bits
    namespace events_endcrypt_bits {
        constexpr uint32_t EVENTS_ENDCRYPT = (1U << 0);  ///< Encrypt/decrypt complete
    }

    /// EVENTS_ERROR Register bits
    namespace events_error_bits {
        constexpr uint32_t EVENTS_ERROR = (1U << 0);  ///< Deprecated field - CCM error event
    }

    /// PUBLISH_ENDKSGEN Register bits
    namespace publish_endksgen_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event ENDKSGEN will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ENDCRYPT Register bits
    namespace publish_endcrypt_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event ENDCRYPT will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ERROR Register bits
    namespace publish_error_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event ERROR will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t ENDKSGEN_CRYPT = (1U << 0);  ///< Shortcut between event ENDKSGEN and task CRYPT
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t ENDKSGEN = (1U << 0);  ///< Write '1' to enable interrupt for event ENDKSGEN
        constexpr uint32_t ENDCRYPT = (1U << 1);  ///< Write '1' to enable interrupt for event ENDCRYPT
        constexpr uint32_t ERROR = (1U << 2);  ///< Deprecated intsetfield - Write '1' to enable interrupt for event ERROR
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t ENDKSGEN = (1U << 0);  ///< Write '1' to disable interrupt for event ENDKSGEN
        constexpr uint32_t ENDCRYPT = (1U << 1);  ///< Write '1' to disable interrupt for event ENDCRYPT
        constexpr uint32_t ERROR = (1U << 2);  ///< Deprecated intclrfield - Write '1' to disable interrupt for event ERROR
    }

    /// MICSTATUS Register bits
    namespace micstatus_bits {
        constexpr uint32_t MICSTATUS = (1U << 0);  ///< The result of the MIC check performed during the previous decryption operation
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (2 << 0);  ///< Enable or disable CCM
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< The mode of operation to be used. Settings in this register apply whenever either the KSGEN task or the CRYPT task is triggered.
        constexpr uint32_t DATARATE = (2 << 16);  ///< Radio data rate that the CCM shall run synchronous with
        constexpr uint32_t LENGTH = (1U << 24);  ///< Packet length configuration
    }

    /// CNFPTR Register bits
    namespace cnfptr_bits {
        constexpr uint32_t CNFPTR = (32 << 0);  ///< Pointer to the data structure holding the AES key and the CCM NONCE vector (see table CCM data structure overview)
    }

    /// INPTR Register bits
    namespace inptr_bits {
        constexpr uint32_t INPTR = (32 << 0);  ///< Input pointer
    }

    /// OUTPTR Register bits
    namespace outptr_bits {
        constexpr uint32_t OUTPTR = (32 << 0);  ///< Output pointer
    }

    /// SCRATCHPTR Register bits
    namespace scratchptr_bits {
        constexpr uint32_t SCRATCHPTR = (32 << 0);  ///< Pointer to a scratch data area used for temporary storage during keystream generation, MIC generation and encryption/decryption.
    }

    /// MAXPACKETSIZE Register bits
    namespace maxpacketsize_bits {
        constexpr uint32_t MAXPACKETSIZE = (8 << 0);  ///< Length of keystream generated when MODE.LENGTH = Extended. This value must be greater than or equal to the subsequent packet payload to be encrypted/decrypted.
    }

    /// RATEOVERRIDE Register bits
    namespace rateoverride_bits {
        constexpr uint32_t RATEOVERRIDE = (2 << 0);  ///< Data rate override setting
    }

    /// HEADERMASK Register bits
    namespace headermask_bits {
        constexpr uint32_t HEADERMASK = (8 << 0);  ///< Header (S0) mask
    }

}

// ============================================================================
// DPPIC Peripheral
// ============================================================================

namespace dppic {
    /// Base addresses
    constexpr uint32_t DPPIC_NS_BASE = 0x4100F000;

    /// DPPIC Register structure
    struct Registers {
        volatile uint32_t EN;  ///< Offset: 0x00 - Description cluster: Subscribe configuration for task CHG[n].EN
        volatile uint32_t DIS;  ///< Offset: 0x04 - Description cluster: Subscribe configuration for task CHG[n].DIS
        volatile uint32_t CHEN;  ///< Offset: 0x500 - Channel enable register
        volatile uint32_t CHENSET;  ///< Offset: 0x504 - Channel enable set register
        volatile uint32_t CHENCLR;  ///< Offset: 0x508 - Channel enable clear register
        volatile uint32_t CHG[%s];  ///< Offset: 0x800 - Description collection: Channel group n Note: Writes to...
    };

    /// Peripheral instances
    inline Registers* DPPIC_NS = reinterpret_cast<Registers*>(DPPIC_NS_BASE);

    // Bit definitions
    /// EN Register bits
    namespace en_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task CHG[n].EN will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// DIS Register bits
    namespace dis_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task CHG[n].DIS will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// CHEN Register bits
    namespace chen_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Enable or disable channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Enable or disable channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Enable or disable channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Enable or disable channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Enable or disable channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Enable or disable channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Enable or disable channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Enable or disable channel 7
        constexpr uint32_t CH8 = (1U << 8);  ///< Enable or disable channel 8
        constexpr uint32_t CH9 = (1U << 9);  ///< Enable or disable channel 9
        constexpr uint32_t CH10 = (1U << 10);  ///< Enable or disable channel 10
        constexpr uint32_t CH11 = (1U << 11);  ///< Enable or disable channel 11
        constexpr uint32_t CH12 = (1U << 12);  ///< Enable or disable channel 12
        constexpr uint32_t CH13 = (1U << 13);  ///< Enable or disable channel 13
        constexpr uint32_t CH14 = (1U << 14);  ///< Enable or disable channel 14
        constexpr uint32_t CH15 = (1U << 15);  ///< Enable or disable channel 15
    }

    /// CHENSET Register bits
    namespace chenset_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Channel 0 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH1 = (1U << 1);  ///< Channel 1 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH2 = (1U << 2);  ///< Channel 2 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH3 = (1U << 3);  ///< Channel 3 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH4 = (1U << 4);  ///< Channel 4 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH5 = (1U << 5);  ///< Channel 5 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH6 = (1U << 6);  ///< Channel 6 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH7 = (1U << 7);  ///< Channel 7 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH8 = (1U << 8);  ///< Channel 8 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH9 = (1U << 9);  ///< Channel 9 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH10 = (1U << 10);  ///< Channel 10 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH11 = (1U << 11);  ///< Channel 11 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH12 = (1U << 12);  ///< Channel 12 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH13 = (1U << 13);  ///< Channel 13 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH14 = (1U << 14);  ///< Channel 14 enable set register. Writing 0 has no effect.
        constexpr uint32_t CH15 = (1U << 15);  ///< Channel 15 enable set register. Writing 0 has no effect.
    }

    /// CHENCLR Register bits
    namespace chenclr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Channel 0 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH1 = (1U << 1);  ///< Channel 1 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH2 = (1U << 2);  ///< Channel 2 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH3 = (1U << 3);  ///< Channel 3 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH4 = (1U << 4);  ///< Channel 4 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH5 = (1U << 5);  ///< Channel 5 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH6 = (1U << 6);  ///< Channel 6 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH7 = (1U << 7);  ///< Channel 7 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH8 = (1U << 8);  ///< Channel 8 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH9 = (1U << 9);  ///< Channel 9 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH10 = (1U << 10);  ///< Channel 10 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH11 = (1U << 11);  ///< Channel 11 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH12 = (1U << 12);  ///< Channel 12 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH13 = (1U << 13);  ///< Channel 13 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH14 = (1U << 14);  ///< Channel 14 enable clear register. Writing 0 has no effect.
        constexpr uint32_t CH15 = (1U << 15);  ///< Channel 15 enable clear register. Writing 0 has no effect.
    }

    /// CHG[%s] Register bits
    namespace chg[%s]_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Include or exclude channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Include or exclude channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Include or exclude channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Include or exclude channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Include or exclude channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Include or exclude channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Include or exclude channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Include or exclude channel 7
        constexpr uint32_t CH8 = (1U << 8);  ///< Include or exclude channel 8
        constexpr uint32_t CH9 = (1U << 9);  ///< Include or exclude channel 9
        constexpr uint32_t CH10 = (1U << 10);  ///< Include or exclude channel 10
        constexpr uint32_t CH11 = (1U << 11);  ///< Include or exclude channel 11
        constexpr uint32_t CH12 = (1U << 12);  ///< Include or exclude channel 12
        constexpr uint32_t CH13 = (1U << 13);  ///< Include or exclude channel 13
        constexpr uint32_t CH14 = (1U << 14);  ///< Include or exclude channel 14
        constexpr uint32_t CH15 = (1U << 15);  ///< Include or exclude channel 15
    }

}

// ============================================================================
// TEMP Peripheral
// ============================================================================

namespace temp {
    /// Base addresses
    constexpr uint32_t TEMP_NS_BASE = 0x41010000;

    /// TEMP Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start temperature measurement
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop temperature measurement
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x80 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x84 - Subscribe configuration for task STOP
        volatile uint32_t EVENTS_DATARDY;  ///< Offset: 0x100 - Temperature measurement complete, data ready
        volatile uint32_t PUBLISH_DATARDY;  ///< Offset: 0x180 - Publish configuration for event DATARDY
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t TEMP;  ///< Offset: 0x508 - Temperature in degC (0.25deg steps)
        volatile uint32_t A0;  ///< Offset: 0x520 - Slope of first piecewise linear function
        volatile uint32_t A1;  ///< Offset: 0x524 - Slope of second piecewise linear function
        volatile uint32_t A2;  ///< Offset: 0x528 - Slope of third piecewise linear function
        volatile uint32_t A3;  ///< Offset: 0x52C - Slope of fourth piecewise linear function
        volatile uint32_t A4;  ///< Offset: 0x530 - Slope of fifth piecewise linear function
        volatile uint32_t A5;  ///< Offset: 0x534 - Slope of sixth piecewise linear function
        volatile uint32_t B0;  ///< Offset: 0x540 - y-intercept of first piecewise linear function
        volatile uint32_t B1;  ///< Offset: 0x544 - y-intercept of second piecewise linear function
        volatile uint32_t B2;  ///< Offset: 0x548 - y-intercept of third piecewise linear function
        volatile uint32_t B3;  ///< Offset: 0x54C - y-intercept of fourth piecewise linear function
        volatile uint32_t B4;  ///< Offset: 0x550 - y-intercept of fifth piecewise linear function
        volatile uint32_t B5;  ///< Offset: 0x554 - y-intercept of sixth piecewise linear function
        volatile uint32_t T0;  ///< Offset: 0x560 - Endpoint of first piecewise linear function
        volatile uint32_t T1;  ///< Offset: 0x564 - Endpoint of second piecewise linear function
        volatile uint32_t T2;  ///< Offset: 0x568 - Endpoint of third piecewise linear function
        volatile uint32_t T3;  ///< Offset: 0x56C - Endpoint of fourth piecewise linear function
        volatile uint32_t T4;  ///< Offset: 0x570 - Endpoint of fifth piecewise linear function
    };

    /// Peripheral instances
    inline Registers* TEMP_NS = reinterpret_cast<Registers*>(TEMP_NS_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start temperature measurement
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop temperature measurement
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_DATARDY Register bits
    namespace events_datardy_bits {
        constexpr uint32_t EVENTS_DATARDY = (1U << 0);  ///< Temperature measurement complete, data ready
    }

    /// PUBLISH_DATARDY Register bits
    namespace publish_datardy_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event DATARDY will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Write '1' to enable interrupt for event DATARDY
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t DATARDY = (1U << 0);  ///< Write '1' to disable interrupt for event DATARDY
    }

    /// TEMP Register bits
    namespace temp_bits {
        constexpr uint32_t TEMP = (32 << 0);  ///< Temperature in degC (0.25deg steps)
    }

    /// A0 Register bits
    namespace a0_bits {
        constexpr uint32_t A0 = (12 << 0);  ///< Slope of first piecewise linear function
    }

    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t A1 = (12 << 0);  ///< Slope of second piecewise linear function
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t A2 = (12 << 0);  ///< Slope of third piecewise linear function
    }

    /// A3 Register bits
    namespace a3_bits {
        constexpr uint32_t A3 = (12 << 0);  ///< Slope of fourth piecewise linear function
    }

    /// A4 Register bits
    namespace a4_bits {
        constexpr uint32_t A4 = (12 << 0);  ///< Slope of fifth piecewise linear function
    }

    /// A5 Register bits
    namespace a5_bits {
        constexpr uint32_t A5 = (12 << 0);  ///< Slope of sixth piecewise linear function
    }

    /// B0 Register bits
    namespace b0_bits {
        constexpr uint32_t B0 = (12 << 0);  ///< y-intercept of first piecewise linear function
    }

    /// B1 Register bits
    namespace b1_bits {
        constexpr uint32_t B1 = (12 << 0);  ///< y-intercept of second piecewise linear function
    }

    /// B2 Register bits
    namespace b2_bits {
        constexpr uint32_t B2 = (12 << 0);  ///< y-intercept of third piecewise linear function
    }

    /// B3 Register bits
    namespace b3_bits {
        constexpr uint32_t B3 = (12 << 0);  ///< y-intercept of fourth piecewise linear function
    }

    /// B4 Register bits
    namespace b4_bits {
        constexpr uint32_t B4 = (12 << 0);  ///< y-intercept of fifth piecewise linear function
    }

    /// B5 Register bits
    namespace b5_bits {
        constexpr uint32_t B5 = (12 << 0);  ///< y-intercept of sixth piecewise linear function
    }

    /// T0 Register bits
    namespace t0_bits {
        constexpr uint32_t T0 = (8 << 0);  ///< Endpoint of first piecewise linear function
    }

    /// T1 Register bits
    namespace t1_bits {
        constexpr uint32_t T1 = (8 << 0);  ///< Endpoint of second piecewise linear function
    }

    /// T2 Register bits
    namespace t2_bits {
        constexpr uint32_t T2 = (8 << 0);  ///< Endpoint of third piecewise linear function
    }

    /// T3 Register bits
    namespace t3_bits {
        constexpr uint32_t T3 = (8 << 0);  ///< Endpoint of fourth piecewise linear function
    }

    /// T4 Register bits
    namespace t4_bits {
        constexpr uint32_t T4 = (8 << 0);  ///< Endpoint of fifth piecewise linear function
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC0_NS_BASE = 0x41011000;
    constexpr uint32_t RTC1_NS_BASE = 0x41016000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start RTC counter
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop RTC counter
        volatile uint32_t TASKS_CLEAR;  ///< Offset: 0x08 - Clear RTC counter
        volatile uint32_t TASKS_TRIGOVRFLW;  ///< Offset: 0x0C - Set counter to 0xFFFFF0
        volatile uint32_t TASKS_CAPTURE[%s];  ///< Offset: 0x40 - Description collection: Capture RTC counter to CC[n] register
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x80 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x84 - Subscribe configuration for task STOP
        volatile uint32_t SUBSCRIBE_CLEAR;  ///< Offset: 0x88 - Subscribe configuration for task CLEAR
        volatile uint32_t SUBSCRIBE_TRIGOVRFLW;  ///< Offset: 0x8C - Subscribe configuration for task TRIGOVRFLW
        volatile uint32_t SUBSCRIBE_CAPTURE[%s];  ///< Offset: 0xC0 - Description collection: Subscribe configuration for task...
        volatile uint32_t EVENTS_TICK;  ///< Offset: 0x100 - Event on counter increment
        volatile uint32_t EVENTS_OVRFLW;  ///< Offset: 0x104 - Event on counter overflow
        volatile uint32_t EVENTS_COMPARE[%s];  ///< Offset: 0x140 - Description collection: Compare event on CC[n] match
        volatile uint32_t PUBLISH_TICK;  ///< Offset: 0x180 - Publish configuration for event TICK
        volatile uint32_t PUBLISH_OVRFLW;  ///< Offset: 0x184 - Publish configuration for event OVRFLW
        volatile uint32_t PUBLISH_COMPARE[%s];  ///< Offset: 0x1C0 - Description collection: Publish configuration for event...
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t EVTEN;  ///< Offset: 0x340 - Enable or disable event routing
        volatile uint32_t EVTENSET;  ///< Offset: 0x344 - Enable event routing
        volatile uint32_t EVTENCLR;  ///< Offset: 0x348 - Disable event routing
        volatile uint32_t COUNTER;  ///< Offset: 0x504 - Current counter value
        volatile uint32_t PRESCALER;  ///< Offset: 0x508 - 12-bit prescaler for counter frequency (32768 /...
        volatile uint32_t CC[%s];  ///< Offset: 0x540 - Description collection: Compare register n
    };

    /// Peripheral instances
    inline Registers* RTC0_NS = reinterpret_cast<Registers*>(RTC0_NS_BASE);
    inline Registers* RTC1_NS = reinterpret_cast<Registers*>(RTC1_NS_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start RTC counter
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop RTC counter
    }

    /// TASKS_CLEAR Register bits
    namespace tasks_clear_bits {
        constexpr uint32_t TASKS_CLEAR = (1U << 0);  ///< Clear RTC counter
    }

    /// TASKS_TRIGOVRFLW Register bits
    namespace tasks_trigovrflw_bits {
        constexpr uint32_t TASKS_TRIGOVRFLW = (1U << 0);  ///< Set counter to 0xFFFFF0
    }

    /// TASKS_CAPTURE[%s] Register bits
    namespace tasks_capture[%s]_bits {
        constexpr uint32_t TASKS_CAPTURE = (1U << 0);  ///< Capture RTC counter to CC[n] register
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CLEAR Register bits
    namespace subscribe_clear_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task CLEAR will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_TRIGOVRFLW Register bits
    namespace subscribe_trigovrflw_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task TRIGOVRFLW will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CAPTURE[%s] Register bits
    namespace subscribe_capture[%s]_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task CAPTURE[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_TICK Register bits
    namespace events_tick_bits {
        constexpr uint32_t EVENTS_TICK = (1U << 0);  ///< Event on counter increment
    }

    /// EVENTS_OVRFLW Register bits
    namespace events_ovrflw_bits {
        constexpr uint32_t EVENTS_OVRFLW = (1U << 0);  ///< Event on counter overflow
    }

    /// EVENTS_COMPARE[%s] Register bits
    namespace events_compare[%s]_bits {
        constexpr uint32_t EVENTS_COMPARE = (1U << 0);  ///< Compare event on CC[n] match
    }

    /// PUBLISH_TICK Register bits
    namespace publish_tick_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event TICK will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_OVRFLW Register bits
    namespace publish_ovrflw_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event OVRFLW will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_COMPARE[%s] Register bits
    namespace publish_compare[%s]_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event COMPARE[n] will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t COMPARE0_CLEAR = (1U << 0);  ///< Shortcut between event COMPARE[0] and task CLEAR
        constexpr uint32_t COMPARE1_CLEAR = (1U << 1);  ///< Shortcut between event COMPARE[1] and task CLEAR
        constexpr uint32_t COMPARE2_CLEAR = (1U << 2);  ///< Shortcut between event COMPARE[2] and task CLEAR
        constexpr uint32_t COMPARE3_CLEAR = (1U << 3);  ///< Shortcut between event COMPARE[3] and task CLEAR
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to enable interrupt for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to enable interrupt for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to enable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to enable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to enable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to enable interrupt for event COMPARE[3]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to disable interrupt for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to disable interrupt for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to disable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to disable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to disable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to disable interrupt for event COMPARE[3]
    }

    /// EVTEN Register bits
    namespace evten_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Enable or disable event routing for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Enable or disable event routing for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Enable or disable event routing for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Enable or disable event routing for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Enable or disable event routing for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Enable or disable event routing for event COMPARE[3]
    }

    /// EVTENSET Register bits
    namespace evtenset_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to enable event routing for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to enable event routing for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to enable event routing for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to enable event routing for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to enable event routing for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to enable event routing for event COMPARE[3]
    }

    /// EVTENCLR Register bits
    namespace evtenclr_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to disable event routing for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to disable event routing for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to disable event routing for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to disable event routing for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to disable event routing for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to disable event routing for event COMPARE[3]
    }

    /// COUNTER Register bits
    namespace counter_bits {
        constexpr uint32_t COUNTER = (24 << 0);  ///< Counter value
    }

    /// PRESCALER Register bits
    namespace prescaler_bits {
        constexpr uint32_t PRESCALER = (12 << 0);  ///< Prescaler value
    }

    /// CC[%s] Register bits
    namespace cc[%s]_bits {
        constexpr uint32_t COMPARE = (24 << 0);  ///< Compare value
    }

}

// ============================================================================
// IPC Peripheral
// ============================================================================

namespace ipc {
    /// Base addresses
    constexpr uint32_t IPC_NS_BASE = 0x41012000;

    /// IPC Register structure
    struct Registers {
        volatile uint32_t TASKS_SEND[%s];  ///< Offset: 0x00 - Description collection: Trigger events on IPC channel...
        volatile uint32_t SUBSCRIBE_SEND[%s];  ///< Offset: 0x80 - Description collection: Subscribe configuration for task SEND[n]
        volatile uint32_t EVENTS_RECEIVE[%s];  ///< Offset: 0x100 - Description collection: Event received on one or more of...
        volatile uint32_t PUBLISH_RECEIVE[%s];  ///< Offset: 0x180 - Description collection: Publish configuration for event...
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t INTPEND;  ///< Offset: 0x30C - Pending interrupts
        volatile uint32_t SEND_CNF[%s];  ///< Offset: 0x510 - Description collection: Send event configuration for...
        volatile uint32_t RECEIVE_CNF[%s];  ///< Offset: 0x590 - Description collection: Receive event configuration for...
        volatile uint32_t GPMEM[%s];  ///< Offset: 0x610 - Description collection: General purpose memory
    };

    /// Peripheral instances
    inline Registers* IPC_NS = reinterpret_cast<Registers*>(IPC_NS_BASE);

    // Bit definitions
    /// TASKS_SEND[%s] Register bits
    namespace tasks_send[%s]_bits {
        constexpr uint32_t TASKS_SEND = (1U << 0);  ///< Trigger events on IPC channel enabled in SEND_CNF[n]
    }

    /// SUBSCRIBE_SEND[%s] Register bits
    namespace subscribe_send[%s]_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task SEND[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_RECEIVE[%s] Register bits
    namespace events_receive[%s]_bits {
        constexpr uint32_t EVENTS_RECEIVE = (1U << 0);  ///< Event received on one or more of the enabled IPC channels in RECEIVE_CNF[n]
    }

    /// PUBLISH_RECEIVE[%s] Register bits
    namespace publish_receive[%s]_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event RECEIVE[n] will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t RECEIVE0 = (1U << 0);  ///< Enable or disable interrupt for event RECEIVE[0]
        constexpr uint32_t RECEIVE1 = (1U << 1);  ///< Enable or disable interrupt for event RECEIVE[1]
        constexpr uint32_t RECEIVE2 = (1U << 2);  ///< Enable or disable interrupt for event RECEIVE[2]
        constexpr uint32_t RECEIVE3 = (1U << 3);  ///< Enable or disable interrupt for event RECEIVE[3]
        constexpr uint32_t RECEIVE4 = (1U << 4);  ///< Enable or disable interrupt for event RECEIVE[4]
        constexpr uint32_t RECEIVE5 = (1U << 5);  ///< Enable or disable interrupt for event RECEIVE[5]
        constexpr uint32_t RECEIVE6 = (1U << 6);  ///< Enable or disable interrupt for event RECEIVE[6]
        constexpr uint32_t RECEIVE7 = (1U << 7);  ///< Enable or disable interrupt for event RECEIVE[7]
        constexpr uint32_t RECEIVE8 = (1U << 8);  ///< Enable or disable interrupt for event RECEIVE[8]
        constexpr uint32_t RECEIVE9 = (1U << 9);  ///< Enable or disable interrupt for event RECEIVE[9]
        constexpr uint32_t RECEIVE10 = (1U << 10);  ///< Enable or disable interrupt for event RECEIVE[10]
        constexpr uint32_t RECEIVE11 = (1U << 11);  ///< Enable or disable interrupt for event RECEIVE[11]
        constexpr uint32_t RECEIVE12 = (1U << 12);  ///< Enable or disable interrupt for event RECEIVE[12]
        constexpr uint32_t RECEIVE13 = (1U << 13);  ///< Enable or disable interrupt for event RECEIVE[13]
        constexpr uint32_t RECEIVE14 = (1U << 14);  ///< Enable or disable interrupt for event RECEIVE[14]
        constexpr uint32_t RECEIVE15 = (1U << 15);  ///< Enable or disable interrupt for event RECEIVE[15]
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t RECEIVE0 = (1U << 0);  ///< Write '1' to enable interrupt for event RECEIVE[0]
        constexpr uint32_t RECEIVE1 = (1U << 1);  ///< Write '1' to enable interrupt for event RECEIVE[1]
        constexpr uint32_t RECEIVE2 = (1U << 2);  ///< Write '1' to enable interrupt for event RECEIVE[2]
        constexpr uint32_t RECEIVE3 = (1U << 3);  ///< Write '1' to enable interrupt for event RECEIVE[3]
        constexpr uint32_t RECEIVE4 = (1U << 4);  ///< Write '1' to enable interrupt for event RECEIVE[4]
        constexpr uint32_t RECEIVE5 = (1U << 5);  ///< Write '1' to enable interrupt for event RECEIVE[5]
        constexpr uint32_t RECEIVE6 = (1U << 6);  ///< Write '1' to enable interrupt for event RECEIVE[6]
        constexpr uint32_t RECEIVE7 = (1U << 7);  ///< Write '1' to enable interrupt for event RECEIVE[7]
        constexpr uint32_t RECEIVE8 = (1U << 8);  ///< Write '1' to enable interrupt for event RECEIVE[8]
        constexpr uint32_t RECEIVE9 = (1U << 9);  ///< Write '1' to enable interrupt for event RECEIVE[9]
        constexpr uint32_t RECEIVE10 = (1U << 10);  ///< Write '1' to enable interrupt for event RECEIVE[10]
        constexpr uint32_t RECEIVE11 = (1U << 11);  ///< Write '1' to enable interrupt for event RECEIVE[11]
        constexpr uint32_t RECEIVE12 = (1U << 12);  ///< Write '1' to enable interrupt for event RECEIVE[12]
        constexpr uint32_t RECEIVE13 = (1U << 13);  ///< Write '1' to enable interrupt for event RECEIVE[13]
        constexpr uint32_t RECEIVE14 = (1U << 14);  ///< Write '1' to enable interrupt for event RECEIVE[14]
        constexpr uint32_t RECEIVE15 = (1U << 15);  ///< Write '1' to enable interrupt for event RECEIVE[15]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t RECEIVE0 = (1U << 0);  ///< Write '1' to disable interrupt for event RECEIVE[0]
        constexpr uint32_t RECEIVE1 = (1U << 1);  ///< Write '1' to disable interrupt for event RECEIVE[1]
        constexpr uint32_t RECEIVE2 = (1U << 2);  ///< Write '1' to disable interrupt for event RECEIVE[2]
        constexpr uint32_t RECEIVE3 = (1U << 3);  ///< Write '1' to disable interrupt for event RECEIVE[3]
        constexpr uint32_t RECEIVE4 = (1U << 4);  ///< Write '1' to disable interrupt for event RECEIVE[4]
        constexpr uint32_t RECEIVE5 = (1U << 5);  ///< Write '1' to disable interrupt for event RECEIVE[5]
        constexpr uint32_t RECEIVE6 = (1U << 6);  ///< Write '1' to disable interrupt for event RECEIVE[6]
        constexpr uint32_t RECEIVE7 = (1U << 7);  ///< Write '1' to disable interrupt for event RECEIVE[7]
        constexpr uint32_t RECEIVE8 = (1U << 8);  ///< Write '1' to disable interrupt for event RECEIVE[8]
        constexpr uint32_t RECEIVE9 = (1U << 9);  ///< Write '1' to disable interrupt for event RECEIVE[9]
        constexpr uint32_t RECEIVE10 = (1U << 10);  ///< Write '1' to disable interrupt for event RECEIVE[10]
        constexpr uint32_t RECEIVE11 = (1U << 11);  ///< Write '1' to disable interrupt for event RECEIVE[11]
        constexpr uint32_t RECEIVE12 = (1U << 12);  ///< Write '1' to disable interrupt for event RECEIVE[12]
        constexpr uint32_t RECEIVE13 = (1U << 13);  ///< Write '1' to disable interrupt for event RECEIVE[13]
        constexpr uint32_t RECEIVE14 = (1U << 14);  ///< Write '1' to disable interrupt for event RECEIVE[14]
        constexpr uint32_t RECEIVE15 = (1U << 15);  ///< Write '1' to disable interrupt for event RECEIVE[15]
    }

    /// INTPEND Register bits
    namespace intpend_bits {
        constexpr uint32_t RECEIVE0 = (1U << 0);  ///< Read pending status of interrupt for event RECEIVE[0]
        constexpr uint32_t RECEIVE1 = (1U << 1);  ///< Read pending status of interrupt for event RECEIVE[1]
        constexpr uint32_t RECEIVE2 = (1U << 2);  ///< Read pending status of interrupt for event RECEIVE[2]
        constexpr uint32_t RECEIVE3 = (1U << 3);  ///< Read pending status of interrupt for event RECEIVE[3]
        constexpr uint32_t RECEIVE4 = (1U << 4);  ///< Read pending status of interrupt for event RECEIVE[4]
        constexpr uint32_t RECEIVE5 = (1U << 5);  ///< Read pending status of interrupt for event RECEIVE[5]
        constexpr uint32_t RECEIVE6 = (1U << 6);  ///< Read pending status of interrupt for event RECEIVE[6]
        constexpr uint32_t RECEIVE7 = (1U << 7);  ///< Read pending status of interrupt for event RECEIVE[7]
        constexpr uint32_t RECEIVE8 = (1U << 8);  ///< Read pending status of interrupt for event RECEIVE[8]
        constexpr uint32_t RECEIVE9 = (1U << 9);  ///< Read pending status of interrupt for event RECEIVE[9]
        constexpr uint32_t RECEIVE10 = (1U << 10);  ///< Read pending status of interrupt for event RECEIVE[10]
        constexpr uint32_t RECEIVE11 = (1U << 11);  ///< Read pending status of interrupt for event RECEIVE[11]
        constexpr uint32_t RECEIVE12 = (1U << 12);  ///< Read pending status of interrupt for event RECEIVE[12]
        constexpr uint32_t RECEIVE13 = (1U << 13);  ///< Read pending status of interrupt for event RECEIVE[13]
        constexpr uint32_t RECEIVE14 = (1U << 14);  ///< Read pending status of interrupt for event RECEIVE[14]
        constexpr uint32_t RECEIVE15 = (1U << 15);  ///< Read pending status of interrupt for event RECEIVE[15]
    }

    /// SEND_CNF[%s] Register bits
    namespace send_cnf[%s]_bits {
        constexpr uint32_t CHEN0 = (1U << 0);  ///< Enable broadcasting on IPC channel 0
        constexpr uint32_t CHEN1 = (1U << 1);  ///< Enable broadcasting on IPC channel 1
        constexpr uint32_t CHEN2 = (1U << 2);  ///< Enable broadcasting on IPC channel 2
        constexpr uint32_t CHEN3 = (1U << 3);  ///< Enable broadcasting on IPC channel 3
        constexpr uint32_t CHEN4 = (1U << 4);  ///< Enable broadcasting on IPC channel 4
        constexpr uint32_t CHEN5 = (1U << 5);  ///< Enable broadcasting on IPC channel 5
        constexpr uint32_t CHEN6 = (1U << 6);  ///< Enable broadcasting on IPC channel 6
        constexpr uint32_t CHEN7 = (1U << 7);  ///< Enable broadcasting on IPC channel 7
        constexpr uint32_t CHEN8 = (1U << 8);  ///< Enable broadcasting on IPC channel 8
        constexpr uint32_t CHEN9 = (1U << 9);  ///< Enable broadcasting on IPC channel 9
        constexpr uint32_t CHEN10 = (1U << 10);  ///< Enable broadcasting on IPC channel 10
        constexpr uint32_t CHEN11 = (1U << 11);  ///< Enable broadcasting on IPC channel 11
        constexpr uint32_t CHEN12 = (1U << 12);  ///< Enable broadcasting on IPC channel 12
        constexpr uint32_t CHEN13 = (1U << 13);  ///< Enable broadcasting on IPC channel 13
        constexpr uint32_t CHEN14 = (1U << 14);  ///< Enable broadcasting on IPC channel 14
        constexpr uint32_t CHEN15 = (1U << 15);  ///< Enable broadcasting on IPC channel 15
    }

    /// RECEIVE_CNF[%s] Register bits
    namespace receive_cnf[%s]_bits {
        constexpr uint32_t CHEN0 = (1U << 0);  ///< Enable subscription to IPC channel 0
        constexpr uint32_t CHEN1 = (1U << 1);  ///< Enable subscription to IPC channel 1
        constexpr uint32_t CHEN2 = (1U << 2);  ///< Enable subscription to IPC channel 2
        constexpr uint32_t CHEN3 = (1U << 3);  ///< Enable subscription to IPC channel 3
        constexpr uint32_t CHEN4 = (1U << 4);  ///< Enable subscription to IPC channel 4
        constexpr uint32_t CHEN5 = (1U << 5);  ///< Enable subscription to IPC channel 5
        constexpr uint32_t CHEN6 = (1U << 6);  ///< Enable subscription to IPC channel 6
        constexpr uint32_t CHEN7 = (1U << 7);  ///< Enable subscription to IPC channel 7
        constexpr uint32_t CHEN8 = (1U << 8);  ///< Enable subscription to IPC channel 8
        constexpr uint32_t CHEN9 = (1U << 9);  ///< Enable subscription to IPC channel 9
        constexpr uint32_t CHEN10 = (1U << 10);  ///< Enable subscription to IPC channel 10
        constexpr uint32_t CHEN11 = (1U << 11);  ///< Enable subscription to IPC channel 11
        constexpr uint32_t CHEN12 = (1U << 12);  ///< Enable subscription to IPC channel 12
        constexpr uint32_t CHEN13 = (1U << 13);  ///< Enable subscription to IPC channel 13
        constexpr uint32_t CHEN14 = (1U << 14);  ///< Enable subscription to IPC channel 14
        constexpr uint32_t CHEN15 = (1U << 15);  ///< Enable subscription to IPC channel 15
    }

    /// GPMEM[%s] Register bits
    namespace gpmem[%s]_bits {
        constexpr uint32_t GPMEM = (32 << 0);  ///< General purpose memory
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPIM0_NS_BASE = 0x41013000;
    constexpr uint32_t SPIS0_NS_BASE = 0x41013000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x10 - Start SPI transaction
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x14 - Stop SPI transaction
        volatile uint32_t TASKS_SUSPEND;  ///< Offset: 0x1C - Suspend SPI transaction
        volatile uint32_t TASKS_RESUME;  ///< Offset: 0x20 - Resume SPI transaction
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x90 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x94 - Subscribe configuration for task STOP
        volatile uint32_t SUBSCRIBE_SUSPEND;  ///< Offset: 0x9C - Subscribe configuration for task SUSPEND
        volatile uint32_t SUBSCRIBE_RESUME;  ///< Offset: 0xA0 - Subscribe configuration for task RESUME
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - SPI transaction has stopped
        volatile uint32_t EVENTS_ENDRX;  ///< Offset: 0x110 - End of RXD buffer reached
        volatile uint32_t EVENTS_END;  ///< Offset: 0x118 - End of RXD buffer and TXD buffer reached
        volatile uint32_t EVENTS_ENDTX;  ///< Offset: 0x120 - End of TXD buffer reached
        volatile uint32_t EVENTS_STARTED;  ///< Offset: 0x14C - Transaction started
        volatile uint32_t PUBLISH_STOPPED;  ///< Offset: 0x184 - Publish configuration for event STOPPED
        volatile uint32_t PUBLISH_ENDRX;  ///< Offset: 0x190 - Publish configuration for event ENDRX
        volatile uint32_t PUBLISH_END;  ///< Offset: 0x198 - Publish configuration for event END
        volatile uint32_t PUBLISH_ENDTX;  ///< Offset: 0x1A0 - Publish configuration for event ENDTX
        volatile uint32_t PUBLISH_STARTED;  ///< Offset: 0x1CC - Publish configuration for event STARTED
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t STALLSTAT;  ///< Offset: 0x400 - Stall status for EasyDMA RAM accesses. The fields in...
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable SPIM
        volatile uint32_t SCK;  ///< Offset: 0x00 - Pin select for SCK
        volatile uint32_t MOSI;  ///< Offset: 0x04 - Pin select for MOSI signal
        volatile uint32_t MISO;  ///< Offset: 0x08 - Pin select for MISO signal
        volatile uint32_t CSN;  ///< Offset: 0x0C - Pin select for CSN
        volatile uint32_t FREQUENCY;  ///< Offset: 0x524 - SPI frequency. Accuracy depends on the HFCLK source selected.
        volatile uint32_t PTR;  ///< Offset: 0x00 - Data pointer
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Number of bytes in transmit buffer
        volatile uint32_t AMOUNT;  ///< Offset: 0x08 - Number of bytes transferred in the last transaction
        volatile uint32_t LIST;  ///< Offset: 0x0C - EasyDMA list type
        volatile uint32_t CONFIG;  ///< Offset: 0x554 - Configuration register
        volatile uint32_t RXDELAY;  ///< Offset: 0x00 - Sample delay for input serial data on MISO
        volatile uint32_t CSNDUR;  ///< Offset: 0x04 - Minimum duration between edge of CSN and edge of SCK and...
        volatile uint32_t CSNPOL;  ///< Offset: 0x568 - Polarity of CSN output
        volatile uint32_t PSELDCX;  ///< Offset: 0x56C - Pin select for DCX signal
        volatile uint32_t DCXCNT;  ///< Offset: 0x570 - DCX configuration
        volatile uint32_t ORC;  ///< Offset: 0x5C0 - Byte transmitted after TXD.MAXCNT bytes have been...
    };

    /// Peripheral instances
    inline Registers* SPIM0_NS = reinterpret_cast<Registers*>(SPIM0_NS_BASE);
    inline Registers* SPIS0_NS = reinterpret_cast<Registers*>(SPIS0_NS_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start SPI transaction
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop SPI transaction
    }

    /// TASKS_SUSPEND Register bits
    namespace tasks_suspend_bits {
        constexpr uint32_t TASKS_SUSPEND = (1U << 0);  ///< Suspend SPI transaction
    }

    /// TASKS_RESUME Register bits
    namespace tasks_resume_bits {
        constexpr uint32_t TASKS_RESUME = (1U << 0);  ///< Resume SPI transaction
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_SUSPEND Register bits
    namespace subscribe_suspend_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task SUSPEND will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_RESUME Register bits
    namespace subscribe_resume_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task RESUME will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< SPI transaction has stopped
    }

    /// EVENTS_ENDRX Register bits
    namespace events_endrx_bits {
        constexpr uint32_t EVENTS_ENDRX = (1U << 0);  ///< End of RXD buffer reached
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< End of RXD buffer and TXD buffer reached
    }

    /// EVENTS_ENDTX Register bits
    namespace events_endtx_bits {
        constexpr uint32_t EVENTS_ENDTX = (1U << 0);  ///< End of TXD buffer reached
    }

    /// EVENTS_STARTED Register bits
    namespace events_started_bits {
        constexpr uint32_t EVENTS_STARTED = (1U << 0);  ///< Transaction started
    }

    /// PUBLISH_STOPPED Register bits
    namespace publish_stopped_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event STOPPED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ENDRX Register bits
    namespace publish_endrx_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event ENDRX will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_END Register bits
    namespace publish_end_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event END will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ENDTX Register bits
    namespace publish_endtx_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event ENDTX will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_STARTED Register bits
    namespace publish_started_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event STARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t END_START = (1U << 17);  ///< Shortcut between event END and task START
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t ENDRX = (1U << 4);  ///< Write '1' to enable interrupt for event ENDRX
        constexpr uint32_t END = (1U << 6);  ///< Write '1' to enable interrupt for event END
        constexpr uint32_t ENDTX = (1U << 8);  ///< Write '1' to enable interrupt for event ENDTX
        constexpr uint32_t STARTED = (1U << 19);  ///< Write '1' to enable interrupt for event STARTED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t ENDRX = (1U << 4);  ///< Write '1' to disable interrupt for event ENDRX
        constexpr uint32_t END = (1U << 6);  ///< Write '1' to disable interrupt for event END
        constexpr uint32_t ENDTX = (1U << 8);  ///< Write '1' to disable interrupt for event ENDTX
        constexpr uint32_t STARTED = (1U << 19);  ///< Write '1' to disable interrupt for event STARTED
    }

    /// STALLSTAT Register bits
    namespace stallstat_bits {
        constexpr uint32_t TX = (1U << 0);  ///< Stall status for EasyDMA RAM reads
        constexpr uint32_t RX = (1U << 1);  ///< Stall status for EasyDMA RAM writes
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (4 << 0);  ///< Enable or disable SPIM
    }

    /// SCK Register bits
    namespace sck_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// MOSI Register bits
    namespace mosi_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// MISO Register bits
    namespace miso_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// CSN Register bits
    namespace csn_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (32 << 0);  ///< SPI master data rate
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Data pointer
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t MAXCNT = (16 << 0);  ///< Maximum number of bytes in transmit buffer
    }

    /// AMOUNT Register bits
    namespace amount_bits {
        constexpr uint32_t AMOUNT = (16 << 0);  ///< Number of bytes transferred in the last transaction
    }

    /// LIST Register bits
    namespace list_bits {
        constexpr uint32_t LIST = (2 << 0);  ///< List type
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t ORDER = (1U << 0);  ///< Bit order
        constexpr uint32_t CPHA = (1U << 1);  ///< Serial clock (SCK) phase
        constexpr uint32_t CPOL = (1U << 2);  ///< Serial clock (SCK) polarity
    }

    /// RXDELAY Register bits
    namespace rxdelay_bits {
        constexpr uint32_t RXDELAY = (3 << 0);  ///< Sample delay for input serial data on MISO. The value specifies the number of 64 MHz clock cycles (15.625 ns) delay from the the sampling edge of SCK (leading edge for CONFIG.CPHA = 0, trailing edge for CONFIG.CPHA = 1) until the input serial data is sampled. As en example, if RXDELAY = 0 and CONFIG.CPHA = 0, the input serial data is sampled on the rising edge of SCK.
    }

    /// CSNDUR Register bits
    namespace csndur_bits {
        constexpr uint32_t CSNDUR = (8 << 0);  ///< Minimum duration between edge of CSN and edge of SCK and minimum duration CSN must stay high between transactions. The value is specified in number of 64 MHz clock cycles (15.625 ns).
    }

    /// CSNPOL Register bits
    namespace csnpol_bits {
        constexpr uint32_t CSNPOL = (1U << 0);  ///< Polarity of CSN output
    }

    /// PSELDCX Register bits
    namespace pseldcx_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// DCXCNT Register bits
    namespace dcxcnt_bits {
        constexpr uint32_t DCXCNT = (4 << 0);  ///< This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes.
    }

    /// ORC Register bits
    namespace orc_bits {
        constexpr uint32_t ORC = (8 << 0);  ///< Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT.
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t TWIM0_NS_BASE = 0x41013000;
    constexpr uint32_t TWIS0_NS_BASE = 0x41013000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTRX;  ///< Offset: 0x00 - Start TWI receive sequence
        volatile uint32_t TASKS_STARTTX;  ///< Offset: 0x08 - Start TWI transmit sequence
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x14 - Stop TWI transaction. Must be issued while the TWI...
        volatile uint32_t TASKS_SUSPEND;  ///< Offset: 0x1C - Suspend TWI transaction
        volatile uint32_t TASKS_RESUME;  ///< Offset: 0x20 - Resume TWI transaction
        volatile uint32_t SUBSCRIBE_STARTRX;  ///< Offset: 0x80 - Subscribe configuration for task STARTRX
        volatile uint32_t SUBSCRIBE_STARTTX;  ///< Offset: 0x88 - Subscribe configuration for task STARTTX
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x94 - Subscribe configuration for task STOP
        volatile uint32_t SUBSCRIBE_SUSPEND;  ///< Offset: 0x9C - Subscribe configuration for task SUSPEND
        volatile uint32_t SUBSCRIBE_RESUME;  ///< Offset: 0xA0 - Subscribe configuration for task RESUME
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - TWI stopped
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x124 - TWI error
        volatile uint32_t EVENTS_SUSPENDED;  ///< Offset: 0x148 - SUSPEND task has been issued, TWI traffic is now suspended.
        volatile uint32_t EVENTS_RXSTARTED;  ///< Offset: 0x14C - Receive sequence started
        volatile uint32_t EVENTS_TXSTARTED;  ///< Offset: 0x150 - Transmit sequence started
        volatile uint32_t EVENTS_LASTRX;  ///< Offset: 0x15C - Byte boundary, starting to receive the last byte
        volatile uint32_t EVENTS_LASTTX;  ///< Offset: 0x160 - Byte boundary, starting to transmit the last byte
        volatile uint32_t PUBLISH_STOPPED;  ///< Offset: 0x184 - Publish configuration for event STOPPED
        volatile uint32_t PUBLISH_ERROR;  ///< Offset: 0x1A4 - Publish configuration for event ERROR
        volatile uint32_t PUBLISH_SUSPENDED;  ///< Offset: 0x1C8 - Publish configuration for event SUSPENDED
        volatile uint32_t PUBLISH_RXSTARTED;  ///< Offset: 0x1CC - Publish configuration for event RXSTARTED
        volatile uint32_t PUBLISH_TXSTARTED;  ///< Offset: 0x1D0 - Publish configuration for event TXSTARTED
        volatile uint32_t PUBLISH_LASTRX;  ///< Offset: 0x1DC - Publish configuration for event LASTRX
        volatile uint32_t PUBLISH_LASTTX;  ///< Offset: 0x1E0 - Publish configuration for event LASTTX
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ERRORSRC;  ///< Offset: 0x4C4 - Error source
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable TWIM
        volatile uint32_t SCL;  ///< Offset: 0x00 - Pin select for SCL signal
        volatile uint32_t SDA;  ///< Offset: 0x04 - Pin select for SDA signal
        volatile uint32_t FREQUENCY;  ///< Offset: 0x524 - TWI frequency. Accuracy depends on the HFCLK source selected.
        volatile uint32_t PTR;  ///< Offset: 0x00 - Data pointer
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Maximum number of bytes in transmit buffer
        volatile uint32_t AMOUNT;  ///< Offset: 0x08 - Number of bytes transferred in the last transaction
        volatile uint32_t LIST;  ///< Offset: 0x0C - EasyDMA list type
        volatile uint32_t ADDRESS;  ///< Offset: 0x588 - Address used in the TWI transfer
    };

    /// Peripheral instances
    inline Registers* TWIM0_NS = reinterpret_cast<Registers*>(TWIM0_NS_BASE);
    inline Registers* TWIS0_NS = reinterpret_cast<Registers*>(TWIS0_NS_BASE);

    // Bit definitions
    /// TASKS_STARTRX Register bits
    namespace tasks_startrx_bits {
        constexpr uint32_t TASKS_STARTRX = (1U << 0);  ///< Start TWI receive sequence
    }

    /// TASKS_STARTTX Register bits
    namespace tasks_starttx_bits {
        constexpr uint32_t TASKS_STARTTX = (1U << 0);  ///< Start TWI transmit sequence
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop TWI transaction. Must be issued while the TWI master is not suspended.
    }

    /// TASKS_SUSPEND Register bits
    namespace tasks_suspend_bits {
        constexpr uint32_t TASKS_SUSPEND = (1U << 0);  ///< Suspend TWI transaction
    }

    /// TASKS_RESUME Register bits
    namespace tasks_resume_bits {
        constexpr uint32_t TASKS_RESUME = (1U << 0);  ///< Resume TWI transaction
    }

    /// SUBSCRIBE_STARTRX Register bits
    namespace subscribe_startrx_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STARTRX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STARTTX Register bits
    namespace subscribe_starttx_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STARTTX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_SUSPEND Register bits
    namespace subscribe_suspend_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task SUSPEND will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_RESUME Register bits
    namespace subscribe_resume_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task RESUME will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< TWI stopped
    }

    /// EVENTS_ERROR Register bits
    namespace events_error_bits {
        constexpr uint32_t EVENTS_ERROR = (1U << 0);  ///< TWI error
    }

    /// EVENTS_SUSPENDED Register bits
    namespace events_suspended_bits {
        constexpr uint32_t EVENTS_SUSPENDED = (1U << 0);  ///< SUSPEND task has been issued, TWI traffic is now suspended.
    }

    /// EVENTS_RXSTARTED Register bits
    namespace events_rxstarted_bits {
        constexpr uint32_t EVENTS_RXSTARTED = (1U << 0);  ///< Receive sequence started
    }

    /// EVENTS_TXSTARTED Register bits
    namespace events_txstarted_bits {
        constexpr uint32_t EVENTS_TXSTARTED = (1U << 0);  ///< Transmit sequence started
    }

    /// EVENTS_LASTRX Register bits
    namespace events_lastrx_bits {
        constexpr uint32_t EVENTS_LASTRX = (1U << 0);  ///< Byte boundary, starting to receive the last byte
    }

    /// EVENTS_LASTTX Register bits
    namespace events_lasttx_bits {
        constexpr uint32_t EVENTS_LASTTX = (1U << 0);  ///< Byte boundary, starting to transmit the last byte
    }

    /// PUBLISH_STOPPED Register bits
    namespace publish_stopped_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event STOPPED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ERROR Register bits
    namespace publish_error_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event ERROR will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_SUSPENDED Register bits
    namespace publish_suspended_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event SUSPENDED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_RXSTARTED Register bits
    namespace publish_rxstarted_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event RXSTARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_TXSTARTED Register bits
    namespace publish_txstarted_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event TXSTARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_LASTRX Register bits
    namespace publish_lastrx_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event LASTRX will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_LASTTX Register bits
    namespace publish_lasttx_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event LASTTX will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t LASTTX_STARTRX = (1U << 7);  ///< Shortcut between event LASTTX and task STARTRX
        constexpr uint32_t LASTTX_SUSPEND = (1U << 8);  ///< Shortcut between event LASTTX and task SUSPEND
        constexpr uint32_t LASTTX_STOP = (1U << 9);  ///< Shortcut between event LASTTX and task STOP
        constexpr uint32_t LASTRX_STARTTX = (1U << 10);  ///< Shortcut between event LASTRX and task STARTTX
        constexpr uint32_t LASTRX_STOP = (1U << 12);  ///< Shortcut between event LASTRX and task STOP
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Enable or disable interrupt for event STOPPED
        constexpr uint32_t ERROR = (1U << 9);  ///< Enable or disable interrupt for event ERROR
        constexpr uint32_t SUSPENDED = (1U << 18);  ///< Enable or disable interrupt for event SUSPENDED
        constexpr uint32_t RXSTARTED = (1U << 19);  ///< Enable or disable interrupt for event RXSTARTED
        constexpr uint32_t TXSTARTED = (1U << 20);  ///< Enable or disable interrupt for event TXSTARTED
        constexpr uint32_t LASTRX = (1U << 23);  ///< Enable or disable interrupt for event LASTRX
        constexpr uint32_t LASTTX = (1U << 24);  ///< Enable or disable interrupt for event LASTTX
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to enable interrupt for event ERROR
        constexpr uint32_t SUSPENDED = (1U << 18);  ///< Write '1' to enable interrupt for event SUSPENDED
        constexpr uint32_t RXSTARTED = (1U << 19);  ///< Write '1' to enable interrupt for event RXSTARTED
        constexpr uint32_t TXSTARTED = (1U << 20);  ///< Write '1' to enable interrupt for event TXSTARTED
        constexpr uint32_t LASTRX = (1U << 23);  ///< Write '1' to enable interrupt for event LASTRX
        constexpr uint32_t LASTTX = (1U << 24);  ///< Write '1' to enable interrupt for event LASTTX
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to disable interrupt for event ERROR
        constexpr uint32_t SUSPENDED = (1U << 18);  ///< Write '1' to disable interrupt for event SUSPENDED
        constexpr uint32_t RXSTARTED = (1U << 19);  ///< Write '1' to disable interrupt for event RXSTARTED
        constexpr uint32_t TXSTARTED = (1U << 20);  ///< Write '1' to disable interrupt for event TXSTARTED
        constexpr uint32_t LASTRX = (1U << 23);  ///< Write '1' to disable interrupt for event LASTRX
        constexpr uint32_t LASTTX = (1U << 24);  ///< Write '1' to disable interrupt for event LASTTX
    }

    /// ERRORSRC Register bits
    namespace errorsrc_bits {
        constexpr uint32_t OVERRUN = (1U << 0);  ///< Overrun error
        constexpr uint32_t ANACK = (1U << 1);  ///< NACK received after sending the address (write '1' to clear)
        constexpr uint32_t DNACK = (1U << 2);  ///< NACK received after sending a data byte (write '1' to clear)
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (4 << 0);  ///< Enable or disable TWIM
    }

    /// SCL Register bits
    namespace scl_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// SDA Register bits
    namespace sda_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (32 << 0);  ///< TWI master clock frequency
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Data pointer
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t MAXCNT = (16 << 0);  ///< Maximum number of bytes in transmit buffer
    }

    /// AMOUNT Register bits
    namespace amount_bits {
        constexpr uint32_t AMOUNT = (16 << 0);  ///< Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte.
    }

    /// LIST Register bits
    namespace list_bits {
        constexpr uint32_t LIST = (3 << 0);  ///< List type
    }

    /// ADDRESS Register bits
    namespace address_bits {
        constexpr uint32_t ADDRESS = (7 << 0);  ///< Address used in the TWI transfer
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UARTE0_NS_BASE = 0x41013000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTRX;  ///< Offset: 0x00 - Start UART receiver
        volatile uint32_t TASKS_STOPRX;  ///< Offset: 0x04 - Stop UART receiver
        volatile uint32_t TASKS_STARTTX;  ///< Offset: 0x08 - Start UART transmitter
        volatile uint32_t TASKS_STOPTX;  ///< Offset: 0x0C - Stop UART transmitter
        volatile uint32_t TASKS_FLUSHRX;  ///< Offset: 0x2C - Flush RX FIFO into RX buffer
        volatile uint32_t SUBSCRIBE_STARTRX;  ///< Offset: 0x80 - Subscribe configuration for task STARTRX
        volatile uint32_t SUBSCRIBE_STOPRX;  ///< Offset: 0x84 - Subscribe configuration for task STOPRX
        volatile uint32_t SUBSCRIBE_STARTTX;  ///< Offset: 0x88 - Subscribe configuration for task STARTTX
        volatile uint32_t SUBSCRIBE_STOPTX;  ///< Offset: 0x8C - Subscribe configuration for task STOPTX
        volatile uint32_t SUBSCRIBE_FLUSHRX;  ///< Offset: 0xAC - Subscribe configuration for task FLUSHRX
        volatile uint32_t EVENTS_CTS;  ///< Offset: 0x100 - CTS is activated (set low). Clear To Send.
        volatile uint32_t EVENTS_NCTS;  ///< Offset: 0x104 - CTS is deactivated (set high). Not Clear To Send.
        volatile uint32_t EVENTS_RXDRDY;  ///< Offset: 0x108 - Data received in RXD (but potentially not yet...
        volatile uint32_t EVENTS_ENDRX;  ///< Offset: 0x110 - Receive buffer is filled up
        volatile uint32_t EVENTS_TXDRDY;  ///< Offset: 0x11C - Data sent from TXD
        volatile uint32_t EVENTS_ENDTX;  ///< Offset: 0x120 - Last TX byte transmitted
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x124 - Error detected
        volatile uint32_t EVENTS_RXTO;  ///< Offset: 0x144 - Receiver timeout
        volatile uint32_t EVENTS_RXSTARTED;  ///< Offset: 0x14C - UART receiver has started
        volatile uint32_t EVENTS_TXSTARTED;  ///< Offset: 0x150 - UART transmitter has started
        volatile uint32_t EVENTS_TXSTOPPED;  ///< Offset: 0x158 - Transmitter stopped
        volatile uint32_t PUBLISH_CTS;  ///< Offset: 0x180 - Publish configuration for event CTS
        volatile uint32_t PUBLISH_NCTS;  ///< Offset: 0x184 - Publish configuration for event NCTS
        volatile uint32_t PUBLISH_RXDRDY;  ///< Offset: 0x188 - Publish configuration for event RXDRDY
        volatile uint32_t PUBLISH_ENDRX;  ///< Offset: 0x190 - Publish configuration for event ENDRX
        volatile uint32_t PUBLISH_TXDRDY;  ///< Offset: 0x19C - Publish configuration for event TXDRDY
        volatile uint32_t PUBLISH_ENDTX;  ///< Offset: 0x1A0 - Publish configuration for event ENDTX
        volatile uint32_t PUBLISH_ERROR;  ///< Offset: 0x1A4 - Publish configuration for event ERROR
        volatile uint32_t PUBLISH_RXTO;  ///< Offset: 0x1C4 - Publish configuration for event RXTO
        volatile uint32_t PUBLISH_RXSTARTED;  ///< Offset: 0x1CC - Publish configuration for event RXSTARTED
        volatile uint32_t PUBLISH_TXSTARTED;  ///< Offset: 0x1D0 - Publish configuration for event TXSTARTED
        volatile uint32_t PUBLISH_TXSTOPPED;  ///< Offset: 0x1D8 - Publish configuration for event TXSTOPPED
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ERRORSRC;  ///< Offset: 0x480 - Error source
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable UART
        volatile uint32_t RTS;  ///< Offset: 0x00 - Pin select for RTS signal
        volatile uint32_t TXD;  ///< Offset: 0x04 - Pin select for TXD signal
        volatile uint32_t CTS;  ///< Offset: 0x08 - Pin select for CTS signal
        volatile uint32_t RXD;  ///< Offset: 0x0C - Pin select for RXD signal
        volatile uint32_t BAUDRATE;  ///< Offset: 0x524 - Baud rate. Accuracy depends on the HFCLK source selected.
        volatile uint32_t PTR;  ///< Offset: 0x00 - Data pointer
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Maximum number of bytes in transmit buffer
        volatile uint32_t AMOUNT;  ///< Offset: 0x08 - Number of bytes transferred in the last transaction
        volatile uint32_t CONFIG;  ///< Offset: 0x56C - Configuration of parity and hardware flow control
    };

    /// Peripheral instances
    inline Registers* UARTE0_NS = reinterpret_cast<Registers*>(UARTE0_NS_BASE);

    // Bit definitions
    /// TASKS_STARTRX Register bits
    namespace tasks_startrx_bits {
        constexpr uint32_t TASKS_STARTRX = (1U << 0);  ///< Start UART receiver
    }

    /// TASKS_STOPRX Register bits
    namespace tasks_stoprx_bits {
        constexpr uint32_t TASKS_STOPRX = (1U << 0);  ///< Stop UART receiver
    }

    /// TASKS_STARTTX Register bits
    namespace tasks_starttx_bits {
        constexpr uint32_t TASKS_STARTTX = (1U << 0);  ///< Start UART transmitter
    }

    /// TASKS_STOPTX Register bits
    namespace tasks_stoptx_bits {
        constexpr uint32_t TASKS_STOPTX = (1U << 0);  ///< Stop UART transmitter
    }

    /// TASKS_FLUSHRX Register bits
    namespace tasks_flushrx_bits {
        constexpr uint32_t TASKS_FLUSHRX = (1U << 0);  ///< Flush RX FIFO into RX buffer
    }

    /// SUBSCRIBE_STARTRX Register bits
    namespace subscribe_startrx_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STARTRX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOPRX Register bits
    namespace subscribe_stoprx_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STOPRX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STARTTX Register bits
    namespace subscribe_starttx_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STARTTX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOPTX Register bits
    namespace subscribe_stoptx_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task STOPTX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_FLUSHRX Register bits
    namespace subscribe_flushrx_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task FLUSHRX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_CTS Register bits
    namespace events_cts_bits {
        constexpr uint32_t EVENTS_CTS = (1U << 0);  ///< CTS is activated (set low). Clear To Send.
    }

    /// EVENTS_NCTS Register bits
    namespace events_ncts_bits {
        constexpr uint32_t EVENTS_NCTS = (1U << 0);  ///< CTS is deactivated (set high). Not Clear To Send.
    }

    /// EVENTS_RXDRDY Register bits
    namespace events_rxdrdy_bits {
        constexpr uint32_t EVENTS_RXDRDY = (1U << 0);  ///< Data received in RXD (but potentially not yet transferred to Data RAM)
    }

    /// EVENTS_ENDRX Register bits
    namespace events_endrx_bits {
        constexpr uint32_t EVENTS_ENDRX = (1U << 0);  ///< Receive buffer is filled up
    }

    /// EVENTS_TXDRDY Register bits
    namespace events_txdrdy_bits {
        constexpr uint32_t EVENTS_TXDRDY = (1U << 0);  ///< Data sent from TXD
    }

    /// EVENTS_ENDTX Register bits
    namespace events_endtx_bits {
        constexpr uint32_t EVENTS_ENDTX = (1U << 0);  ///< Last TX byte transmitted
    }

    /// EVENTS_ERROR Register bits
    namespace events_error_bits {
        constexpr uint32_t EVENTS_ERROR = (1U << 0);  ///< Error detected
    }

    /// EVENTS_RXTO Register bits
    namespace events_rxto_bits {
        constexpr uint32_t EVENTS_RXTO = (1U << 0);  ///< Receiver timeout
    }

    /// EVENTS_RXSTARTED Register bits
    namespace events_rxstarted_bits {
        constexpr uint32_t EVENTS_RXSTARTED = (1U << 0);  ///< UART receiver has started
    }

    /// EVENTS_TXSTARTED Register bits
    namespace events_txstarted_bits {
        constexpr uint32_t EVENTS_TXSTARTED = (1U << 0);  ///< UART transmitter has started
    }

    /// EVENTS_TXSTOPPED Register bits
    namespace events_txstopped_bits {
        constexpr uint32_t EVENTS_TXSTOPPED = (1U << 0);  ///< Transmitter stopped
    }

    /// PUBLISH_CTS Register bits
    namespace publish_cts_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event CTS will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_NCTS Register bits
    namespace publish_ncts_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event NCTS will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_RXDRDY Register bits
    namespace publish_rxdrdy_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event RXDRDY will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ENDRX Register bits
    namespace publish_endrx_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event ENDRX will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_TXDRDY Register bits
    namespace publish_txdrdy_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event TXDRDY will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ENDTX Register bits
    namespace publish_endtx_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event ENDTX will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ERROR Register bits
    namespace publish_error_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event ERROR will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_RXTO Register bits
    namespace publish_rxto_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event RXTO will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_RXSTARTED Register bits
    namespace publish_rxstarted_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event RXSTARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_TXSTARTED Register bits
    namespace publish_txstarted_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event TXSTARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_TXSTOPPED Register bits
    namespace publish_txstopped_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event TXSTOPPED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t ENDRX_STARTRX = (1U << 5);  ///< Shortcut between event ENDRX and task STARTRX
        constexpr uint32_t ENDRX_STOPRX = (1U << 6);  ///< Shortcut between event ENDRX and task STOPRX
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t CTS = (1U << 0);  ///< Enable or disable interrupt for event CTS
        constexpr uint32_t NCTS = (1U << 1);  ///< Enable or disable interrupt for event NCTS
        constexpr uint32_t RXDRDY = (1U << 2);  ///< Enable or disable interrupt for event RXDRDY
        constexpr uint32_t ENDRX = (1U << 4);  ///< Enable or disable interrupt for event ENDRX
        constexpr uint32_t TXDRDY = (1U << 7);  ///< Enable or disable interrupt for event TXDRDY
        constexpr uint32_t ENDTX = (1U << 8);  ///< Enable or disable interrupt for event ENDTX
        constexpr uint32_t ERROR = (1U << 9);  ///< Enable or disable interrupt for event ERROR
        constexpr uint32_t RXTO = (1U << 17);  ///< Enable or disable interrupt for event RXTO
        constexpr uint32_t RXSTARTED = (1U << 19);  ///< Enable or disable interrupt for event RXSTARTED
        constexpr uint32_t TXSTARTED = (1U << 20);  ///< Enable or disable interrupt for event TXSTARTED
        constexpr uint32_t TXSTOPPED = (1U << 22);  ///< Enable or disable interrupt for event TXSTOPPED
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t CTS = (1U << 0);  ///< Write '1' to enable interrupt for event CTS
        constexpr uint32_t NCTS = (1U << 1);  ///< Write '1' to enable interrupt for event NCTS
        constexpr uint32_t RXDRDY = (1U << 2);  ///< Write '1' to enable interrupt for event RXDRDY
        constexpr uint32_t ENDRX = (1U << 4);  ///< Write '1' to enable interrupt for event ENDRX
        constexpr uint32_t TXDRDY = (1U << 7);  ///< Write '1' to enable interrupt for event TXDRDY
        constexpr uint32_t ENDTX = (1U << 8);  ///< Write '1' to enable interrupt for event ENDTX
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to enable interrupt for event ERROR
        constexpr uint32_t RXTO = (1U << 17);  ///< Write '1' to enable interrupt for event RXTO
        constexpr uint32_t RXSTARTED = (1U << 19);  ///< Write '1' to enable interrupt for event RXSTARTED
        constexpr uint32_t TXSTARTED = (1U << 20);  ///< Write '1' to enable interrupt for event TXSTARTED
        constexpr uint32_t TXSTOPPED = (1U << 22);  ///< Write '1' to enable interrupt for event TXSTOPPED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t CTS = (1U << 0);  ///< Write '1' to disable interrupt for event CTS
        constexpr uint32_t NCTS = (1U << 1);  ///< Write '1' to disable interrupt for event NCTS
        constexpr uint32_t RXDRDY = (1U << 2);  ///< Write '1' to disable interrupt for event RXDRDY
        constexpr uint32_t ENDRX = (1U << 4);  ///< Write '1' to disable interrupt for event ENDRX
        constexpr uint32_t TXDRDY = (1U << 7);  ///< Write '1' to disable interrupt for event TXDRDY
        constexpr uint32_t ENDTX = (1U << 8);  ///< Write '1' to disable interrupt for event ENDTX
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to disable interrupt for event ERROR
        constexpr uint32_t RXTO = (1U << 17);  ///< Write '1' to disable interrupt for event RXTO
        constexpr uint32_t RXSTARTED = (1U << 19);  ///< Write '1' to disable interrupt for event RXSTARTED
        constexpr uint32_t TXSTARTED = (1U << 20);  ///< Write '1' to disable interrupt for event TXSTARTED
        constexpr uint32_t TXSTOPPED = (1U << 22);  ///< Write '1' to disable interrupt for event TXSTOPPED
    }

    /// ERRORSRC Register bits
    namespace errorsrc_bits {
        constexpr uint32_t OVERRUN = (1U << 0);  ///< Overrun error
        constexpr uint32_t PARITY = (1U << 1);  ///< Parity error
        constexpr uint32_t FRAMING = (1U << 2);  ///< Framing error occurred
        constexpr uint32_t BREAK = (1U << 3);  ///< Break condition
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (4 << 0);  ///< Enable or disable UARTE
    }

    /// RTS Register bits
    namespace rts_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// TXD Register bits
    namespace txd_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// CTS Register bits
    namespace cts_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// RXD Register bits
    namespace rxd_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t PORT = (1U << 5);  ///< Port number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// BAUDRATE Register bits
    namespace baudrate_bits {
        constexpr uint32_t BAUDRATE = (32 << 0);  ///< Baud rate
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Data pointer
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t MAXCNT = (16 << 0);  ///< Maximum number of bytes in transmit buffer
    }

    /// AMOUNT Register bits
    namespace amount_bits {
        constexpr uint32_t AMOUNT = (16 << 0);  ///< Number of bytes transferred in the last transaction
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t HWFC = (1U << 0);  ///< Hardware flow control
        constexpr uint32_t PARITY = (3 << 1);  ///< Parity
        constexpr uint32_t STOP = (1U << 4);  ///< Stop bits
        constexpr uint32_t PARITYTYPE = (1U << 8);  ///< Even or odd parity type
    }

}

// ============================================================================
// EGU0 Peripheral
// ============================================================================

namespace egu0 {
    /// Base addresses
    constexpr uint32_t EGU0_NS_BASE = 0x41014000;

    /// EGU0 Register structure
    struct Registers {
        volatile uint32_t TASKS_TRIGGER[%s];  ///< Offset: 0x00 - Description collection: Trigger n for triggering the...
        volatile uint32_t SUBSCRIBE_TRIGGER[%s];  ///< Offset: 0x80 - Description collection: Subscribe configuration for task...
        volatile uint32_t EVENTS_TRIGGERED[%s];  ///< Offset: 0x100 - Description collection: Event number n generated by...
        volatile uint32_t PUBLISH_TRIGGERED[%s];  ///< Offset: 0x180 - Description collection: Publish configuration for event...
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
    };

    /// Peripheral instances
    inline Registers* EGU0_NS = reinterpret_cast<Registers*>(EGU0_NS_BASE);

    // Bit definitions
    /// TASKS_TRIGGER[%s] Register bits
    namespace tasks_trigger[%s]_bits {
        constexpr uint32_t TASKS_TRIGGER = (1U << 0);  ///< Trigger n for triggering the corresponding TRIGGERED[n] event
    }

    /// SUBSCRIBE_TRIGGER[%s] Register bits
    namespace subscribe_trigger[%s]_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that task TRIGGER[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_TRIGGERED[%s] Register bits
    namespace events_triggered[%s]_bits {
        constexpr uint32_t EVENTS_TRIGGERED = (1U << 0);  ///< Event number n generated by triggering the corresponding TRIGGER[n] task
    }

    /// PUBLISH_TRIGGERED[%s] Register bits
    namespace publish_triggered[%s]_bits {
        constexpr uint32_t CHIDX = (8 << 0);  ///< DPPI channel that event TRIGGERED[n] will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t TRIGGERED0 = (1U << 0);  ///< Enable or disable interrupt for event TRIGGERED[0]
        constexpr uint32_t TRIGGERED1 = (1U << 1);  ///< Enable or disable interrupt for event TRIGGERED[1]
        constexpr uint32_t TRIGGERED2 = (1U << 2);  ///< Enable or disable interrupt for event TRIGGERED[2]
        constexpr uint32_t TRIGGERED3 = (1U << 3);  ///< Enable or disable interrupt for event TRIGGERED[3]
        constexpr uint32_t TRIGGERED4 = (1U << 4);  ///< Enable or disable interrupt for event TRIGGERED[4]
        constexpr uint32_t TRIGGERED5 = (1U << 5);  ///< Enable or disable interrupt for event TRIGGERED[5]
        constexpr uint32_t TRIGGERED6 = (1U << 6);  ///< Enable or disable interrupt for event TRIGGERED[6]
        constexpr uint32_t TRIGGERED7 = (1U << 7);  ///< Enable or disable interrupt for event TRIGGERED[7]
        constexpr uint32_t TRIGGERED8 = (1U << 8);  ///< Enable or disable interrupt for event TRIGGERED[8]
        constexpr uint32_t TRIGGERED9 = (1U << 9);  ///< Enable or disable interrupt for event TRIGGERED[9]
        constexpr uint32_t TRIGGERED10 = (1U << 10);  ///< Enable or disable interrupt for event TRIGGERED[10]
        constexpr uint32_t TRIGGERED11 = (1U << 11);  ///< Enable or disable interrupt for event TRIGGERED[11]
        constexpr uint32_t TRIGGERED12 = (1U << 12);  ///< Enable or disable interrupt for event TRIGGERED[12]
        constexpr uint32_t TRIGGERED13 = (1U << 13);  ///< Enable or disable interrupt for event TRIGGERED[13]
        constexpr uint32_t TRIGGERED14 = (1U << 14);  ///< Enable or disable interrupt for event TRIGGERED[14]
        constexpr uint32_t TRIGGERED15 = (1U << 15);  ///< Enable or disable interrupt for event TRIGGERED[15]
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TRIGGERED0 = (1U << 0);  ///< Write '1' to enable interrupt for event TRIGGERED[0]
        constexpr uint32_t TRIGGERED1 = (1U << 1);  ///< Write '1' to enable interrupt for event TRIGGERED[1]
        constexpr uint32_t TRIGGERED2 = (1U << 2);  ///< Write '1' to enable interrupt for event TRIGGERED[2]
        constexpr uint32_t TRIGGERED3 = (1U << 3);  ///< Write '1' to enable interrupt for event TRIGGERED[3]
        constexpr uint32_t TRIGGERED4 = (1U << 4);  ///< Write '1' to enable interrupt for event TRIGGERED[4]
        constexpr uint32_t TRIGGERED5 = (1U << 5);  ///< Write '1' to enable interrupt for event TRIGGERED[5]
        constexpr uint32_t TRIGGERED6 = (1U << 6);  ///< Write '1' to enable interrupt for event TRIGGERED[6]
        constexpr uint32_t TRIGGERED7 = (1U << 7);  ///< Write '1' to enable interrupt for event TRIGGERED[7]
        constexpr uint32_t TRIGGERED8 = (1U << 8);  ///< Write '1' to enable interrupt for event TRIGGERED[8]
        constexpr uint32_t TRIGGERED9 = (1U << 9);  ///< Write '1' to enable interrupt for event TRIGGERED[9]
        constexpr uint32_t TRIGGERED10 = (1U << 10);  ///< Write '1' to enable interrupt for event TRIGGERED[10]
        constexpr uint32_t TRIGGERED11 = (1U << 11);  ///< Write '1' to enable interrupt for event TRIGGERED[11]
        constexpr uint32_t TRIGGERED12 = (1U << 12);  ///< Write '1' to enable interrupt for event TRIGGERED[12]
        constexpr uint32_t TRIGGERED13 = (1U << 13);  ///< Write '1' to enable interrupt for event TRIGGERED[13]
        constexpr uint32_t TRIGGERED14 = (1U << 14);  ///< Write '1' to enable interrupt for event TRIGGERED[14]
        constexpr uint32_t TRIGGERED15 = (1U << 15);  ///< Write '1' to enable interrupt for event TRIGGERED[15]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TRIGGERED0 = (1U << 0);  ///< Write '1' to disable interrupt for event TRIGGERED[0]
        constexpr uint32_t TRIGGERED1 = (1U << 1);  ///< Write '1' to disable interrupt for event TRIGGERED[1]
        constexpr uint32_t TRIGGERED2 = (1U << 2);  ///< Write '1' to disable interrupt for event TRIGGERED[2]
        constexpr uint32_t TRIGGERED3 = (1U << 3);  ///< Write '1' to disable interrupt for event TRIGGERED[3]
        constexpr uint32_t TRIGGERED4 = (1U << 4);  ///< Write '1' to disable interrupt for event TRIGGERED[4]
        constexpr uint32_t TRIGGERED5 = (1U << 5);  ///< Write '1' to disable interrupt for event TRIGGERED[5]
        constexpr uint32_t TRIGGERED6 = (1U << 6);  ///< Write '1' to disable interrupt for event TRIGGERED[6]
        constexpr uint32_t TRIGGERED7 = (1U << 7);  ///< Write '1' to disable interrupt for event TRIGGERED[7]
        constexpr uint32_t TRIGGERED8 = (1U << 8);  ///< Write '1' to disable interrupt for event TRIGGERED[8]
        constexpr uint32_t TRIGGERED9 = (1U << 9);  ///< Write '1' to disable interrupt for event TRIGGERED[9]
        constexpr uint32_t TRIGGERED10 = (1U << 10);  ///< Write '1' to disable interrupt for event TRIGGERED[10]
        constexpr uint32_t TRIGGERED11 = (1U << 11);  ///< Write '1' to disable interrupt for event TRIGGERED[11]
        constexpr uint32_t TRIGGERED12 = (1U << 12);  ///< Write '1' to disable interrupt for event TRIGGERED[12]
        constexpr uint32_t TRIGGERED13 = (1U << 13);  ///< Write '1' to disable interrupt for event TRIGGERED[13]
        constexpr uint32_t TRIGGERED14 = (1U << 14);  ///< Write '1' to disable interrupt for event TRIGGERED[14]
        constexpr uint32_t TRIGGERED15 = (1U << 15);  ///< Write '1' to disable interrupt for event TRIGGERED[15]
    }

}

// ============================================================================
// SWI0 Peripheral
// ============================================================================

namespace swi0 {
    /// Base addresses
    constexpr uint32_t SWI0_NS_BASE = 0x4101A000;

    /// SWI0 Register structure
    struct Registers {
        volatile uint32_t UNUSED;  ///< Offset: 0x00 - Unused.
    };

    /// Peripheral instances
    inline Registers* SWI0_NS = reinterpret_cast<Registers*>(SWI0_NS_BASE);

}

// ============================================================================
// SWI1 Peripheral
// ============================================================================

namespace swi1 {
    /// Base addresses
    constexpr uint32_t SWI1_NS_BASE = 0x4101B000;

    /// SWI1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SWI1_NS = reinterpret_cast<Registers*>(SWI1_NS_BASE);

}

// ============================================================================
// SWI2 Peripheral
// ============================================================================

namespace swi2 {
    /// Base addresses
    constexpr uint32_t SWI2_NS_BASE = 0x4101C000;

    /// SWI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SWI2_NS = reinterpret_cast<Registers*>(SWI2_NS_BASE);

}

// ============================================================================
// SWI3 Peripheral
// ============================================================================

namespace swi3 {
    /// Base addresses
    constexpr uint32_t SWI3_NS_BASE = 0x4101D000;

    /// SWI3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SWI3_NS = reinterpret_cast<Registers*>(SWI3_NS_BASE);

}

// ============================================================================
// APPMUTEX Peripheral
// ============================================================================

namespace appmutex {
    /// Base addresses
    constexpr uint32_t APPMUTEX_NS_BASE = 0x40030000;
    constexpr uint32_t APPMUTEX_S_BASE = 0x50030000;

    /// APPMUTEX Register structure
    struct Registers {
        volatile uint32_t MUTEX[%s];  ///< Offset: 0x400 - Description collection: Mutex register
    };

    /// Peripheral instances
    inline Registers* APPMUTEX_NS = reinterpret_cast<Registers*>(APPMUTEX_NS_BASE);
    inline Registers* APPMUTEX_S = reinterpret_cast<Registers*>(APPMUTEX_S_BASE);

    // Bit definitions
    /// MUTEX[%s] Register bits
    namespace mutex[%s]_bits {
        constexpr uint32_t MUTEX = (1U << 0);  ///< Mutex register n
    }

}

// ============================================================================
// ACL Peripheral
// ============================================================================

namespace acl {
    /// Base addresses
    constexpr uint32_t ACL_NS_BASE = 0x41080000;

    /// ACL Register structure
    struct Registers {
        volatile uint32_t ADDR;  ///< Offset: 0x00 - Description cluster: Start address of region to protect....
        volatile uint32_t SIZE;  ///< Offset: 0x04 - Description cluster: Size of region to protect counting...
        volatile uint32_t PERM;  ///< Offset: 0x08 - Description cluster: Access permissions for region n as...
    };

    /// Peripheral instances
    inline Registers* ACL_NS = reinterpret_cast<Registers*>(ACL_NS_BASE);

    // Bit definitions
    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Start address of flash region n. The start address must point to a flash page boundary.
    }

    /// SIZE Register bits
    namespace size_bits {
        constexpr uint32_t SIZE = (32 << 0);  ///< Size of flash region n in bytes. Must be a multiple of the flash page size.
    }

    /// PERM Register bits
    namespace perm_bits {
        constexpr uint32_t WRITE = (1U << 1);  ///< Configure write and erase permissions for region n. Writing a '0' has no effect.
        constexpr uint32_t READ = (1U << 2);  ///< Configure read permissions for region n. Writing a '0' has no effect.
    }

}

// ============================================================================
// NVMC Peripheral
// ============================================================================

namespace nvmc {
    /// Base addresses
    constexpr uint32_t NVMC_NS_BASE = 0x41080000;

    /// NVMC Register structure
    struct Registers {
        volatile uint32_t READY;  ///< Offset: 0x400 - Ready flag
        volatile uint32_t READYNEXT;  ///< Offset: 0x408 - Ready flag
        volatile uint32_t CONFIG;  ///< Offset: 0x504 - Configuration register
        volatile uint32_t ERASEALL;  ///< Offset: 0x50C - Register for erasing all non-volatile user memory
        volatile uint32_t ERASEPAGEPARTIALCFG;  ///< Offset: 0x51C - Register for partial erase configuration
        volatile uint32_t ICACHECNF;  ///< Offset: 0x540 - I-code cache configuration register
        volatile uint32_t IHIT;  ///< Offset: 0x548 - I-code cache hit counter
        volatile uint32_t IMISS;  ///< Offset: 0x54C - I-code cache miss counter
    };

    /// Peripheral instances
    inline Registers* NVMC_NS = reinterpret_cast<Registers*>(NVMC_NS_BASE);

    // Bit definitions
    /// READY Register bits
    namespace ready_bits {
        constexpr uint32_t READY = (1U << 0);  ///< NVMC is ready or busy
    }

    /// READYNEXT Register bits
    namespace readynext_bits {
        constexpr uint32_t READYNEXT = (1U << 0);  ///< NVMC can accept a new write operation
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t WEN = (3 << 0);  ///< Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated.
    }

    /// ERASEALL Register bits
    namespace eraseall_bits {
        constexpr uint32_t ERASEALL = (1U << 0);  ///< Erase all non-volatile memory including UICR registers. Before the non-volatile memory can be erased, erasing must be enabled by setting CONFIG.WEN=Een.
    }

    /// ERASEPAGEPARTIALCFG Register bits
    namespace erasepagepartialcfg_bits {
        constexpr uint32_t DURATION = (7 << 0);  ///< Duration of the partial erase in milliseconds
    }

    /// ICACHECNF Register bits
    namespace icachecnf_bits {
        constexpr uint32_t CACHEEN = (1U << 0);  ///< Cache enable
        constexpr uint32_t CACHEPROFEN = (1U << 8);  ///< Cache profiling enable
    }

    /// IHIT Register bits
    namespace ihit_bits {
        constexpr uint32_t HITS = (32 << 0);  ///< Number of cache hits Write zero to clear
    }

    /// IMISS Register bits
    namespace imiss_bits {
        constexpr uint32_t MISSES = (32 << 0);  ///< Number of cache misses Write zero to clear
    }

}

// ============================================================================
// VMC Peripheral
// ============================================================================

namespace vmc {
    /// Base addresses
    constexpr uint32_t VMC_NS_BASE = 0x41081000;

    /// VMC Register structure
    struct Registers {
        volatile uint32_t POWER;  ///< Offset: 0x00 - Description cluster: RAM[n] power control register
        volatile uint32_t POWERSET;  ///< Offset: 0x04 - Description cluster: RAM[n] power control set register
        volatile uint32_t POWERCLR;  ///< Offset: 0x08 - Description cluster: RAM[n] power control clear register
    };

    /// Peripheral instances
    inline Registers* VMC_NS = reinterpret_cast<Registers*>(VMC_NS_BASE);

    // Bit definitions
    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t S0POWER = (1U << 0);  ///< Keep RAM section S0 of RAM[n] on or off in System ON mode
        constexpr uint32_t S1POWER = (1U << 1);  ///< Keep RAM section S1 of RAM[n] on or off in System ON mode
        constexpr uint32_t S2POWER = (1U << 2);  ///< Keep RAM section S2 of RAM[n] on or off in System ON mode
        constexpr uint32_t S3POWER = (1U << 3);  ///< Keep RAM section S3 of RAM[n] on or off in System ON mode
        constexpr uint32_t S0RETENTION = (1U << 16);  ///< Keep retention on RAM section S0 of RAM[n] when RAM section is switched off
        constexpr uint32_t S1RETENTION = (1U << 17);  ///< Keep retention on RAM section S1 of RAM[n] when RAM section is switched off
        constexpr uint32_t S2RETENTION = (1U << 18);  ///< Keep retention on RAM section S2 of RAM[n] when RAM section is switched off
        constexpr uint32_t S3RETENTION = (1U << 19);  ///< Keep retention on RAM section S3 of RAM[n] when RAM section is switched off
    }

    /// POWERSET Register bits
    namespace powerset_bits {
        constexpr uint32_t S0POWER = (1U << 0);  ///< Keep RAM section S0 of RAM[n] on or off in System ON mode
        constexpr uint32_t S1POWER = (1U << 1);  ///< Keep RAM section S1 of RAM[n] on or off in System ON mode
        constexpr uint32_t S2POWER = (1U << 2);  ///< Keep RAM section S2 of RAM[n] on or off in System ON mode
        constexpr uint32_t S3POWER = (1U << 3);  ///< Keep RAM section S3 of RAM[n] on or off in System ON mode
        constexpr uint32_t S0RETENTION = (1U << 16);  ///< Keep retention on RAM section S0 of RAM[n] when RAM section is switched off
        constexpr uint32_t S1RETENTION = (1U << 17);  ///< Keep retention on RAM section S1 of RAM[n] when RAM section is switched off
        constexpr uint32_t S2RETENTION = (1U << 18);  ///< Keep retention on RAM section S2 of RAM[n] when RAM section is switched off
        constexpr uint32_t S3RETENTION = (1U << 19);  ///< Keep retention on RAM section S3 of RAM[n] when RAM section is switched off
    }

    /// POWERCLR Register bits
    namespace powerclr_bits {
        constexpr uint32_t S0POWER = (1U << 0);  ///< Keep RAM section S0 of RAM[n] on or off in System ON mode
        constexpr uint32_t S1POWER = (1U << 1);  ///< Keep RAM section S1 of RAM[n] on or off in System ON mode
        constexpr uint32_t S2POWER = (1U << 2);  ///< Keep RAM section S2 of RAM[n] on or off in System ON mode
        constexpr uint32_t S3POWER = (1U << 3);  ///< Keep RAM section S3 of RAM[n] on or off in System ON mode
        constexpr uint32_t S0RETENTION = (1U << 16);  ///< Keep retention on RAM section S0 of RAM[n] when RAM section is switched off
        constexpr uint32_t S1RETENTION = (1U << 17);  ///< Keep retention on RAM section S1 of RAM[n] when RAM section is switched off
        constexpr uint32_t S2RETENTION = (1U << 18);  ///< Keep retention on RAM section S2 of RAM[n] when RAM section is switched off
        constexpr uint32_t S3RETENTION = (1U << 19);  ///< Keep retention on RAM section S3 of RAM[n] when RAM section is switched off
    }

}

// ============================================================================
// P0 Peripheral
// ============================================================================

namespace p0 {
    /// Base addresses
    constexpr uint32_t P0_NS_BASE = 0x418C0500;

    /// P0 Register structure
    struct Registers {
        volatile uint32_t OUT;  ///< Offset: 0x04 - Write GPIO port
        volatile uint32_t OUTSET;  ///< Offset: 0x08 - Set individual bits in GPIO port
        volatile uint32_t OUTCLR;  ///< Offset: 0x0C - Clear individual bits in GPIO port
        volatile uint32_t IN;  ///< Offset: 0x10 - Read GPIO port
        volatile uint32_t DIR;  ///< Offset: 0x14 - Direction of GPIO pins
        volatile uint32_t DIRSET;  ///< Offset: 0x18 - DIR set register
        volatile uint32_t DIRCLR;  ///< Offset: 0x1C - DIR clear register
        volatile uint32_t LATCH;  ///< Offset: 0x20 - Latch register indicating what GPIO pins that have met...
        volatile uint32_t DETECTMODE;  ///< Offset: 0x24 - Select between default DETECT signal behavior and...
        volatile uint32_t DETECTMODE_SEC;  ///< Offset: 0x28 - Select between default DETECT signal behavior and...
        volatile uint32_t PIN_CNF[%s];  ///< Offset: 0x200 - Description collection: Configuration of GPIO pins
    };

    /// Peripheral instances
    inline Registers* P0_NS = reinterpret_cast<Registers*>(P0_NS_BASE);

    // Bit definitions
    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// OUTSET Register bits
    namespace outset_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// OUTCLR Register bits
    namespace outclr_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// DIR Register bits
    namespace dir_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// DIRSET Register bits
    namespace dirset_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Set as output pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Set as output pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Set as output pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Set as output pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Set as output pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Set as output pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Set as output pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Set as output pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Set as output pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Set as output pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Set as output pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Set as output pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Set as output pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Set as output pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Set as output pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Set as output pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Set as output pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Set as output pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Set as output pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Set as output pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Set as output pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Set as output pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Set as output pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Set as output pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Set as output pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Set as output pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Set as output pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Set as output pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Set as output pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Set as output pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Set as output pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Set as output pin 31
    }

    /// DIRCLR Register bits
    namespace dirclr_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Set as input pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Set as input pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Set as input pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Set as input pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Set as input pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Set as input pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Set as input pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Set as input pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Set as input pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Set as input pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Set as input pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Set as input pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Set as input pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Set as input pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Set as input pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Set as input pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Set as input pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Set as input pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Set as input pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Set as input pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Set as input pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Set as input pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Set as input pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Set as input pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Set as input pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Set as input pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Set as input pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Set as input pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Set as input pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Set as input pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Set as input pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Set as input pin 31
    }

    /// LATCH Register bits
    namespace latch_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Status on whether PIN[0] has met criteria set in PIN_CNF[0].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN1 = (1U << 1);  ///< Status on whether PIN[1] has met criteria set in PIN_CNF[1].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN2 = (1U << 2);  ///< Status on whether PIN[2] has met criteria set in PIN_CNF[2].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN3 = (1U << 3);  ///< Status on whether PIN[3] has met criteria set in PIN_CNF[3].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN4 = (1U << 4);  ///< Status on whether PIN[4] has met criteria set in PIN_CNF[4].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN5 = (1U << 5);  ///< Status on whether PIN[5] has met criteria set in PIN_CNF[5].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN6 = (1U << 6);  ///< Status on whether PIN[6] has met criteria set in PIN_CNF[6].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN7 = (1U << 7);  ///< Status on whether PIN[7] has met criteria set in PIN_CNF[7].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN8 = (1U << 8);  ///< Status on whether PIN[8] has met criteria set in PIN_CNF[8].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN9 = (1U << 9);  ///< Status on whether PIN[9] has met criteria set in PIN_CNF[9].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN10 = (1U << 10);  ///< Status on whether PIN[10] has met criteria set in PIN_CNF[10].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN11 = (1U << 11);  ///< Status on whether PIN[11] has met criteria set in PIN_CNF[11].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN12 = (1U << 12);  ///< Status on whether PIN[12] has met criteria set in PIN_CNF[12].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN13 = (1U << 13);  ///< Status on whether PIN[13] has met criteria set in PIN_CNF[13].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN14 = (1U << 14);  ///< Status on whether PIN[14] has met criteria set in PIN_CNF[14].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN15 = (1U << 15);  ///< Status on whether PIN[15] has met criteria set in PIN_CNF[15].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN16 = (1U << 16);  ///< Status on whether PIN[16] has met criteria set in PIN_CNF[16].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN17 = (1U << 17);  ///< Status on whether PIN[17] has met criteria set in PIN_CNF[17].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN18 = (1U << 18);  ///< Status on whether PIN[18] has met criteria set in PIN_CNF[18].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN19 = (1U << 19);  ///< Status on whether PIN[19] has met criteria set in PIN_CNF[19].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN20 = (1U << 20);  ///< Status on whether PIN[20] has met criteria set in PIN_CNF[20].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN21 = (1U << 21);  ///< Status on whether PIN[21] has met criteria set in PIN_CNF[21].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN22 = (1U << 22);  ///< Status on whether PIN[22] has met criteria set in PIN_CNF[22].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN23 = (1U << 23);  ///< Status on whether PIN[23] has met criteria set in PIN_CNF[23].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN24 = (1U << 24);  ///< Status on whether PIN[24] has met criteria set in PIN_CNF[24].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN25 = (1U << 25);  ///< Status on whether PIN[25] has met criteria set in PIN_CNF[25].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN26 = (1U << 26);  ///< Status on whether PIN[26] has met criteria set in PIN_CNF[26].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN27 = (1U << 27);  ///< Status on whether PIN[27] has met criteria set in PIN_CNF[27].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN28 = (1U << 28);  ///< Status on whether PIN[28] has met criteria set in PIN_CNF[28].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN29 = (1U << 29);  ///< Status on whether PIN[29] has met criteria set in PIN_CNF[29].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN30 = (1U << 30);  ///< Status on whether PIN[30] has met criteria set in PIN_CNF[30].SENSE register. Write '1' to clear.
        constexpr uint32_t PIN31 = (1U << 31);  ///< Status on whether PIN[31] has met criteria set in PIN_CNF[31].SENSE register. Write '1' to clear.
    }

    /// DETECTMODE Register bits
    namespace detectmode_bits {
        constexpr uint32_t DETECTMODE = (1U << 0);  ///< Select between default DETECT signal behavior and LDETECT mode
    }

    /// DETECTMODE_SEC Register bits
    namespace detectmode_sec_bits {
        constexpr uint32_t DETECTMODE = (1U << 0);  ///< Select between default DETECT signal behavior and LDETECT mode
    }

    /// PIN_CNF[%s] Register bits
    namespace pin_cnf[%s]_bits {
        constexpr uint32_t DIR = (1U << 0);  ///< Pin direction. Same physical register as DIR register
        constexpr uint32_t INPUT = (1U << 1);  ///< Connect or disconnect input buffer
        constexpr uint32_t PULL = (2 << 2);  ///< Pull configuration
        constexpr uint32_t DRIVE = (4 << 8);  ///< Drive configuration
        constexpr uint32_t SENSE = (2 << 16);  ///< Pin sensing mechanism
        constexpr uint32_t MCUSEL = (3 << 28);  ///< Select which MCU/Subsystem controls this pin Note: this field is only accessible from secure code.
    }

}

// ============================================================================
// P1 Peripheral
// ============================================================================

namespace p1 {
    /// Base addresses
    constexpr uint32_t P1_NS_BASE = 0x418C0800;

    /// P1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* P1_NS = reinterpret_cast<Registers*>(P1_NS_BASE);

}


} // namespace alloy::generated::nrf5340_network

#endif // ALLOY_GENERATED_NRF5340_NETWORK_PERIPHERALS_HPP