/// Auto-generated code for nrf9160
/// Generated by Alloy Code Generator
/// Source: nordic_nrf9160.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:26
#ifndef ALLOY_GENERATED_NRF9160_PERIPHERALS_HPP
#define ALLOY_GENERATED_NRF9160_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::nrf9160 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_ficr = true;
    constexpr uint32_t num_ficr_instances = 1;
    constexpr bool has_uicr = true;
    constexpr uint32_t num_uicr_instances = 1;
    constexpr bool has_tad = true;
    constexpr uint32_t num_tad_instances = 1;
    constexpr bool has_spu = true;
    constexpr uint32_t num_spu_instances = 1;
    constexpr bool has_regulators = true;
    constexpr uint32_t num_regulators_instances = 2;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 2;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 2;
    constexpr bool has_ctrl = true;
    constexpr uint32_t num_ctrl_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 16;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 16;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 8;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 2;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 6;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 4;
    constexpr bool has_dppic = true;
    constexpr uint32_t num_dppic_instances = 2;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_egu0 = true;
    constexpr uint32_t num_egu0_instances = 2;
    constexpr bool has_egu1 = true;
    constexpr uint32_t num_egu1_instances = 2;
    constexpr bool has_egu2 = true;
    constexpr uint32_t num_egu2_instances = 2;
    constexpr bool has_egu3 = true;
    constexpr uint32_t num_egu3_instances = 2;
    constexpr bool has_egu4 = true;
    constexpr uint32_t num_egu4_instances = 2;
    constexpr bool has_egu5 = true;
    constexpr uint32_t num_egu5_instances = 2;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 8;
    constexpr bool has_pdm = true;
    constexpr uint32_t num_pdm_instances = 2;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 2;
    constexpr bool has_ipc = true;
    constexpr uint32_t num_ipc_instances = 2;
    constexpr bool has_fpu = true;
    constexpr uint32_t num_fpu_instances = 2;
    constexpr bool has_kmu = true;
    constexpr uint32_t num_kmu_instances = 2;
    constexpr bool has_nvmc = true;
    constexpr uint32_t num_nvmc_instances = 2;
    constexpr bool has_vmc = true;
    constexpr uint32_t num_vmc_instances = 2;
    constexpr bool has_cc = true;
    constexpr uint32_t num_cc_instances = 1;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 1;
    constexpr bool has_p0 = true;
    constexpr uint32_t num_p0_instances = 2;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct ficr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct uicr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tad_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct regulators_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ctrl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 16;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 16;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct dppic_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct egu0_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct egu1_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct egu2_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct egu3_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct egu4_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct egu5_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct pdm_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ipc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct fpu_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct kmu_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct nvmc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct vmc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct cc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct p0_tag> {
        static constexpr uint32_t value = 2;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 2;
    constexpr uint32_t max_gpio_pins = 32;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uarte0_ns = true;
    constexpr bool has_uarte0_s = true;
    constexpr bool has_uarte1_ns = true;
    constexpr bool has_uarte1_s = true;
    constexpr bool has_uarte2_ns = true;
    constexpr bool has_uarte2_s = true;
    constexpr bool has_uarte3_ns = true;
    constexpr bool has_uarte3_s = true;
}

// ============================================================================
// FICR Peripheral
// ============================================================================

namespace ficr {
    /// Base addresses
    constexpr uint32_t FICR_S_BASE = 0x00FF0000;

    /// FICR Register structure
    struct Registers {
        volatile uint32_t DEVICEID__;  ///< Offset: 0x04 - Description collection: Device identifier (renamed from DEVICEID__)
        volatile uint32_t PART;  ///< Offset: 0x0C - Part code
        volatile uint32_t VARIANT;  ///< Offset: 0x10 - Part Variant, Hardware version and Production configuration
        volatile uint32_t PACKAGE;  ///< Offset: 0x14 - Package option
        volatile uint32_t RAM;  ///< Offset: 0x18 - RAM variant
        volatile uint32_t FLASH;  ///< Offset: 0x1C - Flash variant
        volatile uint32_t CODEPAGESIZE;  ///< Offset: 0x20 - Code memory page size
        volatile uint32_t CODESIZE;  ///< Offset: 0x24 - Code memory size
        volatile uint32_t DEVICETYPE;  ///< Offset: 0x28 - Device type
        volatile uint32_t ADDR;  ///< Offset: 0x00 - Description cluster: Address
        volatile uint32_t DATA;  ///< Offset: 0x04 - Description cluster: Data
        volatile uint32_t BYTES;  ///< Offset: 0x00 - Amount of bytes for the required entropy bits
        volatile uint32_t RCCUTOFF;  ///< Offset: 0x04 - Repetition counter cutoff
        volatile uint32_t APCUTOFF;  ///< Offset: 0x08 - Adaptive proportion cutoff
        volatile uint32_t STARTUP;  ///< Offset: 0x0C - Amount of bytes for the startup tests
        volatile uint32_t ROSC1;  ///< Offset: 0x10 - Sample count for ring oscillator 1
        volatile uint32_t ROSC2;  ///< Offset: 0x14 - Sample count for ring oscillator 2
        volatile uint32_t ROSC3;  ///< Offset: 0x18 - Sample count for ring oscillator 3
        volatile uint32_t ROSC4;  ///< Offset: 0x1C - Sample count for ring oscillator 4
    };

    /// Peripheral instances
    inline Registers* FICR_S = reinterpret_cast<Registers*>(FICR_S_BASE);

    // Bit definitions
    /// DEVICEID__ Register bits
    namespace deviceid___bits {
        constexpr uint32_t DEVICEID = (32 << 0);  ///< 64 bit unique device identifier
    }

    /// PART Register bits
    namespace part_bits {
        constexpr uint32_t PART = (32 << 0);  ///< Part code
    }

    /// VARIANT Register bits
    namespace variant_bits {
        constexpr uint32_t VARIANT = (32 << 0);  ///< Part Variant, Hardware version and Production configuration, encoded as ASCII
    }

    /// PACKAGE Register bits
    namespace package_bits {
        constexpr uint32_t PACKAGE = (32 << 0);  ///< Package option
    }

    /// RAM Register bits
    namespace ram_bits {
        constexpr uint32_t RAM = (32 << 0);  ///< RAM variant
    }

    /// FLASH Register bits
    namespace flash_bits {
        constexpr uint32_t FLASH = (32 << 0);  ///< Flash variant
    }

    /// CODEPAGESIZE Register bits
    namespace codepagesize_bits {
        constexpr uint32_t CODEPAGESIZE = (32 << 0);  ///< Code memory page size
    }

    /// CODESIZE Register bits
    namespace codesize_bits {
        constexpr uint32_t CODESIZE = (32 << 0);  ///< Code memory size in number of pages
    }

    /// DEVICETYPE Register bits
    namespace devicetype_bits {
        constexpr uint32_t DEVICETYPE = (32 << 0);  ///< Device type
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t Address = (32 << 0);  ///< Address
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t Data = (32 << 0);  ///< Data
    }

    /// BYTES Register bits
    namespace bytes_bits {
        constexpr uint32_t BYTES = (32 << 0);  ///< Amount of bytes for the required entropy bits
    }

    /// RCCUTOFF Register bits
    namespace rccutoff_bits {
        constexpr uint32_t RCCUTOFF = (32 << 0);  ///< Repetition counter cutoff
    }

    /// APCUTOFF Register bits
    namespace apcutoff_bits {
        constexpr uint32_t APCUTOFF = (32 << 0);  ///< Adaptive proportion cutoff
    }

    /// STARTUP Register bits
    namespace startup_bits {
        constexpr uint32_t STARTUP = (32 << 0);  ///< Amount of bytes for the startup tests
    }

    /// ROSC1 Register bits
    namespace rosc1_bits {
        constexpr uint32_t ROSC1 = (32 << 0);  ///< Sample count for ring oscillator 1
    }

    /// ROSC2 Register bits
    namespace rosc2_bits {
        constexpr uint32_t ROSC2 = (32 << 0);  ///< Sample count for ring oscillator 2
    }

    /// ROSC3 Register bits
    namespace rosc3_bits {
        constexpr uint32_t ROSC3 = (32 << 0);  ///< Sample count for ring oscillator 3
    }

    /// ROSC4 Register bits
    namespace rosc4_bits {
        constexpr uint32_t ROSC4 = (32 << 0);  ///< Sample count for ring oscillator 4
    }

}

// ============================================================================
// UICR Peripheral
// ============================================================================

namespace uicr {
    /// Base addresses
    constexpr uint32_t UICR_S_BASE = 0x00FF8000;

    /// UICR Register structure
    struct Registers {
        volatile uint32_t APPROTECT;  ///< Offset: 0x00 - Access port protection
        volatile uint32_t XOSC32M;  ///< Offset: 0x14 - Oscillator control
        volatile uint32_t HFXOSRC;  ///< Offset: 0x1C - HFXO clock source selection
        volatile uint32_t HFXOCNT;  ///< Offset: 0x20 - HFXO startup counter
        volatile uint32_t SECUREAPPROTECT;  ///< Offset: 0x2C - Secure access port protection
        volatile uint32_t ERASEPROTECT;  ///< Offset: 0x30 - Erase protection
        volatile uint32_t OTP__;  ///< Offset: 0x108 - Description collection: One time programmable memory (renamed from OTP__)
        volatile uint32_t DEST;  ///< Offset: 0x00 - Description cluster: Destination address where content...
        volatile uint32_t PERM;  ///< Offset: 0x04 - Description cluster: Define permissions for the key...
        volatile uint32_t VALUE__;  ///< Offset: 0x00 - Description collection: Define bits [31+o*32:0+o*32] of... (renamed from VALUE__)
    };

    /// Peripheral instances
    inline Registers* UICR_S = reinterpret_cast<Registers*>(UICR_S_BASE);

    // Bit definitions
    /// APPROTECT Register bits
    namespace approtect_bits {
        constexpr uint32_t PALL = (32 << 0);  ///< Blocks debugger read/write access to all CPU registers and memory mapped addresses
    }

    /// XOSC32M Register bits
    namespace xosc32m_bits {
        constexpr uint32_t CTRL = (6 << 0);  ///< Pierce current DAC control signals
    }

    /// HFXOSRC Register bits
    namespace hfxosrc_bits {
        constexpr uint32_t HFXOSRC = (1U << 0);  ///< HFXO clock source selection
    }

    /// HFXOCNT Register bits
    namespace hfxocnt_bits {
        constexpr uint32_t HFXOCNT = (8 << 0);  ///< HFXO startup counter. Total debounce time = HFXOCNT*64 us + 0.5 us
    }

    /// SECUREAPPROTECT Register bits
    namespace secureapprotect_bits {
        constexpr uint32_t PALL = (32 << 0);  ///< Blocks debugger read/write access to all secure CPU registers and secure memory mapped addresses
    }

    /// ERASEPROTECT Register bits
    namespace eraseprotect_bits {
        constexpr uint32_t PALL = (32 << 0);  ///< Blocks NVMC ERASEALL and CTRLAP ERASEALL functionality
    }

    /// OTP__ Register bits
    namespace otp___bits {
        constexpr uint32_t LOWER = (16 << 0);  ///< Lower half word
        constexpr uint32_t UPPER = (16 << 16);  ///< Upper half word
    }

    /// DEST Register bits
    namespace dest_bits {
        constexpr uint32_t DEST = (32 << 0);  ///< Secure APB destination address
    }

    /// PERM Register bits
    namespace perm_bits {
        constexpr uint32_t WRITE = (1U << 0);  ///< Write permission for key slot
        constexpr uint32_t READ = (1U << 1);  ///< Read permission for key slot
        constexpr uint32_t PUSH = (1U << 2);  ///< Push permission for key slot
        constexpr uint32_t STATE = (1U << 16);  ///< Revocation state for the key slot
    }

    /// VALUE__ Register bits
    namespace value___bits {
        constexpr uint32_t VALUE = (32 << 0);  ///< Define bits [31+o*32:0+o*32] of value assigned to KMU key slot
    }

}

// ============================================================================
// TAD Peripheral
// ============================================================================

namespace tad {
    /// Base addresses
    constexpr uint32_t TAD_S_BASE = 0xE0080000;

    /// TAD Register structure
    struct Registers {
        volatile uint32_t CLOCKSTART;  ///< Offset: 0x00 - Start all trace and debug clocks.
        volatile uint32_t CLOCKSTOP;  ///< Offset: 0x04 - Stop all trace and debug clocks.
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable debug domain and aquire selected GPIOs
        volatile uint32_t TRACECLK;  ///< Offset: 0x00 - Pin number configuration for TRACECLK
        volatile uint32_t TRACEDATA0;  ///< Offset: 0x04 - Pin number configuration for TRACEDATA[0]
        volatile uint32_t TRACEDATA1;  ///< Offset: 0x08 - Pin number configuration for TRACEDATA[1]
        volatile uint32_t TRACEDATA2;  ///< Offset: 0x0C - Pin number configuration for TRACEDATA[2]
        volatile uint32_t TRACEDATA3;  ///< Offset: 0x10 - Pin number configuration for TRACEDATA[3]
        volatile uint32_t TRACEPORTSPEED;  ///< Offset: 0x518 - Clocking options for the Trace Port debug interface
    };

    /// Peripheral instances
    inline Registers* TAD_S = reinterpret_cast<Registers*>(TAD_S_BASE);

    // Bit definitions
    /// CLOCKSTART Register bits
    namespace clockstart_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start all trace and debug clocks.
    }

    /// CLOCKSTOP Register bits
    namespace clockstop_bits {
        constexpr uint32_t STOP = (1U << 0);  ///< Stop all trace and debug clocks.
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Disable debug domain and release selected GPIOs
    }

    /// TRACECLK Register bits
    namespace traceclk_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// TRACEDATA0 Register bits
    namespace tracedata0_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// TRACEDATA1 Register bits
    namespace tracedata1_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// TRACEDATA2 Register bits
    namespace tracedata2_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// TRACEDATA3 Register bits
    namespace tracedata3_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// TRACEPORTSPEED Register bits
    namespace traceportspeed_bits {
        constexpr uint32_t TRACEPORTSPEED = (2 << 0);  ///< Speed of Trace Port clock. Note that the TRACECLK pin will output this clock divided by two.
    }

}

// ============================================================================
// SPU Peripheral
// ============================================================================

namespace spu {
    /// Base addresses
    constexpr uint32_t SPU_S_BASE = 0x50003000;

    /// SPU Register structure
    struct Registers {
        volatile uint32_t EVENTS_RAMACCERR;  ///< Offset: 0x100 - A security violation has been detected for the RAM memory space
        volatile uint32_t EVENTS_FLASHACCERR;  ///< Offset: 0x104 - A security violation has been detected for the flash memory space
        volatile uint32_t EVENTS_PERIPHACCERR;  ///< Offset: 0x108 - A security violation has been detected on one or several...
        volatile uint32_t PUBLISH_RAMACCERR;  ///< Offset: 0x180 - Publish configuration for event RAMACCERR
        volatile uint32_t PUBLISH_FLASHACCERR;  ///< Offset: 0x184 - Publish configuration for event FLASHACCERR
        volatile uint32_t PUBLISH_PERIPHACCERR;  ///< Offset: 0x188 - Publish configuration for event PERIPHACCERR
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t CAP;  ///< Offset: 0x400 - Show implemented features for the current device
        volatile uint32_t PERM;  ///< Offset: 0x00 - Description cluster: List capabilities and access...
        volatile uint32_t LOCK;  ///< Offset: 0x04 - Description cluster: Prevent further modification of the...
        volatile uint32_t REGION;  ///< Offset: 0x00 - Description cluster: Define which RAM region can contain...
        volatile uint32_t SIZE;  ///< Offset: 0x04 - Description cluster: Define the size of the non-secure...
    };

    /// Peripheral instances
    inline Registers* SPU_S = reinterpret_cast<Registers*>(SPU_S_BASE);

    // Bit definitions
    /// EVENTS_RAMACCERR Register bits
    namespace events_ramaccerr_bits {
        constexpr uint32_t EVENTS_RAMACCERR = (1U << 0);  ///< A security violation has been detected for the RAM memory space
    }

    /// EVENTS_FLASHACCERR Register bits
    namespace events_flashaccerr_bits {
        constexpr uint32_t EVENTS_FLASHACCERR = (1U << 0);  ///< A security violation has been detected for the flash memory space
    }

    /// EVENTS_PERIPHACCERR Register bits
    namespace events_periphaccerr_bits {
        constexpr uint32_t EVENTS_PERIPHACCERR = (1U << 0);  ///< A security violation has been detected on one or several peripherals
    }

    /// PUBLISH_RAMACCERR Register bits
    namespace publish_ramaccerr_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event RAMACCERR will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_FLASHACCERR Register bits
    namespace publish_flashaccerr_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event FLASHACCERR will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_PERIPHACCERR Register bits
    namespace publish_periphaccerr_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event PERIPHACCERR will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t RAMACCERR = (1U << 0);  ///< Enable or disable interrupt for event RAMACCERR
        constexpr uint32_t FLASHACCERR = (1U << 1);  ///< Enable or disable interrupt for event FLASHACCERR
        constexpr uint32_t PERIPHACCERR = (1U << 2);  ///< Enable or disable interrupt for event PERIPHACCERR
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t RAMACCERR = (1U << 0);  ///< Write '1' to enable interrupt for event RAMACCERR
        constexpr uint32_t FLASHACCERR = (1U << 1);  ///< Write '1' to enable interrupt for event FLASHACCERR
        constexpr uint32_t PERIPHACCERR = (1U << 2);  ///< Write '1' to enable interrupt for event PERIPHACCERR
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t RAMACCERR = (1U << 0);  ///< Write '1' to disable interrupt for event RAMACCERR
        constexpr uint32_t FLASHACCERR = (1U << 1);  ///< Write '1' to disable interrupt for event FLASHACCERR
        constexpr uint32_t PERIPHACCERR = (1U << 2);  ///< Write '1' to disable interrupt for event PERIPHACCERR
    }

    /// CAP Register bits
    namespace cap_bits {
        constexpr uint32_t TZM = (1U << 0);  ///< Show ARM TrustZone status
    }

    /// PERM Register bits
    namespace perm_bits {
        constexpr uint32_t SECUREMAPPING = (2 << 0);  ///< Define configuration capabilities for TrustZone Cortex-M secure attribute
        constexpr uint32_t DMA = (2 << 2);  ///< Indicate if the peripheral has DMA capabilities and if DMA transfer can be assigned to a different security attribute than the peripheral itself
        constexpr uint32_t SECATTR = (1U << 4);  ///< Peripheral security mapping
        constexpr uint32_t DMASEC = (1U << 5);  ///< Security attribution for the DMA transfer
        constexpr uint32_t LOCK = (1U << 8);  ///< This register can be updated
        constexpr uint32_t PRESENT = (1U << 31);  ///< Indicate if a peripheral is present with ID n
    }

    /// LOCK Register bits
    namespace lock_bits {
        constexpr uint32_t LOCK = (1U << 0);  ///< GPIOPORT[n].PERM register can't be changed until next reset
    }

    /// REGION Register bits
    namespace region_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< Region number
        constexpr uint32_t LOCK = (1U << 8);  ///< This register can be updated
    }

    /// SIZE Register bits
    namespace size_bits {
        constexpr uint32_t SIZE = (4 << 0);  ///< Size of the non-secure callable (NSC) region n
        constexpr uint32_t LOCK = (1U << 8);  ///< This register can be updated
    }

}

// ============================================================================
// REGULATORS Peripheral
// ============================================================================

namespace regulators {
    /// Base addresses
    constexpr uint32_t REGULATORS_NS_BASE = 0x40004000;
    constexpr uint32_t REGULATORS_S_BASE = 0x50004000;

    /// REGULATORS Register structure
    struct Registers {
        volatile uint32_t SYSTEMOFF;  ///< Offset: 0x500 - System OFF register
        volatile uint32_t DCDCEN;  ///< Offset: 0x578 - Enable DC/DC mode of the main voltage regulator.
    };

    /// Peripheral instances
    inline Registers* REGULATORS_NS = reinterpret_cast<Registers*>(REGULATORS_NS_BASE);
    inline Registers* REGULATORS_S = reinterpret_cast<Registers*>(REGULATORS_S_BASE);

    // Bit definitions
    /// SYSTEMOFF Register bits
    namespace systemoff_bits {
        constexpr uint32_t SYSTEMOFF = (1U << 0);  ///< Enable System OFF mode
    }

    /// DCDCEN Register bits
    namespace dcdcen_bits {
        constexpr uint32_t DCDCEN = (1U << 0);  ///< Enable DC/DC converter
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t CLOCK_NS_BASE = 0x40005000;
    constexpr uint32_t CLOCK_S_BASE = 0x50005000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t TASKS_HFCLKSTART;  ///< Offset: 0x00 - Start HFCLK source
        volatile uint32_t TASKS_HFCLKSTOP;  ///< Offset: 0x04 - Stop HFCLK source
        volatile uint32_t TASKS_LFCLKSTART;  ///< Offset: 0x08 - Start LFCLK source
        volatile uint32_t TASKS_LFCLKSTOP;  ///< Offset: 0x0C - Stop LFCLK source
        volatile uint32_t SUBSCRIBE_HFCLKSTART;  ///< Offset: 0x80 - Subscribe configuration for task HFCLKSTART
        volatile uint32_t SUBSCRIBE_HFCLKSTOP;  ///< Offset: 0x84 - Subscribe configuration for task HFCLKSTOP
        volatile uint32_t SUBSCRIBE_LFCLKSTART;  ///< Offset: 0x88 - Subscribe configuration for task LFCLKSTART
        volatile uint32_t SUBSCRIBE_LFCLKSTOP;  ///< Offset: 0x8C - Subscribe configuration for task LFCLKSTOP
        volatile uint32_t EVENTS_HFCLKSTARTED;  ///< Offset: 0x100 - HFCLK oscillator started
        volatile uint32_t EVENTS_LFCLKSTARTED;  ///< Offset: 0x104 - LFCLK started
        volatile uint32_t PUBLISH_HFCLKSTARTED;  ///< Offset: 0x180 - Publish configuration for event HFCLKSTARTED
        volatile uint32_t PUBLISH_LFCLKSTARTED;  ///< Offset: 0x184 - Publish configuration for event LFCLKSTARTED
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t INTPEND;  ///< Offset: 0x30C - Pending interrupts
        volatile uint32_t HFCLKRUN;  ///< Offset: 0x408 - Status indicating that HFCLKSTART task has been triggered
        volatile uint32_t HFCLKSTAT;  ///< Offset: 0x40C - The register shows if HFXO has been requested by...
        volatile uint32_t LFCLKRUN;  ///< Offset: 0x414 - Status indicating that LFCLKSTART task has been triggered
        volatile uint32_t LFCLKSTAT;  ///< Offset: 0x418 - The register shows which LFCLK source has been requested...
        volatile uint32_t LFCLKSRCCOPY;  ///< Offset: 0x41C - Copy of LFCLKSRC register, set after LFCLKSTART task has...
        volatile uint32_t LFCLKSRC;  ///< Offset: 0x518 - Clock source for the LFCLK. LFCLKSTART task starts...
    };

    /// Peripheral instances
    inline Registers* CLOCK_NS = reinterpret_cast<Registers*>(CLOCK_NS_BASE);
    inline Registers* CLOCK_S = reinterpret_cast<Registers*>(CLOCK_S_BASE);

    // Bit definitions
    /// TASKS_HFCLKSTART Register bits
    namespace tasks_hfclkstart_bits {
        constexpr uint32_t TASKS_HFCLKSTART = (1U << 0);  ///< Start HFCLK source
    }

    /// TASKS_HFCLKSTOP Register bits
    namespace tasks_hfclkstop_bits {
        constexpr uint32_t TASKS_HFCLKSTOP = (1U << 0);  ///< Stop HFCLK source
    }

    /// TASKS_LFCLKSTART Register bits
    namespace tasks_lfclkstart_bits {
        constexpr uint32_t TASKS_LFCLKSTART = (1U << 0);  ///< Start LFCLK source
    }

    /// TASKS_LFCLKSTOP Register bits
    namespace tasks_lfclkstop_bits {
        constexpr uint32_t TASKS_LFCLKSTOP = (1U << 0);  ///< Stop LFCLK source
    }

    /// SUBSCRIBE_HFCLKSTART Register bits
    namespace subscribe_hfclkstart_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task HFCLKSTART will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_HFCLKSTOP Register bits
    namespace subscribe_hfclkstop_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task HFCLKSTOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_LFCLKSTART Register bits
    namespace subscribe_lfclkstart_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task LFCLKSTART will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_LFCLKSTOP Register bits
    namespace subscribe_lfclkstop_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task LFCLKSTOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_HFCLKSTARTED Register bits
    namespace events_hfclkstarted_bits {
        constexpr uint32_t EVENTS_HFCLKSTARTED = (1U << 0);  ///< HFCLK oscillator started
    }

    /// EVENTS_LFCLKSTARTED Register bits
    namespace events_lfclkstarted_bits {
        constexpr uint32_t EVENTS_LFCLKSTARTED = (1U << 0);  ///< LFCLK started
    }

    /// PUBLISH_HFCLKSTARTED Register bits
    namespace publish_hfclkstarted_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event HFCLKSTARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_LFCLKSTARTED Register bits
    namespace publish_lfclkstarted_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event LFCLKSTARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Enable or disable interrupt for event HFCLKSTARTED
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Enable or disable interrupt for event LFCLKSTARTED
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Write '1' to enable interrupt for event HFCLKSTARTED
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Write '1' to enable interrupt for event LFCLKSTARTED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Write '1' to disable interrupt for event HFCLKSTARTED
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Write '1' to disable interrupt for event LFCLKSTARTED
    }

    /// INTPEND Register bits
    namespace intpend_bits {
        constexpr uint32_t HFCLKSTARTED = (1U << 0);  ///< Read pending status of interrupt for event HFCLKSTARTED
        constexpr uint32_t LFCLKSTARTED = (1U << 1);  ///< Read pending status of interrupt for event LFCLKSTARTED
    }

    /// HFCLKRUN Register bits
    namespace hfclkrun_bits {
        constexpr uint32_t STATUS = (1U << 0);  ///< HFCLKSTART task triggered or not
    }

    /// HFCLKSTAT Register bits
    namespace hfclkstat_bits {
        constexpr uint32_t SRC = (1U << 0);  ///< Active clock source
        constexpr uint32_t STATE = (1U << 16);  ///< HFCLK state
    }

    /// LFCLKRUN Register bits
    namespace lfclkrun_bits {
        constexpr uint32_t STATUS = (1U << 0);  ///< LFCLKSTART task triggered or not
    }

    /// LFCLKSTAT Register bits
    namespace lfclkstat_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Active clock source
        constexpr uint32_t STATE = (1U << 16);  ///< LFCLK state
    }

    /// LFCLKSRCCOPY Register bits
    namespace lfclksrccopy_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Clock source
    }

    /// LFCLKSRC Register bits
    namespace lfclksrc_bits {
        constexpr uint32_t SRC = (2 << 0);  ///< Clock source
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t POWER_NS_BASE = 0x40005000;
    constexpr uint32_t POWER_S_BASE = 0x50005000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t TASKS_CONSTLAT;  ///< Offset: 0x78 - Enable constant latency mode.
        volatile uint32_t TASKS_LOWPWR;  ///< Offset: 0x7C - Enable low power mode (variable latency)
        volatile uint32_t SUBSCRIBE_CONSTLAT;  ///< Offset: 0xF8 - Subscribe configuration for task CONSTLAT
        volatile uint32_t SUBSCRIBE_LOWPWR;  ///< Offset: 0xFC - Subscribe configuration for task LOWPWR
        volatile uint32_t EVENTS_POFWARN;  ///< Offset: 0x108 - Power failure warning
        volatile uint32_t EVENTS_SLEEPENTER;  ///< Offset: 0x114 - CPU entered WFI/WFE sleep
        volatile uint32_t EVENTS_SLEEPEXIT;  ///< Offset: 0x118 - CPU exited WFI/WFE sleep
        volatile uint32_t PUBLISH_POFWARN;  ///< Offset: 0x188 - Publish configuration for event POFWARN
        volatile uint32_t PUBLISH_SLEEPENTER;  ///< Offset: 0x194 - Publish configuration for event SLEEPENTER
        volatile uint32_t PUBLISH_SLEEPEXIT;  ///< Offset: 0x198 - Publish configuration for event SLEEPEXIT
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t RESETREAS;  ///< Offset: 0x400 - Reset reason
        volatile uint32_t POWERSTATUS;  ///< Offset: 0x440 - Modem domain power status
        volatile uint32_t GPREGRET__;  ///< Offset: 0x51C - Description collection: General purpose retention register (renamed from GPREGRET__)
    };

    /// Peripheral instances
    inline Registers* POWER_NS = reinterpret_cast<Registers*>(POWER_NS_BASE);
    inline Registers* POWER_S = reinterpret_cast<Registers*>(POWER_S_BASE);

    // Bit definitions
    /// TASKS_CONSTLAT Register bits
    namespace tasks_constlat_bits {
        constexpr uint32_t TASKS_CONSTLAT = (1U << 0);  ///< Enable constant latency mode.
    }

    /// TASKS_LOWPWR Register bits
    namespace tasks_lowpwr_bits {
        constexpr uint32_t TASKS_LOWPWR = (1U << 0);  ///< Enable low power mode (variable latency)
    }

    /// SUBSCRIBE_CONSTLAT Register bits
    namespace subscribe_constlat_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task CONSTLAT will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_LOWPWR Register bits
    namespace subscribe_lowpwr_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task LOWPWR will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_POFWARN Register bits
    namespace events_pofwarn_bits {
        constexpr uint32_t EVENTS_POFWARN = (1U << 0);  ///< Power failure warning
    }

    /// EVENTS_SLEEPENTER Register bits
    namespace events_sleepenter_bits {
        constexpr uint32_t EVENTS_SLEEPENTER = (1U << 0);  ///< CPU entered WFI/WFE sleep
    }

    /// EVENTS_SLEEPEXIT Register bits
    namespace events_sleepexit_bits {
        constexpr uint32_t EVENTS_SLEEPEXIT = (1U << 0);  ///< CPU exited WFI/WFE sleep
    }

    /// PUBLISH_POFWARN Register bits
    namespace publish_pofwarn_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event POFWARN will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_SLEEPENTER Register bits
    namespace publish_sleepenter_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event SLEEPENTER will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_SLEEPEXIT Register bits
    namespace publish_sleepexit_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event SLEEPEXIT will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t POFWARN = (1U << 2);  ///< Enable or disable interrupt for event POFWARN
        constexpr uint32_t SLEEPENTER = (1U << 5);  ///< Enable or disable interrupt for event SLEEPENTER
        constexpr uint32_t SLEEPEXIT = (1U << 6);  ///< Enable or disable interrupt for event SLEEPEXIT
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t POFWARN = (1U << 2);  ///< Write '1' to enable interrupt for event POFWARN
        constexpr uint32_t SLEEPENTER = (1U << 5);  ///< Write '1' to enable interrupt for event SLEEPENTER
        constexpr uint32_t SLEEPEXIT = (1U << 6);  ///< Write '1' to enable interrupt for event SLEEPEXIT
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t POFWARN = (1U << 2);  ///< Write '1' to disable interrupt for event POFWARN
        constexpr uint32_t SLEEPENTER = (1U << 5);  ///< Write '1' to disable interrupt for event SLEEPENTER
        constexpr uint32_t SLEEPEXIT = (1U << 6);  ///< Write '1' to disable interrupt for event SLEEPEXIT
    }

    /// RESETREAS Register bits
    namespace resetreas_bits {
        constexpr uint32_t RESETPIN = (1U << 0);  ///< Reset from pin reset detected
        constexpr uint32_t DOG = (1U << 1);  ///< Reset from global watchdog detected
        constexpr uint32_t OFF = (1U << 2);  ///< Reset due to wakeup from System OFF mode, when wakeup is triggered by DETECT signal from GPIO
        constexpr uint32_t DIF = (1U << 4);  ///< Reset due to wakeup from System OFF mode, when wakeup is triggered by entering debug interface mode
        constexpr uint32_t SREQ = (1U << 16);  ///< Reset from AIRCR.SYSRESETREQ detected
        constexpr uint32_t LOCKUP = (1U << 17);  ///< Reset from CPU lock-up detected
        constexpr uint32_t CTRLAP = (1U << 18);  ///< Reset triggered through CTRL-AP
    }

    /// POWERSTATUS Register bits
    namespace powerstatus_bits {
        constexpr uint32_t LTEMODEM = (1U << 0);  ///< LTE modem domain status
    }

    /// GPREGRET__ Register bits
    namespace gpregret___bits {
        constexpr uint32_t GPREGRET = (8 << 0);  ///< General purpose retention register
    }

}

// ============================================================================
// CTRL Peripheral
// ============================================================================

namespace ctrl {
    /// Base addresses
    constexpr uint32_t CTRL_AP_PERI_S_BASE = 0x50006000;

    /// CTRL Register structure
    struct Registers {
        volatile uint32_t RXDATA;  ///< Offset: 0x00 - Data sent from the debugger to the CPU
        volatile uint32_t RXSTATUS;  ///< Offset: 0x04 - Status to indicate if data sent from the debugger to the...
        volatile uint32_t TXDATA;  ///< Offset: 0x80 - Data sent from the CPU to the debugger
        volatile uint32_t TXSTATUS;  ///< Offset: 0x84 - Status to indicate if data sent from the CPU to the...
        volatile uint32_t LOCK;  ///< Offset: 0x00 - Lock register ERASEPROTECT.DISABLE from being written...
        volatile uint32_t DISABLE;  ///< Offset: 0x04 - Disable ERASEPROTECT and perform ERASEALL
    };

    /// Peripheral instances
    inline Registers* CTRL_AP_PERI_S = reinterpret_cast<Registers*>(CTRL_AP_PERI_S_BASE);

    // Bit definitions
    /// RXDATA Register bits
    namespace rxdata_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Data received from debugger
    }

    /// RXSTATUS Register bits
    namespace rxstatus_bits {
        constexpr uint32_t RXSTATUS = (1U << 0);  ///< Status of data in register RXDATA
    }

    /// TXDATA Register bits
    namespace txdata_bits {
        constexpr uint32_t TXDATA = (32 << 0);  ///< Data sent to debugger
    }

    /// TXSTATUS Register bits
    namespace txstatus_bits {
        constexpr uint32_t TXSTATUS = (1U << 0);  ///< Status of data in register TXDATA
    }

    /// LOCK Register bits
    namespace lock_bits {
        constexpr uint32_t LOCK = (1U << 0);  ///< Lock register ERASEPROTECT.DISABLE from being written until next reset
    }

    /// DISABLE Register bits
    namespace disable_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< The ERASEALL sequence will be initiated if value of KEY fields are non-zero and KEY fields match on both CPU and debugger side
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPIM0_NS_BASE = 0x40008000;
    constexpr uint32_t SPIS0_NS_BASE = 0x40008000;
    constexpr uint32_t SPIM0_S_BASE = 0x50008000;
    constexpr uint32_t SPIS0_S_BASE = 0x50008000;
    constexpr uint32_t SPIM1_NS_BASE = 0x40009000;
    constexpr uint32_t SPIS1_NS_BASE = 0x40009000;
    constexpr uint32_t SPIM1_S_BASE = 0x50009000;
    constexpr uint32_t SPIS1_S_BASE = 0x50009000;
    constexpr uint32_t SPIM2_NS_BASE = 0x4000A000;
    constexpr uint32_t SPIS2_NS_BASE = 0x4000A000;
    constexpr uint32_t SPIM2_S_BASE = 0x5000A000;
    constexpr uint32_t SPIS2_S_BASE = 0x5000A000;
    constexpr uint32_t SPIM3_NS_BASE = 0x4000B000;
    constexpr uint32_t SPIS3_NS_BASE = 0x4000B000;
    constexpr uint32_t SPIM3_S_BASE = 0x5000B000;
    constexpr uint32_t SPIS3_S_BASE = 0x5000B000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x10 - Start SPI transaction
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x14 - Stop SPI transaction
        volatile uint32_t TASKS_SUSPEND;  ///< Offset: 0x1C - Suspend SPI transaction
        volatile uint32_t TASKS_RESUME;  ///< Offset: 0x20 - Resume SPI transaction
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x90 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x94 - Subscribe configuration for task STOP
        volatile uint32_t SUBSCRIBE_SUSPEND;  ///< Offset: 0x9C - Subscribe configuration for task SUSPEND
        volatile uint32_t SUBSCRIBE_RESUME;  ///< Offset: 0xA0 - Subscribe configuration for task RESUME
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - SPI transaction has stopped
        volatile uint32_t EVENTS_ENDRX;  ///< Offset: 0x110 - End of RXD buffer reached
        volatile uint32_t EVENTS_END;  ///< Offset: 0x118 - End of RXD buffer and TXD buffer reached
        volatile uint32_t EVENTS_ENDTX;  ///< Offset: 0x120 - End of TXD buffer reached
        volatile uint32_t EVENTS_STARTED;  ///< Offset: 0x14C - Transaction started
        volatile uint32_t PUBLISH_STOPPED;  ///< Offset: 0x184 - Publish configuration for event STOPPED
        volatile uint32_t PUBLISH_ENDRX;  ///< Offset: 0x190 - Publish configuration for event ENDRX
        volatile uint32_t PUBLISH_END;  ///< Offset: 0x198 - Publish configuration for event END
        volatile uint32_t PUBLISH_ENDTX;  ///< Offset: 0x1A0 - Publish configuration for event ENDTX
        volatile uint32_t PUBLISH_STARTED;  ///< Offset: 0x1CC - Publish configuration for event STARTED
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable SPIM
        volatile uint32_t SCK;  ///< Offset: 0x00 - Pin select for SCK
        volatile uint32_t MOSI;  ///< Offset: 0x04 - Pin select for MOSI signal
        volatile uint32_t MISO;  ///< Offset: 0x08 - Pin select for MISO signal
        volatile uint32_t FREQUENCY;  ///< Offset: 0x524 - SPI frequency. Accuracy depends on the HFCLK source selected.
        volatile uint32_t PTR;  ///< Offset: 0x00 - Data pointer
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Maximum number of bytes in transmit buffer
        volatile uint32_t AMOUNT;  ///< Offset: 0x08 - Number of bytes transferred in the last transaction
        volatile uint32_t LIST;  ///< Offset: 0x0C - EasyDMA list type
        volatile uint32_t CONFIG;  ///< Offset: 0x554 - Configuration register
        volatile uint32_t ORC;  ///< Offset: 0x5C0 - Over-read character. Character clocked out in case an...
    };

    /// Peripheral instances
    inline Registers* SPIM0_NS = reinterpret_cast<Registers*>(SPIM0_NS_BASE);
    inline Registers* SPIS0_NS = reinterpret_cast<Registers*>(SPIS0_NS_BASE);
    inline Registers* SPIM0_S = reinterpret_cast<Registers*>(SPIM0_S_BASE);
    inline Registers* SPIS0_S = reinterpret_cast<Registers*>(SPIS0_S_BASE);
    inline Registers* SPIM1_NS = reinterpret_cast<Registers*>(SPIM1_NS_BASE);
    inline Registers* SPIS1_NS = reinterpret_cast<Registers*>(SPIS1_NS_BASE);
    inline Registers* SPIM1_S = reinterpret_cast<Registers*>(SPIM1_S_BASE);
    inline Registers* SPIS1_S = reinterpret_cast<Registers*>(SPIS1_S_BASE);
    inline Registers* SPIM2_NS = reinterpret_cast<Registers*>(SPIM2_NS_BASE);
    inline Registers* SPIS2_NS = reinterpret_cast<Registers*>(SPIS2_NS_BASE);
    inline Registers* SPIM2_S = reinterpret_cast<Registers*>(SPIM2_S_BASE);
    inline Registers* SPIS2_S = reinterpret_cast<Registers*>(SPIS2_S_BASE);
    inline Registers* SPIM3_NS = reinterpret_cast<Registers*>(SPIM3_NS_BASE);
    inline Registers* SPIS3_NS = reinterpret_cast<Registers*>(SPIS3_NS_BASE);
    inline Registers* SPIM3_S = reinterpret_cast<Registers*>(SPIM3_S_BASE);
    inline Registers* SPIS3_S = reinterpret_cast<Registers*>(SPIS3_S_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start SPI transaction
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop SPI transaction
    }

    /// TASKS_SUSPEND Register bits
    namespace tasks_suspend_bits {
        constexpr uint32_t TASKS_SUSPEND = (1U << 0);  ///< Suspend SPI transaction
    }

    /// TASKS_RESUME Register bits
    namespace tasks_resume_bits {
        constexpr uint32_t TASKS_RESUME = (1U << 0);  ///< Resume SPI transaction
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_SUSPEND Register bits
    namespace subscribe_suspend_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task SUSPEND will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_RESUME Register bits
    namespace subscribe_resume_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task RESUME will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< SPI transaction has stopped
    }

    /// EVENTS_ENDRX Register bits
    namespace events_endrx_bits {
        constexpr uint32_t EVENTS_ENDRX = (1U << 0);  ///< End of RXD buffer reached
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< End of RXD buffer and TXD buffer reached
    }

    /// EVENTS_ENDTX Register bits
    namespace events_endtx_bits {
        constexpr uint32_t EVENTS_ENDTX = (1U << 0);  ///< End of TXD buffer reached
    }

    /// EVENTS_STARTED Register bits
    namespace events_started_bits {
        constexpr uint32_t EVENTS_STARTED = (1U << 0);  ///< Transaction started
    }

    /// PUBLISH_STOPPED Register bits
    namespace publish_stopped_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event STOPPED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ENDRX Register bits
    namespace publish_endrx_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event ENDRX will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_END Register bits
    namespace publish_end_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event END will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ENDTX Register bits
    namespace publish_endtx_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event ENDTX will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_STARTED Register bits
    namespace publish_started_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event STARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t END_START = (1U << 17);  ///< Shortcut between event END and task START
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t ENDRX = (1U << 4);  ///< Write '1' to enable interrupt for event ENDRX
        constexpr uint32_t END = (1U << 6);  ///< Write '1' to enable interrupt for event END
        constexpr uint32_t ENDTX = (1U << 8);  ///< Write '1' to enable interrupt for event ENDTX
        constexpr uint32_t STARTED = (1U << 19);  ///< Write '1' to enable interrupt for event STARTED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t ENDRX = (1U << 4);  ///< Write '1' to disable interrupt for event ENDRX
        constexpr uint32_t END = (1U << 6);  ///< Write '1' to disable interrupt for event END
        constexpr uint32_t ENDTX = (1U << 8);  ///< Write '1' to disable interrupt for event ENDTX
        constexpr uint32_t STARTED = (1U << 19);  ///< Write '1' to disable interrupt for event STARTED
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (4 << 0);  ///< Enable or disable SPIM
    }

    /// SCK Register bits
    namespace sck_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// MOSI Register bits
    namespace mosi_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// MISO Register bits
    namespace miso_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (32 << 0);  ///< SPI master data rate
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Data pointer
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t MAXCNT = (13 << 0);  ///< Maximum number of bytes in transmit buffer
    }

    /// AMOUNT Register bits
    namespace amount_bits {
        constexpr uint32_t AMOUNT = (13 << 0);  ///< Number of bytes transferred in the last transaction
    }

    /// LIST Register bits
    namespace list_bits {
        constexpr uint32_t LIST = (2 << 0);  ///< List type
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t ORDER = (1U << 0);  ///< Bit order
        constexpr uint32_t CPHA = (1U << 1);  ///< Serial clock (SCK) phase
        constexpr uint32_t CPOL = (1U << 2);  ///< Serial clock (SCK) polarity
    }

    /// ORC Register bits
    namespace orc_bits {
        constexpr uint32_t ORC = (8 << 0);  ///< Over-read character. Character clocked out in case an over-read of the TXD buffer.
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t TWIM0_NS_BASE = 0x40008000;
    constexpr uint32_t TWIS0_NS_BASE = 0x40008000;
    constexpr uint32_t TWIM0_S_BASE = 0x50008000;
    constexpr uint32_t TWIS0_S_BASE = 0x50008000;
    constexpr uint32_t TWIM1_NS_BASE = 0x40009000;
    constexpr uint32_t TWIS1_NS_BASE = 0x40009000;
    constexpr uint32_t TWIM1_S_BASE = 0x50009000;
    constexpr uint32_t TWIS1_S_BASE = 0x50009000;
    constexpr uint32_t TWIM2_NS_BASE = 0x4000A000;
    constexpr uint32_t TWIS2_NS_BASE = 0x4000A000;
    constexpr uint32_t TWIM2_S_BASE = 0x5000A000;
    constexpr uint32_t TWIS2_S_BASE = 0x5000A000;
    constexpr uint32_t TWIM3_NS_BASE = 0x4000B000;
    constexpr uint32_t TWIS3_NS_BASE = 0x4000B000;
    constexpr uint32_t TWIM3_S_BASE = 0x5000B000;
    constexpr uint32_t TWIS3_S_BASE = 0x5000B000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTRX;  ///< Offset: 0x00 - Start TWI receive sequence
        volatile uint32_t TASKS_STARTTX;  ///< Offset: 0x08 - Start TWI transmit sequence
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x14 - Stop TWI transaction. Must be issued while the TWI...
        volatile uint32_t TASKS_SUSPEND;  ///< Offset: 0x1C - Suspend TWI transaction
        volatile uint32_t TASKS_RESUME;  ///< Offset: 0x20 - Resume TWI transaction
        volatile uint32_t SUBSCRIBE_STARTRX;  ///< Offset: 0x80 - Subscribe configuration for task STARTRX
        volatile uint32_t SUBSCRIBE_STARTTX;  ///< Offset: 0x88 - Subscribe configuration for task STARTTX
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x94 - Subscribe configuration for task STOP
        volatile uint32_t SUBSCRIBE_SUSPEND;  ///< Offset: 0x9C - Subscribe configuration for task SUSPEND
        volatile uint32_t SUBSCRIBE_RESUME;  ///< Offset: 0xA0 - Subscribe configuration for task RESUME
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - TWI stopped
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x124 - TWI error
        volatile uint32_t EVENTS_SUSPENDED;  ///< Offset: 0x148 - SUSPEND task has been issued, TWI traffic is now suspended.
        volatile uint32_t EVENTS_RXSTARTED;  ///< Offset: 0x14C - Receive sequence started
        volatile uint32_t EVENTS_TXSTARTED;  ///< Offset: 0x150 - Transmit sequence started
        volatile uint32_t EVENTS_LASTRX;  ///< Offset: 0x15C - Byte boundary, starting to receive the last byte
        volatile uint32_t EVENTS_LASTTX;  ///< Offset: 0x160 - Byte boundary, starting to transmit the last byte
        volatile uint32_t PUBLISH_STOPPED;  ///< Offset: 0x184 - Publish configuration for event STOPPED
        volatile uint32_t PUBLISH_ERROR;  ///< Offset: 0x1A4 - Publish configuration for event ERROR
        volatile uint32_t PUBLISH_SUSPENDED;  ///< Offset: 0x1C8 - Publish configuration for event SUSPENDED
        volatile uint32_t PUBLISH_RXSTARTED;  ///< Offset: 0x1CC - Publish configuration for event RXSTARTED
        volatile uint32_t PUBLISH_TXSTARTED;  ///< Offset: 0x1D0 - Publish configuration for event TXSTARTED
        volatile uint32_t PUBLISH_LASTRX;  ///< Offset: 0x1DC - Publish configuration for event LASTRX
        volatile uint32_t PUBLISH_LASTTX;  ///< Offset: 0x1E0 - Publish configuration for event LASTTX
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ERRORSRC;  ///< Offset: 0x4C4 - Error source
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable TWIM
        volatile uint32_t SCL;  ///< Offset: 0x00 - Pin select for SCL signal
        volatile uint32_t SDA;  ///< Offset: 0x04 - Pin select for SDA signal
        volatile uint32_t FREQUENCY;  ///< Offset: 0x524 - TWI frequency. Accuracy depends on the HFCLK source selected.
        volatile uint32_t PTR;  ///< Offset: 0x00 - Data pointer
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Maximum number of bytes in transmit buffer
        volatile uint32_t AMOUNT;  ///< Offset: 0x08 - Number of bytes transferred in the last transaction
        volatile uint32_t LIST;  ///< Offset: 0x0C - EasyDMA list type
        volatile uint32_t ADDRESS;  ///< Offset: 0x588 - Address used in the TWI transfer
    };

    /// Peripheral instances
    inline Registers* TWIM0_NS = reinterpret_cast<Registers*>(TWIM0_NS_BASE);
    inline Registers* TWIS0_NS = reinterpret_cast<Registers*>(TWIS0_NS_BASE);
    inline Registers* TWIM0_S = reinterpret_cast<Registers*>(TWIM0_S_BASE);
    inline Registers* TWIS0_S = reinterpret_cast<Registers*>(TWIS0_S_BASE);
    inline Registers* TWIM1_NS = reinterpret_cast<Registers*>(TWIM1_NS_BASE);
    inline Registers* TWIS1_NS = reinterpret_cast<Registers*>(TWIS1_NS_BASE);
    inline Registers* TWIM1_S = reinterpret_cast<Registers*>(TWIM1_S_BASE);
    inline Registers* TWIS1_S = reinterpret_cast<Registers*>(TWIS1_S_BASE);
    inline Registers* TWIM2_NS = reinterpret_cast<Registers*>(TWIM2_NS_BASE);
    inline Registers* TWIS2_NS = reinterpret_cast<Registers*>(TWIS2_NS_BASE);
    inline Registers* TWIM2_S = reinterpret_cast<Registers*>(TWIM2_S_BASE);
    inline Registers* TWIS2_S = reinterpret_cast<Registers*>(TWIS2_S_BASE);
    inline Registers* TWIM3_NS = reinterpret_cast<Registers*>(TWIM3_NS_BASE);
    inline Registers* TWIS3_NS = reinterpret_cast<Registers*>(TWIS3_NS_BASE);
    inline Registers* TWIM3_S = reinterpret_cast<Registers*>(TWIM3_S_BASE);
    inline Registers* TWIS3_S = reinterpret_cast<Registers*>(TWIS3_S_BASE);

    // Bit definitions
    /// TASKS_STARTRX Register bits
    namespace tasks_startrx_bits {
        constexpr uint32_t TASKS_STARTRX = (1U << 0);  ///< Start TWI receive sequence
    }

    /// TASKS_STARTTX Register bits
    namespace tasks_starttx_bits {
        constexpr uint32_t TASKS_STARTTX = (1U << 0);  ///< Start TWI transmit sequence
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop TWI transaction. Must be issued while the TWI master is not suspended.
    }

    /// TASKS_SUSPEND Register bits
    namespace tasks_suspend_bits {
        constexpr uint32_t TASKS_SUSPEND = (1U << 0);  ///< Suspend TWI transaction
    }

    /// TASKS_RESUME Register bits
    namespace tasks_resume_bits {
        constexpr uint32_t TASKS_RESUME = (1U << 0);  ///< Resume TWI transaction
    }

    /// SUBSCRIBE_STARTRX Register bits
    namespace subscribe_startrx_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STARTRX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STARTTX Register bits
    namespace subscribe_starttx_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STARTTX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_SUSPEND Register bits
    namespace subscribe_suspend_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task SUSPEND will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_RESUME Register bits
    namespace subscribe_resume_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task RESUME will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< TWI stopped
    }

    /// EVENTS_ERROR Register bits
    namespace events_error_bits {
        constexpr uint32_t EVENTS_ERROR = (1U << 0);  ///< TWI error
    }

    /// EVENTS_SUSPENDED Register bits
    namespace events_suspended_bits {
        constexpr uint32_t EVENTS_SUSPENDED = (1U << 0);  ///< SUSPEND task has been issued, TWI traffic is now suspended.
    }

    /// EVENTS_RXSTARTED Register bits
    namespace events_rxstarted_bits {
        constexpr uint32_t EVENTS_RXSTARTED = (1U << 0);  ///< Receive sequence started
    }

    /// EVENTS_TXSTARTED Register bits
    namespace events_txstarted_bits {
        constexpr uint32_t EVENTS_TXSTARTED = (1U << 0);  ///< Transmit sequence started
    }

    /// EVENTS_LASTRX Register bits
    namespace events_lastrx_bits {
        constexpr uint32_t EVENTS_LASTRX = (1U << 0);  ///< Byte boundary, starting to receive the last byte
    }

    /// EVENTS_LASTTX Register bits
    namespace events_lasttx_bits {
        constexpr uint32_t EVENTS_LASTTX = (1U << 0);  ///< Byte boundary, starting to transmit the last byte
    }

    /// PUBLISH_STOPPED Register bits
    namespace publish_stopped_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event STOPPED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ERROR Register bits
    namespace publish_error_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event ERROR will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_SUSPENDED Register bits
    namespace publish_suspended_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event SUSPENDED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_RXSTARTED Register bits
    namespace publish_rxstarted_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event RXSTARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_TXSTARTED Register bits
    namespace publish_txstarted_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event TXSTARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_LASTRX Register bits
    namespace publish_lastrx_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event LASTRX will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_LASTTX Register bits
    namespace publish_lasttx_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event LASTTX will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t LASTTX_STARTRX = (1U << 7);  ///< Shortcut between event LASTTX and task STARTRX
        constexpr uint32_t LASTTX_SUSPEND = (1U << 8);  ///< Shortcut between event LASTTX and task SUSPEND
        constexpr uint32_t LASTTX_STOP = (1U << 9);  ///< Shortcut between event LASTTX and task STOP
        constexpr uint32_t LASTRX_STARTTX = (1U << 10);  ///< Shortcut between event LASTRX and task STARTTX
        constexpr uint32_t LASTRX_SUSPEND = (1U << 11);  ///< Shortcut between event LASTRX and task SUSPEND
        constexpr uint32_t LASTRX_STOP = (1U << 12);  ///< Shortcut between event LASTRX and task STOP
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Enable or disable interrupt for event STOPPED
        constexpr uint32_t ERROR = (1U << 9);  ///< Enable or disable interrupt for event ERROR
        constexpr uint32_t SUSPENDED = (1U << 18);  ///< Enable or disable interrupt for event SUSPENDED
        constexpr uint32_t RXSTARTED = (1U << 19);  ///< Enable or disable interrupt for event RXSTARTED
        constexpr uint32_t TXSTARTED = (1U << 20);  ///< Enable or disable interrupt for event TXSTARTED
        constexpr uint32_t LASTRX = (1U << 23);  ///< Enable or disable interrupt for event LASTRX
        constexpr uint32_t LASTTX = (1U << 24);  ///< Enable or disable interrupt for event LASTTX
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to enable interrupt for event ERROR
        constexpr uint32_t SUSPENDED = (1U << 18);  ///< Write '1' to enable interrupt for event SUSPENDED
        constexpr uint32_t RXSTARTED = (1U << 19);  ///< Write '1' to enable interrupt for event RXSTARTED
        constexpr uint32_t TXSTARTED = (1U << 20);  ///< Write '1' to enable interrupt for event TXSTARTED
        constexpr uint32_t LASTRX = (1U << 23);  ///< Write '1' to enable interrupt for event LASTRX
        constexpr uint32_t LASTTX = (1U << 24);  ///< Write '1' to enable interrupt for event LASTTX
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to disable interrupt for event ERROR
        constexpr uint32_t SUSPENDED = (1U << 18);  ///< Write '1' to disable interrupt for event SUSPENDED
        constexpr uint32_t RXSTARTED = (1U << 19);  ///< Write '1' to disable interrupt for event RXSTARTED
        constexpr uint32_t TXSTARTED = (1U << 20);  ///< Write '1' to disable interrupt for event TXSTARTED
        constexpr uint32_t LASTRX = (1U << 23);  ///< Write '1' to disable interrupt for event LASTRX
        constexpr uint32_t LASTTX = (1U << 24);  ///< Write '1' to disable interrupt for event LASTTX
    }

    /// ERRORSRC Register bits
    namespace errorsrc_bits {
        constexpr uint32_t OVERRUN = (1U << 0);  ///< Overrun error
        constexpr uint32_t ANACK = (1U << 1);  ///< NACK received after sending the address (write '1' to clear)
        constexpr uint32_t DNACK = (1U << 2);  ///< NACK received after sending a data byte (write '1' to clear)
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (4 << 0);  ///< Enable or disable TWIM
    }

    /// SCL Register bits
    namespace scl_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// SDA Register bits
    namespace sda_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// FREQUENCY Register bits
    namespace frequency_bits {
        constexpr uint32_t FREQUENCY = (32 << 0);  ///< TWI master clock frequency
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Data pointer
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t MAXCNT = (13 << 0);  ///< Maximum number of bytes in transmit buffer
    }

    /// AMOUNT Register bits
    namespace amount_bits {
        constexpr uint32_t AMOUNT = (13 << 0);  ///< Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte.
    }

    /// LIST Register bits
    namespace list_bits {
        constexpr uint32_t LIST = (2 << 0);  ///< List type
    }

    /// ADDRESS Register bits
    namespace address_bits {
        constexpr uint32_t ADDRESS = (7 << 0);  ///< Address used in the TWI transfer
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UARTE0_NS_BASE = 0x40008000;
    constexpr uint32_t UARTE0_S_BASE = 0x50008000;
    constexpr uint32_t UARTE1_NS_BASE = 0x40009000;
    constexpr uint32_t UARTE1_S_BASE = 0x50009000;
    constexpr uint32_t UARTE2_NS_BASE = 0x4000A000;
    constexpr uint32_t UARTE2_S_BASE = 0x5000A000;
    constexpr uint32_t UARTE3_NS_BASE = 0x4000B000;
    constexpr uint32_t UARTE3_S_BASE = 0x5000B000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t TASKS_STARTRX;  ///< Offset: 0x00 - Start UART receiver
        volatile uint32_t TASKS_STOPRX;  ///< Offset: 0x04 - Stop UART receiver
        volatile uint32_t TASKS_STARTTX;  ///< Offset: 0x08 - Start UART transmitter
        volatile uint32_t TASKS_STOPTX;  ///< Offset: 0x0C - Stop UART transmitter
        volatile uint32_t TASKS_FLUSHRX;  ///< Offset: 0x2C - Flush RX FIFO into RX buffer
        volatile uint32_t SUBSCRIBE_STARTRX;  ///< Offset: 0x80 - Subscribe configuration for task STARTRX
        volatile uint32_t SUBSCRIBE_STOPRX;  ///< Offset: 0x84 - Subscribe configuration for task STOPRX
        volatile uint32_t SUBSCRIBE_STARTTX;  ///< Offset: 0x88 - Subscribe configuration for task STARTTX
        volatile uint32_t SUBSCRIBE_STOPTX;  ///< Offset: 0x8C - Subscribe configuration for task STOPTX
        volatile uint32_t SUBSCRIBE_FLUSHRX;  ///< Offset: 0xAC - Subscribe configuration for task FLUSHRX
        volatile uint32_t EVENTS_CTS;  ///< Offset: 0x100 - CTS is activated (set low). Clear To Send.
        volatile uint32_t EVENTS_NCTS;  ///< Offset: 0x104 - CTS is deactivated (set high). Not Clear To Send.
        volatile uint32_t EVENTS_RXDRDY;  ///< Offset: 0x108 - Data received in RXD (but potentially not yet...
        volatile uint32_t EVENTS_ENDRX;  ///< Offset: 0x110 - Receive buffer is filled up
        volatile uint32_t EVENTS_TXDRDY;  ///< Offset: 0x11C - Data sent from TXD
        volatile uint32_t EVENTS_ENDTX;  ///< Offset: 0x120 - Last TX byte transmitted
        volatile uint32_t EVENTS_ERROR;  ///< Offset: 0x124 - Error detected
        volatile uint32_t EVENTS_RXTO;  ///< Offset: 0x144 - Receiver timeout
        volatile uint32_t EVENTS_RXSTARTED;  ///< Offset: 0x14C - UART receiver has started
        volatile uint32_t EVENTS_TXSTARTED;  ///< Offset: 0x150 - UART transmitter has started
        volatile uint32_t EVENTS_TXSTOPPED;  ///< Offset: 0x158 - Transmitter stopped
        volatile uint32_t PUBLISH_CTS;  ///< Offset: 0x180 - Publish configuration for event CTS
        volatile uint32_t PUBLISH_NCTS;  ///< Offset: 0x184 - Publish configuration for event NCTS
        volatile uint32_t PUBLISH_RXDRDY;  ///< Offset: 0x188 - Publish configuration for event RXDRDY
        volatile uint32_t PUBLISH_ENDRX;  ///< Offset: 0x190 - Publish configuration for event ENDRX
        volatile uint32_t PUBLISH_TXDRDY;  ///< Offset: 0x19C - Publish configuration for event TXDRDY
        volatile uint32_t PUBLISH_ENDTX;  ///< Offset: 0x1A0 - Publish configuration for event ENDTX
        volatile uint32_t PUBLISH_ERROR;  ///< Offset: 0x1A4 - Publish configuration for event ERROR
        volatile uint32_t PUBLISH_RXTO;  ///< Offset: 0x1C4 - Publish configuration for event RXTO
        volatile uint32_t PUBLISH_RXSTARTED;  ///< Offset: 0x1CC - Publish configuration for event RXSTARTED
        volatile uint32_t PUBLISH_TXSTARTED;  ///< Offset: 0x1D0 - Publish configuration for event TXSTARTED
        volatile uint32_t PUBLISH_TXSTOPPED;  ///< Offset: 0x1D8 - Publish configuration for event TXSTOPPED
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ERRORSRC;  ///< Offset: 0x480 - Error source Note : this register is read / write one to clear.
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable UART
        volatile uint32_t RTS;  ///< Offset: 0x00 - Pin select for RTS signal
        volatile uint32_t TXD;  ///< Offset: 0x04 - Pin select for TXD signal
        volatile uint32_t CTS;  ///< Offset: 0x08 - Pin select for CTS signal
        volatile uint32_t RXD;  ///< Offset: 0x0C - Pin select for RXD signal
        volatile uint32_t BAUDRATE;  ///< Offset: 0x524 - Baud rate. Accuracy depends on the HFCLK source selected.
        volatile uint32_t PTR;  ///< Offset: 0x00 - Data pointer
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Maximum number of bytes in transmit buffer
        volatile uint32_t AMOUNT;  ///< Offset: 0x08 - Number of bytes transferred in the last transaction
        volatile uint32_t CONFIG;  ///< Offset: 0x56C - Configuration of parity and hardware flow control
    };

    /// Peripheral instances
    inline Registers* UARTE0_NS = reinterpret_cast<Registers*>(UARTE0_NS_BASE);
    inline Registers* UARTE0_S = reinterpret_cast<Registers*>(UARTE0_S_BASE);
    inline Registers* UARTE1_NS = reinterpret_cast<Registers*>(UARTE1_NS_BASE);
    inline Registers* UARTE1_S = reinterpret_cast<Registers*>(UARTE1_S_BASE);
    inline Registers* UARTE2_NS = reinterpret_cast<Registers*>(UARTE2_NS_BASE);
    inline Registers* UARTE2_S = reinterpret_cast<Registers*>(UARTE2_S_BASE);
    inline Registers* UARTE3_NS = reinterpret_cast<Registers*>(UARTE3_NS_BASE);
    inline Registers* UARTE3_S = reinterpret_cast<Registers*>(UARTE3_S_BASE);

    // Bit definitions
    /// TASKS_STARTRX Register bits
    namespace tasks_startrx_bits {
        constexpr uint32_t TASKS_STARTRX = (1U << 0);  ///< Start UART receiver
    }

    /// TASKS_STOPRX Register bits
    namespace tasks_stoprx_bits {
        constexpr uint32_t TASKS_STOPRX = (1U << 0);  ///< Stop UART receiver
    }

    /// TASKS_STARTTX Register bits
    namespace tasks_starttx_bits {
        constexpr uint32_t TASKS_STARTTX = (1U << 0);  ///< Start UART transmitter
    }

    /// TASKS_STOPTX Register bits
    namespace tasks_stoptx_bits {
        constexpr uint32_t TASKS_STOPTX = (1U << 0);  ///< Stop UART transmitter
    }

    /// TASKS_FLUSHRX Register bits
    namespace tasks_flushrx_bits {
        constexpr uint32_t TASKS_FLUSHRX = (1U << 0);  ///< Flush RX FIFO into RX buffer
    }

    /// SUBSCRIBE_STARTRX Register bits
    namespace subscribe_startrx_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STARTRX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOPRX Register bits
    namespace subscribe_stoprx_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STOPRX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STARTTX Register bits
    namespace subscribe_starttx_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STARTTX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOPTX Register bits
    namespace subscribe_stoptx_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STOPTX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_FLUSHRX Register bits
    namespace subscribe_flushrx_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task FLUSHRX will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_CTS Register bits
    namespace events_cts_bits {
        constexpr uint32_t EVENTS_CTS = (1U << 0);  ///< CTS is activated (set low). Clear To Send.
    }

    /// EVENTS_NCTS Register bits
    namespace events_ncts_bits {
        constexpr uint32_t EVENTS_NCTS = (1U << 0);  ///< CTS is deactivated (set high). Not Clear To Send.
    }

    /// EVENTS_RXDRDY Register bits
    namespace events_rxdrdy_bits {
        constexpr uint32_t EVENTS_RXDRDY = (1U << 0);  ///< Data received in RXD (but potentially not yet transferred to Data RAM)
    }

    /// EVENTS_ENDRX Register bits
    namespace events_endrx_bits {
        constexpr uint32_t EVENTS_ENDRX = (1U << 0);  ///< Receive buffer is filled up
    }

    /// EVENTS_TXDRDY Register bits
    namespace events_txdrdy_bits {
        constexpr uint32_t EVENTS_TXDRDY = (1U << 0);  ///< Data sent from TXD
    }

    /// EVENTS_ENDTX Register bits
    namespace events_endtx_bits {
        constexpr uint32_t EVENTS_ENDTX = (1U << 0);  ///< Last TX byte transmitted
    }

    /// EVENTS_ERROR Register bits
    namespace events_error_bits {
        constexpr uint32_t EVENTS_ERROR = (1U << 0);  ///< Error detected
    }

    /// EVENTS_RXTO Register bits
    namespace events_rxto_bits {
        constexpr uint32_t EVENTS_RXTO = (1U << 0);  ///< Receiver timeout
    }

    /// EVENTS_RXSTARTED Register bits
    namespace events_rxstarted_bits {
        constexpr uint32_t EVENTS_RXSTARTED = (1U << 0);  ///< UART receiver has started
    }

    /// EVENTS_TXSTARTED Register bits
    namespace events_txstarted_bits {
        constexpr uint32_t EVENTS_TXSTARTED = (1U << 0);  ///< UART transmitter has started
    }

    /// EVENTS_TXSTOPPED Register bits
    namespace events_txstopped_bits {
        constexpr uint32_t EVENTS_TXSTOPPED = (1U << 0);  ///< Transmitter stopped
    }

    /// PUBLISH_CTS Register bits
    namespace publish_cts_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event CTS will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_NCTS Register bits
    namespace publish_ncts_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event NCTS will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_RXDRDY Register bits
    namespace publish_rxdrdy_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event RXDRDY will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ENDRX Register bits
    namespace publish_endrx_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event ENDRX will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_TXDRDY Register bits
    namespace publish_txdrdy_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event TXDRDY will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ENDTX Register bits
    namespace publish_endtx_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event ENDTX will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_ERROR Register bits
    namespace publish_error_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event ERROR will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_RXTO Register bits
    namespace publish_rxto_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event RXTO will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_RXSTARTED Register bits
    namespace publish_rxstarted_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event RXSTARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_TXSTARTED Register bits
    namespace publish_txstarted_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event TXSTARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_TXSTOPPED Register bits
    namespace publish_txstopped_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event TXSTOPPED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t ENDRX_STARTRX = (1U << 5);  ///< Shortcut between event ENDRX and task STARTRX
        constexpr uint32_t ENDRX_STOPRX = (1U << 6);  ///< Shortcut between event ENDRX and task STOPRX
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t CTS = (1U << 0);  ///< Enable or disable interrupt for event CTS
        constexpr uint32_t NCTS = (1U << 1);  ///< Enable or disable interrupt for event NCTS
        constexpr uint32_t RXDRDY = (1U << 2);  ///< Enable or disable interrupt for event RXDRDY
        constexpr uint32_t ENDRX = (1U << 4);  ///< Enable or disable interrupt for event ENDRX
        constexpr uint32_t TXDRDY = (1U << 7);  ///< Enable or disable interrupt for event TXDRDY
        constexpr uint32_t ENDTX = (1U << 8);  ///< Enable or disable interrupt for event ENDTX
        constexpr uint32_t ERROR = (1U << 9);  ///< Enable or disable interrupt for event ERROR
        constexpr uint32_t RXTO = (1U << 17);  ///< Enable or disable interrupt for event RXTO
        constexpr uint32_t RXSTARTED = (1U << 19);  ///< Enable or disable interrupt for event RXSTARTED
        constexpr uint32_t TXSTARTED = (1U << 20);  ///< Enable or disable interrupt for event TXSTARTED
        constexpr uint32_t TXSTOPPED = (1U << 22);  ///< Enable or disable interrupt for event TXSTOPPED
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t CTS = (1U << 0);  ///< Write '1' to enable interrupt for event CTS
        constexpr uint32_t NCTS = (1U << 1);  ///< Write '1' to enable interrupt for event NCTS
        constexpr uint32_t RXDRDY = (1U << 2);  ///< Write '1' to enable interrupt for event RXDRDY
        constexpr uint32_t ENDRX = (1U << 4);  ///< Write '1' to enable interrupt for event ENDRX
        constexpr uint32_t TXDRDY = (1U << 7);  ///< Write '1' to enable interrupt for event TXDRDY
        constexpr uint32_t ENDTX = (1U << 8);  ///< Write '1' to enable interrupt for event ENDTX
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to enable interrupt for event ERROR
        constexpr uint32_t RXTO = (1U << 17);  ///< Write '1' to enable interrupt for event RXTO
        constexpr uint32_t RXSTARTED = (1U << 19);  ///< Write '1' to enable interrupt for event RXSTARTED
        constexpr uint32_t TXSTARTED = (1U << 20);  ///< Write '1' to enable interrupt for event TXSTARTED
        constexpr uint32_t TXSTOPPED = (1U << 22);  ///< Write '1' to enable interrupt for event TXSTOPPED
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t CTS = (1U << 0);  ///< Write '1' to disable interrupt for event CTS
        constexpr uint32_t NCTS = (1U << 1);  ///< Write '1' to disable interrupt for event NCTS
        constexpr uint32_t RXDRDY = (1U << 2);  ///< Write '1' to disable interrupt for event RXDRDY
        constexpr uint32_t ENDRX = (1U << 4);  ///< Write '1' to disable interrupt for event ENDRX
        constexpr uint32_t TXDRDY = (1U << 7);  ///< Write '1' to disable interrupt for event TXDRDY
        constexpr uint32_t ENDTX = (1U << 8);  ///< Write '1' to disable interrupt for event ENDTX
        constexpr uint32_t ERROR = (1U << 9);  ///< Write '1' to disable interrupt for event ERROR
        constexpr uint32_t RXTO = (1U << 17);  ///< Write '1' to disable interrupt for event RXTO
        constexpr uint32_t RXSTARTED = (1U << 19);  ///< Write '1' to disable interrupt for event RXSTARTED
        constexpr uint32_t TXSTARTED = (1U << 20);  ///< Write '1' to disable interrupt for event TXSTARTED
        constexpr uint32_t TXSTOPPED = (1U << 22);  ///< Write '1' to disable interrupt for event TXSTOPPED
    }

    /// ERRORSRC Register bits
    namespace errorsrc_bits {
        constexpr uint32_t OVERRUN = (1U << 0);  ///< Overrun error
        constexpr uint32_t PARITY = (1U << 1);  ///< Parity error
        constexpr uint32_t FRAMING = (1U << 2);  ///< Framing error occurred
        constexpr uint32_t BREAK_ = (1U << 3);  ///< Break condition (renamed from BREAK_)
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (4 << 0);  ///< Enable or disable UARTE
    }

    /// RTS Register bits
    namespace rts_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// TXD Register bits
    namespace txd_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// CTS Register bits
    namespace cts_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// RXD Register bits
    namespace rxd_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// BAUDRATE Register bits
    namespace baudrate_bits {
        constexpr uint32_t BAUDRATE = (32 << 0);  ///< Baud rate
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Data pointer
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t MAXCNT = (13 << 0);  ///< Maximum number of bytes in transmit buffer
    }

    /// AMOUNT Register bits
    namespace amount_bits {
        constexpr uint32_t AMOUNT = (13 << 0);  ///< Number of bytes transferred in the last transaction
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t HWFC = (1U << 0);  ///< Hardware flow control
        constexpr uint32_t PARITY = (3 << 1);  ///< Parity
        constexpr uint32_t STOP = (1U << 4);  ///< Stop bits
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOTE0_S_BASE = 0x5000D000;
    constexpr uint32_t GPIOTE1_NS_BASE = 0x40031000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t TASKS_OUT__;  ///< Offset: 0x00 - Description collection: Task for writing to pin... (renamed from TASKS_OUT__)
        volatile uint32_t TASKS_SET__;  ///< Offset: 0x30 - Description collection: Task for writing to pin... (renamed from TASKS_SET__)
        volatile uint32_t TASKS_CLR__;  ///< Offset: 0x60 - Description collection: Task for writing to pin... (renamed from TASKS_CLR__)
        volatile uint32_t SUBSCRIBE_OUT__;  ///< Offset: 0x80 - Description collection: Subscribe configuration for task OUT[n] (renamed from SUBSCRIBE_OUT__)
        volatile uint32_t SUBSCRIBE_SET__;  ///< Offset: 0xB0 - Description collection: Subscribe configuration for task SET[n] (renamed from SUBSCRIBE_SET__)
        volatile uint32_t SUBSCRIBE_CLR__;  ///< Offset: 0xE0 - Description collection: Subscribe configuration for task CLR[n] (renamed from SUBSCRIBE_CLR__)
        volatile uint32_t EVENTS_IN__;  ///< Offset: 0x100 - Description collection: Event generated from pin... (renamed from EVENTS_IN__)
        volatile uint32_t EVENTS_PORT;  ///< Offset: 0x17C - Event generated from multiple input GPIO pins with SENSE...
        volatile uint32_t PUBLISH_IN__;  ///< Offset: 0x180 - Description collection: Publish configuration for event IN[n] (renamed from PUBLISH_IN__)
        volatile uint32_t PUBLISH_PORT;  ///< Offset: 0x1FC - Publish configuration for event PORT
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t CONFIG__;  ///< Offset: 0x510 - Description collection: Configuration for OUT[n], SET[n]... (renamed from CONFIG__)
    };

    /// Peripheral instances
    inline Registers* GPIOTE0_S = reinterpret_cast<Registers*>(GPIOTE0_S_BASE);
    inline Registers* GPIOTE1_NS = reinterpret_cast<Registers*>(GPIOTE1_NS_BASE);

    // Bit definitions
    /// TASKS_OUT__ Register bits
    namespace tasks_out___bits {
        constexpr uint32_t TASKS_OUT = (1U << 0);  ///< Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is configured in CONFIG[n].POLARITY.
    }

    /// TASKS_SET__ Register bits
    namespace tasks_set___bits {
        constexpr uint32_t TASKS_SET = (1U << 0);  ///< Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it high.
    }

    /// TASKS_CLR__ Register bits
    namespace tasks_clr___bits {
        constexpr uint32_t TASKS_CLR = (1U << 0);  ///< Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it low.
    }

    /// SUBSCRIBE_OUT__ Register bits
    namespace subscribe_out___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task OUT[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_SET__ Register bits
    namespace subscribe_set___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task SET[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CLR__ Register bits
    namespace subscribe_clr___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task CLR[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_IN__ Register bits
    namespace events_in___bits {
        constexpr uint32_t EVENTS_IN = (1U << 0);  ///< Event generated from pin specified in CONFIG[n].PSEL
    }

    /// EVENTS_PORT Register bits
    namespace events_port_bits {
        constexpr uint32_t EVENTS_PORT = (1U << 0);  ///< Event generated from multiple input GPIO pins with SENSE mechanism enabled
    }

    /// PUBLISH_IN__ Register bits
    namespace publish_in___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event IN[n] will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_PORT Register bits
    namespace publish_port_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event PORT will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t IN0 = (1U << 0);  ///< Write '1' to enable interrupt for event IN[0]
        constexpr uint32_t IN1 = (1U << 1);  ///< Write '1' to enable interrupt for event IN[1]
        constexpr uint32_t IN2 = (1U << 2);  ///< Write '1' to enable interrupt for event IN[2]
        constexpr uint32_t IN3 = (1U << 3);  ///< Write '1' to enable interrupt for event IN[3]
        constexpr uint32_t IN4 = (1U << 4);  ///< Write '1' to enable interrupt for event IN[4]
        constexpr uint32_t IN5 = (1U << 5);  ///< Write '1' to enable interrupt for event IN[5]
        constexpr uint32_t IN6 = (1U << 6);  ///< Write '1' to enable interrupt for event IN[6]
        constexpr uint32_t IN7 = (1U << 7);  ///< Write '1' to enable interrupt for event IN[7]
        constexpr uint32_t PORT = (1U << 31);  ///< Write '1' to enable interrupt for event PORT
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t IN0 = (1U << 0);  ///< Write '1' to disable interrupt for event IN[0]
        constexpr uint32_t IN1 = (1U << 1);  ///< Write '1' to disable interrupt for event IN[1]
        constexpr uint32_t IN2 = (1U << 2);  ///< Write '1' to disable interrupt for event IN[2]
        constexpr uint32_t IN3 = (1U << 3);  ///< Write '1' to disable interrupt for event IN[3]
        constexpr uint32_t IN4 = (1U << 4);  ///< Write '1' to disable interrupt for event IN[4]
        constexpr uint32_t IN5 = (1U << 5);  ///< Write '1' to disable interrupt for event IN[5]
        constexpr uint32_t IN6 = (1U << 6);  ///< Write '1' to disable interrupt for event IN[6]
        constexpr uint32_t IN7 = (1U << 7);  ///< Write '1' to disable interrupt for event IN[7]
        constexpr uint32_t PORT = (1U << 31);  ///< Write '1' to disable interrupt for event PORT
    }

    /// CONFIG__ Register bits
    namespace config___bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Mode
        constexpr uint32_t PSEL = (5 << 8);  ///< GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event
        constexpr uint32_t POLARITY = (2 << 16);  ///< When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event.
        constexpr uint32_t OUTINIT = (1U << 20);  ///< When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect.
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t SAADC_NS_BASE = 0x4000E000;
    constexpr uint32_t SAADC_S_BASE = 0x5000E000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start the ADC and prepare the result buffer in RAM
        volatile uint32_t TASKS_SAMPLE;  ///< Offset: 0x04 - Take one ADC sample, if scan is enabled all channels are sampled
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x08 - Stop the ADC and terminate any on-going conversion
        volatile uint32_t TASKS_CALIBRATEOFFSET;  ///< Offset: 0x0C - Starts offset auto-calibration
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x80 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_SAMPLE;  ///< Offset: 0x84 - Subscribe configuration for task SAMPLE
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x88 - Subscribe configuration for task STOP
        volatile uint32_t SUBSCRIBE_CALIBRATEOFFSET;  ///< Offset: 0x8C - Subscribe configuration for task CALIBRATEOFFSET
        volatile uint32_t EVENTS_STARTED;  ///< Offset: 0x100 - The ADC has started
        volatile uint32_t EVENTS_END;  ///< Offset: 0x104 - The ADC has filled up the Result buffer
        volatile uint32_t EVENTS_DONE;  ///< Offset: 0x108 - A conversion task has been completed. Depending on the...
        volatile uint32_t EVENTS_RESULTDONE;  ///< Offset: 0x10C - A result is ready to get transferred to RAM.
        volatile uint32_t EVENTS_CALIBRATEDONE;  ///< Offset: 0x110 - Calibration is complete
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x114 - The ADC has stopped
        volatile uint32_t LIMITH;  ///< Offset: 0x00 - Description cluster: Publish configuration for event CH[n].LIMITH
        volatile uint32_t LIMITL;  ///< Offset: 0x04 - Description cluster: Publish configuration for event CH[n].LIMITL
        volatile uint32_t PUBLISH_STARTED;  ///< Offset: 0x180 - Publish configuration for event STARTED
        volatile uint32_t PUBLISH_END;  ///< Offset: 0x184 - Publish configuration for event END
        volatile uint32_t PUBLISH_DONE;  ///< Offset: 0x188 - Publish configuration for event DONE
        volatile uint32_t PUBLISH_RESULTDONE;  ///< Offset: 0x18C - Publish configuration for event RESULTDONE
        volatile uint32_t PUBLISH_CALIBRATEDONE;  ///< Offset: 0x190 - Publish configuration for event CALIBRATEDONE
        volatile uint32_t PUBLISH_STOPPED;  ///< Offset: 0x194 - Publish configuration for event STOPPED
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t STATUS;  ///< Offset: 0x400 - Status
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable or disable ADC
        volatile uint32_t PSELP;  ///< Offset: 0x00 - Description cluster: Input positive pin selection for CH[n]
        volatile uint32_t PSELN;  ///< Offset: 0x04 - Description cluster: Input negative pin selection for CH[n]
        volatile uint32_t CONFIG;  ///< Offset: 0x08 - Description cluster: Input configuration for CH[n]
        volatile uint32_t LIMIT;  ///< Offset: 0x0C - Description cluster: High/low limits for event...
        volatile uint32_t RESOLUTION;  ///< Offset: 0x5F0 - Resolution configuration
        volatile uint32_t OVERSAMPLE;  ///< Offset: 0x5F4 - Oversampling configuration. OVERSAMPLE should not be...
        volatile uint32_t SAMPLERATE;  ///< Offset: 0x5F8 - Controls normal or continuous sample rate
        volatile uint32_t PTR;  ///< Offset: 0x00 - Data pointer
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Maximum number of buffer words to transfer
        volatile uint32_t AMOUNT;  ///< Offset: 0x08 - Number of buffer words transferred since last START
    };

    /// Peripheral instances
    inline Registers* SAADC_NS = reinterpret_cast<Registers*>(SAADC_NS_BASE);
    inline Registers* SAADC_S = reinterpret_cast<Registers*>(SAADC_S_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start the ADC and prepare the result buffer in RAM
    }

    /// TASKS_SAMPLE Register bits
    namespace tasks_sample_bits {
        constexpr uint32_t TASKS_SAMPLE = (1U << 0);  ///< Take one ADC sample, if scan is enabled all channels are sampled
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop the ADC and terminate any on-going conversion
    }

    /// TASKS_CALIBRATEOFFSET Register bits
    namespace tasks_calibrateoffset_bits {
        constexpr uint32_t TASKS_CALIBRATEOFFSET = (1U << 0);  ///< Starts offset auto-calibration
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_SAMPLE Register bits
    namespace subscribe_sample_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task SAMPLE will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CALIBRATEOFFSET Register bits
    namespace subscribe_calibrateoffset_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task CALIBRATEOFFSET will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_STARTED Register bits
    namespace events_started_bits {
        constexpr uint32_t EVENTS_STARTED = (1U << 0);  ///< The ADC has started
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< The ADC has filled up the Result buffer
    }

    /// EVENTS_DONE Register bits
    namespace events_done_bits {
        constexpr uint32_t EVENTS_DONE = (1U << 0);  ///< A conversion task has been completed. Depending on the mode, multiple conversions might be needed for a result to be transferred to RAM.
    }

    /// EVENTS_RESULTDONE Register bits
    namespace events_resultdone_bits {
        constexpr uint32_t EVENTS_RESULTDONE = (1U << 0);  ///< A result is ready to get transferred to RAM.
    }

    /// EVENTS_CALIBRATEDONE Register bits
    namespace events_calibratedone_bits {
        constexpr uint32_t EVENTS_CALIBRATEDONE = (1U << 0);  ///< Calibration is complete
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< The ADC has stopped
    }

    /// LIMITH Register bits
    namespace limith_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event CH[n].LIMITH will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// LIMITL Register bits
    namespace limitl_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event CH[n].LIMITL will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_STARTED Register bits
    namespace publish_started_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event STARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_END Register bits
    namespace publish_end_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event END will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_DONE Register bits
    namespace publish_done_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event DONE will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_RESULTDONE Register bits
    namespace publish_resultdone_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event RESULTDONE will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_CALIBRATEDONE Register bits
    namespace publish_calibratedone_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event CALIBRATEDONE will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_STOPPED Register bits
    namespace publish_stopped_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event STOPPED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Enable or disable interrupt for event STARTED
        constexpr uint32_t END = (1U << 1);  ///< Enable or disable interrupt for event END
        constexpr uint32_t DONE = (1U << 2);  ///< Enable or disable interrupt for event DONE
        constexpr uint32_t RESULTDONE = (1U << 3);  ///< Enable or disable interrupt for event RESULTDONE
        constexpr uint32_t CALIBRATEDONE = (1U << 4);  ///< Enable or disable interrupt for event CALIBRATEDONE
        constexpr uint32_t STOPPED = (1U << 5);  ///< Enable or disable interrupt for event STOPPED
        constexpr uint32_t CH0LIMITH = (1U << 6);  ///< Enable or disable interrupt for event CH0LIMITH
        constexpr uint32_t CH0LIMITL = (1U << 7);  ///< Enable or disable interrupt for event CH0LIMITL
        constexpr uint32_t CH1LIMITH = (1U << 8);  ///< Enable or disable interrupt for event CH1LIMITH
        constexpr uint32_t CH1LIMITL = (1U << 9);  ///< Enable or disable interrupt for event CH1LIMITL
        constexpr uint32_t CH2LIMITH = (1U << 10);  ///< Enable or disable interrupt for event CH2LIMITH
        constexpr uint32_t CH2LIMITL = (1U << 11);  ///< Enable or disable interrupt for event CH2LIMITL
        constexpr uint32_t CH3LIMITH = (1U << 12);  ///< Enable or disable interrupt for event CH3LIMITH
        constexpr uint32_t CH3LIMITL = (1U << 13);  ///< Enable or disable interrupt for event CH3LIMITL
        constexpr uint32_t CH4LIMITH = (1U << 14);  ///< Enable or disable interrupt for event CH4LIMITH
        constexpr uint32_t CH4LIMITL = (1U << 15);  ///< Enable or disable interrupt for event CH4LIMITL
        constexpr uint32_t CH5LIMITH = (1U << 16);  ///< Enable or disable interrupt for event CH5LIMITH
        constexpr uint32_t CH5LIMITL = (1U << 17);  ///< Enable or disable interrupt for event CH5LIMITL
        constexpr uint32_t CH6LIMITH = (1U << 18);  ///< Enable or disable interrupt for event CH6LIMITH
        constexpr uint32_t CH6LIMITL = (1U << 19);  ///< Enable or disable interrupt for event CH6LIMITL
        constexpr uint32_t CH7LIMITH = (1U << 20);  ///< Enable or disable interrupt for event CH7LIMITH
        constexpr uint32_t CH7LIMITL = (1U << 21);  ///< Enable or disable interrupt for event CH7LIMITL
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Write '1' to enable interrupt for event STARTED
        constexpr uint32_t END = (1U << 1);  ///< Write '1' to enable interrupt for event END
        constexpr uint32_t DONE = (1U << 2);  ///< Write '1' to enable interrupt for event DONE
        constexpr uint32_t RESULTDONE = (1U << 3);  ///< Write '1' to enable interrupt for event RESULTDONE
        constexpr uint32_t CALIBRATEDONE = (1U << 4);  ///< Write '1' to enable interrupt for event CALIBRATEDONE
        constexpr uint32_t STOPPED = (1U << 5);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t CH0LIMITH = (1U << 6);  ///< Write '1' to enable interrupt for event CH0LIMITH
        constexpr uint32_t CH0LIMITL = (1U << 7);  ///< Write '1' to enable interrupt for event CH0LIMITL
        constexpr uint32_t CH1LIMITH = (1U << 8);  ///< Write '1' to enable interrupt for event CH1LIMITH
        constexpr uint32_t CH1LIMITL = (1U << 9);  ///< Write '1' to enable interrupt for event CH1LIMITL
        constexpr uint32_t CH2LIMITH = (1U << 10);  ///< Write '1' to enable interrupt for event CH2LIMITH
        constexpr uint32_t CH2LIMITL = (1U << 11);  ///< Write '1' to enable interrupt for event CH2LIMITL
        constexpr uint32_t CH3LIMITH = (1U << 12);  ///< Write '1' to enable interrupt for event CH3LIMITH
        constexpr uint32_t CH3LIMITL = (1U << 13);  ///< Write '1' to enable interrupt for event CH3LIMITL
        constexpr uint32_t CH4LIMITH = (1U << 14);  ///< Write '1' to enable interrupt for event CH4LIMITH
        constexpr uint32_t CH4LIMITL = (1U << 15);  ///< Write '1' to enable interrupt for event CH4LIMITL
        constexpr uint32_t CH5LIMITH = (1U << 16);  ///< Write '1' to enable interrupt for event CH5LIMITH
        constexpr uint32_t CH5LIMITL = (1U << 17);  ///< Write '1' to enable interrupt for event CH5LIMITL
        constexpr uint32_t CH6LIMITH = (1U << 18);  ///< Write '1' to enable interrupt for event CH6LIMITH
        constexpr uint32_t CH6LIMITL = (1U << 19);  ///< Write '1' to enable interrupt for event CH6LIMITL
        constexpr uint32_t CH7LIMITH = (1U << 20);  ///< Write '1' to enable interrupt for event CH7LIMITH
        constexpr uint32_t CH7LIMITL = (1U << 21);  ///< Write '1' to enable interrupt for event CH7LIMITL
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Write '1' to disable interrupt for event STARTED
        constexpr uint32_t END = (1U << 1);  ///< Write '1' to disable interrupt for event END
        constexpr uint32_t DONE = (1U << 2);  ///< Write '1' to disable interrupt for event DONE
        constexpr uint32_t RESULTDONE = (1U << 3);  ///< Write '1' to disable interrupt for event RESULTDONE
        constexpr uint32_t CALIBRATEDONE = (1U << 4);  ///< Write '1' to disable interrupt for event CALIBRATEDONE
        constexpr uint32_t STOPPED = (1U << 5);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t CH0LIMITH = (1U << 6);  ///< Write '1' to disable interrupt for event CH0LIMITH
        constexpr uint32_t CH0LIMITL = (1U << 7);  ///< Write '1' to disable interrupt for event CH0LIMITL
        constexpr uint32_t CH1LIMITH = (1U << 8);  ///< Write '1' to disable interrupt for event CH1LIMITH
        constexpr uint32_t CH1LIMITL = (1U << 9);  ///< Write '1' to disable interrupt for event CH1LIMITL
        constexpr uint32_t CH2LIMITH = (1U << 10);  ///< Write '1' to disable interrupt for event CH2LIMITH
        constexpr uint32_t CH2LIMITL = (1U << 11);  ///< Write '1' to disable interrupt for event CH2LIMITL
        constexpr uint32_t CH3LIMITH = (1U << 12);  ///< Write '1' to disable interrupt for event CH3LIMITH
        constexpr uint32_t CH3LIMITL = (1U << 13);  ///< Write '1' to disable interrupt for event CH3LIMITL
        constexpr uint32_t CH4LIMITH = (1U << 14);  ///< Write '1' to disable interrupt for event CH4LIMITH
        constexpr uint32_t CH4LIMITL = (1U << 15);  ///< Write '1' to disable interrupt for event CH4LIMITL
        constexpr uint32_t CH5LIMITH = (1U << 16);  ///< Write '1' to disable interrupt for event CH5LIMITH
        constexpr uint32_t CH5LIMITL = (1U << 17);  ///< Write '1' to disable interrupt for event CH5LIMITL
        constexpr uint32_t CH6LIMITH = (1U << 18);  ///< Write '1' to disable interrupt for event CH6LIMITH
        constexpr uint32_t CH6LIMITL = (1U << 19);  ///< Write '1' to disable interrupt for event CH6LIMITL
        constexpr uint32_t CH7LIMITH = (1U << 20);  ///< Write '1' to disable interrupt for event CH7LIMITH
        constexpr uint32_t CH7LIMITL = (1U << 21);  ///< Write '1' to disable interrupt for event CH7LIMITL
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATUS = (1U << 0);  ///< Status
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable ADC
    }

    /// PSELP Register bits
    namespace pselp_bits {
        constexpr uint32_t PSELP = (5 << 0);  ///< Analog positive input channel
    }

    /// PSELN Register bits
    namespace pseln_bits {
        constexpr uint32_t PSELN = (5 << 0);  ///< Analog negative input, enables differential channel
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t RESP = (2 << 0);  ///< Positive channel resistor control
        constexpr uint32_t RESN = (2 << 4);  ///< Negative channel resistor control
        constexpr uint32_t GAIN = (3 << 8);  ///< Gain control
        constexpr uint32_t REFSEL = (1U << 12);  ///< Reference control
        constexpr uint32_t TACQ = (3 << 16);  ///< Acquisition time, the time the ADC uses to sample the input voltage
        constexpr uint32_t MODE = (1U << 20);  ///< Enable differential mode
        constexpr uint32_t BURST = (1U << 24);  ///< Enable burst mode
    }

    /// LIMIT Register bits
    namespace limit_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low level limit
        constexpr uint32_t HIGH = (16 << 16);  ///< High level limit
    }

    /// RESOLUTION Register bits
    namespace resolution_bits {
        constexpr uint32_t VAL = (3 << 0);  ///< Set the resolution
    }

    /// OVERSAMPLE Register bits
    namespace oversample_bits {
        constexpr uint32_t OVERSAMPLE = (4 << 0);  ///< Oversample control
    }

    /// SAMPLERATE Register bits
    namespace samplerate_bits {
        constexpr uint32_t CC = (11 << 0);  ///< Capture and compare value. Sample rate is 16 MHz/CC
        constexpr uint32_t MODE = (1U << 12);  ///< Select mode for sample rate control
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Data pointer
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t MAXCNT = (15 << 0);  ///< Maximum number of buffer words to transfer
    }

    /// AMOUNT Register bits
    namespace amount_bits {
        constexpr uint32_t AMOUNT = (15 << 0);  ///< Number of buffer words transferred since last START. This register can be read after an END or STOPPED event.
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER0_NS_BASE = 0x4000F000;
    constexpr uint32_t TIMER0_S_BASE = 0x5000F000;
    constexpr uint32_t TIMER1_NS_BASE = 0x40010000;
    constexpr uint32_t TIMER1_S_BASE = 0x50010000;
    constexpr uint32_t TIMER2_NS_BASE = 0x40011000;
    constexpr uint32_t TIMER2_S_BASE = 0x50011000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start Timer
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop Timer
        volatile uint32_t TASKS_COUNT;  ///< Offset: 0x08 - Increment Timer (Counter mode only)
        volatile uint32_t TASKS_CLEAR;  ///< Offset: 0x0C - Clear time
        volatile uint32_t TASKS_SHUTDOWN;  ///< Offset: 0x10 - Deprecated register - Shut down timer
        volatile uint32_t TASKS_CAPTURE__;  ///< Offset: 0x40 - Description collection: Capture Timer value to CC[n] register (renamed from TASKS_CAPTURE__)
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x80 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x84 - Subscribe configuration for task STOP
        volatile uint32_t SUBSCRIBE_COUNT;  ///< Offset: 0x88 - Subscribe configuration for task COUNT
        volatile uint32_t SUBSCRIBE_CLEAR;  ///< Offset: 0x8C - Subscribe configuration for task CLEAR
        volatile uint32_t SUBSCRIBE_SHUTDOWN;  ///< Offset: 0x90 - Deprecated register - Subscribe configuration for task SHUTDOWN
        volatile uint32_t SUBSCRIBE_CAPTURE__;  ///< Offset: 0xC0 - Description collection: Subscribe configuration for task... (renamed from SUBSCRIBE_CAPTURE__)
        volatile uint32_t EVENTS_COMPARE__;  ///< Offset: 0x140 - Description collection: Compare event on CC[n] match (renamed from EVENTS_COMPARE__)
        volatile uint32_t PUBLISH_COMPARE__;  ///< Offset: 0x1C0 - Description collection: Publish configuration for event... (renamed from PUBLISH_COMPARE__)
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t MODE;  ///< Offset: 0x504 - Timer mode selection
        volatile uint32_t BITMODE;  ///< Offset: 0x508 - Configure the number of bits used by the TIMER
        volatile uint32_t PRESCALER;  ///< Offset: 0x510 - Timer prescaler register
        volatile uint32_t ONESHOTEN__;  ///< Offset: 0x514 - Description collection: Enable one-shot operation for... (renamed from ONESHOTEN__)
        volatile uint32_t CC__;  ///< Offset: 0x540 - Description collection: Capture/Compare register n (renamed from CC__)
    };

    /// Peripheral instances
    inline Registers* TIMER0_NS = reinterpret_cast<Registers*>(TIMER0_NS_BASE);
    inline Registers* TIMER0_S = reinterpret_cast<Registers*>(TIMER0_S_BASE);
    inline Registers* TIMER1_NS = reinterpret_cast<Registers*>(TIMER1_NS_BASE);
    inline Registers* TIMER1_S = reinterpret_cast<Registers*>(TIMER1_S_BASE);
    inline Registers* TIMER2_NS = reinterpret_cast<Registers*>(TIMER2_NS_BASE);
    inline Registers* TIMER2_S = reinterpret_cast<Registers*>(TIMER2_S_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start Timer
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop Timer
    }

    /// TASKS_COUNT Register bits
    namespace tasks_count_bits {
        constexpr uint32_t TASKS_COUNT = (1U << 0);  ///< Increment Timer (Counter mode only)
    }

    /// TASKS_CLEAR Register bits
    namespace tasks_clear_bits {
        constexpr uint32_t TASKS_CLEAR = (1U << 0);  ///< Clear time
    }

    /// TASKS_SHUTDOWN Register bits
    namespace tasks_shutdown_bits {
        constexpr uint32_t TASKS_SHUTDOWN = (1U << 0);  ///< Deprecated field - Shut down timer
    }

    /// TASKS_CAPTURE__ Register bits
    namespace tasks_capture___bits {
        constexpr uint32_t TASKS_CAPTURE = (1U << 0);  ///< Capture Timer value to CC[n] register
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_COUNT Register bits
    namespace subscribe_count_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task COUNT will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CLEAR Register bits
    namespace subscribe_clear_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task CLEAR will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_SHUTDOWN Register bits
    namespace subscribe_shutdown_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task SHUTDOWN will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CAPTURE__ Register bits
    namespace subscribe_capture___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task CAPTURE[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_COMPARE__ Register bits
    namespace events_compare___bits {
        constexpr uint32_t EVENTS_COMPARE = (1U << 0);  ///< Compare event on CC[n] match
    }

    /// PUBLISH_COMPARE__ Register bits
    namespace publish_compare___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event COMPARE[n] will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t COMPARE0_CLEAR = (1U << 0);  ///< Shortcut between event COMPARE[0] and task CLEAR
        constexpr uint32_t COMPARE1_CLEAR = (1U << 1);  ///< Shortcut between event COMPARE[1] and task CLEAR
        constexpr uint32_t COMPARE2_CLEAR = (1U << 2);  ///< Shortcut between event COMPARE[2] and task CLEAR
        constexpr uint32_t COMPARE3_CLEAR = (1U << 3);  ///< Shortcut between event COMPARE[3] and task CLEAR
        constexpr uint32_t COMPARE4_CLEAR = (1U << 4);  ///< Shortcut between event COMPARE[4] and task CLEAR
        constexpr uint32_t COMPARE5_CLEAR = (1U << 5);  ///< Shortcut between event COMPARE[5] and task CLEAR
        constexpr uint32_t COMPARE0_STOP = (1U << 8);  ///< Shortcut between event COMPARE[0] and task STOP
        constexpr uint32_t COMPARE1_STOP = (1U << 9);  ///< Shortcut between event COMPARE[1] and task STOP
        constexpr uint32_t COMPARE2_STOP = (1U << 10);  ///< Shortcut between event COMPARE[2] and task STOP
        constexpr uint32_t COMPARE3_STOP = (1U << 11);  ///< Shortcut between event COMPARE[3] and task STOP
        constexpr uint32_t COMPARE4_STOP = (1U << 12);  ///< Shortcut between event COMPARE[4] and task STOP
        constexpr uint32_t COMPARE5_STOP = (1U << 13);  ///< Shortcut between event COMPARE[5] and task STOP
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to enable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to enable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to enable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to enable interrupt for event COMPARE[3]
        constexpr uint32_t COMPARE4 = (1U << 20);  ///< Write '1' to enable interrupt for event COMPARE[4]
        constexpr uint32_t COMPARE5 = (1U << 21);  ///< Write '1' to enable interrupt for event COMPARE[5]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to disable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to disable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to disable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to disable interrupt for event COMPARE[3]
        constexpr uint32_t COMPARE4 = (1U << 20);  ///< Write '1' to disable interrupt for event COMPARE[4]
        constexpr uint32_t COMPARE5 = (1U << 21);  ///< Write '1' to disable interrupt for event COMPARE[5]
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Timer mode
    }

    /// BITMODE Register bits
    namespace bitmode_bits {
        constexpr uint32_t BITMODE = (2 << 0);  ///< Timer bit width
    }

    /// PRESCALER Register bits
    namespace prescaler_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< Prescaler value
    }

    /// ONESHOTEN__ Register bits
    namespace oneshoten___bits {
        constexpr uint32_t ONESHOTEN = (1U << 0);  ///< Enable one-shot operation
    }

    /// CC__ Register bits
    namespace cc___bits {
        constexpr uint32_t CC = (32 << 0);  ///< Capture/Compare value
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC0_NS_BASE = 0x40014000;
    constexpr uint32_t RTC0_S_BASE = 0x50014000;
    constexpr uint32_t RTC1_NS_BASE = 0x40015000;
    constexpr uint32_t RTC1_S_BASE = 0x50015000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start RTC counter
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stop RTC counter
        volatile uint32_t TASKS_CLEAR;  ///< Offset: 0x08 - Clear RTC counter
        volatile uint32_t TASKS_TRIGOVRFLW;  ///< Offset: 0x0C - Set counter to 0xFFFFF0
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x80 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x84 - Subscribe configuration for task STOP
        volatile uint32_t SUBSCRIBE_CLEAR;  ///< Offset: 0x88 - Subscribe configuration for task CLEAR
        volatile uint32_t SUBSCRIBE_TRIGOVRFLW;  ///< Offset: 0x8C - Subscribe configuration for task TRIGOVRFLW
        volatile uint32_t EVENTS_TICK;  ///< Offset: 0x100 - Event on counter increment
        volatile uint32_t EVENTS_OVRFLW;  ///< Offset: 0x104 - Event on counter overflow
        volatile uint32_t EVENTS_COMPARE__;  ///< Offset: 0x140 - Description collection: Compare event on CC[n] match (renamed from EVENTS_COMPARE__)
        volatile uint32_t PUBLISH_TICK;  ///< Offset: 0x180 - Publish configuration for event TICK
        volatile uint32_t PUBLISH_OVRFLW;  ///< Offset: 0x184 - Publish configuration for event OVRFLW
        volatile uint32_t PUBLISH_COMPARE__;  ///< Offset: 0x1C0 - Description collection: Publish configuration for event... (renamed from PUBLISH_COMPARE__)
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t EVTEN;  ///< Offset: 0x340 - Enable or disable event routing
        volatile uint32_t EVTENSET;  ///< Offset: 0x344 - Enable event routing
        volatile uint32_t EVTENCLR;  ///< Offset: 0x348 - Disable event routing
        volatile uint32_t COUNTER;  ///< Offset: 0x504 - Current counter value
        volatile uint32_t PRESCALER;  ///< Offset: 0x508 - 12-bit prescaler for counter frequency...
        volatile uint32_t CC__;  ///< Offset: 0x540 - Description collection: Compare register n (renamed from CC__)
    };

    /// Peripheral instances
    inline Registers* RTC0_NS = reinterpret_cast<Registers*>(RTC0_NS_BASE);
    inline Registers* RTC0_S = reinterpret_cast<Registers*>(RTC0_S_BASE);
    inline Registers* RTC1_NS = reinterpret_cast<Registers*>(RTC1_NS_BASE);
    inline Registers* RTC1_S = reinterpret_cast<Registers*>(RTC1_S_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start RTC counter
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stop RTC counter
    }

    /// TASKS_CLEAR Register bits
    namespace tasks_clear_bits {
        constexpr uint32_t TASKS_CLEAR = (1U << 0);  ///< Clear RTC counter
    }

    /// TASKS_TRIGOVRFLW Register bits
    namespace tasks_trigovrflw_bits {
        constexpr uint32_t TASKS_TRIGOVRFLW = (1U << 0);  ///< Set counter to 0xFFFFF0
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_CLEAR Register bits
    namespace subscribe_clear_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task CLEAR will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_TRIGOVRFLW Register bits
    namespace subscribe_trigovrflw_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task TRIGOVRFLW will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_TICK Register bits
    namespace events_tick_bits {
        constexpr uint32_t EVENTS_TICK = (1U << 0);  ///< Event on counter increment
    }

    /// EVENTS_OVRFLW Register bits
    namespace events_ovrflw_bits {
        constexpr uint32_t EVENTS_OVRFLW = (1U << 0);  ///< Event on counter overflow
    }

    /// EVENTS_COMPARE__ Register bits
    namespace events_compare___bits {
        constexpr uint32_t EVENTS_COMPARE = (1U << 0);  ///< Compare event on CC[n] match
    }

    /// PUBLISH_TICK Register bits
    namespace publish_tick_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event TICK will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_OVRFLW Register bits
    namespace publish_ovrflw_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event OVRFLW will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_COMPARE__ Register bits
    namespace publish_compare___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event COMPARE[n] will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to enable interrupt for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to enable interrupt for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to enable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to enable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to enable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to enable interrupt for event COMPARE[3]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to disable interrupt for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to disable interrupt for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to disable interrupt for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to disable interrupt for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to disable interrupt for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to disable interrupt for event COMPARE[3]
    }

    /// EVTEN Register bits
    namespace evten_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Enable or disable event routing for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Enable or disable event routing for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Enable or disable event routing for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Enable or disable event routing for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Enable or disable event routing for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Enable or disable event routing for event COMPARE[3]
    }

    /// EVTENSET Register bits
    namespace evtenset_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to enable event routing for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to enable event routing for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to enable event routing for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to enable event routing for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to enable event routing for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to enable event routing for event COMPARE[3]
    }

    /// EVTENCLR Register bits
    namespace evtenclr_bits {
        constexpr uint32_t TICK = (1U << 0);  ///< Write '1' to disable event routing for event TICK
        constexpr uint32_t OVRFLW = (1U << 1);  ///< Write '1' to disable event routing for event OVRFLW
        constexpr uint32_t COMPARE0 = (1U << 16);  ///< Write '1' to disable event routing for event COMPARE[0]
        constexpr uint32_t COMPARE1 = (1U << 17);  ///< Write '1' to disable event routing for event COMPARE[1]
        constexpr uint32_t COMPARE2 = (1U << 18);  ///< Write '1' to disable event routing for event COMPARE[2]
        constexpr uint32_t COMPARE3 = (1U << 19);  ///< Write '1' to disable event routing for event COMPARE[3]
    }

    /// COUNTER Register bits
    namespace counter_bits {
        constexpr uint32_t COUNTER = (24 << 0);  ///< Counter value
    }

    /// PRESCALER Register bits
    namespace prescaler_bits {
        constexpr uint32_t PRESCALER = (12 << 0);  ///< Prescaler value
    }

    /// CC__ Register bits
    namespace cc___bits {
        constexpr uint32_t COMPARE = (24 << 0);  ///< Compare value
    }

}

// ============================================================================
// DPPIC Peripheral
// ============================================================================

namespace dppic {
    /// Base addresses
    constexpr uint32_t DPPIC_NS_BASE = 0x40017000;
    constexpr uint32_t DPPIC_S_BASE = 0x50017000;

    /// DPPIC Register structure
    struct Registers {
        volatile uint32_t EN;  ///< Offset: 0x00 - Description cluster: Subscribe configuration for task CHG[n].EN
        volatile uint32_t DIS;  ///< Offset: 0x04 - Description cluster: Subscribe configuration for task CHG[n].DIS
        volatile uint32_t CHEN;  ///< Offset: 0x500 - Channel enable register
        volatile uint32_t CHENSET;  ///< Offset: 0x504 - Channel enable set register
        volatile uint32_t CHENCLR;  ///< Offset: 0x508 - Channel enable clear register
        volatile uint32_t CHG__;  ///< Offset: 0x800 - Description collection: Channel group n Note: Writes to... (renamed from CHG__)
    };

    /// Peripheral instances
    inline Registers* DPPIC_NS = reinterpret_cast<Registers*>(DPPIC_NS_BASE);
    inline Registers* DPPIC_S = reinterpret_cast<Registers*>(DPPIC_S_BASE);

    // Bit definitions
    /// EN Register bits
    namespace en_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task CHG[n].EN will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// DIS Register bits
    namespace dis_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task CHG[n].DIS will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// CHEN Register bits
    namespace chen_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Enable or disable channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Enable or disable channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Enable or disable channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Enable or disable channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Enable or disable channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Enable or disable channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Enable or disable channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Enable or disable channel 7
        constexpr uint32_t CH8 = (1U << 8);  ///< Enable or disable channel 8
        constexpr uint32_t CH9 = (1U << 9);  ///< Enable or disable channel 9
        constexpr uint32_t CH10 = (1U << 10);  ///< Enable or disable channel 10
        constexpr uint32_t CH11 = (1U << 11);  ///< Enable or disable channel 11
        constexpr uint32_t CH12 = (1U << 12);  ///< Enable or disable channel 12
        constexpr uint32_t CH13 = (1U << 13);  ///< Enable or disable channel 13
        constexpr uint32_t CH14 = (1U << 14);  ///< Enable or disable channel 14
        constexpr uint32_t CH15 = (1U << 15);  ///< Enable or disable channel 15
    }

    /// CHENSET Register bits
    namespace chenset_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Channel 0 enable set register. Writing '0' has no effect
        constexpr uint32_t CH1 = (1U << 1);  ///< Channel 1 enable set register. Writing '0' has no effect
        constexpr uint32_t CH2 = (1U << 2);  ///< Channel 2 enable set register. Writing '0' has no effect
        constexpr uint32_t CH3 = (1U << 3);  ///< Channel 3 enable set register. Writing '0' has no effect
        constexpr uint32_t CH4 = (1U << 4);  ///< Channel 4 enable set register. Writing '0' has no effect
        constexpr uint32_t CH5 = (1U << 5);  ///< Channel 5 enable set register. Writing '0' has no effect
        constexpr uint32_t CH6 = (1U << 6);  ///< Channel 6 enable set register. Writing '0' has no effect
        constexpr uint32_t CH7 = (1U << 7);  ///< Channel 7 enable set register. Writing '0' has no effect
        constexpr uint32_t CH8 = (1U << 8);  ///< Channel 8 enable set register. Writing '0' has no effect
        constexpr uint32_t CH9 = (1U << 9);  ///< Channel 9 enable set register. Writing '0' has no effect
        constexpr uint32_t CH10 = (1U << 10);  ///< Channel 10 enable set register. Writing '0' has no effect
        constexpr uint32_t CH11 = (1U << 11);  ///< Channel 11 enable set register. Writing '0' has no effect
        constexpr uint32_t CH12 = (1U << 12);  ///< Channel 12 enable set register. Writing '0' has no effect
        constexpr uint32_t CH13 = (1U << 13);  ///< Channel 13 enable set register. Writing '0' has no effect
        constexpr uint32_t CH14 = (1U << 14);  ///< Channel 14 enable set register. Writing '0' has no effect
        constexpr uint32_t CH15 = (1U << 15);  ///< Channel 15 enable set register. Writing '0' has no effect
    }

    /// CHENCLR Register bits
    namespace chenclr_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Channel 0 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH1 = (1U << 1);  ///< Channel 1 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH2 = (1U << 2);  ///< Channel 2 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH3 = (1U << 3);  ///< Channel 3 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH4 = (1U << 4);  ///< Channel 4 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH5 = (1U << 5);  ///< Channel 5 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH6 = (1U << 6);  ///< Channel 6 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH7 = (1U << 7);  ///< Channel 7 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH8 = (1U << 8);  ///< Channel 8 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH9 = (1U << 9);  ///< Channel 9 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH10 = (1U << 10);  ///< Channel 10 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH11 = (1U << 11);  ///< Channel 11 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH12 = (1U << 12);  ///< Channel 12 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH13 = (1U << 13);  ///< Channel 13 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH14 = (1U << 14);  ///< Channel 14 enable clear register. Writing '0' has no effect
        constexpr uint32_t CH15 = (1U << 15);  ///< Channel 15 enable clear register. Writing '0' has no effect
    }

    /// CHG__ Register bits
    namespace chg___bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Include or exclude channel 0
        constexpr uint32_t CH1 = (1U << 1);  ///< Include or exclude channel 1
        constexpr uint32_t CH2 = (1U << 2);  ///< Include or exclude channel 2
        constexpr uint32_t CH3 = (1U << 3);  ///< Include or exclude channel 3
        constexpr uint32_t CH4 = (1U << 4);  ///< Include or exclude channel 4
        constexpr uint32_t CH5 = (1U << 5);  ///< Include or exclude channel 5
        constexpr uint32_t CH6 = (1U << 6);  ///< Include or exclude channel 6
        constexpr uint32_t CH7 = (1U << 7);  ///< Include or exclude channel 7
        constexpr uint32_t CH8 = (1U << 8);  ///< Include or exclude channel 8
        constexpr uint32_t CH9 = (1U << 9);  ///< Include or exclude channel 9
        constexpr uint32_t CH10 = (1U << 10);  ///< Include or exclude channel 10
        constexpr uint32_t CH11 = (1U << 11);  ///< Include or exclude channel 11
        constexpr uint32_t CH12 = (1U << 12);  ///< Include or exclude channel 12
        constexpr uint32_t CH13 = (1U << 13);  ///< Include or exclude channel 13
        constexpr uint32_t CH14 = (1U << 14);  ///< Include or exclude channel 14
        constexpr uint32_t CH15 = (1U << 15);  ///< Include or exclude channel 15
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_NS_BASE = 0x40018000;
    constexpr uint32_t WDT_S_BASE = 0x50018000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Start the watchdog
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x80 - Subscribe configuration for task START
        volatile uint32_t EVENTS_TIMEOUT;  ///< Offset: 0x100 - Watchdog timeout
        volatile uint32_t PUBLISH_TIMEOUT;  ///< Offset: 0x180 - Publish configuration for event TIMEOUT
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t RUNSTATUS;  ///< Offset: 0x400 - Run status
        volatile uint32_t REQSTATUS;  ///< Offset: 0x404 - Request status
        volatile uint32_t CRV;  ///< Offset: 0x504 - Counter reload value
        volatile uint32_t RREN;  ///< Offset: 0x508 - Enable register for reload request registers
        volatile uint32_t CONFIG;  ///< Offset: 0x50C - Configuration register
        volatile uint32_t RR__;  ///< Offset: 0x600 - Description collection: Reload request n (renamed from RR__)
    };

    /// Peripheral instances
    inline Registers* WDT_NS = reinterpret_cast<Registers*>(WDT_NS_BASE);
    inline Registers* WDT_S = reinterpret_cast<Registers*>(WDT_S_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Start the watchdog
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_TIMEOUT Register bits
    namespace events_timeout_bits {
        constexpr uint32_t EVENTS_TIMEOUT = (1U << 0);  ///< Watchdog timeout
    }

    /// PUBLISH_TIMEOUT Register bits
    namespace publish_timeout_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event TIMEOUT will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TIMEOUT = (1U << 0);  ///< Write '1' to enable interrupt for event TIMEOUT
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TIMEOUT = (1U << 0);  ///< Write '1' to disable interrupt for event TIMEOUT
    }

    /// RUNSTATUS Register bits
    namespace runstatus_bits {
        constexpr uint32_t RUNSTATUSWDT = (1U << 0);  ///< Indicates whether or not the watchdog is running
    }

    /// REQSTATUS Register bits
    namespace reqstatus_bits {
        constexpr uint32_t RR0 = (1U << 0);  ///< Request status for RR[0] register
        constexpr uint32_t RR1 = (1U << 1);  ///< Request status for RR[1] register
        constexpr uint32_t RR2 = (1U << 2);  ///< Request status for RR[2] register
        constexpr uint32_t RR3 = (1U << 3);  ///< Request status for RR[3] register
        constexpr uint32_t RR4 = (1U << 4);  ///< Request status for RR[4] register
        constexpr uint32_t RR5 = (1U << 5);  ///< Request status for RR[5] register
        constexpr uint32_t RR6 = (1U << 6);  ///< Request status for RR[6] register
        constexpr uint32_t RR7 = (1U << 7);  ///< Request status for RR[7] register
    }

    /// CRV Register bits
    namespace crv_bits {
        constexpr uint32_t CRV = (32 << 0);  ///< Counter reload value in number of cycles of the 32.768 kHz clock
    }

    /// RREN Register bits
    namespace rren_bits {
        constexpr uint32_t RR0 = (1U << 0);  ///< Enable or disable RR[0] register
        constexpr uint32_t RR1 = (1U << 1);  ///< Enable or disable RR[1] register
        constexpr uint32_t RR2 = (1U << 2);  ///< Enable or disable RR[2] register
        constexpr uint32_t RR3 = (1U << 3);  ///< Enable or disable RR[3] register
        constexpr uint32_t RR4 = (1U << 4);  ///< Enable or disable RR[4] register
        constexpr uint32_t RR5 = (1U << 5);  ///< Enable or disable RR[5] register
        constexpr uint32_t RR6 = (1U << 6);  ///< Enable or disable RR[6] register
        constexpr uint32_t RR7 = (1U << 7);  ///< Enable or disable RR[7] register
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t SLEEP = (1U << 0);  ///< Configure the watchdog to either be paused, or kept running, while the CPU is sleeping
        constexpr uint32_t HALT = (1U << 3);  ///< Configure the watchdog to either be paused, or kept running, while the CPU is halted by the debugger
    }

    /// RR__ Register bits
    namespace rr___bits {
        constexpr uint32_t RR = (32 << 0);  ///< Reload request register
    }

}

// ============================================================================
// EGU0 Peripheral
// ============================================================================

namespace egu0 {
    /// Base addresses
    constexpr uint32_t EGU0_NS_BASE = 0x4001B000;
    constexpr uint32_t EGU0_S_BASE = 0x5001B000;

    /// EGU0 Register structure
    struct Registers {
        volatile uint32_t TASKS_TRIGGER__;  ///< Offset: 0x00 - Description collection: Trigger n for triggering the... (renamed from TASKS_TRIGGER__)
        volatile uint32_t SUBSCRIBE_TRIGGER__;  ///< Offset: 0x80 - Description collection: Subscribe configuration for task... (renamed from SUBSCRIBE_TRIGGER__)
        volatile uint32_t EVENTS_TRIGGERED__;  ///< Offset: 0x100 - Description collection: Event number n generated by... (renamed from EVENTS_TRIGGERED__)
        volatile uint32_t PUBLISH_TRIGGERED__;  ///< Offset: 0x180 - Description collection: Publish configuration for event... (renamed from PUBLISH_TRIGGERED__)
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
    };

    /// Peripheral instances
    inline Registers* EGU0_NS = reinterpret_cast<Registers*>(EGU0_NS_BASE);
    inline Registers* EGU0_S = reinterpret_cast<Registers*>(EGU0_S_BASE);

    // Bit definitions
    /// TASKS_TRIGGER__ Register bits
    namespace tasks_trigger___bits {
        constexpr uint32_t TASKS_TRIGGER = (1U << 0);  ///< Trigger n for triggering the corresponding TRIGGERED[n] event
    }

    /// SUBSCRIBE_TRIGGER__ Register bits
    namespace subscribe_trigger___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task TRIGGER[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_TRIGGERED__ Register bits
    namespace events_triggered___bits {
        constexpr uint32_t EVENTS_TRIGGERED = (1U << 0);  ///< Event number n generated by triggering the corresponding TRIGGER[n] task
    }

    /// PUBLISH_TRIGGERED__ Register bits
    namespace publish_triggered___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event TRIGGERED[n] will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t TRIGGERED0 = (1U << 0);  ///< Enable or disable interrupt for event TRIGGERED[0]
        constexpr uint32_t TRIGGERED1 = (1U << 1);  ///< Enable or disable interrupt for event TRIGGERED[1]
        constexpr uint32_t TRIGGERED2 = (1U << 2);  ///< Enable or disable interrupt for event TRIGGERED[2]
        constexpr uint32_t TRIGGERED3 = (1U << 3);  ///< Enable or disable interrupt for event TRIGGERED[3]
        constexpr uint32_t TRIGGERED4 = (1U << 4);  ///< Enable or disable interrupt for event TRIGGERED[4]
        constexpr uint32_t TRIGGERED5 = (1U << 5);  ///< Enable or disable interrupt for event TRIGGERED[5]
        constexpr uint32_t TRIGGERED6 = (1U << 6);  ///< Enable or disable interrupt for event TRIGGERED[6]
        constexpr uint32_t TRIGGERED7 = (1U << 7);  ///< Enable or disable interrupt for event TRIGGERED[7]
        constexpr uint32_t TRIGGERED8 = (1U << 8);  ///< Enable or disable interrupt for event TRIGGERED[8]
        constexpr uint32_t TRIGGERED9 = (1U << 9);  ///< Enable or disable interrupt for event TRIGGERED[9]
        constexpr uint32_t TRIGGERED10 = (1U << 10);  ///< Enable or disable interrupt for event TRIGGERED[10]
        constexpr uint32_t TRIGGERED11 = (1U << 11);  ///< Enable or disable interrupt for event TRIGGERED[11]
        constexpr uint32_t TRIGGERED12 = (1U << 12);  ///< Enable or disable interrupt for event TRIGGERED[12]
        constexpr uint32_t TRIGGERED13 = (1U << 13);  ///< Enable or disable interrupt for event TRIGGERED[13]
        constexpr uint32_t TRIGGERED14 = (1U << 14);  ///< Enable or disable interrupt for event TRIGGERED[14]
        constexpr uint32_t TRIGGERED15 = (1U << 15);  ///< Enable or disable interrupt for event TRIGGERED[15]
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TRIGGERED0 = (1U << 0);  ///< Write '1' to enable interrupt for event TRIGGERED[0]
        constexpr uint32_t TRIGGERED1 = (1U << 1);  ///< Write '1' to enable interrupt for event TRIGGERED[1]
        constexpr uint32_t TRIGGERED2 = (1U << 2);  ///< Write '1' to enable interrupt for event TRIGGERED[2]
        constexpr uint32_t TRIGGERED3 = (1U << 3);  ///< Write '1' to enable interrupt for event TRIGGERED[3]
        constexpr uint32_t TRIGGERED4 = (1U << 4);  ///< Write '1' to enable interrupt for event TRIGGERED[4]
        constexpr uint32_t TRIGGERED5 = (1U << 5);  ///< Write '1' to enable interrupt for event TRIGGERED[5]
        constexpr uint32_t TRIGGERED6 = (1U << 6);  ///< Write '1' to enable interrupt for event TRIGGERED[6]
        constexpr uint32_t TRIGGERED7 = (1U << 7);  ///< Write '1' to enable interrupt for event TRIGGERED[7]
        constexpr uint32_t TRIGGERED8 = (1U << 8);  ///< Write '1' to enable interrupt for event TRIGGERED[8]
        constexpr uint32_t TRIGGERED9 = (1U << 9);  ///< Write '1' to enable interrupt for event TRIGGERED[9]
        constexpr uint32_t TRIGGERED10 = (1U << 10);  ///< Write '1' to enable interrupt for event TRIGGERED[10]
        constexpr uint32_t TRIGGERED11 = (1U << 11);  ///< Write '1' to enable interrupt for event TRIGGERED[11]
        constexpr uint32_t TRIGGERED12 = (1U << 12);  ///< Write '1' to enable interrupt for event TRIGGERED[12]
        constexpr uint32_t TRIGGERED13 = (1U << 13);  ///< Write '1' to enable interrupt for event TRIGGERED[13]
        constexpr uint32_t TRIGGERED14 = (1U << 14);  ///< Write '1' to enable interrupt for event TRIGGERED[14]
        constexpr uint32_t TRIGGERED15 = (1U << 15);  ///< Write '1' to enable interrupt for event TRIGGERED[15]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TRIGGERED0 = (1U << 0);  ///< Write '1' to disable interrupt for event TRIGGERED[0]
        constexpr uint32_t TRIGGERED1 = (1U << 1);  ///< Write '1' to disable interrupt for event TRIGGERED[1]
        constexpr uint32_t TRIGGERED2 = (1U << 2);  ///< Write '1' to disable interrupt for event TRIGGERED[2]
        constexpr uint32_t TRIGGERED3 = (1U << 3);  ///< Write '1' to disable interrupt for event TRIGGERED[3]
        constexpr uint32_t TRIGGERED4 = (1U << 4);  ///< Write '1' to disable interrupt for event TRIGGERED[4]
        constexpr uint32_t TRIGGERED5 = (1U << 5);  ///< Write '1' to disable interrupt for event TRIGGERED[5]
        constexpr uint32_t TRIGGERED6 = (1U << 6);  ///< Write '1' to disable interrupt for event TRIGGERED[6]
        constexpr uint32_t TRIGGERED7 = (1U << 7);  ///< Write '1' to disable interrupt for event TRIGGERED[7]
        constexpr uint32_t TRIGGERED8 = (1U << 8);  ///< Write '1' to disable interrupt for event TRIGGERED[8]
        constexpr uint32_t TRIGGERED9 = (1U << 9);  ///< Write '1' to disable interrupt for event TRIGGERED[9]
        constexpr uint32_t TRIGGERED10 = (1U << 10);  ///< Write '1' to disable interrupt for event TRIGGERED[10]
        constexpr uint32_t TRIGGERED11 = (1U << 11);  ///< Write '1' to disable interrupt for event TRIGGERED[11]
        constexpr uint32_t TRIGGERED12 = (1U << 12);  ///< Write '1' to disable interrupt for event TRIGGERED[12]
        constexpr uint32_t TRIGGERED13 = (1U << 13);  ///< Write '1' to disable interrupt for event TRIGGERED[13]
        constexpr uint32_t TRIGGERED14 = (1U << 14);  ///< Write '1' to disable interrupt for event TRIGGERED[14]
        constexpr uint32_t TRIGGERED15 = (1U << 15);  ///< Write '1' to disable interrupt for event TRIGGERED[15]
    }

}

// ============================================================================
// EGU1 Peripheral
// ============================================================================

namespace egu1 {
    /// Base addresses
    constexpr uint32_t EGU1_NS_BASE = 0x4001C000;
    constexpr uint32_t EGU1_S_BASE = 0x5001C000;

    /// EGU1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* EGU1_NS = reinterpret_cast<Registers*>(EGU1_NS_BASE);
    inline Registers* EGU1_S = reinterpret_cast<Registers*>(EGU1_S_BASE);

}

// ============================================================================
// EGU2 Peripheral
// ============================================================================

namespace egu2 {
    /// Base addresses
    constexpr uint32_t EGU2_NS_BASE = 0x4001D000;
    constexpr uint32_t EGU2_S_BASE = 0x5001D000;

    /// EGU2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* EGU2_NS = reinterpret_cast<Registers*>(EGU2_NS_BASE);
    inline Registers* EGU2_S = reinterpret_cast<Registers*>(EGU2_S_BASE);

}

// ============================================================================
// EGU3 Peripheral
// ============================================================================

namespace egu3 {
    /// Base addresses
    constexpr uint32_t EGU3_NS_BASE = 0x4001E000;
    constexpr uint32_t EGU3_S_BASE = 0x5001E000;

    /// EGU3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* EGU3_NS = reinterpret_cast<Registers*>(EGU3_NS_BASE);
    inline Registers* EGU3_S = reinterpret_cast<Registers*>(EGU3_S_BASE);

}

// ============================================================================
// EGU4 Peripheral
// ============================================================================

namespace egu4 {
    /// Base addresses
    constexpr uint32_t EGU4_NS_BASE = 0x4001F000;
    constexpr uint32_t EGU4_S_BASE = 0x5001F000;

    /// EGU4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* EGU4_NS = reinterpret_cast<Registers*>(EGU4_NS_BASE);
    inline Registers* EGU4_S = reinterpret_cast<Registers*>(EGU4_S_BASE);

}

// ============================================================================
// EGU5 Peripheral
// ============================================================================

namespace egu5 {
    /// Base addresses
    constexpr uint32_t EGU5_NS_BASE = 0x40020000;
    constexpr uint32_t EGU5_S_BASE = 0x50020000;

    /// EGU5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* EGU5_NS = reinterpret_cast<Registers*>(EGU5_NS_BASE);
    inline Registers* EGU5_S = reinterpret_cast<Registers*>(EGU5_S_BASE);

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t PWM0_NS_BASE = 0x40021000;
    constexpr uint32_t PWM0_S_BASE = 0x50021000;
    constexpr uint32_t PWM1_NS_BASE = 0x40022000;
    constexpr uint32_t PWM1_S_BASE = 0x50022000;
    constexpr uint32_t PWM2_NS_BASE = 0x40023000;
    constexpr uint32_t PWM2_S_BASE = 0x50023000;
    constexpr uint32_t PWM3_NS_BASE = 0x40024000;
    constexpr uint32_t PWM3_S_BASE = 0x50024000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stops PWM pulse generation on all channels at the end of...
        volatile uint32_t TASKS_SEQSTART__;  ///< Offset: 0x08 - Description collection: Loads the first PWM value on all... (renamed from TASKS_SEQSTART__)
        volatile uint32_t TASKS_NEXTSTEP;  ///< Offset: 0x10 - Steps by one value in the current sequence on all...
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x84 - Subscribe configuration for task STOP
        volatile uint32_t SUBSCRIBE_SEQSTART__;  ///< Offset: 0x88 - Description collection: Subscribe configuration for task... (renamed from SUBSCRIBE_SEQSTART__)
        volatile uint32_t SUBSCRIBE_NEXTSTEP;  ///< Offset: 0x90 - Subscribe configuration for task NEXTSTEP
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - Response to STOP task, emitted when PWM pulses are no...
        volatile uint32_t EVENTS_SEQSTARTED__;  ///< Offset: 0x108 - Description collection: First PWM period started on sequence n (renamed from EVENTS_SEQSTARTED__)
        volatile uint32_t EVENTS_SEQEND__;  ///< Offset: 0x110 - Description collection: Emitted at end of every sequence... (renamed from EVENTS_SEQEND__)
        volatile uint32_t EVENTS_PWMPERIODEND;  ///< Offset: 0x118 - Emitted at the end of each PWM period
        volatile uint32_t EVENTS_LOOPSDONE;  ///< Offset: 0x11C - Concatenated sequences have been played the amount of...
        volatile uint32_t PUBLISH_STOPPED;  ///< Offset: 0x184 - Publish configuration for event STOPPED
        volatile uint32_t PUBLISH_SEQSTARTED__;  ///< Offset: 0x188 - Description collection: Publish configuration for event... (renamed from PUBLISH_SEQSTARTED__)
        volatile uint32_t PUBLISH_SEQEND__;  ///< Offset: 0x190 - Description collection: Publish configuration for event SEQEND[n] (renamed from PUBLISH_SEQEND__)
        volatile uint32_t PUBLISH_PWMPERIODEND;  ///< Offset: 0x198 - Publish configuration for event PWMPERIODEND
        volatile uint32_t PUBLISH_LOOPSDONE;  ///< Offset: 0x19C - Publish configuration for event LOOPSDONE
        volatile uint32_t SHORTS;  ///< Offset: 0x200 - Shortcuts between local events and tasks
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - PWM module enable register
        volatile uint32_t MODE;  ///< Offset: 0x504 - Selects operating mode of the wave counter
        volatile uint32_t COUNTERTOP;  ///< Offset: 0x508 - Value up to which the pulse generator counter counts
        volatile uint32_t PRESCALER;  ///< Offset: 0x50C - Configuration for PWM_CLK
        volatile uint32_t DECODER;  ///< Offset: 0x510 - Configuration of the decoder
        volatile uint32_t LOOP;  ///< Offset: 0x514 - Number of playbacks of a loop
        volatile uint32_t PTR;  ///< Offset: 0x00 - Description cluster: Beginning address in RAM of this sequence
        volatile uint32_t CNT;  ///< Offset: 0x04 - Description cluster: Number of values (duty cycles) in...
        volatile uint32_t REFRESH;  ///< Offset: 0x08 - Description cluster: Number of additional PWM periods...
        volatile uint32_t ENDDELAY;  ///< Offset: 0x0C - Description cluster: Time added after the sequence
        volatile uint32_t OUT__;  ///< Offset: 0x00 - Description collection: Output pin select for PWM channel n (renamed from OUT__)
    };

    /// Peripheral instances
    inline Registers* PWM0_NS = reinterpret_cast<Registers*>(PWM0_NS_BASE);
    inline Registers* PWM0_S = reinterpret_cast<Registers*>(PWM0_S_BASE);
    inline Registers* PWM1_NS = reinterpret_cast<Registers*>(PWM1_NS_BASE);
    inline Registers* PWM1_S = reinterpret_cast<Registers*>(PWM1_S_BASE);
    inline Registers* PWM2_NS = reinterpret_cast<Registers*>(PWM2_NS_BASE);
    inline Registers* PWM2_S = reinterpret_cast<Registers*>(PWM2_S_BASE);
    inline Registers* PWM3_NS = reinterpret_cast<Registers*>(PWM3_NS_BASE);
    inline Registers* PWM3_S = reinterpret_cast<Registers*>(PWM3_S_BASE);

    // Bit definitions
    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
    }

    /// TASKS_SEQSTART__ Register bits
    namespace tasks_seqstart___bits {
        constexpr uint32_t TASKS_SEQSTART = (1U << 0);  ///< Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
    }

    /// TASKS_NEXTSTEP Register bits
    namespace tasks_nextstep_bits {
        constexpr uint32_t TASKS_NEXTSTEP = (1U << 0);  ///< Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_SEQSTART__ Register bits
    namespace subscribe_seqstart___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task SEQSTART[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_NEXTSTEP Register bits
    namespace subscribe_nextstep_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task NEXTSTEP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< Response to STOP task, emitted when PWM pulses are no longer generated
    }

    /// EVENTS_SEQSTARTED__ Register bits
    namespace events_seqstarted___bits {
        constexpr uint32_t EVENTS_SEQSTARTED = (1U << 0);  ///< First PWM period started on sequence n
    }

    /// EVENTS_SEQEND__ Register bits
    namespace events_seqend___bits {
        constexpr uint32_t EVENTS_SEQEND = (1U << 0);  ///< Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
    }

    /// EVENTS_PWMPERIODEND Register bits
    namespace events_pwmperiodend_bits {
        constexpr uint32_t EVENTS_PWMPERIODEND = (1U << 0);  ///< Emitted at the end of each PWM period
    }

    /// EVENTS_LOOPSDONE Register bits
    namespace events_loopsdone_bits {
        constexpr uint32_t EVENTS_LOOPSDONE = (1U << 0);  ///< Concatenated sequences have been played the amount of times defined in LOOP.CNT
    }

    /// PUBLISH_STOPPED Register bits
    namespace publish_stopped_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event STOPPED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_SEQSTARTED__ Register bits
    namespace publish_seqstarted___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event SEQSTARTED[n] will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_SEQEND__ Register bits
    namespace publish_seqend___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event SEQEND[n] will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_PWMPERIODEND Register bits
    namespace publish_pwmperiodend_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event PWMPERIODEND will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_LOOPSDONE Register bits
    namespace publish_loopsdone_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event LOOPSDONE will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// SHORTS Register bits
    namespace shorts_bits {
        constexpr uint32_t SEQEND0_STOP = (1U << 0);  ///< Shortcut between event SEQEND[0] and task STOP
        constexpr uint32_t SEQEND1_STOP = (1U << 1);  ///< Shortcut between event SEQEND[1] and task STOP
        constexpr uint32_t LOOPSDONE_SEQSTART0 = (1U << 2);  ///< Shortcut between event LOOPSDONE and task SEQSTART[0]
        constexpr uint32_t LOOPSDONE_SEQSTART1 = (1U << 3);  ///< Shortcut between event LOOPSDONE and task SEQSTART[1]
        constexpr uint32_t LOOPSDONE_STOP = (1U << 4);  ///< Shortcut between event LOOPSDONE and task STOP
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Enable or disable interrupt for event STOPPED
        constexpr uint32_t SEQSTARTED0 = (1U << 2);  ///< Enable or disable interrupt for event SEQSTARTED[0]
        constexpr uint32_t SEQSTARTED1 = (1U << 3);  ///< Enable or disable interrupt for event SEQSTARTED[1]
        constexpr uint32_t SEQEND0 = (1U << 4);  ///< Enable or disable interrupt for event SEQEND[0]
        constexpr uint32_t SEQEND1 = (1U << 5);  ///< Enable or disable interrupt for event SEQEND[1]
        constexpr uint32_t PWMPERIODEND = (1U << 6);  ///< Enable or disable interrupt for event PWMPERIODEND
        constexpr uint32_t LOOPSDONE = (1U << 7);  ///< Enable or disable interrupt for event LOOPSDONE
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t SEQSTARTED0 = (1U << 2);  ///< Write '1' to enable interrupt for event SEQSTARTED[0]
        constexpr uint32_t SEQSTARTED1 = (1U << 3);  ///< Write '1' to enable interrupt for event SEQSTARTED[1]
        constexpr uint32_t SEQEND0 = (1U << 4);  ///< Write '1' to enable interrupt for event SEQEND[0]
        constexpr uint32_t SEQEND1 = (1U << 5);  ///< Write '1' to enable interrupt for event SEQEND[1]
        constexpr uint32_t PWMPERIODEND = (1U << 6);  ///< Write '1' to enable interrupt for event PWMPERIODEND
        constexpr uint32_t LOOPSDONE = (1U << 7);  ///< Write '1' to enable interrupt for event LOOPSDONE
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t SEQSTARTED0 = (1U << 2);  ///< Write '1' to disable interrupt for event SEQSTARTED[0]
        constexpr uint32_t SEQSTARTED1 = (1U << 3);  ///< Write '1' to disable interrupt for event SEQSTARTED[1]
        constexpr uint32_t SEQEND0 = (1U << 4);  ///< Write '1' to disable interrupt for event SEQEND[0]
        constexpr uint32_t SEQEND1 = (1U << 5);  ///< Write '1' to disable interrupt for event SEQEND[1]
        constexpr uint32_t PWMPERIODEND = (1U << 6);  ///< Write '1' to disable interrupt for event PWMPERIODEND
        constexpr uint32_t LOOPSDONE = (1U << 7);  ///< Write '1' to disable interrupt for event LOOPSDONE
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable PWM module
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t UPDOWN = (1U << 0);  ///< Selects up mode or up-and-down mode for the counter
    }

    /// COUNTERTOP Register bits
    namespace countertop_bits {
        constexpr uint32_t COUNTERTOP = (15 << 0);  ///< Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used.
    }

    /// PRESCALER Register bits
    namespace prescaler_bits {
        constexpr uint32_t PRESCALER = (3 << 0);  ///< Prescaler of PWM_CLK
    }

    /// DECODER Register bits
    namespace decoder_bits {
        constexpr uint32_t LOAD = (2 << 0);  ///< How a sequence is read from RAM and spread to the compare register
        constexpr uint32_t MODE = (1U << 8);  ///< Selects source for advancing the active sequence
    }

    /// LOOP Register bits
    namespace loop_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Number of playbacks of pattern cycles
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Beginning address in RAM of this sequence
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (15 << 0);  ///< Number of values (duty cycles) in this sequence
    }

    /// REFRESH Register bits
    namespace refresh_bits {
        constexpr uint32_t CNT = (24 << 0);  ///< Number of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)
    }

    /// ENDDELAY Register bits
    namespace enddelay_bits {
        constexpr uint32_t CNT = (24 << 0);  ///< Time added after the sequence in PWM periods
    }

    /// OUT__ Register bits
    namespace out___bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

}

// ============================================================================
// PDM Peripheral
// ============================================================================

namespace pdm {
    /// Base addresses
    constexpr uint32_t PDM_NS_BASE = 0x40026000;
    constexpr uint32_t PDM_S_BASE = 0x50026000;

    /// PDM Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Starts continuous PDM transfer
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stops PDM transfer
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x80 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x84 - Subscribe configuration for task STOP
        volatile uint32_t EVENTS_STARTED;  ///< Offset: 0x100 - PDM transfer has started
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x104 - PDM transfer has finished
        volatile uint32_t EVENTS_END;  ///< Offset: 0x108 - The PDM has written the last sample specified by...
        volatile uint32_t PUBLISH_STARTED;  ///< Offset: 0x180 - Publish configuration for event STARTED
        volatile uint32_t PUBLISH_STOPPED;  ///< Offset: 0x184 - Publish configuration for event STOPPED
        volatile uint32_t PUBLISH_END;  ///< Offset: 0x188 - Publish configuration for event END
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - PDM module enable register
        volatile uint32_t PDMCLKCTRL;  ///< Offset: 0x504 - PDM clock generator control
        volatile uint32_t MODE;  ///< Offset: 0x508 - Defines the routing of the connected PDM microphones' signals
        volatile uint32_t GAINL;  ///< Offset: 0x518 - Left output gain adjustment
        volatile uint32_t GAINR;  ///< Offset: 0x51C - Right output gain adjustment
        volatile uint32_t RATIO;  ///< Offset: 0x520 - Selects the ratio between PDM_CLK and output sample...
        volatile uint32_t CLK;  ///< Offset: 0x00 - Pin number configuration for PDM CLK signal
        volatile uint32_t DIN;  ///< Offset: 0x04 - Pin number configuration for PDM DIN signal
        volatile uint32_t PTR;  ///< Offset: 0x00 - RAM address pointer to write samples to with EasyDMA
        volatile uint32_t MAXCNT;  ///< Offset: 0x04 - Number of samples to allocate memory for in EasyDMA mode
    };

    /// Peripheral instances
    inline Registers* PDM_NS = reinterpret_cast<Registers*>(PDM_NS_BASE);
    inline Registers* PDM_S = reinterpret_cast<Registers*>(PDM_S_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Starts continuous PDM transfer
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stops PDM transfer
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_STARTED Register bits
    namespace events_started_bits {
        constexpr uint32_t EVENTS_STARTED = (1U << 0);  ///< PDM transfer has started
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< PDM transfer has finished
    }

    /// EVENTS_END Register bits
    namespace events_end_bits {
        constexpr uint32_t EVENTS_END = (1U << 0);  ///< The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM
    }

    /// PUBLISH_STARTED Register bits
    namespace publish_started_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event STARTED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_STOPPED Register bits
    namespace publish_stopped_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event STOPPED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_END Register bits
    namespace publish_end_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event END will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Enable or disable interrupt for event STARTED
        constexpr uint32_t STOPPED = (1U << 1);  ///< Enable or disable interrupt for event STOPPED
        constexpr uint32_t END = (1U << 2);  ///< Enable or disable interrupt for event END
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Write '1' to enable interrupt for event STARTED
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t END = (1U << 2);  ///< Write '1' to enable interrupt for event END
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t STARTED = (1U << 0);  ///< Write '1' to disable interrupt for event STARTED
        constexpr uint32_t STOPPED = (1U << 1);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t END = (1U << 2);  ///< Write '1' to disable interrupt for event END
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable PDM module
    }

    /// PDMCLKCTRL Register bits
    namespace pdmclkctrl_bits {
        constexpr uint32_t FREQ = (32 << 0);  ///< PDM_CLK frequency
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t OPERATION = (1U << 0);  ///< Mono or stereo operation
        constexpr uint32_t EDGE = (1U << 1);  ///< Defines on which PDM_CLK edge Left (or mono) is sampled
    }

    /// GAINL Register bits
    namespace gainl_bits {
        constexpr uint32_t GAINL = (7 << 0);  ///< Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00 -20 dB gain adjust 0x01 -19.5 dB gain adjust (...) 0x27 -0.5 dB gain adjust 0x28 0 dB gain adjust 0x29 +0.5 dB gain adjust (...) 0x4F +19.5 dB gain adjust 0x50 +20 dB gain adjust
    }

    /// GAINR Register bits
    namespace gainr_bits {
        constexpr uint32_t GAINR = (7 << 0);  ///< Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)
    }

    /// RATIO Register bits
    namespace ratio_bits {
        constexpr uint32_t RATIO = (1U << 0);  ///< Selects the ratio between PDM_CLK and output sample rate
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// DIN Register bits
    namespace din_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t SAMPLEPTR = (32 << 0);  ///< Address to write PDM samples to over DMA
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t BUFFSIZE = (15 << 0);  ///< Length of DMA RAM allocation in number of samples
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S_NS_BASE = 0x40028000;
    constexpr uint32_t I2S_S_BASE = 0x50028000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t TASKS_START;  ///< Offset: 0x00 - Starts continuous I2S transfer. Also starts MCK...
        volatile uint32_t TASKS_STOP;  ///< Offset: 0x04 - Stops I2S transfer. Also stops MCK generator. Triggering...
        volatile uint32_t SUBSCRIBE_START;  ///< Offset: 0x80 - Subscribe configuration for task START
        volatile uint32_t SUBSCRIBE_STOP;  ///< Offset: 0x84 - Subscribe configuration for task STOP
        volatile uint32_t EVENTS_RXPTRUPD;  ///< Offset: 0x104 - The RXD.PTR register has been copied to internal...
        volatile uint32_t EVENTS_STOPPED;  ///< Offset: 0x108 - I2S transfer stopped.
        volatile uint32_t EVENTS_TXPTRUPD;  ///< Offset: 0x114 - The TDX.PTR register has been copied to internal...
        volatile uint32_t PUBLISH_RXPTRUPD;  ///< Offset: 0x184 - Publish configuration for event RXPTRUPD
        volatile uint32_t PUBLISH_STOPPED;  ///< Offset: 0x188 - Publish configuration for event STOPPED
        volatile uint32_t PUBLISH_TXPTRUPD;  ///< Offset: 0x194 - Publish configuration for event TXPTRUPD
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable I2S module.
        volatile uint32_t MODE;  ///< Offset: 0x00 - I2S mode.
        volatile uint32_t RXEN;  ///< Offset: 0x04 - Reception (RX) enable.
        volatile uint32_t TXEN;  ///< Offset: 0x08 - Transmission (TX) enable.
        volatile uint32_t MCKEN;  ///< Offset: 0x0C - Master clock generator enable.
        volatile uint32_t MCKFREQ;  ///< Offset: 0x10 - Master clock generator frequency.
        volatile uint32_t RATIO;  ///< Offset: 0x14 - MCK / LRCK ratio.
        volatile uint32_t SWIDTH;  ///< Offset: 0x18 - Sample width.
        volatile uint32_t ALIGN;  ///< Offset: 0x1C - Alignment of sample within a frame.
        volatile uint32_t FORMAT;  ///< Offset: 0x20 - Frame format.
        volatile uint32_t CHANNELS;  ///< Offset: 0x24 - Enable channels.
        volatile uint32_t PTR;  ///< Offset: 0x00 - Transmit buffer RAM start address.
        volatile uint32_t MAXCNT;  ///< Offset: 0x00 - Size of RXD and TXD buffers.
        volatile uint32_t MCK;  ///< Offset: 0x00 - Pin select for MCK signal.
        volatile uint32_t SCK;  ///< Offset: 0x04 - Pin select for SCK signal.
        volatile uint32_t LRCK;  ///< Offset: 0x08 - Pin select for LRCK signal.
        volatile uint32_t SDIN;  ///< Offset: 0x0C - Pin select for SDIN signal.
        volatile uint32_t SDOUT;  ///< Offset: 0x10 - Pin select for SDOUT signal.
    };

    /// Peripheral instances
    inline Registers* I2S_NS = reinterpret_cast<Registers*>(I2S_NS_BASE);
    inline Registers* I2S_S = reinterpret_cast<Registers*>(I2S_S_BASE);

    // Bit definitions
    /// TASKS_START Register bits
    namespace tasks_start_bits {
        constexpr uint32_t TASKS_START = (1U << 0);  ///< Starts continuous I2S transfer. Also starts MCK generator when this is enabled.
    }

    /// TASKS_STOP Register bits
    namespace tasks_stop_bits {
        constexpr uint32_t TASKS_STOP = (1U << 0);  ///< Stops I2S transfer. Also stops MCK generator. Triggering this task will cause the STOPPED event to be generated.
    }

    /// SUBSCRIBE_START Register bits
    namespace subscribe_start_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task START will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// SUBSCRIBE_STOP Register bits
    namespace subscribe_stop_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task STOP will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_RXPTRUPD Register bits
    namespace events_rxptrupd_bits {
        constexpr uint32_t EVENTS_RXPTRUPD = (1U << 0);  ///< The RXD.PTR register has been copied to internal double-buffers. When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words that are received on the SDIN pin.
    }

    /// EVENTS_STOPPED Register bits
    namespace events_stopped_bits {
        constexpr uint32_t EVENTS_STOPPED = (1U << 0);  ///< I2S transfer stopped.
    }

    /// EVENTS_TXPTRUPD Register bits
    namespace events_txptrupd_bits {
        constexpr uint32_t EVENTS_TXPTRUPD = (1U << 0);  ///< The TDX.PTR register has been copied to internal double-buffers. When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin.
    }

    /// PUBLISH_RXPTRUPD Register bits
    namespace publish_rxptrupd_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event RXPTRUPD will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_STOPPED Register bits
    namespace publish_stopped_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event STOPPED will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// PUBLISH_TXPTRUPD Register bits
    namespace publish_txptrupd_bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event TXPTRUPD will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t RXPTRUPD = (1U << 1);  ///< Enable or disable interrupt for event RXPTRUPD
        constexpr uint32_t STOPPED = (1U << 2);  ///< Enable or disable interrupt for event STOPPED
        constexpr uint32_t TXPTRUPD = (1U << 5);  ///< Enable or disable interrupt for event TXPTRUPD
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t RXPTRUPD = (1U << 1);  ///< Write '1' to enable interrupt for event RXPTRUPD
        constexpr uint32_t STOPPED = (1U << 2);  ///< Write '1' to enable interrupt for event STOPPED
        constexpr uint32_t TXPTRUPD = (1U << 5);  ///< Write '1' to enable interrupt for event TXPTRUPD
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t RXPTRUPD = (1U << 1);  ///< Write '1' to disable interrupt for event RXPTRUPD
        constexpr uint32_t STOPPED = (1U << 2);  ///< Write '1' to disable interrupt for event STOPPED
        constexpr uint32_t TXPTRUPD = (1U << 5);  ///< Write '1' to disable interrupt for event TXPTRUPD
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable I2S module.
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< I2S mode.
    }

    /// RXEN Register bits
    namespace rxen_bits {
        constexpr uint32_t RXEN = (1U << 0);  ///< Reception (RX) enable.
    }

    /// TXEN Register bits
    namespace txen_bits {
        constexpr uint32_t TXEN = (1U << 0);  ///< Transmission (TX) enable.
    }

    /// MCKEN Register bits
    namespace mcken_bits {
        constexpr uint32_t MCKEN = (1U << 0);  ///< Master clock generator enable.
    }

    /// MCKFREQ Register bits
    namespace mckfreq_bits {
        constexpr uint32_t MCKFREQ = (32 << 0);  ///< Master clock generator frequency.
    }

    /// RATIO Register bits
    namespace ratio_bits {
        constexpr uint32_t RATIO = (4 << 0);  ///< MCK / LRCK ratio.
    }

    /// SWIDTH Register bits
    namespace swidth_bits {
        constexpr uint32_t SWIDTH = (2 << 0);  ///< Sample width.
    }

    /// ALIGN Register bits
    namespace align_bits {
        constexpr uint32_t ALIGN = (1U << 0);  ///< Alignment of sample within a frame.
    }

    /// FORMAT Register bits
    namespace format_bits {
        constexpr uint32_t FORMAT = (1U << 0);  ///< Frame format.
    }

    /// CHANNELS Register bits
    namespace channels_bits {
        constexpr uint32_t CHANNELS = (2 << 0);  ///< Enable channels.
    }

    /// PTR Register bits
    namespace ptr_bits {
        constexpr uint32_t PTR = (32 << 0);  ///< Transmit buffer Data RAM start address. When transmitting, words containing samples will be fetched from this address. This address is a word aligned Data RAM address.
    }

    /// MAXCNT Register bits
    namespace maxcnt_bits {
        constexpr uint32_t MAXCNT = (14 << 0);  ///< Size of RXD and TXD buffers in number of 32 bit words.
    }

    /// MCK Register bits
    namespace mck_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// SCK Register bits
    namespace sck_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// LRCK Register bits
    namespace lrck_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// SDIN Register bits
    namespace sdin_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

    /// SDOUT Register bits
    namespace sdout_bits {
        constexpr uint32_t PIN = (5 << 0);  ///< Pin number
        constexpr uint32_t CONNECT = (1U << 31);  ///< Connection
    }

}

// ============================================================================
// IPC Peripheral
// ============================================================================

namespace ipc {
    /// Base addresses
    constexpr uint32_t IPC_NS_BASE = 0x4002A000;
    constexpr uint32_t IPC_S_BASE = 0x5002A000;

    /// IPC Register structure
    struct Registers {
        volatile uint32_t TASKS_SEND__;  ///< Offset: 0x00 - Description collection: Trigger events on channel... (renamed from TASKS_SEND__)
        volatile uint32_t SUBSCRIBE_SEND__;  ///< Offset: 0x80 - Description collection: Subscribe configuration for task SEND[n] (renamed from SUBSCRIBE_SEND__)
        volatile uint32_t EVENTS_RECEIVE__;  ///< Offset: 0x100 - Description collection: Event received on one or more of... (renamed from EVENTS_RECEIVE__)
        volatile uint32_t PUBLISH_RECEIVE__;  ///< Offset: 0x180 - Description collection: Publish configuration for event... (renamed from PUBLISH_RECEIVE__)
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t INTPEND;  ///< Offset: 0x30C - Pending interrupts
        volatile uint32_t SEND_CNF__;  ///< Offset: 0x510 - Description collection: Send event configuration for... (renamed from SEND_CNF__)
        volatile uint32_t RECEIVE_CNF__;  ///< Offset: 0x590 - Description collection: Receive event configuration for... (renamed from RECEIVE_CNF__)
        volatile uint32_t GPMEM__;  ///< Offset: 0x610 - Description collection: General purpose memory. (renamed from GPMEM__)
    };

    /// Peripheral instances
    inline Registers* IPC_NS = reinterpret_cast<Registers*>(IPC_NS_BASE);
    inline Registers* IPC_S = reinterpret_cast<Registers*>(IPC_S_BASE);

    // Bit definitions
    /// TASKS_SEND__ Register bits
    namespace tasks_send___bits {
        constexpr uint32_t TASKS_SEND = (1U << 0);  ///< Trigger events on channel enabled in SEND_CNF[n].
    }

    /// SUBSCRIBE_SEND__ Register bits
    namespace subscribe_send___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that task SEND[n] will subscribe to
        constexpr uint32_t EN = (1U << 31);  ///< Disable subscription
    }

    /// EVENTS_RECEIVE__ Register bits
    namespace events_receive___bits {
        constexpr uint32_t EVENTS_RECEIVE = (1U << 0);  ///< Event received on one or more of the enabled channels in RECEIVE_CNF[n].
    }

    /// PUBLISH_RECEIVE__ Register bits
    namespace publish_receive___bits {
        constexpr uint32_t CHIDX = (4 << 0);  ///< Channel that event RECEIVE[n] will publish to.
        constexpr uint32_t EN = (1U << 31);  ///< Disable publishing
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t RECEIVE0 = (1U << 0);  ///< Enable or disable interrupt for event RECEIVE[0]
        constexpr uint32_t RECEIVE1 = (1U << 1);  ///< Enable or disable interrupt for event RECEIVE[1]
        constexpr uint32_t RECEIVE2 = (1U << 2);  ///< Enable or disable interrupt for event RECEIVE[2]
        constexpr uint32_t RECEIVE3 = (1U << 3);  ///< Enable or disable interrupt for event RECEIVE[3]
        constexpr uint32_t RECEIVE4 = (1U << 4);  ///< Enable or disable interrupt for event RECEIVE[4]
        constexpr uint32_t RECEIVE5 = (1U << 5);  ///< Enable or disable interrupt for event RECEIVE[5]
        constexpr uint32_t RECEIVE6 = (1U << 6);  ///< Enable or disable interrupt for event RECEIVE[6]
        constexpr uint32_t RECEIVE7 = (1U << 7);  ///< Enable or disable interrupt for event RECEIVE[7]
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t RECEIVE0 = (1U << 0);  ///< Write '1' to enable interrupt for event RECEIVE[0]
        constexpr uint32_t RECEIVE1 = (1U << 1);  ///< Write '1' to enable interrupt for event RECEIVE[1]
        constexpr uint32_t RECEIVE2 = (1U << 2);  ///< Write '1' to enable interrupt for event RECEIVE[2]
        constexpr uint32_t RECEIVE3 = (1U << 3);  ///< Write '1' to enable interrupt for event RECEIVE[3]
        constexpr uint32_t RECEIVE4 = (1U << 4);  ///< Write '1' to enable interrupt for event RECEIVE[4]
        constexpr uint32_t RECEIVE5 = (1U << 5);  ///< Write '1' to enable interrupt for event RECEIVE[5]
        constexpr uint32_t RECEIVE6 = (1U << 6);  ///< Write '1' to enable interrupt for event RECEIVE[6]
        constexpr uint32_t RECEIVE7 = (1U << 7);  ///< Write '1' to enable interrupt for event RECEIVE[7]
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t RECEIVE0 = (1U << 0);  ///< Write '1' to disable interrupt for event RECEIVE[0]
        constexpr uint32_t RECEIVE1 = (1U << 1);  ///< Write '1' to disable interrupt for event RECEIVE[1]
        constexpr uint32_t RECEIVE2 = (1U << 2);  ///< Write '1' to disable interrupt for event RECEIVE[2]
        constexpr uint32_t RECEIVE3 = (1U << 3);  ///< Write '1' to disable interrupt for event RECEIVE[3]
        constexpr uint32_t RECEIVE4 = (1U << 4);  ///< Write '1' to disable interrupt for event RECEIVE[4]
        constexpr uint32_t RECEIVE5 = (1U << 5);  ///< Write '1' to disable interrupt for event RECEIVE[5]
        constexpr uint32_t RECEIVE6 = (1U << 6);  ///< Write '1' to disable interrupt for event RECEIVE[6]
        constexpr uint32_t RECEIVE7 = (1U << 7);  ///< Write '1' to disable interrupt for event RECEIVE[7]
    }

    /// INTPEND Register bits
    namespace intpend_bits {
        constexpr uint32_t RECEIVE0 = (1U << 0);  ///< Read pending status of interrupt for event RECEIVE[0]
        constexpr uint32_t RECEIVE1 = (1U << 1);  ///< Read pending status of interrupt for event RECEIVE[1]
        constexpr uint32_t RECEIVE2 = (1U << 2);  ///< Read pending status of interrupt for event RECEIVE[2]
        constexpr uint32_t RECEIVE3 = (1U << 3);  ///< Read pending status of interrupt for event RECEIVE[3]
        constexpr uint32_t RECEIVE4 = (1U << 4);  ///< Read pending status of interrupt for event RECEIVE[4]
        constexpr uint32_t RECEIVE5 = (1U << 5);  ///< Read pending status of interrupt for event RECEIVE[5]
        constexpr uint32_t RECEIVE6 = (1U << 6);  ///< Read pending status of interrupt for event RECEIVE[6]
        constexpr uint32_t RECEIVE7 = (1U << 7);  ///< Read pending status of interrupt for event RECEIVE[7]
    }

    /// SEND_CNF__ Register bits
    namespace send_cnf___bits {
        constexpr uint32_t CHEN0 = (1U << 0);  ///< Enable broadcasting on channel 0.
        constexpr uint32_t CHEN1 = (1U << 1);  ///< Enable broadcasting on channel 1.
        constexpr uint32_t CHEN2 = (1U << 2);  ///< Enable broadcasting on channel 2.
        constexpr uint32_t CHEN3 = (1U << 3);  ///< Enable broadcasting on channel 3.
        constexpr uint32_t CHEN4 = (1U << 4);  ///< Enable broadcasting on channel 4.
        constexpr uint32_t CHEN5 = (1U << 5);  ///< Enable broadcasting on channel 5.
        constexpr uint32_t CHEN6 = (1U << 6);  ///< Enable broadcasting on channel 6.
        constexpr uint32_t CHEN7 = (1U << 7);  ///< Enable broadcasting on channel 7.
    }

    /// RECEIVE_CNF__ Register bits
    namespace receive_cnf___bits {
        constexpr uint32_t CHEN0 = (1U << 0);  ///< Enable subscription to channel 0.
        constexpr uint32_t CHEN1 = (1U << 1);  ///< Enable subscription to channel 1.
        constexpr uint32_t CHEN2 = (1U << 2);  ///< Enable subscription to channel 2.
        constexpr uint32_t CHEN3 = (1U << 3);  ///< Enable subscription to channel 3.
        constexpr uint32_t CHEN4 = (1U << 4);  ///< Enable subscription to channel 4.
        constexpr uint32_t CHEN5 = (1U << 5);  ///< Enable subscription to channel 5.
        constexpr uint32_t CHEN6 = (1U << 6);  ///< Enable subscription to channel 6.
        constexpr uint32_t CHEN7 = (1U << 7);  ///< Enable subscription to channel 7.
    }

    /// GPMEM__ Register bits
    namespace gpmem___bits {
        constexpr uint32_t GPMEM = (32 << 0);  ///< General purpose memory
    }

}

// ============================================================================
// FPU Peripheral
// ============================================================================

namespace fpu {
    /// Base addresses
    constexpr uint32_t FPU_NS_BASE = 0x4002C000;
    constexpr uint32_t FPU_S_BASE = 0x5002C000;

    /// FPU Register structure
    struct Registers {
        volatile uint32_t UNUSED;  ///< Offset: 0x00 - Unused.
    };

    /// Peripheral instances
    inline Registers* FPU_NS = reinterpret_cast<Registers*>(FPU_NS_BASE);
    inline Registers* FPU_S = reinterpret_cast<Registers*>(FPU_S_BASE);

}

// ============================================================================
// KMU Peripheral
// ============================================================================

namespace kmu {
    /// Base addresses
    constexpr uint32_t KMU_NS_BASE = 0x40039000;
    constexpr uint32_t KMU_S_BASE = 0x50039000;

    /// KMU Register structure
    struct Registers {
        volatile uint32_t TASKS_PUSH_KEYSLOT;  ///< Offset: 0x00 - Push a key slot over secure APB
        volatile uint32_t EVENTS_KEYSLOT_PUSHED;  ///< Offset: 0x100 - Key slot successfully pushed over secure APB
        volatile uint32_t EVENTS_KEYSLOT_REVOKED;  ///< Offset: 0x104 - Key slot has been revoked and cannot be tasked for selection
        volatile uint32_t EVENTS_KEYSLOT_ERROR;  ///< Offset: 0x108 - No key slot selected, no destination address defined, or...
        volatile uint32_t INTEN;  ///< Offset: 0x300 - Enable or disable interrupt
        volatile uint32_t INTENSET;  ///< Offset: 0x304 - Enable interrupt
        volatile uint32_t INTENCLR;  ///< Offset: 0x308 - Disable interrupt
        volatile uint32_t INTPEND;  ///< Offset: 0x30C - Pending interrupts
        volatile uint32_t STATUS;  ///< Offset: 0x40C - Status bits for KMU operation
        volatile uint32_t SELECTKEYSLOT;  ///< Offset: 0x500 - Select key slot to be read over AHB or pushed over...
    };

    /// Peripheral instances
    inline Registers* KMU_NS = reinterpret_cast<Registers*>(KMU_NS_BASE);
    inline Registers* KMU_S = reinterpret_cast<Registers*>(KMU_S_BASE);

    // Bit definitions
    /// TASKS_PUSH_KEYSLOT Register bits
    namespace tasks_push_keyslot_bits {
        constexpr uint32_t TASKS_PUSH_KEYSLOT = (1U << 0);  ///< Push a key slot over secure APB
    }

    /// EVENTS_KEYSLOT_PUSHED Register bits
    namespace events_keyslot_pushed_bits {
        constexpr uint32_t EVENTS_KEYSLOT_PUSHED = (1U << 0);  ///< Key slot successfully pushed over secure APB
    }

    /// EVENTS_KEYSLOT_REVOKED Register bits
    namespace events_keyslot_revoked_bits {
        constexpr uint32_t EVENTS_KEYSLOT_REVOKED = (1U << 0);  ///< Key slot has been revoked and cannot be tasked for selection
    }

    /// EVENTS_KEYSLOT_ERROR Register bits
    namespace events_keyslot_error_bits {
        constexpr uint32_t EVENTS_KEYSLOT_ERROR = (1U << 0);  ///< No key slot selected, no destination address defined, or error during push operation
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t KEYSLOT_PUSHED = (1U << 0);  ///< Enable or disable interrupt for event KEYSLOT_PUSHED
        constexpr uint32_t KEYSLOT_REVOKED = (1U << 1);  ///< Enable or disable interrupt for event KEYSLOT_REVOKED
        constexpr uint32_t KEYSLOT_ERROR = (1U << 2);  ///< Enable or disable interrupt for event KEYSLOT_ERROR
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t KEYSLOT_PUSHED = (1U << 0);  ///< Write '1' to enable interrupt for event KEYSLOT_PUSHED
        constexpr uint32_t KEYSLOT_REVOKED = (1U << 1);  ///< Write '1' to enable interrupt for event KEYSLOT_REVOKED
        constexpr uint32_t KEYSLOT_ERROR = (1U << 2);  ///< Write '1' to enable interrupt for event KEYSLOT_ERROR
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t KEYSLOT_PUSHED = (1U << 0);  ///< Write '1' to disable interrupt for event KEYSLOT_PUSHED
        constexpr uint32_t KEYSLOT_REVOKED = (1U << 1);  ///< Write '1' to disable interrupt for event KEYSLOT_REVOKED
        constexpr uint32_t KEYSLOT_ERROR = (1U << 2);  ///< Write '1' to disable interrupt for event KEYSLOT_ERROR
    }

    /// INTPEND Register bits
    namespace intpend_bits {
        constexpr uint32_t KEYSLOT_PUSHED = (1U << 0);  ///< Read pending status of interrupt for event KEYSLOT_PUSHED
        constexpr uint32_t KEYSLOT_REVOKED = (1U << 1);  ///< Read pending status of interrupt for event KEYSLOT_REVOKED
        constexpr uint32_t KEYSLOT_ERROR = (1U << 2);  ///< Read pending status of interrupt for event KEYSLOT_ERROR
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SELECTED = (1U << 0);  ///< Key slot ID successfully selected by the KMU
        constexpr uint32_t BLOCKED = (1U << 1);  ///< Violation status
    }

    /// SELECTKEYSLOT Register bits
    namespace selectkeyslot_bits {
        constexpr uint32_t ID = (8 << 0);  ///< Select key slot ID to be read over AHB, or pushed over secure APB, when TASKS_PUSH_KEYSLOT is started NOTE: ID=0 is not a valid key slot ID. The 0 ID should be used when the KMU is idle or not in use NOTE: Index N in UICR-&gt;KEYSLOT.KEY[N] and UICR-&gt;KEYSLOT.CONFIG[N] corresponds to KMU key slot ID=N+1
    }

}

// ============================================================================
// NVMC Peripheral
// ============================================================================

namespace nvmc {
    /// Base addresses
    constexpr uint32_t NVMC_NS_BASE = 0x40039000;
    constexpr uint32_t NVMC_S_BASE = 0x50039000;

    /// NVMC Register structure
    struct Registers {
        volatile uint32_t READY;  ///< Offset: 0x400 - Ready flag
        volatile uint32_t READYNEXT;  ///< Offset: 0x408 - Ready flag
        volatile uint32_t CONFIG;  ///< Offset: 0x504 - Configuration register
        volatile uint32_t ERASEALL;  ///< Offset: 0x50C - Register for erasing all non-volatile user memory
        volatile uint32_t ERASEPAGEPARTIALCFG;  ///< Offset: 0x51C - Register for partial erase configuration
        volatile uint32_t ICACHECNF;  ///< Offset: 0x540 - I-code cache configuration register
        volatile uint32_t IHIT;  ///< Offset: 0x548 - I-code cache hit counter
        volatile uint32_t IMISS;  ///< Offset: 0x54C - I-code cache miss counter
        volatile uint32_t CONFIGNS;  ///< Offset: 0x584 - Unspecified
        volatile uint32_t WRITEUICRNS;  ///< Offset: 0x588 - Non-secure APPROTECT enable register
    };

    /// Peripheral instances
    inline Registers* NVMC_NS = reinterpret_cast<Registers*>(NVMC_NS_BASE);
    inline Registers* NVMC_S = reinterpret_cast<Registers*>(NVMC_S_BASE);

    // Bit definitions
    /// READY Register bits
    namespace ready_bits {
        constexpr uint32_t READY = (1U << 0);  ///< NVMC is ready or busy
    }

    /// READYNEXT Register bits
    namespace readynext_bits {
        constexpr uint32_t READYNEXT = (1U << 0);  ///< NVMC can accept a new write operation
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t WEN = (3 << 0);  ///< Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated.
    }

    /// ERASEALL Register bits
    namespace eraseall_bits {
        constexpr uint32_t ERASEALL = (1U << 0);  ///< Erase all non-volatile memory including UICR registers. Note that erasing must be enabled by setting CONFIG.WEN = Een before the non-volatile memory can be erased.
    }

    /// ERASEPAGEPARTIALCFG Register bits
    namespace erasepagepartialcfg_bits {
        constexpr uint32_t DURATION = (7 << 0);  ///< Duration of the partial erase in milliseconds
    }

    /// ICACHECNF Register bits
    namespace icachecnf_bits {
        constexpr uint32_t CACHEEN = (1U << 0);  ///< Cache enable
        constexpr uint32_t CACHEPROFEN = (1U << 8);  ///< Cache profiling enable
    }

    /// IHIT Register bits
    namespace ihit_bits {
        constexpr uint32_t HITS = (32 << 0);  ///< Number of cache hits Write zero to clear
    }

    /// IMISS Register bits
    namespace imiss_bits {
        constexpr uint32_t MISSES = (32 << 0);  ///< Number of cache misses Write zero to clear
    }

    /// CONFIGNS Register bits
    namespace configns_bits {
        constexpr uint32_t WEN = (2 << 0);  ///< Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated.
    }

    /// WRITEUICRNS Register bits
    namespace writeuicrns_bits {
        constexpr uint32_t SET = (1U << 0);  ///< Allow non-secure code to set APPROTECT
        constexpr uint32_t KEY = (28 << 4);  ///< Key to write in order to validate the write operation
    }

}

// ============================================================================
// VMC Peripheral
// ============================================================================

namespace vmc {
    /// Base addresses
    constexpr uint32_t VMC_NS_BASE = 0x4003A000;
    constexpr uint32_t VMC_S_BASE = 0x5003A000;

    /// VMC Register structure
    struct Registers {
        volatile uint32_t POWER;  ///< Offset: 0x00 - Description cluster: RAMn power control register
        volatile uint32_t POWERSET;  ///< Offset: 0x04 - Description cluster: RAMn power control set register
        volatile uint32_t POWERCLR;  ///< Offset: 0x08 - Description cluster: RAMn power control clear register
    };

    /// Peripheral instances
    inline Registers* VMC_NS = reinterpret_cast<Registers*>(VMC_NS_BASE);
    inline Registers* VMC_S = reinterpret_cast<Registers*>(VMC_S_BASE);

    // Bit definitions
    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t S0POWER = (1U << 0);  ///< Keep RAM section S0 of RAM n on or off in System ON mode
        constexpr uint32_t S1POWER = (1U << 1);  ///< Keep RAM section S1 of RAM n on or off in System ON mode
        constexpr uint32_t S2POWER = (1U << 2);  ///< Keep RAM section S2 of RAM n on or off in System ON mode
        constexpr uint32_t S3POWER = (1U << 3);  ///< Keep RAM section S3 of RAM n on or off in System ON mode
        constexpr uint32_t S0RETENTION = (1U << 16);  ///< Keep retention on RAM section S0 of RAM n when RAM section is switched off
        constexpr uint32_t S1RETENTION = (1U << 17);  ///< Keep retention on RAM section S1 of RAM n when RAM section is switched off
        constexpr uint32_t S2RETENTION = (1U << 18);  ///< Keep retention on RAM section S2 of RAM n when RAM section is switched off
        constexpr uint32_t S3RETENTION = (1U << 19);  ///< Keep retention on RAM section S3 of RAM n when RAM section is switched off
    }

    /// POWERSET Register bits
    namespace powerset_bits {
        constexpr uint32_t S0POWER = (1U << 0);  ///< Keep RAM section S0 of RAM n on or off in System ON mode
        constexpr uint32_t S1POWER = (1U << 1);  ///< Keep RAM section S1 of RAM n on or off in System ON mode
        constexpr uint32_t S2POWER = (1U << 2);  ///< Keep RAM section S2 of RAM n on or off in System ON mode
        constexpr uint32_t S3POWER = (1U << 3);  ///< Keep RAM section S3 of RAM n on or off in System ON mode
        constexpr uint32_t S0RETENTION = (1U << 16);  ///< Keep retention on RAM section S0 of RAM n when RAM section is switched off
        constexpr uint32_t S1RETENTION = (1U << 17);  ///< Keep retention on RAM section S1 of RAM n when RAM section is switched off
        constexpr uint32_t S2RETENTION = (1U << 18);  ///< Keep retention on RAM section S2 of RAM n when RAM section is switched off
        constexpr uint32_t S3RETENTION = (1U << 19);  ///< Keep retention on RAM section S3 of RAM n when RAM section is switched off
    }

    /// POWERCLR Register bits
    namespace powerclr_bits {
        constexpr uint32_t S0POWER = (1U << 0);  ///< Keep RAM section S0 of RAM n on or off in System ON mode
        constexpr uint32_t S1POWER = (1U << 1);  ///< Keep RAM section S1 of RAM n on or off in System ON mode
        constexpr uint32_t S2POWER = (1U << 2);  ///< Keep RAM section S2 of RAM n on or off in System ON mode
        constexpr uint32_t S3POWER = (1U << 3);  ///< Keep RAM section S3 of RAM n on or off in System ON mode
        constexpr uint32_t S0RETENTION = (1U << 16);  ///< Keep retention on RAM section S0 of RAM n when RAM section is switched off
        constexpr uint32_t S1RETENTION = (1U << 17);  ///< Keep retention on RAM section S1 of RAM n when RAM section is switched off
        constexpr uint32_t S2RETENTION = (1U << 18);  ///< Keep retention on RAM section S2 of RAM n when RAM section is switched off
        constexpr uint32_t S3RETENTION = (1U << 19);  ///< Keep retention on RAM section S3 of RAM n when RAM section is switched off
    }

}

// ============================================================================
// CC Peripheral
// ============================================================================

namespace cc {
    /// Base addresses
    constexpr uint32_t CC_HOST_RGF_S_BASE = 0x50840000;

    /// CC Register structure
    struct Registers {
        volatile uint32_t HOST_CRYPTOKEY_SEL;  ///< Offset: 0x1A38 - AES hardware key select
        volatile uint32_t HOST_IOT_KPRTL_LOCK;  ///< Offset: 0x1A4C - This write-once register is the K_PRTL lock register....
        volatile uint32_t HOST_IOT_KDR0;  ///< Offset: 0x1A50 - This register holds bits 31:0 of K_DR. The value of this...
        volatile uint32_t HOST_IOT_KDR1;  ///< Offset: 0x1A54 - This register holds bits 63:32 of K_DR. The value of...
        volatile uint32_t HOST_IOT_KDR2;  ///< Offset: 0x1A58 - This register holds bits 95:64 of K_DR. The value of...
        volatile uint32_t HOST_IOT_KDR3;  ///< Offset: 0x1A5C - This register holds bits 127:96 of K_DR. The value of...
        volatile uint32_t HOST_IOT_LCS;  ///< Offset: 0x1A60 - Controls lifecycle state (LCS) for CRYPTOCELL subsystem
    };

    /// Peripheral instances
    inline Registers* CC_HOST_RGF_S = reinterpret_cast<Registers*>(CC_HOST_RGF_S_BASE);

    // Bit definitions
    /// HOST_CRYPTOKEY_SEL Register bits
    namespace host_cryptokey_sel_bits {
        constexpr uint32_t HOST_CRYPTOKEY_SEL = (2 << 0);  ///< Select the source of the HW key that is used by the AES engine
    }

    /// HOST_IOT_KPRTL_LOCK Register bits
    namespace host_iot_kprtl_lock_bits {
        constexpr uint32_t HOST_IOT_KPRTL_LOCK = (1U << 0);  ///< This register is the K_PRTL lock register. When this register is set, K_PRTL cannot be used and a zeroed key will be used instead. The value of this register is saved in the CRYPTOCELL AO power domain.
    }

    /// HOST_IOT_KDR0 Register bits
    namespace host_iot_kdr0_bits {
        constexpr uint32_t HOST_IOT_KDR0 = (32 << 0);  ///< Write: K_DR bits 31:0. Read: 0x00000000 when 128-bit K_DR key value is not yet retained in the CRYPTOCELL AO power domain. Read: 0x00000001 when 128-bit K_DR key value is successfully retained in the CRYPTOCELL AO power domain.
    }

    /// HOST_IOT_KDR1 Register bits
    namespace host_iot_kdr1_bits {
        constexpr uint32_t HOST_IOT_KDR1 = (32 << 0);  ///< K_DR bits 63:32
    }

    /// HOST_IOT_KDR2 Register bits
    namespace host_iot_kdr2_bits {
        constexpr uint32_t HOST_IOT_KDR2 = (32 << 0);  ///< K_DR bits 95:64
    }

    /// HOST_IOT_KDR3 Register bits
    namespace host_iot_kdr3_bits {
        constexpr uint32_t HOST_IOT_KDR3 = (32 << 0);  ///< K_DR bits 127:96
    }

    /// HOST_IOT_LCS Register bits
    namespace host_iot_lcs_bits {
        constexpr uint32_t LCS = (3 << 0);  ///< Lifecycle state value. This field is write-once per reset.
        constexpr uint32_t LCS_IS_VALID = (1U << 8);  ///< Read-only field. Indicates if CRYPTOCELL LCS has been successfully configured since last reset.
    }

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t CRYPTOCELL_S_BASE = 0x50840000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t ENABLE;  ///< Offset: 0x500 - Enable CRYPTOCELL subsystem
    };

    /// Peripheral instances
    inline Registers* CRYPTOCELL_S = reinterpret_cast<Registers*>(CRYPTOCELL_S_BASE);

    // Bit definitions
    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable or disable the CRYPTOCELL subsystem
    }

}

// ============================================================================
// P0 Peripheral
// ============================================================================

namespace p0 {
    /// Base addresses
    constexpr uint32_t P0_NS_BASE = 0x40842500;
    constexpr uint32_t P0_S_BASE = 0x50842500;

    /// P0 Register structure
    struct Registers {
        volatile uint32_t OUT;  ///< Offset: 0x04 - Write GPIO port
        volatile uint32_t OUTSET;  ///< Offset: 0x08 - Set individual bits in GPIO port
        volatile uint32_t OUTCLR;  ///< Offset: 0x0C - Clear individual bits in GPIO port
        volatile uint32_t IN;  ///< Offset: 0x10 - Read GPIO port
        volatile uint32_t DIR;  ///< Offset: 0x14 - Direction of GPIO pins
        volatile uint32_t DIRSET;  ///< Offset: 0x18 - DIR set register
        volatile uint32_t DIRCLR;  ///< Offset: 0x1C - DIR clear register
        volatile uint32_t LATCH;  ///< Offset: 0x20 - Latch register indicating what GPIO pins that have met...
        volatile uint32_t DETECTMODE;  ///< Offset: 0x24 - Select between default DETECT signal behavior and...
        volatile uint32_t DETECTMODE_SEC;  ///< Offset: 0x28 - Select between default DETECT signal behavior and...
        volatile uint32_t PIN_CNF__;  ///< Offset: 0x200 - Description collection: Configuration of GPIO pins (renamed from PIN_CNF__)
    };

    /// Peripheral instances
    inline Registers* P0_NS = reinterpret_cast<Registers*>(P0_NS_BASE);
    inline Registers* P0_S = reinterpret_cast<Registers*>(P0_S_BASE);

    // Bit definitions
    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// OUTSET Register bits
    namespace outset_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// OUTCLR Register bits
    namespace outclr_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// DIR Register bits
    namespace dir_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Pin 31
    }

    /// DIRSET Register bits
    namespace dirset_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Set as output pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Set as output pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Set as output pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Set as output pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Set as output pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Set as output pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Set as output pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Set as output pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Set as output pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Set as output pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Set as output pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Set as output pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Set as output pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Set as output pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Set as output pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Set as output pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Set as output pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Set as output pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Set as output pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Set as output pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Set as output pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Set as output pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Set as output pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Set as output pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Set as output pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Set as output pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Set as output pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Set as output pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Set as output pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Set as output pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Set as output pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Set as output pin 31
    }

    /// DIRCLR Register bits
    namespace dirclr_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Set as input pin 0
        constexpr uint32_t PIN1 = (1U << 1);  ///< Set as input pin 1
        constexpr uint32_t PIN2 = (1U << 2);  ///< Set as input pin 2
        constexpr uint32_t PIN3 = (1U << 3);  ///< Set as input pin 3
        constexpr uint32_t PIN4 = (1U << 4);  ///< Set as input pin 4
        constexpr uint32_t PIN5 = (1U << 5);  ///< Set as input pin 5
        constexpr uint32_t PIN6 = (1U << 6);  ///< Set as input pin 6
        constexpr uint32_t PIN7 = (1U << 7);  ///< Set as input pin 7
        constexpr uint32_t PIN8 = (1U << 8);  ///< Set as input pin 8
        constexpr uint32_t PIN9 = (1U << 9);  ///< Set as input pin 9
        constexpr uint32_t PIN10 = (1U << 10);  ///< Set as input pin 10
        constexpr uint32_t PIN11 = (1U << 11);  ///< Set as input pin 11
        constexpr uint32_t PIN12 = (1U << 12);  ///< Set as input pin 12
        constexpr uint32_t PIN13 = (1U << 13);  ///< Set as input pin 13
        constexpr uint32_t PIN14 = (1U << 14);  ///< Set as input pin 14
        constexpr uint32_t PIN15 = (1U << 15);  ///< Set as input pin 15
        constexpr uint32_t PIN16 = (1U << 16);  ///< Set as input pin 16
        constexpr uint32_t PIN17 = (1U << 17);  ///< Set as input pin 17
        constexpr uint32_t PIN18 = (1U << 18);  ///< Set as input pin 18
        constexpr uint32_t PIN19 = (1U << 19);  ///< Set as input pin 19
        constexpr uint32_t PIN20 = (1U << 20);  ///< Set as input pin 20
        constexpr uint32_t PIN21 = (1U << 21);  ///< Set as input pin 21
        constexpr uint32_t PIN22 = (1U << 22);  ///< Set as input pin 22
        constexpr uint32_t PIN23 = (1U << 23);  ///< Set as input pin 23
        constexpr uint32_t PIN24 = (1U << 24);  ///< Set as input pin 24
        constexpr uint32_t PIN25 = (1U << 25);  ///< Set as input pin 25
        constexpr uint32_t PIN26 = (1U << 26);  ///< Set as input pin 26
        constexpr uint32_t PIN27 = (1U << 27);  ///< Set as input pin 27
        constexpr uint32_t PIN28 = (1U << 28);  ///< Set as input pin 28
        constexpr uint32_t PIN29 = (1U << 29);  ///< Set as input pin 29
        constexpr uint32_t PIN30 = (1U << 30);  ///< Set as input pin 30
        constexpr uint32_t PIN31 = (1U << 31);  ///< Set as input pin 31
    }

    /// LATCH Register bits
    namespace latch_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< Status on whether PIN0 has met criteria set in PIN_CNF0.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN1 = (1U << 1);  ///< Status on whether PIN1 has met criteria set in PIN_CNF1.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN2 = (1U << 2);  ///< Status on whether PIN2 has met criteria set in PIN_CNF2.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN3 = (1U << 3);  ///< Status on whether PIN3 has met criteria set in PIN_CNF3.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN4 = (1U << 4);  ///< Status on whether PIN4 has met criteria set in PIN_CNF4.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN5 = (1U << 5);  ///< Status on whether PIN5 has met criteria set in PIN_CNF5.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN6 = (1U << 6);  ///< Status on whether PIN6 has met criteria set in PIN_CNF6.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN7 = (1U << 7);  ///< Status on whether PIN7 has met criteria set in PIN_CNF7.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN8 = (1U << 8);  ///< Status on whether PIN8 has met criteria set in PIN_CNF8.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN9 = (1U << 9);  ///< Status on whether PIN9 has met criteria set in PIN_CNF9.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN10 = (1U << 10);  ///< Status on whether PIN10 has met criteria set in PIN_CNF10.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN11 = (1U << 11);  ///< Status on whether PIN11 has met criteria set in PIN_CNF11.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN12 = (1U << 12);  ///< Status on whether PIN12 has met criteria set in PIN_CNF12.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN13 = (1U << 13);  ///< Status on whether PIN13 has met criteria set in PIN_CNF13.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN14 = (1U << 14);  ///< Status on whether PIN14 has met criteria set in PIN_CNF14.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN15 = (1U << 15);  ///< Status on whether PIN15 has met criteria set in PIN_CNF15.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN16 = (1U << 16);  ///< Status on whether PIN16 has met criteria set in PIN_CNF16.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN17 = (1U << 17);  ///< Status on whether PIN17 has met criteria set in PIN_CNF17.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN18 = (1U << 18);  ///< Status on whether PIN18 has met criteria set in PIN_CNF18.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN19 = (1U << 19);  ///< Status on whether PIN19 has met criteria set in PIN_CNF19.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN20 = (1U << 20);  ///< Status on whether PIN20 has met criteria set in PIN_CNF20.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN21 = (1U << 21);  ///< Status on whether PIN21 has met criteria set in PIN_CNF21.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN22 = (1U << 22);  ///< Status on whether PIN22 has met criteria set in PIN_CNF22.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN23 = (1U << 23);  ///< Status on whether PIN23 has met criteria set in PIN_CNF23.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN24 = (1U << 24);  ///< Status on whether PIN24 has met criteria set in PIN_CNF24.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN25 = (1U << 25);  ///< Status on whether PIN25 has met criteria set in PIN_CNF25.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN26 = (1U << 26);  ///< Status on whether PIN26 has met criteria set in PIN_CNF26.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN27 = (1U << 27);  ///< Status on whether PIN27 has met criteria set in PIN_CNF27.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN28 = (1U << 28);  ///< Status on whether PIN28 has met criteria set in PIN_CNF28.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN29 = (1U << 29);  ///< Status on whether PIN29 has met criteria set in PIN_CNF29.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN30 = (1U << 30);  ///< Status on whether PIN30 has met criteria set in PIN_CNF30.SENSE register. Write '1' to clear.
        constexpr uint32_t PIN31 = (1U << 31);  ///< Status on whether PIN31 has met criteria set in PIN_CNF31.SENSE register. Write '1' to clear.
    }

    /// DETECTMODE Register bits
    namespace detectmode_bits {
        constexpr uint32_t DETECTMODE = (1U << 0);  ///< Select between default DETECT signal behavior and LDETECT mode
    }

    /// DETECTMODE_SEC Register bits
    namespace detectmode_sec_bits {
        constexpr uint32_t DETECTMODE = (1U << 0);  ///< Select between default DETECT signal behavior and LDETECT mode
    }

    /// PIN_CNF__ Register bits
    namespace pin_cnf___bits {
        constexpr uint32_t DIR = (1U << 0);  ///< Pin direction. Same physical register as DIR register
        constexpr uint32_t INPUT = (1U << 1);  ///< Connect or disconnect input buffer
        constexpr uint32_t PULL = (2 << 2);  ///< Pull configuration
        constexpr uint32_t DRIVE = (3 << 8);  ///< Drive configuration
        constexpr uint32_t SENSE = (2 << 16);  ///< Pin sensing mechanism
    }

}


} // namespace alloy::generated::nrf9160

#endif // ALLOY_GENERATED_NRF9160_PERIPHERALS_HPP