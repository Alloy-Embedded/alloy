/// Auto-generated code for QN908XC
/// Generated by Alloy Code Generator
/// Source: nxp_qn908xc.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:21:29
#ifndef ALLOY_GENERATED_QN908XC_PERIPHERALS_HPP
#define ALLOY_GENERATED_QN908XC_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::qn908xc {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// SYSCON Peripheral
// ============================================================================

namespace syscon {
    /// Base addresses
    constexpr uint32_t SYSCON_BASE = 0x40000000;

    /// SYSCON Register structure
    struct Registers {
        volatile uint32_t RST_SW_SET;  ///< Offset: 0x00 - block software reset set register
        volatile uint32_t RST_SW_CLR;  ///< Offset: 0x04 - block software reset clear register
        volatile uint32_t CLK_DIS;  ///< Offset: 0x08 - clock disable register
        volatile uint32_t CLK_EN;  ///< Offset: 0x0C - clock enable register
        volatile uint32_t CLK_CTRL;  ///< Offset: 0x10 - system clock source and divider register
        volatile uint32_t SYS_MODE_CTRL;  ///< Offset: 0x14 - system mode and address remap register
        volatile uint32_t SYS_STAT;  ///< Offset: 0x80 - system status register
        volatile uint32_t SYS_TICK;  ///< Offset: 0x100 - systick timer control register
        volatile uint32_t SRAM_CTRL;  ///< Offset: 0x104 - Exchange memory base address register
        volatile uint32_t CHIP_ID;  ///< Offset: 0x108 - chip id register
        volatile uint32_t ANA_CTRL0;  ///< Offset: 0x110 - crystal and PA register
        volatile uint32_t XTAL_CTRL;  ///< Offset: 0x180 - crystal control register
        volatile uint32_t BUCK;  ///< Offset: 0x184 - buck control register
        volatile uint32_t FC_FRG;  ///< Offset: 0x200 - flexcomm 0 and 1 clock divider register
        volatile uint32_t PIO_PULL_CFG0;  ///< Offset: 0x800 - pad pull control register 0
        volatile uint32_t PIO_PULL_CFG1;  ///< Offset: 0x804 - pad pull control register 1
        volatile uint32_t PIO_PULL_CFG2;  ///< Offset: 0x808 - pad pull control register 2
        volatile uint32_t IO_CAP;  ///< Offset: 0x80C - io status capture register
        volatile uint32_t PIO_DRV_CFG0;  ///< Offset: 0x810 - pad drive strength register 0
        volatile uint32_t PIO_DRV_CFG1;  ///< Offset: 0x814 - pad drive strength register 1
        volatile uint32_t PIO_DRV_CFG2;  ///< Offset: 0x818 - pad drive extra register
        volatile uint32_t PIO_CFG_MISC;  ///< Offset: 0x81C - pin misc control register
        volatile uint32_t PIO_WAKEUP_LVL0;  ///< Offset: 0x820 - pin wakeup polarity register 0
        volatile uint32_t PIO_WAKEUP_LVL1;  ///< Offset: 0x824 - pin wakeup polarity register 1
        volatile uint32_t PIO_IE_CFG0;  ///< Offset: 0x828 - pad input enable register 0
        volatile uint32_t PIO_IE_CFG1;  ///< Offset: 0x82C - pad input enable register 1
        volatile uint32_t PIO_FUNC_CFG0;  ///< Offset: 0x830 - pin mux control register 0
        volatile uint32_t PIO_FUNC_CFG1;  ///< Offset: 0x834 - pin mux control register 1
        volatile uint32_t PIO_FUNC_CFG2;  ///< Offset: 0x838 - pin mux control register 2
        volatile uint32_t PIO_FUNC_CFG3;  ///< Offset: 0x83C - pin mux control register 3
        volatile uint32_t PIO_WAKEUP_EN0;  ///< Offset: 0x840 - pin function selection in power down mode register 0
        volatile uint32_t PIO_WAKEUP_EN1;  ///< Offset: 0x844 - pin function selection in power down mode register 1
        volatile uint32_t PIO_CAP_OE0;  ///< Offset: 0x848 - pin output enable status register 0 while captured by...
        volatile uint32_t PIO_CAP_OE1;  ///< Offset: 0x84C - pin output enable status register 1 while captured by...
        volatile uint32_t PIO_CAP_OUT0;  ///< Offset: 0x850 - pin output status register 0 while captured by writing 1...
        volatile uint32_t PIO_CAP_OUT1;  ///< Offset: 0x854 - pin output status register 0 while captured by writing 1...
        volatile uint32_t RST_CAUSE_SRC;  ///< Offset: 0x858 - reset source status register
        volatile uint32_t PMU_CTRL0;  ///< Offset: 0x85C - power management uinit control register 0
        volatile uint32_t PMU_CTRL1;  ///< Offset: 0x860 - power management uinit control register 1
        volatile uint32_t ANA_EN;  ///< Offset: 0x864 - analog setting register
        volatile uint32_t XTAL32K_CTRL;  ///< Offset: 0x868 - crystal 32K control register
        volatile uint32_t USB_CFG;  ///< Offset: 0x86C - USB configuration register
        volatile uint32_t PMU_CTRL2;  ///< Offset: 0x880 - power management uinit control register 2
        volatile uint32_t ANA_CTRL1;  ///< Offset: 0x884 - IVREF and DVREG setting register
        volatile uint32_t MISC;  ///< Offset: 0x890 - MISC register
    };

    /// Peripheral instances
    inline Registers* SYSCON = reinterpret_cast<Registers*>(SYSCON_BASE);

    // Bit definitions
    /// RST_SW_SET Register bits
    namespace rst_sw_set_bits {
        constexpr uint32_t SET_FC0_RST = (1U << 0);  ///< Write 1 to set FLEXCOMM0 reset
        constexpr uint32_t SET_FC1_RST = (1U << 1);  ///< Write 1 to set FLEXCOMM1 reset
        constexpr uint32_t SET_FC2_RST = (1U << 2);  ///< Write 1 to set FLEXCOMM2 reset
        constexpr uint32_t SET_FC3_RST = (1U << 3);  ///< Write 1 to set FLEXCOMM3 reset
        constexpr uint32_t SET_TIM0_RST = (1U << 4);  ///< Write 1 to set CTIMER0 reset
        constexpr uint32_t SET_TIM1_RST = (1U << 5);  ///< Write 1 to set CTIMER1 reset
        constexpr uint32_t SET_TIM2_RST = (1U << 6);  ///< Write 1 to set CTIMER2 reset
        constexpr uint32_t SET_TIM3_RST = (1U << 7);  ///< Write 1 to set CTIMER3 reset
        constexpr uint32_t SET_SCT_RST = (1U << 8);  ///< Write 1 to set SCT reset
        constexpr uint32_t SET_WDT_RST = (1U << 9);  ///< Write 1 to set Watch Dog reset
        constexpr uint32_t SET_USB_RST = (1U << 10);  ///< Write 1 to set USB reset
        constexpr uint32_t SET_GPIO_RST = (1U << 11);  ///< Write 1 to set GPIO reset
        constexpr uint32_t SET_RTC_RST = (1U << 12);  ///< Write 1 to set RTC reset
        constexpr uint32_t SET_ADC_RST = (1U << 13);  ///< Write 1 to set ADC interface reset
        constexpr uint32_t SET_DAC_RST = (1U << 14);  ///< Write 1 to set DAC interface reset
        constexpr uint32_t SET_CS_RST = (1U << 15);  ///< Write 1 to set Cap sensor interface reset
        constexpr uint32_t SET_FSP_RST = (1U << 16);  ///< Write 1 to set FSP reset
        constexpr uint32_t SET_DMA_RST = (1U << 17);  ///< Write 1 to set DMA reset
        constexpr uint32_t SET_QDEC0_RST = (1U << 19);  ///< Write 1 to set QDEC 0 reset
        constexpr uint32_t SET_QDEC1_RST = (1U << 20);  ///< Write 1 to set QDEC 1 reset
        constexpr uint32_t SET_SPIFI_RST = (1U << 22);  ///< Write 1 to set SPIFI reset
        constexpr uint32_t SET_CPU_RST = (1U << 26);  ///< Write 1 to set CPU reset
        constexpr uint32_t SET_BLE_RST = (1U << 27);  ///< Write 1 to set BLE reset
        constexpr uint32_t SET_FLASH_RST = (1U << 28);  ///< Write 1 to set flash controller reset
        constexpr uint32_t SET_DP_RST = (1U << 29);  ///< Write 1 to set DataPath reset
        constexpr uint32_t SET_REG_RST = (1U << 30);  ///< Write 1 to reset retention register
        constexpr uint32_t SET_REBOOT = (1U << 31);  ///< Write 1 to Reboot entire system
    }

    /// RST_SW_CLR Register bits
    namespace rst_sw_clr_bits {
        constexpr uint32_t CLR_FC0_RST = (1U << 0);  ///< Write 1 to clear FLEXCOMM0 reset
        constexpr uint32_t CLR_FC1_RST = (1U << 1);  ///< Write 1 to clear FLEXCOMM1 reset
        constexpr uint32_t CLR_FC2_RST = (1U << 2);  ///< Write 1 to clear FLEXCOMM2 reset
        constexpr uint32_t CLR_FC3_RST = (1U << 3);  ///< Write 1 to clear FLEXCOMM3 reset
        constexpr uint32_t CLR_TIM0_RST = (1U << 4);  ///< Write 1 to clear CTIMER0 reset
        constexpr uint32_t CLR_TIM1_RST = (1U << 5);  ///< Write 1 to clear CTIMER1 reset
        constexpr uint32_t CLR_TIM2_RST = (1U << 6);  ///< Write 1 to clear CTIMER2 reset
        constexpr uint32_t CLR_TIM3_RST = (1U << 7);  ///< Write 1 to clear CTIMER3 reset
        constexpr uint32_t CLR_SCT_RST = (1U << 8);  ///< Write 1 to clear SCT reset
        constexpr uint32_t CLR_WDT_RST = (1U << 9);  ///< Write 1 to clear Watch Dog reset
        constexpr uint32_t CLR_USB_RST = (1U << 10);  ///< Write 1 to clear USB reset
        constexpr uint32_t CLR_GPIO_RST = (1U << 11);  ///< Write 1 to clear GPIO reset
        constexpr uint32_t CLR_RTC_RST = (1U << 12);  ///< Write 1 to clear RTC reset
        constexpr uint32_t CLR_ADC_RST = (1U << 13);  ///< Write 1 to clear ADC interface reset
        constexpr uint32_t CLR_DAC_RST = (1U << 14);  ///< Write 1 to clear DAC interface reset
        constexpr uint32_t CLR_CS_RST = (1U << 15);  ///< Write 1 to clear cap sensor interface reset
        constexpr uint32_t CLR_FSP_RST = (1U << 16);  ///< Write 1 to clear FSP reset
        constexpr uint32_t CLR_DMA_RST = (1U << 17);  ///< Write 1 to clear DMA reset
        constexpr uint32_t CLR_QDEC0_RST = (1U << 19);  ///< Write 1 to clear QDEC 0 reset
        constexpr uint32_t CLR_QDEC1_RST = (1U << 20);  ///< Write 1 to clear QDEC 1 reset
        constexpr uint32_t CLR_SPIFI_RST = (1U << 22);  ///< Write 1 to clear SPIFI reset
        constexpr uint32_t CLR_CPU_RST = (1U << 26);  ///< Write 1 to clear CPU reset
        constexpr uint32_t CLR_BLE_RST = (1U << 27);  ///< Write 1 to clear BLE reset
        constexpr uint32_t CLR_FLASH_RST = (1U << 28);  ///< Write 1 to clear flash controller reset
        constexpr uint32_t CLR_DP_RST = (1U << 29);  ///< Write 1 to clear DataPath reset
        constexpr uint32_t CLR_REG_RST = (1U << 30);  ///< Write 1 to clear retention register reset
    }

    /// CLK_DIS Register bits
    namespace clk_dis_bits {
        constexpr uint32_t CLK_FC0_DIS = (1U << 0);  ///< Write 1 to disable FLEXCOMM0 clock
        constexpr uint32_t CLK_FC1_DIS = (1U << 1);  ///< Write 1 to disable FLEXCOMM1 clock
        constexpr uint32_t CLK_FC2_DIS = (1U << 2);  ///< Write 1 to disable FLEXCOMM2 clock
        constexpr uint32_t CLK_FC3_DIS = (1U << 3);  ///< Write 1 to disable FLEXCOMM3 clock
        constexpr uint32_t CLK_TIM0_DIS = (1U << 4);  ///< Write 1 to disable CTIMER0 clock
        constexpr uint32_t CLK_TIM1_DIS = (1U << 5);  ///< Write 1 to disable CTIMER1 clock
        constexpr uint32_t CLK_TIM2_DIS = (1U << 6);  ///< Write 1 to disable CTIMER2 clock
        constexpr uint32_t CLK_TIM3_DIS = (1U << 7);  ///< Write 1 to disable CTIMER3 clock
        constexpr uint32_t CLK_SCT_DIS = (1U << 8);  ///< Write 1 to disable SCT clock
        constexpr uint32_t CLK_WDT_DIS = (1U << 9);  ///< Write 1 to disable Watch Dog clock
        constexpr uint32_t CLK_USB_DIS = (1U << 10);  ///< Write 1 to disable USB clock;
        constexpr uint32_t CLK_GPIO_DIS = (1U << 11);  ///< Write 1 to disable GPIO clock
        constexpr uint32_t CLK_BIV_DIS = (1U << 12);  ///< Write 1 to disable BIV APB clock include RTC BiV register.
        constexpr uint32_t CLK_ADC_DIS = (1U << 13);  ///< Write 1 to disable ADC clock;
        constexpr uint32_t CLK_DAC_DIS = (1U << 14);  ///< Write 1 to disable DAC clock;
        constexpr uint32_t CLK_CS_DIS = (1U << 15);  ///< Write 1 to disable Cap sensor clock;
        constexpr uint32_t CLK_FSP_DIS = (1U << 16);  ///< Write 1 to disable FSP clock;
        constexpr uint32_t CLK_DMA_DIS = (1U << 17);  ///< Write 1 to disable DMA clock
        constexpr uint32_t CLK_QDEC0_DIS = (1U << 19);  ///< Write 1 to disable QDEC0 clock;
        constexpr uint32_t CLK_QDEC1_DIS = (1U << 20);  ///< Write 1 to disable QDEC1 clock;
        constexpr uint32_t CLK_DP_DIS = (1U << 21);  ///< Write 1 to disable Data Path 16/8MHz clock;
        constexpr uint32_t CLK_SPIFI_DIS = (1U << 22);  ///< Write 1 to disable SPIFI clock;
        constexpr uint32_t CLK_CAL_DIS = (1U << 25);  ///< Write 1 to disable Calibration clock;
        constexpr uint32_t CLK_BLE_DIS = (1U << 27);  ///< Write 1 to disable BLE clock
        constexpr uint32_t PCLK_DIS = (1U << 30);  ///< Write 1 to disable PCLK of some logic;
        constexpr uint32_t FCLK_DIS = (1U << 31);  ///< Write 1 to disable CPU FCLK;
    }

    /// CLK_EN Register bits
    namespace clk_en_bits {
        constexpr uint32_t CLK_FC0_EN = (1U << 0);  ///< Write 1 to enable FLEXCOMM0 clock
        constexpr uint32_t CLK_FC1_EN = (1U << 1);  ///< Write 1 to enable FLEXCOMM1 clock
        constexpr uint32_t CLK_FC2_EN = (1U << 2);  ///< Write 1 to enable FLEXCOMM2 clock
        constexpr uint32_t CLK_FC3_EN = (1U << 3);  ///< Write 1 to enable FLEXCOMM3 clock
        constexpr uint32_t CLK_TIM0_EN = (1U << 4);  ///< Write 1 to enable CTIMER0 clock
        constexpr uint32_t CLK_TIM1_EN = (1U << 5);  ///< Write 1 to enable CTIMER1 clock
        constexpr uint32_t CLK_TIM2_EN = (1U << 6);  ///< Write 1 to enable CTIMER2 clock
        constexpr uint32_t CLK_TIM3_EN = (1U << 7);  ///< Write 1 to enable CTIMER3 clock
        constexpr uint32_t CLK_SCT_EN = (1U << 8);  ///< Write 1 to enable SCT clock
        constexpr uint32_t CLK_WDT_EN = (1U << 9);  ///< Write 1 to enable Watch Dog clock
        constexpr uint32_t CLK_USB_EN = (1U << 10);  ///< Write 1 to enable USB clock;
        constexpr uint32_t CLK_GPIO_EN = (1U << 11);  ///< Write 1 to enable GPIO clock
        constexpr uint32_t CLK_BIV_EN = (1U << 12);  ///< Write 1 to enable BIV APB clock include RTC BiV register.
        constexpr uint32_t CLK_ADC_EN = (1U << 13);  ///< Write 1 to enable ADC clock;
        constexpr uint32_t CLK_DAC_EN = (1U << 14);  ///< Write 1 to enable DAC clock;
        constexpr uint32_t CLK_CS_EN = (1U << 15);  ///< Write 1 to enable Cap sensor clock;
        constexpr uint32_t CLK_FSP_EN = (1U << 16);  ///< Write 1 to enable FSP clock;
        constexpr uint32_t CLK_DMA_EN = (1U << 17);  ///< Write 1 to enable DMA clock
        constexpr uint32_t CLK_QDEC0_EN = (1U << 19);  ///< Write 1 to enable QDEC0 clock;
        constexpr uint32_t CLK_QDEC1_EN = (1U << 20);  ///< Write 1 to enable QDEC1 clock;
        constexpr uint32_t CLK_DP_EN = (1U << 21);  ///< Write 1 to enable Data Path 16/8MHz clock;
        constexpr uint32_t CLK_SPIFI_EN = (1U << 22);  ///< Write 1 to enable SPIFI clock;
        constexpr uint32_t CLK_CAL_EN = (1U << 25);  ///< Write 1 to enable Calibration clock;
        constexpr uint32_t CLK_BLE_EN = (1U << 27);  ///< Write 1 to enable BLE clock
    }

    /// CLK_CTRL Register bits
    namespace clk_ctrl_bits {
        constexpr uint32_t APB_DIV = (4 << 0);  ///< APB_CLK = AHB_CLK/(APB_DIV+1)
        constexpr uint32_t AHB_DIV = (13 << 4);  ///< AHB_CLK = SYS_CLK / (AHB_DIV+1);Note Before enable BLE clock (CLK_BLE_EN =1) It is mandatory to set AHB_CLK = 32 or 16 or 8 MHz.
        constexpr uint32_t CLK_BLE_SEL = (1U << 17);  ///< BLE frequency indicator
        constexpr uint32_t CLK_WDT_SEL = (1U << 18);  ///< Select Watch Dog clock
        constexpr uint32_t CLK_XTAL_SEL = (1U << 19);  ///< Crytal clock selection
        constexpr uint32_t CLK_OSC32M_DIV = (1U << 20);  ///< digital OSC clock input selection
        constexpr uint32_t CLK_32K_SEL = (1U << 21);  ///< 32K clock source selection
        constexpr uint32_t CLK_XTAL_OE = (1U << 22);  ///< system clock output enable
        constexpr uint32_t CLK_32K_OE = (1U << 23);  ///< 32K clock output enable
        constexpr uint32_t XTAL_OUT_DIV = (4 << 24);  ///< high frequency xtal clock output divider
        constexpr uint32_t CGBYPASS = (1U << 28);  ///< If it is 0, it can save CPU power in active mode
        constexpr uint32_t SYS_CLK_SEL = (2 << 30);  ///< Select SYS_CLK source
    }

    /// SYS_MODE_CTRL Register bits
    namespace sys_mode_ctrl_bits {
        constexpr uint32_t REMAP = (2 << 0);  ///< software remap system address
        constexpr uint32_t LOCKUP_EN = (1U << 2);  ///< lock up enable
        constexpr uint32_t XTAL_RDY = (1U << 25);  ///< 16/32 MHz xtal ready readout
        constexpr uint32_t XTAL32K_RDY = (1U << 26);  ///< 32KHz xtal ready readout
        constexpr uint32_t PLL48M_RDY = (1U << 27);  ///< 48MHz PLL ready readout
        constexpr uint32_t OSC32M_RDY = (1U << 28);  ///< 32MHz oscillator ready readout
        constexpr uint32_t BG_RDY = (1U << 29);  ///< BG ready readout
        constexpr uint32_t BOOT_MODE = (1U << 31);  ///< boot mode pin status
    }

    /// SYS_STAT Register bits
    namespace sys_stat_bits {
        constexpr uint32_t FREQ_WORD = (8 << 0);  ///< BLE Frequency word;
        constexpr uint32_t BLE_FREQ_HOP = (1U << 8);  ///< BLE frequency word change flag;
        constexpr uint32_t EVENT_IN_PROCESS = (1U << 9);  ///< BLE event indicator
        constexpr uint32_t RX_EN = (1U << 10);  ///< when 1, system is in RX state
        constexpr uint32_t TX_EN = (1U << 11);  ///< when 1, system is in TX state
        constexpr uint32_t OSC_EN = (1U << 12);  ///< BLE osc_en output;
        constexpr uint32_t RADIO_EN = (1U << 13);  ///< BLE radio_en output;
        constexpr uint32_t CLK_STATUS = (1U << 14);  ///< BLE status
    }

    /// SYS_TICK Register bits
    namespace sys_tick_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< system tick timer calibration value
        constexpr uint32_t SKEW = (1U << 24);  ///< whether THE TENMS value will generate a precise 10 millisencod time or an approximation
        constexpr uint32_t NOREF = (1U << 25);  ///< whether an external reference clock is available
        constexpr uint32_t EN_STCLKEN = (1U << 31);  ///< 1 is enable STCLKEN;
    }

    /// SRAM_CTRL Register bits
    namespace sram_ctrl_bits {
        constexpr uint32_t EM_BASE_ADDR = (15 << 0);  ///< Exchange memory base address in system memory. Default value is 9K word.
    }

    /// CHIP_ID Register bits
    namespace chip_id_bits {
        constexpr uint32_t CID0 = (3 << 0);  ///< CHIP ID for manufacture fab
        constexpr uint32_t CID1 = (3 << 3);  ///< CHIP ID for product family
        constexpr uint32_t CID2 = (2 << 6);  ///< CHIP ID for minor revision
        constexpr uint32_t CID3 = (6 << 8);  ///< CHIP ID for product ID
        constexpr uint32_t CID4 = (2 << 14);  ///< CHIP ID for major revision
        constexpr uint32_t MEM_OPTION = (1U << 26);  ///< memory bond indicator
        constexpr uint32_t ADC_OPTION = (1U << 27);  ///< adc bond indicator
        constexpr uint32_t FLASH_OPTION = (1U << 28);  ///< flash bond indicator
        constexpr uint32_t FPU_OPTION = (1U << 29);  ///< fpu bond indicator
        constexpr uint32_t USB_OPTION = (1U << 30);  ///< usb bond indicator
        constexpr uint32_t FSP_OPTION = (1U << 31);  ///< fsp bond indicator
    }

    /// ANA_CTRL0 Register bits
    namespace ana_ctrl0_bits {
        constexpr uint32_t PA_POWER = (8 << 0);  ///< PA power control (all of below is minus data)
        constexpr uint32_t XTAL_AMP = (2 << 20);  ///< crystal amplitude set register
        constexpr uint32_t XTAL_LOAD_CAP = (6 << 22);  ///< Register controlled load cap of the XTAL in normal modeLOAD_CAP=5pF+0.35pF*CSEL+5pF*XADD_C
        constexpr uint32_t XTAL_EXTRA_CAP = (1U << 28);  ///< Add extra 16/32 MHz xtal load cap
        constexpr uint32_t XTAL_MODE = (2 << 30);  ///< Injection mode of the XTAL
    }

    /// XTAL_CTRL Register bits
    namespace xtal_ctrl_bits {
        constexpr uint32_t XTAL_XCUR_BOOST_REG = (1U << 5);  ///< 1 to increase 16/32 MHz xtal current
        constexpr uint32_t XTAL_BPXDLY = (1U << 6);  ///< Bypass the power up delay in the XTAL core.
        constexpr uint32_t XTAL_BP_HYSRES_REG = (1U << 7);  ///< 1 to bypass the degeneration resistor in order to reduce the hysteresis voltage
        constexpr uint32_t XTAL_XSMT_EN_REG = (1U << 8);  ///< 1 to use hysteresis buffer
        constexpr uint32_t XTAL_XRDY_REG = (1U << 9);  ///< 1 to set xtal ready signal by register
        constexpr uint32_t XTAL_XOUT_DIS_REG = (1U << 10);  ///< 1 not to send 16/32 MHz xtal clk out
        constexpr uint32_t DIV_DIFF_CLK_DIG_DIS = (1U << 11);  ///< disable differential clock of digital
        constexpr uint32_t XTAL_SU_CB_REG = (6 << 16);  ///< Register controlled load cap of the XTAL_B in speed up modeCB=2pF+0.35pF*SU_CB+5pF*XADD_C
        constexpr uint32_t XTAL_SU_CA_REG = (6 << 24);  ///< Register controlled load cap of the XTAL_A in speed up modeCA=2pF+0.35pF*SU_CA+5pF*XADD_C
        constexpr uint32_t XTAL_INV = (1U << 30);  ///< Inverse crystal clock
        constexpr uint32_t XTAL_DIV = (1U << 31);  ///< Divide crystal clock when external crystal is 32M this bit should be configured into 1 otherwise 0.
    }

    /// BUCK Register bits
    namespace buck_bits {
        constexpr uint32_t BUCK_DRIVER_PART_EN = (1U << 0);  ///< 1 to short external inductor
        constexpr uint32_t BUCK_IND_USE_EN = (1U << 1);  ///< 1 to turn on buck output stage gradually
        constexpr uint32_t BUCK_ISEL = (2 << 8);  ///< buck current bias control
        constexpr uint32_t BUCK_VREF_SEL = (2 << 10);  ///< buck current setting
        constexpr uint32_t BUCK_VBG_SEL = (2 << 12);  ///< buck reference setting
        constexpr uint32_t BUCK_TMOS = (5 << 16);  ///< buck constant on time control
        constexpr uint32_t BUCK_IC = (1U << 21);  ///< frequency compensation versus BVDD variation
    }

    /// FC_FRG Register bits
    namespace fc_frg_bits {
        constexpr uint32_t FRG_DIV0 = (8 << 0);  ///< flexcomm0 clock generator, Denominator of the fractional divider. DIV is equal to the programmed value +1. Always set to 0xFF to use with the fractional baud rate generator.
        constexpr uint32_t FRG_MULT0 = (8 << 8);  ///< flexcomm0 clock generator, Numerator of the fractional divider. MULT is equal to the programmed value
        constexpr uint32_t FRG_DIV1 = (8 << 16);  ///< flexcomm1 clock generator, Denominator of the fractional divider. DIV is equal to the programmed value +1. Always set to 0xFF to use with the fractional baud rate generator.
        constexpr uint32_t FRG_MULT1 = (8 << 24);  ///< flexcomm1 clock generator, Numerator of the fractional divider. MULT is equal to the programmed value
    }

    /// PIO_PULL_CFG0 Register bits
    namespace pio_pull_cfg0_bits {
        constexpr uint32_t PA00_PULL = (2 << 0);  ///< PA00 pull control register
        constexpr uint32_t PA01_PULL = (2 << 2);  ///< PA01 pull control register
        constexpr uint32_t PA02_PULL = (2 << 4);  ///< PA02 pull control register
        constexpr uint32_t PA03_PULL = (2 << 6);  ///< PA03 pull control register
        constexpr uint32_t PA04_PULL = (2 << 8);  ///< PA04 pull control register
        constexpr uint32_t PA05_PULL = (2 << 10);  ///< PA05 pull control register
        constexpr uint32_t PA06_PULL = (2 << 12);  ///< PA06 pull control register
        constexpr uint32_t PA07_PULL = (2 << 14);  ///< PA07 pull control register
        constexpr uint32_t PA08_PULL = (2 << 16);  ///< PA08 pull control register
        constexpr uint32_t PA09_PULL = (2 << 18);  ///< PA09 pull control register
        constexpr uint32_t PA10_PULL = (2 << 20);  ///< PA10 pull control register
        constexpr uint32_t PA11_PULL = (2 << 22);  ///< PA11 pull control register
        constexpr uint32_t PA12_PULL = (2 << 24);  ///< PA12 pull control register
        constexpr uint32_t PA13_PULL = (2 << 26);  ///< PA13 pull control register
        constexpr uint32_t PA14_PULL = (2 << 28);  ///< PA14 pull control register
        constexpr uint32_t PA15_PULL = (2 << 30);  ///< PA15 pull control register
    }

    /// PIO_PULL_CFG1 Register bits
    namespace pio_pull_cfg1_bits {
        constexpr uint32_t PA16_PULL = (2 << 0);  ///< PA16 pull control register
        constexpr uint32_t PA17_PULL = (2 << 2);  ///< PA17 pull control register
        constexpr uint32_t PA18_PULL = (2 << 4);  ///< PA18 pull control register
        constexpr uint32_t PA19_PULL = (2 << 6);  ///< PA19 pull control register
        constexpr uint32_t PA20_PULL = (2 << 8);  ///< PA20 pull control register
        constexpr uint32_t PA21_PULL = (2 << 10);  ///< PA21 pull control register
        constexpr uint32_t PA22_PULL = (2 << 12);  ///< PA22 pull control register
        constexpr uint32_t PA23_PULL = (2 << 14);  ///< PA23 pull control register
        constexpr uint32_t PA24_PULL = (2 << 16);  ///< PA24 pull control register
        constexpr uint32_t PA25_PULL = (2 << 18);  ///< PA25 pull control register
        constexpr uint32_t PA26_PULL = (2 << 20);  ///< PA26 pull control register
        constexpr uint32_t PA27_PULL = (2 << 22);  ///< PA27 pull control register
        constexpr uint32_t PA28_PULL = (2 << 24);  ///< PA28 pull control register
        constexpr uint32_t PA29_PULL = (2 << 26);  ///< PA29 pull control register
        constexpr uint32_t PA30_PULL = (2 << 28);  ///< PA30 pull control register
        constexpr uint32_t PA31_PULL = (2 << 30);  ///< PA31 pull control register
    }

    /// PIO_PULL_CFG2 Register bits
    namespace pio_pull_cfg2_bits {
        constexpr uint32_t PB00_PULL = (2 << 0);  ///< PB00 pull control register
        constexpr uint32_t PB01_PULL = (2 << 2);  ///< PB01 pull control register
        constexpr uint32_t PB02_PULL = (2 << 4);  ///< PB02 pull control register
    }

    /// IO_CAP Register bits
    namespace io_cap_bits {
        constexpr uint32_t PIN_RETENTION = (1U << 0);  ///< Write 1 to capture pad output and output enable and the status will be saved in PIN_SLP_OEN0 PIN_SLP_OEN1 PIN_SLP_OUT0 and PIN_SLP_OUT1.
    }

    /// PIO_DRV_CFG0 Register bits
    namespace pio_drv_cfg0_bits {
        constexpr uint32_t PA00_DRV = (1U << 0);  ///< PA00 drive strength register
        constexpr uint32_t PA01_DRV = (1U << 1);  ///< PA01 drive strength register
        constexpr uint32_t PA02_DRV = (1U << 2);  ///< PA02 drive strength register
        constexpr uint32_t PA03_DRV = (1U << 3);  ///< PA03 drive strength register
        constexpr uint32_t PA04_DRV = (1U << 4);  ///< PA04 drive strength register
        constexpr uint32_t PA05_DRV = (1U << 5);  ///< PA05 drive strength register
        constexpr uint32_t PA06_DRV = (1U << 6);  ///< PA06 drive strength register
        constexpr uint32_t PA07_DRV = (1U << 7);  ///< PA07 drive strength register
        constexpr uint32_t PA08_DRV = (1U << 8);  ///< PA08 drive strength register
        constexpr uint32_t PA09_DRV = (1U << 9);  ///< PA09 drive strength register
        constexpr uint32_t PA10_DRV = (1U << 10);  ///< PA10 drive strength register
        constexpr uint32_t PA11_DRV = (1U << 11);  ///< PA11 drive strength register
        constexpr uint32_t PA12_DRV = (1U << 12);  ///< PA12 drive strength register
        constexpr uint32_t PA13_DRV = (1U << 13);  ///< PA13 drive strength register
        constexpr uint32_t PA14_DRV = (1U << 14);  ///< PA14 drive strength register
        constexpr uint32_t PA15_DRV = (1U << 15);  ///< PA15 drive strength register
        constexpr uint32_t PA16_DRV = (1U << 16);  ///< PA16 drive strength register
        constexpr uint32_t PA17_DRV = (1U << 17);  ///< PA17 drive strength register
        constexpr uint32_t PA18_DRV = (1U << 18);  ///< PA18 drive strength register
        constexpr uint32_t PA19_DRV = (1U << 19);  ///< PA19 drive strength register
        constexpr uint32_t PA20_DRV = (1U << 20);  ///< PA20 drive strength register
        constexpr uint32_t PA21_DRV = (1U << 21);  ///< PA21 drive strength register
        constexpr uint32_t PA22_DRV = (1U << 22);  ///< PA22 drive strength register
        constexpr uint32_t PA23_DRV = (1U << 23);  ///< PA23 drive strength register
        constexpr uint32_t PA24_DRV = (1U << 24);  ///< PA24 drive strength register
        constexpr uint32_t PA25_DRV = (1U << 25);  ///< PA25 drive strength register
        constexpr uint32_t PA26_DRV = (1U << 26);  ///< PA26 drive strength register
        constexpr uint32_t PA27_DRV = (1U << 27);  ///< PA27 drive strength register
        constexpr uint32_t PA28_DRV = (1U << 28);  ///< PA28 drive strength register
        constexpr uint32_t PA29_DRV = (1U << 29);  ///< PA29 drive strength register
        constexpr uint32_t PA30_DRV = (1U << 30);  ///< PA30 drive strength register
        constexpr uint32_t PA31_DRV = (1U << 31);  ///< PA31 drive strength register
    }

    /// PIO_DRV_CFG1 Register bits
    namespace pio_drv_cfg1_bits {
        constexpr uint32_t PB00_DRV = (1U << 0);  ///< PB00 drive strengh register
        constexpr uint32_t PB01_DRV = (1U << 1);  ///< PB01 drive strengh register
        constexpr uint32_t PB02_DRV = (1U << 2);  ///< PB02 drive strengh register
    }

    /// PIO_DRV_CFG2 Register bits
    namespace pio_drv_cfg2_bits {
        constexpr uint32_t PA06_DRV_EXTRA = (1U << 6);  ///< Write 1 to enable extra driven on PA06
        constexpr uint32_t PA11_DRV_EXTRA = (1U << 11);  ///< Write 1 to enable extra driven on PA11
        constexpr uint32_t PA19_DRV_EXTRA = (1U << 19);  ///< Write 1 to enable extra driven on PA19
        constexpr uint32_t PA26_DRV_EXTRA = (1U << 26);  ///< Write 1 to enable extra driven on PA26
        constexpr uint32_t PA27_DRV_EXTRA = (1U << 27);  ///< Write 1 to enable extra driven on PA27
    }

    /// PIO_CFG_MISC Register bits
    namespace pio_cfg_misc_bits {
        constexpr uint32_t PB00_AE = (1U << 0);  ///< Enable PB00 analog function
        constexpr uint32_t PB01_AE = (1U << 1);  ///< Enable PB01 analog function
        constexpr uint32_t PSYNC = (1U << 15);  ///< when 1, bypass first stage of synchronization of DMA pin trigger
        constexpr uint32_t PB02_MODE = (1U << 16);  ///< chip mode pin function select
        constexpr uint32_t TRX_EN_INV = (1U << 18);  ///< inverse TX_EN &amp; RX_EN pin mux output polarity
        constexpr uint32_t RFE_INV = (1U << 19);  ///< Inverse RFE polarity
    }

    /// PIO_WAKEUP_LVL0 Register bits
    namespace pio_wakeup_lvl0_bits {
        constexpr uint32_t PA00_WAKEUP_LVL = (1U << 0);  ///< Control the wake up polarity of PA00 in sleep mode. 0: high level wakeup, 1: low level wakeup
        constexpr uint32_t PA01_WAKEUP_LVL = (1U << 1);  ///< Control the wake up polarity of PA01 in sleep mode.
        constexpr uint32_t PA02_WAKEUP_LVL = (1U << 2);  ///< Control the wake up polarity of PA02 in sleep mode.
        constexpr uint32_t PA03_WAKEUP_LVL = (1U << 3);  ///< Control the wake up polarity of PA03 in sleep mode.
        constexpr uint32_t PA04_WAKEUP_LVL = (1U << 4);  ///< Control the wake up polarity of PA04 in sleep mode.
        constexpr uint32_t PA05_WAKEUP_LVL = (1U << 5);  ///< Control the wake up polarity of PA05 in sleep mode.
        constexpr uint32_t PA06_WAKEUP_LVL = (1U << 6);  ///< Control the wake up polarity of PA06 in sleep mode.
        constexpr uint32_t PA07_WAKEUP_LVL = (1U << 7);  ///< Control the wake up polarity of PA07 in sleep mode.
        constexpr uint32_t PA08_WAKEUP_LVL = (1U << 8);  ///< Control the wake up polarity of PA08 in sleep mode.
        constexpr uint32_t PA09_WAKEUP_LVL = (1U << 9);  ///< Control the wake up polarity of PA09 in sleep mode.
        constexpr uint32_t PA10_WAKEUP_LVL = (1U << 10);  ///< Control the wake up polarity of PA10 in sleep mode.
        constexpr uint32_t PA11_WAKEUP_LVL = (1U << 11);  ///< Control the wake up polarity of PA11 in sleep mode.
        constexpr uint32_t PA12_WAKEUP_LVL = (1U << 12);  ///< Control the wake up polarity of PA12 in sleep mode.
        constexpr uint32_t PA13_WAKEUP_LVL = (1U << 13);  ///< Control the wake up polarity of PA13 in sleep mode.
        constexpr uint32_t PA14_WAKEUP_LVL = (1U << 14);  ///< Control the wake up polarity of PA14 in sleep mode.
        constexpr uint32_t PA15_WAKEUP_LVL = (1U << 15);  ///< Control the wake up polarity of PA15 in sleep mode.
        constexpr uint32_t PA16_WAKEUP_LVL = (1U << 16);  ///< Control the wake up polarity of PA16 in sleep mode.
        constexpr uint32_t PA17_WAKEUP_LVL = (1U << 17);  ///< Control the wake up polarity of PA17 in sleep mode.
        constexpr uint32_t PA18_WAKEUP_LVL = (1U << 18);  ///< Control the wake up polarity of PA18 in sleep mode.
        constexpr uint32_t PA19_WAKEUP_LVL = (1U << 19);  ///< Control the wake up polarity of PA19 in sleep mode.
        constexpr uint32_t PA20_WAKEUP_LVL = (1U << 20);  ///< Control the wake up polarity of PA20 in sleep mode.
        constexpr uint32_t PA21_WAKEUP_LVL = (1U << 21);  ///< Control the wake up polarity of PA21 in sleep mode.
        constexpr uint32_t PA22_WAKEUP_LVL = (1U << 22);  ///< Control the wake up polarity of PA22 in sleep mode.
        constexpr uint32_t PA23_WAKEUP_LVL = (1U << 23);  ///< Control the wake up polarity of PA23 in sleep mode.
        constexpr uint32_t PA24_WAKEUP_LVL = (1U << 24);  ///< Control the wake up polarity of PA24 in sleep mode.
        constexpr uint32_t PA25_WAKEUP_LVL = (1U << 25);  ///< Control the wake up polarity of PA25 in sleep mode.
        constexpr uint32_t PA26_WAKEUP_LVL = (1U << 26);  ///< Control the wake up polarity of PA26 in sleep mode.
        constexpr uint32_t PA27_WAKEUP_LVL = (1U << 27);  ///< Control the wake up polarity of PA27 in sleep mode.
        constexpr uint32_t PA28_WAKEUP_LVL = (1U << 28);  ///< Control the wake up polarity of PA28 in sleep mode.
        constexpr uint32_t PA29_WAKEUP_LVL = (1U << 29);  ///< Control the wake up polarity of PA29 in sleep mode.
        constexpr uint32_t PA30_WAKEUP_LVL = (1U << 30);  ///< Control the wake up polarity of PA30 in sleep mode.
        constexpr uint32_t PA31_WAKEUP_LVL = (1U << 31);  ///< Control the wake up polarity of PA31 in sleep mode.
    }

    /// PIO_WAKEUP_LVL1 Register bits
    namespace pio_wakeup_lvl1_bits {
        constexpr uint32_t PB00_WAKEUP_LVL = (1U << 0);  ///< Control the wake up polarity of PB01 in sleep mode.
        constexpr uint32_t PB01_WAKEUP_LVL = (1U << 1);  ///< Control the wake up polarity of PB02 in sleep mode.
        constexpr uint32_t PB02_WAKEUP_LVL = (1U << 2);  ///< Control the wake up polarity of PB03 in sleep mode.
    }

    /// PIO_IE_CFG0 Register bits
    namespace pio_ie_cfg0_bits {
        constexpr uint32_t PA00_IE = (1U << 0);  ///< PA00 digital input enable
        constexpr uint32_t PA01_IE = (1U << 1);  ///< PA01 digital input enable
        constexpr uint32_t PA02_IE = (1U << 2);  ///< PA02 digital input enable
        constexpr uint32_t PA03_IE = (1U << 3);  ///< PA03 digital input enable
        constexpr uint32_t PA04_IE = (1U << 4);  ///< PA04 digital input enable
        constexpr uint32_t PA05_IE = (1U << 5);  ///< PA05 digital input enable
        constexpr uint32_t PA06_IE = (1U << 6);  ///< PA06 digital input enable
        constexpr uint32_t PA07_IE = (1U << 7);  ///< PA07 digital input enable
        constexpr uint32_t PA08_IE = (1U << 8);  ///< PA08 digital input enable
        constexpr uint32_t PA09_IE = (1U << 9);  ///< PA09 digital input enable
        constexpr uint32_t PA10_IE = (1U << 10);  ///< PA10 digital input enable
        constexpr uint32_t PA11_IE = (1U << 11);  ///< PA11 digital input enable
        constexpr uint32_t PA12_IE = (1U << 12);  ///< PA12 digital input enable
        constexpr uint32_t PA13_IE = (1U << 13);  ///< PA13 digital input enable
        constexpr uint32_t PA14_IE = (1U << 14);  ///< PA14 digital input enable
        constexpr uint32_t PA15_IE = (1U << 15);  ///< PA15 digital input enable
        constexpr uint32_t PA16_IE = (1U << 16);  ///< PA16 digital input enable
        constexpr uint32_t PA17_IE = (1U << 17);  ///< PA17 digital input enable
        constexpr uint32_t PA18_IE = (1U << 18);  ///< PA18 digital input enable
        constexpr uint32_t PA19_IE = (1U << 19);  ///< PA19 digital input enable
        constexpr uint32_t PA20_IE = (1U << 20);  ///< PA20 digital input enable
        constexpr uint32_t PA21_IE = (1U << 21);  ///< PA21 digital input enable
        constexpr uint32_t PA22_IE = (1U << 22);  ///< PA22 digital input enable
        constexpr uint32_t PA23_IE = (1U << 23);  ///< PA23 digital input enable
        constexpr uint32_t PA24_IE = (1U << 24);  ///< PA24 digital input enable
        constexpr uint32_t PA25_IE = (1U << 25);  ///< PA25 digital input enable
        constexpr uint32_t PA26_IE = (1U << 26);  ///< PA26 digital input enable
        constexpr uint32_t PA27_IE = (1U << 27);  ///< PA27 digital input enable
        constexpr uint32_t PA28_IE = (1U << 28);  ///< PA28 digital input enable
        constexpr uint32_t PA29_IE = (1U << 29);  ///< PA29 digital input enable
        constexpr uint32_t PA30_IE = (1U << 30);  ///< PA30 digital input enable
        constexpr uint32_t PA31_IE = (1U << 31);  ///< PA31 digital input enable
    }

    /// PIO_IE_CFG1 Register bits
    namespace pio_ie_cfg1_bits {
        constexpr uint32_t PB00_IE = (1U << 0);  ///< PB00 digital input enable
        constexpr uint32_t PB01_IE = (1U << 1);  ///< PB01 digital input enable
        constexpr uint32_t BOOT_MODE_IE = (1U << 2);  ///< PB02 input enable
    }

    /// PIO_FUNC_CFG0 Register bits
    namespace pio_func_cfg0_bits {
        constexpr uint32_t PA00_FUNC = (3 << 0);  ///< PA00 function control register
        constexpr uint32_t PA01_FUNC = (3 << 4);  ///< PA01 function control register
        constexpr uint32_t PA02_FUNC = (3 << 8);  ///< PA02 function control register
        constexpr uint32_t PA03_FUNC = (3 << 12);  ///< PA03 function control register
        constexpr uint32_t PA04_FUNC = (3 << 16);  ///< PA04 function control register
        constexpr uint32_t PA05_FUNC = (3 << 20);  ///< PA05 function control register
        constexpr uint32_t PA06_FUNC = (3 << 24);  ///< PA06 function control register
        constexpr uint32_t PA07_FUNC = (3 << 28);  ///< PA07 function control register
    }

    /// PIO_FUNC_CFG1 Register bits
    namespace pio_func_cfg1_bits {
        constexpr uint32_t PA08_FUNC = (3 << 0);  ///< PA08 function control register
        constexpr uint32_t PA09_FUNC = (3 << 4);  ///< PA09 function control register
        constexpr uint32_t PA10_FUNC = (3 << 8);  ///< PA10 function control register
        constexpr uint32_t PA11_FUNC = (3 << 12);  ///< PA11 function control register
        constexpr uint32_t PA12_FUNC = (3 << 16);  ///< PA12 function control register
        constexpr uint32_t PA13_FUNC = (3 << 20);  ///< PA13 function control register
        constexpr uint32_t PA14_FUNC = (3 << 24);  ///< PA14 function control register
        constexpr uint32_t PA15_FUNC = (3 << 28);  ///< PA15 function control register
    }

    /// PIO_FUNC_CFG2 Register bits
    namespace pio_func_cfg2_bits {
        constexpr uint32_t PA16_FUNC = (3 << 0);  ///< PA16 function control register
        constexpr uint32_t PA17_FUNC = (3 << 4);  ///< PA17 function control register
        constexpr uint32_t PA18_FUNC = (3 << 8);  ///< PA18 function control register
        constexpr uint32_t PA19_FUNC = (3 << 12);  ///< PA19 function control register
        constexpr uint32_t PA20_FUNC = (3 << 16);  ///< PA20 function control register
        constexpr uint32_t PA21_FUNC = (3 << 20);  ///< PA21 function control register
        constexpr uint32_t PA22_FUNC = (3 << 24);  ///< PA22 function control register
        constexpr uint32_t PA23_FUNC = (3 << 28);  ///< PA23 function control register
    }

    /// PIO_FUNC_CFG3 Register bits
    namespace pio_func_cfg3_bits {
        constexpr uint32_t PA24_FUNC = (3 << 0);  ///< PA24 function control register
        constexpr uint32_t PA25_FUNC = (3 << 4);  ///< PA25 function control register
        constexpr uint32_t PA26_FUNC = (3 << 8);  ///< PA26 function control register
        constexpr uint32_t PA27_FUNC = (3 << 12);  ///< PA27 function control register
        constexpr uint32_t PA28_FUNC = (3 << 16);  ///< PA28 function control register
        constexpr uint32_t PA29_FUNC = (3 << 20);  ///< PA29 function control register
        constexpr uint32_t PA30_FUNC = (3 << 24);  ///< PA30 function control register
        constexpr uint32_t PA31_FUNC = (3 << 28);  ///< PA31 function control register
    }

    /// PIO_WAKEUP_EN0 Register bits
    namespace pio_wakeup_en0_bits {
        constexpr uint32_t PA00_WAKEUP_EN = (1U << 0);  ///< Control GPIOA[31-0] as Wakeup source.
        constexpr uint32_t PA01_WAKEUP_EN = (1U << 1);  ///< no description available
        constexpr uint32_t PA02_WAKEUP_EN = (1U << 2);  ///< no description available
        constexpr uint32_t PA03_WAKEUP_EN = (1U << 3);  ///< no description available
        constexpr uint32_t PA04_WAKEUP_EN = (1U << 4);  ///< no description available
        constexpr uint32_t PA05_WAKEUP_EN = (1U << 5);  ///< no description available
        constexpr uint32_t PA06_WAKEUP_EN = (1U << 6);  ///< no description available
        constexpr uint32_t PA07_WAKEUP_EN = (1U << 7);  ///< no description available
        constexpr uint32_t PA08_WAKEUP_EN = (1U << 8);  ///< no description available
        constexpr uint32_t PA09_WAKEUP_EN = (1U << 9);  ///< no description available
        constexpr uint32_t PA10_WAKEUP_EN = (1U << 10);  ///< no description available
        constexpr uint32_t PA11_WAKEUP_EN = (1U << 11);  ///< no description available
        constexpr uint32_t PA12_WAKEUP_EN = (1U << 12);  ///< no description available
        constexpr uint32_t PA13_WAKEUP_EN = (1U << 13);  ///< no description available
        constexpr uint32_t PA14_WAKEUP_EN = (1U << 14);  ///< no description available
        constexpr uint32_t PA15_WAKEUP_EN = (1U << 15);  ///< no description available
        constexpr uint32_t PA16_WAKEUP_EN = (1U << 16);  ///< no description available
        constexpr uint32_t PA17_WAKEUP_EN = (1U << 17);  ///< no description available
        constexpr uint32_t PA18_WAKEUP_EN = (1U << 18);  ///< no description available
        constexpr uint32_t PA19_WAKEUP_EN = (1U << 19);  ///< no description available
        constexpr uint32_t PA20_WAKEUP_EN = (1U << 20);  ///< no description available
        constexpr uint32_t PA21_WAKEUP_EN = (1U << 21);  ///< no description available
        constexpr uint32_t PA22_WAKEUP_EN = (1U << 22);  ///< no description available
        constexpr uint32_t PA23_WAKEUP_EN = (1U << 23);  ///< no description available
        constexpr uint32_t PA24_WAKEUP_EN = (1U << 24);  ///< no description available
        constexpr uint32_t PA25_WAKEUP_EN = (1U << 25);  ///< no description available
        constexpr uint32_t PA26_WAKEUP_EN = (1U << 26);  ///< no description available
        constexpr uint32_t PA27_WAKEUP_EN = (1U << 27);  ///< no description available
        constexpr uint32_t PA28_WAKEUP_EN = (1U << 28);  ///< no description available
        constexpr uint32_t PA29_WAKEUP_EN = (1U << 29);  ///< no description available
        constexpr uint32_t PA30_WAKEUP_EN = (1U << 30);  ///< no description available
        constexpr uint32_t PA31_WAKEUP_EN = (1U << 31);  ///< no description available
    }

    /// PIO_WAKEUP_EN1 Register bits
    namespace pio_wakeup_en1_bits {
        constexpr uint32_t PB00_WAKEUP_EN = (1U << 0);  ///< Control GPIOB as Wakeup source.
        constexpr uint32_t PB01_WAKEUP_EN = (1U << 1);  ///< no description available
        constexpr uint32_t PB02_WAKEUP_EN = (1U << 2);  ///< no description available
        constexpr uint32_t PA04_32K_OE = (1U << 4);  ///< 32K clock output enable. When this bit is set to 1 PA04 will output 32k clock. At this time PIN_CTRL register is not effective to control this IO's function.
        constexpr uint32_t PA05_XTAL_OE = (1U << 5);  ///< XTAL clock output enable. When this bit is set to 1 PA05 will output XTAL clock. At this time PIN_CTRL register is not effective to control this IO's function.
        constexpr uint32_t PA10_32K_OE = (1U << 10);  ///< 32K clock output enable. When this bit is set to 1 PA10 (GPIO10) will output 32k clock. At this time PIN_CTRL register is not effective to control this IO's function.
        constexpr uint32_t PA11_XTAL_OE = (1U << 11);  ///< XTAL clock output enable. When this bit is set to 1 PA11 will output XTAL clock. At this time PIN_CTRL register is not effective to control this IO's function.
        constexpr uint32_t PA18_32K_OE = (1U << 18);  ///< 32K clock output enable. When this bit is set to 1 PA18 will output 32k clock. At this time PIN_CTRL register is not effective to control this IO's function.
        constexpr uint32_t PA19_XTAL_OE = (1U << 19);  ///< XTAL clock output enable. When this bit is set to 1 PA19 will output XTAL clock. At this time PIN_CTRL register is not effective to control this IO's function.
        constexpr uint32_t PA24_32K_OE = (1U << 24);  ///< 32K clock output enable. When this bit is set to 1 PA24 will output 32k clock. At this time PIN_CTRL register is not effective to control this IO's function.
        constexpr uint32_t PA25_XTAL_OE = (1U << 25);  ///< XTAL clock output enable. When this bit is set to 1 PA25 will output XTAL clock. At this time PIN_CTRL register is not effective to control this IO's function.
        constexpr uint32_t PDM_IO_SEL = (1U << 31);  ///< pin status selection in power down mode
    }

    /// PIO_CAP_OE0 Register bits
    namespace pio_cap_oe0_bits {
        constexpr uint32_t PA00_CAP_OE = (1U << 0);  ///< PA00 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA01_CAP_OE = (1U << 1);  ///< PA01 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA02_CAP_OE = (1U << 2);  ///< PA02 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA03_CAP_OE = (1U << 3);  ///< PA03 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA04_CAP_OE = (1U << 4);  ///< PA04 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA05_CAP_OE = (1U << 5);  ///< PA05 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA06_CAP_OE = (1U << 6);  ///< PA06 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA07_CAP_OE = (1U << 7);  ///< PA07 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA08_CAP_OE = (1U << 8);  ///< PA08 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA09_CAP_OE = (1U << 9);  ///< PA09 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA10_CAP_OE = (1U << 10);  ///< PA10 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA11_CAP_OE = (1U << 11);  ///< PA11 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA12_CAP_OE = (1U << 12);  ///< PA12 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA13_CAP_OE = (1U << 13);  ///< PA13 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA14_CAP_OE = (1U << 14);  ///< PA14 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA15_CAP_OE = (1U << 15);  ///< PA15 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA16_CAP_OE = (1U << 16);  ///< PA16 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA17_CAP_OE = (1U << 17);  ///< PA17 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA18_CAP_OE = (1U << 18);  ///< PA18 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA19_CAP_OE = (1U << 19);  ///< PA19 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA20_CAP_OE = (1U << 20);  ///< PA20 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA21_CAP_OE = (1U << 21);  ///< PA21 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA22_CAP_OE = (1U << 22);  ///< PA22 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA23_CAP_OE = (1U << 23);  ///< PA23 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA24_CAP_OE = (1U << 24);  ///< PA24 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA25_CAP_OE = (1U << 25);  ///< PA25 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA26_CAP_OE = (1U << 26);  ///< PA26 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA27_CAP_OE = (1U << 27);  ///< PA27 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA28_CAP_OE = (1U << 28);  ///< PA28 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA29_CAP_OE = (1U << 29);  ///< PA29 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA30_CAP_OE = (1U << 30);  ///< PA30 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PA31_CAP_OE = (1U << 31);  ///< PA31 output enable status captured by writing 1 to IO_CAP
    }

    /// PIO_CAP_OE1 Register bits
    namespace pio_cap_oe1_bits {
        constexpr uint32_t PB00_CAP_OE = (1U << 0);  ///< PB00 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PB01_CAP_OE = (1U << 1);  ///< PB01 output enable status captured by writing 1 to IO_CAP
        constexpr uint32_t PB02_CAP_OE = (1U << 2);  ///< PB02 output enable status captured by writing 1 to IO_CAP
    }

    /// PIO_CAP_OUT0 Register bits
    namespace pio_cap_out0_bits {
        constexpr uint32_t PA00_CAP_OUT = (1U << 0);  ///< PA00 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA01_CAP_OUT = (1U << 1);  ///< PA01 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA02_CAP_OUT = (1U << 2);  ///< PA02 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA03_CAP_OUT = (1U << 3);  ///< PA03 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA04_CAP_OUT = (1U << 4);  ///< PA04 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA05_CAP_OUT = (1U << 5);  ///< PA05 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA06_CAP_OUT = (1U << 6);  ///< PA06 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA07_CAP_OUT = (1U << 7);  ///< PA07 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA08_CAP_OUT = (1U << 8);  ///< PA08 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA09_CAP_OUT = (1U << 9);  ///< PA09 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA10_CAP_OUT = (1U << 10);  ///< PA10 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA11_CAP_OUT = (1U << 11);  ///< PA11 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA12_CAP_OUT = (1U << 12);  ///< PA12 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA13_CAP_OUT = (1U << 13);  ///< PA13 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA14_CAP_OUT = (1U << 14);  ///< PA14 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA15_CAP_OUT = (1U << 15);  ///< PA15 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA16_CAP_OUT = (1U << 16);  ///< PA16 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA17_CAP_OUT = (1U << 17);  ///< PA17 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA18_CAP_OUT = (1U << 18);  ///< PA18 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA19_CAP_OUT = (1U << 19);  ///< PA19 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA20_CAP_OUT = (1U << 20);  ///< PA20 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA21_CAP_OUT = (1U << 21);  ///< PA21 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA22_CAP_OUT = (1U << 22);  ///< PA22 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA23_CAP_OUT = (1U << 23);  ///< PA23 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA24_CAP_OUT = (1U << 24);  ///< PA24 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA25_CAP_OUT = (1U << 25);  ///< PA25 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA26_CAP_OUT = (1U << 26);  ///< PA26 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA27_CAP_OUT = (1U << 27);  ///< PA27 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA28_CAP_OUT = (1U << 28);  ///< PA28 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA29_CAP_OUT = (1U << 29);  ///< PA29 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA30_CAP_OUT = (1U << 30);  ///< PA30 output status captured by writing 1 to IO_CAP
        constexpr uint32_t PA31_CAP_OUT = (1U << 31);  ///< PA31 output status captured by writing 1 to IO_CAP
    }

    /// PIO_CAP_OUT1 Register bits
    namespace pio_cap_out1_bits {
        constexpr uint32_t PB00_CAP_OUT = (1U << 0);  ///< PB00 output status while captured by writing 1 to IO_CAP
        constexpr uint32_t PB01_CAP_OUT = (1U << 1);  ///< PB01 output status while captured by writing 1 to IO_CAP
        constexpr uint32_t PB02_CAP_OUT = (1U << 2);  ///< PB02 output status while captured by writing 1 to IO_CAP
    }

    /// RST_CAUSE_SRC Register bits
    namespace rst_cause_src_bits {
        constexpr uint32_t RESET_CAUSE = (9 << 0);  ///< reset source indicator. xxxxxxxx1b = Power-on Reset; xxxxxxx1xb = Brown-Down Reset; xxxxxx1xxb = External pin Reset; xxxxx1xxxb = Watch Dog Reset; xxxx1xxxxb = Lock Up Reset; xxx1xxxxxb = Reboot Reset; xx1000000b = CPU system Reset requirement; x10000000b = Wake Up reset 10000000b = CPU software Reset;
        constexpr uint32_t RST_CAUSE_CLR = (1U << 31);  ///< Write '1' clear RESET_CAUSE bits;
    }

    /// PMU_CTRL0 Register bits
    namespace pmu_ctrl0_bits {
        constexpr uint32_t MEM0_DIS = (1U << 0);  ///< power down sram memory block 0
        constexpr uint32_t MEM1_DIS = (1U << 1);  ///< power down sram memory block 1
        constexpr uint32_t MEM2_DIS = (1U << 2);  ///< power down sram memory block 2
        constexpr uint32_t MEM3_DIS = (1U << 3);  ///< power down sram memory block 3
        constexpr uint32_t MEM4_DIS = (1U << 4);  ///< power down sram memory block 4
        constexpr uint32_t MEM5_DIS = (1U << 5);  ///< power down sram memory block 5
        constexpr uint32_t MEM6_DIS = (1U << 6);  ///< power down sram memory block 6
        constexpr uint32_t MEM7_DIS = (1U << 7);  ///< power down sram memory block 7
        constexpr uint32_t MEM8_DIS = (1U << 8);  ///< power down sram memory block 8
        constexpr uint32_t MEM9_DIS = (1U << 9);  ///< power down sram memory block 9
        constexpr uint32_t BLE_DIS = (1U << 16);  ///< power down BLE
        constexpr uint32_t FIR_DIS = (1U << 17);  ///< power down FIR buffer
        constexpr uint32_t FSP_DIS = (1U << 18);  ///< power down FSP
        constexpr uint32_t MCU_MODE = (1U << 20);  ///< power control of BG, V2I, VREG_A, VREG_D
        constexpr uint32_t OSC_INT_EN = (1U << 26);  ///< 1 to enable OSC_EN as interrupt and wakeup source
        constexpr uint32_t RTC_SEC_WAKEUP_EN = (1U << 27);  ///< 1 to enable RTC interrupt as wakeup source
        constexpr uint32_t WAKEUP_EN = (1U << 28);  ///< 1 to enable sleep wake up source
        constexpr uint32_t PMU_EN = (1U << 29);  ///< 1 to enable chip power down mode
        constexpr uint32_t RETENTION_EN = (1U << 30);  ///< 1 to enable all CPU registers to be retentioned in sleep mode
        constexpr uint32_t BOND_EN = (1U << 31);  ///< 1 to enable FSP_BOND_EN bond option
    }

    /// PMU_CTRL1 Register bits
    namespace pmu_ctrl1_bits {
        constexpr uint32_t RCO32K_DIS = (1U << 0);  ///< 1 to switch off 32K RCO power
        constexpr uint32_t XTAL32K_DIS = (1U << 1);  ///< 1 to switch off 32K XTAL power
        constexpr uint32_t XTAL_DIS = (1U << 2);  ///< 1 to switch off XTAL of digital power
        constexpr uint32_t OSC32M_DIS = (1U << 3);  ///< 1 to switch off 32M OSC power
        constexpr uint32_t USBPLL_DIS = (1U << 4);  ///< 1 to switch off USB 48M PLL power
        constexpr uint32_t ADC_BUF_DIS = (1U << 5);  ///< 1 to switch off buffer in SD ADC
        constexpr uint32_t ADC_BG_DIS = (1U << 6);  ///< 1 to switch off bandgap in SD ADC
        constexpr uint32_t ADC_DIS = (1U << 7);  ///< 1 to switch off SD ADC
        constexpr uint32_t ADC_VCM_DIS = (1U << 8);  ///< 1 to switch off VCM DRV in SD ADC
        constexpr uint32_t ADC_VREF_DIS = (1U << 9);  ///< 1 to switch off VREF DRV in SD ADC
        constexpr uint32_t DAC_DIS = (1U << 10);  ///< 1 to switch off DAC
        constexpr uint32_t CAP_SEN_DIS = (1U << 11);  ///< 1 to switch off CAP_SEN
        constexpr uint32_t BUCK_CTRL = (4 << 16);  ///< BUCK power control, 0x00 to power on, and 0x0F to power down
        constexpr uint32_t RCO32K_PDM_DIS = (1U << 30);  ///< In sleep mode this bit ORs with DIS_RCO_32K to control the RCO 32K power
        constexpr uint32_t XTAL32K_PDM_DIS = (1U << 31);  ///< In sleep mode this bit ORs with DIS_XTAL32K to control the XTAL32 power
    }

    /// ANA_EN Register bits
    namespace ana_en_bits {
        constexpr uint32_t BOD_AMP_EN = (1U << 0);  ///< Enable the AMP of browned out detector
        constexpr uint32_t BOD_EN = (1U << 1);  ///< Enable browned out detector
        constexpr uint32_t BAT_MON_EN = (1U << 2);  ///< Enable battery monitor
        constexpr uint32_t ACMP0_EN = (1U << 3);  ///< Enable comparator 0
        constexpr uint32_t ACMP1_EN = (1U << 4);  ///< Enable comparator 1
        constexpr uint32_t BOR_AMP_EN = (1U << 5);  ///< Enable the AMP of browned reset detector
        constexpr uint32_t BOR_EN = (1U << 6);  ///< Enable browned reset detector
        constexpr uint32_t ACMP0_REF = (4 << 8);  ///< acmp0 reference voltage selection, vref0=Acmp_vref*ACMP0_REF/16
        constexpr uint32_t ACMP1_REF = (4 << 12);  ///< acmp1 reference voltage selection, vref1=Acmp_vref*ACMP1_REF/16
        constexpr uint32_t ACMP0_HYST_EN = (1U << 16);  ///< Hysteresis enable of ACMP0 when 1
        constexpr uint32_t ACMP1_HYST_EN = (1U << 17);  ///< Hysteresis enable of ACMP1 when 1
        constexpr uint32_t ACMP_VREF_SEL = (1U << 18);  ///< Acmp_vref selection
        constexpr uint32_t BOD_THR = (2 << 19);  ///< Browned-out detector threshold voltages, when VDD is lower than this voltage, BOD_OUT interrupt happens. And the detector has a hysteresis.
        constexpr uint32_t BOR_THR = (2 << 21);  ///< Browned-out reset threshold voltages
        constexpr uint32_t ACMP0_OUT = (1U << 24);  ///< Comparator 0 output.
        constexpr uint32_t ACMP1_OUT = (1U << 25);  ///< Comparator 1 output.
        constexpr uint32_t ACMP0_EDGE_SEL = (2 << 26);  ///< ACMP0 interrupt edge selection
        constexpr uint32_t ACMP1_EDGE_SEL = (2 << 28);  ///< ACMP1 interrupt edge selection
        constexpr uint32_t ACMP0_INTEN = (1U << 30);  ///< 1 to enable ACMP0 interrupt
        constexpr uint32_t ACMP1_INTEN = (1U << 31);  ///< 1 to enable ACMP1 interrupt
    }

    /// XTAL32K_CTRL Register bits
    namespace xtal32k_ctrl_bits {
        constexpr uint32_t XTAL32K_ICTRL = (6 << 0);  ///< Xtal 32 gm cell current bias Y
        constexpr uint32_t XTAL32K_INJ = (2 << 6);  ///< Xtal 32KHz clk injection mode1xb = external sine wave clock
        constexpr uint32_t XTAL32K_LOAD_CAP = (6 << 8);  ///< load cap selection of xtal32
        constexpr uint32_t XTAL32K_EXTRA_CAP = (1U << 14);  ///< add extra xtal32 load cap
    }

    /// USB_CFG Register bits
    namespace usb_cfg_bits {
        constexpr uint32_t DPPUEN_B_PHY_POL = (1U << 0);  ///< drive high to inverse the polarity of the connection
        constexpr uint32_t DPPUEN_B_PHY_SEL = (1U << 1);  ///< The control source selection for pull-up resistor
        constexpr uint32_t USB_VBUS = (1U << 3);  ///< USB connection voltage selection
        constexpr uint32_t USB_PHYSTDBY = (1U << 4);  ///< 1 to enable USB_PHY in standby mode
        constexpr uint32_t USB_PHYSTDBY_WEN = (1U << 5);  ///< 1 to enable USB_PHYSTDBY control by register
    }

    /// PMU_CTRL2 Register bits
    namespace pmu_ctrl2_bits {
        constexpr uint32_t BG_PDM_DIS = (1U << 0);  ///< 1 to power down bandcap in power down mode
        constexpr uint32_t V2I_PDM_DIS = (1U << 1);  ///< 1 to power down V2I in power down mode
        constexpr uint32_t VREG_A_PDM_DIS = (1U << 2);  ///< 1 to power down VREG_A in power down mode
        constexpr uint32_t VREG_D_PDM_DIS = (1U << 3);  ///< 1 to power down VREG_D in power down mode
        constexpr uint32_t XTAL_PDM_DIS = (1U << 4);  ///< 1 to power down XTAL in power down mode
        constexpr uint32_t OSC32M_PDM_DIS = (1U << 5);  ///< 1 to power down OSC32M in power down mode
        constexpr uint32_t RFAGC_ON = (1U << 6);  ///< 1 to enable RFAGC
        constexpr uint32_t RX_EN_SEL = (1U << 7);  ///< RX_EN width selection
        constexpr uint32_t BG_DIS = (1U << 8);  ///< 1 to switch off bandcap power
        constexpr uint32_t V2I_DIS = (1U << 9);  ///< 1 to switch off V2I power
        constexpr uint32_t VREG_A_DIS = (1U << 10);  ///< 1 to switch off VREG_A power
        constexpr uint32_t VREG_D_DIS = (1U << 11);  ///< 1 to switch off VREG_D power
        constexpr uint32_t LO_DIS = (1U << 12);  ///< 1 to switch off LO power
        constexpr uint32_t VCO_DIS = (1U << 13);  ///< 1 to switch off VCO power
        constexpr uint32_t PA_PK_DIS = (1U << 14);  ///< 1 to switch off PA peek detector power
        constexpr uint32_t PA_DIS = (1U << 15);  ///< 1 to switch off PA power
        constexpr uint32_t LNA_DIS = (1U << 16);  ///< 1 to switch off LNA power
        constexpr uint32_t MIXER_DIS = (1U << 17);  ///< 1 to switch off MIXER power
        constexpr uint32_t PKDET_DIS = (1U << 18);  ///< 1 to switch off RRF and PPF peek detector power
        constexpr uint32_t PPF_DIS = (1U << 19);  ///< 1 to switch off PPF power
        constexpr uint32_t SAR_DIS = (1U << 20);  ///< 1 to switch off SAR ADC power
        constexpr uint32_t RC_CAL_DIS = (1U << 21);  ///< 1 to switch off RCCAL power
        constexpr uint32_t FLSH_DIS = (1U << 29);  ///< 1 to switch off flash power
        constexpr uint32_t FLSH_PDM_DIS = (1U << 30);  ///< 1 to power down flash VDD25 in power down mode
        constexpr uint32_t SEL_PD = (1U << 31);  ///< power control selection
    }

    /// ANA_CTRL1 Register bits
    namespace ana_ctrl1_bits {
        constexpr uint32_t VDD_PMU_SET_PDM = (2 << 0);  ///< Vdd_pmu while in power down
        constexpr uint32_t VDD_PMU_SET = (2 << 2);  ///< Vdd_pmu while wakeup
        constexpr uint32_t VDD_MEM_SET_PDM = (2 << 4);  ///< Vdd_mem while in power down mode
        constexpr uint32_t VDD_MEM_SET = (2 << 6);  ///< Vdd_mem while wakeup
        constexpr uint32_t VDD_PMU_SET_EXTRA = (1U << 8);  ///< extra high setting for vdd_pmu
        constexpr uint32_t VDD_MEM_SET_EXTRA = (1U << 9);  ///< extra high setting for vdd_mem
        constexpr uint32_t VDD_PMU_SET_ULTRA_LOW = (1U << 10);  ///< ultra low setting for vdd_pmu
        constexpr uint32_t VDD_PMU_MEM_SW = (1U << 11);  ///< 1 to close the switch betwwen vdd_omu and vdd_mem
        constexpr uint32_t IV_BG_SEL = (4 << 12);  ///< VBG voltage select-
        constexpr uint32_t PDM_DIS_BUCK = (1U << 16);  ///< 1 to power off buck in power down mode
        constexpr uint32_t BUCK_PD_CCM = (1U << 17);  ///< 0 buck in CCM mode
        constexpr uint32_t BUCK_PD_DCM = (1U << 18);  ///< 0 buck in DCM mode
        constexpr uint32_t IV_IREF_SEL = (2 << 19);  ///< Reference current select
        constexpr uint32_t IV_VREG11_SET = (3 << 21);  ///< VREG11 setting
        constexpr uint32_t XTAL32K_FORCE_RDY = (1U << 24);  ///< Xtal32k ready from register
        constexpr uint32_t X32_SMT_EN = (1U << 25);  ///< 1 to enable schmidt trigger in xtal32
        constexpr uint32_t BM_X32BUF = (2 << 26);  ///< Xtal 32 buffer current bias
        constexpr uint32_t DVREG11_SET_DIG = (3 << 28);  ///< Vregd set
        constexpr uint32_t BUCK_DPD = (1U << 31);  ///< ZC control select
    }

    /// MISC Register bits
    namespace misc_bits {
        constexpr uint32_t RCO_PWR_MODE = (2 << 0);  ///< RCO VDD selection
        constexpr uint32_t EN_SWD = (1U << 16);  ///< enable swd register when SWD is selected in PIO_FUNC_CTRL
        constexpr uint32_t DIS_FLSH_POWER = (1U << 17);  ///< flash power disable
        constexpr uint32_t DIS_USB_PULLUP = (1U << 18);  ///< USB pull resister connection
        constexpr uint32_t DPPU_OPT_SEL = (1U << 24);  ///< pull up strength source. 0: from DPPU_OPT_POL, 1: from usb device
        constexpr uint32_t DPPU_OPT_POL = (1U << 25);  ///< swap pull up strength value
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40001000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t LOAD;  ///< Offset: 0x00 - watch dog counter start value register
        volatile uint32_t VALUE;  ///< Offset: 0x04 - watch dog counter value register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - watch dog control register
        volatile uint32_t INT_CLR;  ///< Offset: 0x0C - interrupt clear register
        volatile uint32_t INT_RAW;  ///< Offset: 0x10 - raw interrupt status register
        volatile uint32_t MIS;  ///< Offset: 0x14 - interrupt mask register
        volatile uint32_t LOCK;  ///< Offset: 0x20 - watch dog lock register
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// LOAD Register bits
    namespace load_bits {
        constexpr uint32_t LOAD = (32 << 0);  ///< Contain the value from which the counter is to decrement. When this register is written to the count is immediately restarted from the new value. The minimum valid value is 1.
    }

    /// VALUE Register bits
    namespace value_bits {
        constexpr uint32_t VALUE = (32 << 0);  ///< The current value of the decrementing counter.
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t INTEN = (1U << 0);  ///< Enable the interrupt event WDOGINT. Set HIGH to enable the counter and the interrupt and set LOW to disable the counter and interrupt. Reloads the counter from the value in WDOGLOAD when the interrupt is enabled, and was previously disabled.
        constexpr uint32_t RESEN = (1U << 1);  ///< Enable watchdog reset output WDOGRES. Acts as a mask for the reset output. Set HIGH to enablethe reset and LOW to disable the reset.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t INTCLR = (1U << 0);  ///< A write of any value to the Register clears the watchdog interrupt and reloads the counter from the value in WDOGLOAD.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RAWINTSTAT = (1U << 0);  ///< Raw interrupt status from the counter
    }

    /// MIS Register bits
    namespace mis_bits {
        constexpr uint32_t MASKINTSTAT = (1U << 0);  ///< Enabled interrupt status from the counter
    }

    /// LOCK Register bits
    namespace lock_bits {
        constexpr uint32_t LOCK_31_0 = (32 << 0);  ///< Writing 0x1ACCE551to this register enables write access to all other registers.
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t CTIMER0_BASE = 0x40002000;
    constexpr uint32_t CTIMER1_BASE = 0x40003000;
    constexpr uint32_t CTIMER2_BASE = 0x40004000;
    constexpr uint32_t CTIMER3_BASE = 0x40005000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t IR;  ///< Offset: 0x00 - Interrupt Register. The IR can be written to clear...
        volatile uint32_t TCR;  ///< Offset: 0x04 - Timer Control Register. The TCR is used to control the...
        volatile uint32_t TC;  ///< Offset: 0x08 - Timer Counter. The 32 bit TC is incremented every PR+1...
        volatile uint32_t PR;  ///< Offset: 0x0C - Prescale Register. When the Prescale Counter (PC) is...
        volatile uint32_t PC;  ///< Offset: 0x10 - Prescale Counter. The 32 bit PC is a counter which is...
        volatile uint32_t MCR;  ///< Offset: 0x14 - Match Control Register. The MCR is used to control if an...
        volatile uint32_t MR[%s];  ///< Offset: 0x18 - Match Register . MR can be enabled through the MCR to...
        volatile uint32_t CCR;  ///< Offset: 0x28 - Capture Control Register. The CCR controls which edges...
        volatile uint32_t CR[%s];  ///< Offset: 0x2C - Capture Register . CR is loaded with the value of TC...
        volatile uint32_t EMR;  ///< Offset: 0x3C - External Match Register. The EMR controls the match...
        volatile uint32_t CTCR;  ///< Offset: 0x70 - Count Control Register. The CTCR selects between Timer...
        volatile uint32_t PWMC;  ///< Offset: 0x74 - PWM Control Register. The PWMCON enables PWM mode for...
    };

    /// Peripheral instances
    inline Registers* CTIMER0 = reinterpret_cast<Registers*>(CTIMER0_BASE);
    inline Registers* CTIMER1 = reinterpret_cast<Registers*>(CTIMER1_BASE);
    inline Registers* CTIMER2 = reinterpret_cast<Registers*>(CTIMER2_BASE);
    inline Registers* CTIMER3 = reinterpret_cast<Registers*>(CTIMER3_BASE);

    // Bit definitions
    /// IR Register bits
    namespace ir_bits {
        constexpr uint32_t MR0INT = (1U << 0);  ///< Interrupt flag for match channel 0.
        constexpr uint32_t MR1INT = (1U << 1);  ///< Interrupt flag for match channel 1.
        constexpr uint32_t MR2INT = (1U << 2);  ///< Interrupt flag for match channel 2.
        constexpr uint32_t MR3INT = (1U << 3);  ///< Interrupt flag for match channel 3.
        constexpr uint32_t CR0INT = (1U << 4);  ///< Interrupt flag for capture channel 0 event.
        constexpr uint32_t CR1INT = (1U << 5);  ///< Interrupt flag for capture channel 1 event.
        constexpr uint32_t CR2INT = (1U << 6);  ///< Interrupt flag for capture channel 2 event.
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t CEN = (1U << 0);  ///< Counter enable.
        constexpr uint32_t CRST = (1U << 1);  ///< Counter reset.
    }

    /// TC Register bits
    namespace tc_bits {
        constexpr uint32_t TCVAL = (32 << 0);  ///< Timer counter value.
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PRVAL = (32 << 0);  ///< Prescale counter value.
    }

    /// PC Register bits
    namespace pc_bits {
        constexpr uint32_t PCVAL = (32 << 0);  ///< Prescale counter value.
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MR0I = (1U << 0);  ///< Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC. 0 = disabled. 1 = enabled.
        constexpr uint32_t MR0R = (1U << 1);  ///< Reset on MR0: the TC will be reset if MR0 matches it. 0 = disabled. 1 = enabled.
        constexpr uint32_t MR0S = (1U << 2);  ///< Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC. 0 = disabled. 1 = enabled.
        constexpr uint32_t MR1I = (1U << 3);  ///< Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC. 0 = disabled. 1 = enabled. 0 = disabled. 1 = enabled.
        constexpr uint32_t MR1R = (1U << 4);  ///< Reset on MR1: the TC will be reset if MR1 matches it. 0 = disabled. 1 = enabled.
        constexpr uint32_t MR1S = (1U << 5);  ///< Stop on MR1: the TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC. 0 = disabled. 1 = enabled.
        constexpr uint32_t MR2I = (1U << 6);  ///< Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC. 0 = disabled. 1 = enabled.
        constexpr uint32_t MR2R = (1U << 7);  ///< Reset on MR2: the TC will be reset if MR2 matches it. 0 = disabled. 1 = enabled.
        constexpr uint32_t MR2S = (1U << 8);  ///< Stop on MR2: the TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC. 0 = disabled. 1 = enabled.
        constexpr uint32_t MR3I = (1U << 9);  ///< Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC. 0 = disabled. 1 = enabled.
        constexpr uint32_t MR3R = (1U << 10);  ///< Reset on MR3: the TC will be reset if MR3 matches it. 0 = disabled. 1 = enabled.
        constexpr uint32_t MR3S = (1U << 11);  ///< Stop on MR3: the TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC. 0 = disabled. 1 = enabled.
    }

    /// MR[%s] Register bits
    namespace mr[%s]_bits {
        constexpr uint32_t MATCH = (32 << 0);  ///< Timer counter match value.
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t CAP0RE = (1U << 0);  ///< Rising edge of capture channel 0: a sequence of 0 then 1 causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
        constexpr uint32_t CAP0FE = (1U << 1);  ///< Falling edge of capture channel 0: a sequence of 1 then 0 causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
        constexpr uint32_t CAP0I = (1U << 2);  ///< Generate interrupt on channel 0 capture event: a CR0 load generates an interrupt.
        constexpr uint32_t CAP1RE = (1U << 3);  ///< Rising edge of capture channel 1: a sequence of 0 then 1 causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
        constexpr uint32_t CAP1FE = (1U << 4);  ///< Falling edge of capture channel 1: a sequence of 1 then 0 causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
        constexpr uint32_t CAP1I = (1U << 5);  ///< Generate interrupt on channel 1 capture event: a CR1 load generates an interrupt.
        constexpr uint32_t CAP2RE = (1U << 6);  ///< Rising edge of capture channel 2: a sequence of 0 then 1 causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
        constexpr uint32_t CAP2FE = (1U << 7);  ///< Falling edge of capture channel 2: a sequence of 1 then 0 causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
        constexpr uint32_t CAP2I = (1U << 8);  ///< Generate interrupt on channel 2 capture event: a CR2 load generates an interrupt.
    }

    /// CR[%s] Register bits
    namespace cr[%s]_bits {
        constexpr uint32_t CAP = (32 << 0);  ///< Timer counter capture value.
    }

    /// EMR Register bits
    namespace emr_bits {
        constexpr uint32_t EM0 = (1U << 0);  ///< External Match 0. This bit reflects the state of output MAT0, whether or not this output is connected to a pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing, as selected by EMR[5:4]. This bit is driven to the MAT pins if the match function is selected via IOCON. 0 = LOW. 1 = HIGH.
        constexpr uint32_t EM1 = (1U << 1);  ///< External Match 1. This bit reflects the state of output MAT1, whether or not this output is connected to a pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing, as selected by EMR[7:6]. This bit is driven to the MAT pins if the match function is selected via IOCON. 0 = LOW. 1 = HIGH.
        constexpr uint32_t EM2 = (1U << 2);  ///< External Match 2. This bit reflects the state of output MAT2, whether or not this output is connected to a pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing, as selected by EMR[9:8]. This bit is driven to the MAT pins if the match function is selected via IOCON. 0 = LOW. 1 = HIGH.
        constexpr uint32_t EM3 = (1U << 3);  ///< External Match 3. This bit reflects the state of output MAT3, whether or not this output is connected to a pin. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing, as selected by MR[11:10]. This bit is driven to the MAT pins if the match function is selected via IOCON. 0 = LOW. 1 = HIGH.
        constexpr uint32_t EMC0 = (2 << 4);  ///< External Match Control 0. Determines the functionality of External Match 0.
        constexpr uint32_t EMC1 = (2 << 6);  ///< External Match Control 1. Determines the functionality of External Match 1.
        constexpr uint32_t EMC2 = (2 << 8);  ///< External Match Control 2. Determines the functionality of External Match 2.
        constexpr uint32_t EMC3 = (2 << 10);  ///< External Match Control 3. Determines the functionality of External Match 3.
    }

    /// CTCR Register bits
    namespace ctcr_bits {
        constexpr uint32_t CTMODE = (2 << 0);  ///< Counter/Timer Mode This field selects which rising APB bus clock edges can increment Timer'-s Prescale Counter (PC), or clear PC and increment Timer Counter (TC). Timer Mode: the TC is incremented when the Prescale Counter matches the Prescale Register.
        constexpr uint32_t CINSEL = (2 << 2);  ///< Count Input Select When bits 1:0 in this register are not 00, these bits select which CAP pin is sampled for clocking. Note: If Counter mode is selected for a particular CAPn input in the CTCR, the 3 bits for that input in the Capture Control Register (CCR) must be programmed as 000. However, capture and/or interrupt can be selected for the other 3 CAPn inputs in the same timer.
        constexpr uint32_t ENCC = (1U << 4);  ///< Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs.
        constexpr uint32_t SELCC = (3 << 5);  ///< Edge select. When bit 4 is 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and 0x6 to 0x7 are reserved.
    }

    /// PWMC Register bits
    namespace pwmc_bits {
        constexpr uint32_t PWMEN0 = (1U << 0);  ///< PWM mode enable for channel0.
        constexpr uint32_t PWMEN1 = (1U << 1);  ///< PWM mode enable for channel1.
        constexpr uint32_t PWMEN2 = (1U << 2);  ///< PWM mode enable for channel2.
        constexpr uint32_t PWMEN3 = (1U << 3);  ///< PWM mode enable for channel3. Note: It is recommended to use match channel 3 to set the PWM cycle.
    }

}

// ============================================================================
// PINT Peripheral
// ============================================================================

namespace pint {
    /// Base addresses
    constexpr uint32_t PINT_BASE = 0x40006000;

    /// PINT Register structure
    struct Registers {
        volatile uint32_t ISEL;  ///< Offset: 0x00 - Pin Interrupt Mode register
        volatile uint32_t IENR;  ///< Offset: 0x04 - Pin interrupt level or rising edge interrupt enable register
        volatile uint32_t SIENR;  ///< Offset: 0x08 - Pin interrupt level or rising edge interrupt set register
        volatile uint32_t CIENR;  ///< Offset: 0x0C - Pin interrupt level (rising edge interrupt) clear register
        volatile uint32_t IENF;  ///< Offset: 0x10 - Pin interrupt active level or falling edge interrupt...
        volatile uint32_t SIENF;  ///< Offset: 0x14 - Pin interrupt active level or falling edge interrupt set register
        volatile uint32_t CIENF;  ///< Offset: 0x18 - Pin interrupt active level or falling edge interrupt...
        volatile uint32_t RISE;  ///< Offset: 0x1C - Pin interrupt rising edge register
        volatile uint32_t FALL;  ///< Offset: 0x20 - Pin interrupt falling edge register
        volatile uint32_t IST;  ///< Offset: 0x24 - Pin interrupt status register
        volatile uint32_t PMCTRL;  ///< Offset: 0x28 - Pattern match interrupt control register
        volatile uint32_t PMSRC;  ///< Offset: 0x2C - Pattern match interrupt bit-slice source register
        volatile uint32_t PMCFG;  ///< Offset: 0x30 - Pattern match interrupt bit slice configuration register
    };

    /// Peripheral instances
    inline Registers* PINT = reinterpret_cast<Registers*>(PINT_BASE);

    // Bit definitions
    /// ISEL Register bits
    namespace isel_bits {
        constexpr uint32_t PMODE = (4 << 0);  ///< Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive
    }

    /// IENR Register bits
    namespace ienr_bits {
        constexpr uint32_t ENRL = (4 << 0);  ///< Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt.
    }

    /// SIENR Register bits
    namespace sienr_bits {
        constexpr uint32_t SETENRL = (4 << 0);  ///< Ones written to this address set bits in the IENR, thus enabling interrupts. Bit n sets bit n in the IENR register. 0 = No operation. 1 = Enable rising edge or level interrupt.
    }

    /// CIENR Register bits
    namespace cienr_bits {
        constexpr uint32_t CENRL = (4 << 0);  ///< Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt.
    }

    /// IENF Register bits
    namespace ienf_bits {
        constexpr uint32_t ENAF = (4 << 0);  ///< Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH.
    }

    /// SIENF Register bits
    namespace sienf_bits {
        constexpr uint32_t SETENAF = (4 << 0);  ///< Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt.
    }

    /// CIENF Register bits
    namespace cienf_bits {
        constexpr uint32_t CENAF = (4 << 0);  ///< Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled.
    }

    /// RISE Register bits
    namespace rise_bits {
        constexpr uint32_t RDET = (4 << 0);  ///< Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin.
    }

    /// FALL Register bits
    namespace fall_bits {
        constexpr uint32_t FDET = (4 << 0);  ///< Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin.
    }

    /// IST Register bits
    namespace ist_bits {
        constexpr uint32_t PSTAT = (4 << 0);  ///< Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register).
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t SEL_PMATCH = (1U << 0);  ///< Specifies whether the 8 pin interrupts are controlled by the pin interrupt function or by the pattern match function.
        constexpr uint32_t ENA_RXEV = (1U << 1);  ///< Enables the RXEV output to the CPU and/or to a GPIO output when the specified boolean expression evaluates to true.
        constexpr uint32_t PMAT = (8 << 24);  ///< This field displays the current state of pattern matches. A 1 in any bit of this field indicates that the corresponding product term is matched by the current state of the appropriate inputs.
    }

    /// PMSRC Register bits
    namespace pmsrc_bits {
        constexpr uint32_t SRC0 = (3 << 8);  ///< Selects the input source for bit slice 0
        constexpr uint32_t SRC1 = (3 << 11);  ///< Selects the input source for bit slice 1
        constexpr uint32_t SRC2 = (3 << 14);  ///< Selects the input source for bit slice 2
        constexpr uint32_t SRC3 = (3 << 17);  ///< Selects the input source for bit slice 3
        constexpr uint32_t SRC4 = (3 << 20);  ///< Selects the input source for bit slice 4
        constexpr uint32_t SRC5 = (3 << 23);  ///< Selects the input source for bit slice 5
        constexpr uint32_t SRC6 = (3 << 26);  ///< Selects the input source for bit slice 6
        constexpr uint32_t SRC7 = (3 << 29);  ///< Selects the input source for bit slice 7
    }

    /// PMCFG Register bits
    namespace pmcfg_bits {
        constexpr uint32_t PROD_ENDPTS0 = (1U << 0);  ///< Determines whether slice 0 is an endpoint.
        constexpr uint32_t PROD_ENDPTS1 = (1U << 1);  ///< Determines whether slice 1 is an endpoint.
        constexpr uint32_t PROD_ENDPTS2 = (1U << 2);  ///< Determines whether slice 2 is an endpoint.
        constexpr uint32_t PROD_ENDPTS3 = (1U << 3);  ///< Determines whether slice 3 is an endpoint.
        constexpr uint32_t PROD_ENDPTS4 = (1U << 4);  ///< Determines whether slice 4 is an endpoint.
        constexpr uint32_t PROD_ENDPTS5 = (1U << 5);  ///< Determines whether slice 5 is an endpoint.
        constexpr uint32_t PROD_ENDPTS6 = (1U << 6);  ///< Determines whether slice 6 is an endpoint.
        constexpr uint32_t CFG0 = (3 << 8);  ///< Specifies the match contribution condition for bit slice 0.
        constexpr uint32_t CFG1 = (3 << 11);  ///< Specifies the match contribution condition for bit slice 1.
        constexpr uint32_t CFG2 = (3 << 14);  ///< Specifies the match contribution condition for bit slice 2.
        constexpr uint32_t CFG3 = (3 << 17);  ///< Specifies the match contribution condition for bit slice 3.
        constexpr uint32_t CFG4 = (3 << 20);  ///< Specifies the match contribution condition for bit slice 4.
        constexpr uint32_t CFG5 = (3 << 23);  ///< Specifies the match contribution condition for bit slice 5.
        constexpr uint32_t CFG6 = (3 << 26);  ///< Specifies the match contribution condition for bit slice 6.
        constexpr uint32_t CFG7 = (3 << 29);  ///< Specifies the match contribution condition for bit slice 7.
    }

}

// ============================================================================
// INPUTMUX Peripheral
// ============================================================================

namespace inputmux {
    /// Base addresses
    constexpr uint32_t INPUTMUX_BASE = 0x40006200;

    /// INPUTMUX Register structure
    struct Registers {
        volatile uint32_t PINTSEL[%s];  ///< Offset: 0x00 - Pin interrupt select register
        volatile uint32_t DMA_ITRIG_INMUX[%s];  ///< Offset: 0x200 - Trigger select register for DMA channel
        volatile uint32_t DMA_OTRIG_INMUX[%s];  ///< Offset: 0x800 - DMA output trigger selection to become DMA trigger
    };

    /// Peripheral instances
    inline Registers* INPUTMUX = reinterpret_cast<Registers*>(INPUTMUX_BASE);

    // Bit definitions
    /// PINTSEL[%s] Register bits
    namespace pintsel[%s]_bits {
        constexpr uint32_t INTPIN = (5 << 0);  ///< Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO1_31 correspond to numbers 0 to 63).
    }

    /// DMA_ITRIG_INMUX[%s] Register bits
    namespace dma_itrig_inmux[%s]_bits {
        constexpr uint32_t INP = (5 << 0);  ///< Trigger input number (decimal value) for DMA channel n (n = 0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer CT32B0 Match 0 5 = Timer CT32B0 Match 1 6 = Timer CT32B1 Match 0 7 = Timer CT32B2 Match 0 8 = Timer CT32B2 Match 1 9 = Timer CT32B3 Match 0 10 = Timer CT32B4 Match 0 11 = Timer CT32B4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 = DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA output trigger mux 3
    }

    /// DMA_OTRIG_INMUX[%s] Register bits
    namespace dma_otrig_inmux[%s]_bits {
        constexpr uint32_t INP = (5 << 0);  ///< DMA trigger output number (decimal value) for DMA channel n (n = 0 to 19).
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40007000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - ADC control register
        volatile uint32_t CH_SEL;  ///< Offset: 0x04 - ADC channel selection register
        volatile uint32_t CH_CFG;  ///< Offset: 0x08 - ADC channel configuration register
        volatile uint32_t WCMP_THR;  ///< Offset: 0x0C - Window compare threshold register
        volatile uint32_t INTEN;  ///< Offset: 0x10 - ADC interrupt enable register
        volatile uint32_t INT;  ///< Offset: 0x14 - ADC interrupt status register
        volatile uint32_t DATA;  ///< Offset: 0x18 - ADC converted data output
        volatile uint32_t CFG[%s];  ///< Offset: 0x20 - ADC configuration register
        volatile uint32_t BG_BF;  ///< Offset: 0x28 - ADC bandcap and buffer setting register
        volatile uint32_t ANA_CTRL;  ///< Offset: 0x2C - ADC core and reference setting regsiter
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< ADC enable. Write 1 to Writing 1 before starting conversion and 0 to end conversion.
        constexpr uint32_t CONV_MODE = (1U << 1);  ///< ADC conversion mode
        constexpr uint32_t SCAN_EN = (1U << 2);  ///< 1 to enable scan mode
        constexpr uint32_t WCMP_EN = (1U << 3);  ///< 1 to enable window compare
        constexpr uint32_t SW_START = (1U << 7);  ///< Software start ADC conversion write1 to trigger one time ADC conversion, no need clear.
        constexpr uint32_t CLKSEL = (5 << 8);  ///< Sigma-Delta ADC clock select
        constexpr uint32_t SIG_INV_EN = (1U << 13);  ///< 1 to invert Signma-Delta input signal
        constexpr uint32_t VREF_SEL = (2 << 14);  ///< Sigma-Delta ADC Reference source selection.
        constexpr uint32_t CH_IDX_EN = (1U << 18);  ///< 1 to append channel index in data result to be used in scan mode
        constexpr uint32_t DATA_FORMAT = (1U << 19);  ///< Data output format. When DATA_FORMAT ==0, When CH_IDX_EN ==0, the ADC_DATA[31:0] is adc data, signed data, 31 bit frac. When CH_IDX_EN ==1, the ADC_DATA[4:0] is channel output, {ADC_DATA[31:5],5'h0} is adc data, signed data, 31 bit frac. When DATA_FORMAT ==1, When CH_IDX_EN ==0, the ADC_DATA[22:0] is adc data, signed data, 22 bit frac. When CH_IDX_EN ==1, the ADC_DATA[31:27] is channel output, ADC_DATA[22:0] is adc data, signed data, 22 bit frac.
        constexpr uint32_t VREFO_EN = (1U << 20);  ///< 1 to enable bandgap out-chip capacitor
        constexpr uint32_t SRST_DIS = (1U << 21);  ///< 1 to disable adc reset.
        constexpr uint32_t TRIGGER = (6 << 23);  ///< Adc start trigger. 0 to 31 PA00 to PA31; 32 to 34 GPIOB0 to GPIOB2; 35, software trigger; 36, rng trigger; 56 to 59, timer 0 to timer 3; 60 to 63 pwm 0 to pwm 3
    }

    /// CH_SEL Register bits
    namespace ch_sel_bits {
        constexpr uint32_t CH_SEL = (32 << 0);  ///< In scan conversion mode, the channels with 1 set will be scanned, from LSB to MSB. In none scan conversion mode, only the first channel from LSB with 1 set will be converted. If all bits are set to 0, no ADC conversion will be started.
    }

    /// CH_CFG Register bits
    namespace ch_cfg_bits {
        constexpr uint32_t CH_CFG = (32 << 0);  ///< whenCH_CONFIG[N] is 0, the N channelwill select the configure 0 option(seeregister SD_CONFIG0). whenCH_CONFIG[N] is 1, the N channelwill select the configure 1 option(seeregister SD_CONFIG1).
    }

    /// WCMP_THR Register bits
    namespace wcmp_thr_bits {
        constexpr uint32_t WCMP_THR_LOW = (16 << 0);  ///< &lt;s 0 15&gt; Windows compare low threshold.
        constexpr uint32_t WCMP_THR_HIGH = (16 << 16);  ///< &lt;s 0 15&gt; Windows compare high threshold If ADC decimation result is out of the window one compare interrupt will be triggered.
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t DAT_RDY_INTEN = (1U << 0);  ///< 1 to enable Data ready interrupt
        constexpr uint32_t WCMP_INTEN = (1U << 1);  ///< 1 to enable Window compare interrupt.
        constexpr uint32_t FIFO_OF_INTEN = (1U << 2);  ///< 1 to enalble FIFO overflow interrupt.
        constexpr uint32_t ADC_INTEN = (1U << 31);  ///< 1 to enable ADC interrupt
    }

    /// INT Register bits
    namespace int_bits {
        constexpr uint32_t DAT_RDY_INT = (1U << 0);  ///< Data ready interrupt will be cleared after fifo data is read can not be cleared by write 1.
        constexpr uint32_t WCMP_INT = (1U << 1);  ///< Window compare interrupt.
        constexpr uint32_t FIFO_OF_INT = (1U << 2);  ///< FIFO overflow interrupt.
        constexpr uint32_t ADC_INT = (1U << 31);  ///< ADC interrupt.
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< ADC data read from FIFO.
    }

    /// CFG[%s] Register bits
    namespace cfg[%s]_bits {
        constexpr uint32_t PGA_GAIN = (3 << 0);  ///< SD ADC input PGA gain=2^value the range is 1-16.
        constexpr uint32_t PGA_BP = (1U << 3);  ///< 1 to bypass SD ADC input PGA
        constexpr uint32_t PGA_VINN = (2 << 4);  ///< SD ADC PGA VIN input offset selection
        constexpr uint32_t ADC_GAIN = (2 << 6);  ///< SD ADC gain selection.
        constexpr uint32_t VREF_GAIN = (1U << 8);  ///< SD ADC Reference Gain seletion
        constexpr uint32_t ADC_VCM = (3 << 9);  ///< SD ADC input common voltage selection.
        constexpr uint32_t PGA_VCM_EN = (1U << 12);  ///< SD ADC PGA output common voltage control enable signal.
        constexpr uint32_t PGA_VCM_DIR = (1U << 13);  ///< SD ADC PGA output common voltage control direction signal.
        constexpr uint32_t PGA_VCM = (6 << 14);  ///< SD ADC PGA output common voltage, adjustment = (PGA_VCM0[5]+1)*(PGA_VCM0[3:0]+1)*40mv
        constexpr uint32_t DOWN_SAMPLE_RATE = (3 << 20);  ///< Down sample rate
        constexpr uint32_t DS_DATA_STABLE = (6 << 23);  ///< Down sample date stable number. you can keep the bit 1:0 to 2'b11. DS_DATA_STABLE0[5:2]+1
        constexpr uint32_t SCAN_INTV = (3 << 29);  ///< Interval when switching ADC source; 2/4/8/16/32/64/128/256 clock cycle.
    }

    /// BG_BF Register bits
    namespace bg_bf_bits {
        constexpr uint32_t PGA_BM = (3 << 0);  ///< SD ADC buffer bias current selection.
        constexpr uint32_t BG_SEL = (4 << 4);  ///< Bandgap voltage selection to compensate PVT variations8 steps with 5mV each upward. VBG=1205+5*BGSEL(mV)
        constexpr uint32_t TEMP_EN = (1U << 12);  ///< 1 to enable temperature sensor
        constexpr uint32_t PGA_CHOP_EN = (1U << 13);  ///< 1 to enable chopper in PGA
        constexpr uint32_t PGA_BM_DIV2 = (1U << 14);  ///< 1 to half PGA bias current
    }

    /// ANA_CTRL Register bits
    namespace ana_ctrl_bits {
        constexpr uint32_t ADC_BM = (3 << 0);  ///< ADC bias current selection.
        constexpr uint32_t ADC_ORDER = (1U << 4);  ///< 1 to enable SD ADC 2 order mode selection
        constexpr uint32_t DITHER_EN = (1U << 5);  ///< 1 to enable SD ADC PN Sequence in chopper mode
        constexpr uint32_t CHOP_EN = (1U << 6);  ///< 1 to enable SD ADC chopper
        constexpr uint32_t INV_CLK = (1U << 7);  ///< 1 to invert SD ADC Output Clock
        constexpr uint32_t VREF_BM = (3 << 8);  ///< SD ADC Reference Driver bias current selection.
        constexpr uint32_t VREF_BM_X3 = (1U << 11);  ///< SD ADC Reference Driver bias current triple.
        constexpr uint32_t VINN_IN_BM = (3 << 12);  ///< PGA VlNN Input Driver bias current selection.
        constexpr uint32_t VINN_OUT_BM = (3 << 16);  ///< PGA VlNN Output Driver bias current selection.
        constexpr uint32_t VINN_OUT_BM_X3 = (1U << 19);  ///< PGA VlNN Output Driver bias current triple.
        constexpr uint32_t ADC_BM_DIV2 = (1U << 20);  ///< SD ADC bias current half.
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x40007400;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t ANA_CFG;  ///< Offset: 0x00 - reserved
        volatile uint32_t CTRL;  ///< Offset: 0x04 - DAC clock invert
        volatile uint32_t SIN_CFG0;  ///< Offset: 0x08 - sin amplitude
        volatile uint32_t SIN_CFG1;  ///< Offset: 0x0C - reserved
        volatile uint32_t GAIN_CTRL;  ///< Offset: 0x10 - reserved
        volatile uint32_t CLR_TRG;  ///< Offset: 0x14 - Reserved
        volatile uint32_t DIN;  ///< Offset: 0x18 - DAC data input
        volatile uint32_t INT;  ///< Offset: 0x1C - Reserved
        volatile uint32_t INTEN;  ///< Offset: 0x20 - Reserved
        volatile uint32_t INT_STAT;  ///< Offset: 0x24 - Reserved
        volatile uint32_t STATUS;  ///< Offset: 0x28 - Reserved
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

    // Bit definitions
    /// ANA_CFG Register bits
    namespace ana_cfg_bits {
        constexpr uint32_t FILTER_BM = (3 << 0);  ///< Set the filter bias current
        constexpr uint32_t DAC_AMP = (3 << 4);  ///< Set the current bias of the DAC
        constexpr uint32_t FILTER_BW = (2 << 8);  ///< Set the Miller compensation capacitance of the OPAMP. This compensation capacitance is determined by the off-chip load resistance
        constexpr uint32_t FILTER_150K_EN = (1U << 12);  ///< Set the filter type and bandwidth
        constexpr uint32_t VCM = (4 << 16);  ///< Set the common mode I of the driver.
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< DAC module enable
        constexpr uint32_t SIN_EN = (1U << 1);  ///< Sin wave enable
        constexpr uint32_t MOD_EN = (1U << 2);  ///< Modulator enable
        constexpr uint32_t MOD_WD = (1U << 3);  ///< Modulator output width
        constexpr uint32_t SMPL_RATE = (3 << 4);  ///< sigma delta modulator down sample rate
        constexpr uint32_t SGN_INV = (1U << 7);  ///< Sign bit inverse
        constexpr uint32_t BUF_IN_ALGN = (1U << 8);  ///< FIFO input data align
        constexpr uint32_t BUF_OUT_ALGN = (1U << 9);  ///< FIFO output data and Sine wave generator output align mode when no modulation mode
        constexpr uint32_t TRG_MODE = (1U << 10);  ///< Trigger mode
        constexpr uint32_t TRG_EDGE = (2 << 11);  ///< Trigger edge select
        constexpr uint32_t TRG_SEL = (6 << 16);  ///< Trigger select
        constexpr uint32_t CLK_DIV = (7 << 24);  ///< DAC clock divider
        constexpr uint32_t CLK_INV = (1U << 31);  ///< DAC clock invert
    }

    /// SIN_CFG0 Register bits
    namespace sin_cfg0_bits {
        constexpr uint32_t SIN_FREQ = (16 << 0);  ///< sin frequency
        constexpr uint32_t SIN_AMP = (16 << 16);  ///< sin amplitude
    }

    /// SIN_CFG1 Register bits
    namespace sin_cfg1_bits {
        constexpr uint32_t SIN_DC = (20 << 0);  ///< DC value of sin wave
    }

    /// GAIN_CTRL Register bits
    namespace gain_ctrl_bits {
        constexpr uint32_t GAIN_CTRL = (8 << 0);  ///< digital FIFO output multiply with GAIN_CTRL to scale to certain range. Where GAIN_CTRL is a &amp;lt;u 4 4&amp;gt; value.
    }

    /// CLR_TRG Register bits
    namespace clr_trg_bits {
        constexpr uint32_t BUF_CLR = (1U << 0);  ///< clear buffer signal write 1 to clear.
        constexpr uint32_t SW_TRG = (1U << 1);  ///< Software trigger
    }

    /// DIN Register bits
    namespace din_bits {
        constexpr uint32_t DIN = (32 << 0);  ///< DAC data input
    }

    /// INT Register bits
    namespace int_bits {
        constexpr uint32_t BUF_NFUL_INT = (1U << 0);  ///< Buffer not full interrupt
        constexpr uint32_t BUF_FUL_INT = (1U << 1);  ///< Buffer full interrupt
        constexpr uint32_t BUF_EMT_INT = (1U << 2);  ///< Buffer empty interrupt
        constexpr uint32_t BUF_HEMT_INT = (1U << 3);  ///< buffer half empty interrupt
        constexpr uint32_t BUF_OV_INT = (1U << 4);  ///< Buffer overflow interrupt write 1 to clear
        constexpr uint32_t BUF_UD_INT = (1U << 5);  ///< Buffer underflow interrupt write 1 to clear
        constexpr uint32_t BUF_HFUL_INT = (1U << 6);  ///< Buffer half full interrupt
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t BUF_NFUL_INTEN = (1U << 0);  ///< buffer not full interrupt enable
        constexpr uint32_t BUF_FUL_INTEN = (1U << 1);  ///< buffer full interrupt enable
        constexpr uint32_t BUF_EMT_INTEN = (1U << 2);  ///< buffer empty interrupt enable
        constexpr uint32_t BUF_HEMT_INTEN = (1U << 3);  ///< buffer half empty interrupt enable
        constexpr uint32_t BUF_OV_INTEN = (1U << 4);  ///< buffer over flow interrupt enable
        constexpr uint32_t BUF_UD_INTEN = (1U << 5);  ///< Buffer under flow interrupt enable
        constexpr uint32_t BUF_HFUL_INTEN = (1U << 6);  ///< buffer half full interrupt enable
    }

    /// INT_STAT Register bits
    namespace int_stat_bits {
        constexpr uint32_t BUF_NFUL_INT_STAT = (1U << 0);  ///< buffer not full interrupt status
        constexpr uint32_t BUF_FUL_INT_STAT = (1U << 1);  ///< buffer full interrupt status
        constexpr uint32_t BUF_EMT_INT_STAT = (1U << 2);  ///< buffer empty interrupt status
        constexpr uint32_t BUF_HEMT_INT_STAT = (1U << 3);  ///< buffer half empty interrupt status
        constexpr uint32_t BUF_OV_INT_STAT = (1U << 4);  ///< buffer over flow interrupt status
        constexpr uint32_t BUF_UD_INT_STAT = (1U << 5);  ///< Buffer under flow interrupt status
        constexpr uint32_t BUF_HFUL_INT_STAT = (1U << 6);  ///< buffer half full interrupt status
        constexpr uint32_t DAC_INT_STAT = (1U << 16);  ///< DAC all interrupt status
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t BUSY = (1U << 0);  ///< busy
        constexpr uint32_t BUF_WR_PTR = (3 << 16);  ///< Buffer write pointer
        constexpr uint32_t BUF_RD_PTR = (3 << 20);  ///< Buffer read pointer
    }

}

// ============================================================================
// CS Peripheral
// ============================================================================

namespace cs {
    /// Base addresses
    constexpr uint32_t CS_BASE = 0x40007800;

    /// CS Register structure
    struct Registers {
        volatile uint32_t CTRL0;  ///< Offset: 0x00 - CapSense control register 0
        volatile uint32_t CTRL1;  ///< Offset: 0x04 - CapSense control register 1
        volatile uint32_t INT;  ///< Offset: 0x08 - Interrupt status register
        volatile uint32_t INTEN;  ///< Offset: 0x0C - Interrupt mask register
        volatile uint32_t DATA;  ///< Offset: 0x10 - Output data register
        volatile uint32_t LP_CTRL;  ///< Offset: 0x14 - Control register for low power mode
        volatile uint32_t LP_INT;  ///< Offset: 0x18 - Low power interrupt register
        volatile uint32_t LP_INTEN;  ///< Offset: 0x1C - low power interrupt enable register
        volatile uint32_t IDLE_PERIOD;  ///< Offset: 0x20 - Idle preiod number register
    };

    /// Peripheral instances
    inline Registers* CS = reinterpret_cast<Registers*>(CS_BASE);

    // Bit definitions
    /// CTRL0 Register bits
    namespace ctrl0_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< CapSense enable. Write 1 to start work, 0 to stop.
        constexpr uint32_t SRST = (1U << 1);  ///< Soft reset. Set 1 to reset, and 0 to de-assert.
        constexpr uint32_t OSC_FREQ = (6 << 2);  ///< Oscillation frequency control. The driving current will change accordingly.
        constexpr uint32_t CLK_DIV = (9 << 16);  ///< Clock divider from CLK_APB : CLK_CS_DIV = CLK_APB/(CLK_DIV + 1)
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t PERIOD = (16 << 0);  ///< The scan period for one channel, which is PERIOD/(CLK_DIV+1) clock cycles of CLK_APB.
        constexpr uint32_t CH = (8 << 16);  ///< Channel enable, each bit represent one channel, with CH[0] for CS0, CH[1] for CS1
    }

    /// INT Register bits
    namespace int_bits {
        constexpr uint32_t FIFO_NOTEMPTY_INT = (1U << 0);  ///< FIFO not empty status indicator. Will clear automatically if no data available.
        constexpr uint32_t FIFO_HFULL_INT = (1U << 1);  ///< FIFO half full status indicator. Will clear automatically once less than half.
        constexpr uint32_t FIFO_FULL_INT = (1U << 2);  ///< FIFO full status indicator. Will clear automatically once not full.
        constexpr uint32_t SCAN_INT = (1U << 3);  ///< Scan done status flag for all enabled channels. Write 1 to clear.
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t FIFO_NOTEMPTY_INTEN = (1U << 0);  ///< Interrupt mask of FIFO_NOTEMPTY_INT. Set 1 to enable the interrupt.
        constexpr uint32_t FIFO_HFULL_INTEN = (1U << 1);  ///< Interrupt mask of FIFO_HFULL_INT. Set 1 to enable the interrupt.
        constexpr uint32_t FIFO_FULL_INTEN = (1U << 2);  ///< Interrupt mask of FIFO_FULL_INT. Set 1 to enable the interrupt.
        constexpr uint32_t SCAN_INTEN = (1U << 3);  ///< Interrupt mask of SCAN_INT. Set 1 to enable the interrupt.
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (19 << 0);  ///< Output data to MCU: DATA[18:16]: channel index, DATA[15:0]: counter output for that channel.
    }

    /// LP_CTRL Register bits
    namespace lp_ctrl_bits {
        constexpr uint32_t DEBONCE_NUM = (4 << 0);  ///< (DEBONCE_NUM+1) consecutive samples to judge one touch action.
        constexpr uint32_t LP_EN = (1U << 4);  ///< Enable for low power mode.
        constexpr uint32_t LP_CH = (3 << 5);  ///< The index of the channel to monitor in low power mode, representing 0~7.
        constexpr uint32_t THR = (16 << 16);  ///< Threshold to decide the touch action.
    }

    /// LP_INT Register bits
    namespace lp_int_bits {
        constexpr uint32_t LP_INT = (1U << 0);  ///< Interrupt in low power mode when counter output is less than THR.
    }

    /// LP_INTEN Register bits
    namespace lp_inten_bits {
        constexpr uint32_t LP_INTEN = (1U << 0);  ///< Interrupt enable of LP_INT. Set 1 to enable.
    }

    /// IDLE_PERIOD Register bits
    namespace idle_period_bits {
        constexpr uint32_t IDLE_PERIOD = (16 << 0);  ///< Number of idle period. Zero represents no idle time between consecutive scan.
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x40007C00;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - control register
        volatile uint32_t STAT;  ///< Offset: 0x04 - status register
        volatile uint32_t DATA;  ///< Offset: 0x08 - random data output register
        volatile uint32_t INT;  ///< Offset: 0x0C - interrupt register
        volatile uint32_t INTEN;  ///< Offset: 0x10 - interrupt mask register
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< write 1 to enable randome number generator
        constexpr uint32_t START = (1U << 1);  ///< write 1 to start random number generation, auto clear
        constexpr uint32_t NUM = (2 << 4);  ///< total bits
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t BUSY = (1U << 0);  ///< module in processing
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< final random data read by SW
    }

    /// INT Register bits
    namespace int_bits {
        constexpr uint32_t DONE = (1U << 0);  ///< random data generate done
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t DONE_INTEN = (1U << 0);  ///< random data generate done mask
    }

}

// ============================================================================
// QDEC0 Peripheral
// ============================================================================

namespace qdec0 {
    /// Base addresses
    constexpr uint32_t QDEC0_BASE = 0x40009000;

    /// QDEC0 Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - control register
        volatile uint32_t SAMP_CTRL;  ///< Offset: 0x04 - QDEC sample settting register
        volatile uint32_t SAMPLE;  ///< Offset: 0x08 - QDEC sample result register
        volatile uint32_t ACC;  ///< Offset: 0x0C - QDEC accumulate register
        volatile uint32_t ACC_R;  ///< Offset: 0x10 - QDEC accumulate snapshot register
        volatile uint32_t DB;  ///< Offset: 0x14 - double sample register
        volatile uint32_t DB_R;  ///< Offset: 0x18 - DB snapshot register
        volatile uint32_t INT;  ///< Offset: 0x1C - interrupt register
        volatile uint32_t INTEN;  ///< Offset: 0x20 - interrupt mask register
        volatile uint32_t STAT;  ///< Offset: 0x24 - QDEC is running
    };

    /// Peripheral instances
    inline Registers* QDEC0 = reinterpret_cast<Registers*>(QDEC0_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t QDEC_EN = (1U << 0);  ///< no description available
        constexpr uint32_t START = (1U << 1);  ///< no description available
        constexpr uint32_t STOP = (1U << 2);  ///< no description available
        constexpr uint32_t SOFT_CLR = (1U << 3);  ///< no description available
        constexpr uint32_t AUTO_CLR_EN = (1U << 4);  ///< no description available
        constexpr uint32_t SINGLE_SAMPLE_SRST_EN = (1U << 5);  ///< no description available
        constexpr uint32_t DB_FILTER_EN = (1U << 6);  ///< no description available
    }

    /// SAMP_CTRL Register bits
    namespace samp_ctrl_bits {
        constexpr uint32_t DIVIDE = (5 << 0);  ///< divide number to APB clk 0~20 total 21modes
        constexpr uint32_t PTS = (4 << 8);  ///< total sample points 0~11 total 12modes cf. 8.2
        constexpr uint32_t DB_SAMP_DIV = (4 << 16);  ///< Debounce filter sample clk devide cf. 8.3
    }

    /// SAMPLE Register bits
    namespace sample_bits {
        constexpr uint32_t SAMPLE = (2 << 0);  ///< Sample value each time (2's complement)
    }

    /// ACC Register bits
    namespace acc_bits {
        constexpr uint32_t ACC = (11 << 0);  ///< shift counter (-1 &amp; +1 ) normal case
    }

    /// ACC_R Register bits
    namespace acc_r_bits {
        constexpr uint32_t ACC_R = (11 << 0);  ///< ACC RO snapshot when END event is valid
    }

    /// DB Register bits
    namespace db_bits {
        constexpr uint32_t DB = (4 << 0);  ///< 2 trans counter ERROR case max value 15.
    }

    /// DB_R Register bits
    namespace db_r_bits {
        constexpr uint32_t DB_R = (4 << 0);  ///< DB_R RO snapshot when END event is valid
    }

    /// INT Register bits
    namespace int_bits {
        constexpr uint32_t SINGLE_SAMPLE = (1U << 0);  ///< Each time when normal sample is done
        constexpr uint32_t SAMPLE_END = (1U << 1);  ///< END event triggered
        constexpr uint32_t ACC_OF = (1U << 2);  ///< Normal sample (+1/-1) number is overflow
        constexpr uint32_t DB_OF = (1U << 3);  ///< Double sample (2 trans )number is overflow
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t SINGLE_SAMPLE_INTEN = (1U << 0);  ///< single sample done interrupt enable
        constexpr uint32_t SAMPLE_END_INTEN = (1U << 1);  ///< sample end interrupt enable
        constexpr uint32_t ACC_OF_INTEN = (1U << 2);  ///< normal sample overflow interrupt enable
        constexpr uint32_t DB_OF_INTEN = (1U << 3);  ///< double sample overflow interrupt enable
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t BUSY = (1U << 0);  ///< QDEC is running
    }

}

// ============================================================================
// QDEC1 Peripheral
// ============================================================================

namespace qdec1 {
    /// Base addresses
    constexpr uint32_t QDEC1_BASE = 0x40009800;

    /// QDEC1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* QDEC1 = reinterpret_cast<Registers*>(QDEC1_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4000B000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - RTC control register
        volatile uint32_t STATUS;  ///< Offset: 0x04 - RTC status register
        volatile uint32_t SEC;  ///< Offset: 0x08 - RTC second register
        volatile uint32_t CAL;  ///< Offset: 0x10 - RTC calibration register
        volatile uint32_t CNT_VAL;  ///< Offset: 0x14 - RTC count value register
        volatile uint32_t CNT2_CTRL;  ///< Offset: 0x20 - Free running control register
        volatile uint32_t THR_INT;  ///< Offset: 0x24 - interrupt threshold of free running counter register
        volatile uint32_t THR_RST;  ///< Offset: 0x28 - reset threshold of free running counter register
        volatile uint32_t CNT2;  ///< Offset: 0x2C - free running count value
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SEC_INT_EN = (1U << 0);  ///< RTC second interrupt enable
        constexpr uint32_t CFG = (1U << 2);  ///< RTC second configuration control. This bit is self-cleared after synchronization
        constexpr uint32_t CAL_EN = (1U << 8);  ///< Calibration enable
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SEC_INT = (1U << 0);  ///< Second interrupt flag
        constexpr uint32_t CTRL_SYNC = (1U << 8);  ///< Control Register synchronization busy indicator
        constexpr uint32_t STATUS_SYNC = (1U << 9);  ///< Status Register synchronization busy indicator
        constexpr uint32_t SEC_SYNC = (1U << 10);  ///< Second configuration Register synchronization busy indicator
        constexpr uint32_t CALIB_SYNC = (1U << 12);  ///< Calibration Register synchronization busy indicator
        constexpr uint32_t FREE_SYNC = (1U << 16);  ///< Free running counter control Register synchronization busy indicator
        constexpr uint32_t THR_INT_SYNC = (1U << 17);  ///< Free running counter interrupt Threshold Register synchronization busy indicator
        constexpr uint32_t THR_RST_SYNC = (1U << 18);  ///< Free running counter Reset Threshold Register synchronization busy indicator
        constexpr uint32_t FREE_RUNNING_INT = (1U << 31);  ///< Free running interrupt status.
    }

    /// SEC Register bits
    namespace sec_bits {
        constexpr uint32_t SEC = (32 << 0);  ///< Second configuration register.
    }

    /// CAL Register bits
    namespace cal_bits {
        constexpr uint32_t PPM = (16 << 0);  ///< RTC calibration ppm value the precision is 1 ppm.
        constexpr uint32_t DIR = (1U << 16);  ///< RTC calibration direction indicator
    }

    /// CNT_VAL Register bits
    namespace cnt_val_bits {
        constexpr uint32_t CNT = (15 << 0);  ///< RTC counter current value read only.
    }

    /// CNT2_CTRL Register bits
    namespace cnt2_ctrl_bits {
        constexpr uint32_t CNT2_EN = (1U << 0);  ///< 1 to enable free running counter
        constexpr uint32_t CNT2_INT_EN = (1U << 1);  ///< 1 to enable free running interrupt
        constexpr uint32_t CNT2_WAKEUP = (1U << 2);  ///< 1 to enable free running wakeup
        constexpr uint32_t CNT2_RST = (1U << 3);  ///< 1 to enable free running reset
    }

    /// THR_INT Register bits
    namespace thr_int_bits {
        constexpr uint32_t THR_INT = (32 << 0);  ///< The Threshold of free running counter is to generate free running interrupt.
    }

    /// THR_RST Register bits
    namespace thr_rst_bits {
        constexpr uint32_t THR_RST = (32 << 0);  ///< The Threshold of free running counter is to generate free running reset.
    }

    /// CNT2 Register bits
    namespace cnt2_bits {
        constexpr uint32_t CNT2 = (32 << 0);  ///< The current value of free running counter
    }

}

// ============================================================================
// AGC Peripheral
// ============================================================================

namespace agc {
    /// Base addresses
    constexpr uint32_t AGC_BASE = 0x4000C000;

    /// AGC Register structure
    struct Registers {
        volatile uint32_t CTRL0;  ///< Offset: 0x00 - AGC control register 0
        volatile uint32_t CTRL1;  ///< Offset: 0x04 - AGC control register 1
        volatile uint32_t CTRL2;  ///< Offset: 0x08 - AGC control register 2
        volatile uint32_t CTRL3;  ///< Offset: 0x0C - AGC control register 3
        volatile uint32_t CTRL4;  ///< Offset: 0x10 - AGC control register 4
        volatile uint32_t CTRL5;  ///< Offset: 0x14 - AGC control register 5
        volatile uint32_t STAT;  ///< Offset: 0x18 - AGC status register
    };

    /// Peripheral instances
    inline Registers* AGC = reinterpret_cast<Registers*>(AGC_BASE);

    // Bit definitions
    /// CTRL0 Register bits
    namespace ctrl0_bits {
        constexpr uint32_t PPF_INTRPT_MOD = (2 << 0);  ///< Control whether fsm can interrupt
        constexpr uint32_t FREZ_MOD = (2 << 2);  ///< Control whether fsm can restore last value when correalation trigh happens
        constexpr uint32_t RRF_GAIN_SEL = (3 << 4);  ///< LNA gain controlGAIN=26-12*LNA_GAIN_SEL
        constexpr uint32_t RRF_WEN = (1U << 7);  ///< Lna gain write enable
        constexpr uint32_t PPF_GAIN = (4 << 8);  ///< PPF gain controlGain=36-3*PPF_GAIN
        constexpr uint32_t PPF_WEN = (1U << 12);  ///< Ppf gain write enable
        constexpr uint32_t PKWT_TH_DIG_1 = (5 << 13);  ///< PKWT_TH_DIG + PKWT_TH_DIG_ADD in ccode
        constexpr uint32_t PD_CLR_EN = (1U << 18);  ///< Force clear analog PD
        constexpr uint32_t PD_RST_LEN = (3 << 19);  ///< Pd disable time when reset0h0us 1h8us 2h16us 7h56us
        constexpr uint32_t RFAGC_FSYNC_DET_DIS = (1U << 22);  ///< Use to control rfagc gain adjust0brfagc stops when sync 1brfagc always on
        constexpr uint32_t RFAGC_DIRECTION_FREEZE = (1U << 23);  ///< Use to disable rfagc gain adjust when switching antenna at direction found mode0b rfagc enable 1brfagc disable
        constexpr uint32_t DOWN_24_EN = (1U << 24);  ///< Lna decrease 24dbm0bdisable 1benable
        constexpr uint32_t SWITCH_PD_RST_LEN = (2 << 25);  ///< Pd disable time when direction found rfagc reset00b2us 01b4us 10b8us 11b16us
        constexpr uint32_t GLNA_MAX_REDU = (1U << 27);  ///< Lna max gain reduce 12dbm0bdisable 1benable
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t PD3_TH_REG = (3 << 0);  ///< Pd3 threshold
        constexpr uint32_t PD3_TH_HYST_REG = (4 << 3);  ///< Desired upper boundary
        constexpr uint32_t PKWT_TH_ANA_1 = (6 << 7);  ///< PKWT_TH_ANA + PKWT_TH_ANA_ADD
        constexpr uint32_t PKWT_TH_ANA_0 = (5 << 13);  ///< PKWT_TH_ANA in ccode
        constexpr uint32_t PKWT_TH_DIG_0 = (5 << 18);  ///< PKWT_TH_DIG in ccode
        constexpr uint32_t SETL_TH_PPF_2 = (5 << 23);  ///< SETL_TH_PPF_2 + DLY_DIG 1 in ccode
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t PPF_PDVTH_LOW = (1U << 8);  ///< PPF peak detect threshold select
        constexpr uint32_t RRF_MG_PK = (3 << 9);  ///< LNA medium gain peak detect threshold selectAMP=(400-25* LNA_MG_PK)mv
        constexpr uint32_t RRF_HG_PK = (3 << 12);  ///< LNA high gain peak detect threshold selectAMP=(100-8* LNA_HG_PK)mv
    }

    /// CTRL3 Register bits
    namespace ctrl3_bits {
        constexpr uint32_t GF2_PAR00 = (4 << 0);  ///< no description available
        constexpr uint32_t GF2_PAR01 = (4 << 4);  ///< no description available
        constexpr uint32_t GF2_PAR10 = (4 << 8);  ///< no description available
        constexpr uint32_t SETL_TH_OVSHT_DIG = (3 << 12);  ///< no description available
        constexpr uint32_t SETL_TH_OVSHT_INTRPT = (3 << 15);  ///< no description available
        constexpr uint32_t SETL_TH_OVSHT = (3 << 18);  ///< no description available
    }

    /// CTRL4 Register bits
    namespace ctrl4_bits {
        constexpr uint32_t SETL_TH_PD1 = (4 << 0);  ///< no description available
        constexpr uint32_t SETL_TH_PD2 = (4 << 4);  ///< no description available
        constexpr uint32_t SETL_TH_PD3_1 = (6 << 8);  ///< no description available
        constexpr uint32_t SETL_TH_PD3_2 = (6 << 14);  ///< no description available
        constexpr uint32_t GF2_STAT24_TH = (4 << 20);  ///< no description available
    }

    /// CTRL5 Register bits
    namespace ctrl5_bits {
        constexpr uint32_t TEST_CTRL = (4 << 0);  ///< no description available
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t GLNA_CODE_OUT = (3 << 0);  ///< no description available
        constexpr uint32_t GF2_CODE_OUT = (4 << 3);  ///< no description available
        constexpr uint32_t RFAGC_TRIGGER_O = (1U << 7);  ///< no description available
        constexpr uint32_t RF_GAIN = (7 << 8);  ///< no description available
        constexpr uint32_t NUM_GAIN_ADJ = (5 << 15);  ///< no description available
        constexpr uint32_t CUR_STAT = (3 << 20);  ///< no description available
    }

}

// ============================================================================
// PROP Peripheral
// ============================================================================

namespace prop {
    /// Base addresses
    constexpr uint32_t PROP_BASE = 0x4000D000;

    /// PROP Register structure
    struct Registers {
        volatile uint32_t TX_BUF;  ///< Offset: 0x00 - transmit data buffer input port register
        volatile uint32_t RX_BUF;  ///< Offset: 0x04 - received data buffer output register
        volatile uint32_t STAT;  ///< Offset: 0x08 - status register
    };

    /// Peripheral instances
    inline Registers* PROP = reinterpret_cast<Registers*>(PROP_BASE);

    // Bit definitions
    /// TX_BUF Register bits
    namespace tx_buf_bits {
        constexpr uint32_t TX_BUF = (8 << 0);  ///< TX BUF
    }

    /// RX_BUF Register bits
    namespace rx_buf_bits {
        constexpr uint32_t RX_BUF = (8 << 0);  ///< RX BUF
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t BIT_ORDER = (1U << 0);  ///< no description available
        constexpr uint32_t TX_INTEN = (1U << 1);  ///< TX interrupt enable
        constexpr uint32_t RX_INTEN = (1U << 2);  ///< RX interrupt enable
        constexpr uint32_t RX_INT = (1U << 3);  ///< RX interrupt
        constexpr uint32_t TX_INT = (1U << 4);  ///< TX interrupt
        constexpr uint32_t RX_BUSY = (1U << 5);  ///< RX is busy
        constexpr uint32_t TX_BUSY = (1U << 6);  ///< TX is busy
        constexpr uint32_t CLR = (1U << 7);  ///< Clear intf control register.
    }

}

// ============================================================================
// RADIO Peripheral
// ============================================================================

namespace radio {
    /// Base addresses
    constexpr uint32_t BLEDP_BASE = 0x4000E000;

    /// RADIO Register structure
    struct Registers {
        volatile uint32_t DP_TOP_SYSTEM_CTRL;  ///< Offset: 0x00 - datapath system control register
        volatile uint32_t PROP_MODE_CTRL;  ///< Offset: 0x04 - properity mode control register
        volatile uint32_t ACCESS_ADDRESS;  ///< Offset: 0x08 - access address register
        volatile uint32_t ANT_PDU_DATA0;  ///< Offset: 0x0C - pdu data 0 to 1 byte, and preamble register
        volatile uint32_t ANT_PDU_DATA1;  ///< Offset: 0x10 - pdu data 2 to 5 byte
        volatile uint32_t ANT_PDU_DATA2;  ///< Offset: 0x14 - pdu data 6 to 9 byte
        volatile uint32_t ANT_PDU_DATA3;  ///< Offset: 0x18 - pdu data 10 to 13 byte
        volatile uint32_t ANT_PDU_DATA4;  ///< Offset: 0x1C - pdu data 14 to 17 byte
        volatile uint32_t ANT_PDU_DATA5;  ///< Offset: 0x20 - pdu data 18 to 21 byte
        volatile uint32_t ANT_PDU_DATA6;  ///< Offset: 0x24 - pdu data 22 to 25 byte
        volatile uint32_t ANT_PDU_DATA7;  ///< Offset: 0x28 - pdu data 26 to 29 byte
        volatile uint32_t CRCSEED;  ///< Offset: 0x2C - crc seed
        volatile uint32_t DP_FUNCTION_CTRL;  ///< Offset: 0x30 - datapath function control register
        volatile uint32_t DP_TEST_CTRL;  ///< Offset: 0x34 - datapath test iinterface register
        volatile uint32_t BLE_DP_STATUS1;  ///< Offset: 0x38 - datapath status register 1
        volatile uint32_t BLE_DP_STATUS2;  ///< Offset: 0x3C - datapath status register 2
        volatile uint32_t BLE_DP_STATUS3;  ///< Offset: 0x40 - datapath status register 3
        volatile uint32_t BLE_DP_STATUS4;  ///< Offset: 0x44 - datapath status register 4
        volatile uint32_t RX_FRONT_END_CTRL1;  ///< Offset: 0x48 - rx front end control register 1
        volatile uint32_t RX_FRONT_END_CTRL2;  ///< Offset: 0x4C - rx front end control register 2
        volatile uint32_t FREQ_DOMAIN_CTRL1;  ///< Offset: 0x50 - frequency domain control register 1
        volatile uint32_t FREQ_DOMAIN_CTRL2;  ///< Offset: 0x54 - frequency domain control register 2
        volatile uint32_t FREQ_DOMAIN_CTRL3;  ///< Offset: 0x58 - frequency domain control register 3
        volatile uint32_t FREQ_DOMAIN_CTRL4;  ///< Offset: 0x5C - frequency domain control register 4
        volatile uint32_t FREQ_DOMAIN_CTRL5;  ///< Offset: 0x60 - frequency domain control register 5
        volatile uint32_t FREQ_DOMAIN_CTRL6;  ///< Offset: 0x64 - frequency domain control register 5
        volatile uint32_t HP_MODE_CTRL1;  ///< Offset: 0x68 - when high hp mode training size same as cfo tracking.
        volatile uint32_t HP_MODE_CTRL2;  ///< Offset: 0x6C - q paramter in training period of phase offset iir of bmc
        volatile uint32_t FREQ_DOMAIN_STATUS1;  ///< Offset: 0x70 - frequency domain status register 1
        volatile uint32_t FREQ_DOMAIN_STATUS2;  ///< Offset: 0x74 - frequency domain status register 2
        volatile uint32_t DP_AA_ERROR_CTRL;  ///< Offset: 0x84 - AA error control register
        volatile uint32_t DP_INT;  ///< Offset: 0x88 - data path interrupt register
        volatile uint32_t DP_AA_ERROR_TH;  ///< Offset: 0x8C - AA error threshold register
        volatile uint32_t DF_ANTENNA_CTRL;  ///< Offset: 0x90 - antenna register
        volatile uint32_t ANTENNA_MAP01;  ///< Offset: 0x94 - antenna switch map register 0
        volatile uint32_t ANTENNA_MAP23;  ///< Offset: 0x98 - antenna switch map register 1
        volatile uint32_t ANTENNA_MAP45;  ///< Offset: 0x9C - antenna switch map register 2
        volatile uint32_t ANTENNA_MAP67;  ///< Offset: 0xA0 - antenna switch map register 3
    };

    /// Peripheral instances
    inline Registers* BLEDP = reinterpret_cast<Registers*>(BLEDP_BASE);

    // Bit definitions
    /// DP_TOP_SYSTEM_CTRL Register bits
    namespace dp_top_system_ctrl_bits {
        constexpr uint32_t RX_PDU_LEN_IN = (14 << 0);  ///< pdu length user programmed header+payload unit is bit.
        constexpr uint32_t AA_SEL = (1U << 14);  ///< access address selection
        constexpr uint32_t PDU_LEN_SEL = (1U << 15);  ///< pdu length selection
        constexpr uint32_t H_IDX = (8 << 16);  ///< h index from 0.25 to 0.75 default is 0.5.
        constexpr uint32_t RX_EN_SEL = (1U << 24);  ///< rx enable select signal
        constexpr uint32_t TX_EN_SEL = (1U << 25);  ///< tx enable select signal
        constexpr uint32_t RX_REQ = (1U << 26);  ///< rx request.
        constexpr uint32_t TX_REQ = (1U << 27);  ///< tx request.
        constexpr uint32_t RX_MODE = (2 << 28);  ///< rx mode
        constexpr uint32_t ANT_DATA_START = (1U << 30);  ///< ant mode data start signal need write 0 first then to 1.
        constexpr uint32_t DET_MODE = (1U << 31);  ///< detection mode 0low ppwer mode 1high performance mode.
    }

    /// PROP_MODE_CTRL Register bits
    namespace prop_mode_ctrl_bits {
        constexpr uint32_t PROP_AA_ADDR_IN = (8 << 0);  ///< prop mode when access address is 5 byte the access address is {prop_aa_addr_in aa_addr_in} otherwise is aa_addr_in
        constexpr uint32_t PROP_CRC_NUM = (2 << 8);  ///< prop mode crc number
        constexpr uint32_t PROP_AA_NUM = (2 << 12);  ///< prop mode network address number
        constexpr uint32_t PROP_PRE_NUM = (3 << 16);  ///< prop mode preamble number
        constexpr uint32_t PROP_DATA_RATE = (2 << 20);  ///< prop mode data rate
        constexpr uint32_t PROP_DIRECTION_RATE = (2 << 22);  ///< prop direction find mode sample rate
        constexpr uint32_t PROP_DIRECTION_MODE = (1U << 24);  ///< prop direction find mode just work at prop mode.
        constexpr uint32_t RX_ALWAYS_ON = (1U << 25);  ///< rx always on
        constexpr uint32_t TX_ALWAYS_ON = (1U << 26);  ///< tx always on
        constexpr uint32_t TX_POWER_DONE_TIME = (5 << 27);  ///< tx power down time in ant mode and prop mode unit is us.
    }

    /// ACCESS_ADDRESS Register bits
    namespace access_address_bits {
        constexpr uint32_t AA_ADDR_IN = (32 << 0);  ///< access address user programmed.
    }

    /// ANT_PDU_DATA0 Register bits
    namespace ant_pdu_data0_bits {
        constexpr uint32_t PDU_DATA0 = (16 << 0);  ///< pdu data 0 to 1 byte
        constexpr uint32_t PATTERN_SEL = (4 << 16);  ///< pattern selection
        constexpr uint32_t TEST_PATTERN_EN = (1U << 20);  ///< enable test pattern.
        constexpr uint32_t PROP_PREAMBLE_WEN = (1U << 23);  ///< when high enable manual prop mode preamble.
        constexpr uint32_t PROP_PREAMBLE = (8 << 24);  ///< prop mode preamble.
    }

    /// ANT_PDU_DATA1 Register bits
    namespace ant_pdu_data1_bits {
        constexpr uint32_t PDU_DATA1 = (32 << 0);  ///< pdu data 2 to 5 byte
    }

    /// ANT_PDU_DATA2 Register bits
    namespace ant_pdu_data2_bits {
        constexpr uint32_t PDU_DATA2 = (32 << 0);  ///< pdu data 6 to 9 byte
    }

    /// ANT_PDU_DATA3 Register bits
    namespace ant_pdu_data3_bits {
        constexpr uint32_t PDU_DATA3 = (32 << 0);  ///< pdu data 10 to 13 byte
    }

    /// ANT_PDU_DATA4 Register bits
    namespace ant_pdu_data4_bits {
        constexpr uint32_t PDU_DATA4 = (32 << 0);  ///< pdu data 14 to 17 byte
    }

    /// ANT_PDU_DATA5 Register bits
    namespace ant_pdu_data5_bits {
        constexpr uint32_t PDU_DATA5 = (32 << 0);  ///< pdu data 18 to 21 byte
    }

    /// ANT_PDU_DATA6 Register bits
    namespace ant_pdu_data6_bits {
        constexpr uint32_t PDU_DATA6 = (32 << 0);  ///< pdu data 22 to 25 byte
    }

    /// ANT_PDU_DATA7 Register bits
    namespace ant_pdu_data7_bits {
        constexpr uint32_t PDU_DATA7 = (32 << 0);  ///< pdu data 26 to 29 byte
    }

    /// CRCSEED Register bits
    namespace crcseed_bits {
        constexpr uint32_t CRC_SEED_IN = (24 << 0);  ///< user programmed crc seed.
        constexpr uint32_t CRC_SEED_WEN = (1U << 24);  ///< when high enable manual program crc seed.
    }

    /// DP_FUNCTION_CTRL Register bits
    namespace dp_function_ctrl_bits {
        constexpr uint32_t DP_STATISTICS_SEL = (3 << 0);  ///< datapath statistics selection.
        constexpr uint32_t CHF_COEF_WEN = (1U << 3);  ///< manual select channel filter coefficent.
        constexpr uint32_t CHF_COEF_IDX = (2 << 4);  ///< no description available
        constexpr uint32_t LP_SNR_LEN_AUTO = (1U << 6);  ///< when enable auto adjust lp mode snr acc length otherwise the legnth fixed.
        constexpr uint32_t DOUT_ADJ_DIS = (1U << 7);  ///< data delay adjust disable.
        constexpr uint32_t LP_ADJ_MODE = (1U << 8);  ///< lp mode delay adjust mode
        constexpr uint32_t FR_OFFSET_EN = (1U << 9);  ///< pdu frequency offset track enable.
        constexpr uint32_t DC_AVE_EN = (1U << 10);  ///< when high enable cfo estimation average.
        constexpr uint32_t FIX_DELAY_EN = (1U << 11);  ///< no description available
        constexpr uint32_t TRACK_LEN = (2 << 12);  ///< track length
        constexpr uint32_t TRACK_LEN_WEN = (1U << 14);  ///< when high manual track length.
        constexpr uint32_t XCORR_FILT_EN = (1U << 16);  ///< when high enable xcorr filter.
        constexpr uint32_t XCORR_FULLWIN_EN = (1U << 17);  ///< when xcorr_win_auto_en low full sync enable.
        constexpr uint32_t XCORR_AA_LEN = (1U << 18);  ///< select access address bit number
        constexpr uint32_t XCORR_AA_LEN_WEN = (1U << 19);  ///< enable manual correlation aa length.
        constexpr uint32_t XCORR_WIN_AUTO_EN = (1U << 20);  ///< correlation window size auto selection enable.
        constexpr uint32_t RESAMPLER_TAP = (1U << 21);  ///< resampler tap number
        constexpr uint32_t RESAMPLER_TAP_WEN = (1U << 22);  ///< when high enable manual resampler tap number otherwise auto selection.
        constexpr uint32_t RESAMPLER_BP = (1U << 23);  ///< resampler enable or bypass
        constexpr uint32_t FAGC_WIN_LEN = (1U << 24);  ///< select estimation length
        constexpr uint32_t FAGC_WEN = (1U << 25);  ///< when high enable manual fine agc gain.
        constexpr uint32_t HP_CFO_EN = (1U << 26);  ///< when hp mode cfo estimation enable
        constexpr uint32_t CFO_TRACK_EN = (1U << 27);  ///< tracking cfo enable.
        constexpr uint32_t CFO_INI_EN = (1U << 28);  ///< initial cfo enable.
        constexpr uint32_t ADC_IN_FLIP = (1U << 29);  ///< when 1 exchange i and q signals.
        constexpr uint32_t TX_EN_MODE = (1U << 30);  ///< transmit mode
        constexpr uint32_t RX_EN_MODE = (1U << 31);  ///< receiver mode
    }

    /// DP_TEST_CTRL Register bits
    namespace dp_test_ctrl_bits {
        constexpr uint32_t TIF_SEL = (8 << 0);  ///< test interface selection.
        constexpr uint32_t TIF_CLK_SEL = (2 << 8);  ///< test interface clock selection
        constexpr uint32_t CORDIC_DAC_OUT = (1U << 11);  ///< when high cordic to dac
        constexpr uint32_t TIF_EN = (1U << 12);  ///< test interface enable
        constexpr uint32_t IMR_INV = (1U << 13);  ///< datapath mixer nco if selection
        constexpr uint32_t CLK_TX_GATE_DIS = (1U << 14);  ///< clock tx gate disable
        constexpr uint32_t BUF_FULL_OFFRF_DIS = (1U << 15);  ///< (new standard)______when high rf always on in rx_en other wise when buffer full rf will be off.
        constexpr uint32_t CLK_BUST_GATE_DIS = (1U << 16);  ///< clock burst gate disable
        constexpr uint32_t CLK_RX_GATE_DIS = (1U << 17);  ///< clock rx gate disable
        constexpr uint32_t CLK_LPDET_GATE_DIS = (1U << 18);  ///< clock lp mode detector gate disable
        constexpr uint32_t CLK_HPDET_GATE_DIS = (1U << 19);  ///< clock hp mode detector gate disable
        constexpr uint32_t CLK_RFE_GATE_DIS = (1U << 20);  ///< clock rfe gate disable
        constexpr uint32_t IQSWAP_XOR = (1U << 21);  ///< iq swap xor.
        constexpr uint32_t DAC_TEST_EN = (1U << 23);  ///< dac test enable dac input comes from register
        constexpr uint32_t DAC_TEST = (8 << 24);  ///< dac input data value
    }

    /// BLE_DP_STATUS1 Register bits
    namespace ble_dp_status1_bits {
        constexpr uint32_t SNR_EST = (8 << 0);  ///< snr estimation
        constexpr uint32_t CNR_EST = (6 << 8);  ///< cnr estimation
        constexpr uint32_t AGC_RSSI = (8 << 16);  ///< signal rssi db value.
        constexpr uint32_t AGC_RSSI_READY = (1U << 24);  ///< signal rssi valid.
        constexpr uint32_t SNR_VLD = (1U << 25);  ///< snr estimation valid.
        constexpr uint32_t CNR_VLD = (1U << 26);  ///< cnr estimation valid.
        constexpr uint32_t TX_BUSY = (1U << 27);  ///< tx busy signal.
    }

    /// BLE_DP_STATUS2 Register bits
    namespace ble_dp_status2_bits {
        constexpr uint32_t VALID_PCK_NUM = (16 << 0);  ///< received valid packet number.
        constexpr uint32_t AA_ERR_NUM = (6 << 16);  ///< access address error number.
        constexpr uint32_t CRC_ERROR = (1U << 29);  ///< indicator of packet crc error.
        constexpr uint32_t BURST_DET = (1U << 30);  ///< indicator of burst detection
        constexpr uint32_t DP_STATUS_VLD_0 = (1U << 31);  ///< data path status valid after access address valid.
    }

    /// BLE_DP_STATUS3 Register bits
    namespace ble_dp_status3_bits {
        constexpr uint32_t FD_CFO_TRACK = (11 << 0);  ///< normalized cfo tracking estimation.
        constexpr uint32_t CFO_EST_FD = (11 << 16);  ///< normalized lp cfo initial estimation.
    }

    /// BLE_DP_STATUS4 Register bits
    namespace ble_dp_status4_bits {
        constexpr uint32_t RESAMPLER_PH = (10 << 0);  ///< resampler phase.
        constexpr uint32_t HP_CFO = (12 << 16);  ///< normalized hp cfo estimation.
        constexpr uint32_t HP_CFO_VLD = (1U << 31);  ///< hp mode cfo estimation result valid
    }

    /// RX_FRONT_END_CTRL1 Register bits
    namespace rx_front_end_ctrl1_bits {
        constexpr uint32_t CFO_COMP = (15 << 0);  ///< ______cfo user programmed.
        constexpr uint32_t DCNOTCH_GIN = (2 << 16);  ///< dc notch coefficient
    }

    /// RX_FRONT_END_CTRL2 Register bits
    namespace rx_front_end_ctrl2_bits {
        constexpr uint32_t FAGC_GAIN = (11 << 0);  ///< fine agc gain.
        constexpr uint32_t FAGC_INI_VAL = (1U << 11);  ///< fagc gain initial value
        constexpr uint32_t CNR_IDX_DELTA = (4 << 12);  ///< cnr index delta.
        constexpr uint32_t FAGC_REF = (8 << 16);  ///< fine agc signal reference.
        constexpr uint32_t CORDIC_MIN_VIN_TH = (4 << 24);  ///< cordic input signal min threshold
        constexpr uint32_t FREQ_TRADE_EN = (1U << 28);  ///< enable frequency trade when cordic input signal small than cordic_min_vin_th
        constexpr uint32_t CHN_SHIFT = (3 << 29);  ///< channel filter shift
    }

    /// FREQ_DOMAIN_CTRL1 Register bits
    namespace freq_domain_ctrl1_bits {
        constexpr uint32_t SYNC_WORD_IN0 = (8 << 0);  ///< manul sync word [3932]
        constexpr uint32_t SYNC_WORD_WEN = (1U << 8);  ///< when high enable manul sync word
        constexpr uint32_t SYNC_P_SEL = (1U << 15);  ///< no description available
        constexpr uint32_t RD_EXBIT_EN = (1U << 16);  ///< read extra 8 samples after sync
        constexpr uint32_t RFAGC_TRACK_DLY = (3 << 17);  ///< buffer settle threshold from 1us to 127us step is 1us
        constexpr uint32_t PROP_DF_16US = (8 << 24);  ///< prop mode direct found waiting 16 us.
    }

    /// FREQ_DOMAIN_CTRL2 Register bits
    namespace freq_domain_ctrl2_bits {
        constexpr uint32_t SYNC_WORD_IN1 = (32 << 0);  ///< manul sync word [310]
    }

    /// FREQ_DOMAIN_CTRL3 Register bits
    namespace freq_domain_ctrl3_bits {
        constexpr uint32_t XCORR_PAR_TH3 = (6 << 0);  ///< xcorr trigger par threshold3
        constexpr uint32_t XCORR_PAR_TH2 = (6 << 8);  ///< xcorr trigger par threshold2
        constexpr uint32_t XCORR_PAR_TH1 = (6 << 16);  ///< xcorr trigger par threshold1
        constexpr uint32_t XCORR_PAR_TH0 = (6 << 24);  ///< xcorr trigger par threshold0
    }

    /// FREQ_DOMAIN_CTRL4 Register bits
    namespace freq_domain_ctrl4_bits {
        constexpr uint32_t XCORR_POW_TH3 = (6 << 0);  ///< xcorr power threshold3
        constexpr uint32_t XCORR_POW_TH2 = (6 << 8);  ///< xcorr power threshold2
        constexpr uint32_t XCORR_POW_TH1 = (6 << 16);  ///< xcorr power threshold1
        constexpr uint32_t XCORR_POW_TH0 = (6 << 24);  ///< xcorr power threshold0
    }

    /// FREQ_DOMAIN_CTRL5 Register bits
    namespace freq_domain_ctrl5_bits {
        constexpr uint32_t GAIN_TED = (2 << 0);  ///< ted gain
        constexpr uint32_t SYNC_DIN_SAT_VALUE = (3 << 4);  ///< &lt;u 1 2&gt;sync din amplitude limit value 0 to 1.75 correspond to 2 to 3.75
        constexpr uint32_t SYNC_DIN_SAT_EN = (1U << 7);  ///< sync din amplitude limit enable
        constexpr uint32_t CNT_SETTLE_IDX = (3 << 8);  ///< buffer settle threshold from 32 to 256 step is 32
        constexpr uint32_t TRIG_XCORR_CNT = (4 << 12);  ///< correlation search window size.
        constexpr uint32_t XCORR_RSSI_TH3 = (4 << 16);  ///< xcorr triger rssi threshold0
        constexpr uint32_t XCORR_RSSI_TH2 = (4 << 20);  ///< xcorr triger rssi threshold0
        constexpr uint32_t XCORR_RSSI_TH1 = (4 << 24);  ///< xcorr triger rssi threshold0
        constexpr uint32_t XCORR_RSSI_TH0 = (4 << 28);  ///< xcorr triger rssi threshold0
    }

    /// FREQ_DOMAIN_CTRL6 Register bits
    namespace freq_domain_ctrl6_bits {
        constexpr uint32_t HP_TRAIN_SIZ = (5 << 0);  ///< hp mode training size.
        constexpr uint32_t HP_HIDX_GAIN = (8 << 8);  ///< h index reference gain when hp mode default is 1.0
        constexpr uint32_t H_REF_GAIN = (6 << 16);  ///< h index reference gain when frequency offset track default is 1.0
        constexpr uint32_t DET_FR_IDX = (2 << 24);  ///< pdu cfo tracking loop gain
        constexpr uint32_t CFO_FR_IDX = (2 << 28);  ///< aa cfo tracking loop gain
    }

    /// HP_MODE_CTRL1 Register bits
    namespace hp_mode_ctrl1_bits {
        constexpr uint32_t HP_BMC_P_TRACK = (6 << 0);  ///< p paramter in search period of frequency offset iir of bmc
        constexpr uint32_t HP_BMC_P_TRAIN = (6 << 8);  ///< p paramter in training period of frequency offset iir of bmc
        constexpr uint32_t HP_BMC_CZ1 = (6 << 16);  ///< cz1 parameter.
        constexpr uint32_t BUF_IDX_DELTA = (4 << 24);  ///< buffer index delta
        constexpr uint32_t WMF2_DSAMP_IDX = (3 << 28);  ///< wmf2 down sampling position -4 to 3
        constexpr uint32_t HP_TRAIN_SIZ_FIX = (1U << 31);  ///< when high hp mode training size same as cfo tracking.
    }

    /// HP_MODE_CTRL2 Register bits
    namespace hp_mode_ctrl2_bits {
        constexpr uint32_t SNR_EST_REF = (8 << 0);  ///< signal amplitude used in snr estimation whose unit is db
        constexpr uint32_t SNR_EST_LEN = (2 << 8);  ///< symbol number used in snr estimation when pdu length is less than 4 8 32 will be used otherwise the value configured from register will be used
        constexpr uint32_t SNR_EST_EN = (1U << 12);  ///< snr estimation in time domain enable
        constexpr uint32_t HP_BMC_Q_TRACK = (8 << 16);  ///< q paramter in search period of phase offset iir of bmc
        constexpr uint32_t HP_BMC_Q_TRAIN = (8 << 24);  ///< q paramter in training period of phase offset iir of bmc
    }

    /// FREQ_DOMAIN_STATUS1 Register bits
    namespace freq_domain_status1_bits {
        constexpr uint32_t MAX_XCORR = (10 << 0);  ///< xcorr_org value at the max par position
        constexpr uint32_t PKT_OFFSET_COM = (9 << 16);  ///< time from access addres last bit to trigger finish.
        constexpr uint32_t NIDX = (4 << 28);  ///< noise db buffer index
    }

    /// FREQ_DOMAIN_STATUS2 Register bits
    namespace freq_domain_status2_bits {
        constexpr uint32_t MAX_PAR_SPWR = (10 << 0);  ///< spwr value at the max par position
        constexpr uint32_t MAX_PAR_XCORR = (10 << 16);  ///< xcorr*xcorr value at the max par position
    }

    /// DP_AA_ERROR_CTRL Register bits
    namespace dp_aa_error_ctrl_bits {
        constexpr uint32_t IQSWAP_SEL = (1U << 0);  ///< when high adc data iq swap with analog iqswap. datapath mixer nco if selection changed with analog iqswap.
        constexpr uint32_t AA_ERROR_EN = (1U << 1);  ///< when high it will reset datapath when aa error.
        constexpr uint32_t AA_ERROR_CNR_EN = (1U << 2);  ///< when high the aa error reset condition is cnr &gt; threshold and aa error. when low it don care cnr.
        constexpr uint32_t AA_ERROR_CNR_SEL = (1U << 3);  ///< when high the cnr threshold is 24. when low the cnr threshold is 32.
    }

    /// DP_INT Register bits
    namespace dp_int_bits {
        constexpr uint32_t DP_INTERRUPT0 = (1U << 0);  ///< datapath interrupt0
        constexpr uint32_t DP_INTERRUPT1 = (1U << 1);  ///< datapath interrupt1
        constexpr uint32_t DP_INTERRUPT2 = (1U << 2);  ///< datapath interrupt2
        constexpr uint32_t DP_INTERRUPT = (1U << 3);  ///< datapath interrupt
        constexpr uint32_t DP_INTERRUPT0_SEL = (4 << 16);  ///< datapath interrupt0 selection
        constexpr uint32_t DP_INTERRUPT1_SEL = (4 << 20);  ///< datapath interrupt1 selection
        constexpr uint32_t DP_INTERRUPT2_SEL = (4 << 24);  ///< datapath interrupt2 selection
        constexpr uint32_t DP_INTERRUPT0_MSK = (1U << 28);  ///< datapath interrupt0 msk
        constexpr uint32_t DP_INTERRUPT1_MSK = (1U << 29);  ///< datapath interrupt1 msk
        constexpr uint32_t DP_INTERRUPT2_MSK = (1U << 30);  ///< datapath interrupt2 msk
        constexpr uint32_t DP_INTERRUPT_MSK = (1U << 31);  ///< datapath interrupt msk
    }

    /// DP_AA_ERROR_TH Register bits
    namespace dp_aa_error_th_bits {
        constexpr uint32_t HP_TRAIN_POSITION = (1U << 0);  ///< when high use the bits just ahead of pdu for rsve training. when low the training bit starts at the track bits.
        constexpr uint32_t CORDIC_IN_SCALE = (1U << 1);  ///< when high cordic input will be auto scaled(shift) according to the magnitude of real/imag data.
        constexpr uint32_t PAR_AUTO_HIGHER_SEL = (1U << 2);  ///< when high par auto higher 1/4 when low par auto higher 1/8 it will work together with par_auto_higher_en and rssi_good_dbm.
        constexpr uint32_t PAR_AUTO_HIGHER_EN = (1U << 3);  ///< when high when signal is good ( rssi large than rssi_good_dbm) it will auto higher the par threshold.
        constexpr uint32_t SNR_GOOD_TH = (3 << 4);  ///< threshold for snr(fd mode calculated use aa) to reset datapath cooperate with cnr snr and aa error.
        constexpr uint32_t CNR_GOOD_TH = (6 << 8);  ///< threshold for cnr to reset datapath cooperate with cnr snr and aa error.
        constexpr uint32_t RSSI_GOOD_TH = (8 << 16);  ///< threshold for rssi to reset datapath cooperate with cnr snr and aa error.
        constexpr uint32_t RSSI_GOOD_DBM = (8 << 24);  ///< when rssi dbm large than the -rssi_good_dbm the signal is good enough to higher the par threshold if the function enable.
    }

    /// DF_ANTENNA_CTRL Register bits
    namespace df_antenna_ctrl_bits {
        constexpr uint32_t SWITCH_MAP_SEL_8F = (2 << 0);  ///< switch antenna map selection 8 to f
        constexpr uint32_t SWITCH_MAP_SEL_07 = (2 << 2);  ///< switch antenna map selection 0 to 7
        constexpr uint32_t EXT_ANTENNA_NUM = (4 << 4);  ///< user programmed switch antenna number
        constexpr uint32_t EXT_ANTENNA_NUM_WEN = (1U << 8);  ///< user programmed switch antenna enable
        constexpr uint32_t BUFFER_BP = (1U << 16);  ///< when high, bypass buffer, and not write/read buffer for datapath power test
        constexpr uint32_t TEST_TD_POWER = (1U << 17);  ///< when high, test rfe,td detector power, other module don't work, the cordic work or not decided by resampler_bp
        constexpr uint32_t TEST_FD_POWER = (1U << 18);  ///< when high, test rfe, cordic and fd detector power, other module don't work
        constexpr uint32_t TEST_SYNC_POWER = (1U << 19);  ///< when high, test rfe. Cordic and sync power. Other module don't work
        constexpr uint32_t TEST_RFE_CORDIC_POWER = (1U << 20);  ///< when high, test rfe and cordic power, other module don't work
        constexpr uint32_t TEST_RFE_POWER = (1U << 21);  ///< when high, test rfe power, other module don't work
        constexpr uint32_t ADC01_SAMPLE_TIME = (1U << 22);  ///< when high, will exchange the adc0/adc1 sample time, to avoid the error sample time for adc0/adc1
        constexpr uint32_t PHY_RATE_MUX = (1U << 23);  ///< ble data rate used in datapath, 0: 1mbps 1: 2mbps
        constexpr uint32_t PHY_RATE_REG = (1U << 24);  ///< user programmed phy data rate
        constexpr uint32_t PHY_RATE_WEN = (1U << 25);  ///< 0: phy rate comes from ble ip 1:phy rate comes from regsiter phy_rate_reg
        constexpr uint32_t PDU_RSSI_WAIT_TIME = (1U << 26);  ///< 0:wait 0us 1: wait 4us
        constexpr uint32_t PDU_RSSI_WIN_LEN = (1U << 27);  ///< select estimation length for pdu rssi calculate
        constexpr uint32_t CAL_PDU_RSSI_EN = (1U << 28);  ///< calculate rssi use pdu data enbale.
        constexpr uint32_t PROP_CRC_AA_DIS = (1U << 29);  ///< prop mode crc check disable check access address.
        constexpr uint32_t PROP_AA_LSB_FIRST = (1U << 30);  ///< prop mode access address lsb first for cbt test.
        constexpr uint32_t PRE_NUM_WEN = (1U << 31);  ///< preamble number write enable
    }

    /// ANTENNA_MAP01 Register bits
    namespace antenna_map01_bits {
        constexpr uint32_t SWITCH_MAP_1 = (14 << 0);  ///< switch antenna map 1
        constexpr uint32_t SWITCH_MAP_0 = (14 << 16);  ///< switch antenna map 0
    }

    /// ANTENNA_MAP23 Register bits
    namespace antenna_map23_bits {
        constexpr uint32_t SWITCH_MAP_3 = (14 << 0);  ///< switch antenna map 3
        constexpr uint32_t SWITCH_MAP_2 = (14 << 16);  ///< switch antenna map 2
    }

    /// ANTENNA_MAP45 Register bits
    namespace antenna_map45_bits {
        constexpr uint32_t SWITCH_MAP_5 = (14 << 0);  ///< switch antenna map 5
        constexpr uint32_t SWITCH_MAP_4 = (14 << 16);  ///< switch antenna map 4
    }

    /// ANTENNA_MAP67 Register bits
    namespace antenna_map67_bits {
        constexpr uint32_t SWITCH_MAP_7 = (14 << 0);  ///< switch antenna map 7
        constexpr uint32_t SWITCH_MAP_6 = (14 << 16);  ///< switch antenna map 6
    }

}

// ============================================================================
// CALIB Peripheral
// ============================================================================

namespace calib {
    /// Base addresses
    constexpr uint32_t CALIB_BASE = 0x4000F000;

    /// CALIB Register structure
    struct Registers {
        volatile uint32_t START;  ///< Offset: 0x00 - calibration start register
        volatile uint32_t STATUS;  ///< Offset: 0x04 - calibration FSM status register
        volatile uint32_t DC_CODE;  ///< Offset: 0x08 - DC code status register
        volatile uint32_t DC_CFG;  ///< Offset: 0x0C - DC code configured code register
        volatile uint32_t RCO_RC_REF_OSC_CODE;  ///< Offset: 0x10 - RCO RC PLL48M OSC code status register
        volatile uint32_t RCO_RC_REF_OSC_CFG;  ///< Offset: 0x14 - RCO RC PLL48M OSC configured code register
        volatile uint32_t VCOA_KVCO2M_CODE;  ///< Offset: 0x18 - reserved
        volatile uint32_t VCOA_KVCO2M_CFG;  ///< Offset: 0x1C - reserved
        volatile uint32_t VCOF_KVCO_PO_CODE;  ///< Offset: 0x20 - reserved
        volatile uint32_t VCOF_KVCO_CFG;  ///< Offset: 0x24 - VCOF hop calibration bypass
        volatile uint32_t VCOF_KVCO_CODE;  ///< Offset: 0x28 - reserved
        volatile uint32_t KVCO_HOP_CODE;  ///< Offset: 0x2C - reserved
        volatile uint32_t VCOF_CNT_SLOPE;  ///< Offset: 0x30 - reserved
        volatile uint32_t XTL_CODE;  ///< Offset: 0x34 - Reserved
        volatile uint32_t XTL_CFG;  ///< Offset: 0x38 - Reserved
        volatile uint32_t CAL_DLY;  ///< Offset: 0x3C - hop calibration delay bypass
        volatile uint32_t DONE;  ///< Offset: 0x40 - Reserved
        volatile uint32_t RRF1;  ///< Offset: 0x400 - Amplitude of LO buffer for active mixer
        volatile uint32_t PLL48_PPF;  ///< Offset: 0x404 - reserved
        volatile uint32_t LO0;  ///< Offset: 0x408 - reserved
        volatile uint32_t LO1;  ///< Offset: 0x40C - Reserved
        volatile uint32_t PA_CTRL;  ///< Offset: 0x410 - Reserved
        volatile uint32_t CTRL;  ///< Offset: 0x800 - Reserved
        volatile uint32_t INT_RAW;  ///< Offset: 0x804 - Reserved
        volatile uint32_t INTEN;  ///< Offset: 0x808 - Reserved
        volatile uint32_t INT_STAT;  ///< Offset: 0x80C - Reserved
        volatile uint32_t TIF;  ///< Offset: 0x810 - reserved
        volatile uint32_t KVCO_MEAN;  ///< Offset: 0x814 - reserved
        volatile uint32_t KVCO_DLT;  ///< Offset: 0x818 - reserved
        volatile uint32_t LO_CFG;  ///< Offset: 0x81C - no description available
        volatile uint32_t LO_TABLE;  ///< Offset: 0x820 - no description available
        volatile uint32_t LO_RATIO;  ///< Offset: 0x824 - no description available
        volatile uint32_t VCO_MOD_CFG;  ///< Offset: 0x828 - TRX 2M mode selection signal
        volatile uint32_t VCO_MOD_STAT;  ///< Offset: 0x82C - no description available
        volatile uint32_t CH_IDX;  ///< Offset: 0x830 - no description available
        volatile uint32_t VCOF_CNT_UP;  ///< Offset: 0x834 - reserved
        volatile uint32_t VCOF_CNT_DN;  ///< Offset: 0x838 - reserved
    };

    /// Peripheral instances
    inline Registers* CALIB = reinterpret_cast<Registers*>(CALIB_BASE);

    // Bit definitions
    /// START Register bits
    namespace start_bits {
        constexpr uint32_t PO_CLB_START = (1U << 0);  ///< Power on calibration start
        constexpr uint32_t HOP_CLB_START = (1U << 1);  ///< Frequency hop calibration start
        constexpr uint32_t OSC_CLB_START = (1U << 2);  ///< OSC calibration start
        constexpr uint32_t REF_CLB_START = (1U << 3);  ///< REF PLL calibration start
        constexpr uint32_t RCO_CLB_START = (1U << 4);  ///< RCO calibration start
        constexpr uint32_t XTL_CLB_START = (1U << 5);  ///< XTAL calibration start
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t TOP_FSM = (5 << 0);  ///< TOP FSM
        constexpr uint32_t DC_FSM = (4 << 5);  ///< DC FSM
        constexpr uint32_t VCOA_FSM = (3 << 9);  ///< VCOA FSM
        constexpr uint32_t VCOF_FSM = (5 << 12);  ///< VCOF FSM
        constexpr uint32_t KVCO_FSM = (4 << 17);  ///< KVCO FSM
        constexpr uint32_t RCO_FSM = (3 << 21);  ///< RCO FSM
        constexpr uint32_t OSC_FSM = (3 << 24);  ///< OSC FSM
        constexpr uint32_t REF_FSM = (3 << 27);  ///< REF FSM
    }

    /// DC_CODE Register bits
    namespace dc_code_bits {
        constexpr uint32_t PPF_DCCAL2_I = (4 << 0);  ///< Power on DC calibration i code
        constexpr uint32_t PPF_DCCAL2_Q = (4 << 4);  ///< Power on DC calibration q code
        constexpr uint32_t PPF_DCCAL_I = (6 << 16);  ///< DC re-calibration i code
        constexpr uint32_t PPF_DCCAL_Q = (6 << 24);  ///< DC re-calibration q code
    }

    /// DC_CFG Register bits
    namespace dc_cfg_bits {
        constexpr uint32_t PPF_DCCAL2_CFG_I = (4 << 0);  ///< Power on DC calibration i code configured
        constexpr uint32_t PPF_DCCAL2_CFG_Q = (4 << 4);  ///< Power on DC calibration q code configured
        constexpr uint32_t DC_2NDCAL_DIS = (1U << 8);  ///< DC calibration disable
        constexpr uint32_t DC_2NDCAL_REQ = (1U << 9);  ///< DC calibration request
        constexpr uint32_t PPF_DCCAL_CFG_I = (6 << 16);  ///< DC re-calibration i code configured
        constexpr uint32_t DC_HOP_CAL_BP = (1U << 22);  ///< DC hop calibration bypass
        constexpr uint32_t PPF_DCCAL_CFG_Q = (6 << 24);  ///< DC re-calibration q code configured
        constexpr uint32_t DC_1STCAL_DIS = (1U << 30);  ///< DC hop calibration disable
        constexpr uint32_t DC_1STCAL_REQ = (1U << 31);  ///< DC hop calibration request
    }

    /// RCO_RC_REF_OSC_CODE Register bits
    namespace rco_rc_ref_osc_code_bits {
        constexpr uint32_t CAU_RCO_CAP = (4 << 0);  ///< RCO calibration output code
        constexpr uint32_t CAU_OSC_CUR = (5 << 8);  ///< OSC calibration output code
        constexpr uint32_t CAU_RC_CAL_OUT2REG = (4 << 16);  ///< RC calibration output code
        constexpr uint32_t PLL48_ENREF = (4 << 24);  ///< REF calibration output code
    }

    /// RCO_RC_REF_OSC_CFG Register bits
    namespace rco_rc_ref_osc_cfg_bits {
        constexpr uint32_t CAU_RCO_CAP_CFG = (4 << 0);  ///< RCO calibration code configured
        constexpr uint32_t RCO_CAL_DIS = (1U << 4);  ///< RCO calibration disable
        constexpr uint32_t RCO_CAL_REQ = (1U << 5);  ///< RCO calibration request
        constexpr uint32_t CAU_OSC_CUR_CFG = (5 << 8);  ///< OSC calibration output code configured
        constexpr uint32_t OSC_CAL_DIS = (1U << 13);  ///< OSC calibration disable
        constexpr uint32_t OSC_CAL_REQ = (1U << 14);  ///< OSC calibration request
        constexpr uint32_t CAU_RC_CAL_REG_IN = (4 << 16);  ///< RC calibration code to analog
        constexpr uint32_t CAU_RC_CAL_DIS = (1U << 20);  ///< RC calibration disable
        constexpr uint32_t RC_CAL_REQ = (1U << 21);  ///< RC calibration request
        constexpr uint32_t PLL48_ENREF_CFG = (4 << 24);  ///< REF calibration output code configured
        constexpr uint32_t REF_CAL_DIS = (1U << 28);  ///< REF PLL calibration disable
        constexpr uint32_t REF_CAL_REQ = (1U << 29);  ///< REF PLL calibration request
    }

    /// VCOA_KVCO2M_CODE Register bits
    namespace vcoa_kvco2m_code_bits {
        constexpr uint32_t KCALF2M_PO = (11 << 0);  ///< KVCO 2M mode calibration power on code
        constexpr uint32_t TX_VCO_AMP = (5 << 16);  ///< VCO TX amplitude calibration output code
        constexpr uint32_t RX_VCO_AMP = (5 << 24);  ///< VCO RX amplitude calibration output code
    }

    /// VCOA_KVCO2M_CFG Register bits
    namespace vcoa_kvco2m_cfg_bits {
        constexpr uint32_t KCALF2M_CFG = (11 << 0);  ///< KVCO 2M mode calibration code configure
        constexpr uint32_t KCALF2M_BP = (1U << 11);  ///< bypass KVCO 2M mode power on calibration
        constexpr uint32_t KVCO_CAL_E = (3 << 12);  ///< no description available
        constexpr uint32_t TX_VCO_AMP_CFG = (5 << 16);  ///< TX VCO amplitude calibration output code configured
        constexpr uint32_t VCOA_CAL_DIS = (1U << 21);  ///< VCO amplitude calibration disable
        constexpr uint32_t VCOA_CAL_REQ = (1U << 22);  ///< VCO amplitude calibration request
        constexpr uint32_t RX_VCO_AMP_CFG = (5 << 24);  ///< RX VCO amplitude calibration output code configured
    }

    /// VCOF_KVCO_PO_CODE Register bits
    namespace vcof_kvco_po_code_bits {
        constexpr uint32_t KCALF_PO = (11 << 0);  ///< KVCO power up calibration result
        constexpr uint32_t TX_VCO_CBANK_PO = (6 << 16);  ///< TX VCO frequency power on calibration output code
        constexpr uint32_t RX_VCO_CBANK_PO = (6 << 24);  ///< RX VCO frequency power on calibration output code
    }

    /// VCOF_KVCO_CFG Register bits
    namespace vcof_kvco_cfg_bits {
        constexpr uint32_t KCALF_CFG = (11 << 0);  ///< KVCO calibration code configure
        constexpr uint32_t KVCO_REQ = (1U << 11);  ///< KVCO calibration request
        constexpr uint32_t KVCO_DIS = (1U << 12);  ///< KVCO calibration disable
        constexpr uint32_t KVCO_SKIP = (1U << 13);  ///< KVCO hop calibration calculation skip
        constexpr uint32_t TX_VCO_CBANK_CFG = (6 << 16);  ///< TX VCO frequency calibration output code configured
        constexpr uint32_t VCOF_CAL_DIS = (1U << 22);  ///< VCO frequency calibration disable
        constexpr uint32_t VCOF_CAL_REQ = (1U << 23);  ///< VCO frequency calibration request
        constexpr uint32_t RX_VCO_CBANK_CFG = (6 << 24);  ///< RX VCO frequency calibration output code configured
        constexpr uint32_t VCOF_SKIP = (1U << 30);  ///< VCOF hop calibration calculation skip
        constexpr uint32_t VCOF_HOP_BP = (1U << 31);  ///< VCOF hop calibration bypass
    }

    /// VCOF_KVCO_CODE Register bits
    namespace vcof_kvco_code_bits {
        constexpr uint32_t KCALF = (11 << 0);  ///< KVCO calibration output at carrier frequency
        constexpr uint32_t TX_VCO_CBANK = (6 << 16);  ///< TX VCO frequency calibration output code
        constexpr uint32_t RX_VCO_CBANK = (6 << 24);  ///< RX VCO frequency calibration output code
    }

    /// KVCO_HOP_CODE Register bits
    namespace kvco_hop_code_bits {
        constexpr uint32_t KCALF1M = (11 << 0);  ///< KVCO hop calibration output at carrier frequency in 1M mode
        constexpr uint32_t KCALF2M = (11 << 16);  ///< KVCO hop calibration output at carrier frequency in 2M mode
    }

    /// VCOF_CNT_SLOPE Register bits
    namespace vcof_cnt_slope_bits {
        constexpr uint32_t TX_VCOF_CNT = (8 << 0);  ///< TX VCO frequency power up calibration 8us count value
        constexpr uint32_t TX_SLOPE = (6 << 8);  ///< TX frequency curve slope
        constexpr uint32_t RX_VCOF_CNT = (8 << 16);  ///< RX VCO frequency power up calibration 8us count value
        constexpr uint32_t RX_SLOPE = (6 << 24);  ///< RX frequency curve slope
    }

    /// XTL_CODE Register bits
    namespace xtl_code_bits {
        constexpr uint32_t XTL_XICTRL_CODE = (6 << 0);  ///< crystal calibration code
        constexpr uint32_t XTL_AMP_DET_OUT = (1U << 8);  ///< crystal comparator output result
    }

    /// XTL_CFG Register bits
    namespace xtl_cfg_bits {
        constexpr uint32_t XTL_XICTRL_CFG = (6 << 0);  ///< crystal calibration CFG
        constexpr uint32_t XTL_CAL_DIS = (1U << 6);  ///< crystal code disable
        constexpr uint32_t XTL_CAL_REQ = (1U << 7);  ///< crystal calibration request
    }

    /// CAL_DLY Register bits
    namespace cal_dly_bits {
        constexpr uint32_t HOP_DLY = (6 << 0);  ///< hop calibration delay time
        constexpr uint32_t HOP_DLY_BP = (1U << 7);  ///< hop calibration delay bypass
        constexpr uint32_t TX_DLY_DIG1M = (2 << 8);  ///< no description available
        constexpr uint32_t TX_DLY_DIG2M = (2 << 10);  ///< no description available
        constexpr uint32_t TX_DLY_DAC_1M = (2 << 12);  ///< no description available
        constexpr uint32_t TX_DLY_DAC_2M = (2 << 14);  ///< no description available
        constexpr uint32_t RX_PWRUP_CNT_TH1M = (8 << 16);  ///< no description available
        constexpr uint32_t RX_PWRUP_CNT_TH2M = (8 << 24);  ///< no description available
    }

    /// DONE Register bits
    namespace done_bits {
        constexpr uint32_t OSC_CAL_DONE = (1U << 2);  ///< OSC calibration done
        constexpr uint32_t REF_CAL_DONE = (1U << 3);  ///< REF PLL calibration done
        constexpr uint32_t RCO_CAL_DONE = (1U << 4);  ///< RCO calibration done
        constexpr uint32_t RC_CAL_DONE = (1U << 5);  ///< RC calibration done
        constexpr uint32_t VCOF_CAL_DONE = (1U << 6);  ///< VCO frequency calibration done
        constexpr uint32_t VCOA_CAL_DONE = (1U << 7);  ///< VCO amplitude calibration done
        constexpr uint32_t DC2ND_CAL_DONE = (1U << 8);  ///< DC 2nd stage calibration done
        constexpr uint32_t DC1ST_CAL_DONE = (1U << 9);  ///< DC 1st stage calibration done
        constexpr uint32_t XTL_CAL_DONE = (1U << 10);  ///< XTL calibration done
        constexpr uint32_t KVCO_CAL_DONE = (1U << 11);  ///< KVCO calibration done
        constexpr uint32_t KVCO_HOP_DONE = (1U << 12);  ///< KVCO calibration done
    }

    /// RRF1 Register bits
    namespace rrf1_bits {
        constexpr uint32_t RRF_INCAP2 = (3 << 0);  ///< LNA input LC cap bank
        constexpr uint32_t RRF_LOAD_CAP = (4 << 3);  ///< LNA load LC cap bank
        constexpr uint32_t RRF_TX_INCAP1 = (3 << 7);  ///< LNA&amp;PA matching cap bank
        constexpr uint32_t RRF_RX_INCAP1 = (3 << 10);  ///< LNA&amp;PA matching cap bank
        constexpr uint32_t RRF_VGATE11_LNA = (3 << 13);  ///< LNA vrega voltage
        constexpr uint32_t RRF_BM_GM = (2 << 16);  ///< Constant gm current control
        constexpr uint32_t RRF_BM_LNA = (2 << 18);  ///< LNA bias current control-
        constexpr uint32_t RRF_BM_MIXER = (2 << 20);  ///< Mixer current bias
        constexpr uint32_t PPF_DCCAL_RES = (2 << 22);  ///< Input res selection of ppf for dccal
        constexpr uint32_t RRF_CAL_MIX_EN = (1U << 24);  ///< no description available
        constexpr uint32_t RRF_CAL_MIX1_EN = (1U << 25);  ///< no description available
        constexpr uint32_t RRF_LO_SEL_P = (2 << 26);  ///< Dc voltage bias control for the pmos switch of active mixer
        constexpr uint32_t RRF_LO_SEL_N = (2 << 28);  ///< Dc voltage bias control for the nmos switch of active mixer
        constexpr uint32_t RRF_LO_AMP = (2 << 30);  ///< Amplitude of LO buffer for active mixer
    }

    /// PLL48_PPF Register bits
    namespace pll48_ppf_bits {
        constexpr uint32_t PPF_BM = (2 << 0);  ///< Ppf current control-
        constexpr uint32_t PPF_IQSW = (1U << 2);  ///< no description available
        constexpr uint32_t PLL48_DIFF_CLK_48M_DIS = (1U << 3);  ///< no description available
        constexpr uint32_t PLL48_TST_CPREF = (4 << 4);  ///< CP current selecting
    }

    /// LO0 Register bits
    namespace lo0_bits {
        constexpr uint32_t VCO_DAC_IPTAT = (4 << 0);  ///< Set the temperature characteristic of TX DAC in order to compensate the modulation gain error of the VCO
        constexpr uint32_t VCO_TST_CP = (4 << 4);  ///< LO CP current control-
        constexpr uint32_t VCO_VTUN_SET = (5 << 8);  ///< Set VTUNE voltage change in order to properly compensate the VUNE error introduced by charge injection when the PLL loop is broken;VTUNE change introduced by this register is around 50uV*(VTUNE_SET-16)
        constexpr uint32_t VCO_ACAL_SET = (3 << 13);  ///< Set the threshold (differential peak) in VCO amplitude calibration-VTH=0.2+0.05*ACAL_SET
        constexpr uint32_t VCO_BM_TXFIL = (2 << 16);  ///< Set the bias current of the TX filter
        constexpr uint32_t VCO_BM_TXDAC = (2 << 18);  ///< Set the bias current of the TX DAC
        constexpr uint32_t VCO_SAMP_EN = (1U << 23);  ///< no description available
        constexpr uint32_t VCO_CAP_HALF_EN = (1U << 24);  ///< no description available
        constexpr uint32_t VCO_SET_VCO_VDD_LOW = (1U << 25);  ///< no description available
        constexpr uint32_t VCO_8OR16M_INV_EN = (1U << 26);  ///< no description available
        constexpr uint32_t VCO_DIV_PD_EN = (1U << 27);  ///< no description available
        constexpr uint32_t VCO_TXDLY1M = (1U << 28);  ///< no description available
        constexpr uint32_t VCO_TXDLY2M = (1U << 29);  ///< no description available
        constexpr uint32_t VCO_RX_CK_TST = (1U << 30);  ///< no description available
        constexpr uint32_t VCO_DSM_INT_EN = (1U << 31);  ///< no description available
    }

    /// LO1 Register bits
    namespace lo1_bits {
        constexpr uint32_t SPEED_UP_TIME = (5 << 0);  ///< LO speed up time
        constexpr uint32_t SW_LO_SPEED_UP = (1U << 5);  ///< software LO speed up
        constexpr uint32_t RX_PLLPFD_EN = (1U << 6);  ///< PLL pfd enable in RX mode
        constexpr uint32_t TX_PLLPFD_EN = (1U << 7);  ///< PLL pfd enable in TX mode
        constexpr uint32_t LO_SET_TIME = (6 << 8);  ///< LO settle time
        constexpr uint32_t MOD_TEST = (1U << 14);  ///< LO open loop or close loop select
        constexpr uint32_t DIV_DIFF_CLK_LO_DIS = (1U << 15);  ///< no description available
        constexpr uint32_t TX_VCO_FTC_SET = (2 << 16);  ///< no description available
        constexpr uint32_t RX_VCO_FTC_SET = (2 << 18);  ///< no description available
    }

    /// PA_CTRL Register bits
    namespace pa_ctrl_bits {
        constexpr uint32_t PA_ON_DLY = (6 << 0);  ///< PA turn on delay time
        constexpr uint32_t PA_OFF_DLY = (4 << 8);  ///< PA turn off delay time
        constexpr uint32_t PA_INCREASE_SEL = (3 << 16);  ///< PA output power increasing control
        constexpr uint32_t PA_SEL_BIAS = (1U << 19);  ///< PA duty cycle voltage bias
        constexpr uint32_t PA_BM_CUR = (2 << 20);  ///< Pa bias current control
        constexpr uint32_t PA_VDUTY_CYCLE_SEL = (2 << 22);  ///< PA duty cycle control voltage select
        constexpr uint32_t PA_VCDCG = (1U << 24);  ///< PA duty cycle control
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t RC_TIM = (2 << 0);  ///< RC calibration reset time
        constexpr uint32_t VCO_TEST_INT = (1U << 4);  ///< no description available
        constexpr uint32_t HOP_CLB_SEL = (1U << 8);  ///< Frequency hop calibration start select
        constexpr uint32_t XTL_PO_TIM = (2 << 16);  ///< crystal calibration power on wait time
        constexpr uint32_t XTL_CAL_TIM = (2 << 18);  ///< crystal calibration code wait time
        constexpr uint32_t XTL_AMP_DET_PWR_SEL = (2 << 20);  ///< crystal amplitude detector power select
        constexpr uint32_t XTL_SWCAL_EN = (1U << 22);  ///< crystal software calibration enable
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t PO_CAL_DONE_INT = (1U << 0);  ///< power on calibration done interrupt
        constexpr uint32_t HOP_CAL_DONE_INT = (1U << 1);  ///< hop calibration done interrupt
        constexpr uint32_t OSC_CAL_DONE_INT = (1U << 2);  ///< OSC calibration done interrupt
        constexpr uint32_t REF_CAL_DONE_INT = (1U << 3);  ///< REF PLL calibration done interrupt
        constexpr uint32_t RCO_CAL_DONE_INT = (1U << 4);  ///< RCO calibration done interrupt
        constexpr uint32_t XTL_CAL_DONE_INT = (1U << 5);  ///< XTL calibration done interrupt
        constexpr uint32_t PO_ALL_DONE_INT = (1U << 8);  ///< RCO &amp; REF &amp; OSC &amp; Power on calibration all done interrupt. And signal of above interrupt
        constexpr uint32_t CAL_INT = (1U << 16);  ///< or signal of all calibration interrupt
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t PO_CAL_DONE_INTEN = (1U << 0);  ///< power on calibration done interrupt enable
        constexpr uint32_t HOP_CAL_DONE_INTEN = (1U << 1);  ///< hop calibration done interrupt enable
        constexpr uint32_t OSC_CAL_DONE_INTEN = (1U << 2);  ///< OSC calibration done interrupt enable
        constexpr uint32_t REF_CAL_DONE_INTEN = (1U << 3);  ///< REF PLL calibration done interrupt enable
        constexpr uint32_t RCO_CAL_DONE_INTEN = (1U << 4);  ///< RCO calibration done interrupt enable
        constexpr uint32_t XTL_CAL_DONE_INTEN = (1U << 5);  ///< XTL calibration done interrupt enable
        constexpr uint32_t PO_ALL_DONE_INTEN = (1U << 8);  ///< PO_ALL_DONE_INT enable
    }

    /// INT_STAT Register bits
    namespace int_stat_bits {
        constexpr uint32_t PO_CAL_DONE_INT_STAT = (1U << 0);  ///< power on calibration done interrupt status
        constexpr uint32_t HOP_CAL_DONE_INT_STAT = (1U << 1);  ///< hop calibration done interrupt status
        constexpr uint32_t OSC_CAL_DONE_INT_STAT = (1U << 2);  ///< OSC calibration done interrupt status
        constexpr uint32_t REF_CAL_DONE_INT_STAT = (1U << 3);  ///< REF PLL calibration done interrupt status
        constexpr uint32_t RCO_CAL_DONE_INT_STAT = (1U << 4);  ///< RCO calibration done interrupt status
        constexpr uint32_t XTL_CAL_DONE_INT_STAT = (1U << 5);  ///< XTL calibration done interrupt status
        constexpr uint32_t PO_ALL_DONE_INT_STAT = (1U << 8);  ///< PO_ALL_DONE_INT status
        constexpr uint32_t CAL_INT_STAT = (1U << 16);  ///< calibration all interrupt status
    }

    /// TIF Register bits
    namespace tif_bits {
        constexpr uint32_t TEST_CTRL = (4 << 0);  ///< Test interface selection
    }

    /// KVCO_MEAN Register bits
    namespace kvco_mean_bits {
        constexpr uint32_t KVCO_CNT_MEAN = (21 << 0);  ///< KVCO counter 1 and counter 2 mean
    }

    /// KVCO_DLT Register bits
    namespace kvco_dlt_bits {
        constexpr uint32_t KVCO_CNT_DLT = (9 << 0);  ///< KVCO counter 1 and counter 2 delta
    }

    /// LO_CFG Register bits
    namespace lo_cfg_bits {
        constexpr uint32_t LO_INT_CFG = (6 << 0);  ///< no description available
        constexpr uint32_t LO_FRAC_CFG = (22 << 6);  ///< no description available
        constexpr uint32_t LO_SEL = (1U << 30);  ///< no description available
        constexpr uint32_t LO_CHANGE = (1U << 31);  ///< no description available
    }

    /// LO_TABLE Register bits
    namespace lo_table_bits {
        constexpr uint32_t LO_INT_TABLE = (6 << 0);  ///< no description available
        constexpr uint32_t LO_FRAC_TABLE = (20 << 6);  ///< no description available
    }

    /// LO_RATIO Register bits
    namespace lo_ratio_bits {
        constexpr uint32_t LO_INT = (6 << 0);  ///< no description available
        constexpr uint32_t LO_FRAC = (22 << 6);  ///< no description available
    }

    /// VCO_MOD_CFG Register bits
    namespace vco_mod_cfg_bits {
        constexpr uint32_t VCO_MOD_TX_CFG = (1U << 0);  ///< VCO_MOD_TX register configured value. See section 6.10.5 for detail.
        constexpr uint32_t VCO_MOD_TX_SEL = (1U << 1);  ///< VCO_MOD_TX selection
        constexpr uint32_t TRX2M_MODE_CFG = (1U << 2);  ///< TRX 2M mode software configured value
        constexpr uint32_t TRX2M_MODE_SEL = (1U << 3);  ///< TRX 2M mode selection signal
        constexpr uint32_t IMR = (1U << 4);  ///< no description available
    }

    /// VCO_MOD_STAT Register bits
    namespace vco_mod_stat_bits {
        constexpr uint32_t VCO_MOD_TX = (1U << 0);  ///< no description available
        constexpr uint32_t TRX2M_MODE = (1U << 2);  ///< no description available
    }

    /// CH_IDX Register bits
    namespace ch_idx_bits {
        constexpr uint32_t CH_IDX = (8 << 0);  ///< no description available
    }

    /// VCOF_CNT_UP Register bits
    namespace vcof_cnt_up_bits {
        constexpr uint32_t TX_VCOF_CNT_UP = (8 << 0);  ///< TX VCO frequency power up calibration 8us count value
        constexpr uint32_t RX_VCOF_CNT_UP = (8 << 16);  ///< RX VCO frequency power up calibration 8us count value
    }

    /// VCOF_CNT_DN Register bits
    namespace vcof_cnt_dn_bits {
        constexpr uint32_t TX_VCOF_CNT_DN = (8 << 0);  ///< TX VCO frequency power up calibration 8us count value
        constexpr uint32_t RX_VCOF_CNT_DN = (8 << 16);  ///< RX VCO frequency power up calibration 8us count value
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPIFI0_BASE = 0x40080000;
    constexpr uint32_t SPI0_BASE = 0x40087000;
    constexpr uint32_t SPI1_BASE = 0x4008F000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - SPIFI control register
        volatile uint32_t CMD;  ///< Offset: 0x04 - SPIFI command register
        volatile uint32_t ADDR;  ///< Offset: 0x08 - SPIFI address register
        volatile uint32_t IDATA;  ///< Offset: 0x0C - SPIFI intermediate data register
        volatile uint32_t CLIMIT;  ///< Offset: 0x10 - SPIFI limit register
        volatile uint32_t DATA;  ///< Offset: 0x14 - SPIFI data register
        volatile uint32_t MCMD;  ///< Offset: 0x18 - SPIFI memory command register
        volatile uint32_t STAT;  ///< Offset: 0x1C - SPIFI status register
    };

    /// Peripheral instances
    inline Registers* SPIFI0 = reinterpret_cast<Registers*>(SPIFI0_BASE);
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TIMEOUT = (16 << 0);  ///< This field contains the number of serial clock periods without the processor reading data in memory mode, which will cause the SPIFI hardware to terminate the command by driving the CS pin high and negating the CMD bit in the Status register. (This allows the flash memory to enter a lower-power state.) If the processor reads data from the flash region after a time-out, the command in the Memory Command Register is issued again.
        constexpr uint32_t CSHIGH = (4 << 16);  ///< This field controls the minimum CS high time, expressed as a number of serial clock periods minus one.
        constexpr uint32_t D_PRFTCH_DIS = (1U << 21);  ///< This bit allows conditioning of memory mode prefetches based on the AHB HPROT (instruction/data) access information. A 1 in this register means that the SPIFI will not attempt a speculative prefetch when it encounters data accesses.
        constexpr uint32_t INTEN = (1U << 22);  ///< If this bit is 1 when a command ends, the SPIFI will assert its interrupt request output. See INTRQ in the status register for further details.
        constexpr uint32_t MODE3 = (1U << 23);  ///< SPI Mode 3 select.
        constexpr uint32_t PRFTCH_DIS = (1U << 27);  ///< Cache prefetching enable. The SPIFI includes an internal cache. A 1 in this bit disables prefetching of cache lines.
        constexpr uint32_t DUAL = (1U << 28);  ///< Select dual protocol.
        constexpr uint32_t RFCLK = (1U << 29);  ///< Select active clock edge for input data.
        constexpr uint32_t FBCLK = (1U << 30);  ///< Feedback clock select.
        constexpr uint32_t DMAEN = (1U << 31);  ///< A 1 in this bit enables the DMA Request output from the SPIFI. Set this bit only when a DMA channel is used to transfer data in peripheral mode. Do not set this bit when a DMA channel is used for memory-to-memory transfers from the SPIFI memory area. DMAEN should only be used in Command mode.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t DATALEN = (14 << 0);  ///< Except when the POLL bit in this register is 1, this field controls how many data bytes are in the command. 0 indicates that the command does not contain a data field.
        constexpr uint32_t POLL = (1U << 14);  ///< This bit should be written as 1 only with an opcode that a) contains an input data field, and b) causes the serial flash device to return byte status repetitively (e.g., a Read Status command). When this bit is 1, the SPIFI hardware continues to read bytes until the test specified by the DATALEN field is met. The hardware tests the bit in each status byte selected by DATALEN bits 2:0, until a bit is found that is equal to DATALEN bit 3. When the test succeeds, the SPIFI captures the byte that meets this test so that it can be read from the Data Register, and terminates the command by raising CS. The end-of-command interrupt can be enabled to inform software when this occurs
        constexpr uint32_t DOUT = (1U << 15);  ///< If the DATALEN field is not zero, this bit controls the direction of the data:
        constexpr uint32_t INTLEN = (3 << 16);  ///< This field controls how many intermediate bytes precede the data. (Each such byte may require 8 or 2 SCK cycles, depending on whether the intermediate field is in serial, 2-bit, or 4-bit format.) Intermediate bytes are output by the SPIFI, and include post-address control information, dummy and delay bytes. See the description of the Intermediate Data register for the contents of such bytes.
        constexpr uint32_t FIELDFORM = (2 << 19);  ///< This field controls how the fields of the command are sent.
        constexpr uint32_t FRAMEFORM = (3 << 21);  ///< This field controls the opcode and address fields.
        constexpr uint32_t OPCODE = (8 << 24);  ///< The opcode of the command (not used for some FRAMEFORM values).
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address.
    }

    /// IDATA Register bits
    namespace idata_bits {
        constexpr uint32_t IDATA = (32 << 0);  ///< Value of intermediate bytes.
    }

    /// CLIMIT Register bits
    namespace climit_bits {
        constexpr uint32_t CLIMIT = (32 << 0);  ///< Zero-based upper limit of cacheable memory
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Input or output data
    }

    /// MCMD Register bits
    namespace mcmd_bits {
        constexpr uint32_t POLL = (1U << 14);  ///< This bit should be written as 0.
        constexpr uint32_t DOUT = (1U << 15);  ///< This bit should be written as 0.
        constexpr uint32_t INTLEN = (3 << 16);  ///< This field controls how many intermediate bytes precede the data. (Each such byte may require 8 or 2 SCK cycles, depending on whether the intermediate field is in serial, 2-bit, or 4-bit format.) Intermediate bytes are output by the SPIFI, and include post-address control information, dummy and delay bytes. See the description of the Intermediate Data register for the contents of such bytes.
        constexpr uint32_t FIELDFORM = (2 << 19);  ///< This field controls how the fields of the command are sent.
        constexpr uint32_t FRAMEFORM = (3 << 21);  ///< This field controls the opcode and address fields.
        constexpr uint32_t OPCODE = (8 << 24);  ///< The opcode of the command (not used for some FRAMEFORM values).
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t MCINIT = (1U << 0);  ///< This bit is set when software successfully writes the Memory Command register, and is cleared by Reset or by writing a 1 to the RESET bit in this register.
        constexpr uint32_t CMD = (1U << 1);  ///< This bit is 1 when the Command register is written. It is cleared by a hardware reset, a write to the RESET bit in this register, or the deassertion of CS which indicates that the command has completed communication with the SPI Flash.
        constexpr uint32_t RESET = (1U << 4);  ///< Write a 1 to this bit to abort a current command or memory mode. This bit is cleared when the hardware is ready for a new command to be written to the Command register.
        constexpr uint32_t INTRQ = (1U << 5);  ///< This bit reflects the SPIFI interrupt request. Write a 1 to this bit to clear it. This bit is set when a CMD was previously 1 and has been cleared due to the deassertion of CS.
        constexpr uint32_t VERSION = (8 << 24);  ///< -
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40081000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t INI_RD_EN;  ///< Offset: 0x00 - flash initial read register
        volatile uint32_t ERASE_CTRL;  ///< Offset: 0x04 - flash erase control register
        volatile uint32_t ERASE_TIME;  ///< Offset: 0x08 - flash erase time setting register
        volatile uint32_t TIME_CTRL;  ///< Offset: 0x0C - flash operation time setting register
        volatile uint32_t SMART_CTRL;  ///< Offset: 0x10 - smart erase control register
        volatile uint32_t INTEN;  ///< Offset: 0x14 - interrupt enable register
        volatile uint32_t INT_STAT;  ///< Offset: 0x18 - interrupt status register
        volatile uint32_t INTCLR;  ///< Offset: 0x1C - interrupt clear register
        volatile uint32_t LOCK_STAT0;  ///< Offset: 0x20 - lock control register 0
        volatile uint32_t LOCK_STAT1;  ///< Offset: 0x24 - no description available
        volatile uint32_t LOCK_STAT2;  ///< Offset: 0x28 - no description available
        volatile uint32_t LOCK_STAT3;  ///< Offset: 0x2C - no description available
        volatile uint32_t LOCK_STAT4;  ///< Offset: 0x30 - no description available
        volatile uint32_t LOCK_STAT5;  ///< Offset: 0x34 - no description available
        volatile uint32_t LOCK_STAT6;  ///< Offset: 0x38 - no description available
        volatile uint32_t LOCK_STAT7;  ///< Offset: 0x3C - no description available
        volatile uint32_t LOCK_STAT8;  ///< Offset: 0x40 - no description available
        volatile uint32_t STATUS1;  ///< Offset: 0x48 - no description available
        volatile uint32_t ERR_INFOL1;  ///< Offset: 0x5C - no description available
        volatile uint32_t ERR_INFOL2;  ///< Offset: 0x60 - no description available
        volatile uint32_t ERR_INFOL3;  ///< Offset: 0x64 - no description available
        volatile uint32_t ERR_INFOH1;  ///< Offset: 0x68 - no description available
        volatile uint32_t ERR_INFOH2;  ///< Offset: 0x6C - no description available
        volatile uint32_t ERR_INFOH3;  ///< Offset: 0x70 - no description available
        volatile uint32_t DEBUG_PASSWORD;  ///< Offset: 0xA8 - no description available
        volatile uint32_t ERASE_PASSWORD;  ///< Offset: 0xAC - no description available
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);

    // Bit definitions
    /// INI_RD_EN Register bits
    namespace ini_rd_en_bits {
        constexpr uint32_t INI_RD_EN = (1U << 0);  ///< enable contoller to automatically read GDR repaired information and lock bit
    }

    /// ERASE_CTRL Register bits
    namespace erase_ctrl_bits {
        constexpr uint32_t PAGE_IDXL = (7 << 0);  ///< Low 256KB page erase index
        constexpr uint32_t PAGE_IDXH = (7 << 8);  ///< High 256KB page erase index
        constexpr uint32_t HALF_ERASEL_EN = (1U << 28);  ///< Write '1' to Enable Mass Erase Low 256KB Flash; Write '0' is inactive. This bit is set by software and reset at the end of low 256KB flash mass erase operation by hardware.
        constexpr uint32_t HALF_ERASEH_EN = (1U << 29);  ///< Write '1' to Enable Mass Erase High 256KB Flash; Write '0' is inactive. This bit is set by software and reset at the end of high 256KB flash mass erase operation by hardware.
        constexpr uint32_t PAGE_ERASEL_EN = (1U << 30);  ///< Low 256KB block page erase enable. This bit initiates a page erase operation when set. This bit is set by software and reset at the end of page erase operation by hardware.
        constexpr uint32_t PAGE_ERASEH_EN = (1U << 31);  ///< High 256KB block page erase enable. This bit initiates a page erase operation when set. This bit is set by software and reset at the end of page erase operation by hardware.
    }

    /// ERASE_TIME Register bits
    namespace erase_time_bits {
        constexpr uint32_t ERASE_TIME_BASE = (20 << 0);  ///< Erase time, which is used to control Terase, Tme and Tsme. An 8MHz clock is to count the erase time. The maximum time of erase is 100ms. Default value is 640000 cycles in 8 MHz, that's 80 ms. User should set a pessimistic value to avoid possible error in erase operation.
    }

    /// TIME_CTRL Register bits
    namespace time_ctrl_bits {
        constexpr uint32_t PRGM_CYCLE = (12 << 0);  ///< Time base of some flash timing parameters, which represents 2 us. Default value is 64 cycles in 32 MHz (ahb clock). It is used in write and erase operations.
        constexpr uint32_t TIME_BASE = (8 << 12);  ///< Max write operation times in one program, which are used to control Terase and Tme. User should set a pessimistic value to avoid possible error in erase/page erase operation. When user do write operation: It is used to limit allowed write numbers. (Max 21 ms-Tnvs-Tpgs-Tpgh-Tnvh)/18us = 1167 This register is only used when common write.
    }

    /// SMART_CTRL Register bits
    namespace smart_ctrl_bits {
        constexpr uint32_t PRGML_EN = (1U << 0);  ///< It enable Low 256KB Flash write operation;
        constexpr uint32_t PRGMH_EN = (1U << 1);  ///< It enable High 256KB Flash write operation;
        constexpr uint32_t SMART_WRITEL_EN = (1U << 2);  ///< It enable Low 256KB Flash Smart program flow. When smart write is done, hardware automatically clear it
        constexpr uint32_t SMART_WRITEH_EN = (1U << 3);  ///< It enable High 256KB Flash Smart program flow. When smart write is done, hardware automatically clear it
        constexpr uint32_t SMART_ERASEL_EN = (1U << 4);  ///< It enable Low 256KB Flash Smart erase flow; When smart erase is done, hardware automatically clear it
        constexpr uint32_t SMART_ERASEH_EN = (1U << 5);  ///< It enable High 256KB Flash Smart erase flow; When smart erase is done, hardware automatically clear it
        constexpr uint32_t MAX_WRITE = (4 << 8);  ///< When smart program is used, this is the maximum retry number for one write operation.
        constexpr uint32_t MAX_ERASE = (6 << 12);  ///< When smart erase is used, this is the maximum retry number for one erase operation.
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t AHBL_INTEN = (1U << 0);  ///< low 256K flash AHB error interrupt enable
        constexpr uint32_t LOCKL_INTEN = (1U << 1);  ///< low 256K flash lock error interrupt enable
        constexpr uint32_t ERASEL_INTEN = (1U << 2);  ///< low 256K flash erase status interrupt enable
        constexpr uint32_t WRITEL_INTEN = (1U << 3);  ///< low 256K flash write status interrupt enable
        constexpr uint32_t WRBUFL_INTEN = (1U << 4);  ///< low 256K flash write buffer status interrupt enable
        constexpr uint32_t AHBH_INTEN = (1U << 8);  ///< high 256K flash AHB error interrupt enable
        constexpr uint32_t LOCKH_INTEN = (1U << 9);  ///< high 256K flash lock error interrupt enable
        constexpr uint32_t ERASEH_INTEN = (1U << 10);  ///< high 256K flash erase status interrupt enable
        constexpr uint32_t WRITEH_INTEN = (1U << 11);  ///< high 256K flash write status interrupt enable
        constexpr uint32_t WRBUFH_INTEN = (1U << 12);  ///< high 256K flash write buffer status interrupt enable
        constexpr uint32_t FLASH_INTEN = (1U << 31);  ///< flash total interrupt enable
    }

    /// INT_STAT Register bits
    namespace int_stat_bits {
        constexpr uint32_t AHBL_INT = (1U << 0);  ///< It is low 256KB Flash AHB error interrupt stat. 1 indicates AHB operation error AHB error include: Write/read unmapped space; AHB align rules violation; Byte/half-word Flash write operation;
        constexpr uint32_t LOCKL_INT = (1U << 1);  ///< It is low 256KB Flash Lock page be accessed interrupt status
        constexpr uint32_t ERASEL_INT = (1U << 2);  ///< It is low 256KB Erase operation done interrupt status If erase is used, it indicates one erase is done.
        constexpr uint32_t WRITEL_INT = (1U << 3);  ///< It is low 256KB write operation done interrupt status If write is used, it indicates one program is done.
        constexpr uint32_t WRBUFL_INT = (1U << 4);  ///< It is low 256KB Write Buffer empty interrupt status 0 = write buffer is not empty 1 = write buffer is empty It is auto cleared when write buffer is written. It is enabled only when PRGML_EN is enabled and write buffer is empty
        constexpr uint32_t WRITE_FAIL_L_INT = (1U << 5);  ///< When smart write of low 256KB Flash is enable, 0 = Smart write is successful, 1 = Smart write is fail.
        constexpr uint32_t ERASE_FAIL_L_INT = (1U << 6);  ///< When smart erase of low 256KB Flash is enable, 0 = Smart erase is successful, 1 = Smart erase is fail.
        constexpr uint32_t AHBH_INT = (1U << 8);  ///< it is high 256KB Flash AHB error interrupt stat 1 indicates AHB operation error AHB error include: Write/read unmapped space; AHB align rules violation; Byte/half-word Flash write operation;
        constexpr uint32_t LOCKH_INT = (1U << 9);  ///< it is high 256KB Flash Lock page be accessed interrupt status
        constexpr uint32_t ERASEH_INT = (1U << 10);  ///< it is high 256KB Flash Erase operation done interrupt status If erase is used, it indicates one erase is done.
        constexpr uint32_t WRITEH_INT = (1U << 11);  ///< it is high 256KB Flash write operation done interrupt status If write is used, it indicates one program is done.
        constexpr uint32_t WRBUFH_INT = (1U << 12);  ///< it is high 256KB Flash Write Buffer empty interrupt status 0 = write buffer is not empty 1 = write buffer is empty It is auto cleared when write buffer is written. It is enabled only when PRGMH_EN is enabled and write buffer is empty
        constexpr uint32_t WRITE_FAIL_H_INT = (1U << 13);  ///< When smart write of high 256KB Flash is enable, 0 = Smart write is successful, 1 = Smart write is fail.
        constexpr uint32_t ERASE_FAIL_H_INT = (1U << 14);  ///< When smart erase of high 256KB Flash is enable, 0 = Smart erase is successful, 1 = Smart erase is fail.
    }

    /// INTCLR Register bits
    namespace intclr_bits {
        constexpr uint32_t AHBL_INTCLR = (1U << 0);  ///< low 256K flash AHB error interrupt clear
        constexpr uint32_t LOCKL_INTCLR = (1U << 1);  ///< low 256K flash lock error interrupt clear
        constexpr uint32_t ERASEL_INTCLR = (1U << 2);  ///< low 256K flash erase status interrupt clear
        constexpr uint32_t WRITEL_INTCLR = (1U << 3);  ///< low 256K flash write status interrupt clear
        constexpr uint32_t AHBH_INTCLR = (1U << 8);  ///< high 256K flash AHB error interrupt clear
        constexpr uint32_t LOCKH_INTCLR = (1U << 9);  ///< high 256K flash lock error interrupt clear
        constexpr uint32_t ERASEH_INTCLR = (1U << 10);  ///< high 256K flash erase status interrupt clear
        constexpr uint32_t WRITEH_INTCLR = (1U << 11);  ///< high 256K flash write status interrupt clear
    }

    /// LOCK_STAT0 Register bits
    namespace lock_stat0_bits {
        constexpr uint32_t PAGE_LOCK0 = (32 << 0);  ///< Low 256K flash main memory page 0-31 write and erase lock status
    }

    /// LOCK_STAT1 Register bits
    namespace lock_stat1_bits {
        constexpr uint32_t PAGE_LOCK1 = (32 << 0);  ///< Low 256K flash main memory page 32-63 write and erase lock status
    }

    /// LOCK_STAT2 Register bits
    namespace lock_stat2_bits {
        constexpr uint32_t PAGE_LOCK2 = (32 << 0);  ///< Low 256K flash main memory page 64-95 write and erase lock status
    }

    /// LOCK_STAT3 Register bits
    namespace lock_stat3_bits {
        constexpr uint32_t PAGE_LOCK3 = (32 << 0);  ///< Low 256K flash main memory page 96-127 write and erase lock status
    }

    /// LOCK_STAT4 Register bits
    namespace lock_stat4_bits {
        constexpr uint32_t PAGE_LOCK4 = (32 << 0);  ///< high 256K flash main memory page 0-31 write and erase lock status
    }

    /// LOCK_STAT5 Register bits
    namespace lock_stat5_bits {
        constexpr uint32_t PAGE_LOCK5 = (32 << 0);  ///< high 256K flash main memory page 32-63 write and erase lock status
    }

    /// LOCK_STAT6 Register bits
    namespace lock_stat6_bits {
        constexpr uint32_t PAGE_LOCK6 = (32 << 0);  ///< high 256K flash main memory page 64-95 write and erase lock status
    }

    /// LOCK_STAT7 Register bits
    namespace lock_stat7_bits {
        constexpr uint32_t PAGE_LOCK7 = (32 << 0);  ///< high 256K flash main memory page 96-127 write and erase lock status
    }

    /// LOCK_STAT8 Register bits
    namespace lock_stat8_bits {
        constexpr uint32_t MASS_ERASE_LOCK = (1U << 0);  ///< Mass erase operation lock status 0 : Mass erase operation is locked 1 : Mass erase operation is unlocked
        constexpr uint32_t FSH_PROTECT = (1U << 1);  ///< SWD flash protection status 0 : flash is unprotected 1 : flash is protected
        constexpr uint32_t MEM_PROTECT = (1U << 2);  ///< SWD memory protection status 0 : Memory is unprotected 1 : Memory is protected
    }

    /// STATUS1 Register bits
    namespace status1_bits {
        constexpr uint32_t FSH_ERA_BUSY_L = (1U << 9);  ///< flash block 0 erase operation status 0 : no flash block 0 erase operation in progress. 1 : flash block 0 erase operation is in progress.
        constexpr uint32_t FSH_WR_BUSY_L = (1U << 10);  ///< flash block 0 write operation status: 0 : no flash block 0 write operation in progress. 1 : flash block 0 write operation is in progress.
        constexpr uint32_t DBG_ERA_DONE_L = (1U << 11);  ///< A flash block 0 debug initiated smart mass erase status. 0 : no debug port initiated flash block 0 smart mass erase operation in progress. 1 : debug port initiated flash block 0 smart mass erase operation in progress.
        constexpr uint32_t FSH_ERA_BUSY_H = (1U << 12);  ///< flash block 1 erase operation status 0 : no flash block 1 erase operation in progress. 1 : flash block 1 erase operation is in progress.
        constexpr uint32_t FSH_WR_BUSY_H = (1U << 13);  ///< flash block 1 write operation status: 0 : no flash block 1 write operation in progress. 1 : flash block 1 write operation is in progress.
        constexpr uint32_t DBG_ERA_DONE_H = (1U << 14);  ///< A flash block 1 debug initiated smart mass erase status. 0 : no debug port initiated flash block 1 smart mass erase operation in progress. 1 : debug port initiated flash block 1 smart mass erase operation in progress.
        constexpr uint32_t INI_RD_DONE = (1U << 15);  ///< flash initial read done.
        constexpr uint32_t FSH_STA = (1U << 26);  ///< when 0 means data information is 0x55AA.
        constexpr uint32_t RESERVED = (5 << 27);  ///< reserved
    }

    /// ERR_INFOL1 Register bits
    namespace err_infol1_bits {
        constexpr uint32_t WR_FAILEDL_ADDR = (18 << 0);  ///< When a flash block 0 smart write fails, the address is stored in this bit filed
        constexpr uint32_t SMART_FAILL_CTR = (6 << 18);  ///< The amount of fails during a smart write or smart erase is stored in this bit field
    }

    /// ERR_INFOL2 Register bits
    namespace err_infol2_bits {
        constexpr uint32_t WR_FAILEDL_DATA = (32 << 0);  ///< When a flash block 0 smart write fails, the data is stored in this bit field
    }

    /// ERR_INFOL3 Register bits
    namespace err_infol3_bits {
        constexpr uint32_t ERA_FAILEDL_INFO = (18 << 0);  ///< When a smart erase on flash block 0 fails, the address is stored in this bit field
    }

    /// ERR_INFOH1 Register bits
    namespace err_infoh1_bits {
        constexpr uint32_t WR_FAILEDH_ADDR = (18 << 0);  ///< When a flash block 1 smart write fails, the address is stored in this bit field
        constexpr uint32_t SMART_FAILH_CTR = (6 << 18);  ///< The amount of fails during a msart write or smart erase is stored int his bit field
    }

    /// ERR_INFOH2 Register bits
    namespace err_infoh2_bits {
        constexpr uint32_t WR_FAILEDH_DATA = (32 << 0);  ///< When a flash block 1 smart write fails, the data is stored in this bit field
    }

    /// ERR_INFOH3 Register bits
    namespace err_infoh3_bits {
        constexpr uint32_t ERA_FAILEDH_INFO = (18 << 0);  ///< when a smart erase on flash block 1 fails, the address is stored in this bit field
    }

    /// DEBUG_PASSWORD Register bits
    namespace debug_password_bits {
        constexpr uint32_t DEBUG_PASSWORD = (32 << 0);  ///< An SWD initiated smart mass erase operation will only be issued if this register is programmed with the value 0xCA1E093F.
    }

    /// ERASE_PASSWORD Register bits
    namespace erase_password_bits {
        constexpr uint32_t ERASE_PASSWORD = (32 << 0);  ///< When this register is programmed with the value 0xCA1E093F, a FW initiated mass erase or page erase operation will bypass the current lock and protection scheme.
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA0_BASE = 0x40082000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - DMA control.
        volatile uint32_t INTSTAT;  ///< Offset: 0x04 - Interrupt status.
        volatile uint32_t SRAMBASE;  ///< Offset: 0x08 - SRAM address of the channel configuration table.
        volatile uint32_t ENABLESET0;  ///< Offset: 0x20 - Channel Enable read and Set for all DMA channels.
        volatile uint32_t ENABLECLR0;  ///< Offset: 0x28 - Channel Enable Clear for all DMA channels.
        volatile uint32_t ACTIVE0;  ///< Offset: 0x30 - Channel Active status for all DMA channels.
        volatile uint32_t BUSY0;  ///< Offset: 0x38 - Channel Busy status for all DMA channels.
        volatile uint32_t ERRINT0;  ///< Offset: 0x40 - Error Interrupt status for all DMA channels.
        volatile uint32_t INTENSET0;  ///< Offset: 0x48 - Interrupt Enable read and Set for all DMA channels.
        volatile uint32_t INTENCLR0;  ///< Offset: 0x50 - Interrupt Enable Clear for all DMA channels.
        volatile uint32_t INTA0;  ///< Offset: 0x58 - Interrupt A status for all DMA channels.
        volatile uint32_t INTB0;  ///< Offset: 0x60 - Interrupt B status for all DMA channels.
        volatile uint32_t SETVALID0;  ///< Offset: 0x68 - Set ValidPending control bits for all DMA channels.
        volatile uint32_t SETTRIG0;  ///< Offset: 0x70 - Set Trigger control bits for all DMA channels.
        volatile uint32_t ABORT0;  ///< Offset: 0x78 - Channel Abort control for all DMA channels.
        volatile uint32_t CFG;  ///< Offset: 0x00 - Configuration register for DMA channel .
        volatile uint32_t CTLSTAT;  ///< Offset: 0x04 - Control and status register for DMA channel .
        volatile uint32_t XFERCFG;  ///< Offset: 0x08 - Transfer configuration register for DMA channel .
    };

    /// Peripheral instances
    inline Registers* DMA0 = reinterpret_cast<Registers*>(DMA0_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< DMA controller master enable.
    }

    /// INTSTAT Register bits
    namespace intstat_bits {
        constexpr uint32_t ACTIVEINT = (1U << 1);  ///< Summarizes whether any enabled interrupts (other than error interrupts) are pending.
        constexpr uint32_t ACTIVEERRINT = (1U << 2);  ///< Summarizes whether any error interrupts are pending.
    }

    /// SRAMBASE Register bits
    namespace srambase_bits {
        constexpr uint32_t OFFSET = (23 << 9);  ///< Address bits 31:9 of the beginning of the DMA descriptor table. For 18 channels, the table must begin on a 512 byte boundary.
    }

    /// ENABLESET0 Register bits
    namespace enableset0_bits {
        constexpr uint32_t ENA = (32 << 0);  ///< Enable for DMA channels. Bit n enables or disables DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = disabled. 1 = enabled.
    }

    /// ENABLECLR0 Register bits
    namespace enableclr0_bits {
        constexpr uint32_t CLR = (32 << 0);  ///< Writing ones to this register clears the corresponding bits in ENABLESET0. Bit n clears the channel enable bit n. The number of bits = number of DMA channels in this device. Other bits are reserved.
    }

    /// ACTIVE0 Register bits
    namespace active0_bits {
        constexpr uint32_t ACT = (32 << 0);  ///< Active flag for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = not active. 1 = active.
    }

    /// BUSY0 Register bits
    namespace busy0_bits {
        constexpr uint32_t BSY = (32 << 0);  ///< Busy flag for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = not busy. 1 = busy.
    }

    /// ERRINT0 Register bits
    namespace errint0_bits {
        constexpr uint32_t ERR = (32 << 0);  ///< Error Interrupt flag for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = error interrupt is not active. 1 = error interrupt is active.
    }

    /// INTENSET0 Register bits
    namespace intenset0_bits {
        constexpr uint32_t INTEN = (32 << 0);  ///< Interrupt Enable read and set for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = interrupt for DMA channel is disabled. 1 = interrupt for DMA channel is enabled.
    }

    /// INTENCLR0 Register bits
    namespace intenclr0_bits {
        constexpr uint32_t CLR = (32 << 0);  ///< Writing ones to this register clears corresponding bits in the INTENSET0. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved.
    }

    /// INTA0 Register bits
    namespace inta0_bits {
        constexpr uint32_t IA = (32 << 0);  ///< Interrupt A status for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = the DMA channel interrupt A is not active. 1 = the DMA channel interrupt A is active.
    }

    /// INTB0 Register bits
    namespace intb0_bits {
        constexpr uint32_t IB = (32 << 0);  ///< Interrupt B status for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = the DMA channel interrupt B is not active. 1 = the DMA channel interrupt B is active.
    }

    /// SETVALID0 Register bits
    namespace setvalid0_bits {
        constexpr uint32_t SV = (32 << 0);  ///< SETVALID control for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = no effect. 1 = sets the VALIDPENDING control bit for DMA channel n
    }

    /// SETTRIG0 Register bits
    namespace settrig0_bits {
        constexpr uint32_t TRIG = (32 << 0);  ///< Set Trigger control bit for DMA channel 0. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = no effect. 1 = sets the TRIG bit for DMA channel n.
    }

    /// ABORT0 Register bits
    namespace abort0_bits {
        constexpr uint32_t ABORTCTRL = (32 << 0);  ///< Abort control for DMA channel 0. Bit n corresponds to DMA channel n. 0 = no effect. 1 = aborts DMA operations on channel n.
    }

    /// CFG Register bits
    namespace cfg_bits {
        constexpr uint32_t PERIPHREQEN = (1U << 0);  ///< Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.
        constexpr uint32_t HWTRIGEN = (1U << 1);  ///< Hardware Triggering Enable for this channel.
        constexpr uint32_t TRIGPOL = (1U << 4);  ///< Trigger Polarity. Selects the polarity of a hardware trigger for this channel.
        constexpr uint32_t TRIGTYPE = (1U << 5);  ///< Trigger Type. Selects hardware trigger as edge triggered or level triggered.
        constexpr uint32_t TRIGBURST = (1U << 6);  ///< Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.
        constexpr uint32_t BURSTPOWER = (4 << 8);  ///< Burst Power is used in two ways. It always selects the address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported. The total transfer length as defined in the XFERCOUNT bits in the XFERCFG register must be an even multiple of the burst size.
        constexpr uint32_t SRCBURSTWRAP = (1U << 14);  ///< Source Burst Wrap. When enabled, the source data address for the DMA is 'wrapped', meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.
        constexpr uint32_t DSTBURSTWRAP = (1U << 15);  ///< Destination Burst Wrap. When enabled, the destination data address for the DMA is 'wrapped', meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.
        constexpr uint32_t CHPRIORITY = (3 << 16);  ///< Priority of this channel when multiple DMA requests are pending. Eight priority levels are supported: 0x0 = highest priority. 0x7 = lowest priority.
    }

    /// CTLSTAT Register bits
    namespace ctlstat_bits {
        constexpr uint32_t VALIDPENDING = (1U << 0);  ///< Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.
        constexpr uint32_t TRIG = (1U << 2);  ///< Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.
    }

    /// XFERCFG Register bits
    namespace xfercfg_bits {
        constexpr uint32_t CFGVALID = (1U << 0);  ///< Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.
        constexpr uint32_t RELOAD = (1U << 1);  ///< Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.
        constexpr uint32_t SWTRIG = (1U << 2);  ///< Software Trigger.
        constexpr uint32_t CLRTRIG = (1U << 3);  ///< Clear Trigger.
        constexpr uint32_t SETINTA = (1U << 4);  ///< Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.
        constexpr uint32_t SETINTB = (1U << 5);  ///< Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.
        constexpr uint32_t WIDTH = (2 << 8);  ///< Transfer width used for this DMA channel.
        constexpr uint32_t SRCINC = (2 << 12);  ///< Determines whether the source address is incremented for each DMA transfer.
        constexpr uint32_t DSTINC = (2 << 14);  ///< Determines whether the destination address is incremented for each DMA transfer.
        constexpr uint32_t XFERCOUNT = (10 << 16);  ///< Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. 0x3FF = a total of 1,024 transfers will be performed.
    }

}

// ============================================================================
// FLEXCOMM0 Peripheral
// ============================================================================

namespace flexcomm0 {
    /// Base addresses
    constexpr uint32_t FLEXCOMM0_BASE = 0x40083000;

    /// FLEXCOMM0 Register structure
    struct Registers {
        volatile uint32_t IOMODE;  ///< Offset: 0xF00 - io mode register
        volatile uint32_t PSELID;  ///< Offset: 0xFF8 - Peripheral Select and Flexcomm ID register.
        volatile uint32_t PID;  ///< Offset: 0xFFC - Peripheral identification register.
    };

    /// Peripheral instances
    inline Registers* FLEXCOMM0 = reinterpret_cast<Registers*>(FLEXCOMM0_BASE);

    // Bit definitions
    /// IOMODE Register bits
    namespace iomode_bits {
        constexpr uint32_t DIO_MODE = (1U << 0);  ///< IO mode register, SPI share MISO/MOSI at MOSI, USART share TXD/RXD at RXD
        constexpr uint32_t DIO_OEN = (1U << 1);  ///< shared pin direction register
    }

    /// PSELID Register bits
    namespace pselid_bits {
        constexpr uint32_t PERSEL = (3 << 0);  ///< Peripheral Select. This field is writable by software.
        constexpr uint32_t LOCK = (1U << 3);  ///< Lock the peripheral select. This field is writable by software.
        constexpr uint32_t USARTPRESENT = (1U << 4);  ///< USART present indicator. This field is Read-only.
        constexpr uint32_t SPIPRESENT = (1U << 5);  ///< SPI present indicator. This field is Read-only.
        constexpr uint32_t I2CPRESENT = (1U << 6);  ///< I2C present indicator. This field is Read-only.
        constexpr uint32_t I2SPRESENT = (1U << 7);  ///< I 2S present indicator. This field is Read-only.
        constexpr uint32_t SC3W = (1U << 8);  ///< Smart card/SPI 3 wire mode feature indicator. This field is Read-only
        constexpr uint32_t ID = (20 << 12);  ///< Flexcomm ID.
    }

    /// PID Register bits
    namespace pid_bits {
        constexpr uint32_t Minor_Rev = (4 << 8);  ///< Minor revision of module implementation.
        constexpr uint32_t Major_Rev = (4 << 12);  ///< Major revision of module implementation.
        constexpr uint32_t ID = (16 << 16);  ///< Module identifier for the selected function.
    }

}

// ============================================================================
// FLEXCOMM1 Peripheral
// ============================================================================

namespace flexcomm1 {
    /// Base addresses
    constexpr uint32_t FLEXCOMM1_BASE = 0x40086000;

    /// FLEXCOMM1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* FLEXCOMM1 = reinterpret_cast<Registers*>(FLEXCOMM1_BASE);

}

// ============================================================================
// FLEXCOMM2 Peripheral
// ============================================================================

namespace flexcomm2 {
    /// Base addresses
    constexpr uint32_t FLEXCOMM2_BASE = 0x40087000;

    /// FLEXCOMM2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* FLEXCOMM2 = reinterpret_cast<Registers*>(FLEXCOMM2_BASE);

}

// ============================================================================
// FLEXCOMM3 Peripheral
// ============================================================================

namespace flexcomm3 {
    /// Base addresses
    constexpr uint32_t FLEXCOMM3_BASE = 0x4008F000;

    /// FLEXCOMM3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* FLEXCOMM3 = reinterpret_cast<Registers*>(FLEXCOMM3_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART0_BASE = 0x40083000;
    constexpr uint32_t USART1_BASE = 0x40086000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CFG;  ///< Offset: 0x00 - USART Configuration register. Basic USART configuration...
        volatile uint32_t CTL;  ///< Offset: 0x04 - USART Control register. USART control settings that are...
        volatile uint32_t STAT;  ///< Offset: 0x08 - USART Status register. The complete status value can be...
        volatile uint32_t INTENSET;  ///< Offset: 0x0C - Interrupt Enable read and Set register for USART (not...
        volatile uint32_t INTENCLR;  ///< Offset: 0x10 - Interrupt Enable Clear register. Allows clearing any...
        volatile uint32_t BRG;  ///< Offset: 0x20 - Baud Rate Generator register. 16-bit integer baud rate...
        volatile uint32_t INTSTAT;  ///< Offset: 0x24 - Interrupt status register. Reflects interrupts that are...
        volatile uint32_t OSR;  ///< Offset: 0x28 - Oversample selection register for asynchronous communication.
        volatile uint32_t ADDR;  ///< Offset: 0x2C - Address register for automatic address matching.
        volatile uint32_t FIFOCFG;  ///< Offset: 0xE00 - FIFO configuration and enable register.
        volatile uint32_t FIFOSTAT;  ///< Offset: 0xE04 - FIFO status register.
        volatile uint32_t FIFOTRIG;  ///< Offset: 0xE08 - FIFO trigger settings for interrupt and DMA request.
        volatile uint32_t FIFOINTENSET;  ///< Offset: 0xE10 - FIFO interrupt enable set (enable) and read register.
        volatile uint32_t FIFOINTENCLR;  ///< Offset: 0xE14 - FIFO interrupt enable clear (disable) and read register.
        volatile uint32_t FIFOINTSTAT;  ///< Offset: 0xE18 - FIFO interrupt status register.
        volatile uint32_t FIFOWR;  ///< Offset: 0xE20 - FIFO write data.
        volatile uint32_t FIFORD;  ///< Offset: 0xE30 - FIFO read data.
        volatile uint32_t FIFORDNOPOP;  ///< Offset: 0xE40 - FIFO data read with no FIFO pop.
        volatile uint32_t ID;  ///< Offset: 0xFFC - USART module Identification. This value appears in the...
    };

    /// Peripheral instances
    inline Registers* USART0 = reinterpret_cast<Registers*>(USART0_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);

    // Bit definitions
    /// CFG Register bits
    namespace cfg_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< USART Enable.
        constexpr uint32_t DATALEN = (2 << 2);  ///< Selects the data size for the USART.
        constexpr uint32_t PARITYSEL = (2 << 4);  ///< Selects what type of parity is used by the USART.
        constexpr uint32_t STOPLEN = (1U << 6);  ///< Number of stop bits appended to transmitted data. Only a single stop bit is required for received data.
        constexpr uint32_t MODE32K = (1U << 7);  ///< Selects standard or 32 kHz clocking mode.
        constexpr uint32_t LINMODE = (1U << 8);  ///< LIN break mode enable.
        constexpr uint32_t CTSEN = (1U << 9);  ///< CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART'-s own RTS if loopback mode is enabled.
        constexpr uint32_t SYNCEN = (1U << 11);  ///< Selects synchronous or asynchronous operation.
        constexpr uint32_t CLKPOL = (1U << 12);  ///< Selects the clock polarity and sampling edge of received data in synchronous mode.
        constexpr uint32_t SYNCMST = (1U << 14);  ///< Synchronous mode Master select.
        constexpr uint32_t LOOP = (1U << 15);  ///< Selects data loopback mode.
        constexpr uint32_t OETA = (1U << 18);  ///< Output Enable Turnaround time enable for RS-485 operation.
        constexpr uint32_t AUTOADDR = (1U << 19);  ///< Automatic Address matching enable.
        constexpr uint32_t OESEL = (1U << 20);  ///< Output Enable Select.
        constexpr uint32_t OEPOL = (1U << 21);  ///< Output Enable Polarity.
        constexpr uint32_t RXPOL = (1U << 22);  ///< Receive data polarity.
        constexpr uint32_t TXPOL = (1U << 23);  ///< Transmit data polarity.
    }

    /// CTL Register bits
    namespace ctl_bits {
        constexpr uint32_t TXBRKEN = (1U << 1);  ///< Break Enable.
        constexpr uint32_t ADDRDET = (1U << 2);  ///< Enable address detect mode.
        constexpr uint32_t TXDIS = (1U << 6);  ///< Transmit Disable.
        constexpr uint32_t CC = (1U << 8);  ///< Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode.
        constexpr uint32_t CLRCCONRX = (1U << 9);  ///< Clear Continuous Clock.
        constexpr uint32_t AUTOBAUD = (1U << 16);  ///< Autobaud enable.
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t RXIDLE = (1U << 1);  ///< Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data.
        constexpr uint32_t TXIDLE = (1U << 3);  ///< Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data.
        constexpr uint32_t CTS = (1U << 4);  ///< This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled.
        constexpr uint32_t DELTACTS = (1U << 5);  ///< This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software.
        constexpr uint32_t TXDISSTAT = (1U << 6);  ///< Transmitter Disabled Status flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS bit in the CFG register (TXDIS = 1).
        constexpr uint32_t RXBRK = (1U << 10);  ///< Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high.
        constexpr uint32_t DELTARXBRK = (1U << 11);  ///< This bit is set when a change in the state of receiver break detection occurs. Cleared by software.
        constexpr uint32_t START = (1U << 12);  ///< This bit is set when a start is detected on the receiver input. Its purpose is primarily to allow wake-up from Deep-sleep or Power-down mode immediately when a start is detected. Cleared by software.
        constexpr uint32_t FRAMERRINT = (1U << 13);  ///< Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.
        constexpr uint32_t PARITYERRINT = (1U << 14);  ///< Parity Error interrupt flag. This flag is set when a parity error is detected in a received character.
        constexpr uint32_t RXNOISEINT = (1U << 15);  ///< Received Noise interrupt flag. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. This flag is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception.
        constexpr uint32_t ABERR = (1U << 16);  ///< Auto baud Error. An auto baud error can occur if the BRG counts to its limit before the end of the start bit that is being measured, essentially an auto baud time-out.
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t TXIDLEEN = (1U << 3);  ///< When 1, enables an interrupt when the transmitter becomes idle (TXIDLE = 1).
        constexpr uint32_t DELTACTSEN = (1U << 5);  ///< When 1, enables an interrupt when there is a change in the state of the CTS input.
        constexpr uint32_t TXDISEN = (1U << 6);  ///< When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details.
        constexpr uint32_t DELTARXBRKEN = (1U << 11);  ///< When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted).
        constexpr uint32_t STARTEN = (1U << 12);  ///< When 1, enables an interrupt when a received start bit has been detected.
        constexpr uint32_t FRAMERREN = (1U << 13);  ///< When 1, enables an interrupt when a framing error has been detected.
        constexpr uint32_t PARITYERREN = (1U << 14);  ///< When 1, enables an interrupt when a parity error has been detected.
        constexpr uint32_t RXNOISEEN = (1U << 15);  ///< When 1, enables an interrupt when noise is detected. See description of the RXNOISEINT bit in Table 354.
        constexpr uint32_t ABERREN = (1U << 16);  ///< When 1, enables an interrupt when an auto baud error occurs.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t TXIDLECLR = (1U << 3);  ///< Writing 1 clears the corresponding bit in the INTENSET register.
        constexpr uint32_t DELTACTSCLR = (1U << 5);  ///< Writing 1 clears the corresponding bit in the INTENSET register.
        constexpr uint32_t TXDISCLR = (1U << 6);  ///< Writing 1 clears the corresponding bit in the INTENSET register.
        constexpr uint32_t DELTARXBRKCLR = (1U << 11);  ///< Writing 1 clears the corresponding bit in the INTENSET register.
        constexpr uint32_t STARTCLR = (1U << 12);  ///< Writing 1 clears the corresponding bit in the INTENSET register.
        constexpr uint32_t FRAMERRCLR = (1U << 13);  ///< Writing 1 clears the corresponding bit in the INTENSET register.
        constexpr uint32_t PARITYERRCLR = (1U << 14);  ///< Writing 1 clears the corresponding bit in the INTENSET register.
        constexpr uint32_t RXNOISECLR = (1U << 15);  ///< Writing 1 clears the corresponding bit in the INTENSET register.
        constexpr uint32_t ABERRCLR = (1U << 16);  ///< Writing 1 clears the corresponding bit in the INTENSET register.
    }

    /// BRG Register bits
    namespace brg_bits {
        constexpr uint32_t BRGVAL = (16 << 0);  ///< This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0 = FCLK is used directly by the USART function. 1 = FCLK is divided by 2 before use by the USART function. 2 = FCLK is divided by 3 before use by the USART function. 0xFFFF = FCLK is divided by 65,536 before use by the USART function.
    }

    /// INTSTAT Register bits
    namespace intstat_bits {
        constexpr uint32_t TXIDLE = (1U << 3);  ///< Transmitter Idle status.
        constexpr uint32_t DELTACTS = (1U << 5);  ///< This bit is set when a change in the state of the CTS input is detected.
        constexpr uint32_t TXDISINT = (1U << 6);  ///< Transmitter Disabled Interrupt flag.
        constexpr uint32_t DELTARXBRK = (1U << 11);  ///< This bit is set when a change in the state of receiver break detection occurs.
        constexpr uint32_t START = (1U << 12);  ///< This bit is set when a start is detected on the receiver input.
        constexpr uint32_t FRAMERRINT = (1U << 13);  ///< Framing Error interrupt flag.
        constexpr uint32_t PARITYERRINT = (1U << 14);  ///< Parity Error interrupt flag.
        constexpr uint32_t RXNOISEINT = (1U << 15);  ///< Received Noise interrupt flag.
        constexpr uint32_t ABERRINT = (1U << 16);  ///< Auto baud Error Interrupt flag.
    }

    /// OSR Register bits
    namespace osr_bits {
        constexpr uint32_t OSRVAL = (4 << 0);  ///< Oversample Selection Value. 0 to 3 = not supported 0x4 = 5 function clocks are used to transmit and receive each data bit. 0x5 = 6 function clocks are used to transmit and receive each data bit. 0xF= 16 function clocks are used to transmit and receive each data bit.
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDRESS = (8 << 0);  ///< 8-bit address used with automatic address matching. Used when address detection is enabled (ADDRDET in CTL = 1) and automatic address matching is enabled (AUTOADDR in CFG = 1).
    }

    /// FIFOCFG Register bits
    namespace fifocfg_bits {
        constexpr uint32_t ENABLETX = (1U << 0);  ///< Enable the transmit FIFO.
        constexpr uint32_t ENABLERX = (1U << 1);  ///< Enable the receive FIFO.
        constexpr uint32_t SIZE = (2 << 4);  ///< FIFO size configuration. This is a read-only field. 0x0 = FIFO is configured as 16 entries of 8 bits. 0x1, 0x2, 0x3 = not applicable to USART.
        constexpr uint32_t DMATX = (1U << 12);  ///< DMA configuration for transmit.
        constexpr uint32_t DMARX = (1U << 13);  ///< DMA configuration for receive.
        constexpr uint32_t EMPTYTX = (1U << 16);  ///< Empty command for the transmit FIFO. When a 1 is written to this bit, the TX FIFO is emptied.
        constexpr uint32_t EMPTYRX = (1U << 17);  ///< Empty command for the receive FIFO. When a 1 is written to this bit, the RX FIFO is emptied.
    }

    /// FIFOSTAT Register bits
    namespace fifostat_bits {
        constexpr uint32_t TXERR = (1U << 0);  ///< TX FIFO error. Will be set if a transmit FIFO error occurs. This could be an overflow caused by pushing data into a full FIFO, or by an underflow if the FIFO is empty when data is needed. Cleared by writing a 1 to this bit.
        constexpr uint32_t RXERR = (1U << 1);  ///< RX FIFO error. Will be set if a receive FIFO overflow occurs, caused by software or DMA not emptying the FIFO fast enough. Cleared by writing a 1 to this bit.
        constexpr uint32_t PERINT = (1U << 3);  ///< Peripheral interrupt. When 1, this indicates that the peripheral function has asserted an interrupt. The details can be found by reading the peripheral'-s STAT register.
        constexpr uint32_t TXEMPTY = (1U << 4);  ///< Transmit FIFO empty. When 1, the transmit FIFO is empty. The peripheral may still be processing the last piece of data.
        constexpr uint32_t TXNOTFULL = (1U << 5);  ///< Transmit FIFO not full. When 1, the transmit FIFO is not full, so more data can be written. When 0, the transmit FIFO is full and another write would cause it to overflow.
        constexpr uint32_t RXNOTEMPTY = (1U << 6);  ///< Receive FIFO not empty. When 1, the receive FIFO is not empty, so data can be read. When 0, the receive FIFO is empty.
        constexpr uint32_t RXFULL = (1U << 7);  ///< Receive FIFO full. When 1, the receive FIFO is full. Data needs to be read out to prevent the peripheral from causing an overflow.
        constexpr uint32_t TXLVL = (5 << 8);  ///< Transmit FIFO current level. A 0 means the TX FIFO is currently empty, and the TXEMPTY and TXNOTFULL flags will be 1. Other values tell how much data is actually in the TX FIFO at the point where the read occurs. If the TX FIFO is full, the TXEMPTY and TXNOTFULL flags will be 0.
        constexpr uint32_t RXLVL = (5 << 16);  ///< Receive FIFO current level. A 0 means the RX FIFO is currently empty, and the RXFULL and RXNOTEMPTY flags will be 0. Other values tell how much data is actually in the RX FIFO at the point where the read occurs. If the RX FIFO is full, the RXFULL and RXNOTEMPTY flags will be 1.
    }

    /// FIFOTRIG Register bits
    namespace fifotrig_bits {
        constexpr uint32_t TXLVLENA = (1U << 0);  ///< Transmit FIFO level trigger enable. This trigger will become an interrupt if enabled in FIFOINTENSET, or a DMA trigger if DMATX in FIFOCFG is set.
        constexpr uint32_t RXLVLENA = (1U << 1);  ///< Receive FIFO level trigger enable. This trigger will become an interrupt if enabled in FIFOINTENSET, or a DMA trigger if DMARX in FIFOCFG is set.
        constexpr uint32_t TXLVL = (4 << 8);  ///< Transmit FIFO level trigger point. This field is used only when TXLVLENA = 1. If enabled to do so, the FIFO level can wake up the device just enough to perform DMA, then return to the reduced power mode. See Hardware Wake-up control register. 0 = trigger when the TX FIFO becomes empty. 1 = trigger when the TX FIFO level decreases to one entry. 15 = trigger when the TX FIFO level decreases to 15 entries (is no longer full).
        constexpr uint32_t RXLVL = (4 << 16);  ///< Receive FIFO level trigger point. The RX FIFO level is checked when a new piece of data is received. This field is used only when RXLVLENA = 1. If enabled to do so, the FIFO level can wake up the device just enough to perform DMA, then return to the reduced power mode. See Hardware Wake-up control register. 0 = trigger when the RX FIFO has received one entry (is no longer empty). 1 = trigger when the RX FIFO has received two entries. 15 = trigger when the RX FIFO has received 16 entries (has become full).
    }

    /// FIFOINTENSET Register bits
    namespace fifointenset_bits {
        constexpr uint32_t TXERR = (1U << 0);  ///< Determines whether an interrupt occurs when a transmit error occurs, based on the TXERR flag in the FIFOSTAT register.
        constexpr uint32_t RXERR = (1U << 1);  ///< Determines whether an interrupt occurs when a receive error occurs, based on the RXERR flag in the FIFOSTAT register.
        constexpr uint32_t TXLVL = (1U << 2);  ///< Determines whether an interrupt occurs when a the transmit FIFO reaches the level specified by the TXLVL field in the FIFOTRIG register.
        constexpr uint32_t RXLVL = (1U << 3);  ///< Determines whether an interrupt occurs when a the receive FIFO reaches the level specified by the TXLVL field in the FIFOTRIG register.
    }

    /// FIFOINTENCLR Register bits
    namespace fifointenclr_bits {
        constexpr uint32_t TXERR = (1U << 0);  ///< Writing one clears the corresponding bits in the FIFOINTENSET register.
        constexpr uint32_t RXERR = (1U << 1);  ///< Writing one clears the corresponding bits in the FIFOINTENSET register.
        constexpr uint32_t TXLVL = (1U << 2);  ///< Writing one clears the corresponding bits in the FIFOINTENSET register.
        constexpr uint32_t RXLVL = (1U << 3);  ///< Writing one clears the corresponding bits in the FIFOINTENSET register.
    }

    /// FIFOINTSTAT Register bits
    namespace fifointstat_bits {
        constexpr uint32_t TXERR = (1U << 0);  ///< TX FIFO error.
        constexpr uint32_t RXERR = (1U << 1);  ///< RX FIFO error.
        constexpr uint32_t TXLVL = (1U << 2);  ///< Transmit FIFO level interrupt.
        constexpr uint32_t RXLVL = (1U << 3);  ///< Receive FIFO level interrupt.
        constexpr uint32_t PERINT = (1U << 4);  ///< Peripheral interrupt.
    }

    /// FIFOWR Register bits
    namespace fifowr_bits {
        constexpr uint32_t TXDATA = (9 << 0);  ///< Transmit data to the FIFO.
    }

    /// FIFORD Register bits
    namespace fiford_bits {
        constexpr uint32_t RXDATA = (9 << 0);  ///< Received data from the FIFO. The number of bits used depends on the DATALEN and PARITYSEL settings.
        constexpr uint32_t FRAMERR = (1U << 13);  ///< Framing Error status flag. This bit reflects the status for the data it is read along with from the FIFO, and indicates that the character was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.
        constexpr uint32_t PARITYERR = (1U << 14);  ///< Parity Error status flag. This bit reflects the status for the data it is read along with from the FIFO. This bit will be set when a parity error is detected in a received character.
        constexpr uint32_t RXNOISE = (1U << 15);  ///< Received Noise flag. See description of the RxNoiseInt bit in Table 354.
    }

    /// FIFORDNOPOP Register bits
    namespace fifordnopop_bits {
        constexpr uint32_t RXDATA = (9 << 0);  ///< Received data from the FIFO. The number of bits used depends on the DATALEN and PARITYSEL settings.
        constexpr uint32_t FRAMERR = (1U << 13);  ///< Framing Error status flag. This bit reflects the status for the data it is read along with from the FIFO, and indicates that the character was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.
        constexpr uint32_t PARITYERR = (1U << 14);  ///< Parity Error status flag. This bit reflects the status for the data it is read along with from the FIFO. This bit will be set when a parity error is detected in a received character.
        constexpr uint32_t RXNOISE = (1U << 15);  ///< Received Noise flag. See description of the RxNoiseInt bit in Table 354.
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t APERTURE = (8 << 0);  ///< Aperture: encoded as (aperture size/4K) -1, so 0x00 means a 4K aperture.
        constexpr uint32_t MINOR_REV = (4 << 8);  ///< Minor revision of module implementation, starting at 0. Minor revision of module implementation, starting at 0. Software compatibility is expected between minor revisions.
        constexpr uint32_t MAJOR_REV = (4 << 12);  ///< Major revision of module implementation, starting at 0. There may not be software compatibility between major revisions.
        constexpr uint32_t ID = (16 << 16);  ///< Unique module identifier for this IP block.
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB0_BASE = 0x40084000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t DEVCMDSTAT;  ///< Offset: 0x00 - USB Device Command/Status register
        volatile uint32_t INFO;  ///< Offset: 0x04 - USB Info register
        volatile uint32_t EPLISTSTART;  ///< Offset: 0x08 - USB EP Command/Status List start address
        volatile uint32_t DATABUFSTART;  ///< Offset: 0x0C - USB Data buffer start address
        volatile uint32_t LPM;  ///< Offset: 0x10 - USB Link Power Management register
        volatile uint32_t EPSKIP;  ///< Offset: 0x14 - USB Endpoint skip
        volatile uint32_t EPINUSE;  ///< Offset: 0x18 - USB Endpoint Buffer in use
        volatile uint32_t EPBUFCFG;  ///< Offset: 0x1C - USB Endpoint Buffer Configuration register
        volatile uint32_t INTSTAT;  ///< Offset: 0x20 - USB interrupt status register
        volatile uint32_t INTEN;  ///< Offset: 0x24 - USB interrupt enable register
        volatile uint32_t INTSETSTAT;  ///< Offset: 0x28 - USB set interrupt status register
        volatile uint32_t EPTOGGLE;  ///< Offset: 0x34 - USB Endpoint toggle register
    };

    /// Peripheral instances
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);

    // Bit definitions
    /// DEVCMDSTAT Register bits
    namespace devcmdstat_bits {
        constexpr uint32_t DEV_ADDR = (7 << 0);  ///< USB device address. After bus reset, the address is reset to 0x00. If the enable bit is set, the device will respond on packets for function address DEV_ADDR. When receiving a SetAddress Control Request from the USB host, software must program the new address before completing the status phase of the SetAddress Control Request.
        constexpr uint32_t DEV_EN = (1U << 7);  ///< USB device enable. If this bit is set, the HW will start responding on packets for function address DEV_ADDR.
        constexpr uint32_t SETUP = (1U << 8);  ///< SETUP token received. If a SETUP token is received and acknowledged by the device, this bit is set. As long as this bit is set all received IN and OUT tokens will be NAKed by HW. SW must clear this bit by writing a one. If this bit is zero, HW will handle the tokens to the CTRL EP0 as indicated by the CTRL EP0 IN and OUT data information programmed by SW.
        constexpr uint32_t FORCE_NEEDCLK = (1U << 9);  ///< Forces the NEEDCLK output to always be on:
        constexpr uint32_t LPM_SUP = (1U << 11);  ///< LPM Supported:
        constexpr uint32_t INTONNAK_AO = (1U << 12);  ///< Interrupt on NAK for interrupt and bulk OUT EP
        constexpr uint32_t INTONNAK_AI = (1U << 13);  ///< Interrupt on NAK for interrupt and bulk IN EP
        constexpr uint32_t INTONNAK_CO = (1U << 14);  ///< Interrupt on NAK for control OUT EP
        constexpr uint32_t INTONNAK_CI = (1U << 15);  ///< Interrupt on NAK for control IN EP
        constexpr uint32_t DCON = (1U << 16);  ///< Device status - connect. The connect bit must be set by SW to indicate that the device must signal a connect. The pull-up resistor on USB_DP will be enabled when this bit is set and the VBUSDEBOUNCED bit is one.
        constexpr uint32_t DSUS = (1U << 17);  ///< Device status - suspend. The suspend bit indicates the current suspend state. It is set to 1 when the device hasn'-t seen any activity on its upstream port for more than 3 milliseconds. It is reset to 0 on any activity. When the device is suspended (Suspend bit DSUS = 1) and the software writes a 0 to it, the device will generate a remote wake-up. This will only happen when the device is connected (Connect bit = 1). When the device is not connected or not suspended, a writing a 0 has no effect. Writing a 1 never has an effect.
        constexpr uint32_t LPM_SUS = (1U << 19);  ///< Device status - LPM Suspend. This bit represents the current LPM suspend state. It is set to 1 by HW when the device has acknowledged the LPM request from the USB host and the Token Retry Time of 10 ms has elapsed. When the device is in the LPM suspended state (LPM suspend bit = 1) and the software writes a zero to this bit, the device will generate a remote walk-up. Software can only write a zero to this bit when the LPM_REWP bit is set to 1. HW resets this bit when it receives a host initiated resume. HW only updates the LPM_SUS bit when the LPM_SUPP bit is equal to one.
        constexpr uint32_t LPM_REWP = (1U << 20);  ///< LPM Remote Wake-up Enabled by USB host. HW sets this bit to one when the bRemoteWake bit in the LPM extended token is set to 1. HW will reset this bit to 0 when it receives the host initiated LPM resume, when a remote wake-up is sent by the device or when a USB bus reset is received. Software can use this bit to check if the remote wake-up feature is enabled by the host for the LPM transaction.
        constexpr uint32_t DCON_C = (1U << 24);  ///< Device status - connect change. The Connect Change bit is set when the device'-s pull-up resistor is disconnected because VBus disappeared. The bit is reset by writing a one to it.
        constexpr uint32_t DSUS_C = (1U << 25);  ///< Device status - suspend change. The suspend change bit is set to 1 when the suspend bit toggles. The suspend bit can toggle because: - The device goes in the suspended state - The device is disconnected - The device receives resume signaling on its upstream port. The bit is reset by writing a one to it.
        constexpr uint32_t DRES_C = (1U << 26);  ///< Device status - reset change. This bit is set when the device received a bus reset. On a bus reset the device will automatically go to the default state (unconfigured and responding to address 0). The bit is reset by writing a one to it.
        constexpr uint32_t VBUSDEBOUNCED = (1U << 28);  ///< This bit indicates if Vbus is detected or not. The bit raises immediately when Vbus becomes high. It drops to zero if Vbus is low for at least 3 ms. If this bit is high and the DCon bit is set, the HW will enable the pull-up resistor to signal a connect.
    }

    /// INFO Register bits
    namespace info_bits {
        constexpr uint32_t FRAME_NR = (11 << 0);  ///< Frame number. This contains the frame number of the last successfully received SOF. In case no SOF was received by the device at the beginning of a frame, the frame number returned is that of the last successfully received SOF. In case the SOF frame number contained a CRC error, the frame number returned will be the corrupted frame number as received by the device.
        constexpr uint32_t ERR_CODE = (4 << 11);  ///< The error code which last occurred:
    }

    /// EPLISTSTART Register bits
    namespace epliststart_bits {
        constexpr uint32_t EP_LIST = (24 << 8);  ///< Start address of the USB EP Command/Status List.
    }

    /// DATABUFSTART Register bits
    namespace databufstart_bits {
        constexpr uint32_t DA_BUF = (10 << 22);  ///< Start address of the buffer pointer page where all endpoint data buffers are located.
    }

    /// LPM Register bits
    namespace lpm_bits {
        constexpr uint32_t HIRD_HW = (4 << 0);  ///< Host Initiated Resume Duration - HW. This is the HIRD value from the last received LPM token
        constexpr uint32_t HIRD_SW = (4 << 4);  ///< Host Initiated Resume Duration - SW. This is the time duration required by the USB device system to come out of LPM initiated suspend after receiving the host initiated LPM resume.
        constexpr uint32_t DATA_PENDING = (1U << 8);  ///< As long as this bit is set to one and LPM supported bit is set to one, HW will return a NYET handshake on every LPM token it receives. If LPM supported bit is set to one and this bit is zero, HW will return an ACK handshake on every LPM token it receives. If SW has still data pending and LPM is supported, it must set this bit to 1.
    }

    /// EPSKIP Register bits
    namespace epskip_bits {
        constexpr uint32_t SKIP = (30 << 0);  ///< Endpoint skip: Writing 1 to one of these bits, will indicate to HW that it must deactivate the buffer assigned to this endpoint and return control back to software. When HW has deactivated the endpoint, it will clear this bit, but it will not modify the EPINUSE bit. An interrupt will be generated when the Active bit goes from 1 to 0. Note: In case of double-buffering, HW will only clear the Active bit of the buffer indicated by the EPINUSE bit.
    }

    /// EPINUSE Register bits
    namespace epinuse_bits {
        constexpr uint32_t BUF = (8 << 2);  ///< Buffer in use: This register has one bit per physical endpoint. 0: HW is accessing buffer 0. 1: HW is accessing buffer 1.
    }

    /// EPBUFCFG Register bits
    namespace epbufcfg_bits {
        constexpr uint32_t BUF_SB = (8 << 2);  ///< Buffer usage: This register has one bit per physical endpoint. 0: Single-buffer. 1: Double-buffer. If the bit is set to single-buffer (0), it will not toggle the corresponding EPINUSE bit when it clears the active bit. If the bit is set to double-buffer (1), HW will toggle the EPINUSE bit when it clears the Active bit for the buffer.
    }

    /// INTSTAT Register bits
    namespace intstat_bits {
        constexpr uint32_t EP0OUT = (1U << 0);  ///< Interrupt status register bit for the Control EP0 OUT direction. This bit will be set if NBytes transitions to zero or the skip bit is set by software or a SETUP packet is successfully received for the control EP0. If the IntOnNAK_CO is set, this bit will also be set when a NAK is transmitted for the Control EP0 OUT direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP0IN = (1U << 1);  ///< Interrupt status register bit for the Control EP0 IN direction. This bit will be set if NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_CI is set, this bit will also be set when a NAK is transmitted for the Control EP0 IN direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP1OUT = (1U << 2);  ///< Interrupt status register bit for the EP1 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP1 OUT direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP1IN = (1U << 3);  ///< Interrupt status register bit for the EP1 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP1 IN direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP2OUT = (1U << 4);  ///< Interrupt status register bit for the EP2 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP2 OUT direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP2IN = (1U << 5);  ///< Interrupt status register bit for the EP2 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP2 IN direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP3OUT = (1U << 6);  ///< Interrupt status register bit for the EP3 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP3 OUT direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP3IN = (1U << 7);  ///< Interrupt status register bit for the EP3 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP3 IN direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP4OUT = (1U << 8);  ///< Interrupt status register bit for the EP4 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP4 OUT direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP4IN = (1U << 9);  ///< Interrupt status register bit for the EP4 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP4 IN direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP5OUT = (1U << 10);  ///< Interrupt status register bit for the EP5 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP5 OUT direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP5IN = (1U << 11);  ///< Interrupt status register bit for the EP5 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP5 IN direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP6OUT = (1U << 12);  ///< Interrupt status register bit for the EP6 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP6 OUT direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP6IN = (1U << 13);  ///< Interrupt status register bit for the EP6 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP6 IN direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP7OUT = (1U << 14);  ///< Interrupt status register bit for the EP7 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP7 OUT direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t EP7IN = (1U << 15);  ///< Interrupt status register bit for the EP7 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP7 IN direction. Software can clear this bit by writing a one to it.
        constexpr uint32_t FRAME_INT = (1U << 30);  ///< Frame interrupt. This bit is set to one every millisecond when the VbusDebounced bit and the DCON bit are set. This bit can be used by software when handling isochronous endpoints. Software can clear this bit by writing a one to it.
        constexpr uint32_t DEV_INT = (1U << 31);  ///< Device status interrupt. This bit is set by HW when one of the bits in the Device Status Change register are set. Software can clear this bit by writing a one to it.
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t EP_INT_EN = (16 << 0);  ///< If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line indicated by the corresponding USB interrupt routing bit.
        constexpr uint32_t FRAME_INT_EN = (1U << 30);  ///< If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line indicated by the corresponding USB interrupt routing bit.
        constexpr uint32_t DEV_INT_EN = (1U << 31);  ///< If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line indicated by the corresponding USB interrupt routing bit.
    }

    /// INTSETSTAT Register bits
    namespace intsetstat_bits {
        constexpr uint32_t EP_SET_INT = (16 << 0);  ///< If software writes a one to one of these bits, the corresponding USB interrupt status bit is set. When this register is read, the same value as the USB interrupt status register is returned.
        constexpr uint32_t FRAME_SET_INT = (1U << 30);  ///< If software writes a one to one of these bits, the corresponding USB interrupt status bit is set. When this register is read, the same value as the USB interrupt status register is returned.
        constexpr uint32_t DEV_SET_INT = (1U << 31);  ///< If software writes a one to one of these bits, the corresponding USB interrupt status bit is set. When this register is read, the same value as the USB interrupt status register is returned.
    }

    /// EPTOGGLE Register bits
    namespace eptoggle_bits {
        constexpr uint32_t TOGGLE = (16 << 0);  ///< Endpoint data toggle: This field indicates the current value of the data toggle for the corresponding endpoint.
    }

}

// ============================================================================
// SCT0 Peripheral
// ============================================================================

namespace sct0 {
    /// Base addresses
    constexpr uint32_t SCT0_BASE = 0x40085000;

    /// SCT0 Register structure
    struct Registers {
        volatile uint32_t CONFIG;  ///< Offset: 0x00 - SCT configuration register
        volatile uint32_t CTRL;  ///< Offset: 0x04 - SCT event control register 0
        volatile uint32_t LIMIT;  ///< Offset: 0x08 - SCT limit event select register
        volatile uint32_t HALT;  ///< Offset: 0x0C - SCT halt event select register
        volatile uint32_t STOP;  ///< Offset: 0x10 - SCT stop event select register
        volatile uint32_t START;  ///< Offset: 0x14 - SCT start event select register
        volatile uint32_t COUNT;  ///< Offset: 0x40 - SCT counter register
        volatile uint32_t STATE;  ///< Offset: 0x00 - SCT event state register 0
        volatile uint32_t INPUT;  ///< Offset: 0x48 - SCT input register
        volatile uint32_t REGMODE;  ///< Offset: 0x4C - SCT match/capture mode register
        volatile uint32_t OUTPUT;  ///< Offset: 0x50 - SCT output register
        volatile uint32_t OUTPUTDIRCTRL;  ///< Offset: 0x54 - SCT output counter direction control register
        volatile uint32_t RES;  ///< Offset: 0x58 - SCT conflict resolution register
        volatile uint32_t DMA0REQUEST;  ///< Offset: 0x5C - SCT DMA request 0 register
        volatile uint32_t DMA1REQUEST;  ///< Offset: 0x60 - SCT DMA request 1 register
        volatile uint32_t EVEN;  ///< Offset: 0xF0 - SCT event interrupt enable register
        volatile uint32_t EVFLAG;  ///< Offset: 0xF4 - SCT event flag register
        volatile uint32_t CONEN;  ///< Offset: 0xF8 - SCT conflict interrupt enable register
        volatile uint32_t CONFLAG;  ///< Offset: 0xFC - SCT conflict flag register
        volatile uint32_t SCTCAP[%s];  ///< Offset: 0x100 - SCT capture register of capture channel
        volatile uint32_t SCTMATCH[%s];  ///< Offset: 0x100 - SCT match value register of match channels
        volatile uint32_t SCTCAPCTRL[%s];  ///< Offset: 0x200 - SCT capture control register
        volatile uint32_t SCTMATCHREL[%s];  ///< Offset: 0x200 - SCT match reload value register
        volatile uint32_t SET;  ///< Offset: 0x00 - SCT output 0 set register
        volatile uint32_t CLR;  ///< Offset: 0x04 - SCT output 0 clear register
        volatile uint32_t MODULECONTENT;  ///< Offset: 0x7FC - Reserved
    };

    /// Peripheral instances
    inline Registers* SCT0 = reinterpret_cast<Registers*>(SCT0_BASE);

    // Bit definitions
    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t UNIFY = (1U << 0);  ///< SCT operation
        constexpr uint32_t CLKMODE = (2 << 1);  ///< SCT clock mode
        constexpr uint32_t CKSEL = (4 << 3);  ///< SCT clock select. The specific functionality of the designated input/edge is dependent on the CLKMODE bit selection in this register.
        constexpr uint32_t NORELAOD_L = (1U << 7);  ///< A 1 in this bit prevents the lower match registers from being reloaded from their respective reload registers. Setting this bit eliminates the need to write to the reload registers MATCHREL if the match values are fixed. Software can write to set or clear this bit at any time. This bit applies to both the higher and lower registers when the UNIFY bit is set.
        constexpr uint32_t NORELOAD_H = (1U << 8);  ///< A 1 in this bit prevents the higher match registers from being reloaded from their respective reload registers. Setting this bit eliminates the need to write to the reload registers MATCHREL if the match values are fixed. Software can write to set or clear this bit at any time. This bit is not used when the UNIFY bit is set.
        constexpr uint32_t INSYNC = (4 << 9);  ///< Synchronization for input N (bit 9 = input 0, bit 10 = input 1,, bit 12 = input 3); all other bits are reserved. A 1 in one of these bits subjects the corresponding input to synchronization to the SCT clock, before it is used to create an event. If an input is known to already be synchronous to the SCT clock, this bit may be set to 0 for faster input response. (Note: The SCT clock is the system clock for CKMODEs 0-2. It is the selected, asynchronous SCT input clock for CKMODE3). Note that the INSYNC field only affects inputs used for event generation. It does not apply to the clock input specified in the CKSEL field.
        constexpr uint32_t AUTOLIMIT_L = (1U << 17);  ///< A one in this bit causes a match on match register 0 to be treated as a de-facto LIMIT condition without the need to define an associated event. As with any LIMIT event, this automatic limit causes the counter to be cleared to zero in unidirectional mode or to change the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit applies to both the higher and lower registers when the UNIFY bit is set.
        constexpr uint32_t AUTOLIMIT_H = (1U << 18);  ///< A one in this bit will cause a match on match register 0 to be treated as a de-facto LIMIT condition without the need to define an associated event. As with any LIMIT event, this automatic limit causes the counter to be cleared to zero in unidirectional mode or to change the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit is not used when the UNIFY bit is set.
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t MATCHSEL = (4 << 0);  ///< Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running.
        constexpr uint32_t HEVENT = (1U << 4);  ///< Select L/H counter. Do not set this bit if UNIFY = 1.
        constexpr uint32_t OUTSEL = (1U << 5);  ///< Input/output select
        constexpr uint32_t IOSEL = (4 << 6);  ///< Selects the input or output signal number associated with this event (if any). Do not select an input in this register if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event.
        constexpr uint32_t IOCOND = (2 << 10);  ///< Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period .
        constexpr uint32_t COMBMODE = (2 << 12);  ///< Selects how the specified match and I/O condition are used and combined.
        constexpr uint32_t STATELD = (1U << 14);  ///< This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state.
        constexpr uint32_t STATEV = (5 << 15);  ///< This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value.
        constexpr uint32_t MATCHMEM = (1U << 20);  ///< If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value.
        constexpr uint32_t DIRECTION = (2 << 21);  ///< Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.
    }

    /// LIMIT Register bits
    namespace limit_bits {
        constexpr uint32_t LIMMSK_L = (16 << 0);  ///< If bit n is one, event n is used as a counter limit for the L or unified counter (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
        constexpr uint32_t LIMMSK_H = (16 << 16);  ///< If bit n is one, event n is used as a counter limit for the H counter (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of events in this SCT.
    }

    /// HALT Register bits
    namespace halt_bits {
        constexpr uint32_t HALTMSK_L = (16 << 0);  ///< If bit n is one, event n sets the HALT_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
        constexpr uint32_t HALTMSK_H = (16 << 16);  ///< If bit n is one, event n sets the HALT_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of events in this SCT.
    }

    /// STOP Register bits
    namespace stop_bits {
        constexpr uint32_t STOPMSK_L = (16 << 0);  ///< If bit n is one, event n sets the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
        constexpr uint32_t STOPMSK_H = (16 << 16);  ///< If bit n is one, event n sets the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of events in this SCT.
    }

    /// START Register bits
    namespace start_bits {
        constexpr uint32_t STARTMSK_L = (16 << 0);  ///< If bit n is one, event n clears the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
        constexpr uint32_t STARTMSK_H = (16 << 16);  ///< If bit n is one, event n clears the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of events in this SCT.
    }

    /// COUNT Register bits
    namespace count_bits {
        constexpr uint32_t CTR_L = (16 << 0);  ///< When UNIFY = 0, read or write the 16-bit L counter value. When UNIFY = 1, read or write the lower 16 bits of the 32-bit unified counter.
        constexpr uint32_t CTR_H = (16 << 16);  ///< When UNIFY = 0, read or write the 16-bit H counter value. When UNIFY = 1, read or write the upper 16 bits of the 32-bit unified counter.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t STATEMSKn = (16 << 0);  ///< If bit m is one, event n happens in state m of the counter selected by the HEVENT bit (n = event number, m = state number; state 0 = bit 0, state 1= bit 1, etc.). The number of bits = number of states in this SCT.
    }

    /// INPUT Register bits
    namespace input_bits {
        constexpr uint32_t AIN0 = (1U << 0);  ///< Input 0 state. Input 0 state on the last SCT clock edge.
        constexpr uint32_t AIN1 = (1U << 1);  ///< Input 1 state. Input 1 state on the last SCT clock edge.
        constexpr uint32_t AIN2 = (1U << 2);  ///< Input 2 state. Input 2 state on the last SCT clock edge.
        constexpr uint32_t AIN3 = (1U << 3);  ///< Input 3 state. Input 3 state on the last SCT clock edge.
        constexpr uint32_t AIN4 = (1U << 4);  ///< Input 4 state. Input 4 state on the last SCT clock edge.
        constexpr uint32_t AIN5 = (1U << 5);  ///< Input 5 state. Input 5 state on the last SCT clock edge.
        constexpr uint32_t AIN6 = (1U << 6);  ///< Input 6 state. Input 6 state on the last SCT clock edge.
        constexpr uint32_t AIN7 = (1U << 7);  ///< Input 7 state. Input 7 state on the last SCT clock edge.
        constexpr uint32_t AIN8 = (1U << 8);  ///< Input 8 state. Input 8 state on the last SCT clock edge.
        constexpr uint32_t AIN9 = (1U << 9);  ///< Input 9 state. Input 9 state on the last SCT clock edge.
        constexpr uint32_t AIN10 = (1U << 10);  ///< Input 10 state. Input 10 state on the last SCT clock edge.
        constexpr uint32_t AIN11 = (1U << 11);  ///< Input 11 state. Input 11 state on the last SCT clock edge.
        constexpr uint32_t AIN12 = (1U << 12);  ///< Input 12 state. Input 12 state on the last SCT clock edge.
        constexpr uint32_t AIN13 = (1U << 13);  ///< Input 13 state. Input 13 state on the last SCT clock edge.
        constexpr uint32_t AIN14 = (1U << 14);  ///< Input 14 state. Input 14 state on the last SCT clock edge.
        constexpr uint32_t AIN15 = (1U << 15);  ///< Input 15 state. Input 15 state on the last SCT clock edge.
        constexpr uint32_t SIN0 = (1U << 16);  ///< Input 0 state. Input 0 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN1 = (1U << 17);  ///< Input 1 state. Input 1 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN2 = (1U << 18);  ///< Input 2 state. Input 2 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN3 = (1U << 19);  ///< Input 3 state. Input 3 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN4 = (1U << 20);  ///< Input 4 state. Input 4 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN5 = (1U << 21);  ///< Input 5 state. Input 5 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN6 = (1U << 22);  ///< Input 6 state. Input 6 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN7 = (1U << 23);  ///< Input 7 state. Input 7 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN8 = (1U << 24);  ///< Input 8 state. Input 8 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN9 = (1U << 25);  ///< Input 9 state. Input 9 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN10 = (1U << 26);  ///< Input 10 state. Input 10 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN11 = (1U << 27);  ///< Input 11 state. Input 11 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN12 = (1U << 28);  ///< Input 12 state. Input 12 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN13 = (1U << 29);  ///< Input 13 state. Input 13 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN14 = (1U << 30);  ///< Input 14 state. Input 14 state following the synchronization specified by INSYNC.
        constexpr uint32_t SIN15 = (1U << 31);  ///< Input 15 state. Input 15 state following the synchronization specified by INSYNC.
    }

    /// REGMODE Register bits
    namespace regmode_bits {
        constexpr uint32_t REGMOD_L = (16 << 0);  ///< Each bit controls one match/capture register (register 0 = bit 0, register 1 = bit 1, etc.). The number of bits = number of match/captures in this SCT. 0 = register operates as match register. 1 = register operates as capture register.
        constexpr uint32_t REGMOD_H = (16 << 16);  ///< Each bit controls one match/capture register (register 0 = bit 16, register 1 = bit 17, etc.). The number of bits = number of match/captures in this SCT. 0 = register operates as match registers. 1 = register operates as capture registers.
    }

    /// OUTPUT Register bits
    namespace output_bits {
        constexpr uint32_t OUT = (16 << 0);  ///< Writing a 1 to bit n forces the corresponding output HIGH. Writing a 0 forces the corresponding output LOW (output 0 = bit 0, output 1 = bit 1, etc.). The number of bits = number of outputs in this SCT.
    }

    /// OUTPUTDIRCTRL Register bits
    namespace outputdirctrl_bits {
        constexpr uint32_t SETCLR0 = (2 << 0);  ///< Set/clear operation on output 0. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR1 = (2 << 2);  ///< Set/clear operation on output 1. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR2 = (2 << 4);  ///< Set/clear operation on output 2. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR3 = (2 << 6);  ///< Set/clear operation on output 3. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR4 = (2 << 8);  ///< Set/clear operation on output 4. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR5 = (2 << 10);  ///< Set/clear operation on output 5. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR6 = (2 << 12);  ///< Set/clear operation on output 6. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR7 = (2 << 14);  ///< Set/clear operation on output 7. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR8 = (2 << 16);  ///< Set/clear operation on output 8. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR9 = (2 << 18);  ///< Set/clear operation on output 9. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR10 = (2 << 20);  ///< Set/clear operation on output 10. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR11 = (2 << 22);  ///< Set/clear operation on output 11. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR12 = (2 << 24);  ///< Set/clear operation on output 12. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR13 = (2 << 26);  ///< Set/clear operation on output 13. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR14 = (2 << 28);  ///< Set/clear operation on output 14. Value 0x3 is reserved. Do not program this value.
        constexpr uint32_t SETCLR15 = (2 << 30);  ///< Set/clear operation on output 15. Value 0x3 is reserved. Do not program this value.
    }

    /// RES Register bits
    namespace res_bits {
        constexpr uint32_t O0RES = (2 << 0);  ///< Effect of simultaneous set and clear on output 0.
        constexpr uint32_t O1RES = (2 << 2);  ///< Effect of simultaneous set and clear on output 1.
        constexpr uint32_t O2RES = (2 << 4);  ///< Effect of simultaneous set and clear on output 2.
        constexpr uint32_t O3RES = (2 << 6);  ///< Effect of simultaneous set and clear on output 3.
        constexpr uint32_t O4RES = (2 << 8);  ///< Effect of simultaneous set and clear on output 4.
        constexpr uint32_t O5RES = (2 << 10);  ///< Effect of simultaneous set and clear on output 5.
        constexpr uint32_t O6RES = (2 << 12);  ///< Effect of simultaneous set and clear on output 6.
        constexpr uint32_t O7RES = (2 << 14);  ///< Effect of simultaneous set and clear on output 7.
        constexpr uint32_t O8RES = (2 << 16);  ///< Effect of simultaneous set and clear on output 8.
        constexpr uint32_t O9RES = (2 << 18);  ///< Effect of simultaneous set and clear on output 9.
        constexpr uint32_t O10RES = (2 << 20);  ///< Effect of simultaneous set and clear on output 10.
        constexpr uint32_t O11RES = (2 << 22);  ///< Effect of simultaneous set and clear on output 11.
        constexpr uint32_t O12RES = (2 << 24);  ///< Effect of simultaneous set and clear on output 12.
        constexpr uint32_t O13RES = (2 << 26);  ///< Effect of simultaneous set and clear on output 13.
        constexpr uint32_t O14RES = (2 << 28);  ///< Effect of simultaneous set and clear on output 14.
        constexpr uint32_t O15RES = (2 << 30);  ///< Effect of simultaneous set and clear on output 15.
    }

    /// DMA0REQUEST Register bits
    namespace dma0request_bits {
        constexpr uint32_t DEV_0 = (16 << 0);  ///< If bit n is one, event n triggers DMA request 0 (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
        constexpr uint32_t DRL0 = (1U << 30);  ///< A 1 in this bit triggers DMA request 0 when it loads the MATCH_L/Unified registers from the RELOAD_L/Unified registers.
        constexpr uint32_t DRQ0 = (1U << 31);  ///< This read-only bit indicates the state of DMA Request 0. Note that if the related DMA channel is enabled and properly set up, it is unlikely that software will see this flag, it will be cleared rapidly by the DMA service. The flag remaining set could point to an issue with DMA setup.
    }

    /// DMA1REQUEST Register bits
    namespace dma1request_bits {
        constexpr uint32_t DEV_1 = (16 << 0);  ///< If bit n is one, event n triggers DMA request 1 (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
        constexpr uint32_t DRL1 = (1U << 30);  ///< A 1 in this bit triggers DMA request 1 when it loads the Match L/Unified registers from the Reload L/Unified registers.
        constexpr uint32_t DRQ1 = (1U << 31);  ///< This read-only bit indicates the state of DMA Request 1. Note that if the related DMA channel is enabled and properly set up, it is unlikely that software will see this flag, it will be cleared rapidly by the DMA service. The flag remaining set could point to an issue with DMA setup.
    }

    /// EVEN Register bits
    namespace even_bits {
        constexpr uint32_t IEN = (16 << 0);  ///< The SCT requests an interrupt when bit n of this register and the event flag register are both one (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
    }

    /// EVFLAG Register bits
    namespace evflag_bits {
        constexpr uint32_t FLAG = (16 << 0);  ///< Bit n is one if event n has occurred since reset or a 1 was last written to this bit (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
    }

    /// CONEN Register bits
    namespace conen_bits {
        constexpr uint32_t NCEN = (16 << 0);  ///< The SCT requests an interrupt when bit n of this register and the SCT conflict flag register are both one (output 0 = bit 0, output 1 = bit 1, etc.). The number of bits = number of outputs in this SCT.
    }

    /// CONFLAG Register bits
    namespace conflag_bits {
        constexpr uint32_t NCFLAG = (16 << 0);  ///< Bit n is one if a no-change conflict event occurred on output n since reset or a 1 was last written to this bit (output 0 = bit 0, output 1 = bit 1, etc.). The number of bits = number of outputs in this SCT.
        constexpr uint32_t BUSERRL = (1U << 30);  ///< The most recent bus error from this SCT involved writing CTR L/Unified, STATE L/Unified, MATCH L/Unified, or the Output register when the L/U counter was not halted. A word write to certain L and H registers can be half successful and half unsuccessful.
        constexpr uint32_t BUSERRH = (1U << 31);  ///< The most recent bus error from this SCT involved writing CTR H, STATE H, MATCH H, or the Output register when the H counter was not halted.
    }

    /// SCTCAP[%s] Register bits
    namespace sctcap[%s]_bits {
        constexpr uint32_t CAPn_L = (16 << 0);  ///< When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.
        constexpr uint32_t CAPn_H = (16 << 16);  ///< When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.
    }

    /// SCTMATCH[%s] Register bits
    namespace sctmatch[%s]_bits {
        constexpr uint32_t MATCHn_L = (16 << 0);  ///< When UNIFY = 0, read or write the 16-bit value to be compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.
        constexpr uint32_t MATCHn_H = (16 << 16);  ///< When UNIFY = 0, read or write the 16-bit value to be compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.
    }

    /// SCTCAPCTRL[%s] Register bits
    namespace sctcapctrl[%s]_bits {
        constexpr uint32_t CAPCONn_L = (16 << 0);  ///< If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of match/captures in this SCT.
        constexpr uint32_t CAPCONn_H = (16 << 16);  ///< If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of match/captures in this SCT.
    }

    /// SCTMATCHREL[%s] Register bits
    namespace sctmatchrel[%s]_bits {
        constexpr uint32_t RELOADn_L = (16 << 0);  ///< When UNIFY = 0, specifies the 16-bit value to be loaded into the MATCHn_L register. When UNIFY = 1, specifies the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.
        constexpr uint32_t RELOADn_H = (16 << 16);  ///< When UNIFY = 0, specifies the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, specifies the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.
    }

    /// SET Register bits
    namespace set_bits {
        constexpr uint32_t SET = (16 << 0);  ///< A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) output 0 = bit 0, output 1 = bit 1, etc. The number of bits = number of events in this SCT. When the counter is used in bi-directional mode, it is possible to reverse the action specified by the output set and clear registers when counting down, See the OUTPUTCTRL register.
    }

    /// CLR Register bits
    namespace clr_bits {
        constexpr uint32_t CLR = (16 << 0);  ///< A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The number of bits = number of events in this SCT. When the counter is used in bi-directional mode, it is possible to reverse the action specified by the output set and clear registers when counting down, See the OUTPUTCTRL register.
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40086000;
    constexpr uint32_t I2C1_BASE = 0x40087000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CFG;  ///< Offset: 0x800 - Configuration for shared functions.
        volatile uint32_t STAT;  ///< Offset: 0x804 - Status register for Master, Slave, and Monitor functions.
        volatile uint32_t INTENSET;  ///< Offset: 0x808 - Interrupt Enable Set and read register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x80C - Interrupt Enable Clear register.
        volatile uint32_t TIMEOUT;  ///< Offset: 0x810 - Time-out value register.
        volatile uint32_t CLKDIV;  ///< Offset: 0x814 - Clock pre-divider for the entire I2C interface. This...
        volatile uint32_t INTSTAT;  ///< Offset: 0x818 - Interrupt Status register for Master, Slave, and Monitor...
        volatile uint32_t MSTCTL;  ///< Offset: 0x820 - Master control register.
        volatile uint32_t MSTTIME;  ///< Offset: 0x824 - Master timing configuration.
        volatile uint32_t MSTDAT;  ///< Offset: 0x828 - Combined Master receiver and transmitter data register.
        volatile uint32_t SLVCTL;  ///< Offset: 0x840 - Slave control register.
        volatile uint32_t SLVDAT;  ///< Offset: 0x844 - Combined Slave receiver and transmitter data register.
        volatile uint32_t SLVADR[%s];  ///< Offset: 0x848 - Slave address register.
        volatile uint32_t SLVQUAL0;  ///< Offset: 0x858 - Slave Qualification for address 0.
        volatile uint32_t MONRXDAT;  ///< Offset: 0x880 - Monitor receiver data register.
        volatile uint32_t ID;  ///< Offset: 0xFFC - I2C module Identification. This value appears in the...
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// CFG Register bits
    namespace cfg_bits {
        constexpr uint32_t MSTEN = (1U << 0);  ///< Master Enable. When disabled, configurations settings for the Master function are not changed, but the Master function is internally reset.
        constexpr uint32_t SLVEN = (1U << 1);  ///< Slave Enable. When disabled, configurations settings for the Slave function are not changed, but the Slave function is internally reset.
        constexpr uint32_t MONEN = (1U << 2);  ///< Monitor Enable. When disabled, configurations settings for the Monitor function are not changed, but the Monitor function is internally reset.
        constexpr uint32_t TIMEOUTEN = (1U << 3);  ///< I2C bus Time-out Enable. When disabled, the time-out function is internally reset.
        constexpr uint32_t MONCLKSTR = (1U << 4);  ///< Monitor function Clock Stretching.
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t MSTPENDING = (1U << 0);  ///< Master Pending. Indicates that the Master is waiting to continue communication on the I2C-bus (pending) or is idle. When the master is pending, the MSTSTATE bits indicate what type of software service if any the master expects. This flag will cause an interrupt when set if, enabled via the INTENSET register. The MSTPENDING flag is not set when the DMA is handling an event (if the MSTDMA bit in the MSTCTL register is set). If the master is in the idle state, and no communication is needed, mask this interrupt.
        constexpr uint32_t MSTSTATE = (3 << 1);  ///< Master State code. The master state code reflects the master state when the MSTPENDING bit is set, that is the master is pending or in the idle state. Each value of this field indicates a specific required service for the Master function. All other values are reserved. See Table 400 for details of state values and appropriate responses.
        constexpr uint32_t MSTARBLOSS = (1U << 4);  ///< Master Arbitration Loss flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE.
        constexpr uint32_t MSTSTSTPERR = (1U << 6);  ///< Master Start/Stop Error flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE.
        constexpr uint32_t SLVPENDING = (1U << 8);  ///< Slave Pending. Indicates that the Slave function is waiting to continue communication on the I2C-bus and needs software service. This flag will cause an interrupt when set if enabled via INTENSET. The SLVPENDING flag is not set when the DMA is handling an event (if the SLVDMA bit in the SLVCTL register is set). The SLVPENDING flag is read-only and is automatically cleared when a 1 is written to the SLVCONTINUE bit in the SLVCTL register. The point in time when SlvPending is set depends on whether the I2C interface is in HSCAPABLE mode. See Section 25.7.2.2.2. When the I2C interface is configured to be HSCAPABLE, HS master codes are detected automatically. Due to the requirements of the HS I2C specification, slave addresses must also be detected automatically, since the address must be acknowledged before the clock can be stretched.
        constexpr uint32_t SLVSTATE = (2 << 9);  ///< Slave State code. Each value of this field indicates a specific required service for the Slave function. All other values are reserved. See Table 401 for state values and actions. note that the occurrence of some states and how they are handled are affected by DMA mode and Automatic Operation modes.
        constexpr uint32_t SLVNOTSTR = (1U << 11);  ///< Slave Not Stretching. Indicates when the slave function is stretching the I2C clock. This is needed in order to gracefully invoke Deep Sleep or Power-down modes during slave operation. This read-only flag reflects the slave function status in real time.
        constexpr uint32_t SLVIDX = (2 << 12);  ///< Slave address match Index. This field is valid when the I2C slave function has been selected by receiving an address that matches one of the slave addresses defined by any enabled slave address registers, and provides an identification of the address that was matched. It is possible that more than one address could be matched, but only one match can be reported here.
        constexpr uint32_t SLVSEL = (1U << 14);  ///< Slave selected flag. SLVSEL is set after an address match when software tells the Slave function to acknowledge the address, or when the address has been automatically acknowledged. It is cleared when another address cycle presents an address that does not match an enabled address on the Slave function, when slave software decides to NACK a matched address, when there is a Stop detected on the bus, when the master NACKs slave data, and in some combinations of Automatic Operation. SLVSEL is not cleared if software NACKs data.
        constexpr uint32_t SLVDESEL = (1U << 15);  ///< Slave Deselected flag. This flag will cause an interrupt when set if enabled via INTENSET. This flag can be cleared by writing a 1 to this bit.
        constexpr uint32_t MONRDY = (1U << 16);  ///< Monitor Ready. This flag is cleared when the MONRXDAT register is read.
        constexpr uint32_t MONOV = (1U << 17);  ///< Monitor Overflow flag.
        constexpr uint32_t MONACTIVE = (1U << 18);  ///< Monitor Active flag. Indicates when the Monitor function considers the I 2C bus to be active. Active is defined here as when some Master is on the bus: a bus Start has occurred more recently than a bus Stop.
        constexpr uint32_t MONIDLE = (1U << 19);  ///< Monitor Idle flag. This flag is set when the Monitor function sees the I2C bus change from active to inactive. This can be used by software to decide when to process data accumulated by the Monitor function. This flag will cause an interrupt when set if enabled via the INTENSET register. The flag can be cleared by writing a 1 to this bit.
        constexpr uint32_t EVENTTIMEOUT = (1U << 24);  ///< Event Time-out Interrupt flag. Indicates when the time between events has been longer than the time specified by the TIMEOUT register. Events include Start, Stop, and clock edges. The flag is cleared by writing a 1 to this bit. No time-out is created when the I2C-bus is idle.
        constexpr uint32_t SCLTIMEOUT = (1U << 25);  ///< SCL Time-out Interrupt flag. Indicates when SCL has remained low longer than the time specific by the TIMEOUT register. The flag is cleared by writing a 1 to this bit.
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t MSTPENDINGEN = (1U << 0);  ///< Master Pending interrupt Enable.
        constexpr uint32_t MSTARBLOSSEN = (1U << 4);  ///< Master Arbitration Loss interrupt Enable.
        constexpr uint32_t MSTSTSTPERREN = (1U << 6);  ///< Master Start/Stop Error interrupt Enable.
        constexpr uint32_t SLVPENDINGEN = (1U << 8);  ///< Slave Pending interrupt Enable.
        constexpr uint32_t SLVNOTSTREN = (1U << 11);  ///< Slave Not Stretching interrupt Enable.
        constexpr uint32_t SLVDESELEN = (1U << 15);  ///< Slave Deselect interrupt Enable.
        constexpr uint32_t MONRDYEN = (1U << 16);  ///< Monitor data Ready interrupt Enable.
        constexpr uint32_t MONOVEN = (1U << 17);  ///< Monitor Overrun interrupt Enable.
        constexpr uint32_t MONIDLEEN = (1U << 19);  ///< Monitor Idle interrupt Enable.
        constexpr uint32_t EVENTTIMEOUTEN = (1U << 24);  ///< Event time-out interrupt Enable.
        constexpr uint32_t SCLTIMEOUTEN = (1U << 25);  ///< SCL time-out interrupt Enable.
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t MSTPENDINGCLR = (1U << 0);  ///< Master Pending interrupt clear. Writing 1 to this bit clears the corresponding bit in the INTENSET register if implemented.
        constexpr uint32_t MSTARBLOSSCLR = (1U << 4);  ///< Master Arbitration Loss interrupt clear.
        constexpr uint32_t MSTSTSTPERRCLR = (1U << 6);  ///< Master Start/Stop Error interrupt clear.
        constexpr uint32_t SLVPENDINGCLR = (1U << 8);  ///< Slave Pending interrupt clear.
        constexpr uint32_t SLVNOTSTRCLR = (1U << 11);  ///< Slave Not Stretching interrupt clear.
        constexpr uint32_t SLVDESELCLR = (1U << 15);  ///< Slave Deselect interrupt clear.
        constexpr uint32_t MONRDYCLR = (1U << 16);  ///< Monitor data Ready interrupt clear.
        constexpr uint32_t MONOVCLR = (1U << 17);  ///< Monitor Overrun interrupt clear.
        constexpr uint32_t MONIDLECLR = (1U << 19);  ///< Monitor Idle interrupt clear.
        constexpr uint32_t EVENTTIMEOUTCLR = (1U << 24);  ///< Event time-out interrupt clear.
        constexpr uint32_t SCLTIMEOUTCLR = (1U << 25);  ///< SCL time-out interrupt clear.
    }

    /// TIMEOUT Register bits
    namespace timeout_bits {
        constexpr uint32_t TOMIN = (4 << 0);  ///< Time-out time value, bottom four bits. These are hard-wired to 0xF. This gives a minimum time-out of 16 I2C function clocks and also a time-out resolution of 16 I2C function clocks.
        constexpr uint32_t TO = (12 << 4);  ///< Time-out time value. Specifies the time-out interval value in increments of 16 I 2C function clocks, as defined by the CLKDIV register. To change this value while I2C is in operation, disable all time-outs, write a new value to TIMEOUT, then re-enable time-outs. 0x000 = A time-out will occur after 16 counts of the I2C function clock. 0x001 = A time-out will occur after 32 counts of the I2C function clock. 0xFFF = A time-out will occur after 65,536 counts of the I2C function clock.
    }

    /// CLKDIV Register bits
    namespace clkdiv_bits {
        constexpr uint32_t DIVVAL = (16 << 0);  ///< This field controls how the Flexcomm clock (FCLK) is used by the I2C functions that need an internal clock in order to operate. 0x0000 = FCLK is used directly by the I2C. 0x0001 = FCLK is divided by 2 before use. 0x0002 = FCLK is divided by 3 before use. 0xFFFF = FCLK is divided by 65,536 before use.
    }

    /// INTSTAT Register bits
    namespace intstat_bits {
        constexpr uint32_t MSTPENDING = (1U << 0);  ///< Master Pending.
        constexpr uint32_t MSTARBLOSS = (1U << 4);  ///< Master Arbitration Loss flag.
        constexpr uint32_t MSTSTSTPERR = (1U << 6);  ///< Master Start/Stop Error flag.
        constexpr uint32_t SLVPENDING = (1U << 8);  ///< Slave Pending.
        constexpr uint32_t SLVNOTSTR = (1U << 11);  ///< Slave Not Stretching status.
        constexpr uint32_t SLVDESEL = (1U << 15);  ///< Slave Deselected flag.
        constexpr uint32_t MONRDY = (1U << 16);  ///< Monitor Ready.
        constexpr uint32_t MONOV = (1U << 17);  ///< Monitor Overflow flag.
        constexpr uint32_t MONIDLE = (1U << 19);  ///< Monitor Idle flag.
        constexpr uint32_t EVENTTIMEOUT = (1U << 24);  ///< Event time-out Interrupt flag.
        constexpr uint32_t SCLTIMEOUT = (1U << 25);  ///< SCL time-out Interrupt flag.
    }

    /// MSTCTL Register bits
    namespace mstctl_bits {
        constexpr uint32_t MSTCONTINUE = (1U << 0);  ///< Master Continue. This bit is write-only.
        constexpr uint32_t MSTSTART = (1U << 1);  ///< Master Start control. This bit is write-only.
        constexpr uint32_t MSTSTOP = (1U << 2);  ///< Master Stop control. This bit is write-only.
        constexpr uint32_t MSTDMA = (1U << 3);  ///< Master DMA enable. Data operations of the I2C can be performed with DMA. Protocol type operations such as Start, address, Stop, and address match must always be done with software, typically via an interrupt. Address acknowledgement must also be done by software except when the I2C is configured to be HSCAPABLE (and address acknowledgement is handled entirely by hardware) or when Automatic Operation is enabled. When a DMA data transfer is complete, MSTDMA must be cleared prior to beginning the next operation, typically a Start or Stop.This bit is read/write.
    }

    /// MSTTIME Register bits
    namespace msttime_bits {
        constexpr uint32_t MSTSCLLOW = (3 << 0);  ///< Master SCL Low time. Specifies the minimum low time that will be asserted by this master on SCL. Other devices on the bus (masters or slaves) could lengthen this time. This corresponds to the parameter t LOW in the I2C bus specification. I2C bus specification parameters tBUF and tSU;STA have the same values and are also controlled by MSTSCLLOW.
        constexpr uint32_t MSTSCLHIGH = (3 << 4);  ///< Master SCL High time. Specifies the minimum high time that will be asserted by this master on SCL. Other masters in a multi-master system could shorten this time. This corresponds to the parameter tHIGH in the I2C bus specification. I2C bus specification parameters tSU;STO and tHD;STA have the same values and are also controlled by MSTSCLHIGH.
    }

    /// MSTDAT Register bits
    namespace mstdat_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Master function data register. Read: read the most recently received data for the Master function. Write: transmit data using the Master function.
    }

    /// SLVCTL Register bits
    namespace slvctl_bits {
        constexpr uint32_t SLVCONTINUE = (1U << 0);  ///< Slave Continue.
        constexpr uint32_t SLVNACK = (1U << 1);  ///< Slave NACK.
        constexpr uint32_t SLVDMA = (1U << 3);  ///< Slave DMA enable.
        constexpr uint32_t AUTOACK = (1U << 8);  ///< Automatic Acknowledge.When this bit is set, it will cause an I2C header which matches SLVADR0 and the direction set by AUTOMATCHREAD to be ACKed immediately; this is used with DMA to allow processing of the data without intervention. If this bit is clear and a header matches SLVADR0, the behavior is controlled by AUTONACK in the SLVADR0 register: allowing NACK or interrupt.
        constexpr uint32_t AUTOMATCHREAD = (1U << 9);  ///< When AUTOACK is set, this bit controls whether it matches a read or write request on the next header with an address matching SLVADR0. Since DMA needs to be configured to match the transfer direction, the direction needs to be specified. This bit allows a direction to be chosen for the next operation.
    }

    /// SLVDAT Register bits
    namespace slvdat_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Slave function data register. Read: read the most recently received data for the Slave function. Write: transmit data using the Slave function.
    }

    /// SLVADR[%s] Register bits
    namespace slvadr[%s]_bits {
        constexpr uint32_t SADISABLE = (1U << 0);  ///< Slave Address n Disable.
        constexpr uint32_t SLVADR = (7 << 1);  ///< Slave Address. Seven bit slave address that is compared to received addresses if enabled.
        constexpr uint32_t AUTONACK = (1U << 15);  ///< Automatic NACK operation. Used in conjunction with AUTOACK and AUTOMATCHREAD, allows software to ignore I2C traffic while handling previous I2C data or other operations.
    }

    /// SLVQUAL0 Register bits
    namespace slvqual0_bits {
        constexpr uint32_t QUALMODE0 = (1U << 0);  ///< Qualify mode for slave address 0.
        constexpr uint32_t SLVQUAL0 = (7 << 1);  ///< Slave address Qualifier for address 0. A value of 0 causes the address in SLVADR0 to be used as-is, assuming that it is enabled. If QUALMODE0 = 0, any bit in this field which is set to 1 will cause an automatic match of the corresponding bit of the received address when it is compared to the SLVADR0 register. If QUALMODE0 = 1, an address range is matched for address 0. This range extends from the value defined by SLVADR0 to the address defined by SLVQUAL0 (address matches when SLVADR0[7:1] &amp;lt;= received address &amp;lt;= SLVQUAL0[7:1]).
    }

    /// MONRXDAT Register bits
    namespace monrxdat_bits {
        constexpr uint32_t MONRXDAT = (8 << 0);  ///< Monitor function Receiver Data. This reflects every data byte that passes on the I2C pins.
        constexpr uint32_t MONSTART = (1U << 8);  ///< Monitor Received Start.
        constexpr uint32_t MONRESTART = (1U << 9);  ///< Monitor Received Repeated Start.
        constexpr uint32_t MONNACK = (1U << 10);  ///< Monitor Received NACK.
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t APERTURE = (8 << 0);  ///< Aperture: encoded as (aperture size/4K) -1, so 0x00 means a 4K aperture.
        constexpr uint32_t MINOR_REV = (4 << 8);  ///< Minor revision of module implementation, starting at 0. Minor revision of module implementation, starting at 0. Software compatibility is expected between minor revisions.
        constexpr uint32_t MAJOR_REV = (4 << 12);  ///< Major revision of module implementation, starting at 0. There may not be software compatibility between major revisions.
        constexpr uint32_t ID = (16 << 16);  ///< Unique module identifier for this IP block.
    }

}

// ============================================================================
// FSP Peripheral
// ============================================================================

namespace fsp {
    /// Base addresses
    constexpr uint32_t FSP_BASE = 0x40088000;

    /// FSP Register structure
    struct Registers {
        volatile uint32_t SYS_CTRL;  ///< Offset: 0x00 - FSP system control register
        volatile uint32_t STATUS;  ///< Offset: 0x04 - FSP status register
        volatile uint32_t INT;  ///< Offset: 0x08 - FSP interrupt register
        volatile uint32_t INTEN;  ///< Offset: 0x0C - FSP interrupt enable register
        volatile uint32_t TE_CTRL;  ///< Offset: 0x20 - transmit engine control register
        volatile uint32_t TE_SRC_BASE;  ///< Offset: 0x24 - transfer engine source data memory base register
        volatile uint32_t TE_DST_BASE;  ///< Offset: 0x28 - transfer engine destination data memory base register
        volatile uint32_t MOU_CTRL;  ///< Offset: 0x40 - matrix operation unit control register
        volatile uint32_t MA_SRC_BASE;  ///< Offset: 0x44 - matrix A source data memory base register
        volatile uint32_t MB_SRC_BASE;  ///< Offset: 0x48 - matrix B source data memory base register
        volatile uint32_t MO_DST_BASE;  ///< Offset: 0x4C - matrix output data memory base register
        volatile uint32_t MOU_SCALEA;  ///< Offset: 0x50 - scale coefficient A register
        volatile uint32_t MOU_SCALEB;  ///< Offset: 0x54 - scale coefficient B register
        volatile uint32_t SE_CTRL;  ///< Offset: 0x60 - stastic engine control register
        volatile uint32_t SE_SRC_BASE;  ///< Offset: 0x64 - statistic engine source data base register
        volatile uint32_t SE_IDX;  ///< Offset: 0x68 - max or min data index register
        volatile uint32_t SE_SUM;  ///< Offset: 0x6C - array summary result register
        volatile uint32_t SE_PWR;  ///< Offset: 0x70 - array power result register
        volatile uint32_t COR_CTRL;  ///< Offset: 0x80 - correlation control register
        volatile uint32_t CX_SRC_BASE;  ///< Offset: 0x84 - correlation x sequence base register
        volatile uint32_t CY_SRC_BASE;  ///< Offset: 0x88 - correlation y sequence base register
        volatile uint32_t CO_DST_BASE;  ///< Offset: 0x8C - correlation output sequence base register
        volatile uint32_t COR_OFFSET;  ///< Offset: 0x90 - correlation offset register
        volatile uint32_t FIR_CFG_CH0;  ///< Offset: 0xA0 - FIR channel 0 configuration register
        volatile uint32_t FIR_CFG_CH1;  ///< Offset: 0xA4 - FIR channel 1 configuration register
        volatile uint32_t FIR_CFG_CH2;  ///< Offset: 0xA8 - FIR channel 2 configuration register
        volatile uint32_t FIR_CFG_CH3;  ///< Offset: 0xAC - FIR channel 3 configuration register
        volatile uint32_t FIR_CFG_CH4;  ///< Offset: 0xB0 - FIR channel 4 configuration register
        volatile uint32_t FIR_CFG_CH5;  ///< Offset: 0xB4 - FIR channel 5 configuration register
        volatile uint32_t FIR_CFG_CH6;  ///< Offset: 0xB8 - FIR channel 6 configuration register
        volatile uint32_t FIR_CFG_CH7;  ///< Offset: 0xBC - FIR channel 7 configuration register
        volatile uint32_t FIR_CFG_CH8;  ///< Offset: 0xC0 - FIR channel 8 configuration register
        volatile uint32_t FIR_DAT0_FX;  ///< Offset: 0xD0 - FIR channel 0 fix point data input &amp; output register
        volatile uint32_t FIR_DAT1_FX;  ///< Offset: 0xD4 - FIR channel 1 fix point data input &amp; output register
        volatile uint32_t FIR_DAT2_FX;  ///< Offset: 0xD8 - FIR channel 2 fix point data input &amp; output register
        volatile uint32_t FIR_DAT3_FX;  ///< Offset: 0xDC - FIR channel 3 fix point data input &amp; output register
        volatile uint32_t FIR_DAT4_FX;  ///< Offset: 0xE0 - FIR channel 4 fix point data input &amp; output register
        volatile uint32_t FIR_DAT5_FX;  ///< Offset: 0xE4 - FIR channel 5 fix point data input &amp; output register
        volatile uint32_t FIR_DAT6_FX;  ///< Offset: 0xE8 - FIR channel 6 fix point data input &amp; output register
        volatile uint32_t FIR_DAT7_FX;  ///< Offset: 0xEC - FIR channel 7 fix point data input &amp; output register
        volatile uint32_t FIR_DAT8_FX;  ///< Offset: 0xF0 - FIR channel 8 fix point data input &amp; output register
        volatile uint32_t FIR_DAT0_FL;  ///< Offset: 0x100 - FIR channel 0 float point data input &amp; output register
        volatile uint32_t FIR_DAT1_FL;  ///< Offset: 0x104 - FIR channel 1 float point data input &amp; output register
        volatile uint32_t FIR_DAT2_FL;  ///< Offset: 0x108 - FIR channel 2 float point data input &amp; output register
        volatile uint32_t FIR_DAT3_FL;  ///< Offset: 0x10C - FIR channel 3 float point data input &amp; output register
        volatile uint32_t FIR_DAT4_FL;  ///< Offset: 0x110 - FIR channel 4 float point data input &amp; output register
        volatile uint32_t FIR_DAT5_FL;  ///< Offset: 0x114 - FIR channel 5 float point data input &amp; output register
        volatile uint32_t FIR_DAT6_FL;  ///< Offset: 0x118 - FIR channel 6 float point data input &amp; output register
        volatile uint32_t FIR_DAT7_FL;  ///< Offset: 0x11C - FIR channel 7 float point data input &amp; output register
        volatile uint32_t FIR_DAT8_FL;  ///< Offset: 0x120 - FIR channel 8 float point data input &amp; output register
        volatile uint32_t SIN_COS_IXOX;  ///< Offset: 0x140 - sin &amp; cos input fix output fix mode data address register
        volatile uint32_t SIN_COS_IXOL;  ///< Offset: 0x144 - sin &amp; cos input fix output float mode data address register
        volatile uint32_t SIN_COS_ILOX;  ///< Offset: 0x148 - sin &amp; cos input float output fix mode data address register
        volatile uint32_t SIN_COS_ILOL;  ///< Offset: 0x14C - sin &amp; cos input float output float mode data address register
        volatile uint32_t LN_SQRT_IXOX;  ///< Offset: 0x150 - LN &amp; sqrt input fix output fix mode data address register
        volatile uint32_t LN_SQRT_IXOL;  ///< Offset: 0x154 - LN &amp; sqrt input fix output float mode data address register
        volatile uint32_t LN_SQRT_ILOX;  ///< Offset: 0x158 - LN &amp; sqrt input float output fix mode data address register
        volatile uint32_t LN_SQRT_ILOL;  ///< Offset: 0x15C - LN &amp; sqrt input float output float mode data address register
        volatile uint32_t CORDIC_T0UP_IXOX;  ///< Offset: 0x160 - native cordic input fix output fix, t=0, u=1 mode data...
        volatile uint32_t CORDIC_T0UP_IXOL;  ///< Offset: 0x164 - native cordic input fix output float, t=0, u=1 mode data...
        volatile uint32_t CORDIC_T0UP_ILOX;  ///< Offset: 0x168 - native cordic input float output fix, t=0, u=1 mode data...
        volatile uint32_t CORDIC_T0UP_ILOL;  ///< Offset: 0x16C - native cordic input float output float, t=0, u=1 mode...
        volatile uint32_t CORDIC_T0UN_IXOX;  ///< Offset: 0x170 - native cordic input fix output fix, t=0, u=-1 mode data...
        volatile uint32_t CORDIC_T0UN_IXOL;  ///< Offset: 0x174 - native cordic input fix output float, t=0, u=-1 mode...
        volatile uint32_t CORDIC_T0UN_ILOX;  ///< Offset: 0x178 - native cordic input float output fix, t=0, u=-1 mode...
        volatile uint32_t CORDIC_T0UN_ILOL;  ///< Offset: 0x17C - native cordic input float output float, t=0, u=-1 mode...
        volatile uint32_t CORDIC_T1UP_IXOX;  ///< Offset: 0x180 - native cordic input fix output fix, t=1, u=1 mode data...
        volatile uint32_t CORDIC_T1UP_IXOL;  ///< Offset: 0x184 - native cordic input fix output float, t=1, u=1 mode data...
        volatile uint32_t CORDIC_T1UP_ILOX;  ///< Offset: 0x188 - native cordic input float output fix, t=1, u=1 mode data...
        volatile uint32_t CORDIC_T1UP_ILOL;  ///< Offset: 0x18C - native cordic input float output float, t=1, u=1 mode...
        volatile uint32_t CORDIC_T1UN_IXOX;  ///< Offset: 0x190 - native cordic input fix output fix, t=1, u=-1 mode data...
        volatile uint32_t CORDIC_T1UN_IXOL;  ///< Offset: 0x194 - native cordic input fix output float, t=1, u=-1 mode...
        volatile uint32_t CORDIC_T1UN_ILOX;  ///< Offset: 0x198 - native cordic input float output fix, t=1, u=-1 mode...
        volatile uint32_t CORDIC_T1UN_ILOL;  ///< Offset: 0x19C - native cordic input float output float, t=1, u=-1 mode...
    };

    /// Peripheral instances
    inline Registers* FSP = reinterpret_cast<Registers*>(FSP_BASE);

    // Bit definitions
    /// SYS_CTRL Register bits
    namespace sys_ctrl_bits {
        constexpr uint32_t TE_ABORT = (1U << 0);  ///< Transform Engine abort write 1 to abort
        constexpr uint32_t MOU_ABORT = (1U << 1);  ///< Matrix Operation Unit abort write 1 to abort
        constexpr uint32_t SCF_ABORT = (1U << 2);  ///< SE COR FIR abort write 1 to abort
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t FPU0_BUSY = (1U << 0);  ///< SE COR FIR is in processing busy
        constexpr uint32_t FPU1_BUSY = (1U << 1);  ///< TE MOU is in processing busy
        constexpr uint32_t FIR_READY = (1U << 2);  ///< FIR output buffer is not empty which is valid for read
    }

    /// INT Register bits
    namespace int_bits {
        constexpr uint32_t TE_DONE_INT = (1U << 0);  ///< Transform engine done interrupt
        constexpr uint32_t MOU_DONE_INT = (1U << 1);  ///< Matrix operation unit done interrupt
        constexpr uint32_t SE_DONE_INT = (1U << 2);  ///< Statistic engine done interrupt
        constexpr uint32_t COR_DONE_INT = (1U << 3);  ///< Correlation done interrupt
        constexpr uint32_t FPU0_CALC_IN_ERR_INT = (1U << 8);  ///< SE COR FIR calculation input data error interrupt
        constexpr uint32_t FPU0_CALC_OUT_ERR_INT = (1U << 9);  ///< SE COR FIR calculation output data error interrupt
        constexpr uint32_t FPU0_DIN_OV_INT = (1U << 10);  ///< SE COR FIR input data overflow interrupt (always 0)
        constexpr uint32_t FPU0_DOUT_OV_INT = (1U << 11);  ///< SE COR FIR output data overflow interrupt
        constexpr uint32_t SINGULAR_INT = (1U << 12);  ///< MOU singular interrupt
        constexpr uint32_t FPU1_CALC_IN_ERR_INT = (1U << 16);  ///< MOU TE calculation input data error interrupt
        constexpr uint32_t FPU1_CALC_OUT_ERR_INT = (1U << 17);  ///< MOU TE calculation output data error interrupt
        constexpr uint32_t FPU1_DIN_OV_INT = (1U << 18);  ///< MOU TE input data overflow interrupt
        constexpr uint32_t FPU1_DOUT_OV_INT = (1U << 19);  ///< MOU TE output data overflow interrupt
        constexpr uint32_t FINV_DIN_ERR_INT = (1U << 20);  ///< FINV input data is inf or nan
        constexpr uint32_t FINV_DOUT_OV_INT = (1U << 21);  ///< FINV output data overflow
        constexpr uint32_t FINV_ZERO_INT = (1U << 22);  ///< FINV input data is zero
        constexpr uint32_t CORDIC_DIN_ERR = (1U << 24);  ///< CORDIC input data error interrupt
        constexpr uint32_t CORDIC_DOUT_ERR_INT = (1U << 25);  ///< CORDIC output data error interrupt
        constexpr uint32_t CORDIC_CALC_ERR_INT = (1U << 26);  ///< CORDIC calculation error interrupt
        constexpr uint32_t FSP_INT = (1U << 31);  ///< Or signal of all FSP function interrupt in this register
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t TE_DONE_INTEN = (1U << 0);  ///< Transform engine done interrupt enable
        constexpr uint32_t MOU_DONE_INTEN = (1U << 1);  ///< Matrix operation unit done interrupt enable
        constexpr uint32_t SE_DONE_INTEN = (1U << 2);  ///< Statistic engine done interrupt enable
        constexpr uint32_t COR_DONE_INTEN = (1U << 3);  ///< Correlation done interrupt enable
        constexpr uint32_t FPU0_CALC_IN_ERR_INTEN = (1U << 8);  ///< SE COR FIR calculation input data error interrupt enable
        constexpr uint32_t FPU0_CALC_OUT_ERR_INTEN = (1U << 9);  ///< SE COR FIR calculation output data error interrupt enable
        constexpr uint32_t FPU0_DIN_OV_INTEN = (1U << 10);  ///< SE COR FIR input data overflow interrupt enable
        constexpr uint32_t FPU0_DOUT_OV_INTEN = (1U << 11);  ///< SE COR FIR output data overflow interrupt enable
        constexpr uint32_t SINGULAR_INTEN = (1U << 12);  ///< MOU singular interrupt enable
        constexpr uint32_t FPU1_CALC_IN_ERR_INTEN = (1U << 16);  ///< MOU TE calculation input data error interrupt enable
        constexpr uint32_t FPU1_CALC_OUT_ERR_INTEN = (1U << 17);  ///< MOU TE calculation output data error interrupt enable
        constexpr uint32_t FPU1_DIN_OV_INTEN = (1U << 18);  ///< MOU TE input data overflow interrupt enable
        constexpr uint32_t FPU1_DOUT_OV_INTEN = (1U << 19);  ///< MOU TE output data overflow interrupt enable
        constexpr uint32_t FINV_DIN_ERR_INTEN = (1U << 20);  ///< FINV data input is inf or nan interrupt enable
        constexpr uint32_t FINV_DOUT_OV_INTEN = (1U << 21);  ///< FINV data output overflow interrupt enable
        constexpr uint32_t FINV_ZERO_INTEN = (1U << 22);  ///< FINV input is zero interrupt enable
        constexpr uint32_t CORDIC_DIN_ERR_INTEN = (1U << 24);  ///< CORDIC input data error interrupt enable
        constexpr uint32_t CORDIC_DOUT_ERR_INTEN = (1U << 25);  ///< CORDIC output data error interrupt enable
        constexpr uint32_t CORDIC_CALC_ERR_INTEN = (1U << 26);  ///< CORDIC calculation error interrupt enable
        constexpr uint32_t FSP_INTEN = (1U << 31);  ///< Or signal of all FSP function interrupt in this register enable
    }

    /// TE_CTRL Register bits
    namespace te_ctrl_bits {
        constexpr uint32_t TE_MODE = (2 << 0);  ///< TE compute mode
        constexpr uint32_t TE_IO_MODE = (2 << 2);  ///< TE input &amp; output mode select
        constexpr uint32_t TE_PTS = (2 << 4);  ///< TE compute point
        constexpr uint32_t TE_DIN_FP_SEL = (1U << 6);  ///< TE input data format select
        constexpr uint32_t TE_DOUT_FP_SEL = (1U << 7);  ///< TE output data format select
        constexpr uint32_t TE_SCALE = (8 << 8);  ///< TE scale
        constexpr uint32_t TE_PAUSE_LVL = (3 << 24);  ///< Transfer Engine stop level for debug use only.
    }

    /// TE_SRC_BASE Register bits
    namespace te_src_base_bits {
        constexpr uint32_t TE_SRC_BASE = (17 << 0);  ///< TE source data memory base address
    }

    /// TE_DST_BASE Register bits
    namespace te_dst_base_bits {
        constexpr uint32_t TE_DST_BASE = (17 << 0);  ///< TE destination data memory base address
    }

    /// MOU_CTRL Register bits
    namespace mou_ctrl_bits {
        constexpr uint32_t OP_MODE = (4 << 0);  ///< MOU operation mode
        constexpr uint32_t MOU_DIN_FP_SEL = (1U << 8);  ///< MOU data input format select
        constexpr uint32_t MOU_DOUT_FP_SEL = (1U << 9);  ///< MOU data output format select
        constexpr uint32_t MAT_M = (4 << 16);  ///< MOU Matrix column
        constexpr uint32_t MAT_N = (4 << 20);  ///< MOU Matrix row only valid when matrix's column is not equal to row
        constexpr uint32_t MAT_K = (4 << 24);  ///< MOU Matrix row only valid when matrix mult operation
        constexpr uint32_t DIV_EPSILON = (2 << 28);  ///< When the data exponent is small than DIV_EPSILON the inverse operation will output a error signal.
        constexpr uint32_t LU_STOP = (1U << 30);  ///< Stop at LU
        constexpr uint32_t UINV_STOP = (1U << 31);  ///< stop at U-Matrix inverse
    }

    /// MA_SRC_BASE Register bits
    namespace ma_src_base_bits {
        constexpr uint32_t MA_SRC_BASE = (17 << 0);  ///< Matrix A source data memory base address
    }

    /// MB_SRC_BASE Register bits
    namespace mb_src_base_bits {
        constexpr uint32_t MB_SRC_BASE = (17 << 0);  ///< Matrix B source data memory base address
    }

    /// MO_DST_BASE Register bits
    namespace mo_dst_base_bits {
        constexpr uint32_t MO_DST_BASE = (17 << 0);  ///< Matrix Operation Unit output data destination memory base address
    }

    /// MOU_SCALEA Register bits
    namespace mou_scalea_bits {
        constexpr uint32_t MOU_SCALEA = (32 << 0);  ///< MOU scale coefficient A
    }

    /// MOU_SCALEB Register bits
    namespace mou_scaleb_bits {
        constexpr uint32_t MOU_SCALEB = (32 << 0);  ///< MOU scale coefficient B
    }

    /// SE_CTRL Register bits
    namespace se_ctrl_bits {
        constexpr uint32_t MIN_SEL = (1U << 0);  ///< Minimum value selection
        constexpr uint32_t MAX_SEL = (1U << 1);  ///< Maximum value selection0 the first one1 the last one
        constexpr uint32_t MIN_IDX_EN = (1U << 2);  ///< Minimum value index calculation enable
        constexpr uint32_t MAX_IDX_EN = (1U << 3);  ///< Maximum value index calculation enable
        constexpr uint32_t SUM_EN = (1U << 4);  ///< Summary calculation enable
        constexpr uint32_t PWR_EN = (1U << 5);  ///< Power calculation enable
        constexpr uint32_t SE_DIN_FP_SEL = (1U << 6);  ///< SE data input format select
        constexpr uint32_t SE_DOUT_FP_SEL = (1U << 7);  ///< SE data output format select
        constexpr uint32_t SE_LEN = (8 << 16);  ///< Statistic engine length
    }

    /// SE_SRC_BASE Register bits
    namespace se_src_base_bits {
        constexpr uint32_t SE_SRC_BASE = (17 << 0);  ///< Statistic engine source data base address
    }

    /// SE_IDX Register bits
    namespace se_idx_bits {
        constexpr uint32_t SE_MIN_IDX = (8 << 0);  ///< Minimum data index of an array
        constexpr uint32_t SE_MAX_IDX = (8 << 16);  ///< Maximum data index of an array
    }

    /// SE_SUM Register bits
    namespace se_sum_bits {
        constexpr uint32_t SE_SUM = (32 << 0);  ///< Summary of an array
    }

    /// SE_PWR Register bits
    namespace se_pwr_bits {
        constexpr uint32_t SE_PWR = (32 << 0);  ///< Power value of an array
    }

    /// COR_CTRL Register bits
    namespace cor_ctrl_bits {
        constexpr uint32_t COR_DIN_FP_SEL = (1U << 8);  ///< COR input data format select
        constexpr uint32_t COR_DOUT_FP_SEL = (1U << 9);  ///< COR output data format select
        constexpr uint32_t COR_X_LEN = (8 << 16);  ///< The length of X sequence to be Correlator 0-255
        constexpr uint32_t COR_Y_LEN = (8 << 24);  ///< The length of Y sequence to be Correlator 0-255
    }

    /// CX_SRC_BASE Register bits
    namespace cx_src_base_bits {
        constexpr uint32_t COR_X_ADDR = (17 << 0);  ///< The base address of X sequence to be Correlator
    }

    /// CY_SRC_BASE Register bits
    namespace cy_src_base_bits {
        constexpr uint32_t COR_Y_ADDR = (17 << 0);  ///< The base address of Y sequence to be Correlator
    }

    /// CO_DST_BASE Register bits
    namespace co_dst_base_bits {
        constexpr uint32_t COR_DST_BASE = (17 << 0);  ///< correlation output data destination address base
    }

    /// COR_OFFSET Register bits
    namespace cor_offset_bits {
        constexpr uint32_t COR_X_OFFSET = (8 << 0);  ///< COR input X SEQ offset 0-255
        constexpr uint32_t COR_Y_OFFSET = (8 << 8);  ///< COR input Y SEQ offset 0-255
    }

    /// FIR_CFG_CH0 Register bits
    namespace fir_cfg_ch0_bits {
        constexpr uint32_t FIR_CH0_COEF_BASE = (16 << 0);  ///< FIR channel 0 coefficient base address
        constexpr uint32_t FIR_CH0_TAP_LEN = (4 << 16);  ///< FIR channel 0 tap length the register value equals to real tap length minus 1.
        constexpr uint32_t FIR_BUF_CLR_ALL = (1U << 30);  ///< clear all FIR buffer
        constexpr uint32_t FIR_CH0_BUF_CLR = (1U << 31);  ///< FIR channel 0 buffer clear
    }

    /// FIR_CFG_CH1 Register bits
    namespace fir_cfg_ch1_bits {
        constexpr uint32_t FIR_CH1_COEF_BASE = (16 << 0);  ///< FIR channel 1 coefficient base address
        constexpr uint32_t FIR_CH1_TAP_LEN = (4 << 16);  ///< FIR channel 1 tap length
        constexpr uint32_t FIR_CH1_BUF_CLR = (1U << 31);  ///< FIR channel 1 buffer clear
    }

    /// FIR_CFG_CH2 Register bits
    namespace fir_cfg_ch2_bits {
        constexpr uint32_t FIR_CH2_COEF_BASE = (16 << 0);  ///< FIR channel 2 coefficient base address
        constexpr uint32_t FIR_CH2_TAP_LEN = (4 << 16);  ///< FIR channel 2 tap length
        constexpr uint32_t FIR_CH2_BUF_CLR = (1U << 31);  ///< FIR channel 2 buffer clear
    }

    /// FIR_CFG_CH3 Register bits
    namespace fir_cfg_ch3_bits {
        constexpr uint32_t FIR_CH3_COEF_BASE = (16 << 0);  ///< FIR channel 3 coefficient base address
        constexpr uint32_t FIR_CH3_TAP_LEN = (4 << 16);  ///< FIR channel 3 tap length
        constexpr uint32_t FIR_CH3_BUF_CLR = (1U << 31);  ///< FIR channel 3 buffer clear
    }

    /// FIR_CFG_CH4 Register bits
    namespace fir_cfg_ch4_bits {
        constexpr uint32_t FIR_CH4_COEF_BASE = (16 << 0);  ///< FIR channel 4 coefficient base address
        constexpr uint32_t FIR_CH4_TAP_LEN = (4 << 16);  ///< FIR channel 4 tap length
        constexpr uint32_t FIR_CH4_BUF_CLR = (1U << 31);  ///< FIR channel 4 buffer clear
    }

    /// FIR_CFG_CH5 Register bits
    namespace fir_cfg_ch5_bits {
        constexpr uint32_t FIR_CH5_COEF_BASE = (16 << 0);  ///< FIR channel 5 coefficient base address
        constexpr uint32_t FIR_CH5_TAP_LEN = (4 << 16);  ///< FIR channel 5 tap length
        constexpr uint32_t FIR_CH5_BUF_CLR = (1U << 31);  ///< FIR channel 5 buffer clear
    }

    /// FIR_CFG_CH6 Register bits
    namespace fir_cfg_ch6_bits {
        constexpr uint32_t FIR_CH6_COEF_BASE = (16 << 0);  ///< FIR channel 6 coefficient base address
        constexpr uint32_t FIR_CH6_TAP_LEN = (4 << 16);  ///< FIR channel 6 tap length
        constexpr uint32_t FIR_CH6_BUF_CLR = (1U << 31);  ///< FIR channel 6 buffer clear
    }

    /// FIR_CFG_CH7 Register bits
    namespace fir_cfg_ch7_bits {
        constexpr uint32_t FIR_CH7_COEF_BASE = (16 << 0);  ///< FIR channel 7 coefficient base address
        constexpr uint32_t FIR_CH7_TAP_LEN = (4 << 16);  ///< FIR channel 7 tap length
        constexpr uint32_t FIR_CH7_BUF_CLR = (1U << 31);  ///< FIR channel 7 buffer clear
    }

    /// FIR_CFG_CH8 Register bits
    namespace fir_cfg_ch8_bits {
        constexpr uint32_t FIR_CH8_COEF_BASE = (16 << 0);  ///< FIR channel 8 coefficient base address
        constexpr uint32_t FIR_CH8_TAP_LEN = (4 << 16);  ///< FIR channel 8 tap length
        constexpr uint32_t FIR_CH8_BUF_CLR = (1U << 31);  ///< FIR channel 8 buffer clear
    }

    /// FIR_DAT0_FX Register bits
    namespace fir_dat0_fx_bits {
        constexpr uint32_t FIR_DAT0_FX = (32 << 0);  ///< FIR channel 0 fix data
    }

    /// FIR_DAT1_FX Register bits
    namespace fir_dat1_fx_bits {
        constexpr uint32_t FIR_DAT1_FX = (32 << 0);  ///< FIR channel1 fix data
    }

    /// FIR_DAT2_FX Register bits
    namespace fir_dat2_fx_bits {
        constexpr uint32_t FIR_DAT2_FX = (32 << 0);  ///< FIR channel2 fix data
    }

    /// FIR_DAT3_FX Register bits
    namespace fir_dat3_fx_bits {
        constexpr uint32_t FIR_DAT3_FX = (32 << 0);  ///< FIR channel3 fix data
    }

    /// FIR_DAT4_FX Register bits
    namespace fir_dat4_fx_bits {
        constexpr uint32_t FIR_DAT4_FX = (32 << 0);  ///< FIR channel4 fix data
    }

    /// FIR_DAT5_FX Register bits
    namespace fir_dat5_fx_bits {
        constexpr uint32_t FIR_DAT5_FX = (32 << 0);  ///< FIR channel5 fix data
    }

    /// FIR_DAT6_FX Register bits
    namespace fir_dat6_fx_bits {
        constexpr uint32_t FIR_DAT6_FX = (32 << 0);  ///< FIR channel6 fix data
    }

    /// FIR_DAT7_FX Register bits
    namespace fir_dat7_fx_bits {
        constexpr uint32_t FIR_DAT7_FX = (32 << 0);  ///< FIR channel7 fix data
    }

    /// FIR_DAT8_FX Register bits
    namespace fir_dat8_fx_bits {
        constexpr uint32_t FIR_DAT8_FX = (32 << 0);  ///< FIR channel8 fix data
    }

    /// FIR_DAT0_FL Register bits
    namespace fir_dat0_fl_bits {
        constexpr uint32_t FIR_DAT0_FL = (32 << 0);  ///< FIR channel 0 float data
    }

    /// FIR_DAT1_FL Register bits
    namespace fir_dat1_fl_bits {
        constexpr uint32_t FIR_DAT1_FL = (32 << 0);  ///< FIR channel1 float data
    }

    /// FIR_DAT2_FL Register bits
    namespace fir_dat2_fl_bits {
        constexpr uint32_t FIR_DAT2_FL = (32 << 0);  ///< FIR channel2 float data
    }

    /// FIR_DAT3_FL Register bits
    namespace fir_dat3_fl_bits {
        constexpr uint32_t FIR_DAT3_FL = (32 << 0);  ///< FIR channel3 float data
    }

    /// FIR_DAT4_FL Register bits
    namespace fir_dat4_fl_bits {
        constexpr uint32_t FIR_DAT4_FL = (32 << 0);  ///< FIR channel4 float data
    }

    /// FIR_DAT5_FL Register bits
    namespace fir_dat5_fl_bits {
        constexpr uint32_t FIR_DAT5_FL = (32 << 0);  ///< FIR channel5 float data
    }

    /// FIR_DAT6_FL Register bits
    namespace fir_dat6_fl_bits {
        constexpr uint32_t FIR_DAT6_FL = (32 << 0);  ///< FIR channel6 float data
    }

    /// FIR_DAT7_FL Register bits
    namespace fir_dat7_fl_bits {
        constexpr uint32_t FIR_DAT7_FL = (32 << 0);  ///< FIR channel7 float data
    }

    /// FIR_DAT8_FL Register bits
    namespace fir_dat8_fl_bits {
        constexpr uint32_t FIR_DAT8_FL = (32 << 0);  ///< FIR channel8 float data
    }

    /// SIN_COS_IXOX Register bits
    namespace sin_cos_ixox_bits {
        constexpr uint32_t SIN_COS_IXOX_SRC = (16 << 0);  ///< SIN_COS input data source address. Input fix output fix
        constexpr uint32_t SIN_COS_IXOX_DST = (16 << 16);  ///< SIN_COS output data destination address. Input fix output fix.
    }

    /// SIN_COS_IXOL Register bits
    namespace sin_cos_ixol_bits {
        constexpr uint32_t SIN_COS_IXOL_SRC = (16 << 0);  ///< SIN_COS input data source word address. Input fix output float
        constexpr uint32_t SIN_COS_IXOL_DST = (16 << 16);  ///< SIN_COS output data destination word address. Input fix output float.
    }

    /// SIN_COS_ILOX Register bits
    namespace sin_cos_ilox_bits {
        constexpr uint32_t SIN_COS_ILOX_SRC = (16 << 0);  ///< SIN_COS input data source word address. Input float output fix
        constexpr uint32_t SIN_COS_ILOX_DST = (16 << 16);  ///< SIN_COS output data destination word address. Input float output fix.
    }

    /// SIN_COS_ILOL Register bits
    namespace sin_cos_ilol_bits {
        constexpr uint32_t SIN_COS_ILOL_SRC = (16 << 0);  ///< SIN_COS input data source word address. Input float output float
        constexpr uint32_t SIN_COS_ILOL_DST = (16 << 16);  ///< SIN_COS output data destination word address. Input float output float
    }

    /// LN_SQRT_IXOX Register bits
    namespace ln_sqrt_ixox_bits {
        constexpr uint32_t LN_SQRT_IXOX_SRC = (16 << 0);  ///< LN_SQRT input data source word address. Input fix output fix
        constexpr uint32_t LN_SQRT_IXOX_DST = (16 << 16);  ///< LN_SQRT output data destination word address. Input fix output fix.
    }

    /// LN_SQRT_IXOL Register bits
    namespace ln_sqrt_ixol_bits {
        constexpr uint32_t LN_SQRT_IXOL_SRC = (16 << 0);  ///< LN_SQRT input data source word address. Input fix output float
        constexpr uint32_t LN_SQRT_IXOL_DST = (16 << 16);  ///< LN_SQRT output data destination word address. Input fix output float.
    }

    /// LN_SQRT_ILOX Register bits
    namespace ln_sqrt_ilox_bits {
        constexpr uint32_t LN_SQRT_ILOX_SRC = (16 << 0);  ///< LN_SQRT input data source word address. Input float output fix
        constexpr uint32_t LN_SQRT_ILOX_DST = (16 << 16);  ///< LN_SQRT output data destination word address. Input float output fix.
    }

    /// LN_SQRT_ILOL Register bits
    namespace ln_sqrt_ilol_bits {
        constexpr uint32_t LN_SQRT_ILOL_SRC = (16 << 0);  ///< LN_SQRT input data source word address. Input float output float
        constexpr uint32_t LN_SQRT_ILOL_DST = (16 << 16);  ///< LN_SQRT output data destination word address. Input float output float
    }

    /// CORDIC_T0UP_IXOX Register bits
    namespace cordic_t0up_ixox_bits {
        constexpr uint32_t CORDIC_T0UP_IXOX_SRC = (16 << 0);  ///< CORDIC_T0UP_IXOX input data source word address. Input fix output fix
        constexpr uint32_t CORDIC_T0UP_IXOX_DST = (16 << 16);  ///< CORDIC_T0UP_IXOX output data destination word address. X is saved at here Y is saved at word address CORDIC_T0UP_IXOX_DST+1. Input fix output fix
    }

    /// CORDIC_T0UP_IXOL Register bits
    namespace cordic_t0up_ixol_bits {
        constexpr uint32_t CORDIC_T0UP_IXOL_SRC = (16 << 0);  ///< CORDIC_T0UP_IXOL input data source word address. Input fix output float
        constexpr uint32_t CORDIC_T0UP_IXOL_DST = (16 << 16);  ///< CORDIC_T0UP_IXOL output data destination word address. X is saved at here Y is saved at word address CORDIC_T0UP_IXOL_DST+1. Input fix output float
    }

    /// CORDIC_T0UP_ILOX Register bits
    namespace cordic_t0up_ilox_bits {
        constexpr uint32_t CORDIC_T0UP_ILOX_SRC = (16 << 0);  ///< CORDIC_T0UP_ILOX input data source word address. Input float output fix
        constexpr uint32_t CORDIC_T0UP_ILOX_DST = (16 << 16);  ///< CORDIC_T0UP_ILOX output data destination word address. X is saved at here Y is saved at word address CORDIC_T0UP_ILOX_DST+1. Input float output fix
    }

    /// CORDIC_T0UP_ILOL Register bits
    namespace cordic_t0up_ilol_bits {
        constexpr uint32_t CORDIC_T0UP_ILOL_SRC = (16 << 0);  ///< CORDIC_T0UN_ILOL input data source word address. Input float output float
        constexpr uint32_t CORDIC_T0UP_ILOL_DST = (16 << 16);  ///< CORDIC_T0UN_ILOL output data destination word address. X is saved at here Y is saved at word address CORDIC_T0UN_ILOL_DST+1. Input float output float
    }

    /// CORDIC_T0UN_IXOX Register bits
    namespace cordic_t0un_ixox_bits {
        constexpr uint32_t CORDIC_T0UN_IXOX_SRC = (16 << 0);  ///< CORDIC_T0UN_IXOX input data source word address. Input fix output fix
        constexpr uint32_t CORDIC_T0UN_IXOX_DST = (16 << 16);  ///< CORDIC_T0UN_IXOX output data destination word address. X is saved at here Y is saved at word address CORDIC_T0UN_IXOX_DST+1. Input fix output fix
    }

    /// CORDIC_T0UN_IXOL Register bits
    namespace cordic_t0un_ixol_bits {
        constexpr uint32_t CORDIC_T0UN_IXOL_SRC = (16 << 0);  ///< CORDIC_T0UN_IXOL input data source word address. Input fix output float
        constexpr uint32_t CORDIC_T0UN_IXOL_DST = (16 << 16);  ///< CORDIC_T0UN_IXOL output data destination word address. X is saved at here Y is saved at word address CORDIC_T0UN_IXOL_DST+1. Input fix output float
    }

    /// CORDIC_T0UN_ILOX Register bits
    namespace cordic_t0un_ilox_bits {
        constexpr uint32_t CORDIC_T0UN_ILOX_SRC = (16 << 0);  ///< CORDIC_T0UN_ILOX input data source word address. Input float output fix
        constexpr uint32_t CORDIC_T0UN_ILOX_DST = (16 << 16);  ///< CORDIC_T0UN_ILOX output data destination word address. X is saved at here Y is saved at word address CORDIC_T0UN_ILOX_DST+1. Input float output fix
    }

    /// CORDIC_T0UN_ILOL Register bits
    namespace cordic_t0un_ilol_bits {
        constexpr uint32_t CORDIC_T0UN_ILOL_SRC = (16 << 0);  ///< CORDIC_T0UN_ILOL input data source word address. Input float output float
        constexpr uint32_t CORDIC_T0UN_ILOL_DST = (16 << 16);  ///< CORDIC_T0UN_ILOL output data destination word address. X is saved at here Y is saved at word address CORDIC_T0UN_ILOL_DST+1. Input float output float
    }

    /// CORDIC_T1UP_IXOX Register bits
    namespace cordic_t1up_ixox_bits {
        constexpr uint32_t CORDIC_T1UP_IXOX_SRC = (16 << 0);  ///< CORDIC_T1UP_IXOX input data source word address. Input fix output fix
        constexpr uint32_t CORDIC_T1UP_IXOX_DST = (16 << 16);  ///< CORDIC_T1UP_IXOX output data destination word address. X is saved at here Z is saved at word address CORDIC_T1UP_IXOX_DST+1. Input fix output fix
    }

    /// CORDIC_T1UP_IXOL Register bits
    namespace cordic_t1up_ixol_bits {
        constexpr uint32_t CORDIC_T1UP_IXOL_SRC = (16 << 0);  ///< CORDIC_T1UP_IXOL input data source word address. Input fix output float
        constexpr uint32_t CORDIC_T1UP_IXOL_DST = (16 << 16);  ///< CORDIC_T1UP_IXOL output data destination word address. X is saved at here Z is saved at word address CORDIC_T1UP_IXOL_DST+1. Input fix output float
    }

    /// CORDIC_T1UP_ILOX Register bits
    namespace cordic_t1up_ilox_bits {
        constexpr uint32_t CORDIC_T1UP_ILOX_SRC = (16 << 0);  ///< CORDIC_T1UP_ILOX input data source word address. Input float output fix
        constexpr uint32_t CORDIC_T1UP_ILOX_DST = (16 << 16);  ///< CORDIC_T1UP_ILOX output data destination word address. X is saved at here Z is saved at word address CORDIC_T1UP_ILOX_DST+1. Input float output fix
    }

    /// CORDIC_T1UP_ILOL Register bits
    namespace cordic_t1up_ilol_bits {
        constexpr uint32_t CORDIC_T1UP_ILOL_SRC = (16 << 0);  ///< CORDIC_T1UP_ILOL input data source word address. Input float output float
        constexpr uint32_t CORDIC_T1UP_ILOL_DST = (16 << 16);  ///< CORDIC_T1UP_ILOL output data destination word address. X is saved at here Z is saved at word address CORDIC_T1UP_ILOL_DST+1. Input float output float
    }

    /// CORDIC_T1UN_IXOX Register bits
    namespace cordic_t1un_ixox_bits {
        constexpr uint32_t CORDIC_T1UN_IXOX_SRC = (16 << 0);  ///< CORDIC_T1UN_IXOX input data source word address. Input fix output fix
        constexpr uint32_t CORDIC_T1UN_IXOX_DST = (16 << 16);  ///< CORDIC_T1UN_IXOX output data destination word address. X is saved at here Z is saved at word address CORDIC_T1UN_IXOX_DST+1. Input fix output fix
    }

    /// CORDIC_T1UN_IXOL Register bits
    namespace cordic_t1un_ixol_bits {
        constexpr uint32_t CORDIC_T1UN_IXOL_SRC = (16 << 0);  ///< CORDIC_T1UN_IXOL input data source word address. Input fix output float
        constexpr uint32_t CORDIC_T1UN_IXOL_DST = (16 << 16);  ///< CORDIC_T1UN_IXOL output data destination word address. X is saved at here Z is saved at word address CORDIC_T1UN_IXOL_DST+1. Input fix output float
    }

    /// CORDIC_T1UN_ILOX Register bits
    namespace cordic_t1un_ilox_bits {
        constexpr uint32_t CORDIC_T1UN_ILOX_SRC = (16 << 0);  ///< CORDIC_T1UN_ILOX input data source word address. Input float output fix
        constexpr uint32_t CORDIC_T1UN_ILOX_DST = (16 << 16);  ///< CORDIC_T1UN_ILOX output data destination word address. X is saved at here Z is saved at word address CORDIC_T1UN_ILOX_DST+1. Input float output fix
    }

    /// CORDIC_T1UN_ILOL Register bits
    namespace cordic_t1un_ilol_bits {
        constexpr uint32_t CORDIC_T1UN_ILOL_SRC = (16 << 0);  ///< CORDIC_T1UN_ILOL input data source word address. Input float output float
        constexpr uint32_t CORDIC_T1UN_ILOL_DST = (16 << 16);  ///< CORDIC_T1UN_ILOL output data destination word address. X is saved at here Z is saved at word address CORDIC_T1UN_ILOL_DST+1. Input float output float
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x4008C000;
    constexpr uint32_t GPIOB_BASE = 0x4008D000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x00 - GPIO value register
        volatile uint32_t DATAOUT;  ///< Offset: 0x04 - GPIO output status register
        volatile uint32_t OUTENSET;  ///< Offset: 0x10 - GPIO output enable set register
        volatile uint32_t OUTENCLR;  ///< Offset: 0x14 - GPIO output clear register
        volatile uint32_t INTENSET;  ///< Offset: 0x20 - GPIO interrupt enable set register
        volatile uint32_t INTENCLR;  ///< Offset: 0x24 - GPIO interrupt enable clear register
        volatile uint32_t INTTYPESET;  ///< Offset: 0x28 - GPIO interrupt type set register
        volatile uint32_t INTTYPECLR;  ///< Offset: 0x2C - GPIO interrupt type set register
        volatile uint32_t INTPOLSET;  ///< Offset: 0x30 - GPIO interrupt polarity set register
        volatile uint32_t INTPOLCLR;  ///< Offset: 0x34 - GPIO interrupt polarity clear register
        volatile uint32_t INTSTATUS;  ///< Offset: 0x38 - GPIO interrupt status register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);

    // Bit definitions
    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< data value
    }

    /// DATAOUT Register bits
    namespace dataout_bits {
        constexpr uint32_t DATAOUT = (32 << 0);  ///< Data output register value
    }

    /// OUTENSET Register bits
    namespace outenset_bits {
        constexpr uint32_t OUTENSET = (32 << 0);  ///< output enable clear
    }

    /// OUTENCLR Register bits
    namespace outenclr_bits {
        constexpr uint32_t OUTENCLR = (32 << 0);  ///< output enable clear
    }

    /// INTENSET Register bits
    namespace intenset_bits {
        constexpr uint32_t INTENSET = (32 << 0);  ///< interrupt enable set
    }

    /// INTENCLR Register bits
    namespace intenclr_bits {
        constexpr uint32_t INTENCLR = (32 << 0);  ///< interrupt enable clear
    }

    /// INTTYPESET Register bits
    namespace inttypeset_bits {
        constexpr uint32_t INTTYPESET = (32 << 0);  ///< interrupt type set
    }

    /// INTTYPECLR Register bits
    namespace inttypeclr_bits {
        constexpr uint32_t INTTYPECLR = (32 << 0);  ///< interrupt type clear
    }

    /// INTPOLSET Register bits
    namespace intpolset_bits {
        constexpr uint32_t INTPOLSET = (32 << 0);  ///< interrupt polarity set
    }

    /// INTPOLCLR Register bits
    namespace intpolclr_bits {
        constexpr uint32_t INTPOLCLR = (32 << 0);  ///< interrupt polarity clear
    }

    /// INTSTATUS Register bits
    namespace intstatus_bits {
        constexpr uint32_t INTSTATUS = (32 << 0);  ///< interrupt status
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_ENGINE_BASE = 0x4008E000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t MODE;  ///< Offset: 0x00 - CRC mode register
        volatile uint32_t SEED;  ///< Offset: 0x04 - CRC seed register
        volatile uint32_t SUM;  ///< Offset: 0x08 - CRC checksum register
        volatile uint32_t WR_DATA;  ///< Offset: 0x08 - CRC data register
    };

    /// Peripheral instances
    inline Registers* CRC_ENGINE = reinterpret_cast<Registers*>(CRC_ENGINE_BASE);

    // Bit definitions
    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t CRC_POLY = (2 << 0);  ///< CRC polynomial: 1X = CRC-32 polynomial 01 = CRC-16 polynomial 00 = CRC-CCITT polynomial
        constexpr uint32_t BIT_RVS_WR = (1U << 2);  ///< Data bit order: 1 = Bit order reverse for CRC_WR_DATA (per byte) 0 = No bit order reverse for CRC_WR_DATA (per byte)
        constexpr uint32_t CMPL_WR = (1U << 3);  ///< Data complement: 1 = 1'-s complement for CRC_WR_DATA 0 = No 1'-s complement for CRC_WR_DATA
        constexpr uint32_t BIT_RVS_SUM = (1U << 4);  ///< CRC sum bit order: 1 = Bit order reverse for CRC_SUM 0 = No bit order reverse for CRC_SUM
        constexpr uint32_t CMPL_SUM = (1U << 5);  ///< CRC sum complement: 1 = 1'-s complement for CRC_SUM 0 = No 1'-s complement for CRC_SUM
    }

    /// SEED Register bits
    namespace seed_bits {
        constexpr uint32_t CRC_SEED = (32 << 0);  ///< A write access to this register will load CRC seed value to CRC_SUM register with selected bit order and 1'-s complement pre-processes. A write access to this register will overrule the CRC calculation in progresses.
    }

    /// SUM Register bits
    namespace sum_bits {
        constexpr uint32_t CRC_SUM = (32 << 0);  ///< The most recent CRC sum can be read through this register with selected bit order and 1'-s complement post-processes.
    }

    /// WR_DATA Register bits
    namespace wr_data_bits {
        constexpr uint32_t CRC_WR_DATA = (32 << 0);  ///< Data written to this register will be taken to perform CRC calculation with selected bit order and 1'-s complement pre-process. Any write size 8, 16 or 32-bit are allowed and accept back-to-back transactions.
    }

}


} // namespace alloy::generated::qn908xc

#endif // ALLOY_GENERATED_QN908XC_PERIPHERALS_HPP