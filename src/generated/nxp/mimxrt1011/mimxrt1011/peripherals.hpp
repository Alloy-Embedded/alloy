/// Auto-generated code for MIMXRT1011
/// Generated by Alloy Code Generator
/// Source: nxp_mimxrt1011.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:28
#ifndef ALLOY_GENERATED_MIMXRT1011_PERIPHERALS_HPP
#define ALLOY_GENERATED_MIMXRT1011_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mimxrt1011 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_aipstz1 = true;
    constexpr uint32_t num_aipstz1_instances = 1;
    constexpr bool has_aipstz2 = true;
    constexpr uint32_t num_aipstz2_instances = 1;
    constexpr bool has_dcdc = true;
    constexpr uint32_t num_dcdc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_aoi = true;
    constexpr uint32_t num_aoi_instances = 1;
    constexpr bool has_xbara = true;
    constexpr uint32_t num_xbara_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_otfad = true;
    constexpr uint32_t num_otfad_instances = 1;
    constexpr bool has_iomuxc = true;
    constexpr uint32_t num_iomuxc_instances = 4;
    constexpr bool has_flexram = true;
    constexpr uint32_t num_flexram_instances = 1;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_wdog1 = true;
    constexpr uint32_t num_wdog1_instances = 1;
    constexpr bool has_wdog2 = true;
    constexpr uint32_t num_wdog2_instances = 1;
    constexpr bool has_rtwdog = true;
    constexpr uint32_t num_rtwdog_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_snvs = true;
    constexpr uint32_t num_snvs_instances = 1;
    constexpr bool has_ccm = true;
    constexpr uint32_t num_ccm_instances = 2;
    constexpr bool has_pmu = true;
    constexpr uint32_t num_pmu_instances = 1;
    constexpr bool has_tempmon = true;
    constexpr uint32_t num_tempmon_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 4;
    constexpr bool has_xtalosc24m = true;
    constexpr uint32_t num_xtalosc24m_instances = 1;
    constexpr bool has_csu = true;
    constexpr uint32_t num_csu_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_dcp = true;
    constexpr uint32_t num_dcp_instances = 1;
    constexpr bool has_gpc = true;
    constexpr uint32_t num_gpc_instances = 1;
    constexpr bool has_pgc = true;
    constexpr uint32_t num_pgc_instances = 1;
    constexpr bool has_src = true;
    constexpr uint32_t num_src_instances = 1;
    constexpr bool has_romc = true;
    constexpr uint32_t num_romc_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 4;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_flexio1 = true;
    constexpr uint32_t num_flexio1_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 3;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 1;
    constexpr bool has_spdif = true;
    constexpr uint32_t num_spdif_instances = 1;
    constexpr bool has_sai1 = true;
    constexpr uint32_t num_sai1_instances = 1;
    constexpr bool has_sai3 = true;
    constexpr uint32_t num_sai3_instances = 1;
    constexpr bool has_gpt1 = true;
    constexpr uint32_t num_gpt1_instances = 1;
    constexpr bool has_gpt2 = true;
    constexpr uint32_t num_gpt2_instances = 1;
    constexpr bool has_ocotp = true;
    constexpr uint32_t num_ocotp_instances = 1;
    constexpr bool has_kpp = true;
    constexpr uint32_t num_kpp_instances = 1;
    constexpr bool has_systemcontrol = true;
    constexpr uint32_t num_systemcontrol_instances = 1;
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct aipstz1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aipstz2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcdc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct aoi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct xbara_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct otfad_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct iomuxc_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct flexram_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdog1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdog2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtwdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct snvs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccm_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pmu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tempmon_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct xtalosc24m_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct csu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct dcp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pgc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct src_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct romc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct flexio1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spdif_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ocotp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct kpp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systemcontrol_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 3;
    constexpr uint32_t max_gpio_pins = 48;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart1 = true;
    constexpr bool has_lpuart2 = true;
    constexpr bool has_lpuart3 = true;
    constexpr bool has_lpuart4 = true;
}

// ============================================================================
// AIPSTZ1 Peripheral
// ============================================================================

namespace aipstz1 {
    /// Base addresses
    constexpr uint32_t AIPSTZ1_BASE = 0x4007C000;

    /// AIPSTZ1 Register structure
    struct Registers {
        volatile uint32_t MPR;  ///< Offset: 0x00 - Master Priviledge Registers
        volatile uint32_t OPACR;  ///< Offset: 0x40 - Off-Platform Peripheral Access Control Registers
        volatile uint32_t OPACR1;  ///< Offset: 0x44 - Off-Platform Peripheral Access Control Registers
        volatile uint32_t OPACR2;  ///< Offset: 0x48 - Off-Platform Peripheral Access Control Registers
        volatile uint32_t OPACR3;  ///< Offset: 0x4C - Off-Platform Peripheral Access Control Registers
        volatile uint32_t OPACR4;  ///< Offset: 0x50 - Off-Platform Peripheral Access Control Registers
    };

    /// Peripheral instances
    inline Registers* AIPSTZ1 = reinterpret_cast<Registers*>(AIPSTZ1_BASE);

    // Bit definitions
    /// MPR Register bits
    namespace mpr_bits {
        constexpr uint32_t MPROT5 = (4 << 8);  ///< Master 5 Priviledge, Buffer, Read, Write Control.
        constexpr uint32_t MPROT3 = (4 << 16);  ///< Master 3 Priviledge, Buffer, Read, Write Control.
        constexpr uint32_t MPROT2 = (4 << 20);  ///< Master 2 Priviledge, Buffer, Read, Write Control
        constexpr uint32_t MPROT1 = (4 << 24);  ///< Master 1 Priviledge, Buffer, Read, Write Control
        constexpr uint32_t MPROT0 = (4 << 28);  ///< Master 0 Priviledge, Buffer, Read, Write Control
    }

    /// OPACR Register bits
    namespace opacr_bits {
        constexpr uint32_t OPAC7 = (4 << 0);  ///< Off-platform Peripheral Access Control 7
        constexpr uint32_t OPAC6 = (4 << 4);  ///< Off-platform Peripheral Access Control 6
        constexpr uint32_t OPAC5 = (4 << 8);  ///< Off-platform Peripheral Access Control 5
        constexpr uint32_t OPAC4 = (4 << 12);  ///< Off-platform Peripheral Access Control 4
        constexpr uint32_t OPAC3 = (4 << 16);  ///< Off-platform Peripheral Access Control 3
        constexpr uint32_t OPAC2 = (4 << 20);  ///< Off-platform Peripheral Access Control 2
        constexpr uint32_t OPAC1 = (4 << 24);  ///< Off-platform Peripheral Access Control 1
        constexpr uint32_t OPAC0 = (4 << 28);  ///< Off-platform Peripheral Access Control 0
    }

    /// OPACR1 Register bits
    namespace opacr1_bits {
        constexpr uint32_t OPAC15 = (4 << 0);  ///< Off-platform Peripheral Access Control 15
        constexpr uint32_t OPAC14 = (4 << 4);  ///< Off-platform Peripheral Access Control 14
        constexpr uint32_t OPAC13 = (4 << 8);  ///< Off-platform Peripheral Access Control 13
        constexpr uint32_t OPAC12 = (4 << 12);  ///< Off-platform Peripheral Access Control 12
        constexpr uint32_t OPAC11 = (4 << 16);  ///< Off-platform Peripheral Access Control 11
        constexpr uint32_t OPAC10 = (4 << 20);  ///< Off-platform Peripheral Access Control 10
        constexpr uint32_t OPAC9 = (4 << 24);  ///< Off-platform Peripheral Access Control 9
        constexpr uint32_t OPAC8 = (4 << 28);  ///< Off-platform Peripheral Access Control 8
    }

    /// OPACR2 Register bits
    namespace opacr2_bits {
        constexpr uint32_t OPAC23 = (4 << 0);  ///< Off-platform Peripheral Access Control 23
        constexpr uint32_t OPAC22 = (4 << 4);  ///< Off-platform Peripheral Access Control 22
        constexpr uint32_t OPAC21 = (4 << 8);  ///< Off-platform Peripheral Access Control 21
        constexpr uint32_t OPAC20 = (4 << 12);  ///< Off-platform Peripheral Access Control 20
        constexpr uint32_t OPAC19 = (4 << 16);  ///< Off-platform Peripheral Access Control 19
        constexpr uint32_t OPAC18 = (4 << 20);  ///< Off-platform Peripheral Access Control 18
        constexpr uint32_t OPAC17 = (4 << 24);  ///< Off-platform Peripheral Access Control 17
        constexpr uint32_t OPAC16 = (4 << 28);  ///< Off-platform Peripheral Access Control 16
    }

    /// OPACR3 Register bits
    namespace opacr3_bits {
        constexpr uint32_t OPAC31 = (4 << 0);  ///< Off-platform Peripheral Access Control 31
        constexpr uint32_t OPAC30 = (4 << 4);  ///< Off-platform Peripheral Access Control 30
        constexpr uint32_t OPAC29 = (4 << 8);  ///< Off-platform Peripheral Access Control 29
        constexpr uint32_t OPAC28 = (4 << 12);  ///< Off-platform Peripheral Access Control 28
        constexpr uint32_t OPAC27 = (4 << 16);  ///< Off-platform Peripheral Access Control 27
        constexpr uint32_t OPAC26 = (4 << 20);  ///< Off-platform Peripheral Access Control 26
        constexpr uint32_t OPAC25 = (4 << 24);  ///< Off-platform Peripheral Access Control 25
        constexpr uint32_t OPAC24 = (4 << 28);  ///< Off-platform Peripheral Access Control 24
    }

    /// OPACR4 Register bits
    namespace opacr4_bits {
        constexpr uint32_t OPAC33 = (4 << 24);  ///< Off-platform Peripheral Access Control 33
        constexpr uint32_t OPAC32 = (4 << 28);  ///< Off-platform Peripheral Access Control 32
    }

}

// ============================================================================
// AIPSTZ2 Peripheral
// ============================================================================

namespace aipstz2 {
    /// Base addresses
    constexpr uint32_t AIPSTZ2_BASE = 0x4017C000;

    /// AIPSTZ2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AIPSTZ2 = reinterpret_cast<Registers*>(AIPSTZ2_BASE);

}

// ============================================================================
// DCDC Peripheral
// ============================================================================

namespace dcdc {
    /// Base addresses
    constexpr uint32_t DCDC_BASE = 0x40080000;

    /// DCDC Register structure
    struct Registers {
        volatile uint32_t REG0;  ///< Offset: 0x00 - DCDC Register 0
        volatile uint32_t REG1;  ///< Offset: 0x04 - DCDC Register 1
        volatile uint32_t REG2;  ///< Offset: 0x08 - DCDC Register 2
        volatile uint32_t REG3;  ///< Offset: 0x0C - DCDC Register 3
    };

    /// Peripheral instances
    inline Registers* DCDC = reinterpret_cast<Registers*>(DCDC_BASE);

    // Bit definitions
    /// REG0 Register bits
    namespace reg0_bits {
        constexpr uint32_t PWD_ZCD = (1U << 0);  ///< power down the zero cross detection function for discontinuous conductor mode
        constexpr uint32_t DISABLE_AUTO_CLK_SWITCH = (1U << 1);  ///< Disable automatic clock switch from internal osc to xtal clock.
        constexpr uint32_t SEL_CLK = (1U << 2);  ///< select 24 MHz Crystal clock for DCDC, when dcdc_disable_auto_clk_switch is set.
        constexpr uint32_t PWD_OSC_INT = (1U << 3);  ///< Power down internal osc. Only set this bit, when 24 MHz crystal osc is available
        constexpr uint32_t PWD_CUR_SNS_CMP = (1U << 4);  ///< The power down signal of the current detector.
        constexpr uint32_t CUR_SNS_THRSH = (3 << 5);  ///< Set the threshold of current detector, if the peak current of the inductor exceeds the threshold, the current detector will assert
        constexpr uint32_t PWD_OVERCUR_DET = (1U << 8);  ///< power down overcurrent detection comparator
        constexpr uint32_t OVERCUR_TRIG_ADJ = (2 << 9);  ///< The threshold of over current detection in run mode and power save mode: run mode power save mode 0x0 1 A 0
        constexpr uint32_t PWD_CMP_BATT_DET = (1U << 11);  ///< set to "1" to power down the low voltage detection comparator
        constexpr uint32_t ADJ_POSLIMIT_BUCK = (4 << 12);  ///< adjust value to poslimit_buck register
        constexpr uint32_t EN_LP_OVERLOAD_SNS = (1U << 16);  ///< enable the overload detection in power save mode, if current is larger than the overloading threshold (typical value is 50 mA), DCDC will switch to the run mode automatically
        constexpr uint32_t PWD_HIGH_VOLT_DET = (1U << 17);  ///< power down overvoltage detection comparator
        constexpr uint32_t LP_OVERLOAD_THRSH = (2 << 18);  ///< the threshold of the counting number of charging times during the period that lp_overload_freq_sel sets in power save mode
        constexpr uint32_t LP_OVERLOAD_FREQ_SEL = (1U << 20);  ///< the period of counting the charging times in power save mode 0: eight 32k cycle 1: sixteen 32k cycle
        constexpr uint32_t LP_HIGH_HYS = (1U << 21);  ///< Adjust hysteretic value in low power from 12.5mV to 25mV
        constexpr uint32_t PWD_CMP_OFFSET = (1U << 26);  ///< power down output range comparator
        constexpr uint32_t XTALOK_DISABLE = (1U << 27);  ///< 1'b1: Disable xtalok detection circuit 1'b0: Enable xtalok detection circuit
        constexpr uint32_t CURRENT_ALERT_RESET = (1U << 28);  ///< reset current alert signal
        constexpr uint32_t XTAL_24M_OK = (1U << 29);  ///< set to 1 to switch internal ring osc to xtal 24M
        constexpr uint32_t STS_DC_OK = (1U << 31);  ///< Status register to indicate DCDC status. 1'b1: DCDC already settled 1'b0: DCDC is settling
    }

    /// REG1 Register bits
    namespace reg1_bits {
        constexpr uint32_t REG_FBK_SEL = (2 << 7);  ///< select the feedback point of the internal regulator
        constexpr uint32_t REG_RLOAD_SW = (1U << 9);  ///< control the load resistor of the internal regulator of DCDC, the load resistor is connected as default "1", and need set to "0" to disconnect the load resistor
        constexpr uint32_t LP_CMP_ISRC_SEL = (2 << 12);  ///< set the current bias of low power comparator 0x0: 50 nA 0x1: 100 nA 0x2: 200 nA 0x3: 400 nA
        constexpr uint32_t LOOPCTRL_HST_THRESH = (1U << 21);  ///< increase the threshold detection for common mode analog comparator
        constexpr uint32_t LOOPCTRL_EN_HYST = (1U << 23);  ///< Enable hysteresis in switching converter common mode analog comparators
        constexpr uint32_t VBG_TRIM = (5 << 24);  ///< trim bandgap voltage
    }

    /// REG2 Register bits
    namespace reg2_bits {
        constexpr uint32_t LOOPCTRL_DC_C = (2 << 0);  ///< Ratio of integral control parameter to proportional control parameter in the switching DC-DC converter, and can be used to optimize efficiency and loop response
        constexpr uint32_t LOOPCTRL_DC_R = (4 << 2);  ///< Magnitude of proportional control parameter in the switching DC-DC converter control loop.
        constexpr uint32_t LOOPCTRL_DC_FF = (3 << 6);  ///< Two's complement feed forward step in duty cycle in the switching DC-DC converter
        constexpr uint32_t LOOPCTRL_EN_RCSCALE = (3 << 9);  ///< Enable analog circuit of DC-DC converter to respond faster under transient load conditions.
        constexpr uint32_t LOOPCTRL_RCSCALE_THRSH = (1U << 12);  ///< Increase the threshold detection for RC scale circuit.
        constexpr uint32_t LOOPCTRL_HYST_SIGN = (1U << 13);  ///< Invert the sign of the hysteresis in DC-DC analog comparators.
        constexpr uint32_t BATTMONITOR_EN_BATADJ = (1U << 15);  ///< This bit enables the DC-DC to improve efficiency and minimize ripple using the information from the BATT_VAL field
        constexpr uint32_t DISABLE_PULSE_SKIP = (1U << 27);  ///< Set to "0" : stop charging if the duty cycle is lower than what set by dcdc_neglimit_in
        constexpr uint32_t DCM_SET_CTRL = (1U << 28);  ///< Set high to improve the transition from heavy load to light load
    }

    /// REG3 Register bits
    namespace reg3_bits {
        constexpr uint32_t TRG = (5 << 0);  ///< Target value of VDD_SOC, 25 mV each step 0x0: 0.8V 0xE: 1.15V 0x1F:1.575V
        constexpr uint32_t TARGET_LP = (3 << 8);  ///< Target value of standby (low power) mode 0x0: 0
        constexpr uint32_t MINPWR_DC_HALFCLK = (1U << 24);  ///< Set DCDC clock to half freqeuncy for continuous mode
        constexpr uint32_t MISC_DELAY_TIMING = (1U << 27);  ///< Ajust delay to reduce ground noise
        constexpr uint32_t MISC_DISABLEFET_LOGIC = (1U << 28);  ///< Reserved
        constexpr uint32_t DISABLE_STEP = (1U << 30);  ///< Disable stepping for the output VDD_SOC of DCDC
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT_BASE = 0x40084000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LTMR64H;  ///< Offset: 0xE0 - PIT Upper Lifetime Timer Register
        volatile uint32_t LTMR64L;  ///< Offset: 0xE4 - PIT Lower Lifetime Timer Register
        volatile uint32_t LDVAL;  ///< Offset: 0x00 - Timer Load Value Register
        volatile uint32_t CVAL;  ///< Offset: 0x04 - Current Timer Value Register
        volatile uint32_t TCTRL;  ///< Offset: 0x08 - Timer Control Register
        volatile uint32_t TFLG;  ///< Offset: 0x0C - Timer Flag Register
    };

    /// Peripheral instances
    inline Registers* PIT = reinterpret_cast<Registers*>(PIT_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable for PIT
    }

    /// LTMR64H Register bits
    namespace ltmr64h_bits {
        constexpr uint32_t LTH = (32 << 0);  ///< Life Timer value
    }

    /// LTMR64L Register bits
    namespace ltmr64l_bits {
        constexpr uint32_t LTL = (32 << 0);  ///< Life Timer value
    }

    /// LDVAL Register bits
    namespace ldval_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value
    }

    /// CVAL Register bits
    namespace cval_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL Register bits
    namespace tctrl_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable
        constexpr uint32_t CHN = (1U << 2);  ///< Chain Mode
    }

    /// TFLG Register bits
    namespace tflg_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_ETC_BASE = 0x40088000;
    constexpr uint32_t ADC1_BASE = 0x400C4000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - ADC_ETC Global Control Register
        volatile uint32_t DONE0_1_IRQ;  ///< Offset: 0x04 - ETC DONE0 and DONE1 IRQ State Register
        volatile uint32_t DONE2_ERR_IRQ;  ///< Offset: 0x08 - ETC DONE_2 and DONE_ERR IRQ State Register
        volatile uint32_t DMA_CTRL;  ///< Offset: 0x0C - ETC DMA control Register
        volatile uint32_t TRIG0_CTRL;  ///< Offset: 0x10 - ETC_TRIG Control Register
        volatile uint32_t TRIG0_COUNTER;  ///< Offset: 0x14 - ETC_TRIG Counter Register
        volatile uint32_t TRIG0_CHAIN_1_0;  ///< Offset: 0x18 - ETC_TRIG Chain 0/1 Register
        volatile uint32_t TRIG0_CHAIN_3_2;  ///< Offset: 0x1C - ETC_TRIG Chain 2/3 Register
        volatile uint32_t TRIG0_CHAIN_5_4;  ///< Offset: 0x20 - ETC_TRIG Chain 4/5 Register
        volatile uint32_t TRIG0_CHAIN_7_6;  ///< Offset: 0x24 - ETC_TRIG Chain 6/7 Register
        volatile uint32_t TRIG0_RESULT_1_0;  ///< Offset: 0x28 - ETC_TRIG Result Data 1/0 Register
        volatile uint32_t TRIG0_RESULT_3_2;  ///< Offset: 0x2C - ETC_TRIG Result Data 3/2 Register
        volatile uint32_t TRIG0_RESULT_5_4;  ///< Offset: 0x30 - ETC_TRIG Result Data 5/4 Register
        volatile uint32_t TRIG0_RESULT_7_6;  ///< Offset: 0x34 - ETC_TRIG Result Data 7/6 Register
        volatile uint32_t TRIG1_CTRL;  ///< Offset: 0x38 - ETC_TRIG Control Register
        volatile uint32_t TRIG1_COUNTER;  ///< Offset: 0x3C - ETC_TRIG Counter Register
        volatile uint32_t TRIG1_CHAIN_1_0;  ///< Offset: 0x40 - ETC_TRIG Chain 0/1 Register
        volatile uint32_t TRIG1_CHAIN_3_2;  ///< Offset: 0x44 - ETC_TRIG Chain 2/3 Register
        volatile uint32_t TRIG1_CHAIN_5_4;  ///< Offset: 0x48 - ETC_TRIG Chain 4/5 Register
        volatile uint32_t TRIG1_CHAIN_7_6;  ///< Offset: 0x4C - ETC_TRIG Chain 6/7 Register
        volatile uint32_t TRIG1_RESULT_1_0;  ///< Offset: 0x50 - ETC_TRIG Result Data 1/0 Register
        volatile uint32_t TRIG1_RESULT_3_2;  ///< Offset: 0x54 - ETC_TRIG Result Data 3/2 Register
        volatile uint32_t TRIG1_RESULT_5_4;  ///< Offset: 0x58 - ETC_TRIG Result Data 5/4 Register
        volatile uint32_t TRIG1_RESULT_7_6;  ///< Offset: 0x5C - ETC_TRIG Result Data 7/6 Register
        volatile uint32_t TRIG2_CTRL;  ///< Offset: 0x60 - ETC_TRIG Control Register
        volatile uint32_t TRIG2_COUNTER;  ///< Offset: 0x64 - ETC_TRIG Counter Register
        volatile uint32_t TRIG2_CHAIN_1_0;  ///< Offset: 0x68 - ETC_TRIG Chain 0/1 Register
        volatile uint32_t TRIG2_CHAIN_3_2;  ///< Offset: 0x6C - ETC_TRIG Chain 2/3 Register
        volatile uint32_t TRIG2_CHAIN_5_4;  ///< Offset: 0x70 - ETC_TRIG Chain 4/5 Register
        volatile uint32_t TRIG2_CHAIN_7_6;  ///< Offset: 0x74 - ETC_TRIG Chain 6/7 Register
        volatile uint32_t TRIG2_RESULT_1_0;  ///< Offset: 0x78 - ETC_TRIG Result Data 1/0 Register
        volatile uint32_t TRIG2_RESULT_3_2;  ///< Offset: 0x7C - ETC_TRIG Result Data 3/2 Register
        volatile uint32_t TRIG2_RESULT_5_4;  ///< Offset: 0x80 - ETC_TRIG Result Data 5/4 Register
        volatile uint32_t TRIG2_RESULT_7_6;  ///< Offset: 0x84 - ETC_TRIG Result Data 7/6 Register
        volatile uint32_t TRIG3_CTRL;  ///< Offset: 0x88 - ETC_TRIG Control Register
        volatile uint32_t TRIG3_COUNTER;  ///< Offset: 0x8C - ETC_TRIG Counter Register
        volatile uint32_t TRIG3_CHAIN_1_0;  ///< Offset: 0x90 - ETC_TRIG Chain 0/1 Register
        volatile uint32_t TRIG3_CHAIN_3_2;  ///< Offset: 0x94 - ETC_TRIG Chain 2/3 Register
        volatile uint32_t TRIG3_CHAIN_5_4;  ///< Offset: 0x98 - ETC_TRIG Chain 4/5 Register
        volatile uint32_t TRIG3_CHAIN_7_6;  ///< Offset: 0x9C - ETC_TRIG Chain 6/7 Register
        volatile uint32_t TRIG3_RESULT_1_0;  ///< Offset: 0xA0 - ETC_TRIG Result Data 1/0 Register
        volatile uint32_t TRIG3_RESULT_3_2;  ///< Offset: 0xA4 - ETC_TRIG Result Data 3/2 Register
        volatile uint32_t TRIG3_RESULT_5_4;  ///< Offset: 0xA8 - ETC_TRIG Result Data 5/4 Register
        volatile uint32_t TRIG3_RESULT_7_6;  ///< Offset: 0xAC - ETC_TRIG Result Data 7/6 Register
    };

    /// Peripheral instances
    inline Registers* ADC_ETC = reinterpret_cast<Registers*>(ADC_ETC_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TRIG_ENABLE = (8 << 0);  ///< TRIG enable register
        constexpr uint32_t EXT0_TRIG_ENABLE = (1U << 8);  ///< TSC0 TRIG enable register. 1'b1: enable external TSC0 trigger. 1'b0: disable external TSC0 trigger.
        constexpr uint32_t EXT0_TRIG_PRIORITY = (3 << 9);  ///< External TSC0 trigger priority, 7 is Highest, 0 is lowest .
        constexpr uint32_t EXT1_TRIG_ENABLE = (1U << 12);  ///< TSC1 TRIG enable register. 1'b1: enable external TSC1 trigger. 1'b0: disable external TSC1 trigger.
        constexpr uint32_t EXT1_TRIG_PRIORITY = (3 << 13);  ///< External TSC1 trigger priority, 7 is Highest, 0 is lowest .
        constexpr uint32_t PRE_DIVIDER = (8 << 16);  ///< Pre-divider for trig delay and interval .
        constexpr uint32_t DMA_MODE_SEL = (1U << 29);  ///< 1'b0: Trig DMA_REQ with latched signal, REQ will be cleared when ACK and source request cleared
        constexpr uint32_t TSC_BYPASS = (1U << 30);  ///< 1'b1: TSC is bypassed to ADC2. 1'b0: TSC not bypassed. To use ADC2, this bit should be cleared.
        constexpr uint32_t SOFTRST = (1U << 31);  ///< Software reset, high active. When write 1 ,all logical will be reset.
    }

    /// DONE0_1_IRQ Register bits
    namespace done0_1_irq_bits {
        constexpr uint32_t TRIG0_DONE0 = (1U << 0);  ///< TRIG0 done0 interrupt detection
        constexpr uint32_t TRIG1_DONE0 = (1U << 1);  ///< TRIG1 done0 interrupt detection
        constexpr uint32_t TRIG2_DONE0 = (1U << 2);  ///< TRIG2 done0 interrupt detection
        constexpr uint32_t TRIG3_DONE0 = (1U << 3);  ///< TRIG3 done0 interrupt detection
        constexpr uint32_t TRIG4_DONE0 = (1U << 4);  ///< TRIG4 done0 interrupt detection
        constexpr uint32_t TRIG5_DONE0 = (1U << 5);  ///< TRIG5 done0 interrupt detection
        constexpr uint32_t TRIG6_DONE0 = (1U << 6);  ///< TRIG6 done0 interrupt detection
        constexpr uint32_t TRIG7_DONE0 = (1U << 7);  ///< TRIG7 done0 interrupt detection
        constexpr uint32_t TRIG0_DONE1 = (1U << 16);  ///< TRIG0 done1 interrupt detection
        constexpr uint32_t TRIG1_DONE1 = (1U << 17);  ///< TRIG1 done1 interrupt detection
        constexpr uint32_t TRIG2_DONE1 = (1U << 18);  ///< TRIG2 done1 interrupt detection
        constexpr uint32_t TRIG3_DONE1 = (1U << 19);  ///< TRIG3 done1 interrupt detection
        constexpr uint32_t TRIG4_DONE1 = (1U << 20);  ///< TRIG4 done1 interrupt detection
        constexpr uint32_t TRIG5_DONE1 = (1U << 21);  ///< TRIG5 done1 interrupt detection
        constexpr uint32_t TRIG6_DONE1 = (1U << 22);  ///< TRIG6 done1 interrupt detection
        constexpr uint32_t TRIG7_DONE1 = (1U << 23);  ///< TRIG7 done1 interrupt detection
    }

    /// DONE2_ERR_IRQ Register bits
    namespace done2_err_irq_bits {
        constexpr uint32_t TRIG0_DONE2 = (1U << 0);  ///< TRIG0 done2 interrupt detection
        constexpr uint32_t TRIG1_DONE2 = (1U << 1);  ///< TRIG1 done2 interrupt detection
        constexpr uint32_t TRIG2_DONE2 = (1U << 2);  ///< TRIG2 done2 interrupt detection
        constexpr uint32_t TRIG3_DONE2 = (1U << 3);  ///< TRIG3 done2 interrupt detection
        constexpr uint32_t TRIG4_DONE2 = (1U << 4);  ///< TRIG4 done2 interrupt detection
        constexpr uint32_t TRIG5_DONE2 = (1U << 5);  ///< TRIG5 done2 interrupt detection
        constexpr uint32_t TRIG6_DONE2 = (1U << 6);  ///< TRIG6 done2 interrupt detection
        constexpr uint32_t TRIG7_DONE2 = (1U << 7);  ///< TRIG7 done2 interrupt detection
        constexpr uint32_t TRIG0_DONE3 = (1U << 8);  ///< TRIG0 done3 interrupt detection
        constexpr uint32_t TRIG1_DONE3 = (1U << 9);  ///< TRIG1 done3 interrupt detection
        constexpr uint32_t TRIG2_DONE3 = (1U << 10);  ///< TRIG2 done3 interrupt detection
        constexpr uint32_t TRIG3_DONE3 = (1U << 11);  ///< TRIG3 done3 interrupt detection
        constexpr uint32_t TRIG4_DONE3 = (1U << 12);  ///< TRIG4 done3 interrupt detection
        constexpr uint32_t TRIG5_DONE3 = (1U << 13);  ///< TRIG5 done3 interrupt detection
        constexpr uint32_t TRIG6_DONE3 = (1U << 14);  ///< TRIG6 done3 interrupt detection
        constexpr uint32_t TRIG7_DONE3 = (1U << 15);  ///< TRIG7 done3 interrupt detection
        constexpr uint32_t TRIG0_ERR = (1U << 16);  ///< TRIG0 error interrupt detection
        constexpr uint32_t TRIG1_ERR = (1U << 17);  ///< TRIG1 error interrupt detection
        constexpr uint32_t TRIG2_ERR = (1U << 18);  ///< TRIG2 error interrupt detection
        constexpr uint32_t TRIG3_ERR = (1U << 19);  ///< TRIG3 error interrupt detection
        constexpr uint32_t TRIG4_ERR = (1U << 20);  ///< TRIG4 error interrupt detection
        constexpr uint32_t TRIG5_ERR = (1U << 21);  ///< TRIG5 error interrupt detection
        constexpr uint32_t TRIG6_ERR = (1U << 22);  ///< TRIG6 error interrupt detection
        constexpr uint32_t TRIG7_ERR = (1U << 23);  ///< TRIG7 error interrupt detection
    }

    /// DMA_CTRL Register bits
    namespace dma_ctrl_bits {
        constexpr uint32_t TRIG0_ENABLE = (1U << 0);  ///< When TRIG0 done enable DMA request
        constexpr uint32_t TRIG1_ENABLE = (1U << 1);  ///< When TRIG1 done enable DMA request
        constexpr uint32_t TRIG2_ENABLE = (1U << 2);  ///< When TRIG2 done enable DMA request
        constexpr uint32_t TRIG3_ENABLE = (1U << 3);  ///< When TRIG3 done enable DMA request
        constexpr uint32_t TRIG4_ENABLE = (1U << 4);  ///< When TRIG4 done enable DMA request
        constexpr uint32_t TRIG5_ENABLE = (1U << 5);  ///< When TRIG5 done enable DMA request
        constexpr uint32_t TRIG6_ENABLE = (1U << 6);  ///< When TRIG6 done enable DMA request
        constexpr uint32_t TRIG7_ENABLE = (1U << 7);  ///< When TRIG7 done enable DMA request
        constexpr uint32_t TRIG0_REQ = (1U << 16);  ///< When TRIG0 done DMA request detection
        constexpr uint32_t TRIG1_REQ = (1U << 17);  ///< When TRIG1 done DMA request detection
        constexpr uint32_t TRIG2_REQ = (1U << 18);  ///< When TRIG2 done DMA request detection
        constexpr uint32_t TRIG3_REQ = (1U << 19);  ///< When TRIG3 done DMA request detection
        constexpr uint32_t TRIG4_REQ = (1U << 20);  ///< When TRIG4 done DMA request detection
        constexpr uint32_t TRIG5_REQ = (1U << 21);  ///< When TRIG5 done DMA request detection
        constexpr uint32_t TRIG6_REQ = (1U << 22);  ///< When TRIG6 done DMA request detection
        constexpr uint32_t TRIG7_REQ = (1U << 23);  ///< When TRIG7 done DMA request detection
    }

    /// TRIG0_CTRL Register bits
    namespace trig0_ctrl_bits {
        constexpr uint32_t SW_TRIG = (1U << 0);  ///< Software write 1 as the TRIGGER. This register is self-clearing.
        constexpr uint32_t TRIG_MODE = (1U << 4);  ///< TRIG mode register. 1'b0: hardware trigger. 1'b1: software trigger.
        constexpr uint32_t TRIG_CHAIN = (3 << 8);  ///< TRIG chain length to the ADC. 0: Trig length is 1; ... 7: Trig length is 8;
        constexpr uint32_t TRIG_PRIORITY = (3 << 12);  ///< External trigger priority, 7 is highest, 0 is lowest .
        constexpr uint32_t SYNC_MODE = (1U << 16);  ///< TRIG mode control . 1'b0: Disable sync mode; 1'b1: Enable sync mode
        constexpr uint32_t CHAINx_DONE = (8 << 24);  ///< CHAINx done interrupt detection bit 0: CHAIN0 done interrupt bit 1: CHAIN1 done interrupt bit 2: CHAIN2 done interrupt bit 3: CHAIN3 done interrupt bit 4: CHAIN4 done interrupt bit 5: CHAIN5 done interrupt bit 6: CHAIN6 done interrupt bit 7: CHAIN7 done interrupt The done interrupts are cleared by writing a logic 1 to the bits
    }

    /// TRIG0_COUNTER Register bits
    namespace trig0_counter_bits {
        constexpr uint32_t INIT_DELAY = (16 << 0);  ///< TRIGGER initial delay counter
        constexpr uint32_t SAMPLE_INTERVAL = (16 << 16);  ///< TRIGGER sampling interval counter
    }

    /// TRIG0_CHAIN_1_0 Register bits
    namespace trig0_chain_1_0_bits {
        constexpr uint32_t CSEL0 = (4 << 0);  ///< CHAIN0 CSEL ADC channel selection
        constexpr uint32_t HWTS0 = (8 << 4);  ///< CHAIN0 HWTS ADC hardware trigger selection. For more information, see the ADC chapter.
        constexpr uint32_t B2B0 = (1U << 12);  ///< CHAIN0 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
        constexpr uint32_t IE0 = (2 << 13);  ///< CHAIN0 IE 2'b00: Finished Interrupt on Done0 2'b01: Finished Interrupt on Done1 2'b10: Finished Interrupt on Done2 2'b11: Finished Interrupt on Done3
        constexpr uint32_t IE0_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL1 = (4 << 16);  ///< CHAIN1 CSEL ADC channel selection
        constexpr uint32_t HWTS1 = (8 << 20);  ///< CHAIN1 HWTS ADC hardware trigger selection. For more information, see the ADC chapter.
        constexpr uint32_t B2B1 = (1U << 28);  ///< CHAIN1 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
        constexpr uint32_t IE1 = (2 << 29);  ///< CHAIN1 IE 2'b00: Finished Interrupt on Done0 2'b01: Finished Interrupt on Done1 2'b10: Finished Interrupt on Done2 2'b11: Finished Interrupt on Done3
        constexpr uint32_t IE1_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG0_CHAIN_3_2 Register bits
    namespace trig0_chain_3_2_bits {
        constexpr uint32_t CSEL2 = (4 << 0);  ///< CHAIN2 CSEL
        constexpr uint32_t HWTS2 = (8 << 4);  ///< CHAIN2 HWTS
        constexpr uint32_t B2B2 = (1U << 12);  ///< CHAIN2 B2B
        constexpr uint32_t IE2 = (2 << 13);  ///< CHAIN2 IE
        constexpr uint32_t IE2_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL3 = (4 << 16);  ///< CHAIN3 CSEL
        constexpr uint32_t HWTS3 = (8 << 20);  ///< CHAIN3 HWTS
        constexpr uint32_t B2B3 = (1U << 28);  ///< CHAIN3 B2B
        constexpr uint32_t IE3 = (2 << 29);  ///< CHAIN3 IE
        constexpr uint32_t IE3_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG0_CHAIN_5_4 Register bits
    namespace trig0_chain_5_4_bits {
        constexpr uint32_t CSEL4 = (4 << 0);  ///< CHAIN4 CSEL
        constexpr uint32_t HWTS4 = (8 << 4);  ///< CHAIN4 HWTS
        constexpr uint32_t B2B4 = (1U << 12);  ///< CHAIN4 B2B
        constexpr uint32_t IE4 = (2 << 13);  ///< CHAIN4 IE
        constexpr uint32_t IE4_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL5 = (4 << 16);  ///< CHAIN5 CSEL
        constexpr uint32_t HWTS5 = (8 << 20);  ///< CHAIN5 HWTS
        constexpr uint32_t B2B5 = (1U << 28);  ///< CHAIN5 B2B
        constexpr uint32_t IE5 = (2 << 29);  ///< CHAIN5 IE
        constexpr uint32_t IE5_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG0_CHAIN_7_6 Register bits
    namespace trig0_chain_7_6_bits {
        constexpr uint32_t CSEL6 = (4 << 0);  ///< CHAIN6 CSEL
        constexpr uint32_t HWTS6 = (8 << 4);  ///< CHAIN6 HWTS
        constexpr uint32_t B2B6 = (1U << 12);  ///< CHAIN6 B2B
        constexpr uint32_t IE6 = (2 << 13);  ///< CHAIN6 IE
        constexpr uint32_t IE6_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL7 = (4 << 16);  ///< CHAIN7 CSEL
        constexpr uint32_t HWTS7 = (8 << 20);  ///< CHAIN7 HWTS
        constexpr uint32_t B2B7 = (1U << 28);  ///< CHAIN7 B2B
        constexpr uint32_t IE7 = (2 << 29);  ///< CHAIN7 IE
        constexpr uint32_t IE7_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG0_RESULT_1_0 Register bits
    namespace trig0_result_1_0_bits {
        constexpr uint32_t DATA0 = (12 << 0);  ///< Result DATA0
        constexpr uint32_t DATA1 = (12 << 16);  ///< Result DATA1
    }

    /// TRIG0_RESULT_3_2 Register bits
    namespace trig0_result_3_2_bits {
        constexpr uint32_t DATA2 = (12 << 0);  ///< Result DATA2
        constexpr uint32_t DATA3 = (12 << 16);  ///< Result DATA3
    }

    /// TRIG0_RESULT_5_4 Register bits
    namespace trig0_result_5_4_bits {
        constexpr uint32_t DATA4 = (12 << 0);  ///< Result DATA4
        constexpr uint32_t DATA5 = (12 << 16);  ///< Result DATA5
    }

    /// TRIG0_RESULT_7_6 Register bits
    namespace trig0_result_7_6_bits {
        constexpr uint32_t DATA6 = (12 << 0);  ///< Result DATA6
        constexpr uint32_t DATA7 = (12 << 16);  ///< Result DATA7
    }

    /// TRIG1_CTRL Register bits
    namespace trig1_ctrl_bits {
        constexpr uint32_t SW_TRIG = (1U << 0);  ///< Software write 1 as the TRIGGER. This register is self-clearing.
        constexpr uint32_t TRIG_MODE = (1U << 4);  ///< TRIG mode register. 1'b0: hardware trigger. 1'b1: software trigger.
        constexpr uint32_t TRIG_CHAIN = (3 << 8);  ///< TRIG chain length to the ADC. 0: Trig length is 1; ... 7: Trig length is 8;
        constexpr uint32_t TRIG_PRIORITY = (3 << 12);  ///< External trigger priority, 7 is highest, 0 is lowest .
        constexpr uint32_t SYNC_MODE = (1U << 16);  ///< TRIG mode control . 1'b0: Disable sync mode; 1'b1: Enable sync mode
        constexpr uint32_t CHAINx_DONE = (8 << 24);  ///< CHAINx done interrupt detection bit 0: CHAIN0 done interrupt bit 1: CHAIN1 done interrupt bit 2: CHAIN2 done interrupt bit 3: CHAIN3 done interrupt bit 4: CHAIN4 done interrupt bit 5: CHAIN5 done interrupt bit 6: CHAIN6 done interrupt bit 7: CHAIN7 done interrupt The done interrupts are cleared by writing a logic 1 to the bits
    }

    /// TRIG1_COUNTER Register bits
    namespace trig1_counter_bits {
        constexpr uint32_t INIT_DELAY = (16 << 0);  ///< TRIGGER initial delay counter
        constexpr uint32_t SAMPLE_INTERVAL = (16 << 16);  ///< TRIGGER sampling interval counter
    }

    /// TRIG1_CHAIN_1_0 Register bits
    namespace trig1_chain_1_0_bits {
        constexpr uint32_t CSEL0 = (4 << 0);  ///< CHAIN0 CSEL ADC channel selection
        constexpr uint32_t HWTS0 = (8 << 4);  ///< CHAIN0 HWTS ADC hardware trigger selection. For more information, see the ADC chapter.
        constexpr uint32_t B2B0 = (1U << 12);  ///< CHAIN0 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
        constexpr uint32_t IE0 = (2 << 13);  ///< CHAIN0 IE 2'b00: Finished Interrupt on Done0 2'b01: Finished Interrupt on Done1 2'b10: Finished Interrupt on Done2 2'b11: Finished Interrupt on Done3
        constexpr uint32_t IE0_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL1 = (4 << 16);  ///< CHAIN1 CSEL ADC channel selection
        constexpr uint32_t HWTS1 = (8 << 20);  ///< CHAIN1 HWTS ADC hardware trigger selection. For more information, see the ADC chapter.
        constexpr uint32_t B2B1 = (1U << 28);  ///< CHAIN1 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
        constexpr uint32_t IE1 = (2 << 29);  ///< CHAIN1 IE 2'b00: Finished Interrupt on Done0 2'b01: Finished Interrupt on Done1 2'b10: Finished Interrupt on Done2 2'b11: Finished Interrupt on Done3
        constexpr uint32_t IE1_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG1_CHAIN_3_2 Register bits
    namespace trig1_chain_3_2_bits {
        constexpr uint32_t CSEL2 = (4 << 0);  ///< CHAIN2 CSEL
        constexpr uint32_t HWTS2 = (8 << 4);  ///< CHAIN2 HWTS
        constexpr uint32_t B2B2 = (1U << 12);  ///< CHAIN2 B2B
        constexpr uint32_t IE2 = (2 << 13);  ///< CHAIN2 IE
        constexpr uint32_t IE2_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL3 = (4 << 16);  ///< CHAIN3 CSEL
        constexpr uint32_t HWTS3 = (8 << 20);  ///< CHAIN3 HWTS
        constexpr uint32_t B2B3 = (1U << 28);  ///< CHAIN3 B2B
        constexpr uint32_t IE3 = (2 << 29);  ///< CHAIN3 IE
        constexpr uint32_t IE3_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG1_CHAIN_5_4 Register bits
    namespace trig1_chain_5_4_bits {
        constexpr uint32_t CSEL4 = (4 << 0);  ///< CHAIN4 CSEL
        constexpr uint32_t HWTS4 = (8 << 4);  ///< CHAIN4 HWTS
        constexpr uint32_t B2B4 = (1U << 12);  ///< CHAIN4 B2B
        constexpr uint32_t IE4 = (2 << 13);  ///< CHAIN4 IE
        constexpr uint32_t IE4_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL5 = (4 << 16);  ///< CHAIN5 CSEL
        constexpr uint32_t HWTS5 = (8 << 20);  ///< CHAIN5 HWTS
        constexpr uint32_t B2B5 = (1U << 28);  ///< CHAIN5 B2B
        constexpr uint32_t IE5 = (2 << 29);  ///< CHAIN5 IE
        constexpr uint32_t IE5_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG1_CHAIN_7_6 Register bits
    namespace trig1_chain_7_6_bits {
        constexpr uint32_t CSEL6 = (4 << 0);  ///< CHAIN6 CSEL
        constexpr uint32_t HWTS6 = (8 << 4);  ///< CHAIN6 HWTS
        constexpr uint32_t B2B6 = (1U << 12);  ///< CHAIN6 B2B
        constexpr uint32_t IE6 = (2 << 13);  ///< CHAIN6 IE
        constexpr uint32_t IE6_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL7 = (4 << 16);  ///< CHAIN7 CSEL
        constexpr uint32_t HWTS7 = (8 << 20);  ///< CHAIN7 HWTS
        constexpr uint32_t B2B7 = (1U << 28);  ///< CHAIN7 B2B
        constexpr uint32_t IE7 = (2 << 29);  ///< CHAIN7 IE
        constexpr uint32_t IE7_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG1_RESULT_1_0 Register bits
    namespace trig1_result_1_0_bits {
        constexpr uint32_t DATA0 = (12 << 0);  ///< Result DATA0
        constexpr uint32_t DATA1 = (12 << 16);  ///< Result DATA1
    }

    /// TRIG1_RESULT_3_2 Register bits
    namespace trig1_result_3_2_bits {
        constexpr uint32_t DATA2 = (12 << 0);  ///< Result DATA2
        constexpr uint32_t DATA3 = (12 << 16);  ///< Result DATA3
    }

    /// TRIG1_RESULT_5_4 Register bits
    namespace trig1_result_5_4_bits {
        constexpr uint32_t DATA4 = (12 << 0);  ///< Result DATA4
        constexpr uint32_t DATA5 = (12 << 16);  ///< Result DATA5
    }

    /// TRIG1_RESULT_7_6 Register bits
    namespace trig1_result_7_6_bits {
        constexpr uint32_t DATA6 = (12 << 0);  ///< Result DATA6
        constexpr uint32_t DATA7 = (12 << 16);  ///< Result DATA7
    }

    /// TRIG2_CTRL Register bits
    namespace trig2_ctrl_bits {
        constexpr uint32_t SW_TRIG = (1U << 0);  ///< Software write 1 as the TRIGGER. This register is self-clearing.
        constexpr uint32_t TRIG_MODE = (1U << 4);  ///< TRIG mode register. 1'b0: hardware trigger. 1'b1: software trigger.
        constexpr uint32_t TRIG_CHAIN = (3 << 8);  ///< TRIG chain length to the ADC. 0: Trig length is 1; ... 7: Trig length is 8;
        constexpr uint32_t TRIG_PRIORITY = (3 << 12);  ///< External trigger priority, 7 is highest, 0 is lowest .
        constexpr uint32_t SYNC_MODE = (1U << 16);  ///< TRIG mode control . 1'b0: Disable sync mode; 1'b1: Enable sync mode
        constexpr uint32_t CHAINx_DONE = (8 << 24);  ///< CHAINx done interrupt detection bit 0: CHAIN0 done interrupt bit 1: CHAIN1 done interrupt bit 2: CHAIN2 done interrupt bit 3: CHAIN3 done interrupt bit 4: CHAIN4 done interrupt bit 5: CHAIN5 done interrupt bit 6: CHAIN6 done interrupt bit 7: CHAIN7 done interrupt The done interrupts are cleared by writing a logic 1 to the bits
    }

    /// TRIG2_COUNTER Register bits
    namespace trig2_counter_bits {
        constexpr uint32_t INIT_DELAY = (16 << 0);  ///< TRIGGER initial delay counter
        constexpr uint32_t SAMPLE_INTERVAL = (16 << 16);  ///< TRIGGER sampling interval counter
    }

    /// TRIG2_CHAIN_1_0 Register bits
    namespace trig2_chain_1_0_bits {
        constexpr uint32_t CSEL0 = (4 << 0);  ///< CHAIN0 CSEL ADC channel selection
        constexpr uint32_t HWTS0 = (8 << 4);  ///< CHAIN0 HWTS ADC hardware trigger selection. For more information, see the ADC chapter.
        constexpr uint32_t B2B0 = (1U << 12);  ///< CHAIN0 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
        constexpr uint32_t IE0 = (2 << 13);  ///< CHAIN0 IE 2'b00: Finished Interrupt on Done0 2'b01: Finished Interrupt on Done1 2'b10: Finished Interrupt on Done2 2'b11: Finished Interrupt on Done3
        constexpr uint32_t IE0_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL1 = (4 << 16);  ///< CHAIN1 CSEL ADC channel selection
        constexpr uint32_t HWTS1 = (8 << 20);  ///< CHAIN1 HWTS ADC hardware trigger selection. For more information, see the ADC chapter.
        constexpr uint32_t B2B1 = (1U << 28);  ///< CHAIN1 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
        constexpr uint32_t IE1 = (2 << 29);  ///< CHAIN1 IE 2'b00: Finished Interrupt on Done0 2'b01: Finished Interrupt on Done1 2'b10: Finished Interrupt on Done2 2'b11: Finished Interrupt on Done3
        constexpr uint32_t IE1_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG2_CHAIN_3_2 Register bits
    namespace trig2_chain_3_2_bits {
        constexpr uint32_t CSEL2 = (4 << 0);  ///< CHAIN2 CSEL
        constexpr uint32_t HWTS2 = (8 << 4);  ///< CHAIN2 HWTS
        constexpr uint32_t B2B2 = (1U << 12);  ///< CHAIN2 B2B
        constexpr uint32_t IE2 = (2 << 13);  ///< CHAIN2 IE
        constexpr uint32_t IE2_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL3 = (4 << 16);  ///< CHAIN3 CSEL
        constexpr uint32_t HWTS3 = (8 << 20);  ///< CHAIN3 HWTS
        constexpr uint32_t B2B3 = (1U << 28);  ///< CHAIN3 B2B
        constexpr uint32_t IE3 = (2 << 29);  ///< CHAIN3 IE
        constexpr uint32_t IE3_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG2_CHAIN_5_4 Register bits
    namespace trig2_chain_5_4_bits {
        constexpr uint32_t CSEL4 = (4 << 0);  ///< CHAIN4 CSEL
        constexpr uint32_t HWTS4 = (8 << 4);  ///< CHAIN4 HWTS
        constexpr uint32_t B2B4 = (1U << 12);  ///< CHAIN4 B2B
        constexpr uint32_t IE4 = (2 << 13);  ///< CHAIN4 IE
        constexpr uint32_t IE4_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL5 = (4 << 16);  ///< CHAIN5 CSEL
        constexpr uint32_t HWTS5 = (8 << 20);  ///< CHAIN5 HWTS
        constexpr uint32_t B2B5 = (1U << 28);  ///< CHAIN5 B2B
        constexpr uint32_t IE5 = (2 << 29);  ///< CHAIN5 IE
        constexpr uint32_t IE5_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG2_CHAIN_7_6 Register bits
    namespace trig2_chain_7_6_bits {
        constexpr uint32_t CSEL6 = (4 << 0);  ///< CHAIN6 CSEL
        constexpr uint32_t HWTS6 = (8 << 4);  ///< CHAIN6 HWTS
        constexpr uint32_t B2B6 = (1U << 12);  ///< CHAIN6 B2B
        constexpr uint32_t IE6 = (2 << 13);  ///< CHAIN6 IE
        constexpr uint32_t IE6_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL7 = (4 << 16);  ///< CHAIN7 CSEL
        constexpr uint32_t HWTS7 = (8 << 20);  ///< CHAIN7 HWTS
        constexpr uint32_t B2B7 = (1U << 28);  ///< CHAIN7 B2B
        constexpr uint32_t IE7 = (2 << 29);  ///< CHAIN7 IE
        constexpr uint32_t IE7_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG2_RESULT_1_0 Register bits
    namespace trig2_result_1_0_bits {
        constexpr uint32_t DATA0 = (12 << 0);  ///< Result DATA0
        constexpr uint32_t DATA1 = (12 << 16);  ///< Result DATA1
    }

    /// TRIG2_RESULT_3_2 Register bits
    namespace trig2_result_3_2_bits {
        constexpr uint32_t DATA2 = (12 << 0);  ///< Result DATA2
        constexpr uint32_t DATA3 = (12 << 16);  ///< Result DATA3
    }

    /// TRIG2_RESULT_5_4 Register bits
    namespace trig2_result_5_4_bits {
        constexpr uint32_t DATA4 = (12 << 0);  ///< Result DATA4
        constexpr uint32_t DATA5 = (12 << 16);  ///< Result DATA5
    }

    /// TRIG2_RESULT_7_6 Register bits
    namespace trig2_result_7_6_bits {
        constexpr uint32_t DATA6 = (12 << 0);  ///< Result DATA6
        constexpr uint32_t DATA7 = (12 << 16);  ///< Result DATA7
    }

    /// TRIG3_CTRL Register bits
    namespace trig3_ctrl_bits {
        constexpr uint32_t SW_TRIG = (1U << 0);  ///< Software write 1 as the TRIGGER. This register is self-clearing.
        constexpr uint32_t TRIG_MODE = (1U << 4);  ///< TRIG mode register. 1'b0: hardware trigger. 1'b1: software trigger.
        constexpr uint32_t TRIG_CHAIN = (3 << 8);  ///< TRIG chain length to the ADC. 0: Trig length is 1; ... 7: Trig length is 8;
        constexpr uint32_t TRIG_PRIORITY = (3 << 12);  ///< External trigger priority, 7 is highest, 0 is lowest .
        constexpr uint32_t SYNC_MODE = (1U << 16);  ///< TRIG mode control . 1'b0: Disable sync mode; 1'b1: Enable sync mode
        constexpr uint32_t CHAINx_DONE = (8 << 24);  ///< CHAINx done interrupt detection bit 0: CHAIN0 done interrupt bit 1: CHAIN1 done interrupt bit 2: CHAIN2 done interrupt bit 3: CHAIN3 done interrupt bit 4: CHAIN4 done interrupt bit 5: CHAIN5 done interrupt bit 6: CHAIN6 done interrupt bit 7: CHAIN7 done interrupt The done interrupts are cleared by writing a logic 1 to the bits
    }

    /// TRIG3_COUNTER Register bits
    namespace trig3_counter_bits {
        constexpr uint32_t INIT_DELAY = (16 << 0);  ///< TRIGGER initial delay counter
        constexpr uint32_t SAMPLE_INTERVAL = (16 << 16);  ///< TRIGGER sampling interval counter
    }

    /// TRIG3_CHAIN_1_0 Register bits
    namespace trig3_chain_1_0_bits {
        constexpr uint32_t CSEL0 = (4 << 0);  ///< CHAIN0 CSEL ADC channel selection
        constexpr uint32_t HWTS0 = (8 << 4);  ///< CHAIN0 HWTS ADC hardware trigger selection. For more information, see the ADC chapter.
        constexpr uint32_t B2B0 = (1U << 12);  ///< CHAIN0 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
        constexpr uint32_t IE0 = (2 << 13);  ///< CHAIN0 IE 2'b00: Finished Interrupt on Done0 2'b01: Finished Interrupt on Done1 2'b10: Finished Interrupt on Done2 2'b11: Finished Interrupt on Done3
        constexpr uint32_t IE0_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL1 = (4 << 16);  ///< CHAIN1 CSEL ADC channel selection
        constexpr uint32_t HWTS1 = (8 << 20);  ///< CHAIN1 HWTS ADC hardware trigger selection. For more information, see the ADC chapter.
        constexpr uint32_t B2B1 = (1U << 28);  ///< CHAIN1 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
        constexpr uint32_t IE1 = (2 << 29);  ///< CHAIN1 IE 2'b00: Finished Interrupt on Done0 2'b01: Finished Interrupt on Done1 2'b10: Finished Interrupt on Done2 2'b11: Finished Interrupt on Done3
        constexpr uint32_t IE1_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG3_CHAIN_3_2 Register bits
    namespace trig3_chain_3_2_bits {
        constexpr uint32_t CSEL2 = (4 << 0);  ///< CHAIN2 CSEL
        constexpr uint32_t HWTS2 = (8 << 4);  ///< CHAIN2 HWTS
        constexpr uint32_t B2B2 = (1U << 12);  ///< CHAIN2 B2B
        constexpr uint32_t IE2 = (2 << 13);  ///< CHAIN2 IE
        constexpr uint32_t IE2_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL3 = (4 << 16);  ///< CHAIN3 CSEL
        constexpr uint32_t HWTS3 = (8 << 20);  ///< CHAIN3 HWTS
        constexpr uint32_t B2B3 = (1U << 28);  ///< CHAIN3 B2B
        constexpr uint32_t IE3 = (2 << 29);  ///< CHAIN3 IE
        constexpr uint32_t IE3_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG3_CHAIN_5_4 Register bits
    namespace trig3_chain_5_4_bits {
        constexpr uint32_t CSEL4 = (4 << 0);  ///< CHAIN4 CSEL
        constexpr uint32_t HWTS4 = (8 << 4);  ///< CHAIN4 HWTS
        constexpr uint32_t B2B4 = (1U << 12);  ///< CHAIN4 B2B
        constexpr uint32_t IE4 = (2 << 13);  ///< CHAIN4 IE
        constexpr uint32_t IE4_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL5 = (4 << 16);  ///< CHAIN5 CSEL
        constexpr uint32_t HWTS5 = (8 << 20);  ///< CHAIN5 HWTS
        constexpr uint32_t B2B5 = (1U << 28);  ///< CHAIN5 B2B
        constexpr uint32_t IE5 = (2 << 29);  ///< CHAIN5 IE
        constexpr uint32_t IE5_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG3_CHAIN_7_6 Register bits
    namespace trig3_chain_7_6_bits {
        constexpr uint32_t CSEL6 = (4 << 0);  ///< CHAIN6 CSEL
        constexpr uint32_t HWTS6 = (8 << 4);  ///< CHAIN6 HWTS
        constexpr uint32_t B2B6 = (1U << 12);  ///< CHAIN6 B2B
        constexpr uint32_t IE6 = (2 << 13);  ///< CHAIN6 IE
        constexpr uint32_t IE6_EN = (1U << 15);  ///< IRQ enable
        constexpr uint32_t CSEL7 = (4 << 16);  ///< CHAIN7 CSEL
        constexpr uint32_t HWTS7 = (8 << 20);  ///< CHAIN7 HWTS
        constexpr uint32_t B2B7 = (1U << 28);  ///< CHAIN7 B2B
        constexpr uint32_t IE7 = (2 << 29);  ///< CHAIN7 IE
        constexpr uint32_t IE7_EN = (1U << 31);  ///< IRQ enable
    }

    /// TRIG3_RESULT_1_0 Register bits
    namespace trig3_result_1_0_bits {
        constexpr uint32_t DATA0 = (12 << 0);  ///< Result DATA0
        constexpr uint32_t DATA1 = (12 << 16);  ///< Result DATA1
    }

    /// TRIG3_RESULT_3_2 Register bits
    namespace trig3_result_3_2_bits {
        constexpr uint32_t DATA2 = (12 << 0);  ///< Result DATA2
        constexpr uint32_t DATA3 = (12 << 16);  ///< Result DATA3
    }

    /// TRIG3_RESULT_5_4 Register bits
    namespace trig3_result_5_4_bits {
        constexpr uint32_t DATA4 = (12 << 0);  ///< Result DATA4
        constexpr uint32_t DATA5 = (12 << 16);  ///< Result DATA5
    }

    /// TRIG3_RESULT_7_6 Register bits
    namespace trig3_result_7_6_bits {
        constexpr uint32_t DATA6 = (12 << 0);  ///< Result DATA6
        constexpr uint32_t DATA7 = (12 << 16);  ///< Result DATA7
    }

}

// ============================================================================
// AOI Peripheral
// ============================================================================

namespace aoi {
    /// Base addresses
    constexpr uint32_t AOI_BASE = 0x40094000;

    /// AOI Register structure
    struct Registers {
        volatile uint32_t BFCRT01%s;  ///< Offset: 0x00 - Boolean Function Term 0 and 1 Configuration Register for EVENTn
        volatile uint32_t BFCRT23%s;  ///< Offset: 0x02 - Boolean Function Term 2 and 3 Configuration Register for EVENTn
    };

    /// Peripheral instances
    inline Registers* AOI = reinterpret_cast<Registers*>(AOI_BASE);

    // Bit definitions
    /// BFCRT01%s Register bits
    namespace bfcrt01%s_bits {
        constexpr uint32_t PT1_DC = (2 << 0);  ///< Product term 1, D input configuration
        constexpr uint32_t PT1_CC = (2 << 2);  ///< Product term 1, C input configuration
        constexpr uint32_t PT1_BC = (2 << 4);  ///< Product term 1, B input configuration
        constexpr uint32_t PT1_AC = (2 << 6);  ///< Product term 1, A input configuration
        constexpr uint32_t PT0_DC = (2 << 8);  ///< Product term 0, D input configuration
        constexpr uint32_t PT0_CC = (2 << 10);  ///< Product term 0, C input configuration
        constexpr uint32_t PT0_BC = (2 << 12);  ///< Product term 0, B input configuration
        constexpr uint32_t PT0_AC = (2 << 14);  ///< Product term 0, A input configuration
    }

    /// BFCRT23%s Register bits
    namespace bfcrt23%s_bits {
        constexpr uint32_t PT3_DC = (2 << 0);  ///< Product term 3, D input configuration
        constexpr uint32_t PT3_CC = (2 << 2);  ///< Product term 3, C input configuration
        constexpr uint32_t PT3_BC = (2 << 4);  ///< Product term 3, B input configuration
        constexpr uint32_t PT3_AC = (2 << 6);  ///< Product term 3, A input configuration
        constexpr uint32_t PT2_DC = (2 << 8);  ///< Product term 2, D input configuration
        constexpr uint32_t PT2_CC = (2 << 10);  ///< Product term 2, C input configuration
        constexpr uint32_t PT2_BC = (2 << 12);  ///< Product term 2, B input configuration
        constexpr uint32_t PT2_AC = (2 << 14);  ///< Product term 2, A input configuration
    }

}

// ============================================================================
// XBARA Peripheral
// ============================================================================

namespace xbara {
    /// Base addresses
    constexpr uint32_t XBARA_BASE = 0x40098000;

    /// XBARA Register structure
    struct Registers {
        volatile uint32_t SEL0;  ///< Offset: 0x00 - Crossbar A Select Register 0
        volatile uint32_t SEL1;  ///< Offset: 0x02 - Crossbar A Select Register 1
        volatile uint32_t SEL2;  ///< Offset: 0x04 - Crossbar A Select Register 2
        volatile uint32_t SEL3;  ///< Offset: 0x06 - Crossbar A Select Register 3
        volatile uint32_t SEL4;  ///< Offset: 0x08 - Crossbar A Select Register 4
        volatile uint32_t SEL5;  ///< Offset: 0x0A - Crossbar A Select Register 5
        volatile uint32_t SEL6;  ///< Offset: 0x0C - Crossbar A Select Register 6
        volatile uint32_t SEL7;  ///< Offset: 0x0E - Crossbar A Select Register 7
        volatile uint32_t SEL8;  ///< Offset: 0x10 - Crossbar A Select Register 8
        volatile uint32_t SEL9;  ///< Offset: 0x12 - Crossbar A Select Register 9
        volatile uint32_t SEL10;  ///< Offset: 0x14 - Crossbar A Select Register 10
        volatile uint32_t SEL11;  ///< Offset: 0x16 - Crossbar A Select Register 11
        volatile uint32_t SEL12;  ///< Offset: 0x18 - Crossbar A Select Register 12
        volatile uint32_t SEL13;  ///< Offset: 0x1A - Crossbar A Select Register 13
        volatile uint32_t SEL14;  ///< Offset: 0x1C - Crossbar A Select Register 14
        volatile uint32_t SEL15;  ///< Offset: 0x1E - Crossbar A Select Register 15
        volatile uint32_t SEL16;  ///< Offset: 0x20 - Crossbar A Select Register 16
        volatile uint32_t SEL17;  ///< Offset: 0x22 - Crossbar A Select Register 17
        volatile uint32_t SEL18;  ///< Offset: 0x24 - Crossbar A Select Register 18
        volatile uint32_t SEL19;  ///< Offset: 0x26 - Crossbar A Select Register 19
        volatile uint32_t SEL20;  ///< Offset: 0x28 - Crossbar A Select Register 20
        volatile uint32_t SEL21;  ///< Offset: 0x2A - Crossbar A Select Register 21
        volatile uint32_t SEL22;  ///< Offset: 0x2C - Crossbar A Select Register 22
        volatile uint32_t SEL23;  ///< Offset: 0x2E - Crossbar A Select Register 23
        volatile uint32_t SEL24;  ///< Offset: 0x30 - Crossbar A Select Register 24
        volatile uint32_t SEL25;  ///< Offset: 0x32 - Crossbar A Select Register 25
        volatile uint32_t SEL26;  ///< Offset: 0x34 - Crossbar A Select Register 26
        volatile uint32_t SEL27;  ///< Offset: 0x36 - Crossbar A Select Register 27
        volatile uint32_t SEL28;  ///< Offset: 0x38 - Crossbar A Select Register 28
        volatile uint32_t SEL29;  ///< Offset: 0x3A - Crossbar A Select Register 29
        volatile uint32_t SEL30;  ///< Offset: 0x3C - Crossbar A Select Register 30
        volatile uint32_t SEL31;  ///< Offset: 0x3E - Crossbar A Select Register 31
        volatile uint32_t SEL32;  ///< Offset: 0x40 - Crossbar A Select Register 32
        volatile uint32_t SEL33;  ///< Offset: 0x42 - Crossbar A Select Register 33
        volatile uint32_t SEL34;  ///< Offset: 0x44 - Crossbar A Select Register 34
        volatile uint32_t SEL35;  ///< Offset: 0x46 - Crossbar A Select Register 35
        volatile uint32_t SEL36;  ///< Offset: 0x48 - Crossbar A Select Register 36
        volatile uint32_t SEL37;  ///< Offset: 0x4A - Crossbar A Select Register 37
        volatile uint32_t SEL38;  ///< Offset: 0x4C - Crossbar A Select Register 38
        volatile uint32_t SEL39;  ///< Offset: 0x4E - Crossbar A Select Register 39
        volatile uint32_t SEL40;  ///< Offset: 0x50 - Crossbar A Select Register 40
        volatile uint32_t SEL41;  ///< Offset: 0x52 - Crossbar A Select Register 41
        volatile uint32_t SEL42;  ///< Offset: 0x54 - Crossbar A Select Register 42
        volatile uint32_t SEL43;  ///< Offset: 0x56 - Crossbar A Select Register 43
        volatile uint32_t SEL44;  ///< Offset: 0x58 - Crossbar A Select Register 44
        volatile uint32_t SEL45;  ///< Offset: 0x5A - Crossbar A Select Register 45
        volatile uint32_t SEL46;  ///< Offset: 0x5C - Crossbar A Select Register 46
        volatile uint32_t SEL47;  ///< Offset: 0x5E - Crossbar A Select Register 47
        volatile uint32_t SEL48;  ///< Offset: 0x60 - Crossbar A Select Register 48
        volatile uint32_t SEL49;  ///< Offset: 0x62 - Crossbar A Select Register 49
        volatile uint32_t SEL50;  ///< Offset: 0x64 - Crossbar A Select Register 50
        volatile uint32_t SEL51;  ///< Offset: 0x66 - Crossbar A Select Register 51
        volatile uint32_t SEL52;  ///< Offset: 0x68 - Crossbar A Select Register 52
        volatile uint32_t SEL53;  ///< Offset: 0x6A - Crossbar A Select Register 53
        volatile uint32_t SEL54;  ///< Offset: 0x6C - Crossbar A Select Register 54
        volatile uint32_t SEL55;  ///< Offset: 0x6E - Crossbar A Select Register 55
        volatile uint32_t SEL56;  ///< Offset: 0x70 - Crossbar A Select Register 56
        volatile uint32_t SEL57;  ///< Offset: 0x72 - Crossbar A Select Register 57
        volatile uint32_t SEL58;  ///< Offset: 0x74 - Crossbar A Select Register 58
        volatile uint32_t SEL59;  ///< Offset: 0x76 - Crossbar A Select Register 59
        volatile uint32_t SEL60;  ///< Offset: 0x78 - Crossbar A Select Register 60
        volatile uint32_t SEL61;  ///< Offset: 0x7A - Crossbar A Select Register 61
        volatile uint32_t SEL62;  ///< Offset: 0x7C - Crossbar A Select Register 62
        volatile uint32_t SEL63;  ///< Offset: 0x7E - Crossbar A Select Register 63
        volatile uint32_t SEL64;  ///< Offset: 0x80 - Crossbar A Select Register 64
        volatile uint32_t SEL65;  ///< Offset: 0x82 - Crossbar A Select Register 65
        volatile uint32_t CTRL0;  ///< Offset: 0x84 - Crossbar A Control Register 0
        volatile uint32_t CTRL1;  ///< Offset: 0x86 - Crossbar A Control Register 1
    };

    /// Peripheral instances
    inline Registers* XBARA = reinterpret_cast<Registers*>(XBARA_BASE);

    // Bit definitions
    /// SEL0 Register bits
    namespace sel0_bits {
        constexpr uint32_t SEL0 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT0 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL1 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT1 (refer to Functional Description section for input/output assignment)
    }

    /// SEL1 Register bits
    namespace sel1_bits {
        constexpr uint32_t SEL2 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT2 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL3 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT3 (refer to Functional Description section for input/output assignment)
    }

    /// SEL2 Register bits
    namespace sel2_bits {
        constexpr uint32_t SEL4 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT4 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL5 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT5 (refer to Functional Description section for input/output assignment)
    }

    /// SEL3 Register bits
    namespace sel3_bits {
        constexpr uint32_t SEL6 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT6 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL7 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT7 (refer to Functional Description section for input/output assignment)
    }

    /// SEL4 Register bits
    namespace sel4_bits {
        constexpr uint32_t SEL8 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT8 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL9 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT9 (refer to Functional Description section for input/output assignment)
    }

    /// SEL5 Register bits
    namespace sel5_bits {
        constexpr uint32_t SEL10 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT10 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL11 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT11 (refer to Functional Description section for input/output assignment)
    }

    /// SEL6 Register bits
    namespace sel6_bits {
        constexpr uint32_t SEL12 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT12 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL13 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT13 (refer to Functional Description section for input/output assignment)
    }

    /// SEL7 Register bits
    namespace sel7_bits {
        constexpr uint32_t SEL14 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT14 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL15 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT15 (refer to Functional Description section for input/output assignment)
    }

    /// SEL8 Register bits
    namespace sel8_bits {
        constexpr uint32_t SEL16 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT16 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL17 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT17 (refer to Functional Description section for input/output assignment)
    }

    /// SEL9 Register bits
    namespace sel9_bits {
        constexpr uint32_t SEL18 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT18 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL19 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT19 (refer to Functional Description section for input/output assignment)
    }

    /// SEL10 Register bits
    namespace sel10_bits {
        constexpr uint32_t SEL20 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT20 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL21 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT21 (refer to Functional Description section for input/output assignment)
    }

    /// SEL11 Register bits
    namespace sel11_bits {
        constexpr uint32_t SEL22 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT22 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL23 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT23 (refer to Functional Description section for input/output assignment)
    }

    /// SEL12 Register bits
    namespace sel12_bits {
        constexpr uint32_t SEL24 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT24 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL25 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT25 (refer to Functional Description section for input/output assignment)
    }

    /// SEL13 Register bits
    namespace sel13_bits {
        constexpr uint32_t SEL26 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT26 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL27 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT27 (refer to Functional Description section for input/output assignment)
    }

    /// SEL14 Register bits
    namespace sel14_bits {
        constexpr uint32_t SEL28 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT28 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL29 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT29 (refer to Functional Description section for input/output assignment)
    }

    /// SEL15 Register bits
    namespace sel15_bits {
        constexpr uint32_t SEL30 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT30 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL31 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT31 (refer to Functional Description section for input/output assignment)
    }

    /// SEL16 Register bits
    namespace sel16_bits {
        constexpr uint32_t SEL32 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT32 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL33 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT33 (refer to Functional Description section for input/output assignment)
    }

    /// SEL17 Register bits
    namespace sel17_bits {
        constexpr uint32_t SEL34 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT34 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL35 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT35 (refer to Functional Description section for input/output assignment)
    }

    /// SEL18 Register bits
    namespace sel18_bits {
        constexpr uint32_t SEL36 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT36 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL37 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT37 (refer to Functional Description section for input/output assignment)
    }

    /// SEL19 Register bits
    namespace sel19_bits {
        constexpr uint32_t SEL38 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT38 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL39 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT39 (refer to Functional Description section for input/output assignment)
    }

    /// SEL20 Register bits
    namespace sel20_bits {
        constexpr uint32_t SEL40 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT40 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL41 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT41 (refer to Functional Description section for input/output assignment)
    }

    /// SEL21 Register bits
    namespace sel21_bits {
        constexpr uint32_t SEL42 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT42 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL43 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT43 (refer to Functional Description section for input/output assignment)
    }

    /// SEL22 Register bits
    namespace sel22_bits {
        constexpr uint32_t SEL44 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT44 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL45 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT45 (refer to Functional Description section for input/output assignment)
    }

    /// SEL23 Register bits
    namespace sel23_bits {
        constexpr uint32_t SEL46 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT46 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL47 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT47 (refer to Functional Description section for input/output assignment)
    }

    /// SEL24 Register bits
    namespace sel24_bits {
        constexpr uint32_t SEL48 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT48 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL49 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT49 (refer to Functional Description section for input/output assignment)
    }

    /// SEL25 Register bits
    namespace sel25_bits {
        constexpr uint32_t SEL50 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT50 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL51 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT51 (refer to Functional Description section for input/output assignment)
    }

    /// SEL26 Register bits
    namespace sel26_bits {
        constexpr uint32_t SEL52 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT52 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL53 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT53 (refer to Functional Description section for input/output assignment)
    }

    /// SEL27 Register bits
    namespace sel27_bits {
        constexpr uint32_t SEL54 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT54 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL55 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT55 (refer to Functional Description section for input/output assignment)
    }

    /// SEL28 Register bits
    namespace sel28_bits {
        constexpr uint32_t SEL56 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT56 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL57 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT57 (refer to Functional Description section for input/output assignment)
    }

    /// SEL29 Register bits
    namespace sel29_bits {
        constexpr uint32_t SEL58 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT58 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL59 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT59 (refer to Functional Description section for input/output assignment)
    }

    /// SEL30 Register bits
    namespace sel30_bits {
        constexpr uint32_t SEL60 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT60 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL61 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT61 (refer to Functional Description section for input/output assignment)
    }

    /// SEL31 Register bits
    namespace sel31_bits {
        constexpr uint32_t SEL62 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT62 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL63 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT63 (refer to Functional Description section for input/output assignment)
    }

    /// SEL32 Register bits
    namespace sel32_bits {
        constexpr uint32_t SEL64 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT64 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL65 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT65 (refer to Functional Description section for input/output assignment)
    }

    /// SEL33 Register bits
    namespace sel33_bits {
        constexpr uint32_t SEL66 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT66 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL67 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT67 (refer to Functional Description section for input/output assignment)
    }

    /// SEL34 Register bits
    namespace sel34_bits {
        constexpr uint32_t SEL68 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT68 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL69 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT69 (refer to Functional Description section for input/output assignment)
    }

    /// SEL35 Register bits
    namespace sel35_bits {
        constexpr uint32_t SEL70 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT70 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL71 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT71 (refer to Functional Description section for input/output assignment)
    }

    /// SEL36 Register bits
    namespace sel36_bits {
        constexpr uint32_t SEL72 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT72 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL73 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT73 (refer to Functional Description section for input/output assignment)
    }

    /// SEL37 Register bits
    namespace sel37_bits {
        constexpr uint32_t SEL74 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT74 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL75 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT75 (refer to Functional Description section for input/output assignment)
    }

    /// SEL38 Register bits
    namespace sel38_bits {
        constexpr uint32_t SEL76 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT76 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL77 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT77 (refer to Functional Description section for input/output assignment)
    }

    /// SEL39 Register bits
    namespace sel39_bits {
        constexpr uint32_t SEL78 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT78 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL79 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT79 (refer to Functional Description section for input/output assignment)
    }

    /// SEL40 Register bits
    namespace sel40_bits {
        constexpr uint32_t SEL80 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT80 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL81 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT81 (refer to Functional Description section for input/output assignment)
    }

    /// SEL41 Register bits
    namespace sel41_bits {
        constexpr uint32_t SEL82 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT82 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL83 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT83 (refer to Functional Description section for input/output assignment)
    }

    /// SEL42 Register bits
    namespace sel42_bits {
        constexpr uint32_t SEL84 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT84 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL85 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT85 (refer to Functional Description section for input/output assignment)
    }

    /// SEL43 Register bits
    namespace sel43_bits {
        constexpr uint32_t SEL86 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT86 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL87 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT87 (refer to Functional Description section for input/output assignment)
    }

    /// SEL44 Register bits
    namespace sel44_bits {
        constexpr uint32_t SEL88 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT88 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL89 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT89 (refer to Functional Description section for input/output assignment)
    }

    /// SEL45 Register bits
    namespace sel45_bits {
        constexpr uint32_t SEL90 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT90 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL91 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT91 (refer to Functional Description section for input/output assignment)
    }

    /// SEL46 Register bits
    namespace sel46_bits {
        constexpr uint32_t SEL92 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT92 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL93 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT93 (refer to Functional Description section for input/output assignment)
    }

    /// SEL47 Register bits
    namespace sel47_bits {
        constexpr uint32_t SEL94 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT94 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL95 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT95 (refer to Functional Description section for input/output assignment)
    }

    /// SEL48 Register bits
    namespace sel48_bits {
        constexpr uint32_t SEL96 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT96 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL97 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT97 (refer to Functional Description section for input/output assignment)
    }

    /// SEL49 Register bits
    namespace sel49_bits {
        constexpr uint32_t SEL98 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT98 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL99 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT99 (refer to Functional Description section for input/output assignment)
    }

    /// SEL50 Register bits
    namespace sel50_bits {
        constexpr uint32_t SEL100 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT100 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL101 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT101 (refer to Functional Description section for input/output assignment)
    }

    /// SEL51 Register bits
    namespace sel51_bits {
        constexpr uint32_t SEL102 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT102 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL103 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT103 (refer to Functional Description section for input/output assignment)
    }

    /// SEL52 Register bits
    namespace sel52_bits {
        constexpr uint32_t SEL104 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT104 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL105 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT105 (refer to Functional Description section for input/output assignment)
    }

    /// SEL53 Register bits
    namespace sel53_bits {
        constexpr uint32_t SEL106 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT106 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL107 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT107 (refer to Functional Description section for input/output assignment)
    }

    /// SEL54 Register bits
    namespace sel54_bits {
        constexpr uint32_t SEL108 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT108 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL109 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT109 (refer to Functional Description section for input/output assignment)
    }

    /// SEL55 Register bits
    namespace sel55_bits {
        constexpr uint32_t SEL110 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT110 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL111 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT111 (refer to Functional Description section for input/output assignment)
    }

    /// SEL56 Register bits
    namespace sel56_bits {
        constexpr uint32_t SEL112 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT112 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL113 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT113 (refer to Functional Description section for input/output assignment)
    }

    /// SEL57 Register bits
    namespace sel57_bits {
        constexpr uint32_t SEL114 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT114 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL115 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT115 (refer to Functional Description section for input/output assignment)
    }

    /// SEL58 Register bits
    namespace sel58_bits {
        constexpr uint32_t SEL116 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT116 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL117 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT117 (refer to Functional Description section for input/output assignment)
    }

    /// SEL59 Register bits
    namespace sel59_bits {
        constexpr uint32_t SEL118 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT118 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL119 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT119 (refer to Functional Description section for input/output assignment)
    }

    /// SEL60 Register bits
    namespace sel60_bits {
        constexpr uint32_t SEL120 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT120 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL121 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT121 (refer to Functional Description section for input/output assignment)
    }

    /// SEL61 Register bits
    namespace sel61_bits {
        constexpr uint32_t SEL122 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT122 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL123 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT123 (refer to Functional Description section for input/output assignment)
    }

    /// SEL62 Register bits
    namespace sel62_bits {
        constexpr uint32_t SEL124 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT124 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL125 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT125 (refer to Functional Description section for input/output assignment)
    }

    /// SEL63 Register bits
    namespace sel63_bits {
        constexpr uint32_t SEL126 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT126 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL127 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT127 (refer to Functional Description section for input/output assignment)
    }

    /// SEL64 Register bits
    namespace sel64_bits {
        constexpr uint32_t SEL128 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT128 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL129 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT129 (refer to Functional Description section for input/output assignment)
    }

    /// SEL65 Register bits
    namespace sel65_bits {
        constexpr uint32_t SEL130 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT130 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL131 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT131 (refer to Functional Description section for input/output assignment)
    }

    /// CTRL0 Register bits
    namespace ctrl0_bits {
        constexpr uint32_t DEN0 = (1U << 0);  ///< DMA Enable for XBAR_OUT0
        constexpr uint32_t IEN0 = (1U << 1);  ///< Interrupt Enable for XBAR_OUT0
        constexpr uint32_t EDGE0 = (2 << 2);  ///< Active edge for edge detection on XBAR_OUT0
        constexpr uint32_t STS0 = (1U << 4);  ///< Edge detection status for XBAR_OUT0
        constexpr uint32_t DEN1 = (1U << 8);  ///< DMA Enable for XBAR_OUT1
        constexpr uint32_t IEN1 = (1U << 9);  ///< Interrupt Enable for XBAR_OUT1
        constexpr uint32_t EDGE1 = (2 << 10);  ///< Active edge for edge detection on XBAR_OUT1
        constexpr uint32_t STS1 = (1U << 12);  ///< Edge detection status for XBAR_OUT1
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t DEN2 = (1U << 0);  ///< DMA Enable for XBAR_OUT2
        constexpr uint32_t IEN2 = (1U << 1);  ///< Interrupt Enable for XBAR_OUT2
        constexpr uint32_t EDGE2 = (2 << 2);  ///< Active edge for edge detection on XBAR_OUT2
        constexpr uint32_t STS2 = (1U << 4);  ///< Edge detection status for XBAR_OUT2
        constexpr uint32_t DEN3 = (1U << 8);  ///< DMA Enable for XBAR_OUT3
        constexpr uint32_t IEN3 = (1U << 9);  ///< Interrupt Enable for XBAR_OUT3
        constexpr uint32_t EDGE3 = (2 << 10);  ///< Active edge for edge detection on XBAR_OUT3
        constexpr uint32_t STS3 = (1U << 12);  ///< Edge detection status for XBAR_OUT3
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t FLEXSPI_BASE = 0x400A0000;
    constexpr uint32_t LPSPI1_BASE = 0x40194000;
    constexpr uint32_t LPSPI2_BASE = 0x40198000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t MCR0;  ///< Offset: 0x00 - Module Control Register 0
        volatile uint32_t MCR1;  ///< Offset: 0x04 - Module Control Register 1
        volatile uint32_t MCR2;  ///< Offset: 0x08 - Module Control Register 2
        volatile uint32_t AHBCR;  ///< Offset: 0x0C - AHB Bus Control Register
        volatile uint32_t INTEN;  ///< Offset: 0x10 - Interrupt Enable Register
        volatile uint32_t INTR;  ///< Offset: 0x14 - Interrupt Register
        volatile uint32_t LUTKEY;  ///< Offset: 0x18 - LUT Key Register
        volatile uint32_t LUTCR;  ///< Offset: 0x1C - LUT Control Register
        volatile uint32_t AHBRXBUF0CR0;  ///< Offset: 0x20 - AHB RX Buffer 0 Control Register 0
        volatile uint32_t AHBRXBUF1CR0;  ///< Offset: 0x24 - AHB RX Buffer 1 Control Register 0
        volatile uint32_t AHBRXBUF2CR0;  ///< Offset: 0x28 - AHB RX Buffer 2 Control Register 0
        volatile uint32_t AHBRXBUF3CR0;  ///< Offset: 0x2C - AHB RX Buffer 3 Control Register 0
        volatile uint32_t FLSHA1CR0;  ///< Offset: 0x60 - Flash Control Register 0
        volatile uint32_t FLSHA2CR0;  ///< Offset: 0x64 - Flash Control Register 0
        volatile uint32_t FLSHB1CR0;  ///< Offset: 0x68 - Flash Control Register 0
        volatile uint32_t FLSHB2CR0;  ///< Offset: 0x6C - Flash Control Register 0
        volatile uint32_t FLSHCR1%s;  ///< Offset: 0x70 - Flash Control Register 1
        volatile uint32_t FLSHCR2%s;  ///< Offset: 0x80 - Flash Control Register 2
        volatile uint32_t FLSHCR4;  ///< Offset: 0x94 - Flash Control Register 4
        volatile uint32_t IPCR0;  ///< Offset: 0xA0 - IP Control Register 0
        volatile uint32_t IPCR1;  ///< Offset: 0xA4 - IP Control Register 1
        volatile uint32_t IPCMD;  ///< Offset: 0xB0 - IP Command Register
        volatile uint32_t IPRXFCR;  ///< Offset: 0xB8 - IP RX FIFO Control Register
        volatile uint32_t IPTXFCR;  ///< Offset: 0xBC - IP TX FIFO Control Register
        volatile uint32_t DLLCR%s;  ///< Offset: 0xC0 - DLL Control Register 0
        volatile uint32_t STS0;  ///< Offset: 0xE0 - Status Register 0
        volatile uint32_t STS1;  ///< Offset: 0xE4 - Status Register 1
        volatile uint32_t STS2;  ///< Offset: 0xE8 - Status Register 2
        volatile uint32_t AHBSPNDSTS;  ///< Offset: 0xEC - AHB Suspend Status Register
        volatile uint32_t IPRXFSTS;  ///< Offset: 0xF0 - IP RX FIFO Status Register
        volatile uint32_t IPTXFSTS;  ///< Offset: 0xF4 - IP TX FIFO Status Register
        volatile uint32_t RFDR[%s];  ///< Offset: 0x100 - IP RX FIFO Data Register 0
        volatile uint32_t TFDR[%s];  ///< Offset: 0x180 - IP TX FIFO Data Register 0
        volatile uint32_t LUT[%s];  ///< Offset: 0x200 - LUT 0
    };

    /// Peripheral instances
    inline Registers* FLEXSPI = reinterpret_cast<Registers*>(FLEXSPI_BASE);
    inline Registers* LPSPI1 = reinterpret_cast<Registers*>(LPSPI1_BASE);
    inline Registers* LPSPI2 = reinterpret_cast<Registers*>(LPSPI2_BASE);

    // Bit definitions
    /// MCR0 Register bits
    namespace mcr0_bits {
        constexpr uint32_t SWRESET = (1U << 0);  ///< Software Reset
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable
        constexpr uint32_t RXCLKSRC = (2 << 4);  ///< Sample Clock source selection for Flash Reading
        constexpr uint32_t ARDFEN = (1U << 6);  ///< Enable AHB bus Read Access to IP RX FIFO.
        constexpr uint32_t ATDFEN = (1U << 7);  ///< Enable AHB bus Write Access to IP TX FIFO.
        constexpr uint32_t SERCLKDIV = (3 << 8);  ///< The serial root clock could be divided inside FlexSPI . Refer Clocks chapter for more details on clocking.
        constexpr uint32_t HSEN = (1U << 11);  ///< Half Speed Serial Flash access Enable.
        constexpr uint32_t DOZEEN = (1U << 12);  ///< Doze mode enable bit
        constexpr uint32_t COMBINATIONEN = (1U << 13);  ///< This bit is to support Flash Octal mode access by combining Port A and B Data pins (A_DATA[3:0] and B_DATA[3:0]).
        constexpr uint32_t SCKFREERUNEN = (1U << 14);  ///< This bit is used to force SCLK output free-running. For FPGA applications, external device may use SCLK as reference clock to its internal PLL. If SCLK free-running is enabled, data sampling with loopback clock from SCLK pad is not supported (MCR0[RXCLKSRC]=2).
        constexpr uint32_t IPGRANTWAIT = (8 << 16);  ///< Time out wait cycle for IP command grant.
        constexpr uint32_t AHBGRANTWAIT = (8 << 24);  ///< Timeout wait cycle for AHB command grant.
    }

    /// MCR1 Register bits
    namespace mcr1_bits {
        constexpr uint32_t AHBBUSWAIT = (16 << 0);  ///< AHB Read/Write access to Serial Flash Memory space will timeout if not data received from Flash or data not transmitted after AHBBUSWAIT * 1024 ahb clock cycles, AHB Bus will get an error response
        constexpr uint32_t SEQWAIT = (16 << 16);  ///< Command Sequence Execution will timeout and abort after SEQWAIT * 1024 Serial Root Clock cycles
    }

    /// MCR2 Register bits
    namespace mcr2_bits {
        constexpr uint32_t CLRAHBBUFOPT = (1U << 11);  ///< This bit determines whether AHB RX Buffer and AHB TX Buffer will be cleaned automatically when FlexSPI returns STOP mode ACK. Software should set this bit if AHB RX Buffer or AHB TX Buffer will be powered off in STOP mode. Otherwise AHB read access after exiting STOP mode may hit AHB RX Buffer or AHB TX Buffer but their data entries are invalid.
        constexpr uint32_t CLRLEARNPHASE = (1U << 14);  ///< The sampling clock phase selection will be reset to phase 0 when this bit is written with 0x1. This bit will be auto-cleared immediately.
        constexpr uint32_t SAMEDEVICEEN = (1U << 15);  ///< All external devices are same devices (both in types and size) for A1/A2/B1/B2.
        constexpr uint32_t SCKBDIFFOPT = (1U << 19);  ///< B_SCLK pad can be used as A_SCLK differential clock output (inverted clock to A_SCLK). In this case, port B flash access is not available. After changing the value of this field, MCR0[SWRESET] should be set.
        constexpr uint32_t RESUMEWAIT = (8 << 24);  ///< Wait cycle (in AHB clock cycle) for idle state before suspended command sequence resumed.
    }

    /// AHBCR Register bits
    namespace ahbcr_bits {
        constexpr uint32_t APAREN = (1U << 0);  ///< Parallel mode enabled for AHB triggered Command (both read and write) .
        constexpr uint32_t CLRAHBRXBUF = (1U << 1);  ///< Clear the status/pointers of AHB RX Buffer. Auto-cleared.
        constexpr uint32_t CLRAHBTXBUF = (1U << 2);  ///< Clear the status/pointers of AHB TX Buffer. Auto-cleared.
        constexpr uint32_t CACHABLEEN = (1U << 3);  ///< Enable AHB bus cachable read access support.
        constexpr uint32_t BUFFERABLEEN = (1U << 4);  ///< Enable AHB bus bufferable write access support. This field affects the last beat of AHB write access, refer for more details about AHB bufferable write.
        constexpr uint32_t PREFETCHEN = (1U << 5);  ///< AHB Read Prefetch Enable.
        constexpr uint32_t READADDROPT = (1U << 6);  ///< AHB Read Address option bit. This option bit is intend to remove AHB burst start address alignment limitation.
        constexpr uint32_t READSZALIGN = (1U << 10);  ///< AHB Read Size Alignment
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t IPCMDDONEEN = (1U << 0);  ///< IP triggered Command Sequences Execution finished interrupt enable.
        constexpr uint32_t IPCMDGEEN = (1U << 1);  ///< IP triggered Command Sequences Grant Timeout interrupt enable.
        constexpr uint32_t AHBCMDGEEN = (1U << 2);  ///< AHB triggered Command Sequences Grant Timeout interrupt enable.
        constexpr uint32_t IPCMDERREN = (1U << 3);  ///< IP triggered Command Sequences Error Detected interrupt enable.
        constexpr uint32_t AHBCMDERREN = (1U << 4);  ///< AHB triggered Command Sequences Error Detected interrupt enable.
        constexpr uint32_t IPRXWAEN = (1U << 5);  ///< IP RX FIFO WaterMark available interrupt enable.
        constexpr uint32_t IPTXWEEN = (1U << 6);  ///< IP TX FIFO WaterMark empty interrupt enable.
        constexpr uint32_t SCKSTOPBYRDEN = (1U << 8);  ///< SCLK is stopped during command sequence because Async RX FIFO full interrupt enable.
        constexpr uint32_t SCKSTOPBYWREN = (1U << 9);  ///< SCLK is stopped during command sequence because Async TX FIFO empty interrupt enable.
        constexpr uint32_t AHBBUSERROREN = (1U << 10);  ///< AHB Bus error interrupt enable.Refer Interrupts chapter for more details.
        constexpr uint32_t SEQTIMEOUTEN = (1U << 11);  ///< Sequence execution timeout interrupt enable.Refer Interrupts chapter for more details.
        constexpr uint32_t KEYDONEEN = (1U << 12);  ///< OTFAD key blob processing done interrupt enable.Refer Interrupts chapter for more details.
        constexpr uint32_t KEYERROREN = (1U << 13);  ///< OTFAD key blob processing error interrupt enable.Refer Interrupts chapter for more details.
    }

    /// INTR Register bits
    namespace intr_bits {
        constexpr uint32_t IPCMDDONE = (1U << 0);  ///< IP triggered Command Sequences Execution finished interrupt. This interrupt is also generated when there is IPCMDGE or IPCMDERR interrupt generated.
        constexpr uint32_t IPCMDGE = (1U << 1);  ///< IP triggered Command Sequences Grant Timeout interrupt.
        constexpr uint32_t AHBCMDGE = (1U << 2);  ///< AHB triggered Command Sequences Grant Timeout interrupt.
        constexpr uint32_t IPCMDERR = (1U << 3);  ///< IP triggered Command Sequences Error Detected interrupt. When an error detected for IP command, this command will be ignored and not executed at all.
        constexpr uint32_t AHBCMDERR = (1U << 4);  ///< AHB triggered Command Sequences Error Detected interrupt. When an error detected for AHB command, this command will be ignored and not executed at all.
        constexpr uint32_t IPRXWA = (1U << 5);  ///< IP RX FIFO watermark available interrupt.
        constexpr uint32_t IPTXWE = (1U << 6);  ///< IP TX FIFO watermark empty interrupt.
        constexpr uint32_t SCKSTOPBYRD = (1U << 8);  ///< SCLK is stopped during command sequence because Async RX FIFO full interrupt.
        constexpr uint32_t SCKSTOPBYWR = (1U << 9);  ///< SCLK is stopped during command sequence because Async TX FIFO empty interrupt.
        constexpr uint32_t AHBBUSERROR = (1U << 10);  ///< AHB Bus timeout or AHB bus illegal access Flash during OTFAD key blob processing interrupt.
        constexpr uint32_t SEQTIMEOUT = (1U << 11);  ///< Sequence execution timeout interrupt.
        constexpr uint32_t KEYDONE = (1U << 12);  ///< OTFAD key blob processing done interrupt.
        constexpr uint32_t KEYERROR = (1U << 13);  ///< OTFAD key blob processing error interrupt.
    }

    /// LUTKEY Register bits
    namespace lutkey_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< The Key to lock or unlock LUT.
    }

    /// LUTCR Register bits
    namespace lutcr_bits {
        constexpr uint32_t LOCK = (1U << 0);  ///< Lock LUT
        constexpr uint32_t UNLOCK = (1U << 1);  ///< Unlock LUT
    }

    /// AHBRXBUF0CR0 Register bits
    namespace ahbrxbuf0cr0_bits {
        constexpr uint32_t BUFSZ = (8 << 0);  ///< AHB RX Buffer Size in 64 bits.
        constexpr uint32_t MSTRID = (4 << 16);  ///< This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID).
        constexpr uint32_t PRIORITY = (2 << 24);  ///< This priority for AHB Master Read which this AHB RX Buffer is assigned. 7 is the highest priority, 0 the lowest.
        constexpr uint32_t PREFETCHEN = (1U << 31);  ///< AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
    }

    /// AHBRXBUF1CR0 Register bits
    namespace ahbrxbuf1cr0_bits {
        constexpr uint32_t BUFSZ = (8 << 0);  ///< AHB RX Buffer Size in 64 bits.
        constexpr uint32_t MSTRID = (4 << 16);  ///< This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID).
        constexpr uint32_t PRIORITY = (2 << 24);  ///< This priority for AHB Master Read which this AHB RX Buffer is assigned. 7 is the highest priority, 0 the lowest.
        constexpr uint32_t PREFETCHEN = (1U << 31);  ///< AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
    }

    /// AHBRXBUF2CR0 Register bits
    namespace ahbrxbuf2cr0_bits {
        constexpr uint32_t BUFSZ = (8 << 0);  ///< AHB RX Buffer Size in 64 bits.
        constexpr uint32_t MSTRID = (4 << 16);  ///< This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID).
        constexpr uint32_t PRIORITY = (2 << 24);  ///< This priority for AHB Master Read which this AHB RX Buffer is assigned. 7 is the highest priority, 0 the lowest.
        constexpr uint32_t PREFETCHEN = (1U << 31);  ///< AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
    }

    /// AHBRXBUF3CR0 Register bits
    namespace ahbrxbuf3cr0_bits {
        constexpr uint32_t BUFSZ = (8 << 0);  ///< AHB RX Buffer Size in 64 bits.
        constexpr uint32_t MSTRID = (4 << 16);  ///< This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID).
        constexpr uint32_t PRIORITY = (2 << 24);  ///< This priority for AHB Master Read which this AHB RX Buffer is assigned. 7 is the highest priority, 0 the lowest.
        constexpr uint32_t PREFETCHEN = (1U << 31);  ///< AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
    }

    /// FLSHA1CR0 Register bits
    namespace flsha1cr0_bits {
        constexpr uint32_t FLSHSZ = (23 << 0);  ///< Flash Size in KByte.
    }

    /// FLSHA2CR0 Register bits
    namespace flsha2cr0_bits {
        constexpr uint32_t FLSHSZ = (23 << 0);  ///< Flash Size in KByte.
    }

    /// FLSHB1CR0 Register bits
    namespace flshb1cr0_bits {
        constexpr uint32_t FLSHSZ = (23 << 0);  ///< Flash Size in KByte.
    }

    /// FLSHB2CR0 Register bits
    namespace flshb2cr0_bits {
        constexpr uint32_t FLSHSZ = (23 << 0);  ///< Flash Size in KByte.
    }

    /// FLSHCR1%s Register bits
    namespace flshcr1%s_bits {
        constexpr uint32_t TCSS = (5 << 0);  ///< Serial Flash CS setup time.
        constexpr uint32_t TCSH = (5 << 5);  ///< Serial Flash CS Hold time.
        constexpr uint32_t WA = (1U << 10);  ///< Word Addressable.
        constexpr uint32_t CAS = (4 << 11);  ///< Column Address Size.
        constexpr uint32_t CSINTERVALUNIT = (1U << 15);  ///< CS interval unit
        constexpr uint32_t CSINTERVAL = (16 << 16);  ///< This field is used to set the minimum interval between flash device Chip selection deassertion and flash device Chip selection assertion. If external flash has a limitation on the interval between command sequences, this field should be set accordingly. If there is no limitation, set this field with value 0x0.
    }

    /// FLSHCR2%s Register bits
    namespace flshcr2%s_bits {
        constexpr uint32_t ARDSEQID = (4 << 0);  ///< Sequence Index for AHB Read triggered Command in LUT.
        constexpr uint32_t ARDSEQNUM = (3 << 5);  ///< Sequence Number for AHB Read triggered Command in LUT.
        constexpr uint32_t AWRSEQID = (4 << 8);  ///< Sequence Index for AHB Write triggered Command.
        constexpr uint32_t AWRSEQNUM = (3 << 13);  ///< Sequence Number for AHB Write triggered Command.
        constexpr uint32_t AWRWAIT = (12 << 16);  ///< For certain devices (such as FPGA), it need some time to write data into internal memory after the command sequences finished on FlexSPI interface
        constexpr uint32_t AWRWAITUNIT = (3 << 28);  ///< AWRWAIT unit
        constexpr uint32_t CLRINSTRPTR = (1U << 31);  ///< Clear the instruction pointer which is internally saved pointer by JMP_ON_CS. Refer Programmable Sequence Engine for details.
    }

    /// FLSHCR4 Register bits
    namespace flshcr4_bits {
        constexpr uint32_t WMOPT1 = (1U << 0);  ///< Write mask option bit 1. This option bit could be used to remove AHB write burst start address alignment limitation.
        constexpr uint32_t WMENA = (1U << 2);  ///< Write mask enable bit for flash device on port A. When write mask function is needed for memory device on port A, this bit must be set.
        constexpr uint32_t WMENB = (1U << 3);  ///< Write mask enable bit for flash device on port B. When write mask function is needed for memory device on port B, this bit must be set.
    }

    /// IPCR0 Register bits
    namespace ipcr0_bits {
        constexpr uint32_t SFAR = (32 << 0);  ///< Serial Flash Address for IP command.
    }

    /// IPCR1 Register bits
    namespace ipcr1_bits {
        constexpr uint32_t IDATSZ = (16 << 0);  ///< Flash Read/Program Data Size (in Bytes) for IP command.
        constexpr uint32_t ISEQID = (4 << 16);  ///< Sequence Index in LUT for IP command.
        constexpr uint32_t ISEQNUM = (3 << 24);  ///< Sequence Number for IP command: ISEQNUM+1.
        constexpr uint32_t IPAREN = (1U << 31);  ///< Parallel mode Enabled for IP command.
    }

    /// IPCMD Register bits
    namespace ipcmd_bits {
        constexpr uint32_t TRG = (1U << 0);  ///< Setting this bit will trigger an IP Command.
    }

    /// IPRXFCR Register bits
    namespace iprxfcr_bits {
        constexpr uint32_t CLRIPRXF = (1U << 0);  ///< Clear all valid data entries in IP RX FIFO.
        constexpr uint32_t RXDMAEN = (1U << 1);  ///< IP RX FIFO reading by DMA enabled.
        constexpr uint32_t RXWMRK = (4 << 2);  ///< Watermark level is (RXWMRK+1)*64 Bits.
    }

    /// IPTXFCR Register bits
    namespace iptxfcr_bits {
        constexpr uint32_t CLRIPTXF = (1U << 0);  ///< Clear all valid data entries in IP TX FIFO.
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< IP TX FIFO filling by DMA enabled.
        constexpr uint32_t TXWMRK = (4 << 2);  ///< Watermark level is (TXWMRK+1)*64 Bits.
    }

    /// DLLCR%s Register bits
    namespace dllcr%s_bits {
        constexpr uint32_t DLLEN = (1U << 0);  ///< DLL calibration enable.
        constexpr uint32_t DLLRESET = (1U << 1);  ///< Software could force a reset on DLL by setting this field to 0x1. This will cause the DLL to lose lock and re-calibrate to detect an ref_clock half period phase shift. The reset action is edge triggered, so software need to clear this bit after set this bit (no delay limitation).
        constexpr uint32_t SLVDLYTARGET = (4 << 3);  ///< The delay target for slave delay line is: ((SLVDLYTARGET+1) * 1/32 * clock cycle of reference clock (serial root clock). If serial root clock is >= 100 MHz, DLLEN set to 0x1, OVRDEN set to =0x0, then SLVDLYTARGET setting of 0xF is recommended.
        constexpr uint32_t OVRDEN = (1U << 8);  ///< Slave clock delay line delay cell number selection override enable.
        constexpr uint32_t OVRDVAL = (6 << 9);  ///< Slave clock delay line delay cell number selection override value.
    }

    /// STS0 Register bits
    namespace sts0_bits {
        constexpr uint32_t SEQIDLE = (1U << 0);  ///< This status bit indicates the state machine in SEQ_CTL is idle and there is command sequence executing on FlexSPI interface.
        constexpr uint32_t ARBIDLE = (1U << 1);  ///< This status bit indicates the state machine in ARB_CTL is busy and there is command sequence granted by arbitrator and not finished yet on FlexSPI interface. When ARB_CTL state (ARBIDLE=0x1) is idle, there will be no transaction on FlexSPI interface also (SEQIDLE=0x1). So this bit should be polled to wait for FlexSPI controller become idle instead of SEQIDLE.
        constexpr uint32_t ARBCMDSRC = (2 << 2);  ///< This status field indicates the trigger source of current command sequence granted by arbitrator. This field value is meaningless when ARB_CTL is not busy (STS0[ARBIDLE]=0x1).
    }

    /// STS1 Register bits
    namespace sts1_bits {
        constexpr uint32_t AHBCMDERRID = (4 << 0);  ///< Indicates the sequence index when an AHB command error is detected. This field will be cleared when INTR[AHBCMDERR] is write-1-clear(w1c).
        constexpr uint32_t AHBCMDERRCODE = (4 << 8);  ///< Indicates the Error Code when AHB command Error detected. This field will be cleared when INTR[AHBCMDERR] is write-1-clear(w1c).
        constexpr uint32_t IPCMDERRID = (4 << 16);  ///< Indicates the sequence Index when IP command error detected. This field will be cleared when INTR[IPCMDERR] is write-1-clear(w1c).
        constexpr uint32_t IPCMDERRCODE = (4 << 24);  ///< Indicates the Error Code when IP command Error detected. This field will be cleared when INTR[IPCMDERR] is write-1-clear(w1c).
    }

    /// STS2 Register bits
    namespace sts2_bits {
        constexpr uint32_t ASLVLOCK = (1U << 0);  ///< Flash A sample clock slave delay line locked.
        constexpr uint32_t AREFLOCK = (1U << 1);  ///< Flash A sample clock reference delay line locked.
        constexpr uint32_t ASLVSEL = (6 << 2);  ///< Flash A sample clock slave delay line delay cell number selection .
        constexpr uint32_t AREFSEL = (6 << 8);  ///< Flash A sample clock reference delay line delay cell number selection.
        constexpr uint32_t BSLVLOCK = (1U << 16);  ///< Flash B sample clock slave delay line locked.
        constexpr uint32_t BREFLOCK = (1U << 17);  ///< Flash B sample clock reference delay line locked.
        constexpr uint32_t BSLVSEL = (6 << 18);  ///< Flash B sample clock slave delay line delay cell number selection.
        constexpr uint32_t BREFSEL = (6 << 24);  ///< Flash B sample clock reference delay line delay cell number selection.
    }

    /// AHBSPNDSTS Register bits
    namespace ahbspndsts_bits {
        constexpr uint32_t ACTIVE = (1U << 0);  ///< Indicates if an AHB read prefetch command sequence has been suspended.
        constexpr uint32_t BUFID = (3 << 1);  ///< AHB RX BUF ID for suspended command sequence.
        constexpr uint32_t DATLFT = (16 << 16);  ///< Left Data size for suspended command sequence (in byte).
    }

    /// IPRXFSTS Register bits
    namespace iprxfsts_bits {
        constexpr uint32_t FILL = (8 << 0);  ///< Fill level of IP RX FIFO.
        constexpr uint32_t RDCNTR = (16 << 16);  ///< Total Read Data Counter: RDCNTR * 64 Bits.
    }

    /// IPTXFSTS Register bits
    namespace iptxfsts_bits {
        constexpr uint32_t FILL = (8 << 0);  ///< Fill level of IP TX FIFO.
        constexpr uint32_t WRCNTR = (16 << 16);  ///< Total Write Data Counter: WRCNTR * 64 Bits.
    }

    /// RFDR[%s] Register bits
    namespace rfdr[%s]_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< RX Data
    }

    /// TFDR[%s] Register bits
    namespace tfdr[%s]_bits {
        constexpr uint32_t TXDATA = (32 << 0);  ///< TX Data
    }

    /// LUT[%s] Register bits
    namespace lut[%s]_bits {
        constexpr uint32_t OPERAND0 = (8 << 0);  ///< OPERAND0
        constexpr uint32_t NUM_PADS0 = (2 << 8);  ///< NUM_PADS0
        constexpr uint32_t OPCODE0 = (6 << 10);  ///< OPCODE
        constexpr uint32_t OPERAND1 = (8 << 16);  ///< OPERAND1
        constexpr uint32_t NUM_PADS1 = (2 << 24);  ///< NUM_PADS1
        constexpr uint32_t OPCODE1 = (6 << 26);  ///< OPCODE1
    }

}

// ============================================================================
// OTFAD Peripheral
// ============================================================================

namespace otfad {
    /// Base addresses
    constexpr uint32_t OTFAD_BASE = 0x400A0000;

    /// OTFAD Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0xC00 - Control Register
        volatile uint32_t SR;  ///< Offset: 0xC04 - Status Register
        volatile uint32_t CTX_KEY%s;  ///< Offset: 0x00 - AES Key Word
        volatile uint32_t CTX_CTR%s;  ///< Offset: 0x10 - AES Counter Word
        volatile uint32_t CTX_RGD_W0;  ///< Offset: 0x18 - AES Region Descriptor Word0
        volatile uint32_t CTX_RGD_W1;  ///< Offset: 0x1C - AES Region Descriptor Word1
    };

    /// Peripheral instances
    inline Registers* OTFAD = reinterpret_cast<Registers*>(OTFAD_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t IRQE = (1U << 0);  ///< IRQE
        constexpr uint32_t FERR = (1U << 1);  ///< Force Error
        constexpr uint32_t FSVM = (1U << 2);  ///< Force Security Violation Mode
        constexpr uint32_t FLDM = (1U << 3);  ///< Force Logically Disabled Mode
        constexpr uint32_t KBSE = (1U << 4);  ///< Key Blob Scramble Enable
        constexpr uint32_t KBPE = (1U << 5);  ///< Key Blob Processing Enable
        constexpr uint32_t KBCE = (1U << 6);  ///< Key Blob CRC Enable
        constexpr uint32_t RRAE = (1U << 7);  ///< Restricted Register Access Enable
        constexpr uint32_t SKBP = (1U << 30);  ///< Start key blob processing
        constexpr uint32_t GE = (1U << 31);  ///< Global OTFAD Enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t KBERR = (1U << 0);  ///< Key Blob Error
        constexpr uint32_t MDPCP = (1U << 1);  ///< MDPC Present
        constexpr uint32_t MODE = (2 << 2);  ///< Operating Mode
        constexpr uint32_t NCTX = (4 << 4);  ///< Number of Contexts
        constexpr uint32_t CTXER0 = (1U << 8);  ///< Context Error
        constexpr uint32_t CTXER1 = (1U << 9);  ///< Context Error
        constexpr uint32_t CTXER2 = (1U << 10);  ///< Context Error
        constexpr uint32_t CTXER3 = (1U << 11);  ///< Context Error
        constexpr uint32_t CTXIE0 = (1U << 16);  ///< Context Integrity Error
        constexpr uint32_t CTXIE1 = (1U << 17);  ///< Context Integrity Error
        constexpr uint32_t CTXIE2 = (1U << 18);  ///< Context Integrity Error
        constexpr uint32_t CTXIE3 = (1U << 19);  ///< Context Integrity Error
        constexpr uint32_t HRL = (4 << 24);  ///< Hardware Revision Level
        constexpr uint32_t RRAM = (1U << 28);  ///< Restricted Register Access Mode
        constexpr uint32_t GEM = (1U << 29);  ///< Global Enable Mode
        constexpr uint32_t KBPE = (1U << 30);  ///< Key Blob Processing Enable
        constexpr uint32_t KBD = (1U << 31);  ///< Key Blob Processing Done
    }

    /// CTX_KEY%s Register bits
    namespace ctx_key%s_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< AES Key
    }

    /// CTX_CTR%s Register bits
    namespace ctx_ctr%s_bits {
        constexpr uint32_t CTR = (32 << 0);  ///< AES Counter
    }

    /// CTX_RGD_W0 Register bits
    namespace ctx_rgd_w0_bits {
        constexpr uint32_t SRTADDR = (22 << 10);  ///< Start Address
    }

    /// CTX_RGD_W1 Register bits
    namespace ctx_rgd_w1_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t ADE = (1U << 1);  ///< AES Decryption Enable.
        constexpr uint32_t RO = (1U << 2);  ///< Read-Only
        constexpr uint32_t ENDADDR = (22 << 10);  ///< End Address
    }

}

// ============================================================================
// IOMUXC Peripheral
// ============================================================================

namespace iomuxc {
    /// Base addresses
    constexpr uint32_t IOMUXC_SNVS_GPR_BASE = 0x400A4000;
    constexpr uint32_t IOMUXC_SNVS_BASE = 0x400A8000;
    constexpr uint32_t IOMUXC_GPR_BASE = 0x400AC000;
    constexpr uint32_t IOMUXC_BASE = 0x401F8000;

    /// IOMUXC Register structure
    struct Registers {
        volatile uint32_t GPR0;  ///< Offset: 0x00 - GPR0 General Purpose Register
        volatile uint32_t GPR1;  ///< Offset: 0x04 - GPR1 General Purpose Register
        volatile uint32_t GPR2;  ///< Offset: 0x08 - GPR2 General Purpose Register
        volatile uint32_t GPR3;  ///< Offset: 0x0C - GPR3 General Purpose Register
    };

    /// Peripheral instances
    inline Registers* IOMUXC_SNVS_GPR = reinterpret_cast<Registers*>(IOMUXC_SNVS_GPR_BASE);
    inline Registers* IOMUXC_SNVS = reinterpret_cast<Registers*>(IOMUXC_SNVS_BASE);
    inline Registers* IOMUXC_GPR = reinterpret_cast<Registers*>(IOMUXC_GPR_BASE);
    inline Registers* IOMUXC = reinterpret_cast<Registers*>(IOMUXC_BASE);

    // Bit definitions
    /// GPR3 Register bits
    namespace gpr3_bits {
        constexpr uint32_t LPSR_MODE_ENABLE = (1U << 0);  ///< Set to enable LPSR mode.
        constexpr uint32_t DCDC_STATUS_CAPT_CLR = (1U << 1);  ///< DCDC captured status clear
        constexpr uint32_t POR_PULL_TYPE = (2 << 2);  ///< POR_B pad control
        constexpr uint32_t DCDC_IN_LOW_VOL = (1U << 16);  ///< DCDC_IN low voltage detect.
        constexpr uint32_t DCDC_OVER_CUR = (1U << 17);  ///< DCDC output over current alert
        constexpr uint32_t DCDC_OVER_VOL = (1U << 18);  ///< DCDC output over voltage alert
        constexpr uint32_t DCDC_STS_DC_OK = (1U << 19);  ///< DCDC status OK
    }

}

// ============================================================================
// FLEXRAM Peripheral
// ============================================================================

namespace flexram {
    /// Base addresses
    constexpr uint32_t FLEXRAM_BASE = 0x400B0000;

    /// FLEXRAM Register structure
    struct Registers {
        volatile uint32_t TCM_CTRL;  ///< Offset: 0x00 - TCM CRTL Register
        volatile uint32_t OCRAM_MAGIC_ADDR;  ///< Offset: 0x04 - OCRAM Magic Address Register
        volatile uint32_t DTCM_MAGIC_ADDR;  ///< Offset: 0x08 - DTCM Magic Address Register
        volatile uint32_t ITCM_MAGIC_ADDR;  ///< Offset: 0x0C - ITCM Magic Address Register
        volatile uint32_t INT_STATUS;  ///< Offset: 0x10 - Interrupt Status Register
        volatile uint32_t INT_STAT_EN;  ///< Offset: 0x14 - Interrupt Status Enable Register
        volatile uint32_t INT_SIG_EN;  ///< Offset: 0x18 - Interrupt Enable Register
    };

    /// Peripheral instances
    inline Registers* FLEXRAM = reinterpret_cast<Registers*>(FLEXRAM_BASE);

    // Bit definitions
    /// TCM_CTRL Register bits
    namespace tcm_ctrl_bits {
        constexpr uint32_t TCM_WWAIT_EN = (1U << 0);  ///< TCM Write Wait Mode Enable
        constexpr uint32_t TCM_RWAIT_EN = (1U << 1);  ///< TCM Read Wait Mode Enable
        constexpr uint32_t FORCE_CLK_ON = (1U << 2);  ///< Force RAM Clock Always On
    }

    /// OCRAM_MAGIC_ADDR Register bits
    namespace ocram_magic_addr_bits {
        constexpr uint32_t OCRAM_WR_RD_SEL = (1U << 0);  ///< OCRAM Write Read Select
        constexpr uint32_t OCRAM_MAGIC_ADDR = (14 << 1);  ///< OCRAM Magic Address
    }

    /// DTCM_MAGIC_ADDR Register bits
    namespace dtcm_magic_addr_bits {
        constexpr uint32_t DTCM_WR_RD_SEL = (1U << 0);  ///< DTCM Write Read Select
        constexpr uint32_t DTCM_MAGIC_ADDR = (14 << 1);  ///< DTCM Magic Address
    }

    /// ITCM_MAGIC_ADDR Register bits
    namespace itcm_magic_addr_bits {
        constexpr uint32_t ITCM_WR_RD_SEL = (1U << 0);  ///< ITCM Write Read Select
        constexpr uint32_t ITCM_MAGIC_ADDR = (14 << 1);  ///< ITCM Magic Address
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t ITCM_MAM_STATUS = (1U << 0);  ///< ITCM Magic Address Match Status
        constexpr uint32_t DTCM_MAM_STATUS = (1U << 1);  ///< DTCM Magic Address Match Status
        constexpr uint32_t OCRAM_MAM_STATUS = (1U << 2);  ///< OCRAM Magic Address Match Status
        constexpr uint32_t ITCM_ERR_STATUS = (1U << 3);  ///< ITCM Access Error Status
        constexpr uint32_t DTCM_ERR_STATUS = (1U << 4);  ///< DTCM Access Error Status
        constexpr uint32_t OCRAM_ERR_STATUS = (1U << 5);  ///< OCRAM Access Error Status
    }

    /// INT_STAT_EN Register bits
    namespace int_stat_en_bits {
        constexpr uint32_t ITCM_MAM_STAT_EN = (1U << 0);  ///< ITCM Magic Address Match Status Enable
        constexpr uint32_t DTCM_MAM_STAT_EN = (1U << 1);  ///< DTCM Magic Address Match Status Enable
        constexpr uint32_t OCRAM_MAM_STAT_EN = (1U << 2);  ///< OCRAM Magic Address Match Status Enable
        constexpr uint32_t ITCM_ERR_STAT_EN = (1U << 3);  ///< ITCM Access Error Status Enable
        constexpr uint32_t DTCM_ERR_STAT_EN = (1U << 4);  ///< DTCM Access Error Status Enable
        constexpr uint32_t OCRAM_ERR_STAT_EN = (1U << 5);  ///< OCRAM Access Error Status Enable
    }

    /// INT_SIG_EN Register bits
    namespace int_sig_en_bits {
        constexpr uint32_t ITCM_MAM_SIG_EN = (1U << 0);  ///< ITCM Magic Address Match Interrupt Enable
        constexpr uint32_t DTCM_MAM_SIG_EN = (1U << 1);  ///< DTCM Magic Address Match Interrupt Enable
        constexpr uint32_t OCRAM_MAM_SIG_EN = (1U << 2);  ///< OCRAM Magic Address Match Interrupt Enable
        constexpr uint32_t ITCM_ERR_SIG_EN = (1U << 3);  ///< ITCM Access Error Interrupt Enable
        constexpr uint32_t DTCM_ERR_SIG_EN = (1U << 4);  ///< DTCM Access Error Interrupt Enable
        constexpr uint32_t OCRAM_ERR_SIG_EN = (1U << 5);  ///< OCRAM Access Error Interrupt Enable
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x400B4000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
        volatile uint32_t CLKCTRL;  ///< Offset: 0x04 - Clock Control Register
        volatile uint32_t CLKPRESCALER;  ///< Offset: 0x05 - Clock Prescaler Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
        constexpr uint32_t INTEN = (1U << 3);  ///< Interrupt Enable.
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< SERVICE
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< COMPAREL
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< COMPAREH
    }

    /// CLKCTRL Register bits
    namespace clkctrl_bits {
        constexpr uint32_t CLKSEL = (2 << 0);  ///< CLKSEL
    }

    /// CLKPRESCALER Register bits
    namespace clkprescaler_bits {
        constexpr uint32_t CLK_DIV = (8 << 0);  ///< CLK_DIV
    }

}

// ============================================================================
// WDOG1 Peripheral
// ============================================================================

namespace wdog1 {
    /// Base addresses
    constexpr uint32_t WDOG1_BASE = 0x400B8000;

    /// WDOG1 Register structure
    struct Registers {
        volatile uint32_t WCR;  ///< Offset: 0x00 - Watchdog Control Register
        volatile uint32_t WSR;  ///< Offset: 0x02 - Watchdog Service Register
        volatile uint32_t WRSR;  ///< Offset: 0x04 - Watchdog Reset Status Register
        volatile uint32_t WICR;  ///< Offset: 0x06 - Watchdog Interrupt Control Register
        volatile uint32_t WMCR;  ///< Offset: 0x08 - Watchdog Miscellaneous Control Register
    };

    /// Peripheral instances
    inline Registers* WDOG1 = reinterpret_cast<Registers*>(WDOG1_BASE);

    // Bit definitions
    /// WCR Register bits
    namespace wcr_bits {
        constexpr uint32_t WDZST = (1U << 0);  ///< WDZST
        constexpr uint32_t WDBG = (1U << 1);  ///< WDBG
        constexpr uint32_t WDE = (1U << 2);  ///< WDE
        constexpr uint32_t WDT = (1U << 3);  ///< WDT
        constexpr uint32_t SRS = (1U << 4);  ///< SRS
        constexpr uint32_t WDA = (1U << 5);  ///< WDA
        constexpr uint32_t SRE = (1U << 6);  ///< software reset extension, an option way to generate software reset
        constexpr uint32_t WDW = (1U << 7);  ///< WDW
        constexpr uint32_t WT = (8 << 8);  ///< WT
    }

    /// WSR Register bits
    namespace wsr_bits {
        constexpr uint32_t WSR = (16 << 0);  ///< WSR
    }

    /// WRSR Register bits
    namespace wrsr_bits {
        constexpr uint32_t SFTW = (1U << 0);  ///< SFTW
        constexpr uint32_t TOUT = (1U << 1);  ///< TOUT
        constexpr uint32_t POR = (1U << 4);  ///< POR
    }

    /// WICR Register bits
    namespace wicr_bits {
        constexpr uint32_t WICT = (8 << 0);  ///< WICT
        constexpr uint32_t WTIS = (1U << 14);  ///< WTIS
        constexpr uint32_t WIE = (1U << 15);  ///< WIE
    }

    /// WMCR Register bits
    namespace wmcr_bits {
        constexpr uint32_t PDE = (1U << 0);  ///< PDE
    }

}

// ============================================================================
// WDOG2 Peripheral
// ============================================================================

namespace wdog2 {
    /// Base addresses
    constexpr uint32_t WDOG2_BASE = 0x400D0000;

    /// WDOG2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* WDOG2 = reinterpret_cast<Registers*>(WDOG2_BASE);

}

// ============================================================================
// RTWDOG Peripheral
// ============================================================================

namespace rtwdog {
    /// Base addresses
    constexpr uint32_t RTWDOG_BASE = 0x400BC000;

    /// RTWDOG Register structure
    struct Registers {
        volatile uint32_t CS;  ///< Offset: 0x00 - Watchdog Control and Status Register
        volatile uint32_t CNT;  ///< Offset: 0x04 - Watchdog Counter Register
        volatile uint32_t TOVAL;  ///< Offset: 0x08 - Watchdog Timeout Value Register
        volatile uint32_t WIN;  ///< Offset: 0x0C - Watchdog Window Register
    };

    /// Peripheral instances
    inline Registers* RTWDOG = reinterpret_cast<Registers*>(RTWDOG_BASE);

    // Bit definitions
    /// CS Register bits
    namespace cs_bits {
        constexpr uint32_t STOP = (1U << 0);  ///< Stop Enable
        constexpr uint32_t WAIT = (1U << 1);  ///< Wait Enable
        constexpr uint32_t DBG = (1U << 2);  ///< Debug Enable
        constexpr uint32_t TST = (2 << 3);  ///< Watchdog Test
        constexpr uint32_t UPDATE = (1U << 5);  ///< Allow updates
        constexpr uint32_t INT = (1U << 6);  ///< Watchdog Interrupt
        constexpr uint32_t EN = (1U << 7);  ///< Watchdog Enable
        constexpr uint32_t CLK = (2 << 8);  ///< Watchdog Clock
        constexpr uint32_t RCS = (1U << 10);  ///< Reconfiguration Success
        constexpr uint32_t ULK = (1U << 11);  ///< Unlock status
        constexpr uint32_t PRES = (1U << 12);  ///< Watchdog prescaler
        constexpr uint32_t CMD32EN = (1U << 13);  ///< Enables or disables WDOG support for 32-bit (otherwise 16-bit or 8-bit) refresh/unlock command write words
        constexpr uint32_t FLG = (1U << 14);  ///< Watchdog Interrupt Flag
        constexpr uint32_t WIN = (1U << 15);  ///< Watchdog Window
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNTLOW = (8 << 0);  ///< Low byte of the Watchdog Counter
        constexpr uint32_t CNTHIGH = (8 << 8);  ///< High byte of the Watchdog Counter
    }

    /// TOVAL Register bits
    namespace toval_bits {
        constexpr uint32_t TOVALLOW = (8 << 0);  ///< Low byte of the timeout value
        constexpr uint32_t TOVALHIGH = (8 << 8);  ///< High byte of the timeout value
    }

    /// WIN Register bits
    namespace win_bits {
        constexpr uint32_t WINLOW = (8 << 0);  ///< Low byte of Watchdog Window
        constexpr uint32_t WINHIGH = (8 << 8);  ///< High byte of Watchdog Window
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t TRNG_BASE = 0x400CC000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t MCTL;  ///< Offset: 0x00 - Miscellaneous Control Register
        volatile uint32_t SCMISC;  ///< Offset: 0x04 - Statistical Check Miscellaneous Register
        volatile uint32_t PKRRNG;  ///< Offset: 0x08 - Poker Range Register
        volatile uint32_t PKRMAX;  ///< Offset: 0x0C - Poker Maximum Limit Register
        volatile uint32_t PKRSQ;  ///< Offset: 0x0C - Poker Square Calculation Result Register
        volatile uint32_t SDCTL;  ///< Offset: 0x10 - Seed Control Register
        volatile uint32_t SBLIM;  ///< Offset: 0x14 - Sparse Bit Limit Register
        volatile uint32_t TOTSAM;  ///< Offset: 0x14 - Total Samples Register
        volatile uint32_t FRQMIN;  ///< Offset: 0x18 - Frequency Count Minimum Limit Register
        volatile uint32_t FRQCNT;  ///< Offset: 0x1C - Frequency Count Register
        volatile uint32_t FRQMAX;  ///< Offset: 0x1C - Frequency Count Maximum Limit Register
        volatile uint32_t SCMC;  ///< Offset: 0x20 - Statistical Check Monobit Count Register
        volatile uint32_t SCML;  ///< Offset: 0x20 - Statistical Check Monobit Limit Register
        volatile uint32_t SCR1C;  ///< Offset: 0x24 - Statistical Check Run Length 1 Count Register
        volatile uint32_t SCR1L;  ///< Offset: 0x24 - Statistical Check Run Length 1 Limit Register
        volatile uint32_t SCR2C;  ///< Offset: 0x28 - Statistical Check Run Length 2 Count Register
        volatile uint32_t SCR2L;  ///< Offset: 0x28 - Statistical Check Run Length 2 Limit Register
        volatile uint32_t SCR3C;  ///< Offset: 0x2C - Statistical Check Run Length 3 Count Register
        volatile uint32_t SCR3L;  ///< Offset: 0x2C - Statistical Check Run Length 3 Limit Register
        volatile uint32_t SCR4C;  ///< Offset: 0x30 - Statistical Check Run Length 4 Count Register
        volatile uint32_t SCR4L;  ///< Offset: 0x30 - Statistical Check Run Length 4 Limit Register
        volatile uint32_t SCR5C;  ///< Offset: 0x34 - Statistical Check Run Length 5 Count Register
        volatile uint32_t SCR5L;  ///< Offset: 0x34 - Statistical Check Run Length 5 Limit Register
        volatile uint32_t SCR6PC;  ///< Offset: 0x38 - Statistical Check Run Length 6+ Count Register
        volatile uint32_t SCR6PL;  ///< Offset: 0x38 - Statistical Check Run Length 6+ Limit Register
        volatile uint32_t STATUS;  ///< Offset: 0x3C - Status Register
        volatile uint32_t ENT[%s];  ///< Offset: 0x40 - Entropy Read Register
        volatile uint32_t PKRCNT10;  ///< Offset: 0x80 - Statistical Check Poker Count 1 and 0 Register
        volatile uint32_t PKRCNT32;  ///< Offset: 0x84 - Statistical Check Poker Count 3 and 2 Register
        volatile uint32_t PKRCNT54;  ///< Offset: 0x88 - Statistical Check Poker Count 5 and 4 Register
        volatile uint32_t PKRCNT76;  ///< Offset: 0x8C - Statistical Check Poker Count 7 and 6 Register
        volatile uint32_t PKRCNT98;  ///< Offset: 0x90 - Statistical Check Poker Count 9 and 8 Register
        volatile uint32_t PKRCNTBA;  ///< Offset: 0x94 - Statistical Check Poker Count B and A Register
        volatile uint32_t PKRCNTDC;  ///< Offset: 0x98 - Statistical Check Poker Count D and C Register
        volatile uint32_t PKRCNTFE;  ///< Offset: 0x9C - Statistical Check Poker Count F and E Register
        volatile uint32_t SEC_CFG;  ///< Offset: 0xA0 - Security Configuration Register
        volatile uint32_t INT_CTRL;  ///< Offset: 0xA4 - Interrupt Control Register
        volatile uint32_t INT_MASK;  ///< Offset: 0xA8 - Mask Register
        volatile uint32_t INT_STATUS;  ///< Offset: 0xAC - Interrupt Status Register
        volatile uint32_t VID1;  ///< Offset: 0xF0 - Version ID Register (MS)
        volatile uint32_t VID2;  ///< Offset: 0xF4 - Version ID Register (LS)
    };

    /// Peripheral instances
    inline Registers* TRNG = reinterpret_cast<Registers*>(TRNG_BASE);

    // Bit definitions
    /// MCTL Register bits
    namespace mctl_bits {
        constexpr uint32_t SAMP_MODE = (2 << 0);  ///< Sample Mode
        constexpr uint32_t OSC_DIV = (2 << 2);  ///< Oscillator Divide
        constexpr uint32_t UNUSED4 = (1U << 4);  ///< This bit is unused. Always reads zero.
        constexpr uint32_t UNUSED5 = (1U << 5);  ///< This bit is unused. Always reads zero.
        constexpr uint32_t RST_DEF = (1U << 6);  ///< Reset Defaults
        constexpr uint32_t FOR_SCLK = (1U << 7);  ///< Force System Clock
        constexpr uint32_t FCT_FAIL = (1U << 8);  ///< Read only: Frequency Count Fail
        constexpr uint32_t FCT_VAL = (1U << 9);  ///< Read only: Frequency Count Valid. Indicates that a valid frequency count may be read from FRQCNT.
        constexpr uint32_t ENT_VAL = (1U << 10);  ///< Read only: Entropy Valid
        constexpr uint32_t TST_OUT = (1U << 11);  ///< Read only: Test point inside ring oscillator.
        constexpr uint32_t ERR = (1U << 12);  ///< Read: Error status
        constexpr uint32_t TSTOP_OK = (1U << 13);  ///< TRNG_OK_TO_STOP
        constexpr uint32_t LRUN_CONT = (1U << 14);  ///< Long run count continues between entropy generations
        constexpr uint32_t PRGM = (1U << 16);  ///< Programming Mode Select
    }

    /// SCMISC Register bits
    namespace scmisc_bits {
        constexpr uint32_t LRUN_MAX = (8 << 0);  ///< LONG RUN MAX LIMIT
        constexpr uint32_t RTY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// PKRRNG Register bits
    namespace pkrrng_bits {
        constexpr uint32_t PKR_RNG = (16 << 0);  ///< Poker Range
    }

    /// PKRMAX Register bits
    namespace pkrmax_bits {
        constexpr uint32_t PKR_MAX = (24 << 0);  ///< Poker Maximum Limit.
    }

    /// PKRSQ Register bits
    namespace pkrsq_bits {
        constexpr uint32_t PKR_SQ = (24 << 0);  ///< Poker Square Calculation Result.
    }

    /// SDCTL Register bits
    namespace sdctl_bits {
        constexpr uint32_t SAMP_SIZE = (16 << 0);  ///< Sample Size
        constexpr uint32_t ENT_DLY = (16 << 16);  ///< Entropy Delay
    }

    /// SBLIM Register bits
    namespace sblim_bits {
        constexpr uint32_t SB_LIM = (10 << 0);  ///< Sparse Bit Limit
    }

    /// TOTSAM Register bits
    namespace totsam_bits {
        constexpr uint32_t TOT_SAM = (20 << 0);  ///< Total Samples
    }

    /// FRQMIN Register bits
    namespace frqmin_bits {
        constexpr uint32_t FRQ_MIN = (22 << 0);  ///< Frequency Count Minimum Limit
    }

    /// FRQCNT Register bits
    namespace frqcnt_bits {
        constexpr uint32_t FRQ_CT = (22 << 0);  ///< Frequency Count
    }

    /// FRQMAX Register bits
    namespace frqmax_bits {
        constexpr uint32_t FRQ_MAX = (22 << 0);  ///< Frequency Counter Maximum Limit
    }

    /// SCMC Register bits
    namespace scmc_bits {
        constexpr uint32_t MONO_CT = (16 << 0);  ///< Monobit Count
    }

    /// SCML Register bits
    namespace scml_bits {
        constexpr uint32_t MONO_MAX = (16 << 0);  ///< Monobit Maximum Limit
        constexpr uint32_t MONO_RNG = (16 << 16);  ///< Monobit Range
    }

    /// SCR1C Register bits
    namespace scr1c_bits {
        constexpr uint32_t R1_0_CT = (15 << 0);  ///< Runs of Zero, Length 1 Count
        constexpr uint32_t R1_1_CT = (15 << 16);  ///< Runs of One, Length 1 Count
    }

    /// SCR1L Register bits
    namespace scr1l_bits {
        constexpr uint32_t RUN1_MAX = (15 << 0);  ///< Run Length 1 Maximum Limit
        constexpr uint32_t RUN1_RNG = (15 << 16);  ///< Run Length 1 Range
    }

    /// SCR2C Register bits
    namespace scr2c_bits {
        constexpr uint32_t R2_0_CT = (14 << 0);  ///< Runs of Zero, Length 2 Count
        constexpr uint32_t R2_1_CT = (14 << 16);  ///< Runs of One, Length 2 Count
    }

    /// SCR2L Register bits
    namespace scr2l_bits {
        constexpr uint32_t RUN2_MAX = (14 << 0);  ///< Run Length 2 Maximum Limit
        constexpr uint32_t RUN2_RNG = (14 << 16);  ///< Run Length 2 Range
    }

    /// SCR3C Register bits
    namespace scr3c_bits {
        constexpr uint32_t R3_0_CT = (13 << 0);  ///< Runs of Zeroes, Length 3 Count
        constexpr uint32_t R3_1_CT = (13 << 16);  ///< Runs of Ones, Length 3 Count
    }

    /// SCR3L Register bits
    namespace scr3l_bits {
        constexpr uint32_t RUN3_MAX = (13 << 0);  ///< Run Length 3 Maximum Limit
        constexpr uint32_t RUN3_RNG = (13 << 16);  ///< Run Length 3 Range
    }

    /// SCR4C Register bits
    namespace scr4c_bits {
        constexpr uint32_t R4_0_CT = (12 << 0);  ///< Runs of Zero, Length 4 Count
        constexpr uint32_t R4_1_CT = (12 << 16);  ///< Runs of One, Length 4 Count
    }

    /// SCR4L Register bits
    namespace scr4l_bits {
        constexpr uint32_t RUN4_MAX = (12 << 0);  ///< Run Length 4 Maximum Limit
        constexpr uint32_t RUN4_RNG = (12 << 16);  ///< Run Length 4 Range
    }

    /// SCR5C Register bits
    namespace scr5c_bits {
        constexpr uint32_t R5_0_CT = (11 << 0);  ///< Runs of Zero, Length 5 Count
        constexpr uint32_t R5_1_CT = (11 << 16);  ///< Runs of One, Length 5 Count
    }

    /// SCR5L Register bits
    namespace scr5l_bits {
        constexpr uint32_t RUN5_MAX = (11 << 0);  ///< Run Length 5 Maximum Limit
        constexpr uint32_t RUN5_RNG = (11 << 16);  ///< Run Length 5 Range
    }

    /// SCR6PC Register bits
    namespace scr6pc_bits {
        constexpr uint32_t R6P_0_CT = (11 << 0);  ///< Runs of Zero, Length 6+ Count
        constexpr uint32_t R6P_1_CT = (11 << 16);  ///< Runs of One, Length 6+ Count
    }

    /// SCR6PL Register bits
    namespace scr6pl_bits {
        constexpr uint32_t RUN6P_MAX = (11 << 0);  ///< Run Length 6+ Maximum Limit
        constexpr uint32_t RUN6P_RNG = (11 << 16);  ///< Run Length 6+ Range
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t TF1BR0 = (1U << 0);  ///< Test Fail, 1-Bit Run, Sampling 0s. If TF1BR0=1, the 1-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF1BR1 = (1U << 1);  ///< Test Fail, 1-Bit Run, Sampling 1s. If TF1BR1=1, the 1-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF2BR0 = (1U << 2);  ///< Test Fail, 2-Bit Run, Sampling 0s. If TF2BR0=1, the 2-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF2BR1 = (1U << 3);  ///< Test Fail, 2-Bit Run, Sampling 1s. If TF2BR1=1, the 2-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF3BR0 = (1U << 4);  ///< Test Fail, 3-Bit Run, Sampling 0s. If TF3BR0=1, the 3-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF3BR1 = (1U << 5);  ///< Test Fail, 3-Bit Run, Sampling 1s. If TF3BR1=1, the 3-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF4BR0 = (1U << 6);  ///< Test Fail, 4-Bit Run, Sampling 0s. If TF4BR0=1, the 4-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF4BR1 = (1U << 7);  ///< Test Fail, 4-Bit Run, Sampling 1s. If TF4BR1=1, the 4-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF5BR0 = (1U << 8);  ///< Test Fail, 5-Bit Run, Sampling 0s. If TF5BR0=1, the 5-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF5BR1 = (1U << 9);  ///< Test Fail, 5-Bit Run, Sampling 1s. If TF5BR1=1, the 5-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF6PBR0 = (1U << 10);  ///< Test Fail, 6 Plus Bit Run, Sampling 0s
        constexpr uint32_t TF6PBR1 = (1U << 11);  ///< Test Fail, 6 Plus Bit Run, Sampling 1s
        constexpr uint32_t TFSB = (1U << 12);  ///< Test Fail, Sparse Bit. If TFSB=1, the Sparse Bit Test has failed.
        constexpr uint32_t TFLR = (1U << 13);  ///< Test Fail, Long Run. If TFLR=1, the Long Run Test has failed.
        constexpr uint32_t TFP = (1U << 14);  ///< Test Fail, Poker. If TFP=1, the Poker Test has failed.
        constexpr uint32_t TFMB = (1U << 15);  ///< Test Fail, Mono Bit. If TFMB=1, the Mono Bit Test has failed.
        constexpr uint32_t RETRY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// ENT[%s] Register bits
    namespace ent[%s]_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// PKRCNT10 Register bits
    namespace pkrcnt10_bits {
        constexpr uint32_t PKR_0_CT = (16 << 0);  ///< Poker 0h Count
        constexpr uint32_t PKR_1_CT = (16 << 16);  ///< Poker 1h Count
    }

    /// PKRCNT32 Register bits
    namespace pkrcnt32_bits {
        constexpr uint32_t PKR_2_CT = (16 << 0);  ///< Poker 2h Count
        constexpr uint32_t PKR_3_CT = (16 << 16);  ///< Poker 3h Count
    }

    /// PKRCNT54 Register bits
    namespace pkrcnt54_bits {
        constexpr uint32_t PKR_4_CT = (16 << 0);  ///< Poker 4h Count
        constexpr uint32_t PKR_5_CT = (16 << 16);  ///< Poker 5h Count
    }

    /// PKRCNT76 Register bits
    namespace pkrcnt76_bits {
        constexpr uint32_t PKR_6_CT = (16 << 0);  ///< Poker 6h Count
        constexpr uint32_t PKR_7_CT = (16 << 16);  ///< Poker 7h Count
    }

    /// PKRCNT98 Register bits
    namespace pkrcnt98_bits {
        constexpr uint32_t PKR_8_CT = (16 << 0);  ///< Poker 8h Count
        constexpr uint32_t PKR_9_CT = (16 << 16);  ///< Poker 9h Count
    }

    /// PKRCNTBA Register bits
    namespace pkrcntba_bits {
        constexpr uint32_t PKR_A_CT = (16 << 0);  ///< Poker Ah Count
        constexpr uint32_t PKR_B_CT = (16 << 16);  ///< Poker Bh Count
    }

    /// PKRCNTDC Register bits
    namespace pkrcntdc_bits {
        constexpr uint32_t PKR_C_CT = (16 << 0);  ///< Poker Ch Count
        constexpr uint32_t PKR_D_CT = (16 << 16);  ///< Poker Dh Count
    }

    /// PKRCNTFE Register bits
    namespace pkrcntfe_bits {
        constexpr uint32_t PKR_E_CT = (16 << 0);  ///< Poker Eh Count
        constexpr uint32_t PKR_F_CT = (16 << 16);  ///< Poker Fh Count
    }

    /// SEC_CFG Register bits
    namespace sec_cfg_bits {
        constexpr uint32_t UNUSED0 = (1U << 0);  ///< This bit is unused. Ignore.
        constexpr uint32_t NO_PRGM = (1U << 1);  ///< If set, the TRNG registers cannot be programmed
        constexpr uint32_t UNUSED2 = (1U << 2);  ///< This bit is unused. Ignore.
    }

    /// INT_CTRL Register bits
    namespace int_ctrl_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS register has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 of this register.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 of this register.
    }

    /// INT_MASK Register bits
    namespace int_mask_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 of this register.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 of this register.
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Read: Error status
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Read only: Entropy Valid
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Read only: Frequency Count Fail
    }

    /// VID1 Register bits
    namespace vid1_bits {
        constexpr uint32_t MIN_REV = (8 << 0);  ///< Shows the IP's Minor revision of the TRNG.
        constexpr uint32_t MAJ_REV = (8 << 8);  ///< Shows the IP's Major revision of the TRNG.
        constexpr uint32_t IP_ID = (16 << 16);  ///< Shows the IP ID.
    }

    /// VID2 Register bits
    namespace vid2_bits {
        constexpr uint32_t CONFIG_OPT = (8 << 0);  ///< Shows the IP's Configuaration options for the TRNG.
        constexpr uint32_t ECO_REV = (8 << 8);  ///< Shows the IP's ECO revision of the TRNG.
        constexpr uint32_t INTG_OPT = (8 << 16);  ///< Shows the integration options for the TRNG.
        constexpr uint32_t ERA = (8 << 24);  ///< Shows the compile options for the TRNG.
    }

}

// ============================================================================
// SNVS Peripheral
// ============================================================================

namespace snvs {
    /// Base addresses
    constexpr uint32_t SNVS_BASE = 0x400D4000;

    /// SNVS Register structure
    struct Registers {
        volatile uint32_t HPLR;  ///< Offset: 0x00 - SNVS_HP Lock Register
        volatile uint32_t HPCOMR;  ///< Offset: 0x04 - SNVS_HP Command Register
        volatile uint32_t HPCR;  ///< Offset: 0x08 - SNVS_HP Control Register
        volatile uint32_t HPSICR;  ///< Offset: 0x0C - SNVS_HP Security Interrupt Control Register
        volatile uint32_t HPSVCR;  ///< Offset: 0x10 - SNVS_HP Security Violation Control Register
        volatile uint32_t HPSR;  ///< Offset: 0x14 - SNVS_HP Status Register
        volatile uint32_t HPSVSR;  ///< Offset: 0x18 - SNVS_HP Security Violation Status Register
        volatile uint32_t HPHACIVR;  ///< Offset: 0x1C - SNVS_HP High Assurance Counter IV Register
        volatile uint32_t HPHACR;  ///< Offset: 0x20 - SNVS_HP High Assurance Counter Register
        volatile uint32_t HPRTCMR;  ///< Offset: 0x24 - SNVS_HP Real Time Counter MSB Register
        volatile uint32_t HPRTCLR;  ///< Offset: 0x28 - SNVS_HP Real Time Counter LSB Register
        volatile uint32_t HPTAMR;  ///< Offset: 0x2C - SNVS_HP Time Alarm MSB Register
        volatile uint32_t HPTALR;  ///< Offset: 0x30 - SNVS_HP Time Alarm LSB Register
        volatile uint32_t LPLR;  ///< Offset: 0x34 - SNVS_LP Lock Register
        volatile uint32_t LPCR;  ///< Offset: 0x38 - SNVS_LP Control Register
        volatile uint32_t LPMKCR;  ///< Offset: 0x3C - SNVS_LP Master Key Control Register
        volatile uint32_t LPSVCR;  ///< Offset: 0x40 - SNVS_LP Security Violation Control Register
        volatile uint32_t LPTDCR;  ///< Offset: 0x48 - SNVS_LP Tamper Detectors Configuration Register
        volatile uint32_t LPSR;  ///< Offset: 0x4C - SNVS_LP Status Register
        volatile uint32_t LPSRTCMR;  ///< Offset: 0x50 - SNVS_LP Secure Real Time Counter MSB Register
        volatile uint32_t LPSRTCLR;  ///< Offset: 0x54 - SNVS_LP Secure Real Time Counter LSB Register
        volatile uint32_t LPTAR;  ///< Offset: 0x58 - SNVS_LP Time Alarm Register
        volatile uint32_t LPSMCMR;  ///< Offset: 0x5C - SNVS_LP Secure Monotonic Counter MSB Register
        volatile uint32_t LPSMCLR;  ///< Offset: 0x60 - SNVS_LP Secure Monotonic Counter LSB Register
        volatile uint32_t LPPGDR;  ///< Offset: 0x64 - SNVS_LP Power Glitch Detector Register
        volatile uint32_t LPGPR0_legacy_alias;  ///< Offset: 0x68 - SNVS_LP General Purpose Register 0 (legacy alias)
        volatile uint32_t LPZMKR[%s];  ///< Offset: 0x6C - SNVS_LP Zeroizable Master Key Register
        volatile uint32_t LPGPR_alias[%s];  ///< Offset: 0x90 - SNVS_LP General Purpose Registers 0 .. 3
        volatile uint32_t LPGPR[%s];  ///< Offset: 0x100 - SNVS_LP General Purpose Registers 0 .. 3
        volatile uint32_t HPVIDR1;  ///< Offset: 0xBF8 - SNVS_HP Version ID Register 1
        volatile uint32_t HPVIDR2;  ///< Offset: 0xBFC - SNVS_HP Version ID Register 2
    };

    /// Peripheral instances
    inline Registers* SNVS = reinterpret_cast<Registers*>(SNVS_BASE);

    // Bit definitions
    /// HPLR Register bits
    namespace hplr_bits {
        constexpr uint32_t ZMK_WSL = (1U << 0);  ///< Zeroizable Master Key Write Soft Lock When set, prevents any writes (software and hardware) to the ZMK registers and the ZMK_HWP, ZMK_VAL, and ZMK_ECC_EN fields of the LPMKCR
        constexpr uint32_t ZMK_RSL = (1U << 1);  ///< Zeroizable Master Key Read Soft Lock When set, prevents any software reads to the ZMK Registers and ZMK_ECC_VALUE field of the LPMKCR
        constexpr uint32_t SRTC_SL = (1U << 2);  ///< Secure Real Time Counter Soft Lock When set, prevents any writes to the SRTC Registers, SRTC_ENV, and SRTC_INV_EN bits
        constexpr uint32_t LPCALB_SL = (1U << 3);  ///< LP Calibration Soft Lock When set, prevents any writes to the LP Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
        constexpr uint32_t MC_SL = (1U << 4);  ///< Monotonic Counter Soft Lock When set, prevents any writes (increments) to the MC Registers and MC_ENV bit
        constexpr uint32_t GPR_SL = (1U << 5);  ///< General Purpose Register Soft Lock When set, prevents any writes to the GPR
        constexpr uint32_t LPSVCR_SL = (1U << 6);  ///< LP Security Violation Control Register Soft Lock When set, prevents any writes to the LPSVCR
        constexpr uint32_t LPTDCR_SL = (1U << 8);  ///< LP Tamper Detectors Configuration Register Soft Lock When set, prevents any writes to the LPTDCR
        constexpr uint32_t MKS_SL = (1U << 9);  ///< Master Key Select Soft Lock When set, prevents any writes to the MASTER_KEY_SEL field of the LPMKCR
        constexpr uint32_t HPSVCR_L = (1U << 16);  ///< HP Security Violation Control Register Lock When set, prevents any writes to the HPSVCR
        constexpr uint32_t HPSICR_L = (1U << 17);  ///< HP Security Interrupt Control Register Lock When set, prevents any writes to the HPSICR
        constexpr uint32_t HAC_L = (1U << 18);  ///< High Assurance Counter Lock When set, prevents any writes to HPHACIVR, HPHACR, and HAC_EN bit of HPCOMR
    }

    /// HPCOMR Register bits
    namespace hpcomr_bits {
        constexpr uint32_t SSM_ST = (1U << 0);  ///< SSM State Transition Transition state of the system security monitor
        constexpr uint32_t SSM_ST_DIS = (1U << 1);  ///< SSM Secure to Trusted State Transition Disable When set, disables the SSM transition from secure to trusted state
        constexpr uint32_t SSM_SFNS_DIS = (1U << 2);  ///< SSM Soft Fail to Non-Secure State Transition Disable When set, it disables the SSM transition from soft fail to non-secure state
        constexpr uint32_t LP_SWR = (1U << 4);  ///< LP Software Reset When set to 1, most registers in the SNVS_LP section are reset, but the following registers are not reset by an LP software reset: Secure Real Time Counter Time Alarm Register This bit cannot be set when the LP_SWR_DIS bit is set
        constexpr uint32_t LP_SWR_DIS = (1U << 5);  ///< LP Software Reset Disable When set, disables the LP software reset
        constexpr uint32_t SW_SV = (1U << 8);  ///< Software Security Violation When set, the system security monitor treats this bit as a non-fatal security violation
        constexpr uint32_t SW_FSV = (1U << 9);  ///< Software Fatal Security Violation When set, the system security monitor treats this bit as a fatal security violation
        constexpr uint32_t SW_LPSV = (1U << 10);  ///< LP Software Security Violation When set, SNVS_LP treats this bit as a security violation
        constexpr uint32_t PROG_ZMK = (1U << 12);  ///< Program Zeroizable Master Key This bit activates ZMK hardware programming mechanism
        constexpr uint32_t MKS_EN = (1U << 13);  ///< Master Key Select Enable When not set, the one time programmable (OTP) master key is selected by default
        constexpr uint32_t HAC_EN = (1U << 16);  ///< High Assurance Counter Enable This bit controls the SSM transition from the soft fail to the hard fail state
        constexpr uint32_t HAC_LOAD = (1U << 17);  ///< High Assurance Counter Load When set, it loads the High Assurance Counter Register with the value of the High Assurance Counter Load Register
        constexpr uint32_t HAC_CLEAR = (1U << 18);  ///< High Assurance Counter Clear When set, it clears the High Assurance Counter Register
        constexpr uint32_t HAC_STOP = (1U << 19);  ///< High Assurance Counter Stop This bit can be set only when SSM is in soft fail state
        constexpr uint32_t NPSWA_EN = (1U << 31);  ///< Non-Privileged Software Access Enable When set, allows non-privileged software to access all SNVS registers, including those that are privileged software read/write access only
    }

    /// HPCR Register bits
    namespace hpcr_bits {
        constexpr uint32_t RTC_EN = (1U << 0);  ///< HP Real Time Counter Enable
        constexpr uint32_t HPTA_EN = (1U << 1);  ///< HP Time Alarm Enable When set, the time alarm interrupt is generated if the value in the HP Time Alarm Registers is equal to the value of the HP Real Time Counter
        constexpr uint32_t DIS_PI = (1U << 2);  ///< Disable periodic interrupt in the functional interrupt
        constexpr uint32_t PI_EN = (1U << 3);  ///< HP Periodic Interrupt Enable The periodic interrupt can be generated only if the HP Real Time Counter is enabled
        constexpr uint32_t PI_FREQ = (4 << 4);  ///< Periodic Interrupt Frequency Defines frequency of the periodic interrupt
        constexpr uint32_t HPCALB_EN = (1U << 8);  ///< HP Real Time Counter Calibration Enabled Indicates that the time calibration mechanism is enabled.
        constexpr uint32_t HPCALB_VAL = (5 << 10);  ///< HP Calibration Value Defines signed calibration value for the HP Real Time Counter
        constexpr uint32_t HP_TS = (1U << 16);  ///< HP Time Synchronize
        constexpr uint32_t BTN_CONFIG = (3 << 24);  ///< Button Configuration
        constexpr uint32_t BTN_MASK = (1U << 27);  ///< Button interrupt mask
    }

    /// HPSICR Register bits
    namespace hpsicr_bits {
        constexpr uint32_t SV0_EN = (1U << 0);  ///< Security Violation 0 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 0 security violation
        constexpr uint32_t SV1_EN = (1U << 1);  ///< Security Violation 1 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 1 security violation
        constexpr uint32_t SV2_EN = (1U << 2);  ///< Security Violation 2 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 2 security violation
        constexpr uint32_t SV3_EN = (1U << 3);  ///< Security Violation 3 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 3 security violation
        constexpr uint32_t SV4_EN = (1U << 4);  ///< Security Violation 4 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 4 security violation
        constexpr uint32_t SV5_EN = (1U << 5);  ///< Security Violation 5 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 5 security violation
        constexpr uint32_t LPSVI_EN = (1U << 31);  ///< LP Security Violation Interrupt Enable This bit enables generating of the security interrupt to the host processor upon security violation signal from the LP section
    }

    /// HPSVCR Register bits
    namespace hpsvcr_bits {
        constexpr uint32_t SV0_CFG = (1U << 0);  ///< Security Violation 0 Security Violation Configuration This field configures the Security Violation 0 Security Violation Input
        constexpr uint32_t SV1_CFG = (1U << 1);  ///< Security Violation 1 Security Violation Configuration This field configures the Security Violation 1 Security Violation Input
        constexpr uint32_t SV2_CFG = (1U << 2);  ///< Security Violation 2 Security Violation Configuration This field configures the Security Violation 2 Security Violation Input
        constexpr uint32_t SV3_CFG = (1U << 3);  ///< Security Violation 3 Security Violation Configuration This field configures the Security Violation 3 Security Violation Input
        constexpr uint32_t SV4_CFG = (1U << 4);  ///< Security Violation 4 Security Violation Configuration This field configures the Security Violation 4 Security Violation Input
        constexpr uint32_t SV5_CFG = (2 << 5);  ///< Security Violation 5 Security Violation Configuration This field configures the Security Violation 5 Security Violation Input
        constexpr uint32_t LPSV_CFG = (2 << 30);  ///< LP Security Violation Configuration This field configures the LP security violation source.
    }

    /// HPSR Register bits
    namespace hpsr_bits {
        constexpr uint32_t HPTA = (1U << 0);  ///< HP Time Alarm Indicates that the HP Time Alarm has occurred since this bit was last cleared.
        constexpr uint32_t PI = (1U << 1);  ///< Periodic Interrupt Indicates that periodic interrupt has occurred since this bit was last cleared.
        constexpr uint32_t LPDIS = (1U << 4);  ///< Low Power Disable If 1, the low power section has been disabled by means of an input signal to SNVS
        constexpr uint32_t BTN = (1U << 6);  ///< Button Value of the BTN input
        constexpr uint32_t BI = (1U << 7);  ///< Button Interrupt Signal ipi_snvs_btn_int_b was asserted.
        constexpr uint32_t SSM_STATE = (4 << 8);  ///< System Security Monitor State This field contains the encoded state of the SSM's state machine
        constexpr uint32_t SECURITY_CONFIG = (4 << 12);  ///< Security Configuration This field reflects the settings of the sys_secure_boot input and the three security configuration inputs to SNVS
        constexpr uint32_t OTPMK_SYNDROME = (9 << 16);  ///< One Time Programmable Master Key Syndrome In the case of a single-bit error, the eight lower bits of this value indicate the bit number of error location
        constexpr uint32_t OTPMK_ZERO = (1U << 27);  ///< One Time Programmable Master Key is Equal to Zero
        constexpr uint32_t ZMK_ZERO = (1U << 31);  ///< Zeroizable Master Key is Equal to Zero
    }

    /// HPSVSR Register bits
    namespace hpsvsr_bits {
        constexpr uint32_t SV0 = (1U << 0);  ///< Security Violation 0 security violation was detected.
        constexpr uint32_t SV1 = (1U << 1);  ///< Security Violation 1 security violation was detected.
        constexpr uint32_t SV2 = (1U << 2);  ///< Security Violation 2 security violation was detected.
        constexpr uint32_t SV3 = (1U << 3);  ///< Security Violation 3 security violation was detected.
        constexpr uint32_t SV4 = (1U << 4);  ///< Security Violation 4 security violation was detected.
        constexpr uint32_t SV5 = (1U << 5);  ///< Security Violation 5 security violation was detected.
        constexpr uint32_t SW_SV = (1U << 13);  ///< Software Security Violation This bit is a read-only copy of the SW_SV bit in the HP Command Register
        constexpr uint32_t SW_FSV = (1U << 14);  ///< Software Fatal Security Violation This bit is a read-only copy of the SW_FSV bit in the HP Command Register
        constexpr uint32_t SW_LPSV = (1U << 15);  ///< LP Software Security Violation This bit is a read-only copy of the SW_LPSV bit in the HP Command Register
        constexpr uint32_t ZMK_SYNDROME = (9 << 16);  ///< Zeroizable Master Key Syndrome The ZMK syndrome indicates the single-bit error location and parity for the ZMK register
        constexpr uint32_t ZMK_ECC_FAIL = (1U << 27);  ///< Zeroizable Master Key Error Correcting Code Check Failure When set, this bit triggers a bad key violation to the SSM and a security violation to the SNVS_LP section, which clears security sensitive data
        constexpr uint32_t LP_SEC_VIO = (1U << 31);  ///< LP Security Violation A security volation was detected in the SNVS low power section.
    }

    /// HPHACIVR Register bits
    namespace hphacivr_bits {
        constexpr uint32_t HAC_COUNTER_IV = (32 << 0);  ///< High Assurance Counter Initial Value This register is used to set the starting count value to the high assurance counter
    }

    /// HPHACR Register bits
    namespace hphacr_bits {
        constexpr uint32_t HAC_COUNTER = (32 << 0);  ///< High Assurance Counter When the HAC_EN bit is set and the SSM is in the soft fail state, this counter starts to count down with the system clock
    }

    /// HPRTCMR Register bits
    namespace hprtcmr_bits {
        constexpr uint32_t RTC = (15 << 0);  ///< HP Real Time Counter The most-significant 15 bits of the RTC
    }

    /// HPRTCLR Register bits
    namespace hprtclr_bits {
        constexpr uint32_t RTC = (32 << 0);  ///< HP Real Time Counter least-significant 32 bits
    }

    /// HPTAMR Register bits
    namespace hptamr_bits {
        constexpr uint32_t HPTA_MS = (15 << 0);  ///< HP Time Alarm, most-significant 15 bits
    }

    /// HPTALR Register bits
    namespace hptalr_bits {
        constexpr uint32_t HPTA_LS = (32 << 0);  ///< HP Time Alarm, 32 least-significant bits
    }

    /// LPLR Register bits
    namespace lplr_bits {
        constexpr uint32_t ZMK_WHL = (1U << 0);  ///< Zeroizable Master Key Write Hard Lock When set, prevents any writes (software and hardware) to the ZMK registers and ZMK_HWP, ZMK_VAL, and ZMK_ECC_EN fields of the LPMKCR
        constexpr uint32_t ZMK_RHL = (1U << 1);  ///< Zeroizable Master Key Read Hard Lock When set, prevents any software reads to the ZMK registers and ZMK_ECC_VALUE field of the LPMKCR
        constexpr uint32_t SRTC_HL = (1U << 2);  ///< Secure Real Time Counter Hard Lock When set, prevents any writes to the SRTC registers, SRTC_ENV, and SRTC_INV_EN bits
        constexpr uint32_t LPCALB_HL = (1U << 3);  ///< LP Calibration Hard Lock When set, prevents any writes to the LP Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
        constexpr uint32_t MC_HL = (1U << 4);  ///< Monotonic Counter Hard Lock When set, prevents any writes (increments) to the MC Registers and MC_ENV bit
        constexpr uint32_t GPR_HL = (1U << 5);  ///< General Purpose Register Hard Lock When set, prevents any writes to the GPR
        constexpr uint32_t LPSVCR_HL = (1U << 6);  ///< LP Security Violation Control Register Hard Lock When set, prevents any writes to the LPSVCR
        constexpr uint32_t LPTDCR_HL = (1U << 8);  ///< LP Tamper Detectors Configuration Register Hard Lock When set, prevents any writes to the LPTDCR
        constexpr uint32_t MKS_HL = (1U << 9);  ///< Master Key Select Hard Lock When set, prevents any writes to the MASTER_KEY_SEL field of the LP Master Key Control Register
    }

    /// LPCR Register bits
    namespace lpcr_bits {
        constexpr uint32_t SRTC_ENV = (1U << 0);  ///< Secure Real Time Counter Enabled and Valid When set, the SRTC becomes operational
        constexpr uint32_t LPTA_EN = (1U << 1);  ///< LP Time Alarm Enable When set, the SNVS functional interrupt is asserted if the LP Time Alarm Register is equal to the 32 MSBs of the secure real time counter
        constexpr uint32_t MC_ENV = (1U << 2);  ///< Monotonic Counter Enabled and Valid When set, the MC can be incremented (by write transaction to the LPSMCMR or LPSMCLR)
        constexpr uint32_t LPWUI_EN = (1U << 3);  ///< LP Wake-Up Interrupt Enable This interrupt line should be connected to the external pin and is intended to inform the external chip about an SNVS_LP event (tamper event, MC rollover, SRTC rollover, or time alarm )
        constexpr uint32_t SRTC_INV_EN = (1U << 4);  ///< If this bit is 1, in the case of a security violation the SRTC stops counting and the SRTC is invalidated (SRTC_ENV bit is cleared)
        constexpr uint32_t DP_EN = (1U << 5);  ///< Dumb PMIC Enabled When set, software can control the system power
        constexpr uint32_t TOP = (1U << 6);  ///< Turn off System Power Asserting this bit causes a signal to be sent to the Power Management IC to turn off the system power
        constexpr uint32_t PWR_GLITCH_EN = (1U << 7);  ///< Power Glitch Enable By default the detection of a power glitch does not cause the pmic_en_b signal to be asserted
        constexpr uint32_t LPCALB_EN = (1U << 8);  ///< LP Calibration Enable When set, enables the SRTC calibration mechanism
        constexpr uint32_t LPCALB_VAL = (5 << 10);  ///< LP Calibration Value Defines signed calibration value for SRTC
        constexpr uint32_t BTN_PRESS_TIME = (2 << 16);  ///< This field configures the button press time out values for the PMIC Logic
        constexpr uint32_t DEBOUNCE = (2 << 18);  ///< This field configures the amount of debounce time for the BTN input signal
        constexpr uint32_t ON_TIME = (2 << 20);  ///< The ON_TIME field is used to configure the period of time after BTN is asserted before pmic_en_b is asserted to turn on the SoC power
        constexpr uint32_t PK_EN = (1U << 22);  ///< PMIC On Request Enable The value written to PK_EN will be asserted on output signal snvs_lp_pk_en
        constexpr uint32_t PK_OVERRIDE = (1U << 23);  ///< PMIC On Request Override The value written to PK_OVERRIDE will be asserted on output signal snvs_lp_pk_override
        constexpr uint32_t GPR_Z_DIS = (1U << 24);  ///< General Purpose Registers Zeroization Disable
    }

    /// LPMKCR Register bits
    namespace lpmkcr_bits {
        constexpr uint32_t MASTER_KEY_SEL = (2 << 0);  ///< Master Key Select These bits select the SNVS Master Key output when Master Key Select bits are enabled by MKS_EN bit in the HPCOMR
        constexpr uint32_t ZMK_HWP = (1U << 2);  ///< Zeroizable Master Key hardware Programming mode When set, only the hardware key programming mechanism can set the ZMK and software cannot read it
        constexpr uint32_t ZMK_VAL = (1U << 3);  ///< Zeroizable Master Key Valid When set, the ZMK value can be selected by the master key control block for use by cryptographic modules
        constexpr uint32_t ZMK_ECC_EN = (1U << 4);  ///< Zeroizable Master Key Error Correcting Code Check Enable Writing one to this field automatically calculates and sets the ZMK ECC value in the ZMK_ECC_VALUE field of this register
        constexpr uint32_t ZMK_ECC_VALUE = (9 << 7);  ///< Zeroizable Master Key Error Correcting Code Value This field is automatically calculated and set when one is written into ZMK_ECC_EN bit of this register
    }

    /// LPSVCR Register bits
    namespace lpsvcr_bits {
        constexpr uint32_t SV0_EN = (1U << 0);  ///< Security Violation 0 Enable This bit enables Security Violation 0 Input
        constexpr uint32_t SV1_EN = (1U << 1);  ///< Security Violation 1 Enable This bit enables Security Violation 1 Input
        constexpr uint32_t SV2_EN = (1U << 2);  ///< Security Violation 2 Enable This bit enables Security Violation 2 Input
        constexpr uint32_t SV3_EN = (1U << 3);  ///< Security Violation 3 Enable This bit enables Security Violation 3 Input
        constexpr uint32_t SV4_EN = (1U << 4);  ///< Security Violation 4 Enable This bit enables Security Violation 4 Input
        constexpr uint32_t SV5_EN = (1U << 5);  ///< Security Violation 5 Enable This bit enables Security Violation 5 Input
    }

    /// LPTDCR Register bits
    namespace lptdcr_bits {
        constexpr uint32_t SRTCR_EN = (1U << 1);  ///< SRTC Rollover Enable When set, an SRTC rollover event generates an LP security violation.
        constexpr uint32_t MCR_EN = (1U << 2);  ///< MC Rollover Enable When set, an MC Rollover event generates an LP security violation.
        constexpr uint32_t ET1_EN = (1U << 9);  ///< External Tampering 1 Enable When set, external tampering 1 detection generates an LP security violation
        constexpr uint32_t ET1P = (1U << 11);  ///< External Tampering 1 Polarity This bit is used to determine the polarity of external tamper 1.
        constexpr uint32_t PFD_OBSERV = (1U << 14);  ///< System Power Fail Detector (PFD) Observability Flop The asynchronous reset input of this flop is connected directly to the inverted output of the PFD analog circuitry (external to the SNVS block)
        constexpr uint32_t POR_OBSERV = (1U << 15);  ///< Power On Reset (POR) Observability Flop The asynchronous reset input of this flop is connected directly to the output of the POR analog circuitry (external to the SNVS
        constexpr uint32_t OSCB = (1U << 28);  ///< Oscillator Bypass When OSCB=1 the osc_bypass signal is asserted
    }

    /// LPSR Register bits
    namespace lpsr_bits {
        constexpr uint32_t LPTA = (1U << 0);  ///< LP Time Alarm
        constexpr uint32_t SRTCR = (1U << 1);  ///< Secure Real Time Counter Rollover
        constexpr uint32_t MCR = (1U << 2);  ///< Monotonic Counter Rollover
        constexpr uint32_t PGD = (1U << 3);  ///< Power Supply Glitch Detected 0 No power supply glitch. 1 Power supply glitch is detected.
        constexpr uint32_t ET1D = (1U << 9);  ///< External Tampering 1 Detected
        constexpr uint32_t ESVD = (1U << 16);  ///< External Security Violation Detected Indicates that a security violation is detected on one of the HP security violation ports
        constexpr uint32_t EO = (1U << 17);  ///< Emergency Off This bit is set when a power off is requested.
        constexpr uint32_t SPO = (1U << 18);  ///< Set Power Off The SPO bit is set when the power button is pressed longer than the configured debounce time
        constexpr uint32_t SED = (1U << 20);  ///< Scan Exit Detected
        constexpr uint32_t LPNS = (1U << 30);  ///< LP Section is Non-Secured Indicates that LP section was provisioned/programmed in the non-secure state
        constexpr uint32_t LPS = (1U << 31);  ///< LP Section is Secured Indicates that the LP section is provisioned/programmed in the secure or trusted state
    }

    /// LPSRTCMR Register bits
    namespace lpsrtcmr_bits {
        constexpr uint32_t SRTC = (15 << 0);  ///< LP Secure Real Time Counter The most-significant 15 bits of the SRTC
    }

    /// LPSRTCLR Register bits
    namespace lpsrtclr_bits {
        constexpr uint32_t SRTC = (32 << 0);  ///< LP Secure Real Time Counter least-significant 32 bits This register can be programmed only when SRTC is not active and not locked, meaning the SRTC_ENV, SRTC_SL, and SRTC_HL bits are not set
    }

    /// LPTAR Register bits
    namespace lptar_bits {
        constexpr uint32_t LPTA = (32 << 0);  ///< LP Time Alarm This register can be programmed only when the LP time alarm is disabled (LPTA_EN bit is not set)
    }

    /// LPSMCMR Register bits
    namespace lpsmcmr_bits {
        constexpr uint32_t MON_COUNTER = (16 << 0);  ///< Monotonic Counter most-significant 16 Bits The MC is incremented by one when: A write transaction to the LPSMCMR or LPSMCLR register is detected
        constexpr uint32_t MC_ERA_BITS = (16 << 16);  ///< Monotonic Counter Era Bits These bits are inputs to the module and typically connect to fuses
    }

    /// LPSMCLR Register bits
    namespace lpsmclr_bits {
        constexpr uint32_t MON_COUNTER = (32 << 0);  ///< Monotonic Counter bits The MC is incremented by one when: A write transaction to the LPSMCMR or LPSMCLR Register is detected
    }

    /// LPPGDR Register bits
    namespace lppgdr_bits {
        constexpr uint32_t PGD = (32 << 0);  ///< Power Glitch Detector Value
    }

    /// LPGPR0_legacy_alias Register bits
    namespace lpgpr0_legacy_alias_bits {
        constexpr uint32_t GPR = (32 << 0);  ///< General Purpose Register When GPR_SL or GPR_HL bit is set, the register cannot be programmed.
    }

    /// LPZMKR[%s] Register bits
    namespace lpzmkr[%s]_bits {
        constexpr uint32_t ZMK = (32 << 0);  ///< Zeroizable Master Key Each of these registers contains 32 bits of the 256-bit ZMK value
    }

    /// LPGPR_alias[%s] Register bits
    namespace lpgpr_alias[%s]_bits {
        constexpr uint32_t GPR = (32 << 0);  ///< General Purpose Register When GPR_SL or GPR_HL bit is set, the register cannot be programmed.
    }

    /// LPGPR[%s] Register bits
    namespace lpgpr[%s]_bits {
        constexpr uint32_t GPR = (32 << 0);  ///< General Purpose Register When GPR_SL or GPR_HL bit is set, the register cannot be programmed.
    }

    /// HPVIDR1 Register bits
    namespace hpvidr1_bits {
        constexpr uint32_t MINOR_REV = (8 << 0);  ///< SNVS block minor version number
        constexpr uint32_t MAJOR_REV = (8 << 8);  ///< SNVS block major version number
        constexpr uint32_t IP_ID = (16 << 16);  ///< SNVS block ID
    }

    /// HPVIDR2 Register bits
    namespace hpvidr2_bits {
        constexpr uint32_t CONFIG_OPT = (8 << 0);  ///< SNVS Configuration Options
        constexpr uint32_t ECO_REV = (8 << 8);  ///< SNVS ECO Revision
        constexpr uint32_t INTG_OPT = (8 << 16);  ///< SNVS Integration Options
        constexpr uint32_t IP_ERA = (8 << 24);  ///< IP Era 00h - Era 1 or 2 03h - Era 3 04h - Era 4 05h - Era 5
    }

}

// ============================================================================
// CCM Peripheral
// ============================================================================

namespace ccm {
    /// Base addresses
    constexpr uint32_t CCM_ANALOG_BASE = 0x400D8000;
    constexpr uint32_t CCM_BASE = 0x400FC000;

    /// CCM Register structure
    struct Registers {
        volatile uint32_t PLL_USB1;  ///< Offset: 0x10 - Analog USB1 480MHz PLL Control Register
        volatile uint32_t PLL_USB1_SET;  ///< Offset: 0x14 - Analog USB1 480MHz PLL Control Register
        volatile uint32_t PLL_USB1_CLR;  ///< Offset: 0x18 - Analog USB1 480MHz PLL Control Register
        volatile uint32_t PLL_USB1_TOG;  ///< Offset: 0x1C - Analog USB1 480MHz PLL Control Register
        volatile uint32_t PLL_SYS;  ///< Offset: 0x30 - Analog System PLL Control Register
        volatile uint32_t PLL_SYS_SET;  ///< Offset: 0x34 - Analog System PLL Control Register
        volatile uint32_t PLL_SYS_CLR;  ///< Offset: 0x38 - Analog System PLL Control Register
        volatile uint32_t PLL_SYS_TOG;  ///< Offset: 0x3C - Analog System PLL Control Register
        volatile uint32_t PLL_SYS_SS;  ///< Offset: 0x40 - 528MHz System PLL Spread Spectrum Register
        volatile uint32_t PLL_SYS_NUM;  ///< Offset: 0x50 - Numerator of 528MHz System PLL Fractional Loop Divider Register
        volatile uint32_t PLL_SYS_DENOM;  ///< Offset: 0x60 - Denominator of 528MHz System PLL Fractional Loop Divider Register
        volatile uint32_t PLL_AUDIO;  ///< Offset: 0x70 - Analog Audio PLL control Register
        volatile uint32_t PLL_AUDIO_SET;  ///< Offset: 0x74 - Analog Audio PLL control Register
        volatile uint32_t PLL_AUDIO_CLR;  ///< Offset: 0x78 - Analog Audio PLL control Register
        volatile uint32_t PLL_AUDIO_TOG;  ///< Offset: 0x7C - Analog Audio PLL control Register
        volatile uint32_t PLL_AUDIO_NUM;  ///< Offset: 0x80 - Numerator of Audio PLL Fractional Loop Divider Register
        volatile uint32_t PLL_AUDIO_DENOM;  ///< Offset: 0x90 - Denominator of Audio PLL Fractional Loop Divider Register
        volatile uint32_t PLL_ENET;  ///< Offset: 0xE0 - Analog ENET PLL Control Register
        volatile uint32_t PLL_ENET_SET;  ///< Offset: 0xE4 - Analog ENET PLL Control Register
        volatile uint32_t PLL_ENET_CLR;  ///< Offset: 0xE8 - Analog ENET PLL Control Register
        volatile uint32_t PLL_ENET_TOG;  ///< Offset: 0xEC - Analog ENET PLL Control Register
        volatile uint32_t PFD_480;  ///< Offset: 0xF0 - 480MHz Clock (PLL3) Phase Fractional Divider Control Register
        volatile uint32_t PFD_480_SET;  ///< Offset: 0xF4 - 480MHz Clock (PLL3) Phase Fractional Divider Control Register
        volatile uint32_t PFD_480_CLR;  ///< Offset: 0xF8 - 480MHz Clock (PLL3) Phase Fractional Divider Control Register
        volatile uint32_t PFD_480_TOG;  ///< Offset: 0xFC - 480MHz Clock (PLL3) Phase Fractional Divider Control Register
        volatile uint32_t PFD_528;  ///< Offset: 0x100 - 528MHz Clock (PLL2) Phase Fractional Divider Control Register
        volatile uint32_t PFD_528_SET;  ///< Offset: 0x104 - 528MHz Clock (PLL2) Phase Fractional Divider Control Register
        volatile uint32_t PFD_528_CLR;  ///< Offset: 0x108 - 528MHz Clock (PLL2) Phase Fractional Divider Control Register
        volatile uint32_t PFD_528_TOG;  ///< Offset: 0x10C - 528MHz Clock (PLL2) Phase Fractional Divider Control Register
        volatile uint32_t MISC0;  ///< Offset: 0x150 - Miscellaneous Register 0
        volatile uint32_t MISC0_SET;  ///< Offset: 0x154 - Miscellaneous Register 0
        volatile uint32_t MISC0_CLR;  ///< Offset: 0x158 - Miscellaneous Register 0
        volatile uint32_t MISC0_TOG;  ///< Offset: 0x15C - Miscellaneous Register 0
        volatile uint32_t MISC1;  ///< Offset: 0x160 - Miscellaneous Register 1
        volatile uint32_t MISC1_SET;  ///< Offset: 0x164 - Miscellaneous Register 1
        volatile uint32_t MISC1_CLR;  ///< Offset: 0x168 - Miscellaneous Register 1
        volatile uint32_t MISC1_TOG;  ///< Offset: 0x16C - Miscellaneous Register 1
        volatile uint32_t MISC2;  ///< Offset: 0x170 - Miscellaneous Register 2
        volatile uint32_t MISC2_SET;  ///< Offset: 0x174 - Miscellaneous Register 2
        volatile uint32_t MISC2_CLR;  ///< Offset: 0x178 - Miscellaneous Register 2
        volatile uint32_t MISC2_TOG;  ///< Offset: 0x17C - Miscellaneous Register 2
    };

    /// Peripheral instances
    inline Registers* CCM_ANALOG = reinterpret_cast<Registers*>(CCM_ANALOG_BASE);
    inline Registers* CCM = reinterpret_cast<Registers*>(CCM_BASE);

    // Bit definitions
    /// PLL_USB1 Register bits
    namespace pll_usb1_bits {
        constexpr uint32_t DIV_SELECT = (1U << 1);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t EN_USB_CLKS = (1U << 6);  ///< Powers the 9-phase PLL outputs for USBPHYn
        constexpr uint32_t POWER = (1U << 12);  ///< Powers up the PLL. This bit will be set automatically when USBPHY0 remote wakeup event happens.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_USB1_SET Register bits
    namespace pll_usb1_set_bits {
        constexpr uint32_t DIV_SELECT = (1U << 1);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t EN_USB_CLKS = (1U << 6);  ///< Powers the 9-phase PLL outputs for USBPHYn
        constexpr uint32_t POWER = (1U << 12);  ///< Powers up the PLL. This bit will be set automatically when USBPHY0 remote wakeup event happens.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_USB1_CLR Register bits
    namespace pll_usb1_clr_bits {
        constexpr uint32_t DIV_SELECT = (1U << 1);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t EN_USB_CLKS = (1U << 6);  ///< Powers the 9-phase PLL outputs for USBPHYn
        constexpr uint32_t POWER = (1U << 12);  ///< Powers up the PLL. This bit will be set automatically when USBPHY0 remote wakeup event happens.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_USB1_TOG Register bits
    namespace pll_usb1_tog_bits {
        constexpr uint32_t DIV_SELECT = (1U << 1);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t EN_USB_CLKS = (1U << 6);  ///< Powers the 9-phase PLL outputs for USBPHYn
        constexpr uint32_t POWER = (1U << 12);  ///< Powers up the PLL. This bit will be set automatically when USBPHY0 remote wakeup event happens.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_SYS Register bits
    namespace pll_sys_bits {
        constexpr uint32_t DIV_SELECT = (1U << 0);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_SYS_SET Register bits
    namespace pll_sys_set_bits {
        constexpr uint32_t DIV_SELECT = (1U << 0);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_SYS_CLR Register bits
    namespace pll_sys_clr_bits {
        constexpr uint32_t DIV_SELECT = (1U << 0);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_SYS_TOG Register bits
    namespace pll_sys_tog_bits {
        constexpr uint32_t DIV_SELECT = (1U << 0);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_SYS_SS Register bits
    namespace pll_sys_ss_bits {
        constexpr uint32_t STEP = (15 << 0);  ///< Frequency change step = step/CCM_ANALOG_PLL_SYS_DENOM[B]*24MHz.
        constexpr uint32_t ENABLE = (1U << 15);  ///< Enable bit
        constexpr uint32_t STOP = (16 << 16);  ///< Frequency change = stop/CCM_ANALOG_PLL_SYS_DENOM[B]*24MHz.
    }

    /// PLL_SYS_NUM Register bits
    namespace pll_sys_num_bits {
        constexpr uint32_t A = (30 << 0);  ///< 30 bit numerator (A) of fractional loop divider (signed integer).
    }

    /// PLL_SYS_DENOM Register bits
    namespace pll_sys_denom_bits {
        constexpr uint32_t B = (30 << 0);  ///< 30 bit denominator (B) of fractional loop divider (unsigned integer).
    }

    /// PLL_AUDIO Register bits
    namespace pll_audio_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t POST_DIV_SELECT = (2 << 19);  ///< These bits implement a divider after the PLL, but before the enable and bypass mux.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_AUDIO_SET Register bits
    namespace pll_audio_set_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t POST_DIV_SELECT = (2 << 19);  ///< These bits implement a divider after the PLL, but before the enable and bypass mux.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_AUDIO_CLR Register bits
    namespace pll_audio_clr_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t POST_DIV_SELECT = (2 << 19);  ///< These bits implement a divider after the PLL, but before the enable and bypass mux.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_AUDIO_TOG Register bits
    namespace pll_audio_tog_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t POST_DIV_SELECT = (2 << 19);  ///< These bits implement a divider after the PLL, but before the enable and bypass mux.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_AUDIO_NUM Register bits
    namespace pll_audio_num_bits {
        constexpr uint32_t A = (30 << 0);  ///< 30 bit numerator of fractional loop divider.
    }

    /// PLL_AUDIO_DENOM Register bits
    namespace pll_audio_denom_bits {
        constexpr uint32_t B = (30 << 0);  ///< 30 bit denominator of fractional loop divider.
    }

    /// PLL_ENET Register bits
    namespace pll_enet_bits {
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t ENET_500M_REF_EN = (1U << 22);  ///< Enable the PLL providing ENET 500 MHz reference clock
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_ENET_SET Register bits
    namespace pll_enet_set_bits {
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t ENET_500M_REF_EN = (1U << 22);  ///< Enable the PLL providing ENET 500 MHz reference clock
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_ENET_CLR Register bits
    namespace pll_enet_clr_bits {
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t ENET_500M_REF_EN = (1U << 22);  ///< Enable the PLL providing ENET 500 MHz reference clock
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_ENET_TOG Register bits
    namespace pll_enet_tog_bits {
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t ENET_500M_REF_EN = (1U << 22);  ///< Enable the PLL providing ENET 500 MHz reference clock
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PFD_480 Register bits
    namespace pfd_480_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_480_SET Register bits
    namespace pfd_480_set_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_480_CLR Register bits
    namespace pfd_480_clr_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_480_TOG Register bits
    namespace pfd_480_tog_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_528 Register bits
    namespace pfd_528_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_528_SET Register bits
    namespace pfd_528_set_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_528_CLR Register bits
    namespace pfd_528_clr_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_528_TOG Register bits
    namespace pfd_528_tog_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// MISC0 Register bits
    namespace misc0_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true
    }

    /// MISC0_SET Register bits
    namespace misc0_set_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true
    }

    /// MISC0_CLR Register bits
    namespace misc0_clr_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true
    }

    /// MISC0_TOG Register bits
    namespace misc0_tog_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true
    }

    /// MISC1 Register bits
    namespace misc1_bits {
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC1_SET Register bits
    namespace misc1_set_bits {
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC1_CLR Register bits
    namespace misc1_clr_bits {
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC1_TOG Register bits
    namespace misc1_tog_bits {
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC2 Register bits
    namespace misc2_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_OK = (1U << 6);  ///< ARM supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t PLL3_DISABLE = (1U << 7);  ///< When USB is in low power suspend mode this Control bit is used to indicate if other system peripherals require the USB PLL3 clock when the SoC is not in low power mode
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit. Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_OK = (1U << 14);  ///< GPU supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
    }

    /// MISC2_SET Register bits
    namespace misc2_set_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_OK = (1U << 6);  ///< ARM supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t PLL3_DISABLE = (1U << 7);  ///< When USB is in low power suspend mode this Control bit is used to indicate if other system peripherals require the USB PLL3 clock when the SoC is not in low power mode
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit. Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_OK = (1U << 14);  ///< GPU supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
    }

    /// MISC2_CLR Register bits
    namespace misc2_clr_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_OK = (1U << 6);  ///< ARM supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t PLL3_DISABLE = (1U << 7);  ///< When USB is in low power suspend mode this Control bit is used to indicate if other system peripherals require the USB PLL3 clock when the SoC is not in low power mode
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit. Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_OK = (1U << 14);  ///< GPU supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
    }

    /// MISC2_TOG Register bits
    namespace misc2_tog_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_OK = (1U << 6);  ///< ARM supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t PLL3_DISABLE = (1U << 7);  ///< When USB is in low power suspend mode this Control bit is used to indicate if other system peripherals require the USB PLL3 clock when the SoC is not in low power mode
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit. Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_OK = (1U << 14);  ///< GPU supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
    }

}

// ============================================================================
// PMU Peripheral
// ============================================================================

namespace pmu {
    /// Base addresses
    constexpr uint32_t PMU_BASE = 0x400D8000;

    /// PMU Register structure
    struct Registers {
        volatile uint32_t REG_1P1;  ///< Offset: 0x110 - Regulator 1P1 Register
        volatile uint32_t REG_1P1_SET;  ///< Offset: 0x114 - Regulator 1P1 Register
        volatile uint32_t REG_1P1_CLR;  ///< Offset: 0x118 - Regulator 1P1 Register
        volatile uint32_t REG_1P1_TOG;  ///< Offset: 0x11C - Regulator 1P1 Register
        volatile uint32_t REG_3P0;  ///< Offset: 0x120 - Regulator 3P0 Register
        volatile uint32_t REG_3P0_SET;  ///< Offset: 0x124 - Regulator 3P0 Register
        volatile uint32_t REG_3P0_CLR;  ///< Offset: 0x128 - Regulator 3P0 Register
        volatile uint32_t REG_3P0_TOG;  ///< Offset: 0x12C - Regulator 3P0 Register
        volatile uint32_t REG_2P5;  ///< Offset: 0x130 - Regulator 2P5 Register
        volatile uint32_t REG_2P5_SET;  ///< Offset: 0x134 - Regulator 2P5 Register
        volatile uint32_t REG_2P5_CLR;  ///< Offset: 0x138 - Regulator 2P5 Register
        volatile uint32_t REG_2P5_TOG;  ///< Offset: 0x13C - Regulator 2P5 Register
        volatile uint32_t REG_CORE;  ///< Offset: 0x140 - Digital Regulator Core Register
        volatile uint32_t REG_CORE_SET;  ///< Offset: 0x144 - Digital Regulator Core Register
        volatile uint32_t REG_CORE_CLR;  ///< Offset: 0x148 - Digital Regulator Core Register
        volatile uint32_t REG_CORE_TOG;  ///< Offset: 0x14C - Digital Regulator Core Register
        volatile uint32_t MISC0;  ///< Offset: 0x150 - Miscellaneous Register 0
        volatile uint32_t MISC0_SET;  ///< Offset: 0x154 - Miscellaneous Register 0
        volatile uint32_t MISC0_CLR;  ///< Offset: 0x158 - Miscellaneous Register 0
        volatile uint32_t MISC0_TOG;  ///< Offset: 0x15C - Miscellaneous Register 0
        volatile uint32_t MISC1;  ///< Offset: 0x160 - Miscellaneous Register 1
        volatile uint32_t MISC1_SET;  ///< Offset: 0x164 - Miscellaneous Register 1
        volatile uint32_t MISC1_CLR;  ///< Offset: 0x168 - Miscellaneous Register 1
        volatile uint32_t MISC1_TOG;  ///< Offset: 0x16C - Miscellaneous Register 1
        volatile uint32_t MISC2;  ///< Offset: 0x170 - Miscellaneous Control Register
        volatile uint32_t MISC2_SET;  ///< Offset: 0x174 - Miscellaneous Control Register
        volatile uint32_t MISC2_CLR;  ///< Offset: 0x178 - Miscellaneous Control Register
        volatile uint32_t MISC2_TOG;  ///< Offset: 0x17C - Miscellaneous Control Register
    };

    /// Peripheral instances
    inline Registers* PMU = reinterpret_cast<Registers*>(PMU_BASE);

    // Bit definitions
    /// REG_1P1 Register bits
    namespace reg_1p1_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD1P1 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD1P1 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 1p1 regulator
        constexpr uint32_t SELREF_WEAK_LINREG = (1U << 19);  ///< Selects the source for the reference voltage of the weak 1p1 regulator.
    }

    /// REG_1P1_SET Register bits
    namespace reg_1p1_set_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD1P1 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD1P1 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 1p1 regulator
        constexpr uint32_t SELREF_WEAK_LINREG = (1U << 19);  ///< Selects the source for the reference voltage of the weak 1p1 regulator.
    }

    /// REG_1P1_CLR Register bits
    namespace reg_1p1_clr_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD1P1 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD1P1 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 1p1 regulator
        constexpr uint32_t SELREF_WEAK_LINREG = (1U << 19);  ///< Selects the source for the reference voltage of the weak 1p1 regulator.
    }

    /// REG_1P1_TOG Register bits
    namespace reg_1p1_tog_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD1P1 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD1P1 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 1p1 regulator
        constexpr uint32_t SELREF_WEAK_LINREG = (1U << 19);  ///< Selects the source for the reference voltage of the weak 1p1 regulator.
    }

    /// REG_3P0 Register bits
    namespace reg_3p0_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t VBUS_SEL = (1U << 7);  ///< Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or USB_OTG2_VBUS
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD3P0 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD3P0 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
    }

    /// REG_3P0_SET Register bits
    namespace reg_3p0_set_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t VBUS_SEL = (1U << 7);  ///< Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or USB_OTG2_VBUS
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD3P0 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD3P0 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
    }

    /// REG_3P0_CLR Register bits
    namespace reg_3p0_clr_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t VBUS_SEL = (1U << 7);  ///< Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or USB_OTG2_VBUS
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD3P0 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD3P0 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
    }

    /// REG_3P0_TOG Register bits
    namespace reg_3p0_tog_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t VBUS_SEL = (1U << 7);  ///< Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or USB_OTG2_VBUS
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD3P0 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD3P0 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
    }

    /// REG_2P5 Register bits
    namespace reg_2p5_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD2P5 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD2P5 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 2p5 regulator
    }

    /// REG_2P5_SET Register bits
    namespace reg_2p5_set_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD2P5 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD2P5 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 2p5 regulator
    }

    /// REG_2P5_CLR Register bits
    namespace reg_2p5_clr_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD2P5 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD2P5 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 2p5 regulator
    }

    /// REG_2P5_TOG Register bits
    namespace reg_2p5_tog_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD2P5 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD2P5 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 2p5 regulator
    }

    /// REG_CORE Register bits
    namespace reg_core_bits {
        constexpr uint32_t REG0_TARG = (5 << 0);  ///< This field defines the target voltage for the ARM core power domain
        constexpr uint32_t REG0_ADJ = (4 << 5);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg0. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG1_TARG = (5 << 9);  ///< This bit field defines the target voltage for the vpu/gpu power domain. Single bit increments reflect 25mV core voltage steps. Not all steps will make sense to use either because of input supply limitations or load operation.
        constexpr uint32_t REG1_ADJ = (4 << 14);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg1. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG2_TARG = (5 << 18);  ///< This field defines the target voltage for the SOC power domain
        constexpr uint32_t REG2_ADJ = (4 << 23);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg2. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t RAMP_RATE = (2 << 27);  ///< Regulator voltage ramp rate.
        constexpr uint32_t FET_ODRIVE = (1U << 29);  ///< If set, increases the gate drive on power gating FETs to reduce leakage in the off state
    }

    /// REG_CORE_SET Register bits
    namespace reg_core_set_bits {
        constexpr uint32_t REG0_TARG = (5 << 0);  ///< This field defines the target voltage for the ARM core power domain
        constexpr uint32_t REG0_ADJ = (4 << 5);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg0. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG1_TARG = (5 << 9);  ///< This bit field defines the target voltage for the vpu/gpu power domain. Single bit increments reflect 25mV core voltage steps. Not all steps will make sense to use either because of input supply limitations or load operation.
        constexpr uint32_t REG1_ADJ = (4 << 14);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg1. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG2_TARG = (5 << 18);  ///< This field defines the target voltage for the SOC power domain
        constexpr uint32_t REG2_ADJ = (4 << 23);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg2. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t RAMP_RATE = (2 << 27);  ///< Regulator voltage ramp rate.
        constexpr uint32_t FET_ODRIVE = (1U << 29);  ///< If set, increases the gate drive on power gating FETs to reduce leakage in the off state
    }

    /// REG_CORE_CLR Register bits
    namespace reg_core_clr_bits {
        constexpr uint32_t REG0_TARG = (5 << 0);  ///< This field defines the target voltage for the ARM core power domain
        constexpr uint32_t REG0_ADJ = (4 << 5);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg0. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG1_TARG = (5 << 9);  ///< This bit field defines the target voltage for the vpu/gpu power domain. Single bit increments reflect 25mV core voltage steps. Not all steps will make sense to use either because of input supply limitations or load operation.
        constexpr uint32_t REG1_ADJ = (4 << 14);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg1. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG2_TARG = (5 << 18);  ///< This field defines the target voltage for the SOC power domain
        constexpr uint32_t REG2_ADJ = (4 << 23);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg2. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t RAMP_RATE = (2 << 27);  ///< Regulator voltage ramp rate.
        constexpr uint32_t FET_ODRIVE = (1U << 29);  ///< If set, increases the gate drive on power gating FETs to reduce leakage in the off state
    }

    /// REG_CORE_TOG Register bits
    namespace reg_core_tog_bits {
        constexpr uint32_t REG0_TARG = (5 << 0);  ///< This field defines the target voltage for the ARM core power domain
        constexpr uint32_t REG0_ADJ = (4 << 5);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg0. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG1_TARG = (5 << 9);  ///< This bit field defines the target voltage for the vpu/gpu power domain. Single bit increments reflect 25mV core voltage steps. Not all steps will make sense to use either because of input supply limitations or load operation.
        constexpr uint32_t REG1_ADJ = (4 << 14);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg1. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG2_TARG = (5 << 18);  ///< This field defines the target voltage for the SOC power domain
        constexpr uint32_t REG2_ADJ = (4 << 23);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg2. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t RAMP_RATE = (2 << 27);  ///< Regulator voltage ramp rate.
        constexpr uint32_t FET_ODRIVE = (1U << 29);  ///< If set, increases the gate drive on power gating FETs to reduce leakage in the off state
    }

    /// MISC0 Register bits
    namespace misc0_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_PWDVBGUP = (1U << 1);  ///< Control bit to power down the VBG-up detection circuitry in the analog bandgap.
        constexpr uint32_t REFTOP_LOWPOWER = (1U << 2);  ///< Control bit to enable the low-power mode in the analog bandgap.
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< no description available
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable. 1 - Stable.
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
    }

    /// MISC0_SET Register bits
    namespace misc0_set_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_PWDVBGUP = (1U << 1);  ///< Control bit to power down the VBG-up detection circuitry in the analog bandgap.
        constexpr uint32_t REFTOP_LOWPOWER = (1U << 2);  ///< Control bit to enable the low-power mode in the analog bandgap.
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< no description available
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable. 1 - Stable.
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
    }

    /// MISC0_CLR Register bits
    namespace misc0_clr_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_PWDVBGUP = (1U << 1);  ///< Control bit to power down the VBG-up detection circuitry in the analog bandgap.
        constexpr uint32_t REFTOP_LOWPOWER = (1U << 2);  ///< Control bit to enable the low-power mode in the analog bandgap.
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< no description available
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable. 1 - Stable.
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
    }

    /// MISC0_TOG Register bits
    namespace misc0_tog_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_PWDVBGUP = (1U << 1);  ///< Control bit to power down the VBG-up detection circuitry in the analog bandgap.
        constexpr uint32_t REFTOP_LOWPOWER = (1U << 2);  ///< Control bit to enable the low-power mode in the analog bandgap.
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< no description available
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable. 1 - Stable.
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
    }

    /// MISC1 Register bits
    namespace misc1_bits {
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC1_SET Register bits
    namespace misc1_set_bits {
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC1_CLR Register bits
    namespace misc1_clr_bits {
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC1_TOG Register bits
    namespace misc1_tog_bits {
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC2 Register bits
    namespace misc2_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.
        constexpr uint32_t PLL3_disable = (1U << 7);  ///< Default value of "0"
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit.
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).
    }

    /// MISC2_SET Register bits
    namespace misc2_set_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.
        constexpr uint32_t PLL3_disable = (1U << 7);  ///< Default value of "0"
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit.
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).
    }

    /// MISC2_CLR Register bits
    namespace misc2_clr_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.
        constexpr uint32_t PLL3_disable = (1U << 7);  ///< Default value of "0"
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit.
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).
    }

    /// MISC2_TOG Register bits
    namespace misc2_tog_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.
        constexpr uint32_t PLL3_disable = (1U << 7);  ///< Default value of "0"
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit.
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).
    }

}

// ============================================================================
// TEMPMON Peripheral
// ============================================================================

namespace tempmon {
    /// Base addresses
    constexpr uint32_t TEMPMON_BASE = 0x400D8000;

    /// TEMPMON Register structure
    struct Registers {
        volatile uint32_t TEMPSENSE0;  ///< Offset: 0x180 - Tempsensor Control Register 0
        volatile uint32_t TEMPSENSE0_SET;  ///< Offset: 0x184 - Tempsensor Control Register 0
        volatile uint32_t TEMPSENSE0_CLR;  ///< Offset: 0x188 - Tempsensor Control Register 0
        volatile uint32_t TEMPSENSE0_TOG;  ///< Offset: 0x18C - Tempsensor Control Register 0
        volatile uint32_t TEMPSENSE1;  ///< Offset: 0x190 - Tempsensor Control Register 1
        volatile uint32_t TEMPSENSE1_SET;  ///< Offset: 0x194 - Tempsensor Control Register 1
        volatile uint32_t TEMPSENSE1_CLR;  ///< Offset: 0x198 - Tempsensor Control Register 1
        volatile uint32_t TEMPSENSE1_TOG;  ///< Offset: 0x19C - Tempsensor Control Register 1
        volatile uint32_t TEMPSENSE2;  ///< Offset: 0x290 - Tempsensor Control Register 2
        volatile uint32_t TEMPSENSE2_SET;  ///< Offset: 0x294 - Tempsensor Control Register 2
        volatile uint32_t TEMPSENSE2_CLR;  ///< Offset: 0x298 - Tempsensor Control Register 2
        volatile uint32_t TEMPSENSE2_TOG;  ///< Offset: 0x29C - Tempsensor Control Register 2
    };

    /// Peripheral instances
    inline Registers* TEMPMON = reinterpret_cast<Registers*>(TEMPMON_BASE);

    // Bit definitions
    /// TEMPSENSE0 Register bits
    namespace tempsense0_bits {
        constexpr uint32_t POWER_DOWN = (1U << 0);  ///< This bit powers down the temperature sensor.
        constexpr uint32_t MEASURE_TEMP = (1U << 1);  ///< Starts the measurement process
        constexpr uint32_t FINISHED = (1U << 2);  ///< Indicates that the latest temp is valid
        constexpr uint32_t TEMP_CNT = (12 << 8);  ///< This bit field contains the last measured temperature count.
        constexpr uint32_t ALARM_VALUE = (12 << 20);  ///< This bit field contains the temperature count (raw sensor output) that will generate a high alarm when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE0_SET Register bits
    namespace tempsense0_set_bits {
        constexpr uint32_t POWER_DOWN = (1U << 0);  ///< This bit powers down the temperature sensor.
        constexpr uint32_t MEASURE_TEMP = (1U << 1);  ///< Starts the measurement process
        constexpr uint32_t FINISHED = (1U << 2);  ///< Indicates that the latest temp is valid
        constexpr uint32_t TEMP_CNT = (12 << 8);  ///< This bit field contains the last measured temperature count.
        constexpr uint32_t ALARM_VALUE = (12 << 20);  ///< This bit field contains the temperature count (raw sensor output) that will generate a high alarm when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE0_CLR Register bits
    namespace tempsense0_clr_bits {
        constexpr uint32_t POWER_DOWN = (1U << 0);  ///< This bit powers down the temperature sensor.
        constexpr uint32_t MEASURE_TEMP = (1U << 1);  ///< Starts the measurement process
        constexpr uint32_t FINISHED = (1U << 2);  ///< Indicates that the latest temp is valid
        constexpr uint32_t TEMP_CNT = (12 << 8);  ///< This bit field contains the last measured temperature count.
        constexpr uint32_t ALARM_VALUE = (12 << 20);  ///< This bit field contains the temperature count (raw sensor output) that will generate a high alarm when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE0_TOG Register bits
    namespace tempsense0_tog_bits {
        constexpr uint32_t POWER_DOWN = (1U << 0);  ///< This bit powers down the temperature sensor.
        constexpr uint32_t MEASURE_TEMP = (1U << 1);  ///< Starts the measurement process
        constexpr uint32_t FINISHED = (1U << 2);  ///< Indicates that the latest temp is valid
        constexpr uint32_t TEMP_CNT = (12 << 8);  ///< This bit field contains the last measured temperature count.
        constexpr uint32_t ALARM_VALUE = (12 << 20);  ///< This bit field contains the temperature count (raw sensor output) that will generate a high alarm when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE1 Register bits
    namespace tempsense1_bits {
        constexpr uint32_t MEASURE_FREQ = (16 << 0);  ///< This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement
    }

    /// TEMPSENSE1_SET Register bits
    namespace tempsense1_set_bits {
        constexpr uint32_t MEASURE_FREQ = (16 << 0);  ///< This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement
    }

    /// TEMPSENSE1_CLR Register bits
    namespace tempsense1_clr_bits {
        constexpr uint32_t MEASURE_FREQ = (16 << 0);  ///< This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement
    }

    /// TEMPSENSE1_TOG Register bits
    namespace tempsense1_tog_bits {
        constexpr uint32_t MEASURE_FREQ = (16 << 0);  ///< This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement
    }

    /// TEMPSENSE2 Register bits
    namespace tempsense2_bits {
        constexpr uint32_t LOW_ALARM_VALUE = (12 << 0);  ///< This bit field contains the temperature count that will generate a low alarm interrupt when the field is exceeded by TEMP_CNT
        constexpr uint32_t PANIC_ALARM_VALUE = (12 << 16);  ///< This bit field contains the temperature count that will generate a panic interrupt when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE2_SET Register bits
    namespace tempsense2_set_bits {
        constexpr uint32_t LOW_ALARM_VALUE = (12 << 0);  ///< This bit field contains the temperature count that will generate a low alarm interrupt when the field is exceeded by TEMP_CNT
        constexpr uint32_t PANIC_ALARM_VALUE = (12 << 16);  ///< This bit field contains the temperature count that will generate a panic interrupt when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE2_CLR Register bits
    namespace tempsense2_clr_bits {
        constexpr uint32_t LOW_ALARM_VALUE = (12 << 0);  ///< This bit field contains the temperature count that will generate a low alarm interrupt when the field is exceeded by TEMP_CNT
        constexpr uint32_t PANIC_ALARM_VALUE = (12 << 16);  ///< This bit field contains the temperature count that will generate a panic interrupt when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE2_TOG Register bits
    namespace tempsense2_tog_bits {
        constexpr uint32_t LOW_ALARM_VALUE = (12 << 0);  ///< This bit field contains the temperature count that will generate a low alarm interrupt when the field is exceeded by TEMP_CNT
        constexpr uint32_t PANIC_ALARM_VALUE = (12 << 16);  ///< This bit field contains the temperature count that will generate a panic interrupt when TEMP_CNT is smaller than this field
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_ANALOG_BASE = 0x400D8000;
    constexpr uint32_t USBPHY_BASE = 0x400D9000;
    constexpr uint32_t USB_BASE = 0x400E4000;
    constexpr uint32_t USBNC_BASE = 0x400E4000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t USB1_VBUS_DETECT;  ///< Offset: 0x1A0 - USB VBUS Detect Register
        volatile uint32_t USB1_VBUS_DETECT_SET;  ///< Offset: 0x1A4 - USB VBUS Detect Register
        volatile uint32_t USB1_VBUS_DETECT_CLR;  ///< Offset: 0x1A8 - USB VBUS Detect Register
        volatile uint32_t USB1_VBUS_DETECT_TOG;  ///< Offset: 0x1AC - USB VBUS Detect Register
        volatile uint32_t USB1_CHRG_DETECT;  ///< Offset: 0x1B0 - USB Charger Detect Register
        volatile uint32_t USB1_CHRG_DETECT_SET;  ///< Offset: 0x1B4 - USB Charger Detect Register
        volatile uint32_t USB1_CHRG_DETECT_CLR;  ///< Offset: 0x1B8 - USB Charger Detect Register
        volatile uint32_t USB1_CHRG_DETECT_TOG;  ///< Offset: 0x1BC - USB Charger Detect Register
        volatile uint32_t USB1_VBUS_DETECT_STAT;  ///< Offset: 0x1C0 - USB VBUS Detect Status Register
        volatile uint32_t USB1_CHRG_DETECT_STAT;  ///< Offset: 0x1D0 - USB Charger Detect Status Register
        volatile uint32_t USB1_LOOPBACK;  ///< Offset: 0x1E0 - USB Loopback Test Register
        volatile uint32_t USB1_LOOPBACK_SET;  ///< Offset: 0x1E4 - USB Loopback Test Register
        volatile uint32_t USB1_LOOPBACK_CLR;  ///< Offset: 0x1E8 - USB Loopback Test Register
        volatile uint32_t USB1_LOOPBACK_TOG;  ///< Offset: 0x1EC - USB Loopback Test Register
        volatile uint32_t USB1_MISC;  ///< Offset: 0x1F0 - USB Misc Register
        volatile uint32_t USB1_MISC_SET;  ///< Offset: 0x1F4 - USB Misc Register
        volatile uint32_t USB1_MISC_CLR;  ///< Offset: 0x1F8 - USB Misc Register
        volatile uint32_t USB1_MISC_TOG;  ///< Offset: 0x1FC - USB Misc Register
        volatile uint32_t DIGPROG;  ///< Offset: 0x260 - Chip Silicon Version
    };

    /// Peripheral instances
    inline Registers* USB_ANALOG = reinterpret_cast<Registers*>(USB_ANALOG_BASE);
    inline Registers* USBPHY = reinterpret_cast<Registers*>(USBPHY_BASE);
    inline Registers* USB = reinterpret_cast<Registers*>(USB_BASE);
    inline Registers* USBNC = reinterpret_cast<Registers*>(USBNC_BASE);

    // Bit definitions
    /// USB1_VBUS_DETECT Register bits
    namespace usb1_vbus_detect_bits {
        constexpr uint32_t VBUSVALID_THRESH = (3 << 0);  ///< Set the threshold for the VBUSVALID comparator
        constexpr uint32_t VBUSVALID_PWRUP_CMPS = (1U << 20);  ///< Powers up comparators for vbus_valid detector.
        constexpr uint32_t DISCHARGE_VBUS = (1U << 26);  ///< USB OTG discharge VBUS.
        constexpr uint32_t CHARGE_VBUS = (1U << 27);  ///< USB OTG charge VBUS.
    }

    /// USB1_VBUS_DETECT_SET Register bits
    namespace usb1_vbus_detect_set_bits {
        constexpr uint32_t VBUSVALID_THRESH = (3 << 0);  ///< Set the threshold for the VBUSVALID comparator
        constexpr uint32_t VBUSVALID_PWRUP_CMPS = (1U << 20);  ///< Powers up comparators for vbus_valid detector.
        constexpr uint32_t DISCHARGE_VBUS = (1U << 26);  ///< USB OTG discharge VBUS.
        constexpr uint32_t CHARGE_VBUS = (1U << 27);  ///< USB OTG charge VBUS.
    }

    /// USB1_VBUS_DETECT_CLR Register bits
    namespace usb1_vbus_detect_clr_bits {
        constexpr uint32_t VBUSVALID_THRESH = (3 << 0);  ///< Set the threshold for the VBUSVALID comparator
        constexpr uint32_t VBUSVALID_PWRUP_CMPS = (1U << 20);  ///< Powers up comparators for vbus_valid detector.
        constexpr uint32_t DISCHARGE_VBUS = (1U << 26);  ///< USB OTG discharge VBUS.
        constexpr uint32_t CHARGE_VBUS = (1U << 27);  ///< USB OTG charge VBUS.
    }

    /// USB1_VBUS_DETECT_TOG Register bits
    namespace usb1_vbus_detect_tog_bits {
        constexpr uint32_t VBUSVALID_THRESH = (3 << 0);  ///< Set the threshold for the VBUSVALID comparator
        constexpr uint32_t VBUSVALID_PWRUP_CMPS = (1U << 20);  ///< Powers up comparators for vbus_valid detector.
        constexpr uint32_t DISCHARGE_VBUS = (1U << 26);  ///< USB OTG discharge VBUS.
        constexpr uint32_t CHARGE_VBUS = (1U << 27);  ///< USB OTG charge VBUS.
    }

    /// USB1_CHRG_DETECT Register bits
    namespace usb1_chrg_detect_bits {
        constexpr uint32_t CHK_CONTACT = (1U << 18);  ///< Check the contact of USB plug
        constexpr uint32_t CHK_CHRG_B = (1U << 19);  ///< Check the charger connection
        constexpr uint32_t EN_B = (1U << 20);  ///< Control the charger detector.
    }

    /// USB1_CHRG_DETECT_SET Register bits
    namespace usb1_chrg_detect_set_bits {
        constexpr uint32_t CHK_CONTACT = (1U << 18);  ///< Check the contact of USB plug
        constexpr uint32_t CHK_CHRG_B = (1U << 19);  ///< Check the charger connection
        constexpr uint32_t EN_B = (1U << 20);  ///< Control the charger detector.
    }

    /// USB1_CHRG_DETECT_CLR Register bits
    namespace usb1_chrg_detect_clr_bits {
        constexpr uint32_t CHK_CONTACT = (1U << 18);  ///< Check the contact of USB plug
        constexpr uint32_t CHK_CHRG_B = (1U << 19);  ///< Check the charger connection
        constexpr uint32_t EN_B = (1U << 20);  ///< Control the charger detector.
    }

    /// USB1_CHRG_DETECT_TOG Register bits
    namespace usb1_chrg_detect_tog_bits {
        constexpr uint32_t CHK_CONTACT = (1U << 18);  ///< Check the contact of USB plug
        constexpr uint32_t CHK_CHRG_B = (1U << 19);  ///< Check the charger connection
        constexpr uint32_t EN_B = (1U << 20);  ///< Control the charger detector.
    }

    /// USB1_VBUS_DETECT_STAT Register bits
    namespace usb1_vbus_detect_stat_bits {
        constexpr uint32_t SESSEND = (1U << 0);  ///< Session End for USB OTG
        constexpr uint32_t BVALID = (1U << 1);  ///< Indicates VBus is valid for a B-peripheral
        constexpr uint32_t AVALID = (1U << 2);  ///< Indicates VBus is valid for a A-peripheral
        constexpr uint32_t VBUS_VALID = (1U << 3);  ///< VBus valid for USB OTG
    }

    /// USB1_CHRG_DETECT_STAT Register bits
    namespace usb1_chrg_detect_stat_bits {
        constexpr uint32_t PLUG_CONTACT = (1U << 0);  ///< State of the USB plug contact detector.
        constexpr uint32_t CHRG_DETECTED = (1U << 1);  ///< State of charger detection. This bit is a read only version of the state of the analog signal.
        constexpr uint32_t DM_STATE = (1U << 2);  ///< DM line state output of the charger detector.
        constexpr uint32_t DP_STATE = (1U << 3);  ///< DP line state output of the charger detector.
    }

    /// USB1_LOOPBACK Register bits
    namespace usb1_loopback_bits {
        constexpr uint32_t UTMI_TESTSTART = (1U << 0);  ///< Setting this bit can enable 1
    }

    /// USB1_LOOPBACK_SET Register bits
    namespace usb1_loopback_set_bits {
        constexpr uint32_t UTMI_TESTSTART = (1U << 0);  ///< Setting this bit can enable 1
    }

    /// USB1_LOOPBACK_CLR Register bits
    namespace usb1_loopback_clr_bits {
        constexpr uint32_t UTMI_TESTSTART = (1U << 0);  ///< Setting this bit can enable 1
    }

    /// USB1_LOOPBACK_TOG Register bits
    namespace usb1_loopback_tog_bits {
        constexpr uint32_t UTMI_TESTSTART = (1U << 0);  ///< Setting this bit can enable 1
    }

    /// USB1_MISC Register bits
    namespace usb1_misc_bits {
        constexpr uint32_t HS_USE_EXTERNAL_R = (1U << 0);  ///< Use external resistor to generate the current bias for the high speed transmitter
        constexpr uint32_t EN_DEGLITCH = (1U << 1);  ///< Enable the deglitching circuit of the USB PLL output.
        constexpr uint32_t EN_CLK_UTMI = (1U << 30);  ///< Enables the clk to the UTMI block.
    }

    /// USB1_MISC_SET Register bits
    namespace usb1_misc_set_bits {
        constexpr uint32_t HS_USE_EXTERNAL_R = (1U << 0);  ///< Use external resistor to generate the current bias for the high speed transmitter
        constexpr uint32_t EN_DEGLITCH = (1U << 1);  ///< Enable the deglitching circuit of the USB PLL output.
        constexpr uint32_t EN_CLK_UTMI = (1U << 30);  ///< Enables the clk to the UTMI block.
    }

    /// USB1_MISC_CLR Register bits
    namespace usb1_misc_clr_bits {
        constexpr uint32_t HS_USE_EXTERNAL_R = (1U << 0);  ///< Use external resistor to generate the current bias for the high speed transmitter
        constexpr uint32_t EN_DEGLITCH = (1U << 1);  ///< Enable the deglitching circuit of the USB PLL output.
        constexpr uint32_t EN_CLK_UTMI = (1U << 30);  ///< Enables the clk to the UTMI block.
    }

    /// USB1_MISC_TOG Register bits
    namespace usb1_misc_tog_bits {
        constexpr uint32_t HS_USE_EXTERNAL_R = (1U << 0);  ///< Use external resistor to generate the current bias for the high speed transmitter
        constexpr uint32_t EN_DEGLITCH = (1U << 1);  ///< Enable the deglitching circuit of the USB PLL output.
        constexpr uint32_t EN_CLK_UTMI = (1U << 30);  ///< Enables the clk to the UTMI block.
    }

    /// DIGPROG Register bits
    namespace digprog_bits {
        constexpr uint32_t SILICON_REVISION = (32 << 0);  ///< Chip silicon revision
    }

}

// ============================================================================
// XTALOSC24M Peripheral
// ============================================================================

namespace xtalosc24m {
    /// Base addresses
    constexpr uint32_t XTALOSC24M_BASE = 0x400D8000;

    /// XTALOSC24M Register structure
    struct Registers {
        volatile uint32_t MISC0;  ///< Offset: 0x150 - Miscellaneous Register 0
        volatile uint32_t MISC0_SET;  ///< Offset: 0x154 - Miscellaneous Register 0
        volatile uint32_t MISC0_CLR;  ///< Offset: 0x158 - Miscellaneous Register 0
        volatile uint32_t MISC0_TOG;  ///< Offset: 0x15C - Miscellaneous Register 0
        volatile uint32_t LOWPWR_CTRL;  ///< Offset: 0x270 - XTAL OSC (LP) Control Register
        volatile uint32_t LOWPWR_CTRL_SET;  ///< Offset: 0x274 - XTAL OSC (LP) Control Register
        volatile uint32_t LOWPWR_CTRL_CLR;  ///< Offset: 0x278 - XTAL OSC (LP) Control Register
        volatile uint32_t LOWPWR_CTRL_TOG;  ///< Offset: 0x27C - XTAL OSC (LP) Control Register
        volatile uint32_t OSC_CONFIG0;  ///< Offset: 0x2A0 - XTAL OSC Configuration 0 Register
        volatile uint32_t OSC_CONFIG0_SET;  ///< Offset: 0x2A4 - XTAL OSC Configuration 0 Register
        volatile uint32_t OSC_CONFIG0_CLR;  ///< Offset: 0x2A8 - XTAL OSC Configuration 0 Register
        volatile uint32_t OSC_CONFIG0_TOG;  ///< Offset: 0x2AC - XTAL OSC Configuration 0 Register
        volatile uint32_t OSC_CONFIG1;  ///< Offset: 0x2B0 - XTAL OSC Configuration 1 Register
        volatile uint32_t OSC_CONFIG1_SET;  ///< Offset: 0x2B4 - XTAL OSC Configuration 1 Register
        volatile uint32_t OSC_CONFIG1_CLR;  ///< Offset: 0x2B8 - XTAL OSC Configuration 1 Register
        volatile uint32_t OSC_CONFIG1_TOG;  ///< Offset: 0x2BC - XTAL OSC Configuration 1 Register
        volatile uint32_t OSC_CONFIG2;  ///< Offset: 0x2C0 - XTAL OSC Configuration 2 Register
        volatile uint32_t OSC_CONFIG2_SET;  ///< Offset: 0x2C4 - XTAL OSC Configuration 2 Register
        volatile uint32_t OSC_CONFIG2_CLR;  ///< Offset: 0x2C8 - XTAL OSC Configuration 2 Register
        volatile uint32_t OSC_CONFIG2_TOG;  ///< Offset: 0x2CC - XTAL OSC Configuration 2 Register
    };

    /// Peripheral instances
    inline Registers* XTALOSC24M = reinterpret_cast<Registers*>(XTALOSC24M_BASE);

    // Bit definitions
    /// MISC0 Register bits
    namespace misc0_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to oscillator.
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.Not related to oscillator.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable.
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
        constexpr uint32_t VID_PLL_PREDIV = (1U << 31);  ///< Predivider for the source clock of the PLL's. Not related to oscillator.
    }

    /// MISC0_SET Register bits
    namespace misc0_set_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to oscillator.
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.Not related to oscillator.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable.
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
        constexpr uint32_t VID_PLL_PREDIV = (1U << 31);  ///< Predivider for the source clock of the PLL's. Not related to oscillator.
    }

    /// MISC0_CLR Register bits
    namespace misc0_clr_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to oscillator.
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.Not related to oscillator.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable.
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
        constexpr uint32_t VID_PLL_PREDIV = (1U << 31);  ///< Predivider for the source clock of the PLL's. Not related to oscillator.
    }

    /// MISC0_TOG Register bits
    namespace misc0_tog_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to oscillator.
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.Not related to oscillator.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable.
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
        constexpr uint32_t VID_PLL_PREDIV = (1U << 31);  ///< Predivider for the source clock of the PLL's. Not related to oscillator.
    }

    /// LOWPWR_CTRL Register bits
    namespace lowpwr_ctrl_bits {
        constexpr uint32_t RC_OSC_EN = (1U << 0);  ///< RC Osc. enable control.
        constexpr uint32_t OSC_SEL = (1U << 4);  ///< Select the source for the 24MHz clock.
        constexpr uint32_t LPBG_SEL = (1U << 5);  ///< Bandgap select. Not related to oscillator.
        constexpr uint32_t LPBG_TEST = (1U << 6);  ///< Low power bandgap test bit. Not related to oscillator.
        constexpr uint32_t REFTOP_IBIAS_OFF = (1U << 7);  ///< Low power reftop ibias disable. Not related to oscillator.
        constexpr uint32_t L1_PWRGATE = (1U << 8);  ///< L1 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t L2_PWRGATE = (1U << 9);  ///< L2 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t CPU_PWRGATE = (1U << 10);  ///< CPU power gate control. Used as software override. Test purpose only Not related to oscillator.
        constexpr uint32_t DISPLAY_PWRGATE = (1U << 11);  ///< Display logic power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t RCOSC_CG_OVERRIDE = (1U << 13);  ///< For debug purposes only
        constexpr uint32_t XTALOSC_PWRUP_DELAY = (2 << 14);  ///< Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use
        constexpr uint32_t XTALOSC_PWRUP_STAT = (1U << 16);  ///< Status of the 24MHz xtal oscillator.
        constexpr uint32_t MIX_PWRGATE = (1U << 17);  ///< Display power gate control. Used as software mask. Set to zero to force ungated.
        constexpr uint32_t GPU_PWRGATE = (1U << 18);  ///< GPU power gate control. Used as software mask. Set to zero to force ungated.
    }

    /// LOWPWR_CTRL_SET Register bits
    namespace lowpwr_ctrl_set_bits {
        constexpr uint32_t RC_OSC_EN = (1U << 0);  ///< RC Osc. enable control.
        constexpr uint32_t OSC_SEL = (1U << 4);  ///< Select the source for the 24MHz clock.
        constexpr uint32_t LPBG_SEL = (1U << 5);  ///< Bandgap select. Not related to oscillator.
        constexpr uint32_t LPBG_TEST = (1U << 6);  ///< Low power bandgap test bit. Not related to oscillator.
        constexpr uint32_t REFTOP_IBIAS_OFF = (1U << 7);  ///< Low power reftop ibias disable. Not related to oscillator.
        constexpr uint32_t L1_PWRGATE = (1U << 8);  ///< L1 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t L2_PWRGATE = (1U << 9);  ///< L2 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t CPU_PWRGATE = (1U << 10);  ///< CPU power gate control. Used as software override. Test purpose only Not related to oscillator.
        constexpr uint32_t DISPLAY_PWRGATE = (1U << 11);  ///< Display logic power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t RCOSC_CG_OVERRIDE = (1U << 13);  ///< For debug purposes only
        constexpr uint32_t XTALOSC_PWRUP_DELAY = (2 << 14);  ///< Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use
        constexpr uint32_t XTALOSC_PWRUP_STAT = (1U << 16);  ///< Status of the 24MHz xtal oscillator.
        constexpr uint32_t MIX_PWRGATE = (1U << 17);  ///< Display power gate control. Used as software mask. Set to zero to force ungated.
        constexpr uint32_t GPU_PWRGATE = (1U << 18);  ///< GPU power gate control. Used as software mask. Set to zero to force ungated.
    }

    /// LOWPWR_CTRL_CLR Register bits
    namespace lowpwr_ctrl_clr_bits {
        constexpr uint32_t RC_OSC_EN = (1U << 0);  ///< RC Osc. enable control.
        constexpr uint32_t OSC_SEL = (1U << 4);  ///< Select the source for the 24MHz clock.
        constexpr uint32_t LPBG_SEL = (1U << 5);  ///< Bandgap select. Not related to oscillator.
        constexpr uint32_t LPBG_TEST = (1U << 6);  ///< Low power bandgap test bit. Not related to oscillator.
        constexpr uint32_t REFTOP_IBIAS_OFF = (1U << 7);  ///< Low power reftop ibias disable. Not related to oscillator.
        constexpr uint32_t L1_PWRGATE = (1U << 8);  ///< L1 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t L2_PWRGATE = (1U << 9);  ///< L2 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t CPU_PWRGATE = (1U << 10);  ///< CPU power gate control. Used as software override. Test purpose only Not related to oscillator.
        constexpr uint32_t DISPLAY_PWRGATE = (1U << 11);  ///< Display logic power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t RCOSC_CG_OVERRIDE = (1U << 13);  ///< For debug purposes only
        constexpr uint32_t XTALOSC_PWRUP_DELAY = (2 << 14);  ///< Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use
        constexpr uint32_t XTALOSC_PWRUP_STAT = (1U << 16);  ///< Status of the 24MHz xtal oscillator.
        constexpr uint32_t MIX_PWRGATE = (1U << 17);  ///< Display power gate control. Used as software mask. Set to zero to force ungated.
        constexpr uint32_t GPU_PWRGATE = (1U << 18);  ///< GPU power gate control. Used as software mask. Set to zero to force ungated.
    }

    /// LOWPWR_CTRL_TOG Register bits
    namespace lowpwr_ctrl_tog_bits {
        constexpr uint32_t RC_OSC_EN = (1U << 0);  ///< RC Osc. enable control.
        constexpr uint32_t OSC_SEL = (1U << 4);  ///< Select the source for the 24MHz clock.
        constexpr uint32_t LPBG_SEL = (1U << 5);  ///< Bandgap select. Not related to oscillator.
        constexpr uint32_t LPBG_TEST = (1U << 6);  ///< Low power bandgap test bit. Not related to oscillator.
        constexpr uint32_t REFTOP_IBIAS_OFF = (1U << 7);  ///< Low power reftop ibias disable. Not related to oscillator.
        constexpr uint32_t L1_PWRGATE = (1U << 8);  ///< L1 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t L2_PWRGATE = (1U << 9);  ///< L2 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t CPU_PWRGATE = (1U << 10);  ///< CPU power gate control. Used as software override. Test purpose only Not related to oscillator.
        constexpr uint32_t DISPLAY_PWRGATE = (1U << 11);  ///< Display logic power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t RCOSC_CG_OVERRIDE = (1U << 13);  ///< For debug purposes only
        constexpr uint32_t XTALOSC_PWRUP_DELAY = (2 << 14);  ///< Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use
        constexpr uint32_t XTALOSC_PWRUP_STAT = (1U << 16);  ///< Status of the 24MHz xtal oscillator.
        constexpr uint32_t MIX_PWRGATE = (1U << 17);  ///< Display power gate control. Used as software mask. Set to zero to force ungated.
        constexpr uint32_t GPU_PWRGATE = (1U << 18);  ///< GPU power gate control. Used as software mask. Set to zero to force ungated.
    }

    /// OSC_CONFIG0 Register bits
    namespace osc_config0_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start/stop bit for the RC tuning calculation logic. If stopped the tuning logic is reset.
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enables the tuning logic to calculate new RC tuning values
        constexpr uint32_t BYPASS = (1U << 2);  ///< Bypasses any calculated RC tuning value and uses the programmed register value.
        constexpr uint32_t INVERT = (1U << 3);  ///< Invert the stepping of the calculated RC tuning value.
        constexpr uint32_t RC_OSC_PROG = (8 << 4);  ///< RC osc. tuning values.
        constexpr uint32_t HYST_PLUS = (4 << 12);  ///< Positive hysteresis value
        constexpr uint32_t HYST_MINUS = (4 << 16);  ///< Negative hysteresis value
        constexpr uint32_t RC_OSC_PROG_CUR = (8 << 24);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG0_SET Register bits
    namespace osc_config0_set_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start/stop bit for the RC tuning calculation logic. If stopped the tuning logic is reset.
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enables the tuning logic to calculate new RC tuning values
        constexpr uint32_t BYPASS = (1U << 2);  ///< Bypasses any calculated RC tuning value and uses the programmed register value.
        constexpr uint32_t INVERT = (1U << 3);  ///< Invert the stepping of the calculated RC tuning value.
        constexpr uint32_t RC_OSC_PROG = (8 << 4);  ///< RC osc. tuning values.
        constexpr uint32_t HYST_PLUS = (4 << 12);  ///< Positive hysteresis value
        constexpr uint32_t HYST_MINUS = (4 << 16);  ///< Negative hysteresis value
        constexpr uint32_t RC_OSC_PROG_CUR = (8 << 24);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG0_CLR Register bits
    namespace osc_config0_clr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start/stop bit for the RC tuning calculation logic. If stopped the tuning logic is reset.
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enables the tuning logic to calculate new RC tuning values
        constexpr uint32_t BYPASS = (1U << 2);  ///< Bypasses any calculated RC tuning value and uses the programmed register value.
        constexpr uint32_t INVERT = (1U << 3);  ///< Invert the stepping of the calculated RC tuning value.
        constexpr uint32_t RC_OSC_PROG = (8 << 4);  ///< RC osc. tuning values.
        constexpr uint32_t HYST_PLUS = (4 << 12);  ///< Positive hysteresis value
        constexpr uint32_t HYST_MINUS = (4 << 16);  ///< Negative hysteresis value
        constexpr uint32_t RC_OSC_PROG_CUR = (8 << 24);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG0_TOG Register bits
    namespace osc_config0_tog_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start/stop bit for the RC tuning calculation logic. If stopped the tuning logic is reset.
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enables the tuning logic to calculate new RC tuning values
        constexpr uint32_t BYPASS = (1U << 2);  ///< Bypasses any calculated RC tuning value and uses the programmed register value.
        constexpr uint32_t INVERT = (1U << 3);  ///< Invert the stepping of the calculated RC tuning value.
        constexpr uint32_t RC_OSC_PROG = (8 << 4);  ///< RC osc. tuning values.
        constexpr uint32_t HYST_PLUS = (4 << 12);  ///< Positive hysteresis value
        constexpr uint32_t HYST_MINUS = (4 << 16);  ///< Negative hysteresis value
        constexpr uint32_t RC_OSC_PROG_CUR = (8 << 24);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG1 Register bits
    namespace osc_config1_bits {
        constexpr uint32_t COUNT_RC_TRG = (12 << 0);  ///< The target count used to tune the RC OSC frequency
        constexpr uint32_t COUNT_RC_CUR = (12 << 20);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG1_SET Register bits
    namespace osc_config1_set_bits {
        constexpr uint32_t COUNT_RC_TRG = (12 << 0);  ///< The target count used to tune the RC OSC frequency
        constexpr uint32_t COUNT_RC_CUR = (12 << 20);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG1_CLR Register bits
    namespace osc_config1_clr_bits {
        constexpr uint32_t COUNT_RC_TRG = (12 << 0);  ///< The target count used to tune the RC OSC frequency
        constexpr uint32_t COUNT_RC_CUR = (12 << 20);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG1_TOG Register bits
    namespace osc_config1_tog_bits {
        constexpr uint32_t COUNT_RC_TRG = (12 << 0);  ///< The target count used to tune the RC OSC frequency
        constexpr uint32_t COUNT_RC_CUR = (12 << 20);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG2 Register bits
    namespace osc_config2_bits {
        constexpr uint32_t COUNT_1M_TRG = (12 << 0);  ///< The target count used to tune the 1MHz clock frequency
        constexpr uint32_t ENABLE_1M = (1U << 16);  ///< Enable the 1MHz clock output. 0 - disabled; 1 - enabled.
        constexpr uint32_t MUX_1M = (1U << 17);  ///< Mux the corrected or uncorrected 1MHz clock to the output
        constexpr uint32_t CLK_1M_ERR_FL = (1U << 31);  ///< Flag indicates that the count_1m count wasn't reached within 1 32kHz period
    }

    /// OSC_CONFIG2_SET Register bits
    namespace osc_config2_set_bits {
        constexpr uint32_t COUNT_1M_TRG = (12 << 0);  ///< The target count used to tune the 1MHz clock frequency
        constexpr uint32_t ENABLE_1M = (1U << 16);  ///< Enable the 1MHz clock output. 0 - disabled; 1 - enabled.
        constexpr uint32_t MUX_1M = (1U << 17);  ///< Mux the corrected or uncorrected 1MHz clock to the output
        constexpr uint32_t CLK_1M_ERR_FL = (1U << 31);  ///< Flag indicates that the count_1m count wasn't reached within 1 32kHz period
    }

    /// OSC_CONFIG2_CLR Register bits
    namespace osc_config2_clr_bits {
        constexpr uint32_t COUNT_1M_TRG = (12 << 0);  ///< The target count used to tune the 1MHz clock frequency
        constexpr uint32_t ENABLE_1M = (1U << 16);  ///< Enable the 1MHz clock output. 0 - disabled; 1 - enabled.
        constexpr uint32_t MUX_1M = (1U << 17);  ///< Mux the corrected or uncorrected 1MHz clock to the output
        constexpr uint32_t CLK_1M_ERR_FL = (1U << 31);  ///< Flag indicates that the count_1m count wasn't reached within 1 32kHz period
    }

    /// OSC_CONFIG2_TOG Register bits
    namespace osc_config2_tog_bits {
        constexpr uint32_t COUNT_1M_TRG = (12 << 0);  ///< The target count used to tune the 1MHz clock frequency
        constexpr uint32_t ENABLE_1M = (1U << 16);  ///< Enable the 1MHz clock output. 0 - disabled; 1 - enabled.
        constexpr uint32_t MUX_1M = (1U << 17);  ///< Mux the corrected or uncorrected 1MHz clock to the output
        constexpr uint32_t CLK_1M_ERR_FL = (1U << 31);  ///< Flag indicates that the count_1m count wasn't reached within 1 32kHz period
    }

}

// ============================================================================
// CSU Peripheral
// ============================================================================

namespace csu {
    /// Base addresses
    constexpr uint32_t CSU_BASE = 0x400DC000;

    /// CSU Register structure
    struct Registers {
        volatile uint32_t CSL%s;  ///< Offset: 0x00 - Config security level register
        volatile uint32_t HP0;  ///< Offset: 0x200 - HP0 register
        volatile uint32_t SA;  ///< Offset: 0x218 - Secure access register
        volatile uint32_t HPCONTROL0;  ///< Offset: 0x358 - HPCONTROL0 register
    };

    /// Peripheral instances
    inline Registers* CSU = reinterpret_cast<Registers*>(CSU_BASE);

    // Bit definitions
    /// CSL%s Register bits
    namespace csl%s_bits {
        constexpr uint32_t SUR_S2 = (1U << 0);  ///< Secure user read access control for the second slave
        constexpr uint32_t SSR_S2 = (1U << 1);  ///< Secure supervisor read access control for the second slave
        constexpr uint32_t NUR_S2 = (1U << 2);  ///< Non-secure user read access control for the second slave
        constexpr uint32_t NSR_S2 = (1U << 3);  ///< Non-secure supervisor read access control for the second slave
        constexpr uint32_t SUW_S2 = (1U << 4);  ///< Secure user write access control for the second slave
        constexpr uint32_t SSW_S2 = (1U << 5);  ///< Secure supervisor write access control for the second slave
        constexpr uint32_t NUW_S2 = (1U << 6);  ///< Non-secure user write access control for the second slave
        constexpr uint32_t NSW_S2 = (1U << 7);  ///< Non-secure supervisor write access control for the second slave
        constexpr uint32_t LOCK_S2 = (1U << 8);  ///< The lock bit corresponding to the second slave. It is written by the secure software.
        constexpr uint32_t SUR_S1 = (1U << 16);  ///< Secure user read access control for the first slave
        constexpr uint32_t SSR_S1 = (1U << 17);  ///< Secure supervisor read access control for the first slave
        constexpr uint32_t NUR_S1 = (1U << 18);  ///< Non-secure user read access control for the first slave
        constexpr uint32_t NSR_S1 = (1U << 19);  ///< Non-secure supervisor read access control for the first slave
        constexpr uint32_t SUW_S1 = (1U << 20);  ///< Secure user write access control for the first slave
        constexpr uint32_t SSW_S1 = (1U << 21);  ///< Secure supervisor write access control for the first slave
        constexpr uint32_t NUW_S1 = (1U << 22);  ///< Non-secure user write access control for the first slave
        constexpr uint32_t NSW_S1 = (1U << 23);  ///< Non-secure supervisor write access control for the first slave
        constexpr uint32_t LOCK_S1 = (1U << 24);  ///< The lock bit corresponding to the first slave. It is written by the secure software.
    }

    /// HP0 Register bits
    namespace hp0_bits {
        constexpr uint32_t HP_DMA = (1U << 2);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the eDMA
        constexpr uint32_t L_DMA = (1U << 3);  ///< Lock bit set by the TZ software for the eDMA
        constexpr uint32_t HP_LCDIF = (1U << 4);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the LCDIF
        constexpr uint32_t L_LCDIF = (1U << 5);  ///< Lock bit set by the TZ software for the LCDIF
        constexpr uint32_t HP_CSI = (1U << 6);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the CSI
        constexpr uint32_t L_CSI = (1U << 7);  ///< Lock bit set by the TZ software for the CSI
        constexpr uint32_t HP_PXP = (1U << 8);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the PXP
        constexpr uint32_t L_PXP = (1U << 9);  ///< Lock bit set by the TZ software for the PXP
        constexpr uint32_t HP_DCP = (1U << 10);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the DCP
        constexpr uint32_t L_DCP = (1U << 11);  ///< Lock bit set by the TZ software for the DCP
        constexpr uint32_t HP_ENET = (1U << 14);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the ENET
        constexpr uint32_t L_ENET = (1U << 15);  ///< Lock bit set by the TZ software for the ENET
        constexpr uint32_t HP_USDHC1 = (1U << 16);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the USDHC1
        constexpr uint32_t L_USDHC1 = (1U << 17);  ///< Lock bit set by the TZ software for the USDHC1
        constexpr uint32_t HP_USDHC2 = (1U << 18);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the USDHC2
        constexpr uint32_t L_USDHC2 = (1U << 19);  ///< Lock bit set by the TZ software for the USDHC2
        constexpr uint32_t HP_TPSMP = (1U << 20);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the TPSMP
        constexpr uint32_t L_TPSMP = (1U << 21);  ///< Lock bit set by the TZ software for the TPSMP
        constexpr uint32_t HP_USB = (1U << 22);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the USB
        constexpr uint32_t L_USB = (1U << 23);  ///< Lock bit set by the TZ software for the USB
    }

    /// SA Register bits
    namespace sa_bits {
        constexpr uint32_t NSA_DMA = (1U << 2);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_DMA = (1U << 3);  ///< Lock bit set by the TZ software for the eDMA
        constexpr uint32_t NSA_LCDIF = (1U << 4);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_LCDIF = (1U << 5);  ///< Lock bit set by the TZ software for the LCDIF
        constexpr uint32_t NSA_CSI = (1U << 6);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_CSI = (1U << 7);  ///< Lock bit set by the TZ software for the CSI
        constexpr uint32_t NSA_PXP = (1U << 8);  ///< Non-Secure Access Policy indicator bit
        constexpr uint32_t L_PXP = (1U << 9);  ///< Lock bit set by the TZ software for the PXP
        constexpr uint32_t NSA_DCP = (1U << 10);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_DCP = (1U << 11);  ///< Lock bit set by the TZ software for the DCP
        constexpr uint32_t NSA_ENET = (1U << 14);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_ENET = (1U << 15);  ///< Lock bit set by the TZ software for the ENET1 and ENET2
        constexpr uint32_t NSA_USDHC1 = (1U << 16);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_USDHC1 = (1U << 17);  ///< Lock bit set by the TZ software for the USDHC1
        constexpr uint32_t NSA_USDHC2 = (1U << 18);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_USDHC2 = (1U << 19);  ///< Lock bit set by the TZ software for the USDHC2
        constexpr uint32_t NSA_TPSMP = (1U << 20);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_TPSMP = (1U << 21);  ///< Lock bit set by the TZ software for the TPSMP
        constexpr uint32_t NSA_USB = (1U << 22);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_USB = (1U << 23);  ///< Lock bit set by the TZ software for the USB
    }

    /// HPCONTROL0 Register bits
    namespace hpcontrol0_bits {
        constexpr uint32_t HPC_DMA = (1U << 2);  ///< Indicates the privilege/user mode for the eDMA
        constexpr uint32_t L_DMA = (1U << 3);  ///< Lock bit set by the TZ software for the eDMA
        constexpr uint32_t HPC_LCDIF = (1U << 4);  ///< Indicates the privilege/user mode for the LCDIF
        constexpr uint32_t L_LCDIF = (1U << 5);  ///< Lock bit set by the TZ software for the LCDIF
        constexpr uint32_t HPC_CSI = (1U << 6);  ///< Indicates the privilege/user mode for the CSI
        constexpr uint32_t L_CSI = (1U << 7);  ///< Lock bit set by the TZ software for the CSI
        constexpr uint32_t HPC_PXP = (1U << 8);  ///< Indicates the privilege/user mode for the PXP
        constexpr uint32_t L_PXP = (1U << 9);  ///< Lock bit set by the TZ software for the PXP
        constexpr uint32_t HPC_DCP = (1U << 10);  ///< Indicates the privilege/user mode for the DCP
        constexpr uint32_t L_DCP = (1U << 11);  ///< Lock bit set by the TZ software for the DCP
        constexpr uint32_t HPC_ENET = (1U << 14);  ///< Indicates the privilege/user mode for the ENET
        constexpr uint32_t L_ENET = (1U << 15);  ///< Lock bit set by the TZ software for the ENET
        constexpr uint32_t HPC_USDHC1 = (1U << 16);  ///< Indicates the privilege/user mode for the USDHC1
        constexpr uint32_t L_USDHC1 = (1U << 17);  ///< Lock bit set by the TZ software for the USDHC1
        constexpr uint32_t HPC_USDHC2 = (1U << 18);  ///< Indicates the privilege/user mode for the USDHC2
        constexpr uint32_t L_USDHC2 = (1U << 19);  ///< Lock bit set by the TZ software for the USDHC2.
        constexpr uint32_t HPC_TPSMP = (1U << 20);  ///< Indicates the privilege/user mode for the TPSMP
        constexpr uint32_t L_TPSMP = (1U << 21);  ///< Lock bit set by the TZ software for the TPSMP.
        constexpr uint32_t HPC_USB = (1U << 22);  ///< Indicates the privilege/user mode for the USB
        constexpr uint32_t L_USB = (1U << 23);  ///< Lock bit set by the TZ software for the USB.
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA0_BASE = 0x400E8000;
    constexpr uint32_t DMAMUX_BASE = 0x400EC000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT;  ///< Offset: 0x24 - Interrupt Request Register
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t EARS;  ///< Offset: 0x44 - Enable Asynchronous Request in Stop Register
        volatile uint32_t DCHPRI3;  ///< Offset: 0x100 - Channel Priority Register
        volatile uint32_t DCHPRI2;  ///< Offset: 0x101 - Channel Priority Register
        volatile uint32_t DCHPRI1;  ///< Offset: 0x102 - Channel Priority Register
        volatile uint32_t DCHPRI0;  ///< Offset: 0x103 - Channel Priority Register
        volatile uint32_t DCHPRI7;  ///< Offset: 0x104 - Channel Priority Register
        volatile uint32_t DCHPRI6;  ///< Offset: 0x105 - Channel Priority Register
        volatile uint32_t DCHPRI5;  ///< Offset: 0x106 - Channel Priority Register
        volatile uint32_t DCHPRI4;  ///< Offset: 0x107 - Channel Priority Register
        volatile uint32_t DCHPRI11;  ///< Offset: 0x108 - Channel Priority Register
        volatile uint32_t DCHPRI10;  ///< Offset: 0x109 - Channel Priority Register
        volatile uint32_t DCHPRI9;  ///< Offset: 0x10A - Channel Priority Register
        volatile uint32_t DCHPRI8;  ///< Offset: 0x10B - Channel Priority Register
        volatile uint32_t DCHPRI15;  ///< Offset: 0x10C - Channel Priority Register
        volatile uint32_t DCHPRI14;  ///< Offset: 0x10D - Channel Priority Register
        volatile uint32_t DCHPRI13;  ///< Offset: 0x10E - Channel Priority Register
        volatile uint32_t DCHPRI12;  ///< Offset: 0x10F - Channel Priority Register
        volatile uint32_t TCD0_SADDR;  ///< Offset: 0x1000 - TCD Source Address
        volatile uint32_t TCD0_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset
        volatile uint32_t TCD0_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes
        volatile uint32_t TCD0_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD0_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD0_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD0_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment
        volatile uint32_t TCD0_DADDR;  ///< Offset: 0x1010 - TCD Destination Address
        volatile uint32_t TCD0_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset
        volatile uint32_t TCD0_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD0_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD0_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD0_CSR;  ///< Offset: 0x101C - TCD Control and Status
        volatile uint32_t TCD0_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD0_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD1_SADDR;  ///< Offset: 0x1020 - TCD Source Address
        volatile uint32_t TCD1_SOFF;  ///< Offset: 0x1024 - TCD Signed Source Address Offset
        volatile uint32_t TCD1_ATTR;  ///< Offset: 0x1026 - TCD Transfer Attributes
        volatile uint32_t TCD1_NBYTES_MLNO;  ///< Offset: 0x1028 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD1_NBYTES_MLOFFNO;  ///< Offset: 0x1028 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD1_NBYTES_MLOFFYES;  ///< Offset: 0x1028 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD1_SLAST;  ///< Offset: 0x102C - TCD Last Source Address Adjustment
        volatile uint32_t TCD1_DADDR;  ///< Offset: 0x1030 - TCD Destination Address
        volatile uint32_t TCD1_DOFF;  ///< Offset: 0x1034 - TCD Signed Destination Address Offset
        volatile uint32_t TCD1_CITER_ELINKNO;  ///< Offset: 0x1036 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD1_CITER_ELINKYES;  ///< Offset: 0x1036 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD1_DLASTSGA;  ///< Offset: 0x1038 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD1_CSR;  ///< Offset: 0x103C - TCD Control and Status
        volatile uint32_t TCD1_BITER_ELINKNO;  ///< Offset: 0x103E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD1_BITER_ELINKYES;  ///< Offset: 0x103E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD2_SADDR;  ///< Offset: 0x1040 - TCD Source Address
        volatile uint32_t TCD2_SOFF;  ///< Offset: 0x1044 - TCD Signed Source Address Offset
        volatile uint32_t TCD2_ATTR;  ///< Offset: 0x1046 - TCD Transfer Attributes
        volatile uint32_t TCD2_NBYTES_MLNO;  ///< Offset: 0x1048 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD2_NBYTES_MLOFFNO;  ///< Offset: 0x1048 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD2_NBYTES_MLOFFYES;  ///< Offset: 0x1048 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD2_SLAST;  ///< Offset: 0x104C - TCD Last Source Address Adjustment
        volatile uint32_t TCD2_DADDR;  ///< Offset: 0x1050 - TCD Destination Address
        volatile uint32_t TCD2_DOFF;  ///< Offset: 0x1054 - TCD Signed Destination Address Offset
        volatile uint32_t TCD2_CITER_ELINKNO;  ///< Offset: 0x1056 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD2_CITER_ELINKYES;  ///< Offset: 0x1056 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD2_DLASTSGA;  ///< Offset: 0x1058 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD2_CSR;  ///< Offset: 0x105C - TCD Control and Status
        volatile uint32_t TCD2_BITER_ELINKNO;  ///< Offset: 0x105E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD2_BITER_ELINKYES;  ///< Offset: 0x105E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD3_SADDR;  ///< Offset: 0x1060 - TCD Source Address
        volatile uint32_t TCD3_SOFF;  ///< Offset: 0x1064 - TCD Signed Source Address Offset
        volatile uint32_t TCD3_ATTR;  ///< Offset: 0x1066 - TCD Transfer Attributes
        volatile uint32_t TCD3_NBYTES_MLNO;  ///< Offset: 0x1068 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD3_NBYTES_MLOFFNO;  ///< Offset: 0x1068 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD3_NBYTES_MLOFFYES;  ///< Offset: 0x1068 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD3_SLAST;  ///< Offset: 0x106C - TCD Last Source Address Adjustment
        volatile uint32_t TCD3_DADDR;  ///< Offset: 0x1070 - TCD Destination Address
        volatile uint32_t TCD3_DOFF;  ///< Offset: 0x1074 - TCD Signed Destination Address Offset
        volatile uint32_t TCD3_CITER_ELINKNO;  ///< Offset: 0x1076 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD3_CITER_ELINKYES;  ///< Offset: 0x1076 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD3_DLASTSGA;  ///< Offset: 0x1078 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD3_CSR;  ///< Offset: 0x107C - TCD Control and Status
        volatile uint32_t TCD3_BITER_ELINKNO;  ///< Offset: 0x107E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD3_BITER_ELINKYES;  ///< Offset: 0x107E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD4_SADDR;  ///< Offset: 0x1080 - TCD Source Address
        volatile uint32_t TCD4_SOFF;  ///< Offset: 0x1084 - TCD Signed Source Address Offset
        volatile uint32_t TCD4_ATTR;  ///< Offset: 0x1086 - TCD Transfer Attributes
        volatile uint32_t TCD4_NBYTES_MLNO;  ///< Offset: 0x1088 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD4_NBYTES_MLOFFNO;  ///< Offset: 0x1088 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD4_NBYTES_MLOFFYES;  ///< Offset: 0x1088 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD4_SLAST;  ///< Offset: 0x108C - TCD Last Source Address Adjustment
        volatile uint32_t TCD4_DADDR;  ///< Offset: 0x1090 - TCD Destination Address
        volatile uint32_t TCD4_DOFF;  ///< Offset: 0x1094 - TCD Signed Destination Address Offset
        volatile uint32_t TCD4_CITER_ELINKNO;  ///< Offset: 0x1096 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD4_CITER_ELINKYES;  ///< Offset: 0x1096 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD4_DLASTSGA;  ///< Offset: 0x1098 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD4_CSR;  ///< Offset: 0x109C - TCD Control and Status
        volatile uint32_t TCD4_BITER_ELINKNO;  ///< Offset: 0x109E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD4_BITER_ELINKYES;  ///< Offset: 0x109E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD5_SADDR;  ///< Offset: 0x10A0 - TCD Source Address
        volatile uint32_t TCD5_SOFF;  ///< Offset: 0x10A4 - TCD Signed Source Address Offset
        volatile uint32_t TCD5_ATTR;  ///< Offset: 0x10A6 - TCD Transfer Attributes
        volatile uint32_t TCD5_NBYTES_MLNO;  ///< Offset: 0x10A8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD5_NBYTES_MLOFFNO;  ///< Offset: 0x10A8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD5_NBYTES_MLOFFYES;  ///< Offset: 0x10A8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD5_SLAST;  ///< Offset: 0x10AC - TCD Last Source Address Adjustment
        volatile uint32_t TCD5_DADDR;  ///< Offset: 0x10B0 - TCD Destination Address
        volatile uint32_t TCD5_DOFF;  ///< Offset: 0x10B4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD5_CITER_ELINKNO;  ///< Offset: 0x10B6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD5_CITER_ELINKYES;  ///< Offset: 0x10B6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD5_DLASTSGA;  ///< Offset: 0x10B8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD5_CSR;  ///< Offset: 0x10BC - TCD Control and Status
        volatile uint32_t TCD5_BITER_ELINKNO;  ///< Offset: 0x10BE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD5_BITER_ELINKYES;  ///< Offset: 0x10BE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD6_SADDR;  ///< Offset: 0x10C0 - TCD Source Address
        volatile uint32_t TCD6_SOFF;  ///< Offset: 0x10C4 - TCD Signed Source Address Offset
        volatile uint32_t TCD6_ATTR;  ///< Offset: 0x10C6 - TCD Transfer Attributes
        volatile uint32_t TCD6_NBYTES_MLNO;  ///< Offset: 0x10C8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD6_NBYTES_MLOFFNO;  ///< Offset: 0x10C8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD6_NBYTES_MLOFFYES;  ///< Offset: 0x10C8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD6_SLAST;  ///< Offset: 0x10CC - TCD Last Source Address Adjustment
        volatile uint32_t TCD6_DADDR;  ///< Offset: 0x10D0 - TCD Destination Address
        volatile uint32_t TCD6_DOFF;  ///< Offset: 0x10D4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD6_CITER_ELINKNO;  ///< Offset: 0x10D6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD6_CITER_ELINKYES;  ///< Offset: 0x10D6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD6_DLASTSGA;  ///< Offset: 0x10D8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD6_CSR;  ///< Offset: 0x10DC - TCD Control and Status
        volatile uint32_t TCD6_BITER_ELINKNO;  ///< Offset: 0x10DE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD6_BITER_ELINKYES;  ///< Offset: 0x10DE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD7_SADDR;  ///< Offset: 0x10E0 - TCD Source Address
        volatile uint32_t TCD7_SOFF;  ///< Offset: 0x10E4 - TCD Signed Source Address Offset
        volatile uint32_t TCD7_ATTR;  ///< Offset: 0x10E6 - TCD Transfer Attributes
        volatile uint32_t TCD7_NBYTES_MLNO;  ///< Offset: 0x10E8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD7_NBYTES_MLOFFNO;  ///< Offset: 0x10E8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD7_NBYTES_MLOFFYES;  ///< Offset: 0x10E8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD7_SLAST;  ///< Offset: 0x10EC - TCD Last Source Address Adjustment
        volatile uint32_t TCD7_DADDR;  ///< Offset: 0x10F0 - TCD Destination Address
        volatile uint32_t TCD7_DOFF;  ///< Offset: 0x10F4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD7_CITER_ELINKNO;  ///< Offset: 0x10F6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD7_CITER_ELINKYES;  ///< Offset: 0x10F6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD7_DLASTSGA;  ///< Offset: 0x10F8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD7_CSR;  ///< Offset: 0x10FC - TCD Control and Status
        volatile uint32_t TCD7_BITER_ELINKNO;  ///< Offset: 0x10FE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD7_BITER_ELINKYES;  ///< Offset: 0x10FE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD8_SADDR;  ///< Offset: 0x1100 - TCD Source Address
        volatile uint32_t TCD8_SOFF;  ///< Offset: 0x1104 - TCD Signed Source Address Offset
        volatile uint32_t TCD8_ATTR;  ///< Offset: 0x1106 - TCD Transfer Attributes
        volatile uint32_t TCD8_NBYTES_MLNO;  ///< Offset: 0x1108 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD8_NBYTES_MLOFFNO;  ///< Offset: 0x1108 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD8_NBYTES_MLOFFYES;  ///< Offset: 0x1108 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD8_SLAST;  ///< Offset: 0x110C - TCD Last Source Address Adjustment
        volatile uint32_t TCD8_DADDR;  ///< Offset: 0x1110 - TCD Destination Address
        volatile uint32_t TCD8_DOFF;  ///< Offset: 0x1114 - TCD Signed Destination Address Offset
        volatile uint32_t TCD8_CITER_ELINKNO;  ///< Offset: 0x1116 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD8_CITER_ELINKYES;  ///< Offset: 0x1116 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD8_DLASTSGA;  ///< Offset: 0x1118 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD8_CSR;  ///< Offset: 0x111C - TCD Control and Status
        volatile uint32_t TCD8_BITER_ELINKNO;  ///< Offset: 0x111E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD8_BITER_ELINKYES;  ///< Offset: 0x111E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD9_SADDR;  ///< Offset: 0x1120 - TCD Source Address
        volatile uint32_t TCD9_SOFF;  ///< Offset: 0x1124 - TCD Signed Source Address Offset
        volatile uint32_t TCD9_ATTR;  ///< Offset: 0x1126 - TCD Transfer Attributes
        volatile uint32_t TCD9_NBYTES_MLNO;  ///< Offset: 0x1128 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD9_NBYTES_MLOFFNO;  ///< Offset: 0x1128 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD9_NBYTES_MLOFFYES;  ///< Offset: 0x1128 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD9_SLAST;  ///< Offset: 0x112C - TCD Last Source Address Adjustment
        volatile uint32_t TCD9_DADDR;  ///< Offset: 0x1130 - TCD Destination Address
        volatile uint32_t TCD9_DOFF;  ///< Offset: 0x1134 - TCD Signed Destination Address Offset
        volatile uint32_t TCD9_CITER_ELINKNO;  ///< Offset: 0x1136 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD9_CITER_ELINKYES;  ///< Offset: 0x1136 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD9_DLASTSGA;  ///< Offset: 0x1138 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD9_CSR;  ///< Offset: 0x113C - TCD Control and Status
        volatile uint32_t TCD9_BITER_ELINKNO;  ///< Offset: 0x113E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD9_BITER_ELINKYES;  ///< Offset: 0x113E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD10_SADDR;  ///< Offset: 0x1140 - TCD Source Address
        volatile uint32_t TCD10_SOFF;  ///< Offset: 0x1144 - TCD Signed Source Address Offset
        volatile uint32_t TCD10_ATTR;  ///< Offset: 0x1146 - TCD Transfer Attributes
        volatile uint32_t TCD10_NBYTES_MLNO;  ///< Offset: 0x1148 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD10_NBYTES_MLOFFNO;  ///< Offset: 0x1148 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD10_NBYTES_MLOFFYES;  ///< Offset: 0x1148 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD10_SLAST;  ///< Offset: 0x114C - TCD Last Source Address Adjustment
        volatile uint32_t TCD10_DADDR;  ///< Offset: 0x1150 - TCD Destination Address
        volatile uint32_t TCD10_DOFF;  ///< Offset: 0x1154 - TCD Signed Destination Address Offset
        volatile uint32_t TCD10_CITER_ELINKNO;  ///< Offset: 0x1156 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD10_CITER_ELINKYES;  ///< Offset: 0x1156 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD10_DLASTSGA;  ///< Offset: 0x1158 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD10_CSR;  ///< Offset: 0x115C - TCD Control and Status
        volatile uint32_t TCD10_BITER_ELINKNO;  ///< Offset: 0x115E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD10_BITER_ELINKYES;  ///< Offset: 0x115E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD11_SADDR;  ///< Offset: 0x1160 - TCD Source Address
        volatile uint32_t TCD11_SOFF;  ///< Offset: 0x1164 - TCD Signed Source Address Offset
        volatile uint32_t TCD11_ATTR;  ///< Offset: 0x1166 - TCD Transfer Attributes
        volatile uint32_t TCD11_NBYTES_MLNO;  ///< Offset: 0x1168 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD11_NBYTES_MLOFFNO;  ///< Offset: 0x1168 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD11_NBYTES_MLOFFYES;  ///< Offset: 0x1168 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD11_SLAST;  ///< Offset: 0x116C - TCD Last Source Address Adjustment
        volatile uint32_t TCD11_DADDR;  ///< Offset: 0x1170 - TCD Destination Address
        volatile uint32_t TCD11_DOFF;  ///< Offset: 0x1174 - TCD Signed Destination Address Offset
        volatile uint32_t TCD11_CITER_ELINKNO;  ///< Offset: 0x1176 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD11_CITER_ELINKYES;  ///< Offset: 0x1176 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD11_DLASTSGA;  ///< Offset: 0x1178 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD11_CSR;  ///< Offset: 0x117C - TCD Control and Status
        volatile uint32_t TCD11_BITER_ELINKNO;  ///< Offset: 0x117E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD11_BITER_ELINKYES;  ///< Offset: 0x117E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD12_SADDR;  ///< Offset: 0x1180 - TCD Source Address
        volatile uint32_t TCD12_SOFF;  ///< Offset: 0x1184 - TCD Signed Source Address Offset
        volatile uint32_t TCD12_ATTR;  ///< Offset: 0x1186 - TCD Transfer Attributes
        volatile uint32_t TCD12_NBYTES_MLNO;  ///< Offset: 0x1188 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD12_NBYTES_MLOFFNO;  ///< Offset: 0x1188 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD12_NBYTES_MLOFFYES;  ///< Offset: 0x1188 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD12_SLAST;  ///< Offset: 0x118C - TCD Last Source Address Adjustment
        volatile uint32_t TCD12_DADDR;  ///< Offset: 0x1190 - TCD Destination Address
        volatile uint32_t TCD12_DOFF;  ///< Offset: 0x1194 - TCD Signed Destination Address Offset
        volatile uint32_t TCD12_CITER_ELINKNO;  ///< Offset: 0x1196 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD12_CITER_ELINKYES;  ///< Offset: 0x1196 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD12_DLASTSGA;  ///< Offset: 0x1198 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD12_CSR;  ///< Offset: 0x119C - TCD Control and Status
        volatile uint32_t TCD12_BITER_ELINKNO;  ///< Offset: 0x119E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD12_BITER_ELINKYES;  ///< Offset: 0x119E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD13_SADDR;  ///< Offset: 0x11A0 - TCD Source Address
        volatile uint32_t TCD13_SOFF;  ///< Offset: 0x11A4 - TCD Signed Source Address Offset
        volatile uint32_t TCD13_ATTR;  ///< Offset: 0x11A6 - TCD Transfer Attributes
        volatile uint32_t TCD13_NBYTES_MLNO;  ///< Offset: 0x11A8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD13_NBYTES_MLOFFNO;  ///< Offset: 0x11A8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD13_NBYTES_MLOFFYES;  ///< Offset: 0x11A8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD13_SLAST;  ///< Offset: 0x11AC - TCD Last Source Address Adjustment
        volatile uint32_t TCD13_DADDR;  ///< Offset: 0x11B0 - TCD Destination Address
        volatile uint32_t TCD13_DOFF;  ///< Offset: 0x11B4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD13_CITER_ELINKNO;  ///< Offset: 0x11B6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD13_CITER_ELINKYES;  ///< Offset: 0x11B6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD13_DLASTSGA;  ///< Offset: 0x11B8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD13_CSR;  ///< Offset: 0x11BC - TCD Control and Status
        volatile uint32_t TCD13_BITER_ELINKNO;  ///< Offset: 0x11BE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD13_BITER_ELINKYES;  ///< Offset: 0x11BE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD14_SADDR;  ///< Offset: 0x11C0 - TCD Source Address
        volatile uint32_t TCD14_SOFF;  ///< Offset: 0x11C4 - TCD Signed Source Address Offset
        volatile uint32_t TCD14_ATTR;  ///< Offset: 0x11C6 - TCD Transfer Attributes
        volatile uint32_t TCD14_NBYTES_MLNO;  ///< Offset: 0x11C8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD14_NBYTES_MLOFFNO;  ///< Offset: 0x11C8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD14_NBYTES_MLOFFYES;  ///< Offset: 0x11C8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD14_SLAST;  ///< Offset: 0x11CC - TCD Last Source Address Adjustment
        volatile uint32_t TCD14_DADDR;  ///< Offset: 0x11D0 - TCD Destination Address
        volatile uint32_t TCD14_DOFF;  ///< Offset: 0x11D4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD14_CITER_ELINKNO;  ///< Offset: 0x11D6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD14_CITER_ELINKYES;  ///< Offset: 0x11D6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD14_DLASTSGA;  ///< Offset: 0x11D8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD14_CSR;  ///< Offset: 0x11DC - TCD Control and Status
        volatile uint32_t TCD14_BITER_ELINKNO;  ///< Offset: 0x11DE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD14_BITER_ELINKYES;  ///< Offset: 0x11DE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD15_SADDR;  ///< Offset: 0x11E0 - TCD Source Address
        volatile uint32_t TCD15_SOFF;  ///< Offset: 0x11E4 - TCD Signed Source Address Offset
        volatile uint32_t TCD15_ATTR;  ///< Offset: 0x11E6 - TCD Transfer Attributes
        volatile uint32_t TCD15_NBYTES_MLNO;  ///< Offset: 0x11E8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD15_NBYTES_MLOFFNO;  ///< Offset: 0x11E8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD15_NBYTES_MLOFFYES;  ///< Offset: 0x11E8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD15_SLAST;  ///< Offset: 0x11EC - TCD Last Source Address Adjustment
        volatile uint32_t TCD15_DADDR;  ///< Offset: 0x11F0 - TCD Destination Address
        volatile uint32_t TCD15_DOFF;  ///< Offset: 0x11F4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD15_CITER_ELINKNO;  ///< Offset: 0x11F6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD15_CITER_ELINKYES;  ///< Offset: 0x11F6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD15_DLASTSGA;  ///< Offset: 0x11F8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD15_CSR;  ///< Offset: 0x11FC - TCD Control and Status
        volatile uint32_t TCD15_BITER_ELINKNO;  ///< Offset: 0x11FE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD15_BITER_ELINKYES;  ///< Offset: 0x11FE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
    };

    /// Peripheral instances
    inline Registers* DMA0 = reinterpret_cast<Registers*>(DMA0_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
        constexpr uint32_t ACTIVE = (1U << 31);  ///< DMA Active Status
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (4 << 8);  ///< Error Channel Number or Canceled Channel Number
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Canceled
        constexpr uint32_t VLD = (1U << 31);  ///< VLD
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
        constexpr uint32_t ERQ4 = (1U << 4);  ///< Enable DMA Request 4
        constexpr uint32_t ERQ5 = (1U << 5);  ///< Enable DMA Request 5
        constexpr uint32_t ERQ6 = (1U << 6);  ///< Enable DMA Request 6
        constexpr uint32_t ERQ7 = (1U << 7);  ///< Enable DMA Request 7
        constexpr uint32_t ERQ8 = (1U << 8);  ///< Enable DMA Request 8
        constexpr uint32_t ERQ9 = (1U << 9);  ///< Enable DMA Request 9
        constexpr uint32_t ERQ10 = (1U << 10);  ///< Enable DMA Request 10
        constexpr uint32_t ERQ11 = (1U << 11);  ///< Enable DMA Request 11
        constexpr uint32_t ERQ12 = (1U << 12);  ///< Enable DMA Request 12
        constexpr uint32_t ERQ13 = (1U << 13);  ///< Enable DMA Request 13
        constexpr uint32_t ERQ14 = (1U << 14);  ///< Enable DMA Request 14
        constexpr uint32_t ERQ15 = (1U << 15);  ///< Enable DMA Request 15
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
        constexpr uint32_t EEI4 = (1U << 4);  ///< Enable Error Interrupt 4
        constexpr uint32_t EEI5 = (1U << 5);  ///< Enable Error Interrupt 5
        constexpr uint32_t EEI6 = (1U << 6);  ///< Enable Error Interrupt 6
        constexpr uint32_t EEI7 = (1U << 7);  ///< Enable Error Interrupt 7
        constexpr uint32_t EEI8 = (1U << 8);  ///< Enable Error Interrupt 8
        constexpr uint32_t EEI9 = (1U << 9);  ///< Enable Error Interrupt 9
        constexpr uint32_t EEI10 = (1U << 10);  ///< Enable Error Interrupt 10
        constexpr uint32_t EEI11 = (1U << 11);  ///< Enable Error Interrupt 11
        constexpr uint32_t EEI12 = (1U << 12);  ///< Enable Error Interrupt 12
        constexpr uint32_t EEI13 = (1U << 13);  ///< Enable Error Interrupt 13
        constexpr uint32_t EEI14 = (1U << 14);  ///< Enable Error Interrupt 14
        constexpr uint32_t EEI15 = (1U << 15);  ///< Enable Error Interrupt 15
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (4 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (4 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (4 << 0);  ///< Clear Enable Request
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (4 << 0);  ///< Set Enable Request
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (4 << 0);  ///< Clear DONE Bit
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (4 << 0);  ///< Set START Bit
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (4 << 0);  ///< Clear Error Indicator
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (4 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// INT Register bits
    namespace int_bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
        constexpr uint32_t INT4 = (1U << 4);  ///< Interrupt Request 4
        constexpr uint32_t INT5 = (1U << 5);  ///< Interrupt Request 5
        constexpr uint32_t INT6 = (1U << 6);  ///< Interrupt Request 6
        constexpr uint32_t INT7 = (1U << 7);  ///< Interrupt Request 7
        constexpr uint32_t INT8 = (1U << 8);  ///< Interrupt Request 8
        constexpr uint32_t INT9 = (1U << 9);  ///< Interrupt Request 9
        constexpr uint32_t INT10 = (1U << 10);  ///< Interrupt Request 10
        constexpr uint32_t INT11 = (1U << 11);  ///< Interrupt Request 11
        constexpr uint32_t INT12 = (1U << 12);  ///< Interrupt Request 12
        constexpr uint32_t INT13 = (1U << 13);  ///< Interrupt Request 13
        constexpr uint32_t INT14 = (1U << 14);  ///< Interrupt Request 14
        constexpr uint32_t INT15 = (1U << 15);  ///< Interrupt Request 15
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
        constexpr uint32_t ERR4 = (1U << 4);  ///< Error In Channel 4
        constexpr uint32_t ERR5 = (1U << 5);  ///< Error In Channel 5
        constexpr uint32_t ERR6 = (1U << 6);  ///< Error In Channel 6
        constexpr uint32_t ERR7 = (1U << 7);  ///< Error In Channel 7
        constexpr uint32_t ERR8 = (1U << 8);  ///< Error In Channel 8
        constexpr uint32_t ERR9 = (1U << 9);  ///< Error In Channel 9
        constexpr uint32_t ERR10 = (1U << 10);  ///< Error In Channel 10
        constexpr uint32_t ERR11 = (1U << 11);  ///< Error In Channel 11
        constexpr uint32_t ERR12 = (1U << 12);  ///< Error In Channel 12
        constexpr uint32_t ERR13 = (1U << 13);  ///< Error In Channel 13
        constexpr uint32_t ERR14 = (1U << 14);  ///< Error In Channel 14
        constexpr uint32_t ERR15 = (1U << 15);  ///< Error In Channel 15
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
        constexpr uint32_t HRS4 = (1U << 4);  ///< Hardware Request Status Channel 4
        constexpr uint32_t HRS5 = (1U << 5);  ///< Hardware Request Status Channel 5
        constexpr uint32_t HRS6 = (1U << 6);  ///< Hardware Request Status Channel 6
        constexpr uint32_t HRS7 = (1U << 7);  ///< Hardware Request Status Channel 7
        constexpr uint32_t HRS8 = (1U << 8);  ///< Hardware Request Status Channel 8
        constexpr uint32_t HRS9 = (1U << 9);  ///< Hardware Request Status Channel 9
        constexpr uint32_t HRS10 = (1U << 10);  ///< Hardware Request Status Channel 10
        constexpr uint32_t HRS11 = (1U << 11);  ///< Hardware Request Status Channel 11
        constexpr uint32_t HRS12 = (1U << 12);  ///< Hardware Request Status Channel 12
        constexpr uint32_t HRS13 = (1U << 13);  ///< Hardware Request Status Channel 13
        constexpr uint32_t HRS14 = (1U << 14);  ///< Hardware Request Status Channel 14
        constexpr uint32_t HRS15 = (1U << 15);  ///< Hardware Request Status Channel 15
    }

    /// EARS Register bits
    namespace ears_bits {
        constexpr uint32_t EDREQ_0 = (1U << 0);  ///< Enable asynchronous DMA request in stop mode for channel 0.
        constexpr uint32_t EDREQ_1 = (1U << 1);  ///< Enable asynchronous DMA request in stop mode for channel 1.
        constexpr uint32_t EDREQ_2 = (1U << 2);  ///< Enable asynchronous DMA request in stop mode for channel 2.
        constexpr uint32_t EDREQ_3 = (1U << 3);  ///< Enable asynchronous DMA request in stop mode for channel 3.
        constexpr uint32_t EDREQ_4 = (1U << 4);  ///< Enable asynchronous DMA request in stop mode for channel 4
        constexpr uint32_t EDREQ_5 = (1U << 5);  ///< Enable asynchronous DMA request in stop mode for channel 5
        constexpr uint32_t EDREQ_6 = (1U << 6);  ///< Enable asynchronous DMA request in stop mode for channel 6
        constexpr uint32_t EDREQ_7 = (1U << 7);  ///< Enable asynchronous DMA request in stop mode for channel 7
        constexpr uint32_t EDREQ_8 = (1U << 8);  ///< Enable asynchronous DMA request in stop mode for channel 8
        constexpr uint32_t EDREQ_9 = (1U << 9);  ///< Enable asynchronous DMA request in stop mode for channel 9
        constexpr uint32_t EDREQ_10 = (1U << 10);  ///< Enable asynchronous DMA request in stop mode for channel 10
        constexpr uint32_t EDREQ_11 = (1U << 11);  ///< Enable asynchronous DMA request in stop mode for channel 11
        constexpr uint32_t EDREQ_12 = (1U << 12);  ///< Enable asynchronous DMA request in stop mode for channel 12
        constexpr uint32_t EDREQ_13 = (1U << 13);  ///< Enable asynchronous DMA request in stop mode for channel 13
        constexpr uint32_t EDREQ_14 = (1U << 14);  ///< Enable asynchronous DMA request in stop mode for channel 14
        constexpr uint32_t EDREQ_15 = (1U << 15);  ///< Enable asynchronous DMA request in stop mode for channel 15
    }

    /// DCHPRI3 Register bits
    namespace dchpri3_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI2 Register bits
    namespace dchpri2_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI1 Register bits
    namespace dchpri1_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI0 Register bits
    namespace dchpri0_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI7 Register bits
    namespace dchpri7_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI6 Register bits
    namespace dchpri6_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI5 Register bits
    namespace dchpri5_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI4 Register bits
    namespace dchpri4_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI11 Register bits
    namespace dchpri11_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI10 Register bits
    namespace dchpri10_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI9 Register bits
    namespace dchpri9_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI8 Register bits
    namespace dchpri8_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI15 Register bits
    namespace dchpri15_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI14 Register bits
    namespace dchpri14_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI13 Register bits
    namespace dchpri13_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI12 Register bits
    namespace dchpri12_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// TCD0_SADDR Register bits
    namespace tcd0_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD0_SOFF Register bits
    namespace tcd0_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD0_ATTR Register bits
    namespace tcd0_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD0_NBYTES_MLNO Register bits
    namespace tcd0_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD0_NBYTES_MLOFFNO Register bits
    namespace tcd0_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD0_NBYTES_MLOFFYES Register bits
    namespace tcd0_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD0_SLAST Register bits
    namespace tcd0_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD0_DADDR Register bits
    namespace tcd0_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD0_DOFF Register bits
    namespace tcd0_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD0_CITER_ELINKNO Register bits
    namespace tcd0_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD0_CITER_ELINKYES Register bits
    namespace tcd0_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD0_DLASTSGA Register bits
    namespace tcd0_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD0_CSR Register bits
    namespace tcd0_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD0_BITER_ELINKNO Register bits
    namespace tcd0_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD0_BITER_ELINKYES Register bits
    namespace tcd0_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD1_SADDR Register bits
    namespace tcd1_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD1_SOFF Register bits
    namespace tcd1_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD1_ATTR Register bits
    namespace tcd1_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD1_NBYTES_MLNO Register bits
    namespace tcd1_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD1_NBYTES_MLOFFNO Register bits
    namespace tcd1_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD1_NBYTES_MLOFFYES Register bits
    namespace tcd1_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD1_SLAST Register bits
    namespace tcd1_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD1_DADDR Register bits
    namespace tcd1_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD1_DOFF Register bits
    namespace tcd1_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD1_CITER_ELINKNO Register bits
    namespace tcd1_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD1_CITER_ELINKYES Register bits
    namespace tcd1_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD1_DLASTSGA Register bits
    namespace tcd1_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD1_CSR Register bits
    namespace tcd1_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD1_BITER_ELINKNO Register bits
    namespace tcd1_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD1_BITER_ELINKYES Register bits
    namespace tcd1_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD2_SADDR Register bits
    namespace tcd2_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD2_SOFF Register bits
    namespace tcd2_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD2_ATTR Register bits
    namespace tcd2_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD2_NBYTES_MLNO Register bits
    namespace tcd2_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD2_NBYTES_MLOFFNO Register bits
    namespace tcd2_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD2_NBYTES_MLOFFYES Register bits
    namespace tcd2_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD2_SLAST Register bits
    namespace tcd2_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD2_DADDR Register bits
    namespace tcd2_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD2_DOFF Register bits
    namespace tcd2_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD2_CITER_ELINKNO Register bits
    namespace tcd2_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD2_CITER_ELINKYES Register bits
    namespace tcd2_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD2_DLASTSGA Register bits
    namespace tcd2_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD2_CSR Register bits
    namespace tcd2_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD2_BITER_ELINKNO Register bits
    namespace tcd2_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD2_BITER_ELINKYES Register bits
    namespace tcd2_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD3_SADDR Register bits
    namespace tcd3_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD3_SOFF Register bits
    namespace tcd3_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD3_ATTR Register bits
    namespace tcd3_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD3_NBYTES_MLNO Register bits
    namespace tcd3_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD3_NBYTES_MLOFFNO Register bits
    namespace tcd3_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD3_NBYTES_MLOFFYES Register bits
    namespace tcd3_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD3_SLAST Register bits
    namespace tcd3_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD3_DADDR Register bits
    namespace tcd3_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD3_DOFF Register bits
    namespace tcd3_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD3_CITER_ELINKNO Register bits
    namespace tcd3_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD3_CITER_ELINKYES Register bits
    namespace tcd3_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD3_DLASTSGA Register bits
    namespace tcd3_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD3_CSR Register bits
    namespace tcd3_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD3_BITER_ELINKNO Register bits
    namespace tcd3_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD3_BITER_ELINKYES Register bits
    namespace tcd3_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD4_SADDR Register bits
    namespace tcd4_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD4_SOFF Register bits
    namespace tcd4_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD4_ATTR Register bits
    namespace tcd4_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD4_NBYTES_MLNO Register bits
    namespace tcd4_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD4_NBYTES_MLOFFNO Register bits
    namespace tcd4_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD4_NBYTES_MLOFFYES Register bits
    namespace tcd4_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD4_SLAST Register bits
    namespace tcd4_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD4_DADDR Register bits
    namespace tcd4_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD4_DOFF Register bits
    namespace tcd4_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD4_CITER_ELINKNO Register bits
    namespace tcd4_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD4_CITER_ELINKYES Register bits
    namespace tcd4_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD4_DLASTSGA Register bits
    namespace tcd4_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD4_CSR Register bits
    namespace tcd4_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD4_BITER_ELINKNO Register bits
    namespace tcd4_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD4_BITER_ELINKYES Register bits
    namespace tcd4_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD5_SADDR Register bits
    namespace tcd5_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD5_SOFF Register bits
    namespace tcd5_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD5_ATTR Register bits
    namespace tcd5_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD5_NBYTES_MLNO Register bits
    namespace tcd5_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD5_NBYTES_MLOFFNO Register bits
    namespace tcd5_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD5_NBYTES_MLOFFYES Register bits
    namespace tcd5_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD5_SLAST Register bits
    namespace tcd5_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD5_DADDR Register bits
    namespace tcd5_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD5_DOFF Register bits
    namespace tcd5_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD5_CITER_ELINKNO Register bits
    namespace tcd5_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD5_CITER_ELINKYES Register bits
    namespace tcd5_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD5_DLASTSGA Register bits
    namespace tcd5_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD5_CSR Register bits
    namespace tcd5_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD5_BITER_ELINKNO Register bits
    namespace tcd5_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD5_BITER_ELINKYES Register bits
    namespace tcd5_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD6_SADDR Register bits
    namespace tcd6_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD6_SOFF Register bits
    namespace tcd6_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD6_ATTR Register bits
    namespace tcd6_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD6_NBYTES_MLNO Register bits
    namespace tcd6_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD6_NBYTES_MLOFFNO Register bits
    namespace tcd6_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD6_NBYTES_MLOFFYES Register bits
    namespace tcd6_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD6_SLAST Register bits
    namespace tcd6_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD6_DADDR Register bits
    namespace tcd6_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD6_DOFF Register bits
    namespace tcd6_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD6_CITER_ELINKNO Register bits
    namespace tcd6_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD6_CITER_ELINKYES Register bits
    namespace tcd6_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD6_DLASTSGA Register bits
    namespace tcd6_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD6_CSR Register bits
    namespace tcd6_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD6_BITER_ELINKNO Register bits
    namespace tcd6_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD6_BITER_ELINKYES Register bits
    namespace tcd6_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD7_SADDR Register bits
    namespace tcd7_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD7_SOFF Register bits
    namespace tcd7_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD7_ATTR Register bits
    namespace tcd7_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD7_NBYTES_MLNO Register bits
    namespace tcd7_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD7_NBYTES_MLOFFNO Register bits
    namespace tcd7_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD7_NBYTES_MLOFFYES Register bits
    namespace tcd7_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD7_SLAST Register bits
    namespace tcd7_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD7_DADDR Register bits
    namespace tcd7_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD7_DOFF Register bits
    namespace tcd7_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD7_CITER_ELINKNO Register bits
    namespace tcd7_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD7_CITER_ELINKYES Register bits
    namespace tcd7_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD7_DLASTSGA Register bits
    namespace tcd7_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD7_CSR Register bits
    namespace tcd7_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD7_BITER_ELINKNO Register bits
    namespace tcd7_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD7_BITER_ELINKYES Register bits
    namespace tcd7_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD8_SADDR Register bits
    namespace tcd8_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD8_SOFF Register bits
    namespace tcd8_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD8_ATTR Register bits
    namespace tcd8_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD8_NBYTES_MLNO Register bits
    namespace tcd8_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD8_NBYTES_MLOFFNO Register bits
    namespace tcd8_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD8_NBYTES_MLOFFYES Register bits
    namespace tcd8_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD8_SLAST Register bits
    namespace tcd8_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD8_DADDR Register bits
    namespace tcd8_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD8_DOFF Register bits
    namespace tcd8_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD8_CITER_ELINKNO Register bits
    namespace tcd8_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD8_CITER_ELINKYES Register bits
    namespace tcd8_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD8_DLASTSGA Register bits
    namespace tcd8_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD8_CSR Register bits
    namespace tcd8_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD8_BITER_ELINKNO Register bits
    namespace tcd8_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD8_BITER_ELINKYES Register bits
    namespace tcd8_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD9_SADDR Register bits
    namespace tcd9_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD9_SOFF Register bits
    namespace tcd9_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD9_ATTR Register bits
    namespace tcd9_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD9_NBYTES_MLNO Register bits
    namespace tcd9_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD9_NBYTES_MLOFFNO Register bits
    namespace tcd9_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD9_NBYTES_MLOFFYES Register bits
    namespace tcd9_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD9_SLAST Register bits
    namespace tcd9_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD9_DADDR Register bits
    namespace tcd9_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD9_DOFF Register bits
    namespace tcd9_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD9_CITER_ELINKNO Register bits
    namespace tcd9_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD9_CITER_ELINKYES Register bits
    namespace tcd9_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD9_DLASTSGA Register bits
    namespace tcd9_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD9_CSR Register bits
    namespace tcd9_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD9_BITER_ELINKNO Register bits
    namespace tcd9_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD9_BITER_ELINKYES Register bits
    namespace tcd9_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD10_SADDR Register bits
    namespace tcd10_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD10_SOFF Register bits
    namespace tcd10_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD10_ATTR Register bits
    namespace tcd10_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD10_NBYTES_MLNO Register bits
    namespace tcd10_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD10_NBYTES_MLOFFNO Register bits
    namespace tcd10_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD10_NBYTES_MLOFFYES Register bits
    namespace tcd10_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD10_SLAST Register bits
    namespace tcd10_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD10_DADDR Register bits
    namespace tcd10_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD10_DOFF Register bits
    namespace tcd10_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD10_CITER_ELINKNO Register bits
    namespace tcd10_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD10_CITER_ELINKYES Register bits
    namespace tcd10_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD10_DLASTSGA Register bits
    namespace tcd10_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD10_CSR Register bits
    namespace tcd10_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD10_BITER_ELINKNO Register bits
    namespace tcd10_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD10_BITER_ELINKYES Register bits
    namespace tcd10_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD11_SADDR Register bits
    namespace tcd11_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD11_SOFF Register bits
    namespace tcd11_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD11_ATTR Register bits
    namespace tcd11_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD11_NBYTES_MLNO Register bits
    namespace tcd11_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD11_NBYTES_MLOFFNO Register bits
    namespace tcd11_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD11_NBYTES_MLOFFYES Register bits
    namespace tcd11_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD11_SLAST Register bits
    namespace tcd11_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD11_DADDR Register bits
    namespace tcd11_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD11_DOFF Register bits
    namespace tcd11_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD11_CITER_ELINKNO Register bits
    namespace tcd11_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD11_CITER_ELINKYES Register bits
    namespace tcd11_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD11_DLASTSGA Register bits
    namespace tcd11_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD11_CSR Register bits
    namespace tcd11_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD11_BITER_ELINKNO Register bits
    namespace tcd11_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD11_BITER_ELINKYES Register bits
    namespace tcd11_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD12_SADDR Register bits
    namespace tcd12_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD12_SOFF Register bits
    namespace tcd12_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD12_ATTR Register bits
    namespace tcd12_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD12_NBYTES_MLNO Register bits
    namespace tcd12_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD12_NBYTES_MLOFFNO Register bits
    namespace tcd12_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD12_NBYTES_MLOFFYES Register bits
    namespace tcd12_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD12_SLAST Register bits
    namespace tcd12_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD12_DADDR Register bits
    namespace tcd12_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD12_DOFF Register bits
    namespace tcd12_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD12_CITER_ELINKNO Register bits
    namespace tcd12_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD12_CITER_ELINKYES Register bits
    namespace tcd12_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD12_DLASTSGA Register bits
    namespace tcd12_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD12_CSR Register bits
    namespace tcd12_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD12_BITER_ELINKNO Register bits
    namespace tcd12_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD12_BITER_ELINKYES Register bits
    namespace tcd12_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD13_SADDR Register bits
    namespace tcd13_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD13_SOFF Register bits
    namespace tcd13_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD13_ATTR Register bits
    namespace tcd13_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD13_NBYTES_MLNO Register bits
    namespace tcd13_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD13_NBYTES_MLOFFNO Register bits
    namespace tcd13_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD13_NBYTES_MLOFFYES Register bits
    namespace tcd13_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD13_SLAST Register bits
    namespace tcd13_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD13_DADDR Register bits
    namespace tcd13_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD13_DOFF Register bits
    namespace tcd13_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD13_CITER_ELINKNO Register bits
    namespace tcd13_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD13_CITER_ELINKYES Register bits
    namespace tcd13_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD13_DLASTSGA Register bits
    namespace tcd13_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD13_CSR Register bits
    namespace tcd13_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD13_BITER_ELINKNO Register bits
    namespace tcd13_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD13_BITER_ELINKYES Register bits
    namespace tcd13_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD14_SADDR Register bits
    namespace tcd14_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD14_SOFF Register bits
    namespace tcd14_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD14_ATTR Register bits
    namespace tcd14_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD14_NBYTES_MLNO Register bits
    namespace tcd14_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD14_NBYTES_MLOFFNO Register bits
    namespace tcd14_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD14_NBYTES_MLOFFYES Register bits
    namespace tcd14_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD14_SLAST Register bits
    namespace tcd14_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD14_DADDR Register bits
    namespace tcd14_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD14_DOFF Register bits
    namespace tcd14_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD14_CITER_ELINKNO Register bits
    namespace tcd14_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD14_CITER_ELINKYES Register bits
    namespace tcd14_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD14_DLASTSGA Register bits
    namespace tcd14_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD14_CSR Register bits
    namespace tcd14_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD14_BITER_ELINKNO Register bits
    namespace tcd14_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD14_BITER_ELINKYES Register bits
    namespace tcd14_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD15_SADDR Register bits
    namespace tcd15_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD15_SOFF Register bits
    namespace tcd15_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD15_ATTR Register bits
    namespace tcd15_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD15_NBYTES_MLNO Register bits
    namespace tcd15_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD15_NBYTES_MLOFFNO Register bits
    namespace tcd15_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD15_NBYTES_MLOFFYES Register bits
    namespace tcd15_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD15_SLAST Register bits
    namespace tcd15_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD15_DADDR Register bits
    namespace tcd15_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD15_DOFF Register bits
    namespace tcd15_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD15_CITER_ELINKNO Register bits
    namespace tcd15_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD15_CITER_ELINKYES Register bits
    namespace tcd15_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD15_DLASTSGA Register bits
    namespace tcd15_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD15_CSR Register bits
    namespace tcd15_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD15_BITER_ELINKNO Register bits
    namespace tcd15_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD15_BITER_ELINKYES Register bits
    namespace tcd15_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// DCP Peripheral
// ============================================================================

namespace dcp {
    /// Base addresses
    constexpr uint32_t DCP_BASE = 0x400F0000;

    /// DCP Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - DCP control register 0
        volatile uint32_t CTRL_SET;  ///< Offset: 0x04 - DCP control register 0
        volatile uint32_t CTRL_CLR;  ///< Offset: 0x08 - DCP control register 0
        volatile uint32_t CTRL_TOG;  ///< Offset: 0x0C - DCP control register 0
        volatile uint32_t STAT;  ///< Offset: 0x10 - DCP status register
        volatile uint32_t STAT_SET;  ///< Offset: 0x14 - DCP status register
        volatile uint32_t STAT_CLR;  ///< Offset: 0x18 - DCP status register
        volatile uint32_t STAT_TOG;  ///< Offset: 0x1C - DCP status register
        volatile uint32_t CHANNELCTRL;  ///< Offset: 0x20 - DCP channel control register
        volatile uint32_t CHANNELCTRL_SET;  ///< Offset: 0x24 - DCP channel control register
        volatile uint32_t CHANNELCTRL_CLR;  ///< Offset: 0x28 - DCP channel control register
        volatile uint32_t CHANNELCTRL_TOG;  ///< Offset: 0x2C - DCP channel control register
        volatile uint32_t CAPABILITY0;  ///< Offset: 0x30 - DCP capability 0 register
        volatile uint32_t CAPABILITY1;  ///< Offset: 0x40 - DCP capability 1 register
        volatile uint32_t CONTEXT;  ///< Offset: 0x50 - DCP context buffer pointer
        volatile uint32_t KEY;  ///< Offset: 0x60 - DCP key index
        volatile uint32_t KEYDATA;  ///< Offset: 0x70 - DCP key data
        volatile uint32_t PACKET0;  ///< Offset: 0x80 - DCP work packet 0 status register
        volatile uint32_t PACKET1;  ///< Offset: 0x90 - DCP work packet 1 status register
        volatile uint32_t PACKET2;  ///< Offset: 0xA0 - DCP work packet 2 status register
        volatile uint32_t PACKET3;  ///< Offset: 0xB0 - DCP work packet 3 status register
        volatile uint32_t PACKET4;  ///< Offset: 0xC0 - DCP work packet 4 status register
        volatile uint32_t PACKET5;  ///< Offset: 0xD0 - DCP work packet 5 status register
        volatile uint32_t PACKET6;  ///< Offset: 0xE0 - DCP work packet 6 status register
        volatile uint32_t CH0CMDPTR;  ///< Offset: 0x100 - DCP channel 0 command pointer address register
        volatile uint32_t CH0SEMA;  ///< Offset: 0x110 - DCP channel 0 semaphore register
        volatile uint32_t CH0STAT;  ///< Offset: 0x120 - DCP channel 0 status register
        volatile uint32_t CH0STAT_SET;  ///< Offset: 0x124 - DCP channel 0 status register
        volatile uint32_t CH0STAT_CLR;  ///< Offset: 0x128 - DCP channel 0 status register
        volatile uint32_t CH0STAT_TOG;  ///< Offset: 0x12C - DCP channel 0 status register
        volatile uint32_t CH0OPTS;  ///< Offset: 0x130 - DCP channel 0 options register
        volatile uint32_t CH0OPTS_SET;  ///< Offset: 0x134 - DCP channel 0 options register
        volatile uint32_t CH0OPTS_CLR;  ///< Offset: 0x138 - DCP channel 0 options register
        volatile uint32_t CH0OPTS_TOG;  ///< Offset: 0x13C - DCP channel 0 options register
        volatile uint32_t CH1CMDPTR;  ///< Offset: 0x140 - DCP channel 1 command pointer address register
        volatile uint32_t CH1SEMA;  ///< Offset: 0x150 - DCP channel 1 semaphore register
        volatile uint32_t CH1STAT;  ///< Offset: 0x160 - DCP channel 1 status register
        volatile uint32_t CH1STAT_SET;  ///< Offset: 0x164 - DCP channel 1 status register
        volatile uint32_t CH1STAT_CLR;  ///< Offset: 0x168 - DCP channel 1 status register
        volatile uint32_t CH1STAT_TOG;  ///< Offset: 0x16C - DCP channel 1 status register
        volatile uint32_t CH1OPTS;  ///< Offset: 0x170 - DCP channel 1 options register
        volatile uint32_t CH1OPTS_SET;  ///< Offset: 0x174 - DCP channel 1 options register
        volatile uint32_t CH1OPTS_CLR;  ///< Offset: 0x178 - DCP channel 1 options register
        volatile uint32_t CH1OPTS_TOG;  ///< Offset: 0x17C - DCP channel 1 options register
        volatile uint32_t CH2CMDPTR;  ///< Offset: 0x180 - DCP channel 2 command pointer address register
        volatile uint32_t CH2SEMA;  ///< Offset: 0x190 - DCP channel 2 semaphore register
        volatile uint32_t CH2STAT;  ///< Offset: 0x1A0 - DCP channel 2 status register
        volatile uint32_t CH2STAT_SET;  ///< Offset: 0x1A4 - DCP channel 2 status register
        volatile uint32_t CH2STAT_CLR;  ///< Offset: 0x1A8 - DCP channel 2 status register
        volatile uint32_t CH2STAT_TOG;  ///< Offset: 0x1AC - DCP channel 2 status register
        volatile uint32_t CH2OPTS;  ///< Offset: 0x1B0 - DCP channel 2 options register
        volatile uint32_t CH2OPTS_SET;  ///< Offset: 0x1B4 - DCP channel 2 options register
        volatile uint32_t CH2OPTS_CLR;  ///< Offset: 0x1B8 - DCP channel 2 options register
        volatile uint32_t CH2OPTS_TOG;  ///< Offset: 0x1BC - DCP channel 2 options register
        volatile uint32_t CH3CMDPTR;  ///< Offset: 0x1C0 - DCP channel 3 command pointer address register
        volatile uint32_t CH3SEMA;  ///< Offset: 0x1D0 - DCP channel 3 semaphore register
        volatile uint32_t CH3STAT;  ///< Offset: 0x1E0 - DCP channel 3 status register
        volatile uint32_t CH3STAT_SET;  ///< Offset: 0x1E4 - DCP channel 3 status register
        volatile uint32_t CH3STAT_CLR;  ///< Offset: 0x1E8 - DCP channel 3 status register
        volatile uint32_t CH3STAT_TOG;  ///< Offset: 0x1EC - DCP channel 3 status register
        volatile uint32_t CH3OPTS;  ///< Offset: 0x1F0 - DCP channel 3 options register
        volatile uint32_t CH3OPTS_SET;  ///< Offset: 0x1F4 - DCP channel 3 options register
        volatile uint32_t CH3OPTS_CLR;  ///< Offset: 0x1F8 - DCP channel 3 options register
        volatile uint32_t CH3OPTS_TOG;  ///< Offset: 0x1FC - DCP channel 3 options register
        volatile uint32_t DBGSELECT;  ///< Offset: 0x400 - DCP debug select register
        volatile uint32_t DBGDATA;  ///< Offset: 0x410 - DCP debug data register
        volatile uint32_t PAGETABLE;  ///< Offset: 0x420 - DCP page table register
        volatile uint32_t VERSION;  ///< Offset: 0x430 - DCP version register
    };

    /// Peripheral instances
    inline Registers* DCP = reinterpret_cast<Registers*>(DCP_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t CHANNEL_INTERRUPT_ENABLE = (8 << 0);  ///< Per-channel interrupt enable bit
        constexpr uint32_t ENABLE_CONTEXT_SWITCHING = (1U << 21);  ///< Enable automatic context switching for the channels
        constexpr uint32_t ENABLE_CONTEXT_CACHING = (1U << 22);  ///< The software must set this bit to enable the caching of contexts between the operations
        constexpr uint32_t GATHER_RESIDUAL_WRITES = (1U << 23);  ///< The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
        constexpr uint32_t PRESENT_SHA = (1U << 28);  ///< Indicates whether the SHA1/SHA2 functions are present.
        constexpr uint32_t PRESENT_CRYPTO = (1U << 29);  ///< Indicates whether the crypto (cipher/hash) functions are present.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for a normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< Set this bit to zero to enable a normal DCP operation
    }

    /// CTRL_SET Register bits
    namespace ctrl_set_bits {
        constexpr uint32_t CHANNEL_INTERRUPT_ENABLE = (8 << 0);  ///< Per-channel interrupt enable bit
        constexpr uint32_t ENABLE_CONTEXT_SWITCHING = (1U << 21);  ///< Enable automatic context switching for the channels
        constexpr uint32_t ENABLE_CONTEXT_CACHING = (1U << 22);  ///< The software must set this bit to enable the caching of contexts between the operations
        constexpr uint32_t GATHER_RESIDUAL_WRITES = (1U << 23);  ///< The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
        constexpr uint32_t PRESENT_SHA = (1U << 28);  ///< Indicates whether the SHA1/SHA2 functions are present.
        constexpr uint32_t PRESENT_CRYPTO = (1U << 29);  ///< Indicates whether the crypto (cipher/hash) functions are present.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for a normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< Set this bit to zero to enable a normal DCP operation
    }

    /// CTRL_CLR Register bits
    namespace ctrl_clr_bits {
        constexpr uint32_t CHANNEL_INTERRUPT_ENABLE = (8 << 0);  ///< Per-channel interrupt enable bit
        constexpr uint32_t ENABLE_CONTEXT_SWITCHING = (1U << 21);  ///< Enable automatic context switching for the channels
        constexpr uint32_t ENABLE_CONTEXT_CACHING = (1U << 22);  ///< The software must set this bit to enable the caching of contexts between the operations
        constexpr uint32_t GATHER_RESIDUAL_WRITES = (1U << 23);  ///< The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
        constexpr uint32_t PRESENT_SHA = (1U << 28);  ///< Indicates whether the SHA1/SHA2 functions are present.
        constexpr uint32_t PRESENT_CRYPTO = (1U << 29);  ///< Indicates whether the crypto (cipher/hash) functions are present.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for a normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< Set this bit to zero to enable a normal DCP operation
    }

    /// CTRL_TOG Register bits
    namespace ctrl_tog_bits {
        constexpr uint32_t CHANNEL_INTERRUPT_ENABLE = (8 << 0);  ///< Per-channel interrupt enable bit
        constexpr uint32_t ENABLE_CONTEXT_SWITCHING = (1U << 21);  ///< Enable automatic context switching for the channels
        constexpr uint32_t ENABLE_CONTEXT_CACHING = (1U << 22);  ///< The software must set this bit to enable the caching of contexts between the operations
        constexpr uint32_t GATHER_RESIDUAL_WRITES = (1U << 23);  ///< The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
        constexpr uint32_t PRESENT_SHA = (1U << 28);  ///< Indicates whether the SHA1/SHA2 functions are present.
        constexpr uint32_t PRESENT_CRYPTO = (1U << 29);  ///< Indicates whether the crypto (cipher/hash) functions are present.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for a normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< Set this bit to zero to enable a normal DCP operation
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t IRQ = (4 << 0);  ///< Indicates which channels have pending interrupt requests
        constexpr uint32_t READY_CHANNELS = (8 << 16);  ///< Indicates which channels are ready to proceed with a transfer (the active channel is also included)
        constexpr uint32_t CUR_CHANNEL = (4 << 24);  ///< Current (active) channel (encoded)
        constexpr uint32_t OTP_KEY_READY = (1U << 28);  ///< When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
    }

    /// STAT_SET Register bits
    namespace stat_set_bits {
        constexpr uint32_t IRQ = (4 << 0);  ///< Indicates which channels have pending interrupt requests
        constexpr uint32_t READY_CHANNELS = (8 << 16);  ///< Indicates which channels are ready to proceed with a transfer (the active channel is also included)
        constexpr uint32_t CUR_CHANNEL = (4 << 24);  ///< Current (active) channel (encoded)
        constexpr uint32_t OTP_KEY_READY = (1U << 28);  ///< When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
    }

    /// STAT_CLR Register bits
    namespace stat_clr_bits {
        constexpr uint32_t IRQ = (4 << 0);  ///< Indicates which channels have pending interrupt requests
        constexpr uint32_t READY_CHANNELS = (8 << 16);  ///< Indicates which channels are ready to proceed with a transfer (the active channel is also included)
        constexpr uint32_t CUR_CHANNEL = (4 << 24);  ///< Current (active) channel (encoded)
        constexpr uint32_t OTP_KEY_READY = (1U << 28);  ///< When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
    }

    /// STAT_TOG Register bits
    namespace stat_tog_bits {
        constexpr uint32_t IRQ = (4 << 0);  ///< Indicates which channels have pending interrupt requests
        constexpr uint32_t READY_CHANNELS = (8 << 16);  ///< Indicates which channels are ready to proceed with a transfer (the active channel is also included)
        constexpr uint32_t CUR_CHANNEL = (4 << 24);  ///< Current (active) channel (encoded)
        constexpr uint32_t OTP_KEY_READY = (1U << 28);  ///< When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
    }

    /// CHANNELCTRL Register bits
    namespace channelctrl_bits {
        constexpr uint32_t ENABLE_CHANNEL = (8 << 0);  ///< Setting a bit in this field enables the DMA channel associated with it
        constexpr uint32_t HIGH_PRIORITY_CHANNEL = (8 << 8);  ///< Setting a bit in this field causes the corresponding channel to have high-priority arbitration
        constexpr uint32_t CH0_IRQ_MERGED = (1U << 16);  ///< Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
    }

    /// CHANNELCTRL_SET Register bits
    namespace channelctrl_set_bits {
        constexpr uint32_t ENABLE_CHANNEL = (8 << 0);  ///< Setting a bit in this field enables the DMA channel associated with it
        constexpr uint32_t HIGH_PRIORITY_CHANNEL = (8 << 8);  ///< Setting a bit in this field causes the corresponding channel to have high-priority arbitration
        constexpr uint32_t CH0_IRQ_MERGED = (1U << 16);  ///< Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
    }

    /// CHANNELCTRL_CLR Register bits
    namespace channelctrl_clr_bits {
        constexpr uint32_t ENABLE_CHANNEL = (8 << 0);  ///< Setting a bit in this field enables the DMA channel associated with it
        constexpr uint32_t HIGH_PRIORITY_CHANNEL = (8 << 8);  ///< Setting a bit in this field causes the corresponding channel to have high-priority arbitration
        constexpr uint32_t CH0_IRQ_MERGED = (1U << 16);  ///< Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
    }

    /// CHANNELCTRL_TOG Register bits
    namespace channelctrl_tog_bits {
        constexpr uint32_t ENABLE_CHANNEL = (8 << 0);  ///< Setting a bit in this field enables the DMA channel associated with it
        constexpr uint32_t HIGH_PRIORITY_CHANNEL = (8 << 8);  ///< Setting a bit in this field causes the corresponding channel to have high-priority arbitration
        constexpr uint32_t CH0_IRQ_MERGED = (1U << 16);  ///< Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
    }

    /// CAPABILITY0 Register bits
    namespace capability0_bits {
        constexpr uint32_t NUM_KEYS = (8 << 0);  ///< Encoded value indicating the number of key-storage locations implemented in the design
        constexpr uint32_t NUM_CHANNELS = (4 << 8);  ///< Encoded value indicating the number of channels implemented in the design
        constexpr uint32_t DISABLE_UNIQUE_KEY = (1U << 29);  ///< Write to a 1 to disable the per-device unique key
        constexpr uint32_t DISABLE_DECRYPT = (1U << 31);  ///< Write to 1 to disable the decryption
    }

    /// CAPABILITY1 Register bits
    namespace capability1_bits {
        constexpr uint32_t CIPHER_ALGORITHMS = (16 << 0);  ///< One-hot field indicating which cipher algorithms are available
        constexpr uint32_t HASH_ALGORITHMS = (16 << 16);  ///< One-hot field indicating which hashing features are implemented in the hardware
    }

    /// CONTEXT Register bits
    namespace context_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Context pointer address
    }

    /// KEY Register bits
    namespace key_bits {
        constexpr uint32_t SUBWORD = (2 << 0);  ///< Key subword pointer
        constexpr uint32_t INDEX = (2 << 4);  ///< Key index pointer. The valid indices are 0-[number_keys].
    }

    /// KEYDATA Register bits
    namespace keydata_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Word 0 data for the key. This is the least-significant word.
    }

    /// PACKET0 Register bits
    namespace packet0_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Next pointer register
    }

    /// PACKET1 Register bits
    namespace packet1_bits {
        constexpr uint32_t INTERRUPT = (1U << 0);  ///< Reflects whether the channel must issue an interrupt upon the completion of the packet.
        constexpr uint32_t DECR_SEMAPHORE = (1U << 1);  ///< Reflects whether the channel's semaphore must be decremented at the end of the current operation
        constexpr uint32_t CHAIN = (1U << 2);  ///< Reflects whether the next command pointer register must be loaded into the channel's current descriptor pointer
        constexpr uint32_t CHAIN_CONTIGUOUS = (1U << 3);  ///< Reflects whether the next packet's address is located following this packet's payload.
        constexpr uint32_t ENABLE_MEMCOPY = (1U << 4);  ///< Reflects whether the selected hashing function should be enabled for this operation.
        constexpr uint32_t ENABLE_CIPHER = (1U << 5);  ///< Reflects whether the selected cipher function must be enabled for this operation.
        constexpr uint32_t ENABLE_HASH = (1U << 6);  ///< Reflects whether the selected hashing function must be enabled for this operation.
        constexpr uint32_t ENABLE_BLIT = (1U << 7);  ///< Reflects whether the DCP must perform a blit operation
        constexpr uint32_t CIPHER_ENCRYPT = (1U << 8);  ///< When the cipher block is enabled, this bit indicates whether the operation is encryption or decryption
        constexpr uint32_t CIPHER_INIT = (1U << 9);  ///< Reflects whether the cipher block must load the initialization vector from the payload for this operation
        constexpr uint32_t OTP_KEY = (1U << 10);  ///< Reflects whether a hardware-based key must be used
        constexpr uint32_t PAYLOAD_KEY = (1U << 11);  ///< When set, it indicates the payload contains the key
        constexpr uint32_t HASH_INIT = (1U << 12);  ///< Reflects whether the current hashing block is the initial block in the hashing operation, so the hash registers must be initialized before the operation
        constexpr uint32_t HASH_TERM = (1U << 13);  ///< Reflects whether the current hashing block is the final block in the hashing operation, so the hash padding must be applied by the hardware
        constexpr uint32_t CHECK_HASH = (1U << 14);  ///< Reflects whether the calculated hash value must be compared to the hash provided in the payload.
        constexpr uint32_t HASH_OUTPUT = (1U << 15);  ///< When the hashing is enabled, this bit controls whether the input or output data is hashed.
        constexpr uint32_t CONSTANT_FILL = (1U << 16);  ///< When this bit is set (MEMCOPY and BLIT modes only), the DCP simply fills the destination buffer with the value found in the source address field
        constexpr uint32_t TEST_SEMA_IRQ = (1U << 17);  ///< This bit is used to test the channel semaphore transition to 0. FOR TEST USE ONLY!
        constexpr uint32_t KEY_BYTESWAP = (1U << 18);  ///< Reflects whether the DCP engine swaps the key bytes (big-endian key).
        constexpr uint32_t KEY_WORDSWAP = (1U << 19);  ///< Reflects whether the DCP engine swaps the key words (big-endian key).
        constexpr uint32_t INPUT_BYTESWAP = (1U << 20);  ///< Reflects whether the DCP engine byteswaps the input data (big-endian data).
        constexpr uint32_t INPUT_WORDSWAP = (1U << 21);  ///< Reflects whether the DCP engine wordswaps the input data (big-endian data).
        constexpr uint32_t OUTPUT_BYTESWAP = (1U << 22);  ///< Reflects whether the DCP engine byteswaps the output data (big-endian data).
        constexpr uint32_t OUTPUT_WORDSWAP = (1U << 23);  ///< Reflects whether the DCP engine wordswaps the output data (big-endian data).
        constexpr uint32_t TAG = (8 << 24);  ///< Packet Tag
    }

    /// PACKET2 Register bits
    namespace packet2_bits {
        constexpr uint32_t CIPHER_SELECT = (4 << 0);  ///< Cipher selection field
        constexpr uint32_t CIPHER_MODE = (4 << 4);  ///< Cipher mode selection field. Reflects the mode of operation for the cipher operations.
        constexpr uint32_t KEY_SELECT = (8 << 8);  ///< Key selection field
        constexpr uint32_t HASH_SELECT = (4 << 16);  ///< Hash Selection Field
        constexpr uint32_t CIPHER_CFG = (8 << 24);  ///< Cipher configuration bits. Optional configuration bits are required for the ciphers.
    }

    /// PACKET3 Register bits
    namespace packet3_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Source buffer address pointer
    }

    /// PACKET4 Register bits
    namespace packet4_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Destination buffer address pointer
    }

    /// PACKET5 Register bits
    namespace packet5_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< Byte count register. This value is the working value and updates as the operation proceeds.
    }

    /// PACKET6 Register bits
    namespace packet6_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< This regiser reflects the payload pointer for the current control packet.
    }

    /// CH0CMDPTR Register bits
    namespace ch0cmdptr_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Pointer to the descriptor structure to be processed for channel 0.
    }

    /// CH0SEMA Register bits
    namespace ch0sema_bits {
        constexpr uint32_t INCREMENT = (8 << 0);  ///< The value written to this field is added to the semaphore count in an atomic way such that the simultaneous software adds and DCP hardware substracts happening on the same clock are protected
        constexpr uint32_t VALUE = (8 << 16);  ///< This read-only field shows the current (instantaneous) value of the semaphore counter.
    }

    /// CH0STAT Register bits
    namespace ch0stat_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure
    }

    /// CH0STAT_SET Register bits
    namespace ch0stat_set_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure
    }

    /// CH0STAT_CLR Register bits
    namespace ch0stat_clr_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure
    }

    /// CH0STAT_TOG Register bits
    namespace ch0stat_tog_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure
    }

    /// CH0OPTS Register bits
    namespace ch0opts_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH0OPTS_SET Register bits
    namespace ch0opts_set_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH0OPTS_CLR Register bits
    namespace ch0opts_clr_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH0OPTS_TOG Register bits
    namespace ch0opts_tog_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH1CMDPTR Register bits
    namespace ch1cmdptr_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Pointer to the descriptor structure to be processed for channel 1.
    }

    /// CH1SEMA Register bits
    namespace ch1sema_bits {
        constexpr uint32_t INCREMENT = (8 << 0);  ///< The value written to this field is added to the semaphore count in an atomic way, such that the simultaneous software adds and the DCP hardware substracts happening on the same clock are protected
        constexpr uint32_t VALUE = (8 << 16);  ///< This read-only field shows the current (instantaneous) value of the semaphore counter.
    }

    /// CH1STAT Register bits
    namespace ch1stat_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH1STAT_SET Register bits
    namespace ch1stat_set_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH1STAT_CLR Register bits
    namespace ch1stat_clr_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH1STAT_TOG Register bits
    namespace ch1stat_tog_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH1OPTS Register bits
    namespace ch1opts_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH1OPTS_SET Register bits
    namespace ch1opts_set_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH1OPTS_CLR Register bits
    namespace ch1opts_clr_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH1OPTS_TOG Register bits
    namespace ch1opts_tog_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH2CMDPTR Register bits
    namespace ch2cmdptr_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Pointer to the descriptor structure to be processed for channel 2.
    }

    /// CH2SEMA Register bits
    namespace ch2sema_bits {
        constexpr uint32_t INCREMENT = (8 << 0);  ///< The value written to this field is added to the semaphore count in an atomic way, such that the simultaneous software adds and DCP hardware substracts happening on the same clock are protected
        constexpr uint32_t VALUE = (8 << 16);  ///< This read-only field shows the current (instantaneous) value of the semaphore counter.
    }

    /// CH2STAT Register bits
    namespace ch2stat_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH2STAT_SET Register bits
    namespace ch2stat_set_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH2STAT_CLR Register bits
    namespace ch2stat_clr_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH2STAT_TOG Register bits
    namespace ch2stat_tog_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH2OPTS Register bits
    namespace ch2opts_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH2OPTS_SET Register bits
    namespace ch2opts_set_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH2OPTS_CLR Register bits
    namespace ch2opts_clr_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH2OPTS_TOG Register bits
    namespace ch2opts_tog_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH3CMDPTR Register bits
    namespace ch3cmdptr_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Pointer to the descriptor structure to be processed for channel 3.
    }

    /// CH3SEMA Register bits
    namespace ch3sema_bits {
        constexpr uint32_t INCREMENT = (8 << 0);  ///< The value written to this field is added to the semaphore count in an atomic way, such that the simultaneous software adds and DCP hardware substracts happening on the same clock are protected
        constexpr uint32_t VALUE = (8 << 16);  ///< This read-only field shows the current (instantaneous) value of the semaphore counter.
    }

    /// CH3STAT Register bits
    namespace ch3stat_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH3STAT_SET Register bits
    namespace ch3stat_set_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH3STAT_CLR Register bits
    namespace ch3stat_clr_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH3STAT_TOG Register bits
    namespace ch3stat_tog_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH3OPTS Register bits
    namespace ch3opts_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH3OPTS_SET Register bits
    namespace ch3opts_set_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH3OPTS_CLR Register bits
    namespace ch3opts_clr_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH3OPTS_TOG Register bits
    namespace ch3opts_tog_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// DBGSELECT Register bits
    namespace dbgselect_bits {
        constexpr uint32_t INDEX = (8 << 0);  ///< Selects a value to read via the debug data register.
    }

    /// DBGDATA Register bits
    namespace dbgdata_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Debug data
    }

    /// PAGETABLE Register bits
    namespace pagetable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Page table enable control
        constexpr uint32_t FLUSH = (1U << 1);  ///< Page table flush control. To flush the TLB, write this bit to 1 and then back to 0.
        constexpr uint32_t BASE = (30 << 2);  ///< Page table base address
    }

    /// VERSION Register bits
    namespace version_bits {
        constexpr uint32_t STEP = (16 << 0);  ///< Fixed read-only value reflecting the stepping of the version of the design implementation.
        constexpr uint32_t MINOR = (8 << 16);  ///< Fixed read-only value reflecting the MINOR version of the design implementation.
        constexpr uint32_t MAJOR = (8 << 24);  ///< Fixed read-only value reflecting the MAJOR version of the design implementation.
    }

}

// ============================================================================
// GPC Peripheral
// ============================================================================

namespace gpc {
    /// Base addresses
    constexpr uint32_t GPC_BASE = 0x400F4000;

    /// GPC Register structure
    struct Registers {
        volatile uint32_t CNTR;  ///< Offset: 0x00 - GPC Interface control register
        volatile uint32_t IMR1;  ///< Offset: 0x08 - IRQ masking register 1
        volatile uint32_t IMR2;  ///< Offset: 0x0C - IRQ masking register 2
        volatile uint32_t IMR3;  ///< Offset: 0x10 - IRQ masking register 3
        volatile uint32_t IMR4;  ///< Offset: 0x14 - IRQ masking register 4
        volatile uint32_t ISR1;  ///< Offset: 0x18 - IRQ status resister 1
        volatile uint32_t ISR2;  ///< Offset: 0x1C - IRQ status resister 2
        volatile uint32_t ISR3;  ///< Offset: 0x20 - IRQ status resister 3
        volatile uint32_t ISR4;  ///< Offset: 0x24 - IRQ status resister 4
        volatile uint32_t IMR5;  ///< Offset: 0x34 - IRQ masking register 5
        volatile uint32_t ISR5;  ///< Offset: 0x38 - IRQ status resister 5
    };

    /// Peripheral instances
    inline Registers* GPC = reinterpret_cast<Registers*>(GPC_BASE);

    // Bit definitions
    /// CNTR Register bits
    namespace cntr_bits {
        constexpr uint32_t MEGA_PDN_REQ = (1U << 2);  ///< MEGA domain power down request
        constexpr uint32_t MEGA_PUP_REQ = (1U << 3);  ///< MEGA domain power up request
        constexpr uint32_t PDRAM0_PGE = (1U << 22);  ///< FlexRAM PDRAM0 Power Gate Enable
    }

    /// IMR1 Register bits
    namespace imr1_bits {
        constexpr uint32_t IMR1 = (32 << 0);  ///< IRQ[31:0] masking bits: 1-irq masked, 0-irq is not masked
    }

    /// IMR2 Register bits
    namespace imr2_bits {
        constexpr uint32_t IMR2 = (32 << 0);  ///< IRQ[63:32] masking bits: 1-irq masked, 0-irq is not masked
    }

    /// IMR3 Register bits
    namespace imr3_bits {
        constexpr uint32_t IMR3 = (32 << 0);  ///< IRQ[95:64] masking bits: 1-irq masked, 0-irq is not masked
    }

    /// IMR4 Register bits
    namespace imr4_bits {
        constexpr uint32_t IMR4 = (32 << 0);  ///< IRQ[127:96] masking bits: 1-irq masked, 0-irq is not masked
    }

    /// ISR1 Register bits
    namespace isr1_bits {
        constexpr uint32_t ISR1 = (32 << 0);  ///< IRQ[31:0] status, read only
    }

    /// ISR2 Register bits
    namespace isr2_bits {
        constexpr uint32_t ISR2 = (32 << 0);  ///< IRQ[63:32] status, read only
    }

    /// ISR3 Register bits
    namespace isr3_bits {
        constexpr uint32_t ISR3 = (32 << 0);  ///< IRQ[95:64] status, read only
    }

    /// ISR4 Register bits
    namespace isr4_bits {
        constexpr uint32_t ISR4 = (32 << 0);  ///< IRQ[127:96] status, read only
    }

    /// IMR5 Register bits
    namespace imr5_bits {
        constexpr uint32_t IMR5 = (32 << 0);  ///< IRQ[159:128] masking bits: 1-irq masked, 0-irq is not masked
    }

    /// ISR5 Register bits
    namespace isr5_bits {
        constexpr uint32_t ISR4 = (32 << 0);  ///< IRQ[159:128] status, read only
    }

}

// ============================================================================
// PGC Peripheral
// ============================================================================

namespace pgc {
    /// Base addresses
    constexpr uint32_t PGC_BASE = 0x400F4000;

    /// PGC Register structure
    struct Registers {
        volatile uint32_t MEGA_CTRL;  ///< Offset: 0x220 - PGC Mega Control Register
        volatile uint32_t MEGA_PUPSCR;  ///< Offset: 0x224 - PGC Mega Power Up Sequence Control Register
        volatile uint32_t MEGA_PDNSCR;  ///< Offset: 0x228 - PGC Mega Pull Down Sequence Control Register
        volatile uint32_t MEGA_SR;  ///< Offset: 0x22C - PGC Mega Power Gating Controller Status Register
        volatile uint32_t CPU_CTRL;  ///< Offset: 0x2A0 - PGC CPU Control Register
        volatile uint32_t CPU_PUPSCR;  ///< Offset: 0x2A4 - PGC CPU Power Up Sequence Control Register
        volatile uint32_t CPU_PDNSCR;  ///< Offset: 0x2A8 - PGC CPU Pull Down Sequence Control Register
        volatile uint32_t CPU_SR;  ///< Offset: 0x2AC - PGC CPU Power Gating Controller Status Register
    };

    /// Peripheral instances
    inline Registers* PGC = reinterpret_cast<Registers*>(PGC_BASE);

    // Bit definitions
    /// MEGA_CTRL Register bits
    namespace mega_ctrl_bits {
        constexpr uint32_t PCR = (1U << 0);  ///< Power Control PCR must not change from power-down request (pdn_req) assertion until the target subsystem is completely powered up
    }

    /// MEGA_PUPSCR Register bits
    namespace mega_pupscr_bits {
        constexpr uint32_t SW = (6 << 0);  ///< After a power-up request (pup_req assertion), the PGC waits a number of IPG clocks equal to the value of SW before asserting power toggle on/off signal (switch_b)
        constexpr uint32_t SW2ISO = (6 << 8);  ///< After asserting power toggle on/off signal (switch_b), the PGC waits a number of IPG clocks equal to the value of SW2ISO before negating isolation
    }

    /// MEGA_PDNSCR Register bits
    namespace mega_pdnscr_bits {
        constexpr uint32_t ISO = (6 << 0);  ///< After a power-down request (pdn_req assertion), the PGC waits a number of IPG clocks equal to the value of ISO before asserting isolation
        constexpr uint32_t ISO2SW = (6 << 8);  ///< After asserting isolation, the PGC waits a number of IPG clocks equal to the value of ISO2SW before negating power toggle on/off signal (switch_b)
    }

    /// MEGA_SR Register bits
    namespace mega_sr_bits {
        constexpr uint32_t PSR = (1U << 0);  ///< Power status
    }

    /// CPU_CTRL Register bits
    namespace cpu_ctrl_bits {
        constexpr uint32_t PCR = (1U << 0);  ///< Power Control PCR must not change from power-down request (pdn_req) assertion until the target subsystem is completely powered up
    }

    /// CPU_PUPSCR Register bits
    namespace cpu_pupscr_bits {
        constexpr uint32_t SW = (6 << 0);  ///< There are two different silicon revisions: 1
        constexpr uint32_t SW2ISO = (6 << 8);  ///< There are two different silicon revisions: 1
    }

    /// CPU_PDNSCR Register bits
    namespace cpu_pdnscr_bits {
        constexpr uint32_t ISO = (6 << 0);  ///< After a power-down request (pdn_req assertion), the PGC waits a number of 32k clocks equal to the value of ISO before asserting isolation
        constexpr uint32_t ISO2SW = (6 << 8);  ///< After asserting isolation, the PGC waits a number of 32k clocks equal to the value of ISO2SW before negating
    }

    /// CPU_SR Register bits
    namespace cpu_sr_bits {
        constexpr uint32_t PSR = (1U << 0);  ///< Power status
    }

}

// ============================================================================
// SRC Peripheral
// ============================================================================

namespace src {
    /// Base addresses
    constexpr uint32_t SRC_BASE = 0x400F8000;

    /// SRC Register structure
    struct Registers {
        volatile uint32_t SCR;  ///< Offset: 0x00 - SRC Control Register
        volatile uint32_t SBMR1;  ///< Offset: 0x04 - SRC Boot Mode Register 1
        volatile uint32_t SRSR;  ///< Offset: 0x08 - SRC Reset Status Register
        volatile uint32_t SBMR2;  ///< Offset: 0x1C - SRC Boot Mode Register 2
        volatile uint32_t GPR1;  ///< Offset: 0x20 - SRC General Purpose Register 1
        volatile uint32_t GPR2;  ///< Offset: 0x24 - SRC General Purpose Register 2
        volatile uint32_t GPR3;  ///< Offset: 0x28 - SRC General Purpose Register 3
        volatile uint32_t GPR4;  ///< Offset: 0x2C - SRC General Purpose Register 4
        volatile uint32_t GPR5;  ///< Offset: 0x30 - SRC General Purpose Register 5
        volatile uint32_t GPR6;  ///< Offset: 0x34 - SRC General Purpose Register 6
        volatile uint32_t GPR7;  ///< Offset: 0x38 - SRC General Purpose Register 7
        volatile uint32_t GPR8;  ///< Offset: 0x3C - SRC General Purpose Register 8
        volatile uint32_t GPR9;  ///< Offset: 0x40 - SRC General Purpose Register 9
        volatile uint32_t GPR10;  ///< Offset: 0x44 - SRC General Purpose Register 10
    };

    /// Peripheral instances
    inline Registers* SRC = reinterpret_cast<Registers*>(SRC_BASE);

    // Bit definitions
    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t lockup_rst = (1U << 4);  ///< lockup reset enable bit
        constexpr uint32_t mask_wdog_rst = (4 << 7);  ///< Mask wdog_rst_b source
        constexpr uint32_t core0_rst = (1U << 13);  ///< Software reset for core0 only
        constexpr uint32_t core0_dbg_rst = (1U << 17);  ///< Software reset for core0 debug only
        constexpr uint32_t dbg_rst_msk_pg = (1U << 25);  ///< Do not assert debug resets after power gating event of core
        constexpr uint32_t mask_wdog3_rst = (4 << 28);  ///< Mask wdog3_rst_b source
    }

    /// SBMR1 Register bits
    namespace sbmr1_bits {
        constexpr uint32_t BOOT_CFG1 = (8 << 0);  ///< Refer to fusemap.
        constexpr uint32_t BOOT_CFG2 = (8 << 8);  ///< Refer to fusemap.
        constexpr uint32_t BOOT_CFG3 = (8 << 16);  ///< Refer to fusemap.
        constexpr uint32_t BOOT_CFG4 = (8 << 24);  ///< Refer to fusemap.
    }

    /// SRSR Register bits
    namespace srsr_bits {
        constexpr uint32_t ipp_reset_b = (1U << 0);  ///< Indicates whether reset was the result of ipp_reset_b pin (Power-up sequence)
        constexpr uint32_t lockup = (1U << 1);  ///< Indicates a reset has been caused by CPU lockup.
        constexpr uint32_t csu_reset_b = (1U << 2);  ///< Indicates whether the reset was the result of the csu_reset_b input.
        constexpr uint32_t ipp_user_reset_b = (1U << 3);  ///< Indicates whether the reset was the result of the ipp_user_reset_b qualified reset.
        constexpr uint32_t wdog_rst_b = (1U << 4);  ///< IC Watchdog Time-out reset
        constexpr uint32_t jtag_rst_b = (1U << 5);  ///< HIGH - Z JTAG reset. Indicates whether the reset was the result of HIGH-Z reset from JTAG.
        constexpr uint32_t jtag_sw_rst = (1U << 6);  ///< JTAG software reset
        constexpr uint32_t wdog3_rst_b = (1U << 7);  ///< IC Watchdog3 Time-out reset
        constexpr uint32_t tempsense_rst_b = (1U << 8);  ///< Temper Sensor software reset
    }

    /// SBMR2 Register bits
    namespace sbmr2_bits {
        constexpr uint32_t SEC_CONFIG = (2 << 0);  ///< SECONFIG[1] shows the state of the SECONFIG[1] fuse
        constexpr uint32_t DIR_BT_DIS = (1U << 3);  ///< DIR_BT_DIS shows the state of the DIR_BT_DIS fuse
        constexpr uint32_t BT_FUSE_SEL = (1U << 4);  ///< BT_FUSE_SEL (connected to gpio bt_fuse_sel) shows the state of the BT_FUSE_SEL fuse
        constexpr uint32_t BMOD = (2 << 24);  ///< BMOD[1:0] shows the latched state of the BOOT_MODE1 and BOOT_MODE0 signals on the rising edge of POR_B
    }

    /// GPR1 Register bits
    namespace gpr1_bits {
        constexpr uint32_t PERSISTENT_ENTRY0 = (32 << 0);  ///< Holds entry function for core0 for waking-up from low power mode
    }

    /// GPR2 Register bits
    namespace gpr2_bits {
        constexpr uint32_t PERSISTENT_ARG0 = (32 << 0);  ///< Holds argument of entry function for core0 for waking-up from low power mode
    }

    /// GPR10 Register bits
    namespace gpr10_bits {
        constexpr uint32_t PERSIST_REDUNDANT_BOOT = (2 << 26);  ///< This field identifies which image must be used - 0/1/2/3
        constexpr uint32_t PERSIST_SECONDARY_BOOT = (1U << 30);  ///< This bit identifies which image must be used - primary and secondary
    }

}

// ============================================================================
// ROMC Peripheral
// ============================================================================

namespace romc {
    /// Base addresses
    constexpr uint32_t ROMC_BASE = 0x40180000;

    /// ROMC Register structure
    struct Registers {
        volatile uint32_t ROMPATCH%sD;  ///< Offset: 0xD4 - ROMC Data Registers
        volatile uint32_t ROMPATCHCNTL;  ///< Offset: 0xF4 - ROMC Control Register
        volatile uint32_t ROMPATCHENH;  ///< Offset: 0xF8 - ROMC Enable Register High
        volatile uint32_t ROMPATCHENL;  ///< Offset: 0xFC - ROMC Enable Register Low
        volatile uint32_t ROMPATCH%sA;  ///< Offset: 0x100 - ROMC Address Registers
        volatile uint32_t ROMPATCHSR;  ///< Offset: 0x208 - ROMC Status Register
    };

    /// Peripheral instances
    inline Registers* ROMC = reinterpret_cast<Registers*>(ROMC_BASE);

    // Bit definitions
    /// ROMPATCH%sD Register bits
    namespace rompatch%sd_bits {
        constexpr uint32_t DATAX = (32 << 0);  ///< Data Fix Registers - Stores the data used for 1-word data fix operations
    }

    /// ROMPATCHCNTL Register bits
    namespace rompatchcntl_bits {
        constexpr uint32_t DATAFIX = (8 << 0);  ///< Data Fix Enable - Controls the use of the first 8 address comparators for 1-word data fix or for code patch routine
        constexpr uint32_t DIS = (1U << 29);  ///< ROMC Disable -- This bit, when set, disables all ROMC operations
    }

    /// ROMPATCHENL Register bits
    namespace rompatchenl_bits {
        constexpr uint32_t ENABLE = (16 << 0);  ///< Enable Address Comparator - This bit enables the corresponding address comparator to trigger an event
    }

    /// ROMPATCH%sA Register bits
    namespace rompatch%sa_bits {
        constexpr uint32_t THUMBX = (1U << 0);  ///< THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an Arm opcode patch
        constexpr uint32_t ADDRX = (22 << 1);  ///< Address Comparator Registers - Indicates the memory address to be watched
    }

    /// ROMPATCHSR Register bits
    namespace rompatchsr_bits {
        constexpr uint32_t SOURCE = (6 << 0);  ///< ROMC Source Number - Binary encoding of the number of the address comparator which has an address match in the most recent patch event on ROMC AHB
        constexpr uint32_t SW = (1U << 17);  ///< ROMC AHB Multiple Address Comparator matches Indicator - Indicates that multiple address comparator matches occurred
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART1_BASE = 0x40184000;
    constexpr uint32_t LPUART2_BASE = 0x40188000;
    constexpr uint32_t LPUART3_BASE = 0x4018C000;
    constexpr uint32_t LPUART4_BASE = 0x40190000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t GLOBAL;  ///< Offset: 0x08 - LPUART Global Register
        volatile uint32_t PINCFG;  ///< Offset: 0x0C - LPUART Pin Configuration Register
        volatile uint32_t BAUD;  ///< Offset: 0x10 - LPUART Baud Rate Register
        volatile uint32_t STAT;  ///< Offset: 0x14 - LPUART Status Register
        volatile uint32_t CTRL;  ///< Offset: 0x18 - LPUART Control Register
        volatile uint32_t DATA;  ///< Offset: 0x1C - LPUART Data Register
        volatile uint32_t MATCH;  ///< Offset: 0x20 - LPUART Match Address Register
        volatile uint32_t MODIR;  ///< Offset: 0x24 - LPUART Modem IrDA Register
        volatile uint32_t FIFO;  ///< Offset: 0x28 - LPUART FIFO Register
        volatile uint32_t WATER;  ///< Offset: 0x2C - LPUART Watermark Register
    };

    /// Peripheral instances
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* LPUART2 = reinterpret_cast<Registers*>(LPUART2_BASE);
    inline Registers* LPUART3 = reinterpret_cast<Registers*>(LPUART3_BASE);
    inline Registers* LPUART4 = reinterpret_cast<Registers*>(LPUART4_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Identification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t TXFIFO = (8 << 0);  ///< Transmit FIFO Size
        constexpr uint32_t RXFIFO = (8 << 8);  ///< Receive FIFO Size
    }

    /// GLOBAL Register bits
    namespace global_bits {
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
    }

    /// PINCFG Register bits
    namespace pincfg_bits {
        constexpr uint32_t TRGSEL = (2 << 0);  ///< Trigger Select
    }

    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t SBR = (13 << 0);  ///< Baud Rate Modulo Divisor.
        constexpr uint32_t SBNS = (1U << 13);  ///< Stop Bit Number Select
        constexpr uint32_t RXEDGIE = (1U << 14);  ///< RX Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 15);  ///< LIN Break Detect Interrupt Enable
        constexpr uint32_t RESYNCDIS = (1U << 16);  ///< Resynchronization Disable
        constexpr uint32_t BOTHEDGE = (1U << 17);  ///< Both Edge Sampling
        constexpr uint32_t MATCFG = (2 << 18);  ///< Match Configuration
        constexpr uint32_t RIDMAE = (1U << 20);  ///< Receiver Idle DMA Enable
        constexpr uint32_t RDMAE = (1U << 21);  ///< Receiver Full DMA Enable
        constexpr uint32_t TDMAE = (1U << 23);  ///< Transmitter DMA Enable
        constexpr uint32_t OSR = (5 << 24);  ///< Oversampling Ratio
        constexpr uint32_t M10 = (1U << 29);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 30);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 31);  ///< Match Address Mode Enable 1
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t MA2F = (1U << 14);  ///< Match 2 Flag
        constexpr uint32_t MA1F = (1U << 15);  ///< Match 1 Flag
        constexpr uint32_t PF = (1U << 16);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 17);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 18);  ///< Noise Flag
        constexpr uint32_t OR = (1U << 19);  ///< Receiver Overrun Flag
        constexpr uint32_t IDLE = (1U << 20);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 21);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 22);  ///< Transmission Complete Flag
        constexpr uint32_t TDRE = (1U << 23);  ///< Transmit Data Register Empty Flag
        constexpr uint32_t RAF = (1U << 24);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 25);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 26);  ///< Break Character Generation Length
        constexpr uint32_t RWUID = (1U << 27);  ///< Receive Wake Up Idle Detect
        constexpr uint32_t RXINV = (1U << 28);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 29);  ///< MSB First
        constexpr uint32_t RXEDGIF = (1U << 30);  ///< RXD Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 31);  ///< LIN Break Detect Interrupt Flag
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-Bit or 8-Bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t DOZEEN = (1U << 6);  ///< Doze Enable
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
        constexpr uint32_t IDLECFG = (3 << 8);  ///< Idle Configuration
        constexpr uint32_t M7 = (1U << 11);  ///< 7-Bit Mode Select
        constexpr uint32_t MA2IE = (1U << 14);  ///< Match 2 Interrupt Enable
        constexpr uint32_t MA1IE = (1U << 15);  ///< Match 1 Interrupt Enable
        constexpr uint32_t SBK = (1U << 16);  ///< Send Break
        constexpr uint32_t RWU = (1U << 17);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 18);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 19);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 20);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 21);  ///< Receiver Interrupt Enable
        constexpr uint32_t TCIE = (1U << 22);  ///< Transmission Complete Interrupt Enable for
        constexpr uint32_t TIE = (1U << 23);  ///< Transmit Interrupt Enable
        constexpr uint32_t PEIE = (1U << 24);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 25);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 26);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 27);  ///< Overrun Interrupt Enable
        constexpr uint32_t TXINV = (1U << 28);  ///< Transmit Data Inversion
        constexpr uint32_t TXDIR = (1U << 29);  ///< TXD Pin Direction in Single-Wire Mode
        constexpr uint32_t R9T8 = (1U << 30);  ///< Receive Bit 9 / Transmit Bit 8
        constexpr uint32_t R8T9 = (1U << 31);  ///< Receive Bit 8 / Transmit Bit 9
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t R0T0 = (1U << 0);  ///< R0T0
        constexpr uint32_t R1T1 = (1U << 1);  ///< R1T1
        constexpr uint32_t R2T2 = (1U << 2);  ///< R2T2
        constexpr uint32_t R3T3 = (1U << 3);  ///< R3T3
        constexpr uint32_t R4T4 = (1U << 4);  ///< R4T4
        constexpr uint32_t R5T5 = (1U << 5);  ///< R5T5
        constexpr uint32_t R6T6 = (1U << 6);  ///< R6T6
        constexpr uint32_t R7T7 = (1U << 7);  ///< R7T7
        constexpr uint32_t R8T8 = (1U << 8);  ///< R8T8
        constexpr uint32_t R9T9 = (1U << 9);  ///< R9T9
        constexpr uint32_t IDLINE = (1U << 11);  ///< Idle Line
        constexpr uint32_t RXEMPT = (1U << 12);  ///< Receive Buffer Empty
        constexpr uint32_t FRETSC = (1U << 13);  ///< Frame Error / Transmit Special Character
        constexpr uint32_t PARITYE = (1U << 14);  ///< PARITYE
        constexpr uint32_t NOISY = (1U << 15);  ///< NOISY
    }

    /// MATCH Register bits
    namespace match_bits {
        constexpr uint32_t MA1 = (10 << 0);  ///< Match Address 1
        constexpr uint32_t MA2 = (10 << 16);  ///< Match Address 2
    }

    /// MODIR Register bits
    namespace modir_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
        constexpr uint32_t TXCTSC = (1U << 4);  ///< Transmit CTS Configuration
        constexpr uint32_t TXCTSSRC = (1U << 5);  ///< Transmit CTS Source
        constexpr uint32_t RTSWATER = (2 << 8);  ///< Receive RTS Configuration
        constexpr uint32_t TNP = (2 << 16);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 18);  ///< Infrared enable
    }

    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
        constexpr uint32_t RXUFE = (1U << 8);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 9);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXIDEN = (3 << 10);  ///< Receiver Idle Empty Enable
        constexpr uint32_t RXFLUSH = (1U << 14);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 15);  ///< Transmit FIFO/Buffer Flush
        constexpr uint32_t RXUF = (1U << 16);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 17);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXEMPT = (1U << 22);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 23);  ///< Transmit Buffer/FIFO Empty
    }

    /// WATER Register bits
    namespace water_bits {
        constexpr uint32_t TXWATER = (2 << 0);  ///< Transmit Watermark
        constexpr uint32_t TXCOUNT = (3 << 8);  ///< Transmit Counter
        constexpr uint32_t RXWATER = (2 << 16);  ///< Receive Watermark
        constexpr uint32_t RXCOUNT = (3 << 24);  ///< Receive Counter
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t LPI2C1_BASE = 0x401A4000;
    constexpr uint32_t LPI2C2_BASE = 0x401A8000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t MCR;  ///< Offset: 0x10 - Master Control Register
        volatile uint32_t MSR;  ///< Offset: 0x14 - Master Status Register
        volatile uint32_t MIER;  ///< Offset: 0x18 - Master Interrupt Enable Register
        volatile uint32_t MDER;  ///< Offset: 0x1C - Master DMA Enable Register
        volatile uint32_t MCFGR0;  ///< Offset: 0x20 - Master Configuration Register 0
        volatile uint32_t MCFGR1;  ///< Offset: 0x24 - Master Configuration Register 1
        volatile uint32_t MCFGR2;  ///< Offset: 0x28 - Master Configuration Register 2
        volatile uint32_t MCFGR3;  ///< Offset: 0x2C - Master Configuration Register 3
        volatile uint32_t MDMR;  ///< Offset: 0x40 - Master Data Match Register
        volatile uint32_t MCCR0;  ///< Offset: 0x48 - Master Clock Configuration Register 0
        volatile uint32_t MCCR1;  ///< Offset: 0x50 - Master Clock Configuration Register 1
        volatile uint32_t MFCR;  ///< Offset: 0x58 - Master FIFO Control Register
        volatile uint32_t MFSR;  ///< Offset: 0x5C - Master FIFO Status Register
        volatile uint32_t MTDR;  ///< Offset: 0x60 - Master Transmit Data Register
        volatile uint32_t MRDR;  ///< Offset: 0x70 - Master Receive Data Register
        volatile uint32_t SCR;  ///< Offset: 0x110 - Slave Control Register
        volatile uint32_t SSR;  ///< Offset: 0x114 - Slave Status Register
        volatile uint32_t SIER;  ///< Offset: 0x118 - Slave Interrupt Enable Register
        volatile uint32_t SDER;  ///< Offset: 0x11C - Slave DMA Enable Register
        volatile uint32_t SCFGR1;  ///< Offset: 0x124 - Slave Configuration Register 1
        volatile uint32_t SCFGR2;  ///< Offset: 0x128 - Slave Configuration Register 2
        volatile uint32_t SAMR;  ///< Offset: 0x140 - Slave Address Match Register
        volatile uint32_t SASR;  ///< Offset: 0x150 - Slave Address Status Register
        volatile uint32_t STAR;  ///< Offset: 0x154 - Slave Transmit ACK Register
        volatile uint32_t STDR;  ///< Offset: 0x160 - Slave Transmit Data Register
        volatile uint32_t SRDR;  ///< Offset: 0x170 - Slave Receive Data Register
    };

    /// Peripheral instances
    inline Registers* LPI2C1 = reinterpret_cast<Registers*>(LPI2C1_BASE);
    inline Registers* LPI2C2 = reinterpret_cast<Registers*>(LPI2C2_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t MTXFIFO = (4 << 0);  ///< Master Transmit FIFO Size
        constexpr uint32_t MRXFIFO = (4 << 8);  ///< Master Receive FIFO Size
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MEN = (1U << 0);  ///< Master Enable
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
        constexpr uint32_t DOZEN = (1U << 2);  ///< Doze mode enable
        constexpr uint32_t DBGEN = (1U << 3);  ///< Debug Enable
        constexpr uint32_t RTF = (1U << 8);  ///< Reset Transmit FIFO
        constexpr uint32_t RRF = (1U << 9);  ///< Reset Receive FIFO
    }

    /// MSR Register bits
    namespace msr_bits {
        constexpr uint32_t TDF = (1U << 0);  ///< Transmit Data Flag
        constexpr uint32_t RDF = (1U << 1);  ///< Receive Data Flag
        constexpr uint32_t EPF = (1U << 8);  ///< End Packet Flag
        constexpr uint32_t SDF = (1U << 9);  ///< STOP Detect Flag
        constexpr uint32_t NDF = (1U << 10);  ///< NACK Detect Flag
        constexpr uint32_t ALF = (1U << 11);  ///< Arbitration Lost Flag
        constexpr uint32_t FEF = (1U << 12);  ///< FIFO Error Flag
        constexpr uint32_t PLTF = (1U << 13);  ///< Pin Low Timeout Flag
        constexpr uint32_t DMF = (1U << 14);  ///< Data Match Flag
        constexpr uint32_t MBF = (1U << 24);  ///< Master Busy Flag
        constexpr uint32_t BBF = (1U << 25);  ///< Bus Busy Flag
    }

    /// MIER Register bits
    namespace mier_bits {
        constexpr uint32_t TDIE = (1U << 0);  ///< Transmit Data Interrupt Enable
        constexpr uint32_t RDIE = (1U << 1);  ///< Receive Data Interrupt Enable
        constexpr uint32_t EPIE = (1U << 8);  ///< End Packet Interrupt Enable
        constexpr uint32_t SDIE = (1U << 9);  ///< STOP Detect Interrupt Enable
        constexpr uint32_t NDIE = (1U << 10);  ///< NACK Detect Interrupt Enable
        constexpr uint32_t ALIE = (1U << 11);  ///< Arbitration Lost Interrupt Enable
        constexpr uint32_t FEIE = (1U << 12);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t PLTIE = (1U << 13);  ///< Pin Low Timeout Interrupt Enable
        constexpr uint32_t DMIE = (1U << 14);  ///< Data Match Interrupt Enable
    }

    /// MDER Register bits
    namespace mder_bits {
        constexpr uint32_t TDDE = (1U << 0);  ///< Transmit Data DMA Enable
        constexpr uint32_t RDDE = (1U << 1);  ///< Receive Data DMA Enable
    }

    /// MCFGR0 Register bits
    namespace mcfgr0_bits {
        constexpr uint32_t HREN = (1U << 0);  ///< Host Request Enable
        constexpr uint32_t HRPOL = (1U << 1);  ///< Host Request Polarity
        constexpr uint32_t HRSEL = (1U << 2);  ///< Host Request Select
        constexpr uint32_t CIRFIFO = (1U << 8);  ///< Circular FIFO Enable
        constexpr uint32_t RDMO = (1U << 9);  ///< Receive Data Match Only
    }

    /// MCFGR1 Register bits
    namespace mcfgr1_bits {
        constexpr uint32_t PRESCALE = (3 << 0);  ///< Prescaler
        constexpr uint32_t AUTOSTOP = (1U << 8);  ///< Automatic STOP Generation
        constexpr uint32_t IGNACK = (1U << 9);  ///< IGNACK
        constexpr uint32_t TIMECFG = (1U << 10);  ///< Timeout Configuration
        constexpr uint32_t MATCFG = (3 << 16);  ///< Match Configuration
        constexpr uint32_t PINCFG = (3 << 24);  ///< Pin Configuration
    }

    /// MCFGR2 Register bits
    namespace mcfgr2_bits {
        constexpr uint32_t BUSIDLE = (12 << 0);  ///< Bus Idle Timeout
        constexpr uint32_t FILTSCL = (4 << 16);  ///< Glitch Filter SCL
        constexpr uint32_t FILTSDA = (4 << 24);  ///< Glitch Filter SDA
    }

    /// MCFGR3 Register bits
    namespace mcfgr3_bits {
        constexpr uint32_t PINLOW = (12 << 8);  ///< Pin Low Timeout
    }

    /// MDMR Register bits
    namespace mdmr_bits {
        constexpr uint32_t MATCH0 = (8 << 0);  ///< Match 0 Value
        constexpr uint32_t MATCH1 = (8 << 16);  ///< Match 1 Value
    }

    /// MCCR0 Register bits
    namespace mccr0_bits {
        constexpr uint32_t CLKLO = (6 << 0);  ///< Clock Low Period
        constexpr uint32_t CLKHI = (6 << 8);  ///< Clock High Period
        constexpr uint32_t SETHOLD = (6 << 16);  ///< Setup Hold Delay
        constexpr uint32_t DATAVD = (6 << 24);  ///< Data Valid Delay
    }

    /// MCCR1 Register bits
    namespace mccr1_bits {
        constexpr uint32_t CLKLO = (6 << 0);  ///< Clock Low Period
        constexpr uint32_t CLKHI = (6 << 8);  ///< Clock High Period
        constexpr uint32_t SETHOLD = (6 << 16);  ///< Setup Hold Delay
        constexpr uint32_t DATAVD = (6 << 24);  ///< Data Valid Delay
    }

    /// MFCR Register bits
    namespace mfcr_bits {
        constexpr uint32_t TXWATER = (2 << 0);  ///< Transmit FIFO Watermark
        constexpr uint32_t RXWATER = (2 << 16);  ///< Receive FIFO Watermark
    }

    /// MFSR Register bits
    namespace mfsr_bits {
        constexpr uint32_t TXCOUNT = (3 << 0);  ///< Transmit FIFO Count
        constexpr uint32_t RXCOUNT = (3 << 16);  ///< Receive FIFO Count
    }

    /// MTDR Register bits
    namespace mtdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Transmit Data
        constexpr uint32_t CMD = (3 << 8);  ///< Command Data
    }

    /// MRDR Register bits
    namespace mrdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Receive Data
        constexpr uint32_t RXEMPTY = (1U << 14);  ///< RX Empty
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SEN = (1U << 0);  ///< Slave Enable
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
        constexpr uint32_t FILTEN = (1U << 4);  ///< Filter Enable
        constexpr uint32_t FILTDZ = (1U << 5);  ///< Filter Doze Enable
        constexpr uint32_t RTF = (1U << 8);  ///< Reset Transmit FIFO
        constexpr uint32_t RRF = (1U << 9);  ///< Reset Receive FIFO
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t TDF = (1U << 0);  ///< Transmit Data Flag
        constexpr uint32_t RDF = (1U << 1);  ///< Receive Data Flag
        constexpr uint32_t AVF = (1U << 2);  ///< Address Valid Flag
        constexpr uint32_t TAF = (1U << 3);  ///< Transmit ACK Flag
        constexpr uint32_t RSF = (1U << 8);  ///< Repeated Start Flag
        constexpr uint32_t SDF = (1U << 9);  ///< STOP Detect Flag
        constexpr uint32_t BEF = (1U << 10);  ///< Bit Error Flag
        constexpr uint32_t FEF = (1U << 11);  ///< FIFO Error Flag
        constexpr uint32_t AM0F = (1U << 12);  ///< Address Match 0 Flag
        constexpr uint32_t AM1F = (1U << 13);  ///< Address Match 1 Flag
        constexpr uint32_t GCF = (1U << 14);  ///< General Call Flag
        constexpr uint32_t SARF = (1U << 15);  ///< SMBus Alert Response Flag
        constexpr uint32_t SBF = (1U << 24);  ///< Slave Busy Flag
        constexpr uint32_t BBF = (1U << 25);  ///< Bus Busy Flag
    }

    /// SIER Register bits
    namespace sier_bits {
        constexpr uint32_t TDIE = (1U << 0);  ///< Transmit Data Interrupt Enable
        constexpr uint32_t RDIE = (1U << 1);  ///< Receive Data Interrupt Enable
        constexpr uint32_t AVIE = (1U << 2);  ///< Address Valid Interrupt Enable
        constexpr uint32_t TAIE = (1U << 3);  ///< Transmit ACK Interrupt Enable
        constexpr uint32_t RSIE = (1U << 8);  ///< Repeated Start Interrupt Enable
        constexpr uint32_t SDIE = (1U << 9);  ///< STOP Detect Interrupt Enable
        constexpr uint32_t BEIE = (1U << 10);  ///< Bit Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 11);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t AM0IE = (1U << 12);  ///< Address Match 0 Interrupt Enable
        constexpr uint32_t AM1F = (1U << 13);  ///< Address Match 1 Interrupt Enable
        constexpr uint32_t GCIE = (1U << 14);  ///< General Call Interrupt Enable
        constexpr uint32_t SARIE = (1U << 15);  ///< SMBus Alert Response Interrupt Enable
    }

    /// SDER Register bits
    namespace sder_bits {
        constexpr uint32_t TDDE = (1U << 0);  ///< Transmit Data DMA Enable
        constexpr uint32_t RDDE = (1U << 1);  ///< Receive Data DMA Enable
        constexpr uint32_t AVDE = (1U << 2);  ///< Address Valid DMA Enable
    }

    /// SCFGR1 Register bits
    namespace scfgr1_bits {
        constexpr uint32_t ADRSTALL = (1U << 0);  ///< Address SCL Stall
        constexpr uint32_t RXSTALL = (1U << 1);  ///< RX SCL Stall
        constexpr uint32_t TXDSTALL = (1U << 2);  ///< TX Data SCL Stall
        constexpr uint32_t ACKSTALL = (1U << 3);  ///< ACK SCL Stall
        constexpr uint32_t GCEN = (1U << 8);  ///< General Call Enable
        constexpr uint32_t SAEN = (1U << 9);  ///< SMBus Alert Enable
        constexpr uint32_t TXCFG = (1U << 10);  ///< Transmit Flag Configuration
        constexpr uint32_t RXCFG = (1U << 11);  ///< Receive Data Configuration
        constexpr uint32_t IGNACK = (1U << 12);  ///< Ignore NACK
        constexpr uint32_t HSMEN = (1U << 13);  ///< High Speed Mode Enable
        constexpr uint32_t ADDRCFG = (3 << 16);  ///< Address Configuration
    }

    /// SCFGR2 Register bits
    namespace scfgr2_bits {
        constexpr uint32_t CLKHOLD = (4 << 0);  ///< Clock Hold Time
        constexpr uint32_t DATAVD = (6 << 8);  ///< Data Valid Delay
        constexpr uint32_t FILTSCL = (4 << 16);  ///< Glitch Filter SCL
        constexpr uint32_t FILTSDA = (4 << 24);  ///< Glitch Filter SDA
    }

    /// SAMR Register bits
    namespace samr_bits {
        constexpr uint32_t ADDR0 = (10 << 1);  ///< Address 0 Value
        constexpr uint32_t ADDR1 = (10 << 17);  ///< Address 1 Value
    }

    /// SASR Register bits
    namespace sasr_bits {
        constexpr uint32_t RADDR = (11 << 0);  ///< Received Address
        constexpr uint32_t ANV = (1U << 14);  ///< Address Not Valid
    }

    /// STAR Register bits
    namespace star_bits {
        constexpr uint32_t TXNACK = (1U << 0);  ///< Transmit NACK
    }

    /// STDR Register bits
    namespace stdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Transmit Data
    }

    /// SRDR Register bits
    namespace srdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Receive Data
        constexpr uint32_t RXEMPTY = (1U << 14);  ///< RX Empty
        constexpr uint32_t SOF = (1U << 15);  ///< Start Of Frame
    }

}

// ============================================================================
// FLEXIO1 Peripheral
// ============================================================================

namespace flexio1 {
    /// Base addresses
    constexpr uint32_t FLEXIO1_BASE = 0x401AC000;

    /// FLEXIO1 Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - FlexIO Control Register
        volatile uint32_t PIN;  ///< Offset: 0x0C - Pin State Register
        volatile uint32_t SHIFTSTAT;  ///< Offset: 0x10 - Shifter Status Register
        volatile uint32_t SHIFTERR;  ///< Offset: 0x14 - Shifter Error Register
        volatile uint32_t TIMSTAT;  ///< Offset: 0x18 - Timer Status Register
        volatile uint32_t SHIFTSIEN;  ///< Offset: 0x20 - Shifter Status Interrupt Enable
        volatile uint32_t SHIFTEIEN;  ///< Offset: 0x24 - Shifter Error Interrupt Enable
        volatile uint32_t TIMIEN;  ///< Offset: 0x28 - Timer Interrupt Enable Register
        volatile uint32_t SHIFTSDEN;  ///< Offset: 0x30 - Shifter Status DMA Enable
        volatile uint32_t SHIFTSTATE;  ///< Offset: 0x40 - Shifter State Register
        volatile uint32_t SHIFTCTL[%s];  ///< Offset: 0x80 - Shifter Control N Register
        volatile uint32_t SHIFTCFG[%s];  ///< Offset: 0x100 - Shifter Configuration N Register
        volatile uint32_t SHIFTBUF[%s];  ///< Offset: 0x200 - Shifter Buffer N Register
        volatile uint32_t SHIFTBUFBIS[%s];  ///< Offset: 0x280 - Shifter Buffer N Bit Swapped Register
        volatile uint32_t SHIFTBUFBYS[%s];  ///< Offset: 0x300 - Shifter Buffer N Byte Swapped Register
        volatile uint32_t SHIFTBUFBBS[%s];  ///< Offset: 0x380 - Shifter Buffer N Bit Byte Swapped Register
        volatile uint32_t TIMCTL[%s];  ///< Offset: 0x400 - Timer Control N Register
        volatile uint32_t TIMCFG[%s];  ///< Offset: 0x480 - Timer Configuration N Register
        volatile uint32_t TIMCMP[%s];  ///< Offset: 0x500 - Timer Compare N Register
        volatile uint32_t SHIFTBUFNBS[%s];  ///< Offset: 0x680 - Shifter Buffer N Nibble Byte Swapped Register
        volatile uint32_t SHIFTBUFHWS[%s];  ///< Offset: 0x700 - Shifter Buffer N Half Word Swapped Register
        volatile uint32_t SHIFTBUFNIS[%s];  ///< Offset: 0x780 - Shifter Buffer N Nibble Swapped Register
    };

    /// Peripheral instances
    inline Registers* FLEXIO1 = reinterpret_cast<Registers*>(FLEXIO1_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t SHIFTER = (8 << 0);  ///< Shifter Number
        constexpr uint32_t TIMER = (8 << 8);  ///< Timer Number
        constexpr uint32_t PIN = (8 << 16);  ///< Pin Number
        constexpr uint32_t TRIGGER = (8 << 24);  ///< Trigger Number
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t FLEXEN = (1U << 0);  ///< FlexIO Enable
        constexpr uint32_t SWRST = (1U << 1);  ///< Software Reset
        constexpr uint32_t FASTACC = (1U << 2);  ///< Fast Access
        constexpr uint32_t DBGE = (1U << 30);  ///< Debug Enable
        constexpr uint32_t DOZEN = (1U << 31);  ///< Doze Enable
    }

    /// PIN Register bits
    namespace pin_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Pin Data Input
    }

    /// SHIFTSTAT Register bits
    namespace shiftstat_bits {
        constexpr uint32_t SSF = (8 << 0);  ///< Shifter Status Flag
    }

    /// SHIFTERR Register bits
    namespace shifterr_bits {
        constexpr uint32_t SEF = (8 << 0);  ///< Shifter Error Flags
    }

    /// TIMSTAT Register bits
    namespace timstat_bits {
        constexpr uint32_t TSF = (8 << 0);  ///< Timer Status Flags
    }

    /// SHIFTSIEN Register bits
    namespace shiftsien_bits {
        constexpr uint32_t SSIE = (8 << 0);  ///< Shifter Status Interrupt Enable
    }

    /// SHIFTEIEN Register bits
    namespace shifteien_bits {
        constexpr uint32_t SEIE = (8 << 0);  ///< Shifter Error Interrupt Enable
    }

    /// TIMIEN Register bits
    namespace timien_bits {
        constexpr uint32_t TEIE = (8 << 0);  ///< Timer Status Interrupt Enable
    }

    /// SHIFTSDEN Register bits
    namespace shiftsden_bits {
        constexpr uint32_t SSDE = (8 << 0);  ///< Shifter Status DMA Enable
    }

    /// SHIFTSTATE Register bits
    namespace shiftstate_bits {
        constexpr uint32_t STATE = (3 << 0);  ///< Current State Pointer
    }

    /// SHIFTCTL[%s] Register bits
    namespace shiftctl[%s]_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (3 << 24);  ///< Timer Select
    }

    /// SHIFTCFG[%s] Register bits
    namespace shiftcfg[%s]_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
        constexpr uint32_t PWIDTH = (5 << 16);  ///< Parallel Width
    }

    /// SHIFTBUF[%s] Register bits
    namespace shiftbuf[%s]_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBIS[%s] Register bits
    namespace shiftbufbis[%s]_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBYS[%s] Register bits
    namespace shiftbufbys[%s]_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBBS[%s] Register bits
    namespace shiftbufbbs[%s]_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// TIMCTL[%s] Register bits
    namespace timctl[%s]_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (6 << 24);  ///< Trigger Select
    }

    /// TIMCFG[%s] Register bits
    namespace timcfg[%s]_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// TIMCMP[%s] Register bits
    namespace timcmp[%s]_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

    /// SHIFTBUFNBS[%s] Register bits
    namespace shiftbufnbs[%s]_bits {
        constexpr uint32_t SHIFTBUFNBS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFHWS[%s] Register bits
    namespace shiftbufhws[%s]_bits {
        constexpr uint32_t SHIFTBUFHWS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFNIS[%s] Register bits
    namespace shiftbufnis[%s]_bits {
        constexpr uint32_t SHIFTBUFNIS = (32 << 0);  ///< Shift Buffer
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO1_BASE = 0x401B8000;
    constexpr uint32_t GPIO5_BASE = 0x400C0000;
    constexpr uint32_t GPIO2_BASE = 0x42000000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - GPIO data register
        volatile uint32_t GDIR;  ///< Offset: 0x04 - GPIO direction register
        volatile uint32_t PSR;  ///< Offset: 0x08 - GPIO pad status register
        volatile uint32_t ICR1;  ///< Offset: 0x0C - GPIO interrupt configuration register1
        volatile uint32_t ICR2;  ///< Offset: 0x10 - GPIO interrupt configuration register2
        volatile uint32_t IMR;  ///< Offset: 0x14 - GPIO interrupt mask register
        volatile uint32_t ISR;  ///< Offset: 0x18 - GPIO interrupt status register
        volatile uint32_t EDGE_SEL;  ///< Offset: 0x1C - GPIO edge select register
        volatile uint32_t DR_SET;  ///< Offset: 0x84 - GPIO data register SET
        volatile uint32_t DR_CLEAR;  ///< Offset: 0x88 - GPIO data register CLEAR
        volatile uint32_t DR_TOGGLE;  ///< Offset: 0x8C - GPIO data register TOGGLE
    };

    /// Peripheral instances
    inline Registers* GPIO1 = reinterpret_cast<Registers*>(GPIO1_BASE);
    inline Registers* GPIO5 = reinterpret_cast<Registers*>(GPIO5_BASE);
    inline Registers* GPIO2 = reinterpret_cast<Registers*>(GPIO2_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< DR
    }

    /// GDIR Register bits
    namespace gdir_bits {
        constexpr uint32_t GDIR = (32 << 0);  ///< GDIR
    }

    /// PSR Register bits
    namespace psr_bits {
        constexpr uint32_t PSR = (32 << 0);  ///< PSR
    }

    /// ICR1 Register bits
    namespace icr1_bits {
        constexpr uint32_t ICR0 = (2 << 0);  ///< ICR0
        constexpr uint32_t ICR1 = (2 << 2);  ///< ICR1
        constexpr uint32_t ICR2 = (2 << 4);  ///< ICR2
        constexpr uint32_t ICR3 = (2 << 6);  ///< ICR3
        constexpr uint32_t ICR4 = (2 << 8);  ///< ICR4
        constexpr uint32_t ICR5 = (2 << 10);  ///< ICR5
        constexpr uint32_t ICR6 = (2 << 12);  ///< ICR6
        constexpr uint32_t ICR7 = (2 << 14);  ///< ICR7
        constexpr uint32_t ICR8 = (2 << 16);  ///< ICR8
        constexpr uint32_t ICR9 = (2 << 18);  ///< ICR9
        constexpr uint32_t ICR10 = (2 << 20);  ///< ICR10
        constexpr uint32_t ICR11 = (2 << 22);  ///< ICR11
        constexpr uint32_t ICR12 = (2 << 24);  ///< ICR12
        constexpr uint32_t ICR13 = (2 << 26);  ///< ICR13
        constexpr uint32_t ICR14 = (2 << 28);  ///< ICR14
        constexpr uint32_t ICR15 = (2 << 30);  ///< ICR15
    }

    /// ICR2 Register bits
    namespace icr2_bits {
        constexpr uint32_t ICR16 = (2 << 0);  ///< ICR16
        constexpr uint32_t ICR17 = (2 << 2);  ///< ICR17
        constexpr uint32_t ICR18 = (2 << 4);  ///< ICR18
        constexpr uint32_t ICR19 = (2 << 6);  ///< ICR19
        constexpr uint32_t ICR20 = (2 << 8);  ///< ICR20
        constexpr uint32_t ICR21 = (2 << 10);  ///< ICR21
        constexpr uint32_t ICR22 = (2 << 12);  ///< ICR22
        constexpr uint32_t ICR23 = (2 << 14);  ///< ICR23
        constexpr uint32_t ICR24 = (2 << 16);  ///< ICR24
        constexpr uint32_t ICR25 = (2 << 18);  ///< ICR25
        constexpr uint32_t ICR26 = (2 << 20);  ///< ICR26
        constexpr uint32_t ICR27 = (2 << 22);  ///< ICR27
        constexpr uint32_t ICR28 = (2 << 24);  ///< ICR28
        constexpr uint32_t ICR29 = (2 << 26);  ///< ICR29
        constexpr uint32_t ICR30 = (2 << 28);  ///< ICR30
        constexpr uint32_t ICR31 = (2 << 30);  ///< ICR31
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t IMR = (32 << 0);  ///< IMR
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ISR = (32 << 0);  ///< ISR
    }

    /// EDGE_SEL Register bits
    namespace edge_sel_bits {
        constexpr uint32_t GPIO_EDGE_SEL = (32 << 0);  ///< GPIO_EDGE_SEL
    }

    /// DR_SET Register bits
    namespace dr_set_bits {
        constexpr uint32_t DR_SET = (32 << 0);  ///< DR_SET
    }

    /// DR_CLEAR Register bits
    namespace dr_clear_bits {
        constexpr uint32_t DR_CLEAR = (32 << 0);  ///< DR_CLEAR
    }

    /// DR_TOGGLE Register bits
    namespace dr_toggle_bits {
        constexpr uint32_t DR_TOGGLE = (32 << 0);  ///< DR_TOGGLE
    }

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t PWM1_BASE = 0x401CC000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t SM0CNT;  ///< Offset: 0x00 - Counter Register
        volatile uint32_t SM0INIT;  ///< Offset: 0x02 - Initial Count Register
        volatile uint32_t SM0CTRL2;  ///< Offset: 0x04 - Control 2 Register
        volatile uint32_t SM0CTRL;  ///< Offset: 0x06 - Control Register
        volatile uint32_t SM0VAL0;  ///< Offset: 0x0A - Value Register 0
        volatile uint32_t SM0FRACVAL1;  ///< Offset: 0x0C - Fractional Value Register 1
        volatile uint32_t SM0VAL1;  ///< Offset: 0x0E - Value Register 1
        volatile uint32_t SM0FRACVAL2;  ///< Offset: 0x10 - Fractional Value Register 2
        volatile uint32_t SM0VAL2;  ///< Offset: 0x12 - Value Register 2
        volatile uint32_t SM0FRACVAL3;  ///< Offset: 0x14 - Fractional Value Register 3
        volatile uint32_t SM0VAL3;  ///< Offset: 0x16 - Value Register 3
        volatile uint32_t SM0FRACVAL4;  ///< Offset: 0x18 - Fractional Value Register 4
        volatile uint32_t SM0VAL4;  ///< Offset: 0x1A - Value Register 4
        volatile uint32_t SM0FRACVAL5;  ///< Offset: 0x1C - Fractional Value Register 5
        volatile uint32_t SM0VAL5;  ///< Offset: 0x1E - Value Register 5
        volatile uint32_t SM0FRCTRL;  ///< Offset: 0x20 - Fractional Control Register
        volatile uint32_t SM0OCTRL;  ///< Offset: 0x22 - Output Control Register
        volatile uint32_t SM0STS;  ///< Offset: 0x24 - Status Register
        volatile uint32_t SM0INTEN;  ///< Offset: 0x26 - Interrupt Enable Register
        volatile uint32_t SM0DMAEN;  ///< Offset: 0x28 - DMA Enable Register
        volatile uint32_t SM0TCTRL;  ///< Offset: 0x2A - Output Trigger Control Register
        volatile uint32_t SM0DISMAP0;  ///< Offset: 0x2C - Fault Disable Mapping Register 0
        volatile uint32_t SM0DISMAP1;  ///< Offset: 0x2E - Fault Disable Mapping Register 1
        volatile uint32_t SM0DTCNT0;  ///< Offset: 0x30 - Deadtime Count Register 0
        volatile uint32_t SM0DTCNT1;  ///< Offset: 0x32 - Deadtime Count Register 1
        volatile uint32_t SM0CAPTCTRLA;  ///< Offset: 0x34 - Capture Control A Register
        volatile uint32_t SM0CAPTCOMPA;  ///< Offset: 0x36 - Capture Compare A Register
        volatile uint32_t SM0CAPTCTRLB;  ///< Offset: 0x38 - Capture Control B Register
        volatile uint32_t SM0CAPTCOMPB;  ///< Offset: 0x3A - Capture Compare B Register
        volatile uint32_t SM0CAPTCTRLX;  ///< Offset: 0x3C - Capture Control X Register
        volatile uint32_t SM0CAPTCOMPX;  ///< Offset: 0x3E - Capture Compare X Register
        volatile uint32_t SM0CVAL0;  ///< Offset: 0x40 - Capture Value 0 Register
        volatile uint32_t SM0CVAL0CYC;  ///< Offset: 0x42 - Capture Value 0 Cycle Register
        volatile uint32_t SM0CVAL1;  ///< Offset: 0x44 - Capture Value 1 Register
        volatile uint32_t SM0CVAL1CYC;  ///< Offset: 0x46 - Capture Value 1 Cycle Register
        volatile uint32_t SM0CVAL2;  ///< Offset: 0x48 - Capture Value 2 Register
        volatile uint32_t SM0CVAL2CYC;  ///< Offset: 0x4A - Capture Value 2 Cycle Register
        volatile uint32_t SM0CVAL3;  ///< Offset: 0x4C - Capture Value 3 Register
        volatile uint32_t SM0CVAL3CYC;  ///< Offset: 0x4E - Capture Value 3 Cycle Register
        volatile uint32_t SM0CVAL4;  ///< Offset: 0x50 - Capture Value 4 Register
        volatile uint32_t SM0CVAL4CYC;  ///< Offset: 0x52 - Capture Value 4 Cycle Register
        volatile uint32_t SM0CVAL5;  ///< Offset: 0x54 - Capture Value 5 Register
        volatile uint32_t SM0CVAL5CYC;  ///< Offset: 0x56 - Capture Value 5 Cycle Register
        volatile uint32_t SM0PHASEDLY;  ///< Offset: 0x58 - Phase Delay Register
        volatile uint32_t SM1CNT;  ///< Offset: 0x60 - Counter Register
        volatile uint32_t SM1INIT;  ///< Offset: 0x62 - Initial Count Register
        volatile uint32_t SM1CTRL2;  ///< Offset: 0x64 - Control 2 Register
        volatile uint32_t SM1CTRL;  ///< Offset: 0x66 - Control Register
        volatile uint32_t SM1VAL0;  ///< Offset: 0x6A - Value Register 0
        volatile uint32_t SM1FRACVAL1;  ///< Offset: 0x6C - Fractional Value Register 1
        volatile uint32_t SM1VAL1;  ///< Offset: 0x6E - Value Register 1
        volatile uint32_t SM1FRACVAL2;  ///< Offset: 0x70 - Fractional Value Register 2
        volatile uint32_t SM1VAL2;  ///< Offset: 0x72 - Value Register 2
        volatile uint32_t SM1FRACVAL3;  ///< Offset: 0x74 - Fractional Value Register 3
        volatile uint32_t SM1VAL3;  ///< Offset: 0x76 - Value Register 3
        volatile uint32_t SM1FRACVAL4;  ///< Offset: 0x78 - Fractional Value Register 4
        volatile uint32_t SM1VAL4;  ///< Offset: 0x7A - Value Register 4
        volatile uint32_t SM1FRACVAL5;  ///< Offset: 0x7C - Fractional Value Register 5
        volatile uint32_t SM1VAL5;  ///< Offset: 0x7E - Value Register 5
        volatile uint32_t SM1FRCTRL;  ///< Offset: 0x80 - Fractional Control Register
        volatile uint32_t SM1OCTRL;  ///< Offset: 0x82 - Output Control Register
        volatile uint32_t SM1STS;  ///< Offset: 0x84 - Status Register
        volatile uint32_t SM1INTEN;  ///< Offset: 0x86 - Interrupt Enable Register
        volatile uint32_t SM1DMAEN;  ///< Offset: 0x88 - DMA Enable Register
        volatile uint32_t SM1TCTRL;  ///< Offset: 0x8A - Output Trigger Control Register
        volatile uint32_t SM1DISMAP0;  ///< Offset: 0x8C - Fault Disable Mapping Register 0
        volatile uint32_t SM1DISMAP1;  ///< Offset: 0x8E - Fault Disable Mapping Register 1
        volatile uint32_t SM1DTCNT0;  ///< Offset: 0x90 - Deadtime Count Register 0
        volatile uint32_t SM1DTCNT1;  ///< Offset: 0x92 - Deadtime Count Register 1
        volatile uint32_t SM1CAPTCTRLA;  ///< Offset: 0x94 - Capture Control A Register
        volatile uint32_t SM1CAPTCOMPA;  ///< Offset: 0x96 - Capture Compare A Register
        volatile uint32_t SM1CAPTCTRLB;  ///< Offset: 0x98 - Capture Control B Register
        volatile uint32_t SM1CAPTCOMPB;  ///< Offset: 0x9A - Capture Compare B Register
        volatile uint32_t SM1CAPTCTRLX;  ///< Offset: 0x9C - Capture Control X Register
        volatile uint32_t SM1CAPTCOMPX;  ///< Offset: 0x9E - Capture Compare X Register
        volatile uint32_t SM1CVAL0;  ///< Offset: 0xA0 - Capture Value 0 Register
        volatile uint32_t SM1CVAL0CYC;  ///< Offset: 0xA2 - Capture Value 0 Cycle Register
        volatile uint32_t SM1CVAL1;  ///< Offset: 0xA4 - Capture Value 1 Register
        volatile uint32_t SM1CVAL1CYC;  ///< Offset: 0xA6 - Capture Value 1 Cycle Register
        volatile uint32_t SM1CVAL2;  ///< Offset: 0xA8 - Capture Value 2 Register
        volatile uint32_t SM1CVAL2CYC;  ///< Offset: 0xAA - Capture Value 2 Cycle Register
        volatile uint32_t SM1CVAL3;  ///< Offset: 0xAC - Capture Value 3 Register
        volatile uint32_t SM1CVAL3CYC;  ///< Offset: 0xAE - Capture Value 3 Cycle Register
        volatile uint32_t SM1CVAL4;  ///< Offset: 0xB0 - Capture Value 4 Register
        volatile uint32_t SM1CVAL4CYC;  ///< Offset: 0xB2 - Capture Value 4 Cycle Register
        volatile uint32_t SM1CVAL5;  ///< Offset: 0xB4 - Capture Value 5 Register
        volatile uint32_t SM1CVAL5CYC;  ///< Offset: 0xB6 - Capture Value 5 Cycle Register
        volatile uint32_t SM1PHASEDLY;  ///< Offset: 0xB8 - Phase Delay Register
        volatile uint32_t SM2CNT;  ///< Offset: 0xC0 - Counter Register
        volatile uint32_t SM2INIT;  ///< Offset: 0xC2 - Initial Count Register
        volatile uint32_t SM2CTRL2;  ///< Offset: 0xC4 - Control 2 Register
        volatile uint32_t SM2CTRL;  ///< Offset: 0xC6 - Control Register
        volatile uint32_t SM2VAL0;  ///< Offset: 0xCA - Value Register 0
        volatile uint32_t SM2FRACVAL1;  ///< Offset: 0xCC - Fractional Value Register 1
        volatile uint32_t SM2VAL1;  ///< Offset: 0xCE - Value Register 1
        volatile uint32_t SM2FRACVAL2;  ///< Offset: 0xD0 - Fractional Value Register 2
        volatile uint32_t SM2VAL2;  ///< Offset: 0xD2 - Value Register 2
        volatile uint32_t SM2FRACVAL3;  ///< Offset: 0xD4 - Fractional Value Register 3
        volatile uint32_t SM2VAL3;  ///< Offset: 0xD6 - Value Register 3
        volatile uint32_t SM2FRACVAL4;  ///< Offset: 0xD8 - Fractional Value Register 4
        volatile uint32_t SM2VAL4;  ///< Offset: 0xDA - Value Register 4
        volatile uint32_t SM2FRACVAL5;  ///< Offset: 0xDC - Fractional Value Register 5
        volatile uint32_t SM2VAL5;  ///< Offset: 0xDE - Value Register 5
        volatile uint32_t SM2FRCTRL;  ///< Offset: 0xE0 - Fractional Control Register
        volatile uint32_t SM2OCTRL;  ///< Offset: 0xE2 - Output Control Register
        volatile uint32_t SM2STS;  ///< Offset: 0xE4 - Status Register
        volatile uint32_t SM2INTEN;  ///< Offset: 0xE6 - Interrupt Enable Register
        volatile uint32_t SM2DMAEN;  ///< Offset: 0xE8 - DMA Enable Register
        volatile uint32_t SM2TCTRL;  ///< Offset: 0xEA - Output Trigger Control Register
        volatile uint32_t SM2DISMAP0;  ///< Offset: 0xEC - Fault Disable Mapping Register 0
        volatile uint32_t SM2DISMAP1;  ///< Offset: 0xEE - Fault Disable Mapping Register 1
        volatile uint32_t SM2DTCNT0;  ///< Offset: 0xF0 - Deadtime Count Register 0
        volatile uint32_t SM2DTCNT1;  ///< Offset: 0xF2 - Deadtime Count Register 1
        volatile uint32_t SM2CAPTCTRLA;  ///< Offset: 0xF4 - Capture Control A Register
        volatile uint32_t SM2CAPTCOMPA;  ///< Offset: 0xF6 - Capture Compare A Register
        volatile uint32_t SM2CAPTCTRLB;  ///< Offset: 0xF8 - Capture Control B Register
        volatile uint32_t SM2CAPTCOMPB;  ///< Offset: 0xFA - Capture Compare B Register
        volatile uint32_t SM2CAPTCTRLX;  ///< Offset: 0xFC - Capture Control X Register
        volatile uint32_t SM2CAPTCOMPX;  ///< Offset: 0xFE - Capture Compare X Register
        volatile uint32_t SM2CVAL0;  ///< Offset: 0x100 - Capture Value 0 Register
        volatile uint32_t SM2CVAL0CYC;  ///< Offset: 0x102 - Capture Value 0 Cycle Register
        volatile uint32_t SM2CVAL1;  ///< Offset: 0x104 - Capture Value 1 Register
        volatile uint32_t SM2CVAL1CYC;  ///< Offset: 0x106 - Capture Value 1 Cycle Register
        volatile uint32_t SM2CVAL2;  ///< Offset: 0x108 - Capture Value 2 Register
        volatile uint32_t SM2CVAL2CYC;  ///< Offset: 0x10A - Capture Value 2 Cycle Register
        volatile uint32_t SM2CVAL3;  ///< Offset: 0x10C - Capture Value 3 Register
        volatile uint32_t SM2CVAL3CYC;  ///< Offset: 0x10E - Capture Value 3 Cycle Register
        volatile uint32_t SM2CVAL4;  ///< Offset: 0x110 - Capture Value 4 Register
        volatile uint32_t SM2CVAL4CYC;  ///< Offset: 0x112 - Capture Value 4 Cycle Register
        volatile uint32_t SM2CVAL5;  ///< Offset: 0x114 - Capture Value 5 Register
        volatile uint32_t SM2CVAL5CYC;  ///< Offset: 0x116 - Capture Value 5 Cycle Register
        volatile uint32_t SM2PHASEDLY;  ///< Offset: 0x118 - Phase Delay Register
        volatile uint32_t SM3CNT;  ///< Offset: 0x120 - Counter Register
        volatile uint32_t SM3INIT;  ///< Offset: 0x122 - Initial Count Register
        volatile uint32_t SM3CTRL2;  ///< Offset: 0x124 - Control 2 Register
        volatile uint32_t SM3CTRL;  ///< Offset: 0x126 - Control Register
        volatile uint32_t SM3VAL0;  ///< Offset: 0x12A - Value Register 0
        volatile uint32_t SM3FRACVAL1;  ///< Offset: 0x12C - Fractional Value Register 1
        volatile uint32_t SM3VAL1;  ///< Offset: 0x12E - Value Register 1
        volatile uint32_t SM3FRACVAL2;  ///< Offset: 0x130 - Fractional Value Register 2
        volatile uint32_t SM3VAL2;  ///< Offset: 0x132 - Value Register 2
        volatile uint32_t SM3FRACVAL3;  ///< Offset: 0x134 - Fractional Value Register 3
        volatile uint32_t SM3VAL3;  ///< Offset: 0x136 - Value Register 3
        volatile uint32_t SM3FRACVAL4;  ///< Offset: 0x138 - Fractional Value Register 4
        volatile uint32_t SM3VAL4;  ///< Offset: 0x13A - Value Register 4
        volatile uint32_t SM3FRACVAL5;  ///< Offset: 0x13C - Fractional Value Register 5
        volatile uint32_t SM3VAL5;  ///< Offset: 0x13E - Value Register 5
        volatile uint32_t SM3FRCTRL;  ///< Offset: 0x140 - Fractional Control Register
        volatile uint32_t SM3OCTRL;  ///< Offset: 0x142 - Output Control Register
        volatile uint32_t SM3STS;  ///< Offset: 0x144 - Status Register
        volatile uint32_t SM3INTEN;  ///< Offset: 0x146 - Interrupt Enable Register
        volatile uint32_t SM3DMAEN;  ///< Offset: 0x148 - DMA Enable Register
        volatile uint32_t SM3TCTRL;  ///< Offset: 0x14A - Output Trigger Control Register
        volatile uint32_t SM3DISMAP0;  ///< Offset: 0x14C - Fault Disable Mapping Register 0
        volatile uint32_t SM3DISMAP1;  ///< Offset: 0x14E - Fault Disable Mapping Register 1
        volatile uint32_t SM3DTCNT0;  ///< Offset: 0x150 - Deadtime Count Register 0
        volatile uint32_t SM3DTCNT1;  ///< Offset: 0x152 - Deadtime Count Register 1
        volatile uint32_t SM3CAPTCTRLA;  ///< Offset: 0x154 - Capture Control A Register
        volatile uint32_t SM3CAPTCOMPA;  ///< Offset: 0x156 - Capture Compare A Register
        volatile uint32_t SM3CAPTCTRLB;  ///< Offset: 0x158 - Capture Control B Register
        volatile uint32_t SM3CAPTCOMPB;  ///< Offset: 0x15A - Capture Compare B Register
        volatile uint32_t SM3CAPTCTRLX;  ///< Offset: 0x15C - Capture Control X Register
        volatile uint32_t SM3CAPTCOMPX;  ///< Offset: 0x15E - Capture Compare X Register
        volatile uint32_t SM3CVAL0;  ///< Offset: 0x160 - Capture Value 0 Register
        volatile uint32_t SM3CVAL0CYC;  ///< Offset: 0x162 - Capture Value 0 Cycle Register
        volatile uint32_t SM3CVAL1;  ///< Offset: 0x164 - Capture Value 1 Register
        volatile uint32_t SM3CVAL1CYC;  ///< Offset: 0x166 - Capture Value 1 Cycle Register
        volatile uint32_t SM3CVAL2;  ///< Offset: 0x168 - Capture Value 2 Register
        volatile uint32_t SM3CVAL2CYC;  ///< Offset: 0x16A - Capture Value 2 Cycle Register
        volatile uint32_t SM3CVAL3;  ///< Offset: 0x16C - Capture Value 3 Register
        volatile uint32_t SM3CVAL3CYC;  ///< Offset: 0x16E - Capture Value 3 Cycle Register
        volatile uint32_t SM3CVAL4;  ///< Offset: 0x170 - Capture Value 4 Register
        volatile uint32_t SM3CVAL4CYC;  ///< Offset: 0x172 - Capture Value 4 Cycle Register
        volatile uint32_t SM3CVAL5;  ///< Offset: 0x174 - Capture Value 5 Register
        volatile uint32_t SM3CVAL5CYC;  ///< Offset: 0x176 - Capture Value 5 Cycle Register
        volatile uint32_t SM3PHASEDLY;  ///< Offset: 0x178 - Phase Delay Register
        volatile uint32_t OUTEN;  ///< Offset: 0x180 - Output Enable Register
        volatile uint32_t MASK;  ///< Offset: 0x182 - Mask Register
        volatile uint32_t SWCOUT;  ///< Offset: 0x184 - Software Controlled Output Register
        volatile uint32_t DTSRCSEL;  ///< Offset: 0x186 - PWM Source Select Register
        volatile uint32_t MCTRL;  ///< Offset: 0x188 - Master Control Register
        volatile uint32_t MCTRL2;  ///< Offset: 0x18A - Master Control 2 Register
        volatile uint32_t FCTRL0;  ///< Offset: 0x18C - Fault Control Register
        volatile uint32_t FSTS0;  ///< Offset: 0x18E - Fault Status Register
        volatile uint32_t FFILT0;  ///< Offset: 0x190 - Fault Filter Register
        volatile uint32_t FTST0;  ///< Offset: 0x192 - Fault Test Register
        volatile uint32_t FCTRL20;  ///< Offset: 0x194 - Fault Control 2 Register
    };

    /// Peripheral instances
    inline Registers* PWM1 = reinterpret_cast<Registers*>(PWM1_BASE);

    // Bit definitions
    /// SM0CNT Register bits
    namespace sm0cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter Register Bits
    }

    /// SM0INIT Register bits
    namespace sm0init_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Count Register Bits
    }

    /// SM0CTRL2 Register bits
    namespace sm0ctrl2_bits {
        constexpr uint32_t CLK_SEL = (2 << 0);  ///< Clock Source Select
        constexpr uint32_t RELOAD_SEL = (1U << 2);  ///< Reload Source Select
        constexpr uint32_t FORCE_SEL = (3 << 3);  ///< This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
        constexpr uint32_t FORCE = (1U << 6);  ///< Force Initialization
        constexpr uint32_t FRCEN = (1U << 7);  ///< FRCEN
        constexpr uint32_t INIT_SEL = (2 << 8);  ///< Initialization Control Select
        constexpr uint32_t PWMX_INIT = (1U << 10);  ///< PWM_X Initial Value
        constexpr uint32_t PWM45_INIT = (1U << 11);  ///< PWM45 Initial Value
        constexpr uint32_t PWM23_INIT = (1U << 12);  ///< PWM23 Initial Value
        constexpr uint32_t INDEP = (1U << 13);  ///< Independent or Complementary Pair Operation
        constexpr uint32_t WAITEN = (1U << 14);  ///< WAIT Enable
        constexpr uint32_t DBGEN = (1U << 15);  ///< Debug Enable
    }

    /// SM0CTRL Register bits
    namespace sm0ctrl_bits {
        constexpr uint32_t DBLEN = (1U << 0);  ///< Double Switching Enable
        constexpr uint32_t DBLX = (1U << 1);  ///< PWMX Double Switching Enable
        constexpr uint32_t LDMOD = (1U << 2);  ///< Load Mode Select
        constexpr uint32_t SPLIT = (1U << 3);  ///< Split the DBLPWM signal to PWMA and PWMB
        constexpr uint32_t PRSC = (3 << 4);  ///< Prescaler
        constexpr uint32_t COMPMODE = (1U << 7);  ///< Compare Mode
        constexpr uint32_t DT = (2 << 8);  ///< Deadtime
        constexpr uint32_t FULL = (1U << 10);  ///< Full Cycle Reload
        constexpr uint32_t HALF = (1U << 11);  ///< Half Cycle Reload
        constexpr uint32_t LDFQ = (4 << 12);  ///< Load Frequency
    }

    /// SM0VAL0 Register bits
    namespace sm0val0_bits {
        constexpr uint32_t VAL0 = (16 << 0);  ///< Value Register 0
    }

    /// SM0FRACVAL1 Register bits
    namespace sm0fracval1_bits {
        constexpr uint32_t FRACVAL1 = (5 << 11);  ///< Fractional Value 1 Register
    }

    /// SM0VAL1 Register bits
    namespace sm0val1_bits {
        constexpr uint32_t VAL1 = (16 << 0);  ///< Value Register 1
    }

    /// SM0FRACVAL2 Register bits
    namespace sm0fracval2_bits {
        constexpr uint32_t FRACVAL2 = (5 << 11);  ///< Fractional Value 2
    }

    /// SM0VAL2 Register bits
    namespace sm0val2_bits {
        constexpr uint32_t VAL2 = (16 << 0);  ///< Value Register 2
    }

    /// SM0FRACVAL3 Register bits
    namespace sm0fracval3_bits {
        constexpr uint32_t FRACVAL3 = (5 << 11);  ///< Fractional Value 3
    }

    /// SM0VAL3 Register bits
    namespace sm0val3_bits {
        constexpr uint32_t VAL3 = (16 << 0);  ///< Value Register 3
    }

    /// SM0FRACVAL4 Register bits
    namespace sm0fracval4_bits {
        constexpr uint32_t FRACVAL4 = (5 << 11);  ///< Fractional Value 4
    }

    /// SM0VAL4 Register bits
    namespace sm0val4_bits {
        constexpr uint32_t VAL4 = (16 << 0);  ///< Value Register 4
    }

    /// SM0FRACVAL5 Register bits
    namespace sm0fracval5_bits {
        constexpr uint32_t FRACVAL5 = (5 << 11);  ///< Fractional Value 5
    }

    /// SM0VAL5 Register bits
    namespace sm0val5_bits {
        constexpr uint32_t VAL5 = (16 << 0);  ///< Value Register 5
    }

    /// SM0FRCTRL Register bits
    namespace sm0frctrl_bits {
        constexpr uint32_t FRAC1_EN = (1U << 1);  ///< Fractional Cycle PWM Period Enable
        constexpr uint32_t FRAC23_EN = (1U << 2);  ///< Fractional Cycle Placement Enable for PWM_A
        constexpr uint32_t FRAC45_EN = (1U << 4);  ///< Fractional Cycle Placement Enable for PWM_B
        constexpr uint32_t FRAC_PU = (1U << 8);  ///< Fractional Delay Circuit Power Up
        constexpr uint32_t TEST = (1U << 15);  ///< Test Status Bit
    }

    /// SM0OCTRL Register bits
    namespace sm0octrl_bits {
        constexpr uint32_t PWMXFS = (2 << 0);  ///< PWM_X Fault State
        constexpr uint32_t PWMBFS = (2 << 2);  ///< PWM_B Fault State
        constexpr uint32_t PWMAFS = (2 << 4);  ///< PWM_A Fault State
        constexpr uint32_t POLX = (1U << 8);  ///< PWM_X Output Polarity
        constexpr uint32_t POLB = (1U << 9);  ///< PWM_B Output Polarity
        constexpr uint32_t POLA = (1U << 10);  ///< PWM_A Output Polarity
        constexpr uint32_t PWMX_IN = (1U << 13);  ///< PWM_X Input
        constexpr uint32_t PWMB_IN = (1U << 14);  ///< PWM_B Input
        constexpr uint32_t PWMA_IN = (1U << 15);  ///< PWM_A Input
    }

    /// SM0STS Register bits
    namespace sm0sts_bits {
        constexpr uint32_t CMPF = (6 << 0);  ///< Compare Flags
        constexpr uint32_t CFX0 = (1U << 6);  ///< Capture Flag X0
        constexpr uint32_t CFX1 = (1U << 7);  ///< Capture Flag X1
        constexpr uint32_t CFB0 = (1U << 8);  ///< Capture Flag B0
        constexpr uint32_t CFB1 = (1U << 9);  ///< Capture Flag B1
        constexpr uint32_t CFA0 = (1U << 10);  ///< Capture Flag A0
        constexpr uint32_t CFA1 = (1U << 11);  ///< Capture Flag A1
        constexpr uint32_t RF = (1U << 12);  ///< Reload Flag
        constexpr uint32_t REF = (1U << 13);  ///< Reload Error Flag
        constexpr uint32_t RUF = (1U << 14);  ///< Registers Updated Flag
    }

    /// SM0INTEN Register bits
    namespace sm0inten_bits {
        constexpr uint32_t CMPIE = (6 << 0);  ///< Compare Interrupt Enables
        constexpr uint32_t CX0IE = (1U << 6);  ///< Capture X 0 Interrupt Enable
        constexpr uint32_t CX1IE = (1U << 7);  ///< Capture X 1 Interrupt Enable
        constexpr uint32_t CB0IE = (1U << 8);  ///< Capture B 0 Interrupt Enable
        constexpr uint32_t CB1IE = (1U << 9);  ///< Capture B 1 Interrupt Enable
        constexpr uint32_t CA0IE = (1U << 10);  ///< Capture A 0 Interrupt Enable
        constexpr uint32_t CA1IE = (1U << 11);  ///< Capture A 1 Interrupt Enable
        constexpr uint32_t RIE = (1U << 12);  ///< Reload Interrupt Enable
        constexpr uint32_t REIE = (1U << 13);  ///< Reload Error Interrupt Enable
    }

    /// SM0DMAEN Register bits
    namespace sm0dmaen_bits {
        constexpr uint32_t CX0DE = (1U << 0);  ///< Capture X0 FIFO DMA Enable
        constexpr uint32_t CX1DE = (1U << 1);  ///< Capture X1 FIFO DMA Enable
        constexpr uint32_t CB0DE = (1U << 2);  ///< Capture B0 FIFO DMA Enable
        constexpr uint32_t CB1DE = (1U << 3);  ///< Capture B1 FIFO DMA Enable
        constexpr uint32_t CA0DE = (1U << 4);  ///< Capture A0 FIFO DMA Enable
        constexpr uint32_t CA1DE = (1U << 5);  ///< Capture A1 FIFO DMA Enable
        constexpr uint32_t CAPTDE = (2 << 6);  ///< Capture DMA Enable Source Select
        constexpr uint32_t FAND = (1U << 8);  ///< FIFO Watermark AND Control
        constexpr uint32_t VALDE = (1U << 9);  ///< Value Registers DMA Enable
    }

    /// SM0TCTRL Register bits
    namespace sm0tctrl_bits {
        constexpr uint32_t OUT_TRIG_EN = (6 << 0);  ///< Output Trigger Enables
        constexpr uint32_t TRGFRQ = (1U << 12);  ///< Trigger frequency
        constexpr uint32_t PWBOT1 = (1U << 14);  ///< Output Trigger 1 Source Select
        constexpr uint32_t PWAOT0 = (1U << 15);  ///< Output Trigger 0 Source Select
    }

    /// SM0DISMAP0 Register bits
    namespace sm0dismap0_bits {
        constexpr uint32_t DIS0A = (4 << 0);  ///< PWM_A Fault Disable Mask 0
        constexpr uint32_t DIS0B = (4 << 4);  ///< PWM_B Fault Disable Mask 0
        constexpr uint32_t DIS0X = (4 << 8);  ///< PWM_X Fault Disable Mask 0
    }

    /// SM0DISMAP1 Register bits
    namespace sm0dismap1_bits {
        constexpr uint32_t DIS1A = (4 << 0);  ///< PWM_A Fault Disable Mask 1
        constexpr uint32_t DIS1B = (4 << 4);  ///< PWM_B Fault Disable Mask 1
        constexpr uint32_t DIS1X = (4 << 8);  ///< PWM_X Fault Disable Mask 1
    }

    /// SM0DTCNT0 Register bits
    namespace sm0dtcnt0_bits {
        constexpr uint32_t DTCNT0 = (16 << 0);  ///< DTCNT0
    }

    /// SM0DTCNT1 Register bits
    namespace sm0dtcnt1_bits {
        constexpr uint32_t DTCNT1 = (16 << 0);  ///< DTCNT1
    }

    /// SM0CAPTCTRLA Register bits
    namespace sm0captctrla_bits {
        constexpr uint32_t ARMA = (1U << 0);  ///< Arm A
        constexpr uint32_t ONESHOTA = (1U << 1);  ///< One Shot Mode A
        constexpr uint32_t EDGA0 = (2 << 2);  ///< Edge A 0
        constexpr uint32_t EDGA1 = (2 << 4);  ///< Edge A 1
        constexpr uint32_t INP_SELA = (1U << 6);  ///< Input Select A
        constexpr uint32_t EDGCNTA_EN = (1U << 7);  ///< Edge Counter A Enable
        constexpr uint32_t CFAWM = (2 << 8);  ///< Capture A FIFOs Water Mark
        constexpr uint32_t CA0CNT = (3 << 10);  ///< Capture A0 FIFO Word Count
        constexpr uint32_t CA1CNT = (3 << 13);  ///< Capture A1 FIFO Word Count
    }

    /// SM0CAPTCOMPA Register bits
    namespace sm0captcompa_bits {
        constexpr uint32_t EDGCMPA = (8 << 0);  ///< Edge Compare A
        constexpr uint32_t EDGCNTA = (8 << 8);  ///< Edge Counter A
    }

    /// SM0CAPTCTRLB Register bits
    namespace sm0captctrlb_bits {
        constexpr uint32_t ARMB = (1U << 0);  ///< Arm B
        constexpr uint32_t ONESHOTB = (1U << 1);  ///< One Shot Mode B
        constexpr uint32_t EDGB0 = (2 << 2);  ///< Edge B 0
        constexpr uint32_t EDGB1 = (2 << 4);  ///< Edge B 1
        constexpr uint32_t INP_SELB = (1U << 6);  ///< Input Select B
        constexpr uint32_t EDGCNTB_EN = (1U << 7);  ///< Edge Counter B Enable
        constexpr uint32_t CFBWM = (2 << 8);  ///< Capture B FIFOs Water Mark
        constexpr uint32_t CB0CNT = (3 << 10);  ///< Capture B0 FIFO Word Count
        constexpr uint32_t CB1CNT = (3 << 13);  ///< Capture B1 FIFO Word Count
    }

    /// SM0CAPTCOMPB Register bits
    namespace sm0captcompb_bits {
        constexpr uint32_t EDGCMPB = (8 << 0);  ///< Edge Compare B
        constexpr uint32_t EDGCNTB = (8 << 8);  ///< Edge Counter B
    }

    /// SM0CAPTCTRLX Register bits
    namespace sm0captctrlx_bits {
        constexpr uint32_t ARMX = (1U << 0);  ///< Arm X
        constexpr uint32_t ONESHOTX = (1U << 1);  ///< One Shot Mode Aux
        constexpr uint32_t EDGX0 = (2 << 2);  ///< Edge X 0
        constexpr uint32_t EDGX1 = (2 << 4);  ///< Edge X 1
        constexpr uint32_t INP_SELX = (1U << 6);  ///< Input Select X
        constexpr uint32_t EDGCNTX_EN = (1U << 7);  ///< Edge Counter X Enable
        constexpr uint32_t CFXWM = (2 << 8);  ///< Capture X FIFOs Water Mark
        constexpr uint32_t CX0CNT = (3 << 10);  ///< Capture X0 FIFO Word Count
        constexpr uint32_t CX1CNT = (3 << 13);  ///< Capture X1 FIFO Word Count
    }

    /// SM0CAPTCOMPX Register bits
    namespace sm0captcompx_bits {
        constexpr uint32_t EDGCMPX = (8 << 0);  ///< Edge Compare X
        constexpr uint32_t EDGCNTX = (8 << 8);  ///< Edge Counter X
    }

    /// SM0CVAL0 Register bits
    namespace sm0cval0_bits {
        constexpr uint32_t CAPTVAL0 = (16 << 0);  ///< CAPTVAL0
    }

    /// SM0CVAL0CYC Register bits
    namespace sm0cval0cyc_bits {
        constexpr uint32_t CVAL0CYC = (4 << 0);  ///< CVAL0CYC
    }

    /// SM0CVAL1 Register bits
    namespace sm0cval1_bits {
        constexpr uint32_t CAPTVAL1 = (16 << 0);  ///< CAPTVAL1
    }

    /// SM0CVAL1CYC Register bits
    namespace sm0cval1cyc_bits {
        constexpr uint32_t CVAL1CYC = (4 << 0);  ///< CVAL1CYC
    }

    /// SM0CVAL2 Register bits
    namespace sm0cval2_bits {
        constexpr uint32_t CAPTVAL2 = (16 << 0);  ///< CAPTVAL2
    }

    /// SM0CVAL2CYC Register bits
    namespace sm0cval2cyc_bits {
        constexpr uint32_t CVAL2CYC = (4 << 0);  ///< CVAL2CYC
    }

    /// SM0CVAL3 Register bits
    namespace sm0cval3_bits {
        constexpr uint32_t CAPTVAL3 = (16 << 0);  ///< CAPTVAL3
    }

    /// SM0CVAL3CYC Register bits
    namespace sm0cval3cyc_bits {
        constexpr uint32_t CVAL3CYC = (4 << 0);  ///< CVAL3CYC
    }

    /// SM0CVAL4 Register bits
    namespace sm0cval4_bits {
        constexpr uint32_t CAPTVAL4 = (16 << 0);  ///< CAPTVAL4
    }

    /// SM0CVAL4CYC Register bits
    namespace sm0cval4cyc_bits {
        constexpr uint32_t CVAL4CYC = (4 << 0);  ///< CVAL4CYC
    }

    /// SM0CVAL5 Register bits
    namespace sm0cval5_bits {
        constexpr uint32_t CAPTVAL5 = (16 << 0);  ///< CAPTVAL5
    }

    /// SM0CVAL5CYC Register bits
    namespace sm0cval5cyc_bits {
        constexpr uint32_t CVAL5CYC = (4 << 0);  ///< CVAL5CYC
    }

    /// SM0PHASEDLY Register bits
    namespace sm0phasedly_bits {
        constexpr uint32_t PHASEDLY = (16 << 0);  ///< Initial Count Register Bits
    }

    /// SM1CNT Register bits
    namespace sm1cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter Register Bits
    }

    /// SM1INIT Register bits
    namespace sm1init_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Count Register Bits
    }

    /// SM1CTRL2 Register bits
    namespace sm1ctrl2_bits {
        constexpr uint32_t CLK_SEL = (2 << 0);  ///< Clock Source Select
        constexpr uint32_t RELOAD_SEL = (1U << 2);  ///< Reload Source Select
        constexpr uint32_t FORCE_SEL = (3 << 3);  ///< This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
        constexpr uint32_t FORCE = (1U << 6);  ///< Force Initialization
        constexpr uint32_t FRCEN = (1U << 7);  ///< FRCEN
        constexpr uint32_t INIT_SEL = (2 << 8);  ///< Initialization Control Select
        constexpr uint32_t PWMX_INIT = (1U << 10);  ///< PWM_X Initial Value
        constexpr uint32_t PWM45_INIT = (1U << 11);  ///< PWM45 Initial Value
        constexpr uint32_t PWM23_INIT = (1U << 12);  ///< PWM23 Initial Value
        constexpr uint32_t INDEP = (1U << 13);  ///< Independent or Complementary Pair Operation
        constexpr uint32_t WAITEN = (1U << 14);  ///< WAIT Enable
        constexpr uint32_t DBGEN = (1U << 15);  ///< Debug Enable
    }

    /// SM1CTRL Register bits
    namespace sm1ctrl_bits {
        constexpr uint32_t DBLEN = (1U << 0);  ///< Double Switching Enable
        constexpr uint32_t DBLX = (1U << 1);  ///< PWMX Double Switching Enable
        constexpr uint32_t LDMOD = (1U << 2);  ///< Load Mode Select
        constexpr uint32_t SPLIT = (1U << 3);  ///< Split the DBLPWM signal to PWMA and PWMB
        constexpr uint32_t PRSC = (3 << 4);  ///< Prescaler
        constexpr uint32_t COMPMODE = (1U << 7);  ///< Compare Mode
        constexpr uint32_t DT = (2 << 8);  ///< Deadtime
        constexpr uint32_t FULL = (1U << 10);  ///< Full Cycle Reload
        constexpr uint32_t HALF = (1U << 11);  ///< Half Cycle Reload
        constexpr uint32_t LDFQ = (4 << 12);  ///< Load Frequency
    }

    /// SM1VAL0 Register bits
    namespace sm1val0_bits {
        constexpr uint32_t VAL0 = (16 << 0);  ///< Value Register 0
    }

    /// SM1FRACVAL1 Register bits
    namespace sm1fracval1_bits {
        constexpr uint32_t FRACVAL1 = (5 << 11);  ///< Fractional Value 1 Register
    }

    /// SM1VAL1 Register bits
    namespace sm1val1_bits {
        constexpr uint32_t VAL1 = (16 << 0);  ///< Value Register 1
    }

    /// SM1FRACVAL2 Register bits
    namespace sm1fracval2_bits {
        constexpr uint32_t FRACVAL2 = (5 << 11);  ///< Fractional Value 2
    }

    /// SM1VAL2 Register bits
    namespace sm1val2_bits {
        constexpr uint32_t VAL2 = (16 << 0);  ///< Value Register 2
    }

    /// SM1FRACVAL3 Register bits
    namespace sm1fracval3_bits {
        constexpr uint32_t FRACVAL3 = (5 << 11);  ///< Fractional Value 3
    }

    /// SM1VAL3 Register bits
    namespace sm1val3_bits {
        constexpr uint32_t VAL3 = (16 << 0);  ///< Value Register 3
    }

    /// SM1FRACVAL4 Register bits
    namespace sm1fracval4_bits {
        constexpr uint32_t FRACVAL4 = (5 << 11);  ///< Fractional Value 4
    }

    /// SM1VAL4 Register bits
    namespace sm1val4_bits {
        constexpr uint32_t VAL4 = (16 << 0);  ///< Value Register 4
    }

    /// SM1FRACVAL5 Register bits
    namespace sm1fracval5_bits {
        constexpr uint32_t FRACVAL5 = (5 << 11);  ///< Fractional Value 5
    }

    /// SM1VAL5 Register bits
    namespace sm1val5_bits {
        constexpr uint32_t VAL5 = (16 << 0);  ///< Value Register 5
    }

    /// SM1FRCTRL Register bits
    namespace sm1frctrl_bits {
        constexpr uint32_t FRAC1_EN = (1U << 1);  ///< Fractional Cycle PWM Period Enable
        constexpr uint32_t FRAC23_EN = (1U << 2);  ///< Fractional Cycle Placement Enable for PWM_A
        constexpr uint32_t FRAC45_EN = (1U << 4);  ///< Fractional Cycle Placement Enable for PWM_B
        constexpr uint32_t FRAC_PU = (1U << 8);  ///< Fractional Delay Circuit Power Up
        constexpr uint32_t TEST = (1U << 15);  ///< Test Status Bit
    }

    /// SM1OCTRL Register bits
    namespace sm1octrl_bits {
        constexpr uint32_t PWMXFS = (2 << 0);  ///< PWM_X Fault State
        constexpr uint32_t PWMBFS = (2 << 2);  ///< PWM_B Fault State
        constexpr uint32_t PWMAFS = (2 << 4);  ///< PWM_A Fault State
        constexpr uint32_t POLX = (1U << 8);  ///< PWM_X Output Polarity
        constexpr uint32_t POLB = (1U << 9);  ///< PWM_B Output Polarity
        constexpr uint32_t POLA = (1U << 10);  ///< PWM_A Output Polarity
        constexpr uint32_t PWMX_IN = (1U << 13);  ///< PWM_X Input
        constexpr uint32_t PWMB_IN = (1U << 14);  ///< PWM_B Input
        constexpr uint32_t PWMA_IN = (1U << 15);  ///< PWM_A Input
    }

    /// SM1STS Register bits
    namespace sm1sts_bits {
        constexpr uint32_t CMPF = (6 << 0);  ///< Compare Flags
        constexpr uint32_t CFX0 = (1U << 6);  ///< Capture Flag X0
        constexpr uint32_t CFX1 = (1U << 7);  ///< Capture Flag X1
        constexpr uint32_t CFB0 = (1U << 8);  ///< Capture Flag B0
        constexpr uint32_t CFB1 = (1U << 9);  ///< Capture Flag B1
        constexpr uint32_t CFA0 = (1U << 10);  ///< Capture Flag A0
        constexpr uint32_t CFA1 = (1U << 11);  ///< Capture Flag A1
        constexpr uint32_t RF = (1U << 12);  ///< Reload Flag
        constexpr uint32_t REF = (1U << 13);  ///< Reload Error Flag
        constexpr uint32_t RUF = (1U << 14);  ///< Registers Updated Flag
    }

    /// SM1INTEN Register bits
    namespace sm1inten_bits {
        constexpr uint32_t CMPIE = (6 << 0);  ///< Compare Interrupt Enables
        constexpr uint32_t CX0IE = (1U << 6);  ///< Capture X 0 Interrupt Enable
        constexpr uint32_t CX1IE = (1U << 7);  ///< Capture X 1 Interrupt Enable
        constexpr uint32_t CB0IE = (1U << 8);  ///< Capture B 0 Interrupt Enable
        constexpr uint32_t CB1IE = (1U << 9);  ///< Capture B 1 Interrupt Enable
        constexpr uint32_t CA0IE = (1U << 10);  ///< Capture A 0 Interrupt Enable
        constexpr uint32_t CA1IE = (1U << 11);  ///< Capture A 1 Interrupt Enable
        constexpr uint32_t RIE = (1U << 12);  ///< Reload Interrupt Enable
        constexpr uint32_t REIE = (1U << 13);  ///< Reload Error Interrupt Enable
    }

    /// SM1DMAEN Register bits
    namespace sm1dmaen_bits {
        constexpr uint32_t CX0DE = (1U << 0);  ///< Capture X0 FIFO DMA Enable
        constexpr uint32_t CX1DE = (1U << 1);  ///< Capture X1 FIFO DMA Enable
        constexpr uint32_t CB0DE = (1U << 2);  ///< Capture B0 FIFO DMA Enable
        constexpr uint32_t CB1DE = (1U << 3);  ///< Capture B1 FIFO DMA Enable
        constexpr uint32_t CA0DE = (1U << 4);  ///< Capture A0 FIFO DMA Enable
        constexpr uint32_t CA1DE = (1U << 5);  ///< Capture A1 FIFO DMA Enable
        constexpr uint32_t CAPTDE = (2 << 6);  ///< Capture DMA Enable Source Select
        constexpr uint32_t FAND = (1U << 8);  ///< FIFO Watermark AND Control
        constexpr uint32_t VALDE = (1U << 9);  ///< Value Registers DMA Enable
    }

    /// SM1TCTRL Register bits
    namespace sm1tctrl_bits {
        constexpr uint32_t OUT_TRIG_EN = (6 << 0);  ///< Output Trigger Enables
        constexpr uint32_t TRGFRQ = (1U << 12);  ///< Trigger frequency
        constexpr uint32_t PWBOT1 = (1U << 14);  ///< Output Trigger 1 Source Select
        constexpr uint32_t PWAOT0 = (1U << 15);  ///< Output Trigger 0 Source Select
    }

    /// SM1DISMAP0 Register bits
    namespace sm1dismap0_bits {
        constexpr uint32_t DIS0A = (4 << 0);  ///< PWM_A Fault Disable Mask 0
        constexpr uint32_t DIS0B = (4 << 4);  ///< PWM_B Fault Disable Mask 0
        constexpr uint32_t DIS0X = (4 << 8);  ///< PWM_X Fault Disable Mask 0
    }

    /// SM1DISMAP1 Register bits
    namespace sm1dismap1_bits {
        constexpr uint32_t DIS1A = (4 << 0);  ///< PWM_A Fault Disable Mask 1
        constexpr uint32_t DIS1B = (4 << 4);  ///< PWM_B Fault Disable Mask 1
        constexpr uint32_t DIS1X = (4 << 8);  ///< PWM_X Fault Disable Mask 1
    }

    /// SM1DTCNT0 Register bits
    namespace sm1dtcnt0_bits {
        constexpr uint32_t DTCNT0 = (16 << 0);  ///< DTCNT0
    }

    /// SM1DTCNT1 Register bits
    namespace sm1dtcnt1_bits {
        constexpr uint32_t DTCNT1 = (16 << 0);  ///< DTCNT1
    }

    /// SM1CAPTCTRLA Register bits
    namespace sm1captctrla_bits {
        constexpr uint32_t ARMA = (1U << 0);  ///< Arm A
        constexpr uint32_t ONESHOTA = (1U << 1);  ///< One Shot Mode A
        constexpr uint32_t EDGA0 = (2 << 2);  ///< Edge A 0
        constexpr uint32_t EDGA1 = (2 << 4);  ///< Edge A 1
        constexpr uint32_t INP_SELA = (1U << 6);  ///< Input Select A
        constexpr uint32_t EDGCNTA_EN = (1U << 7);  ///< Edge Counter A Enable
        constexpr uint32_t CFAWM = (2 << 8);  ///< Capture A FIFOs Water Mark
        constexpr uint32_t CA0CNT = (3 << 10);  ///< Capture A0 FIFO Word Count
        constexpr uint32_t CA1CNT = (3 << 13);  ///< Capture A1 FIFO Word Count
    }

    /// SM1CAPTCOMPA Register bits
    namespace sm1captcompa_bits {
        constexpr uint32_t EDGCMPA = (8 << 0);  ///< Edge Compare A
        constexpr uint32_t EDGCNTA = (8 << 8);  ///< Edge Counter A
    }

    /// SM1CAPTCTRLB Register bits
    namespace sm1captctrlb_bits {
        constexpr uint32_t ARMB = (1U << 0);  ///< Arm B
        constexpr uint32_t ONESHOTB = (1U << 1);  ///< One Shot Mode B
        constexpr uint32_t EDGB0 = (2 << 2);  ///< Edge B 0
        constexpr uint32_t EDGB1 = (2 << 4);  ///< Edge B 1
        constexpr uint32_t INP_SELB = (1U << 6);  ///< Input Select B
        constexpr uint32_t EDGCNTB_EN = (1U << 7);  ///< Edge Counter B Enable
        constexpr uint32_t CFBWM = (2 << 8);  ///< Capture B FIFOs Water Mark
        constexpr uint32_t CB0CNT = (3 << 10);  ///< Capture B0 FIFO Word Count
        constexpr uint32_t CB1CNT = (3 << 13);  ///< Capture B1 FIFO Word Count
    }

    /// SM1CAPTCOMPB Register bits
    namespace sm1captcompb_bits {
        constexpr uint32_t EDGCMPB = (8 << 0);  ///< Edge Compare B
        constexpr uint32_t EDGCNTB = (8 << 8);  ///< Edge Counter B
    }

    /// SM1CAPTCTRLX Register bits
    namespace sm1captctrlx_bits {
        constexpr uint32_t ARMX = (1U << 0);  ///< Arm X
        constexpr uint32_t ONESHOTX = (1U << 1);  ///< One Shot Mode Aux
        constexpr uint32_t EDGX0 = (2 << 2);  ///< Edge X 0
        constexpr uint32_t EDGX1 = (2 << 4);  ///< Edge X 1
        constexpr uint32_t INP_SELX = (1U << 6);  ///< Input Select X
        constexpr uint32_t EDGCNTX_EN = (1U << 7);  ///< Edge Counter X Enable
        constexpr uint32_t CFXWM = (2 << 8);  ///< Capture X FIFOs Water Mark
        constexpr uint32_t CX0CNT = (3 << 10);  ///< Capture X0 FIFO Word Count
        constexpr uint32_t CX1CNT = (3 << 13);  ///< Capture X1 FIFO Word Count
    }

    /// SM1CAPTCOMPX Register bits
    namespace sm1captcompx_bits {
        constexpr uint32_t EDGCMPX = (8 << 0);  ///< Edge Compare X
        constexpr uint32_t EDGCNTX = (8 << 8);  ///< Edge Counter X
    }

    /// SM1CVAL0 Register bits
    namespace sm1cval0_bits {
        constexpr uint32_t CAPTVAL0 = (16 << 0);  ///< CAPTVAL0
    }

    /// SM1CVAL0CYC Register bits
    namespace sm1cval0cyc_bits {
        constexpr uint32_t CVAL0CYC = (4 << 0);  ///< CVAL0CYC
    }

    /// SM1CVAL1 Register bits
    namespace sm1cval1_bits {
        constexpr uint32_t CAPTVAL1 = (16 << 0);  ///< CAPTVAL1
    }

    /// SM1CVAL1CYC Register bits
    namespace sm1cval1cyc_bits {
        constexpr uint32_t CVAL1CYC = (4 << 0);  ///< CVAL1CYC
    }

    /// SM1CVAL2 Register bits
    namespace sm1cval2_bits {
        constexpr uint32_t CAPTVAL2 = (16 << 0);  ///< CAPTVAL2
    }

    /// SM1CVAL2CYC Register bits
    namespace sm1cval2cyc_bits {
        constexpr uint32_t CVAL2CYC = (4 << 0);  ///< CVAL2CYC
    }

    /// SM1CVAL3 Register bits
    namespace sm1cval3_bits {
        constexpr uint32_t CAPTVAL3 = (16 << 0);  ///< CAPTVAL3
    }

    /// SM1CVAL3CYC Register bits
    namespace sm1cval3cyc_bits {
        constexpr uint32_t CVAL3CYC = (4 << 0);  ///< CVAL3CYC
    }

    /// SM1CVAL4 Register bits
    namespace sm1cval4_bits {
        constexpr uint32_t CAPTVAL4 = (16 << 0);  ///< CAPTVAL4
    }

    /// SM1CVAL4CYC Register bits
    namespace sm1cval4cyc_bits {
        constexpr uint32_t CVAL4CYC = (4 << 0);  ///< CVAL4CYC
    }

    /// SM1CVAL5 Register bits
    namespace sm1cval5_bits {
        constexpr uint32_t CAPTVAL5 = (16 << 0);  ///< CAPTVAL5
    }

    /// SM1CVAL5CYC Register bits
    namespace sm1cval5cyc_bits {
        constexpr uint32_t CVAL5CYC = (4 << 0);  ///< CVAL5CYC
    }

    /// SM1PHASEDLY Register bits
    namespace sm1phasedly_bits {
        constexpr uint32_t PHASEDLY = (16 << 0);  ///< Initial Count Register Bits
    }

    /// SM2CNT Register bits
    namespace sm2cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter Register Bits
    }

    /// SM2INIT Register bits
    namespace sm2init_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Count Register Bits
    }

    /// SM2CTRL2 Register bits
    namespace sm2ctrl2_bits {
        constexpr uint32_t CLK_SEL = (2 << 0);  ///< Clock Source Select
        constexpr uint32_t RELOAD_SEL = (1U << 2);  ///< Reload Source Select
        constexpr uint32_t FORCE_SEL = (3 << 3);  ///< This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
        constexpr uint32_t FORCE = (1U << 6);  ///< Force Initialization
        constexpr uint32_t FRCEN = (1U << 7);  ///< FRCEN
        constexpr uint32_t INIT_SEL = (2 << 8);  ///< Initialization Control Select
        constexpr uint32_t PWMX_INIT = (1U << 10);  ///< PWM_X Initial Value
        constexpr uint32_t PWM45_INIT = (1U << 11);  ///< PWM45 Initial Value
        constexpr uint32_t PWM23_INIT = (1U << 12);  ///< PWM23 Initial Value
        constexpr uint32_t INDEP = (1U << 13);  ///< Independent or Complementary Pair Operation
        constexpr uint32_t WAITEN = (1U << 14);  ///< WAIT Enable
        constexpr uint32_t DBGEN = (1U << 15);  ///< Debug Enable
    }

    /// SM2CTRL Register bits
    namespace sm2ctrl_bits {
        constexpr uint32_t DBLEN = (1U << 0);  ///< Double Switching Enable
        constexpr uint32_t DBLX = (1U << 1);  ///< PWMX Double Switching Enable
        constexpr uint32_t LDMOD = (1U << 2);  ///< Load Mode Select
        constexpr uint32_t SPLIT = (1U << 3);  ///< Split the DBLPWM signal to PWMA and PWMB
        constexpr uint32_t PRSC = (3 << 4);  ///< Prescaler
        constexpr uint32_t COMPMODE = (1U << 7);  ///< Compare Mode
        constexpr uint32_t DT = (2 << 8);  ///< Deadtime
        constexpr uint32_t FULL = (1U << 10);  ///< Full Cycle Reload
        constexpr uint32_t HALF = (1U << 11);  ///< Half Cycle Reload
        constexpr uint32_t LDFQ = (4 << 12);  ///< Load Frequency
    }

    /// SM2VAL0 Register bits
    namespace sm2val0_bits {
        constexpr uint32_t VAL0 = (16 << 0);  ///< Value Register 0
    }

    /// SM2FRACVAL1 Register bits
    namespace sm2fracval1_bits {
        constexpr uint32_t FRACVAL1 = (5 << 11);  ///< Fractional Value 1 Register
    }

    /// SM2VAL1 Register bits
    namespace sm2val1_bits {
        constexpr uint32_t VAL1 = (16 << 0);  ///< Value Register 1
    }

    /// SM2FRACVAL2 Register bits
    namespace sm2fracval2_bits {
        constexpr uint32_t FRACVAL2 = (5 << 11);  ///< Fractional Value 2
    }

    /// SM2VAL2 Register bits
    namespace sm2val2_bits {
        constexpr uint32_t VAL2 = (16 << 0);  ///< Value Register 2
    }

    /// SM2FRACVAL3 Register bits
    namespace sm2fracval3_bits {
        constexpr uint32_t FRACVAL3 = (5 << 11);  ///< Fractional Value 3
    }

    /// SM2VAL3 Register bits
    namespace sm2val3_bits {
        constexpr uint32_t VAL3 = (16 << 0);  ///< Value Register 3
    }

    /// SM2FRACVAL4 Register bits
    namespace sm2fracval4_bits {
        constexpr uint32_t FRACVAL4 = (5 << 11);  ///< Fractional Value 4
    }

    /// SM2VAL4 Register bits
    namespace sm2val4_bits {
        constexpr uint32_t VAL4 = (16 << 0);  ///< Value Register 4
    }

    /// SM2FRACVAL5 Register bits
    namespace sm2fracval5_bits {
        constexpr uint32_t FRACVAL5 = (5 << 11);  ///< Fractional Value 5
    }

    /// SM2VAL5 Register bits
    namespace sm2val5_bits {
        constexpr uint32_t VAL5 = (16 << 0);  ///< Value Register 5
    }

    /// SM2FRCTRL Register bits
    namespace sm2frctrl_bits {
        constexpr uint32_t FRAC1_EN = (1U << 1);  ///< Fractional Cycle PWM Period Enable
        constexpr uint32_t FRAC23_EN = (1U << 2);  ///< Fractional Cycle Placement Enable for PWM_A
        constexpr uint32_t FRAC45_EN = (1U << 4);  ///< Fractional Cycle Placement Enable for PWM_B
        constexpr uint32_t FRAC_PU = (1U << 8);  ///< Fractional Delay Circuit Power Up
        constexpr uint32_t TEST = (1U << 15);  ///< Test Status Bit
    }

    /// SM2OCTRL Register bits
    namespace sm2octrl_bits {
        constexpr uint32_t PWMXFS = (2 << 0);  ///< PWM_X Fault State
        constexpr uint32_t PWMBFS = (2 << 2);  ///< PWM_B Fault State
        constexpr uint32_t PWMAFS = (2 << 4);  ///< PWM_A Fault State
        constexpr uint32_t POLX = (1U << 8);  ///< PWM_X Output Polarity
        constexpr uint32_t POLB = (1U << 9);  ///< PWM_B Output Polarity
        constexpr uint32_t POLA = (1U << 10);  ///< PWM_A Output Polarity
        constexpr uint32_t PWMX_IN = (1U << 13);  ///< PWM_X Input
        constexpr uint32_t PWMB_IN = (1U << 14);  ///< PWM_B Input
        constexpr uint32_t PWMA_IN = (1U << 15);  ///< PWM_A Input
    }

    /// SM2STS Register bits
    namespace sm2sts_bits {
        constexpr uint32_t CMPF = (6 << 0);  ///< Compare Flags
        constexpr uint32_t CFX0 = (1U << 6);  ///< Capture Flag X0
        constexpr uint32_t CFX1 = (1U << 7);  ///< Capture Flag X1
        constexpr uint32_t CFB0 = (1U << 8);  ///< Capture Flag B0
        constexpr uint32_t CFB1 = (1U << 9);  ///< Capture Flag B1
        constexpr uint32_t CFA0 = (1U << 10);  ///< Capture Flag A0
        constexpr uint32_t CFA1 = (1U << 11);  ///< Capture Flag A1
        constexpr uint32_t RF = (1U << 12);  ///< Reload Flag
        constexpr uint32_t REF = (1U << 13);  ///< Reload Error Flag
        constexpr uint32_t RUF = (1U << 14);  ///< Registers Updated Flag
    }

    /// SM2INTEN Register bits
    namespace sm2inten_bits {
        constexpr uint32_t CMPIE = (6 << 0);  ///< Compare Interrupt Enables
        constexpr uint32_t CX0IE = (1U << 6);  ///< Capture X 0 Interrupt Enable
        constexpr uint32_t CX1IE = (1U << 7);  ///< Capture X 1 Interrupt Enable
        constexpr uint32_t CB0IE = (1U << 8);  ///< Capture B 0 Interrupt Enable
        constexpr uint32_t CB1IE = (1U << 9);  ///< Capture B 1 Interrupt Enable
        constexpr uint32_t CA0IE = (1U << 10);  ///< Capture A 0 Interrupt Enable
        constexpr uint32_t CA1IE = (1U << 11);  ///< Capture A 1 Interrupt Enable
        constexpr uint32_t RIE = (1U << 12);  ///< Reload Interrupt Enable
        constexpr uint32_t REIE = (1U << 13);  ///< Reload Error Interrupt Enable
    }

    /// SM2DMAEN Register bits
    namespace sm2dmaen_bits {
        constexpr uint32_t CX0DE = (1U << 0);  ///< Capture X0 FIFO DMA Enable
        constexpr uint32_t CX1DE = (1U << 1);  ///< Capture X1 FIFO DMA Enable
        constexpr uint32_t CB0DE = (1U << 2);  ///< Capture B0 FIFO DMA Enable
        constexpr uint32_t CB1DE = (1U << 3);  ///< Capture B1 FIFO DMA Enable
        constexpr uint32_t CA0DE = (1U << 4);  ///< Capture A0 FIFO DMA Enable
        constexpr uint32_t CA1DE = (1U << 5);  ///< Capture A1 FIFO DMA Enable
        constexpr uint32_t CAPTDE = (2 << 6);  ///< Capture DMA Enable Source Select
        constexpr uint32_t FAND = (1U << 8);  ///< FIFO Watermark AND Control
        constexpr uint32_t VALDE = (1U << 9);  ///< Value Registers DMA Enable
    }

    /// SM2TCTRL Register bits
    namespace sm2tctrl_bits {
        constexpr uint32_t OUT_TRIG_EN = (6 << 0);  ///< Output Trigger Enables
        constexpr uint32_t TRGFRQ = (1U << 12);  ///< Trigger frequency
        constexpr uint32_t PWBOT1 = (1U << 14);  ///< Output Trigger 1 Source Select
        constexpr uint32_t PWAOT0 = (1U << 15);  ///< Output Trigger 0 Source Select
    }

    /// SM2DISMAP0 Register bits
    namespace sm2dismap0_bits {
        constexpr uint32_t DIS0A = (4 << 0);  ///< PWM_A Fault Disable Mask 0
        constexpr uint32_t DIS0B = (4 << 4);  ///< PWM_B Fault Disable Mask 0
        constexpr uint32_t DIS0X = (4 << 8);  ///< PWM_X Fault Disable Mask 0
    }

    /// SM2DISMAP1 Register bits
    namespace sm2dismap1_bits {
        constexpr uint32_t DIS1A = (4 << 0);  ///< PWM_A Fault Disable Mask 1
        constexpr uint32_t DIS1B = (4 << 4);  ///< PWM_B Fault Disable Mask 1
        constexpr uint32_t DIS1X = (4 << 8);  ///< PWM_X Fault Disable Mask 1
    }

    /// SM2DTCNT0 Register bits
    namespace sm2dtcnt0_bits {
        constexpr uint32_t DTCNT0 = (16 << 0);  ///< DTCNT0
    }

    /// SM2DTCNT1 Register bits
    namespace sm2dtcnt1_bits {
        constexpr uint32_t DTCNT1 = (16 << 0);  ///< DTCNT1
    }

    /// SM2CAPTCTRLA Register bits
    namespace sm2captctrla_bits {
        constexpr uint32_t ARMA = (1U << 0);  ///< Arm A
        constexpr uint32_t ONESHOTA = (1U << 1);  ///< One Shot Mode A
        constexpr uint32_t EDGA0 = (2 << 2);  ///< Edge A 0
        constexpr uint32_t EDGA1 = (2 << 4);  ///< Edge A 1
        constexpr uint32_t INP_SELA = (1U << 6);  ///< Input Select A
        constexpr uint32_t EDGCNTA_EN = (1U << 7);  ///< Edge Counter A Enable
        constexpr uint32_t CFAWM = (2 << 8);  ///< Capture A FIFOs Water Mark
        constexpr uint32_t CA0CNT = (3 << 10);  ///< Capture A0 FIFO Word Count
        constexpr uint32_t CA1CNT = (3 << 13);  ///< Capture A1 FIFO Word Count
    }

    /// SM2CAPTCOMPA Register bits
    namespace sm2captcompa_bits {
        constexpr uint32_t EDGCMPA = (8 << 0);  ///< Edge Compare A
        constexpr uint32_t EDGCNTA = (8 << 8);  ///< Edge Counter A
    }

    /// SM2CAPTCTRLB Register bits
    namespace sm2captctrlb_bits {
        constexpr uint32_t ARMB = (1U << 0);  ///< Arm B
        constexpr uint32_t ONESHOTB = (1U << 1);  ///< One Shot Mode B
        constexpr uint32_t EDGB0 = (2 << 2);  ///< Edge B 0
        constexpr uint32_t EDGB1 = (2 << 4);  ///< Edge B 1
        constexpr uint32_t INP_SELB = (1U << 6);  ///< Input Select B
        constexpr uint32_t EDGCNTB_EN = (1U << 7);  ///< Edge Counter B Enable
        constexpr uint32_t CFBWM = (2 << 8);  ///< Capture B FIFOs Water Mark
        constexpr uint32_t CB0CNT = (3 << 10);  ///< Capture B0 FIFO Word Count
        constexpr uint32_t CB1CNT = (3 << 13);  ///< Capture B1 FIFO Word Count
    }

    /// SM2CAPTCOMPB Register bits
    namespace sm2captcompb_bits {
        constexpr uint32_t EDGCMPB = (8 << 0);  ///< Edge Compare B
        constexpr uint32_t EDGCNTB = (8 << 8);  ///< Edge Counter B
    }

    /// SM2CAPTCTRLX Register bits
    namespace sm2captctrlx_bits {
        constexpr uint32_t ARMX = (1U << 0);  ///< Arm X
        constexpr uint32_t ONESHOTX = (1U << 1);  ///< One Shot Mode Aux
        constexpr uint32_t EDGX0 = (2 << 2);  ///< Edge X 0
        constexpr uint32_t EDGX1 = (2 << 4);  ///< Edge X 1
        constexpr uint32_t INP_SELX = (1U << 6);  ///< Input Select X
        constexpr uint32_t EDGCNTX_EN = (1U << 7);  ///< Edge Counter X Enable
        constexpr uint32_t CFXWM = (2 << 8);  ///< Capture X FIFOs Water Mark
        constexpr uint32_t CX0CNT = (3 << 10);  ///< Capture X0 FIFO Word Count
        constexpr uint32_t CX1CNT = (3 << 13);  ///< Capture X1 FIFO Word Count
    }

    /// SM2CAPTCOMPX Register bits
    namespace sm2captcompx_bits {
        constexpr uint32_t EDGCMPX = (8 << 0);  ///< Edge Compare X
        constexpr uint32_t EDGCNTX = (8 << 8);  ///< Edge Counter X
    }

    /// SM2CVAL0 Register bits
    namespace sm2cval0_bits {
        constexpr uint32_t CAPTVAL0 = (16 << 0);  ///< CAPTVAL0
    }

    /// SM2CVAL0CYC Register bits
    namespace sm2cval0cyc_bits {
        constexpr uint32_t CVAL0CYC = (4 << 0);  ///< CVAL0CYC
    }

    /// SM2CVAL1 Register bits
    namespace sm2cval1_bits {
        constexpr uint32_t CAPTVAL1 = (16 << 0);  ///< CAPTVAL1
    }

    /// SM2CVAL1CYC Register bits
    namespace sm2cval1cyc_bits {
        constexpr uint32_t CVAL1CYC = (4 << 0);  ///< CVAL1CYC
    }

    /// SM2CVAL2 Register bits
    namespace sm2cval2_bits {
        constexpr uint32_t CAPTVAL2 = (16 << 0);  ///< CAPTVAL2
    }

    /// SM2CVAL2CYC Register bits
    namespace sm2cval2cyc_bits {
        constexpr uint32_t CVAL2CYC = (4 << 0);  ///< CVAL2CYC
    }

    /// SM2CVAL3 Register bits
    namespace sm2cval3_bits {
        constexpr uint32_t CAPTVAL3 = (16 << 0);  ///< CAPTVAL3
    }

    /// SM2CVAL3CYC Register bits
    namespace sm2cval3cyc_bits {
        constexpr uint32_t CVAL3CYC = (4 << 0);  ///< CVAL3CYC
    }

    /// SM2CVAL4 Register bits
    namespace sm2cval4_bits {
        constexpr uint32_t CAPTVAL4 = (16 << 0);  ///< CAPTVAL4
    }

    /// SM2CVAL4CYC Register bits
    namespace sm2cval4cyc_bits {
        constexpr uint32_t CVAL4CYC = (4 << 0);  ///< CVAL4CYC
    }

    /// SM2CVAL5 Register bits
    namespace sm2cval5_bits {
        constexpr uint32_t CAPTVAL5 = (16 << 0);  ///< CAPTVAL5
    }

    /// SM2CVAL5CYC Register bits
    namespace sm2cval5cyc_bits {
        constexpr uint32_t CVAL5CYC = (4 << 0);  ///< CVAL5CYC
    }

    /// SM2PHASEDLY Register bits
    namespace sm2phasedly_bits {
        constexpr uint32_t PHASEDLY = (16 << 0);  ///< Initial Count Register Bits
    }

    /// SM3CNT Register bits
    namespace sm3cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter Register Bits
    }

    /// SM3INIT Register bits
    namespace sm3init_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Count Register Bits
    }

    /// SM3CTRL2 Register bits
    namespace sm3ctrl2_bits {
        constexpr uint32_t CLK_SEL = (2 << 0);  ///< Clock Source Select
        constexpr uint32_t RELOAD_SEL = (1U << 2);  ///< Reload Source Select
        constexpr uint32_t FORCE_SEL = (3 << 3);  ///< This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
        constexpr uint32_t FORCE = (1U << 6);  ///< Force Initialization
        constexpr uint32_t FRCEN = (1U << 7);  ///< FRCEN
        constexpr uint32_t INIT_SEL = (2 << 8);  ///< Initialization Control Select
        constexpr uint32_t PWMX_INIT = (1U << 10);  ///< PWM_X Initial Value
        constexpr uint32_t PWM45_INIT = (1U << 11);  ///< PWM45 Initial Value
        constexpr uint32_t PWM23_INIT = (1U << 12);  ///< PWM23 Initial Value
        constexpr uint32_t INDEP = (1U << 13);  ///< Independent or Complementary Pair Operation
        constexpr uint32_t WAITEN = (1U << 14);  ///< WAIT Enable
        constexpr uint32_t DBGEN = (1U << 15);  ///< Debug Enable
    }

    /// SM3CTRL Register bits
    namespace sm3ctrl_bits {
        constexpr uint32_t DBLEN = (1U << 0);  ///< Double Switching Enable
        constexpr uint32_t DBLX = (1U << 1);  ///< PWMX Double Switching Enable
        constexpr uint32_t LDMOD = (1U << 2);  ///< Load Mode Select
        constexpr uint32_t SPLIT = (1U << 3);  ///< Split the DBLPWM signal to PWMA and PWMB
        constexpr uint32_t PRSC = (3 << 4);  ///< Prescaler
        constexpr uint32_t COMPMODE = (1U << 7);  ///< Compare Mode
        constexpr uint32_t DT = (2 << 8);  ///< Deadtime
        constexpr uint32_t FULL = (1U << 10);  ///< Full Cycle Reload
        constexpr uint32_t HALF = (1U << 11);  ///< Half Cycle Reload
        constexpr uint32_t LDFQ = (4 << 12);  ///< Load Frequency
    }

    /// SM3VAL0 Register bits
    namespace sm3val0_bits {
        constexpr uint32_t VAL0 = (16 << 0);  ///< Value Register 0
    }

    /// SM3FRACVAL1 Register bits
    namespace sm3fracval1_bits {
        constexpr uint32_t FRACVAL1 = (5 << 11);  ///< Fractional Value 1 Register
    }

    /// SM3VAL1 Register bits
    namespace sm3val1_bits {
        constexpr uint32_t VAL1 = (16 << 0);  ///< Value Register 1
    }

    /// SM3FRACVAL2 Register bits
    namespace sm3fracval2_bits {
        constexpr uint32_t FRACVAL2 = (5 << 11);  ///< Fractional Value 2
    }

    /// SM3VAL2 Register bits
    namespace sm3val2_bits {
        constexpr uint32_t VAL2 = (16 << 0);  ///< Value Register 2
    }

    /// SM3FRACVAL3 Register bits
    namespace sm3fracval3_bits {
        constexpr uint32_t FRACVAL3 = (5 << 11);  ///< Fractional Value 3
    }

    /// SM3VAL3 Register bits
    namespace sm3val3_bits {
        constexpr uint32_t VAL3 = (16 << 0);  ///< Value Register 3
    }

    /// SM3FRACVAL4 Register bits
    namespace sm3fracval4_bits {
        constexpr uint32_t FRACVAL4 = (5 << 11);  ///< Fractional Value 4
    }

    /// SM3VAL4 Register bits
    namespace sm3val4_bits {
        constexpr uint32_t VAL4 = (16 << 0);  ///< Value Register 4
    }

    /// SM3FRACVAL5 Register bits
    namespace sm3fracval5_bits {
        constexpr uint32_t FRACVAL5 = (5 << 11);  ///< Fractional Value 5
    }

    /// SM3VAL5 Register bits
    namespace sm3val5_bits {
        constexpr uint32_t VAL5 = (16 << 0);  ///< Value Register 5
    }

    /// SM3FRCTRL Register bits
    namespace sm3frctrl_bits {
        constexpr uint32_t FRAC1_EN = (1U << 1);  ///< Fractional Cycle PWM Period Enable
        constexpr uint32_t FRAC23_EN = (1U << 2);  ///< Fractional Cycle Placement Enable for PWM_A
        constexpr uint32_t FRAC45_EN = (1U << 4);  ///< Fractional Cycle Placement Enable for PWM_B
        constexpr uint32_t FRAC_PU = (1U << 8);  ///< Fractional Delay Circuit Power Up
        constexpr uint32_t TEST = (1U << 15);  ///< Test Status Bit
    }

    /// SM3OCTRL Register bits
    namespace sm3octrl_bits {
        constexpr uint32_t PWMXFS = (2 << 0);  ///< PWM_X Fault State
        constexpr uint32_t PWMBFS = (2 << 2);  ///< PWM_B Fault State
        constexpr uint32_t PWMAFS = (2 << 4);  ///< PWM_A Fault State
        constexpr uint32_t POLX = (1U << 8);  ///< PWM_X Output Polarity
        constexpr uint32_t POLB = (1U << 9);  ///< PWM_B Output Polarity
        constexpr uint32_t POLA = (1U << 10);  ///< PWM_A Output Polarity
        constexpr uint32_t PWMX_IN = (1U << 13);  ///< PWM_X Input
        constexpr uint32_t PWMB_IN = (1U << 14);  ///< PWM_B Input
        constexpr uint32_t PWMA_IN = (1U << 15);  ///< PWM_A Input
    }

    /// SM3STS Register bits
    namespace sm3sts_bits {
        constexpr uint32_t CMPF = (6 << 0);  ///< Compare Flags
        constexpr uint32_t CFX0 = (1U << 6);  ///< Capture Flag X0
        constexpr uint32_t CFX1 = (1U << 7);  ///< Capture Flag X1
        constexpr uint32_t CFB0 = (1U << 8);  ///< Capture Flag B0
        constexpr uint32_t CFB1 = (1U << 9);  ///< Capture Flag B1
        constexpr uint32_t CFA0 = (1U << 10);  ///< Capture Flag A0
        constexpr uint32_t CFA1 = (1U << 11);  ///< Capture Flag A1
        constexpr uint32_t RF = (1U << 12);  ///< Reload Flag
        constexpr uint32_t REF = (1U << 13);  ///< Reload Error Flag
        constexpr uint32_t RUF = (1U << 14);  ///< Registers Updated Flag
    }

    /// SM3INTEN Register bits
    namespace sm3inten_bits {
        constexpr uint32_t CMPIE = (6 << 0);  ///< Compare Interrupt Enables
        constexpr uint32_t CX0IE = (1U << 6);  ///< Capture X 0 Interrupt Enable
        constexpr uint32_t CX1IE = (1U << 7);  ///< Capture X 1 Interrupt Enable
        constexpr uint32_t CB0IE = (1U << 8);  ///< Capture B 0 Interrupt Enable
        constexpr uint32_t CB1IE = (1U << 9);  ///< Capture B 1 Interrupt Enable
        constexpr uint32_t CA0IE = (1U << 10);  ///< Capture A 0 Interrupt Enable
        constexpr uint32_t CA1IE = (1U << 11);  ///< Capture A 1 Interrupt Enable
        constexpr uint32_t RIE = (1U << 12);  ///< Reload Interrupt Enable
        constexpr uint32_t REIE = (1U << 13);  ///< Reload Error Interrupt Enable
    }

    /// SM3DMAEN Register bits
    namespace sm3dmaen_bits {
        constexpr uint32_t CX0DE = (1U << 0);  ///< Capture X0 FIFO DMA Enable
        constexpr uint32_t CX1DE = (1U << 1);  ///< Capture X1 FIFO DMA Enable
        constexpr uint32_t CB0DE = (1U << 2);  ///< Capture B0 FIFO DMA Enable
        constexpr uint32_t CB1DE = (1U << 3);  ///< Capture B1 FIFO DMA Enable
        constexpr uint32_t CA0DE = (1U << 4);  ///< Capture A0 FIFO DMA Enable
        constexpr uint32_t CA1DE = (1U << 5);  ///< Capture A1 FIFO DMA Enable
        constexpr uint32_t CAPTDE = (2 << 6);  ///< Capture DMA Enable Source Select
        constexpr uint32_t FAND = (1U << 8);  ///< FIFO Watermark AND Control
        constexpr uint32_t VALDE = (1U << 9);  ///< Value Registers DMA Enable
    }

    /// SM3TCTRL Register bits
    namespace sm3tctrl_bits {
        constexpr uint32_t OUT_TRIG_EN = (6 << 0);  ///< Output Trigger Enables
        constexpr uint32_t TRGFRQ = (1U << 12);  ///< Trigger frequency
        constexpr uint32_t PWBOT1 = (1U << 14);  ///< Output Trigger 1 Source Select
        constexpr uint32_t PWAOT0 = (1U << 15);  ///< Output Trigger 0 Source Select
    }

    /// SM3DISMAP0 Register bits
    namespace sm3dismap0_bits {
        constexpr uint32_t DIS0A = (4 << 0);  ///< PWM_A Fault Disable Mask 0
        constexpr uint32_t DIS0B = (4 << 4);  ///< PWM_B Fault Disable Mask 0
        constexpr uint32_t DIS0X = (4 << 8);  ///< PWM_X Fault Disable Mask 0
    }

    /// SM3DISMAP1 Register bits
    namespace sm3dismap1_bits {
        constexpr uint32_t DIS1A = (4 << 0);  ///< PWM_A Fault Disable Mask 1
        constexpr uint32_t DIS1B = (4 << 4);  ///< PWM_B Fault Disable Mask 1
        constexpr uint32_t DIS1X = (4 << 8);  ///< PWM_X Fault Disable Mask 1
    }

    /// SM3DTCNT0 Register bits
    namespace sm3dtcnt0_bits {
        constexpr uint32_t DTCNT0 = (16 << 0);  ///< DTCNT0
    }

    /// SM3DTCNT1 Register bits
    namespace sm3dtcnt1_bits {
        constexpr uint32_t DTCNT1 = (16 << 0);  ///< DTCNT1
    }

    /// SM3CAPTCTRLA Register bits
    namespace sm3captctrla_bits {
        constexpr uint32_t ARMA = (1U << 0);  ///< Arm A
        constexpr uint32_t ONESHOTA = (1U << 1);  ///< One Shot Mode A
        constexpr uint32_t EDGA0 = (2 << 2);  ///< Edge A 0
        constexpr uint32_t EDGA1 = (2 << 4);  ///< Edge A 1
        constexpr uint32_t INP_SELA = (1U << 6);  ///< Input Select A
        constexpr uint32_t EDGCNTA_EN = (1U << 7);  ///< Edge Counter A Enable
        constexpr uint32_t CFAWM = (2 << 8);  ///< Capture A FIFOs Water Mark
        constexpr uint32_t CA0CNT = (3 << 10);  ///< Capture A0 FIFO Word Count
        constexpr uint32_t CA1CNT = (3 << 13);  ///< Capture A1 FIFO Word Count
    }

    /// SM3CAPTCOMPA Register bits
    namespace sm3captcompa_bits {
        constexpr uint32_t EDGCMPA = (8 << 0);  ///< Edge Compare A
        constexpr uint32_t EDGCNTA = (8 << 8);  ///< Edge Counter A
    }

    /// SM3CAPTCTRLB Register bits
    namespace sm3captctrlb_bits {
        constexpr uint32_t ARMB = (1U << 0);  ///< Arm B
        constexpr uint32_t ONESHOTB = (1U << 1);  ///< One Shot Mode B
        constexpr uint32_t EDGB0 = (2 << 2);  ///< Edge B 0
        constexpr uint32_t EDGB1 = (2 << 4);  ///< Edge B 1
        constexpr uint32_t INP_SELB = (1U << 6);  ///< Input Select B
        constexpr uint32_t EDGCNTB_EN = (1U << 7);  ///< Edge Counter B Enable
        constexpr uint32_t CFBWM = (2 << 8);  ///< Capture B FIFOs Water Mark
        constexpr uint32_t CB0CNT = (3 << 10);  ///< Capture B0 FIFO Word Count
        constexpr uint32_t CB1CNT = (3 << 13);  ///< Capture B1 FIFO Word Count
    }

    /// SM3CAPTCOMPB Register bits
    namespace sm3captcompb_bits {
        constexpr uint32_t EDGCMPB = (8 << 0);  ///< Edge Compare B
        constexpr uint32_t EDGCNTB = (8 << 8);  ///< Edge Counter B
    }

    /// SM3CAPTCTRLX Register bits
    namespace sm3captctrlx_bits {
        constexpr uint32_t ARMX = (1U << 0);  ///< Arm X
        constexpr uint32_t ONESHOTX = (1U << 1);  ///< One Shot Mode Aux
        constexpr uint32_t EDGX0 = (2 << 2);  ///< Edge X 0
        constexpr uint32_t EDGX1 = (2 << 4);  ///< Edge X 1
        constexpr uint32_t INP_SELX = (1U << 6);  ///< Input Select X
        constexpr uint32_t EDGCNTX_EN = (1U << 7);  ///< Edge Counter X Enable
        constexpr uint32_t CFXWM = (2 << 8);  ///< Capture X FIFOs Water Mark
        constexpr uint32_t CX0CNT = (3 << 10);  ///< Capture X0 FIFO Word Count
        constexpr uint32_t CX1CNT = (3 << 13);  ///< Capture X1 FIFO Word Count
    }

    /// SM3CAPTCOMPX Register bits
    namespace sm3captcompx_bits {
        constexpr uint32_t EDGCMPX = (8 << 0);  ///< Edge Compare X
        constexpr uint32_t EDGCNTX = (8 << 8);  ///< Edge Counter X
    }

    /// SM3CVAL0 Register bits
    namespace sm3cval0_bits {
        constexpr uint32_t CAPTVAL0 = (16 << 0);  ///< CAPTVAL0
    }

    /// SM3CVAL0CYC Register bits
    namespace sm3cval0cyc_bits {
        constexpr uint32_t CVAL0CYC = (4 << 0);  ///< CVAL0CYC
    }

    /// SM3CVAL1 Register bits
    namespace sm3cval1_bits {
        constexpr uint32_t CAPTVAL1 = (16 << 0);  ///< CAPTVAL1
    }

    /// SM3CVAL1CYC Register bits
    namespace sm3cval1cyc_bits {
        constexpr uint32_t CVAL1CYC = (4 << 0);  ///< CVAL1CYC
    }

    /// SM3CVAL2 Register bits
    namespace sm3cval2_bits {
        constexpr uint32_t CAPTVAL2 = (16 << 0);  ///< CAPTVAL2
    }

    /// SM3CVAL2CYC Register bits
    namespace sm3cval2cyc_bits {
        constexpr uint32_t CVAL2CYC = (4 << 0);  ///< CVAL2CYC
    }

    /// SM3CVAL3 Register bits
    namespace sm3cval3_bits {
        constexpr uint32_t CAPTVAL3 = (16 << 0);  ///< CAPTVAL3
    }

    /// SM3CVAL3CYC Register bits
    namespace sm3cval3cyc_bits {
        constexpr uint32_t CVAL3CYC = (4 << 0);  ///< CVAL3CYC
    }

    /// SM3CVAL4 Register bits
    namespace sm3cval4_bits {
        constexpr uint32_t CAPTVAL4 = (16 << 0);  ///< CAPTVAL4
    }

    /// SM3CVAL4CYC Register bits
    namespace sm3cval4cyc_bits {
        constexpr uint32_t CVAL4CYC = (4 << 0);  ///< CVAL4CYC
    }

    /// SM3CVAL5 Register bits
    namespace sm3cval5_bits {
        constexpr uint32_t CAPTVAL5 = (16 << 0);  ///< CAPTVAL5
    }

    /// SM3CVAL5CYC Register bits
    namespace sm3cval5cyc_bits {
        constexpr uint32_t CVAL5CYC = (4 << 0);  ///< CVAL5CYC
    }

    /// SM3PHASEDLY Register bits
    namespace sm3phasedly_bits {
        constexpr uint32_t PHASEDLY = (16 << 0);  ///< Initial Count Register Bits
    }

    /// OUTEN Register bits
    namespace outen_bits {
        constexpr uint32_t PWMX_EN = (4 << 0);  ///< PWM_X Output Enables
        constexpr uint32_t PWMB_EN = (4 << 4);  ///< PWM_B Output Enables
        constexpr uint32_t PWMA_EN = (4 << 8);  ///< PWM_A Output Enables
    }

    /// MASK Register bits
    namespace mask_bits {
        constexpr uint32_t MASKX = (4 << 0);  ///< PWM_X Masks
        constexpr uint32_t MASKB = (4 << 4);  ///< PWM_B Masks
        constexpr uint32_t MASKA = (4 << 8);  ///< PWM_A Masks
        constexpr uint32_t UPDATE_MASK = (4 << 12);  ///< Update Mask Bits Immediately
    }

    /// SWCOUT Register bits
    namespace swcout_bits {
        constexpr uint32_t SM0OUT45 = (1U << 0);  ///< Submodule 0 Software Controlled Output 45
        constexpr uint32_t SM0OUT23 = (1U << 1);  ///< Submodule 0 Software Controlled Output 23
        constexpr uint32_t SM1OUT45 = (1U << 2);  ///< Submodule 1 Software Controlled Output 45
        constexpr uint32_t SM1OUT23 = (1U << 3);  ///< Submodule 1 Software Controlled Output 23
        constexpr uint32_t SM2OUT45 = (1U << 4);  ///< Submodule 2 Software Controlled Output 45
        constexpr uint32_t SM2OUT23 = (1U << 5);  ///< Submodule 2 Software Controlled Output 23
        constexpr uint32_t SM3OUT45 = (1U << 6);  ///< Submodule 3 Software Controlled Output 45
        constexpr uint32_t SM3OUT23 = (1U << 7);  ///< Submodule 3 Software Controlled Output 23
    }

    /// DTSRCSEL Register bits
    namespace dtsrcsel_bits {
        constexpr uint32_t SM0SEL45 = (2 << 0);  ///< Submodule 0 PWM45 Control Select
        constexpr uint32_t SM0SEL23 = (2 << 2);  ///< Submodule 0 PWM23 Control Select
        constexpr uint32_t SM1SEL45 = (2 << 4);  ///< Submodule 1 PWM45 Control Select
        constexpr uint32_t SM1SEL23 = (2 << 6);  ///< Submodule 1 PWM23 Control Select
        constexpr uint32_t SM2SEL45 = (2 << 8);  ///< Submodule 2 PWM45 Control Select
        constexpr uint32_t SM2SEL23 = (2 << 10);  ///< Submodule 2 PWM23 Control Select
        constexpr uint32_t SM3SEL45 = (2 << 12);  ///< Submodule 3 PWM45 Control Select
        constexpr uint32_t SM3SEL23 = (2 << 14);  ///< Submodule 3 PWM23 Control Select
    }

    /// MCTRL Register bits
    namespace mctrl_bits {
        constexpr uint32_t LDOK = (4 << 0);  ///< Load Okay
        constexpr uint32_t CLDOK = (4 << 4);  ///< Clear Load Okay
        constexpr uint32_t RUN = (4 << 8);  ///< Run
        constexpr uint32_t IPOL = (4 << 12);  ///< Current Polarity
    }

    /// MCTRL2 Register bits
    namespace mctrl2_bits {
        constexpr uint32_t MONPLL = (2 << 0);  ///< Monitor PLL State
    }

    /// FCTRL0 Register bits
    namespace fctrl0_bits {
        constexpr uint32_t FIE = (4 << 0);  ///< Fault Interrupt Enables
        constexpr uint32_t FSAFE = (4 << 4);  ///< Fault Safety Mode
        constexpr uint32_t FAUTO = (4 << 8);  ///< Automatic Fault Clearing
        constexpr uint32_t FLVL = (4 << 12);  ///< Fault Level
    }

    /// FSTS0 Register bits
    namespace fsts0_bits {
        constexpr uint32_t FFLAG = (4 << 0);  ///< Fault Flags
        constexpr uint32_t FFULL = (4 << 4);  ///< Full Cycle
        constexpr uint32_t FFPIN = (4 << 8);  ///< Filtered Fault Pins
        constexpr uint32_t FHALF = (4 << 12);  ///< Half Cycle Fault Recovery
    }

    /// FFILT0 Register bits
    namespace ffilt0_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Fault Filter Period
        constexpr uint32_t FILT_CNT = (3 << 8);  ///< Fault Filter Count
        constexpr uint32_t GSTR = (1U << 15);  ///< Fault Glitch Stretch Enable
    }

    /// FTST0 Register bits
    namespace ftst0_bits {
        constexpr uint32_t FTEST = (1U << 0);  ///< Fault Test
    }

    /// FCTRL20 Register bits
    namespace fctrl20_bits {
        constexpr uint32_t NOCOMB = (4 << 0);  ///< No Combinational Path From Fault Input To PWM Output
    }

}

// ============================================================================
// SPDIF Peripheral
// ============================================================================

namespace spdif {
    /// Base addresses
    constexpr uint32_t SPDIF_BASE = 0x401DC000;

    /// SPDIF Register structure
    struct Registers {
        volatile uint32_t SCR;  ///< Offset: 0x00 - SPDIF Configuration Register
        volatile uint32_t SRCD;  ///< Offset: 0x04 - CDText Control Register
        volatile uint32_t SRPC;  ///< Offset: 0x08 - PhaseConfig Register
        volatile uint32_t SIE;  ///< Offset: 0x0C - InterruptEn Register
        volatile uint32_t SIC;  ///< Offset: 0x10 - InterruptClear Register
        volatile uint32_t SIS;  ///< Offset: 0x10 - InterruptStat Register
        volatile uint32_t SRL;  ///< Offset: 0x14 - SPDIFRxLeft Register
        volatile uint32_t SRR;  ///< Offset: 0x18 - SPDIFRxRight Register
        volatile uint32_t SRCSH;  ///< Offset: 0x1C - SPDIFRxCChannel_h Register
        volatile uint32_t SRCSL;  ///< Offset: 0x20 - SPDIFRxCChannel_l Register
        volatile uint32_t SRU;  ///< Offset: 0x24 - UchannelRx Register
        volatile uint32_t SRQ;  ///< Offset: 0x28 - QchannelRx Register
        volatile uint32_t STL;  ///< Offset: 0x2C - SPDIFTxLeft Register
        volatile uint32_t STR;  ///< Offset: 0x30 - SPDIFTxRight Register
        volatile uint32_t STCSCH;  ///< Offset: 0x34 - SPDIFTxCChannelCons_h Register
        volatile uint32_t STCSCL;  ///< Offset: 0x38 - SPDIFTxCChannelCons_l Register
        volatile uint32_t SRFM;  ///< Offset: 0x44 - FreqMeas Register
        volatile uint32_t STC;  ///< Offset: 0x50 - SPDIFTxClk Register
    };

    /// Peripheral instances
    inline Registers* SPDIF = reinterpret_cast<Registers*>(SPDIF_BASE);

    // Bit definitions
    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t USrc_Sel = (2 << 0);  ///< no description available
        constexpr uint32_t TxSel = (3 << 2);  ///< no description available
        constexpr uint32_t ValCtrl = (1U << 5);  ///< no description available
        constexpr uint32_t DMA_TX_En = (1U << 8);  ///< DMA Transmit Request Enable (Tx FIFO empty)
        constexpr uint32_t DMA_Rx_En = (1U << 9);  ///< DMA Receive Request Enable (RX FIFO full)
        constexpr uint32_t TxFIFO_Ctrl = (2 << 10);  ///< no description available
        constexpr uint32_t soft_reset = (1U << 12);  ///< When write 1 to this bit, it will cause SPDIF software reset
        constexpr uint32_t LOW_POWER = (1U << 13);  ///< When write 1 to this bit, it will cause SPDIF enter low-power mode
        constexpr uint32_t TxFIFOEmpty_Sel = (2 << 15);  ///< no description available
        constexpr uint32_t TxAutoSync = (1U << 17);  ///< no description available
        constexpr uint32_t RxAutoSync = (1U << 18);  ///< no description available
        constexpr uint32_t RxFIFOFull_Sel = (2 << 19);  ///< no description available
        constexpr uint32_t RxFIFO_Rst = (1U << 21);  ///< no description available
        constexpr uint32_t RxFIFO_Off_On = (1U << 22);  ///< no description available
        constexpr uint32_t RxFIFO_Ctrl = (1U << 23);  ///< no description available
    }

    /// SRCD Register bits
    namespace srcd_bits {
        constexpr uint32_t USyncMode = (1U << 1);  ///< no description available
    }

    /// SRPC Register bits
    namespace srpc_bits {
        constexpr uint32_t GainSel = (3 << 3);  ///< Gain selection:
        constexpr uint32_t LOCK = (1U << 6);  ///< LOCK bit to show that the internal DPLL is locked, read only
        constexpr uint32_t ClkSrc_Sel = (4 << 7);  ///< Clock source selection, all other settings not shown are reserved:
    }

    /// SIE Register bits
    namespace sie_bits {
        constexpr uint32_t RxFIFOFul = (1U << 0);  ///< SPDIF Rx FIFO full, can't be cleared with reg. IntClear. To clear it, read from Rx FIFO.
        constexpr uint32_t TxEm = (1U << 1);  ///< SPDIF Tx FIFO empty, can't be cleared with reg. IntClear. To clear it, write toTx FIFO.
        constexpr uint32_t LockLoss = (1U << 2);  ///< SPDIF receiver loss of lock
        constexpr uint32_t RxFIFOResyn = (1U << 3);  ///< Rx FIFO resync
        constexpr uint32_t RxFIFOUnOv = (1U << 4);  ///< Rx FIFO underrun/overrun
        constexpr uint32_t UQErr = (1U << 5);  ///< U/Q Channel framing error
        constexpr uint32_t UQSync = (1U << 6);  ///< U/Q Channel sync found
        constexpr uint32_t QRxOv = (1U << 7);  ///< Q Channel receive register overrun
        constexpr uint32_t QRxFul = (1U << 8);  ///< Q Channel receive register full, can't be cleared with reg
        constexpr uint32_t URxOv = (1U << 9);  ///< U Channel receive register overrun
        constexpr uint32_t URxFul = (1U << 10);  ///< U Channel receive register full, can't be cleared with reg
        constexpr uint32_t BitErr = (1U << 14);  ///< SPDIF receiver found parity bit error
        constexpr uint32_t SymErr = (1U << 15);  ///< SPDIF receiver found illegal symbol
        constexpr uint32_t ValNoGood = (1U << 16);  ///< SPDIF validity flag no good
        constexpr uint32_t CNew = (1U << 17);  ///< SPDIF receive change in value of control channel
        constexpr uint32_t TxResyn = (1U << 18);  ///< SPDIF Tx FIFO resync
        constexpr uint32_t TxUnOv = (1U << 19);  ///< SPDIF Tx FIFO under/overrun
        constexpr uint32_t Lock = (1U << 20);  ///< SPDIF receiver's DPLL is locked
    }

    /// SIC Register bits
    namespace sic_bits {
        constexpr uint32_t LockLoss = (1U << 2);  ///< SPDIF receiver loss of lock
        constexpr uint32_t RxFIFOResyn = (1U << 3);  ///< Rx FIFO resync
        constexpr uint32_t RxFIFOUnOv = (1U << 4);  ///< Rx FIFO underrun/overrun
        constexpr uint32_t UQErr = (1U << 5);  ///< U/Q Channel framing error
        constexpr uint32_t UQSync = (1U << 6);  ///< U/Q Channel sync found
        constexpr uint32_t QRxOv = (1U << 7);  ///< Q Channel receive register overrun
        constexpr uint32_t URxOv = (1U << 9);  ///< U Channel receive register overrun
        constexpr uint32_t BitErr = (1U << 14);  ///< SPDIF receiver found parity bit error
        constexpr uint32_t SymErr = (1U << 15);  ///< SPDIF receiver found illegal symbol
        constexpr uint32_t ValNoGood = (1U << 16);  ///< SPDIF validity flag no good
        constexpr uint32_t CNew = (1U << 17);  ///< SPDIF receive change in value of control channel
        constexpr uint32_t TxResyn = (1U << 18);  ///< SPDIF Tx FIFO resync
        constexpr uint32_t TxUnOv = (1U << 19);  ///< SPDIF Tx FIFO under/overrun
        constexpr uint32_t Lock = (1U << 20);  ///< SPDIF receiver's DPLL is locked
    }

    /// SIS Register bits
    namespace sis_bits {
        constexpr uint32_t RxFIFOFul = (1U << 0);  ///< SPDIF Rx FIFO full, can't be cleared with reg. IntClear. To clear it, read from Rx FIFO.
        constexpr uint32_t TxEm = (1U << 1);  ///< SPDIF Tx FIFO empty, can't be cleared with reg. IntClear. To clear it, write toTx FIFO.
        constexpr uint32_t LockLoss = (1U << 2);  ///< SPDIF receiver loss of lock
        constexpr uint32_t RxFIFOResyn = (1U << 3);  ///< Rx FIFO resync
        constexpr uint32_t RxFIFOUnOv = (1U << 4);  ///< Rx FIFO underrun/overrun
        constexpr uint32_t UQErr = (1U << 5);  ///< U/Q Channel framing error
        constexpr uint32_t UQSync = (1U << 6);  ///< U/Q Channel sync found
        constexpr uint32_t QRxOv = (1U << 7);  ///< Q Channel receive register overrun
        constexpr uint32_t QRxFul = (1U << 8);  ///< Q Channel receive register full, can't be cleared with reg
        constexpr uint32_t URxOv = (1U << 9);  ///< U Channel receive register overrun
        constexpr uint32_t URxFul = (1U << 10);  ///< U Channel receive register full, can't be cleared with reg
        constexpr uint32_t BitErr = (1U << 14);  ///< SPDIF receiver found parity bit error
        constexpr uint32_t SymErr = (1U << 15);  ///< SPDIF receiver found illegal symbol
        constexpr uint32_t ValNoGood = (1U << 16);  ///< SPDIF validity flag no good
        constexpr uint32_t CNew = (1U << 17);  ///< SPDIF receive change in value of control channel
        constexpr uint32_t TxResyn = (1U << 18);  ///< SPDIF Tx FIFO resync
        constexpr uint32_t TxUnOv = (1U << 19);  ///< SPDIF Tx FIFO under/overrun
        constexpr uint32_t Lock = (1U << 20);  ///< SPDIF receiver's DPLL is locked
    }

    /// SRL Register bits
    namespace srl_bits {
        constexpr uint32_t RxDataLeft = (24 << 0);  ///< Processor receive SPDIF data left
    }

    /// SRR Register bits
    namespace srr_bits {
        constexpr uint32_t RxDataRight = (24 << 0);  ///< Processor receive SPDIF data right
    }

    /// SRCSH Register bits
    namespace srcsh_bits {
        constexpr uint32_t RxCChannel_h = (24 << 0);  ///< SPDIF receive C channel register, contains first 24 bits of C channel without interpretation
    }

    /// SRCSL Register bits
    namespace srcsl_bits {
        constexpr uint32_t RxCChannel_l = (24 << 0);  ///< SPDIF receive C channel register, contains next 24 bits of C channel without interpretation
    }

    /// SRU Register bits
    namespace sru_bits {
        constexpr uint32_t RxUChannel = (24 << 0);  ///< SPDIF receive U channel register, contains next 3 U channel bytes
    }

    /// SRQ Register bits
    namespace srq_bits {
        constexpr uint32_t RxQChannel = (24 << 0);  ///< SPDIF receive Q channel register, contains next 3 Q channel bytes
    }

    /// STL Register bits
    namespace stl_bits {
        constexpr uint32_t TxDataLeft = (24 << 0);  ///< SPDIF transmit left channel data. It is write-only, and always returns zeros when read
    }

    /// STR Register bits
    namespace str_bits {
        constexpr uint32_t TxDataRight = (24 << 0);  ///< SPDIF transmit right channel data. It is write-only, and always returns zeros when read
    }

    /// STCSCH Register bits
    namespace stcsch_bits {
        constexpr uint32_t TxCChannelCons_h = (24 << 0);  ///< SPDIF transmit Cons
    }

    /// STCSCL Register bits
    namespace stcscl_bits {
        constexpr uint32_t TxCChannelCons_l = (24 << 0);  ///< SPDIF transmit Cons
    }

    /// SRFM Register bits
    namespace srfm_bits {
        constexpr uint32_t FreqMeas = (24 << 0);  ///< Frequency measurement data
    }

    /// STC Register bits
    namespace stc_bits {
        constexpr uint32_t TxClk_DF = (7 << 0);  ///< Divider factor (1-128)
        constexpr uint32_t tx_all_clk_en = (1U << 7);  ///< Spdif transfer clock enable. When data is going to be transfered, this bit should be set to1.
        constexpr uint32_t TxClk_Source = (3 << 8);  ///< no description available
        constexpr uint32_t SYSCLK_DF = (9 << 11);  ///< system clock divider factor, 2~512.
    }

}

// ============================================================================
// SAI1 Peripheral
// ============================================================================

namespace sai1 {
    /// Base addresses
    constexpr uint32_t SAI1_BASE = 0x401E0000;

    /// SAI1 Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t TCSR;  ///< Offset: 0x08 - SAI Transmit Control Register
        volatile uint32_t TCR1;  ///< Offset: 0x0C - SAI Transmit Configuration 1 Register
        volatile uint32_t TCR2;  ///< Offset: 0x10 - SAI Transmit Configuration 2 Register
        volatile uint32_t TCR3;  ///< Offset: 0x14 - SAI Transmit Configuration 3 Register
        volatile uint32_t TCR4;  ///< Offset: 0x18 - SAI Transmit Configuration 4 Register
        volatile uint32_t TCR5;  ///< Offset: 0x1C - SAI Transmit Configuration 5 Register
        volatile uint32_t TDR[%s];  ///< Offset: 0x20 - SAI Transmit Data Register
        volatile uint32_t TFR[%s];  ///< Offset: 0x40 - SAI Transmit FIFO Register
        volatile uint32_t TMR;  ///< Offset: 0x60 - SAI Transmit Mask Register
        volatile uint32_t RCSR;  ///< Offset: 0x88 - SAI Receive Control Register
        volatile uint32_t RCR1;  ///< Offset: 0x8C - SAI Receive Configuration 1 Register
        volatile uint32_t RCR2;  ///< Offset: 0x90 - SAI Receive Configuration 2 Register
        volatile uint32_t RCR3;  ///< Offset: 0x94 - SAI Receive Configuration 3 Register
        volatile uint32_t RCR4;  ///< Offset: 0x98 - SAI Receive Configuration 4 Register
        volatile uint32_t RCR5;  ///< Offset: 0x9C - SAI Receive Configuration 5 Register
        volatile uint32_t RDR[%s];  ///< Offset: 0xA0 - SAI Receive Data Register
        volatile uint32_t RFR[%s];  ///< Offset: 0xC0 - SAI Receive FIFO Register
        volatile uint32_t RMR;  ///< Offset: 0xE0 - SAI Receive Mask Register
    };

    /// Peripheral instances
    inline Registers* SAI1 = reinterpret_cast<Registers*>(SAI1_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t DATALINE = (4 << 0);  ///< Number of Datalines
        constexpr uint32_t FIFO = (4 << 8);  ///< FIFO Size
        constexpr uint32_t FRAME = (4 << 16);  ///< Frame Size
    }

    /// TCSR Register bits
    namespace tcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO Request DMA Enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO Request Interrupt Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO Request Flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t TE = (1U << 31);  ///< Transmitter Enable
    }

    /// TCR1 Register bits
    namespace tcr1_bits {
        constexpr uint32_t TFW = (5 << 0);  ///< Transmit FIFO Watermark
    }

    /// TCR2 Register bits
    namespace tcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// TCR3 Register bits
    namespace tcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word Flag Configuration
        constexpr uint32_t TCE = (2 << 16);  ///< Transmit Channel Enable
        constexpr uint32_t CFR = (2 << 24);  ///< Channel FIFO Reset
    }

    /// TCR4 Register bits
    namespace tcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t ONDEM = (1U << 2);  ///< On Demand Mode
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t CHMOD = (1U << 5);  ///< Channel Mode
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame size
        constexpr uint32_t FPACK = (2 << 24);  ///< FIFO Packing Mode
        constexpr uint32_t FCOMB = (2 << 26);  ///< FIFO Combine Mode
        constexpr uint32_t FCONT = (1U << 28);  ///< FIFO Continue on Error
    }

    /// TCR5 Register bits
    namespace tcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// TDR[%s] Register bits
    namespace tdr[%s]_bits {
        constexpr uint32_t TDR = (32 << 0);  ///< Transmit Data Register
    }

    /// TFR[%s] Register bits
    namespace tfr[%s]_bits {
        constexpr uint32_t RFP = (6 << 0);  ///< Read FIFO Pointer
        constexpr uint32_t WFP = (6 << 16);  ///< Write FIFO Pointer
        constexpr uint32_t WCP = (1U << 31);  ///< Write Channel Pointer
    }

    /// TMR Register bits
    namespace tmr_bits {
        constexpr uint32_t TWM = (32 << 0);  ///< Transmit Word Mask
    }

    /// RCSR Register bits
    namespace rcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO Request DMA Enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO Request Interrupt Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO Request Flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t RE = (1U << 31);  ///< Receiver Enable
    }

    /// RCR1 Register bits
    namespace rcr1_bits {
        constexpr uint32_t RFW = (5 << 0);  ///< Receive FIFO Watermark
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// RCR3 Register bits
    namespace rcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word Flag Configuration
        constexpr uint32_t RCE = (2 << 16);  ///< Receive Channel Enable
        constexpr uint32_t CFR = (2 << 24);  ///< Channel FIFO Reset
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t ONDEM = (1U << 2);  ///< On Demand Mode
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame Size
        constexpr uint32_t FPACK = (2 << 24);  ///< FIFO Packing Mode
        constexpr uint32_t FCOMB = (2 << 26);  ///< FIFO Combine Mode
        constexpr uint32_t FCONT = (1U << 28);  ///< FIFO Continue on Error
    }

    /// RCR5 Register bits
    namespace rcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// RDR[%s] Register bits
    namespace rdr[%s]_bits {
        constexpr uint32_t RDR = (32 << 0);  ///< Receive Data Register
    }

    /// RFR[%s] Register bits
    namespace rfr[%s]_bits {
        constexpr uint32_t RFP = (6 << 0);  ///< Read FIFO Pointer
        constexpr uint32_t RCP = (1U << 15);  ///< Receive Channel Pointer
        constexpr uint32_t WFP = (6 << 16);  ///< Write FIFO Pointer
    }

    /// RMR Register bits
    namespace rmr_bits {
        constexpr uint32_t RWM = (32 << 0);  ///< Receive Word Mask
    }

}

// ============================================================================
// SAI3 Peripheral
// ============================================================================

namespace sai3 {
    /// Base addresses
    constexpr uint32_t SAI3_BASE = 0x401E8000;

    /// SAI3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SAI3 = reinterpret_cast<Registers*>(SAI3_BASE);

}

// ============================================================================
// GPT1 Peripheral
// ============================================================================

namespace gpt1 {
    /// Base addresses
    constexpr uint32_t GPT1_BASE = 0x401EC000;

    /// GPT1 Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - GPT Control Register
        volatile uint32_t PR;  ///< Offset: 0x04 - GPT Prescaler Register
        volatile uint32_t SR;  ///< Offset: 0x08 - GPT Status Register
        volatile uint32_t IR;  ///< Offset: 0x0C - GPT Interrupt Register
        volatile uint32_t OCR1;  ///< Offset: 0x10 - GPT Output Compare Register 1
        volatile uint32_t OCR2;  ///< Offset: 0x14 - GPT Output Compare Register 2
        volatile uint32_t OCR3;  ///< Offset: 0x18 - GPT Output Compare Register 3
        volatile uint32_t ICR1;  ///< Offset: 0x1C - GPT Input Capture Register 1
        volatile uint32_t ICR2;  ///< Offset: 0x20 - GPT Input Capture Register 2
        volatile uint32_t CNT;  ///< Offset: 0x24 - GPT Counter Register
    };

    /// Peripheral instances
    inline Registers* GPT1 = reinterpret_cast<Registers*>(GPT1_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< GPT Enable
        constexpr uint32_t ENMOD = (1U << 1);  ///< GPT Enable mode
        constexpr uint32_t DBGEN = (1U << 2);  ///< GPT debug mode enable
        constexpr uint32_t WAITEN = (1U << 3);  ///< GPT Wait Mode enable
        constexpr uint32_t DOZEEN = (1U << 4);  ///< GPT Doze Mode Enable
        constexpr uint32_t STOPEN = (1U << 5);  ///< GPT Stop Mode enable
        constexpr uint32_t CLKSRC = (3 << 6);  ///< Clock Source select
        constexpr uint32_t FRR = (1U << 9);  ///< Free-Run or Restart mode
        constexpr uint32_t EN_24M = (1U << 10);  ///< Enable 24 MHz clock input from crystal
        constexpr uint32_t SWR = (1U << 15);  ///< Software reset
        constexpr uint32_t IM1 = (2 << 16);  ///< See IM2
        constexpr uint32_t IM2 = (2 << 18);  ///< IM2 (bits 19-18, Input Capture Channel 2 operating mode) IM1 (bits 17-16, Input Capture Channel 1 operating mode) The IMn bit field determines the transition on the input pin (for Input capture channel n), which will trigger a capture event
        constexpr uint32_t OM1 = (3 << 20);  ///< See OM3
        constexpr uint32_t OM2 = (3 << 23);  ///< See OM3
        constexpr uint32_t OM3 = (3 << 26);  ///< OM3 (bits 28-26) controls the Output Compare Channel 3 operating mode
        constexpr uint32_t FO1 = (1U << 29);  ///< See F03
        constexpr uint32_t FO2 = (1U << 30);  ///< See F03
        constexpr uint32_t FO3 = (1U << 31);  ///< FO3 Force Output Compare Channel 3 FO2 Force Output Compare Channel 2 FO1 Force Output Compare Channel 1 The FOn bit causes the pin action programmed for the timer Output Compare n pin (according to the OMn bits in this register)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PRESCALER = (12 << 0);  ///< Prescaler bits
        constexpr uint32_t PRESCALER24M = (4 << 12);  ///< Prescaler bits
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t OF1 = (1U << 0);  ///< See OF3
        constexpr uint32_t OF2 = (1U << 1);  ///< See OF3
        constexpr uint32_t OF3 = (1U << 2);  ///< OF3 Output Compare 3 Flag OF2 Output Compare 2 Flag OF1 Output Compare 1 Flag The OFn bit indicates that a compare event has occurred on Output Compare channel n
        constexpr uint32_t IF1 = (1U << 3);  ///< See IF2
        constexpr uint32_t IF2 = (1U << 4);  ///< IF2 Input capture 2 Flag IF1 Input capture 1 Flag The IFn bit indicates that a capture event has occurred on Input Capture channel n
        constexpr uint32_t ROV = (1U << 5);  ///< Rollover Flag
    }

    /// IR Register bits
    namespace ir_bits {
        constexpr uint32_t OF1IE = (1U << 0);  ///< See OF3IE
        constexpr uint32_t OF2IE = (1U << 1);  ///< See OF3IE
        constexpr uint32_t OF3IE = (1U << 2);  ///< OF3IE Output Compare 3 Interrupt Enable OF2IE Output Compare 2 Interrupt Enable OF1IE Output Compare 1 Interrupt Enable The OFnIE bit controls the Output Compare Channel n interrupt
        constexpr uint32_t IF1IE = (1U << 3);  ///< See IF2IE
        constexpr uint32_t IF2IE = (1U << 4);  ///< IF2IE Input capture 2 Interrupt Enable IF1IE Input capture 1 Interrupt Enable The IFnIE bit controls the IFnIE Input Capture n Interrupt Enable
        constexpr uint32_t ROVIE = (1U << 5);  ///< Rollover Interrupt Enable. The ROVIE bit controls the Rollover interrupt.
    }

    /// OCR1 Register bits
    namespace ocr1_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Compare Value
    }

    /// OCR2 Register bits
    namespace ocr2_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Compare Value
    }

    /// OCR3 Register bits
    namespace ocr3_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Compare Value
    }

    /// ICR1 Register bits
    namespace icr1_bits {
        constexpr uint32_t CAPT = (32 << 0);  ///< Capture Value
    }

    /// ICR2 Register bits
    namespace icr2_bits {
        constexpr uint32_t CAPT = (32 << 0);  ///< Capture Value
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< Counter Value. The COUNT bits show the current count value of the GPT counter.
    }

}

// ============================================================================
// GPT2 Peripheral
// ============================================================================

namespace gpt2 {
    /// Base addresses
    constexpr uint32_t GPT2_BASE = 0x401F0000;

    /// GPT2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT2 = reinterpret_cast<Registers*>(GPT2_BASE);

}

// ============================================================================
// OCOTP Peripheral
// ============================================================================

namespace ocotp {
    /// Base addresses
    constexpr uint32_t OCOTP_BASE = 0x401F4000;

    /// OCOTP Register structure
    struct Registers {
        volatile uint32_t HW_OCOTP_CTRL;  ///< Offset: 0x00 - OTP Controller Control Register
        volatile uint32_t HW_OCOTP_CTRL_SET;  ///< Offset: 0x04 - OTP Controller Control Register
        volatile uint32_t HW_OCOTP_CTRL_CLR;  ///< Offset: 0x08 - OTP Controller Control Register
        volatile uint32_t HW_OCOTP_CTRL_TOG;  ///< Offset: 0x0C - OTP Controller Control Register
        volatile uint32_t HW_OCOTP_TIMING;  ///< Offset: 0x10 - OTP Controller Timing Register
        volatile uint32_t HW_OCOTP_DATA;  ///< Offset: 0x20 - OTP Controller Write Data Register
        volatile uint32_t HW_OCOTP_READ_CTRL;  ///< Offset: 0x30 - OTP Controller Write Data Register
        volatile uint32_t HW_OCOTP_READ_FUSE_DATA;  ///< Offset: 0x40 - OTP Controller Read Data Register
        volatile uint32_t HW_OCOTP_SW_STICKY;  ///< Offset: 0x50 - Sticky bit Register
        volatile uint32_t HW_OCOTP_SCS;  ///< Offset: 0x60 - Software Controllable Signals Register
        volatile uint32_t HW_OCOTP_SCS_SET;  ///< Offset: 0x64 - Software Controllable Signals Register
        volatile uint32_t HW_OCOTP_SCS_CLR;  ///< Offset: 0x68 - Software Controllable Signals Register
        volatile uint32_t HW_OCOTP_SCS_TOG;  ///< Offset: 0x6C - Software Controllable Signals Register
        volatile uint32_t HW_OCOTP_VERSION;  ///< Offset: 0x90 - OTP Controller Version Register
        volatile uint32_t HW_OCOTP_TIMING2;  ///< Offset: 0x100 - OTP Controller Timing Register 2
        volatile uint32_t HW_OCOTP_LOCK;  ///< Offset: 0x400 - Value of OTP Bank0 Word0 (Lock controls)
        volatile uint32_t HW_OCOTP_CFG0;  ///< Offset: 0x410 - Value of OTP Bank0 Word1 (Configuration and Manufacturing Info.)
        volatile uint32_t HW_OCOTP_CFG1;  ///< Offset: 0x420 - Value of OTP Bank0 Word2 (Configuration and Manufacturing Info.)
        volatile uint32_t HW_OCOTP_CFG2;  ///< Offset: 0x430 - Value of OTP Bank0 Word3 (Configuration and Manufacturing Info.)
        volatile uint32_t HW_OCOTP_CFG3;  ///< Offset: 0x440 - Value of OTP Bank0 Word4 (Configuration and Manufacturing Info.)
        volatile uint32_t HW_OCOTP_CFG4;  ///< Offset: 0x450 - Value of OTP Bank0 Word5 (Configuration and Manufacturing Info.)
        volatile uint32_t HW_OCOTP_CFG5;  ///< Offset: 0x460 - Value of OTP Bank0 Word6 (Configuration and Manufacturing Info.)
        volatile uint32_t HW_OCOTP_CFG6;  ///< Offset: 0x470 - Value of OTP Bank0 Word7 (Configuration and Manufacturing Info.)
        volatile uint32_t HW_OCOTP_MEM0;  ///< Offset: 0x480 - Value of OTP Bank1 Word0 (Memory Related Info.)
        volatile uint32_t HW_OCOTP_MEM1;  ///< Offset: 0x490 - Value of OTP Bank1 Word1 (Memory Related Info.)
        volatile uint32_t HW_OCOTP_MEM2;  ///< Offset: 0x4A0 - Value of OTP Bank1 Word2 (Memory Related Info.)
        volatile uint32_t HW_OCOTP_MEM3;  ///< Offset: 0x4B0 - Value of OTP Bank1 Word3 (Memory Related Info.)
        volatile uint32_t HW_OCOTP_MEM4;  ///< Offset: 0x4C0 - Value of OTP Bank1 Word4 (Memory Related Info.)
        volatile uint32_t HW_OCOTP_ANA0;  ///< Offset: 0x4D0 - Value of OTP Bank1 Word5 (Analog Info.)
        volatile uint32_t HW_OCOTP_ANA1;  ///< Offset: 0x4E0 - Value of OTP Bank1 Word6 (Analog Info.)
        volatile uint32_t HW_OCOTP_ANA2;  ///< Offset: 0x4F0 - Value of OTP Bank1 Word7 (Analog Info.)
        volatile uint32_t HW_OCOTP_SRK0;  ///< Offset: 0x580 - Shadow Register for OTP Bank3 Word0 (SRK Hash)
        volatile uint32_t HW_OCOTP_SRK1;  ///< Offset: 0x590 - Shadow Register for OTP Bank3 Word1 (SRK Hash)
        volatile uint32_t HW_OCOTP_SRK2;  ///< Offset: 0x5A0 - Shadow Register for OTP Bank3 Word2 (SRK Hash)
        volatile uint32_t HW_OCOTP_SRK3;  ///< Offset: 0x5B0 - Shadow Register for OTP Bank3 Word3 (SRK Hash)
        volatile uint32_t HW_OCOTP_SRK4;  ///< Offset: 0x5C0 - Shadow Register for OTP Bank3 Word4 (SRK Hash)
        volatile uint32_t HW_OCOTP_SRK5;  ///< Offset: 0x5D0 - Shadow Register for OTP Bank3 Word5 (SRK Hash)
        volatile uint32_t HW_OCOTP_SRK6;  ///< Offset: 0x5E0 - Shadow Register for OTP Bank3 Word6 (SRK Hash)
        volatile uint32_t HW_OCOTP_SRK7;  ///< Offset: 0x5F0 - Shadow Register for OTP Bank3 Word7 (SRK Hash)
        volatile uint32_t HW_OCOTP_SJC_RESP0;  ///< Offset: 0x600 - Value of OTP Bank4 Word0 (Secure JTAG Response Field)
        volatile uint32_t HW_OCOTP_SJC_RESP1;  ///< Offset: 0x610 - Value of OTP Bank4 Word1 (Secure JTAG Response Field)
        volatile uint32_t HW_OCOTP_MAC0;  ///< Offset: 0x620 - Value of OTP Bank4 Word2 (MAC Address)
        volatile uint32_t HW_OCOTP_MAC1;  ///< Offset: 0x630 - Value of OTP Bank4 Word3 (MAC Address)
        volatile uint32_t HW_OCOTP_GP3;  ///< Offset: 0x640 - Value of OTP Bank4 Word4 (MAC Address)
        volatile uint32_t HW_OCOTP_GP1;  ///< Offset: 0x660 - Value of OTP Bank4 Word6 (General Purpose Customer Defined Info)
        volatile uint32_t HW_OCOTP_GP2;  ///< Offset: 0x670 - Value of OTP Bank4 Word7 (General Purpose Customer Defined Info)
        volatile uint32_t HW_OCOTP_SW_GP1;  ///< Offset: 0x680 - Value of OTP Bank5 Word0 (SW GP1)
        volatile uint32_t HW_OCOTP_SW_GP20;  ///< Offset: 0x690 - Value of OTP Bank5 Word1 (SW GP2)
        volatile uint32_t HW_OCOTP_SW_GP21;  ///< Offset: 0x6A0 - Value of OTP Bank5 Word2 (SW GP2)
        volatile uint32_t HW_OCOTP_SW_GP22;  ///< Offset: 0x6B0 - Value of OTP Bank5 Word3 (SW GP2)
        volatile uint32_t HW_OCOTP_SW_GP23;  ///< Offset: 0x6C0 - Value of OTP Bank5 Word4 (SW GP2)
        volatile uint32_t HW_OCOTP_MISC_CONF0;  ///< Offset: 0x6D0 - Value of OTP Bank5 Word5 (Misc Conf)
        volatile uint32_t HW_OCOTP_MISC_CONF1;  ///< Offset: 0x6E0 - Value of OTP Bank5 Word6 (Misc Conf)
        volatile uint32_t HW_OCOTP_SRK_REVOKE;  ///< Offset: 0x6F0 - Value of OTP Bank5 Word7 (SRK Revoke)
    };

    /// Peripheral instances
    inline Registers* OCOTP = reinterpret_cast<Registers*>(OCOTP_BASE);

    // Bit definitions
    /// HW_OCOTP_CTRL Register bits
    namespace hw_ocotp_ctrl_bits {
        constexpr uint32_t ADDR = (6 << 0);  ///< OTP write and read access address register
        constexpr uint32_t BUSY = (1U << 8);  ///< OTP controller status bit
        constexpr uint32_t ERROR = (1U << 9);  ///< Set by the controller when an access to a locked region(OTP or shadow register) is requested
        constexpr uint32_t RELOAD_SHADOWS = (1U << 10);  ///< Set to force re-loading the shadow registers (HW/SW capability and LOCK)
        constexpr uint32_t WR_UNLOCK = (16 << 16);  ///< Write 0x3E77 to enable OTP write accesses
    }

    /// HW_OCOTP_CTRL_SET Register bits
    namespace hw_ocotp_ctrl_set_bits {
        constexpr uint32_t ADDR = (6 << 0);  ///< OTP write and read access address register
        constexpr uint32_t BUSY = (1U << 8);  ///< OTP controller status bit
        constexpr uint32_t ERROR = (1U << 9);  ///< Set by the controller when an access to a locked region(OTP or shadow register) is requested
        constexpr uint32_t RELOAD_SHADOWS = (1U << 10);  ///< Set to force re-loading the shadow registers (HW/SW capability and LOCK)
        constexpr uint32_t WR_UNLOCK = (16 << 16);  ///< Write 0x3E77 to enable OTP write accesses
    }

    /// HW_OCOTP_CTRL_CLR Register bits
    namespace hw_ocotp_ctrl_clr_bits {
        constexpr uint32_t ADDR = (6 << 0);  ///< OTP write and read access address register
        constexpr uint32_t BUSY = (1U << 8);  ///< OTP controller status bit
        constexpr uint32_t ERROR = (1U << 9);  ///< Set by the controller when an access to a locked region(OTP or shadow register) is requested
        constexpr uint32_t RELOAD_SHADOWS = (1U << 10);  ///< Set to force re-loading the shadow registers (HW/SW capability and LOCK)
        constexpr uint32_t WR_UNLOCK = (16 << 16);  ///< Write 0x3E77 to enable OTP write accesses
    }

    /// HW_OCOTP_CTRL_TOG Register bits
    namespace hw_ocotp_ctrl_tog_bits {
        constexpr uint32_t ADDR = (6 << 0);  ///< OTP write and read access address register
        constexpr uint32_t BUSY = (1U << 8);  ///< OTP controller status bit
        constexpr uint32_t ERROR = (1U << 9);  ///< Set by the controller when an access to a locked region(OTP or shadow register) is requested
        constexpr uint32_t RELOAD_SHADOWS = (1U << 10);  ///< Set to force re-loading the shadow registers (HW/SW capability and LOCK)
        constexpr uint32_t WR_UNLOCK = (16 << 16);  ///< Write 0x3E77 to enable OTP write accesses
    }

    /// HW_OCOTP_TIMING Register bits
    namespace hw_ocotp_timing_bits {
        constexpr uint32_t STROBE_PROG = (12 << 0);  ///< This count value specifies the strobe period in one time write OTP
        constexpr uint32_t RELAX = (4 << 12);  ///< This count value specifies the time to add to all default timing parameters other than the Tpgm and Trd
        constexpr uint32_t STROBE_READ = (6 << 16);  ///< This count value specifies the strobe period in one time read OTP
        constexpr uint32_t WAIT = (6 << 22);  ///< This count value specifies time interval between auto read and write access in one time program
    }

    /// HW_OCOTP_DATA Register bits
    namespace hw_ocotp_data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Used to initiate a write to OTP
    }

    /// HW_OCOTP_READ_CTRL Register bits
    namespace hw_ocotp_read_ctrl_bits {
        constexpr uint32_t READ_FUSE = (1U << 0);  ///< Used to initiate a read to OTP
    }

    /// HW_OCOTP_READ_FUSE_DATA Register bits
    namespace hw_ocotp_read_fuse_data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< The data read from OTP
    }

    /// HW_OCOTP_SW_STICKY Register bits
    namespace hw_ocotp_sw_sticky_bits {
        constexpr uint32_t SRK_REVOKE_LOCK = (1U << 1);  ///< Shadow register write and OTP write lock for SRK_REVOKE region
        constexpr uint32_t FIELD_RETURN_LOCK = (1U << 2);  ///< Shadow register write and OTP write lock for FIELD_RETURN region
    }

    /// HW_OCOTP_SCS Register bits
    namespace hw_ocotp_scs_bits {
        constexpr uint32_t HAB_JDE = (1U << 0);  ///< HAB JTAG Debug Enable
        constexpr uint32_t SPARE = (30 << 1);  ///< Unallocated read/write bits for implementation specific software use.
        constexpr uint32_t LOCK = (1U << 31);  ///< When set, all of the bits in this register are locked and can not be changed through SW programming
    }

    /// HW_OCOTP_SCS_SET Register bits
    namespace hw_ocotp_scs_set_bits {
        constexpr uint32_t HAB_JDE = (1U << 0);  ///< HAB JTAG Debug Enable
        constexpr uint32_t SPARE = (30 << 1);  ///< Unallocated read/write bits for implementation specific software use.
        constexpr uint32_t LOCK = (1U << 31);  ///< When set, all of the bits in this register are locked and can not be changed through SW programming
    }

    /// HW_OCOTP_SCS_CLR Register bits
    namespace hw_ocotp_scs_clr_bits {
        constexpr uint32_t HAB_JDE = (1U << 0);  ///< HAB JTAG Debug Enable
        constexpr uint32_t SPARE = (30 << 1);  ///< Unallocated read/write bits for implementation specific software use.
        constexpr uint32_t LOCK = (1U << 31);  ///< When set, all of the bits in this register are locked and can not be changed through SW programming
    }

    /// HW_OCOTP_SCS_TOG Register bits
    namespace hw_ocotp_scs_tog_bits {
        constexpr uint32_t HAB_JDE = (1U << 0);  ///< HAB JTAG Debug Enable
        constexpr uint32_t SPARE = (30 << 1);  ///< Unallocated read/write bits for implementation specific software use.
        constexpr uint32_t LOCK = (1U << 31);  ///< When set, all of the bits in this register are locked and can not be changed through SW programming
    }

    /// HW_OCOTP_VERSION Register bits
    namespace hw_ocotp_version_bits {
        constexpr uint32_t STEP = (16 << 0);  ///< Fixed read-only value reflecting the stepping of the RTL version.
        constexpr uint32_t MINOR = (8 << 16);  ///< Fixed read-only value reflecting the MINOR field of the RTL version.
        constexpr uint32_t MAJOR = (8 << 24);  ///< Fixed read-only value reflecting the MAJOR field of the RTL version.
    }

    /// HW_OCOTP_TIMING2 Register bits
    namespace hw_ocotp_timing2_bits {
        constexpr uint32_t RELAX_PROG = (12 << 0);  ///< This count value specifies the strobe period in one time write OTP
        constexpr uint32_t RELAX_READ = (6 << 16);  ///< This count value specifies the strobe period in one time read OTP
        constexpr uint32_t RELAX1 = (8 << 22);  ///< This count value specifies time interval between auto read and write access in one time program
    }

    /// HW_OCOTP_LOCK Register bits
    namespace hw_ocotp_lock_bits {
        constexpr uint32_t TESTER = (2 << 0);  ///< Status of shadow register and OTP write lock for tester region
        constexpr uint32_t BOOT_CFG = (2 << 2);  ///< Status of shadow register and OTP write lock for boot_cfg region
        constexpr uint32_t MEM_TRIM = (2 << 4);  ///< Status of shadow register and OTP write lock for mem_trim region
        constexpr uint32_t SJC_RESP = (1U << 6);  ///< Status of shadow register read and write, OTP read and write lock for sjc_resp region
        constexpr uint32_t MAC_ADDR = (2 << 8);  ///< Status of shadow register and OTP write lock for mac_addr region
        constexpr uint32_t GP1 = (2 << 10);  ///< Status of shadow register and OTP write lock for gp1 region
        constexpr uint32_t GP2 = (2 << 12);  ///< Status of shadow register and OTP write lock for gp2 region
        constexpr uint32_t OTPMK_MSB = (1U << 15);  ///< Status of shadow register read and write, OTP read and write lock for otpmk region (MSB)
        constexpr uint32_t SW_GP1 = (1U << 16);  ///< Status of shadow register and OTP write lock for sw_gp1 region
        constexpr uint32_t OTPMK_LSB = (1U << 17);  ///< Status of shadow register read and write, OTP read and write lock for otpmk region (LSB)
        constexpr uint32_t ANALOG = (2 << 18);  ///< Status of shadow register and OTP write lock for analog region
        constexpr uint32_t OTPMK_CRC = (1U << 20);  ///< Status of shadow register and OTP write lock for otpmk_crc region
        constexpr uint32_t SW_GP2_LOCK = (1U << 21);  ///< Status of shadow register and OTP write lock for sw_gp2 region
        constexpr uint32_t MISC_CONF = (1U << 22);  ///< Status of shadow register and OTP write lock for misc_conf region
        constexpr uint32_t SW_GP2_RLOCK = (1U << 23);  ///< Status of shadow register and OTP read lock for sw_gp2 region
        constexpr uint32_t GP3 = (2 << 26);  ///< Status of shadow register and OTP write lock for gp3 region
        constexpr uint32_t FIELD_RETURN = (4 << 28);  ///< Reserved
    }

    /// HW_OCOTP_CFG0 Register bits
    namespace hw_ocotp_cfg0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< This register contains 32 bits of the Unique ID and SJC_CHALLENGE field
    }

    /// HW_OCOTP_CFG1 Register bits
    namespace hw_ocotp_cfg1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< This register contains 32 bits of the Unique ID and SJC_CHALLENGE field
    }

    /// HW_OCOTP_CFG2 Register bits
    namespace hw_ocotp_cfg2_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 0, word 3 (ADDR = 0x03)
    }

    /// HW_OCOTP_CFG3 Register bits
    namespace hw_ocotp_cfg3_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 0, word 4 (ADDR = 0x04)
    }

    /// HW_OCOTP_CFG4 Register bits
    namespace hw_ocotp_cfg4_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 0, word 5 (ADDR = 0x05)
    }

    /// HW_OCOTP_CFG5 Register bits
    namespace hw_ocotp_cfg5_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 0, word 6 (ADDR = 0x06)
    }

    /// HW_OCOTP_CFG6 Register bits
    namespace hw_ocotp_cfg6_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 0, word 7 (ADDR = 0x07)
    }

    /// HW_OCOTP_MEM0 Register bits
    namespace hw_ocotp_mem0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP bank 1, word 0 (ADDR = 0x08)
    }

    /// HW_OCOTP_MEM1 Register bits
    namespace hw_ocotp_mem1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP bank 1, word 1 (ADDR = 0x09)
    }

    /// HW_OCOTP_MEM2 Register bits
    namespace hw_ocotp_mem2_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP bank 1, word 2 (ADDR = 0x0A)
    }

    /// HW_OCOTP_MEM3 Register bits
    namespace hw_ocotp_mem3_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP bank 1, word 3 (ADDR = 0x0B)
    }

    /// HW_OCOTP_MEM4 Register bits
    namespace hw_ocotp_mem4_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP bank 1, word 4 (ADDR = 0x0C)
    }

    /// HW_OCOTP_ANA0 Register bits
    namespace hw_ocotp_ana0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP bank 1, word 5 (ADDR = 0x0D)
    }

    /// HW_OCOTP_ANA1 Register bits
    namespace hw_ocotp_ana1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP bank 1, word 6 (ADDR = 0x0E)
    }

    /// HW_OCOTP_ANA2 Register bits
    namespace hw_ocotp_ana2_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP bank 1, word 7 (ADDR = 0x0F)
    }

    /// HW_OCOTP_SRK0 Register bits
    namespace hw_ocotp_srk0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Shadow register for the hash of the Super Root Key word0 (Copy of OTP Bank 3, word 0 (ADDR = 0x1C))
    }

    /// HW_OCOTP_SRK1 Register bits
    namespace hw_ocotp_srk1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Shadow register for the hash of the Super Root Key word1 (Copy of OTP Bank 3, word 1 (ADDR = 0x1D))
    }

    /// HW_OCOTP_SRK2 Register bits
    namespace hw_ocotp_srk2_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Shadow register for the hash of the Super Root Key word2 (Copy of OTP Bank 3, word 2 (ADDR = 0x1E))
    }

    /// HW_OCOTP_SRK3 Register bits
    namespace hw_ocotp_srk3_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Shadow register for the hash of the Super Root Key word3 (Copy of OTP Bank 3, word 3 (ADDR = 0x1F))
    }

    /// HW_OCOTP_SRK4 Register bits
    namespace hw_ocotp_srk4_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Shadow register for the hash of the Super Root Key word4 (Copy of OTP Bank 3, word 4 (ADDR = 0x20))
    }

    /// HW_OCOTP_SRK5 Register bits
    namespace hw_ocotp_srk5_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Shadow register for the hash of the Super Root Key word5 (Copy of OTP Bank 3, word 5 (ADDR = 0x21))
    }

    /// HW_OCOTP_SRK6 Register bits
    namespace hw_ocotp_srk6_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Shadow register for the hash of the Super Root Key word6 (Copy of OTP Bank 3, word 6 (ADDR = 0x22))
    }

    /// HW_OCOTP_SRK7 Register bits
    namespace hw_ocotp_srk7_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Shadow register for the hash of the Super Root Key word7 (Copy of OTP Bank 3, word 7 (ADDR = 0x23))
    }

    /// HW_OCOTP_SJC_RESP0 Register bits
    namespace hw_ocotp_sjc_resp0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Shadow register for the SJC_RESP Key word0 (Copy of OTP Bank 4, word 0 (ADDR = 0x20))
    }

    /// HW_OCOTP_SJC_RESP1 Register bits
    namespace hw_ocotp_sjc_resp1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Shadow register for the SJC_RESP Key word1 (Copy of OTP Bank 4, word 1 (ADDR = 0x21))
    }

    /// HW_OCOTP_MAC0 Register bits
    namespace hw_ocotp_mac0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 4, word 2 (ADDR = 0x22).
    }

    /// HW_OCOTP_MAC1 Register bits
    namespace hw_ocotp_mac1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 4, word 3 (ADDR = 0x23).
    }

    /// HW_OCOTP_GP3 Register bits
    namespace hw_ocotp_gp3_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 4, word 4 (ADDR = 0x24).
    }

    /// HW_OCOTP_GP1 Register bits
    namespace hw_ocotp_gp1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 4, word 6 (ADDR = 0x26).
    }

    /// HW_OCOTP_GP2 Register bits
    namespace hw_ocotp_gp2_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 4, word 7 (ADDR = 0x27).
    }

    /// HW_OCOTP_SW_GP1 Register bits
    namespace hw_ocotp_sw_gp1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 5, word 0 (ADDR = 0x28).
    }

    /// HW_OCOTP_SW_GP20 Register bits
    namespace hw_ocotp_sw_gp20_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 5, word 1 (ADDR = 0x29).
    }

    /// HW_OCOTP_SW_GP21 Register bits
    namespace hw_ocotp_sw_gp21_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 5, word 2 (ADDR = 0x2a).
    }

    /// HW_OCOTP_SW_GP22 Register bits
    namespace hw_ocotp_sw_gp22_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 5, word 3 (ADDR = 0x2b).
    }

    /// HW_OCOTP_SW_GP23 Register bits
    namespace hw_ocotp_sw_gp23_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 5, word 4 (ADDR = 0x2c).
    }

    /// HW_OCOTP_MISC_CONF0 Register bits
    namespace hw_ocotp_misc_conf0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 5, word 5 (ADDR = 0x2d).
    }

    /// HW_OCOTP_MISC_CONF1 Register bits
    namespace hw_ocotp_misc_conf1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 5, word 6 (ADDR = 0x2e).
    }

    /// HW_OCOTP_SRK_REVOKE Register bits
    namespace hw_ocotp_srk_revoke_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< Reflects value of OTP Bank 5, word 7 (ADDR = 0x2f).
    }

}

// ============================================================================
// KPP Peripheral
// ============================================================================

namespace kpp {
    /// Base addresses
    constexpr uint32_t KPP_BASE = 0x401FC000;

    /// KPP Register structure
    struct Registers {
        volatile uint32_t KPCR;  ///< Offset: 0x00 - Keypad Control Register
        volatile uint32_t KPSR;  ///< Offset: 0x02 - Keypad Status Register
        volatile uint32_t KDDR;  ///< Offset: 0x04 - Keypad Data Direction Register
        volatile uint32_t KPDR;  ///< Offset: 0x06 - Keypad Data Register
    };

    /// Peripheral instances
    inline Registers* KPP = reinterpret_cast<Registers*>(KPP_BASE);

    // Bit definitions
    /// KPCR Register bits
    namespace kpcr_bits {
        constexpr uint32_t KRE = (8 << 0);  ///< Keypad Row Enable
        constexpr uint32_t KCO = (8 << 8);  ///< Keypad Column Strobe Open-Drain Enable
    }

    /// KPSR Register bits
    namespace kpsr_bits {
        constexpr uint32_t KPKD = (1U << 0);  ///< Keypad Key Depress
        constexpr uint32_t KPKR = (1U << 1);  ///< Keypad Key Release
        constexpr uint32_t KDSC = (1U << 2);  ///< Key Depress Synchronizer Clear
        constexpr uint32_t KRSS = (1U << 3);  ///< Key Release Synchronizer Set
        constexpr uint32_t KDIE = (1U << 8);  ///< Keypad Key Depress Interrupt Enable
        constexpr uint32_t KRIE = (1U << 9);  ///< Keypad Release Interrupt Enable
    }

    /// KDDR Register bits
    namespace kddr_bits {
        constexpr uint32_t KRDD = (8 << 0);  ///< Keypad Row Data Direction
        constexpr uint32_t KCDD = (8 << 8);  ///< Keypad Column Data Direction Register
    }

    /// KPDR Register bits
    namespace kpdr_bits {
        constexpr uint32_t KRD = (8 << 0);  ///< Keypad Row Data
        constexpr uint32_t KCD = (8 << 8);  ///< Keypad Column Data
    }

}

// ============================================================================
// SystemControl Peripheral
// ============================================================================

namespace systemcontrol {
    /// Base addresses
    constexpr uint32_t SystemControl_BASE = 0xE000E000;

    /// SystemControl Register structure
    struct Registers {
        volatile uint32_t ACTLR;  ///< Offset: 0x08 - Auxiliary Control Register,
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control and State Register
        volatile uint32_t VTOR;  ///< Offset: 0xD08 - Vector Table Offset Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt and Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration and Control Register
        volatile uint32_t SHPR1;  ///< Offset: 0xD18 - System Handler Priority Register 1
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
        volatile uint32_t CFSR;  ///< Offset: 0xD28 - Configurable Fault Status Register
        volatile uint32_t HFSR;  ///< Offset: 0xD2C - HardFault Status register
        volatile uint32_t DFSR;  ///< Offset: 0xD30 - Debug Fault Status Register
        volatile uint32_t MMFAR;  ///< Offset: 0xD34 - MemManage Fault Address Register
        volatile uint32_t BFAR;  ///< Offset: 0xD38 - BusFault Address Register
        volatile uint32_t ID_PFR0;  ///< Offset: 0xD40 - Processor Feature Register 0
        volatile uint32_t ID_PFR1;  ///< Offset: 0xD44 - Processor Feature Register 1
        volatile uint32_t ID_DFR0;  ///< Offset: 0xD48 - Debug Feature Register
        volatile uint32_t ID_AFR0;  ///< Offset: 0xD4C - Auxiliary Feature Register
        volatile uint32_t ID_MMFR0;  ///< Offset: 0xD50 - Memory Model Feature Register 0
        volatile uint32_t ID_MMFR1;  ///< Offset: 0xD54 - Memory Model Feature Register 1
        volatile uint32_t ID_MMFR2;  ///< Offset: 0xD58 - Memory Model Feature Register 2
        volatile uint32_t ID_MMFR3;  ///< Offset: 0xD5C - Memory Model Feature Register 3
        volatile uint32_t ID_ISAR0;  ///< Offset: 0xD60 - Instruction Set Attributes Register 0
        volatile uint32_t ID_ISAR1;  ///< Offset: 0xD64 - Instruction Set Attributes Register 1
        volatile uint32_t ID_ISAR2;  ///< Offset: 0xD68 - Instruction Set Attributes Register 2
        volatile uint32_t ID_ISAR3;  ///< Offset: 0xD6C - Instruction Set Attributes Register 3
        volatile uint32_t ID_ISAR4;  ///< Offset: 0xD70 - Instruction Set Attributes Register 4
        volatile uint32_t CLIDR;  ///< Offset: 0xD78 - Cache Level ID register
        volatile uint32_t CTR;  ///< Offset: 0xD7C - Cache Type register
        volatile uint32_t CCSIDR;  ///< Offset: 0xD80 - Cache Size ID Register
        volatile uint32_t CSSELR;  ///< Offset: 0xD84 - Cache Size Selection Register
        volatile uint32_t CPACR;  ///< Offset: 0xD88 - Coprocessor Access Control Register
        volatile uint32_t STIR;  ///< Offset: 0xF00 - Instruction cache invalidate all to Point of Unification (PoU)
        volatile uint32_t ICIALLU;  ///< Offset: 0xF50 - Instruction cache invalidate all to Point of Unification (PoU)
        volatile uint32_t ICIMVAU;  ///< Offset: 0xF58 - Instruction cache invalidate by address to PoU
        volatile uint32_t DCIMVAC;  ///< Offset: 0xF5C - Data cache invalidate by address to Point of Coherency (PoC)
        volatile uint32_t DCISW;  ///< Offset: 0xF60 - Data cache invalidate by set/way
        volatile uint32_t DCCMVAU;  ///< Offset: 0xF64 - Data cache by address to PoU
        volatile uint32_t DCCMVAC;  ///< Offset: 0xF68 - Data cache clean by address to PoC
        volatile uint32_t DCCSW;  ///< Offset: 0xF6C - Data cache clean by set/way
        volatile uint32_t DCCIMVAC;  ///< Offset: 0xF70 - Data cache clean and invalidate by address to PoC
        volatile uint32_t DCCISW;  ///< Offset: 0xF74 - Data cache clean and invalidate by set/way
        volatile uint32_t CM7_ITCMCR;  ///< Offset: 0xF90 - Instruction Tightly-Coupled Memory Control Register
        volatile uint32_t CM7_DTCMCR;  ///< Offset: 0xF94 - Data Tightly-Coupled Memory Control Register
        volatile uint32_t CM7_AHBPCR;  ///< Offset: 0xF98 - AHBP Control Register
        volatile uint32_t CM7_CACR;  ///< Offset: 0xF9C - L1 Cache Control Register
        volatile uint32_t CM7_AHBSCR;  ///< Offset: 0xFA0 - AHB Slave Control Register
        volatile uint32_t CM7_ABFSR;  ///< Offset: 0xFA8 - Auxiliary Bus Fault Status Register
    };

    /// Peripheral instances
    inline Registers* SystemControl = reinterpret_cast<Registers*>(SystemControl_BASE);

    // Bit definitions
    /// ACTLR Register bits
    namespace actlr_bits {
        constexpr uint32_t DISFOLD = (1U << 2);  ///< Disables folding of IT instructions.
        constexpr uint32_t FPEXCODIS = (1U << 10);  ///< Disables FPU exception outputs.
        constexpr uint32_t DISRAMODE = (1U << 11);  ///< Disables dynamic read allocate mode for Write-Back Write-Allocate memory regions.
        constexpr uint32_t DISITMATBFLUSH = (1U << 12);  ///< Disables ITM and DWT ATB flush.
        constexpr uint32_t DISBTACREAD = (1U << 13);  ///< Disables BTAC read.
        constexpr uint32_t DISBTACALLOC = (1U << 14);  ///< Disables BTAC allocate.
        constexpr uint32_t DISCRITAXIRUR = (1U << 15);  ///< Disables critical AXI Read-Under-Read.
        constexpr uint32_t DISDI = (5 << 16);  ///< Disables dual-issued.
        constexpr uint32_t DISISSCH1 = (5 << 21);  ///< Disables dual-issued.
        constexpr uint32_t DISDYNADD = (1U << 26);  ///< Disables dynamic allocation of ADD and SUB instructions
        constexpr uint32_t DISCRITAXIRUW = (1U << 27);  ///< Disables critical AXI read-under-write
        constexpr uint32_t DISFPUISSOPT = (1U << 28);  ///< Disables critical AXI read-under-write
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t REVISION = (4 << 0);  ///< Indicates patch release: 0x0 = Patch 0
        constexpr uint32_t PARTNO = (12 << 4);  ///< Indicates part number
        constexpr uint32_t ARCHITECTURE = (4 << 16);  ///< ARCHITECTURE
        constexpr uint32_t VARIANT = (4 << 20);  ///< Indicates processor revision: 0x2 = Revision 2
        constexpr uint32_t IMPLEMENTER = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active exception number
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< Indicates whether there are preempted active exceptions
        constexpr uint32_t VECTPENDING = (9 << 12);  ///< Exception number of the highest priority pending enabled exception
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag, excluding NMI and Faults
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick exception clear-pending bit
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick exception set-pending bit
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV clear-pending bit
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV set-pending bit
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI set-pending bit
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (25 << 7);  ///< Vector table base offset
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTRESET = (1U << 0);  ///< Writing 1 to this bit causes a local system reset
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< Writing 1 to this bit clears all active state information for fixed and configurable exceptions.
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< System reset request
        constexpr uint32_t PRIGROUP = (3 << 8);  ///< Interrupt priority grouping field. This field determines the split of group priority from subpriority.
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< Data endianness
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< Indicates sleep-on-exit when returning from Handler mode to Thread mode
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< Controls whether the processor uses sleep or deep sleep as its low power mode
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< Send Event on Pending bit
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< Indicates how the processor enters Thread mode
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< Enables unprivileged software access to the STIR
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Enables unaligned access traps
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions.
        constexpr uint32_t STKALIGN = (1U << 9);  ///< Indicates stack alignment on exception entry
        constexpr uint32_t DC = (1U << 16);  ///< Enables L1 data cache.
        constexpr uint32_t IC = (1U << 17);  ///< Enables L1 instruction cache.
        constexpr uint32_t BP = (1U << 18);  ///< Always reads-as-one. It indicates branch prediction is enabled.
    }

    /// SHPR1 Register bits
    namespace shpr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of system handler 4, MemManage
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of system handler 5, BusFault
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of system handler 6, UsageFault
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11, SVCall
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14, PendSV
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15, SysTick exception
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t MEMFAULTACT = (1U << 0);  ///< MemManage exception active bit
        constexpr uint32_t BUSFAULTACT = (1U << 1);  ///< BusFault exception active bit
        constexpr uint32_t USGFAULTACT = (1U << 3);  ///< UsageFault exception active bit
        constexpr uint32_t SVCALLACT = (1U << 7);  ///< SVCall active bit
        constexpr uint32_t MONITORACT = (1U << 8);  ///< Debug monitor active bit
        constexpr uint32_t PENDSVACT = (1U << 10);  ///< PendSV exception active bit
        constexpr uint32_t SYSTICKACT = (1U << 11);  ///< SysTick exception active bit
        constexpr uint32_t USGFAULTPENDED = (1U << 12);  ///< UsageFault exception pending bit
        constexpr uint32_t MEMFAULTPENDED = (1U << 13);  ///< MemManage exception pending bit
        constexpr uint32_t BUSFAULTPENDED = (1U << 14);  ///< BusFault exception pending bit
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVCall pending bit
        constexpr uint32_t MEMFAULTENA = (1U << 16);  ///< MemManage enable bit
        constexpr uint32_t BUSFAULTENA = (1U << 17);  ///< BusFault enable bit
        constexpr uint32_t USGFAULTENA = (1U << 18);  ///< UsageFault enable bit
    }

    /// CFSR Register bits
    namespace cfsr_bits {
        constexpr uint32_t IACCVIOL = (1U << 0);  ///< Instruction access violation flag
        constexpr uint32_t DACCVIOL = (1U << 1);  ///< Data access violation flag
        constexpr uint32_t MUNSTKERR = (1U << 3);  ///< MemManage fault on unstacking for a return from exception
        constexpr uint32_t MSTKERR = (1U << 4);  ///< MemManage fault on stacking for exception entry
        constexpr uint32_t MLSPERR = (1U << 5);  ///< MemManage fault occurred during floating-point lazy state preservation
        constexpr uint32_t MMARVALID = (1U << 7);  ///< MemManage Fault Address Register (MMFAR) valid flag
        constexpr uint32_t IBUSERR = (1U << 8);  ///< Instruction bus error
        constexpr uint32_t PRECISERR = (1U << 9);  ///< Precise data bus error
        constexpr uint32_t IMPRECISERR = (1U << 10);  ///< Imprecise data bus error
        constexpr uint32_t UNSTKERR = (1U << 11);  ///< BusFault on unstacking for a return from exception
        constexpr uint32_t STKERR = (1U << 12);  ///< BusFault on stacking for exception entry
        constexpr uint32_t LSPERR = (1U << 13);  ///< Bus fault occurred during floating-point lazy state preservation
        constexpr uint32_t BFARVALID = (1U << 15);  ///< BusFault Address Register (BFAR) valid flag
        constexpr uint32_t UNDEFINSTR = (1U << 16);  ///< Undefined instruction UsageFault
        constexpr uint32_t INVSTATE = (1U << 17);  ///< Invalid state UsageFault
        constexpr uint32_t INVPC = (1U << 18);  ///< Invalid PC load UsageFault, caused by an invalid PC load by EXC_RETURN
        constexpr uint32_t NOCP = (1U << 19);  ///< No coprocessor UsageFault
        constexpr uint32_t UNALIGNED = (1U << 24);  ///< Unaligned access UsageFault
        constexpr uint32_t DIVBYZERO = (1U << 25);  ///< Divide by zero UsageFault
    }

    /// HFSR Register bits
    namespace hfsr_bits {
        constexpr uint32_t VECTTBL = (1U << 1);  ///< Indicates a BusFault on a vector table read during exception processing.
        constexpr uint32_t FORCED = (1U << 30);  ///< Indicates a forced hard fault, generated by escalation of a fault with configurable priority that cannot be handles, either because of priority or because it is disabled.
        constexpr uint32_t DEBUGEVT = (1U << 31);  ///< Reserved for Debug use. When writing to the register you must write 0 to this bit, otherwise behavior is Unpredictable.
    }

    /// DFSR Register bits
    namespace dfsr_bits {
        constexpr uint32_t HALTED = (1U << 0);  ///< Indicates a debug event generated by either a C_HALT or C_STEP request, triggered by a write to the DHCSR or a step request triggered by setting DEMCR.MON_STEP to 1.
        constexpr uint32_t BKPT = (1U << 1);  ///< Debug event generated by BKPT instruction execution or a breakpoint match in FPB
        constexpr uint32_t DWTTRAP = (1U << 2);  ///< Debug event generated by the DWT
        constexpr uint32_t VCATCH = (1U << 3);  ///< Indicates triggering of a Vector catch
        constexpr uint32_t EXTERNAL = (1U << 4);  ///< Debug event generated because of the assertion of an external debug request
    }

    /// MMFAR Register bits
    namespace mmfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address of MemManage fault location
    }

    /// BFAR Register bits
    namespace bfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address of the BusFault location
    }

    /// ID_PFR0 Register bits
    namespace id_pfr0_bits {
        constexpr uint32_t STATE0 = (4 << 0);  ///< ARM instruction set support
        constexpr uint32_t STATE1 = (4 << 4);  ///< Thumb instruction set support
        constexpr uint32_t STATE2 = (4 << 8);  ///< ARMv7-M unused
        constexpr uint32_t STATE3 = (4 << 12);  ///< ARMv7-M unused
    }

    /// ID_PFR1 Register bits
    namespace id_pfr1_bits {
        constexpr uint32_t PROGMODEL = (4 << 8);  ///< M profile programmers' model
    }

    /// ID_DFR0 Register bits
    namespace id_dfr0_bits {
        constexpr uint32_t DEBUGMODEL = (4 << 20);  ///< Support for memory-mapped debug model for M profile processors
    }

    /// ID_AFR0 Register bits
    namespace id_afr0_bits {
        constexpr uint32_t IMPLEMENTATION_DEFINED0 = (4 << 0);  ///< Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
        constexpr uint32_t IMPLEMENTATION_DEFINED1 = (4 << 4);  ///< Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
        constexpr uint32_t IMPLEMENTATION_DEFINED2 = (4 << 8);  ///< Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
        constexpr uint32_t IMPLEMENTATION_DEFINED3 = (4 << 12);  ///< Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
    }

    /// ID_MMFR0 Register bits
    namespace id_mmfr0_bits {
        constexpr uint32_t PMSASUPPORT = (4 << 4);  ///< Indicates support for a PMSA
        constexpr uint32_t OUTERMOST_SHAREABILITY = (4 << 8);  ///< Indicates the outermost shareability domain implemented
        constexpr uint32_t SHAREABILITY_LEVELS = (4 << 12);  ///< Indicates the number of shareability levels implemented
        constexpr uint32_t TCM_SUPPORT = (4 << 16);  ///< Indicates the support for Tightly Coupled Memory
        constexpr uint32_t AUXILIARY_REGISTERS = (4 << 20);  ///< Indicates the support for Auxiliary registers
    }

    /// ID_MMFR1 Register bits
    namespace id_mmfr1_bits {
        constexpr uint32_t ID_MMFR1 = (32 << 0);  ///< Gives information about the implemented memory model and memory management support.
    }

    /// ID_MMFR2 Register bits
    namespace id_mmfr2_bits {
        constexpr uint32_t WFI_STALL = (4 << 24);  ///< Indicates the support for Wait For Interrupt (WFI) stalling
    }

    /// ID_MMFR3 Register bits
    namespace id_mmfr3_bits {
        constexpr uint32_t ID_MMFR3 = (32 << 0);  ///< Gives information about the implemented memory model and memory management support.
    }

    /// ID_ISAR0 Register bits
    namespace id_isar0_bits {
        constexpr uint32_t BITCOUNT_INSTRS = (4 << 4);  ///< Indicates the supported Bit Counting instructions
        constexpr uint32_t BITFIELD_INSTRS = (4 << 8);  ///< Indicates the supported BitField instructions
        constexpr uint32_t CMPBRANCH_INSTRS = (4 << 12);  ///< Indicates the supported combined Compare and Branch instructions
        constexpr uint32_t COPROC_INSTRS = (4 << 16);  ///< Indicates the supported Coprocessor instructions
        constexpr uint32_t DEBUG_INSTRS = (4 << 20);  ///< Indicates the supported Debug instructions
        constexpr uint32_t DIVIDE_INSTRS = (4 << 24);  ///< Indicates the supported Divide instructions
    }

    /// ID_ISAR1 Register bits
    namespace id_isar1_bits {
        constexpr uint32_t EXTEND_INSTRS = (4 << 12);  ///< Indicates the supported Extend instructions
        constexpr uint32_t IFTHEN_INSTRS = (4 << 16);  ///< Indicates the supported IfThen instructions
        constexpr uint32_t IMMEDIATE_INSTRS = (4 << 20);  ///< Indicates the support for data-processing instructions with long immediate
        constexpr uint32_t INTERWORK_INSTRS = (4 << 24);  ///< Indicates the supported Interworking instructions
    }

    /// ID_ISAR2 Register bits
    namespace id_isar2_bits {
        constexpr uint32_t LOADSTORE_INSTRS = (4 << 0);  ///< Indicates the supported additional load and store instructions
        constexpr uint32_t MEMHINT_INSTRS = (4 << 4);  ///< Indicates the supported Memory Hint instructions
        constexpr uint32_t MULTIACCESSINT_INSTRS = (4 << 8);  ///< Indicates the support for multi-access interruptible instructions
        constexpr uint32_t MULT_INSTRS = (4 << 12);  ///< Indicates the supported additional Multiply instructions
        constexpr uint32_t MULTS_INSTRS = (4 << 16);  ///< Indicates the supported advanced signed Multiply instructions
        constexpr uint32_t MULTU_INSTRS = (4 << 20);  ///< Indicates the supported advanced unsigned Multiply instructions
        constexpr uint32_t REVERSAL_INSTRS = (4 << 28);  ///< Indicates the supported Reversal instructions
    }

    /// ID_ISAR3 Register bits
    namespace id_isar3_bits {
        constexpr uint32_t SATURATE_INSTRS = (4 << 0);  ///< Indicates the supported Saturate instructions
        constexpr uint32_t SIMD_INSTRS = (4 << 4);  ///< Indicates the supported SIMD instructions
        constexpr uint32_t SVC_INSTRS = (4 << 8);  ///< Indicates the supported SVC instructions
        constexpr uint32_t SYNCHPRIM_INSTRS = (4 << 12);  ///< Together with the ID_ISAR4[SYNCHPRIM_INSTRS_FRAC] indicates the supported Synchronization Primitives
        constexpr uint32_t TABBRANCH_INSTRS = (4 << 16);  ///< Indicates the supported Table Branch instructions
        constexpr uint32_t THUMBCOPY_INSTRS = (4 << 20);  ///< Indicates the supported non flag-setting MOV instructions
        constexpr uint32_t TRUENOP_INSTRS = (4 << 24);  ///< Indicates the supported non flag-setting MOV instructions
    }

    /// ID_ISAR4 Register bits
    namespace id_isar4_bits {
        constexpr uint32_t UNPRIV_INSTRS = (4 << 0);  ///< Indicates the supported unprivileged instructions. These are the instruction variants indicated by a T suffix.
        constexpr uint32_t WITHSHIFTS_INSTRS = (4 << 4);  ///< Indicates the support for instructions with shifts
        constexpr uint32_t WRITEBACK_INSTRS = (4 << 8);  ///< Indicates the support for Writeback addressing modes
        constexpr uint32_t BARRIER_INSTRS = (4 << 16);  ///< Indicates the supported Barrier instructions
        constexpr uint32_t SYNCHPRIM_INSTRS_FRAC = (4 << 20);  ///< Together with the ID_ISAR3[SYNCHPRIM_INSTRS] indicates the supported Synchronization Primitives
        constexpr uint32_t PSR_M_INSTRS = (4 << 24);  ///< Indicates the supported M profile instructions to modify the PSRs
    }

    /// CLIDR Register bits
    namespace clidr_bits {
        constexpr uint32_t CL1 = (3 << 0);  ///< Indicate the type of cache implemented at level 1.
        constexpr uint32_t CL2 = (3 << 3);  ///< Indicate the type of cache implemented at level 2.
        constexpr uint32_t CL3 = (3 << 6);  ///< Indicate the type of cache implemented at level 3.
        constexpr uint32_t CL4 = (3 << 9);  ///< Indicate the type of cache implemented at level 4.
        constexpr uint32_t CL5 = (3 << 12);  ///< Indicate the type of cache implemented at level 5.
        constexpr uint32_t CL6 = (3 << 15);  ///< Indicate the type of cache implemented at level 6.
        constexpr uint32_t CL7 = (3 << 18);  ///< Indicate the type of cache implemented at level 7.
        constexpr uint32_t LOUIS = (3 << 21);  ///< Level of Unification Inner Shareable for the cache hierarchy. This field is RAZ.
        constexpr uint32_t LOC = (3 << 24);  ///< Level of Coherency for the cache hierarchy
        constexpr uint32_t LOU = (3 << 27);  ///< Level of Unification for the cache hierarchy
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t IMINLINE = (4 << 0);  ///< Log2 of the number of words in the smallest cache line of all the instruction caches that are controlled by the processor.
        constexpr uint32_t DMINLINE = (4 << 16);  ///< Log2 of the number of words in the smallest cache line of all the data caches and unified caches that are controlled by the processor.
        constexpr uint32_t ERG = (4 << 20);  ///< Exclusives Reservation Granule. The maximum size of the reservation granule that has been implemented for the Load-Exclusive and Store-Exclusive instructions, encoded as Log2 of the number of words.
        constexpr uint32_t CWG = (4 << 24);  ///< Cache Write-back Granule. The maximum size of memory that can be overwritten as a result of the eviction of a cache entry that has had a memory location in it modified, encoded as Log2 of the number of words.
        constexpr uint32_t FORMAT = (3 << 29);  ///< Indicates the implemented CTR format.
    }

    /// CCSIDR Register bits
    namespace ccsidr_bits {
        constexpr uint32_t LINESIZE = (3 << 0);  ///< (Log2(Number of words in cache line)) - 2.
        constexpr uint32_t ASSOCIATIVITY = (10 << 3);  ///< (Associativity of cache) - 1, therefore a value of 0 indicates an associativity of 1. The associativity does not have to be a power of 2.
        constexpr uint32_t NUMSETS = (15 << 13);  ///< (Number of sets in cache) - 1, therefore a value of 0 indicates 1 set in the cache. The number of sets does not have to be a power of 2.
        constexpr uint32_t WA = (1U << 28);  ///< Indicates whether the cache level supports write-allocation
        constexpr uint32_t RA = (1U << 29);  ///< Indicates whether the cache level supports read-allocation
        constexpr uint32_t WB = (1U << 30);  ///< Indicates whether the cache level supports write-back
        constexpr uint32_t WT = (1U << 31);  ///< Indicates whether the cache level supports write-through
    }

    /// CSSELR Register bits
    namespace csselr_bits {
        constexpr uint32_t IND = (1U << 0);  ///< Instruction not data bit
        constexpr uint32_t LEVEL = (3 << 1);  ///< Cache level of required cache
    }

    /// CPACR Register bits
    namespace cpacr_bits {
        constexpr uint32_t CP0 = (2 << 0);  ///< Access privileges for coprocessor 0.
        constexpr uint32_t CP1 = (2 << 2);  ///< Access privileges for coprocessor 1.
        constexpr uint32_t CP2 = (2 << 4);  ///< Access privileges for coprocessor 2.
        constexpr uint32_t CP3 = (2 << 6);  ///< Access privileges for coprocessor 3.
        constexpr uint32_t CP4 = (2 << 8);  ///< Access privileges for coprocessor 4.
        constexpr uint32_t CP5 = (2 << 10);  ///< Access privileges for coprocessor 5.
        constexpr uint32_t CP6 = (2 << 12);  ///< Access privileges for coprocessor 6.
        constexpr uint32_t CP7 = (2 << 14);  ///< Access privileges for coprocessor 7.
        constexpr uint32_t CP10 = (2 << 20);  ///< Access privileges for coprocessor 10.
        constexpr uint32_t CP11 = (2 << 22);  ///< Access privileges for coprocessor 11.
    }

    /// STIR Register bits
    namespace stir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< Indicates the interrupt to be triggered
    }

    /// ICIALLU Register bits
    namespace iciallu_bits {
        constexpr uint32_t ICIALLU = (32 << 0);  ///< I-cache invalidate all to PoU
    }

    /// ICIMVAU Register bits
    namespace icimvau_bits {
        constexpr uint32_t ICIMVAU = (32 << 0);  ///< I-cache invalidate by MVA to PoU
    }

    /// DCIMVAC Register bits
    namespace dcimvac_bits {
        constexpr uint32_t DCIMVAC = (32 << 0);  ///< D-cache invalidate by MVA to PoC
    }

    /// DCISW Register bits
    namespace dcisw_bits {
        constexpr uint32_t DCISW = (32 << 0);  ///< D-cache invalidate by set-way
    }

    /// DCCMVAU Register bits
    namespace dccmvau_bits {
        constexpr uint32_t DCCMVAU = (32 << 0);  ///< D-cache clean by MVA to PoU
    }

    /// DCCMVAC Register bits
    namespace dccmvac_bits {
        constexpr uint32_t DCCMVAC = (32 << 0);  ///< D-cache clean by MVA to PoC
    }

    /// DCCSW Register bits
    namespace dccsw_bits {
        constexpr uint32_t DCCSW = (32 << 0);  ///< D-cache clean by set-way
    }

    /// DCCIMVAC Register bits
    namespace dccimvac_bits {
        constexpr uint32_t DCCIMVAC = (32 << 0);  ///< D-cache clean and invalidate by MVA to PoC
    }

    /// DCCISW Register bits
    namespace dccisw_bits {
        constexpr uint32_t DCCISW = (32 << 0);  ///< D-cache clean and invalidate by set-way
    }

    /// CM7_ITCMCR Register bits
    namespace cm7_itcmcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< TCM enable. When a TCM is disabled all accesses are made to the AXIM interface.
        constexpr uint32_t RMW = (1U << 1);  ///< Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that are not the full width of the TCM RAM, use a RMW sequence.
        constexpr uint32_t RETEN = (1U << 2);  ///< Retry phase enable. When enabled the processor guarantees to honor the retry output on the corresponding TCM interface, re-executing the instruction which carried out the TCM access.
        constexpr uint32_t SZ = (4 << 3);  ///< TCM size. Indicates the size of the relevant TCM.
    }

    /// CM7_DTCMCR Register bits
    namespace cm7_dtcmcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< TCM enable. When a TCM is disabled all accesses are made to the AXIM interface.
        constexpr uint32_t RMW = (1U << 1);  ///< Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that are not the full width of the TCM RAM, use a RMW sequence.
        constexpr uint32_t RETEN = (1U << 2);  ///< Retry phase enable. When enabled the processor guarantees to honor the retry output on the corresponding TCM interface, re-executing the instruction which carried out the TCM access.
        constexpr uint32_t SZ = (4 << 3);  ///< TCM size. Indicates the size of the relevant TCM.
    }

    /// CM7_AHBPCR Register bits
    namespace cm7_ahbpcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< AHBP enable.
        constexpr uint32_t SZ = (3 << 1);  ///< AHBP size.
    }

    /// CM7_CACR Register bits
    namespace cm7_cacr_bits {
        constexpr uint32_t SIWT = (1U << 0);  ///< Shared cacheable-is-WT for data cache. Enables limited cache coherency usage.
        constexpr uint32_t ECCDIS = (1U << 1);  ///< Enables ECC in the instruction and data cache.
        constexpr uint32_t FORCEWT = (1U << 2);  ///< Enables Force Write-Through in the data cache.
    }

    /// CM7_AHBSCR Register bits
    namespace cm7_ahbscr_bits {
        constexpr uint32_t CTL = (2 << 0);  ///< AHBS prioritization control.
        constexpr uint32_t TPRI = (9 << 2);  ///< Threshold execution priority for AHBS traffic demotion.
        constexpr uint32_t INITCOUNT = (5 << 11);  ///< Fairness counter initialization value.
    }

    /// CM7_ABFSR Register bits
    namespace cm7_abfsr_bits {
        constexpr uint32_t ITCM = (1U << 0);  ///< Asynchronous fault on ITCM interface.
        constexpr uint32_t DTCM = (1U << 1);  ///< Asynchronous fault on DTCM interface.
        constexpr uint32_t AHBP = (1U << 2);  ///< Asynchronous fault on AHBP interface.
        constexpr uint32_t AXIM = (1U << 3);  ///< Asynchronous fault on AXIM interface.
        constexpr uint32_t EPPB = (1U << 4);  ///< Asynchronous fault on EPPB interface.
        constexpr uint32_t AXIMTYPE = (2 << 8);  ///< Indicates the type of fault on the AXIM interface. Only valid when AXIM is 1.
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t NVICISER0;  ///< Offset: 0x00 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER1;  ///< Offset: 0x04 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER2;  ///< Offset: 0x08 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER3;  ///< Offset: 0x0C - Interrupt Set Enable Register n
        volatile uint32_t NVICICER0;  ///< Offset: 0x80 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER1;  ///< Offset: 0x84 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER2;  ///< Offset: 0x88 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER3;  ///< Offset: 0x8C - Interrupt Clear Enable Register n
        volatile uint32_t NVICISPR0;  ///< Offset: 0x100 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR1;  ///< Offset: 0x104 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR2;  ///< Offset: 0x108 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR3;  ///< Offset: 0x10C - Interrupt Set Pending Register n
        volatile uint32_t NVICICPR0;  ///< Offset: 0x180 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR1;  ///< Offset: 0x184 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR2;  ///< Offset: 0x188 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR3;  ///< Offset: 0x18C - Interrupt Clear Pending Register n
        volatile uint32_t NVICIABR0;  ///< Offset: 0x200 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR1;  ///< Offset: 0x204 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR2;  ///< Offset: 0x208 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR3;  ///< Offset: 0x20C - Interrupt Active bit Register n
        volatile uint32_t NVICIP0;  ///< Offset: 0x300 - Interrupt Priority Register 0
        volatile uint32_t NVICIP1;  ///< Offset: 0x301 - Interrupt Priority Register 1
        volatile uint32_t NVICIP2;  ///< Offset: 0x302 - Interrupt Priority Register 2
        volatile uint32_t NVICIP3;  ///< Offset: 0x303 - Interrupt Priority Register 3
        volatile uint32_t NVICIP4;  ///< Offset: 0x304 - Interrupt Priority Register 4
        volatile uint32_t NVICIP5;  ///< Offset: 0x305 - Interrupt Priority Register 5
        volatile uint32_t NVICIP6;  ///< Offset: 0x306 - Interrupt Priority Register 6
        volatile uint32_t NVICIP7;  ///< Offset: 0x307 - Interrupt Priority Register 7
        volatile uint32_t NVICIP8;  ///< Offset: 0x308 - Interrupt Priority Register 8
        volatile uint32_t NVICIP9;  ///< Offset: 0x309 - Interrupt Priority Register 9
        volatile uint32_t NVICIP10;  ///< Offset: 0x30A - Interrupt Priority Register 10
        volatile uint32_t NVICIP11;  ///< Offset: 0x30B - Interrupt Priority Register 11
        volatile uint32_t NVICIP12;  ///< Offset: 0x30C - Interrupt Priority Register 12
        volatile uint32_t NVICIP13;  ///< Offset: 0x30D - Interrupt Priority Register 13
        volatile uint32_t NVICIP14;  ///< Offset: 0x30E - Interrupt Priority Register 14
        volatile uint32_t NVICIP15;  ///< Offset: 0x30F - Interrupt Priority Register 15
        volatile uint32_t NVICIP16;  ///< Offset: 0x310 - Interrupt Priority Register 16
        volatile uint32_t NVICIP17;  ///< Offset: 0x311 - Interrupt Priority Register 17
        volatile uint32_t NVICIP18;  ///< Offset: 0x312 - Interrupt Priority Register 18
        volatile uint32_t NVICIP19;  ///< Offset: 0x313 - Interrupt Priority Register 19
        volatile uint32_t NVICIP20;  ///< Offset: 0x314 - Interrupt Priority Register 20
        volatile uint32_t NVICIP21;  ///< Offset: 0x315 - Interrupt Priority Register 21
        volatile uint32_t NVICIP22;  ///< Offset: 0x316 - Interrupt Priority Register 22
        volatile uint32_t NVICIP23;  ///< Offset: 0x317 - Interrupt Priority Register 23
        volatile uint32_t NVICIP24;  ///< Offset: 0x318 - Interrupt Priority Register 24
        volatile uint32_t NVICIP25;  ///< Offset: 0x319 - Interrupt Priority Register 25
        volatile uint32_t NVICIP26;  ///< Offset: 0x31A - Interrupt Priority Register 26
        volatile uint32_t NVICIP27;  ///< Offset: 0x31B - Interrupt Priority Register 27
        volatile uint32_t NVICIP28;  ///< Offset: 0x31C - Interrupt Priority Register 28
        volatile uint32_t NVICIP29;  ///< Offset: 0x31D - Interrupt Priority Register 29
        volatile uint32_t NVICIP30;  ///< Offset: 0x31E - Interrupt Priority Register 30
        volatile uint32_t NVICIP31;  ///< Offset: 0x31F - Interrupt Priority Register 31
        volatile uint32_t NVICIP32;  ///< Offset: 0x320 - Interrupt Priority Register 32
        volatile uint32_t NVICIP33;  ///< Offset: 0x321 - Interrupt Priority Register 33
        volatile uint32_t NVICIP34;  ///< Offset: 0x322 - Interrupt Priority Register 34
        volatile uint32_t NVICIP35;  ///< Offset: 0x323 - Interrupt Priority Register 35
        volatile uint32_t NVICIP36;  ///< Offset: 0x324 - Interrupt Priority Register 36
        volatile uint32_t NVICIP37;  ///< Offset: 0x325 - Interrupt Priority Register 37
        volatile uint32_t NVICIP38;  ///< Offset: 0x326 - Interrupt Priority Register 38
        volatile uint32_t NVICIP39;  ///< Offset: 0x327 - Interrupt Priority Register 39
        volatile uint32_t NVICIP40;  ///< Offset: 0x328 - Interrupt Priority Register 40
        volatile uint32_t NVICIP41;  ///< Offset: 0x329 - Interrupt Priority Register 41
        volatile uint32_t NVICIP42;  ///< Offset: 0x32A - Interrupt Priority Register 42
        volatile uint32_t NVICIP43;  ///< Offset: 0x32B - Interrupt Priority Register 43
        volatile uint32_t NVICIP44;  ///< Offset: 0x32C - Interrupt Priority Register 44
        volatile uint32_t NVICIP45;  ///< Offset: 0x32D - Interrupt Priority Register 45
        volatile uint32_t NVICIP46;  ///< Offset: 0x32E - Interrupt Priority Register 46
        volatile uint32_t NVICIP47;  ///< Offset: 0x32F - Interrupt Priority Register 47
        volatile uint32_t NVICIP48;  ///< Offset: 0x330 - Interrupt Priority Register 48
        volatile uint32_t NVICIP49;  ///< Offset: 0x331 - Interrupt Priority Register 49
        volatile uint32_t NVICIP50;  ///< Offset: 0x332 - Interrupt Priority Register 50
        volatile uint32_t NVICIP51;  ///< Offset: 0x333 - Interrupt Priority Register 51
        volatile uint32_t NVICIP52;  ///< Offset: 0x334 - Interrupt Priority Register 52
        volatile uint32_t NVICIP53;  ///< Offset: 0x335 - Interrupt Priority Register 53
        volatile uint32_t NVICIP54;  ///< Offset: 0x336 - Interrupt Priority Register 54
        volatile uint32_t NVICIP55;  ///< Offset: 0x337 - Interrupt Priority Register 55
        volatile uint32_t NVICIP56;  ///< Offset: 0x338 - Interrupt Priority Register 56
        volatile uint32_t NVICIP57;  ///< Offset: 0x339 - Interrupt Priority Register 57
        volatile uint32_t NVICIP58;  ///< Offset: 0x33A - Interrupt Priority Register 58
        volatile uint32_t NVICIP59;  ///< Offset: 0x33B - Interrupt Priority Register 59
        volatile uint32_t NVICIP60;  ///< Offset: 0x33C - Interrupt Priority Register 60
        volatile uint32_t NVICIP61;  ///< Offset: 0x33D - Interrupt Priority Register 61
        volatile uint32_t NVICIP62;  ///< Offset: 0x33E - Interrupt Priority Register 62
        volatile uint32_t NVICIP63;  ///< Offset: 0x33F - Interrupt Priority Register 63
        volatile uint32_t NVICIP64;  ///< Offset: 0x340 - Interrupt Priority Register 64
        volatile uint32_t NVICIP65;  ///< Offset: 0x341 - Interrupt Priority Register 65
        volatile uint32_t NVICIP66;  ///< Offset: 0x342 - Interrupt Priority Register 66
        volatile uint32_t NVICIP67;  ///< Offset: 0x343 - Interrupt Priority Register 67
        volatile uint32_t NVICIP68;  ///< Offset: 0x344 - Interrupt Priority Register 68
        volatile uint32_t NVICIP69;  ///< Offset: 0x345 - Interrupt Priority Register 69
        volatile uint32_t NVICIP70;  ///< Offset: 0x346 - Interrupt Priority Register 70
        volatile uint32_t NVICIP71;  ///< Offset: 0x347 - Interrupt Priority Register 71
        volatile uint32_t NVICIP72;  ///< Offset: 0x348 - Interrupt Priority Register 72
        volatile uint32_t NVICIP73;  ///< Offset: 0x349 - Interrupt Priority Register 73
        volatile uint32_t NVICIP74;  ///< Offset: 0x34A - Interrupt Priority Register 74
        volatile uint32_t NVICIP75;  ///< Offset: 0x34B - Interrupt Priority Register 75
        volatile uint32_t NVICIP76;  ///< Offset: 0x34C - Interrupt Priority Register 76
        volatile uint32_t NVICIP77;  ///< Offset: 0x34D - Interrupt Priority Register 77
        volatile uint32_t NVICIP78;  ///< Offset: 0x34E - Interrupt Priority Register 78
        volatile uint32_t NVICIP79;  ///< Offset: 0x34F - Interrupt Priority Register 79
        volatile uint32_t NVICSTIR;  ///< Offset: 0xE00 - Software Trigger Interrupt Register
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

    // Bit definitions
    /// NVICISER0 Register bits
    namespace nviciser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER1 Register bits
    namespace nviciser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER2 Register bits
    namespace nviciser2_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER3 Register bits
    namespace nviciser3_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICICER0 Register bits
    namespace nvicicer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER1 Register bits
    namespace nvicicer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER2 Register bits
    namespace nvicicer2_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER3 Register bits
    namespace nvicicer3_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICISPR0 Register bits
    namespace nvicispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR1 Register bits
    namespace nvicispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR2 Register bits
    namespace nvicispr2_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR3 Register bits
    namespace nvicispr3_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICICPR0 Register bits
    namespace nvicicpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR1 Register bits
    namespace nvicicpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR2 Register bits
    namespace nvicicpr2_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR3 Register bits
    namespace nvicicpr3_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICIABR0 Register bits
    namespace nviciabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR1 Register bits
    namespace nviciabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR2 Register bits
    namespace nviciabr2_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR3 Register bits
    namespace nviciabr3_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIP0 Register bits
    namespace nvicip0_bits {
        constexpr uint32_t PRI0 = (4 << 4);  ///< Priority of the INT_DMA0 interrupt 0
    }

    /// NVICIP1 Register bits
    namespace nvicip1_bits {
        constexpr uint32_t PRI1 = (4 << 4);  ///< Priority of the INT_DMA1 interrupt 1
    }

    /// NVICIP2 Register bits
    namespace nvicip2_bits {
        constexpr uint32_t PRI2 = (4 << 4);  ///< Priority of the INT_DMA2 interrupt 2
    }

    /// NVICIP3 Register bits
    namespace nvicip3_bits {
        constexpr uint32_t PRI3 = (4 << 4);  ///< Priority of the INT_DMA3 interrupt 3
    }

    /// NVICIP4 Register bits
    namespace nvicip4_bits {
        constexpr uint32_t PRI4 = (4 << 4);  ///< Priority of the INT_DMA4 interrupt 4
    }

    /// NVICIP5 Register bits
    namespace nvicip5_bits {
        constexpr uint32_t PRI5 = (4 << 4);  ///< Priority of the INT_DMA5 interrupt 5
    }

    /// NVICIP6 Register bits
    namespace nvicip6_bits {
        constexpr uint32_t PRI6 = (4 << 4);  ///< Priority of the INT_DMA6 interrupt 6
    }

    /// NVICIP7 Register bits
    namespace nvicip7_bits {
        constexpr uint32_t PRI7 = (4 << 4);  ///< Priority of the INT_DMA7 interrupt 7
    }

    /// NVICIP8 Register bits
    namespace nvicip8_bits {
        constexpr uint32_t PRI8 = (4 << 4);  ///< Priority of the INT_DMA8 interrupt 8
    }

    /// NVICIP9 Register bits
    namespace nvicip9_bits {
        constexpr uint32_t PRI9 = (4 << 4);  ///< Priority of the INT_DMA9 interrupt 9
    }

    /// NVICIP10 Register bits
    namespace nvicip10_bits {
        constexpr uint32_t PRI10 = (4 << 4);  ///< Priority of the INT_DMA10 interrupt 10
    }

    /// NVICIP11 Register bits
    namespace nvicip11_bits {
        constexpr uint32_t PRI11 = (4 << 4);  ///< Priority of the INT_DMA11 interrupt 11
    }

    /// NVICIP12 Register bits
    namespace nvicip12_bits {
        constexpr uint32_t PRI12 = (4 << 4);  ///< Priority of the INT_DMA12 interrupt 12
    }

    /// NVICIP13 Register bits
    namespace nvicip13_bits {
        constexpr uint32_t PRI13 = (4 << 4);  ///< Priority of the INT_DMA13 interrupt 13
    }

    /// NVICIP14 Register bits
    namespace nvicip14_bits {
        constexpr uint32_t PRI14 = (4 << 4);  ///< Priority of the INT_DMA14 interrupt 14
    }

    /// NVICIP15 Register bits
    namespace nvicip15_bits {
        constexpr uint32_t PRI15 = (4 << 4);  ///< Priority of the INT_DMA15 interrupt 15
    }

    /// NVICIP16 Register bits
    namespace nvicip16_bits {
        constexpr uint32_t PRI16 = (4 << 4);  ///< Priority of the INT_DMA_ERROR interrupt 16
    }

    /// NVICIP17 Register bits
    namespace nvicip17_bits {
        constexpr uint32_t PRI17 = (4 << 4);  ///< Priority of the INT_CTI0_ERROR interrupt 17
    }

    /// NVICIP18 Register bits
    namespace nvicip18_bits {
        constexpr uint32_t PRI18 = (4 << 4);  ///< Priority of the INT_CTI1_ERROR interrupt 18
    }

    /// NVICIP19 Register bits
    namespace nvicip19_bits {
        constexpr uint32_t PRI19 = (4 << 4);  ///< Priority of the INT_CORE interrupt 19
    }

    /// NVICIP20 Register bits
    namespace nvicip20_bits {
        constexpr uint32_t PRI20 = (4 << 4);  ///< Priority of the INT_LPUART1 interrupt 20
    }

    /// NVICIP21 Register bits
    namespace nvicip21_bits {
        constexpr uint32_t PRI21 = (4 << 4);  ///< Priority of the INT_LPUART2 interrupt 21
    }

    /// NVICIP22 Register bits
    namespace nvicip22_bits {
        constexpr uint32_t PRI22 = (4 << 4);  ///< Priority of the INT_LPUART3 interrupt 22
    }

    /// NVICIP23 Register bits
    namespace nvicip23_bits {
        constexpr uint32_t PRI23 = (4 << 4);  ///< Priority of the INT_LPUART4 interrupt 23
    }

    /// NVICIP24 Register bits
    namespace nvicip24_bits {
        constexpr uint32_t PRI24 = (4 << 4);  ///< Priority of the INT_PIT interrupt 24
    }

    /// NVICIP25 Register bits
    namespace nvicip25_bits {
        constexpr uint32_t PRI25 = (4 << 4);  ///< Priority of the INT_USB_OTG1 interrupt 25
    }

    /// NVICIP26 Register bits
    namespace nvicip26_bits {
        constexpr uint32_t PRI26 = (4 << 4);  ///< Priority of the INT_FLEXSPI interrupt 26
    }

    /// NVICIP27 Register bits
    namespace nvicip27_bits {
        constexpr uint32_t PRI27 = (4 << 4);  ///< Priority of the INT_FLEXRAM interrupt 27
    }

    /// NVICIP28 Register bits
    namespace nvicip28_bits {
        constexpr uint32_t PRI28 = (4 << 4);  ///< Priority of the INT_LPI2C1 interrupt 28
    }

    /// NVICIP29 Register bits
    namespace nvicip29_bits {
        constexpr uint32_t PRI29 = (4 << 4);  ///< Priority of the INT_LPI2C2 interrupt 29
    }

    /// NVICIP30 Register bits
    namespace nvicip30_bits {
        constexpr uint32_t PRI30 = (4 << 4);  ///< Priority of the INT_GPT1 interrupt 30
    }

    /// NVICIP31 Register bits
    namespace nvicip31_bits {
        constexpr uint32_t PRI31 = (4 << 4);  ///< Priority of the INT_GPT2 interrupt 31
    }

    /// NVICIP32 Register bits
    namespace nvicip32_bits {
        constexpr uint32_t PRI32 = (4 << 4);  ///< Priority of the INT_LPSPI1 interrupt 32
    }

    /// NVICIP33 Register bits
    namespace nvicip33_bits {
        constexpr uint32_t PRI33 = (4 << 4);  ///< Priority of the INT_LPSPI2 interrupt 33
    }

    /// NVICIP34 Register bits
    namespace nvicip34_bits {
        constexpr uint32_t PRI34 = (4 << 4);  ///< Priority of the INT_PWM1_0 interrupt 34
    }

    /// NVICIP35 Register bits
    namespace nvicip35_bits {
        constexpr uint32_t PRI35 = (4 << 4);  ///< Priority of the INT_PWM1_1 interrupt 35
    }

    /// NVICIP36 Register bits
    namespace nvicip36_bits {
        constexpr uint32_t PRI36 = (4 << 4);  ///< Priority of the INT_PWM1_2 interrupt 36
    }

    /// NVICIP37 Register bits
    namespace nvicip37_bits {
        constexpr uint32_t PRI37 = (4 << 4);  ///< Priority of the INT_PWM1_3 interrupt 37
    }

    /// NVICIP38 Register bits
    namespace nvicip38_bits {
        constexpr uint32_t PRI38 = (4 << 4);  ///< Priority of the INT_PWM1_FAULT interrupt 38
    }

    /// NVICIP39 Register bits
    namespace nvicip39_bits {
        constexpr uint32_t PRI39 = (4 << 4);  ///< Priority of the INT_KPP interrupt 39
    }

    /// NVICIP40 Register bits
    namespace nvicip40_bits {
        constexpr uint32_t PRI40 = (4 << 4);  ///< Priority of the INT_SRC interrupt 40
    }

    /// NVICIP41 Register bits
    namespace nvicip41_bits {
        constexpr uint32_t PRI41 = (4 << 4);  ///< Priority of the INT_GPR_IRQ interrupt 41
    }

    /// NVICIP42 Register bits
    namespace nvicip42_bits {
        constexpr uint32_t PRI42 = (4 << 4);  ///< Priority of the INT_CCM_1 interrupt 42
    }

    /// NVICIP43 Register bits
    namespace nvicip43_bits {
        constexpr uint32_t PRI43 = (4 << 4);  ///< Priority of the INT_CCM_2 interrupt 43
    }

    /// NVICIP44 Register bits
    namespace nvicip44_bits {
        constexpr uint32_t PRI44 = (4 << 4);  ///< Priority of the INT_EWM interrupt 44
    }

    /// NVICIP45 Register bits
    namespace nvicip45_bits {
        constexpr uint32_t PRI45 = (4 << 4);  ///< Priority of the INT_WDOG2 interrupt 45
    }

    /// NVICIP46 Register bits
    namespace nvicip46_bits {
        constexpr uint32_t PRI46 = (4 << 4);  ///< Priority of the INT_SNVS_HP_WRAPPER interrupt 46
    }

    /// NVICIP47 Register bits
    namespace nvicip47_bits {
        constexpr uint32_t PRI47 = (4 << 4);  ///< Priority of the INT_SNVS_HP_WRAPPER_TZ interrupt 47
    }

    /// NVICIP48 Register bits
    namespace nvicip48_bits {
        constexpr uint32_t PRI48 = (4 << 4);  ///< Priority of the INT_SNVS_LP_WRAPPER interrupt 48
    }

    /// NVICIP49 Register bits
    namespace nvicip49_bits {
        constexpr uint32_t PRI49 = (4 << 4);  ///< Priority of the INT_CSU interrupt 49
    }

    /// NVICIP50 Register bits
    namespace nvicip50_bits {
        constexpr uint32_t PRI50 = (4 << 4);  ///< Priority of the INT_DCP interrupt 50
    }

    /// NVICIP51 Register bits
    namespace nvicip51_bits {
        constexpr uint32_t PRI51 = (4 << 4);  ///< Priority of the INT_DCP_VMI interrupt 51
    }

    /// NVICIP52 Register bits
    namespace nvicip52_bits {
        constexpr uint32_t PRI52 = (4 << 4);  ///< Priority of the INT_Reserved68 interrupt 52
    }

    /// NVICIP53 Register bits
    namespace nvicip53_bits {
        constexpr uint32_t PRI53 = (4 << 4);  ///< Priority of the INT_TRNG interrupt 53
    }

    /// NVICIP54 Register bits
    namespace nvicip54_bits {
        constexpr uint32_t PRI54 = (4 << 4);  ///< Priority of the INT_Reserved70 interrupt 54
    }

    /// NVICIP55 Register bits
    namespace nvicip55_bits {
        constexpr uint32_t PRI55 = (4 << 4);  ///< Priority of the INT_Reserved71 interrupt 55
    }

    /// NVICIP56 Register bits
    namespace nvicip56_bits {
        constexpr uint32_t PRI56 = (4 << 4);  ///< Priority of the INT_SAI1 interrupt 56
    }

    /// NVICIP57 Register bits
    namespace nvicip57_bits {
        constexpr uint32_t PRI57 = (4 << 4);  ///< Priority of the INT_RTWDOG interrupt 57
    }

    /// NVICIP58 Register bits
    namespace nvicip58_bits {
        constexpr uint32_t PRI58 = (4 << 4);  ///< Priority of the INT_SAI3_RX interrupt 58
    }

    /// NVICIP59 Register bits
    namespace nvicip59_bits {
        constexpr uint32_t PRI59 = (4 << 4);  ///< Priority of the INT_SAI3_TX interrupt 59
    }

    /// NVICIP60 Register bits
    namespace nvicip60_bits {
        constexpr uint32_t PRI60 = (4 << 4);  ///< Priority of the INT_SPDIF interrupt 60
    }

    /// NVICIP61 Register bits
    namespace nvicip61_bits {
        constexpr uint32_t PRI61 = (4 << 4);  ///< Priority of the INT_PMU interrupt 61
    }

    /// NVICIP62 Register bits
    namespace nvicip62_bits {
        constexpr uint32_t PRI62 = (4 << 4);  ///< Priority of the INT_XBAR1_IRQ_0_1_2_3 interrupt 62
    }

    /// NVICIP63 Register bits
    namespace nvicip63_bits {
        constexpr uint32_t PRI63 = (4 << 4);  ///< Priority of the INT_TEMP_LOW_HIGH interrupt 63
    }

    /// NVICIP64 Register bits
    namespace nvicip64_bits {
        constexpr uint32_t PRI64 = (4 << 4);  ///< Priority of the INT_TEMP_PANIC interrupt 64
    }

    /// NVICIP65 Register bits
    namespace nvicip65_bits {
        constexpr uint32_t PRI65 = (4 << 4);  ///< Priority of the INT_USB_PHY interrupt 65
    }

    /// NVICIP66 Register bits
    namespace nvicip66_bits {
        constexpr uint32_t PRI66 = (4 << 4);  ///< Priority of the INT_GPC interrupt 66
    }

    /// NVICIP67 Register bits
    namespace nvicip67_bits {
        constexpr uint32_t PRI67 = (4 << 4);  ///< Priority of the INT_ADC1 interrupt 67
    }

    /// NVICIP68 Register bits
    namespace nvicip68_bits {
        constexpr uint32_t PRI68 = (4 << 4);  ///< Priority of the INT_FLEXIO1 interrupt 68
    }

    /// NVICIP69 Register bits
    namespace nvicip69_bits {
        constexpr uint32_t PRI69 = (4 << 4);  ///< Priority of the INT_DCDC interrupt 69
    }

    /// NVICIP70 Register bits
    namespace nvicip70_bits {
        constexpr uint32_t PRI70 = (4 << 4);  ///< Priority of the INT_GPIO1_Combined_0_15 interrupt 70
    }

    /// NVICIP71 Register bits
    namespace nvicip71_bits {
        constexpr uint32_t PRI71 = (4 << 4);  ///< Priority of the INT_GPIO1_Combined_16_31 interrupt 71
    }

    /// NVICIP72 Register bits
    namespace nvicip72_bits {
        constexpr uint32_t PRI72 = (4 << 4);  ///< Priority of the INT_GPIO2_Combined_0_15 interrupt 72
    }

    /// NVICIP73 Register bits
    namespace nvicip73_bits {
        constexpr uint32_t PRI73 = (4 << 4);  ///< Priority of the INT_GPIO5_Combined_0_15 interrupt 73
    }

    /// NVICIP74 Register bits
    namespace nvicip74_bits {
        constexpr uint32_t PRI74 = (4 << 4);  ///< Priority of the INT_WDOG1 interrupt 74
    }

    /// NVICIP75 Register bits
    namespace nvicip75_bits {
        constexpr uint32_t PRI75 = (4 << 4);  ///< Priority of the INT_ADC_ETC_IRQ0 interrupt 75
    }

    /// NVICIP76 Register bits
    namespace nvicip76_bits {
        constexpr uint32_t PRI76 = (4 << 4);  ///< Priority of the INT_ADC_ETC_IRQ1 interrupt 76
    }

    /// NVICIP77 Register bits
    namespace nvicip77_bits {
        constexpr uint32_t PRI77 = (4 << 4);  ///< Priority of the INT_ADC_ETC_IRQ2 interrupt 77
    }

    /// NVICIP78 Register bits
    namespace nvicip78_bits {
        constexpr uint32_t PRI78 = (4 << 4);  ///< Priority of the INT_ADC_ETC_IRQ3 interrupt 78
    }

    /// NVICIP79 Register bits
    namespace nvicip79_bits {
        constexpr uint32_t PRI79 = (4 << 4);  ///< Priority of the INT_ADC_ETC_ERROR_IRQ interrupt 79
    }

    /// NVICSTIR Register bits
    namespace nvicstir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< Interrupt ID of the interrupt to trigger, in the range 0-239. For example, a value of 0x03 specifies interrupt IRQ3.
    }

}


} // namespace alloy::generated::mimxrt1011

#endif // ALLOY_GENERATED_MIMXRT1011_PERIPHERALS_HPP