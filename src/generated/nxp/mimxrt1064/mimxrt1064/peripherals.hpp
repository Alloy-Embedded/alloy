/// Auto-generated code for MIMXRT1064
/// Generated by Alloy Code Generator
/// Source: nxp_mimxrt1064.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:01:14
#ifndef ALLOY_GENERATED_MIMXRT1064_PERIPHERALS_HPP
#define ALLOY_GENERATED_MIMXRT1064_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mimxrt1064 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_aipstz1 = true;
    constexpr uint32_t num_aipstz1_instances = 1;
    constexpr bool has_aipstz2 = true;
    constexpr uint32_t num_aipstz2_instances = 1;
    constexpr bool has_aipstz3 = true;
    constexpr uint32_t num_aipstz3_instances = 1;
    constexpr bool has_aipstz4 = true;
    constexpr uint32_t num_aipstz4_instances = 1;
    constexpr bool has_dcdc = true;
    constexpr uint32_t num_dcdc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_cmp2 = true;
    constexpr uint32_t num_cmp2_instances = 1;
    constexpr bool has_cmp3 = true;
    constexpr uint32_t num_cmp3_instances = 1;
    constexpr bool has_cmp4 = true;
    constexpr uint32_t num_cmp4_instances = 1;
    constexpr bool has_iomuxc = true;
    constexpr uint32_t num_iomuxc_instances = 4;
    constexpr bool has_flexram = true;
    constexpr uint32_t num_flexram_instances = 1;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_wdog1 = true;
    constexpr uint32_t num_wdog1_instances = 1;
    constexpr bool has_wdog2 = true;
    constexpr uint32_t num_wdog2_instances = 1;
    constexpr bool has_rtwdog = true;
    constexpr uint32_t num_rtwdog_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 3;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_snvs = true;
    constexpr uint32_t num_snvs_instances = 1;
    constexpr bool has_ccm = true;
    constexpr uint32_t num_ccm_instances = 2;
    constexpr bool has_pmu = true;
    constexpr uint32_t num_pmu_instances = 1;
    constexpr bool has_tempmon = true;
    constexpr uint32_t num_tempmon_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 7;
    constexpr bool has_xtalosc24m = true;
    constexpr uint32_t num_xtalosc24m_instances = 1;
    constexpr bool has_csu = true;
    constexpr uint32_t num_csu_instances = 1;
    constexpr bool has_tsc = true;
    constexpr uint32_t num_tsc_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_gpc = true;
    constexpr uint32_t num_gpc_instances = 1;
    constexpr bool has_pgc = true;
    constexpr uint32_t num_pgc_instances = 1;
    constexpr bool has_src = true;
    constexpr uint32_t num_src_instances = 1;
    constexpr bool has_romc = true;
    constexpr uint32_t num_romc_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 8;
    constexpr bool has_flexio1 = true;
    constexpr uint32_t num_flexio1_instances = 1;
    constexpr bool has_flexio2 = true;
    constexpr uint32_t num_flexio2_instances = 1;
    constexpr bool has_flexio3 = true;
    constexpr uint32_t num_flexio3_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 9;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 3;
    constexpr bool has_tmr1 = true;
    constexpr uint32_t num_tmr1_instances = 1;
    constexpr bool has_tmr2 = true;
    constexpr uint32_t num_tmr2_instances = 1;
    constexpr bool has_tmr3 = true;
    constexpr uint32_t num_tmr3_instances = 1;
    constexpr bool has_tmr4 = true;
    constexpr uint32_t num_tmr4_instances = 1;
    constexpr bool has_gpt1 = true;
    constexpr uint32_t num_gpt1_instances = 1;
    constexpr bool has_gpt2 = true;
    constexpr uint32_t num_gpt2_instances = 1;
    constexpr bool has_ocotp = true;
    constexpr uint32_t num_ocotp_instances = 1;
    constexpr bool has_kpp = true;
    constexpr uint32_t num_kpp_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 6;
    constexpr bool has_pxp = true;
    constexpr uint32_t num_pxp_instances = 1;
    constexpr bool has_lcdif = true;
    constexpr uint32_t num_lcdif_instances = 1;
    constexpr bool has_csi = true;
    constexpr uint32_t num_csi_instances = 1;
    constexpr bool has_usdhc1 = true;
    constexpr uint32_t num_usdhc1_instances = 1;
    constexpr bool has_usdhc2 = true;
    constexpr uint32_t num_usdhc2_instances = 1;
    constexpr bool has_enet = true;
    constexpr uint32_t num_enet_instances = 1;
    constexpr bool has_enet2 = true;
    constexpr uint32_t num_enet2_instances = 1;
    constexpr bool has_semc = true;
    constexpr uint32_t num_semc_instances = 1;
    constexpr bool has_dcp = true;
    constexpr uint32_t num_dcp_instances = 1;
    constexpr bool has_spdif = true;
    constexpr uint32_t num_spdif_instances = 1;
    constexpr bool has_sai1 = true;
    constexpr uint32_t num_sai1_instances = 1;
    constexpr bool has_sai2 = true;
    constexpr uint32_t num_sai2_instances = 1;
    constexpr bool has_sai3 = true;
    constexpr uint32_t num_sai3_instances = 1;
    constexpr bool has_aoi1 = true;
    constexpr uint32_t num_aoi1_instances = 1;
    constexpr bool has_aoi2 = true;
    constexpr uint32_t num_aoi2_instances = 1;
    constexpr bool has_xbara1 = true;
    constexpr uint32_t num_xbara1_instances = 1;
    constexpr bool has_xbarb2 = true;
    constexpr uint32_t num_xbarb2_instances = 1;
    constexpr bool has_xbarb3 = true;
    constexpr uint32_t num_xbarb3_instances = 1;
    constexpr bool has_enc1 = true;
    constexpr uint32_t num_enc1_instances = 1;
    constexpr bool has_enc2 = true;
    constexpr uint32_t num_enc2_instances = 1;
    constexpr bool has_enc3 = true;
    constexpr uint32_t num_enc3_instances = 1;
    constexpr bool has_enc4 = true;
    constexpr uint32_t num_enc4_instances = 1;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 4;
    constexpr bool has_bee = true;
    constexpr uint32_t num_bee_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 4;
    constexpr bool has_systemcontrol = true;
    constexpr uint32_t num_systemcontrol_instances = 1;
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct aipstz1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aipstz2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aipstz3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aipstz4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcdc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct iomuxc_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct flexram_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdog1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdog2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtwdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct snvs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccm_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pmu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tempmon_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 7;
    };
    template<>
    struct peripheral_count<struct xtalosc24m_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct csu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct gpc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pgc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct src_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct romc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct flexio1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flexio2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flexio3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 9;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct tmr1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tmr2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tmr3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tmr4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ocotp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct kpp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct pxp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lcdif_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct csi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usdhc1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usdhc2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct enet_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct enet2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct semc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spdif_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aoi1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aoi2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct xbara1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct xbarb2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct xbarb3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct enc1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct enc2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct enc3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct enc4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct bee_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct systemcontrol_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 9;
    constexpr uint32_t max_gpio_pins = 144;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart1 = true;
    constexpr bool has_lpuart2 = true;
    constexpr bool has_lpuart3 = true;
    constexpr bool has_lpuart4 = true;
    constexpr bool has_lpuart5 = true;
    constexpr bool has_lpuart6 = true;
    constexpr bool has_lpuart7 = true;
    constexpr bool has_lpuart8 = true;
}

// ============================================================================
// AIPSTZ1 Peripheral
// ============================================================================

namespace aipstz1 {
    /// Base addresses
    constexpr uint32_t AIPSTZ1_BASE = 0x4007C000;

    /// AIPSTZ1 Register structure
    struct Registers {
        volatile uint32_t MPR;  ///< Offset: 0x00 - Master Priviledge Registers
        volatile uint32_t OPACR;  ///< Offset: 0x40 - Off-Platform Peripheral Access Control Registers
        volatile uint32_t OPACR1;  ///< Offset: 0x44 - Off-Platform Peripheral Access Control Registers
        volatile uint32_t OPACR2;  ///< Offset: 0x48 - Off-Platform Peripheral Access Control Registers
        volatile uint32_t OPACR3;  ///< Offset: 0x4C - Off-Platform Peripheral Access Control Registers
        volatile uint32_t OPACR4;  ///< Offset: 0x50 - Off-Platform Peripheral Access Control Registers
    };

    /// Peripheral instances
    inline Registers* AIPSTZ1 = reinterpret_cast<Registers*>(AIPSTZ1_BASE);

    // Bit definitions
    /// MPR Register bits
    namespace mpr_bits {
        constexpr uint32_t MPROT5 = (4 << 8);  ///< Master 5 Priviledge, Buffer, Read, Write Control.
        constexpr uint32_t MPROT3 = (4 << 16);  ///< Master 3 Priviledge, Buffer, Read, Write Control.
        constexpr uint32_t MPROT2 = (4 << 20);  ///< Master 2 Priviledge, Buffer, Read, Write Control
        constexpr uint32_t MPROT1 = (4 << 24);  ///< Master 1 Priviledge, Buffer, Read, Write Control
        constexpr uint32_t MPROT0 = (4 << 28);  ///< Master 0 Priviledge, Buffer, Read, Write Control
    }

    /// OPACR Register bits
    namespace opacr_bits {
        constexpr uint32_t OPAC7 = (4 << 0);  ///< Off-platform Peripheral Access Control 7
        constexpr uint32_t OPAC6 = (4 << 4);  ///< Off-platform Peripheral Access Control 6
        constexpr uint32_t OPAC5 = (4 << 8);  ///< Off-platform Peripheral Access Control 5
        constexpr uint32_t OPAC4 = (4 << 12);  ///< Off-platform Peripheral Access Control 4
        constexpr uint32_t OPAC3 = (4 << 16);  ///< Off-platform Peripheral Access Control 3
        constexpr uint32_t OPAC2 = (4 << 20);  ///< Off-platform Peripheral Access Control 2
        constexpr uint32_t OPAC1 = (4 << 24);  ///< Off-platform Peripheral Access Control 1
        constexpr uint32_t OPAC0 = (4 << 28);  ///< Off-platform Peripheral Access Control 0
    }

    /// OPACR1 Register bits
    namespace opacr1_bits {
        constexpr uint32_t OPAC15 = (4 << 0);  ///< Off-platform Peripheral Access Control 15
        constexpr uint32_t OPAC14 = (4 << 4);  ///< Off-platform Peripheral Access Control 14
        constexpr uint32_t OPAC13 = (4 << 8);  ///< Off-platform Peripheral Access Control 13
        constexpr uint32_t OPAC12 = (4 << 12);  ///< Off-platform Peripheral Access Control 12
        constexpr uint32_t OPAC11 = (4 << 16);  ///< Off-platform Peripheral Access Control 11
        constexpr uint32_t OPAC10 = (4 << 20);  ///< Off-platform Peripheral Access Control 10
        constexpr uint32_t OPAC9 = (4 << 24);  ///< Off-platform Peripheral Access Control 9
        constexpr uint32_t OPAC8 = (4 << 28);  ///< Off-platform Peripheral Access Control 8
    }

    /// OPACR2 Register bits
    namespace opacr2_bits {
        constexpr uint32_t OPAC23 = (4 << 0);  ///< Off-platform Peripheral Access Control 23
        constexpr uint32_t OPAC22 = (4 << 4);  ///< Off-platform Peripheral Access Control 22
        constexpr uint32_t OPAC21 = (4 << 8);  ///< Off-platform Peripheral Access Control 21
        constexpr uint32_t OPAC20 = (4 << 12);  ///< Off-platform Peripheral Access Control 20
        constexpr uint32_t OPAC19 = (4 << 16);  ///< Off-platform Peripheral Access Control 19
        constexpr uint32_t OPAC18 = (4 << 20);  ///< Off-platform Peripheral Access Control 18
        constexpr uint32_t OPAC17 = (4 << 24);  ///< Off-platform Peripheral Access Control 17
        constexpr uint32_t OPAC16 = (4 << 28);  ///< Off-platform Peripheral Access Control 16
    }

    /// OPACR3 Register bits
    namespace opacr3_bits {
        constexpr uint32_t OPAC31 = (4 << 0);  ///< Off-platform Peripheral Access Control 31
        constexpr uint32_t OPAC30 = (4 << 4);  ///< Off-platform Peripheral Access Control 30
        constexpr uint32_t OPAC29 = (4 << 8);  ///< Off-platform Peripheral Access Control 29
        constexpr uint32_t OPAC28 = (4 << 12);  ///< Off-platform Peripheral Access Control 28
        constexpr uint32_t OPAC27 = (4 << 16);  ///< Off-platform Peripheral Access Control 27
        constexpr uint32_t OPAC26 = (4 << 20);  ///< Off-platform Peripheral Access Control 26
        constexpr uint32_t OPAC25 = (4 << 24);  ///< Off-platform Peripheral Access Control 25
        constexpr uint32_t OPAC24 = (4 << 28);  ///< Off-platform Peripheral Access Control 24
    }

    /// OPACR4 Register bits
    namespace opacr4_bits {
        constexpr uint32_t OPAC33 = (4 << 24);  ///< Off-platform Peripheral Access Control 33
        constexpr uint32_t OPAC32 = (4 << 28);  ///< Off-platform Peripheral Access Control 32
    }

}

// ============================================================================
// AIPSTZ2 Peripheral
// ============================================================================

namespace aipstz2 {
    /// Base addresses
    constexpr uint32_t AIPSTZ2_BASE = 0x4017C000;

    /// AIPSTZ2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AIPSTZ2 = reinterpret_cast<Registers*>(AIPSTZ2_BASE);

}

// ============================================================================
// AIPSTZ3 Peripheral
// ============================================================================

namespace aipstz3 {
    /// Base addresses
    constexpr uint32_t AIPSTZ3_BASE = 0x4027C000;

    /// AIPSTZ3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AIPSTZ3 = reinterpret_cast<Registers*>(AIPSTZ3_BASE);

}

// ============================================================================
// AIPSTZ4 Peripheral
// ============================================================================

namespace aipstz4 {
    /// Base addresses
    constexpr uint32_t AIPSTZ4_BASE = 0x4037C000;

    /// AIPSTZ4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AIPSTZ4 = reinterpret_cast<Registers*>(AIPSTZ4_BASE);

}

// ============================================================================
// DCDC Peripheral
// ============================================================================

namespace dcdc {
    /// Base addresses
    constexpr uint32_t DCDC_BASE = 0x40080000;

    /// DCDC Register structure
    struct Registers {
        volatile uint32_t REG0;  ///< Offset: 0x00 - DCDC Register 0
        volatile uint32_t REG1;  ///< Offset: 0x04 - DCDC Register 1
        volatile uint32_t REG2;  ///< Offset: 0x08 - DCDC Register 2
        volatile uint32_t REG3;  ///< Offset: 0x0C - DCDC Register 3
    };

    /// Peripheral instances
    inline Registers* DCDC = reinterpret_cast<Registers*>(DCDC_BASE);

    // Bit definitions
    /// REG0 Register bits
    namespace reg0_bits {
        constexpr uint32_t PWD_ZCD = (1U << 0);  ///< power down the zero cross detection function for discontinuous conductor mode
        constexpr uint32_t DISABLE_AUTO_CLK_SWITCH = (1U << 1);  ///< Disable automatic clock switch from internal osc to xtal clock.
        constexpr uint32_t SEL_CLK = (1U << 2);  ///< select 24 MHz Crystal clock for DCDC, when dcdc_disable_auto_clk_switch is set.
        constexpr uint32_t PWD_OSC_INT = (1U << 3);  ///< Power down internal osc. Only set this bit, when 24 MHz crystal osc is available
        constexpr uint32_t PWD_CUR_SNS_CMP = (1U << 4);  ///< The power down signal of the current detector.
        constexpr uint32_t CUR_SNS_THRSH = (3 << 5);  ///< Set the threshold of current detector, if the peak current of the inductor exceeds the threshold, the current detector will assert
        constexpr uint32_t PWD_OVERCUR_DET = (1U << 8);  ///< power down overcurrent detection comparator
        constexpr uint32_t OVERCUR_TRIG_ADJ = (2 << 9);  ///< The threshold of over current detection in run mode and power save mode: run mode power save mode 0x0 1 A 0
        constexpr uint32_t PWD_CMP_BATT_DET = (1U << 11);  ///< set to "1" to power down the low voltage detection comparator
        constexpr uint32_t ADJ_POSLIMIT_BUCK = (4 << 12);  ///< adjust value to poslimit_buck register
        constexpr uint32_t EN_LP_OVERLOAD_SNS = (1U << 16);  ///< enable the overload detection in power save mode, if current is larger than the overloading threshold (typical value is 50 mA), DCDC will switch to the run mode automatically
        constexpr uint32_t PWD_HIGH_VOLT_DET = (1U << 17);  ///< power down overvoltage detection comparator
        constexpr uint32_t LP_OVERLOAD_THRSH = (2 << 18);  ///< the threshold of the counting number of charging times during the period that lp_overload_freq_sel sets in power save mode
        constexpr uint32_t LP_OVERLOAD_FREQ_SEL = (1U << 20);  ///< the period of counting the charging times in power save mode 0: eight 32k cycle 1: sixteen 32k cycle
        constexpr uint32_t LP_HIGH_HYS = (1U << 21);  ///< Adjust hysteretic value in low power from 12.5mV to 25mV
        constexpr uint32_t PWD_CMP_OFFSET = (1U << 26);  ///< power down output range comparator
        constexpr uint32_t XTALOK_DISABLE = (1U << 27);  ///< 1'b1: Disable xtalok detection circuit 1'b0: Enable xtalok detection circuit
        constexpr uint32_t CURRENT_ALERT_RESET = (1U << 28);  ///< reset current alert signal
        constexpr uint32_t XTAL_24M_OK = (1U << 29);  ///< set to 1 to switch internal ring osc to xtal 24M
        constexpr uint32_t STS_DC_OK = (1U << 31);  ///< Status register to indicate DCDC status. 1'b1: DCDC already settled 1'b0: DCDC is settling
    }

    /// REG1 Register bits
    namespace reg1_bits {
        constexpr uint32_t REG_FBK_SEL = (2 << 7);  ///< select the feedback point of the internal regulator
        constexpr uint32_t REG_RLOAD_SW = (1U << 9);  ///< control the load resistor of the internal regulator of DCDC, the load resistor is connected as default "1", and need set to "0" to disconnect the load resistor
        constexpr uint32_t LP_CMP_ISRC_SEL = (2 << 12);  ///< set the current bias of low power comparator 0x0: 50 nA 0x1: 100 nA 0x2: 200 nA 0x3: 400 nA
        constexpr uint32_t LOOPCTRL_HST_THRESH = (1U << 21);  ///< increase the threshold detection for common mode analog comparator
        constexpr uint32_t LOOPCTRL_EN_HYST = (1U << 23);  ///< Enable hysteresis in switching converter common mode analog comparators
        constexpr uint32_t VBG_TRIM = (5 << 24);  ///< trim bandgap voltage
    }

    /// REG2 Register bits
    namespace reg2_bits {
        constexpr uint32_t LOOPCTRL_DC_C = (2 << 0);  ///< Ratio of integral control parameter to proportional control parameter in the switching DC-DC converter, and can be used to optimize efficiency and loop response
        constexpr uint32_t LOOPCTRL_DC_R = (4 << 2);  ///< Magnitude of proportional control parameter in the switching DC-DC converter control loop.
        constexpr uint32_t LOOPCTRL_DC_FF = (3 << 6);  ///< Two's complement feed forward step in duty cycle in the switching DC-DC converter
        constexpr uint32_t LOOPCTRL_EN_RCSCALE = (3 << 9);  ///< Enable analog circuit of DC-DC converter to respond faster under transient load conditions.
        constexpr uint32_t LOOPCTRL_RCSCALE_THRSH = (1U << 12);  ///< Increase the threshold detection for RC scale circuit.
        constexpr uint32_t LOOPCTRL_HYST_SIGN = (1U << 13);  ///< Invert the sign of the hysteresis in DC-DC analog comparators.
        constexpr uint32_t DISABLE_PULSE_SKIP = (1U << 27);  ///< Set to "0" : stop charging if the duty cycle is lower than what set by dcdc_neglimit_in
        constexpr uint32_t DCM_SET_CTRL = (1U << 28);  ///< Set high to improve the transition from heavy load to light load
    }

    /// REG3 Register bits
    namespace reg3_bits {
        constexpr uint32_t TRG = (5 << 0);  ///< Target value of VDD_SOC, 25 mV each step 0x0: 0.8V 0xE: 1.15V 0x1F:1.575V
        constexpr uint32_t TARGET_LP = (3 << 8);  ///< Target value of standby (low power) mode 0x0: 0
        constexpr uint32_t MINPWR_DC_HALFCLK = (1U << 24);  ///< Set DCDC clock to half freqeuncy for continuous mode
        constexpr uint32_t MISC_DELAY_TIMING = (1U << 27);  ///< Ajust delay to reduce ground noise
        constexpr uint32_t MISC_DISABLEFET_LOGIC = (1U << 28);  ///< Reserved
        constexpr uint32_t DISABLE_STEP = (1U << 30);  ///< Disable stepping for the output VDD_SOC of DCDC
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT_BASE = 0x40084000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LTMR64H;  ///< Offset: 0xE0 - PIT Upper Lifetime Timer Register
        volatile uint32_t LTMR64L;  ///< Offset: 0xE4 - PIT Lower Lifetime Timer Register
        volatile uint32_t LDVAL;  ///< Offset: 0x00 - Timer Load Value Register
        volatile uint32_t CVAL;  ///< Offset: 0x04 - Current Timer Value Register
        volatile uint32_t TCTRL;  ///< Offset: 0x08 - Timer Control Register
        volatile uint32_t TFLG;  ///< Offset: 0x0C - Timer Flag Register
    };

    /// Peripheral instances
    inline Registers* PIT = reinterpret_cast<Registers*>(PIT_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable - (PIT section)
    }

    /// LTMR64H Register bits
    namespace ltmr64h_bits {
        constexpr uint32_t LTH = (32 << 0);  ///< Life Timer value
    }

    /// LTMR64L Register bits
    namespace ltmr64l_bits {
        constexpr uint32_t LTL = (32 << 0);  ///< Life Timer value
    }

    /// LDVAL Register bits
    namespace ldval_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value
    }

    /// CVAL Register bits
    namespace cval_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL Register bits
    namespace tctrl_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable
        constexpr uint32_t CHN = (1U << 2);  ///< Chain Mode
    }

    /// TFLG Register bits
    namespace tflg_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag
    }

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x40094000;

    /// CMP1 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
    }

}

// ============================================================================
// CMP2 Peripheral
// ============================================================================

namespace cmp2 {
    /// Base addresses
    constexpr uint32_t CMP2_BASE = 0x40094008;

    /// CMP2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CMP2 = reinterpret_cast<Registers*>(CMP2_BASE);

}

// ============================================================================
// CMP3 Peripheral
// ============================================================================

namespace cmp3 {
    /// Base addresses
    constexpr uint32_t CMP3_BASE = 0x40094010;

    /// CMP3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CMP3 = reinterpret_cast<Registers*>(CMP3_BASE);

}

// ============================================================================
// CMP4 Peripheral
// ============================================================================

namespace cmp4 {
    /// Base addresses
    constexpr uint32_t CMP4_BASE = 0x40094018;

    /// CMP4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CMP4 = reinterpret_cast<Registers*>(CMP4_BASE);

}

// ============================================================================
// IOMUXC Peripheral
// ============================================================================

namespace iomuxc {
    /// Base addresses
    constexpr uint32_t IOMUXC_SNVS_GPR_BASE = 0x400A4000;
    constexpr uint32_t IOMUXC_SNVS_BASE = 0x400A8000;
    constexpr uint32_t IOMUXC_GPR_BASE = 0x400AC000;
    constexpr uint32_t IOMUXC_BASE = 0x401F8000;

    /// IOMUXC Register structure
    struct Registers {
        volatile uint32_t GPR0;  ///< Offset: 0x00 - GPR0 General Purpose Register
        volatile uint32_t GPR1;  ///< Offset: 0x04 - GPR1 General Purpose Register
        volatile uint32_t GPR2;  ///< Offset: 0x08 - GPR2 General Purpose Register
        volatile uint32_t GPR3;  ///< Offset: 0x0C - GPR3 General Purpose Register
    };

    /// Peripheral instances
    inline Registers* IOMUXC_SNVS_GPR = reinterpret_cast<Registers*>(IOMUXC_SNVS_GPR_BASE);
    inline Registers* IOMUXC_SNVS = reinterpret_cast<Registers*>(IOMUXC_SNVS_BASE);
    inline Registers* IOMUXC_GPR = reinterpret_cast<Registers*>(IOMUXC_GPR_BASE);
    inline Registers* IOMUXC = reinterpret_cast<Registers*>(IOMUXC_BASE);

    // Bit definitions
    /// GPR3 Register bits
    namespace gpr3_bits {
        constexpr uint32_t LPSR_MODE_ENABLE = (1U << 0);  ///< Set to enable LPSR mode.
        constexpr uint32_t DCDC_STATUS_CAPT_CLR = (1U << 1);  ///< DCDC captured status clear
        constexpr uint32_t POR_PULL_TYPE = (2 << 2);  ///< POR_B pad control
        constexpr uint32_t DCDC_IN_LOW_VOL = (1U << 16);  ///< DCDC_IN low voltage detect.
        constexpr uint32_t DCDC_OVER_CUR = (1U << 17);  ///< DCDC output over current alert
        constexpr uint32_t DCDC_OVER_VOL = (1U << 18);  ///< DCDC output over voltage alert
        constexpr uint32_t DCDC_STS_DC_OK = (1U << 19);  ///< DCDC status OK
    }

}

// ============================================================================
// FLEXRAM Peripheral
// ============================================================================

namespace flexram {
    /// Base addresses
    constexpr uint32_t FLEXRAM_BASE = 0x400B0000;

    /// FLEXRAM Register structure
    struct Registers {
        volatile uint32_t TCM_CTRL;  ///< Offset: 0x00 - TCM CRTL Register
        volatile uint32_t INT_STATUS;  ///< Offset: 0x10 - Interrupt Status Register
        volatile uint32_t INT_STAT_EN;  ///< Offset: 0x14 - Interrupt Status Enable Register
        volatile uint32_t INT_SIG_EN;  ///< Offset: 0x18 - Interrupt Enable Register
    };

    /// Peripheral instances
    inline Registers* FLEXRAM = reinterpret_cast<Registers*>(FLEXRAM_BASE);

    // Bit definitions
    /// TCM_CTRL Register bits
    namespace tcm_ctrl_bits {
        constexpr uint32_t TCM_WWAIT_EN = (1U << 0);  ///< TCM Write Wait Mode Enable
        constexpr uint32_t TCM_RWAIT_EN = (1U << 1);  ///< TCM Read Wait Mode Enable
        constexpr uint32_t FORCE_CLK_ON = (1U << 2);  ///< Force RAM Clock Always On
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t ITCM_ERR_STATUS = (1U << 3);  ///< ITCM Access Error Status
        constexpr uint32_t DTCM_ERR_STATUS = (1U << 4);  ///< DTCM Access Error Status
        constexpr uint32_t OCRAM_ERR_STATUS = (1U << 5);  ///< OCRAM Access Error Status
    }

    /// INT_STAT_EN Register bits
    namespace int_stat_en_bits {
        constexpr uint32_t ITCM_ERR_STAT_EN = (1U << 3);  ///< ITCM Access Error Status Enable
        constexpr uint32_t DTCM_ERR_STAT_EN = (1U << 4);  ///< DTCM Access Error Status Enable
        constexpr uint32_t OCRAM_ERR_STAT_EN = (1U << 5);  ///< OCRAM Access Error Status Enable
    }

    /// INT_SIG_EN Register bits
    namespace int_sig_en_bits {
        constexpr uint32_t ITCM_ERR_SIG_EN = (1U << 3);  ///< ITCM Access Error Interrupt Enable
        constexpr uint32_t DTCM_ERR_SIG_EN = (1U << 4);  ///< DTCM Access Error Interrupt Enable
        constexpr uint32_t OCRAM_ERR_SIG_EN = (1U << 5);  ///< OCRAM Access Error Interrupt Enable
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x400B4000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
        volatile uint32_t CLKCTRL;  ///< Offset: 0x04 - Clock Control Register
        volatile uint32_t CLKPRESCALER;  ///< Offset: 0x05 - Clock Prescaler Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
        constexpr uint32_t INTEN = (1U << 3);  ///< Interrupt Enable.
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< SERVICE
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< COMPAREL
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< COMPAREH
    }

    /// CLKCTRL Register bits
    namespace clkctrl_bits {
        constexpr uint32_t CLKSEL = (2 << 0);  ///< CLKSEL
    }

    /// CLKPRESCALER Register bits
    namespace clkprescaler_bits {
        constexpr uint32_t CLK_DIV = (8 << 0);  ///< CLK_DIV
    }

}

// ============================================================================
// WDOG1 Peripheral
// ============================================================================

namespace wdog1 {
    /// Base addresses
    constexpr uint32_t WDOG1_BASE = 0x400B8000;

    /// WDOG1 Register structure
    struct Registers {
        volatile uint32_t WCR;  ///< Offset: 0x00 - Watchdog Control Register
        volatile uint32_t WSR;  ///< Offset: 0x02 - Watchdog Service Register
        volatile uint32_t WRSR;  ///< Offset: 0x04 - Watchdog Reset Status Register
        volatile uint32_t WICR;  ///< Offset: 0x06 - Watchdog Interrupt Control Register
        volatile uint32_t WMCR;  ///< Offset: 0x08 - Watchdog Miscellaneous Control Register
    };

    /// Peripheral instances
    inline Registers* WDOG1 = reinterpret_cast<Registers*>(WDOG1_BASE);

    // Bit definitions
    /// WCR Register bits
    namespace wcr_bits {
        constexpr uint32_t WDZST = (1U << 0);  ///< Watchdog Low Power
        constexpr uint32_t WDBG = (1U << 1);  ///< Watchdog DEBUG Enable
        constexpr uint32_t WDE = (1U << 2);  ///< Watchdog Enable
        constexpr uint32_t WDT = (1U << 3);  ///< WDOG_B Time-out assertion
        constexpr uint32_t SRS = (1U << 4);  ///< Software Reset Signal
        constexpr uint32_t WDA = (1U << 5);  ///< WDOG_B assertion. Controls the software assertion of the WDOG_B signal.
        constexpr uint32_t SRE = (1U << 6);  ///< software reset extension, an option way to generate software reset.
        constexpr uint32_t WDW = (1U << 7);  ///< Watchdog Disable for Wait
        constexpr uint32_t WT = (8 << 8);  ///< Watchdog Time-out Field
    }

    /// WSR Register bits
    namespace wsr_bits {
        constexpr uint32_t WSR = (16 << 0);  ///< Watchdog Service Register
    }

    /// WRSR Register bits
    namespace wrsr_bits {
        constexpr uint32_t SFTW = (1U << 0);  ///< Software Reset
        constexpr uint32_t TOUT = (1U << 1);  ///< Timeout. Indicates whether the reset is the result of a WDOG timeout.
        constexpr uint32_t POR = (1U << 4);  ///< Power On Reset. Indicates whether the reset is the result of a power on reset.
    }

    /// WICR Register bits
    namespace wicr_bits {
        constexpr uint32_t WICT = (8 << 0);  ///< Watchdog Interrupt Count Time-out (WICT) field determines, how long before the counter time-out must the interrupt occur
        constexpr uint32_t WTIS = (1U << 14);  ///< Watchdog Timer Interrupt Status bit will reflect the timer interrupt status, whether interrupt has occurred or not
        constexpr uint32_t WIE = (1U << 15);  ///< Watchdog Timer Interrupt enable bit
    }

    /// WMCR Register bits
    namespace wmcr_bits {
        constexpr uint32_t PDE = (1U << 0);  ///< Power Down Enable bit
    }

}

// ============================================================================
// WDOG2 Peripheral
// ============================================================================

namespace wdog2 {
    /// Base addresses
    constexpr uint32_t WDOG2_BASE = 0x400D0000;

    /// WDOG2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* WDOG2 = reinterpret_cast<Registers*>(WDOG2_BASE);

}

// ============================================================================
// RTWDOG Peripheral
// ============================================================================

namespace rtwdog {
    /// Base addresses
    constexpr uint32_t RTWDOG_BASE = 0x400BC000;

    /// RTWDOG Register structure
    struct Registers {
        volatile uint32_t CS;  ///< Offset: 0x00 - Watchdog Control and Status Register
        volatile uint32_t CNT;  ///< Offset: 0x04 - Watchdog Counter Register
        volatile uint32_t TOVAL;  ///< Offset: 0x08 - Watchdog Timeout Value Register
        volatile uint32_t WIN;  ///< Offset: 0x0C - Watchdog Window Register
    };

    /// Peripheral instances
    inline Registers* RTWDOG = reinterpret_cast<Registers*>(RTWDOG_BASE);

    // Bit definitions
    /// CS Register bits
    namespace cs_bits {
        constexpr uint32_t STOP = (1U << 0);  ///< Stop Enable
        constexpr uint32_t WAIT = (1U << 1);  ///< Wait Enable
        constexpr uint32_t DBG = (1U << 2);  ///< Debug Enable
        constexpr uint32_t TST = (2 << 3);  ///< Watchdog Test
        constexpr uint32_t UPDATE = (1U << 5);  ///< Allow updates
        constexpr uint32_t INT = (1U << 6);  ///< Watchdog Interrupt
        constexpr uint32_t EN = (1U << 7);  ///< Watchdog Enable
        constexpr uint32_t CLK = (2 << 8);  ///< Watchdog Clock
        constexpr uint32_t RCS = (1U << 10);  ///< Reconfiguration Success
        constexpr uint32_t ULK = (1U << 11);  ///< Unlock status
        constexpr uint32_t PRES = (1U << 12);  ///< Watchdog prescaler
        constexpr uint32_t CMD32EN = (1U << 13);  ///< Enables or disables WDOG support for 32-bit (otherwise 16-bit or 8-bit) refresh/unlock command write words
        constexpr uint32_t FLG = (1U << 14);  ///< Watchdog Interrupt Flag
        constexpr uint32_t WIN = (1U << 15);  ///< Watchdog Window
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNTLOW = (8 << 0);  ///< Low byte of the Watchdog Counter
        constexpr uint32_t CNTHIGH = (8 << 8);  ///< High byte of the Watchdog Counter
    }

    /// TOVAL Register bits
    namespace toval_bits {
        constexpr uint32_t TOVALLOW = (8 << 0);  ///< Low byte of the timeout value
        constexpr uint32_t TOVALHIGH = (8 << 8);  ///< High byte of the timeout value
    }

    /// WIN Register bits
    namespace win_bits {
        constexpr uint32_t WINLOW = (8 << 0);  ///< Low byte of Watchdog Window
        constexpr uint32_t WINHIGH = (8 << 8);  ///< High byte of Watchdog Window
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC1_BASE = 0x400C4000;
    constexpr uint32_t ADC2_BASE = 0x400C8000;
    constexpr uint32_t ADC_ETC_BASE = 0x403B0000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t HC0;  ///< Offset: 0x00 - Control register for hardware triggers
        volatile uint32_t HC%s;  ///< Offset: 0x04 - Control register for hardware triggers
        volatile uint32_t HS;  ///< Offset: 0x20 - Status register for HW triggers
        volatile uint32_t R0;  ///< Offset: 0x24 - Data result register for HW triggers
        volatile uint32_t R%s;  ///< Offset: 0x28 - Data result register for HW triggers
        volatile uint32_t CFG;  ///< Offset: 0x44 - Configuration register
        volatile uint32_t GC;  ///< Offset: 0x48 - General control register
        volatile uint32_t GS;  ///< Offset: 0x4C - General status register
        volatile uint32_t CV;  ///< Offset: 0x50 - Compare value register
        volatile uint32_t OFS;  ///< Offset: 0x54 - Offset correction value register
        volatile uint32_t CAL;  ///< Offset: 0x58 - Calibration value register
    };

    /// Peripheral instances
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* ADC2 = reinterpret_cast<Registers*>(ADC2_BASE);
    inline Registers* ADC_ETC = reinterpret_cast<Registers*>(ADC_ETC_BASE);

    // Bit definitions
    /// HC0 Register bits
    namespace hc0_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input Channel Select
        constexpr uint32_t AIEN = (1U << 7);  ///< Conversion Complete Interrupt Enable/Disable Control
    }

    /// HC%s Register bits
    namespace hc%s_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input Channel Select
        constexpr uint32_t AIEN = (1U << 7);  ///< Conversion Complete Interrupt Enable/Disable Control
    }

    /// HS Register bits
    namespace hs_bits {
        constexpr uint32_t COCO0 = (1U << 0);  ///< Conversion Complete Flag
    }

    /// R0 Register bits
    namespace r0_bits {
        constexpr uint32_t CDATA = (12 << 0);  ///< Data (result of an ADC conversion)
    }

    /// R%s Register bits
    namespace r%s_bits {
        constexpr uint32_t CDATA = (12 << 0);  ///< Data (result of an ADC conversion)
    }

    /// CFG Register bits
    namespace cfg_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion Mode Selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Long Sample Time Configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-Power Configuration
        constexpr uint32_t ADSTS = (2 << 8);  ///< Defines the sample time duration
        constexpr uint32_t ADHSC = (1U << 10);  ///< High Speed Configuration
        constexpr uint32_t REFSEL = (2 << 11);  ///< Voltage Reference Selection
        constexpr uint32_t ADTRG = (1U << 13);  ///< Conversion Trigger Select
        constexpr uint32_t AVGS = (2 << 14);  ///< Hardware Average select
        constexpr uint32_t OVWREN = (1U << 16);  ///< Data Overwrite Enable
    }

    /// GC Register bits
    namespace gc_bits {
        constexpr uint32_t ADACKEN = (1U << 0);  ///< Asynchronous clock output enable
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Enable
        constexpr uint32_t ACREN = (1U << 2);  ///< Compare Function Range Enable
        constexpr uint32_t ACFGT = (1U << 3);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 4);  ///< Compare Function Enable
        constexpr uint32_t AVGE = (1U << 5);  ///< Hardware average enable
        constexpr uint32_t ADCO = (1U << 6);  ///< Continuous Conversion Enable
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// GS Register bits
    namespace gs_bits {
        constexpr uint32_t ADACT = (1U << 0);  ///< Conversion Active
        constexpr uint32_t CALF = (1U << 1);  ///< Calibration Failed Flag
        constexpr uint32_t AWKST = (1U << 2);  ///< Asynchronous wakeup interrupt status
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t CV1 = (12 << 0);  ///< Compare Value 1
        constexpr uint32_t CV2 = (12 << 16);  ///< Compare Value 2
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (12 << 0);  ///< Offset value
        constexpr uint32_t SIGN = (1U << 12);  ///< Sign bit
    }

    /// CAL Register bits
    namespace cal_bits {
        constexpr uint32_t CAL_CODE = (4 << 0);  ///< Calibration Result Value
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t TRNG_BASE = 0x400CC000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t MCTL;  ///< Offset: 0x00 - Miscellaneous Control Register
        volatile uint32_t SCMISC;  ///< Offset: 0x04 - Statistical Check Miscellaneous Register
        volatile uint32_t PKRRNG;  ///< Offset: 0x08 - Poker Range Register
        volatile uint32_t PKRMAX;  ///< Offset: 0x0C - Poker Maximum Limit Register
        volatile uint32_t PKRSQ;  ///< Offset: 0x0C - Poker Square Calculation Result Register
        volatile uint32_t SDCTL;  ///< Offset: 0x10 - Seed Control Register
        volatile uint32_t SBLIM;  ///< Offset: 0x14 - Sparse Bit Limit Register
        volatile uint32_t TOTSAM;  ///< Offset: 0x14 - Total Samples Register
        volatile uint32_t FRQMIN;  ///< Offset: 0x18 - Frequency Count Minimum Limit Register
        volatile uint32_t FRQCNT;  ///< Offset: 0x1C - Frequency Count Register
        volatile uint32_t FRQMAX;  ///< Offset: 0x1C - Frequency Count Maximum Limit Register
        volatile uint32_t SCMC;  ///< Offset: 0x20 - Statistical Check Monobit Count Register
        volatile uint32_t SCML;  ///< Offset: 0x20 - Statistical Check Monobit Limit Register
        volatile uint32_t SCR1C;  ///< Offset: 0x24 - Statistical Check Run Length 1 Count Register
        volatile uint32_t SCR1L;  ///< Offset: 0x24 - Statistical Check Run Length 1 Limit Register
        volatile uint32_t SCR2C;  ///< Offset: 0x28 - Statistical Check Run Length 2 Count Register
        volatile uint32_t SCR2L;  ///< Offset: 0x28 - Statistical Check Run Length 2 Limit Register
        volatile uint32_t SCR3C;  ///< Offset: 0x2C - Statistical Check Run Length 3 Count Register
        volatile uint32_t SCR3L;  ///< Offset: 0x2C - Statistical Check Run Length 3 Limit Register
        volatile uint32_t SCR4C;  ///< Offset: 0x30 - Statistical Check Run Length 4 Count Register
        volatile uint32_t SCR4L;  ///< Offset: 0x30 - Statistical Check Run Length 4 Limit Register
        volatile uint32_t SCR5C;  ///< Offset: 0x34 - Statistical Check Run Length 5 Count Register
        volatile uint32_t SCR5L;  ///< Offset: 0x34 - Statistical Check Run Length 5 Limit Register
        volatile uint32_t SCR6PC;  ///< Offset: 0x38 - Statistical Check Run Length 6+ Count Register
        volatile uint32_t SCR6PL;  ///< Offset: 0x38 - Statistical Check Run Length 6+ Limit Register
        volatile uint32_t STATUS;  ///< Offset: 0x3C - Status Register
        volatile uint32_t ENT[%s];  ///< Offset: 0x40 - Entropy Read Register
        volatile uint32_t PKRCNT10;  ///< Offset: 0x80 - Statistical Check Poker Count 1 and 0 Register
        volatile uint32_t PKRCNT32;  ///< Offset: 0x84 - Statistical Check Poker Count 3 and 2 Register
        volatile uint32_t PKRCNT54;  ///< Offset: 0x88 - Statistical Check Poker Count 5 and 4 Register
        volatile uint32_t PKRCNT76;  ///< Offset: 0x8C - Statistical Check Poker Count 7 and 6 Register
        volatile uint32_t PKRCNT98;  ///< Offset: 0x90 - Statistical Check Poker Count 9 and 8 Register
        volatile uint32_t PKRCNTBA;  ///< Offset: 0x94 - Statistical Check Poker Count B and A Register
        volatile uint32_t PKRCNTDC;  ///< Offset: 0x98 - Statistical Check Poker Count D and C Register
        volatile uint32_t PKRCNTFE;  ///< Offset: 0x9C - Statistical Check Poker Count F and E Register
        volatile uint32_t SEC_CFG;  ///< Offset: 0xA0 - Security Configuration Register
        volatile uint32_t INT_CTRL;  ///< Offset: 0xA4 - Interrupt Control Register
        volatile uint32_t INT_MASK;  ///< Offset: 0xA8 - Mask Register
        volatile uint32_t INT_STATUS;  ///< Offset: 0xAC - Interrupt Status Register
        volatile uint32_t VID1;  ///< Offset: 0xF0 - Version ID Register (MS)
        volatile uint32_t VID2;  ///< Offset: 0xF4 - Version ID Register (LS)
    };

    /// Peripheral instances
    inline Registers* TRNG = reinterpret_cast<Registers*>(TRNG_BASE);

    // Bit definitions
    /// MCTL Register bits
    namespace mctl_bits {
        constexpr uint32_t SAMP_MODE = (2 << 0);  ///< Sample Mode
        constexpr uint32_t OSC_DIV = (2 << 2);  ///< Oscillator Divide
        constexpr uint32_t UNUSED4 = (1U << 4);  ///< This bit is unused. Always reads zero.
        constexpr uint32_t UNUSED5 = (1U << 5);  ///< This bit is unused. Always reads zero.
        constexpr uint32_t RST_DEF = (1U << 6);  ///< Reset Defaults
        constexpr uint32_t FOR_SCLK = (1U << 7);  ///< Force System Clock
        constexpr uint32_t FCT_FAIL = (1U << 8);  ///< Read only: Frequency Count Fail
        constexpr uint32_t FCT_VAL = (1U << 9);  ///< Read only: Frequency Count Valid. Indicates that a valid frequency count may be read from FRQCNT.
        constexpr uint32_t ENT_VAL = (1U << 10);  ///< Read only: Entropy Valid
        constexpr uint32_t TST_OUT = (1U << 11);  ///< Read only: Test point inside ring oscillator.
        constexpr uint32_t ERR = (1U << 12);  ///< Read: Error status
        constexpr uint32_t TSTOP_OK = (1U << 13);  ///< TRNG_OK_TO_STOP
        constexpr uint32_t LRUN_CONT = (1U << 14);  ///< Long run count continues between entropy generations
        constexpr uint32_t PRGM = (1U << 16);  ///< Programming Mode Select
    }

    /// SCMISC Register bits
    namespace scmisc_bits {
        constexpr uint32_t LRUN_MAX = (8 << 0);  ///< LONG RUN MAX LIMIT
        constexpr uint32_t RTY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// PKRRNG Register bits
    namespace pkrrng_bits {
        constexpr uint32_t PKR_RNG = (16 << 0);  ///< Poker Range
    }

    /// PKRMAX Register bits
    namespace pkrmax_bits {
        constexpr uint32_t PKR_MAX = (24 << 0);  ///< Poker Maximum Limit.
    }

    /// PKRSQ Register bits
    namespace pkrsq_bits {
        constexpr uint32_t PKR_SQ = (24 << 0);  ///< Poker Square Calculation Result.
    }

    /// SDCTL Register bits
    namespace sdctl_bits {
        constexpr uint32_t SAMP_SIZE = (16 << 0);  ///< Sample Size
        constexpr uint32_t ENT_DLY = (16 << 16);  ///< Entropy Delay
    }

    /// SBLIM Register bits
    namespace sblim_bits {
        constexpr uint32_t SB_LIM = (10 << 0);  ///< Sparse Bit Limit
    }

    /// TOTSAM Register bits
    namespace totsam_bits {
        constexpr uint32_t TOT_SAM = (20 << 0);  ///< Total Samples
    }

    /// FRQMIN Register bits
    namespace frqmin_bits {
        constexpr uint32_t FRQ_MIN = (22 << 0);  ///< Frequency Count Minimum Limit
    }

    /// FRQCNT Register bits
    namespace frqcnt_bits {
        constexpr uint32_t FRQ_CT = (22 << 0);  ///< Frequency Count
    }

    /// FRQMAX Register bits
    namespace frqmax_bits {
        constexpr uint32_t FRQ_MAX = (22 << 0);  ///< Frequency Counter Maximum Limit
    }

    /// SCMC Register bits
    namespace scmc_bits {
        constexpr uint32_t MONO_CT = (16 << 0);  ///< Monobit Count
    }

    /// SCML Register bits
    namespace scml_bits {
        constexpr uint32_t MONO_MAX = (16 << 0);  ///< Monobit Maximum Limit
        constexpr uint32_t MONO_RNG = (16 << 16);  ///< Monobit Range
    }

    /// SCR1C Register bits
    namespace scr1c_bits {
        constexpr uint32_t R1_0_CT = (15 << 0);  ///< Runs of Zero, Length 1 Count
        constexpr uint32_t R1_1_CT = (15 << 16);  ///< Runs of One, Length 1 Count
    }

    /// SCR1L Register bits
    namespace scr1l_bits {
        constexpr uint32_t RUN1_MAX = (15 << 0);  ///< Run Length 1 Maximum Limit
        constexpr uint32_t RUN1_RNG = (15 << 16);  ///< Run Length 1 Range
    }

    /// SCR2C Register bits
    namespace scr2c_bits {
        constexpr uint32_t R2_0_CT = (14 << 0);  ///< Runs of Zero, Length 2 Count
        constexpr uint32_t R2_1_CT = (14 << 16);  ///< Runs of One, Length 2 Count
    }

    /// SCR2L Register bits
    namespace scr2l_bits {
        constexpr uint32_t RUN2_MAX = (14 << 0);  ///< Run Length 2 Maximum Limit
        constexpr uint32_t RUN2_RNG = (14 << 16);  ///< Run Length 2 Range
    }

    /// SCR3C Register bits
    namespace scr3c_bits {
        constexpr uint32_t R3_0_CT = (13 << 0);  ///< Runs of Zeroes, Length 3 Count
        constexpr uint32_t R3_1_CT = (13 << 16);  ///< Runs of Ones, Length 3 Count
    }

    /// SCR3L Register bits
    namespace scr3l_bits {
        constexpr uint32_t RUN3_MAX = (13 << 0);  ///< Run Length 3 Maximum Limit
        constexpr uint32_t RUN3_RNG = (13 << 16);  ///< Run Length 3 Range
    }

    /// SCR4C Register bits
    namespace scr4c_bits {
        constexpr uint32_t R4_0_CT = (12 << 0);  ///< Runs of Zero, Length 4 Count
        constexpr uint32_t R4_1_CT = (12 << 16);  ///< Runs of One, Length 4 Count
    }

    /// SCR4L Register bits
    namespace scr4l_bits {
        constexpr uint32_t RUN4_MAX = (12 << 0);  ///< Run Length 4 Maximum Limit
        constexpr uint32_t RUN4_RNG = (12 << 16);  ///< Run Length 4 Range
    }

    /// SCR5C Register bits
    namespace scr5c_bits {
        constexpr uint32_t R5_0_CT = (11 << 0);  ///< Runs of Zero, Length 5 Count
        constexpr uint32_t R5_1_CT = (11 << 16);  ///< Runs of One, Length 5 Count
    }

    /// SCR5L Register bits
    namespace scr5l_bits {
        constexpr uint32_t RUN5_MAX = (11 << 0);  ///< Run Length 5 Maximum Limit
        constexpr uint32_t RUN5_RNG = (11 << 16);  ///< Run Length 5 Range
    }

    /// SCR6PC Register bits
    namespace scr6pc_bits {
        constexpr uint32_t R6P_0_CT = (11 << 0);  ///< Runs of Zero, Length 6+ Count
        constexpr uint32_t R6P_1_CT = (11 << 16);  ///< Runs of One, Length 6+ Count
    }

    /// SCR6PL Register bits
    namespace scr6pl_bits {
        constexpr uint32_t RUN6P_MAX = (11 << 0);  ///< Run Length 6+ Maximum Limit
        constexpr uint32_t RUN6P_RNG = (11 << 16);  ///< Run Length 6+ Range
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t TF1BR0 = (1U << 0);  ///< Test Fail, 1-Bit Run, Sampling 0s. If TF1BR0=1, the 1-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF1BR1 = (1U << 1);  ///< Test Fail, 1-Bit Run, Sampling 1s. If TF1BR1=1, the 1-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF2BR0 = (1U << 2);  ///< Test Fail, 2-Bit Run, Sampling 0s. If TF2BR0=1, the 2-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF2BR1 = (1U << 3);  ///< Test Fail, 2-Bit Run, Sampling 1s. If TF2BR1=1, the 2-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF3BR0 = (1U << 4);  ///< Test Fail, 3-Bit Run, Sampling 0s. If TF3BR0=1, the 3-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF3BR1 = (1U << 5);  ///< Test Fail, 3-Bit Run, Sampling 1s. If TF3BR1=1, the 3-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF4BR0 = (1U << 6);  ///< Test Fail, 4-Bit Run, Sampling 0s. If TF4BR0=1, the 4-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF4BR1 = (1U << 7);  ///< Test Fail, 4-Bit Run, Sampling 1s. If TF4BR1=1, the 4-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF5BR0 = (1U << 8);  ///< Test Fail, 5-Bit Run, Sampling 0s. If TF5BR0=1, the 5-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF5BR1 = (1U << 9);  ///< Test Fail, 5-Bit Run, Sampling 1s. If TF5BR1=1, the 5-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF6PBR0 = (1U << 10);  ///< Test Fail, 6 Plus Bit Run, Sampling 0s
        constexpr uint32_t TF6PBR1 = (1U << 11);  ///< Test Fail, 6 Plus Bit Run, Sampling 1s
        constexpr uint32_t TFSB = (1U << 12);  ///< Test Fail, Sparse Bit. If TFSB=1, the Sparse Bit Test has failed.
        constexpr uint32_t TFLR = (1U << 13);  ///< Test Fail, Long Run. If TFLR=1, the Long Run Test has failed.
        constexpr uint32_t TFP = (1U << 14);  ///< Test Fail, Poker. If TFP=1, the Poker Test has failed.
        constexpr uint32_t TFMB = (1U << 15);  ///< Test Fail, Mono Bit. If TFMB=1, the Mono Bit Test has failed.
        constexpr uint32_t RETRY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// ENT[%s] Register bits
    namespace ent[%s]_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// PKRCNT10 Register bits
    namespace pkrcnt10_bits {
        constexpr uint32_t PKR_0_CT = (16 << 0);  ///< Poker 0h Count
        constexpr uint32_t PKR_1_CT = (16 << 16);  ///< Poker 1h Count
    }

    /// PKRCNT32 Register bits
    namespace pkrcnt32_bits {
        constexpr uint32_t PKR_2_CT = (16 << 0);  ///< Poker 2h Count
        constexpr uint32_t PKR_3_CT = (16 << 16);  ///< Poker 3h Count
    }

    /// PKRCNT54 Register bits
    namespace pkrcnt54_bits {
        constexpr uint32_t PKR_4_CT = (16 << 0);  ///< Poker 4h Count
        constexpr uint32_t PKR_5_CT = (16 << 16);  ///< Poker 5h Count
    }

    /// PKRCNT76 Register bits
    namespace pkrcnt76_bits {
        constexpr uint32_t PKR_6_CT = (16 << 0);  ///< Poker 6h Count
        constexpr uint32_t PKR_7_CT = (16 << 16);  ///< Poker 7h Count
    }

    /// PKRCNT98 Register bits
    namespace pkrcnt98_bits {
        constexpr uint32_t PKR_8_CT = (16 << 0);  ///< Poker 8h Count
        constexpr uint32_t PKR_9_CT = (16 << 16);  ///< Poker 9h Count
    }

    /// PKRCNTBA Register bits
    namespace pkrcntba_bits {
        constexpr uint32_t PKR_A_CT = (16 << 0);  ///< Poker Ah Count
        constexpr uint32_t PKR_B_CT = (16 << 16);  ///< Poker Bh Count
    }

    /// PKRCNTDC Register bits
    namespace pkrcntdc_bits {
        constexpr uint32_t PKR_C_CT = (16 << 0);  ///< Poker Ch Count
        constexpr uint32_t PKR_D_CT = (16 << 16);  ///< Poker Dh Count
    }

    /// PKRCNTFE Register bits
    namespace pkrcntfe_bits {
        constexpr uint32_t PKR_E_CT = (16 << 0);  ///< Poker Eh Count
        constexpr uint32_t PKR_F_CT = (16 << 16);  ///< Poker Fh Count
    }

    /// SEC_CFG Register bits
    namespace sec_cfg_bits {
        constexpr uint32_t UNUSED0 = (1U << 0);  ///< This bit is unused. Ignore.
        constexpr uint32_t NO_PRGM = (1U << 1);  ///< If set, the TRNG registers cannot be programmed
        constexpr uint32_t UNUSED2 = (1U << 2);  ///< This bit is unused. Ignore.
    }

    /// INT_CTRL Register bits
    namespace int_ctrl_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS register has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 of this register.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 of this register.
    }

    /// INT_MASK Register bits
    namespace int_mask_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 of this register.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 of this register.
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Read: Error status
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Read only: Entropy Valid
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Read only: Frequency Count Fail
    }

    /// VID1 Register bits
    namespace vid1_bits {
        constexpr uint32_t MIN_REV = (8 << 0);  ///< Shows the IP's Minor revision of the TRNG.
        constexpr uint32_t MAJ_REV = (8 << 8);  ///< Shows the IP's Major revision of the TRNG.
        constexpr uint32_t IP_ID = (16 << 16);  ///< Shows the IP ID.
    }

    /// VID2 Register bits
    namespace vid2_bits {
        constexpr uint32_t CONFIG_OPT = (8 << 0);  ///< Shows the IP's Configuaration options for the TRNG.
        constexpr uint32_t ECO_REV = (8 << 8);  ///< Shows the IP's ECO revision of the TRNG.
        constexpr uint32_t INTG_OPT = (8 << 16);  ///< Shows the integration options for the TRNG.
        constexpr uint32_t ERA = (8 << 24);  ///< Shows the compile options for the TRNG.
    }

}

// ============================================================================
// SNVS Peripheral
// ============================================================================

namespace snvs {
    /// Base addresses
    constexpr uint32_t SNVS_BASE = 0x400D4000;

    /// SNVS Register structure
    struct Registers {
        volatile uint32_t HPLR;  ///< Offset: 0x00 - SNVS_HP Lock Register
        volatile uint32_t HPCOMR;  ///< Offset: 0x04 - SNVS_HP Command Register
        volatile uint32_t HPCR;  ///< Offset: 0x08 - SNVS_HP Control Register
        volatile uint32_t HPSICR;  ///< Offset: 0x0C - SNVS_HP Security Interrupt Control Register
        volatile uint32_t HPSVCR;  ///< Offset: 0x10 - SNVS_HP Security Violation Control Register
        volatile uint32_t HPSR;  ///< Offset: 0x14 - SNVS_HP Status Register
        volatile uint32_t HPSVSR;  ///< Offset: 0x18 - SNVS_HP Security Violation Status Register
        volatile uint32_t HPHACIVR;  ///< Offset: 0x1C - SNVS_HP High Assurance Counter IV Register
        volatile uint32_t HPHACR;  ///< Offset: 0x20 - SNVS_HP High Assurance Counter Register
        volatile uint32_t HPRTCMR;  ///< Offset: 0x24 - SNVS_HP Real Time Counter MSB Register
        volatile uint32_t HPRTCLR;  ///< Offset: 0x28 - SNVS_HP Real Time Counter LSB Register
        volatile uint32_t HPTAMR;  ///< Offset: 0x2C - SNVS_HP Time Alarm MSB Register
        volatile uint32_t HPTALR;  ///< Offset: 0x30 - SNVS_HP Time Alarm LSB Register
        volatile uint32_t LPLR;  ///< Offset: 0x34 - SNVS_LP Lock Register
        volatile uint32_t LPCR;  ///< Offset: 0x38 - SNVS_LP Control Register
        volatile uint32_t LPMKCR;  ///< Offset: 0x3C - SNVS_LP Master Key Control Register
        volatile uint32_t LPSVCR;  ///< Offset: 0x40 - SNVS_LP Security Violation Control Register
        volatile uint32_t LPTDCR;  ///< Offset: 0x48 - SNVS_LP Tamper Detectors Configuration Register
        volatile uint32_t LPSR;  ///< Offset: 0x4C - SNVS_LP Status Register
        volatile uint32_t LPSRTCMR;  ///< Offset: 0x50 - SNVS_LP Secure Real Time Counter MSB Register
        volatile uint32_t LPSRTCLR;  ///< Offset: 0x54 - SNVS_LP Secure Real Time Counter LSB Register
        volatile uint32_t LPTAR;  ///< Offset: 0x58 - SNVS_LP Time Alarm Register
        volatile uint32_t LPSMCMR;  ///< Offset: 0x5C - SNVS_LP Secure Monotonic Counter MSB Register
        volatile uint32_t LPSMCLR;  ///< Offset: 0x60 - SNVS_LP Secure Monotonic Counter LSB Register
        volatile uint32_t LPPGDR;  ///< Offset: 0x64 - SNVS_LP Power Glitch Detector Register
        volatile uint32_t LPGPR0_legacy_alias;  ///< Offset: 0x68 - SNVS_LP General Purpose Register 0 (legacy alias)
        volatile uint32_t LPZMKR[%s];  ///< Offset: 0x6C - SNVS_LP Zeroizable Master Key Register
        volatile uint32_t LPGPR_alias[%s];  ///< Offset: 0x90 - SNVS_LP General Purpose Registers 0 .. 3
        volatile uint32_t LPGPR[%s];  ///< Offset: 0x100 - SNVS_LP General Purpose Registers 0 .. 7
        volatile uint32_t HPVIDR1;  ///< Offset: 0xBF8 - SNVS_HP Version ID Register 1
        volatile uint32_t HPVIDR2;  ///< Offset: 0xBFC - SNVS_HP Version ID Register 2
    };

    /// Peripheral instances
    inline Registers* SNVS = reinterpret_cast<Registers*>(SNVS_BASE);

    // Bit definitions
    /// HPLR Register bits
    namespace hplr_bits {
        constexpr uint32_t ZMK_WSL = (1U << 0);  ///< Zeroizable Master Key Write Soft Lock When set, prevents any writes (software and hardware) to the ZMK registers and the ZMK_HWP, ZMK_VAL, and ZMK_ECC_EN fields of the LPMKCR
        constexpr uint32_t ZMK_RSL = (1U << 1);  ///< Zeroizable Master Key Read Soft Lock When set, prevents any software reads to the ZMK Registers and ZMK_ECC_VALUE field of the LPMKCR
        constexpr uint32_t SRTC_SL = (1U << 2);  ///< Secure Real Time Counter Soft Lock When set, prevents any writes to the SRTC Registers, SRTC_ENV, and SRTC_INV_EN bits
        constexpr uint32_t LPCALB_SL = (1U << 3);  ///< LP Calibration Soft Lock When set, prevents any writes to the LP Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
        constexpr uint32_t MC_SL = (1U << 4);  ///< Monotonic Counter Soft Lock When set, prevents any writes (increments) to the MC Registers and MC_ENV bit
        constexpr uint32_t GPR_SL = (1U << 5);  ///< General Purpose Register Soft Lock When set, prevents any writes to the GPR
        constexpr uint32_t LPSVCR_SL = (1U << 6);  ///< LP Security Violation Control Register Soft Lock When set, prevents any writes to the LPSVCR
        constexpr uint32_t LPTDCR_SL = (1U << 8);  ///< LP Tamper Detectors Configuration Register Soft Lock When set, prevents any writes to the LPTDCR
        constexpr uint32_t MKS_SL = (1U << 9);  ///< Master Key Select Soft Lock When set, prevents any writes to the MASTER_KEY_SEL field of the LPMKCR
        constexpr uint32_t HPSVCR_L = (1U << 16);  ///< HP Security Violation Control Register Lock When set, prevents any writes to the HPSVCR
        constexpr uint32_t HPSICR_L = (1U << 17);  ///< HP Security Interrupt Control Register Lock When set, prevents any writes to the HPSICR
        constexpr uint32_t HAC_L = (1U << 18);  ///< High Assurance Counter Lock When set, prevents any writes to HPHACIVR, HPHACR, and HAC_EN bit of HPCOMR
    }

    /// HPCOMR Register bits
    namespace hpcomr_bits {
        constexpr uint32_t SSM_ST = (1U << 0);  ///< SSM State Transition Transition state of the system security monitor
        constexpr uint32_t SSM_ST_DIS = (1U << 1);  ///< SSM Secure to Trusted State Transition Disable When set, disables the SSM transition from secure to trusted state
        constexpr uint32_t SSM_SFNS_DIS = (1U << 2);  ///< SSM Soft Fail to Non-Secure State Transition Disable When set, it disables the SSM transition from soft fail to non-secure state
        constexpr uint32_t LP_SWR = (1U << 4);  ///< LP Software Reset When set to 1, most registers in the SNVS_LP section are reset, but the following registers are not reset by an LP software reset: Secure Real Time Counter Time Alarm Register This bit cannot be set when the LP_SWR_DIS bit is set
        constexpr uint32_t LP_SWR_DIS = (1U << 5);  ///< LP Software Reset Disable When set, disables the LP software reset
        constexpr uint32_t SW_SV = (1U << 8);  ///< Software Security Violation When set, the system security monitor treats this bit as a non-fatal security violation
        constexpr uint32_t SW_FSV = (1U << 9);  ///< Software Fatal Security Violation When set, the system security monitor treats this bit as a fatal security violation
        constexpr uint32_t SW_LPSV = (1U << 10);  ///< LP Software Security Violation When set, SNVS_LP treats this bit as a security violation
        constexpr uint32_t PROG_ZMK = (1U << 12);  ///< Program Zeroizable Master Key This bit activates ZMK hardware programming mechanism
        constexpr uint32_t MKS_EN = (1U << 13);  ///< Master Key Select Enable When not set, the one time programmable (OTP) master key is selected by default
        constexpr uint32_t HAC_EN = (1U << 16);  ///< High Assurance Counter Enable This bit controls the SSM transition from the soft fail to the hard fail state
        constexpr uint32_t HAC_LOAD = (1U << 17);  ///< High Assurance Counter Load When set, it loads the High Assurance Counter Register with the value of the High Assurance Counter Load Register
        constexpr uint32_t HAC_CLEAR = (1U << 18);  ///< High Assurance Counter Clear When set, it clears the High Assurance Counter Register
        constexpr uint32_t HAC_STOP = (1U << 19);  ///< High Assurance Counter Stop This bit can be set only when SSM is in soft fail state
        constexpr uint32_t NPSWA_EN = (1U << 31);  ///< Non-Privileged Software Access Enable When set, allows non-privileged software to access all SNVS registers, including those that are privileged software read/write access only
    }

    /// HPCR Register bits
    namespace hpcr_bits {
        constexpr uint32_t RTC_EN = (1U << 0);  ///< HP Real Time Counter Enable
        constexpr uint32_t HPTA_EN = (1U << 1);  ///< HP Time Alarm Enable When set, the time alarm interrupt is generated if the value in the HP Time Alarm Registers is equal to the value of the HP Real Time Counter
        constexpr uint32_t DIS_PI = (1U << 2);  ///< Disable periodic interrupt in the functional interrupt
        constexpr uint32_t PI_EN = (1U << 3);  ///< HP Periodic Interrupt Enable The periodic interrupt can be generated only if the HP Real Time Counter is enabled
        constexpr uint32_t PI_FREQ = (4 << 4);  ///< Periodic Interrupt Frequency Defines frequency of the periodic interrupt
        constexpr uint32_t HPCALB_EN = (1U << 8);  ///< HP Real Time Counter Calibration Enabled Indicates that the time calibration mechanism is enabled.
        constexpr uint32_t HPCALB_VAL = (5 << 10);  ///< HP Calibration Value Defines signed calibration value for the HP Real Time Counter
        constexpr uint32_t HP_TS = (1U << 16);  ///< HP Time Synchronize
        constexpr uint32_t BTN_CONFIG = (3 << 24);  ///< Button Configuration
        constexpr uint32_t BTN_MASK = (1U << 27);  ///< Button interrupt mask
    }

    /// HPSICR Register bits
    namespace hpsicr_bits {
        constexpr uint32_t SV0_EN = (1U << 0);  ///< Security Violation 0 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 0 security violation
        constexpr uint32_t SV1_EN = (1U << 1);  ///< Security Violation 1 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 1 security violation
        constexpr uint32_t SV2_EN = (1U << 2);  ///< Security Violation 2 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 2 security violation
        constexpr uint32_t SV3_EN = (1U << 3);  ///< Security Violation 3 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 3 security violation
        constexpr uint32_t SV4_EN = (1U << 4);  ///< Security Violation 4 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 4 security violation
        constexpr uint32_t SV5_EN = (1U << 5);  ///< Security Violation 5 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 5 security violation
        constexpr uint32_t LPSVI_EN = (1U << 31);  ///< LP Security Violation Interrupt Enable This bit enables generating of the security interrupt to the host processor upon security violation signal from the LP section
    }

    /// HPSVCR Register bits
    namespace hpsvcr_bits {
        constexpr uint32_t SV0_CFG = (1U << 0);  ///< Security Violation 0 Security Violation Configuration This field configures the Security Violation 0 Security Violation Input
        constexpr uint32_t SV1_CFG = (1U << 1);  ///< Security Violation 1 Security Violation Configuration This field configures the Security Violation 1 Security Violation Input
        constexpr uint32_t SV2_CFG = (1U << 2);  ///< Security Violation 2 Security Violation Configuration This field configures the Security Violation 2 Security Violation Input
        constexpr uint32_t SV3_CFG = (1U << 3);  ///< Security Violation 3 Security Violation Configuration This field configures the Security Violation 3 Security Violation Input
        constexpr uint32_t SV4_CFG = (1U << 4);  ///< Security Violation 4 Security Violation Configuration This field configures the Security Violation 4 Security Violation Input
        constexpr uint32_t SV5_CFG = (2 << 5);  ///< Security Violation 5 Security Violation Configuration This field configures the Security Violation 5 Security Violation Input
        constexpr uint32_t LPSV_CFG = (2 << 30);  ///< LP Security Violation Configuration This field configures the LP security violation source.
    }

    /// HPSR Register bits
    namespace hpsr_bits {
        constexpr uint32_t HPTA = (1U << 0);  ///< HP Time Alarm Indicates that the HP Time Alarm has occurred since this bit was last cleared.
        constexpr uint32_t PI = (1U << 1);  ///< Periodic Interrupt Indicates that periodic interrupt has occurred since this bit was last cleared.
        constexpr uint32_t LPDIS = (1U << 4);  ///< Low Power Disable If 1, the low power section has been disabled by means of an input signal to SNVS
        constexpr uint32_t BTN = (1U << 6);  ///< Button Value of the BTN input
        constexpr uint32_t BI = (1U << 7);  ///< Button Interrupt Signal ipi_snvs_btn_int_b was asserted.
        constexpr uint32_t SSM_STATE = (4 << 8);  ///< System Security Monitor State This field contains the encoded state of the SSM's state machine
        constexpr uint32_t SECURITY_CONFIG = (4 << 12);  ///< Security Configuration This field reflects the settings of the sys_secure_boot input and the three security configuration inputs to SNVS
        constexpr uint32_t OTPMK_SYNDROME = (9 << 16);  ///< One Time Programmable Master Key Syndrome In the case of a single-bit error, the eight lower bits of this value indicate the bit number of error location
        constexpr uint32_t OTPMK_ZERO = (1U << 27);  ///< One Time Programmable Master Key is Equal to Zero
        constexpr uint32_t ZMK_ZERO = (1U << 31);  ///< Zeroizable Master Key is Equal to Zero
    }

    /// HPSVSR Register bits
    namespace hpsvsr_bits {
        constexpr uint32_t SV0 = (1U << 0);  ///< Security Violation 0 security violation was detected.
        constexpr uint32_t SV1 = (1U << 1);  ///< Security Violation 1 security violation was detected.
        constexpr uint32_t SV2 = (1U << 2);  ///< Security Violation 2 security violation was detected.
        constexpr uint32_t SV3 = (1U << 3);  ///< Security Violation 3 security violation was detected.
        constexpr uint32_t SV4 = (1U << 4);  ///< Security Violation 4 security violation was detected.
        constexpr uint32_t SV5 = (1U << 5);  ///< Security Violation 5 security violation was detected.
        constexpr uint32_t SW_SV = (1U << 13);  ///< Software Security Violation This bit is a read-only copy of the SW_SV bit in the HP Command Register
        constexpr uint32_t SW_FSV = (1U << 14);  ///< Software Fatal Security Violation This bit is a read-only copy of the SW_FSV bit in the HP Command Register
        constexpr uint32_t SW_LPSV = (1U << 15);  ///< LP Software Security Violation This bit is a read-only copy of the SW_LPSV bit in the HP Command Register
        constexpr uint32_t ZMK_SYNDROME = (9 << 16);  ///< Zeroizable Master Key Syndrome The ZMK syndrome indicates the single-bit error location and parity for the ZMK register
        constexpr uint32_t ZMK_ECC_FAIL = (1U << 27);  ///< Zeroizable Master Key Error Correcting Code Check Failure When set, this bit triggers a bad key violation to the SSM and a security violation to the SNVS_LP section, which clears security sensitive data
        constexpr uint32_t LP_SEC_VIO = (1U << 31);  ///< LP Security Violation A security volation was detected in the SNVS low power section.
    }

    /// HPHACIVR Register bits
    namespace hphacivr_bits {
        constexpr uint32_t HAC_COUNTER_IV = (32 << 0);  ///< High Assurance Counter Initial Value This register is used to set the starting count value to the high assurance counter
    }

    /// HPHACR Register bits
    namespace hphacr_bits {
        constexpr uint32_t HAC_COUNTER = (32 << 0);  ///< High Assurance Counter When the HAC_EN bit is set and the SSM is in the soft fail state, this counter starts to count down with the system clock
    }

    /// HPRTCMR Register bits
    namespace hprtcmr_bits {
        constexpr uint32_t RTC = (15 << 0);  ///< HP Real Time Counter The most-significant 15 bits of the RTC
    }

    /// HPRTCLR Register bits
    namespace hprtclr_bits {
        constexpr uint32_t RTC = (32 << 0);  ///< HP Real Time Counter least-significant 32 bits
    }

    /// HPTAMR Register bits
    namespace hptamr_bits {
        constexpr uint32_t HPTA_MS = (15 << 0);  ///< HP Time Alarm, most-significant 15 bits
    }

    /// HPTALR Register bits
    namespace hptalr_bits {
        constexpr uint32_t HPTA_LS = (32 << 0);  ///< HP Time Alarm, 32 least-significant bits
    }

    /// LPLR Register bits
    namespace lplr_bits {
        constexpr uint32_t ZMK_WHL = (1U << 0);  ///< Zeroizable Master Key Write Hard Lock When set, prevents any writes (software and hardware) to the ZMK registers and ZMK_HWP, ZMK_VAL, and ZMK_ECC_EN fields of the LPMKCR
        constexpr uint32_t ZMK_RHL = (1U << 1);  ///< Zeroizable Master Key Read Hard Lock When set, prevents any software reads to the ZMK registers and ZMK_ECC_VALUE field of the LPMKCR
        constexpr uint32_t SRTC_HL = (1U << 2);  ///< Secure Real Time Counter Hard Lock When set, prevents any writes to the SRTC registers, SRTC_ENV, and SRTC_INV_EN bits
        constexpr uint32_t LPCALB_HL = (1U << 3);  ///< LP Calibration Hard Lock When set, prevents any writes to the LP Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
        constexpr uint32_t MC_HL = (1U << 4);  ///< Monotonic Counter Hard Lock When set, prevents any writes (increments) to the MC Registers and MC_ENV bit
        constexpr uint32_t GPR_HL = (1U << 5);  ///< General Purpose Register Hard Lock When set, prevents any writes to the GPR
        constexpr uint32_t LPSVCR_HL = (1U << 6);  ///< LP Security Violation Control Register Hard Lock When set, prevents any writes to the LPSVCR
        constexpr uint32_t LPTDCR_HL = (1U << 8);  ///< LP Tamper Detectors Configuration Register Hard Lock When set, prevents any writes to the LPTDCR
        constexpr uint32_t MKS_HL = (1U << 9);  ///< Master Key Select Hard Lock When set, prevents any writes to the MASTER_KEY_SEL field of the LP Master Key Control Register
    }

    /// LPCR Register bits
    namespace lpcr_bits {
        constexpr uint32_t SRTC_ENV = (1U << 0);  ///< Secure Real Time Counter Enabled and Valid When set, the SRTC becomes operational
        constexpr uint32_t LPTA_EN = (1U << 1);  ///< LP Time Alarm Enable When set, the SNVS functional interrupt is asserted if the LP Time Alarm Register is equal to the 32 MSBs of the secure real time counter
        constexpr uint32_t MC_ENV = (1U << 2);  ///< Monotonic Counter Enabled and Valid When set, the MC can be incremented (by write transaction to the LPSMCMR or LPSMCLR)
        constexpr uint32_t LPWUI_EN = (1U << 3);  ///< LP Wake-Up Interrupt Enable This interrupt line should be connected to the external pin and is intended to inform the external chip about an SNVS_LP event (tamper event, MC rollover, SRTC rollover, or time alarm )
        constexpr uint32_t SRTC_INV_EN = (1U << 4);  ///< If this bit is 1, in the case of a security violation the SRTC stops counting and the SRTC is invalidated (SRTC_ENV bit is cleared)
        constexpr uint32_t DP_EN = (1U << 5);  ///< Dumb PMIC Enabled When set, software can control the system power
        constexpr uint32_t TOP = (1U << 6);  ///< Turn off System Power Asserting this bit causes a signal to be sent to the Power Management IC to turn off the system power
        constexpr uint32_t PWR_GLITCH_EN = (1U << 7);  ///< Power Glitch Enable By default the detection of a power glitch does not cause the pmic_en_b signal to be asserted
        constexpr uint32_t LPCALB_EN = (1U << 8);  ///< LP Calibration Enable When set, enables the SRTC calibration mechanism
        constexpr uint32_t LPCALB_VAL = (5 << 10);  ///< LP Calibration Value Defines signed calibration value for SRTC
        constexpr uint32_t BTN_PRESS_TIME = (2 << 16);  ///< This field configures the button press time out values for the PMIC Logic
        constexpr uint32_t DEBOUNCE = (2 << 18);  ///< This field configures the amount of debounce time for the BTN input signal
        constexpr uint32_t ON_TIME = (2 << 20);  ///< The ON_TIME field is used to configure the period of time after BTN is asserted before pmic_en_b is asserted to turn on the SoC power
        constexpr uint32_t PK_EN = (1U << 22);  ///< PMIC On Request Enable The value written to PK_EN will be asserted on output signal snvs_lp_pk_en
        constexpr uint32_t PK_OVERRIDE = (1U << 23);  ///< PMIC On Request Override The value written to PK_OVERRIDE will be asserted on output signal snvs_lp_pk_override
        constexpr uint32_t GPR_Z_DIS = (1U << 24);  ///< General Purpose Registers Zeroization Disable
    }

    /// LPMKCR Register bits
    namespace lpmkcr_bits {
        constexpr uint32_t MASTER_KEY_SEL = (2 << 0);  ///< Master Key Select These bits select the SNVS Master Key output when Master Key Select bits are enabled by MKS_EN bit in the HPCOMR
        constexpr uint32_t ZMK_HWP = (1U << 2);  ///< Zeroizable Master Key hardware Programming mode When set, only the hardware key programming mechanism can set the ZMK and software cannot read it
        constexpr uint32_t ZMK_VAL = (1U << 3);  ///< Zeroizable Master Key Valid When set, the ZMK value can be selected by the master key control block for use by cryptographic modules
        constexpr uint32_t ZMK_ECC_EN = (1U << 4);  ///< Zeroizable Master Key Error Correcting Code Check Enable Writing one to this field automatically calculates and sets the ZMK ECC value in the ZMK_ECC_VALUE field of this register
        constexpr uint32_t ZMK_ECC_VALUE = (9 << 7);  ///< Zeroizable Master Key Error Correcting Code Value This field is automatically calculated and set when one is written into ZMK_ECC_EN bit of this register
    }

    /// LPSVCR Register bits
    namespace lpsvcr_bits {
        constexpr uint32_t SV0_EN = (1U << 0);  ///< Security Violation 0 Enable This bit enables Security Violation 0 Input
        constexpr uint32_t SV1_EN = (1U << 1);  ///< Security Violation 1 Enable This bit enables Security Violation 1 Input
        constexpr uint32_t SV2_EN = (1U << 2);  ///< Security Violation 2 Enable This bit enables Security Violation 2 Input
        constexpr uint32_t SV3_EN = (1U << 3);  ///< Security Violation 3 Enable This bit enables Security Violation 3 Input
        constexpr uint32_t SV4_EN = (1U << 4);  ///< Security Violation 4 Enable This bit enables Security Violation 4 Input
        constexpr uint32_t SV5_EN = (1U << 5);  ///< Security Violation 5 Enable This bit enables Security Violation 5 Input
    }

    /// LPTDCR Register bits
    namespace lptdcr_bits {
        constexpr uint32_t SRTCR_EN = (1U << 1);  ///< SRTC Rollover Enable When set, an SRTC rollover event generates an LP security violation.
        constexpr uint32_t MCR_EN = (1U << 2);  ///< MC Rollover Enable When set, an MC Rollover event generates an LP security violation.
        constexpr uint32_t ET1_EN = (1U << 9);  ///< External Tampering 1 Enable When set, external tampering 1 detection generates an LP security violation
        constexpr uint32_t ET1P = (1U << 11);  ///< External Tampering 1 Polarity This bit is used to determine the polarity of external tamper 1.
        constexpr uint32_t PFD_OBSERV = (1U << 14);  ///< System Power Fail Detector (PFD) Observability Flop The asynchronous reset input of this flop is connected directly to the inverted output of the PFD analog circuitry (external to the SNVS block)
        constexpr uint32_t POR_OBSERV = (1U << 15);  ///< Power On Reset (POR) Observability Flop The asynchronous reset input of this flop is connected directly to the output of the POR analog circuitry (external to the SNVS
        constexpr uint32_t OSCB = (1U << 28);  ///< Oscillator Bypass When OSCB=1 the osc_bypass signal is asserted
    }

    /// LPSR Register bits
    namespace lpsr_bits {
        constexpr uint32_t LPTA = (1U << 0);  ///< LP Time Alarm
        constexpr uint32_t SRTCR = (1U << 1);  ///< Secure Real Time Counter Rollover
        constexpr uint32_t MCR = (1U << 2);  ///< Monotonic Counter Rollover
        constexpr uint32_t PGD = (1U << 3);  ///< Power Supply Glitch Detected 0 No power supply glitch. 1 Power supply glitch is detected.
        constexpr uint32_t ET1D = (1U << 9);  ///< External Tampering 1 Detected
        constexpr uint32_t ESVD = (1U << 16);  ///< External Security Violation Detected Indicates that a security violation is detected on one of the HP security violation ports
        constexpr uint32_t EO = (1U << 17);  ///< Emergency Off This bit is set when a power off is requested.
        constexpr uint32_t SPO = (1U << 18);  ///< Set Power Off The SPO bit is set when the power button is pressed longer than the configured debounce time
        constexpr uint32_t SED = (1U << 20);  ///< Scan Exit Detected
        constexpr uint32_t LPNS = (1U << 30);  ///< LP Section is Non-Secured Indicates that LP section was provisioned/programmed in the non-secure state
        constexpr uint32_t LPS = (1U << 31);  ///< LP Section is Secured Indicates that the LP section is provisioned/programmed in the secure or trusted state
    }

    /// LPSRTCMR Register bits
    namespace lpsrtcmr_bits {
        constexpr uint32_t SRTC = (15 << 0);  ///< LP Secure Real Time Counter The most-significant 15 bits of the SRTC
    }

    /// LPSRTCLR Register bits
    namespace lpsrtclr_bits {
        constexpr uint32_t SRTC = (32 << 0);  ///< LP Secure Real Time Counter least-significant 32 bits This register can be programmed only when SRTC is not active and not locked, meaning the SRTC_ENV, SRTC_SL, and SRTC_HL bits are not set
    }

    /// LPTAR Register bits
    namespace lptar_bits {
        constexpr uint32_t LPTA = (32 << 0);  ///< LP Time Alarm This register can be programmed only when the LP time alarm is disabled (LPTA_EN bit is not set)
    }

    /// LPSMCMR Register bits
    namespace lpsmcmr_bits {
        constexpr uint32_t MON_COUNTER = (16 << 0);  ///< Monotonic Counter most-significant 16 Bits The MC is incremented by one when: A write transaction to the LPSMCMR or LPSMCLR register is detected
        constexpr uint32_t MC_ERA_BITS = (16 << 16);  ///< Monotonic Counter Era Bits These bits are inputs to the module and typically connect to fuses
    }

    /// LPSMCLR Register bits
    namespace lpsmclr_bits {
        constexpr uint32_t MON_COUNTER = (32 << 0);  ///< Monotonic Counter bits The MC is incremented by one when: A write transaction to the LPSMCMR or LPSMCLR Register is detected
    }

    /// LPPGDR Register bits
    namespace lppgdr_bits {
        constexpr uint32_t PGD = (32 << 0);  ///< Power Glitch Detector Value
    }

    /// LPGPR0_legacy_alias Register bits
    namespace lpgpr0_legacy_alias_bits {
        constexpr uint32_t GPR = (32 << 0);  ///< General Purpose Register When GPR_SL or GPR_HL bit is set, the register cannot be programmed.
    }

    /// LPZMKR[%s] Register bits
    namespace lpzmkr[%s]_bits {
        constexpr uint32_t ZMK = (32 << 0);  ///< Zeroizable Master Key Each of these registers contains 32 bits of the 256-bit ZMK value
    }

    /// LPGPR_alias[%s] Register bits
    namespace lpgpr_alias[%s]_bits {
        constexpr uint32_t GPR = (32 << 0);  ///< General Purpose Register When GPR_SL or GPR_HL bit is set, the register cannot be programmed.
    }

    /// LPGPR[%s] Register bits
    namespace lpgpr[%s]_bits {
        constexpr uint32_t GPR = (32 << 0);  ///< General Purpose Register When GPR_SL or GPR_HL bit is set, the register cannot be programmed.
    }

    /// HPVIDR1 Register bits
    namespace hpvidr1_bits {
        constexpr uint32_t MINOR_REV = (8 << 0);  ///< SNVS block minor version number
        constexpr uint32_t MAJOR_REV = (8 << 8);  ///< SNVS block major version number
        constexpr uint32_t IP_ID = (16 << 16);  ///< SNVS block ID
    }

    /// HPVIDR2 Register bits
    namespace hpvidr2_bits {
        constexpr uint32_t CONFIG_OPT = (8 << 0);  ///< SNVS Configuration Options
        constexpr uint32_t ECO_REV = (8 << 8);  ///< SNVS ECO Revision
        constexpr uint32_t INTG_OPT = (8 << 16);  ///< SNVS Integration Options
        constexpr uint32_t IP_ERA = (8 << 24);  ///< IP Era 00h - Era 1 or 2 03h - Era 3 04h - Era 4 05h - Era 5
    }

}

// ============================================================================
// CCM Peripheral
// ============================================================================

namespace ccm {
    /// Base addresses
    constexpr uint32_t CCM_ANALOG_BASE = 0x400D8000;
    constexpr uint32_t CCM_BASE = 0x400FC000;

    /// CCM Register structure
    struct Registers {
        volatile uint32_t PLL_ARM;  ///< Offset: 0x00 - Analog ARM PLL control Register
        volatile uint32_t PLL_ARM_SET;  ///< Offset: 0x04 - Analog ARM PLL control Register
        volatile uint32_t PLL_ARM_CLR;  ///< Offset: 0x08 - Analog ARM PLL control Register
        volatile uint32_t PLL_ARM_TOG;  ///< Offset: 0x0C - Analog ARM PLL control Register
        volatile uint32_t PLL_USB1;  ///< Offset: 0x10 - Analog USB1 480MHz PLL Control Register
        volatile uint32_t PLL_USB1_SET;  ///< Offset: 0x14 - Analog USB1 480MHz PLL Control Register
        volatile uint32_t PLL_USB1_CLR;  ///< Offset: 0x18 - Analog USB1 480MHz PLL Control Register
        volatile uint32_t PLL_USB1_TOG;  ///< Offset: 0x1C - Analog USB1 480MHz PLL Control Register
        volatile uint32_t PLL_USB2;  ///< Offset: 0x20 - Analog USB2 480MHz PLL Control Register
        volatile uint32_t PLL_USB2_SET;  ///< Offset: 0x24 - Analog USB2 480MHz PLL Control Register
        volatile uint32_t PLL_USB2_CLR;  ///< Offset: 0x28 - Analog USB2 480MHz PLL Control Register
        volatile uint32_t PLL_USB2_TOG;  ///< Offset: 0x2C - Analog USB2 480MHz PLL Control Register
        volatile uint32_t PLL_SYS;  ///< Offset: 0x30 - Analog System PLL Control Register
        volatile uint32_t PLL_SYS_SET;  ///< Offset: 0x34 - Analog System PLL Control Register
        volatile uint32_t PLL_SYS_CLR;  ///< Offset: 0x38 - Analog System PLL Control Register
        volatile uint32_t PLL_SYS_TOG;  ///< Offset: 0x3C - Analog System PLL Control Register
        volatile uint32_t PLL_SYS_SS;  ///< Offset: 0x40 - 528MHz System PLL Spread Spectrum Register
        volatile uint32_t PLL_SYS_NUM;  ///< Offset: 0x50 - Numerator of 528MHz System PLL Fractional Loop Divider Register
        volatile uint32_t PLL_SYS_DENOM;  ///< Offset: 0x60 - Denominator of 528MHz System PLL Fractional Loop Divider Register
        volatile uint32_t PLL_AUDIO;  ///< Offset: 0x70 - Analog Audio PLL control Register
        volatile uint32_t PLL_AUDIO_SET;  ///< Offset: 0x74 - Analog Audio PLL control Register
        volatile uint32_t PLL_AUDIO_CLR;  ///< Offset: 0x78 - Analog Audio PLL control Register
        volatile uint32_t PLL_AUDIO_TOG;  ///< Offset: 0x7C - Analog Audio PLL control Register
        volatile uint32_t PLL_AUDIO_NUM;  ///< Offset: 0x80 - Numerator of Audio PLL Fractional Loop Divider Register
        volatile uint32_t PLL_AUDIO_DENOM;  ///< Offset: 0x90 - Denominator of Audio PLL Fractional Loop Divider Register
        volatile uint32_t PLL_VIDEO;  ///< Offset: 0xA0 - Analog Video PLL control Register
        volatile uint32_t PLL_VIDEO_SET;  ///< Offset: 0xA4 - Analog Video PLL control Register
        volatile uint32_t PLL_VIDEO_CLR;  ///< Offset: 0xA8 - Analog Video PLL control Register
        volatile uint32_t PLL_VIDEO_TOG;  ///< Offset: 0xAC - Analog Video PLL control Register
        volatile uint32_t PLL_VIDEO_NUM;  ///< Offset: 0xB0 - Numerator of Video PLL Fractional Loop Divider Register
        volatile uint32_t PLL_VIDEO_DENOM;  ///< Offset: 0xC0 - Denominator of Video PLL Fractional Loop Divider Register
        volatile uint32_t PLL_ENET;  ///< Offset: 0xE0 - Analog ENET PLL Control Register
        volatile uint32_t PLL_ENET_SET;  ///< Offset: 0xE4 - Analog ENET PLL Control Register
        volatile uint32_t PLL_ENET_CLR;  ///< Offset: 0xE8 - Analog ENET PLL Control Register
        volatile uint32_t PLL_ENET_TOG;  ///< Offset: 0xEC - Analog ENET PLL Control Register
        volatile uint32_t PFD_480;  ///< Offset: 0xF0 - 480MHz Clock (PLL3) Phase Fractional Divider Control Register
        volatile uint32_t PFD_480_SET;  ///< Offset: 0xF4 - 480MHz Clock (PLL3) Phase Fractional Divider Control Register
        volatile uint32_t PFD_480_CLR;  ///< Offset: 0xF8 - 480MHz Clock (PLL3) Phase Fractional Divider Control Register
        volatile uint32_t PFD_480_TOG;  ///< Offset: 0xFC - 480MHz Clock (PLL3) Phase Fractional Divider Control Register
        volatile uint32_t PFD_528;  ///< Offset: 0x100 - 528MHz Clock (PLL2) Phase Fractional Divider Control Register
        volatile uint32_t PFD_528_SET;  ///< Offset: 0x104 - 528MHz Clock (PLL2) Phase Fractional Divider Control Register
        volatile uint32_t PFD_528_CLR;  ///< Offset: 0x108 - 528MHz Clock (PLL2) Phase Fractional Divider Control Register
        volatile uint32_t PFD_528_TOG;  ///< Offset: 0x10C - 528MHz Clock (PLL2) Phase Fractional Divider Control Register
        volatile uint32_t MISC0;  ///< Offset: 0x150 - Miscellaneous Register 0
        volatile uint32_t MISC0_SET;  ///< Offset: 0x154 - Miscellaneous Register 0
        volatile uint32_t MISC0_CLR;  ///< Offset: 0x158 - Miscellaneous Register 0
        volatile uint32_t MISC0_TOG;  ///< Offset: 0x15C - Miscellaneous Register 0
        volatile uint32_t MISC1;  ///< Offset: 0x160 - Miscellaneous Register 1
        volatile uint32_t MISC1_SET;  ///< Offset: 0x164 - Miscellaneous Register 1
        volatile uint32_t MISC1_CLR;  ///< Offset: 0x168 - Miscellaneous Register 1
        volatile uint32_t MISC1_TOG;  ///< Offset: 0x16C - Miscellaneous Register 1
        volatile uint32_t MISC2;  ///< Offset: 0x170 - Miscellaneous Register 2
        volatile uint32_t MISC2_SET;  ///< Offset: 0x174 - Miscellaneous Register 2
        volatile uint32_t MISC2_CLR;  ///< Offset: 0x178 - Miscellaneous Register 2
        volatile uint32_t MISC2_TOG;  ///< Offset: 0x17C - Miscellaneous Register 2
    };

    /// Peripheral instances
    inline Registers* CCM_ANALOG = reinterpret_cast<Registers*>(CCM_ANALOG_BASE);
    inline Registers* CCM = reinterpret_cast<Registers*>(CCM_BASE);

    // Bit definitions
    /// PLL_ARM Register bits
    namespace pll_arm_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t PLL_SEL = (1U << 19);  ///< Reserved
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_ARM_SET Register bits
    namespace pll_arm_set_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t PLL_SEL = (1U << 19);  ///< Reserved
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_ARM_CLR Register bits
    namespace pll_arm_clr_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t PLL_SEL = (1U << 19);  ///< Reserved
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_ARM_TOG Register bits
    namespace pll_arm_tog_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t PLL_SEL = (1U << 19);  ///< Reserved
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_USB1 Register bits
    namespace pll_usb1_bits {
        constexpr uint32_t DIV_SELECT = (1U << 1);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t EN_USB_CLKS = (1U << 6);  ///< Powers the 9-phase PLL outputs for USBPHYn
        constexpr uint32_t POWER = (1U << 12);  ///< Powers up the PLL. This bit will be set automatically when USBPHY0 remote wakeup event happens.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_USB1_SET Register bits
    namespace pll_usb1_set_bits {
        constexpr uint32_t DIV_SELECT = (1U << 1);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t EN_USB_CLKS = (1U << 6);  ///< Powers the 9-phase PLL outputs for USBPHYn
        constexpr uint32_t POWER = (1U << 12);  ///< Powers up the PLL. This bit will be set automatically when USBPHY0 remote wakeup event happens.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_USB1_CLR Register bits
    namespace pll_usb1_clr_bits {
        constexpr uint32_t DIV_SELECT = (1U << 1);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t EN_USB_CLKS = (1U << 6);  ///< Powers the 9-phase PLL outputs for USBPHYn
        constexpr uint32_t POWER = (1U << 12);  ///< Powers up the PLL. This bit will be set automatically when USBPHY0 remote wakeup event happens.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_USB1_TOG Register bits
    namespace pll_usb1_tog_bits {
        constexpr uint32_t DIV_SELECT = (1U << 1);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t EN_USB_CLKS = (1U << 6);  ///< Powers the 9-phase PLL outputs for USBPHYn
        constexpr uint32_t POWER = (1U << 12);  ///< Powers up the PLL. This bit will be set automatically when USBPHY0 remote wakeup event happens.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_USB2 Register bits
    namespace pll_usb2_bits {
        constexpr uint32_t DIV_SELECT = (1U << 1);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t EN_USB_CLKS = (1U << 6);  ///< 0: 8-phase PLL outputs for USBPHY1 are powered down
        constexpr uint32_t POWER = (1U << 12);  ///< Powers up the PLL. This bit will be set automatically when USBPHY1 remote wakeup event happens.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_USB2_SET Register bits
    namespace pll_usb2_set_bits {
        constexpr uint32_t DIV_SELECT = (1U << 1);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t EN_USB_CLKS = (1U << 6);  ///< 0: 8-phase PLL outputs for USBPHY1 are powered down
        constexpr uint32_t POWER = (1U << 12);  ///< Powers up the PLL. This bit will be set automatically when USBPHY1 remote wakeup event happens.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_USB2_CLR Register bits
    namespace pll_usb2_clr_bits {
        constexpr uint32_t DIV_SELECT = (1U << 1);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t EN_USB_CLKS = (1U << 6);  ///< 0: 8-phase PLL outputs for USBPHY1 are powered down
        constexpr uint32_t POWER = (1U << 12);  ///< Powers up the PLL. This bit will be set automatically when USBPHY1 remote wakeup event happens.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_USB2_TOG Register bits
    namespace pll_usb2_tog_bits {
        constexpr uint32_t DIV_SELECT = (1U << 1);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t EN_USB_CLKS = (1U << 6);  ///< 0: 8-phase PLL outputs for USBPHY1 are powered down
        constexpr uint32_t POWER = (1U << 12);  ///< Powers up the PLL. This bit will be set automatically when USBPHY1 remote wakeup event happens.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL clock output.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_SYS Register bits
    namespace pll_sys_bits {
        constexpr uint32_t DIV_SELECT = (1U << 0);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_SYS_SET Register bits
    namespace pll_sys_set_bits {
        constexpr uint32_t DIV_SELECT = (1U << 0);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_SYS_CLR Register bits
    namespace pll_sys_clr_bits {
        constexpr uint32_t DIV_SELECT = (1U << 0);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_SYS_TOG Register bits
    namespace pll_sys_tog_bits {
        constexpr uint32_t DIV_SELECT = (1U << 0);  ///< This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_SYS_SS Register bits
    namespace pll_sys_ss_bits {
        constexpr uint32_t STEP = (15 << 0);  ///< Frequency change step = step/CCM_ANALOG_PLL_SYS_DENOM[B]*24MHz.
        constexpr uint32_t ENABLE = (1U << 15);  ///< Enable bit
        constexpr uint32_t STOP = (16 << 16);  ///< Frequency change = stop/CCM_ANALOG_PLL_SYS_DENOM[B]*24MHz.
    }

    /// PLL_SYS_NUM Register bits
    namespace pll_sys_num_bits {
        constexpr uint32_t A = (30 << 0);  ///< 30 bit numerator (A) of fractional loop divider (signed integer).
    }

    /// PLL_SYS_DENOM Register bits
    namespace pll_sys_denom_bits {
        constexpr uint32_t B = (30 << 0);  ///< 30 bit Denominator (B) of fractional loop divider (unsigned integer).
    }

    /// PLL_AUDIO Register bits
    namespace pll_audio_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t POST_DIV_SELECT = (2 << 19);  ///< These bits implement a divider after the PLL, but before the enable and bypass mux.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_AUDIO_SET Register bits
    namespace pll_audio_set_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t POST_DIV_SELECT = (2 << 19);  ///< These bits implement a divider after the PLL, but before the enable and bypass mux.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_AUDIO_CLR Register bits
    namespace pll_audio_clr_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t POST_DIV_SELECT = (2 << 19);  ///< These bits implement a divider after the PLL, but before the enable and bypass mux.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_AUDIO_TOG Register bits
    namespace pll_audio_tog_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t POST_DIV_SELECT = (2 << 19);  ///< These bits implement a divider after the PLL, but before the enable and bypass mux.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked. 0 - PLL is not currently locked.
    }

    /// PLL_AUDIO_NUM Register bits
    namespace pll_audio_num_bits {
        constexpr uint32_t A = (30 << 0);  ///< 30 bit numerator of fractional loop divider.
    }

    /// PLL_AUDIO_DENOM Register bits
    namespace pll_audio_denom_bits {
        constexpr uint32_t B = (30 << 0);  ///< 30 bit Denominator of fractional loop divider.
    }

    /// PLL_VIDEO Register bits
    namespace pll_video_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enalbe PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t POST_DIV_SELECT = (2 << 19);  ///< These bits implement a divider after the PLL, but before the enable and bypass mux.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_VIDEO_SET Register bits
    namespace pll_video_set_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enalbe PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t POST_DIV_SELECT = (2 << 19);  ///< These bits implement a divider after the PLL, but before the enable and bypass mux.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_VIDEO_CLR Register bits
    namespace pll_video_clr_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enalbe PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t POST_DIV_SELECT = (2 << 19);  ///< These bits implement a divider after the PLL, but before the enable and bypass mux.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_VIDEO_TOG Register bits
    namespace pll_video_tog_bits {
        constexpr uint32_t DIV_SELECT = (7 << 0);  ///< This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enalbe PLL output
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t POST_DIV_SELECT = (2 << 19);  ///< These bits implement a divider after the PLL, but before the enable and bypass mux.
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_VIDEO_NUM Register bits
    namespace pll_video_num_bits {
        constexpr uint32_t A = (30 << 0);  ///< 30 bit numerator of fractional loop divider(Signed number), absolute value should be less than denominator
    }

    /// PLL_VIDEO_DENOM Register bits
    namespace pll_video_denom_bits {
        constexpr uint32_t B = (30 << 0);  ///< 30 bit Denominator of fractional loop divider.
    }

    /// PLL_ENET Register bits
    namespace pll_enet_bits {
        constexpr uint32_t DIV_SELECT = (2 << 0);  ///< Controls the frequency of the ethernet reference clock
        constexpr uint32_t ENET2_DIV_SELECT = (2 << 2);  ///< Controls the frequency of the ENET2 reference clock.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL providing the ENET reference clock.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t ENET2_REF_EN = (1U << 20);  ///< Enable the PLL providing the ENET2 reference clock
        constexpr uint32_t ENET_25M_REF_EN = (1U << 21);  ///< Enable the PLL providing ENET 25 MHz reference clock
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_ENET_SET Register bits
    namespace pll_enet_set_bits {
        constexpr uint32_t DIV_SELECT = (2 << 0);  ///< Controls the frequency of the ethernet reference clock
        constexpr uint32_t ENET2_DIV_SELECT = (2 << 2);  ///< Controls the frequency of the ENET2 reference clock.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL providing the ENET reference clock.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t ENET2_REF_EN = (1U << 20);  ///< Enable the PLL providing the ENET2 reference clock
        constexpr uint32_t ENET_25M_REF_EN = (1U << 21);  ///< Enable the PLL providing ENET 25 MHz reference clock
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_ENET_CLR Register bits
    namespace pll_enet_clr_bits {
        constexpr uint32_t DIV_SELECT = (2 << 0);  ///< Controls the frequency of the ethernet reference clock
        constexpr uint32_t ENET2_DIV_SELECT = (2 << 2);  ///< Controls the frequency of the ENET2 reference clock.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL providing the ENET reference clock.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t ENET2_REF_EN = (1U << 20);  ///< Enable the PLL providing the ENET2 reference clock
        constexpr uint32_t ENET_25M_REF_EN = (1U << 21);  ///< Enable the PLL providing ENET 25 MHz reference clock
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PLL_ENET_TOG Register bits
    namespace pll_enet_tog_bits {
        constexpr uint32_t DIV_SELECT = (2 << 0);  ///< Controls the frequency of the ethernet reference clock
        constexpr uint32_t ENET2_DIV_SELECT = (2 << 2);  ///< Controls the frequency of the ENET2 reference clock.
        constexpr uint32_t POWERDOWN = (1U << 12);  ///< Powers down the PLL.
        constexpr uint32_t ENABLE = (1U << 13);  ///< Enable the PLL providing the ENET reference clock.
        constexpr uint32_t BYPASS_CLK_SRC = (2 << 14);  ///< Determines the bypass source.
        constexpr uint32_t BYPASS = (1U << 16);  ///< Bypass the PLL.
        constexpr uint32_t ENET2_REF_EN = (1U << 20);  ///< Enable the PLL providing the ENET2 reference clock
        constexpr uint32_t ENET_25M_REF_EN = (1U << 21);  ///< Enable the PLL providing ENET 25 MHz reference clock
        constexpr uint32_t LOCK = (1U << 31);  ///< 1 - PLL is currently locked; 0 - PLL is not currently locked.
    }

    /// PFD_480 Register bits
    namespace pfd_480_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_480_SET Register bits
    namespace pfd_480_set_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_480_CLR Register bits
    namespace pfd_480_clr_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_480_TOG Register bits
    namespace pfd_480_tog_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_528 Register bits
    namespace pfd_528_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_528_SET Register bits
    namespace pfd_528_set_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_528_CLR Register bits
    namespace pfd_528_clr_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// PFD_528_TOG Register bits
    namespace pfd_528_tog_bits {
        constexpr uint32_t PFD0_FRAC = (6 << 0);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD0_STABLE = (1U << 6);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD0_CLKGATE = (1U << 7);  ///< If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
        constexpr uint32_t PFD1_FRAC = (6 << 8);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD1_STABLE = (1U << 14);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD1_CLKGATE = (1U << 15);  ///< IO Clock Gate
        constexpr uint32_t PFD2_FRAC = (6 << 16);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD2_STABLE = (1U << 22);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD2_CLKGATE = (1U << 23);  ///< IO Clock Gate
        constexpr uint32_t PFD3_FRAC = (6 << 24);  ///< This field controls the fractional divide value
        constexpr uint32_t PFD3_STABLE = (1U << 30);  ///< This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
        constexpr uint32_t PFD3_CLKGATE = (1U << 31);  ///< IO Clock Gate
    }

    /// MISC0 Register bits
    namespace misc0_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true
    }

    /// MISC0_SET Register bits
    namespace misc0_set_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true
    }

    /// MISC0_CLR Register bits
    namespace misc0_clr_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true
    }

    /// MISC0_TOG Register bits
    namespace misc0_tog_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true
    }

    /// MISC1 Register bits
    namespace misc1_bits {
        constexpr uint32_t LVDS1_CLK_SEL = (5 << 0);  ///< This field selects the clk to be routed to anaclk1/1b.
        constexpr uint32_t LVDSCLK1_OBEN = (1U << 10);  ///< This enables the LVDS output buffer for anaclk1/1b
        constexpr uint32_t LVDSCLK1_IBEN = (1U << 12);  ///< This enables the LVDS input buffer for anaclk1/1b
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC1_SET Register bits
    namespace misc1_set_bits {
        constexpr uint32_t LVDS1_CLK_SEL = (5 << 0);  ///< This field selects the clk to be routed to anaclk1/1b.
        constexpr uint32_t LVDSCLK1_OBEN = (1U << 10);  ///< This enables the LVDS output buffer for anaclk1/1b
        constexpr uint32_t LVDSCLK1_IBEN = (1U << 12);  ///< This enables the LVDS input buffer for anaclk1/1b
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC1_CLR Register bits
    namespace misc1_clr_bits {
        constexpr uint32_t LVDS1_CLK_SEL = (5 << 0);  ///< This field selects the clk to be routed to anaclk1/1b.
        constexpr uint32_t LVDSCLK1_OBEN = (1U << 10);  ///< This enables the LVDS output buffer for anaclk1/1b
        constexpr uint32_t LVDSCLK1_IBEN = (1U << 12);  ///< This enables the LVDS input buffer for anaclk1/1b
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC1_TOG Register bits
    namespace misc1_tog_bits {
        constexpr uint32_t LVDS1_CLK_SEL = (5 << 0);  ///< This field selects the clk to be routed to anaclk1/1b.
        constexpr uint32_t LVDSCLK1_OBEN = (1U << 10);  ///< This enables the LVDS output buffer for anaclk1/1b
        constexpr uint32_t LVDSCLK1_IBEN = (1U << 12);  ///< This enables the LVDS input buffer for anaclk1/1b
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC2 Register bits
    namespace misc2_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_OK = (1U << 6);  ///< ARM supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t PLL3_DISABLE = (1U << 7);  ///< When USB is in low power suspend mode this Control bit is used to indicate if other system peripherals require the USB PLL3 clock when the SoC is not in low power mode
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit. Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_OK = (1U << 14);  ///< GPU/VPU supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t VIDEO_DIV = (2 << 30);  ///< Post-divider for video
    }

    /// MISC2_SET Register bits
    namespace misc2_set_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_OK = (1U << 6);  ///< ARM supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t PLL3_DISABLE = (1U << 7);  ///< When USB is in low power suspend mode this Control bit is used to indicate if other system peripherals require the USB PLL3 clock when the SoC is not in low power mode
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit. Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_OK = (1U << 14);  ///< GPU/VPU supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t VIDEO_DIV = (2 << 30);  ///< Post-divider for video
    }

    /// MISC2_CLR Register bits
    namespace misc2_clr_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_OK = (1U << 6);  ///< ARM supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t PLL3_DISABLE = (1U << 7);  ///< When USB is in low power suspend mode this Control bit is used to indicate if other system peripherals require the USB PLL3 clock when the SoC is not in low power mode
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit. Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_OK = (1U << 14);  ///< GPU/VPU supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t VIDEO_DIV = (2 << 30);  ///< Post-divider for video
    }

    /// MISC2_TOG Register bits
    namespace misc2_tog_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG0_OK = (1U << 6);  ///< ARM supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t PLL3_DISABLE = (1U << 7);  ///< When USB is in low power suspend mode this Control bit is used to indicate if other system peripherals require the USB PLL3 clock when the SoC is not in low power mode
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit. Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_OK = (1U << 14);  ///< GPU/VPU supply Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
        constexpr uint32_t VIDEO_DIV = (2 << 30);  ///< Post-divider for video
    }

}

// ============================================================================
// PMU Peripheral
// ============================================================================

namespace pmu {
    /// Base addresses
    constexpr uint32_t PMU_BASE = 0x400D8000;

    /// PMU Register structure
    struct Registers {
        volatile uint32_t REG_1P1;  ///< Offset: 0x110 - Regulator 1P1 Register
        volatile uint32_t REG_1P1_SET;  ///< Offset: 0x114 - Regulator 1P1 Register
        volatile uint32_t REG_1P1_CLR;  ///< Offset: 0x118 - Regulator 1P1 Register
        volatile uint32_t REG_1P1_TOG;  ///< Offset: 0x11C - Regulator 1P1 Register
        volatile uint32_t REG_3P0;  ///< Offset: 0x120 - Regulator 3P0 Register
        volatile uint32_t REG_3P0_SET;  ///< Offset: 0x124 - Regulator 3P0 Register
        volatile uint32_t REG_3P0_CLR;  ///< Offset: 0x128 - Regulator 3P0 Register
        volatile uint32_t REG_3P0_TOG;  ///< Offset: 0x12C - Regulator 3P0 Register
        volatile uint32_t REG_2P5;  ///< Offset: 0x130 - Regulator 2P5 Register
        volatile uint32_t REG_2P5_SET;  ///< Offset: 0x134 - Regulator 2P5 Register
        volatile uint32_t REG_2P5_CLR;  ///< Offset: 0x138 - Regulator 2P5 Register
        volatile uint32_t REG_2P5_TOG;  ///< Offset: 0x13C - Regulator 2P5 Register
        volatile uint32_t REG_CORE;  ///< Offset: 0x140 - Digital Regulator Core Register
        volatile uint32_t REG_CORE_SET;  ///< Offset: 0x144 - Digital Regulator Core Register
        volatile uint32_t REG_CORE_CLR;  ///< Offset: 0x148 - Digital Regulator Core Register
        volatile uint32_t REG_CORE_TOG;  ///< Offset: 0x14C - Digital Regulator Core Register
        volatile uint32_t MISC0;  ///< Offset: 0x150 - Miscellaneous Register 0
        volatile uint32_t MISC0_SET;  ///< Offset: 0x154 - Miscellaneous Register 0
        volatile uint32_t MISC0_CLR;  ///< Offset: 0x158 - Miscellaneous Register 0
        volatile uint32_t MISC0_TOG;  ///< Offset: 0x15C - Miscellaneous Register 0
        volatile uint32_t MISC1;  ///< Offset: 0x160 - Miscellaneous Register 1
        volatile uint32_t MISC1_SET;  ///< Offset: 0x164 - Miscellaneous Register 1
        volatile uint32_t MISC1_CLR;  ///< Offset: 0x168 - Miscellaneous Register 1
        volatile uint32_t MISC1_TOG;  ///< Offset: 0x16C - Miscellaneous Register 1
        volatile uint32_t MISC2;  ///< Offset: 0x170 - Miscellaneous Control Register
        volatile uint32_t MISC2_SET;  ///< Offset: 0x174 - Miscellaneous Control Register
        volatile uint32_t MISC2_CLR;  ///< Offset: 0x178 - Miscellaneous Control Register
        volatile uint32_t MISC2_TOG;  ///< Offset: 0x17C - Miscellaneous Control Register
    };

    /// Peripheral instances
    inline Registers* PMU = reinterpret_cast<Registers*>(PMU_BASE);

    // Bit definitions
    /// REG_1P1 Register bits
    namespace reg_1p1_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD1P1 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD1P1 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 1p1 regulator
        constexpr uint32_t SELREF_WEAK_LINREG = (1U << 19);  ///< Selects the source for the reference voltage of the weak 1p1 regulator.
    }

    /// REG_1P1_SET Register bits
    namespace reg_1p1_set_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD1P1 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD1P1 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 1p1 regulator
        constexpr uint32_t SELREF_WEAK_LINREG = (1U << 19);  ///< Selects the source for the reference voltage of the weak 1p1 regulator.
    }

    /// REG_1P1_CLR Register bits
    namespace reg_1p1_clr_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD1P1 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD1P1 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 1p1 regulator
        constexpr uint32_t SELREF_WEAK_LINREG = (1U << 19);  ///< Selects the source for the reference voltage of the weak 1p1 regulator.
    }

    /// REG_1P1_TOG Register bits
    namespace reg_1p1_tog_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD1P1 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD1P1 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 1p1 regulator
        constexpr uint32_t SELREF_WEAK_LINREG = (1U << 19);  ///< Selects the source for the reference voltage of the weak 1p1 regulator.
    }

    /// REG_3P0 Register bits
    namespace reg_3p0_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t VBUS_SEL = (1U << 7);  ///< Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or USB_OTG2_VBUS
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD3P0 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD3P0 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
    }

    /// REG_3P0_SET Register bits
    namespace reg_3p0_set_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t VBUS_SEL = (1U << 7);  ///< Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or USB_OTG2_VBUS
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD3P0 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD3P0 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
    }

    /// REG_3P0_CLR Register bits
    namespace reg_3p0_clr_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t VBUS_SEL = (1U << 7);  ///< Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or USB_OTG2_VBUS
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD3P0 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD3P0 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
    }

    /// REG_3P0_TOG Register bits
    namespace reg_3p0_tog_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t VBUS_SEL = (1U << 7);  ///< Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or USB_OTG2_VBUS
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD3P0 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD3P0 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
    }

    /// REG_2P5 Register bits
    namespace reg_2p5_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD2P5 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD2P5 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 2p5 regulator
    }

    /// REG_2P5_SET Register bits
    namespace reg_2p5_set_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD2P5 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD2P5 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 2p5 regulator
    }

    /// REG_2P5_CLR Register bits
    namespace reg_2p5_clr_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD2P5 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD2P5 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 2p5 regulator
    }

    /// REG_2P5_TOG Register bits
    namespace reg_2p5_tog_bits {
        constexpr uint32_t ENABLE_LINREG = (1U << 0);  ///< Control bit to enable the regulator output.
        constexpr uint32_t ENABLE_BO = (1U << 1);  ///< Control bit to enable the brownout circuitry in the regulator.
        constexpr uint32_t ENABLE_ILIMIT = (1U << 2);  ///< Control bit to enable the current-limit circuitry in the regulator.
        constexpr uint32_t ENABLE_PULLDOWN = (1U << 3);  ///< Control bit to enable the pull-down circuitry in the regulator
        constexpr uint32_t BO_OFFSET = (3 << 4);  ///< Control bits to adjust the regulator brownout offset voltage in 25mV steps
        constexpr uint32_t OUTPUT_TRG = (5 << 8);  ///< Control bits to adjust the regulator output voltage
        constexpr uint32_t BO_VDD2P5 = (1U << 16);  ///< Status bit that signals when a brownout is detected on the regulator output.
        constexpr uint32_t OK_VDD2P5 = (1U << 17);  ///< Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
        constexpr uint32_t ENABLE_WEAK_LINREG = (1U << 18);  ///< Enables the weak 2p5 regulator
    }

    /// REG_CORE Register bits
    namespace reg_core_bits {
        constexpr uint32_t REG0_TARG = (5 << 0);  ///< This field defines the target voltage for the ARM core power domain
        constexpr uint32_t REG0_ADJ = (4 << 5);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg0. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG1_TARG = (5 << 9);  ///< This bit field defines the target voltage for the vpu/gpu power domain. Single bit increments reflect 25mV core voltage steps. Not all steps will make sense to use either because of input supply limitations or load operation.
        constexpr uint32_t REG1_ADJ = (4 << 14);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg1. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG2_TARG = (5 << 18);  ///< This field defines the target voltage for the SOC power domain
        constexpr uint32_t REG2_ADJ = (4 << 23);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg2. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t RAMP_RATE = (2 << 27);  ///< Regulator voltage ramp rate.
        constexpr uint32_t FET_ODRIVE = (1U << 29);  ///< If set, increases the gate drive on power gating FETs to reduce leakage in the off state
    }

    /// REG_CORE_SET Register bits
    namespace reg_core_set_bits {
        constexpr uint32_t REG0_TARG = (5 << 0);  ///< This field defines the target voltage for the ARM core power domain
        constexpr uint32_t REG0_ADJ = (4 << 5);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg0. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG1_TARG = (5 << 9);  ///< This bit field defines the target voltage for the vpu/gpu power domain. Single bit increments reflect 25mV core voltage steps. Not all steps will make sense to use either because of input supply limitations or load operation.
        constexpr uint32_t REG1_ADJ = (4 << 14);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg1. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG2_TARG = (5 << 18);  ///< This field defines the target voltage for the SOC power domain
        constexpr uint32_t REG2_ADJ = (4 << 23);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg2. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t RAMP_RATE = (2 << 27);  ///< Regulator voltage ramp rate.
        constexpr uint32_t FET_ODRIVE = (1U << 29);  ///< If set, increases the gate drive on power gating FETs to reduce leakage in the off state
    }

    /// REG_CORE_CLR Register bits
    namespace reg_core_clr_bits {
        constexpr uint32_t REG0_TARG = (5 << 0);  ///< This field defines the target voltage for the ARM core power domain
        constexpr uint32_t REG0_ADJ = (4 << 5);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg0. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG1_TARG = (5 << 9);  ///< This bit field defines the target voltage for the vpu/gpu power domain. Single bit increments reflect 25mV core voltage steps. Not all steps will make sense to use either because of input supply limitations or load operation.
        constexpr uint32_t REG1_ADJ = (4 << 14);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg1. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG2_TARG = (5 << 18);  ///< This field defines the target voltage for the SOC power domain
        constexpr uint32_t REG2_ADJ = (4 << 23);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg2. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t RAMP_RATE = (2 << 27);  ///< Regulator voltage ramp rate.
        constexpr uint32_t FET_ODRIVE = (1U << 29);  ///< If set, increases the gate drive on power gating FETs to reduce leakage in the off state
    }

    /// REG_CORE_TOG Register bits
    namespace reg_core_tog_bits {
        constexpr uint32_t REG0_TARG = (5 << 0);  ///< This field defines the target voltage for the ARM core power domain
        constexpr uint32_t REG0_ADJ = (4 << 5);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg0. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG1_TARG = (5 << 9);  ///< This bit field defines the target voltage for the vpu/gpu power domain. Single bit increments reflect 25mV core voltage steps. Not all steps will make sense to use either because of input supply limitations or load operation.
        constexpr uint32_t REG1_ADJ = (4 << 14);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg1. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t REG2_TARG = (5 << 18);  ///< This field defines the target voltage for the SOC power domain
        constexpr uint32_t REG2_ADJ = (4 << 23);  ///< This bit field defines the adjustment bits to calibrate the target value of Reg2. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
        constexpr uint32_t RAMP_RATE = (2 << 27);  ///< Regulator voltage ramp rate.
        constexpr uint32_t FET_ODRIVE = (1U << 29);  ///< If set, increases the gate drive on power gating FETs to reduce leakage in the off state
    }

    /// MISC0 Register bits
    namespace misc0_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< no description available
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable. 1 - Stable.
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
        constexpr uint32_t VID_PLL_PREDIV = (1U << 31);  ///< Predivider for the source clock of the PLL's.
    }

    /// MISC0_SET Register bits
    namespace misc0_set_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< no description available
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable. 1 - Stable.
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
        constexpr uint32_t VID_PLL_PREDIV = (1U << 31);  ///< Predivider for the source clock of the PLL's.
    }

    /// MISC0_CLR Register bits
    namespace misc0_clr_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< no description available
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable. 1 - Stable.
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
        constexpr uint32_t VID_PLL_PREDIV = (1U << 31);  ///< Predivider for the source clock of the PLL's.
    }

    /// MISC0_TOG Register bits
    namespace misc0_tog_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< no description available
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable. 1 - Stable.
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
        constexpr uint32_t VID_PLL_PREDIV = (1U << 31);  ///< Predivider for the source clock of the PLL's.
    }

    /// MISC1 Register bits
    namespace misc1_bits {
        constexpr uint32_t LVDS1_CLK_SEL = (5 << 0);  ///< This field selects the clk to be routed to anaclk1/1b.Not related to PMU.
        constexpr uint32_t LVDS2_CLK_SEL = (5 << 5);  ///< This field selects the clk to be routed to anaclk2/2b.Not related to PMU.
        constexpr uint32_t LVDSCLK1_OBEN = (1U << 10);  ///< This enables the LVDS output buffer for anaclk1/1b
        constexpr uint32_t LVDSCLK2_OBEN = (1U << 11);  ///< This enables the LVDS output buffer for anaclk2/2b
        constexpr uint32_t LVDSCLK1_IBEN = (1U << 12);  ///< This enables the LVDS input buffer for anaclk1/1b
        constexpr uint32_t LVDSCLK2_IBEN = (1U << 13);  ///< This enables the LVDS input buffer for anaclk2/2b
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC1_SET Register bits
    namespace misc1_set_bits {
        constexpr uint32_t LVDS1_CLK_SEL = (5 << 0);  ///< This field selects the clk to be routed to anaclk1/1b.Not related to PMU.
        constexpr uint32_t LVDS2_CLK_SEL = (5 << 5);  ///< This field selects the clk to be routed to anaclk2/2b.Not related to PMU.
        constexpr uint32_t LVDSCLK1_OBEN = (1U << 10);  ///< This enables the LVDS output buffer for anaclk1/1b
        constexpr uint32_t LVDSCLK2_OBEN = (1U << 11);  ///< This enables the LVDS output buffer for anaclk2/2b
        constexpr uint32_t LVDSCLK1_IBEN = (1U << 12);  ///< This enables the LVDS input buffer for anaclk1/1b
        constexpr uint32_t LVDSCLK2_IBEN = (1U << 13);  ///< This enables the LVDS input buffer for anaclk2/2b
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC1_CLR Register bits
    namespace misc1_clr_bits {
        constexpr uint32_t LVDS1_CLK_SEL = (5 << 0);  ///< This field selects the clk to be routed to anaclk1/1b.Not related to PMU.
        constexpr uint32_t LVDS2_CLK_SEL = (5 << 5);  ///< This field selects the clk to be routed to anaclk2/2b.Not related to PMU.
        constexpr uint32_t LVDSCLK1_OBEN = (1U << 10);  ///< This enables the LVDS output buffer for anaclk1/1b
        constexpr uint32_t LVDSCLK2_OBEN = (1U << 11);  ///< This enables the LVDS output buffer for anaclk2/2b
        constexpr uint32_t LVDSCLK1_IBEN = (1U << 12);  ///< This enables the LVDS input buffer for anaclk1/1b
        constexpr uint32_t LVDSCLK2_IBEN = (1U << 13);  ///< This enables the LVDS input buffer for anaclk2/2b
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC1_TOG Register bits
    namespace misc1_tog_bits {
        constexpr uint32_t LVDS1_CLK_SEL = (5 << 0);  ///< This field selects the clk to be routed to anaclk1/1b.Not related to PMU.
        constexpr uint32_t LVDS2_CLK_SEL = (5 << 5);  ///< This field selects the clk to be routed to anaclk2/2b.Not related to PMU.
        constexpr uint32_t LVDSCLK1_OBEN = (1U << 10);  ///< This enables the LVDS output buffer for anaclk1/1b
        constexpr uint32_t LVDSCLK2_OBEN = (1U << 11);  ///< This enables the LVDS output buffer for anaclk2/2b
        constexpr uint32_t LVDSCLK1_IBEN = (1U << 12);  ///< This enables the LVDS input buffer for anaclk1/1b
        constexpr uint32_t LVDSCLK2_IBEN = (1U << 13);  ///< This enables the LVDS input buffer for anaclk2/2b
        constexpr uint32_t PFD_480_AUTOGATE_EN = (1U << 16);  ///< This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
        constexpr uint32_t PFD_528_AUTOGATE_EN = (1U << 17);  ///< This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
        constexpr uint32_t IRQ_TEMPPANIC = (1U << 27);  ///< This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
        constexpr uint32_t IRQ_TEMPLOW = (1U << 28);  ///< This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
        constexpr uint32_t IRQ_TEMPHIGH = (1U << 29);  ///< This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
        constexpr uint32_t IRQ_ANA_BO = (1U << 30);  ///< This status bit is set to one when when any of the analog regulator brownout interrupts assert
        constexpr uint32_t IRQ_DIG_BO = (1U << 31);  ///< This status bit is set to one when when any of the digital regulator brownout interrupts assert
    }

    /// MISC2 Register bits
    namespace misc2_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.
        constexpr uint32_t PLL3_disable = (1U << 7);  ///< Default value of "0"
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit.
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t VIDEO_DIV = (2 << 30);  ///< Post-divider for video
    }

    /// MISC2_SET Register bits
    namespace misc2_set_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.
        constexpr uint32_t PLL3_disable = (1U << 7);  ///< Default value of "0"
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit.
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t VIDEO_DIV = (2 << 30);  ///< Post-divider for video
    }

    /// MISC2_CLR Register bits
    namespace misc2_clr_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.
        constexpr uint32_t PLL3_disable = (1U << 7);  ///< Default value of "0"
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit.
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t VIDEO_DIV = (2 << 30);  ///< Post-divider for video
    }

    /// MISC2_TOG Register bits
    namespace misc2_tog_bits {
        constexpr uint32_t REG0_BO_OFFSET = (3 << 0);  ///< This field defines the brown out voltage offset for the CORE power domain
        constexpr uint32_t REG0_BO_STATUS = (1U << 3);  ///< Reg0 brownout status bit.
        constexpr uint32_t REG0_ENABLE_BO = (1U << 5);  ///< Enables the brownout detection.
        constexpr uint32_t PLL3_disable = (1U << 7);  ///< Default value of "0"
        constexpr uint32_t REG1_BO_OFFSET = (3 << 8);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG1_BO_STATUS = (1U << 11);  ///< Reg1 brownout status bit.
        constexpr uint32_t REG1_ENABLE_BO = (1U << 13);  ///< Enables the brownout detection.
        constexpr uint32_t AUDIO_DIV_LSB = (1U << 15);  ///< LSB of Post-divider for Audio PLL
        constexpr uint32_t REG2_BO_OFFSET = (3 << 16);  ///< This field defines the brown out voltage offset for the xPU power domain
        constexpr uint32_t REG2_BO_STATUS = (1U << 19);  ///< Reg2 brownout status bit.
        constexpr uint32_t REG2_ENABLE_BO = (1U << 21);  ///< Enables the brownout detection.
        constexpr uint32_t REG2_OK = (1U << 22);  ///< Signals that the voltage is above the brownout level for the SOC supply
        constexpr uint32_t AUDIO_DIV_MSB = (1U << 23);  ///< MSB of Post-divider for Audio PLL
        constexpr uint32_t REG0_STEP_TIME = (2 << 24);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG1_STEP_TIME = (2 << 26);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t REG2_STEP_TIME = (2 << 28);  ///< Number of clock periods (24MHz clock).
        constexpr uint32_t VIDEO_DIV = (2 << 30);  ///< Post-divider for video
    }

}

// ============================================================================
// TEMPMON Peripheral
// ============================================================================

namespace tempmon {
    /// Base addresses
    constexpr uint32_t TEMPMON_BASE = 0x400D8000;

    /// TEMPMON Register structure
    struct Registers {
        volatile uint32_t TEMPSENSE0;  ///< Offset: 0x180 - Tempsensor Control Register 0
        volatile uint32_t TEMPSENSE0_SET;  ///< Offset: 0x184 - Tempsensor Control Register 0
        volatile uint32_t TEMPSENSE0_CLR;  ///< Offset: 0x188 - Tempsensor Control Register 0
        volatile uint32_t TEMPSENSE0_TOG;  ///< Offset: 0x18C - Tempsensor Control Register 0
        volatile uint32_t TEMPSENSE1;  ///< Offset: 0x190 - Tempsensor Control Register 1
        volatile uint32_t TEMPSENSE1_SET;  ///< Offset: 0x194 - Tempsensor Control Register 1
        volatile uint32_t TEMPSENSE1_CLR;  ///< Offset: 0x198 - Tempsensor Control Register 1
        volatile uint32_t TEMPSENSE1_TOG;  ///< Offset: 0x19C - Tempsensor Control Register 1
        volatile uint32_t TEMPSENSE2;  ///< Offset: 0x290 - Tempsensor Control Register 2
        volatile uint32_t TEMPSENSE2_SET;  ///< Offset: 0x294 - Tempsensor Control Register 2
        volatile uint32_t TEMPSENSE2_CLR;  ///< Offset: 0x298 - Tempsensor Control Register 2
        volatile uint32_t TEMPSENSE2_TOG;  ///< Offset: 0x29C - Tempsensor Control Register 2
    };

    /// Peripheral instances
    inline Registers* TEMPMON = reinterpret_cast<Registers*>(TEMPMON_BASE);

    // Bit definitions
    /// TEMPSENSE0 Register bits
    namespace tempsense0_bits {
        constexpr uint32_t POWER_DOWN = (1U << 0);  ///< This bit powers down the temperature sensor.
        constexpr uint32_t MEASURE_TEMP = (1U << 1);  ///< Starts the measurement process
        constexpr uint32_t FINISHED = (1U << 2);  ///< Indicates that the latest temp is valid
        constexpr uint32_t TEMP_CNT = (12 << 8);  ///< This bit field contains the last measured temperature count.
        constexpr uint32_t ALARM_VALUE = (12 << 20);  ///< This bit field contains the temperature count (raw sensor output) that will generate a high alarm when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE0_SET Register bits
    namespace tempsense0_set_bits {
        constexpr uint32_t POWER_DOWN = (1U << 0);  ///< This bit powers down the temperature sensor.
        constexpr uint32_t MEASURE_TEMP = (1U << 1);  ///< Starts the measurement process
        constexpr uint32_t FINISHED = (1U << 2);  ///< Indicates that the latest temp is valid
        constexpr uint32_t TEMP_CNT = (12 << 8);  ///< This bit field contains the last measured temperature count.
        constexpr uint32_t ALARM_VALUE = (12 << 20);  ///< This bit field contains the temperature count (raw sensor output) that will generate a high alarm when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE0_CLR Register bits
    namespace tempsense0_clr_bits {
        constexpr uint32_t POWER_DOWN = (1U << 0);  ///< This bit powers down the temperature sensor.
        constexpr uint32_t MEASURE_TEMP = (1U << 1);  ///< Starts the measurement process
        constexpr uint32_t FINISHED = (1U << 2);  ///< Indicates that the latest temp is valid
        constexpr uint32_t TEMP_CNT = (12 << 8);  ///< This bit field contains the last measured temperature count.
        constexpr uint32_t ALARM_VALUE = (12 << 20);  ///< This bit field contains the temperature count (raw sensor output) that will generate a high alarm when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE0_TOG Register bits
    namespace tempsense0_tog_bits {
        constexpr uint32_t POWER_DOWN = (1U << 0);  ///< This bit powers down the temperature sensor.
        constexpr uint32_t MEASURE_TEMP = (1U << 1);  ///< Starts the measurement process
        constexpr uint32_t FINISHED = (1U << 2);  ///< Indicates that the latest temp is valid
        constexpr uint32_t TEMP_CNT = (12 << 8);  ///< This bit field contains the last measured temperature count.
        constexpr uint32_t ALARM_VALUE = (12 << 20);  ///< This bit field contains the temperature count (raw sensor output) that will generate a high alarm when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE1 Register bits
    namespace tempsense1_bits {
        constexpr uint32_t MEASURE_FREQ = (16 << 0);  ///< This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement
    }

    /// TEMPSENSE1_SET Register bits
    namespace tempsense1_set_bits {
        constexpr uint32_t MEASURE_FREQ = (16 << 0);  ///< This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement
    }

    /// TEMPSENSE1_CLR Register bits
    namespace tempsense1_clr_bits {
        constexpr uint32_t MEASURE_FREQ = (16 << 0);  ///< This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement
    }

    /// TEMPSENSE1_TOG Register bits
    namespace tempsense1_tog_bits {
        constexpr uint32_t MEASURE_FREQ = (16 << 0);  ///< This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement
    }

    /// TEMPSENSE2 Register bits
    namespace tempsense2_bits {
        constexpr uint32_t LOW_ALARM_VALUE = (12 << 0);  ///< This bit field contains the temperature count that will generate a low alarm interrupt when the field is exceeded by TEMP_CNT
        constexpr uint32_t PANIC_ALARM_VALUE = (12 << 16);  ///< This bit field contains the temperature count that will generate a panic interrupt when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE2_SET Register bits
    namespace tempsense2_set_bits {
        constexpr uint32_t LOW_ALARM_VALUE = (12 << 0);  ///< This bit field contains the temperature count that will generate a low alarm interrupt when the field is exceeded by TEMP_CNT
        constexpr uint32_t PANIC_ALARM_VALUE = (12 << 16);  ///< This bit field contains the temperature count that will generate a panic interrupt when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE2_CLR Register bits
    namespace tempsense2_clr_bits {
        constexpr uint32_t LOW_ALARM_VALUE = (12 << 0);  ///< This bit field contains the temperature count that will generate a low alarm interrupt when the field is exceeded by TEMP_CNT
        constexpr uint32_t PANIC_ALARM_VALUE = (12 << 16);  ///< This bit field contains the temperature count that will generate a panic interrupt when TEMP_CNT is smaller than this field
    }

    /// TEMPSENSE2_TOG Register bits
    namespace tempsense2_tog_bits {
        constexpr uint32_t LOW_ALARM_VALUE = (12 << 0);  ///< This bit field contains the temperature count that will generate a low alarm interrupt when the field is exceeded by TEMP_CNT
        constexpr uint32_t PANIC_ALARM_VALUE = (12 << 16);  ///< This bit field contains the temperature count that will generate a panic interrupt when TEMP_CNT is smaller than this field
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_ANALOG_BASE = 0x400D8000;
    constexpr uint32_t USBPHY1_BASE = 0x400D9000;
    constexpr uint32_t USBPHY2_BASE = 0x400DA000;
    constexpr uint32_t USB1_BASE = 0x402E0000;
    constexpr uint32_t USB2_BASE = 0x402E0200;
    constexpr uint32_t USBNC1_BASE = 0x402E0000;
    constexpr uint32_t USBNC2_BASE = 0x402E0004;

    /// USB Register structure
    struct Registers {
        volatile uint32_t USB1_VBUS_DETECT;  ///< Offset: 0x1A0 - USB VBUS Detect Register
        volatile uint32_t USB1_VBUS_DETECT_SET;  ///< Offset: 0x1A4 - USB VBUS Detect Register
        volatile uint32_t USB1_VBUS_DETECT_CLR;  ///< Offset: 0x1A8 - USB VBUS Detect Register
        volatile uint32_t USB1_VBUS_DETECT_TOG;  ///< Offset: 0x1AC - USB VBUS Detect Register
        volatile uint32_t USB1_CHRG_DETECT;  ///< Offset: 0x1B0 - USB Charger Detect Register
        volatile uint32_t USB1_CHRG_DETECT_SET;  ///< Offset: 0x1B4 - USB Charger Detect Register
        volatile uint32_t USB1_CHRG_DETECT_CLR;  ///< Offset: 0x1B8 - USB Charger Detect Register
        volatile uint32_t USB1_CHRG_DETECT_TOG;  ///< Offset: 0x1BC - USB Charger Detect Register
        volatile uint32_t USB1_VBUS_DETECT_STAT;  ///< Offset: 0x1C0 - USB VBUS Detect Status Register
        volatile uint32_t USB1_CHRG_DETECT_STAT;  ///< Offset: 0x1D0 - USB Charger Detect Status Register
        volatile uint32_t USB1_LOOPBACK;  ///< Offset: 0x1E0 - USB Loopback Test Register
        volatile uint32_t USB1_LOOPBACK_SET;  ///< Offset: 0x1E4 - USB Loopback Test Register
        volatile uint32_t USB1_LOOPBACK_CLR;  ///< Offset: 0x1E8 - USB Loopback Test Register
        volatile uint32_t USB1_LOOPBACK_TOG;  ///< Offset: 0x1EC - USB Loopback Test Register
        volatile uint32_t USB1_MISC;  ///< Offset: 0x1F0 - USB Misc Register
        volatile uint32_t USB1_MISC_SET;  ///< Offset: 0x1F4 - USB Misc Register
        volatile uint32_t USB1_MISC_CLR;  ///< Offset: 0x1F8 - USB Misc Register
        volatile uint32_t USB1_MISC_TOG;  ///< Offset: 0x1FC - USB Misc Register
        volatile uint32_t USB2_VBUS_DETECT;  ///< Offset: 0x200 - USB VBUS Detect Register
        volatile uint32_t USB2_VBUS_DETECT_SET;  ///< Offset: 0x204 - USB VBUS Detect Register
        volatile uint32_t USB2_VBUS_DETECT_CLR;  ///< Offset: 0x208 - USB VBUS Detect Register
        volatile uint32_t USB2_VBUS_DETECT_TOG;  ///< Offset: 0x20C - USB VBUS Detect Register
        volatile uint32_t USB2_CHRG_DETECT;  ///< Offset: 0x210 - USB Charger Detect Register
        volatile uint32_t USB2_CHRG_DETECT_SET;  ///< Offset: 0x214 - USB Charger Detect Register
        volatile uint32_t USB2_CHRG_DETECT_CLR;  ///< Offset: 0x218 - USB Charger Detect Register
        volatile uint32_t USB2_CHRG_DETECT_TOG;  ///< Offset: 0x21C - USB Charger Detect Register
        volatile uint32_t USB2_VBUS_DETECT_STAT;  ///< Offset: 0x220 - USB VBUS Detect Status Register
        volatile uint32_t USB2_CHRG_DETECT_STAT;  ///< Offset: 0x230 - USB Charger Detect Status Register
        volatile uint32_t USB2_LOOPBACK;  ///< Offset: 0x240 - USB Loopback Test Register
        volatile uint32_t USB2_LOOPBACK_SET;  ///< Offset: 0x244 - USB Loopback Test Register
        volatile uint32_t USB2_LOOPBACK_CLR;  ///< Offset: 0x248 - USB Loopback Test Register
        volatile uint32_t USB2_LOOPBACK_TOG;  ///< Offset: 0x24C - USB Loopback Test Register
        volatile uint32_t USB2_MISC;  ///< Offset: 0x250 - USB Misc Register
        volatile uint32_t USB2_MISC_SET;  ///< Offset: 0x254 - USB Misc Register
        volatile uint32_t USB2_MISC_CLR;  ///< Offset: 0x258 - USB Misc Register
        volatile uint32_t USB2_MISC_TOG;  ///< Offset: 0x25C - USB Misc Register
        volatile uint32_t DIGPROG;  ///< Offset: 0x260 - Chip Silicon Version
    };

    /// Peripheral instances
    inline Registers* USB_ANALOG = reinterpret_cast<Registers*>(USB_ANALOG_BASE);
    inline Registers* USBPHY1 = reinterpret_cast<Registers*>(USBPHY1_BASE);
    inline Registers* USBPHY2 = reinterpret_cast<Registers*>(USBPHY2_BASE);
    inline Registers* USB1 = reinterpret_cast<Registers*>(USB1_BASE);
    inline Registers* USB2 = reinterpret_cast<Registers*>(USB2_BASE);
    inline Registers* USBNC1 = reinterpret_cast<Registers*>(USBNC1_BASE);
    inline Registers* USBNC2 = reinterpret_cast<Registers*>(USBNC2_BASE);

    // Bit definitions
    /// USB1_VBUS_DETECT Register bits
    namespace usb1_vbus_detect_bits {
        constexpr uint32_t VBUSVALID_THRESH = (3 << 0);  ///< Set the threshold for the VBUSVALID comparator
        constexpr uint32_t VBUSVALID_PWRUP_CMPS = (1U << 20);  ///< Powers up comparators for vbus_valid detector.
        constexpr uint32_t DISCHARGE_VBUS = (1U << 26);  ///< USB OTG discharge VBUS.
        constexpr uint32_t CHARGE_VBUS = (1U << 27);  ///< USB OTG charge VBUS.
    }

    /// USB1_VBUS_DETECT_SET Register bits
    namespace usb1_vbus_detect_set_bits {
        constexpr uint32_t VBUSVALID_THRESH = (3 << 0);  ///< Set the threshold for the VBUSVALID comparator
        constexpr uint32_t VBUSVALID_PWRUP_CMPS = (1U << 20);  ///< Powers up comparators for vbus_valid detector.
        constexpr uint32_t DISCHARGE_VBUS = (1U << 26);  ///< USB OTG discharge VBUS.
        constexpr uint32_t CHARGE_VBUS = (1U << 27);  ///< USB OTG charge VBUS.
    }

    /// USB1_VBUS_DETECT_CLR Register bits
    namespace usb1_vbus_detect_clr_bits {
        constexpr uint32_t VBUSVALID_THRESH = (3 << 0);  ///< Set the threshold for the VBUSVALID comparator
        constexpr uint32_t VBUSVALID_PWRUP_CMPS = (1U << 20);  ///< Powers up comparators for vbus_valid detector.
        constexpr uint32_t DISCHARGE_VBUS = (1U << 26);  ///< USB OTG discharge VBUS.
        constexpr uint32_t CHARGE_VBUS = (1U << 27);  ///< USB OTG charge VBUS.
    }

    /// USB1_VBUS_DETECT_TOG Register bits
    namespace usb1_vbus_detect_tog_bits {
        constexpr uint32_t VBUSVALID_THRESH = (3 << 0);  ///< Set the threshold for the VBUSVALID comparator
        constexpr uint32_t VBUSVALID_PWRUP_CMPS = (1U << 20);  ///< Powers up comparators for vbus_valid detector.
        constexpr uint32_t DISCHARGE_VBUS = (1U << 26);  ///< USB OTG discharge VBUS.
        constexpr uint32_t CHARGE_VBUS = (1U << 27);  ///< USB OTG charge VBUS.
    }

    /// USB1_CHRG_DETECT Register bits
    namespace usb1_chrg_detect_bits {
        constexpr uint32_t CHK_CONTACT = (1U << 18);  ///< Check the contact of USB plug
        constexpr uint32_t CHK_CHRG_B = (1U << 19);  ///< Check the charger connection
        constexpr uint32_t EN_B = (1U << 20);  ///< Control the charger detector.
    }

    /// USB1_CHRG_DETECT_SET Register bits
    namespace usb1_chrg_detect_set_bits {
        constexpr uint32_t CHK_CONTACT = (1U << 18);  ///< Check the contact of USB plug
        constexpr uint32_t CHK_CHRG_B = (1U << 19);  ///< Check the charger connection
        constexpr uint32_t EN_B = (1U << 20);  ///< Control the charger detector.
    }

    /// USB1_CHRG_DETECT_CLR Register bits
    namespace usb1_chrg_detect_clr_bits {
        constexpr uint32_t CHK_CONTACT = (1U << 18);  ///< Check the contact of USB plug
        constexpr uint32_t CHK_CHRG_B = (1U << 19);  ///< Check the charger connection
        constexpr uint32_t EN_B = (1U << 20);  ///< Control the charger detector.
    }

    /// USB1_CHRG_DETECT_TOG Register bits
    namespace usb1_chrg_detect_tog_bits {
        constexpr uint32_t CHK_CONTACT = (1U << 18);  ///< Check the contact of USB plug
        constexpr uint32_t CHK_CHRG_B = (1U << 19);  ///< Check the charger connection
        constexpr uint32_t EN_B = (1U << 20);  ///< Control the charger detector.
    }

    /// USB1_VBUS_DETECT_STAT Register bits
    namespace usb1_vbus_detect_stat_bits {
        constexpr uint32_t SESSEND = (1U << 0);  ///< Session End for USB OTG
        constexpr uint32_t BVALID = (1U << 1);  ///< Indicates VBus is valid for a B-peripheral
        constexpr uint32_t AVALID = (1U << 2);  ///< Indicates VBus is valid for a A-peripheral
        constexpr uint32_t VBUS_VALID = (1U << 3);  ///< VBus valid for USB OTG
    }

    /// USB1_CHRG_DETECT_STAT Register bits
    namespace usb1_chrg_detect_stat_bits {
        constexpr uint32_t PLUG_CONTACT = (1U << 0);  ///< State of the USB plug contact detector.
        constexpr uint32_t CHRG_DETECTED = (1U << 1);  ///< State of charger detection. This bit is a read only version of the state of the analog signal.
        constexpr uint32_t DM_STATE = (1U << 2);  ///< DM line state output of the charger detector.
        constexpr uint32_t DP_STATE = (1U << 3);  ///< DP line state output of the charger detector.
    }

    /// USB1_LOOPBACK Register bits
    namespace usb1_loopback_bits {
        constexpr uint32_t UTMI_TESTSTART = (1U << 0);  ///< Setting this bit can enable 1
    }

    /// USB1_LOOPBACK_SET Register bits
    namespace usb1_loopback_set_bits {
        constexpr uint32_t UTMI_TESTSTART = (1U << 0);  ///< Setting this bit can enable 1
    }

    /// USB1_LOOPBACK_CLR Register bits
    namespace usb1_loopback_clr_bits {
        constexpr uint32_t UTMI_TESTSTART = (1U << 0);  ///< Setting this bit can enable 1
    }

    /// USB1_LOOPBACK_TOG Register bits
    namespace usb1_loopback_tog_bits {
        constexpr uint32_t UTMI_TESTSTART = (1U << 0);  ///< Setting this bit can enable 1
    }

    /// USB1_MISC Register bits
    namespace usb1_misc_bits {
        constexpr uint32_t HS_USE_EXTERNAL_R = (1U << 0);  ///< Use external resistor to generate the current bias for the high speed transmitter
        constexpr uint32_t EN_DEGLITCH = (1U << 1);  ///< Enable the deglitching circuit of the USB PLL output.
        constexpr uint32_t EN_CLK_UTMI = (1U << 30);  ///< Enables the clk to the UTMI block.
    }

    /// USB1_MISC_SET Register bits
    namespace usb1_misc_set_bits {
        constexpr uint32_t HS_USE_EXTERNAL_R = (1U << 0);  ///< Use external resistor to generate the current bias for the high speed transmitter
        constexpr uint32_t EN_DEGLITCH = (1U << 1);  ///< Enable the deglitching circuit of the USB PLL output.
        constexpr uint32_t EN_CLK_UTMI = (1U << 30);  ///< Enables the clk to the UTMI block.
    }

    /// USB1_MISC_CLR Register bits
    namespace usb1_misc_clr_bits {
        constexpr uint32_t HS_USE_EXTERNAL_R = (1U << 0);  ///< Use external resistor to generate the current bias for the high speed transmitter
        constexpr uint32_t EN_DEGLITCH = (1U << 1);  ///< Enable the deglitching circuit of the USB PLL output.
        constexpr uint32_t EN_CLK_UTMI = (1U << 30);  ///< Enables the clk to the UTMI block.
    }

    /// USB1_MISC_TOG Register bits
    namespace usb1_misc_tog_bits {
        constexpr uint32_t HS_USE_EXTERNAL_R = (1U << 0);  ///< Use external resistor to generate the current bias for the high speed transmitter
        constexpr uint32_t EN_DEGLITCH = (1U << 1);  ///< Enable the deglitching circuit of the USB PLL output.
        constexpr uint32_t EN_CLK_UTMI = (1U << 30);  ///< Enables the clk to the UTMI block.
    }

    /// USB2_VBUS_DETECT Register bits
    namespace usb2_vbus_detect_bits {
        constexpr uint32_t VBUSVALID_THRESH = (3 << 0);  ///< Set the threshold for the VBUSVALID comparator
        constexpr uint32_t VBUSVALID_PWRUP_CMPS = (1U << 20);  ///< Powers up comparators for vbus_valid detector.
        constexpr uint32_t DISCHARGE_VBUS = (1U << 26);  ///< USB OTG discharge VBUS.
        constexpr uint32_t CHARGE_VBUS = (1U << 27);  ///< USB OTG charge VBUS.
    }

    /// USB2_VBUS_DETECT_SET Register bits
    namespace usb2_vbus_detect_set_bits {
        constexpr uint32_t VBUSVALID_THRESH = (3 << 0);  ///< Set the threshold for the VBUSVALID comparator
        constexpr uint32_t VBUSVALID_PWRUP_CMPS = (1U << 20);  ///< Powers up comparators for vbus_valid detector.
        constexpr uint32_t DISCHARGE_VBUS = (1U << 26);  ///< USB OTG discharge VBUS.
        constexpr uint32_t CHARGE_VBUS = (1U << 27);  ///< USB OTG charge VBUS.
    }

    /// USB2_VBUS_DETECT_CLR Register bits
    namespace usb2_vbus_detect_clr_bits {
        constexpr uint32_t VBUSVALID_THRESH = (3 << 0);  ///< Set the threshold for the VBUSVALID comparator
        constexpr uint32_t VBUSVALID_PWRUP_CMPS = (1U << 20);  ///< Powers up comparators for vbus_valid detector.
        constexpr uint32_t DISCHARGE_VBUS = (1U << 26);  ///< USB OTG discharge VBUS.
        constexpr uint32_t CHARGE_VBUS = (1U << 27);  ///< USB OTG charge VBUS.
    }

    /// USB2_VBUS_DETECT_TOG Register bits
    namespace usb2_vbus_detect_tog_bits {
        constexpr uint32_t VBUSVALID_THRESH = (3 << 0);  ///< Set the threshold for the VBUSVALID comparator
        constexpr uint32_t VBUSVALID_PWRUP_CMPS = (1U << 20);  ///< Powers up comparators for vbus_valid detector.
        constexpr uint32_t DISCHARGE_VBUS = (1U << 26);  ///< USB OTG discharge VBUS.
        constexpr uint32_t CHARGE_VBUS = (1U << 27);  ///< USB OTG charge VBUS.
    }

    /// USB2_CHRG_DETECT Register bits
    namespace usb2_chrg_detect_bits {
        constexpr uint32_t CHK_CONTACT = (1U << 18);  ///< Check the contact of USB plug
        constexpr uint32_t CHK_CHRG_B = (1U << 19);  ///< Check the charger connection
        constexpr uint32_t EN_B = (1U << 20);  ///< Control the charger detector.
    }

    /// USB2_CHRG_DETECT_SET Register bits
    namespace usb2_chrg_detect_set_bits {
        constexpr uint32_t CHK_CONTACT = (1U << 18);  ///< Check the contact of USB plug
        constexpr uint32_t CHK_CHRG_B = (1U << 19);  ///< Check the charger connection
        constexpr uint32_t EN_B = (1U << 20);  ///< Control the charger detector.
    }

    /// USB2_CHRG_DETECT_CLR Register bits
    namespace usb2_chrg_detect_clr_bits {
        constexpr uint32_t CHK_CONTACT = (1U << 18);  ///< Check the contact of USB plug
        constexpr uint32_t CHK_CHRG_B = (1U << 19);  ///< Check the charger connection
        constexpr uint32_t EN_B = (1U << 20);  ///< Control the charger detector.
    }

    /// USB2_CHRG_DETECT_TOG Register bits
    namespace usb2_chrg_detect_tog_bits {
        constexpr uint32_t CHK_CONTACT = (1U << 18);  ///< Check the contact of USB plug
        constexpr uint32_t CHK_CHRG_B = (1U << 19);  ///< Check the charger connection
        constexpr uint32_t EN_B = (1U << 20);  ///< Control the charger detector.
    }

    /// USB2_VBUS_DETECT_STAT Register bits
    namespace usb2_vbus_detect_stat_bits {
        constexpr uint32_t SESSEND = (1U << 0);  ///< Session End for USB OTG
        constexpr uint32_t BVALID = (1U << 1);  ///< Indicates VBus is valid for a B-peripheral
        constexpr uint32_t AVALID = (1U << 2);  ///< Indicates VBus is valid for a A-peripheral
        constexpr uint32_t VBUS_VALID = (1U << 3);  ///< VBus valid for USB OTG
    }

    /// USB2_CHRG_DETECT_STAT Register bits
    namespace usb2_chrg_detect_stat_bits {
        constexpr uint32_t PLUG_CONTACT = (1U << 0);  ///< State of the USB plug contact detector.
        constexpr uint32_t CHRG_DETECTED = (1U << 1);  ///< State of charger detection. This bit is a read only version of the state of the analog signal.
        constexpr uint32_t DM_STATE = (1U << 2);  ///< DM line state output of the charger detector.
        constexpr uint32_t DP_STATE = (1U << 3);  ///< DP line state output of the charger detector.
    }

    /// USB2_LOOPBACK Register bits
    namespace usb2_loopback_bits {
        constexpr uint32_t UTMI_TESTSTART = (1U << 0);  ///< Setting this bit can enable 1
    }

    /// USB2_LOOPBACK_SET Register bits
    namespace usb2_loopback_set_bits {
        constexpr uint32_t UTMI_TESTSTART = (1U << 0);  ///< Setting this bit can enable 1
    }

    /// USB2_LOOPBACK_CLR Register bits
    namespace usb2_loopback_clr_bits {
        constexpr uint32_t UTMI_TESTSTART = (1U << 0);  ///< Setting this bit can enable 1
    }

    /// USB2_LOOPBACK_TOG Register bits
    namespace usb2_loopback_tog_bits {
        constexpr uint32_t UTMI_TESTSTART = (1U << 0);  ///< Setting this bit can enable 1
    }

    /// USB2_MISC Register bits
    namespace usb2_misc_bits {
        constexpr uint32_t HS_USE_EXTERNAL_R = (1U << 0);  ///< Use external resistor to generate the current bias for the high speed transmitter
        constexpr uint32_t EN_DEGLITCH = (1U << 1);  ///< Enable the deglitching circuit of the USB PLL output.
        constexpr uint32_t EN_CLK_UTMI = (1U << 30);  ///< Enables the clk to the UTMI block.
    }

    /// USB2_MISC_SET Register bits
    namespace usb2_misc_set_bits {
        constexpr uint32_t HS_USE_EXTERNAL_R = (1U << 0);  ///< Use external resistor to generate the current bias for the high speed transmitter
        constexpr uint32_t EN_DEGLITCH = (1U << 1);  ///< Enable the deglitching circuit of the USB PLL output.
        constexpr uint32_t EN_CLK_UTMI = (1U << 30);  ///< Enables the clk to the UTMI block.
    }

    /// USB2_MISC_CLR Register bits
    namespace usb2_misc_clr_bits {
        constexpr uint32_t HS_USE_EXTERNAL_R = (1U << 0);  ///< Use external resistor to generate the current bias for the high speed transmitter
        constexpr uint32_t EN_DEGLITCH = (1U << 1);  ///< Enable the deglitching circuit of the USB PLL output.
        constexpr uint32_t EN_CLK_UTMI = (1U << 30);  ///< Enables the clk to the UTMI block.
    }

    /// USB2_MISC_TOG Register bits
    namespace usb2_misc_tog_bits {
        constexpr uint32_t HS_USE_EXTERNAL_R = (1U << 0);  ///< Use external resistor to generate the current bias for the high speed transmitter
        constexpr uint32_t EN_DEGLITCH = (1U << 1);  ///< Enable the deglitching circuit of the USB PLL output.
        constexpr uint32_t EN_CLK_UTMI = (1U << 30);  ///< Enables the clk to the UTMI block.
    }

    /// DIGPROG Register bits
    namespace digprog_bits {
        constexpr uint32_t SILICON_REVISION = (32 << 0);  ///< Chip silicon revision
    }

}

// ============================================================================
// XTALOSC24M Peripheral
// ============================================================================

namespace xtalosc24m {
    /// Base addresses
    constexpr uint32_t XTALOSC24M_BASE = 0x400D8000;

    /// XTALOSC24M Register structure
    struct Registers {
        volatile uint32_t MISC0;  ///< Offset: 0x150 - Miscellaneous Register 0
        volatile uint32_t MISC0_SET;  ///< Offset: 0x154 - Miscellaneous Register 0
        volatile uint32_t MISC0_CLR;  ///< Offset: 0x158 - Miscellaneous Register 0
        volatile uint32_t MISC0_TOG;  ///< Offset: 0x15C - Miscellaneous Register 0
        volatile uint32_t LOWPWR_CTRL;  ///< Offset: 0x270 - XTAL OSC (LP) Control Register
        volatile uint32_t LOWPWR_CTRL_SET;  ///< Offset: 0x274 - XTAL OSC (LP) Control Register
        volatile uint32_t LOWPWR_CTRL_CLR;  ///< Offset: 0x278 - XTAL OSC (LP) Control Register
        volatile uint32_t LOWPWR_CTRL_TOG;  ///< Offset: 0x27C - XTAL OSC (LP) Control Register
        volatile uint32_t OSC_CONFIG0;  ///< Offset: 0x2A0 - XTAL OSC Configuration 0 Register
        volatile uint32_t OSC_CONFIG0_SET;  ///< Offset: 0x2A4 - XTAL OSC Configuration 0 Register
        volatile uint32_t OSC_CONFIG0_CLR;  ///< Offset: 0x2A8 - XTAL OSC Configuration 0 Register
        volatile uint32_t OSC_CONFIG0_TOG;  ///< Offset: 0x2AC - XTAL OSC Configuration 0 Register
        volatile uint32_t OSC_CONFIG1;  ///< Offset: 0x2B0 - XTAL OSC Configuration 1 Register
        volatile uint32_t OSC_CONFIG1_SET;  ///< Offset: 0x2B4 - XTAL OSC Configuration 1 Register
        volatile uint32_t OSC_CONFIG1_CLR;  ///< Offset: 0x2B8 - XTAL OSC Configuration 1 Register
        volatile uint32_t OSC_CONFIG1_TOG;  ///< Offset: 0x2BC - XTAL OSC Configuration 1 Register
        volatile uint32_t OSC_CONFIG2;  ///< Offset: 0x2C0 - XTAL OSC Configuration 2 Register
        volatile uint32_t OSC_CONFIG2_SET;  ///< Offset: 0x2C4 - XTAL OSC Configuration 2 Register
        volatile uint32_t OSC_CONFIG2_CLR;  ///< Offset: 0x2C8 - XTAL OSC Configuration 2 Register
        volatile uint32_t OSC_CONFIG2_TOG;  ///< Offset: 0x2CC - XTAL OSC Configuration 2 Register
    };

    /// Peripheral instances
    inline Registers* XTALOSC24M = reinterpret_cast<Registers*>(XTALOSC24M_BASE);

    // Bit definitions
    /// MISC0 Register bits
    namespace misc0_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to oscillator.
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.Not related to oscillator.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable.
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
        constexpr uint32_t VID_PLL_PREDIV = (1U << 31);  ///< Predivider for the source clock of the PLL's. Not related to oscillator.
    }

    /// MISC0_SET Register bits
    namespace misc0_set_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to oscillator.
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.Not related to oscillator.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable.
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
        constexpr uint32_t VID_PLL_PREDIV = (1U << 31);  ///< Predivider for the source clock of the PLL's. Not related to oscillator.
    }

    /// MISC0_CLR Register bits
    namespace misc0_clr_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to oscillator.
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.Not related to oscillator.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable.
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
        constexpr uint32_t VID_PLL_PREDIV = (1U << 31);  ///< Predivider for the source clock of the PLL's. Not related to oscillator.
    }

    /// MISC0_TOG Register bits
    namespace misc0_tog_bits {
        constexpr uint32_t REFTOP_PWD = (1U << 0);  ///< Control bit to power-down the analog bandgap reference circuitry
        constexpr uint32_t REFTOP_SELFBIASOFF = (1U << 3);  ///< Control bit to disable the self-bias circuit in the analog bandgap
        constexpr uint32_t REFTOP_VBGADJ = (3 << 4);  ///< Not related to oscillator.
        constexpr uint32_t REFTOP_VBGUP = (1U << 7);  ///< Status bit that signals the analog bandgap voltage is up and stable
        constexpr uint32_t STOP_MODE_CONFIG = (2 << 10);  ///< Configure the analog behavior in stop mode.Not related to oscillator.
        constexpr uint32_t DISCON_HIGH_SNVS = (1U << 12);  ///< This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
        constexpr uint32_t OSC_I = (2 << 13);  ///< This field determines the bias current in the 24MHz oscillator
        constexpr uint32_t OSC_XTALOK = (1U << 15);  ///< Status bit that signals that the output of the 24-MHz crystal oscillator is stable
        constexpr uint32_t OSC_XTALOK_EN = (1U << 16);  ///< This bit enables the detector that signals when the 24MHz crystal oscillator is stable.
        constexpr uint32_t CLKGATE_CTRL = (1U << 25);  ///< This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
        constexpr uint32_t CLKGATE_DELAY = (3 << 26);  ///< This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
        constexpr uint32_t RTC_XTAL_SOURCE = (1U << 29);  ///< This field indicates which chip source is being used for the rtc clock.
        constexpr uint32_t XTAL_24M_PWD = (1U << 30);  ///< This field powers down the 24M crystal oscillator if set true.
        constexpr uint32_t VID_PLL_PREDIV = (1U << 31);  ///< Predivider for the source clock of the PLL's. Not related to oscillator.
    }

    /// LOWPWR_CTRL Register bits
    namespace lowpwr_ctrl_bits {
        constexpr uint32_t RC_OSC_EN = (1U << 0);  ///< RC Osc. enable control.
        constexpr uint32_t OSC_SEL = (1U << 4);  ///< Select the source for the 24MHz clock.
        constexpr uint32_t LPBG_SEL = (1U << 5);  ///< Bandgap select. Not related to oscillator.
        constexpr uint32_t LPBG_TEST = (1U << 6);  ///< Low power bandgap test bit. Not related to oscillator.
        constexpr uint32_t REFTOP_IBIAS_OFF = (1U << 7);  ///< Low power reftop ibias disable. Not related to oscillator.
        constexpr uint32_t L1_PWRGATE = (1U << 8);  ///< L1 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t L2_PWRGATE = (1U << 9);  ///< L2 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t CPU_PWRGATE = (1U << 10);  ///< CPU power gate control. Used as software override. Test purpose only Not related to oscillator.
        constexpr uint32_t DISPLAY_PWRGATE = (1U << 11);  ///< Display logic power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t RCOSC_CG_OVERRIDE = (1U << 13);  ///< For debug purposes only
        constexpr uint32_t XTALOSC_PWRUP_DELAY = (2 << 14);  ///< Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use
        constexpr uint32_t XTALOSC_PWRUP_STAT = (1U << 16);  ///< Status of the 24MHz xtal oscillator.
        constexpr uint32_t MIX_PWRGATE = (1U << 17);  ///< Display power gate control. Used as software mask. Set to zero to force ungated.
        constexpr uint32_t GPU_PWRGATE = (1U << 18);  ///< GPU power gate control. Used as software mask. Set to zero to force ungated.
    }

    /// LOWPWR_CTRL_SET Register bits
    namespace lowpwr_ctrl_set_bits {
        constexpr uint32_t RC_OSC_EN = (1U << 0);  ///< RC Osc. enable control.
        constexpr uint32_t OSC_SEL = (1U << 4);  ///< Select the source for the 24MHz clock.
        constexpr uint32_t LPBG_SEL = (1U << 5);  ///< Bandgap select. Not related to oscillator.
        constexpr uint32_t LPBG_TEST = (1U << 6);  ///< Low power bandgap test bit. Not related to oscillator.
        constexpr uint32_t REFTOP_IBIAS_OFF = (1U << 7);  ///< Low power reftop ibias disable. Not related to oscillator.
        constexpr uint32_t L1_PWRGATE = (1U << 8);  ///< L1 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t L2_PWRGATE = (1U << 9);  ///< L2 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t CPU_PWRGATE = (1U << 10);  ///< CPU power gate control. Used as software override. Test purpose only Not related to oscillator.
        constexpr uint32_t DISPLAY_PWRGATE = (1U << 11);  ///< Display logic power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t RCOSC_CG_OVERRIDE = (1U << 13);  ///< For debug purposes only
        constexpr uint32_t XTALOSC_PWRUP_DELAY = (2 << 14);  ///< Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use
        constexpr uint32_t XTALOSC_PWRUP_STAT = (1U << 16);  ///< Status of the 24MHz xtal oscillator.
        constexpr uint32_t MIX_PWRGATE = (1U << 17);  ///< Display power gate control. Used as software mask. Set to zero to force ungated.
        constexpr uint32_t GPU_PWRGATE = (1U << 18);  ///< GPU power gate control. Used as software mask. Set to zero to force ungated.
    }

    /// LOWPWR_CTRL_CLR Register bits
    namespace lowpwr_ctrl_clr_bits {
        constexpr uint32_t RC_OSC_EN = (1U << 0);  ///< RC Osc. enable control.
        constexpr uint32_t OSC_SEL = (1U << 4);  ///< Select the source for the 24MHz clock.
        constexpr uint32_t LPBG_SEL = (1U << 5);  ///< Bandgap select. Not related to oscillator.
        constexpr uint32_t LPBG_TEST = (1U << 6);  ///< Low power bandgap test bit. Not related to oscillator.
        constexpr uint32_t REFTOP_IBIAS_OFF = (1U << 7);  ///< Low power reftop ibias disable. Not related to oscillator.
        constexpr uint32_t L1_PWRGATE = (1U << 8);  ///< L1 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t L2_PWRGATE = (1U << 9);  ///< L2 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t CPU_PWRGATE = (1U << 10);  ///< CPU power gate control. Used as software override. Test purpose only Not related to oscillator.
        constexpr uint32_t DISPLAY_PWRGATE = (1U << 11);  ///< Display logic power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t RCOSC_CG_OVERRIDE = (1U << 13);  ///< For debug purposes only
        constexpr uint32_t XTALOSC_PWRUP_DELAY = (2 << 14);  ///< Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use
        constexpr uint32_t XTALOSC_PWRUP_STAT = (1U << 16);  ///< Status of the 24MHz xtal oscillator.
        constexpr uint32_t MIX_PWRGATE = (1U << 17);  ///< Display power gate control. Used as software mask. Set to zero to force ungated.
        constexpr uint32_t GPU_PWRGATE = (1U << 18);  ///< GPU power gate control. Used as software mask. Set to zero to force ungated.
    }

    /// LOWPWR_CTRL_TOG Register bits
    namespace lowpwr_ctrl_tog_bits {
        constexpr uint32_t RC_OSC_EN = (1U << 0);  ///< RC Osc. enable control.
        constexpr uint32_t OSC_SEL = (1U << 4);  ///< Select the source for the 24MHz clock.
        constexpr uint32_t LPBG_SEL = (1U << 5);  ///< Bandgap select. Not related to oscillator.
        constexpr uint32_t LPBG_TEST = (1U << 6);  ///< Low power bandgap test bit. Not related to oscillator.
        constexpr uint32_t REFTOP_IBIAS_OFF = (1U << 7);  ///< Low power reftop ibias disable. Not related to oscillator.
        constexpr uint32_t L1_PWRGATE = (1U << 8);  ///< L1 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t L2_PWRGATE = (1U << 9);  ///< L2 power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t CPU_PWRGATE = (1U << 10);  ///< CPU power gate control. Used as software override. Test purpose only Not related to oscillator.
        constexpr uint32_t DISPLAY_PWRGATE = (1U << 11);  ///< Display logic power gate control. Used as software override. Not related to oscillator.
        constexpr uint32_t RCOSC_CG_OVERRIDE = (1U << 13);  ///< For debug purposes only
        constexpr uint32_t XTALOSC_PWRUP_DELAY = (2 << 14);  ///< Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use
        constexpr uint32_t XTALOSC_PWRUP_STAT = (1U << 16);  ///< Status of the 24MHz xtal oscillator.
        constexpr uint32_t MIX_PWRGATE = (1U << 17);  ///< Display power gate control. Used as software mask. Set to zero to force ungated.
        constexpr uint32_t GPU_PWRGATE = (1U << 18);  ///< GPU power gate control. Used as software mask. Set to zero to force ungated.
    }

    /// OSC_CONFIG0 Register bits
    namespace osc_config0_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start/stop bit for the RC tuning calculation logic. If stopped the tuning logic is reset.
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enables the tuning logic to calculate new RC tuning values
        constexpr uint32_t BYPASS = (1U << 2);  ///< Bypasses any calculated RC tuning value and uses the programmed register value.
        constexpr uint32_t INVERT = (1U << 3);  ///< Invert the stepping of the calculated RC tuning value.
        constexpr uint32_t RC_OSC_PROG = (8 << 4);  ///< RC osc. tuning values.
        constexpr uint32_t HYST_PLUS = (4 << 12);  ///< Positive hysteresis value
        constexpr uint32_t HYST_MINUS = (4 << 16);  ///< Negative hysteresis value
        constexpr uint32_t RC_OSC_PROG_CUR = (8 << 24);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG0_SET Register bits
    namespace osc_config0_set_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start/stop bit for the RC tuning calculation logic. If stopped the tuning logic is reset.
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enables the tuning logic to calculate new RC tuning values
        constexpr uint32_t BYPASS = (1U << 2);  ///< Bypasses any calculated RC tuning value and uses the programmed register value.
        constexpr uint32_t INVERT = (1U << 3);  ///< Invert the stepping of the calculated RC tuning value.
        constexpr uint32_t RC_OSC_PROG = (8 << 4);  ///< RC osc. tuning values.
        constexpr uint32_t HYST_PLUS = (4 << 12);  ///< Positive hysteresis value
        constexpr uint32_t HYST_MINUS = (4 << 16);  ///< Negative hysteresis value
        constexpr uint32_t RC_OSC_PROG_CUR = (8 << 24);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG0_CLR Register bits
    namespace osc_config0_clr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start/stop bit for the RC tuning calculation logic. If stopped the tuning logic is reset.
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enables the tuning logic to calculate new RC tuning values
        constexpr uint32_t BYPASS = (1U << 2);  ///< Bypasses any calculated RC tuning value and uses the programmed register value.
        constexpr uint32_t INVERT = (1U << 3);  ///< Invert the stepping of the calculated RC tuning value.
        constexpr uint32_t RC_OSC_PROG = (8 << 4);  ///< RC osc. tuning values.
        constexpr uint32_t HYST_PLUS = (4 << 12);  ///< Positive hysteresis value
        constexpr uint32_t HYST_MINUS = (4 << 16);  ///< Negative hysteresis value
        constexpr uint32_t RC_OSC_PROG_CUR = (8 << 24);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG0_TOG Register bits
    namespace osc_config0_tog_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start/stop bit for the RC tuning calculation logic. If stopped the tuning logic is reset.
        constexpr uint32_t ENABLE = (1U << 1);  ///< Enables the tuning logic to calculate new RC tuning values
        constexpr uint32_t BYPASS = (1U << 2);  ///< Bypasses any calculated RC tuning value and uses the programmed register value.
        constexpr uint32_t INVERT = (1U << 3);  ///< Invert the stepping of the calculated RC tuning value.
        constexpr uint32_t RC_OSC_PROG = (8 << 4);  ///< RC osc. tuning values.
        constexpr uint32_t HYST_PLUS = (4 << 12);  ///< Positive hysteresis value
        constexpr uint32_t HYST_MINUS = (4 << 16);  ///< Negative hysteresis value
        constexpr uint32_t RC_OSC_PROG_CUR = (8 << 24);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG1 Register bits
    namespace osc_config1_bits {
        constexpr uint32_t COUNT_RC_TRG = (12 << 0);  ///< The target count used to tune the RC OSC frequency
        constexpr uint32_t COUNT_RC_CUR = (12 << 20);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG1_SET Register bits
    namespace osc_config1_set_bits {
        constexpr uint32_t COUNT_RC_TRG = (12 << 0);  ///< The target count used to tune the RC OSC frequency
        constexpr uint32_t COUNT_RC_CUR = (12 << 20);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG1_CLR Register bits
    namespace osc_config1_clr_bits {
        constexpr uint32_t COUNT_RC_TRG = (12 << 0);  ///< The target count used to tune the RC OSC frequency
        constexpr uint32_t COUNT_RC_CUR = (12 << 20);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG1_TOG Register bits
    namespace osc_config1_tog_bits {
        constexpr uint32_t COUNT_RC_TRG = (12 << 0);  ///< The target count used to tune the RC OSC frequency
        constexpr uint32_t COUNT_RC_CUR = (12 << 20);  ///< The current tuning value in use.
    }

    /// OSC_CONFIG2 Register bits
    namespace osc_config2_bits {
        constexpr uint32_t COUNT_1M_TRG = (12 << 0);  ///< The target count used to tune the 1MHz clock frequency
        constexpr uint32_t ENABLE_1M = (1U << 16);  ///< Enable the 1MHz clock output. 0 - disabled; 1 - enabled.
        constexpr uint32_t MUX_1M = (1U << 17);  ///< Mux the corrected or uncorrected 1MHz clock to the output
        constexpr uint32_t CLK_1M_ERR_FL = (1U << 31);  ///< Flag indicates that the count_1m count wasn't reached within 1 32kHz period
    }

    /// OSC_CONFIG2_SET Register bits
    namespace osc_config2_set_bits {
        constexpr uint32_t COUNT_1M_TRG = (12 << 0);  ///< The target count used to tune the 1MHz clock frequency
        constexpr uint32_t ENABLE_1M = (1U << 16);  ///< Enable the 1MHz clock output. 0 - disabled; 1 - enabled.
        constexpr uint32_t MUX_1M = (1U << 17);  ///< Mux the corrected or uncorrected 1MHz clock to the output
        constexpr uint32_t CLK_1M_ERR_FL = (1U << 31);  ///< Flag indicates that the count_1m count wasn't reached within 1 32kHz period
    }

    /// OSC_CONFIG2_CLR Register bits
    namespace osc_config2_clr_bits {
        constexpr uint32_t COUNT_1M_TRG = (12 << 0);  ///< The target count used to tune the 1MHz clock frequency
        constexpr uint32_t ENABLE_1M = (1U << 16);  ///< Enable the 1MHz clock output. 0 - disabled; 1 - enabled.
        constexpr uint32_t MUX_1M = (1U << 17);  ///< Mux the corrected or uncorrected 1MHz clock to the output
        constexpr uint32_t CLK_1M_ERR_FL = (1U << 31);  ///< Flag indicates that the count_1m count wasn't reached within 1 32kHz period
    }

    /// OSC_CONFIG2_TOG Register bits
    namespace osc_config2_tog_bits {
        constexpr uint32_t COUNT_1M_TRG = (12 << 0);  ///< The target count used to tune the 1MHz clock frequency
        constexpr uint32_t ENABLE_1M = (1U << 16);  ///< Enable the 1MHz clock output. 0 - disabled; 1 - enabled.
        constexpr uint32_t MUX_1M = (1U << 17);  ///< Mux the corrected or uncorrected 1MHz clock to the output
        constexpr uint32_t CLK_1M_ERR_FL = (1U << 31);  ///< Flag indicates that the count_1m count wasn't reached within 1 32kHz period
    }

}

// ============================================================================
// CSU Peripheral
// ============================================================================

namespace csu {
    /// Base addresses
    constexpr uint32_t CSU_BASE = 0x400DC000;

    /// CSU Register structure
    struct Registers {
        volatile uint32_t CSL%s;  ///< Offset: 0x00 - Config security level register
        volatile uint32_t HP0;  ///< Offset: 0x200 - HP0 register
        volatile uint32_t SA;  ///< Offset: 0x218 - Secure access register
        volatile uint32_t HPCONTROL0;  ///< Offset: 0x358 - HPCONTROL0 register
    };

    /// Peripheral instances
    inline Registers* CSU = reinterpret_cast<Registers*>(CSU_BASE);

    // Bit definitions
    /// CSL%s Register bits
    namespace csl%s_bits {
        constexpr uint32_t SUR_S2 = (1U << 0);  ///< Secure user read access control for the second slave
        constexpr uint32_t SSR_S2 = (1U << 1);  ///< Secure supervisor read access control for the second slave
        constexpr uint32_t NUR_S2 = (1U << 2);  ///< Non-secure user read access control for the second slave
        constexpr uint32_t NSR_S2 = (1U << 3);  ///< Non-secure supervisor read access control for the second slave
        constexpr uint32_t SUW_S2 = (1U << 4);  ///< Secure user write access control for the second slave
        constexpr uint32_t SSW_S2 = (1U << 5);  ///< Secure supervisor write access control for the second slave
        constexpr uint32_t NUW_S2 = (1U << 6);  ///< Non-secure user write access control for the second slave
        constexpr uint32_t NSW_S2 = (1U << 7);  ///< Non-secure supervisor write access control for the second slave
        constexpr uint32_t LOCK_S2 = (1U << 8);  ///< The lock bit corresponding to the second slave. It is written by the secure software.
        constexpr uint32_t SUR_S1 = (1U << 16);  ///< Secure user read access control for the first slave
        constexpr uint32_t SSR_S1 = (1U << 17);  ///< Secure supervisor read access control for the first slave
        constexpr uint32_t NUR_S1 = (1U << 18);  ///< Non-secure user read access control for the first slave
        constexpr uint32_t NSR_S1 = (1U << 19);  ///< Non-secure supervisor read access control for the first slave
        constexpr uint32_t SUW_S1 = (1U << 20);  ///< Secure user write access control for the first slave
        constexpr uint32_t SSW_S1 = (1U << 21);  ///< Secure supervisor write access control for the first slave
        constexpr uint32_t NUW_S1 = (1U << 22);  ///< Non-secure user write access control for the first slave
        constexpr uint32_t NSW_S1 = (1U << 23);  ///< Non-secure supervisor write access control for the first slave
        constexpr uint32_t LOCK_S1 = (1U << 24);  ///< The lock bit corresponding to the first slave. It is written by the secure software.
    }

    /// HP0 Register bits
    namespace hp0_bits {
        constexpr uint32_t HP_DMA = (1U << 2);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the eDMA
        constexpr uint32_t L_DMA = (1U << 3);  ///< Lock bit set by the TZ software for the eDMA
        constexpr uint32_t HP_LCDIF = (1U << 4);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the LCDIF
        constexpr uint32_t L_LCDIF = (1U << 5);  ///< Lock bit set by the TZ software for the LCDIF
        constexpr uint32_t HP_CSI = (1U << 6);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the CSI
        constexpr uint32_t L_CSI = (1U << 7);  ///< Lock bit set by the TZ software for the CSI
        constexpr uint32_t HP_PXP = (1U << 8);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the PXP
        constexpr uint32_t L_PXP = (1U << 9);  ///< Lock bit set by the TZ software for the PXP
        constexpr uint32_t HP_DCP = (1U << 10);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the DCP
        constexpr uint32_t L_DCP = (1U << 11);  ///< Lock bit set by the TZ software for the DCP
        constexpr uint32_t HP_ENET = (1U << 14);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the ENET
        constexpr uint32_t L_ENET = (1U << 15);  ///< Lock bit set by the TZ software for the ENET
        constexpr uint32_t HP_USDHC1 = (1U << 16);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the USDHC1
        constexpr uint32_t L_USDHC1 = (1U << 17);  ///< Lock bit set by the TZ software for the USDHC1
        constexpr uint32_t HP_USDHC2 = (1U << 18);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the USDHC2
        constexpr uint32_t L_USDHC2 = (1U << 19);  ///< Lock bit set by the TZ software for the USDHC2
        constexpr uint32_t HP_TPSMP = (1U << 20);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the TPSMP
        constexpr uint32_t L_TPSMP = (1U << 21);  ///< Lock bit set by the TZ software for the TPSMP
        constexpr uint32_t HP_USB = (1U << 22);  ///< Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the USB
        constexpr uint32_t L_USB = (1U << 23);  ///< Lock bit set by the TZ software for the USB
    }

    /// SA Register bits
    namespace sa_bits {
        constexpr uint32_t NSA_DMA = (1U << 2);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_DMA = (1U << 3);  ///< Lock bit set by the TZ software for the eDMA
        constexpr uint32_t NSA_LCDIF = (1U << 4);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_LCDIF = (1U << 5);  ///< Lock bit set by the TZ software for the LCDIF
        constexpr uint32_t NSA_CSI = (1U << 6);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_CSI = (1U << 7);  ///< Lock bit set by the TZ software for the CSI
        constexpr uint32_t NSA_PXP = (1U << 8);  ///< Non-Secure Access Policy indicator bit
        constexpr uint32_t L_PXP = (1U << 9);  ///< Lock bit set by the TZ software for the PXP
        constexpr uint32_t NSA_DCP = (1U << 10);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_DCP = (1U << 11);  ///< Lock bit set by the TZ software for the DCP
        constexpr uint32_t NSA_ENET = (1U << 14);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_ENET = (1U << 15);  ///< Lock bit set by the TZ software for the ENET1 and ENET2
        constexpr uint32_t NSA_USDHC1 = (1U << 16);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_USDHC1 = (1U << 17);  ///< Lock bit set by the TZ software for the USDHC1
        constexpr uint32_t NSA_USDHC2 = (1U << 18);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_USDHC2 = (1U << 19);  ///< Lock bit set by the TZ software for the USDHC2
        constexpr uint32_t NSA_TPSMP = (1U << 20);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_TPSMP = (1U << 21);  ///< Lock bit set by the TZ software for the TPSMP
        constexpr uint32_t NSA_USB = (1U << 22);  ///< Non-secure access policy indicator bit
        constexpr uint32_t L_USB = (1U << 23);  ///< Lock bit set by the TZ software for the USB
    }

    /// HPCONTROL0 Register bits
    namespace hpcontrol0_bits {
        constexpr uint32_t HPC_DMA = (1U << 2);  ///< Indicates the privilege/user mode for the eDMA
        constexpr uint32_t L_DMA = (1U << 3);  ///< Lock bit set by the TZ software for the eDMA
        constexpr uint32_t HPC_LCDIF = (1U << 4);  ///< Indicates the privilege/user mode for the LCDIF
        constexpr uint32_t L_LCDIF = (1U << 5);  ///< Lock bit set by the TZ software for the LCDIF
        constexpr uint32_t HPC_CSI = (1U << 6);  ///< Indicates the privilege/user mode for the CSI
        constexpr uint32_t L_CSI = (1U << 7);  ///< Lock bit set by the TZ software for the CSI
        constexpr uint32_t HPC_PXP = (1U << 8);  ///< Indicates the privilege/user mode for the PXP
        constexpr uint32_t L_PXP = (1U << 9);  ///< Lock bit set by the TZ software for the PXP
        constexpr uint32_t HPC_DCP = (1U << 10);  ///< Indicates the privilege/user mode for the DCP
        constexpr uint32_t L_DCP = (1U << 11);  ///< Lock bit set by the TZ software for the DCP
        constexpr uint32_t HPC_ENET = (1U << 14);  ///< Indicates the privilege/user mode for the ENET
        constexpr uint32_t L_ENET = (1U << 15);  ///< Lock bit set by the TZ software for the ENET
        constexpr uint32_t HPC_USDHC1 = (1U << 16);  ///< Indicates the privilege/user mode for the USDHC1
        constexpr uint32_t L_USDHC1 = (1U << 17);  ///< Lock bit set by the TZ software for the USDHC1
        constexpr uint32_t HPC_USDHC2 = (1U << 18);  ///< Indicates the privilege/user mode for the USDHC2
        constexpr uint32_t L_USDHC2 = (1U << 19);  ///< Lock bit set by the TZ software for the USDHC2.
        constexpr uint32_t HPC_TPSMP = (1U << 20);  ///< Indicates the privilege/user mode for the TPSMP
        constexpr uint32_t L_TPSMP = (1U << 21);  ///< Lock bit set by the TZ software for the TPSMP.
        constexpr uint32_t HPC_USB = (1U << 22);  ///< Indicates the privilege/user mode for the USB
        constexpr uint32_t L_USB = (1U << 23);  ///< Lock bit set by the TZ software for the USB.
    }

}

// ============================================================================
// TSC Peripheral
// ============================================================================

namespace tsc {
    /// Base addresses
    constexpr uint32_t TSC_BASE = 0x400E0000;

    /// TSC Register structure
    struct Registers {
        volatile uint32_t BASIC_SETTING;  ///< Offset: 0x00 - no description available
        volatile uint32_t PRE_CHARGE_TIME;  ///< Offset: 0x10 - no description available
        volatile uint32_t FLOW_CONTROL;  ///< Offset: 0x20 - Flow Control
        volatile uint32_t MEASEURE_VALUE;  ///< Offset: 0x30 - Measure Value
        volatile uint32_t INT_EN;  ///< Offset: 0x40 - Interrupt Enable
        volatile uint32_t INT_SIG_EN;  ///< Offset: 0x50 - Interrupt Signal Enable
        volatile uint32_t INT_STATUS;  ///< Offset: 0x60 - Intterrupt Status
        volatile uint32_t DEBUG_MODE;  ///< Offset: 0x70 - no description available
        volatile uint32_t DEBUG_MODE2;  ///< Offset: 0x80 - no description available
    };

    /// Peripheral instances
    inline Registers* TSC = reinterpret_cast<Registers*>(TSC_BASE);

    // Bit definitions
    /// BASIC_SETTING Register bits
    namespace basic_setting_bits {
        constexpr uint32_t AUTO_MEASURE = (1U << 0);  ///< Auto Measure
        constexpr uint32_t _4_5_WIRE = (1U << 4);  ///< 4/5 Wire detection
        constexpr uint32_t MEASURE_DELAY_TIME = (24 << 8);  ///< Measure Delay Time
    }

    /// PRE_CHARGE_TIME Register bits
    namespace pre_charge_time_bits {
        constexpr uint32_t PRE_CHARGE_TIME = (32 << 0);  ///< Before detection, the top screen needs some time before being pulled up to a high voltage.
    }

    /// FLOW_CONTROL Register bits
    namespace flow_control_bits {
        constexpr uint32_t SW_RST = (1U << 0);  ///< Soft Reset
        constexpr uint32_t START_MEASURE = (1U << 4);  ///< Start Measure
        constexpr uint32_t DROP_MEASURE = (1U << 8);  ///< Drop Measure
        constexpr uint32_t START_SENSE = (1U << 12);  ///< Start Sense
        constexpr uint32_t DISABLE = (1U << 16);  ///< This bit is for SW disable registers
    }

    /// MEASEURE_VALUE Register bits
    namespace measeure_value_bits {
        constexpr uint32_t Y_VALUE = (12 << 0);  ///< Y Value
        constexpr uint32_t X_VALUE = (12 << 16);  ///< X Value
    }

    /// INT_EN Register bits
    namespace int_en_bits {
        constexpr uint32_t MEASURE_INT_EN = (1U << 0);  ///< Measure Interrupt Enable
        constexpr uint32_t DETECT_INT_EN = (1U << 4);  ///< Detect Interrupt Enable
        constexpr uint32_t IDLE_SW_INT_EN = (1U << 12);  ///< Idle Software Interrupt Enable
    }

    /// INT_SIG_EN Register bits
    namespace int_sig_en_bits {
        constexpr uint32_t MEASURE_SIG_EN = (1U << 0);  ///< Measure Signal Enable
        constexpr uint32_t DETECT_SIG_EN = (1U << 4);  ///< Detect Signal Enable
        constexpr uint32_t VALID_SIG_EN = (1U << 8);  ///< Valid Signal Enable
        constexpr uint32_t IDLE_SW_SIG_EN = (1U << 12);  ///< Idle Software Signal Enable
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t MEASURE = (1U << 0);  ///< Measure Signal
        constexpr uint32_t DETECT = (1U << 4);  ///< Detect Signal
        constexpr uint32_t VALID = (1U << 8);  ///< Valid Signal
        constexpr uint32_t IDLE_SW = (1U << 12);  ///< Idle Software
    }

    /// DEBUG_MODE Register bits
    namespace debug_mode_bits {
        constexpr uint32_t ADC_CONV_VALUE = (12 << 0);  ///< ADC Conversion Value
        constexpr uint32_t ADC_COCO = (1U << 12);  ///< ADC COCO Signal
        constexpr uint32_t EXT_HWTS = (5 << 16);  ///< Hardware Trigger Select Signal
        constexpr uint32_t TRIGGER = (1U << 24);  ///< Trigger
        constexpr uint32_t ADC_COCO_CLEAR = (1U << 25);  ///< ADC Coco Clear
        constexpr uint32_t ADC_COCO_CLEAR_DISABLE = (1U << 26);  ///< ADC COCO Clear Disable
        constexpr uint32_t DEBUG_EN = (1U << 28);  ///< Debug Enable
    }

    /// DEBUG_MODE2 Register bits
    namespace debug_mode2_bits {
        constexpr uint32_t XPUL_PULL_DOWN = (1U << 0);  ///< XPUL Wire Pull Down Switch
        constexpr uint32_t XPUL_PULL_UP = (1U << 1);  ///< XPUL Wire Pull Up Switch
        constexpr uint32_t XPUL_200K_PULL_UP = (1U << 2);  ///< XPUL Wire 200K Pull Up Switch
        constexpr uint32_t XNUR_PULL_DOWN = (1U << 3);  ///< XNUR Wire Pull Down Switch
        constexpr uint32_t XNUR_PULL_UP = (1U << 4);  ///< XNUR Wire Pull Up Switch
        constexpr uint32_t XNUR_200K_PULL_UP = (1U << 5);  ///< XNUR Wire 200K Pull Up Switch
        constexpr uint32_t YPLL_PULL_DOWN = (1U << 6);  ///< YPLL Wire Pull Down Switch
        constexpr uint32_t YPLL_PULL_UP = (1U << 7);  ///< YPLL Wire Pull Up Switch
        constexpr uint32_t YPLL_200K_PULL_UP = (1U << 8);  ///< YPLL Wire 200K Pull Up Switch
        constexpr uint32_t YNLR_PULL_DOWN = (1U << 9);  ///< YNLR Wire Pull Down Switch
        constexpr uint32_t YNLR_PULL_UP = (1U << 10);  ///< YNLR Wire Pull Up Switch
        constexpr uint32_t YNLR_200K_PULL_UP = (1U << 11);  ///< YNLR Wire 200K Pull Up Switch
        constexpr uint32_t WIPER_PULL_DOWN = (1U << 12);  ///< Wiper Wire Pull Down Switch
        constexpr uint32_t WIPER_PULL_UP = (1U << 13);  ///< Wiper Wire Pull Up Switch
        constexpr uint32_t WIPER_200K_PULL_UP = (1U << 14);  ///< Wiper Wire 200K Pull Up Switch
        constexpr uint32_t DETECT_FOUR_WIRE = (1U << 16);  ///< Detect Four Wire
        constexpr uint32_t DETECT_FIVE_WIRE = (1U << 17);  ///< Detect Five Wire
        constexpr uint32_t STATE_MACHINE = (3 << 20);  ///< State Machine
        constexpr uint32_t INTERMEDIATE = (1U << 23);  ///< Intermediate State
        constexpr uint32_t DETECT_ENABLE_FOUR_WIRE = (1U << 24);  ///< Detect Enable Four Wire
        constexpr uint32_t DETECT_ENABLE_FIVE_WIRE = (1U << 28);  ///< Detect Enable Five Wire
        constexpr uint32_t DE_GLITCH = (2 << 29);  ///< This field indicates glitch threshold
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA0_BASE = 0x400E8000;
    constexpr uint32_t DMAMUX_BASE = 0x400EC000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT;  ///< Offset: 0x24 - Interrupt Request Register
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t EARS;  ///< Offset: 0x44 - Enable Asynchronous Request in Stop Register
        volatile uint32_t DCHPRI3;  ///< Offset: 0x100 - Channel n Priority Register
        volatile uint32_t DCHPRI2;  ///< Offset: 0x101 - Channel n Priority Register
        volatile uint32_t DCHPRI1;  ///< Offset: 0x102 - Channel n Priority Register
        volatile uint32_t DCHPRI0;  ///< Offset: 0x103 - Channel n Priority Register
        volatile uint32_t DCHPRI7;  ///< Offset: 0x104 - Channel n Priority Register
        volatile uint32_t DCHPRI6;  ///< Offset: 0x105 - Channel n Priority Register
        volatile uint32_t DCHPRI5;  ///< Offset: 0x106 - Channel n Priority Register
        volatile uint32_t DCHPRI4;  ///< Offset: 0x107 - Channel n Priority Register
        volatile uint32_t DCHPRI11;  ///< Offset: 0x108 - Channel n Priority Register
        volatile uint32_t DCHPRI10;  ///< Offset: 0x109 - Channel n Priority Register
        volatile uint32_t DCHPRI9;  ///< Offset: 0x10A - Channel n Priority Register
        volatile uint32_t DCHPRI8;  ///< Offset: 0x10B - Channel n Priority Register
        volatile uint32_t DCHPRI15;  ///< Offset: 0x10C - Channel n Priority Register
        volatile uint32_t DCHPRI14;  ///< Offset: 0x10D - Channel n Priority Register
        volatile uint32_t DCHPRI13;  ///< Offset: 0x10E - Channel n Priority Register
        volatile uint32_t DCHPRI12;  ///< Offset: 0x10F - Channel n Priority Register
        volatile uint32_t DCHPRI19;  ///< Offset: 0x110 - Channel n Priority Register
        volatile uint32_t DCHPRI18;  ///< Offset: 0x111 - Channel n Priority Register
        volatile uint32_t DCHPRI17;  ///< Offset: 0x112 - Channel n Priority Register
        volatile uint32_t DCHPRI16;  ///< Offset: 0x113 - Channel n Priority Register
        volatile uint32_t DCHPRI23;  ///< Offset: 0x114 - Channel n Priority Register
        volatile uint32_t DCHPRI22;  ///< Offset: 0x115 - Channel n Priority Register
        volatile uint32_t DCHPRI21;  ///< Offset: 0x116 - Channel n Priority Register
        volatile uint32_t DCHPRI20;  ///< Offset: 0x117 - Channel n Priority Register
        volatile uint32_t DCHPRI27;  ///< Offset: 0x118 - Channel n Priority Register
        volatile uint32_t DCHPRI26;  ///< Offset: 0x119 - Channel n Priority Register
        volatile uint32_t DCHPRI25;  ///< Offset: 0x11A - Channel n Priority Register
        volatile uint32_t DCHPRI24;  ///< Offset: 0x11B - Channel n Priority Register
        volatile uint32_t DCHPRI31;  ///< Offset: 0x11C - Channel n Priority Register
        volatile uint32_t DCHPRI30;  ///< Offset: 0x11D - Channel n Priority Register
        volatile uint32_t DCHPRI29;  ///< Offset: 0x11E - Channel n Priority Register
        volatile uint32_t DCHPRI28;  ///< Offset: 0x11F - Channel n Priority Register
        volatile uint32_t TCD0_SADDR;  ///< Offset: 0x1000 - TCD Source Address
        volatile uint32_t TCD0_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset
        volatile uint32_t TCD0_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes
        volatile uint32_t TCD0_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD0_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD0_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD0_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment
        volatile uint32_t TCD0_DADDR;  ///< Offset: 0x1010 - TCD Destination Address
        volatile uint32_t TCD0_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset
        volatile uint32_t TCD0_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD0_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD0_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD0_CSR;  ///< Offset: 0x101C - TCD Control and Status
        volatile uint32_t TCD0_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD0_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD1_SADDR;  ///< Offset: 0x1020 - TCD Source Address
        volatile uint32_t TCD1_SOFF;  ///< Offset: 0x1024 - TCD Signed Source Address Offset
        volatile uint32_t TCD1_ATTR;  ///< Offset: 0x1026 - TCD Transfer Attributes
        volatile uint32_t TCD1_NBYTES_MLNO;  ///< Offset: 0x1028 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD1_NBYTES_MLOFFNO;  ///< Offset: 0x1028 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD1_NBYTES_MLOFFYES;  ///< Offset: 0x1028 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD1_SLAST;  ///< Offset: 0x102C - TCD Last Source Address Adjustment
        volatile uint32_t TCD1_DADDR;  ///< Offset: 0x1030 - TCD Destination Address
        volatile uint32_t TCD1_DOFF;  ///< Offset: 0x1034 - TCD Signed Destination Address Offset
        volatile uint32_t TCD1_CITER_ELINKNO;  ///< Offset: 0x1036 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD1_CITER_ELINKYES;  ///< Offset: 0x1036 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD1_DLASTSGA;  ///< Offset: 0x1038 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD1_CSR;  ///< Offset: 0x103C - TCD Control and Status
        volatile uint32_t TCD1_BITER_ELINKNO;  ///< Offset: 0x103E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD1_BITER_ELINKYES;  ///< Offset: 0x103E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD2_SADDR;  ///< Offset: 0x1040 - TCD Source Address
        volatile uint32_t TCD2_SOFF;  ///< Offset: 0x1044 - TCD Signed Source Address Offset
        volatile uint32_t TCD2_ATTR;  ///< Offset: 0x1046 - TCD Transfer Attributes
        volatile uint32_t TCD2_NBYTES_MLNO;  ///< Offset: 0x1048 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD2_NBYTES_MLOFFNO;  ///< Offset: 0x1048 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD2_NBYTES_MLOFFYES;  ///< Offset: 0x1048 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD2_SLAST;  ///< Offset: 0x104C - TCD Last Source Address Adjustment
        volatile uint32_t TCD2_DADDR;  ///< Offset: 0x1050 - TCD Destination Address
        volatile uint32_t TCD2_DOFF;  ///< Offset: 0x1054 - TCD Signed Destination Address Offset
        volatile uint32_t TCD2_CITER_ELINKNO;  ///< Offset: 0x1056 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD2_CITER_ELINKYES;  ///< Offset: 0x1056 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD2_DLASTSGA;  ///< Offset: 0x1058 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD2_CSR;  ///< Offset: 0x105C - TCD Control and Status
        volatile uint32_t TCD2_BITER_ELINKNO;  ///< Offset: 0x105E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD2_BITER_ELINKYES;  ///< Offset: 0x105E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD3_SADDR;  ///< Offset: 0x1060 - TCD Source Address
        volatile uint32_t TCD3_SOFF;  ///< Offset: 0x1064 - TCD Signed Source Address Offset
        volatile uint32_t TCD3_ATTR;  ///< Offset: 0x1066 - TCD Transfer Attributes
        volatile uint32_t TCD3_NBYTES_MLNO;  ///< Offset: 0x1068 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD3_NBYTES_MLOFFNO;  ///< Offset: 0x1068 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD3_NBYTES_MLOFFYES;  ///< Offset: 0x1068 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD3_SLAST;  ///< Offset: 0x106C - TCD Last Source Address Adjustment
        volatile uint32_t TCD3_DADDR;  ///< Offset: 0x1070 - TCD Destination Address
        volatile uint32_t TCD3_DOFF;  ///< Offset: 0x1074 - TCD Signed Destination Address Offset
        volatile uint32_t TCD3_CITER_ELINKNO;  ///< Offset: 0x1076 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD3_CITER_ELINKYES;  ///< Offset: 0x1076 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD3_DLASTSGA;  ///< Offset: 0x1078 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD3_CSR;  ///< Offset: 0x107C - TCD Control and Status
        volatile uint32_t TCD3_BITER_ELINKNO;  ///< Offset: 0x107E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD3_BITER_ELINKYES;  ///< Offset: 0x107E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD4_SADDR;  ///< Offset: 0x1080 - TCD Source Address
        volatile uint32_t TCD4_SOFF;  ///< Offset: 0x1084 - TCD Signed Source Address Offset
        volatile uint32_t TCD4_ATTR;  ///< Offset: 0x1086 - TCD Transfer Attributes
        volatile uint32_t TCD4_NBYTES_MLNO;  ///< Offset: 0x1088 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD4_NBYTES_MLOFFNO;  ///< Offset: 0x1088 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD4_NBYTES_MLOFFYES;  ///< Offset: 0x1088 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD4_SLAST;  ///< Offset: 0x108C - TCD Last Source Address Adjustment
        volatile uint32_t TCD4_DADDR;  ///< Offset: 0x1090 - TCD Destination Address
        volatile uint32_t TCD4_DOFF;  ///< Offset: 0x1094 - TCD Signed Destination Address Offset
        volatile uint32_t TCD4_CITER_ELINKNO;  ///< Offset: 0x1096 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD4_CITER_ELINKYES;  ///< Offset: 0x1096 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD4_DLASTSGA;  ///< Offset: 0x1098 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD4_CSR;  ///< Offset: 0x109C - TCD Control and Status
        volatile uint32_t TCD4_BITER_ELINKNO;  ///< Offset: 0x109E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD4_BITER_ELINKYES;  ///< Offset: 0x109E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD5_SADDR;  ///< Offset: 0x10A0 - TCD Source Address
        volatile uint32_t TCD5_SOFF;  ///< Offset: 0x10A4 - TCD Signed Source Address Offset
        volatile uint32_t TCD5_ATTR;  ///< Offset: 0x10A6 - TCD Transfer Attributes
        volatile uint32_t TCD5_NBYTES_MLNO;  ///< Offset: 0x10A8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD5_NBYTES_MLOFFNO;  ///< Offset: 0x10A8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD5_NBYTES_MLOFFYES;  ///< Offset: 0x10A8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD5_SLAST;  ///< Offset: 0x10AC - TCD Last Source Address Adjustment
        volatile uint32_t TCD5_DADDR;  ///< Offset: 0x10B0 - TCD Destination Address
        volatile uint32_t TCD5_DOFF;  ///< Offset: 0x10B4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD5_CITER_ELINKNO;  ///< Offset: 0x10B6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD5_CITER_ELINKYES;  ///< Offset: 0x10B6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD5_DLASTSGA;  ///< Offset: 0x10B8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD5_CSR;  ///< Offset: 0x10BC - TCD Control and Status
        volatile uint32_t TCD5_BITER_ELINKNO;  ///< Offset: 0x10BE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD5_BITER_ELINKYES;  ///< Offset: 0x10BE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD6_SADDR;  ///< Offset: 0x10C0 - TCD Source Address
        volatile uint32_t TCD6_SOFF;  ///< Offset: 0x10C4 - TCD Signed Source Address Offset
        volatile uint32_t TCD6_ATTR;  ///< Offset: 0x10C6 - TCD Transfer Attributes
        volatile uint32_t TCD6_NBYTES_MLNO;  ///< Offset: 0x10C8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD6_NBYTES_MLOFFNO;  ///< Offset: 0x10C8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD6_NBYTES_MLOFFYES;  ///< Offset: 0x10C8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD6_SLAST;  ///< Offset: 0x10CC - TCD Last Source Address Adjustment
        volatile uint32_t TCD6_DADDR;  ///< Offset: 0x10D0 - TCD Destination Address
        volatile uint32_t TCD6_DOFF;  ///< Offset: 0x10D4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD6_CITER_ELINKNO;  ///< Offset: 0x10D6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD6_CITER_ELINKYES;  ///< Offset: 0x10D6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD6_DLASTSGA;  ///< Offset: 0x10D8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD6_CSR;  ///< Offset: 0x10DC - TCD Control and Status
        volatile uint32_t TCD6_BITER_ELINKNO;  ///< Offset: 0x10DE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD6_BITER_ELINKYES;  ///< Offset: 0x10DE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD7_SADDR;  ///< Offset: 0x10E0 - TCD Source Address
        volatile uint32_t TCD7_SOFF;  ///< Offset: 0x10E4 - TCD Signed Source Address Offset
        volatile uint32_t TCD7_ATTR;  ///< Offset: 0x10E6 - TCD Transfer Attributes
        volatile uint32_t TCD7_NBYTES_MLNO;  ///< Offset: 0x10E8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD7_NBYTES_MLOFFNO;  ///< Offset: 0x10E8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD7_NBYTES_MLOFFYES;  ///< Offset: 0x10E8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD7_SLAST;  ///< Offset: 0x10EC - TCD Last Source Address Adjustment
        volatile uint32_t TCD7_DADDR;  ///< Offset: 0x10F0 - TCD Destination Address
        volatile uint32_t TCD7_DOFF;  ///< Offset: 0x10F4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD7_CITER_ELINKNO;  ///< Offset: 0x10F6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD7_CITER_ELINKYES;  ///< Offset: 0x10F6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD7_DLASTSGA;  ///< Offset: 0x10F8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD7_CSR;  ///< Offset: 0x10FC - TCD Control and Status
        volatile uint32_t TCD7_BITER_ELINKNO;  ///< Offset: 0x10FE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD7_BITER_ELINKYES;  ///< Offset: 0x10FE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD8_SADDR;  ///< Offset: 0x1100 - TCD Source Address
        volatile uint32_t TCD8_SOFF;  ///< Offset: 0x1104 - TCD Signed Source Address Offset
        volatile uint32_t TCD8_ATTR;  ///< Offset: 0x1106 - TCD Transfer Attributes
        volatile uint32_t TCD8_NBYTES_MLNO;  ///< Offset: 0x1108 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD8_NBYTES_MLOFFNO;  ///< Offset: 0x1108 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD8_NBYTES_MLOFFYES;  ///< Offset: 0x1108 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD8_SLAST;  ///< Offset: 0x110C - TCD Last Source Address Adjustment
        volatile uint32_t TCD8_DADDR;  ///< Offset: 0x1110 - TCD Destination Address
        volatile uint32_t TCD8_DOFF;  ///< Offset: 0x1114 - TCD Signed Destination Address Offset
        volatile uint32_t TCD8_CITER_ELINKNO;  ///< Offset: 0x1116 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD8_CITER_ELINKYES;  ///< Offset: 0x1116 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD8_DLASTSGA;  ///< Offset: 0x1118 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD8_CSR;  ///< Offset: 0x111C - TCD Control and Status
        volatile uint32_t TCD8_BITER_ELINKNO;  ///< Offset: 0x111E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD8_BITER_ELINKYES;  ///< Offset: 0x111E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD9_SADDR;  ///< Offset: 0x1120 - TCD Source Address
        volatile uint32_t TCD9_SOFF;  ///< Offset: 0x1124 - TCD Signed Source Address Offset
        volatile uint32_t TCD9_ATTR;  ///< Offset: 0x1126 - TCD Transfer Attributes
        volatile uint32_t TCD9_NBYTES_MLNO;  ///< Offset: 0x1128 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD9_NBYTES_MLOFFNO;  ///< Offset: 0x1128 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD9_NBYTES_MLOFFYES;  ///< Offset: 0x1128 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD9_SLAST;  ///< Offset: 0x112C - TCD Last Source Address Adjustment
        volatile uint32_t TCD9_DADDR;  ///< Offset: 0x1130 - TCD Destination Address
        volatile uint32_t TCD9_DOFF;  ///< Offset: 0x1134 - TCD Signed Destination Address Offset
        volatile uint32_t TCD9_CITER_ELINKNO;  ///< Offset: 0x1136 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD9_CITER_ELINKYES;  ///< Offset: 0x1136 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD9_DLASTSGA;  ///< Offset: 0x1138 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD9_CSR;  ///< Offset: 0x113C - TCD Control and Status
        volatile uint32_t TCD9_BITER_ELINKNO;  ///< Offset: 0x113E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD9_BITER_ELINKYES;  ///< Offset: 0x113E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD10_SADDR;  ///< Offset: 0x1140 - TCD Source Address
        volatile uint32_t TCD10_SOFF;  ///< Offset: 0x1144 - TCD Signed Source Address Offset
        volatile uint32_t TCD10_ATTR;  ///< Offset: 0x1146 - TCD Transfer Attributes
        volatile uint32_t TCD10_NBYTES_MLNO;  ///< Offset: 0x1148 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD10_NBYTES_MLOFFNO;  ///< Offset: 0x1148 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD10_NBYTES_MLOFFYES;  ///< Offset: 0x1148 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD10_SLAST;  ///< Offset: 0x114C - TCD Last Source Address Adjustment
        volatile uint32_t TCD10_DADDR;  ///< Offset: 0x1150 - TCD Destination Address
        volatile uint32_t TCD10_DOFF;  ///< Offset: 0x1154 - TCD Signed Destination Address Offset
        volatile uint32_t TCD10_CITER_ELINKNO;  ///< Offset: 0x1156 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD10_CITER_ELINKYES;  ///< Offset: 0x1156 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD10_DLASTSGA;  ///< Offset: 0x1158 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD10_CSR;  ///< Offset: 0x115C - TCD Control and Status
        volatile uint32_t TCD10_BITER_ELINKNO;  ///< Offset: 0x115E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD10_BITER_ELINKYES;  ///< Offset: 0x115E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD11_SADDR;  ///< Offset: 0x1160 - TCD Source Address
        volatile uint32_t TCD11_SOFF;  ///< Offset: 0x1164 - TCD Signed Source Address Offset
        volatile uint32_t TCD11_ATTR;  ///< Offset: 0x1166 - TCD Transfer Attributes
        volatile uint32_t TCD11_NBYTES_MLNO;  ///< Offset: 0x1168 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD11_NBYTES_MLOFFNO;  ///< Offset: 0x1168 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD11_NBYTES_MLOFFYES;  ///< Offset: 0x1168 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD11_SLAST;  ///< Offset: 0x116C - TCD Last Source Address Adjustment
        volatile uint32_t TCD11_DADDR;  ///< Offset: 0x1170 - TCD Destination Address
        volatile uint32_t TCD11_DOFF;  ///< Offset: 0x1174 - TCD Signed Destination Address Offset
        volatile uint32_t TCD11_CITER_ELINKNO;  ///< Offset: 0x1176 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD11_CITER_ELINKYES;  ///< Offset: 0x1176 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD11_DLASTSGA;  ///< Offset: 0x1178 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD11_CSR;  ///< Offset: 0x117C - TCD Control and Status
        volatile uint32_t TCD11_BITER_ELINKNO;  ///< Offset: 0x117E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD11_BITER_ELINKYES;  ///< Offset: 0x117E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD12_SADDR;  ///< Offset: 0x1180 - TCD Source Address
        volatile uint32_t TCD12_SOFF;  ///< Offset: 0x1184 - TCD Signed Source Address Offset
        volatile uint32_t TCD12_ATTR;  ///< Offset: 0x1186 - TCD Transfer Attributes
        volatile uint32_t TCD12_NBYTES_MLNO;  ///< Offset: 0x1188 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD12_NBYTES_MLOFFNO;  ///< Offset: 0x1188 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD12_NBYTES_MLOFFYES;  ///< Offset: 0x1188 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD12_SLAST;  ///< Offset: 0x118C - TCD Last Source Address Adjustment
        volatile uint32_t TCD12_DADDR;  ///< Offset: 0x1190 - TCD Destination Address
        volatile uint32_t TCD12_DOFF;  ///< Offset: 0x1194 - TCD Signed Destination Address Offset
        volatile uint32_t TCD12_CITER_ELINKNO;  ///< Offset: 0x1196 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD12_CITER_ELINKYES;  ///< Offset: 0x1196 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD12_DLASTSGA;  ///< Offset: 0x1198 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD12_CSR;  ///< Offset: 0x119C - TCD Control and Status
        volatile uint32_t TCD12_BITER_ELINKNO;  ///< Offset: 0x119E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD12_BITER_ELINKYES;  ///< Offset: 0x119E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD13_SADDR;  ///< Offset: 0x11A0 - TCD Source Address
        volatile uint32_t TCD13_SOFF;  ///< Offset: 0x11A4 - TCD Signed Source Address Offset
        volatile uint32_t TCD13_ATTR;  ///< Offset: 0x11A6 - TCD Transfer Attributes
        volatile uint32_t TCD13_NBYTES_MLNO;  ///< Offset: 0x11A8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD13_NBYTES_MLOFFNO;  ///< Offset: 0x11A8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD13_NBYTES_MLOFFYES;  ///< Offset: 0x11A8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD13_SLAST;  ///< Offset: 0x11AC - TCD Last Source Address Adjustment
        volatile uint32_t TCD13_DADDR;  ///< Offset: 0x11B0 - TCD Destination Address
        volatile uint32_t TCD13_DOFF;  ///< Offset: 0x11B4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD13_CITER_ELINKNO;  ///< Offset: 0x11B6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD13_CITER_ELINKYES;  ///< Offset: 0x11B6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD13_DLASTSGA;  ///< Offset: 0x11B8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD13_CSR;  ///< Offset: 0x11BC - TCD Control and Status
        volatile uint32_t TCD13_BITER_ELINKNO;  ///< Offset: 0x11BE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD13_BITER_ELINKYES;  ///< Offset: 0x11BE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD14_SADDR;  ///< Offset: 0x11C0 - TCD Source Address
        volatile uint32_t TCD14_SOFF;  ///< Offset: 0x11C4 - TCD Signed Source Address Offset
        volatile uint32_t TCD14_ATTR;  ///< Offset: 0x11C6 - TCD Transfer Attributes
        volatile uint32_t TCD14_NBYTES_MLNO;  ///< Offset: 0x11C8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD14_NBYTES_MLOFFNO;  ///< Offset: 0x11C8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD14_NBYTES_MLOFFYES;  ///< Offset: 0x11C8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD14_SLAST;  ///< Offset: 0x11CC - TCD Last Source Address Adjustment
        volatile uint32_t TCD14_DADDR;  ///< Offset: 0x11D0 - TCD Destination Address
        volatile uint32_t TCD14_DOFF;  ///< Offset: 0x11D4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD14_CITER_ELINKNO;  ///< Offset: 0x11D6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD14_CITER_ELINKYES;  ///< Offset: 0x11D6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD14_DLASTSGA;  ///< Offset: 0x11D8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD14_CSR;  ///< Offset: 0x11DC - TCD Control and Status
        volatile uint32_t TCD14_BITER_ELINKNO;  ///< Offset: 0x11DE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD14_BITER_ELINKYES;  ///< Offset: 0x11DE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD15_SADDR;  ///< Offset: 0x11E0 - TCD Source Address
        volatile uint32_t TCD15_SOFF;  ///< Offset: 0x11E4 - TCD Signed Source Address Offset
        volatile uint32_t TCD15_ATTR;  ///< Offset: 0x11E6 - TCD Transfer Attributes
        volatile uint32_t TCD15_NBYTES_MLNO;  ///< Offset: 0x11E8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD15_NBYTES_MLOFFNO;  ///< Offset: 0x11E8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD15_NBYTES_MLOFFYES;  ///< Offset: 0x11E8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD15_SLAST;  ///< Offset: 0x11EC - TCD Last Source Address Adjustment
        volatile uint32_t TCD15_DADDR;  ///< Offset: 0x11F0 - TCD Destination Address
        volatile uint32_t TCD15_DOFF;  ///< Offset: 0x11F4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD15_CITER_ELINKNO;  ///< Offset: 0x11F6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD15_CITER_ELINKYES;  ///< Offset: 0x11F6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD15_DLASTSGA;  ///< Offset: 0x11F8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD15_CSR;  ///< Offset: 0x11FC - TCD Control and Status
        volatile uint32_t TCD15_BITER_ELINKNO;  ///< Offset: 0x11FE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD15_BITER_ELINKYES;  ///< Offset: 0x11FE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD16_SADDR;  ///< Offset: 0x1200 - TCD Source Address
        volatile uint32_t TCD16_SOFF;  ///< Offset: 0x1204 - TCD Signed Source Address Offset
        volatile uint32_t TCD16_ATTR;  ///< Offset: 0x1206 - TCD Transfer Attributes
        volatile uint32_t TCD16_NBYTES_MLNO;  ///< Offset: 0x1208 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD16_NBYTES_MLOFFNO;  ///< Offset: 0x1208 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD16_NBYTES_MLOFFYES;  ///< Offset: 0x1208 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD16_SLAST;  ///< Offset: 0x120C - TCD Last Source Address Adjustment
        volatile uint32_t TCD16_DADDR;  ///< Offset: 0x1210 - TCD Destination Address
        volatile uint32_t TCD16_DOFF;  ///< Offset: 0x1214 - TCD Signed Destination Address Offset
        volatile uint32_t TCD16_CITER_ELINKNO;  ///< Offset: 0x1216 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD16_CITER_ELINKYES;  ///< Offset: 0x1216 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD16_DLASTSGA;  ///< Offset: 0x1218 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD16_CSR;  ///< Offset: 0x121C - TCD Control and Status
        volatile uint32_t TCD16_BITER_ELINKNO;  ///< Offset: 0x121E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD16_BITER_ELINKYES;  ///< Offset: 0x121E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD17_SADDR;  ///< Offset: 0x1220 - TCD Source Address
        volatile uint32_t TCD17_SOFF;  ///< Offset: 0x1224 - TCD Signed Source Address Offset
        volatile uint32_t TCD17_ATTR;  ///< Offset: 0x1226 - TCD Transfer Attributes
        volatile uint32_t TCD17_NBYTES_MLNO;  ///< Offset: 0x1228 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD17_NBYTES_MLOFFNO;  ///< Offset: 0x1228 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD17_NBYTES_MLOFFYES;  ///< Offset: 0x1228 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD17_SLAST;  ///< Offset: 0x122C - TCD Last Source Address Adjustment
        volatile uint32_t TCD17_DADDR;  ///< Offset: 0x1230 - TCD Destination Address
        volatile uint32_t TCD17_DOFF;  ///< Offset: 0x1234 - TCD Signed Destination Address Offset
        volatile uint32_t TCD17_CITER_ELINKNO;  ///< Offset: 0x1236 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD17_CITER_ELINKYES;  ///< Offset: 0x1236 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD17_DLASTSGA;  ///< Offset: 0x1238 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD17_CSR;  ///< Offset: 0x123C - TCD Control and Status
        volatile uint32_t TCD17_BITER_ELINKNO;  ///< Offset: 0x123E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD17_BITER_ELINKYES;  ///< Offset: 0x123E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD18_SADDR;  ///< Offset: 0x1240 - TCD Source Address
        volatile uint32_t TCD18_SOFF;  ///< Offset: 0x1244 - TCD Signed Source Address Offset
        volatile uint32_t TCD18_ATTR;  ///< Offset: 0x1246 - TCD Transfer Attributes
        volatile uint32_t TCD18_NBYTES_MLNO;  ///< Offset: 0x1248 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD18_NBYTES_MLOFFNO;  ///< Offset: 0x1248 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD18_NBYTES_MLOFFYES;  ///< Offset: 0x1248 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD18_SLAST;  ///< Offset: 0x124C - TCD Last Source Address Adjustment
        volatile uint32_t TCD18_DADDR;  ///< Offset: 0x1250 - TCD Destination Address
        volatile uint32_t TCD18_DOFF;  ///< Offset: 0x1254 - TCD Signed Destination Address Offset
        volatile uint32_t TCD18_CITER_ELINKNO;  ///< Offset: 0x1256 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD18_CITER_ELINKYES;  ///< Offset: 0x1256 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD18_DLASTSGA;  ///< Offset: 0x1258 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD18_CSR;  ///< Offset: 0x125C - TCD Control and Status
        volatile uint32_t TCD18_BITER_ELINKNO;  ///< Offset: 0x125E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD18_BITER_ELINKYES;  ///< Offset: 0x125E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD19_SADDR;  ///< Offset: 0x1260 - TCD Source Address
        volatile uint32_t TCD19_SOFF;  ///< Offset: 0x1264 - TCD Signed Source Address Offset
        volatile uint32_t TCD19_ATTR;  ///< Offset: 0x1266 - TCD Transfer Attributes
        volatile uint32_t TCD19_NBYTES_MLNO;  ///< Offset: 0x1268 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD19_NBYTES_MLOFFNO;  ///< Offset: 0x1268 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD19_NBYTES_MLOFFYES;  ///< Offset: 0x1268 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD19_SLAST;  ///< Offset: 0x126C - TCD Last Source Address Adjustment
        volatile uint32_t TCD19_DADDR;  ///< Offset: 0x1270 - TCD Destination Address
        volatile uint32_t TCD19_DOFF;  ///< Offset: 0x1274 - TCD Signed Destination Address Offset
        volatile uint32_t TCD19_CITER_ELINKNO;  ///< Offset: 0x1276 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD19_CITER_ELINKYES;  ///< Offset: 0x1276 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD19_DLASTSGA;  ///< Offset: 0x1278 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD19_CSR;  ///< Offset: 0x127C - TCD Control and Status
        volatile uint32_t TCD19_BITER_ELINKNO;  ///< Offset: 0x127E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD19_BITER_ELINKYES;  ///< Offset: 0x127E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD20_SADDR;  ///< Offset: 0x1280 - TCD Source Address
        volatile uint32_t TCD20_SOFF;  ///< Offset: 0x1284 - TCD Signed Source Address Offset
        volatile uint32_t TCD20_ATTR;  ///< Offset: 0x1286 - TCD Transfer Attributes
        volatile uint32_t TCD20_NBYTES_MLNO;  ///< Offset: 0x1288 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD20_NBYTES_MLOFFNO;  ///< Offset: 0x1288 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD20_NBYTES_MLOFFYES;  ///< Offset: 0x1288 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD20_SLAST;  ///< Offset: 0x128C - TCD Last Source Address Adjustment
        volatile uint32_t TCD20_DADDR;  ///< Offset: 0x1290 - TCD Destination Address
        volatile uint32_t TCD20_DOFF;  ///< Offset: 0x1294 - TCD Signed Destination Address Offset
        volatile uint32_t TCD20_CITER_ELINKNO;  ///< Offset: 0x1296 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD20_CITER_ELINKYES;  ///< Offset: 0x1296 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD20_DLASTSGA;  ///< Offset: 0x1298 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD20_CSR;  ///< Offset: 0x129C - TCD Control and Status
        volatile uint32_t TCD20_BITER_ELINKNO;  ///< Offset: 0x129E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD20_BITER_ELINKYES;  ///< Offset: 0x129E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD21_SADDR;  ///< Offset: 0x12A0 - TCD Source Address
        volatile uint32_t TCD21_SOFF;  ///< Offset: 0x12A4 - TCD Signed Source Address Offset
        volatile uint32_t TCD21_ATTR;  ///< Offset: 0x12A6 - TCD Transfer Attributes
        volatile uint32_t TCD21_NBYTES_MLNO;  ///< Offset: 0x12A8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD21_NBYTES_MLOFFNO;  ///< Offset: 0x12A8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD21_NBYTES_MLOFFYES;  ///< Offset: 0x12A8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD21_SLAST;  ///< Offset: 0x12AC - TCD Last Source Address Adjustment
        volatile uint32_t TCD21_DADDR;  ///< Offset: 0x12B0 - TCD Destination Address
        volatile uint32_t TCD21_DOFF;  ///< Offset: 0x12B4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD21_CITER_ELINKNO;  ///< Offset: 0x12B6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD21_CITER_ELINKYES;  ///< Offset: 0x12B6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD21_DLASTSGA;  ///< Offset: 0x12B8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD21_CSR;  ///< Offset: 0x12BC - TCD Control and Status
        volatile uint32_t TCD21_BITER_ELINKNO;  ///< Offset: 0x12BE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD21_BITER_ELINKYES;  ///< Offset: 0x12BE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD22_SADDR;  ///< Offset: 0x12C0 - TCD Source Address
        volatile uint32_t TCD22_SOFF;  ///< Offset: 0x12C4 - TCD Signed Source Address Offset
        volatile uint32_t TCD22_ATTR;  ///< Offset: 0x12C6 - TCD Transfer Attributes
        volatile uint32_t TCD22_NBYTES_MLNO;  ///< Offset: 0x12C8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD22_NBYTES_MLOFFNO;  ///< Offset: 0x12C8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD22_NBYTES_MLOFFYES;  ///< Offset: 0x12C8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD22_SLAST;  ///< Offset: 0x12CC - TCD Last Source Address Adjustment
        volatile uint32_t TCD22_DADDR;  ///< Offset: 0x12D0 - TCD Destination Address
        volatile uint32_t TCD22_DOFF;  ///< Offset: 0x12D4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD22_CITER_ELINKNO;  ///< Offset: 0x12D6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD22_CITER_ELINKYES;  ///< Offset: 0x12D6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD22_DLASTSGA;  ///< Offset: 0x12D8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD22_CSR;  ///< Offset: 0x12DC - TCD Control and Status
        volatile uint32_t TCD22_BITER_ELINKNO;  ///< Offset: 0x12DE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD22_BITER_ELINKYES;  ///< Offset: 0x12DE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD23_SADDR;  ///< Offset: 0x12E0 - TCD Source Address
        volatile uint32_t TCD23_SOFF;  ///< Offset: 0x12E4 - TCD Signed Source Address Offset
        volatile uint32_t TCD23_ATTR;  ///< Offset: 0x12E6 - TCD Transfer Attributes
        volatile uint32_t TCD23_NBYTES_MLNO;  ///< Offset: 0x12E8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD23_NBYTES_MLOFFNO;  ///< Offset: 0x12E8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD23_NBYTES_MLOFFYES;  ///< Offset: 0x12E8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD23_SLAST;  ///< Offset: 0x12EC - TCD Last Source Address Adjustment
        volatile uint32_t TCD23_DADDR;  ///< Offset: 0x12F0 - TCD Destination Address
        volatile uint32_t TCD23_DOFF;  ///< Offset: 0x12F4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD23_CITER_ELINKNO;  ///< Offset: 0x12F6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD23_CITER_ELINKYES;  ///< Offset: 0x12F6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD23_DLASTSGA;  ///< Offset: 0x12F8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD23_CSR;  ///< Offset: 0x12FC - TCD Control and Status
        volatile uint32_t TCD23_BITER_ELINKNO;  ///< Offset: 0x12FE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD23_BITER_ELINKYES;  ///< Offset: 0x12FE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD24_SADDR;  ///< Offset: 0x1300 - TCD Source Address
        volatile uint32_t TCD24_SOFF;  ///< Offset: 0x1304 - TCD Signed Source Address Offset
        volatile uint32_t TCD24_ATTR;  ///< Offset: 0x1306 - TCD Transfer Attributes
        volatile uint32_t TCD24_NBYTES_MLNO;  ///< Offset: 0x1308 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD24_NBYTES_MLOFFNO;  ///< Offset: 0x1308 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD24_NBYTES_MLOFFYES;  ///< Offset: 0x1308 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD24_SLAST;  ///< Offset: 0x130C - TCD Last Source Address Adjustment
        volatile uint32_t TCD24_DADDR;  ///< Offset: 0x1310 - TCD Destination Address
        volatile uint32_t TCD24_DOFF;  ///< Offset: 0x1314 - TCD Signed Destination Address Offset
        volatile uint32_t TCD24_CITER_ELINKNO;  ///< Offset: 0x1316 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD24_CITER_ELINKYES;  ///< Offset: 0x1316 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD24_DLASTSGA;  ///< Offset: 0x1318 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD24_CSR;  ///< Offset: 0x131C - TCD Control and Status
        volatile uint32_t TCD24_BITER_ELINKNO;  ///< Offset: 0x131E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD24_BITER_ELINKYES;  ///< Offset: 0x131E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD25_SADDR;  ///< Offset: 0x1320 - TCD Source Address
        volatile uint32_t TCD25_SOFF;  ///< Offset: 0x1324 - TCD Signed Source Address Offset
        volatile uint32_t TCD25_ATTR;  ///< Offset: 0x1326 - TCD Transfer Attributes
        volatile uint32_t TCD25_NBYTES_MLNO;  ///< Offset: 0x1328 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD25_NBYTES_MLOFFNO;  ///< Offset: 0x1328 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD25_NBYTES_MLOFFYES;  ///< Offset: 0x1328 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD25_SLAST;  ///< Offset: 0x132C - TCD Last Source Address Adjustment
        volatile uint32_t TCD25_DADDR;  ///< Offset: 0x1330 - TCD Destination Address
        volatile uint32_t TCD25_DOFF;  ///< Offset: 0x1334 - TCD Signed Destination Address Offset
        volatile uint32_t TCD25_CITER_ELINKNO;  ///< Offset: 0x1336 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD25_CITER_ELINKYES;  ///< Offset: 0x1336 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD25_DLASTSGA;  ///< Offset: 0x1338 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD25_CSR;  ///< Offset: 0x133C - TCD Control and Status
        volatile uint32_t TCD25_BITER_ELINKNO;  ///< Offset: 0x133E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD25_BITER_ELINKYES;  ///< Offset: 0x133E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD26_SADDR;  ///< Offset: 0x1340 - TCD Source Address
        volatile uint32_t TCD26_SOFF;  ///< Offset: 0x1344 - TCD Signed Source Address Offset
        volatile uint32_t TCD26_ATTR;  ///< Offset: 0x1346 - TCD Transfer Attributes
        volatile uint32_t TCD26_NBYTES_MLNO;  ///< Offset: 0x1348 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD26_NBYTES_MLOFFNO;  ///< Offset: 0x1348 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD26_NBYTES_MLOFFYES;  ///< Offset: 0x1348 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD26_SLAST;  ///< Offset: 0x134C - TCD Last Source Address Adjustment
        volatile uint32_t TCD26_DADDR;  ///< Offset: 0x1350 - TCD Destination Address
        volatile uint32_t TCD26_DOFF;  ///< Offset: 0x1354 - TCD Signed Destination Address Offset
        volatile uint32_t TCD26_CITER_ELINKNO;  ///< Offset: 0x1356 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD26_CITER_ELINKYES;  ///< Offset: 0x1356 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD26_DLASTSGA;  ///< Offset: 0x1358 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD26_CSR;  ///< Offset: 0x135C - TCD Control and Status
        volatile uint32_t TCD26_BITER_ELINKNO;  ///< Offset: 0x135E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD26_BITER_ELINKYES;  ///< Offset: 0x135E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD27_SADDR;  ///< Offset: 0x1360 - TCD Source Address
        volatile uint32_t TCD27_SOFF;  ///< Offset: 0x1364 - TCD Signed Source Address Offset
        volatile uint32_t TCD27_ATTR;  ///< Offset: 0x1366 - TCD Transfer Attributes
        volatile uint32_t TCD27_NBYTES_MLNO;  ///< Offset: 0x1368 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD27_NBYTES_MLOFFNO;  ///< Offset: 0x1368 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD27_NBYTES_MLOFFYES;  ///< Offset: 0x1368 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD27_SLAST;  ///< Offset: 0x136C - TCD Last Source Address Adjustment
        volatile uint32_t TCD27_DADDR;  ///< Offset: 0x1370 - TCD Destination Address
        volatile uint32_t TCD27_DOFF;  ///< Offset: 0x1374 - TCD Signed Destination Address Offset
        volatile uint32_t TCD27_CITER_ELINKNO;  ///< Offset: 0x1376 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD27_CITER_ELINKYES;  ///< Offset: 0x1376 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD27_DLASTSGA;  ///< Offset: 0x1378 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD27_CSR;  ///< Offset: 0x137C - TCD Control and Status
        volatile uint32_t TCD27_BITER_ELINKNO;  ///< Offset: 0x137E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD27_BITER_ELINKYES;  ///< Offset: 0x137E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD28_SADDR;  ///< Offset: 0x1380 - TCD Source Address
        volatile uint32_t TCD28_SOFF;  ///< Offset: 0x1384 - TCD Signed Source Address Offset
        volatile uint32_t TCD28_ATTR;  ///< Offset: 0x1386 - TCD Transfer Attributes
        volatile uint32_t TCD28_NBYTES_MLNO;  ///< Offset: 0x1388 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD28_NBYTES_MLOFFNO;  ///< Offset: 0x1388 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD28_NBYTES_MLOFFYES;  ///< Offset: 0x1388 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD28_SLAST;  ///< Offset: 0x138C - TCD Last Source Address Adjustment
        volatile uint32_t TCD28_DADDR;  ///< Offset: 0x1390 - TCD Destination Address
        volatile uint32_t TCD28_DOFF;  ///< Offset: 0x1394 - TCD Signed Destination Address Offset
        volatile uint32_t TCD28_CITER_ELINKNO;  ///< Offset: 0x1396 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD28_CITER_ELINKYES;  ///< Offset: 0x1396 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD28_DLASTSGA;  ///< Offset: 0x1398 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD28_CSR;  ///< Offset: 0x139C - TCD Control and Status
        volatile uint32_t TCD28_BITER_ELINKNO;  ///< Offset: 0x139E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD28_BITER_ELINKYES;  ///< Offset: 0x139E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD29_SADDR;  ///< Offset: 0x13A0 - TCD Source Address
        volatile uint32_t TCD29_SOFF;  ///< Offset: 0x13A4 - TCD Signed Source Address Offset
        volatile uint32_t TCD29_ATTR;  ///< Offset: 0x13A6 - TCD Transfer Attributes
        volatile uint32_t TCD29_NBYTES_MLNO;  ///< Offset: 0x13A8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD29_NBYTES_MLOFFNO;  ///< Offset: 0x13A8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD29_NBYTES_MLOFFYES;  ///< Offset: 0x13A8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD29_SLAST;  ///< Offset: 0x13AC - TCD Last Source Address Adjustment
        volatile uint32_t TCD29_DADDR;  ///< Offset: 0x13B0 - TCD Destination Address
        volatile uint32_t TCD29_DOFF;  ///< Offset: 0x13B4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD29_CITER_ELINKNO;  ///< Offset: 0x13B6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD29_CITER_ELINKYES;  ///< Offset: 0x13B6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD29_DLASTSGA;  ///< Offset: 0x13B8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD29_CSR;  ///< Offset: 0x13BC - TCD Control and Status
        volatile uint32_t TCD29_BITER_ELINKNO;  ///< Offset: 0x13BE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD29_BITER_ELINKYES;  ///< Offset: 0x13BE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD30_SADDR;  ///< Offset: 0x13C0 - TCD Source Address
        volatile uint32_t TCD30_SOFF;  ///< Offset: 0x13C4 - TCD Signed Source Address Offset
        volatile uint32_t TCD30_ATTR;  ///< Offset: 0x13C6 - TCD Transfer Attributes
        volatile uint32_t TCD30_NBYTES_MLNO;  ///< Offset: 0x13C8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD30_NBYTES_MLOFFNO;  ///< Offset: 0x13C8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD30_NBYTES_MLOFFYES;  ///< Offset: 0x13C8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD30_SLAST;  ///< Offset: 0x13CC - TCD Last Source Address Adjustment
        volatile uint32_t TCD30_DADDR;  ///< Offset: 0x13D0 - TCD Destination Address
        volatile uint32_t TCD30_DOFF;  ///< Offset: 0x13D4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD30_CITER_ELINKNO;  ///< Offset: 0x13D6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD30_CITER_ELINKYES;  ///< Offset: 0x13D6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD30_DLASTSGA;  ///< Offset: 0x13D8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD30_CSR;  ///< Offset: 0x13DC - TCD Control and Status
        volatile uint32_t TCD30_BITER_ELINKNO;  ///< Offset: 0x13DE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD30_BITER_ELINKYES;  ///< Offset: 0x13DE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD31_SADDR;  ///< Offset: 0x13E0 - TCD Source Address
        volatile uint32_t TCD31_SOFF;  ///< Offset: 0x13E4 - TCD Signed Source Address Offset
        volatile uint32_t TCD31_ATTR;  ///< Offset: 0x13E6 - TCD Transfer Attributes
        volatile uint32_t TCD31_NBYTES_MLNO;  ///< Offset: 0x13E8 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD31_NBYTES_MLOFFNO;  ///< Offset: 0x13E8 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD31_NBYTES_MLOFFYES;  ///< Offset: 0x13E8 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD31_SLAST;  ///< Offset: 0x13EC - TCD Last Source Address Adjustment
        volatile uint32_t TCD31_DADDR;  ///< Offset: 0x13F0 - TCD Destination Address
        volatile uint32_t TCD31_DOFF;  ///< Offset: 0x13F4 - TCD Signed Destination Address Offset
        volatile uint32_t TCD31_CITER_ELINKNO;  ///< Offset: 0x13F6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD31_CITER_ELINKYES;  ///< Offset: 0x13F6 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD31_DLASTSGA;  ///< Offset: 0x13F8 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD31_CSR;  ///< Offset: 0x13FC - TCD Control and Status
        volatile uint32_t TCD31_BITER_ELINKNO;  ///< Offset: 0x13FE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD31_BITER_ELINKYES;  ///< Offset: 0x13FE - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
    };

    /// Peripheral instances
    inline Registers* DMA0 = reinterpret_cast<Registers*>(DMA0_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t ERGA = (1U << 3);  ///< Enable Round Robin Group Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t GRP0PRI = (1U << 8);  ///< Channel Group 0 Priority
        constexpr uint32_t GRP1PRI = (1U << 10);  ///< Channel Group 1 Priority
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
        constexpr uint32_t ACTIVE = (1U << 31);  ///< DMA Active Status
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (5 << 8);  ///< Error Channel Number or Canceled Channel Number
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t GPE = (1U << 15);  ///< Group Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Canceled
        constexpr uint32_t VLD = (1U << 31);  ///< VLD
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
        constexpr uint32_t ERQ4 = (1U << 4);  ///< Enable DMA Request 4
        constexpr uint32_t ERQ5 = (1U << 5);  ///< Enable DMA Request 5
        constexpr uint32_t ERQ6 = (1U << 6);  ///< Enable DMA Request 6
        constexpr uint32_t ERQ7 = (1U << 7);  ///< Enable DMA Request 7
        constexpr uint32_t ERQ8 = (1U << 8);  ///< Enable DMA Request 8
        constexpr uint32_t ERQ9 = (1U << 9);  ///< Enable DMA Request 9
        constexpr uint32_t ERQ10 = (1U << 10);  ///< Enable DMA Request 10
        constexpr uint32_t ERQ11 = (1U << 11);  ///< Enable DMA Request 11
        constexpr uint32_t ERQ12 = (1U << 12);  ///< Enable DMA Request 12
        constexpr uint32_t ERQ13 = (1U << 13);  ///< Enable DMA Request 13
        constexpr uint32_t ERQ14 = (1U << 14);  ///< Enable DMA Request 14
        constexpr uint32_t ERQ15 = (1U << 15);  ///< Enable DMA Request 15
        constexpr uint32_t ERQ16 = (1U << 16);  ///< Enable DMA Request 16
        constexpr uint32_t ERQ17 = (1U << 17);  ///< Enable DMA Request 17
        constexpr uint32_t ERQ18 = (1U << 18);  ///< Enable DMA Request 18
        constexpr uint32_t ERQ19 = (1U << 19);  ///< Enable DMA Request 19
        constexpr uint32_t ERQ20 = (1U << 20);  ///< Enable DMA Request 20
        constexpr uint32_t ERQ21 = (1U << 21);  ///< Enable DMA Request 21
        constexpr uint32_t ERQ22 = (1U << 22);  ///< Enable DMA Request 22
        constexpr uint32_t ERQ23 = (1U << 23);  ///< Enable DMA Request 23
        constexpr uint32_t ERQ24 = (1U << 24);  ///< Enable DMA Request 24
        constexpr uint32_t ERQ25 = (1U << 25);  ///< Enable DMA Request 25
        constexpr uint32_t ERQ26 = (1U << 26);  ///< Enable DMA Request 26
        constexpr uint32_t ERQ27 = (1U << 27);  ///< Enable DMA Request 27
        constexpr uint32_t ERQ28 = (1U << 28);  ///< Enable DMA Request 28
        constexpr uint32_t ERQ29 = (1U << 29);  ///< Enable DMA Request 29
        constexpr uint32_t ERQ30 = (1U << 30);  ///< Enable DMA Request 30
        constexpr uint32_t ERQ31 = (1U << 31);  ///< Enable DMA Request 31
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
        constexpr uint32_t EEI4 = (1U << 4);  ///< Enable Error Interrupt 4
        constexpr uint32_t EEI5 = (1U << 5);  ///< Enable Error Interrupt 5
        constexpr uint32_t EEI6 = (1U << 6);  ///< Enable Error Interrupt 6
        constexpr uint32_t EEI7 = (1U << 7);  ///< Enable Error Interrupt 7
        constexpr uint32_t EEI8 = (1U << 8);  ///< Enable Error Interrupt 8
        constexpr uint32_t EEI9 = (1U << 9);  ///< Enable Error Interrupt 9
        constexpr uint32_t EEI10 = (1U << 10);  ///< Enable Error Interrupt 10
        constexpr uint32_t EEI11 = (1U << 11);  ///< Enable Error Interrupt 11
        constexpr uint32_t EEI12 = (1U << 12);  ///< Enable Error Interrupt 12
        constexpr uint32_t EEI13 = (1U << 13);  ///< Enable Error Interrupt 13
        constexpr uint32_t EEI14 = (1U << 14);  ///< Enable Error Interrupt 14
        constexpr uint32_t EEI15 = (1U << 15);  ///< Enable Error Interrupt 15
        constexpr uint32_t EEI16 = (1U << 16);  ///< Enable Error Interrupt 16
        constexpr uint32_t EEI17 = (1U << 17);  ///< Enable Error Interrupt 17
        constexpr uint32_t EEI18 = (1U << 18);  ///< Enable Error Interrupt 18
        constexpr uint32_t EEI19 = (1U << 19);  ///< Enable Error Interrupt 19
        constexpr uint32_t EEI20 = (1U << 20);  ///< Enable Error Interrupt 20
        constexpr uint32_t EEI21 = (1U << 21);  ///< Enable Error Interrupt 21
        constexpr uint32_t EEI22 = (1U << 22);  ///< Enable Error Interrupt 22
        constexpr uint32_t EEI23 = (1U << 23);  ///< Enable Error Interrupt 23
        constexpr uint32_t EEI24 = (1U << 24);  ///< Enable Error Interrupt 24
        constexpr uint32_t EEI25 = (1U << 25);  ///< Enable Error Interrupt 25
        constexpr uint32_t EEI26 = (1U << 26);  ///< Enable Error Interrupt 26
        constexpr uint32_t EEI27 = (1U << 27);  ///< Enable Error Interrupt 27
        constexpr uint32_t EEI28 = (1U << 28);  ///< Enable Error Interrupt 28
        constexpr uint32_t EEI29 = (1U << 29);  ///< Enable Error Interrupt 29
        constexpr uint32_t EEI30 = (1U << 30);  ///< Enable Error Interrupt 30
        constexpr uint32_t EEI31 = (1U << 31);  ///< Enable Error Interrupt 31
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (5 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (5 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (5 << 0);  ///< Clear Enable Request
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (5 << 0);  ///< Set Enable Request
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (5 << 0);  ///< Clear DONE Bit
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (5 << 0);  ///< Set START Bit
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (5 << 0);  ///< Clear Error Indicator
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (5 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// INT Register bits
    namespace int_bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
        constexpr uint32_t INT4 = (1U << 4);  ///< Interrupt Request 4
        constexpr uint32_t INT5 = (1U << 5);  ///< Interrupt Request 5
        constexpr uint32_t INT6 = (1U << 6);  ///< Interrupt Request 6
        constexpr uint32_t INT7 = (1U << 7);  ///< Interrupt Request 7
        constexpr uint32_t INT8 = (1U << 8);  ///< Interrupt Request 8
        constexpr uint32_t INT9 = (1U << 9);  ///< Interrupt Request 9
        constexpr uint32_t INT10 = (1U << 10);  ///< Interrupt Request 10
        constexpr uint32_t INT11 = (1U << 11);  ///< Interrupt Request 11
        constexpr uint32_t INT12 = (1U << 12);  ///< Interrupt Request 12
        constexpr uint32_t INT13 = (1U << 13);  ///< Interrupt Request 13
        constexpr uint32_t INT14 = (1U << 14);  ///< Interrupt Request 14
        constexpr uint32_t INT15 = (1U << 15);  ///< Interrupt Request 15
        constexpr uint32_t INT16 = (1U << 16);  ///< Interrupt Request 16
        constexpr uint32_t INT17 = (1U << 17);  ///< Interrupt Request 17
        constexpr uint32_t INT18 = (1U << 18);  ///< Interrupt Request 18
        constexpr uint32_t INT19 = (1U << 19);  ///< Interrupt Request 19
        constexpr uint32_t INT20 = (1U << 20);  ///< Interrupt Request 20
        constexpr uint32_t INT21 = (1U << 21);  ///< Interrupt Request 21
        constexpr uint32_t INT22 = (1U << 22);  ///< Interrupt Request 22
        constexpr uint32_t INT23 = (1U << 23);  ///< Interrupt Request 23
        constexpr uint32_t INT24 = (1U << 24);  ///< Interrupt Request 24
        constexpr uint32_t INT25 = (1U << 25);  ///< Interrupt Request 25
        constexpr uint32_t INT26 = (1U << 26);  ///< Interrupt Request 26
        constexpr uint32_t INT27 = (1U << 27);  ///< Interrupt Request 27
        constexpr uint32_t INT28 = (1U << 28);  ///< Interrupt Request 28
        constexpr uint32_t INT29 = (1U << 29);  ///< Interrupt Request 29
        constexpr uint32_t INT30 = (1U << 30);  ///< Interrupt Request 30
        constexpr uint32_t INT31 = (1U << 31);  ///< Interrupt Request 31
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
        constexpr uint32_t ERR4 = (1U << 4);  ///< Error In Channel 4
        constexpr uint32_t ERR5 = (1U << 5);  ///< Error In Channel 5
        constexpr uint32_t ERR6 = (1U << 6);  ///< Error In Channel 6
        constexpr uint32_t ERR7 = (1U << 7);  ///< Error In Channel 7
        constexpr uint32_t ERR8 = (1U << 8);  ///< Error In Channel 8
        constexpr uint32_t ERR9 = (1U << 9);  ///< Error In Channel 9
        constexpr uint32_t ERR10 = (1U << 10);  ///< Error In Channel 10
        constexpr uint32_t ERR11 = (1U << 11);  ///< Error In Channel 11
        constexpr uint32_t ERR12 = (1U << 12);  ///< Error In Channel 12
        constexpr uint32_t ERR13 = (1U << 13);  ///< Error In Channel 13
        constexpr uint32_t ERR14 = (1U << 14);  ///< Error In Channel 14
        constexpr uint32_t ERR15 = (1U << 15);  ///< Error In Channel 15
        constexpr uint32_t ERR16 = (1U << 16);  ///< Error In Channel 16
        constexpr uint32_t ERR17 = (1U << 17);  ///< Error In Channel 17
        constexpr uint32_t ERR18 = (1U << 18);  ///< Error In Channel 18
        constexpr uint32_t ERR19 = (1U << 19);  ///< Error In Channel 19
        constexpr uint32_t ERR20 = (1U << 20);  ///< Error In Channel 20
        constexpr uint32_t ERR21 = (1U << 21);  ///< Error In Channel 21
        constexpr uint32_t ERR22 = (1U << 22);  ///< Error In Channel 22
        constexpr uint32_t ERR23 = (1U << 23);  ///< Error In Channel 23
        constexpr uint32_t ERR24 = (1U << 24);  ///< Error In Channel 24
        constexpr uint32_t ERR25 = (1U << 25);  ///< Error In Channel 25
        constexpr uint32_t ERR26 = (1U << 26);  ///< Error In Channel 26
        constexpr uint32_t ERR27 = (1U << 27);  ///< Error In Channel 27
        constexpr uint32_t ERR28 = (1U << 28);  ///< Error In Channel 28
        constexpr uint32_t ERR29 = (1U << 29);  ///< Error In Channel 29
        constexpr uint32_t ERR30 = (1U << 30);  ///< Error In Channel 30
        constexpr uint32_t ERR31 = (1U << 31);  ///< Error In Channel 31
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
        constexpr uint32_t HRS4 = (1U << 4);  ///< Hardware Request Status Channel 4
        constexpr uint32_t HRS5 = (1U << 5);  ///< Hardware Request Status Channel 5
        constexpr uint32_t HRS6 = (1U << 6);  ///< Hardware Request Status Channel 6
        constexpr uint32_t HRS7 = (1U << 7);  ///< Hardware Request Status Channel 7
        constexpr uint32_t HRS8 = (1U << 8);  ///< Hardware Request Status Channel 8
        constexpr uint32_t HRS9 = (1U << 9);  ///< Hardware Request Status Channel 9
        constexpr uint32_t HRS10 = (1U << 10);  ///< Hardware Request Status Channel 10
        constexpr uint32_t HRS11 = (1U << 11);  ///< Hardware Request Status Channel 11
        constexpr uint32_t HRS12 = (1U << 12);  ///< Hardware Request Status Channel 12
        constexpr uint32_t HRS13 = (1U << 13);  ///< Hardware Request Status Channel 13
        constexpr uint32_t HRS14 = (1U << 14);  ///< Hardware Request Status Channel 14
        constexpr uint32_t HRS15 = (1U << 15);  ///< Hardware Request Status Channel 15
        constexpr uint32_t HRS16 = (1U << 16);  ///< Hardware Request Status Channel 16
        constexpr uint32_t HRS17 = (1U << 17);  ///< Hardware Request Status Channel 17
        constexpr uint32_t HRS18 = (1U << 18);  ///< Hardware Request Status Channel 18
        constexpr uint32_t HRS19 = (1U << 19);  ///< Hardware Request Status Channel 19
        constexpr uint32_t HRS20 = (1U << 20);  ///< Hardware Request Status Channel 20
        constexpr uint32_t HRS21 = (1U << 21);  ///< Hardware Request Status Channel 21
        constexpr uint32_t HRS22 = (1U << 22);  ///< Hardware Request Status Channel 22
        constexpr uint32_t HRS23 = (1U << 23);  ///< Hardware Request Status Channel 23
        constexpr uint32_t HRS24 = (1U << 24);  ///< Hardware Request Status Channel 24
        constexpr uint32_t HRS25 = (1U << 25);  ///< Hardware Request Status Channel 25
        constexpr uint32_t HRS26 = (1U << 26);  ///< Hardware Request Status Channel 26
        constexpr uint32_t HRS27 = (1U << 27);  ///< Hardware Request Status Channel 27
        constexpr uint32_t HRS28 = (1U << 28);  ///< Hardware Request Status Channel 28
        constexpr uint32_t HRS29 = (1U << 29);  ///< Hardware Request Status Channel 29
        constexpr uint32_t HRS30 = (1U << 30);  ///< Hardware Request Status Channel 30
        constexpr uint32_t HRS31 = (1U << 31);  ///< Hardware Request Status Channel 31
    }

    /// EARS Register bits
    namespace ears_bits {
        constexpr uint32_t EDREQ_0 = (1U << 0);  ///< Enable asynchronous DMA request in stop mode for channel 0.
        constexpr uint32_t EDREQ_1 = (1U << 1);  ///< Enable asynchronous DMA request in stop mode for channel 1.
        constexpr uint32_t EDREQ_2 = (1U << 2);  ///< Enable asynchronous DMA request in stop mode for channel 2.
        constexpr uint32_t EDREQ_3 = (1U << 3);  ///< Enable asynchronous DMA request in stop mode for channel 3.
        constexpr uint32_t EDREQ_4 = (1U << 4);  ///< Enable asynchronous DMA request in stop mode for channel 4
        constexpr uint32_t EDREQ_5 = (1U << 5);  ///< Enable asynchronous DMA request in stop mode for channel 5
        constexpr uint32_t EDREQ_6 = (1U << 6);  ///< Enable asynchronous DMA request in stop mode for channel 6
        constexpr uint32_t EDREQ_7 = (1U << 7);  ///< Enable asynchronous DMA request in stop mode for channel 7
        constexpr uint32_t EDREQ_8 = (1U << 8);  ///< Enable asynchronous DMA request in stop mode for channel 8
        constexpr uint32_t EDREQ_9 = (1U << 9);  ///< Enable asynchronous DMA request in stop mode for channel 9
        constexpr uint32_t EDREQ_10 = (1U << 10);  ///< Enable asynchronous DMA request in stop mode for channel 10
        constexpr uint32_t EDREQ_11 = (1U << 11);  ///< Enable asynchronous DMA request in stop mode for channel 11
        constexpr uint32_t EDREQ_12 = (1U << 12);  ///< Enable asynchronous DMA request in stop mode for channel 12
        constexpr uint32_t EDREQ_13 = (1U << 13);  ///< Enable asynchronous DMA request in stop mode for channel 13
        constexpr uint32_t EDREQ_14 = (1U << 14);  ///< Enable asynchronous DMA request in stop mode for channel 14
        constexpr uint32_t EDREQ_15 = (1U << 15);  ///< Enable asynchronous DMA request in stop mode for channel 15
        constexpr uint32_t EDREQ_16 = (1U << 16);  ///< Enable asynchronous DMA request in stop mode for channel 16
        constexpr uint32_t EDREQ_17 = (1U << 17);  ///< Enable asynchronous DMA request in stop mode for channel 17
        constexpr uint32_t EDREQ_18 = (1U << 18);  ///< Enable asynchronous DMA request in stop mode for channel 18
        constexpr uint32_t EDREQ_19 = (1U << 19);  ///< Enable asynchronous DMA request in stop mode for channel 19
        constexpr uint32_t EDREQ_20 = (1U << 20);  ///< Enable asynchronous DMA request in stop mode for channel 20
        constexpr uint32_t EDREQ_21 = (1U << 21);  ///< Enable asynchronous DMA request in stop mode for channel 21
        constexpr uint32_t EDREQ_22 = (1U << 22);  ///< Enable asynchronous DMA request in stop mode for channel 22
        constexpr uint32_t EDREQ_23 = (1U << 23);  ///< Enable asynchronous DMA request in stop mode for channel 23
        constexpr uint32_t EDREQ_24 = (1U << 24);  ///< Enable asynchronous DMA request in stop mode for channel 24
        constexpr uint32_t EDREQ_25 = (1U << 25);  ///< Enable asynchronous DMA request in stop mode for channel 25
        constexpr uint32_t EDREQ_26 = (1U << 26);  ///< Enable asynchronous DMA request in stop mode for channel 26
        constexpr uint32_t EDREQ_27 = (1U << 27);  ///< Enable asynchronous DMA request in stop mode for channel 27
        constexpr uint32_t EDREQ_28 = (1U << 28);  ///< Enable asynchronous DMA request in stop mode for channel 28
        constexpr uint32_t EDREQ_29 = (1U << 29);  ///< Enable asynchronous DMA request in stop mode for channel 29
        constexpr uint32_t EDREQ_30 = (1U << 30);  ///< Enable asynchronous DMA request in stop mode for channel 30
        constexpr uint32_t EDREQ_31 = (1U << 31);  ///< Enable asynchronous DMA request in stop mode for channel 31
    }

    /// DCHPRI3 Register bits
    namespace dchpri3_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI2 Register bits
    namespace dchpri2_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI1 Register bits
    namespace dchpri1_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI0 Register bits
    namespace dchpri0_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI7 Register bits
    namespace dchpri7_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI6 Register bits
    namespace dchpri6_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI5 Register bits
    namespace dchpri5_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI4 Register bits
    namespace dchpri4_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI11 Register bits
    namespace dchpri11_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI10 Register bits
    namespace dchpri10_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI9 Register bits
    namespace dchpri9_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI8 Register bits
    namespace dchpri8_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI15 Register bits
    namespace dchpri15_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI14 Register bits
    namespace dchpri14_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI13 Register bits
    namespace dchpri13_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI12 Register bits
    namespace dchpri12_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI19 Register bits
    namespace dchpri19_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI18 Register bits
    namespace dchpri18_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI17 Register bits
    namespace dchpri17_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI16 Register bits
    namespace dchpri16_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI23 Register bits
    namespace dchpri23_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI22 Register bits
    namespace dchpri22_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI21 Register bits
    namespace dchpri21_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI20 Register bits
    namespace dchpri20_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI27 Register bits
    namespace dchpri27_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI26 Register bits
    namespace dchpri26_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI25 Register bits
    namespace dchpri25_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI24 Register bits
    namespace dchpri24_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI31 Register bits
    namespace dchpri31_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI30 Register bits
    namespace dchpri30_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI29 Register bits
    namespace dchpri29_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// DCHPRI28 Register bits
    namespace dchpri28_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability. This field resets to 0.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This field resets to 0.
    }

    /// TCD0_SADDR Register bits
    namespace tcd0_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD0_SOFF Register bits
    namespace tcd0_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD0_ATTR Register bits
    namespace tcd0_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD0_NBYTES_MLNO Register bits
    namespace tcd0_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD0_NBYTES_MLOFFNO Register bits
    namespace tcd0_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD0_NBYTES_MLOFFYES Register bits
    namespace tcd0_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD0_SLAST Register bits
    namespace tcd0_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD0_DADDR Register bits
    namespace tcd0_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD0_DOFF Register bits
    namespace tcd0_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD0_CITER_ELINKNO Register bits
    namespace tcd0_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD0_CITER_ELINKYES Register bits
    namespace tcd0_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD0_DLASTSGA Register bits
    namespace tcd0_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD0_CSR Register bits
    namespace tcd0_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD0_BITER_ELINKNO Register bits
    namespace tcd0_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD0_BITER_ELINKYES Register bits
    namespace tcd0_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD1_SADDR Register bits
    namespace tcd1_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD1_SOFF Register bits
    namespace tcd1_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD1_ATTR Register bits
    namespace tcd1_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD1_NBYTES_MLNO Register bits
    namespace tcd1_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD1_NBYTES_MLOFFNO Register bits
    namespace tcd1_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD1_NBYTES_MLOFFYES Register bits
    namespace tcd1_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD1_SLAST Register bits
    namespace tcd1_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD1_DADDR Register bits
    namespace tcd1_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD1_DOFF Register bits
    namespace tcd1_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD1_CITER_ELINKNO Register bits
    namespace tcd1_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD1_CITER_ELINKYES Register bits
    namespace tcd1_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD1_DLASTSGA Register bits
    namespace tcd1_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD1_CSR Register bits
    namespace tcd1_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD1_BITER_ELINKNO Register bits
    namespace tcd1_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD1_BITER_ELINKYES Register bits
    namespace tcd1_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD2_SADDR Register bits
    namespace tcd2_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD2_SOFF Register bits
    namespace tcd2_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD2_ATTR Register bits
    namespace tcd2_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD2_NBYTES_MLNO Register bits
    namespace tcd2_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD2_NBYTES_MLOFFNO Register bits
    namespace tcd2_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD2_NBYTES_MLOFFYES Register bits
    namespace tcd2_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD2_SLAST Register bits
    namespace tcd2_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD2_DADDR Register bits
    namespace tcd2_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD2_DOFF Register bits
    namespace tcd2_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD2_CITER_ELINKNO Register bits
    namespace tcd2_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD2_CITER_ELINKYES Register bits
    namespace tcd2_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD2_DLASTSGA Register bits
    namespace tcd2_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD2_CSR Register bits
    namespace tcd2_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD2_BITER_ELINKNO Register bits
    namespace tcd2_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD2_BITER_ELINKYES Register bits
    namespace tcd2_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD3_SADDR Register bits
    namespace tcd3_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD3_SOFF Register bits
    namespace tcd3_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD3_ATTR Register bits
    namespace tcd3_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD3_NBYTES_MLNO Register bits
    namespace tcd3_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD3_NBYTES_MLOFFNO Register bits
    namespace tcd3_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD3_NBYTES_MLOFFYES Register bits
    namespace tcd3_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD3_SLAST Register bits
    namespace tcd3_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD3_DADDR Register bits
    namespace tcd3_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD3_DOFF Register bits
    namespace tcd3_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD3_CITER_ELINKNO Register bits
    namespace tcd3_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD3_CITER_ELINKYES Register bits
    namespace tcd3_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD3_DLASTSGA Register bits
    namespace tcd3_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD3_CSR Register bits
    namespace tcd3_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD3_BITER_ELINKNO Register bits
    namespace tcd3_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD3_BITER_ELINKYES Register bits
    namespace tcd3_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD4_SADDR Register bits
    namespace tcd4_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD4_SOFF Register bits
    namespace tcd4_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD4_ATTR Register bits
    namespace tcd4_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD4_NBYTES_MLNO Register bits
    namespace tcd4_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD4_NBYTES_MLOFFNO Register bits
    namespace tcd4_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD4_NBYTES_MLOFFYES Register bits
    namespace tcd4_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD4_SLAST Register bits
    namespace tcd4_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD4_DADDR Register bits
    namespace tcd4_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD4_DOFF Register bits
    namespace tcd4_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD4_CITER_ELINKNO Register bits
    namespace tcd4_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD4_CITER_ELINKYES Register bits
    namespace tcd4_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD4_DLASTSGA Register bits
    namespace tcd4_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD4_CSR Register bits
    namespace tcd4_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD4_BITER_ELINKNO Register bits
    namespace tcd4_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD4_BITER_ELINKYES Register bits
    namespace tcd4_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD5_SADDR Register bits
    namespace tcd5_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD5_SOFF Register bits
    namespace tcd5_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD5_ATTR Register bits
    namespace tcd5_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD5_NBYTES_MLNO Register bits
    namespace tcd5_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD5_NBYTES_MLOFFNO Register bits
    namespace tcd5_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD5_NBYTES_MLOFFYES Register bits
    namespace tcd5_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD5_SLAST Register bits
    namespace tcd5_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD5_DADDR Register bits
    namespace tcd5_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD5_DOFF Register bits
    namespace tcd5_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD5_CITER_ELINKNO Register bits
    namespace tcd5_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD5_CITER_ELINKYES Register bits
    namespace tcd5_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD5_DLASTSGA Register bits
    namespace tcd5_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD5_CSR Register bits
    namespace tcd5_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD5_BITER_ELINKNO Register bits
    namespace tcd5_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD5_BITER_ELINKYES Register bits
    namespace tcd5_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD6_SADDR Register bits
    namespace tcd6_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD6_SOFF Register bits
    namespace tcd6_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD6_ATTR Register bits
    namespace tcd6_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD6_NBYTES_MLNO Register bits
    namespace tcd6_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD6_NBYTES_MLOFFNO Register bits
    namespace tcd6_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD6_NBYTES_MLOFFYES Register bits
    namespace tcd6_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD6_SLAST Register bits
    namespace tcd6_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD6_DADDR Register bits
    namespace tcd6_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD6_DOFF Register bits
    namespace tcd6_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD6_CITER_ELINKNO Register bits
    namespace tcd6_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD6_CITER_ELINKYES Register bits
    namespace tcd6_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD6_DLASTSGA Register bits
    namespace tcd6_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD6_CSR Register bits
    namespace tcd6_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD6_BITER_ELINKNO Register bits
    namespace tcd6_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD6_BITER_ELINKYES Register bits
    namespace tcd6_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD7_SADDR Register bits
    namespace tcd7_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD7_SOFF Register bits
    namespace tcd7_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD7_ATTR Register bits
    namespace tcd7_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD7_NBYTES_MLNO Register bits
    namespace tcd7_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD7_NBYTES_MLOFFNO Register bits
    namespace tcd7_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD7_NBYTES_MLOFFYES Register bits
    namespace tcd7_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD7_SLAST Register bits
    namespace tcd7_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD7_DADDR Register bits
    namespace tcd7_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD7_DOFF Register bits
    namespace tcd7_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD7_CITER_ELINKNO Register bits
    namespace tcd7_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD7_CITER_ELINKYES Register bits
    namespace tcd7_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD7_DLASTSGA Register bits
    namespace tcd7_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD7_CSR Register bits
    namespace tcd7_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD7_BITER_ELINKNO Register bits
    namespace tcd7_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD7_BITER_ELINKYES Register bits
    namespace tcd7_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD8_SADDR Register bits
    namespace tcd8_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD8_SOFF Register bits
    namespace tcd8_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD8_ATTR Register bits
    namespace tcd8_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD8_NBYTES_MLNO Register bits
    namespace tcd8_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD8_NBYTES_MLOFFNO Register bits
    namespace tcd8_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD8_NBYTES_MLOFFYES Register bits
    namespace tcd8_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD8_SLAST Register bits
    namespace tcd8_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD8_DADDR Register bits
    namespace tcd8_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD8_DOFF Register bits
    namespace tcd8_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD8_CITER_ELINKNO Register bits
    namespace tcd8_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD8_CITER_ELINKYES Register bits
    namespace tcd8_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD8_DLASTSGA Register bits
    namespace tcd8_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD8_CSR Register bits
    namespace tcd8_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD8_BITER_ELINKNO Register bits
    namespace tcd8_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD8_BITER_ELINKYES Register bits
    namespace tcd8_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD9_SADDR Register bits
    namespace tcd9_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD9_SOFF Register bits
    namespace tcd9_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD9_ATTR Register bits
    namespace tcd9_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD9_NBYTES_MLNO Register bits
    namespace tcd9_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD9_NBYTES_MLOFFNO Register bits
    namespace tcd9_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD9_NBYTES_MLOFFYES Register bits
    namespace tcd9_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD9_SLAST Register bits
    namespace tcd9_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD9_DADDR Register bits
    namespace tcd9_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD9_DOFF Register bits
    namespace tcd9_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD9_CITER_ELINKNO Register bits
    namespace tcd9_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD9_CITER_ELINKYES Register bits
    namespace tcd9_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD9_DLASTSGA Register bits
    namespace tcd9_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD9_CSR Register bits
    namespace tcd9_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD9_BITER_ELINKNO Register bits
    namespace tcd9_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD9_BITER_ELINKYES Register bits
    namespace tcd9_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD10_SADDR Register bits
    namespace tcd10_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD10_SOFF Register bits
    namespace tcd10_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD10_ATTR Register bits
    namespace tcd10_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD10_NBYTES_MLNO Register bits
    namespace tcd10_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD10_NBYTES_MLOFFNO Register bits
    namespace tcd10_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD10_NBYTES_MLOFFYES Register bits
    namespace tcd10_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD10_SLAST Register bits
    namespace tcd10_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD10_DADDR Register bits
    namespace tcd10_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD10_DOFF Register bits
    namespace tcd10_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD10_CITER_ELINKNO Register bits
    namespace tcd10_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD10_CITER_ELINKYES Register bits
    namespace tcd10_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD10_DLASTSGA Register bits
    namespace tcd10_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD10_CSR Register bits
    namespace tcd10_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD10_BITER_ELINKNO Register bits
    namespace tcd10_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD10_BITER_ELINKYES Register bits
    namespace tcd10_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD11_SADDR Register bits
    namespace tcd11_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD11_SOFF Register bits
    namespace tcd11_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD11_ATTR Register bits
    namespace tcd11_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD11_NBYTES_MLNO Register bits
    namespace tcd11_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD11_NBYTES_MLOFFNO Register bits
    namespace tcd11_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD11_NBYTES_MLOFFYES Register bits
    namespace tcd11_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD11_SLAST Register bits
    namespace tcd11_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD11_DADDR Register bits
    namespace tcd11_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD11_DOFF Register bits
    namespace tcd11_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD11_CITER_ELINKNO Register bits
    namespace tcd11_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD11_CITER_ELINKYES Register bits
    namespace tcd11_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD11_DLASTSGA Register bits
    namespace tcd11_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD11_CSR Register bits
    namespace tcd11_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD11_BITER_ELINKNO Register bits
    namespace tcd11_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD11_BITER_ELINKYES Register bits
    namespace tcd11_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD12_SADDR Register bits
    namespace tcd12_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD12_SOFF Register bits
    namespace tcd12_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD12_ATTR Register bits
    namespace tcd12_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD12_NBYTES_MLNO Register bits
    namespace tcd12_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD12_NBYTES_MLOFFNO Register bits
    namespace tcd12_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD12_NBYTES_MLOFFYES Register bits
    namespace tcd12_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD12_SLAST Register bits
    namespace tcd12_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD12_DADDR Register bits
    namespace tcd12_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD12_DOFF Register bits
    namespace tcd12_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD12_CITER_ELINKNO Register bits
    namespace tcd12_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD12_CITER_ELINKYES Register bits
    namespace tcd12_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD12_DLASTSGA Register bits
    namespace tcd12_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD12_CSR Register bits
    namespace tcd12_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD12_BITER_ELINKNO Register bits
    namespace tcd12_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD12_BITER_ELINKYES Register bits
    namespace tcd12_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD13_SADDR Register bits
    namespace tcd13_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD13_SOFF Register bits
    namespace tcd13_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD13_ATTR Register bits
    namespace tcd13_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD13_NBYTES_MLNO Register bits
    namespace tcd13_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD13_NBYTES_MLOFFNO Register bits
    namespace tcd13_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD13_NBYTES_MLOFFYES Register bits
    namespace tcd13_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD13_SLAST Register bits
    namespace tcd13_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD13_DADDR Register bits
    namespace tcd13_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD13_DOFF Register bits
    namespace tcd13_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD13_CITER_ELINKNO Register bits
    namespace tcd13_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD13_CITER_ELINKYES Register bits
    namespace tcd13_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD13_DLASTSGA Register bits
    namespace tcd13_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD13_CSR Register bits
    namespace tcd13_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD13_BITER_ELINKNO Register bits
    namespace tcd13_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD13_BITER_ELINKYES Register bits
    namespace tcd13_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD14_SADDR Register bits
    namespace tcd14_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD14_SOFF Register bits
    namespace tcd14_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD14_ATTR Register bits
    namespace tcd14_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD14_NBYTES_MLNO Register bits
    namespace tcd14_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD14_NBYTES_MLOFFNO Register bits
    namespace tcd14_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD14_NBYTES_MLOFFYES Register bits
    namespace tcd14_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD14_SLAST Register bits
    namespace tcd14_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD14_DADDR Register bits
    namespace tcd14_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD14_DOFF Register bits
    namespace tcd14_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD14_CITER_ELINKNO Register bits
    namespace tcd14_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD14_CITER_ELINKYES Register bits
    namespace tcd14_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD14_DLASTSGA Register bits
    namespace tcd14_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD14_CSR Register bits
    namespace tcd14_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD14_BITER_ELINKNO Register bits
    namespace tcd14_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD14_BITER_ELINKYES Register bits
    namespace tcd14_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD15_SADDR Register bits
    namespace tcd15_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD15_SOFF Register bits
    namespace tcd15_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD15_ATTR Register bits
    namespace tcd15_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD15_NBYTES_MLNO Register bits
    namespace tcd15_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD15_NBYTES_MLOFFNO Register bits
    namespace tcd15_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD15_NBYTES_MLOFFYES Register bits
    namespace tcd15_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD15_SLAST Register bits
    namespace tcd15_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD15_DADDR Register bits
    namespace tcd15_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD15_DOFF Register bits
    namespace tcd15_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD15_CITER_ELINKNO Register bits
    namespace tcd15_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD15_CITER_ELINKYES Register bits
    namespace tcd15_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD15_DLASTSGA Register bits
    namespace tcd15_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD15_CSR Register bits
    namespace tcd15_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD15_BITER_ELINKNO Register bits
    namespace tcd15_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD15_BITER_ELINKYES Register bits
    namespace tcd15_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD16_SADDR Register bits
    namespace tcd16_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD16_SOFF Register bits
    namespace tcd16_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD16_ATTR Register bits
    namespace tcd16_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD16_NBYTES_MLNO Register bits
    namespace tcd16_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD16_NBYTES_MLOFFNO Register bits
    namespace tcd16_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD16_NBYTES_MLOFFYES Register bits
    namespace tcd16_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD16_SLAST Register bits
    namespace tcd16_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD16_DADDR Register bits
    namespace tcd16_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD16_DOFF Register bits
    namespace tcd16_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD16_CITER_ELINKNO Register bits
    namespace tcd16_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD16_CITER_ELINKYES Register bits
    namespace tcd16_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD16_DLASTSGA Register bits
    namespace tcd16_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD16_CSR Register bits
    namespace tcd16_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD16_BITER_ELINKNO Register bits
    namespace tcd16_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD16_BITER_ELINKYES Register bits
    namespace tcd16_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD17_SADDR Register bits
    namespace tcd17_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD17_SOFF Register bits
    namespace tcd17_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD17_ATTR Register bits
    namespace tcd17_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD17_NBYTES_MLNO Register bits
    namespace tcd17_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD17_NBYTES_MLOFFNO Register bits
    namespace tcd17_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD17_NBYTES_MLOFFYES Register bits
    namespace tcd17_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD17_SLAST Register bits
    namespace tcd17_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD17_DADDR Register bits
    namespace tcd17_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD17_DOFF Register bits
    namespace tcd17_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD17_CITER_ELINKNO Register bits
    namespace tcd17_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD17_CITER_ELINKYES Register bits
    namespace tcd17_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD17_DLASTSGA Register bits
    namespace tcd17_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD17_CSR Register bits
    namespace tcd17_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD17_BITER_ELINKNO Register bits
    namespace tcd17_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD17_BITER_ELINKYES Register bits
    namespace tcd17_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD18_SADDR Register bits
    namespace tcd18_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD18_SOFF Register bits
    namespace tcd18_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD18_ATTR Register bits
    namespace tcd18_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD18_NBYTES_MLNO Register bits
    namespace tcd18_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD18_NBYTES_MLOFFNO Register bits
    namespace tcd18_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD18_NBYTES_MLOFFYES Register bits
    namespace tcd18_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD18_SLAST Register bits
    namespace tcd18_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD18_DADDR Register bits
    namespace tcd18_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD18_DOFF Register bits
    namespace tcd18_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD18_CITER_ELINKNO Register bits
    namespace tcd18_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD18_CITER_ELINKYES Register bits
    namespace tcd18_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD18_DLASTSGA Register bits
    namespace tcd18_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD18_CSR Register bits
    namespace tcd18_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD18_BITER_ELINKNO Register bits
    namespace tcd18_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD18_BITER_ELINKYES Register bits
    namespace tcd18_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD19_SADDR Register bits
    namespace tcd19_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD19_SOFF Register bits
    namespace tcd19_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD19_ATTR Register bits
    namespace tcd19_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD19_NBYTES_MLNO Register bits
    namespace tcd19_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD19_NBYTES_MLOFFNO Register bits
    namespace tcd19_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD19_NBYTES_MLOFFYES Register bits
    namespace tcd19_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD19_SLAST Register bits
    namespace tcd19_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD19_DADDR Register bits
    namespace tcd19_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD19_DOFF Register bits
    namespace tcd19_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD19_CITER_ELINKNO Register bits
    namespace tcd19_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD19_CITER_ELINKYES Register bits
    namespace tcd19_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD19_DLASTSGA Register bits
    namespace tcd19_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD19_CSR Register bits
    namespace tcd19_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD19_BITER_ELINKNO Register bits
    namespace tcd19_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD19_BITER_ELINKYES Register bits
    namespace tcd19_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD20_SADDR Register bits
    namespace tcd20_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD20_SOFF Register bits
    namespace tcd20_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD20_ATTR Register bits
    namespace tcd20_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD20_NBYTES_MLNO Register bits
    namespace tcd20_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD20_NBYTES_MLOFFNO Register bits
    namespace tcd20_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD20_NBYTES_MLOFFYES Register bits
    namespace tcd20_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD20_SLAST Register bits
    namespace tcd20_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD20_DADDR Register bits
    namespace tcd20_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD20_DOFF Register bits
    namespace tcd20_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD20_CITER_ELINKNO Register bits
    namespace tcd20_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD20_CITER_ELINKYES Register bits
    namespace tcd20_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD20_DLASTSGA Register bits
    namespace tcd20_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD20_CSR Register bits
    namespace tcd20_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD20_BITER_ELINKNO Register bits
    namespace tcd20_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD20_BITER_ELINKYES Register bits
    namespace tcd20_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD21_SADDR Register bits
    namespace tcd21_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD21_SOFF Register bits
    namespace tcd21_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD21_ATTR Register bits
    namespace tcd21_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD21_NBYTES_MLNO Register bits
    namespace tcd21_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD21_NBYTES_MLOFFNO Register bits
    namespace tcd21_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD21_NBYTES_MLOFFYES Register bits
    namespace tcd21_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD21_SLAST Register bits
    namespace tcd21_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD21_DADDR Register bits
    namespace tcd21_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD21_DOFF Register bits
    namespace tcd21_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD21_CITER_ELINKNO Register bits
    namespace tcd21_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD21_CITER_ELINKYES Register bits
    namespace tcd21_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD21_DLASTSGA Register bits
    namespace tcd21_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD21_CSR Register bits
    namespace tcd21_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD21_BITER_ELINKNO Register bits
    namespace tcd21_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD21_BITER_ELINKYES Register bits
    namespace tcd21_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD22_SADDR Register bits
    namespace tcd22_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD22_SOFF Register bits
    namespace tcd22_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD22_ATTR Register bits
    namespace tcd22_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD22_NBYTES_MLNO Register bits
    namespace tcd22_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD22_NBYTES_MLOFFNO Register bits
    namespace tcd22_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD22_NBYTES_MLOFFYES Register bits
    namespace tcd22_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD22_SLAST Register bits
    namespace tcd22_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD22_DADDR Register bits
    namespace tcd22_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD22_DOFF Register bits
    namespace tcd22_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD22_CITER_ELINKNO Register bits
    namespace tcd22_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD22_CITER_ELINKYES Register bits
    namespace tcd22_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD22_DLASTSGA Register bits
    namespace tcd22_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD22_CSR Register bits
    namespace tcd22_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD22_BITER_ELINKNO Register bits
    namespace tcd22_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD22_BITER_ELINKYES Register bits
    namespace tcd22_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD23_SADDR Register bits
    namespace tcd23_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD23_SOFF Register bits
    namespace tcd23_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD23_ATTR Register bits
    namespace tcd23_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD23_NBYTES_MLNO Register bits
    namespace tcd23_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD23_NBYTES_MLOFFNO Register bits
    namespace tcd23_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD23_NBYTES_MLOFFYES Register bits
    namespace tcd23_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD23_SLAST Register bits
    namespace tcd23_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD23_DADDR Register bits
    namespace tcd23_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD23_DOFF Register bits
    namespace tcd23_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD23_CITER_ELINKNO Register bits
    namespace tcd23_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD23_CITER_ELINKYES Register bits
    namespace tcd23_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD23_DLASTSGA Register bits
    namespace tcd23_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD23_CSR Register bits
    namespace tcd23_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD23_BITER_ELINKNO Register bits
    namespace tcd23_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD23_BITER_ELINKYES Register bits
    namespace tcd23_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD24_SADDR Register bits
    namespace tcd24_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD24_SOFF Register bits
    namespace tcd24_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD24_ATTR Register bits
    namespace tcd24_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD24_NBYTES_MLNO Register bits
    namespace tcd24_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD24_NBYTES_MLOFFNO Register bits
    namespace tcd24_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD24_NBYTES_MLOFFYES Register bits
    namespace tcd24_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD24_SLAST Register bits
    namespace tcd24_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD24_DADDR Register bits
    namespace tcd24_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD24_DOFF Register bits
    namespace tcd24_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD24_CITER_ELINKNO Register bits
    namespace tcd24_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD24_CITER_ELINKYES Register bits
    namespace tcd24_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD24_DLASTSGA Register bits
    namespace tcd24_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD24_CSR Register bits
    namespace tcd24_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD24_BITER_ELINKNO Register bits
    namespace tcd24_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD24_BITER_ELINKYES Register bits
    namespace tcd24_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD25_SADDR Register bits
    namespace tcd25_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD25_SOFF Register bits
    namespace tcd25_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD25_ATTR Register bits
    namespace tcd25_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD25_NBYTES_MLNO Register bits
    namespace tcd25_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD25_NBYTES_MLOFFNO Register bits
    namespace tcd25_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD25_NBYTES_MLOFFYES Register bits
    namespace tcd25_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD25_SLAST Register bits
    namespace tcd25_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD25_DADDR Register bits
    namespace tcd25_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD25_DOFF Register bits
    namespace tcd25_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD25_CITER_ELINKNO Register bits
    namespace tcd25_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD25_CITER_ELINKYES Register bits
    namespace tcd25_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD25_DLASTSGA Register bits
    namespace tcd25_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD25_CSR Register bits
    namespace tcd25_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD25_BITER_ELINKNO Register bits
    namespace tcd25_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD25_BITER_ELINKYES Register bits
    namespace tcd25_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD26_SADDR Register bits
    namespace tcd26_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD26_SOFF Register bits
    namespace tcd26_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD26_ATTR Register bits
    namespace tcd26_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD26_NBYTES_MLNO Register bits
    namespace tcd26_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD26_NBYTES_MLOFFNO Register bits
    namespace tcd26_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD26_NBYTES_MLOFFYES Register bits
    namespace tcd26_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD26_SLAST Register bits
    namespace tcd26_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD26_DADDR Register bits
    namespace tcd26_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD26_DOFF Register bits
    namespace tcd26_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD26_CITER_ELINKNO Register bits
    namespace tcd26_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD26_CITER_ELINKYES Register bits
    namespace tcd26_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD26_DLASTSGA Register bits
    namespace tcd26_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD26_CSR Register bits
    namespace tcd26_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD26_BITER_ELINKNO Register bits
    namespace tcd26_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD26_BITER_ELINKYES Register bits
    namespace tcd26_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD27_SADDR Register bits
    namespace tcd27_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD27_SOFF Register bits
    namespace tcd27_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD27_ATTR Register bits
    namespace tcd27_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD27_NBYTES_MLNO Register bits
    namespace tcd27_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD27_NBYTES_MLOFFNO Register bits
    namespace tcd27_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD27_NBYTES_MLOFFYES Register bits
    namespace tcd27_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD27_SLAST Register bits
    namespace tcd27_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD27_DADDR Register bits
    namespace tcd27_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD27_DOFF Register bits
    namespace tcd27_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD27_CITER_ELINKNO Register bits
    namespace tcd27_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD27_CITER_ELINKYES Register bits
    namespace tcd27_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD27_DLASTSGA Register bits
    namespace tcd27_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD27_CSR Register bits
    namespace tcd27_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD27_BITER_ELINKNO Register bits
    namespace tcd27_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD27_BITER_ELINKYES Register bits
    namespace tcd27_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD28_SADDR Register bits
    namespace tcd28_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD28_SOFF Register bits
    namespace tcd28_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD28_ATTR Register bits
    namespace tcd28_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD28_NBYTES_MLNO Register bits
    namespace tcd28_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD28_NBYTES_MLOFFNO Register bits
    namespace tcd28_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD28_NBYTES_MLOFFYES Register bits
    namespace tcd28_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD28_SLAST Register bits
    namespace tcd28_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD28_DADDR Register bits
    namespace tcd28_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD28_DOFF Register bits
    namespace tcd28_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD28_CITER_ELINKNO Register bits
    namespace tcd28_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD28_CITER_ELINKYES Register bits
    namespace tcd28_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD28_DLASTSGA Register bits
    namespace tcd28_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD28_CSR Register bits
    namespace tcd28_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD28_BITER_ELINKNO Register bits
    namespace tcd28_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD28_BITER_ELINKYES Register bits
    namespace tcd28_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD29_SADDR Register bits
    namespace tcd29_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD29_SOFF Register bits
    namespace tcd29_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD29_ATTR Register bits
    namespace tcd29_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD29_NBYTES_MLNO Register bits
    namespace tcd29_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD29_NBYTES_MLOFFNO Register bits
    namespace tcd29_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD29_NBYTES_MLOFFYES Register bits
    namespace tcd29_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD29_SLAST Register bits
    namespace tcd29_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD29_DADDR Register bits
    namespace tcd29_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD29_DOFF Register bits
    namespace tcd29_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD29_CITER_ELINKNO Register bits
    namespace tcd29_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD29_CITER_ELINKYES Register bits
    namespace tcd29_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD29_DLASTSGA Register bits
    namespace tcd29_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD29_CSR Register bits
    namespace tcd29_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD29_BITER_ELINKNO Register bits
    namespace tcd29_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD29_BITER_ELINKYES Register bits
    namespace tcd29_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD30_SADDR Register bits
    namespace tcd30_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD30_SOFF Register bits
    namespace tcd30_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD30_ATTR Register bits
    namespace tcd30_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD30_NBYTES_MLNO Register bits
    namespace tcd30_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD30_NBYTES_MLOFFNO Register bits
    namespace tcd30_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD30_NBYTES_MLOFFYES Register bits
    namespace tcd30_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD30_SLAST Register bits
    namespace tcd30_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD30_DADDR Register bits
    namespace tcd30_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD30_DOFF Register bits
    namespace tcd30_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD30_CITER_ELINKNO Register bits
    namespace tcd30_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD30_CITER_ELINKYES Register bits
    namespace tcd30_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD30_DLASTSGA Register bits
    namespace tcd30_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD30_CSR Register bits
    namespace tcd30_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD30_BITER_ELINKNO Register bits
    namespace tcd30_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD30_BITER_ELINKYES Register bits
    namespace tcd30_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD31_SADDR Register bits
    namespace tcd31_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD31_SOFF Register bits
    namespace tcd31_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD31_ATTR Register bits
    namespace tcd31_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD31_NBYTES_MLNO Register bits
    namespace tcd31_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD31_NBYTES_MLOFFNO Register bits
    namespace tcd31_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD31_NBYTES_MLOFFYES Register bits
    namespace tcd31_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD31_SLAST Register bits
    namespace tcd31_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD31_DADDR Register bits
    namespace tcd31_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD31_DOFF Register bits
    namespace tcd31_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD31_CITER_ELINKNO Register bits
    namespace tcd31_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD31_CITER_ELINKYES Register bits
    namespace tcd31_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD31_DLASTSGA Register bits
    namespace tcd31_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< DLASTSGA
    }

    /// TCD31_CSR Register bits
    namespace tcd31_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD31_BITER_ELINKNO Register bits
    namespace tcd31_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD31_BITER_ELINKYES Register bits
    namespace tcd31_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// GPC Peripheral
// ============================================================================

namespace gpc {
    /// Base addresses
    constexpr uint32_t GPC_BASE = 0x400F4000;

    /// GPC Register structure
    struct Registers {
        volatile uint32_t CNTR;  ///< Offset: 0x00 - GPC Interface control register
        volatile uint32_t IMR1;  ///< Offset: 0x08 - IRQ masking register 1
        volatile uint32_t IMR2;  ///< Offset: 0x0C - IRQ masking register 2
        volatile uint32_t IMR3;  ///< Offset: 0x10 - IRQ masking register 3
        volatile uint32_t IMR4;  ///< Offset: 0x14 - IRQ masking register 4
        volatile uint32_t ISR1;  ///< Offset: 0x18 - IRQ status resister 1
        volatile uint32_t ISR2;  ///< Offset: 0x1C - IRQ status resister 2
        volatile uint32_t ISR3;  ///< Offset: 0x20 - IRQ status resister 3
        volatile uint32_t ISR4;  ///< Offset: 0x24 - IRQ status resister 4
        volatile uint32_t IMR5;  ///< Offset: 0x34 - IRQ masking register 5
        volatile uint32_t ISR5;  ///< Offset: 0x38 - IRQ status resister 5
    };

    /// Peripheral instances
    inline Registers* GPC = reinterpret_cast<Registers*>(GPC_BASE);

    // Bit definitions
    /// CNTR Register bits
    namespace cntr_bits {
        constexpr uint32_t MEGA_PDN_REQ = (1U << 2);  ///< MEGA domain power down request
        constexpr uint32_t MEGA_PUP_REQ = (1U << 3);  ///< MEGA domain power up request
        constexpr uint32_t PDRAM0_PGE = (1U << 22);  ///< FlexRAM PDRAM0 Power Gate Enable
    }

    /// IMR1 Register bits
    namespace imr1_bits {
        constexpr uint32_t IMR1 = (32 << 0);  ///< IRQ[31:0] masking bits: 1-irq masked, 0-irq is not masked
    }

    /// IMR2 Register bits
    namespace imr2_bits {
        constexpr uint32_t IMR2 = (32 << 0);  ///< IRQ[63:32] masking bits: 1-irq masked, 0-irq is not masked
    }

    /// IMR3 Register bits
    namespace imr3_bits {
        constexpr uint32_t IMR3 = (32 << 0);  ///< IRQ[95:64] masking bits: 1-irq masked, 0-irq is not masked
    }

    /// IMR4 Register bits
    namespace imr4_bits {
        constexpr uint32_t IMR4 = (32 << 0);  ///< IRQ[127:96] masking bits: 1-irq masked, 0-irq is not masked
    }

    /// ISR1 Register bits
    namespace isr1_bits {
        constexpr uint32_t ISR1 = (32 << 0);  ///< IRQ[31:0] status, read only
    }

    /// ISR2 Register bits
    namespace isr2_bits {
        constexpr uint32_t ISR2 = (32 << 0);  ///< IRQ[63:32] status, read only
    }

    /// ISR3 Register bits
    namespace isr3_bits {
        constexpr uint32_t ISR3 = (32 << 0);  ///< IRQ[95:64] status, read only
    }

    /// ISR4 Register bits
    namespace isr4_bits {
        constexpr uint32_t ISR4 = (32 << 0);  ///< IRQ[127:96] status, read only
    }

    /// IMR5 Register bits
    namespace imr5_bits {
        constexpr uint32_t IMR5 = (32 << 0);  ///< IRQ[159:128] masking bits: 1-irq masked, 0-irq is not masked
    }

    /// ISR5 Register bits
    namespace isr5_bits {
        constexpr uint32_t ISR4 = (32 << 0);  ///< IRQ[159:128] status, read only
    }

}

// ============================================================================
// PGC Peripheral
// ============================================================================

namespace pgc {
    /// Base addresses
    constexpr uint32_t PGC_BASE = 0x400F4000;

    /// PGC Register structure
    struct Registers {
        volatile uint32_t MEGA_CTRL;  ///< Offset: 0x220 - PGC Mega Control Register
        volatile uint32_t MEGA_PUPSCR;  ///< Offset: 0x224 - PGC Mega Power Up Sequence Control Register
        volatile uint32_t MEGA_PDNSCR;  ///< Offset: 0x228 - PGC Mega Pull Down Sequence Control Register
        volatile uint32_t MEGA_SR;  ///< Offset: 0x22C - PGC Mega Power Gating Controller Status Register
        volatile uint32_t CPU_CTRL;  ///< Offset: 0x2A0 - PGC CPU Control Register
        volatile uint32_t CPU_PUPSCR;  ///< Offset: 0x2A4 - PGC CPU Power Up Sequence Control Register
        volatile uint32_t CPU_PDNSCR;  ///< Offset: 0x2A8 - PGC CPU Pull Down Sequence Control Register
        volatile uint32_t CPU_SR;  ///< Offset: 0x2AC - PGC CPU Power Gating Controller Status Register
    };

    /// Peripheral instances
    inline Registers* PGC = reinterpret_cast<Registers*>(PGC_BASE);

    // Bit definitions
    /// MEGA_CTRL Register bits
    namespace mega_ctrl_bits {
        constexpr uint32_t PCR = (1U << 0);  ///< Power Control PCR must not change from power-down request (pdn_req) assertion until the target subsystem is completely powered up
    }

    /// MEGA_PUPSCR Register bits
    namespace mega_pupscr_bits {
        constexpr uint32_t SW = (6 << 0);  ///< After a power-up request (pup_req assertion), the PGC waits a number of IPG clocks equal to the value of SW before asserting power toggle on/off signal (switch_b)
        constexpr uint32_t SW2ISO = (6 << 8);  ///< After asserting power toggle on/off signal (switch_b), the PGC waits a number of IPG clocks equal to the value of SW2ISO before negating isolation
    }

    /// MEGA_PDNSCR Register bits
    namespace mega_pdnscr_bits {
        constexpr uint32_t ISO = (6 << 0);  ///< After a power-down request (pdn_req assertion), the PGC waits a number of IPG clocks equal to the value of ISO before asserting isolation
        constexpr uint32_t ISO2SW = (6 << 8);  ///< After asserting isolation, the PGC waits a number of IPG clocks equal to the value of ISO2SW before negating power toggle on/off signal (switch_b)
    }

    /// MEGA_SR Register bits
    namespace mega_sr_bits {
        constexpr uint32_t PSR = (1U << 0);  ///< Power status
    }

    /// CPU_CTRL Register bits
    namespace cpu_ctrl_bits {
        constexpr uint32_t PCR = (1U << 0);  ///< Power Control PCR must not change from power-down request (pdn_req) assertion until the target subsystem is completely powered up
    }

    /// CPU_PUPSCR Register bits
    namespace cpu_pupscr_bits {
        constexpr uint32_t SW = (6 << 0);  ///< There are two different silicon revisions: 1
        constexpr uint32_t SW2ISO = (6 << 8);  ///< There are two different silicon revisions: 1
    }

    /// CPU_PDNSCR Register bits
    namespace cpu_pdnscr_bits {
        constexpr uint32_t ISO = (6 << 0);  ///< After a power-down request (pdn_req assertion), the PGC waits a number of 32k clocks equal to the value of ISO before asserting isolation
        constexpr uint32_t ISO2SW = (6 << 8);  ///< After asserting isolation, the PGC waits a number of 32k clocks equal to the value of ISO2SW before negating
    }

    /// CPU_SR Register bits
    namespace cpu_sr_bits {
        constexpr uint32_t PSR = (1U << 0);  ///< Power status
    }

}

// ============================================================================
// SRC Peripheral
// ============================================================================

namespace src {
    /// Base addresses
    constexpr uint32_t SRC_BASE = 0x400F8000;

    /// SRC Register structure
    struct Registers {
        volatile uint32_t SCR;  ///< Offset: 0x00 - SRC Control Register
        volatile uint32_t SBMR1;  ///< Offset: 0x04 - SRC Boot Mode Register 1
        volatile uint32_t SRSR;  ///< Offset: 0x08 - SRC Reset Status Register
        volatile uint32_t SBMR2;  ///< Offset: 0x1C - SRC Boot Mode Register 2
        volatile uint32_t GPR1;  ///< Offset: 0x20 - SRC General Purpose Register 1
        volatile uint32_t GPR2;  ///< Offset: 0x24 - SRC General Purpose Register 2
        volatile uint32_t GPR3;  ///< Offset: 0x28 - SRC General Purpose Register 3
        volatile uint32_t GPR4;  ///< Offset: 0x2C - SRC General Purpose Register 4
        volatile uint32_t GPR5;  ///< Offset: 0x30 - SRC General Purpose Register 5
        volatile uint32_t GPR6;  ///< Offset: 0x34 - SRC General Purpose Register 6
        volatile uint32_t GPR7;  ///< Offset: 0x38 - SRC General Purpose Register 7
        volatile uint32_t GPR8;  ///< Offset: 0x3C - SRC General Purpose Register 8
        volatile uint32_t GPR9;  ///< Offset: 0x40 - SRC General Purpose Register 9
        volatile uint32_t GPR10;  ///< Offset: 0x44 - SRC General Purpose Register 10
    };

    /// Peripheral instances
    inline Registers* SRC = reinterpret_cast<Registers*>(SRC_BASE);

    // Bit definitions
    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t mask_wdog_rst = (4 << 7);  ///< Mask wdog_rst_b source
        constexpr uint32_t core0_rst = (1U << 13);  ///< Software reset for core0 only
        constexpr uint32_t core0_dbg_rst = (1U << 17);  ///< Software reset for core0 debug only
        constexpr uint32_t dbg_rst_msk_pg = (1U << 25);  ///< Do not assert debug resets after power gating event of core
        constexpr uint32_t mask_wdog3_rst = (4 << 28);  ///< Mask wdog3_rst_b source
    }

    /// SBMR1 Register bits
    namespace sbmr1_bits {
        constexpr uint32_t BOOT_CFG1 = (8 << 0);  ///< Refer to fusemap.
        constexpr uint32_t BOOT_CFG2 = (8 << 8);  ///< Refer to fusemap.
        constexpr uint32_t BOOT_CFG3 = (8 << 16);  ///< Refer to fusemap.
        constexpr uint32_t BOOT_CFG4 = (8 << 24);  ///< Refer to fusemap.
    }

    /// SRSR Register bits
    namespace srsr_bits {
        constexpr uint32_t ipp_reset_b = (1U << 0);  ///< Indicates whether reset was the result of ipp_reset_b pin (Power-up sequence)
        constexpr uint32_t lockup_sysresetreq = (1U << 1);  ///< Indicates a reset has been caused by CPU lockup or software setting of SYSRESETREQ bit in Application Interrupt and Reset Control Register of the ARM core
        constexpr uint32_t csu_reset_b = (1U << 2);  ///< Indicates whether the reset was the result of the csu_reset_b input.
        constexpr uint32_t ipp_user_reset_b = (1U << 3);  ///< Indicates whether the reset was the result of the ipp_user_reset_b qualified reset.
        constexpr uint32_t wdog_rst_b = (1U << 4);  ///< IC Watchdog Time-out reset
        constexpr uint32_t jtag_rst_b = (1U << 5);  ///< HIGH - Z JTAG reset. Indicates whether the reset was the result of HIGH-Z reset from JTAG.
        constexpr uint32_t jtag_sw_rst = (1U << 6);  ///< JTAG software reset. Indicates whether the reset was the result of software reset from JTAG.
        constexpr uint32_t wdog3_rst_b = (1U << 7);  ///< IC Watchdog3 Time-out reset
        constexpr uint32_t tempsense_rst_b = (1U << 8);  ///< Temper Sensor software reset
    }

    /// SBMR2 Register bits
    namespace sbmr2_bits {
        constexpr uint32_t SEC_CONFIG = (2 << 0);  ///< SECONFIG[1] shows the state of the SECONFIG[1] fuse
        constexpr uint32_t DIR_BT_DIS = (1U << 3);  ///< DIR_BT_DIS shows the state of the DIR_BT_DIS fuse
        constexpr uint32_t BT_FUSE_SEL = (1U << 4);  ///< BT_FUSE_SEL (connected to gpio bt_fuse_sel) shows the state of the BT_FUSE_SEL fuse
        constexpr uint32_t BMOD = (2 << 24);  ///< BMOD[1:0] shows the latched state of the BOOT_MODE1 and BOOT_MODE0 signals on the rising edge of POR_B
    }

    /// GPR1 Register bits
    namespace gpr1_bits {
        constexpr uint32_t PERSISTENT_ENTRY0 = (32 << 0);  ///< Holds entry function for core0 for waking-up from low power mode
    }

    /// GPR2 Register bits
    namespace gpr2_bits {
        constexpr uint32_t PERSISTENT_ARG0 = (32 << 0);  ///< Holds argument of entry function for core0 for waking-up from low power mode
    }

}

// ============================================================================
// ROMC Peripheral
// ============================================================================

namespace romc {
    /// Base addresses
    constexpr uint32_t ROMC_BASE = 0x40180000;

    /// ROMC Register structure
    struct Registers {
        volatile uint32_t ROMPATCH%sD;  ///< Offset: 0xD4 - ROMC Data Registers
        volatile uint32_t ROMPATCHCNTL;  ///< Offset: 0xF4 - ROMC Control Register
        volatile uint32_t ROMPATCHENH;  ///< Offset: 0xF8 - ROMC Enable Register High
        volatile uint32_t ROMPATCHENL;  ///< Offset: 0xFC - ROMC Enable Register Low
        volatile uint32_t ROMPATCH%sA;  ///< Offset: 0x100 - ROMC Address Registers
        volatile uint32_t ROMPATCHSR;  ///< Offset: 0x208 - ROMC Status Register
    };

    /// Peripheral instances
    inline Registers* ROMC = reinterpret_cast<Registers*>(ROMC_BASE);

    // Bit definitions
    /// ROMPATCH%sD Register bits
    namespace rompatch%sd_bits {
        constexpr uint32_t DATAX = (32 << 0);  ///< Data Fix Registers - Stores the data used for 1-word data fix operations
    }

    /// ROMPATCHCNTL Register bits
    namespace rompatchcntl_bits {
        constexpr uint32_t DATAFIX = (8 << 0);  ///< Data Fix Enable - Controls the use of the first 8 address comparators for 1-word data fix or for code patch routine
        constexpr uint32_t DIS = (1U << 29);  ///< ROMC Disable -- This bit, when set, disables all ROMC operations
    }

    /// ROMPATCHENL Register bits
    namespace rompatchenl_bits {
        constexpr uint32_t ENABLE = (16 << 0);  ///< Enable Address Comparator - This bit enables the corresponding address comparator to trigger an event
    }

    /// ROMPATCH%sA Register bits
    namespace rompatch%sa_bits {
        constexpr uint32_t THUMBX = (1U << 0);  ///< THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an Arm opcode patch
        constexpr uint32_t ADDRX = (22 << 1);  ///< Address Comparator Registers - Indicates the memory address to be watched
    }

    /// ROMPATCHSR Register bits
    namespace rompatchsr_bits {
        constexpr uint32_t SOURCE = (6 << 0);  ///< ROMC Source Number - Binary encoding of the number of the address comparator which has an address match in the most recent patch event on ROMC AHB
        constexpr uint32_t SW = (1U << 17);  ///< ROMC AHB Multiple Address Comparator matches Indicator - Indicates that multiple address comparator matches occurred
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART1_BASE = 0x40184000;
    constexpr uint32_t LPUART2_BASE = 0x40188000;
    constexpr uint32_t LPUART3_BASE = 0x4018C000;
    constexpr uint32_t LPUART4_BASE = 0x40190000;
    constexpr uint32_t LPUART5_BASE = 0x40194000;
    constexpr uint32_t LPUART6_BASE = 0x40198000;
    constexpr uint32_t LPUART7_BASE = 0x4019C000;
    constexpr uint32_t LPUART8_BASE = 0x401A0000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t GLOBAL;  ///< Offset: 0x08 - LPUART Global Register
        volatile uint32_t PINCFG;  ///< Offset: 0x0C - LPUART Pin Configuration Register
        volatile uint32_t BAUD;  ///< Offset: 0x10 - LPUART Baud Rate Register
        volatile uint32_t STAT;  ///< Offset: 0x14 - LPUART Status Register
        volatile uint32_t CTRL;  ///< Offset: 0x18 - LPUART Control Register
        volatile uint32_t DATA;  ///< Offset: 0x1C - LPUART Data Register
        volatile uint32_t MATCH;  ///< Offset: 0x20 - LPUART Match Address Register
        volatile uint32_t MODIR;  ///< Offset: 0x24 - LPUART Modem IrDA Register
        volatile uint32_t FIFO;  ///< Offset: 0x28 - LPUART FIFO Register
        volatile uint32_t WATER;  ///< Offset: 0x2C - LPUART Watermark Register
    };

    /// Peripheral instances
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* LPUART2 = reinterpret_cast<Registers*>(LPUART2_BASE);
    inline Registers* LPUART3 = reinterpret_cast<Registers*>(LPUART3_BASE);
    inline Registers* LPUART4 = reinterpret_cast<Registers*>(LPUART4_BASE);
    inline Registers* LPUART5 = reinterpret_cast<Registers*>(LPUART5_BASE);
    inline Registers* LPUART6 = reinterpret_cast<Registers*>(LPUART6_BASE);
    inline Registers* LPUART7 = reinterpret_cast<Registers*>(LPUART7_BASE);
    inline Registers* LPUART8 = reinterpret_cast<Registers*>(LPUART8_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Identification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t TXFIFO = (8 << 0);  ///< Transmit FIFO Size
        constexpr uint32_t RXFIFO = (8 << 8);  ///< Receive FIFO Size
    }

    /// GLOBAL Register bits
    namespace global_bits {
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
    }

    /// PINCFG Register bits
    namespace pincfg_bits {
        constexpr uint32_t TRGSEL = (2 << 0);  ///< Trigger Select
    }

    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t SBR = (13 << 0);  ///< Baud Rate Modulo Divisor.
        constexpr uint32_t SBNS = (1U << 13);  ///< Stop Bit Number Select
        constexpr uint32_t RXEDGIE = (1U << 14);  ///< RX Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 15);  ///< LIN Break Detect Interrupt Enable
        constexpr uint32_t RESYNCDIS = (1U << 16);  ///< Resynchronization Disable
        constexpr uint32_t BOTHEDGE = (1U << 17);  ///< Both Edge Sampling
        constexpr uint32_t MATCFG = (2 << 18);  ///< Match Configuration
        constexpr uint32_t RIDMAE = (1U << 20);  ///< Receiver Idle DMA Enable
        constexpr uint32_t RDMAE = (1U << 21);  ///< Receiver Full DMA Enable
        constexpr uint32_t TDMAE = (1U << 23);  ///< Transmitter DMA Enable
        constexpr uint32_t OSR = (5 << 24);  ///< Oversampling Ratio
        constexpr uint32_t M10 = (1U << 29);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 30);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 31);  ///< Match Address Mode Enable 1
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t MA2F = (1U << 14);  ///< Match 2 Flag
        constexpr uint32_t MA1F = (1U << 15);  ///< Match 1 Flag
        constexpr uint32_t PF = (1U << 16);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 17);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 18);  ///< Noise Flag
        constexpr uint32_t OR = (1U << 19);  ///< Receiver Overrun Flag
        constexpr uint32_t IDLE = (1U << 20);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 21);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 22);  ///< Transmission Complete Flag
        constexpr uint32_t TDRE = (1U << 23);  ///< Transmit Data Register Empty Flag
        constexpr uint32_t RAF = (1U << 24);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 25);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 26);  ///< Break Character Generation Length
        constexpr uint32_t RWUID = (1U << 27);  ///< Receive Wake Up Idle Detect
        constexpr uint32_t RXINV = (1U << 28);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 29);  ///< MSB First
        constexpr uint32_t RXEDGIF = (1U << 30);  ///< RXD Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 31);  ///< LIN Break Detect Interrupt Flag
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-Bit or 8-Bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t DOZEEN = (1U << 6);  ///< Doze Enable
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
        constexpr uint32_t IDLECFG = (3 << 8);  ///< Idle Configuration
        constexpr uint32_t M7 = (1U << 11);  ///< 7-Bit Mode Select
        constexpr uint32_t MA2IE = (1U << 14);  ///< Match 2 Interrupt Enable
        constexpr uint32_t MA1IE = (1U << 15);  ///< Match 1 Interrupt Enable
        constexpr uint32_t SBK = (1U << 16);  ///< Send Break
        constexpr uint32_t RWU = (1U << 17);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 18);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 19);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 20);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 21);  ///< Receiver Interrupt Enable
        constexpr uint32_t TCIE = (1U << 22);  ///< Transmission Complete Interrupt Enable for
        constexpr uint32_t TIE = (1U << 23);  ///< Transmit Interrupt Enable
        constexpr uint32_t PEIE = (1U << 24);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 25);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 26);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 27);  ///< Overrun Interrupt Enable
        constexpr uint32_t TXINV = (1U << 28);  ///< Transmit Data Inversion
        constexpr uint32_t TXDIR = (1U << 29);  ///< TXD Pin Direction in Single-Wire Mode
        constexpr uint32_t R9T8 = (1U << 30);  ///< Receive Bit 9 / Transmit Bit 8
        constexpr uint32_t R8T9 = (1U << 31);  ///< Receive Bit 8 / Transmit Bit 9
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t R0T0 = (1U << 0);  ///< R0T0
        constexpr uint32_t R1T1 = (1U << 1);  ///< R1T1
        constexpr uint32_t R2T2 = (1U << 2);  ///< R2T2
        constexpr uint32_t R3T3 = (1U << 3);  ///< R3T3
        constexpr uint32_t R4T4 = (1U << 4);  ///< R4T4
        constexpr uint32_t R5T5 = (1U << 5);  ///< R5T5
        constexpr uint32_t R6T6 = (1U << 6);  ///< R6T6
        constexpr uint32_t R7T7 = (1U << 7);  ///< R7T7
        constexpr uint32_t R8T8 = (1U << 8);  ///< R8T8
        constexpr uint32_t R9T9 = (1U << 9);  ///< R9T9
        constexpr uint32_t IDLINE = (1U << 11);  ///< Idle Line
        constexpr uint32_t RXEMPT = (1U << 12);  ///< Receive Buffer Empty
        constexpr uint32_t FRETSC = (1U << 13);  ///< Frame Error / Transmit Special Character
        constexpr uint32_t PARITYE = (1U << 14);  ///< PARITYE
        constexpr uint32_t NOISY = (1U << 15);  ///< NOISY
    }

    /// MATCH Register bits
    namespace match_bits {
        constexpr uint32_t MA1 = (10 << 0);  ///< Match Address 1
        constexpr uint32_t MA2 = (10 << 16);  ///< Match Address 2
    }

    /// MODIR Register bits
    namespace modir_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
        constexpr uint32_t TXCTSC = (1U << 4);  ///< Transmit CTS Configuration
        constexpr uint32_t TXCTSSRC = (1U << 5);  ///< Transmit CTS Source
        constexpr uint32_t RTSWATER = (2 << 8);  ///< Receive RTS Configuration
        constexpr uint32_t TNP = (2 << 16);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 18);  ///< Infrared enable
    }

    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
        constexpr uint32_t RXUFE = (1U << 8);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 9);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXIDEN = (3 << 10);  ///< Receiver Idle Empty Enable
        constexpr uint32_t RXFLUSH = (1U << 14);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 15);  ///< Transmit FIFO/Buffer Flush
        constexpr uint32_t RXUF = (1U << 16);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 17);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXEMPT = (1U << 22);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 23);  ///< Transmit Buffer/FIFO Empty
    }

    /// WATER Register bits
    namespace water_bits {
        constexpr uint32_t TXWATER = (2 << 0);  ///< Transmit Watermark
        constexpr uint32_t TXCOUNT = (3 << 8);  ///< Transmit Counter
        constexpr uint32_t RXWATER = (2 << 16);  ///< Receive Watermark
        constexpr uint32_t RXCOUNT = (3 << 24);  ///< Receive Counter
    }

}

// ============================================================================
// FLEXIO1 Peripheral
// ============================================================================

namespace flexio1 {
    /// Base addresses
    constexpr uint32_t FLEXIO1_BASE = 0x401AC000;

    /// FLEXIO1 Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - FlexIO Control Register
        volatile uint32_t PIN;  ///< Offset: 0x0C - Pin State Register
        volatile uint32_t SHIFTSTAT;  ///< Offset: 0x10 - Shifter Status Register
        volatile uint32_t SHIFTERR;  ///< Offset: 0x14 - Shifter Error Register
        volatile uint32_t TIMSTAT;  ///< Offset: 0x18 - Timer Status Register
        volatile uint32_t SHIFTSIEN;  ///< Offset: 0x20 - Shifter Status Interrupt Enable
        volatile uint32_t SHIFTEIEN;  ///< Offset: 0x24 - Shifter Error Interrupt Enable
        volatile uint32_t TIMIEN;  ///< Offset: 0x28 - Timer Interrupt Enable Register
        volatile uint32_t SHIFTSDEN;  ///< Offset: 0x30 - Shifter Status DMA Enable
        volatile uint32_t SHIFTSTATE;  ///< Offset: 0x40 - Shifter State Register
        volatile uint32_t SHIFTCTL[%s];  ///< Offset: 0x80 - Shifter Control N Register
        volatile uint32_t SHIFTCFG[%s];  ///< Offset: 0x100 - Shifter Configuration N Register
        volatile uint32_t SHIFTBUF[%s];  ///< Offset: 0x200 - Shifter Buffer N Register
        volatile uint32_t SHIFTBUFBIS[%s];  ///< Offset: 0x280 - Shifter Buffer N Bit Swapped Register
        volatile uint32_t SHIFTBUFBYS[%s];  ///< Offset: 0x300 - Shifter Buffer N Byte Swapped Register
        volatile uint32_t SHIFTBUFBBS[%s];  ///< Offset: 0x380 - Shifter Buffer N Bit Byte Swapped Register
        volatile uint32_t TIMCTL[%s];  ///< Offset: 0x400 - Timer Control N Register
        volatile uint32_t TIMCFG[%s];  ///< Offset: 0x480 - Timer Configuration N Register
        volatile uint32_t TIMCMP[%s];  ///< Offset: 0x500 - Timer Compare N Register
        volatile uint32_t SHIFTBUFNBS[%s];  ///< Offset: 0x680 - Shifter Buffer N Nibble Byte Swapped Register
        volatile uint32_t SHIFTBUFHWS[%s];  ///< Offset: 0x700 - Shifter Buffer N Half Word Swapped Register
        volatile uint32_t SHIFTBUFNIS[%s];  ///< Offset: 0x780 - Shifter Buffer N Nibble Swapped Register
    };

    /// Peripheral instances
    inline Registers* FLEXIO1 = reinterpret_cast<Registers*>(FLEXIO1_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t SHIFTER = (8 << 0);  ///< Shifter Number
        constexpr uint32_t TIMER = (8 << 8);  ///< Timer Number
        constexpr uint32_t PIN = (8 << 16);  ///< Pin Number
        constexpr uint32_t TRIGGER = (8 << 24);  ///< Trigger Number
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t FLEXEN = (1U << 0);  ///< FlexIO Enable
        constexpr uint32_t SWRST = (1U << 1);  ///< Software Reset
        constexpr uint32_t FASTACC = (1U << 2);  ///< Fast Access
        constexpr uint32_t DBGE = (1U << 30);  ///< Debug Enable
        constexpr uint32_t DOZEN = (1U << 31);  ///< Doze Enable
    }

    /// PIN Register bits
    namespace pin_bits {
        constexpr uint32_t PDI = (16 << 0);  ///< Pin Data Input
    }

    /// SHIFTSTAT Register bits
    namespace shiftstat_bits {
        constexpr uint32_t SSF = (4 << 0);  ///< Shifter Status Flag
    }

    /// SHIFTERR Register bits
    namespace shifterr_bits {
        constexpr uint32_t SEF = (4 << 0);  ///< Shifter Error Flags
    }

    /// TIMSTAT Register bits
    namespace timstat_bits {
        constexpr uint32_t TSF = (4 << 0);  ///< Timer Status Flags
    }

    /// SHIFTSIEN Register bits
    namespace shiftsien_bits {
        constexpr uint32_t SSIE = (4 << 0);  ///< Shifter Status Interrupt Enable
    }

    /// SHIFTEIEN Register bits
    namespace shifteien_bits {
        constexpr uint32_t SEIE = (4 << 0);  ///< Shifter Error Interrupt Enable
    }

    /// TIMIEN Register bits
    namespace timien_bits {
        constexpr uint32_t TEIE = (4 << 0);  ///< Timer Status Interrupt Enable
    }

    /// SHIFTSDEN Register bits
    namespace shiftsden_bits {
        constexpr uint32_t SSDE = (4 << 0);  ///< Shifter Status DMA Enable
    }

    /// SHIFTSTATE Register bits
    namespace shiftstate_bits {
        constexpr uint32_t STATE = (3 << 0);  ///< Current State Pointer
    }

    /// SHIFTCTL[%s] Register bits
    namespace shiftctl[%s]_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (4 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (2 << 24);  ///< Timer Select
    }

    /// SHIFTCFG[%s] Register bits
    namespace shiftcfg[%s]_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
        constexpr uint32_t PWIDTH = (4 << 16);  ///< Parallel Width
    }

    /// SHIFTBUF[%s] Register bits
    namespace shiftbuf[%s]_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBIS[%s] Register bits
    namespace shiftbufbis[%s]_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBYS[%s] Register bits
    namespace shiftbufbys[%s]_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBBS[%s] Register bits
    namespace shiftbufbbs[%s]_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// TIMCTL[%s] Register bits
    namespace timctl[%s]_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (4 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (5 << 24);  ///< Trigger Select
    }

    /// TIMCFG[%s] Register bits
    namespace timcfg[%s]_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// TIMCMP[%s] Register bits
    namespace timcmp[%s]_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

    /// SHIFTBUFNBS[%s] Register bits
    namespace shiftbufnbs[%s]_bits {
        constexpr uint32_t SHIFTBUFNBS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFHWS[%s] Register bits
    namespace shiftbufhws[%s]_bits {
        constexpr uint32_t SHIFTBUFHWS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFNIS[%s] Register bits
    namespace shiftbufnis[%s]_bits {
        constexpr uint32_t SHIFTBUFNIS = (32 << 0);  ///< Shift Buffer
    }

}

// ============================================================================
// FLEXIO2 Peripheral
// ============================================================================

namespace flexio2 {
    /// Base addresses
    constexpr uint32_t FLEXIO2_BASE = 0x401B0000;

    /// FLEXIO2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* FLEXIO2 = reinterpret_cast<Registers*>(FLEXIO2_BASE);

}

// ============================================================================
// FLEXIO3 Peripheral
// ============================================================================

namespace flexio3 {
    /// Base addresses
    constexpr uint32_t FLEXIO3_BASE = 0x42020000;

    /// FLEXIO3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* FLEXIO3 = reinterpret_cast<Registers*>(FLEXIO3_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO1_BASE = 0x401B8000;
    constexpr uint32_t GPIO5_BASE = 0x400C0000;
    constexpr uint32_t GPIO2_BASE = 0x401BC000;
    constexpr uint32_t GPIO3_BASE = 0x401C0000;
    constexpr uint32_t GPIO4_BASE = 0x401C4000;
    constexpr uint32_t GPIO6_BASE = 0x42000000;
    constexpr uint32_t GPIO7_BASE = 0x42004000;
    constexpr uint32_t GPIO8_BASE = 0x42008000;
    constexpr uint32_t GPIO9_BASE = 0x4200C000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - GPIO data register
        volatile uint32_t GDIR;  ///< Offset: 0x04 - GPIO direction register
        volatile uint32_t PSR;  ///< Offset: 0x08 - GPIO pad status register
        volatile uint32_t ICR1;  ///< Offset: 0x0C - GPIO interrupt configuration register1
        volatile uint32_t ICR2;  ///< Offset: 0x10 - GPIO interrupt configuration register2
        volatile uint32_t IMR;  ///< Offset: 0x14 - GPIO interrupt mask register
        volatile uint32_t ISR;  ///< Offset: 0x18 - GPIO interrupt status register
        volatile uint32_t EDGE_SEL;  ///< Offset: 0x1C - GPIO edge select register
        volatile uint32_t DR_SET;  ///< Offset: 0x84 - GPIO data register SET
        volatile uint32_t DR_CLEAR;  ///< Offset: 0x88 - GPIO data register CLEAR
        volatile uint32_t DR_TOGGLE;  ///< Offset: 0x8C - GPIO data register TOGGLE
    };

    /// Peripheral instances
    inline Registers* GPIO1 = reinterpret_cast<Registers*>(GPIO1_BASE);
    inline Registers* GPIO5 = reinterpret_cast<Registers*>(GPIO5_BASE);
    inline Registers* GPIO2 = reinterpret_cast<Registers*>(GPIO2_BASE);
    inline Registers* GPIO3 = reinterpret_cast<Registers*>(GPIO3_BASE);
    inline Registers* GPIO4 = reinterpret_cast<Registers*>(GPIO4_BASE);
    inline Registers* GPIO6 = reinterpret_cast<Registers*>(GPIO6_BASE);
    inline Registers* GPIO7 = reinterpret_cast<Registers*>(GPIO7_BASE);
    inline Registers* GPIO8 = reinterpret_cast<Registers*>(GPIO8_BASE);
    inline Registers* GPIO9 = reinterpret_cast<Registers*>(GPIO9_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< DR
    }

    /// GDIR Register bits
    namespace gdir_bits {
        constexpr uint32_t GDIR = (32 << 0);  ///< GDIR
    }

    /// PSR Register bits
    namespace psr_bits {
        constexpr uint32_t PSR = (32 << 0);  ///< PSR
    }

    /// ICR1 Register bits
    namespace icr1_bits {
        constexpr uint32_t ICR0 = (2 << 0);  ///< ICR0
        constexpr uint32_t ICR1 = (2 << 2);  ///< ICR1
        constexpr uint32_t ICR2 = (2 << 4);  ///< ICR2
        constexpr uint32_t ICR3 = (2 << 6);  ///< ICR3
        constexpr uint32_t ICR4 = (2 << 8);  ///< ICR4
        constexpr uint32_t ICR5 = (2 << 10);  ///< ICR5
        constexpr uint32_t ICR6 = (2 << 12);  ///< ICR6
        constexpr uint32_t ICR7 = (2 << 14);  ///< ICR7
        constexpr uint32_t ICR8 = (2 << 16);  ///< ICR8
        constexpr uint32_t ICR9 = (2 << 18);  ///< ICR9
        constexpr uint32_t ICR10 = (2 << 20);  ///< ICR10
        constexpr uint32_t ICR11 = (2 << 22);  ///< ICR11
        constexpr uint32_t ICR12 = (2 << 24);  ///< ICR12
        constexpr uint32_t ICR13 = (2 << 26);  ///< ICR13
        constexpr uint32_t ICR14 = (2 << 28);  ///< ICR14
        constexpr uint32_t ICR15 = (2 << 30);  ///< ICR15
    }

    /// ICR2 Register bits
    namespace icr2_bits {
        constexpr uint32_t ICR16 = (2 << 0);  ///< ICR16
        constexpr uint32_t ICR17 = (2 << 2);  ///< ICR17
        constexpr uint32_t ICR18 = (2 << 4);  ///< ICR18
        constexpr uint32_t ICR19 = (2 << 6);  ///< ICR19
        constexpr uint32_t ICR20 = (2 << 8);  ///< ICR20
        constexpr uint32_t ICR21 = (2 << 10);  ///< ICR21
        constexpr uint32_t ICR22 = (2 << 12);  ///< ICR22
        constexpr uint32_t ICR23 = (2 << 14);  ///< ICR23
        constexpr uint32_t ICR24 = (2 << 16);  ///< ICR24
        constexpr uint32_t ICR25 = (2 << 18);  ///< ICR25
        constexpr uint32_t ICR26 = (2 << 20);  ///< ICR26
        constexpr uint32_t ICR27 = (2 << 22);  ///< ICR27
        constexpr uint32_t ICR28 = (2 << 24);  ///< ICR28
        constexpr uint32_t ICR29 = (2 << 26);  ///< ICR29
        constexpr uint32_t ICR30 = (2 << 28);  ///< ICR30
        constexpr uint32_t ICR31 = (2 << 30);  ///< ICR31
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t IMR = (32 << 0);  ///< IMR
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ISR = (32 << 0);  ///< ISR
    }

    /// EDGE_SEL Register bits
    namespace edge_sel_bits {
        constexpr uint32_t GPIO_EDGE_SEL = (32 << 0);  ///< GPIO_EDGE_SEL
    }

    /// DR_SET Register bits
    namespace dr_set_bits {
        constexpr uint32_t DR_SET = (32 << 0);  ///< DR_SET
    }

    /// DR_CLEAR Register bits
    namespace dr_clear_bits {
        constexpr uint32_t DR_CLEAR = (32 << 0);  ///< DR_CLEAR
    }

    /// DR_TOGGLE Register bits
    namespace dr_toggle_bits {
        constexpr uint32_t DR_TOGGLE = (32 << 0);  ///< DR_TOGGLE
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN1_BASE = 0x401D0000;
    constexpr uint32_t CAN2_BASE = 0x401D4000;
    constexpr uint32_t CAN3_BASE = 0x401D8000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t CTRL1;  ///< Offset: 0x04 - Control 1 Register
        volatile uint32_t TIMER;  ///< Offset: 0x08 - Free Running Timer Register
        volatile uint32_t RXMGMASK;  ///< Offset: 0x10 - Rx Mailboxes Global Mask Register
        volatile uint32_t RX14MASK;  ///< Offset: 0x14 - Rx Buffer 14 Mask Register
        volatile uint32_t RX15MASK;  ///< Offset: 0x18 - Rx Buffer 15 Mask Register
        volatile uint32_t ECR;  ///< Offset: 0x1C - Error Counter Register
        volatile uint32_t ESR1;  ///< Offset: 0x20 - Error and Status 1 Register
        volatile uint32_t IMASK2;  ///< Offset: 0x24 - Interrupt Masks 2 Register
        volatile uint32_t IMASK1;  ///< Offset: 0x28 - Interrupt Masks 1 Register
        volatile uint32_t IFLAG2;  ///< Offset: 0x2C - Interrupt Flags 2 Register
        volatile uint32_t IFLAG1;  ///< Offset: 0x30 - Interrupt Flags 1 Register
        volatile uint32_t CTRL2;  ///< Offset: 0x34 - Control 2 Register
        volatile uint32_t ESR2;  ///< Offset: 0x38 - Error and Status 2 Register
        volatile uint32_t CRCR;  ///< Offset: 0x44 - CRC Register
        volatile uint32_t RXFGMASK;  ///< Offset: 0x48 - Rx FIFO Global Mask Register
        volatile uint32_t RXFIR;  ///< Offset: 0x4C - Rx FIFO Information Register
        volatile uint32_t DBG1;  ///< Offset: 0x58 - Debug 1 register
        volatile uint32_t DBG2;  ///< Offset: 0x5C - Debug 2 register
        volatile uint32_t RXIMR%s;  ///< Offset: 0x880 - Rx Individual Mask Registers
        volatile uint32_t GFWR;  ///< Offset: 0x9E0 - Glitch Filter Width Registers
    };

    /// Peripheral instances
    inline Registers* CAN1 = reinterpret_cast<Registers*>(CAN1_BASE);
    inline Registers* CAN2 = reinterpret_cast<Registers*>(CAN2_BASE);
    inline Registers* CAN3 = reinterpret_cast<Registers*>(CAN3_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MAXMB = (7 << 0);  ///< This 7-bit field defines the number of the last Message Buffers that will take part in the matching and arbitration processes
        constexpr uint32_t IDAM = (2 << 8);  ///< This 2-bit field identifies the format of the elements of the Rx FIFO filter table, as shown below
        constexpr uint32_t AEN = (1U << 12);  ///< This bit is supplied for backwards compatibility reasons
        constexpr uint32_t LPRIOEN = (1U << 13);  ///< This bit is provided for backwards compatibility reasons
        constexpr uint32_t IRMQ = (1U << 16);  ///< This bit indicates whether Rx matching process will be based either on individual masking and queue or on masking scheme with RXMGMASK, RX14MASK and RX15MASK, RXFGMASK
        constexpr uint32_t SRXDIS = (1U << 17);  ///< This bit defines whether FlexCAN is allowed to receive frames transmitted by itself
        constexpr uint32_t WAKSRC = (1U << 19);  ///< This bit defines whether the integrated low-pass filter is applied to protect the FLEXCAN_RX input from spurious wake up
        constexpr uint32_t LPMACK = (1U << 20);  ///< This read-only bit indicates that FLEXCAN is either in Disable Mode or Stop Mode
        constexpr uint32_t WRNEN = (1U << 21);  ///< When asserted, this bit enables the generation of the TWRN_INT and RWRN_INT flags in the Error and Status Register
        constexpr uint32_t SLFWAK = (1U << 22);  ///< This bit enables the Self Wake Up feature when FLEXCAN is in Stop Mode
        constexpr uint32_t SUPV = (1U << 23);  ///< This bit configures some of the FLEXCAN registers to be either in Supervisor or User Mode
        constexpr uint32_t FRZACK = (1U << 24);  ///< This read-only bit indicates that FLEXCAN is in Freeze Mode and its prescaler is stopped
        constexpr uint32_t SOFTRST = (1U << 25);  ///< When this bit is asserted, FlexCAN resets its internal state machines and some of the memory mapped registers
        constexpr uint32_t WAKMSK = (1U << 26);  ///< This bit enables the Wake Up Interrupt generation.
        constexpr uint32_t NOTRDY = (1U << 27);  ///< This read-only bit indicates that FLEXCAN is either in Disable Mode, Stop Mode or Freeze Mode
        constexpr uint32_t HALT = (1U << 28);  ///< Assertion of this bit puts the FLEXCAN module into Freeze Mode
        constexpr uint32_t RFEN = (1U << 29);  ///< This bit controls whether the Rx FIFO feature is enabled or not
        constexpr uint32_t FRZ = (1U << 30);  ///< The FRZ bit specifies the FLEXCAN behavior when the HALT bit in the MCR Register is set or when Debug Mode is requested at Arm level
        constexpr uint32_t MDIS = (1U << 31);  ///< This bit controls whether FLEXCAN is enabled or not
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t PROPSEG = (3 << 0);  ///< This 3-bit field defines the length of the Propagation Segment in the bit time
        constexpr uint32_t LOM = (1U << 3);  ///< This bit configures FLEXCAN to operate in Listen Only Mode
        constexpr uint32_t LBUF = (1U << 4);  ///< This bit defines the ordering mechanism for Message Buffer transmission
        constexpr uint32_t TSYN = (1U << 5);  ///< This bit enables a mechanism that resets the free-running timer each time a message is received in Message Buffer 0
        constexpr uint32_t BOFFREC = (1U << 6);  ///< This bit defines how FLEXCAN recovers from Bus Off state
        constexpr uint32_t SMP = (1U << 7);  ///< This bit defines the sampling mode of CAN bits at the FLEXCAN_RX
        constexpr uint32_t RWRNMSK = (1U << 10);  ///< This bit provides a mask for the Rx Warning Interrupt associated with the RWRN_INT flag in the Error and Status Register
        constexpr uint32_t TWRNMSK = (1U << 11);  ///< This bit provides a mask for the Tx Warning Interrupt associated with the TWRN_INT flag in the Error and Status Register
        constexpr uint32_t LPB = (1U << 12);  ///< This bit configures FlexCAN to operate in Loop-Back Mode
        constexpr uint32_t ERRMSK = (1U << 14);  ///< This bit provides a mask for the Error Interrupt.
        constexpr uint32_t BOFFMSK = (1U << 15);  ///< This bit provides a mask for the Bus Off Interrupt.
        constexpr uint32_t PSEG2 = (3 << 16);  ///< This 3-bit field defines the length of Phase Buffer Segment 2 in the bit time
        constexpr uint32_t PSEG1 = (3 << 19);  ///< This 3-bit field defines the length of Phase Buffer Segment 1 in the bit time
        constexpr uint32_t RJW = (2 << 22);  ///< This 2-bit field defines the maximum number of time quanta One time quantum is equal to the Sclock period
        constexpr uint32_t PRESDIV = (8 << 24);  ///< This 8-bit field defines the ratio between the PE clock frequency and the Serial Clock (Sclock) frequency
    }

    /// TIMER Register bits
    namespace timer_bits {
        constexpr uint32_t TIMER = (16 << 0);  ///< TIMER
    }

    /// RXMGMASK Register bits
    namespace rxmgmask_bits {
        constexpr uint32_t MG = (32 << 0);  ///< These bits mask the Mailbox filter bits as shown in the figure above
    }

    /// RX14MASK Register bits
    namespace rx14mask_bits {
        constexpr uint32_t RX14M = (32 << 0);  ///< These bits mask Mailbox 14 filter bits in the same fashion as RXMGMASK masks other Mailboxes filters (see RXMGMASKRx Mailboxes Global Mask Register )
    }

    /// RX15MASK Register bits
    namespace rx15mask_bits {
        constexpr uint32_t RX15M = (32 << 0);  ///< These bits mask Mailbox 15 filter bits in the same fashion as RXMGMASK masks other Mailboxes filters (see RXMGMASKRx Mailboxes Global Mask Register )
    }

    /// ECR Register bits
    namespace ecr_bits {
        constexpr uint32_t TX_ERR_COUNTER = (8 << 0);  ///< Tx_Err_Counter
        constexpr uint32_t RX_ERR_COUNTER = (8 << 8);  ///< Rx_Err_Counter
    }

    /// ESR1 Register bits
    namespace esr1_bits {
        constexpr uint32_t WAKINT = (1U << 0);  ///< When FLEXCAN is Stop Mode and a recessive to dominant transition is detected on the CAN bus and if the WAK_MSK bit in the MCR Register is set, an interrupt is generated to the Arm
        constexpr uint32_t ERRINT = (1U << 1);  ///< This bit indicates that at least one of the Error Bits (bits 15-10) is set
        constexpr uint32_t BOFFINT = (1U << 2);  ///< This bit is set when FLEXCAN enters 'Bus Off' state
        constexpr uint32_t RX = (1U << 3);  ///< This bit indicates if FlexCAN is receiving a message. Refer to .
        constexpr uint32_t FLTCONF = (2 << 4);  ///< If the LOM bit in the Control Register is asserted, after some delay that depends on the CAN bit timing the FLT_CONF field will indicate "Error Passive"
        constexpr uint32_t TX = (1U << 6);  ///< This bit indicates if FLEXCAN is transmitting a message.Refer to .
        constexpr uint32_t IDLE = (1U << 7);  ///< This bit indicates when CAN bus is in IDLE state.Refer to .
        constexpr uint32_t RXWRN = (1U << 8);  ///< This bit indicates when repetitive errors are occurring during message reception.
        constexpr uint32_t TXWRN = (1U << 9);  ///< This bit indicates when repetitive errors are occurring during message transmission.
        constexpr uint32_t STFERR = (1U << 10);  ///< This bit indicates that a Stuffing Error has been detected.
        constexpr uint32_t FRMERR = (1U << 11);  ///< This bit indicates that a Form Error has been detected by the receiver node, i
        constexpr uint32_t CRCERR = (1U << 12);  ///< This bit indicates that a CRC Error has been detected by the receiver node, i
        constexpr uint32_t ACKERR = (1U << 13);  ///< This bit indicates that an Acknowledge Error has been detected by the transmitter node, i
        constexpr uint32_t BIT0ERR = (1U << 14);  ///< This bit indicates when an inconsistency occurs between the transmitted and the received bit in a message
        constexpr uint32_t BIT1ERR = (1U << 15);  ///< This bit indicates when an inconsistency occurs between the transmitted and the received bit in a message
        constexpr uint32_t RWRNINT = (1U << 16);  ///< If the WRN_EN bit in MCR is asserted, the RWRN_INT bit is set when the RX_WRN flag transition from '0' to '1', meaning that the Rx error counters reached 96
        constexpr uint32_t TWRNINT = (1U << 17);  ///< If the WRN_EN bit in MCR is asserted, the TWRN_INT bit is set when the TX_WRN flag transition from '0' to '1', meaning that the Tx error counter reached 96
        constexpr uint32_t SYNCH = (1U << 18);  ///< This read-only flag indicates whether the FlexCAN is synchronized to the CAN bus and able to participate in the communication process
    }

    /// IMASK2 Register bits
    namespace imask2_bits {
        constexpr uint32_t BUFHM = (32 << 0);  ///< Each bit enables or disables the respective FLEXCAN Message Buffer (MB32 to MB63) Interrupt
    }

    /// IMASK1 Register bits
    namespace imask1_bits {
        constexpr uint32_t BUFLM = (32 << 0);  ///< Each bit enables or disables the respective FLEXCAN Message Buffer (MB0 to MB31) Interrupt
    }

    /// IFLAG2 Register bits
    namespace iflag2_bits {
        constexpr uint32_t BUFHI = (32 << 0);  ///< Each bit flags the respective FLEXCAN Message Buffer (MB32 to MB63) interrupt.
    }

    /// IFLAG1 Register bits
    namespace iflag1_bits {
        constexpr uint32_t BUF4TO0I = (5 << 0);  ///< If the Rx FIFO is not enabled, these bits flag the interrupts for MB0 to MB4
        constexpr uint32_t BUF5I = (1U << 5);  ///< If the Rx FIFO is not enabled, this bit flags the interrupt for MB5
        constexpr uint32_t BUF6I = (1U << 6);  ///< If the Rx FIFO is not enabled, this bit flags the interrupt for MB6
        constexpr uint32_t BUF7I = (1U << 7);  ///< If the Rx FIFO is not enabled, this bit flags the interrupt for MB7
        constexpr uint32_t BUF31TO8I = (24 << 8);  ///< Each bit flags the respective FLEXCAN Message Buffer (MB8 to MB31) interrupt.
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t EACEN = (1U << 16);  ///< This bit controls the comparison of IDE and RTR bits within Rx Mailboxes filters with their corresponding bits in the incoming frame by the matching process
        constexpr uint32_t RRS = (1U << 17);  ///< If this bit is asserted Remote Request Frame is submitted to a matching process and stored in the corresponding Message Buffer in the same fashion of a Data Frame
        constexpr uint32_t MRP = (1U << 18);  ///< If this bit is set the matching process starts from the Mailboxes and if no match occurs the matching continues on the Rx FIFO
        constexpr uint32_t TASD = (5 << 19);  ///< This 5-bit field indicates how many CAN bits the Tx arbitration process start point can be delayed from the first bit of CRC field on CAN bus
        constexpr uint32_t RFFN = (4 << 24);  ///< This 4-bit field defines the number of Rx FIFO filters according to
        constexpr uint32_t WRMFRZ = (1U << 28);  ///< Enable unrestricted write access to FlexCAN memory in Freeze mode
    }

    /// ESR2 Register bits
    namespace esr2_bits {
        constexpr uint32_t IMB = (1U << 13);  ///< If ESR2[VPS] is asserted, this bit indicates whether there is any inactive Mailbox (CODE field is either 0b1000 or 0b0000)
        constexpr uint32_t VPS = (1U << 14);  ///< This bit indicates whether IMB and LPTM contents are currently valid or not
        constexpr uint32_t LPTM = (7 << 16);  ///< If ESR2[VPS] is asserted, his 7-bit field indicates the lowest number inactive Mailbox (refer to IMB bit description)
    }

    /// CRCR Register bits
    namespace crcr_bits {
        constexpr uint32_t TXCRC = (15 << 0);  ///< This field indicates the CRC value of the last message transmitted
        constexpr uint32_t MBCRC = (7 << 16);  ///< This field indicates the number of the Mailbox corresponding to the value in TXCRC field.
    }

    /// RXFGMASK Register bits
    namespace rxfgmask_bits {
        constexpr uint32_t FGM = (32 << 0);  ///< These bits mask the ID Filter Table elements bits in a perfect alignment
    }

    /// RXFIR Register bits
    namespace rxfir_bits {
        constexpr uint32_t IDHIT = (9 << 0);  ///< This 9-bit field indicates which Identifier Acceptance Filter (see Rx FIFO Structure) was hit by the received message that is in the output of the Rx FIFO
    }

    /// DBG1 Register bits
    namespace dbg1_bits {
        constexpr uint32_t CFSM = (6 << 0);  ///< CAN Finite State Machine
        constexpr uint32_t CBN = (5 << 24);  ///< CAN Bit Number
    }

    /// DBG2 Register bits
    namespace dbg2_bits {
        constexpr uint32_t RMP = (7 << 0);  ///< Rx Matching Pointer
        constexpr uint32_t MPP = (1U << 7);  ///< Matching Process in Progress
        constexpr uint32_t TAP = (7 << 8);  ///< Tx Arbitration Pointer
        constexpr uint32_t APP = (1U << 15);  ///< Arbitration Process in Progress
    }

    /// RXIMR%s Register bits
    namespace rximr%s_bits {
        constexpr uint32_t MI = (32 << 0);  ///< These bits mask both Mailbox filter and Rx FIFO ID Filter Table element in distinct ways
    }

    /// GFWR Register bits
    namespace gfwr_bits {
        constexpr uint32_t GFWR = (8 << 0);  ///< It determines the Glitch Filter Width
    }

}

// ============================================================================
// TMR1 Peripheral
// ============================================================================

namespace tmr1 {
    /// Base addresses
    constexpr uint32_t TMR1_BASE = 0x401DC000;

    /// TMR1 Register structure
    struct Registers {
        volatile uint32_t COMP1%s;  ///< Offset: 0x00 - Timer Channel Compare Register 1
        volatile uint32_t COMP2%s;  ///< Offset: 0x02 - Timer Channel Compare Register 2
        volatile uint32_t CAPT%s;  ///< Offset: 0x04 - Timer Channel Capture Register
        volatile uint32_t LOAD%s;  ///< Offset: 0x06 - Timer Channel Load Register
        volatile uint32_t HOLD%s;  ///< Offset: 0x08 - Timer Channel Hold Register
        volatile uint32_t CNTR%s;  ///< Offset: 0x0A - Timer Channel Counter Register
        volatile uint32_t CTRL%s;  ///< Offset: 0x0C - Timer Channel Control Register
        volatile uint32_t SCTRL%s;  ///< Offset: 0x0E - Timer Channel Status and Control Register
        volatile uint32_t CMPLD1%s;  ///< Offset: 0x10 - Timer Channel Comparator Load Register 1
        volatile uint32_t CMPLD2%s;  ///< Offset: 0x12 - Timer Channel Comparator Load Register 2
        volatile uint32_t CSCTRL%s;  ///< Offset: 0x14 - Timer Channel Comparator Status and Control Register
        volatile uint32_t FILT%s;  ///< Offset: 0x16 - Timer Channel Input Filter Register
        volatile uint32_t DMA%s;  ///< Offset: 0x18 - Timer Channel DMA Enable Register
        volatile uint32_t ENBL;  ///< Offset: 0x1E - Timer Channel Enable Register
    };

    /// Peripheral instances
    inline Registers* TMR1 = reinterpret_cast<Registers*>(TMR1_BASE);

    // Bit definitions
    /// COMP1%s Register bits
    namespace comp1%s_bits {
        constexpr uint32_t COMPARISON_1 = (16 << 0);  ///< Comparison Value 1
    }

    /// COMP2%s Register bits
    namespace comp2%s_bits {
        constexpr uint32_t COMPARISON_2 = (16 << 0);  ///< Comparison Value 2
    }

    /// CAPT%s Register bits
    namespace capt%s_bits {
        constexpr uint32_t CAPTURE = (16 << 0);  ///< Capture Value
    }

    /// LOAD%s Register bits
    namespace load%s_bits {
        constexpr uint32_t LOAD = (16 << 0);  ///< Timer Load Register
    }

    /// HOLD%s Register bits
    namespace hold%s_bits {
        constexpr uint32_t HOLD = (16 << 0);  ///< This read/write register stores the counter's values of specific channels whenever any of the four counters within a module is read
    }

    /// CNTR%s Register bits
    namespace cntr%s_bits {
        constexpr uint32_t COUNTER = (16 << 0);  ///< This read/write register is the counter for the corresponding channel in a timer module.
    }

    /// CTRL%s Register bits
    namespace ctrl%s_bits {
        constexpr uint32_t OUTMODE = (3 << 0);  ///< Output Mode
        constexpr uint32_t COINIT = (1U << 3);  ///< Co-Channel Initialization
        constexpr uint32_t DIR = (1U << 4);  ///< Count Direction
        constexpr uint32_t LENGTH = (1U << 5);  ///< Count Length
        constexpr uint32_t ONCE = (1U << 6);  ///< Count Once
        constexpr uint32_t SCS = (2 << 7);  ///< Secondary Count Source
        constexpr uint32_t PCS = (4 << 9);  ///< Primary Count Source
        constexpr uint32_t CM = (3 << 13);  ///< Count Mode
    }

    /// SCTRL%s Register bits
    namespace sctrl%s_bits {
        constexpr uint32_t OEN = (1U << 0);  ///< Output Enable
        constexpr uint32_t OPS = (1U << 1);  ///< Output Polarity Select
        constexpr uint32_t FORCE = (1U << 2);  ///< Force OFLAG Output
        constexpr uint32_t VAL = (1U << 3);  ///< Forced OFLAG Value
        constexpr uint32_t EEOF = (1U << 4);  ///< Enable External OFLAG Force
        constexpr uint32_t MSTR = (1U << 5);  ///< Master Mode
        constexpr uint32_t CAPTURE_MODE = (2 << 6);  ///< Input Capture Mode
        constexpr uint32_t INPUT = (1U << 8);  ///< External Input Signal
        constexpr uint32_t IPS = (1U << 9);  ///< Input Polarity Select
        constexpr uint32_t IEFIE = (1U << 10);  ///< Input Edge Flag Interrupt Enable
        constexpr uint32_t IEF = (1U << 11);  ///< Input Edge Flag
        constexpr uint32_t TOFIE = (1U << 12);  ///< Timer Overflow Flag Interrupt Enable
        constexpr uint32_t TOF = (1U << 13);  ///< Timer Overflow Flag
        constexpr uint32_t TCFIE = (1U << 14);  ///< Timer Compare Flag Interrupt Enable
        constexpr uint32_t TCF = (1U << 15);  ///< Timer Compare Flag
    }

    /// CMPLD1%s Register bits
    namespace cmpld1%s_bits {
        constexpr uint32_t COMPARATOR_LOAD_1 = (16 << 0);  ///< This read/write register is the comparator 1 preload value for the COMP1 register for the corresponding channel in a timer module
    }

    /// CMPLD2%s Register bits
    namespace cmpld2%s_bits {
        constexpr uint32_t COMPARATOR_LOAD_2 = (16 << 0);  ///< This read/write register is the comparator 2 preload value for the COMP2 register for the corresponding channel in a timer module
    }

    /// CSCTRL%s Register bits
    namespace csctrl%s_bits {
        constexpr uint32_t CL1 = (2 << 0);  ///< Compare Load Control 1
        constexpr uint32_t CL2 = (2 << 2);  ///< Compare Load Control 2
        constexpr uint32_t TCF1 = (1U << 4);  ///< Timer Compare 1 Interrupt Flag
        constexpr uint32_t TCF2 = (1U << 5);  ///< Timer Compare 2 Interrupt Flag
        constexpr uint32_t TCF1EN = (1U << 6);  ///< Timer Compare 1 Interrupt Enable
        constexpr uint32_t TCF2EN = (1U << 7);  ///< Timer Compare 2 Interrupt Enable
        constexpr uint32_t UP = (1U << 9);  ///< Counting Direction Indicator
        constexpr uint32_t TCI = (1U << 10);  ///< Triggered Count Initialization Control
        constexpr uint32_t ROC = (1U << 11);  ///< Reload on Capture
        constexpr uint32_t ALT_LOAD = (1U << 12);  ///< Alternative Load Enable
        constexpr uint32_t FAULT = (1U << 13);  ///< Fault Enable
        constexpr uint32_t DBG_EN = (2 << 14);  ///< Debug Actions Enable
    }

    /// FILT%s Register bits
    namespace filt%s_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Input Filter Sample Period
        constexpr uint32_t FILT_CNT = (3 << 8);  ///< Input Filter Sample Count
    }

    /// DMA%s Register bits
    namespace dma%s_bits {
        constexpr uint32_t IEFDE = (1U << 0);  ///< Input Edge Flag DMA Enable
        constexpr uint32_t CMPLD1DE = (1U << 1);  ///< Comparator Preload Register 1 DMA Enable
        constexpr uint32_t CMPLD2DE = (1U << 2);  ///< Comparator Preload Register 2 DMA Enable
    }

    /// ENBL Register bits
    namespace enbl_bits {
        constexpr uint32_t ENBL = (4 << 0);  ///< Timer Channel Enable
    }

}

// ============================================================================
// TMR2 Peripheral
// ============================================================================

namespace tmr2 {
    /// Base addresses
    constexpr uint32_t TMR2_BASE = 0x401E0000;

    /// TMR2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* TMR2 = reinterpret_cast<Registers*>(TMR2_BASE);

}

// ============================================================================
// TMR3 Peripheral
// ============================================================================

namespace tmr3 {
    /// Base addresses
    constexpr uint32_t TMR3_BASE = 0x401E4000;

    /// TMR3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* TMR3 = reinterpret_cast<Registers*>(TMR3_BASE);

}

// ============================================================================
// TMR4 Peripheral
// ============================================================================

namespace tmr4 {
    /// Base addresses
    constexpr uint32_t TMR4_BASE = 0x401E8000;

    /// TMR4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* TMR4 = reinterpret_cast<Registers*>(TMR4_BASE);

}

// ============================================================================
// GPT1 Peripheral
// ============================================================================

namespace gpt1 {
    /// Base addresses
    constexpr uint32_t GPT1_BASE = 0x401EC000;

    /// GPT1 Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - GPT Control Register
        volatile uint32_t PR;  ///< Offset: 0x04 - GPT Prescaler Register
        volatile uint32_t SR;  ///< Offset: 0x08 - GPT Status Register
        volatile uint32_t IR;  ///< Offset: 0x0C - GPT Interrupt Register
        volatile uint32_t OCR1;  ///< Offset: 0x10 - GPT Output Compare Register 1
        volatile uint32_t OCR2;  ///< Offset: 0x14 - GPT Output Compare Register 2
        volatile uint32_t OCR3;  ///< Offset: 0x18 - GPT Output Compare Register 3
        volatile uint32_t ICR1;  ///< Offset: 0x1C - GPT Input Capture Register 1
        volatile uint32_t ICR2;  ///< Offset: 0x20 - GPT Input Capture Register 2
        volatile uint32_t CNT;  ///< Offset: 0x24 - GPT Counter Register
    };

    /// Peripheral instances
    inline Registers* GPT1 = reinterpret_cast<Registers*>(GPT1_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< GPT Enable
        constexpr uint32_t ENMOD = (1U << 1);  ///< GPT Enable mode
        constexpr uint32_t DBGEN = (1U << 2);  ///< GPT debug mode enable
        constexpr uint32_t WAITEN = (1U << 3);  ///< GPT Wait Mode enable
        constexpr uint32_t DOZEEN = (1U << 4);  ///< GPT Doze Mode Enable
        constexpr uint32_t STOPEN = (1U << 5);  ///< GPT Stop Mode enable
        constexpr uint32_t CLKSRC = (3 << 6);  ///< Clock Source select
        constexpr uint32_t FRR = (1U << 9);  ///< Free-Run or Restart mode
        constexpr uint32_t EN_24M = (1U << 10);  ///< Enable 24 MHz clock input from crystal
        constexpr uint32_t SWR = (1U << 15);  ///< Software reset
        constexpr uint32_t IM1 = (2 << 16);  ///< See IM2
        constexpr uint32_t IM2 = (2 << 18);  ///< IM2 (bits 19-18, Input Capture Channel 2 operating mode) IM1 (bits 17-16, Input Capture Channel 1 operating mode) The IMn bit field determines the transition on the input pin (for Input capture channel n), which will trigger a capture event
        constexpr uint32_t OM1 = (3 << 20);  ///< See OM3
        constexpr uint32_t OM2 = (3 << 23);  ///< See OM3
        constexpr uint32_t OM3 = (3 << 26);  ///< OM3 (bits 28-26) controls the Output Compare Channel 3 operating mode
        constexpr uint32_t FO1 = (1U << 29);  ///< See F03
        constexpr uint32_t FO2 = (1U << 30);  ///< See F03
        constexpr uint32_t FO3 = (1U << 31);  ///< FO3 Force Output Compare Channel 3 FO2 Force Output Compare Channel 2 FO1 Force Output Compare Channel 1 The FOn bit causes the pin action programmed for the timer Output Compare n pin (according to the OMn bits in this register)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PRESCALER = (12 << 0);  ///< Prescaler bits
        constexpr uint32_t PRESCALER24M = (4 << 12);  ///< Prescaler bits
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t OF1 = (1U << 0);  ///< See OF3
        constexpr uint32_t OF2 = (1U << 1);  ///< See OF3
        constexpr uint32_t OF3 = (1U << 2);  ///< OF3 Output Compare 3 Flag OF2 Output Compare 2 Flag OF1 Output Compare 1 Flag The OFn bit indicates that a compare event has occurred on Output Compare channel n
        constexpr uint32_t IF1 = (1U << 3);  ///< See IF2
        constexpr uint32_t IF2 = (1U << 4);  ///< IF2 Input capture 2 Flag IF1 Input capture 1 Flag The IFn bit indicates that a capture event has occurred on Input Capture channel n
        constexpr uint32_t ROV = (1U << 5);  ///< Rollover Flag
    }

    /// IR Register bits
    namespace ir_bits {
        constexpr uint32_t OF1IE = (1U << 0);  ///< See OF3IE
        constexpr uint32_t OF2IE = (1U << 1);  ///< See OF3IE
        constexpr uint32_t OF3IE = (1U << 2);  ///< OF3IE Output Compare 3 Interrupt Enable OF2IE Output Compare 2 Interrupt Enable OF1IE Output Compare 1 Interrupt Enable The OFnIE bit controls the Output Compare Channel n interrupt
        constexpr uint32_t IF1IE = (1U << 3);  ///< See IF2IE
        constexpr uint32_t IF2IE = (1U << 4);  ///< IF2IE Input capture 2 Interrupt Enable IF1IE Input capture 1 Interrupt Enable The IFnIE bit controls the IFnIE Input Capture n Interrupt Enable
        constexpr uint32_t ROVIE = (1U << 5);  ///< Rollover Interrupt Enable. The ROVIE bit controls the Rollover interrupt.
    }

    /// OCR1 Register bits
    namespace ocr1_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Compare Value
    }

    /// OCR2 Register bits
    namespace ocr2_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Compare Value
    }

    /// OCR3 Register bits
    namespace ocr3_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Compare Value
    }

    /// ICR1 Register bits
    namespace icr1_bits {
        constexpr uint32_t CAPT = (32 << 0);  ///< Capture Value
    }

    /// ICR2 Register bits
    namespace icr2_bits {
        constexpr uint32_t CAPT = (32 << 0);  ///< Capture Value
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< Counter Value. The COUNT bits show the current count value of the GPT counter.
    }

}

// ============================================================================
// GPT2 Peripheral
// ============================================================================

namespace gpt2 {
    /// Base addresses
    constexpr uint32_t GPT2_BASE = 0x401F0000;

    /// GPT2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT2 = reinterpret_cast<Registers*>(GPT2_BASE);

}

// ============================================================================
// OCOTP Peripheral
// ============================================================================

namespace ocotp {
    /// Base addresses
    constexpr uint32_t OCOTP_BASE = 0x401F4000;

    /// OCOTP Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - OTP Controller Control Register
        volatile uint32_t CTRL_SET;  ///< Offset: 0x04 - OTP Controller Control Register
        volatile uint32_t CTRL_CLR;  ///< Offset: 0x08 - OTP Controller Control Register
        volatile uint32_t CTRL_TOG;  ///< Offset: 0x0C - OTP Controller Control Register
        volatile uint32_t TIMING;  ///< Offset: 0x10 - OTP Controller Timing Register
        volatile uint32_t DATA;  ///< Offset: 0x20 - OTP Controller Write Data Register
        volatile uint32_t READ_CTRL;  ///< Offset: 0x30 - OTP Controller Write Data Register
        volatile uint32_t READ_FUSE_DATA;  ///< Offset: 0x40 - OTP Controller Read Data Register
        volatile uint32_t SW_STICKY;  ///< Offset: 0x50 - Sticky bit Register
        volatile uint32_t SCS;  ///< Offset: 0x60 - Software Controllable Signals Register
        volatile uint32_t SCS_SET;  ///< Offset: 0x64 - Software Controllable Signals Register
        volatile uint32_t SCS_CLR;  ///< Offset: 0x68 - Software Controllable Signals Register
        volatile uint32_t SCS_TOG;  ///< Offset: 0x6C - Software Controllable Signals Register
        volatile uint32_t CRC_ADDR;  ///< Offset: 0x70 - OTP Controller CRC test address
        volatile uint32_t CRC_VALUE;  ///< Offset: 0x80 - OTP Controller CRC Value Register
        volatile uint32_t VERSION;  ///< Offset: 0x90 - OTP Controller Version Register
        volatile uint32_t TIMING2;  ///< Offset: 0x100 - OTP Controller Timing Register
        volatile uint32_t LOCK;  ///< Offset: 0x400 - Value of OTP Bank0 Word0 (Lock controls)
        volatile uint32_t CFG0;  ///< Offset: 0x410 - Value of OTP Bank0 Word1 (Configuration and Manufacturing Info.)
        volatile uint32_t CFG1;  ///< Offset: 0x420 - Value of OTP Bank0 Word2 (Configuration and Manufacturing Info.)
        volatile uint32_t CFG2;  ///< Offset: 0x430 - Value of OTP Bank0 Word3 (Configuration and Manufacturing Info.)
        volatile uint32_t CFG3;  ///< Offset: 0x440 - Value of OTP Bank0 Word4 (Configuration and Manufacturing Info.)
        volatile uint32_t CFG4;  ///< Offset: 0x450 - Value of OTP Bank0 Word5 (Configuration and Manufacturing Info.)
        volatile uint32_t CFG5;  ///< Offset: 0x460 - Value of OTP Bank0 Word6 (Configuration and Manufacturing Info.)
        volatile uint32_t CFG6;  ///< Offset: 0x470 - Value of OTP Bank0 Word7 (Configuration and Manufacturing Info.)
        volatile uint32_t MEM0;  ///< Offset: 0x480 - Value of OTP Bank1 Word0 (Memory Related Info.)
        volatile uint32_t MEM1;  ///< Offset: 0x490 - Value of OTP Bank1 Word1 (Memory Related Info.)
        volatile uint32_t MEM2;  ///< Offset: 0x4A0 - Value of OTP Bank1 Word2 (Memory Related Info.)
        volatile uint32_t MEM3;  ///< Offset: 0x4B0 - Value of OTP Bank1 Word3 (Memory Related Info.)
        volatile uint32_t MEM4;  ///< Offset: 0x4C0 - Value of OTP Bank1 Word4 (Memory Related Info.)
        volatile uint32_t ANA0;  ///< Offset: 0x4D0 - Value of OTP Bank1 Word5 (Memory Related Info.)
        volatile uint32_t ANA1;  ///< Offset: 0x4E0 - Value of OTP Bank1 Word6 (General Purpose Customer Defined Info.)
        volatile uint32_t ANA2;  ///< Offset: 0x4F0 - Value of OTP Bank1 Word7 (General Purpose Customer Defined Info.)
        volatile uint32_t OTPMK0;  ///< Offset: 0x500 - Value of OTP Bank2 Word0 (OTPMK Key)
        volatile uint32_t OTPMK1;  ///< Offset: 0x510 - Value of OTP Bank2 Word1 (OTPMK Key)
        volatile uint32_t OTPMK2;  ///< Offset: 0x520 - Value of OTP Bank2 Word2 (OTPMK Key)
        volatile uint32_t OTPMK3;  ///< Offset: 0x530 - Value of OTP Bank2 Word3 (OTPMK Key)
        volatile uint32_t OTPMK4;  ///< Offset: 0x540 - Value of OTP Bank2 Word4 (OTPMK Key)
        volatile uint32_t OTPMK5;  ///< Offset: 0x550 - Value of OTP Bank2 Word5 (OTPMK Key)
        volatile uint32_t OTPMK6;  ///< Offset: 0x560 - Value of OTP Bank2 Word6 (OTPMK Key)
        volatile uint32_t OTPMK7;  ///< Offset: 0x570 - Value of OTP Bank2 Word7 (OTPMK Key)
        volatile uint32_t SRK0;  ///< Offset: 0x580 - Shadow Register for OTP Bank3 Word0 (SRK Hash)
        volatile uint32_t SRK1;  ///< Offset: 0x590 - Shadow Register for OTP Bank3 Word1 (SRK Hash)
        volatile uint32_t SRK2;  ///< Offset: 0x5A0 - Shadow Register for OTP Bank3 Word2 (SRK Hash)
        volatile uint32_t SRK3;  ///< Offset: 0x5B0 - Shadow Register for OTP Bank3 Word3 (SRK Hash)
        volatile uint32_t SRK4;  ///< Offset: 0x5C0 - Shadow Register for OTP Bank3 Word4 (SRK Hash)
        volatile uint32_t SRK5;  ///< Offset: 0x5D0 - Shadow Register for OTP Bank3 Word5 (SRK Hash)
        volatile uint32_t SRK6;  ///< Offset: 0x5E0 - Shadow Register for OTP Bank3 Word6 (SRK Hash)
        volatile uint32_t SRK7;  ///< Offset: 0x5F0 - Shadow Register for OTP Bank3 Word7 (SRK Hash)
        volatile uint32_t SJC_RESP0;  ///< Offset: 0x600 - Value of OTP Bank4 Word0 (Secure JTAG Response Field)
        volatile uint32_t SJC_RESP1;  ///< Offset: 0x610 - Value of OTP Bank4 Word1 (Secure JTAG Response Field)
        volatile uint32_t MAC0;  ///< Offset: 0x620 - Value of OTP Bank4 Word2 (MAC Address)
        volatile uint32_t MAC1;  ///< Offset: 0x630 - Value of OTP Bank4 Word3 (MAC Address)
        volatile uint32_t MAC2;  ///< Offset: 0x640 - Value of OTP Bank4 Word4 (MAC2 Address)
        volatile uint32_t OTPMK_CRC32;  ///< Offset: 0x650 - Value of OTP Bank4 Word5 (CRC Key)
        volatile uint32_t GP1;  ///< Offset: 0x660 - Value of OTP Bank4 Word6 (General Purpose Customer Defined Info)
        volatile uint32_t GP2;  ///< Offset: 0x670 - Value of OTP Bank4 Word7 (General Purpose Customer Defined Info)
        volatile uint32_t SW_GP1;  ///< Offset: 0x680 - Value of OTP Bank5 Word0 (SW GP1)
        volatile uint32_t SW_GP20;  ///< Offset: 0x690 - Value of OTP Bank5 Word1 (SW GP2)
        volatile uint32_t SW_GP21;  ///< Offset: 0x6A0 - Value of OTP Bank5 Word2 (SW GP2)
        volatile uint32_t SW_GP22;  ///< Offset: 0x6B0 - Value of OTP Bank5 Word3 (SW GP2)
        volatile uint32_t SW_GP23;  ///< Offset: 0x6C0 - Value of OTP Bank5 Word4 (SW GP2)
        volatile uint32_t MISC_CONF0;  ///< Offset: 0x6D0 - Value of OTP Bank5 Word5 (Misc Conf)
        volatile uint32_t MISC_CONF1;  ///< Offset: 0x6E0 - Value of OTP Bank5 Word6 (Misc Conf)
        volatile uint32_t SRK_REVOKE;  ///< Offset: 0x6F0 - Value of OTP Bank5 Word7 (SRK Revoke)
        volatile uint32_t ROM_PATCH0;  ///< Offset: 0x800 - Value of OTP Bank6 Word0 (ROM Patch)
        volatile uint32_t ROM_PATCH1;  ///< Offset: 0x810 - Value of OTP Bank6 Word1 (ROM Patch)
        volatile uint32_t ROM_PATCH2;  ///< Offset: 0x820 - Value of OTP Bank6 Word2 (ROM Patch)
        volatile uint32_t ROM_PATCH3;  ///< Offset: 0x830 - Value of OTP Bank6 Word3 (ROM Patch)
        volatile uint32_t ROM_PATCH4;  ///< Offset: 0x840 - Value of OTP Bank6 Word4 (ROM Patch)
        volatile uint32_t ROM_PATCH5;  ///< Offset: 0x850 - Value of OTP Bank6 Word5 (ROM Patch)
        volatile uint32_t ROM_PATCH6;  ///< Offset: 0x860 - Value of OTP Bank6 Word6 (ROM Patch)
        volatile uint32_t ROM_PATCH7;  ///< Offset: 0x870 - Value of OTP Bank6 Word7 (ROM Patch)
        volatile uint32_t GP30;  ///< Offset: 0x880 - Value of OTP Bank7 Word0 (GP3)
        volatile uint32_t GP31;  ///< Offset: 0x890 - Value of OTP Bank7 Word1 (GP3)
        volatile uint32_t GP32;  ///< Offset: 0x8A0 - Value of OTP Bank7 Word2 (GP3)
        volatile uint32_t GP33;  ///< Offset: 0x8B0 - Value of OTP Bank7 Word3 (GP3)
        volatile uint32_t GP40;  ///< Offset: 0x8C0 - Value of OTP Bank7 Word4 (GP4)
        volatile uint32_t GP41;  ///< Offset: 0x8D0 - Value of OTP Bank7 Word5 (GP4)
        volatile uint32_t GP42;  ///< Offset: 0x8E0 - Value of OTP Bank7 Word6 (GP4)
        volatile uint32_t GP43;  ///< Offset: 0x8F0 - Value of OTP Bank7 Word7 (GP4)
    };

    /// Peripheral instances
    inline Registers* OCOTP = reinterpret_cast<Registers*>(OCOTP_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t ADDR = (6 << 0);  ///< ADDR
        constexpr uint32_t RSVD0 = (2 << 6);  ///< RSVD0
        constexpr uint32_t BUSY = (1U << 8);  ///< BUSY
        constexpr uint32_t ERROR = (1U << 9);  ///< ERROR
        constexpr uint32_t RELOAD_SHADOWS = (1U << 10);  ///< RELOAD_SHADOWS
        constexpr uint32_t CRC_TEST = (1U << 11);  ///< CRC_TEST
        constexpr uint32_t CRC_FAIL = (1U << 12);  ///< CRC_FAIL
        constexpr uint32_t RSVD1 = (3 << 13);  ///< RSVD1
        constexpr uint32_t WR_UNLOCK = (16 << 16);  ///< WR_UNLOCK
    }

    /// CTRL_SET Register bits
    namespace ctrl_set_bits {
        constexpr uint32_t ADDR = (6 << 0);  ///< ADDR
        constexpr uint32_t RSVD0 = (2 << 6);  ///< RSVD0
        constexpr uint32_t BUSY = (1U << 8);  ///< BUSY
        constexpr uint32_t ERROR = (1U << 9);  ///< ERROR
        constexpr uint32_t RELOAD_SHADOWS = (1U << 10);  ///< RELOAD_SHADOWS
        constexpr uint32_t CRC_TEST = (1U << 11);  ///< CRC_TEST
        constexpr uint32_t CRC_FAIL = (1U << 12);  ///< CRC_FAIL
        constexpr uint32_t RSVD1 = (3 << 13);  ///< RSVD1
        constexpr uint32_t WR_UNLOCK = (16 << 16);  ///< WR_UNLOCK
    }

    /// CTRL_CLR Register bits
    namespace ctrl_clr_bits {
        constexpr uint32_t ADDR = (6 << 0);  ///< ADDR
        constexpr uint32_t RSVD0 = (2 << 6);  ///< RSVD0
        constexpr uint32_t BUSY = (1U << 8);  ///< BUSY
        constexpr uint32_t ERROR = (1U << 9);  ///< ERROR
        constexpr uint32_t RELOAD_SHADOWS = (1U << 10);  ///< RELOAD_SHADOWS
        constexpr uint32_t CRC_TEST = (1U << 11);  ///< CRC_TEST
        constexpr uint32_t CRC_FAIL = (1U << 12);  ///< CRC_FAIL
        constexpr uint32_t RSVD1 = (3 << 13);  ///< RSVD1
        constexpr uint32_t WR_UNLOCK = (16 << 16);  ///< WR_UNLOCK
    }

    /// CTRL_TOG Register bits
    namespace ctrl_tog_bits {
        constexpr uint32_t ADDR = (6 << 0);  ///< ADDR
        constexpr uint32_t RSVD0 = (2 << 6);  ///< RSVD0
        constexpr uint32_t BUSY = (1U << 8);  ///< BUSY
        constexpr uint32_t ERROR = (1U << 9);  ///< ERROR
        constexpr uint32_t RELOAD_SHADOWS = (1U << 10);  ///< RELOAD_SHADOWS
        constexpr uint32_t CRC_TEST = (1U << 11);  ///< CRC_TEST
        constexpr uint32_t CRC_FAIL = (1U << 12);  ///< CRC_FAIL
        constexpr uint32_t RSVD1 = (3 << 13);  ///< RSVD1
        constexpr uint32_t WR_UNLOCK = (16 << 16);  ///< WR_UNLOCK
    }

    /// TIMING Register bits
    namespace timing_bits {
        constexpr uint32_t STROBE_PROG = (12 << 0);  ///< STROBE_PROG
        constexpr uint32_t RELAX = (4 << 12);  ///< RELAX
        constexpr uint32_t STROBE_READ = (6 << 16);  ///< STROBE_READ
        constexpr uint32_t WAIT = (6 << 22);  ///< WAIT
        constexpr uint32_t RSRVD0 = (4 << 28);  ///< RSRVD0
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< DATA
    }

    /// READ_CTRL Register bits
    namespace read_ctrl_bits {
        constexpr uint32_t READ_FUSE = (1U << 0);  ///< READ_FUSE
        constexpr uint32_t RSVD0 = (31 << 1);  ///< RSVD0
    }

    /// READ_FUSE_DATA Register bits
    namespace read_fuse_data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< DATA
    }

    /// SW_STICKY Register bits
    namespace sw_sticky_bits {
        constexpr uint32_t BLOCK_DTCP_KEY = (1U << 0);  ///< BLOCK_DTCP_KEY
        constexpr uint32_t SRK_REVOKE_LOCK = (1U << 1);  ///< SRK_REVOKE_LOCK
        constexpr uint32_t FIELD_RETURN_LOCK = (1U << 2);  ///< FIELD_RETURN_LOCK
        constexpr uint32_t BLOCK_ROM_PART = (1U << 3);  ///< BLOCK_ROM_PART
        constexpr uint32_t JTAG_BLOCK_RELEASE = (1U << 4);  ///< JTAG_BLOCK_RELEASE
        constexpr uint32_t RSVD0 = (27 << 5);  ///< RSVD0
    }

    /// SCS Register bits
    namespace scs_bits {
        constexpr uint32_t HAB_JDE = (1U << 0);  ///< HAB_JDE
        constexpr uint32_t SPARE = (30 << 1);  ///< SPARE
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

    /// SCS_SET Register bits
    namespace scs_set_bits {
        constexpr uint32_t HAB_JDE = (1U << 0);  ///< HAB_JDE
        constexpr uint32_t SPARE = (30 << 1);  ///< SPARE
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

    /// SCS_CLR Register bits
    namespace scs_clr_bits {
        constexpr uint32_t HAB_JDE = (1U << 0);  ///< HAB_JDE
        constexpr uint32_t SPARE = (30 << 1);  ///< SPARE
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

    /// SCS_TOG Register bits
    namespace scs_tog_bits {
        constexpr uint32_t HAB_JDE = (1U << 0);  ///< HAB_JDE
        constexpr uint32_t SPARE = (30 << 1);  ///< SPARE
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

    /// CRC_ADDR Register bits
    namespace crc_addr_bits {
        constexpr uint32_t DATA_START_ADDR = (8 << 0);  ///< DATA_START_ADDR
        constexpr uint32_t DATA_END_ADDR = (8 << 8);  ///< DATA_END_ADDR
        constexpr uint32_t CRC_ADDR = (8 << 16);  ///< CRC_ADDR
        constexpr uint32_t OTPMK_CRC = (1U << 24);  ///< OTPMK_CRC
        constexpr uint32_t RSVD0 = (7 << 25);  ///< RSVD0
    }

    /// CRC_VALUE Register bits
    namespace crc_value_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< DATA
    }

    /// VERSION Register bits
    namespace version_bits {
        constexpr uint32_t STEP = (16 << 0);  ///< STEP
        constexpr uint32_t MINOR = (8 << 16);  ///< MINOR
        constexpr uint32_t MAJOR = (8 << 24);  ///< MAJOR
    }

    /// TIMING2 Register bits
    namespace timing2_bits {
        constexpr uint32_t RELAX_PROG = (12 << 0);  ///< RELAX_PROG
        constexpr uint32_t RSRVD0 = (4 << 12);  ///< RSRVD0
        constexpr uint32_t RELAX_READ = (6 << 16);  ///< RELAX_READ
        constexpr uint32_t RSRVD1 = (10 << 22);  ///< RSRVD0
    }

    /// LOCK Register bits
    namespace lock_bits {
        constexpr uint32_t TESTER = (2 << 0);  ///< TESTER
        constexpr uint32_t BOOT_CFG = (2 << 2);  ///< BOOT_CFG
        constexpr uint32_t MEM_TRIM = (2 << 4);  ///< MEM_TRIM
        constexpr uint32_t SJC_RESP = (1U << 6);  ///< SJC_RESP
        constexpr uint32_t GP4_RLOCK = (1U << 7);  ///< GP4_RLOCK
        constexpr uint32_t MAC_ADDR = (2 << 8);  ///< MAC_ADDR
        constexpr uint32_t GP1 = (2 << 10);  ///< GP1
        constexpr uint32_t GP2 = (2 << 12);  ///< GP2
        constexpr uint32_t ROM_PATCH = (1U << 15);  ///< ROM_PATCH
        constexpr uint32_t SW_GP1 = (1U << 16);  ///< SW_GP1
        constexpr uint32_t OTPMK = (1U << 17);  ///< OTPMK
        constexpr uint32_t ANALOG = (2 << 18);  ///< ANALOG
        constexpr uint32_t OTPMK_CRC = (1U << 20);  ///< OTPMK_CRC
        constexpr uint32_t SW_GP2_LOCK = (1U << 21);  ///< SW_GP2_LOCK
        constexpr uint32_t MISC_CONF = (1U << 22);  ///< MISC_CONF
        constexpr uint32_t SW_GP2_RLOCK = (1U << 23);  ///< SW_GP2_RLOCK
        constexpr uint32_t GP4 = (2 << 24);  ///< GP4
        constexpr uint32_t GP3 = (2 << 26);  ///< GP3
        constexpr uint32_t FIELD_RETURN = (4 << 28);  ///< FIELD_RETURN
    }

    /// CFG0 Register bits
    namespace cfg0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// CFG3 Register bits
    namespace cfg3_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// CFG4 Register bits
    namespace cfg4_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// CFG5 Register bits
    namespace cfg5_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// CFG6 Register bits
    namespace cfg6_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// MEM0 Register bits
    namespace mem0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// MEM1 Register bits
    namespace mem1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// MEM2 Register bits
    namespace mem2_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// MEM3 Register bits
    namespace mem3_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// MEM4 Register bits
    namespace mem4_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// ANA0 Register bits
    namespace ana0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// ANA1 Register bits
    namespace ana1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// ANA2 Register bits
    namespace ana2_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// OTPMK0 Register bits
    namespace otpmk0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// OTPMK1 Register bits
    namespace otpmk1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// OTPMK2 Register bits
    namespace otpmk2_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// OTPMK3 Register bits
    namespace otpmk3_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// OTPMK4 Register bits
    namespace otpmk4_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// OTPMK5 Register bits
    namespace otpmk5_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// OTPMK6 Register bits
    namespace otpmk6_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// OTPMK7 Register bits
    namespace otpmk7_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SRK0 Register bits
    namespace srk0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SRK1 Register bits
    namespace srk1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SRK2 Register bits
    namespace srk2_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SRK3 Register bits
    namespace srk3_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SRK4 Register bits
    namespace srk4_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SRK5 Register bits
    namespace srk5_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SRK6 Register bits
    namespace srk6_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SRK7 Register bits
    namespace srk7_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SJC_RESP0 Register bits
    namespace sjc_resp0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SJC_RESP1 Register bits
    namespace sjc_resp1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// MAC0 Register bits
    namespace mac0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// MAC1 Register bits
    namespace mac1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// MAC2 Register bits
    namespace mac2_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// OTPMK_CRC32 Register bits
    namespace otpmk_crc32_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// GP1 Register bits
    namespace gp1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// GP2 Register bits
    namespace gp2_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SW_GP1 Register bits
    namespace sw_gp1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SW_GP20 Register bits
    namespace sw_gp20_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SW_GP21 Register bits
    namespace sw_gp21_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SW_GP22 Register bits
    namespace sw_gp22_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SW_GP23 Register bits
    namespace sw_gp23_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// MISC_CONF0 Register bits
    namespace misc_conf0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// MISC_CONF1 Register bits
    namespace misc_conf1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// SRK_REVOKE Register bits
    namespace srk_revoke_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// ROM_PATCH0 Register bits
    namespace rom_patch0_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// ROM_PATCH1 Register bits
    namespace rom_patch1_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// ROM_PATCH2 Register bits
    namespace rom_patch2_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// ROM_PATCH3 Register bits
    namespace rom_patch3_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// ROM_PATCH4 Register bits
    namespace rom_patch4_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// ROM_PATCH5 Register bits
    namespace rom_patch5_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// ROM_PATCH6 Register bits
    namespace rom_patch6_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// ROM_PATCH7 Register bits
    namespace rom_patch7_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// GP30 Register bits
    namespace gp30_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// GP31 Register bits
    namespace gp31_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// GP32 Register bits
    namespace gp32_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// GP33 Register bits
    namespace gp33_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// GP40 Register bits
    namespace gp40_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// GP41 Register bits
    namespace gp41_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// GP42 Register bits
    namespace gp42_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

    /// GP43 Register bits
    namespace gp43_bits {
        constexpr uint32_t BITS = (32 << 0);  ///< BITS
    }

}

// ============================================================================
// KPP Peripheral
// ============================================================================

namespace kpp {
    /// Base addresses
    constexpr uint32_t KPP_BASE = 0x401FC000;

    /// KPP Register structure
    struct Registers {
        volatile uint32_t KPCR;  ///< Offset: 0x00 - Keypad Control Register
        volatile uint32_t KPSR;  ///< Offset: 0x02 - Keypad Status Register
        volatile uint32_t KDDR;  ///< Offset: 0x04 - Keypad Data Direction Register
        volatile uint32_t KPDR;  ///< Offset: 0x06 - Keypad Data Register
    };

    /// Peripheral instances
    inline Registers* KPP = reinterpret_cast<Registers*>(KPP_BASE);

    // Bit definitions
    /// KPCR Register bits
    namespace kpcr_bits {
        constexpr uint32_t KRE = (8 << 0);  ///< Keypad Row Enable
        constexpr uint32_t KCO = (8 << 8);  ///< Keypad Column Strobe Open-Drain Enable
    }

    /// KPSR Register bits
    namespace kpsr_bits {
        constexpr uint32_t KPKD = (1U << 0);  ///< Keypad Key Depress
        constexpr uint32_t KPKR = (1U << 1);  ///< Keypad Key Release
        constexpr uint32_t KDSC = (1U << 2);  ///< Key Depress Synchronizer Clear
        constexpr uint32_t KRSS = (1U << 3);  ///< Key Release Synchronizer Set
        constexpr uint32_t KDIE = (1U << 8);  ///< Keypad Key Depress Interrupt Enable
        constexpr uint32_t KRIE = (1U << 9);  ///< Keypad Release Interrupt Enable
    }

    /// KDDR Register bits
    namespace kddr_bits {
        constexpr uint32_t KRDD = (8 << 0);  ///< Keypad Row Data Direction
        constexpr uint32_t KCDD = (8 << 8);  ///< Keypad Column Data Direction Register
    }

    /// KPDR Register bits
    namespace kpdr_bits {
        constexpr uint32_t KRD = (8 << 0);  ///< Keypad Row Data
        constexpr uint32_t KCD = (8 << 8);  ///< Keypad Column Data
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t FLEXSPI_BASE = 0x402A8000;
    constexpr uint32_t FLEXSPI2_BASE = 0x402A4000;
    constexpr uint32_t LPSPI1_BASE = 0x40394000;
    constexpr uint32_t LPSPI2_BASE = 0x40398000;
    constexpr uint32_t LPSPI3_BASE = 0x4039C000;
    constexpr uint32_t LPSPI4_BASE = 0x403A0000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t MCR0;  ///< Offset: 0x00 - Module Control Register 0
        volatile uint32_t MCR1;  ///< Offset: 0x04 - Module Control Register 1
        volatile uint32_t MCR2;  ///< Offset: 0x08 - Module Control Register 2
        volatile uint32_t AHBCR;  ///< Offset: 0x0C - AHB Bus Control Register
        volatile uint32_t INTEN;  ///< Offset: 0x10 - Interrupt Enable Register
        volatile uint32_t INTR;  ///< Offset: 0x14 - Interrupt Register
        volatile uint32_t LUTKEY;  ///< Offset: 0x18 - LUT Key Register
        volatile uint32_t LUTCR;  ///< Offset: 0x1C - LUT Control Register
        volatile uint32_t AHBRXBUF0CR0;  ///< Offset: 0x20 - AHB RX Buffer 0 Control Register 0
        volatile uint32_t AHBRXBUF1CR0;  ///< Offset: 0x24 - AHB RX Buffer 1 Control Register 0
        volatile uint32_t AHBRXBUF2CR0;  ///< Offset: 0x28 - AHB RX Buffer 2 Control Register 0
        volatile uint32_t AHBRXBUF3CR0;  ///< Offset: 0x2C - AHB RX Buffer 3 Control Register 0
        volatile uint32_t FLSHA1CR0;  ///< Offset: 0x60 - Flash A1 Control Register 0
        volatile uint32_t FLSHA2CR0;  ///< Offset: 0x64 - Flash A2 Control Register 0
        volatile uint32_t FLSHB1CR0;  ///< Offset: 0x68 - Flash B1 Control Register 0
        volatile uint32_t FLSHB2CR0;  ///< Offset: 0x6C - Flash B2 Control Register 0
        volatile uint32_t FLSHCR1%s;  ///< Offset: 0x70 - Flash A1 Control Register 1
        volatile uint32_t FLSHCR2%s;  ///< Offset: 0x80 - Flash A1 Control Register 2
        volatile uint32_t FLSHCR4;  ///< Offset: 0x94 - Flash Control Register 4
        volatile uint32_t IPCR0;  ///< Offset: 0xA0 - IP Control Register 0
        volatile uint32_t IPCR1;  ///< Offset: 0xA4 - IP Control Register 1
        volatile uint32_t IPCMD;  ///< Offset: 0xB0 - IP Command Register
        volatile uint32_t IPRXFCR;  ///< Offset: 0xB8 - IP RX FIFO Control Register
        volatile uint32_t IPTXFCR;  ///< Offset: 0xBC - IP TX FIFO Control Register
        volatile uint32_t DLLCR%s;  ///< Offset: 0xC0 - DLL Control Register 0
        volatile uint32_t STS0;  ///< Offset: 0xE0 - Status Register 0
        volatile uint32_t STS1;  ///< Offset: 0xE4 - Status Register 1
        volatile uint32_t STS2;  ///< Offset: 0xE8 - Status Register 2
        volatile uint32_t AHBSPNDSTS;  ///< Offset: 0xEC - AHB Suspend Status Register
        volatile uint32_t IPRXFSTS;  ///< Offset: 0xF0 - IP RX FIFO Status Register
        volatile uint32_t IPTXFSTS;  ///< Offset: 0xF4 - IP TX FIFO Status Register
        volatile uint32_t RFDR[%s];  ///< Offset: 0x100 - IP RX FIFO Data Register 0
        volatile uint32_t TFDR[%s];  ///< Offset: 0x180 - IP TX FIFO Data Register 0
        volatile uint32_t LUT[%s];  ///< Offset: 0x200 - LUT 0
    };

    /// Peripheral instances
    inline Registers* FLEXSPI = reinterpret_cast<Registers*>(FLEXSPI_BASE);
    inline Registers* FLEXSPI2 = reinterpret_cast<Registers*>(FLEXSPI2_BASE);
    inline Registers* LPSPI1 = reinterpret_cast<Registers*>(LPSPI1_BASE);
    inline Registers* LPSPI2 = reinterpret_cast<Registers*>(LPSPI2_BASE);
    inline Registers* LPSPI3 = reinterpret_cast<Registers*>(LPSPI3_BASE);
    inline Registers* LPSPI4 = reinterpret_cast<Registers*>(LPSPI4_BASE);

    // Bit definitions
    /// MCR0 Register bits
    namespace mcr0_bits {
        constexpr uint32_t SWRESET = (1U << 0);  ///< Software Reset
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable
        constexpr uint32_t RXCLKSRC = (2 << 4);  ///< Sample Clock source selection for Flash Reading
        constexpr uint32_t ARDFEN = (1U << 6);  ///< Enable AHB bus Read Access to IP RX FIFO.
        constexpr uint32_t ATDFEN = (1U << 7);  ///< Enable AHB bus Write Access to IP TX FIFO.
        constexpr uint32_t HSEN = (1U << 11);  ///< Half Speed Serial Flash access Enable.
        constexpr uint32_t DOZEEN = (1U << 12);  ///< Doze mode enable bit
        constexpr uint32_t COMBINATIONEN = (1U << 13);  ///< This bit is to support Flash Octal mode access by combining Port A and B Data pins (SIOA[3:0] and SIOB[3:0]).
        constexpr uint32_t SCKFREERUNEN = (1U << 14);  ///< This bit is used to force SCK output free-running. For FPGA applications, external device may use SCK clock as reference clock to its internal PLL. If SCK free-running is enabled, data sampling with loopback clock from SCK pad is not supported (MCR0[RXCLKSRC]=2).
        constexpr uint32_t IPGRANTWAIT = (8 << 16);  ///< Time out wait cycle for IP command grant.
        constexpr uint32_t AHBGRANTWAIT = (8 << 24);  ///< Timeout wait cycle for AHB command grant.
    }

    /// MCR1 Register bits
    namespace mcr1_bits {
        constexpr uint32_t AHBBUSWAIT = (16 << 0);  ///< AHB Read/Write access to Serial Flash Memory space will timeout if not data received from Flash or data not transmited after AHBBUSWAIT * 1024 ahb clock cycles, AHB Bus will get an error response
        constexpr uint32_t SEQWAIT = (16 << 16);  ///< Command Sequence Execution will timeout and abort after SEQWAIT * 1024 Serial Root Clock cycles
    }

    /// MCR2 Register bits
    namespace mcr2_bits {
        constexpr uint32_t CLRAHBBUFOPT = (1U << 11);  ///< This bit determines whether AHB RX Buffer and AHB TX Buffer will be cleaned automaticaly when FlexSPI returns STOP mode ACK. Software should set this bit if AHB RX Buffer or AHB TX Buffer will be powered off in STOP mode. Otherwise AHB read access after exiting STOP mode may hit AHB RX Buffer or AHB TX Buffer but their data entries are invalid.
        constexpr uint32_t CLRLEARNPHASE = (1U << 14);  ///< The sampling clock phase selection will be reset to phase 0 when this bit is written with 0x1. This bit will be auto-cleared immediately.
        constexpr uint32_t SAMEDEVICEEN = (1U << 15);  ///< All external devices are same devices (both in types and size) for A1/A2/B1/B2.
        constexpr uint32_t SCKBDIFFOPT = (1U << 19);  ///< SCKB pad can be used as SCKA differential clock output (inverted clock to SCKA). In this case, port B flash access is not available. After change the value of this feild, MCR0[SWRESET] should be set.
        constexpr uint32_t RESUMEWAIT = (8 << 24);  ///< Wait cycle (in AHB clock cycle) for idle state before suspended command sequence resumed.
    }

    /// AHBCR Register bits
    namespace ahbcr_bits {
        constexpr uint32_t APAREN = (1U << 0);  ///< Parallel mode enabled for AHB triggered Command (both read and write) .
        constexpr uint32_t CACHABLEEN = (1U << 3);  ///< Enable AHB bus cachable read access support.
        constexpr uint32_t BUFFERABLEEN = (1U << 4);  ///< Enable AHB bus bufferable write access support. This field affects the last beat of AHB write access, refer for more details about AHB bufferable write.
        constexpr uint32_t PREFETCHEN = (1U << 5);  ///< AHB Read Prefetch Enable.
        constexpr uint32_t READADDROPT = (1U << 6);  ///< AHB Read Address option bit. This option bit is intend to remove AHB burst start address alignment limitation.
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t IPCMDDONEEN = (1U << 0);  ///< IP triggered Command Sequences Execution finished interrupt enable.
        constexpr uint32_t IPCMDGEEN = (1U << 1);  ///< IP triggered Command Sequences Grant Timeout interrupt enable.
        constexpr uint32_t AHBCMDGEEN = (1U << 2);  ///< AHB triggered Command Sequences Grant Timeout interrupt enable.
        constexpr uint32_t IPCMDERREN = (1U << 3);  ///< IP triggered Command Sequences Error Detected interrupt enable.
        constexpr uint32_t AHBCMDERREN = (1U << 4);  ///< AHB triggered Command Sequences Error Detected interrupt enable.
        constexpr uint32_t IPRXWAEN = (1U << 5);  ///< IP RX FIFO WaterMark available interrupt enable.
        constexpr uint32_t IPTXWEEN = (1U << 6);  ///< IP TX FIFO WaterMark empty interrupt enable.
        constexpr uint32_t SCKSTOPBYRDEN = (1U << 8);  ///< SCK is stopped during command sequence because Async RX FIFO full interrupt enable.
        constexpr uint32_t SCKSTOPBYWREN = (1U << 9);  ///< SCK is stopped during command sequence because Async TX FIFO empty interrupt enable.
        constexpr uint32_t AHBBUSTIMEOUTEN = (1U << 10);  ///< AHB Bus timeout interrupt.Refer Interrupts chapter for more details.
        constexpr uint32_t SEQTIMEOUTEN = (1U << 11);  ///< Sequence execution timeout interrupt enable.Refer Interrupts chapter for more details.
    }

    /// INTR Register bits
    namespace intr_bits {
        constexpr uint32_t IPCMDDONE = (1U << 0);  ///< IP triggered Command Sequences Execution finished interrupt. This interrupt is also generated when there is IPCMDGE or IPCMDERR interrupt generated.
        constexpr uint32_t IPCMDGE = (1U << 1);  ///< IP triggered Command Sequences Grant Timeout interrupt.
        constexpr uint32_t AHBCMDGE = (1U << 2);  ///< AHB triggered Command Sequences Grant Timeout interrupt.
        constexpr uint32_t IPCMDERR = (1U << 3);  ///< IP triggered Command Sequences Error Detected interrupt. When an error detected for IP command, this command will be ignored and not executed at all.
        constexpr uint32_t AHBCMDERR = (1U << 4);  ///< AHB triggered Command Sequences Error Detected interrupt. When an error detected for AHB command, this command will be ignored and not executed at all.
        constexpr uint32_t IPRXWA = (1U << 5);  ///< IP RX FIFO watermark available interrupt.
        constexpr uint32_t IPTXWE = (1U << 6);  ///< IP TX FIFO watermark empty interrupt.
        constexpr uint32_t SCKSTOPBYRD = (1U << 8);  ///< SCK is stopped during command sequence because Async RX FIFO full interrupt.
        constexpr uint32_t SCKSTOPBYWR = (1U << 9);  ///< SCK is stopped during command sequence because Async TX FIFO empty interrupt.
        constexpr uint32_t AHBBUSTIMEOUT = (1U << 10);  ///< AHB Bus timeout interrupt.Refer Interrupts chapter for more details.
        constexpr uint32_t SEQTIMEOUT = (1U << 11);  ///< Sequence execution timeout interrupt.
    }

    /// LUTKEY Register bits
    namespace lutkey_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< The Key to lock or unlock LUT.
    }

    /// LUTCR Register bits
    namespace lutcr_bits {
        constexpr uint32_t LOCK = (1U << 0);  ///< Lock LUT
        constexpr uint32_t UNLOCK = (1U << 1);  ///< Unlock LUT
    }

    /// AHBRXBUF0CR0 Register bits
    namespace ahbrxbuf0cr0_bits {
        constexpr uint32_t BUFSZ = (8 << 0);  ///< AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more details.
        constexpr uint32_t MSTRID = (4 << 16);  ///< This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to for AHB RX Buffer allocation.
        constexpr uint32_t PRIORITY = (2 << 24);  ///< This priority for AHB Master Read which this AHB RX Buffer is assigned. Refer for more details.
        constexpr uint32_t PREFETCHEN = (1U << 31);  ///< AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
    }

    /// AHBRXBUF1CR0 Register bits
    namespace ahbrxbuf1cr0_bits {
        constexpr uint32_t BUFSZ = (8 << 0);  ///< AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more details.
        constexpr uint32_t MSTRID = (4 << 16);  ///< This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to for AHB RX Buffer allocation.
        constexpr uint32_t PRIORITY = (2 << 24);  ///< This priority for AHB Master Read which this AHB RX Buffer is assigned. Refer for more details.
        constexpr uint32_t PREFETCHEN = (1U << 31);  ///< AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
    }

    /// AHBRXBUF2CR0 Register bits
    namespace ahbrxbuf2cr0_bits {
        constexpr uint32_t BUFSZ = (8 << 0);  ///< AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more details.
        constexpr uint32_t MSTRID = (4 << 16);  ///< This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to for AHB RX Buffer allocation.
        constexpr uint32_t PRIORITY = (2 << 24);  ///< This priority for AHB Master Read which this AHB RX Buffer is assigned. Refer for more details.
        constexpr uint32_t PREFETCHEN = (1U << 31);  ///< AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
    }

    /// AHBRXBUF3CR0 Register bits
    namespace ahbrxbuf3cr0_bits {
        constexpr uint32_t BUFSZ = (8 << 0);  ///< AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more details.
        constexpr uint32_t MSTRID = (4 << 16);  ///< This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to for AHB RX Buffer allocation.
        constexpr uint32_t PRIORITY = (2 << 24);  ///< This priority for AHB Master Read which this AHB RX Buffer is assigned. Refer for more details.
        constexpr uint32_t PREFETCHEN = (1U << 31);  ///< AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
    }

    /// FLSHA1CR0 Register bits
    namespace flsha1cr0_bits {
        constexpr uint32_t FLSHSZ = (23 << 0);  ///< Flash Size in KByte.
    }

    /// FLSHA2CR0 Register bits
    namespace flsha2cr0_bits {
        constexpr uint32_t FLSHSZ = (23 << 0);  ///< Flash Size in KByte.
    }

    /// FLSHB1CR0 Register bits
    namespace flshb1cr0_bits {
        constexpr uint32_t FLSHSZ = (23 << 0);  ///< Flash Size in KByte.
    }

    /// FLSHB2CR0 Register bits
    namespace flshb2cr0_bits {
        constexpr uint32_t FLSHSZ = (23 << 0);  ///< Flash Size in KByte.
    }

    /// FLSHCR1%s Register bits
    namespace flshcr1%s_bits {
        constexpr uint32_t TCSS = (5 << 0);  ///< Serial Flash CS setup time.
        constexpr uint32_t TCSH = (5 << 5);  ///< Serial Flash CS Hold time.
        constexpr uint32_t WA = (1U << 10);  ///< Word Addressable.
        constexpr uint32_t CAS = (4 << 11);  ///< Column Address Size.
        constexpr uint32_t CSINTERVALUNIT = (1U << 15);  ///< CS interval unit
        constexpr uint32_t CSINTERVAL = (16 << 16);  ///< This field is used to set the minimum interval between flash device Chip selection deassertion and flash device Chip selection assertion. If external flash has a limitation on the interval between command sequences, this field should be set accordingly. If there is no limitation, set this field with value 0x0.
    }

    /// FLSHCR2%s Register bits
    namespace flshcr2%s_bits {
        constexpr uint32_t ARDSEQID = (4 << 0);  ///< Sequence Index for AHB Read triggered Command in LUT.
        constexpr uint32_t ARDSEQNUM = (3 << 5);  ///< Sequence Number for AHB Read triggered Command in LUT.
        constexpr uint32_t AWRSEQID = (4 << 8);  ///< Sequence Index for AHB Write triggered Command.
        constexpr uint32_t AWRSEQNUM = (3 << 13);  ///< Sequence Number for AHB Write triggered Command.
        constexpr uint32_t AWRWAIT = (12 << 16);  ///< For certain devices (such as FPGA), it need some time to write data into internal memory after the command sequences finished on FlexSPI interface
        constexpr uint32_t AWRWAITUNIT = (3 << 28);  ///< AWRWAIT unit
        constexpr uint32_t CLRINSTRPTR = (1U << 31);  ///< Clear the instruction pointer which is internally saved pointer by JMP_ON_CS. Refer Programmable Sequence Engine for details.
    }

    /// FLSHCR4 Register bits
    namespace flshcr4_bits {
        constexpr uint32_t WMOPT1 = (1U << 0);  ///< Write mask option bit 1. This option bit could be used to remove AHB write burst start address alignment limitation.
        constexpr uint32_t WMENA = (1U << 2);  ///< Write mask enable bit for flash device on port A. When write mask function is needed for memory device on port A, this bit must be set.
        constexpr uint32_t WMENB = (1U << 3);  ///< Write mask enable bit for flash device on port B. When write mask function is needed for memory device on port B, this bit must be set.
    }

    /// IPCR0 Register bits
    namespace ipcr0_bits {
        constexpr uint32_t SFAR = (32 << 0);  ///< Serial Flash Address for IP command.
    }

    /// IPCR1 Register bits
    namespace ipcr1_bits {
        constexpr uint32_t IDATSZ = (16 << 0);  ///< Flash Read/Program Data Size (in Bytes) for IP command.
        constexpr uint32_t ISEQID = (4 << 16);  ///< Sequence Index in LUT for IP command.
        constexpr uint32_t ISEQNUM = (3 << 24);  ///< Sequence Number for IP command: ISEQNUM+1.
        constexpr uint32_t IPAREN = (1U << 31);  ///< Parallel mode Enabled for IP command.
    }

    /// IPCMD Register bits
    namespace ipcmd_bits {
        constexpr uint32_t TRG = (1U << 0);  ///< Setting this bit will trigger an IP Command.
    }

    /// IPRXFCR Register bits
    namespace iprxfcr_bits {
        constexpr uint32_t CLRIPRXF = (1U << 0);  ///< Clear all valid data entries in IP RX FIFO.
        constexpr uint32_t RXDMAEN = (1U << 1);  ///< IP RX FIFO reading by DMA enabled.
        constexpr uint32_t RXWMRK = (4 << 2);  ///< Watermark level is (RXWMRK+1)*64 Bits.
    }

    /// IPTXFCR Register bits
    namespace iptxfcr_bits {
        constexpr uint32_t CLRIPTXF = (1U << 0);  ///< Clear all valid data entries in IP TX FIFO.
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< IP TX FIFO filling by DMA enabled.
        constexpr uint32_t TXWMRK = (4 << 2);  ///< Watermark level is (TXWMRK+1)*64 Bits.
    }

    /// DLLCR%s Register bits
    namespace dllcr%s_bits {
        constexpr uint32_t DLLEN = (1U << 0);  ///< DLL calibration enable.
        constexpr uint32_t DLLRESET = (1U << 1);  ///< Software could force a reset on DLL by setting this field to 0x1. This will cause the DLL to lose lock and re-calibrate to detect an ref_clock half period phase shift. The reset action is edge triggered, so software need to clear this bit after set this bit (no delay limitation).
        constexpr uint32_t SLVDLYTARGET = (4 << 3);  ///< The delay target for slave delay line is: ((SLVDLYTARGET+1) * 1/32 * clock cycle of reference clock (serial clock).
        constexpr uint32_t OVRDEN = (1U << 8);  ///< Slave clock delay line delay cell number selection override enable.
        constexpr uint32_t OVRDVAL = (6 << 9);  ///< Slave clock delay line delay cell number selection override value.
    }

    /// STS0 Register bits
    namespace sts0_bits {
        constexpr uint32_t SEQIDLE = (1U << 0);  ///< This status bit indicates the state machine in SEQ_CTL is idle and there is command sequence executing on FlexSPI interface.
        constexpr uint32_t ARBIDLE = (1U << 1);  ///< This status bit indicates the state machine in ARB_CTL is busy and there is command sequence granted by arbitrator and not finished yet on FlexSPI interface. When ARB_CTL state (ARBIDLE=0x1) is idle, there will be no transaction on FlexSPI interface also (SEQIDLE=0x1). So this bit should be polled to wait for FlexSPI controller become idle instead of SEQIDLE.
        constexpr uint32_t ARBCMDSRC = (2 << 2);  ///< This status field indicates the trigger source of current command sequence granted by arbitrator. This field value is meaningless when ARB_CTL is not busy (STS0[ARBIDLE]=0x1).
    }

    /// STS1 Register bits
    namespace sts1_bits {
        constexpr uint32_t AHBCMDERRID = (4 << 0);  ///< Indicates the sequence index when an AHB command error is detected. This field will be cleared when INTR[AHBCMDERR] is write-1-clear(w1c).
        constexpr uint32_t AHBCMDERRCODE = (4 << 8);  ///< Indicates the Error Code when AHB command Error detected. This field will be cleared when INTR[AHBCMDERR] is write-1-clear(w1c).
        constexpr uint32_t IPCMDERRID = (4 << 16);  ///< Indicates the sequence Index when IP command error detected. This field will be cleared when INTR[IPCMDERR] is write-1-clear(w1c).
        constexpr uint32_t IPCMDERRCODE = (4 << 24);  ///< Indicates the Error Code when IP command Error detected. This field will be cleared when INTR[IPCMDERR] is write-1-clear(w1c).
    }

    /// STS2 Register bits
    namespace sts2_bits {
        constexpr uint32_t ASLVLOCK = (1U << 0);  ///< Flash A sample clock slave delay line locked.
        constexpr uint32_t AREFLOCK = (1U << 1);  ///< Flash A sample clock reference delay line locked.
        constexpr uint32_t ASLVSEL = (6 << 2);  ///< Flash A sample clock slave delay line delay cell number selection .
        constexpr uint32_t AREFSEL = (6 << 8);  ///< Flash A sample clock reference delay line delay cell number selection.
        constexpr uint32_t BSLVLOCK = (1U << 16);  ///< Flash B sample clock slave delay line locked.
        constexpr uint32_t BREFLOCK = (1U << 17);  ///< Flash B sample clock reference delay line locked.
        constexpr uint32_t BSLVSEL = (6 << 18);  ///< Flash B sample clock slave delay line delay cell number selection.
        constexpr uint32_t BREFSEL = (6 << 24);  ///< Flash B sample clock reference delay line delay cell number selection.
    }

    /// AHBSPNDSTS Register bits
    namespace ahbspndsts_bits {
        constexpr uint32_t ACTIVE = (1U << 0);  ///< Indicates if an AHB read prefetch command sequence has been suspended.
        constexpr uint32_t BUFID = (3 << 1);  ///< AHB RX BUF ID for suspended command sequence.
        constexpr uint32_t DATLFT = (16 << 16);  ///< Left Data size for suspended command sequence (in byte).
    }

    /// IPRXFSTS Register bits
    namespace iprxfsts_bits {
        constexpr uint32_t FILL = (8 << 0);  ///< Fill level of IP RX FIFO.
        constexpr uint32_t RDCNTR = (16 << 16);  ///< Total Read Data Counter: RDCNTR * 64 Bits.
    }

    /// IPTXFSTS Register bits
    namespace iptxfsts_bits {
        constexpr uint32_t FILL = (8 << 0);  ///< Fill level of IP TX FIFO.
        constexpr uint32_t WRCNTR = (16 << 16);  ///< Total Write Data Counter: WRCNTR * 64 Bits.
    }

    /// RFDR[%s] Register bits
    namespace rfdr[%s]_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< RX Data
    }

    /// TFDR[%s] Register bits
    namespace tfdr[%s]_bits {
        constexpr uint32_t TXDATA = (32 << 0);  ///< TX Data
    }

    /// LUT[%s] Register bits
    namespace lut[%s]_bits {
        constexpr uint32_t OPERAND0 = (8 << 0);  ///< OPERAND0
        constexpr uint32_t NUM_PADS0 = (2 << 8);  ///< NUM_PADS0
        constexpr uint32_t OPCODE0 = (6 << 10);  ///< OPCODE
        constexpr uint32_t OPERAND1 = (8 << 16);  ///< OPERAND1
        constexpr uint32_t NUM_PADS1 = (2 << 24);  ///< NUM_PADS1
        constexpr uint32_t OPCODE1 = (6 << 26);  ///< OPCODE1
    }

}

// ============================================================================
// PXP Peripheral
// ============================================================================

namespace pxp {
    /// Base addresses
    constexpr uint32_t PXP_BASE = 0x402B4000;

    /// PXP Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register 0
        volatile uint32_t CTRL_SET;  ///< Offset: 0x04 - Control Register 0
        volatile uint32_t CTRL_CLR;  ///< Offset: 0x08 - Control Register 0
        volatile uint32_t CTRL_TOG;  ///< Offset: 0x0C - Control Register 0
        volatile uint32_t STAT;  ///< Offset: 0x10 - Status Register
        volatile uint32_t STAT_SET;  ///< Offset: 0x14 - Status Register
        volatile uint32_t STAT_CLR;  ///< Offset: 0x18 - Status Register
        volatile uint32_t STAT_TOG;  ///< Offset: 0x1C - Status Register
        volatile uint32_t OUT_CTRL;  ///< Offset: 0x20 - Output Buffer Control Register
        volatile uint32_t OUT_CTRL_SET;  ///< Offset: 0x24 - Output Buffer Control Register
        volatile uint32_t OUT_CTRL_CLR;  ///< Offset: 0x28 - Output Buffer Control Register
        volatile uint32_t OUT_CTRL_TOG;  ///< Offset: 0x2C - Output Buffer Control Register
        volatile uint32_t OUT_BUF;  ///< Offset: 0x30 - Output Frame Buffer Pointer
        volatile uint32_t OUT_BUF2;  ///< Offset: 0x40 - Output Frame Buffer Pointer #2
        volatile uint32_t OUT_PITCH;  ///< Offset: 0x50 - Output Buffer Pitch
        volatile uint32_t OUT_LRC;  ///< Offset: 0x60 - Output Surface Lower Right Coordinate
        volatile uint32_t OUT_PS_ULC;  ///< Offset: 0x70 - Processed Surface Upper Left Coordinate
        volatile uint32_t OUT_PS_LRC;  ///< Offset: 0x80 - Processed Surface Lower Right Coordinate
        volatile uint32_t OUT_AS_ULC;  ///< Offset: 0x90 - Alpha Surface Upper Left Coordinate
        volatile uint32_t OUT_AS_LRC;  ///< Offset: 0xA0 - Alpha Surface Lower Right Coordinate
        volatile uint32_t PS_CTRL;  ///< Offset: 0xB0 - Processed Surface (PS) Control Register
        volatile uint32_t PS_CTRL_SET;  ///< Offset: 0xB4 - Processed Surface (PS) Control Register
        volatile uint32_t PS_CTRL_CLR;  ///< Offset: 0xB8 - Processed Surface (PS) Control Register
        volatile uint32_t PS_CTRL_TOG;  ///< Offset: 0xBC - Processed Surface (PS) Control Register
        volatile uint32_t PS_BUF;  ///< Offset: 0xC0 - PS Input Buffer Address
        volatile uint32_t PS_UBUF;  ///< Offset: 0xD0 - PS U/Cb or 2 Plane UV Input Buffer Address
        volatile uint32_t PS_VBUF;  ///< Offset: 0xE0 - PS V/Cr Input Buffer Address
        volatile uint32_t PS_PITCH;  ///< Offset: 0xF0 - Processed Surface Pitch
        volatile uint32_t PS_BACKGROUND;  ///< Offset: 0x100 - PS Background Color
        volatile uint32_t PS_SCALE;  ///< Offset: 0x110 - PS Scale Factor Register
        volatile uint32_t PS_OFFSET;  ///< Offset: 0x120 - PS Scale Offset Register
        volatile uint32_t PS_CLRKEYLOW;  ///< Offset: 0x130 - PS Color Key Low
        volatile uint32_t PS_CLRKEYHIGH;  ///< Offset: 0x140 - PS Color Key High
        volatile uint32_t AS_CTRL;  ///< Offset: 0x150 - Alpha Surface Control
        volatile uint32_t AS_BUF;  ///< Offset: 0x160 - Alpha Surface Buffer Pointer
        volatile uint32_t AS_PITCH;  ///< Offset: 0x170 - Alpha Surface Pitch
        volatile uint32_t AS_CLRKEYLOW;  ///< Offset: 0x180 - Overlay Color Key Low
        volatile uint32_t AS_CLRKEYHIGH;  ///< Offset: 0x190 - Overlay Color Key High
        volatile uint32_t CSC1_COEF0;  ///< Offset: 0x1A0 - Color Space Conversion Coefficient Register 0
        volatile uint32_t CSC1_COEF1;  ///< Offset: 0x1B0 - Color Space Conversion Coefficient Register 1
        volatile uint32_t CSC1_COEF2;  ///< Offset: 0x1C0 - Color Space Conversion Coefficient Register 2
        volatile uint32_t POWER;  ///< Offset: 0x320 - PXP Power Control Register
        volatile uint32_t NEXT;  ///< Offset: 0x400 - Next Frame Pointer
        volatile uint32_t PORTER_DUFF_CTRL;  ///< Offset: 0x440 - PXP Alpha Engine A Control Register.
    };

    /// Peripheral instances
    inline Registers* PXP = reinterpret_cast<Registers*>(PXP_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enables PXP operation with specified parameters
        constexpr uint32_t IRQ_ENABLE = (1U << 1);  ///< Interrupt enable
        constexpr uint32_t NEXT_IRQ_ENABLE = (1U << 2);  ///< Next command interrupt enable
        constexpr uint32_t ENABLE_LCD_HANDSHAKE = (1U << 4);  ///< Enable handshake with LCD controller
        constexpr uint32_t RSVD0 = (3 << 5);  ///< Reserved, always set to zero.
        constexpr uint32_t ROTATE = (2 << 8);  ///< Indicates the clockwise rotation to be applied at the output buffer
        constexpr uint32_t HFLIP = (1U << 10);  ///< Indicates that the output buffer should be flipped horizontally (effect applied before rotation).
        constexpr uint32_t VFLIP = (1U << 11);  ///< Indicates that the output buffer should be flipped vertically (effect applied before rotation).
        constexpr uint32_t RSVD1 = (10 << 12);  ///< Reserved, always set to zero.
        constexpr uint32_t ROT_POS = (1U << 22);  ///< This bit controls where rotation will occur in the PXP datapath
        constexpr uint32_t BLOCK_SIZE = (1U << 23);  ///< Select the block size to process.
        constexpr uint32_t RSVD3 = (4 << 24);  ///< Reserved, always set to zero.
        constexpr uint32_t EN_REPEAT = (1U << 28);  ///< Enable the PXP to run continuously
        constexpr uint32_t RSVD4 = (1U << 29);  ///< Reserved, always set to zero.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< Set this bit to zero to enable normal PXP operation
    }

    /// CTRL_SET Register bits
    namespace ctrl_set_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enables PXP operation with specified parameters
        constexpr uint32_t IRQ_ENABLE = (1U << 1);  ///< Interrupt enable
        constexpr uint32_t NEXT_IRQ_ENABLE = (1U << 2);  ///< Next command interrupt enable
        constexpr uint32_t ENABLE_LCD_HANDSHAKE = (1U << 4);  ///< Enable handshake with LCD controller
        constexpr uint32_t RSVD0 = (3 << 5);  ///< Reserved, always set to zero.
        constexpr uint32_t ROTATE = (2 << 8);  ///< Indicates the clockwise rotation to be applied at the output buffer
        constexpr uint32_t HFLIP = (1U << 10);  ///< Indicates that the output buffer should be flipped horizontally (effect applied before rotation).
        constexpr uint32_t VFLIP = (1U << 11);  ///< Indicates that the output buffer should be flipped vertically (effect applied before rotation).
        constexpr uint32_t RSVD1 = (10 << 12);  ///< Reserved, always set to zero.
        constexpr uint32_t ROT_POS = (1U << 22);  ///< This bit controls where rotation will occur in the PXP datapath
        constexpr uint32_t BLOCK_SIZE = (1U << 23);  ///< Select the block size to process.
        constexpr uint32_t RSVD3 = (4 << 24);  ///< Reserved, always set to zero.
        constexpr uint32_t EN_REPEAT = (1U << 28);  ///< Enable the PXP to run continuously
        constexpr uint32_t RSVD4 = (1U << 29);  ///< Reserved, always set to zero.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< Set this bit to zero to enable normal PXP operation
    }

    /// CTRL_CLR Register bits
    namespace ctrl_clr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enables PXP operation with specified parameters
        constexpr uint32_t IRQ_ENABLE = (1U << 1);  ///< Interrupt enable
        constexpr uint32_t NEXT_IRQ_ENABLE = (1U << 2);  ///< Next command interrupt enable
        constexpr uint32_t ENABLE_LCD_HANDSHAKE = (1U << 4);  ///< Enable handshake with LCD controller
        constexpr uint32_t RSVD0 = (3 << 5);  ///< Reserved, always set to zero.
        constexpr uint32_t ROTATE = (2 << 8);  ///< Indicates the clockwise rotation to be applied at the output buffer
        constexpr uint32_t HFLIP = (1U << 10);  ///< Indicates that the output buffer should be flipped horizontally (effect applied before rotation).
        constexpr uint32_t VFLIP = (1U << 11);  ///< Indicates that the output buffer should be flipped vertically (effect applied before rotation).
        constexpr uint32_t RSVD1 = (10 << 12);  ///< Reserved, always set to zero.
        constexpr uint32_t ROT_POS = (1U << 22);  ///< This bit controls where rotation will occur in the PXP datapath
        constexpr uint32_t BLOCK_SIZE = (1U << 23);  ///< Select the block size to process.
        constexpr uint32_t RSVD3 = (4 << 24);  ///< Reserved, always set to zero.
        constexpr uint32_t EN_REPEAT = (1U << 28);  ///< Enable the PXP to run continuously
        constexpr uint32_t RSVD4 = (1U << 29);  ///< Reserved, always set to zero.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< Set this bit to zero to enable normal PXP operation
    }

    /// CTRL_TOG Register bits
    namespace ctrl_tog_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enables PXP operation with specified parameters
        constexpr uint32_t IRQ_ENABLE = (1U << 1);  ///< Interrupt enable
        constexpr uint32_t NEXT_IRQ_ENABLE = (1U << 2);  ///< Next command interrupt enable
        constexpr uint32_t ENABLE_LCD_HANDSHAKE = (1U << 4);  ///< Enable handshake with LCD controller
        constexpr uint32_t RSVD0 = (3 << 5);  ///< Reserved, always set to zero.
        constexpr uint32_t ROTATE = (2 << 8);  ///< Indicates the clockwise rotation to be applied at the output buffer
        constexpr uint32_t HFLIP = (1U << 10);  ///< Indicates that the output buffer should be flipped horizontally (effect applied before rotation).
        constexpr uint32_t VFLIP = (1U << 11);  ///< Indicates that the output buffer should be flipped vertically (effect applied before rotation).
        constexpr uint32_t RSVD1 = (10 << 12);  ///< Reserved, always set to zero.
        constexpr uint32_t ROT_POS = (1U << 22);  ///< This bit controls where rotation will occur in the PXP datapath
        constexpr uint32_t BLOCK_SIZE = (1U << 23);  ///< Select the block size to process.
        constexpr uint32_t RSVD3 = (4 << 24);  ///< Reserved, always set to zero.
        constexpr uint32_t EN_REPEAT = (1U << 28);  ///< Enable the PXP to run continuously
        constexpr uint32_t RSVD4 = (1U << 29);  ///< Reserved, always set to zero.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< Set this bit to zero to enable normal PXP operation
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t IRQ = (1U << 0);  ///< Indicates current PXP interrupt status
        constexpr uint32_t AXI_WRITE_ERROR = (1U << 1);  ///< Indicates PXP encountered an AXI write error and processing has been terminated.
        constexpr uint32_t AXI_READ_ERROR = (1U << 2);  ///< Indicates PXP encountered an AXI read error and processing has been terminated.
        constexpr uint32_t NEXT_IRQ = (1U << 3);  ///< Indicates that a command issued with the "Next Command" functionality has been issued and that a new command may be initiated with a write to the PXP_NEXT register
        constexpr uint32_t AXI_ERROR_ID = (4 << 4);  ///< Indicates the AXI ID of the failing bus operation.
        constexpr uint32_t LUT_DMA_LOAD_DONE_IRQ = (1U << 8);  ///< Indicates that the LUT DMA transfer has completed.
        constexpr uint32_t RSVD2 = (7 << 9);  ///< Reserved, always set to zero.
        constexpr uint32_t BLOCKY = (8 << 16);  ///< Indicates the X coordinate of the block currently being rendered.
        constexpr uint32_t BLOCKX = (8 << 24);  ///< Indicates the X coordinate of the block currently being rendered.
    }

    /// STAT_SET Register bits
    namespace stat_set_bits {
        constexpr uint32_t IRQ = (1U << 0);  ///< Indicates current PXP interrupt status
        constexpr uint32_t AXI_WRITE_ERROR = (1U << 1);  ///< Indicates PXP encountered an AXI write error and processing has been terminated.
        constexpr uint32_t AXI_READ_ERROR = (1U << 2);  ///< Indicates PXP encountered an AXI read error and processing has been terminated.
        constexpr uint32_t NEXT_IRQ = (1U << 3);  ///< Indicates that a command issued with the "Next Command" functionality has been issued and that a new command may be initiated with a write to the PXP_NEXT register
        constexpr uint32_t AXI_ERROR_ID = (4 << 4);  ///< Indicates the AXI ID of the failing bus operation.
        constexpr uint32_t LUT_DMA_LOAD_DONE_IRQ = (1U << 8);  ///< Indicates that the LUT DMA transfer has completed.
        constexpr uint32_t RSVD2 = (7 << 9);  ///< Reserved, always set to zero.
        constexpr uint32_t BLOCKY = (8 << 16);  ///< Indicates the X coordinate of the block currently being rendered.
        constexpr uint32_t BLOCKX = (8 << 24);  ///< Indicates the X coordinate of the block currently being rendered.
    }

    /// STAT_CLR Register bits
    namespace stat_clr_bits {
        constexpr uint32_t IRQ = (1U << 0);  ///< Indicates current PXP interrupt status
        constexpr uint32_t AXI_WRITE_ERROR = (1U << 1);  ///< Indicates PXP encountered an AXI write error and processing has been terminated.
        constexpr uint32_t AXI_READ_ERROR = (1U << 2);  ///< Indicates PXP encountered an AXI read error and processing has been terminated.
        constexpr uint32_t NEXT_IRQ = (1U << 3);  ///< Indicates that a command issued with the "Next Command" functionality has been issued and that a new command may be initiated with a write to the PXP_NEXT register
        constexpr uint32_t AXI_ERROR_ID = (4 << 4);  ///< Indicates the AXI ID of the failing bus operation.
        constexpr uint32_t LUT_DMA_LOAD_DONE_IRQ = (1U << 8);  ///< Indicates that the LUT DMA transfer has completed.
        constexpr uint32_t RSVD2 = (7 << 9);  ///< Reserved, always set to zero.
        constexpr uint32_t BLOCKY = (8 << 16);  ///< Indicates the X coordinate of the block currently being rendered.
        constexpr uint32_t BLOCKX = (8 << 24);  ///< Indicates the X coordinate of the block currently being rendered.
    }

    /// STAT_TOG Register bits
    namespace stat_tog_bits {
        constexpr uint32_t IRQ = (1U << 0);  ///< Indicates current PXP interrupt status
        constexpr uint32_t AXI_WRITE_ERROR = (1U << 1);  ///< Indicates PXP encountered an AXI write error and processing has been terminated.
        constexpr uint32_t AXI_READ_ERROR = (1U << 2);  ///< Indicates PXP encountered an AXI read error and processing has been terminated.
        constexpr uint32_t NEXT_IRQ = (1U << 3);  ///< Indicates that a command issued with the "Next Command" functionality has been issued and that a new command may be initiated with a write to the PXP_NEXT register
        constexpr uint32_t AXI_ERROR_ID = (4 << 4);  ///< Indicates the AXI ID of the failing bus operation.
        constexpr uint32_t LUT_DMA_LOAD_DONE_IRQ = (1U << 8);  ///< Indicates that the LUT DMA transfer has completed.
        constexpr uint32_t RSVD2 = (7 << 9);  ///< Reserved, always set to zero.
        constexpr uint32_t BLOCKY = (8 << 16);  ///< Indicates the X coordinate of the block currently being rendered.
        constexpr uint32_t BLOCKX = (8 << 24);  ///< Indicates the X coordinate of the block currently being rendered.
    }

    /// OUT_CTRL Register bits
    namespace out_ctrl_bits {
        constexpr uint32_t FORMAT = (5 << 0);  ///< Output framebuffer format
        constexpr uint32_t RSVD0 = (3 << 5);  ///< Reserved, always set to zero.
        constexpr uint32_t INTERLACED_OUTPUT = (2 << 8);  ///< Determines how the PXP writes it's output data
        constexpr uint32_t RSVD1 = (13 << 10);  ///< Reserved, always set to zero.
        constexpr uint32_t ALPHA_OUTPUT = (1U << 23);  ///< Indicates that alpha component in output buffer pixels should be overwritten by PXP_OUT_CTRL[ALPHA]
        constexpr uint32_t ALPHA = (8 << 24);  ///< When generating an output buffer with an alpha component, the value in this field will be used when enabled to override the alpha passed through the pixel data pipeline
    }

    /// OUT_CTRL_SET Register bits
    namespace out_ctrl_set_bits {
        constexpr uint32_t FORMAT = (5 << 0);  ///< Output framebuffer format
        constexpr uint32_t RSVD0 = (3 << 5);  ///< Reserved, always set to zero.
        constexpr uint32_t INTERLACED_OUTPUT = (2 << 8);  ///< Determines how the PXP writes it's output data
        constexpr uint32_t RSVD1 = (13 << 10);  ///< Reserved, always set to zero.
        constexpr uint32_t ALPHA_OUTPUT = (1U << 23);  ///< Indicates that alpha component in output buffer pixels should be overwritten by PXP_OUT_CTRL[ALPHA]
        constexpr uint32_t ALPHA = (8 << 24);  ///< When generating an output buffer with an alpha component, the value in this field will be used when enabled to override the alpha passed through the pixel data pipeline
    }

    /// OUT_CTRL_CLR Register bits
    namespace out_ctrl_clr_bits {
        constexpr uint32_t FORMAT = (5 << 0);  ///< Output framebuffer format
        constexpr uint32_t RSVD0 = (3 << 5);  ///< Reserved, always set to zero.
        constexpr uint32_t INTERLACED_OUTPUT = (2 << 8);  ///< Determines how the PXP writes it's output data
        constexpr uint32_t RSVD1 = (13 << 10);  ///< Reserved, always set to zero.
        constexpr uint32_t ALPHA_OUTPUT = (1U << 23);  ///< Indicates that alpha component in output buffer pixels should be overwritten by PXP_OUT_CTRL[ALPHA]
        constexpr uint32_t ALPHA = (8 << 24);  ///< When generating an output buffer with an alpha component, the value in this field will be used when enabled to override the alpha passed through the pixel data pipeline
    }

    /// OUT_CTRL_TOG Register bits
    namespace out_ctrl_tog_bits {
        constexpr uint32_t FORMAT = (5 << 0);  ///< Output framebuffer format
        constexpr uint32_t RSVD0 = (3 << 5);  ///< Reserved, always set to zero.
        constexpr uint32_t INTERLACED_OUTPUT = (2 << 8);  ///< Determines how the PXP writes it's output data
        constexpr uint32_t RSVD1 = (13 << 10);  ///< Reserved, always set to zero.
        constexpr uint32_t ALPHA_OUTPUT = (1U << 23);  ///< Indicates that alpha component in output buffer pixels should be overwritten by PXP_OUT_CTRL[ALPHA]
        constexpr uint32_t ALPHA = (8 << 24);  ///< When generating an output buffer with an alpha component, the value in this field will be used when enabled to override the alpha passed through the pixel data pipeline
    }

    /// OUT_BUF Register bits
    namespace out_buf_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Current address pointer for the output frame buffer
    }

    /// OUT_BUF2 Register bits
    namespace out_buf2_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Current address pointer for the output frame buffer
    }

    /// OUT_PITCH Register bits
    namespace out_pitch_bits {
        constexpr uint32_t PITCH = (16 << 0);  ///< Indicates the number of bytes in memory between two vertically adjacent pixels.
        constexpr uint32_t RSVD = (16 << 16);  ///< Reserved, always set to zero.
    }

    /// OUT_LRC Register bits
    namespace out_lrc_bits {
        constexpr uint32_t Y = (14 << 0);  ///< Indicates the number of vertical PIXELS in the output surface (non-rotated)
        constexpr uint32_t RSVD0 = (2 << 14);  ///< Reserved, always set to zero.
        constexpr uint32_t X = (14 << 16);  ///< Indicates number of horizontal PIXELS in the output surface (non-rotated)
        constexpr uint32_t RSVD1 = (2 << 30);  ///< Reserved, always set to zero.
    }

    /// OUT_PS_ULC Register bits
    namespace out_ps_ulc_bits {
        constexpr uint32_t Y = (14 << 0);  ///< This field indicates the upper left Y-coordinate (in pixels) of the processed surface in the output buffer
        constexpr uint32_t RSVD0 = (2 << 14);  ///< Reserved, always set to zero.
        constexpr uint32_t X = (14 << 16);  ///< This field indicates the upper left X-coordinate (in pixels) of the processed surface (PS) in the output buffer
        constexpr uint32_t RSVD1 = (2 << 30);  ///< Reserved, always set to zero.
    }

    /// OUT_PS_LRC Register bits
    namespace out_ps_lrc_bits {
        constexpr uint32_t Y = (14 << 0);  ///< This field indicates the lower right Y-coordinate (in pixels) of the processed surface in the output frame buffer
        constexpr uint32_t RSVD0 = (2 << 14);  ///< Reserved, always set to zero.
        constexpr uint32_t X = (14 << 16);  ///< This field indicates the lower right X-coordinate (in pixels) of the processed surface (PS) in the output frame buffer
        constexpr uint32_t RSVD1 = (2 << 30);  ///< Reserved, always set to zero.
    }

    /// OUT_AS_ULC Register bits
    namespace out_as_ulc_bits {
        constexpr uint32_t Y = (14 << 0);  ///< This field indicates the upper left Y-coordinate (in pixels) of the alpha surface in the output frame buffer
        constexpr uint32_t RSVD0 = (2 << 14);  ///< Reserved, always set to zero.
        constexpr uint32_t X = (14 << 16);  ///< This field indicates the upper left X-coordinate (in pixels) of the alpha surface (AS) in the output frame buffer
        constexpr uint32_t RSVD1 = (2 << 30);  ///< Reserved, always set to zero.
    }

    /// OUT_AS_LRC Register bits
    namespace out_as_lrc_bits {
        constexpr uint32_t Y = (14 << 0);  ///< This field indicates the lower right Y-coordinate (in pixels) of the alpha surface in the output frame buffer
        constexpr uint32_t RSVD0 = (2 << 14);  ///< Reserved, always set to zero.
        constexpr uint32_t X = (14 << 16);  ///< This field indicates the lower right X-coordinate (in pixels) of the alpha surface (AS) in the output frame buffer
        constexpr uint32_t RSVD1 = (2 << 30);  ///< Reserved, always set to zero.
    }

    /// PS_CTRL Register bits
    namespace ps_ctrl_bits {
        constexpr uint32_t FORMAT = (5 << 0);  ///< PS buffer format. To select between YUV and YCbCr formats, see bit 31 of the CSC1_COEF0 register.
        constexpr uint32_t WB_SWAP = (1U << 5);  ///< Swap bytes in words. For each 16 bit word, the two bytes will be swapped.
        constexpr uint32_t RSVD0 = (2 << 6);  ///< Reserved, always set to zero.
        constexpr uint32_t DECY = (2 << 8);  ///< Verticle pre decimation filter control.
        constexpr uint32_t DECX = (2 << 10);  ///< Horizontal pre decimation filter control.
        constexpr uint32_t RSVD1 = (20 << 12);  ///< Reserved, always set to zero.
    }

    /// PS_CTRL_SET Register bits
    namespace ps_ctrl_set_bits {
        constexpr uint32_t FORMAT = (5 << 0);  ///< PS buffer format. To select between YUV and YCbCr formats, see bit 31 of the CSC1_COEF0 register.
        constexpr uint32_t WB_SWAP = (1U << 5);  ///< Swap bytes in words. For each 16 bit word, the two bytes will be swapped.
        constexpr uint32_t RSVD0 = (2 << 6);  ///< Reserved, always set to zero.
        constexpr uint32_t DECY = (2 << 8);  ///< Verticle pre decimation filter control.
        constexpr uint32_t DECX = (2 << 10);  ///< Horizontal pre decimation filter control.
        constexpr uint32_t RSVD1 = (20 << 12);  ///< Reserved, always set to zero.
    }

    /// PS_CTRL_CLR Register bits
    namespace ps_ctrl_clr_bits {
        constexpr uint32_t FORMAT = (5 << 0);  ///< PS buffer format. To select between YUV and YCbCr formats, see bit 31 of the CSC1_COEF0 register.
        constexpr uint32_t WB_SWAP = (1U << 5);  ///< Swap bytes in words. For each 16 bit word, the two bytes will be swapped.
        constexpr uint32_t RSVD0 = (2 << 6);  ///< Reserved, always set to zero.
        constexpr uint32_t DECY = (2 << 8);  ///< Verticle pre decimation filter control.
        constexpr uint32_t DECX = (2 << 10);  ///< Horizontal pre decimation filter control.
        constexpr uint32_t RSVD1 = (20 << 12);  ///< Reserved, always set to zero.
    }

    /// PS_CTRL_TOG Register bits
    namespace ps_ctrl_tog_bits {
        constexpr uint32_t FORMAT = (5 << 0);  ///< PS buffer format. To select between YUV and YCbCr formats, see bit 31 of the CSC1_COEF0 register.
        constexpr uint32_t WB_SWAP = (1U << 5);  ///< Swap bytes in words. For each 16 bit word, the two bytes will be swapped.
        constexpr uint32_t RSVD0 = (2 << 6);  ///< Reserved, always set to zero.
        constexpr uint32_t DECY = (2 << 8);  ///< Verticle pre decimation filter control.
        constexpr uint32_t DECX = (2 << 10);  ///< Horizontal pre decimation filter control.
        constexpr uint32_t RSVD1 = (20 << 12);  ///< Reserved, always set to zero.
    }

    /// PS_BUF Register bits
    namespace ps_buf_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Address pointer for the PS RGB or Y (luma) input buffer.
    }

    /// PS_UBUF Register bits
    namespace ps_ubuf_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Address pointer for the PS U/Cb or 2 plane UV Chroma input buffer.
    }

    /// PS_VBUF Register bits
    namespace ps_vbuf_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Address pointer for the PS V/Cr Chroma input buffer.
    }

    /// PS_PITCH Register bits
    namespace ps_pitch_bits {
        constexpr uint32_t PITCH = (16 << 0);  ///< Indicates the number of bytes in memory between two vertically adjacent pixels.
        constexpr uint32_t RSVD = (16 << 16);  ///< Reserved, always set to zero.
    }

    /// PS_BACKGROUND Register bits
    namespace ps_background_bits {
        constexpr uint32_t COLOR = (24 << 0);  ///< Background color (in 24bpp format) for any pixels not within the buffer range specified by the PS ULC/LRC
        constexpr uint32_t RSVD = (8 << 24);  ///< Reserved, always set to zero.
    }

    /// PS_SCALE Register bits
    namespace ps_scale_bits {
        constexpr uint32_t XSCALE = (15 << 0);  ///< This is a two bit integer and 12 bit fractional representation (##
        constexpr uint32_t RSVD1 = (1U << 15);  ///< Reserved, always set to zero.
        constexpr uint32_t YSCALE = (15 << 16);  ///< This is a two bit integer and 12 bit fractional representation (##
        constexpr uint32_t RSVD2 = (1U << 31);  ///< Reserved, always set to zero.
    }

    /// PS_OFFSET Register bits
    namespace ps_offset_bits {
        constexpr uint32_t XOFFSET = (12 << 0);  ///< This is a 12 bit fractional representation (0
        constexpr uint32_t RSVD1 = (4 << 12);  ///< Reserved, always set to zero.
        constexpr uint32_t YOFFSET = (12 << 16);  ///< This is a 12 bit fractional representation (0
        constexpr uint32_t RSVD2 = (4 << 28);  ///< Reserved, always set to zero.
    }

    /// PS_CLRKEYLOW Register bits
    namespace ps_clrkeylow_bits {
        constexpr uint32_t PIXEL = (24 << 0);  ///< Low range of color key applied to PS buffer
        constexpr uint32_t RSVD1 = (8 << 24);  ///< Reserved, always set to zero.
    }

    /// PS_CLRKEYHIGH Register bits
    namespace ps_clrkeyhigh_bits {
        constexpr uint32_t PIXEL = (24 << 0);  ///< High range of color key applied to PS buffer
        constexpr uint32_t RSVD1 = (8 << 24);  ///< Reserved, always set to zero.
    }

    /// AS_CTRL Register bits
    namespace as_ctrl_bits {
        constexpr uint32_t RSVD0 = (1U << 0);  ///< Reserved, always set to zero.
        constexpr uint32_t ALPHA_CTRL = (2 << 1);  ///< Determines how the alpha value is constructed for this alpha surface
        constexpr uint32_t ENABLE_COLORKEY = (1U << 3);  ///< Indicates that colorkey functionality is enabled for this alpha surface
        constexpr uint32_t FORMAT = (4 << 4);  ///< Indicates the input buffer format for AS.
        constexpr uint32_t ALPHA = (8 << 8);  ///< Alpha modifier used when the ALPHA_MULTIPLY or ALPHA_OVERRIDE values are programmed in PXP_AS_CTRL[ALPHA_CTRL]
        constexpr uint32_t ROP = (4 << 16);  ///< Indicates a raster operation to perform when enabled
        constexpr uint32_t ALPHA_INVERT = (1U << 20);  ///< Setting this bit to logic 0 will not alter the alpha value
        constexpr uint32_t RSVD1 = (11 << 21);  ///< Reserved, always set to zero.
    }

    /// AS_BUF Register bits
    namespace as_buf_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Address pointer for the alpha surface 0 buffer.
    }

    /// AS_PITCH Register bits
    namespace as_pitch_bits {
        constexpr uint32_t PITCH = (16 << 0);  ///< Indicates the number of bytes in memory between two vertically adjacent pixels.
        constexpr uint32_t RSVD = (16 << 16);  ///< Reserved, always set to zero.
    }

    /// AS_CLRKEYLOW Register bits
    namespace as_clrkeylow_bits {
        constexpr uint32_t PIXEL = (24 << 0);  ///< Low range of RGB color key applied to AS buffer. Each overlay has an independent colorkey enable.
        constexpr uint32_t RSVD1 = (8 << 24);  ///< Reserved, always set to zero.
    }

    /// AS_CLRKEYHIGH Register bits
    namespace as_clrkeyhigh_bits {
        constexpr uint32_t PIXEL = (24 << 0);  ///< High range of RGB color key applied to AS buffer. Each overlay has an independent colorkey enable.
        constexpr uint32_t RSVD1 = (8 << 24);  ///< Reserved, always set to zero.
    }

    /// CSC1_COEF0 Register bits
    namespace csc1_coef0_bits {
        constexpr uint32_t Y_OFFSET = (9 << 0);  ///< Two's compliment amplitude offset implicit in the Y data
        constexpr uint32_t UV_OFFSET = (9 << 9);  ///< Two's compliment phase offset implicit for CbCr data
        constexpr uint32_t C0 = (11 << 18);  ///< Two's compliment Y multiplier coefficient. YUV=0x100 (1.000) YCbCr=0x12A (1.164)
        constexpr uint32_t RSVD1 = (1U << 29);  ///< Reserved, always set to zero.
        constexpr uint32_t BYPASS = (1U << 30);  ///< Bypass the CSC unit in the scaling engine
        constexpr uint32_t YCBCR_MODE = (1U << 31);  ///< Set to 1 when performing YCbCr conversion to RGB
    }

    /// CSC1_COEF1 Register bits
    namespace csc1_coef1_bits {
        constexpr uint32_t C4 = (11 << 0);  ///< Two's compliment Blue U/Cb multiplier coefficient. YUV=0x208 (2.032) YCbCr=0x204 (2.017)
        constexpr uint32_t RSVD0 = (5 << 11);  ///< Reserved, always set to zero.
        constexpr uint32_t C1 = (11 << 16);  ///< Two's compliment Red V/Cr multiplier coefficient. YUV=0x123 (1.140) YCbCr=0x198 (1.596)
        constexpr uint32_t RSVD1 = (5 << 27);  ///< Reserved, always set to zero.
    }

    /// CSC1_COEF2 Register bits
    namespace csc1_coef2_bits {
        constexpr uint32_t C3 = (11 << 0);  ///< Two's complement Green U/Cb multiplier coefficient. YUV=0x79C (-0.394) YCbCr=0x79C (-0.392)
        constexpr uint32_t RSVD0 = (5 << 11);  ///< Reserved, always set to zero.
        constexpr uint32_t C2 = (11 << 16);  ///< Two's complement Green V/Cr multiplier coefficient. YUV=0x76B (-0.581) YCbCr=0x730 (-0.813)
        constexpr uint32_t RSVD1 = (5 << 27);  ///< Reserved, always set to zero.
    }

    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t ROT_MEM_LP_STATE = (3 << 9);  ///< Select the low power state of the ROT memory.
        constexpr uint32_t CTRL = (20 << 12);  ///< Power control for the PXP.
    }

    /// NEXT Register bits
    namespace next_bits {
        constexpr uint32_t ENABLED = (1U << 0);  ///< Indicates that the "next frame" functionality has been enabled
        constexpr uint32_t RSVD = (1U << 1);  ///< Reserved, always set to zero.
        constexpr uint32_t POINTER = (30 << 2);  ///< A pointer to a data structure containing register values to be used when processing the next frame
    }

    /// PORTER_DUFF_CTRL Register bits
    namespace porter_duff_ctrl_bits {
        constexpr uint32_t POTER_DUFF_ENABLE = (1U << 0);  ///< poter_duff enable
        constexpr uint32_t S0_S1_FACTOR_MODE = (2 << 1);  ///< s0 to s1 factor mode
        constexpr uint32_t S0_GLOBAL_ALPHA_MODE = (2 << 3);  ///< s0 global alpha mode
        constexpr uint32_t S0_ALPHA_MODE = (1U << 5);  ///< s0 alpha mode
        constexpr uint32_t S0_COLOR_MODE = (1U << 6);  ///< s0 color mode
        constexpr uint32_t S1_S0_FACTOR_MODE = (2 << 8);  ///< s1 to s0 factor mode
        constexpr uint32_t S1_GLOBAL_ALPHA_MODE = (2 << 10);  ///< s1 global alpha mode
        constexpr uint32_t S1_ALPHA_MODE = (1U << 12);  ///< s1 alpha mode
        constexpr uint32_t S1_COLOR_MODE = (1U << 13);  ///< s1 color mode
        constexpr uint32_t S0_GLOBAL_ALPHA = (8 << 16);  ///< s0 global alpha
        constexpr uint32_t S1_GLOBAL_ALPHA = (8 << 24);  ///< s1 global alpha
    }

}

// ============================================================================
// LCDIF Peripheral
// ============================================================================

namespace lcdif {
    /// Base addresses
    constexpr uint32_t LCDIF_BASE = 0x402B8000;

    /// LCDIF Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - LCDIF General Control Register
        volatile uint32_t CTRL_SET;  ///< Offset: 0x04 - LCDIF General Control Register
        volatile uint32_t CTRL_CLR;  ///< Offset: 0x08 - LCDIF General Control Register
        volatile uint32_t CTRL_TOG;  ///< Offset: 0x0C - LCDIF General Control Register
        volatile uint32_t CTRL1;  ///< Offset: 0x10 - LCDIF General Control1 Register
        volatile uint32_t CTRL1_SET;  ///< Offset: 0x14 - LCDIF General Control1 Register
        volatile uint32_t CTRL1_CLR;  ///< Offset: 0x18 - LCDIF General Control1 Register
        volatile uint32_t CTRL1_TOG;  ///< Offset: 0x1C - LCDIF General Control1 Register
        volatile uint32_t CTRL2;  ///< Offset: 0x20 - LCDIF General Control2 Register
        volatile uint32_t CTRL2_SET;  ///< Offset: 0x24 - LCDIF General Control2 Register
        volatile uint32_t CTRL2_CLR;  ///< Offset: 0x28 - LCDIF General Control2 Register
        volatile uint32_t CTRL2_TOG;  ///< Offset: 0x2C - LCDIF General Control2 Register
        volatile uint32_t TRANSFER_COUNT;  ///< Offset: 0x30 - LCDIF Horizontal and Vertical Valid Data Count Register
        volatile uint32_t CUR_BUF;  ///< Offset: 0x40 - LCD Interface Current Buffer Address Register
        volatile uint32_t NEXT_BUF;  ///< Offset: 0x50 - LCD Interface Next Buffer Address Register
        volatile uint32_t VDCTRL0;  ///< Offset: 0x70 - LCDIF VSYNC Mode and Dotclk Mode Control Register0
        volatile uint32_t VDCTRL0_SET;  ///< Offset: 0x74 - LCDIF VSYNC Mode and Dotclk Mode Control Register0
        volatile uint32_t VDCTRL0_CLR;  ///< Offset: 0x78 - LCDIF VSYNC Mode and Dotclk Mode Control Register0
        volatile uint32_t VDCTRL0_TOG;  ///< Offset: 0x7C - LCDIF VSYNC Mode and Dotclk Mode Control Register0
        volatile uint32_t VDCTRL1;  ///< Offset: 0x80 - LCDIF VSYNC Mode and Dotclk Mode Control Register1
        volatile uint32_t VDCTRL2;  ///< Offset: 0x90 - LCDIF VSYNC Mode and Dotclk Mode Control Register2
        volatile uint32_t VDCTRL3;  ///< Offset: 0xA0 - LCDIF VSYNC Mode and Dotclk Mode Control Register3
        volatile uint32_t VDCTRL4;  ///< Offset: 0xB0 - LCDIF VSYNC Mode and Dotclk Mode Control Register4
        volatile uint32_t BM_ERROR_STAT;  ///< Offset: 0x190 - Bus Master Error Status Register
        volatile uint32_t CRC_STAT;  ///< Offset: 0x1A0 - CRC Status Register
        volatile uint32_t STAT;  ///< Offset: 0x1B0 - LCD Interface Status Register
        volatile uint32_t PIGEONCTRL0;  ///< Offset: 0x380 - LCDIF Pigeon Mode Control0 Register
        volatile uint32_t PIGEONCTRL0_SET;  ///< Offset: 0x384 - LCDIF Pigeon Mode Control0 Register
        volatile uint32_t PIGEONCTRL0_CLR;  ///< Offset: 0x388 - LCDIF Pigeon Mode Control0 Register
        volatile uint32_t PIGEONCTRL0_TOG;  ///< Offset: 0x38C - LCDIF Pigeon Mode Control0 Register
        volatile uint32_t PIGEONCTRL1;  ///< Offset: 0x390 - LCDIF Pigeon Mode Control1 Register
        volatile uint32_t PIGEONCTRL1_SET;  ///< Offset: 0x394 - LCDIF Pigeon Mode Control1 Register
        volatile uint32_t PIGEONCTRL1_CLR;  ///< Offset: 0x398 - LCDIF Pigeon Mode Control1 Register
        volatile uint32_t PIGEONCTRL1_TOG;  ///< Offset: 0x39C - LCDIF Pigeon Mode Control1 Register
        volatile uint32_t PIGEONCTRL2;  ///< Offset: 0x3A0 - LCDIF Pigeon Mode Control2 Register
        volatile uint32_t PIGEONCTRL2_SET;  ///< Offset: 0x3A4 - LCDIF Pigeon Mode Control2 Register
        volatile uint32_t PIGEONCTRL2_CLR;  ///< Offset: 0x3A8 - LCDIF Pigeon Mode Control2 Register
        volatile uint32_t PIGEONCTRL2_TOG;  ///< Offset: 0x3AC - LCDIF Pigeon Mode Control2 Register
        volatile uint32_t PIGEON_0_0;  ///< Offset: 0x800 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_0_1;  ///< Offset: 0x810 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_0_2;  ///< Offset: 0x820 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_1_0;  ///< Offset: 0x840 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_1_1;  ///< Offset: 0x850 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_1_2;  ///< Offset: 0x860 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_2_0;  ///< Offset: 0x880 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_2_1;  ///< Offset: 0x890 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_2_2;  ///< Offset: 0x8A0 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_3_0;  ///< Offset: 0x8C0 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_3_1;  ///< Offset: 0x8D0 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_3_2;  ///< Offset: 0x8E0 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_4_0;  ///< Offset: 0x900 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_4_1;  ///< Offset: 0x910 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_4_2;  ///< Offset: 0x920 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_5_0;  ///< Offset: 0x940 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_5_1;  ///< Offset: 0x950 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_5_2;  ///< Offset: 0x960 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_6_0;  ///< Offset: 0x980 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_6_1;  ///< Offset: 0x990 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_6_2;  ///< Offset: 0x9A0 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_7_0;  ///< Offset: 0x9C0 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_7_1;  ///< Offset: 0x9D0 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_7_2;  ///< Offset: 0x9E0 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_8_0;  ///< Offset: 0xA00 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_8_1;  ///< Offset: 0xA10 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_8_2;  ///< Offset: 0xA20 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_9_0;  ///< Offset: 0xA40 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_9_1;  ///< Offset: 0xA50 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_9_2;  ///< Offset: 0xA60 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_10_0;  ///< Offset: 0xA80 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_10_1;  ///< Offset: 0xA90 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_10_2;  ///< Offset: 0xAA0 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_11_0;  ///< Offset: 0xAC0 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_11_1;  ///< Offset: 0xAD0 - Panel Interface Signal Generator Register
        volatile uint32_t PIGEON_11_2;  ///< Offset: 0xAE0 - Panel Interface Signal Generator Register
        volatile uint32_t LUT_CTRL;  ///< Offset: 0xB00 - Lookup Table Data Register.
        volatile uint32_t LUT0_ADDR;  ///< Offset: 0xB10 - Lookup Table Control Register.
        volatile uint32_t LUT0_DATA;  ///< Offset: 0xB20 - Lookup Table Data Register.
        volatile uint32_t LUT1_ADDR;  ///< Offset: 0xB30 - Lookup Table Control Register.
        volatile uint32_t LUT1_DATA;  ///< Offset: 0xB40 - Lookup Table Data Register.
    };

    /// Peripheral instances
    inline Registers* LCDIF = reinterpret_cast<Registers*>(LCDIF_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t RUN = (1U << 0);  ///< When this bit is set by software, the LCDIF will begin transferring data between the SoC and the display
        constexpr uint32_t DATA_FORMAT_24_BIT = (1U << 1);  ///< Used only when WORD_LENGTH = 3, i
        constexpr uint32_t DATA_FORMAT_18_BIT = (1U << 2);  ///< Used only when WORD_LENGTH = 2, i.e. 18-bit.
        constexpr uint32_t DATA_FORMAT_16_BIT = (1U << 3);  ///< When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data is in ARGB555 format
        constexpr uint32_t MASTER = (1U << 5);  ///< Set this bit to make the LCDIF act as a bus master
        constexpr uint32_t ENABLE_PXP_HANDSHAKE = (1U << 6);  ///< If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as bus master and the handshake mechanism between LCDIF and PXP will be turned on
        constexpr uint32_t WORD_LENGTH = (2 << 8);  ///< Input data format.
        constexpr uint32_t LCD_DATABUS_WIDTH = (2 << 10);  ///< LCD Data bus transfer width.
        constexpr uint32_t CSC_DATA_SWIZZLE = (2 << 12);  ///< This field specifies how to swap the bytes after the data has been converted into an internal representation of 24 bits per pixel and before it is transmitted over the LCD interface bus
        constexpr uint32_t INPUT_DATA_SWIZZLE = (2 << 14);  ///< This field specifies how to swap the bytes fetched by the bus master interface
        constexpr uint32_t DOTCLK_MODE = (1U << 17);  ///< Set this bit to 1 to make the hardware go into the DOTCLK mode, i
        constexpr uint32_t BYPASS_COUNT = (1U << 19);  ///< When this bit is 0, it means that LCDIF will stop the block operation and turn off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT register has been transferred out
        constexpr uint32_t SHIFT_NUM_BITS = (5 << 21);  ///< The data to be transmitted is shifted left or right by this number of bits.
        constexpr uint32_t DATA_SHIFT_DIR = (1U << 26);  ///< Use this bit to determine the direction of shift of transmit data.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< This bit must be set to zero to enable normal operation of the LCDIF
    }

    /// CTRL_SET Register bits
    namespace ctrl_set_bits {
        constexpr uint32_t RUN = (1U << 0);  ///< When this bit is set by software, the LCDIF will begin transferring data between the SoC and the display
        constexpr uint32_t DATA_FORMAT_24_BIT = (1U << 1);  ///< Used only when WORD_LENGTH = 3, i
        constexpr uint32_t DATA_FORMAT_18_BIT = (1U << 2);  ///< Used only when WORD_LENGTH = 2, i.e. 18-bit.
        constexpr uint32_t DATA_FORMAT_16_BIT = (1U << 3);  ///< When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data is in ARGB555 format
        constexpr uint32_t MASTER = (1U << 5);  ///< Set this bit to make the LCDIF act as a bus master
        constexpr uint32_t ENABLE_PXP_HANDSHAKE = (1U << 6);  ///< If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as bus master and the handshake mechanism between LCDIF and PXP will be turned on
        constexpr uint32_t WORD_LENGTH = (2 << 8);  ///< Input data format.
        constexpr uint32_t LCD_DATABUS_WIDTH = (2 << 10);  ///< LCD Data bus transfer width.
        constexpr uint32_t CSC_DATA_SWIZZLE = (2 << 12);  ///< This field specifies how to swap the bytes after the data has been converted into an internal representation of 24 bits per pixel and before it is transmitted over the LCD interface bus
        constexpr uint32_t INPUT_DATA_SWIZZLE = (2 << 14);  ///< This field specifies how to swap the bytes fetched by the bus master interface
        constexpr uint32_t DOTCLK_MODE = (1U << 17);  ///< Set this bit to 1 to make the hardware go into the DOTCLK mode, i
        constexpr uint32_t BYPASS_COUNT = (1U << 19);  ///< When this bit is 0, it means that LCDIF will stop the block operation and turn off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT register has been transferred out
        constexpr uint32_t SHIFT_NUM_BITS = (5 << 21);  ///< The data to be transmitted is shifted left or right by this number of bits.
        constexpr uint32_t DATA_SHIFT_DIR = (1U << 26);  ///< Use this bit to determine the direction of shift of transmit data.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< This bit must be set to zero to enable normal operation of the LCDIF
    }

    /// CTRL_CLR Register bits
    namespace ctrl_clr_bits {
        constexpr uint32_t RUN = (1U << 0);  ///< When this bit is set by software, the LCDIF will begin transferring data between the SoC and the display
        constexpr uint32_t DATA_FORMAT_24_BIT = (1U << 1);  ///< Used only when WORD_LENGTH = 3, i
        constexpr uint32_t DATA_FORMAT_18_BIT = (1U << 2);  ///< Used only when WORD_LENGTH = 2, i.e. 18-bit.
        constexpr uint32_t DATA_FORMAT_16_BIT = (1U << 3);  ///< When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data is in ARGB555 format
        constexpr uint32_t MASTER = (1U << 5);  ///< Set this bit to make the LCDIF act as a bus master
        constexpr uint32_t ENABLE_PXP_HANDSHAKE = (1U << 6);  ///< If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as bus master and the handshake mechanism between LCDIF and PXP will be turned on
        constexpr uint32_t WORD_LENGTH = (2 << 8);  ///< Input data format.
        constexpr uint32_t LCD_DATABUS_WIDTH = (2 << 10);  ///< LCD Data bus transfer width.
        constexpr uint32_t CSC_DATA_SWIZZLE = (2 << 12);  ///< This field specifies how to swap the bytes after the data has been converted into an internal representation of 24 bits per pixel and before it is transmitted over the LCD interface bus
        constexpr uint32_t INPUT_DATA_SWIZZLE = (2 << 14);  ///< This field specifies how to swap the bytes fetched by the bus master interface
        constexpr uint32_t DOTCLK_MODE = (1U << 17);  ///< Set this bit to 1 to make the hardware go into the DOTCLK mode, i
        constexpr uint32_t BYPASS_COUNT = (1U << 19);  ///< When this bit is 0, it means that LCDIF will stop the block operation and turn off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT register has been transferred out
        constexpr uint32_t SHIFT_NUM_BITS = (5 << 21);  ///< The data to be transmitted is shifted left or right by this number of bits.
        constexpr uint32_t DATA_SHIFT_DIR = (1U << 26);  ///< Use this bit to determine the direction of shift of transmit data.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< This bit must be set to zero to enable normal operation of the LCDIF
    }

    /// CTRL_TOG Register bits
    namespace ctrl_tog_bits {
        constexpr uint32_t RUN = (1U << 0);  ///< When this bit is set by software, the LCDIF will begin transferring data between the SoC and the display
        constexpr uint32_t DATA_FORMAT_24_BIT = (1U << 1);  ///< Used only when WORD_LENGTH = 3, i
        constexpr uint32_t DATA_FORMAT_18_BIT = (1U << 2);  ///< Used only when WORD_LENGTH = 2, i.e. 18-bit.
        constexpr uint32_t DATA_FORMAT_16_BIT = (1U << 3);  ///< When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data is in ARGB555 format
        constexpr uint32_t MASTER = (1U << 5);  ///< Set this bit to make the LCDIF act as a bus master
        constexpr uint32_t ENABLE_PXP_HANDSHAKE = (1U << 6);  ///< If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as bus master and the handshake mechanism between LCDIF and PXP will be turned on
        constexpr uint32_t WORD_LENGTH = (2 << 8);  ///< Input data format.
        constexpr uint32_t LCD_DATABUS_WIDTH = (2 << 10);  ///< LCD Data bus transfer width.
        constexpr uint32_t CSC_DATA_SWIZZLE = (2 << 12);  ///< This field specifies how to swap the bytes after the data has been converted into an internal representation of 24 bits per pixel and before it is transmitted over the LCD interface bus
        constexpr uint32_t INPUT_DATA_SWIZZLE = (2 << 14);  ///< This field specifies how to swap the bytes fetched by the bus master interface
        constexpr uint32_t DOTCLK_MODE = (1U << 17);  ///< Set this bit to 1 to make the hardware go into the DOTCLK mode, i
        constexpr uint32_t BYPASS_COUNT = (1U << 19);  ///< When this bit is 0, it means that LCDIF will stop the block operation and turn off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT register has been transferred out
        constexpr uint32_t SHIFT_NUM_BITS = (5 << 21);  ///< The data to be transmitted is shifted left or right by this number of bits.
        constexpr uint32_t DATA_SHIFT_DIR = (1U << 26);  ///< Use this bit to determine the direction of shift of transmit data.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< This bit must be set to zero to enable normal operation of the LCDIF
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t VSYNC_EDGE_IRQ = (1U << 8);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t CUR_FRAME_DONE_IRQ = (1U << 9);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t UNDERFLOW_IRQ = (1U << 10);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t OVERFLOW_IRQ = (1U << 11);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t VSYNC_EDGE_IRQ_EN = (1U << 12);  ///< This bit is set to enable an interrupt every time the hardware encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the beginning of every field in DVI mode
        constexpr uint32_t CUR_FRAME_DONE_IRQ_EN = (1U << 13);  ///< This bit is set to 1 enable an interrupt every time the hardware enters in the vertical blanking state
        constexpr uint32_t UNDERFLOW_IRQ_EN = (1U << 14);  ///< This bit is set to enable an underflow interrupt in the TXFIFO in the write mode.
        constexpr uint32_t OVERFLOW_IRQ_EN = (1U << 15);  ///< This bit is set to enable an overflow interrupt in the TXFIFO in the write mode.
        constexpr uint32_t BYTE_PACKING_FORMAT = (4 << 16);  ///< This bitfield is used to show which data bytes in a 32-bit word are valid
        constexpr uint32_t IRQ_ON_ALTERNATE_FIELDS = (1U << 20);  ///< If this bit is set, the LCDIF block will assert the cur_frame_done interrupt only on alternate fields, otherwise it will issue the interrupt on both odd and even field
        constexpr uint32_t FIFO_CLEAR = (1U << 21);  ///< Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO and the RXFIFO.
        constexpr uint32_t START_INTERLACE_FROM_SECOND_FIELD = (1U << 22);  ///< The default is to grab the odd lines first and then the even lines
        constexpr uint32_t INTERLACE_FIELDS = (1U << 23);  ///< Set this bit if it is required that the LCDIF block fetches odd lines in one field and even lines in the other field
        constexpr uint32_t RECOVER_ON_UNDERFLOW = (1U << 24);  ///< Set this bit to enable the LCDIF block to recover in the next field/frame if there was an underflow in the current field/frame
        constexpr uint32_t BM_ERROR_IRQ = (1U << 25);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t BM_ERROR_IRQ_EN = (1U << 26);  ///< This bit is set to enable bus master error interrupt in the LCDIF master mode.
        constexpr uint32_t CS_OUT_SELECT = (1U << 30);  ///< This bit is CS0/CS1 valid select signals
        constexpr uint32_t IMAGE_DATA_SELECT = (1U << 31);  ///< Command Mode MIPI image data select bit
    }

    /// CTRL1_SET Register bits
    namespace ctrl1_set_bits {
        constexpr uint32_t VSYNC_EDGE_IRQ = (1U << 8);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t CUR_FRAME_DONE_IRQ = (1U << 9);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t UNDERFLOW_IRQ = (1U << 10);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t OVERFLOW_IRQ = (1U << 11);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t VSYNC_EDGE_IRQ_EN = (1U << 12);  ///< This bit is set to enable an interrupt every time the hardware encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the beginning of every field in DVI mode
        constexpr uint32_t CUR_FRAME_DONE_IRQ_EN = (1U << 13);  ///< This bit is set to 1 enable an interrupt every time the hardware enters in the vertical blanking state
        constexpr uint32_t UNDERFLOW_IRQ_EN = (1U << 14);  ///< This bit is set to enable an underflow interrupt in the TXFIFO in the write mode.
        constexpr uint32_t OVERFLOW_IRQ_EN = (1U << 15);  ///< This bit is set to enable an overflow interrupt in the TXFIFO in the write mode.
        constexpr uint32_t BYTE_PACKING_FORMAT = (4 << 16);  ///< This bitfield is used to show which data bytes in a 32-bit word are valid
        constexpr uint32_t IRQ_ON_ALTERNATE_FIELDS = (1U << 20);  ///< If this bit is set, the LCDIF block will assert the cur_frame_done interrupt only on alternate fields, otherwise it will issue the interrupt on both odd and even field
        constexpr uint32_t FIFO_CLEAR = (1U << 21);  ///< Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO and the RXFIFO.
        constexpr uint32_t START_INTERLACE_FROM_SECOND_FIELD = (1U << 22);  ///< The default is to grab the odd lines first and then the even lines
        constexpr uint32_t INTERLACE_FIELDS = (1U << 23);  ///< Set this bit if it is required that the LCDIF block fetches odd lines in one field and even lines in the other field
        constexpr uint32_t RECOVER_ON_UNDERFLOW = (1U << 24);  ///< Set this bit to enable the LCDIF block to recover in the next field/frame if there was an underflow in the current field/frame
        constexpr uint32_t BM_ERROR_IRQ = (1U << 25);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t BM_ERROR_IRQ_EN = (1U << 26);  ///< This bit is set to enable bus master error interrupt in the LCDIF master mode.
        constexpr uint32_t CS_OUT_SELECT = (1U << 30);  ///< This bit is CS0/CS1 valid select signals
        constexpr uint32_t IMAGE_DATA_SELECT = (1U << 31);  ///< Command Mode MIPI image data select bit
    }

    /// CTRL1_CLR Register bits
    namespace ctrl1_clr_bits {
        constexpr uint32_t VSYNC_EDGE_IRQ = (1U << 8);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t CUR_FRAME_DONE_IRQ = (1U << 9);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t UNDERFLOW_IRQ = (1U << 10);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t OVERFLOW_IRQ = (1U << 11);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t VSYNC_EDGE_IRQ_EN = (1U << 12);  ///< This bit is set to enable an interrupt every time the hardware encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the beginning of every field in DVI mode
        constexpr uint32_t CUR_FRAME_DONE_IRQ_EN = (1U << 13);  ///< This bit is set to 1 enable an interrupt every time the hardware enters in the vertical blanking state
        constexpr uint32_t UNDERFLOW_IRQ_EN = (1U << 14);  ///< This bit is set to enable an underflow interrupt in the TXFIFO in the write mode.
        constexpr uint32_t OVERFLOW_IRQ_EN = (1U << 15);  ///< This bit is set to enable an overflow interrupt in the TXFIFO in the write mode.
        constexpr uint32_t BYTE_PACKING_FORMAT = (4 << 16);  ///< This bitfield is used to show which data bytes in a 32-bit word are valid
        constexpr uint32_t IRQ_ON_ALTERNATE_FIELDS = (1U << 20);  ///< If this bit is set, the LCDIF block will assert the cur_frame_done interrupt only on alternate fields, otherwise it will issue the interrupt on both odd and even field
        constexpr uint32_t FIFO_CLEAR = (1U << 21);  ///< Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO and the RXFIFO.
        constexpr uint32_t START_INTERLACE_FROM_SECOND_FIELD = (1U << 22);  ///< The default is to grab the odd lines first and then the even lines
        constexpr uint32_t INTERLACE_FIELDS = (1U << 23);  ///< Set this bit if it is required that the LCDIF block fetches odd lines in one field and even lines in the other field
        constexpr uint32_t RECOVER_ON_UNDERFLOW = (1U << 24);  ///< Set this bit to enable the LCDIF block to recover in the next field/frame if there was an underflow in the current field/frame
        constexpr uint32_t BM_ERROR_IRQ = (1U << 25);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t BM_ERROR_IRQ_EN = (1U << 26);  ///< This bit is set to enable bus master error interrupt in the LCDIF master mode.
        constexpr uint32_t CS_OUT_SELECT = (1U << 30);  ///< This bit is CS0/CS1 valid select signals
        constexpr uint32_t IMAGE_DATA_SELECT = (1U << 31);  ///< Command Mode MIPI image data select bit
    }

    /// CTRL1_TOG Register bits
    namespace ctrl1_tog_bits {
        constexpr uint32_t VSYNC_EDGE_IRQ = (1U << 8);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t CUR_FRAME_DONE_IRQ = (1U << 9);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t UNDERFLOW_IRQ = (1U << 10);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t OVERFLOW_IRQ = (1U << 11);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t VSYNC_EDGE_IRQ_EN = (1U << 12);  ///< This bit is set to enable an interrupt every time the hardware encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the beginning of every field in DVI mode
        constexpr uint32_t CUR_FRAME_DONE_IRQ_EN = (1U << 13);  ///< This bit is set to 1 enable an interrupt every time the hardware enters in the vertical blanking state
        constexpr uint32_t UNDERFLOW_IRQ_EN = (1U << 14);  ///< This bit is set to enable an underflow interrupt in the TXFIFO in the write mode.
        constexpr uint32_t OVERFLOW_IRQ_EN = (1U << 15);  ///< This bit is set to enable an overflow interrupt in the TXFIFO in the write mode.
        constexpr uint32_t BYTE_PACKING_FORMAT = (4 << 16);  ///< This bitfield is used to show which data bytes in a 32-bit word are valid
        constexpr uint32_t IRQ_ON_ALTERNATE_FIELDS = (1U << 20);  ///< If this bit is set, the LCDIF block will assert the cur_frame_done interrupt only on alternate fields, otherwise it will issue the interrupt on both odd and even field
        constexpr uint32_t FIFO_CLEAR = (1U << 21);  ///< Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO and the RXFIFO.
        constexpr uint32_t START_INTERLACE_FROM_SECOND_FIELD = (1U << 22);  ///< The default is to grab the odd lines first and then the even lines
        constexpr uint32_t INTERLACE_FIELDS = (1U << 23);  ///< Set this bit if it is required that the LCDIF block fetches odd lines in one field and even lines in the other field
        constexpr uint32_t RECOVER_ON_UNDERFLOW = (1U << 24);  ///< Set this bit to enable the LCDIF block to recover in the next field/frame if there was an underflow in the current field/frame
        constexpr uint32_t BM_ERROR_IRQ = (1U << 25);  ///< This bit is set to indicate that an interrupt is requested by the LCDIF block
        constexpr uint32_t BM_ERROR_IRQ_EN = (1U << 26);  ///< This bit is set to enable bus master error interrupt in the LCDIF master mode.
        constexpr uint32_t CS_OUT_SELECT = (1U << 30);  ///< This bit is CS0/CS1 valid select signals
        constexpr uint32_t IMAGE_DATA_SELECT = (1U << 31);  ///< Command Mode MIPI image data select bit
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t EVEN_LINE_PATTERN = (3 << 12);  ///< This field determines the order of the RGB components of each pixel in EVEN lines (line numbers 2,4,6,
        constexpr uint32_t ODD_LINE_PATTERN = (3 << 16);  ///< This field determines the order of the RGB components of each pixel in ODD lines (line numbers 1,3,5,
        constexpr uint32_t BURST_LEN_8 = (1U << 20);  ///< By default, when the LCDIF is in the bus master mode, it will issue AXI bursts of length 16 (except when in packed 24 bpp mode, it will issue bursts of length 15)
        constexpr uint32_t OUTSTANDING_REQS = (3 << 21);  ///< This bitfield indicates the maximum number of outstanding transactions that LCDIF should request when it is acting as a bus master
    }

    /// CTRL2_SET Register bits
    namespace ctrl2_set_bits {
        constexpr uint32_t EVEN_LINE_PATTERN = (3 << 12);  ///< This field determines the order of the RGB components of each pixel in EVEN lines (line numbers 2,4,6,
        constexpr uint32_t ODD_LINE_PATTERN = (3 << 16);  ///< This field determines the order of the RGB components of each pixel in ODD lines (line numbers 1,3,5,
        constexpr uint32_t BURST_LEN_8 = (1U << 20);  ///< By default, when the LCDIF is in the bus master mode, it will issue AXI bursts of length 16 (except when in packed 24 bpp mode, it will issue bursts of length 15)
        constexpr uint32_t OUTSTANDING_REQS = (3 << 21);  ///< This bitfield indicates the maximum number of outstanding transactions that LCDIF should request when it is acting as a bus master
    }

    /// CTRL2_CLR Register bits
    namespace ctrl2_clr_bits {
        constexpr uint32_t EVEN_LINE_PATTERN = (3 << 12);  ///< This field determines the order of the RGB components of each pixel in EVEN lines (line numbers 2,4,6,
        constexpr uint32_t ODD_LINE_PATTERN = (3 << 16);  ///< This field determines the order of the RGB components of each pixel in ODD lines (line numbers 1,3,5,
        constexpr uint32_t BURST_LEN_8 = (1U << 20);  ///< By default, when the LCDIF is in the bus master mode, it will issue AXI bursts of length 16 (except when in packed 24 bpp mode, it will issue bursts of length 15)
        constexpr uint32_t OUTSTANDING_REQS = (3 << 21);  ///< This bitfield indicates the maximum number of outstanding transactions that LCDIF should request when it is acting as a bus master
    }

    /// CTRL2_TOG Register bits
    namespace ctrl2_tog_bits {
        constexpr uint32_t EVEN_LINE_PATTERN = (3 << 12);  ///< This field determines the order of the RGB components of each pixel in EVEN lines (line numbers 2,4,6,
        constexpr uint32_t ODD_LINE_PATTERN = (3 << 16);  ///< This field determines the order of the RGB components of each pixel in ODD lines (line numbers 1,3,5,
        constexpr uint32_t BURST_LEN_8 = (1U << 20);  ///< By default, when the LCDIF is in the bus master mode, it will issue AXI bursts of length 16 (except when in packed 24 bpp mode, it will issue bursts of length 15)
        constexpr uint32_t OUTSTANDING_REQS = (3 << 21);  ///< This bitfield indicates the maximum number of outstanding transactions that LCDIF should request when it is acting as a bus master
    }

    /// TRANSFER_COUNT Register bits
    namespace transfer_count_bits {
        constexpr uint32_t H_COUNT = (16 << 0);  ///< Total valid data (pixels) in each horizontal line
        constexpr uint32_t V_COUNT = (16 << 16);  ///< Number of horizontal lines per frame which contain valid data
    }

    /// CUR_BUF Register bits
    namespace cur_buf_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Address of the current frame being transmitted by LCDIF.
    }

    /// NEXT_BUF Register bits
    namespace next_buf_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Address of the next frame that will be transmitted by LCDIF.
    }

    /// VDCTRL0 Register bits
    namespace vdctrl0_bits {
        constexpr uint32_t VSYNC_PULSE_WIDTH = (18 << 0);  ///< Number of units for which VSYNC signal is active
        constexpr uint32_t HALF_LINE_MODE = (1U << 18);  ///< When this bit is 0, the first field (VSYNC period) will end in half a horizontal line and the second field will begin with half a horizontal line
        constexpr uint32_t HALF_LINE = (1U << 19);  ///< Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
        constexpr uint32_t VSYNC_PULSE_WIDTH_UNIT = (1U << 20);  ///< Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pix_clk) cycles
        constexpr uint32_t VSYNC_PERIOD_UNIT = (1U << 21);  ///< Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk) cycles
        constexpr uint32_t ENABLE_POL = (1U << 24);  ///< Default 0 active low during valid data transfer on each horizontal line.
        constexpr uint32_t DOTCLK_POL = (1U << 25);  ///< Default is data launched at negative edge of DOTCLK and captured at positive edge
        constexpr uint32_t HSYNC_POL = (1U << 26);  ///< Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the rest of the HSYNC period
        constexpr uint32_t VSYNC_POL = (1U << 27);  ///< Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the rest of the VSYNC period
        constexpr uint32_t ENABLE_PRESENT = (1U << 28);  ///< Setting this bit to 1 will make the hardware generate the ENABLE signal in the DOTCLK mode, thereby making it the true RGB interface along with the remaining three signals VSYNC, HSYNC and DOTCLK
    }

    /// VDCTRL0_SET Register bits
    namespace vdctrl0_set_bits {
        constexpr uint32_t VSYNC_PULSE_WIDTH = (18 << 0);  ///< Number of units for which VSYNC signal is active
        constexpr uint32_t HALF_LINE_MODE = (1U << 18);  ///< When this bit is 0, the first field (VSYNC period) will end in half a horizontal line and the second field will begin with half a horizontal line
        constexpr uint32_t HALF_LINE = (1U << 19);  ///< Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
        constexpr uint32_t VSYNC_PULSE_WIDTH_UNIT = (1U << 20);  ///< Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pix_clk) cycles
        constexpr uint32_t VSYNC_PERIOD_UNIT = (1U << 21);  ///< Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk) cycles
        constexpr uint32_t ENABLE_POL = (1U << 24);  ///< Default 0 active low during valid data transfer on each horizontal line.
        constexpr uint32_t DOTCLK_POL = (1U << 25);  ///< Default is data launched at negative edge of DOTCLK and captured at positive edge
        constexpr uint32_t HSYNC_POL = (1U << 26);  ///< Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the rest of the HSYNC period
        constexpr uint32_t VSYNC_POL = (1U << 27);  ///< Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the rest of the VSYNC period
        constexpr uint32_t ENABLE_PRESENT = (1U << 28);  ///< Setting this bit to 1 will make the hardware generate the ENABLE signal in the DOTCLK mode, thereby making it the true RGB interface along with the remaining three signals VSYNC, HSYNC and DOTCLK
    }

    /// VDCTRL0_CLR Register bits
    namespace vdctrl0_clr_bits {
        constexpr uint32_t VSYNC_PULSE_WIDTH = (18 << 0);  ///< Number of units for which VSYNC signal is active
        constexpr uint32_t HALF_LINE_MODE = (1U << 18);  ///< When this bit is 0, the first field (VSYNC period) will end in half a horizontal line and the second field will begin with half a horizontal line
        constexpr uint32_t HALF_LINE = (1U << 19);  ///< Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
        constexpr uint32_t VSYNC_PULSE_WIDTH_UNIT = (1U << 20);  ///< Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pix_clk) cycles
        constexpr uint32_t VSYNC_PERIOD_UNIT = (1U << 21);  ///< Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk) cycles
        constexpr uint32_t ENABLE_POL = (1U << 24);  ///< Default 0 active low during valid data transfer on each horizontal line.
        constexpr uint32_t DOTCLK_POL = (1U << 25);  ///< Default is data launched at negative edge of DOTCLK and captured at positive edge
        constexpr uint32_t HSYNC_POL = (1U << 26);  ///< Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the rest of the HSYNC period
        constexpr uint32_t VSYNC_POL = (1U << 27);  ///< Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the rest of the VSYNC period
        constexpr uint32_t ENABLE_PRESENT = (1U << 28);  ///< Setting this bit to 1 will make the hardware generate the ENABLE signal in the DOTCLK mode, thereby making it the true RGB interface along with the remaining three signals VSYNC, HSYNC and DOTCLK
    }

    /// VDCTRL0_TOG Register bits
    namespace vdctrl0_tog_bits {
        constexpr uint32_t VSYNC_PULSE_WIDTH = (18 << 0);  ///< Number of units for which VSYNC signal is active
        constexpr uint32_t HALF_LINE_MODE = (1U << 18);  ///< When this bit is 0, the first field (VSYNC period) will end in half a horizontal line and the second field will begin with half a horizontal line
        constexpr uint32_t HALF_LINE = (1U << 19);  ///< Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
        constexpr uint32_t VSYNC_PULSE_WIDTH_UNIT = (1U << 20);  ///< Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pix_clk) cycles
        constexpr uint32_t VSYNC_PERIOD_UNIT = (1U << 21);  ///< Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk) cycles
        constexpr uint32_t ENABLE_POL = (1U << 24);  ///< Default 0 active low during valid data transfer on each horizontal line.
        constexpr uint32_t DOTCLK_POL = (1U << 25);  ///< Default is data launched at negative edge of DOTCLK and captured at positive edge
        constexpr uint32_t HSYNC_POL = (1U << 26);  ///< Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the rest of the HSYNC period
        constexpr uint32_t VSYNC_POL = (1U << 27);  ///< Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the rest of the VSYNC period
        constexpr uint32_t ENABLE_PRESENT = (1U << 28);  ///< Setting this bit to 1 will make the hardware generate the ENABLE signal in the DOTCLK mode, thereby making it the true RGB interface along with the remaining three signals VSYNC, HSYNC and DOTCLK
    }

    /// VDCTRL1 Register bits
    namespace vdctrl1_bits {
        constexpr uint32_t VSYNC_PERIOD = (32 << 0);  ///< Total number of units between two positive or two negative edges of the VSYNC signal
    }

    /// VDCTRL2 Register bits
    namespace vdctrl2_bits {
        constexpr uint32_t HSYNC_PERIOD = (18 << 0);  ///< Total number of DISPLAY CLOCK (pix_clk) cycles between two positive or two negative edges of the HSYNC signal
        constexpr uint32_t HSYNC_PULSE_WIDTH = (14 << 18);  ///< Number of DISPLAY CLOCK (pix_clk) cycles for which HSYNC signal is active.
    }

    /// VDCTRL3 Register bits
    namespace vdctrl3_bits {
        constexpr uint32_t VERTICAL_WAIT_CNT = (16 << 0);  ///< In the VSYNC interface mode, wait for this number of DISPLAY CLOCK (pix_clk) cycles from the falling VSYNC edge (or rising if VSYNC_POL is 1) before starting LCD transactions and is applicable only if WAIT_FOR_VSYNC_EDGE is set
        constexpr uint32_t HORIZONTAL_WAIT_CNT = (12 << 16);  ///< In the DOTCLK mode, wait for this number of clocks from falling edge (or rising if HSYNC_POL is 1) of HSYNC signal to account for horizontal back porch plus the number of DOTCLKs before the moving picture information begins
        constexpr uint32_t VSYNC_ONLY = (1U << 28);  ///< This bit must be set to 1 in the VSYNC mode of operation, and 0 in the DOTCLK mode of operation.
        constexpr uint32_t MUX_SYNC_SIGNALS = (1U << 29);  ///< When this bit is set, the LCDIF block will internally mux HSYNC with LCD_D14, DOTCLK with LCD_D13 and ENABLE with LCD_D12, otherwise these signals will go out on separate pins
    }

    /// VDCTRL4 Register bits
    namespace vdctrl4_bits {
        constexpr uint32_t DOTCLK_H_VALID_DATA_CNT = (18 << 0);  ///< Total number of DISPLAY CLOCK (pix_clk) cycles on each horizontal line that carry valid data in DOTCLK mode
        constexpr uint32_t SYNC_SIGNALS_ON = (1U << 18);  ///< Set this field to 1 if the LCD controller requires that the VSYNC or VSYNC/HSYNC/DOTCLK control signals should be active at least one frame before the data transfers actually start and remain active at least one frame after the data transfers end
        constexpr uint32_t DOTCLK_DLY_SEL = (3 << 29);  ///< This bitfield selects the amount of time by which the DOTCLK signal should be delayed before coming out of the LCD_DOTCK pin
    }

    /// BM_ERROR_STAT Register bits
    namespace bm_error_stat_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Virtual address at which bus master error occurred.
    }

    /// CRC_STAT Register bits
    namespace crc_stat_bits {
        constexpr uint32_t CRC_VALUE = (32 << 0);  ///< Calculated CRC value.
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t LFIFO_COUNT = (9 << 0);  ///< Read only view of the current count in Latency buffer (LFIFO).
        constexpr uint32_t TXFIFO_EMPTY = (1U << 26);  ///< Read only view of the signals that indicates LCD TXFIFO is empty.
        constexpr uint32_t TXFIFO_FULL = (1U << 27);  ///< Read only view of the signals that indicates LCD TXFIFO is full.
        constexpr uint32_t LFIFO_EMPTY = (1U << 28);  ///< Read only view of the signals that indicates LCD LFIFO is empty.
        constexpr uint32_t LFIFO_FULL = (1U << 29);  ///< Read only view of the signals that indicates LCD LFIFO is full.
        constexpr uint32_t DMA_REQ = (1U << 30);  ///< Reflects the current state of the DMA Request line for the LCDIF
        constexpr uint32_t PRESENT = (1U << 31);  ///< 0: LCDIF not present on this product 1: LCDIF is present.
    }

    /// PIGEONCTRL0 Register bits
    namespace pigeonctrl0_bits {
        constexpr uint32_t FD_PERIOD = (12 << 0);  ///< Period of line counter during FD phase
        constexpr uint32_t LD_PERIOD = (12 << 16);  ///< Period of pclk counter during LD phase
    }

    /// PIGEONCTRL0_SET Register bits
    namespace pigeonctrl0_set_bits {
        constexpr uint32_t FD_PERIOD = (12 << 0);  ///< Period of line counter during FD phase
        constexpr uint32_t LD_PERIOD = (12 << 16);  ///< Period of pclk counter during LD phase
    }

    /// PIGEONCTRL0_CLR Register bits
    namespace pigeonctrl0_clr_bits {
        constexpr uint32_t FD_PERIOD = (12 << 0);  ///< Period of line counter during FD phase
        constexpr uint32_t LD_PERIOD = (12 << 16);  ///< Period of pclk counter during LD phase
    }

    /// PIGEONCTRL0_TOG Register bits
    namespace pigeonctrl0_tog_bits {
        constexpr uint32_t FD_PERIOD = (12 << 0);  ///< Period of line counter during FD phase
        constexpr uint32_t LD_PERIOD = (12 << 16);  ///< Period of pclk counter during LD phase
    }

    /// PIGEONCTRL1 Register bits
    namespace pigeonctrl1_bits {
        constexpr uint32_t FRAME_CNT_PERIOD = (12 << 0);  ///< Period of frame counter
        constexpr uint32_t FRAME_CNT_CYCLES = (12 << 16);  ///< Max cycles of frame counter
    }

    /// PIGEONCTRL1_SET Register bits
    namespace pigeonctrl1_set_bits {
        constexpr uint32_t FRAME_CNT_PERIOD = (12 << 0);  ///< Period of frame counter
        constexpr uint32_t FRAME_CNT_CYCLES = (12 << 16);  ///< Max cycles of frame counter
    }

    /// PIGEONCTRL1_CLR Register bits
    namespace pigeonctrl1_clr_bits {
        constexpr uint32_t FRAME_CNT_PERIOD = (12 << 0);  ///< Period of frame counter
        constexpr uint32_t FRAME_CNT_CYCLES = (12 << 16);  ///< Max cycles of frame counter
    }

    /// PIGEONCTRL1_TOG Register bits
    namespace pigeonctrl1_tog_bits {
        constexpr uint32_t FRAME_CNT_PERIOD = (12 << 0);  ///< Period of frame counter
        constexpr uint32_t FRAME_CNT_CYCLES = (12 << 16);  ///< Max cycles of frame counter
    }

    /// PIGEONCTRL2 Register bits
    namespace pigeonctrl2_bits {
        constexpr uint32_t PIGEON_DATA_EN = (1U << 0);  ///< Pigeon mode data enable
        constexpr uint32_t PIGEON_CLK_GATE = (1U << 1);  ///< Pigeon mode dot clock gate enable
    }

    /// PIGEONCTRL2_SET Register bits
    namespace pigeonctrl2_set_bits {
        constexpr uint32_t PIGEON_DATA_EN = (1U << 0);  ///< Pigeon mode data enable
        constexpr uint32_t PIGEON_CLK_GATE = (1U << 1);  ///< Pigeon mode dot clock gate enable
    }

    /// PIGEONCTRL2_CLR Register bits
    namespace pigeonctrl2_clr_bits {
        constexpr uint32_t PIGEON_DATA_EN = (1U << 0);  ///< Pigeon mode data enable
        constexpr uint32_t PIGEON_CLK_GATE = (1U << 1);  ///< Pigeon mode dot clock gate enable
    }

    /// PIGEONCTRL2_TOG Register bits
    namespace pigeonctrl2_tog_bits {
        constexpr uint32_t PIGEON_DATA_EN = (1U << 0);  ///< Pigeon mode data enable
        constexpr uint32_t PIGEON_CLK_GATE = (1U << 1);  ///< Pigeon mode dot clock gate enable
    }

    /// PIGEON_0_0 Register bits
    namespace pigeon_0_0_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable pigeon Mode on this signal
        constexpr uint32_t POL = (1U << 1);  ///< Polarity of signal output
        constexpr uint32_t INC_SEL = (2 << 2);  ///< Event to incrment local counter
        constexpr uint32_t OFFSET = (4 << 4);  ///< offset on pclk unit
        constexpr uint32_t MASK_CNT_SEL = (4 << 8);  ///< select global counters as mask condition, use together with MASK_CNT
        constexpr uint32_t MASK_CNT = (12 << 12);  ///< When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
        constexpr uint32_t STATE_MASK = (8 << 24);  ///< state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
    }

    /// PIGEON_0_1 Register bits
    namespace pigeon_0_1_bits {
        constexpr uint32_t SET_CNT = (16 << 0);  ///< Assert signal output when counter match this value
        constexpr uint32_t CLR_CNT = (16 << 16);  ///< Deassert signal output when counter match this value
    }

    /// PIGEON_0_2 Register bits
    namespace pigeon_0_2_bits {
        constexpr uint32_t SIG_LOGIC = (4 << 0);  ///< Logic operation with another signal: DIS/AND/OR/COND
        constexpr uint32_t SIG_ANOTHER = (5 << 4);  ///< Select another signal for logic operation or as mask or counter tick event
    }

    /// PIGEON_1_0 Register bits
    namespace pigeon_1_0_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable pigeon Mode on this signal
        constexpr uint32_t POL = (1U << 1);  ///< Polarity of signal output
        constexpr uint32_t INC_SEL = (2 << 2);  ///< Event to incrment local counter
        constexpr uint32_t OFFSET = (4 << 4);  ///< offset on pclk unit
        constexpr uint32_t MASK_CNT_SEL = (4 << 8);  ///< select global counters as mask condition, use together with MASK_CNT
        constexpr uint32_t MASK_CNT = (12 << 12);  ///< When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
        constexpr uint32_t STATE_MASK = (8 << 24);  ///< state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
    }

    /// PIGEON_1_1 Register bits
    namespace pigeon_1_1_bits {
        constexpr uint32_t SET_CNT = (16 << 0);  ///< Assert signal output when counter match this value
        constexpr uint32_t CLR_CNT = (16 << 16);  ///< Deassert signal output when counter match this value
    }

    /// PIGEON_1_2 Register bits
    namespace pigeon_1_2_bits {
        constexpr uint32_t SIG_LOGIC = (4 << 0);  ///< Logic operation with another signal: DIS/AND/OR/COND
        constexpr uint32_t SIG_ANOTHER = (5 << 4);  ///< Select another signal for logic operation or as mask or counter tick event
    }

    /// PIGEON_2_0 Register bits
    namespace pigeon_2_0_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable pigeon Mode on this signal
        constexpr uint32_t POL = (1U << 1);  ///< Polarity of signal output
        constexpr uint32_t INC_SEL = (2 << 2);  ///< Event to incrment local counter
        constexpr uint32_t OFFSET = (4 << 4);  ///< offset on pclk unit
        constexpr uint32_t MASK_CNT_SEL = (4 << 8);  ///< select global counters as mask condition, use together with MASK_CNT
        constexpr uint32_t MASK_CNT = (12 << 12);  ///< When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
        constexpr uint32_t STATE_MASK = (8 << 24);  ///< state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
    }

    /// PIGEON_2_1 Register bits
    namespace pigeon_2_1_bits {
        constexpr uint32_t SET_CNT = (16 << 0);  ///< Assert signal output when counter match this value
        constexpr uint32_t CLR_CNT = (16 << 16);  ///< Deassert signal output when counter match this value
    }

    /// PIGEON_2_2 Register bits
    namespace pigeon_2_2_bits {
        constexpr uint32_t SIG_LOGIC = (4 << 0);  ///< Logic operation with another signal: DIS/AND/OR/COND
        constexpr uint32_t SIG_ANOTHER = (5 << 4);  ///< Select another signal for logic operation or as mask or counter tick event
    }

    /// PIGEON_3_0 Register bits
    namespace pigeon_3_0_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable pigeon Mode on this signal
        constexpr uint32_t POL = (1U << 1);  ///< Polarity of signal output
        constexpr uint32_t INC_SEL = (2 << 2);  ///< Event to incrment local counter
        constexpr uint32_t OFFSET = (4 << 4);  ///< offset on pclk unit
        constexpr uint32_t MASK_CNT_SEL = (4 << 8);  ///< select global counters as mask condition, use together with MASK_CNT
        constexpr uint32_t MASK_CNT = (12 << 12);  ///< When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
        constexpr uint32_t STATE_MASK = (8 << 24);  ///< state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
    }

    /// PIGEON_3_1 Register bits
    namespace pigeon_3_1_bits {
        constexpr uint32_t SET_CNT = (16 << 0);  ///< Assert signal output when counter match this value
        constexpr uint32_t CLR_CNT = (16 << 16);  ///< Deassert signal output when counter match this value
    }

    /// PIGEON_3_2 Register bits
    namespace pigeon_3_2_bits {
        constexpr uint32_t SIG_LOGIC = (4 << 0);  ///< Logic operation with another signal: DIS/AND/OR/COND
        constexpr uint32_t SIG_ANOTHER = (5 << 4);  ///< Select another signal for logic operation or as mask or counter tick event
    }

    /// PIGEON_4_0 Register bits
    namespace pigeon_4_0_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable pigeon Mode on this signal
        constexpr uint32_t POL = (1U << 1);  ///< Polarity of signal output
        constexpr uint32_t INC_SEL = (2 << 2);  ///< Event to incrment local counter
        constexpr uint32_t OFFSET = (4 << 4);  ///< offset on pclk unit
        constexpr uint32_t MASK_CNT_SEL = (4 << 8);  ///< select global counters as mask condition, use together with MASK_CNT
        constexpr uint32_t MASK_CNT = (12 << 12);  ///< When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
        constexpr uint32_t STATE_MASK = (8 << 24);  ///< state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
    }

    /// PIGEON_4_1 Register bits
    namespace pigeon_4_1_bits {
        constexpr uint32_t SET_CNT = (16 << 0);  ///< Assert signal output when counter match this value
        constexpr uint32_t CLR_CNT = (16 << 16);  ///< Deassert signal output when counter match this value
    }

    /// PIGEON_4_2 Register bits
    namespace pigeon_4_2_bits {
        constexpr uint32_t SIG_LOGIC = (4 << 0);  ///< Logic operation with another signal: DIS/AND/OR/COND
        constexpr uint32_t SIG_ANOTHER = (5 << 4);  ///< Select another signal for logic operation or as mask or counter tick event
    }

    /// PIGEON_5_0 Register bits
    namespace pigeon_5_0_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable pigeon Mode on this signal
        constexpr uint32_t POL = (1U << 1);  ///< Polarity of signal output
        constexpr uint32_t INC_SEL = (2 << 2);  ///< Event to incrment local counter
        constexpr uint32_t OFFSET = (4 << 4);  ///< offset on pclk unit
        constexpr uint32_t MASK_CNT_SEL = (4 << 8);  ///< select global counters as mask condition, use together with MASK_CNT
        constexpr uint32_t MASK_CNT = (12 << 12);  ///< When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
        constexpr uint32_t STATE_MASK = (8 << 24);  ///< state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
    }

    /// PIGEON_5_1 Register bits
    namespace pigeon_5_1_bits {
        constexpr uint32_t SET_CNT = (16 << 0);  ///< Assert signal output when counter match this value
        constexpr uint32_t CLR_CNT = (16 << 16);  ///< Deassert signal output when counter match this value
    }

    /// PIGEON_5_2 Register bits
    namespace pigeon_5_2_bits {
        constexpr uint32_t SIG_LOGIC = (4 << 0);  ///< Logic operation with another signal: DIS/AND/OR/COND
        constexpr uint32_t SIG_ANOTHER = (5 << 4);  ///< Select another signal for logic operation or as mask or counter tick event
    }

    /// PIGEON_6_0 Register bits
    namespace pigeon_6_0_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable pigeon Mode on this signal
        constexpr uint32_t POL = (1U << 1);  ///< Polarity of signal output
        constexpr uint32_t INC_SEL = (2 << 2);  ///< Event to incrment local counter
        constexpr uint32_t OFFSET = (4 << 4);  ///< offset on pclk unit
        constexpr uint32_t MASK_CNT_SEL = (4 << 8);  ///< select global counters as mask condition, use together with MASK_CNT
        constexpr uint32_t MASK_CNT = (12 << 12);  ///< When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
        constexpr uint32_t STATE_MASK = (8 << 24);  ///< state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
    }

    /// PIGEON_6_1 Register bits
    namespace pigeon_6_1_bits {
        constexpr uint32_t SET_CNT = (16 << 0);  ///< Assert signal output when counter match this value
        constexpr uint32_t CLR_CNT = (16 << 16);  ///< Deassert signal output when counter match this value
    }

    /// PIGEON_6_2 Register bits
    namespace pigeon_6_2_bits {
        constexpr uint32_t SIG_LOGIC = (4 << 0);  ///< Logic operation with another signal: DIS/AND/OR/COND
        constexpr uint32_t SIG_ANOTHER = (5 << 4);  ///< Select another signal for logic operation or as mask or counter tick event
    }

    /// PIGEON_7_0 Register bits
    namespace pigeon_7_0_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable pigeon Mode on this signal
        constexpr uint32_t POL = (1U << 1);  ///< Polarity of signal output
        constexpr uint32_t INC_SEL = (2 << 2);  ///< Event to incrment local counter
        constexpr uint32_t OFFSET = (4 << 4);  ///< offset on pclk unit
        constexpr uint32_t MASK_CNT_SEL = (4 << 8);  ///< select global counters as mask condition, use together with MASK_CNT
        constexpr uint32_t MASK_CNT = (12 << 12);  ///< When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
        constexpr uint32_t STATE_MASK = (8 << 24);  ///< state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
    }

    /// PIGEON_7_1 Register bits
    namespace pigeon_7_1_bits {
        constexpr uint32_t SET_CNT = (16 << 0);  ///< Assert signal output when counter match this value
        constexpr uint32_t CLR_CNT = (16 << 16);  ///< Deassert signal output when counter match this value
    }

    /// PIGEON_7_2 Register bits
    namespace pigeon_7_2_bits {
        constexpr uint32_t SIG_LOGIC = (4 << 0);  ///< Logic operation with another signal: DIS/AND/OR/COND
        constexpr uint32_t SIG_ANOTHER = (5 << 4);  ///< Select another signal for logic operation or as mask or counter tick event
    }

    /// PIGEON_8_0 Register bits
    namespace pigeon_8_0_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable pigeon Mode on this signal
        constexpr uint32_t POL = (1U << 1);  ///< Polarity of signal output
        constexpr uint32_t INC_SEL = (2 << 2);  ///< Event to incrment local counter
        constexpr uint32_t OFFSET = (4 << 4);  ///< offset on pclk unit
        constexpr uint32_t MASK_CNT_SEL = (4 << 8);  ///< select global counters as mask condition, use together with MASK_CNT
        constexpr uint32_t MASK_CNT = (12 << 12);  ///< When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
        constexpr uint32_t STATE_MASK = (8 << 24);  ///< state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
    }

    /// PIGEON_8_1 Register bits
    namespace pigeon_8_1_bits {
        constexpr uint32_t SET_CNT = (16 << 0);  ///< Assert signal output when counter match this value
        constexpr uint32_t CLR_CNT = (16 << 16);  ///< Deassert signal output when counter match this value
    }

    /// PIGEON_8_2 Register bits
    namespace pigeon_8_2_bits {
        constexpr uint32_t SIG_LOGIC = (4 << 0);  ///< Logic operation with another signal: DIS/AND/OR/COND
        constexpr uint32_t SIG_ANOTHER = (5 << 4);  ///< Select another signal for logic operation or as mask or counter tick event
    }

    /// PIGEON_9_0 Register bits
    namespace pigeon_9_0_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable pigeon Mode on this signal
        constexpr uint32_t POL = (1U << 1);  ///< Polarity of signal output
        constexpr uint32_t INC_SEL = (2 << 2);  ///< Event to incrment local counter
        constexpr uint32_t OFFSET = (4 << 4);  ///< offset on pclk unit
        constexpr uint32_t MASK_CNT_SEL = (4 << 8);  ///< select global counters as mask condition, use together with MASK_CNT
        constexpr uint32_t MASK_CNT = (12 << 12);  ///< When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
        constexpr uint32_t STATE_MASK = (8 << 24);  ///< state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
    }

    /// PIGEON_9_1 Register bits
    namespace pigeon_9_1_bits {
        constexpr uint32_t SET_CNT = (16 << 0);  ///< Assert signal output when counter match this value
        constexpr uint32_t CLR_CNT = (16 << 16);  ///< Deassert signal output when counter match this value
    }

    /// PIGEON_9_2 Register bits
    namespace pigeon_9_2_bits {
        constexpr uint32_t SIG_LOGIC = (4 << 0);  ///< Logic operation with another signal: DIS/AND/OR/COND
        constexpr uint32_t SIG_ANOTHER = (5 << 4);  ///< Select another signal for logic operation or as mask or counter tick event
    }

    /// PIGEON_10_0 Register bits
    namespace pigeon_10_0_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable pigeon Mode on this signal
        constexpr uint32_t POL = (1U << 1);  ///< Polarity of signal output
        constexpr uint32_t INC_SEL = (2 << 2);  ///< Event to incrment local counter
        constexpr uint32_t OFFSET = (4 << 4);  ///< offset on pclk unit
        constexpr uint32_t MASK_CNT_SEL = (4 << 8);  ///< select global counters as mask condition, use together with MASK_CNT
        constexpr uint32_t MASK_CNT = (12 << 12);  ///< When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
        constexpr uint32_t STATE_MASK = (8 << 24);  ///< state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
    }

    /// PIGEON_10_1 Register bits
    namespace pigeon_10_1_bits {
        constexpr uint32_t SET_CNT = (16 << 0);  ///< Assert signal output when counter match this value
        constexpr uint32_t CLR_CNT = (16 << 16);  ///< Deassert signal output when counter match this value
    }

    /// PIGEON_10_2 Register bits
    namespace pigeon_10_2_bits {
        constexpr uint32_t SIG_LOGIC = (4 << 0);  ///< Logic operation with another signal: DIS/AND/OR/COND
        constexpr uint32_t SIG_ANOTHER = (5 << 4);  ///< Select another signal for logic operation or as mask or counter tick event
    }

    /// PIGEON_11_0 Register bits
    namespace pigeon_11_0_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable pigeon Mode on this signal
        constexpr uint32_t POL = (1U << 1);  ///< Polarity of signal output
        constexpr uint32_t INC_SEL = (2 << 2);  ///< Event to incrment local counter
        constexpr uint32_t OFFSET = (4 << 4);  ///< offset on pclk unit
        constexpr uint32_t MASK_CNT_SEL = (4 << 8);  ///< select global counters as mask condition, use together with MASK_CNT
        constexpr uint32_t MASK_CNT = (12 << 12);  ///< When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
        constexpr uint32_t STATE_MASK = (8 << 24);  ///< state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
    }

    /// PIGEON_11_1 Register bits
    namespace pigeon_11_1_bits {
        constexpr uint32_t SET_CNT = (16 << 0);  ///< Assert signal output when counter match this value
        constexpr uint32_t CLR_CNT = (16 << 16);  ///< Deassert signal output when counter match this value
    }

    /// PIGEON_11_2 Register bits
    namespace pigeon_11_2_bits {
        constexpr uint32_t SIG_LOGIC = (4 << 0);  ///< Logic operation with another signal: DIS/AND/OR/COND
        constexpr uint32_t SIG_ANOTHER = (5 << 4);  ///< Select another signal for logic operation or as mask or counter tick event
    }

    /// LUT_CTRL Register bits
    namespace lut_ctrl_bits {
        constexpr uint32_t LUT_BYPASS = (1U << 0);  ///< Setting this bit will bypass the LUT memory resource completely
    }

    /// LUT0_ADDR Register bits
    namespace lut0_addr_bits {
        constexpr uint32_t ADDR = (8 << 0);  ///< LUT indexed address pointer
    }

    /// LUT0_DATA Register bits
    namespace lut0_data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Writing this field will load 4 bytes, aligned to four byte boundaries, of data indexed by the ADDR field of the REG_LUT_CTRL register
    }

    /// LUT1_ADDR Register bits
    namespace lut1_addr_bits {
        constexpr uint32_t ADDR = (8 << 0);  ///< LUT indexed address pointer
    }

    /// LUT1_DATA Register bits
    namespace lut1_data_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Writing this field will load 4 bytes, aligned to four byte boundaries, of data indexed by the ADDR field of the REG_LUT_CTRL register
    }

}

// ============================================================================
// CSI Peripheral
// ============================================================================

namespace csi {
    /// Base addresses
    constexpr uint32_t CSI_BASE = 0x402BC000;

    /// CSI Register structure
    struct Registers {
        volatile uint32_t CSICR1;  ///< Offset: 0x00 - CSI Control Register 1
        volatile uint32_t CSICR2;  ///< Offset: 0x04 - CSI Control Register 2
        volatile uint32_t CSICR3;  ///< Offset: 0x08 - CSI Control Register 3
        volatile uint32_t CSISTATFIFO;  ///< Offset: 0x0C - CSI Statistic FIFO Register
        volatile uint32_t CSIRFIFO;  ///< Offset: 0x10 - CSI RX FIFO Register
        volatile uint32_t CSIRXCNT;  ///< Offset: 0x14 - CSI RX Count Register
        volatile uint32_t CSISR;  ///< Offset: 0x18 - CSI Status Register
        volatile uint32_t CSIDMASA_STATFIFO;  ///< Offset: 0x20 - CSI DMA Start Address Register - for STATFIFO
        volatile uint32_t CSIDMATS_STATFIFO;  ///< Offset: 0x24 - CSI DMA Transfer Size Register - for STATFIFO
        volatile uint32_t CSIDMASA_FB1;  ///< Offset: 0x28 - CSI DMA Start Address Register - for Frame Buffer1
        volatile uint32_t CSIDMASA_FB2;  ///< Offset: 0x2C - CSI DMA Transfer Size Register - for Frame Buffer2
        volatile uint32_t CSIFBUF_PARA;  ///< Offset: 0x30 - CSI Frame Buffer Parameter Register
        volatile uint32_t CSIIMAG_PARA;  ///< Offset: 0x34 - CSI Image Parameter Register
        volatile uint32_t CSICR18;  ///< Offset: 0x48 - CSI Control Register 18
        volatile uint32_t CSICR19;  ///< Offset: 0x4C - CSI Control Register 19
    };

    /// Peripheral instances
    inline Registers* CSI = reinterpret_cast<Registers*>(CSI_BASE);

    // Bit definitions
    /// CSICR1 Register bits
    namespace csicr1_bits {
        constexpr uint32_t PIXEL_BIT = (1U << 0);  ///< Pixel Bit
        constexpr uint32_t REDGE = (1U << 1);  ///< Valid Pixel Clock Edge Select
        constexpr uint32_t INV_PCLK = (1U << 2);  ///< Invert Pixel Clock Input
        constexpr uint32_t INV_DATA = (1U << 3);  ///< Invert Data Input. This bit enables or disables internal inverters on the data lines.
        constexpr uint32_t GCLK_MODE = (1U << 4);  ///< Gated Clock Mode Enable
        constexpr uint32_t CLR_RXFIFO = (1U << 5);  ///< Asynchronous RXFIFO Clear
        constexpr uint32_t CLR_STATFIFO = (1U << 6);  ///< Asynchronous STATFIFO Clear
        constexpr uint32_t PACK_DIR = (1U << 7);  ///< Data Packing Direction
        constexpr uint32_t FCC = (1U << 8);  ///< FIFO Clear Control
        constexpr uint32_t CCIR_EN = (1U << 10);  ///< CCIR656 Interface Enable
        constexpr uint32_t HSYNC_POL = (1U << 11);  ///< HSYNC Polarity Select
        constexpr uint32_t SOF_INTEN = (1U << 16);  ///< Start Of Frame (SOF) Interrupt Enable. This bit enables the SOF interrupt.
        constexpr uint32_t SOF_POL = (1U << 17);  ///< SOF Interrupt Polarity. This bit controls the condition that generates an SOF interrupt.
        constexpr uint32_t RXFF_INTEN = (1U << 18);  ///< RxFIFO Full Interrupt Enable. This bit enables the RxFIFO full interrupt.
        constexpr uint32_t FB1_DMA_DONE_INTEN = (1U << 19);  ///< Frame Buffer1 DMA Transfer Done Interrupt Enable
        constexpr uint32_t FB2_DMA_DONE_INTEN = (1U << 20);  ///< Frame Buffer2 DMA Transfer Done Interrupt Enable
        constexpr uint32_t STATFF_INTEN = (1U << 21);  ///< STATFIFO Full Interrupt Enable. This bit enables the STAT FIFO interrupt.
        constexpr uint32_t SFF_DMA_DONE_INTEN = (1U << 22);  ///< STATFIFO DMA Transfer Done Interrupt Enable
        constexpr uint32_t RF_OR_INTEN = (1U << 24);  ///< RxFIFO Overrun Interrupt Enable. This bit enables the RX FIFO overrun interrupt.
        constexpr uint32_t SF_OR_INTEN = (1U << 25);  ///< STAT FIFO Overrun Interrupt Enable. This bit enables the STATFIFO overrun interrupt.
        constexpr uint32_t COF_INT_EN = (1U << 26);  ///< Change Of Image Field (COF) Interrupt Enable
        constexpr uint32_t CCIR_MODE = (1U << 27);  ///< CCIR Mode Select
        constexpr uint32_t PrP_IF_EN = (1U << 28);  ///< CSI-PrP Interface Enable
        constexpr uint32_t EOF_INT_EN = (1U << 29);  ///< End-of-Frame Interrupt Enable. This bit enables and disables the EOF interrupt.
        constexpr uint32_t EXT_VSYNC = (1U << 30);  ///< External VSYNC Enable
        constexpr uint32_t SWAP16_EN = (1U << 31);  ///< SWAP 16-Bit Enable
    }

    /// CSICR2 Register bits
    namespace csicr2_bits {
        constexpr uint32_t HSC = (8 << 0);  ///< Horizontal Skip Count
        constexpr uint32_t VSC = (8 << 8);  ///< Vertical Skip Count. Contains the number of rows to skip. SCE must be 1, otherwise VSC is ignored.
        constexpr uint32_t LVRM = (3 << 16);  ///< Live View Resolution Mode. Selects the grid size used for live view resolution.
        constexpr uint32_t BTS = (2 << 19);  ///< Bayer Tile Start. Controls the Bayer pattern starting point.
        constexpr uint32_t SCE = (1U << 23);  ///< Skip Count Enable. Enables or disables the skip count feature.
        constexpr uint32_t AFS = (2 << 24);  ///< Auto Focus Spread. Selects which green pixels are used for auto-focus.
        constexpr uint32_t DRM = (1U << 26);  ///< Double Resolution Mode. Controls size of statistics grid.
        constexpr uint32_t DMA_BURST_TYPE_SFF = (2 << 28);  ///< Burst Type of DMA Transfer from STATFIFO. Selects the burst type of DMA transfer from STATFIFO.
        constexpr uint32_t DMA_BURST_TYPE_RFF = (2 << 30);  ///< Burst Type of DMA Transfer from RxFIFO. Selects the burst type of DMA transfer from RxFIFO.
    }

    /// CSICR3 Register bits
    namespace csicr3_bits {
        constexpr uint32_t ECC_AUTO_EN = (1U << 0);  ///< Automatic Error Correction Enable
        constexpr uint32_t ECC_INT_EN = (1U << 1);  ///< Error Detection Interrupt Enable
        constexpr uint32_t ZERO_PACK_EN = (1U << 2);  ///< Dummy Zero Packing Enable
        constexpr uint32_t TWO_8BIT_SENSOR = (1U << 3);  ///< Two 8-bit Sensor Mode
        constexpr uint32_t RxFF_LEVEL = (3 << 4);  ///< RxFIFO Full Level
        constexpr uint32_t HRESP_ERR_EN = (1U << 7);  ///< Hresponse Error Enable. This bit enables the hresponse error interrupt.
        constexpr uint32_t STATFF_LEVEL = (3 << 8);  ///< STATFIFO Full Level
        constexpr uint32_t DMA_REQ_EN_SFF = (1U << 11);  ///< DMA Request Enable for STATFIFO
        constexpr uint32_t DMA_REQ_EN_RFF = (1U << 12);  ///< DMA Request Enable for RxFIFO
        constexpr uint32_t DMA_REFLASH_SFF = (1U << 13);  ///< Reflash DMA Controller for STATFIFO
        constexpr uint32_t DMA_REFLASH_RFF = (1U << 14);  ///< Reflash DMA Controller for RxFIFO
        constexpr uint32_t FRMCNT_RST = (1U << 15);  ///< Frame Count Reset. Resets the Frame Counter. (Cleared automatically after reset is done)
        constexpr uint32_t FRMCNT = (16 << 16);  ///< Frame Counter
    }

    /// CSISTATFIFO Register bits
    namespace csistatfifo_bits {
        constexpr uint32_t STAT = (32 << 0);  ///< Static data from sensor
    }

    /// CSIRFIFO Register bits
    namespace csirfifo_bits {
        constexpr uint32_t IMAGE = (32 << 0);  ///< Received image data
    }

    /// CSIRXCNT Register bits
    namespace csirxcnt_bits {
        constexpr uint32_t RXCNT = (22 << 0);  ///< RxFIFO Count
    }

    /// CSISR Register bits
    namespace csisr_bits {
        constexpr uint32_t DRDY = (1U << 0);  ///< RXFIFO Data Ready
        constexpr uint32_t ECC_INT = (1U << 1);  ///< CCIR Error Interrupt
        constexpr uint32_t HRESP_ERR_INT = (1U << 7);  ///< Hresponse Error Interrupt Status
        constexpr uint32_t COF_INT = (1U << 13);  ///< Change Of Field Interrupt Status
        constexpr uint32_t F1_INT = (1U << 14);  ///< CCIR Field 1 Interrupt Status
        constexpr uint32_t F2_INT = (1U << 15);  ///< CCIR Field 2 Interrupt Status
        constexpr uint32_t SOF_INT = (1U << 16);  ///< Start of Frame Interrupt Status. Indicates when SOF is detected. (Cleared by writing 1)
        constexpr uint32_t EOF_INT = (1U << 17);  ///< End of Frame (EOF) Interrupt Status. Indicates when EOF is detected. (Cleared by writing 1)
        constexpr uint32_t RxFF_INT = (1U << 18);  ///< RXFIFO Full Interrupt Status
        constexpr uint32_t DMA_TSF_DONE_FB1 = (1U << 19);  ///< DMA Transfer Done in Frame Buffer1
        constexpr uint32_t DMA_TSF_DONE_FB2 = (1U << 20);  ///< DMA Transfer Done in Frame Buffer2
        constexpr uint32_t STATFF_INT = (1U << 21);  ///< STATFIFO Full Interrupt Status
        constexpr uint32_t DMA_TSF_DONE_SFF = (1U << 22);  ///< DMA Transfer Done from StatFIFO
        constexpr uint32_t RF_OR_INT = (1U << 24);  ///< RxFIFO Overrun Interrupt Status
        constexpr uint32_t SF_OR_INT = (1U << 25);  ///< STATFIFO Overrun Interrupt Status
        constexpr uint32_t DMA_FIELD1_DONE = (1U << 26);  ///< When DMA field 0 is complete, this bit will be set to 1(clear by writing 1).
        constexpr uint32_t DMA_FIELD0_DONE = (1U << 27);  ///< When DMA field 0 is complete, this bit will be set to 1(clear by writing 1).
        constexpr uint32_t BASEADDR_CHHANGE_ERROR = (1U << 28);  ///< When using base address switching enable, this bit will be 1 when switching occur before DMA complete
    }

    /// CSIDMASA_STATFIFO Register bits
    namespace csidmasa_statfifo_bits {
        constexpr uint32_t DMA_START_ADDR_SFF = (30 << 2);  ///< DMA Start Address for STATFIFO
    }

    /// CSIDMATS_STATFIFO Register bits
    namespace csidmats_statfifo_bits {
        constexpr uint32_t DMA_TSF_SIZE_SFF = (32 << 0);  ///< DMA Transfer Size for STATFIFO
    }

    /// CSIDMASA_FB1 Register bits
    namespace csidmasa_fb1_bits {
        constexpr uint32_t DMA_START_ADDR_FB1 = (30 << 2);  ///< DMA Start Address in Frame Buffer1
    }

    /// CSIDMASA_FB2 Register bits
    namespace csidmasa_fb2_bits {
        constexpr uint32_t DMA_START_ADDR_FB2 = (30 << 2);  ///< DMA Start Address in Frame Buffer2
    }

    /// CSIFBUF_PARA Register bits
    namespace csifbuf_para_bits {
        constexpr uint32_t FBUF_STRIDE = (16 << 0);  ///< Frame Buffer Parameter
        constexpr uint32_t DEINTERLACE_STRIDE = (16 << 16);  ///< DEINTERLACE_STRIDE is only used in the deinterlace mode
    }

    /// CSIIMAG_PARA Register bits
    namespace csiimag_para_bits {
        constexpr uint32_t IMAGE_HEIGHT = (16 << 0);  ///< Image Height. Indicates how many pixels in a column of the image from the sensor.
        constexpr uint32_t IMAGE_WIDTH = (16 << 16);  ///< Image Width
    }

    /// CSICR18 Register bits
    namespace csicr18_bits {
        constexpr uint32_t DEINTERLACE_EN = (1U << 2);  ///< This bit is used to select the output method When input is standard CCIR656 video.
        constexpr uint32_t PARALLEL24_EN = (1U << 3);  ///< When input is parallel rgb888/yuv444 24bit, this bit can be enabled.
        constexpr uint32_t BASEADDR_SWITCH_EN = (1U << 4);  ///< When this bit is enabled, CSI DMA will switch the base address according to BASEADDR_SWITCH_SEL rather than atomically by DMA completed
        constexpr uint32_t BASEADDR_SWITCH_SEL = (1U << 5);  ///< CSI 2 base addresses switching method. When using this bit, BASEADDR_SWITCH_EN is 1.
        constexpr uint32_t FIELD0_DONE_IE = (1U << 6);  ///< In interlace mode, fileld 0 means interrupt enabled.
        constexpr uint32_t DMA_FIELD1_DONE_IE = (1U << 7);  ///< When in interlace mode, field 1 done interrupt enable.
        constexpr uint32_t LAST_DMA_REQ_SEL = (1U << 8);  ///< Choosing the last DMA request condition.
        constexpr uint32_t BASEADDR_CHANGE_ERROR_IE = (1U << 9);  ///< Base address change error interrupt enable signal.
        constexpr uint32_t RGB888A_FORMAT_SEL = (1U << 10);  ///< Output is 32-bit format.
        constexpr uint32_t AHB_HPROT = (4 << 12);  ///< Hprot value in AHB bus protocol.
        constexpr uint32_t MASK_OPTION = (2 << 18);  ///< These bits used to choose the method to mask the CSI input.
        constexpr uint32_t CSI_ENABLE = (1U << 31);  ///< CSI global enable signal
    }

    /// CSICR19 Register bits
    namespace csicr19_bits {
        constexpr uint32_t DMA_RFIFO_HIGHEST_FIFO_LEVEL = (8 << 0);  ///< This byte stores the highest FIFO level achieved by CSI FIFO timely and will be clear by writing 8'ff to it
    }

}

// ============================================================================
// USDHC1 Peripheral
// ============================================================================

namespace usdhc1 {
    /// Base addresses
    constexpr uint32_t USDHC1_BASE = 0x402C0000;

    /// USDHC1 Register structure
    struct Registers {
        volatile uint32_t DS_ADDR;  ///< Offset: 0x00 - DMA System Address
        volatile uint32_t BLK_ATT;  ///< Offset: 0x04 - Block Attributes
        volatile uint32_t CMD_ARG;  ///< Offset: 0x08 - Command Argument
        volatile uint32_t CMD_XFR_TYP;  ///< Offset: 0x0C - Command Transfer Type
        volatile uint32_t CMD_RSP0;  ///< Offset: 0x10 - Command Response0
        volatile uint32_t CMD_RSP1;  ///< Offset: 0x14 - Command Response1
        volatile uint32_t CMD_RSP2;  ///< Offset: 0x18 - Command Response2
        volatile uint32_t CMD_RSP3;  ///< Offset: 0x1C - Command Response3
        volatile uint32_t DATA_BUFF_ACC_PORT;  ///< Offset: 0x20 - Data Buffer Access Port
        volatile uint32_t PRES_STATE;  ///< Offset: 0x24 - Present State
        volatile uint32_t PROT_CTRL;  ///< Offset: 0x28 - Protocol Control
        volatile uint32_t SYS_CTRL;  ///< Offset: 0x2C - System Control
        volatile uint32_t INT_STATUS;  ///< Offset: 0x30 - Interrupt Status
        volatile uint32_t INT_STATUS_EN;  ///< Offset: 0x34 - Interrupt Status Enable
        volatile uint32_t INT_SIGNAL_EN;  ///< Offset: 0x38 - Interrupt Signal Enable
        volatile uint32_t AUTOCMD12_ERR_STATUS;  ///< Offset: 0x3C - Auto CMD12 Error Status
        volatile uint32_t HOST_CTRL_CAP;  ///< Offset: 0x40 - Host Controller Capabilities
        volatile uint32_t WTMK_LVL;  ///< Offset: 0x44 - Watermark Level
        volatile uint32_t MIX_CTRL;  ///< Offset: 0x48 - Mixer Control
        volatile uint32_t FORCE_EVENT;  ///< Offset: 0x50 - Force Event
        volatile uint32_t ADMA_ERR_STATUS;  ///< Offset: 0x54 - ADMA Error Status Register
        volatile uint32_t ADMA_SYS_ADDR;  ///< Offset: 0x58 - ADMA System Address
        volatile uint32_t DLL_CTRL;  ///< Offset: 0x60 - DLL (Delay Line) Control
        volatile uint32_t DLL_STATUS;  ///< Offset: 0x64 - DLL Status
        volatile uint32_t CLK_TUNE_CTRL_STATUS;  ///< Offset: 0x68 - CLK Tuning Control and Status
        volatile uint32_t VEND_SPEC;  ///< Offset: 0xC0 - Vendor Specific Register
        volatile uint32_t MMC_BOOT;  ///< Offset: 0xC4 - MMC Boot Register
        volatile uint32_t VEND_SPEC2;  ///< Offset: 0xC8 - Vendor Specific 2 Register
        volatile uint32_t TUNING_CTRL;  ///< Offset: 0xCC - Tuning Control Register
    };

    /// Peripheral instances
    inline Registers* USDHC1 = reinterpret_cast<Registers*>(USDHC1_BASE);

    // Bit definitions
    /// DS_ADDR Register bits
    namespace ds_addr_bits {
        constexpr uint32_t DS_ADDR = (32 << 0);  ///< DS_ADDR
    }

    /// BLK_ATT Register bits
    namespace blk_att_bits {
        constexpr uint32_t BLKSIZE = (13 << 0);  ///< Block Size
        constexpr uint32_t BLKCNT = (16 << 16);  ///< Block Count
    }

    /// CMD_ARG Register bits
    namespace cmd_arg_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Command Argument
    }

    /// CMD_XFR_TYP Register bits
    namespace cmd_xfr_typ_bits {
        constexpr uint32_t RSPTYP = (2 << 16);  ///< Response Type Select
        constexpr uint32_t CCCEN = (1U << 19);  ///< Command CRC Check Enable
        constexpr uint32_t CICEN = (1U << 20);  ///< Command Index Check Enable
        constexpr uint32_t DPSEL = (1U << 21);  ///< Data Present Select
        constexpr uint32_t CMDTYP = (2 << 22);  ///< Command Type
        constexpr uint32_t CMDINX = (6 << 24);  ///< Command Index
    }

    /// CMD_RSP0 Register bits
    namespace cmd_rsp0_bits {
        constexpr uint32_t CMDRSP0 = (32 << 0);  ///< Command Response 0
    }

    /// CMD_RSP1 Register bits
    namespace cmd_rsp1_bits {
        constexpr uint32_t CMDRSP1 = (32 << 0);  ///< Command Response 1
    }

    /// CMD_RSP2 Register bits
    namespace cmd_rsp2_bits {
        constexpr uint32_t CMDRSP2 = (32 << 0);  ///< Command Response 2
    }

    /// CMD_RSP3 Register bits
    namespace cmd_rsp3_bits {
        constexpr uint32_t CMDRSP3 = (32 << 0);  ///< Command Response 3
    }

    /// DATA_BUFF_ACC_PORT Register bits
    namespace data_buff_acc_port_bits {
        constexpr uint32_t DATCONT = (32 << 0);  ///< Data Content
    }

    /// PRES_STATE Register bits
    namespace pres_state_bits {
        constexpr uint32_t CIHB = (1U << 0);  ///< Command Inhibit (CMD)
        constexpr uint32_t CDIHB = (1U << 1);  ///< Command Inhibit (DATA)
        constexpr uint32_t DLA = (1U << 2);  ///< Data Line Active
        constexpr uint32_t SDSTB = (1U << 3);  ///< SD Clock Stable
        constexpr uint32_t IPGOFF = (1U << 4);  ///< IPG_CLK Gated Off Internally
        constexpr uint32_t HCKOFF = (1U << 5);  ///< HCLK Gated Off Internally
        constexpr uint32_t PEROFF = (1U << 6);  ///< IPG_PERCLK Gated Off Internally
        constexpr uint32_t SDOFF = (1U << 7);  ///< SD Clock Gated Off Internally
        constexpr uint32_t WTA = (1U << 8);  ///< Write Transfer Active
        constexpr uint32_t RTA = (1U << 9);  ///< Read Transfer Active
        constexpr uint32_t BWEN = (1U << 10);  ///< Buffer Write Enable
        constexpr uint32_t BREN = (1U << 11);  ///< Buffer Read Enable
        constexpr uint32_t RTR = (1U << 12);  ///< Re-Tuning Request (only for SD3.0 SDR104 mode and EMMC HS200 mode)
        constexpr uint32_t TSCD = (1U << 15);  ///< Tape Select Change Done
        constexpr uint32_t CINST = (1U << 16);  ///< Card Inserted
        constexpr uint32_t CDPL = (1U << 18);  ///< Card Detect Pin Level
        constexpr uint32_t WPSPL = (1U << 19);  ///< Write Protect Switch Pin Level
        constexpr uint32_t CLSL = (1U << 23);  ///< CMD Line Signal Level
        constexpr uint32_t DLSL = (8 << 24);  ///< DATA[7:0] Line Signal Level
    }

    /// PROT_CTRL Register bits
    namespace prot_ctrl_bits {
        constexpr uint32_t LCTL = (1U << 0);  ///< LED Control
        constexpr uint32_t DTW = (2 << 1);  ///< Data Transfer Width
        constexpr uint32_t D3CD = (1U << 3);  ///< DATA3 as Card Detection Pin
        constexpr uint32_t EMODE = (2 << 4);  ///< Endian Mode
        constexpr uint32_t CDTL = (1U << 6);  ///< Card Detect Test Level
        constexpr uint32_t CDSS = (1U << 7);  ///< Card Detect Signal Selection
        constexpr uint32_t DMASEL = (2 << 8);  ///< DMA Select
        constexpr uint32_t SABGREQ = (1U << 16);  ///< Stop At Block Gap Request
        constexpr uint32_t CREQ = (1U << 17);  ///< Continue Request
        constexpr uint32_t RWCTL = (1U << 18);  ///< Read Wait Control
        constexpr uint32_t IABG = (1U << 19);  ///< Interrupt At Block Gap
        constexpr uint32_t RD_DONE_NO_8CLK = (1U << 20);  ///< RD_DONE_NO_8CLK
        constexpr uint32_t WECINT = (1U << 24);  ///< Wakeup Event Enable On Card Interrupt
        constexpr uint32_t WECINS = (1U << 25);  ///< Wakeup Event Enable On SD Card Insertion
        constexpr uint32_t WECRM = (1U << 26);  ///< Wakeup Event Enable On SD Card Removal
        constexpr uint32_t BURST_LEN_EN = (3 << 27);  ///< BURST length enable for INCR, INCR4 / INCR8 / INCR16, INCR4-WRAP / INCR8-WRAP / INCR16-WRAP
        constexpr uint32_t NON_EXACT_BLK_RD = (1U << 30);  ///< NON_EXACT_BLK_RD
    }

    /// SYS_CTRL Register bits
    namespace sys_ctrl_bits {
        constexpr uint32_t DVS = (4 << 4);  ///< Divisor
        constexpr uint32_t SDCLKFS = (8 << 8);  ///< SDCLK Frequency Select
        constexpr uint32_t DTOCV = (4 << 16);  ///< Data Timeout Counter Value
        constexpr uint32_t IPP_RST_N = (1U << 23);  ///< IPP_RST_N
        constexpr uint32_t RSTA = (1U << 24);  ///< Software Reset For ALL
        constexpr uint32_t RSTC = (1U << 25);  ///< Software Reset For CMD Line
        constexpr uint32_t RSTD = (1U << 26);  ///< Software Reset For DATA Line
        constexpr uint32_t INITA = (1U << 27);  ///< Initialization Active
        constexpr uint32_t RSTT = (1U << 28);  ///< Reset Tuning
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t CC = (1U << 0);  ///< Command Complete
        constexpr uint32_t TC = (1U << 1);  ///< Transfer Complete
        constexpr uint32_t BGE = (1U << 2);  ///< Block Gap Event
        constexpr uint32_t DINT = (1U << 3);  ///< DMA Interrupt
        constexpr uint32_t BWR = (1U << 4);  ///< Buffer Write Ready
        constexpr uint32_t BRR = (1U << 5);  ///< Buffer Read Ready
        constexpr uint32_t CINS = (1U << 6);  ///< Card Insertion
        constexpr uint32_t CRM = (1U << 7);  ///< Card Removal
        constexpr uint32_t CINT = (1U << 8);  ///< Card Interrupt
        constexpr uint32_t RTE = (1U << 12);  ///< Re-Tuning Event: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
        constexpr uint32_t TP = (1U << 14);  ///< Tuning Pass:(only for SD3.0 SDR104 mode and EMMC HS200 mode)
        constexpr uint32_t CTOE = (1U << 16);  ///< Command Timeout Error
        constexpr uint32_t CCE = (1U << 17);  ///< Command CRC Error
        constexpr uint32_t CEBE = (1U << 18);  ///< Command End Bit Error
        constexpr uint32_t CIE = (1U << 19);  ///< Command Index Error
        constexpr uint32_t DTOE = (1U << 20);  ///< Data Timeout Error
        constexpr uint32_t DCE = (1U << 21);  ///< Data CRC Error
        constexpr uint32_t DEBE = (1U << 22);  ///< Data End Bit Error
        constexpr uint32_t AC12E = (1U << 24);  ///< Auto CMD12 Error
        constexpr uint32_t TNE = (1U << 26);  ///< Tuning Error: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
        constexpr uint32_t DMAE = (1U << 28);  ///< DMA Error
    }

    /// INT_STATUS_EN Register bits
    namespace int_status_en_bits {
        constexpr uint32_t CCSEN = (1U << 0);  ///< Command Complete Status Enable
        constexpr uint32_t TCSEN = (1U << 1);  ///< Transfer Complete Status Enable
        constexpr uint32_t BGESEN = (1U << 2);  ///< Block Gap Event Status Enable
        constexpr uint32_t DINTSEN = (1U << 3);  ///< DMA Interrupt Status Enable
        constexpr uint32_t BWRSEN = (1U << 4);  ///< Buffer Write Ready Status Enable
        constexpr uint32_t BRRSEN = (1U << 5);  ///< Buffer Read Ready Status Enable
        constexpr uint32_t CINSSEN = (1U << 6);  ///< Card Insertion Status Enable
        constexpr uint32_t CRMSEN = (1U << 7);  ///< Card Removal Status Enable
        constexpr uint32_t CINTSEN = (1U << 8);  ///< Card Interrupt Status Enable
        constexpr uint32_t RTESEN = (1U << 12);  ///< Re-Tuning Event Status Enable
        constexpr uint32_t TPSEN = (1U << 14);  ///< Tuning Pass Status Enable
        constexpr uint32_t CTOESEN = (1U << 16);  ///< Command Timeout Error Status Enable
        constexpr uint32_t CCESEN = (1U << 17);  ///< Command CRC Error Status Enable
        constexpr uint32_t CEBESEN = (1U << 18);  ///< Command End Bit Error Status Enable
        constexpr uint32_t CIESEN = (1U << 19);  ///< Command Index Error Status Enable
        constexpr uint32_t DTOESEN = (1U << 20);  ///< Data Timeout Error Status Enable
        constexpr uint32_t DCESEN = (1U << 21);  ///< Data CRC Error Status Enable
        constexpr uint32_t DEBESEN = (1U << 22);  ///< Data End Bit Error Status Enable
        constexpr uint32_t AC12ESEN = (1U << 24);  ///< Auto CMD12 Error Status Enable
        constexpr uint32_t TNESEN = (1U << 26);  ///< Tuning Error Status Enable
        constexpr uint32_t DMAESEN = (1U << 28);  ///< DMA Error Status Enable
    }

    /// INT_SIGNAL_EN Register bits
    namespace int_signal_en_bits {
        constexpr uint32_t CCIEN = (1U << 0);  ///< Command Complete Interrupt Enable
        constexpr uint32_t TCIEN = (1U << 1);  ///< Transfer Complete Interrupt Enable
        constexpr uint32_t BGEIEN = (1U << 2);  ///< Block Gap Event Interrupt Enable
        constexpr uint32_t DINTIEN = (1U << 3);  ///< DMA Interrupt Enable
        constexpr uint32_t BWRIEN = (1U << 4);  ///< Buffer Write Ready Interrupt Enable
        constexpr uint32_t BRRIEN = (1U << 5);  ///< Buffer Read Ready Interrupt Enable
        constexpr uint32_t CINSIEN = (1U << 6);  ///< Card Insertion Interrupt Enable
        constexpr uint32_t CRMIEN = (1U << 7);  ///< Card Removal Interrupt Enable
        constexpr uint32_t CINTIEN = (1U << 8);  ///< Card Interrupt Interrupt Enable
        constexpr uint32_t RTEIEN = (1U << 12);  ///< Re-Tuning Event Interrupt Enable
        constexpr uint32_t TPIEN = (1U << 14);  ///< Tuning Pass Interrupt Enable
        constexpr uint32_t CTOEIEN = (1U << 16);  ///< Command Timeout Error Interrupt Enable
        constexpr uint32_t CCEIEN = (1U << 17);  ///< Command CRC Error Interrupt Enable
        constexpr uint32_t CEBEIEN = (1U << 18);  ///< Command End Bit Error Interrupt Enable
        constexpr uint32_t CIEIEN = (1U << 19);  ///< Command Index Error Interrupt Enable
        constexpr uint32_t DTOEIEN = (1U << 20);  ///< Data Timeout Error Interrupt Enable
        constexpr uint32_t DCEIEN = (1U << 21);  ///< Data CRC Error Interrupt Enable
        constexpr uint32_t DEBEIEN = (1U << 22);  ///< Data End Bit Error Interrupt Enable
        constexpr uint32_t AC12EIEN = (1U << 24);  ///< Auto CMD12 Error Interrupt Enable
        constexpr uint32_t TNEIEN = (1U << 26);  ///< Tuning Error Interrupt Enable
        constexpr uint32_t DMAEIEN = (1U << 28);  ///< DMA Error Interrupt Enable
    }

    /// AUTOCMD12_ERR_STATUS Register bits
    namespace autocmd12_err_status_bits {
        constexpr uint32_t AC12NE = (1U << 0);  ///< Auto CMD12 Not Executed
        constexpr uint32_t AC12TOE = (1U << 1);  ///< Auto CMD12 / 23 Timeout Error
        constexpr uint32_t AC12EBE = (1U << 2);  ///< Auto CMD12 / 23 End Bit Error
        constexpr uint32_t AC12CE = (1U << 3);  ///< Auto CMD12 / 23 CRC Error
        constexpr uint32_t AC12IE = (1U << 4);  ///< Auto CMD12 / 23 Index Error
        constexpr uint32_t CNIBAC12E = (1U << 7);  ///< Command Not Issued By Auto CMD12 Error
        constexpr uint32_t EXECUTE_TUNING = (1U << 22);  ///< Execute Tuning
        constexpr uint32_t SMP_CLK_SEL = (1U << 23);  ///< Sample Clock Select
    }

    /// HOST_CTRL_CAP Register bits
    namespace host_ctrl_cap_bits {
        constexpr uint32_t SDR50_SUPPORT = (1U << 0);  ///< SDR50 support
        constexpr uint32_t SDR104_SUPPORT = (1U << 1);  ///< SDR104 support
        constexpr uint32_t DDR50_SUPPORT = (1U << 2);  ///< DDR50 support
        constexpr uint32_t TIME_COUNT_RETUNING = (4 << 8);  ///< Time Counter for Retuning
        constexpr uint32_t USE_TUNING_SDR50 = (1U << 13);  ///< Use Tuning for SDR50
        constexpr uint32_t RETUNING_MODE = (2 << 14);  ///< Retuning Mode
        constexpr uint32_t MBL = (3 << 16);  ///< Max Block Length
        constexpr uint32_t ADMAS = (1U << 20);  ///< ADMA Support
        constexpr uint32_t HSS = (1U << 21);  ///< High Speed Support
        constexpr uint32_t DMAS = (1U << 22);  ///< DMA Support
        constexpr uint32_t SRS = (1U << 23);  ///< Suspend / Resume Support
        constexpr uint32_t VS33 = (1U << 24);  ///< Voltage Support 3.3V
        constexpr uint32_t VS30 = (1U << 25);  ///< Voltage Support 3.0 V
        constexpr uint32_t VS18 = (1U << 26);  ///< Voltage Support 1.8 V
    }

    /// WTMK_LVL Register bits
    namespace wtmk_lvl_bits {
        constexpr uint32_t RD_WML = (8 << 0);  ///< Read Watermark Level
        constexpr uint32_t RD_BRST_LEN = (5 << 8);  ///< Read Burst Length Due to system restriction, the actual burst length may not exceed 16.
        constexpr uint32_t WR_WML = (8 << 16);  ///< Write Watermark Level
        constexpr uint32_t WR_BRST_LEN = (5 << 24);  ///< Write Burst Length Due to system restriction, the actual burst length may not exceed 16.
    }

    /// MIX_CTRL Register bits
    namespace mix_ctrl_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t BCEN = (1U << 1);  ///< Block Count Enable
        constexpr uint32_t AC12EN = (1U << 2);  ///< Auto CMD12 Enable
        constexpr uint32_t DDR_EN = (1U << 3);  ///< Dual Data Rate mode selection
        constexpr uint32_t DTDSEL = (1U << 4);  ///< Data Transfer Direction Select
        constexpr uint32_t MSBSEL = (1U << 5);  ///< Multi / Single Block Select
        constexpr uint32_t NIBBLE_POS = (1U << 6);  ///< NIBBLE_POS
        constexpr uint32_t AC23EN = (1U << 7);  ///< Auto CMD23 Enable
        constexpr uint32_t EXE_TUNE = (1U << 22);  ///< Execute Tuning: (Only used for SD3.0, SDR104 mode and EMMC HS200 mode)
        constexpr uint32_t SMP_CLK_SEL = (1U << 23);  ///< SMP_CLK_SEL
        constexpr uint32_t AUTO_TUNE_EN = (1U << 24);  ///< Auto Tuning Enable (Only used for SD3.0, SDR104 mode and and EMMC HS200 mode)
        constexpr uint32_t FBCLK_SEL = (1U << 25);  ///< Feedback Clock Source Selection (Only used for SD3.0, SDR104 mode and EMMC HS200 mode)
    }

    /// FORCE_EVENT Register bits
    namespace force_event_bits {
        constexpr uint32_t FEVTAC12NE = (1U << 0);  ///< Force Event Auto Command 12 Not Executed
        constexpr uint32_t FEVTAC12TOE = (1U << 1);  ///< Force Event Auto Command 12 Time Out Error
        constexpr uint32_t FEVTAC12CE = (1U << 2);  ///< Force Event Auto Command 12 CRC Error
        constexpr uint32_t FEVTAC12EBE = (1U << 3);  ///< Force Event Auto Command 12 End Bit Error
        constexpr uint32_t FEVTAC12IE = (1U << 4);  ///< Force Event Auto Command 12 Index Error
        constexpr uint32_t FEVTCNIBAC12E = (1U << 7);  ///< Force Event Command Not Executed By Auto Command 12 Error
        constexpr uint32_t FEVTCTOE = (1U << 16);  ///< Force Event Command Time Out Error
        constexpr uint32_t FEVTCCE = (1U << 17);  ///< Force Event Command CRC Error
        constexpr uint32_t FEVTCEBE = (1U << 18);  ///< Force Event Command End Bit Error
        constexpr uint32_t FEVTCIE = (1U << 19);  ///< Force Event Command Index Error
        constexpr uint32_t FEVTDTOE = (1U << 20);  ///< Force Event Data Time Out Error
        constexpr uint32_t FEVTDCE = (1U << 21);  ///< Force Event Data CRC Error
        constexpr uint32_t FEVTDEBE = (1U << 22);  ///< Force Event Data End Bit Error
        constexpr uint32_t FEVTAC12E = (1U << 24);  ///< Force Event Auto Command 12 Error
        constexpr uint32_t FEVTTNE = (1U << 26);  ///< Force Tuning Error
        constexpr uint32_t FEVTDMAE = (1U << 28);  ///< Force Event DMA Error
        constexpr uint32_t FEVTCINT = (1U << 31);  ///< Force Event Card Interrupt
    }

    /// ADMA_ERR_STATUS Register bits
    namespace adma_err_status_bits {
        constexpr uint32_t ADMAES = (2 << 0);  ///< ADMA Error State (when ADMA Error is occurred)
        constexpr uint32_t ADMALME = (1U << 2);  ///< ADMA Length Mismatch Error
        constexpr uint32_t ADMADCE = (1U << 3);  ///< ADMA Descriptor Error
    }

    /// ADMA_SYS_ADDR Register bits
    namespace adma_sys_addr_bits {
        constexpr uint32_t ADS_ADDR = (30 << 2);  ///< ADMA System Address
    }

    /// DLL_CTRL Register bits
    namespace dll_ctrl_bits {
        constexpr uint32_t DLL_CTRL_ENABLE = (1U << 0);  ///< DLL_CTRL_ENABLE
        constexpr uint32_t DLL_CTRL_RESET = (1U << 1);  ///< DLL_CTRL_RESET
        constexpr uint32_t DLL_CTRL_SLV_FORCE_UPD = (1U << 2);  ///< DLL_CTRL_SLV_FORCE_UPD
        constexpr uint32_t DLL_CTRL_SLV_DLY_TARGET0 = (4 << 3);  ///< DLL_CTRL_SLV_DLY_TARGET0
        constexpr uint32_t DLL_CTRL_GATE_UPDATE = (1U << 7);  ///< DLL_CTRL_GATE_UPDATE
        constexpr uint32_t DLL_CTRL_SLV_OVERRIDE = (1U << 8);  ///< DLL_CTRL_SLV_OVERRIDE
        constexpr uint32_t DLL_CTRL_SLV_OVERRIDE_VAL = (7 << 9);  ///< DLL_CTRL_SLV_OVERRIDE_VAL
        constexpr uint32_t DLL_CTRL_SLV_DLY_TARGET1 = (3 << 16);  ///< DLL_CTRL_SLV_DLY_TARGET1
        constexpr uint32_t DLL_CTRL_SLV_UPDATE_INT = (8 << 20);  ///< DLL_CTRL_SLV_UPDATE_INT
        constexpr uint32_t DLL_CTRL_REF_UPDATE_INT = (4 << 28);  ///< DLL_CTRL_REF_UPDATE_INT
    }

    /// DLL_STATUS Register bits
    namespace dll_status_bits {
        constexpr uint32_t DLL_STS_SLV_LOCK = (1U << 0);  ///< DLL_STS_SLV_LOCK
        constexpr uint32_t DLL_STS_REF_LOCK = (1U << 1);  ///< DLL_STS_REF_LOCK
        constexpr uint32_t DLL_STS_SLV_SEL = (7 << 2);  ///< DLL_STS_SLV_SEL
        constexpr uint32_t DLL_STS_REF_SEL = (7 << 9);  ///< DLL_STS_REF_SEL
    }

    /// CLK_TUNE_CTRL_STATUS Register bits
    namespace clk_tune_ctrl_status_bits {
        constexpr uint32_t DLY_CELL_SET_POST = (4 << 0);  ///< DLY_CELL_SET_POST
        constexpr uint32_t DLY_CELL_SET_OUT = (4 << 4);  ///< DLY_CELL_SET_OUT
        constexpr uint32_t DLY_CELL_SET_PRE = (7 << 8);  ///< DLY_CELL_SET_PRE
        constexpr uint32_t NXT_ERR = (1U << 15);  ///< NXT_ERR
        constexpr uint32_t TAP_SEL_POST = (4 << 16);  ///< TAP_SEL_POST
        constexpr uint32_t TAP_SEL_OUT = (4 << 20);  ///< TAP_SEL_OUT
        constexpr uint32_t TAP_SEL_PRE = (7 << 24);  ///< TAP_SEL_PRE
        constexpr uint32_t PRE_ERR = (1U << 31);  ///< PRE_ERR
    }

    /// VEND_SPEC Register bits
    namespace vend_spec_bits {
        constexpr uint32_t VSELECT = (1U << 1);  ///< Voltage Selection
        constexpr uint32_t CONFLICT_CHK_EN = (1U << 2);  ///< Conflict check enable.
        constexpr uint32_t AC12_WR_CHKBUSY_EN = (1U << 3);  ///< AC12_WR_CHKBUSY_EN
        constexpr uint32_t FRC_SDCLK_ON = (1U << 8);  ///< FRC_SDCLK_ON
        constexpr uint32_t CRC_CHK_DIS = (1U << 15);  ///< CRC Check Disable
        constexpr uint32_t CMD_BYTE_EN = (1U << 31);  ///< CMD_BYTE_EN
    }

    /// MMC_BOOT Register bits
    namespace mmc_boot_bits {
        constexpr uint32_t DTOCV_ACK = (4 << 0);  ///< DTOCV_ACK
        constexpr uint32_t BOOT_ACK = (1U << 4);  ///< BOOT_ACK
        constexpr uint32_t BOOT_MODE = (1U << 5);  ///< BOOT_MODE
        constexpr uint32_t BOOT_EN = (1U << 6);  ///< BOOT_EN
        constexpr uint32_t AUTO_SABG_EN = (1U << 7);  ///< AUTO_SABG_EN
        constexpr uint32_t DISABLE_TIME_OUT = (1U << 8);  ///< Disable Time Out
        constexpr uint32_t BOOT_BLK_CNT = (16 << 16);  ///< BOOT_BLK_CNT
    }

    /// VEND_SPEC2 Register bits
    namespace vend_spec2_bits {
        constexpr uint32_t CARD_INT_D3_TEST = (1U << 3);  ///< Card Interrupt Detection Test
        constexpr uint32_t TUNING_8bit_EN = (1U << 4);  ///< TUNING_8bit_EN
        constexpr uint32_t TUNING_1bit_EN = (1U << 5);  ///< TUNING_1bit_EN
        constexpr uint32_t TUNING_CMD_EN = (1U << 6);  ///< TUNING_CMD_EN
        constexpr uint32_t ACMD23_ARGU2_EN = (1U << 12);  ///< Argument2 register enable for ACMD23
        constexpr uint32_t PART_DLL_DEBUG = (1U << 13);  ///< debug for part dll
        constexpr uint32_t BUS_RST = (1U << 14);  ///< BUS reset
    }

    /// TUNING_CTRL Register bits
    namespace tuning_ctrl_bits {
        constexpr uint32_t TUNING_START_TAP = (8 << 0);  ///< TUNING_START_TAP
        constexpr uint32_t TUNING_COUNTER = (8 << 8);  ///< TUNING_COUNTER
        constexpr uint32_t TUNING_STEP = (3 << 16);  ///< TUNING_STEP
        constexpr uint32_t TUNING_WINDOW = (3 << 20);  ///< TUNING_WINDOW
        constexpr uint32_t STD_TUNING_EN = (1U << 24);  ///< STD_TUNING_EN
    }

}

// ============================================================================
// USDHC2 Peripheral
// ============================================================================

namespace usdhc2 {
    /// Base addresses
    constexpr uint32_t USDHC2_BASE = 0x402C4000;

    /// USDHC2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* USDHC2 = reinterpret_cast<Registers*>(USDHC2_BASE);

}

// ============================================================================
// ENET Peripheral
// ============================================================================

namespace enet {
    /// Base addresses
    constexpr uint32_t ENET_BASE = 0x402D8000;

    /// ENET Register structure
    struct Registers {
        volatile uint32_t EIR;  ///< Offset: 0x04 - Interrupt Event Register
        volatile uint32_t EIMR;  ///< Offset: 0x08 - Interrupt Mask Register
        volatile uint32_t RDAR;  ///< Offset: 0x10 - Receive Descriptor Active Register
        volatile uint32_t TDAR;  ///< Offset: 0x14 - Transmit Descriptor Active Register
        volatile uint32_t ECR;  ///< Offset: 0x24 - Ethernet Control Register
        volatile uint32_t MMFR;  ///< Offset: 0x40 - MII Management Frame Register
        volatile uint32_t MSCR;  ///< Offset: 0x44 - MII Speed Control Register
        volatile uint32_t MIBC;  ///< Offset: 0x64 - MIB Control Register
        volatile uint32_t RCR;  ///< Offset: 0x84 - Receive Control Register
        volatile uint32_t TCR;  ///< Offset: 0xC4 - Transmit Control Register
        volatile uint32_t PALR;  ///< Offset: 0xE4 - Physical Address Lower Register
        volatile uint32_t PAUR;  ///< Offset: 0xE8 - Physical Address Upper Register
        volatile uint32_t OPD;  ///< Offset: 0xEC - Opcode/Pause Duration Register
        volatile uint32_t TXIC;  ///< Offset: 0xF0 - Transmit Interrupt Coalescing Register
        volatile uint32_t RXIC;  ///< Offset: 0x100 - Receive Interrupt Coalescing Register
        volatile uint32_t IAUR;  ///< Offset: 0x118 - Descriptor Individual Upper Address Register
        volatile uint32_t IALR;  ///< Offset: 0x11C - Descriptor Individual Lower Address Register
        volatile uint32_t GAUR;  ///< Offset: 0x120 - Descriptor Group Upper Address Register
        volatile uint32_t GALR;  ///< Offset: 0x124 - Descriptor Group Lower Address Register
        volatile uint32_t TFWR;  ///< Offset: 0x144 - Transmit FIFO Watermark Register
        volatile uint32_t RDSR;  ///< Offset: 0x180 - Receive Descriptor Ring Start Register
        volatile uint32_t TDSR;  ///< Offset: 0x184 - Transmit Buffer Descriptor Ring Start Register
        volatile uint32_t MRBR;  ///< Offset: 0x188 - Maximum Receive Buffer Size Register
        volatile uint32_t RSFL;  ///< Offset: 0x190 - Receive FIFO Section Full Threshold
        volatile uint32_t RSEM;  ///< Offset: 0x194 - Receive FIFO Section Empty Threshold
        volatile uint32_t RAEM;  ///< Offset: 0x198 - Receive FIFO Almost Empty Threshold
        volatile uint32_t RAFL;  ///< Offset: 0x19C - Receive FIFO Almost Full Threshold
        volatile uint32_t TSEM;  ///< Offset: 0x1A0 - Transmit FIFO Section Empty Threshold
        volatile uint32_t TAEM;  ///< Offset: 0x1A4 - Transmit FIFO Almost Empty Threshold
        volatile uint32_t TAFL;  ///< Offset: 0x1A8 - Transmit FIFO Almost Full Threshold
        volatile uint32_t TIPG;  ///< Offset: 0x1AC - Transmit Inter-Packet Gap
        volatile uint32_t FTRL;  ///< Offset: 0x1B0 - Frame Truncation Length
        volatile uint32_t TACC;  ///< Offset: 0x1C0 - Transmit Accelerator Function Configuration
        volatile uint32_t RACC;  ///< Offset: 0x1C4 - Receive Accelerator Function Configuration
        volatile uint32_t RMON_T_DROP;  ///< Offset: 0x200 - Reserved Statistic Register
        volatile uint32_t RMON_T_PACKETS;  ///< Offset: 0x204 - Tx Packet Count Statistic Register
        volatile uint32_t RMON_T_BC_PKT;  ///< Offset: 0x208 - Tx Broadcast Packets Statistic Register
        volatile uint32_t RMON_T_MC_PKT;  ///< Offset: 0x20C - Tx Multicast Packets Statistic Register
        volatile uint32_t RMON_T_CRC_ALIGN;  ///< Offset: 0x210 - Tx Packets with CRC/Align Error Statistic Register
        volatile uint32_t RMON_T_UNDERSIZE;  ///< Offset: 0x214 - Tx Packets Less Than Bytes and Good CRC Statistic Register
        volatile uint32_t RMON_T_OVERSIZE;  ///< Offset: 0x218 - Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
        volatile uint32_t RMON_T_FRAG;  ///< Offset: 0x21C - Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
        volatile uint32_t RMON_T_JAB;  ///< Offset: 0x220 - Tx Packets Greater Than MAX_FL bytes and Bad CRC...
        volatile uint32_t RMON_T_COL;  ///< Offset: 0x224 - Tx Collision Count Statistic Register
        volatile uint32_t RMON_T_P64;  ///< Offset: 0x228 - Tx 64-Byte Packets Statistic Register
        volatile uint32_t RMON_T_P65TO127;  ///< Offset: 0x22C - Tx 65- to 127-byte Packets Statistic Register
        volatile uint32_t RMON_T_P128TO255;  ///< Offset: 0x230 - Tx 128- to 255-byte Packets Statistic Register
        volatile uint32_t RMON_T_P256TO511;  ///< Offset: 0x234 - Tx 256- to 511-byte Packets Statistic Register
        volatile uint32_t RMON_T_P512TO1023;  ///< Offset: 0x238 - Tx 512- to 1023-byte Packets Statistic Register
        volatile uint32_t RMON_T_P1024TO2047;  ///< Offset: 0x23C - Tx 1024- to 2047-byte Packets Statistic Register
        volatile uint32_t RMON_T_P_GTE2048;  ///< Offset: 0x240 - Tx Packets Greater Than 2048 Bytes Statistic Register
        volatile uint32_t RMON_T_OCTETS;  ///< Offset: 0x244 - Tx Octets Statistic Register
        volatile uint32_t IEEE_T_DROP;  ///< Offset: 0x248 - Reserved Statistic Register
        volatile uint32_t IEEE_T_FRAME_OK;  ///< Offset: 0x24C - Frames Transmitted OK Statistic Register
        volatile uint32_t IEEE_T_1COL;  ///< Offset: 0x250 - Frames Transmitted with Single Collision Statistic Register
        volatile uint32_t IEEE_T_MCOL;  ///< Offset: 0x254 - Frames Transmitted with Multiple Collisions Statistic Register
        volatile uint32_t IEEE_T_DEF;  ///< Offset: 0x258 - Frames Transmitted after Deferral Delay Statistic Register
        volatile uint32_t IEEE_T_LCOL;  ///< Offset: 0x25C - Frames Transmitted with Late Collision Statistic Register
        volatile uint32_t IEEE_T_EXCOL;  ///< Offset: 0x260 - Frames Transmitted with Excessive Collisions Statistic Register
        volatile uint32_t IEEE_T_MACERR;  ///< Offset: 0x264 - Frames Transmitted with Tx FIFO Underrun Statistic Register
        volatile uint32_t IEEE_T_CSERR;  ///< Offset: 0x268 - Frames Transmitted with Carrier Sense Error Statistic Register
        volatile uint32_t IEEE_T_SQE;  ///< Offset: 0x26C - Reserved Statistic Register
        volatile uint32_t IEEE_T_FDXFC;  ///< Offset: 0x270 - Flow Control Pause Frames Transmitted Statistic Register
        volatile uint32_t IEEE_T_OCTETS_OK;  ///< Offset: 0x274 - Octet Count for Frames Transmitted w/o Error Statistic Register
        volatile uint32_t RMON_R_PACKETS;  ///< Offset: 0x284 - Rx Packet Count Statistic Register
        volatile uint32_t RMON_R_BC_PKT;  ///< Offset: 0x288 - Rx Broadcast Packets Statistic Register
        volatile uint32_t RMON_R_MC_PKT;  ///< Offset: 0x28C - Rx Multicast Packets Statistic Register
        volatile uint32_t RMON_R_CRC_ALIGN;  ///< Offset: 0x290 - Rx Packets with CRC/Align Error Statistic Register
        volatile uint32_t RMON_R_UNDERSIZE;  ///< Offset: 0x294 - Rx Packets with Less Than 64 Bytes and Good CRC...
        volatile uint32_t RMON_R_OVERSIZE;  ///< Offset: 0x298 - Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
        volatile uint32_t RMON_R_FRAG;  ///< Offset: 0x29C - Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
        volatile uint32_t RMON_R_JAB;  ///< Offset: 0x2A0 - Rx Packets Greater Than MAX_FL Bytes and Bad CRC...
        volatile uint32_t RMON_R_RESVD_0;  ///< Offset: 0x2A4 - Reserved Statistic Register
        volatile uint32_t RMON_R_P64;  ///< Offset: 0x2A8 - Rx 64-Byte Packets Statistic Register
        volatile uint32_t RMON_R_P65TO127;  ///< Offset: 0x2AC - Rx 65- to 127-Byte Packets Statistic Register
        volatile uint32_t RMON_R_P128TO255;  ///< Offset: 0x2B0 - Rx 128- to 255-Byte Packets Statistic Register
        volatile uint32_t RMON_R_P256TO511;  ///< Offset: 0x2B4 - Rx 256- to 511-Byte Packets Statistic Register
        volatile uint32_t RMON_R_P512TO1023;  ///< Offset: 0x2B8 - Rx 512- to 1023-Byte Packets Statistic Register
        volatile uint32_t RMON_R_P1024TO2047;  ///< Offset: 0x2BC - Rx 1024- to 2047-Byte Packets Statistic Register
        volatile uint32_t RMON_R_P_GTE2048;  ///< Offset: 0x2C0 - Rx Packets Greater than 2048 Bytes Statistic Register
        volatile uint32_t RMON_R_OCTETS;  ///< Offset: 0x2C4 - Rx Octets Statistic Register
        volatile uint32_t IEEE_R_DROP;  ///< Offset: 0x2C8 - Frames not Counted Correctly Statistic Register
        volatile uint32_t IEEE_R_FRAME_OK;  ///< Offset: 0x2CC - Frames Received OK Statistic Register
        volatile uint32_t IEEE_R_CRC;  ///< Offset: 0x2D0 - Frames Received with CRC Error Statistic Register
        volatile uint32_t IEEE_R_ALIGN;  ///< Offset: 0x2D4 - Frames Received with Alignment Error Statistic Register
        volatile uint32_t IEEE_R_MACERR;  ///< Offset: 0x2D8 - Receive FIFO Overflow Count Statistic Register
        volatile uint32_t IEEE_R_FDXFC;  ///< Offset: 0x2DC - Flow Control Pause Frames Received Statistic Register
        volatile uint32_t IEEE_R_OCTETS_OK;  ///< Offset: 0x2E0 - Octet Count for Frames Received without Error Statistic Register
        volatile uint32_t ATCR;  ///< Offset: 0x400 - Adjustable Timer Control Register
        volatile uint32_t ATVR;  ///< Offset: 0x404 - Timer Value Register
        volatile uint32_t ATOFF;  ///< Offset: 0x408 - Timer Offset Register
        volatile uint32_t ATPER;  ///< Offset: 0x40C - Timer Period Register
        volatile uint32_t ATCOR;  ///< Offset: 0x410 - Timer Correction Register
        volatile uint32_t ATINC;  ///< Offset: 0x414 - Time-Stamping Clock Period Register
        volatile uint32_t ATSTMP;  ///< Offset: 0x418 - Timestamp of Last Transmitted Frame
        volatile uint32_t TGSR;  ///< Offset: 0x604 - Timer Global Status Register
        volatile uint32_t TCSR%s;  ///< Offset: 0x608 - Timer Control Status Register
        volatile uint32_t TCCR%s;  ///< Offset: 0x60C - Timer Compare Capture Register
    };

    /// Peripheral instances
    inline Registers* ENET = reinterpret_cast<Registers*>(ENET_BASE);

    // Bit definitions
    /// EIR Register bits
    namespace eir_bits {
        constexpr uint32_t TS_TIMER = (1U << 15);  ///< Timestamp Timer
        constexpr uint32_t TS_AVAIL = (1U << 16);  ///< Transmit Timestamp Available
        constexpr uint32_t WAKEUP = (1U << 17);  ///< Node Wakeup Request Indication
        constexpr uint32_t PLR = (1U << 18);  ///< Payload Receive Error
        constexpr uint32_t UN = (1U << 19);  ///< Transmit FIFO Underrun
        constexpr uint32_t RL = (1U << 20);  ///< Collision Retry Limit
        constexpr uint32_t LC = (1U << 21);  ///< Late Collision
        constexpr uint32_t EBERR = (1U << 22);  ///< Ethernet Bus Error
        constexpr uint32_t MII = (1U << 23);  ///< MII Interrupt.
        constexpr uint32_t RXB = (1U << 24);  ///< Receive Buffer Interrupt
        constexpr uint32_t RXF = (1U << 25);  ///< Receive Frame Interrupt
        constexpr uint32_t TXB = (1U << 26);  ///< Transmit Buffer Interrupt
        constexpr uint32_t TXF = (1U << 27);  ///< Transmit Frame Interrupt
        constexpr uint32_t GRA = (1U << 28);  ///< Graceful Stop Complete
        constexpr uint32_t BABT = (1U << 29);  ///< Babbling Transmit Error
        constexpr uint32_t BABR = (1U << 30);  ///< Babbling Receive Error
    }

    /// EIMR Register bits
    namespace eimr_bits {
        constexpr uint32_t TS_TIMER = (1U << 15);  ///< TS_TIMER Interrupt Mask
        constexpr uint32_t TS_AVAIL = (1U << 16);  ///< TS_AVAIL Interrupt Mask
        constexpr uint32_t WAKEUP = (1U << 17);  ///< WAKEUP Interrupt Mask
        constexpr uint32_t PLR = (1U << 18);  ///< PLR Interrupt Mask
        constexpr uint32_t UN = (1U << 19);  ///< UN Interrupt Mask
        constexpr uint32_t RL = (1U << 20);  ///< RL Interrupt Mask
        constexpr uint32_t LC = (1U << 21);  ///< LC Interrupt Mask
        constexpr uint32_t EBERR = (1U << 22);  ///< EBERR Interrupt Mask
        constexpr uint32_t MII = (1U << 23);  ///< MII Interrupt Mask
        constexpr uint32_t RXB = (1U << 24);  ///< RXB Interrupt Mask
        constexpr uint32_t RXF = (1U << 25);  ///< RXF Interrupt Mask
        constexpr uint32_t TXB = (1U << 26);  ///< TXB Interrupt Mask
        constexpr uint32_t TXF = (1U << 27);  ///< TXF Interrupt Mask
        constexpr uint32_t GRA = (1U << 28);  ///< GRA Interrupt Mask
        constexpr uint32_t BABT = (1U << 29);  ///< BABT Interrupt Mask
        constexpr uint32_t BABR = (1U << 30);  ///< BABR Interrupt Mask
    }

    /// RDAR Register bits
    namespace rdar_bits {
        constexpr uint32_t RDAR = (1U << 24);  ///< Receive Descriptor Active
    }

    /// TDAR Register bits
    namespace tdar_bits {
        constexpr uint32_t TDAR = (1U << 24);  ///< Transmit Descriptor Active
    }

    /// ECR Register bits
    namespace ecr_bits {
        constexpr uint32_t RESET = (1U << 0);  ///< Ethernet MAC Reset
        constexpr uint32_t ETHEREN = (1U << 1);  ///< Ethernet Enable
        constexpr uint32_t MAGICEN = (1U << 2);  ///< Magic Packet Detection Enable
        constexpr uint32_t SLEEP = (1U << 3);  ///< Sleep Mode Enable
        constexpr uint32_t EN1588 = (1U << 4);  ///< EN1588 Enable
        constexpr uint32_t DBGEN = (1U << 6);  ///< Debug Enable
        constexpr uint32_t DBSWP = (1U << 8);  ///< Descriptor Byte Swapping Enable
    }

    /// MMFR Register bits
    namespace mmfr_bits {
        constexpr uint32_t DATA = (16 << 0);  ///< Management Frame Data
        constexpr uint32_t TA = (2 << 16);  ///< Turn Around
        constexpr uint32_t RA = (5 << 18);  ///< Register Address
        constexpr uint32_t PA = (5 << 23);  ///< PHY Address
        constexpr uint32_t OP = (2 << 28);  ///< Operation Code
        constexpr uint32_t ST = (2 << 30);  ///< Start Of Frame Delimiter
    }

    /// MSCR Register bits
    namespace mscr_bits {
        constexpr uint32_t MII_SPEED = (6 << 1);  ///< MII Speed
        constexpr uint32_t DIS_PRE = (1U << 7);  ///< Disable Preamble
        constexpr uint32_t HOLDTIME = (3 << 8);  ///< Hold time On MDIO Output
    }

    /// MIBC Register bits
    namespace mibc_bits {
        constexpr uint32_t MIB_CLEAR = (1U << 29);  ///< MIB Clear
        constexpr uint32_t MIB_IDLE = (1U << 30);  ///< MIB Idle
        constexpr uint32_t MIB_DIS = (1U << 31);  ///< Disable MIB Logic
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t LOOP = (1U << 0);  ///< Internal Loopback
        constexpr uint32_t DRT = (1U << 1);  ///< Disable Receive On Transmit
        constexpr uint32_t MII_MODE = (1U << 2);  ///< Media Independent Interface Mode
        constexpr uint32_t PROM = (1U << 3);  ///< Promiscuous Mode
        constexpr uint32_t BC_REJ = (1U << 4);  ///< Broadcast Frame Reject
        constexpr uint32_t FCE = (1U << 5);  ///< Flow Control Enable
        constexpr uint32_t RMII_MODE = (1U << 8);  ///< RMII Mode Enable
        constexpr uint32_t RMII_10T = (1U << 9);  ///< Enables 10-Mbit/s mode of the RMII .
        constexpr uint32_t PADEN = (1U << 12);  ///< Enable Frame Padding Remove On Receive
        constexpr uint32_t PAUFWD = (1U << 13);  ///< Terminate/Forward Pause Frames
        constexpr uint32_t CRCFWD = (1U << 14);  ///< Terminate/Forward Received CRC
        constexpr uint32_t CFEN = (1U << 15);  ///< MAC Control Frame Enable
        constexpr uint32_t MAX_FL = (14 << 16);  ///< Maximum Frame Length
        constexpr uint32_t NLC = (1U << 30);  ///< Payload Length Check Disable
        constexpr uint32_t GRS = (1U << 31);  ///< Graceful Receive Stopped
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t GTS = (1U << 0);  ///< Graceful Transmit Stop
        constexpr uint32_t FDEN = (1U << 2);  ///< Full-Duplex Enable
        constexpr uint32_t TFC_PAUSE = (1U << 3);  ///< Transmit Frame Control Pause
        constexpr uint32_t RFC_PAUSE = (1U << 4);  ///< Receive Frame Control Pause
        constexpr uint32_t ADDSEL = (3 << 5);  ///< Source MAC Address Select On Transmit
        constexpr uint32_t ADDINS = (1U << 8);  ///< Set MAC Address On Transmit
        constexpr uint32_t CRCFWD = (1U << 9);  ///< Forward Frame From Application With CRC
    }

    /// PALR Register bits
    namespace palr_bits {
        constexpr uint32_t PADDR1 = (32 << 0);  ///< Pause Address
    }

    /// PAUR Register bits
    namespace paur_bits {
        constexpr uint32_t TYPE = (16 << 0);  ///< Type Field In PAUSE Frames
        constexpr uint32_t PADDR2 = (16 << 16);  ///< Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual address used for exact match, and the source address field in PAUSE frames
    }

    /// OPD Register bits
    namespace opd_bits {
        constexpr uint32_t PAUSE_DUR = (16 << 0);  ///< Pause Duration
        constexpr uint32_t OPCODE = (16 << 16);  ///< Opcode Field In PAUSE Frames
    }

    /// TXIC Register bits
    namespace txic_bits {
        constexpr uint32_t ICTT = (16 << 0);  ///< Interrupt coalescing timer threshold
        constexpr uint32_t ICFT = (8 << 20);  ///< Interrupt coalescing frame count threshold
        constexpr uint32_t ICCS = (1U << 30);  ///< Interrupt Coalescing Timer Clock Source Select
        constexpr uint32_t ICEN = (1U << 31);  ///< Interrupt Coalescing Enable
    }

    /// RXIC Register bits
    namespace rxic_bits {
        constexpr uint32_t ICTT = (16 << 0);  ///< Interrupt coalescing timer threshold
        constexpr uint32_t ICFT = (8 << 20);  ///< Interrupt coalescing frame count threshold
        constexpr uint32_t ICCS = (1U << 30);  ///< Interrupt Coalescing Timer Clock Source Select
        constexpr uint32_t ICEN = (1U << 31);  ///< Interrupt Coalescing Enable
    }

    /// IAUR Register bits
    namespace iaur_bits {
        constexpr uint32_t IADDR1 = (32 << 0);  ///< Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address
    }

    /// IALR Register bits
    namespace ialr_bits {
        constexpr uint32_t IADDR2 = (32 << 0);  ///< Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address
    }

    /// GAUR Register bits
    namespace gaur_bits {
        constexpr uint32_t GADDR1 = (32 << 0);  ///< Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address
    }

    /// GALR Register bits
    namespace galr_bits {
        constexpr uint32_t GADDR2 = (32 << 0);  ///< Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address
    }

    /// TFWR Register bits
    namespace tfwr_bits {
        constexpr uint32_t TFWR = (6 << 0);  ///< Transmit FIFO Write
        constexpr uint32_t STRFWD = (1U << 8);  ///< Store And Forward Enable
    }

    /// RDSR Register bits
    namespace rdsr_bits {
        constexpr uint32_t R_DES_START = (29 << 3);  ///< Pointer to the beginning of the receive buffer descriptor queue.
    }

    /// TDSR Register bits
    namespace tdsr_bits {
        constexpr uint32_t X_DES_START = (29 << 3);  ///< Pointer to the beginning of the transmit buffer descriptor queue.
    }

    /// MRBR Register bits
    namespace mrbr_bits {
        constexpr uint32_t R_BUF_SIZE = (10 << 4);  ///< Receive buffer size in bytes
    }

    /// RSFL Register bits
    namespace rsfl_bits {
        constexpr uint32_t RX_SECTION_FULL = (8 << 0);  ///< Value Of Receive FIFO Section Full Threshold
    }

    /// RSEM Register bits
    namespace rsem_bits {
        constexpr uint32_t RX_SECTION_EMPTY = (8 << 0);  ///< Value Of The Receive FIFO Section Empty Threshold
        constexpr uint32_t STAT_SECTION_EMPTY = (5 << 16);  ///< RX Status FIFO Section Empty Threshold
    }

    /// RAEM Register bits
    namespace raem_bits {
        constexpr uint32_t RX_ALMOST_EMPTY = (8 << 0);  ///< Value Of The Receive FIFO Almost Empty Threshold
    }

    /// RAFL Register bits
    namespace rafl_bits {
        constexpr uint32_t RX_ALMOST_FULL = (8 << 0);  ///< Value Of The Receive FIFO Almost Full Threshold
    }

    /// TSEM Register bits
    namespace tsem_bits {
        constexpr uint32_t TX_SECTION_EMPTY = (8 << 0);  ///< Value Of The Transmit FIFO Section Empty Threshold
    }

    /// TAEM Register bits
    namespace taem_bits {
        constexpr uint32_t TX_ALMOST_EMPTY = (8 << 0);  ///< Value of Transmit FIFO Almost Empty Threshold
    }

    /// TAFL Register bits
    namespace tafl_bits {
        constexpr uint32_t TX_ALMOST_FULL = (8 << 0);  ///< Value Of The Transmit FIFO Almost Full Threshold
    }

    /// TIPG Register bits
    namespace tipg_bits {
        constexpr uint32_t IPG = (5 << 0);  ///< Transmit Inter-Packet Gap
    }

    /// FTRL Register bits
    namespace ftrl_bits {
        constexpr uint32_t TRUNC_FL = (14 << 0);  ///< Frame Truncation Length
    }

    /// TACC Register bits
    namespace tacc_bits {
        constexpr uint32_t SHIFT16 = (1U << 0);  ///< TX FIFO Shift-16
        constexpr uint32_t IPCHK = (1U << 3);  ///< Enables insertion of IP header checksum.
        constexpr uint32_t PROCHK = (1U << 4);  ///< Enables insertion of protocol checksum.
    }

    /// RACC Register bits
    namespace racc_bits {
        constexpr uint32_t PADREM = (1U << 0);  ///< Enable Padding Removal For Short IP Frames
        constexpr uint32_t IPDIS = (1U << 1);  ///< Enable Discard Of Frames With Wrong IPv4 Header Checksum
        constexpr uint32_t PRODIS = (1U << 2);  ///< Enable Discard Of Frames With Wrong Protocol Checksum
        constexpr uint32_t LINEDIS = (1U << 6);  ///< Enable Discard Of Frames With MAC Layer Errors
        constexpr uint32_t SHIFT16 = (1U << 7);  ///< RX FIFO Shift-16
    }

    /// RMON_T_PACKETS Register bits
    namespace rmon_t_packets_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Packet count
    }

    /// RMON_T_BC_PKT Register bits
    namespace rmon_t_bc_pkt_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Broadcast packets
    }

    /// RMON_T_MC_PKT Register bits
    namespace rmon_t_mc_pkt_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Multicast packets
    }

    /// RMON_T_CRC_ALIGN Register bits
    namespace rmon_t_crc_align_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Packets with CRC/align error
    }

    /// RMON_T_UNDERSIZE Register bits
    namespace rmon_t_undersize_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Number of transmit packets less than 64 bytes with good CRC
    }

    /// RMON_T_OVERSIZE Register bits
    namespace rmon_t_oversize_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Number of transmit packets greater than MAX_FL bytes with good CRC
    }

    /// RMON_T_FRAG Register bits
    namespace rmon_t_frag_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Number of packets less than 64 bytes with bad CRC
    }

    /// RMON_T_JAB Register bits
    namespace rmon_t_jab_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Number of transmit packets greater than MAX_FL bytes and bad CRC
    }

    /// RMON_T_COL Register bits
    namespace rmon_t_col_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Number of transmit collisions
    }

    /// RMON_T_P64 Register bits
    namespace rmon_t_p64_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Number of 64-byte transmit packets
    }

    /// RMON_T_P65TO127 Register bits
    namespace rmon_t_p65to127_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Number of 65- to 127-byte transmit packets
    }

    /// RMON_T_P128TO255 Register bits
    namespace rmon_t_p128to255_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Number of 128- to 255-byte transmit packets
    }

    /// RMON_T_P256TO511 Register bits
    namespace rmon_t_p256to511_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Number of 256- to 511-byte transmit packets
    }

    /// RMON_T_P512TO1023 Register bits
    namespace rmon_t_p512to1023_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Number of 512- to 1023-byte transmit packets
    }

    /// RMON_T_P1024TO2047 Register bits
    namespace rmon_t_p1024to2047_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Number of 1024- to 2047-byte transmit packets
    }

    /// RMON_T_P_GTE2048 Register bits
    namespace rmon_t_p_gte2048_bits {
        constexpr uint32_t TXPKTS = (16 << 0);  ///< Number of transmit packets greater than 2048 bytes
    }

    /// RMON_T_OCTETS Register bits
    namespace rmon_t_octets_bits {
        constexpr uint32_t TXOCTS = (32 << 0);  ///< Number of transmit octets
    }

    /// IEEE_T_FRAME_OK Register bits
    namespace ieee_t_frame_ok_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of frames transmitted OK
    }

    /// IEEE_T_1COL Register bits
    namespace ieee_t_1col_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of frames transmitted with one collision
    }

    /// IEEE_T_MCOL Register bits
    namespace ieee_t_mcol_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of frames transmitted with multiple collisions
    }

    /// IEEE_T_DEF Register bits
    namespace ieee_t_def_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of frames transmitted with deferral delay
    }

    /// IEEE_T_LCOL Register bits
    namespace ieee_t_lcol_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of frames transmitted with late collision
    }

    /// IEEE_T_EXCOL Register bits
    namespace ieee_t_excol_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of frames transmitted with excessive collisions
    }

    /// IEEE_T_MACERR Register bits
    namespace ieee_t_macerr_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of frames transmitted with transmit FIFO underrun
    }

    /// IEEE_T_CSERR Register bits
    namespace ieee_t_cserr_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of frames transmitted with carrier sense error
    }

    /// IEEE_T_SQE Register bits
    namespace ieee_t_sqe_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< This read-only field is reserved and always has the value 0
    }

    /// IEEE_T_FDXFC Register bits
    namespace ieee_t_fdxfc_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of flow-control pause frames transmitted
    }

    /// IEEE_T_OCTETS_OK Register bits
    namespace ieee_t_octets_ok_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< Octet count for frames transmitted without error Counts total octets (includes header and FCS fields).
    }

    /// RMON_R_PACKETS Register bits
    namespace rmon_r_packets_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of packets received
    }

    /// RMON_R_BC_PKT Register bits
    namespace rmon_r_bc_pkt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of receive broadcast packets
    }

    /// RMON_R_MC_PKT Register bits
    namespace rmon_r_mc_pkt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of receive multicast packets
    }

    /// RMON_R_CRC_ALIGN Register bits
    namespace rmon_r_crc_align_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of receive packets with CRC or align error
    }

    /// RMON_R_UNDERSIZE Register bits
    namespace rmon_r_undersize_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of receive packets with less than 64 bytes and good CRC
    }

    /// RMON_R_OVERSIZE Register bits
    namespace rmon_r_oversize_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of receive packets greater than MAX_FL and good CRC
    }

    /// RMON_R_FRAG Register bits
    namespace rmon_r_frag_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of receive packets with less than 64 bytes and bad CRC
    }

    /// RMON_R_JAB Register bits
    namespace rmon_r_jab_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of receive packets greater than MAX_FL and bad CRC
    }

    /// RMON_R_P64 Register bits
    namespace rmon_r_p64_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of 64-byte receive packets
    }

    /// RMON_R_P65TO127 Register bits
    namespace rmon_r_p65to127_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of 65- to 127-byte recieve packets
    }

    /// RMON_R_P128TO255 Register bits
    namespace rmon_r_p128to255_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of 128- to 255-byte recieve packets
    }

    /// RMON_R_P256TO511 Register bits
    namespace rmon_r_p256to511_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of 256- to 511-byte recieve packets
    }

    /// RMON_R_P512TO1023 Register bits
    namespace rmon_r_p512to1023_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of 512- to 1023-byte recieve packets
    }

    /// RMON_R_P1024TO2047 Register bits
    namespace rmon_r_p1024to2047_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of 1024- to 2047-byte recieve packets
    }

    /// RMON_R_P_GTE2048 Register bits
    namespace rmon_r_p_gte2048_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of greater-than-2048-byte recieve packets
    }

    /// RMON_R_OCTETS Register bits
    namespace rmon_r_octets_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< Number of receive octets
    }

    /// IEEE_R_DROP Register bits
    namespace ieee_r_drop_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Frame count
    }

    /// IEEE_R_FRAME_OK Register bits
    namespace ieee_r_frame_ok_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of frames received OK
    }

    /// IEEE_R_CRC Register bits
    namespace ieee_r_crc_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of frames received with CRC error
    }

    /// IEEE_R_ALIGN Register bits
    namespace ieee_r_align_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of frames received with alignment error
    }

    /// IEEE_R_MACERR Register bits
    namespace ieee_r_macerr_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Receive FIFO overflow count
    }

    /// IEEE_R_FDXFC Register bits
    namespace ieee_r_fdxfc_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Number of flow-control pause frames received
    }

    /// IEEE_R_OCTETS_OK Register bits
    namespace ieee_r_octets_ok_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< Number of octets for frames received without error
    }

    /// ATCR Register bits
    namespace atcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Timer
        constexpr uint32_t OFFEN = (1U << 2);  ///< Enable One-Shot Offset Event
        constexpr uint32_t OFFRST = (1U << 3);  ///< Reset Timer On Offset Event
        constexpr uint32_t PEREN = (1U << 4);  ///< Enable Periodical Event
        constexpr uint32_t PINPER = (1U << 7);  ///< Enables event signal output assertion on period event
        constexpr uint32_t RESTART = (1U << 9);  ///< Reset Timer
        constexpr uint32_t CAPTURE = (1U << 11);  ///< Capture Timer Value
        constexpr uint32_t SLAVE = (1U << 13);  ///< Enable Timer Slave Mode
    }

    /// ATVR Register bits
    namespace atvr_bits {
        constexpr uint32_t ATIME = (32 << 0);  ///< A write sets the timer
    }

    /// ATOFF Register bits
    namespace atoff_bits {
        constexpr uint32_t OFFSET = (32 << 0);  ///< Offset value for one-shot event generation
    }

    /// ATPER Register bits
    namespace atper_bits {
        constexpr uint32_t PERIOD = (32 << 0);  ///< Value for generating periodic events
    }

    /// ATCOR Register bits
    namespace atcor_bits {
        constexpr uint32_t COR = (31 << 0);  ///< Correction Counter Wrap-Around Value
    }

    /// ATINC Register bits
    namespace atinc_bits {
        constexpr uint32_t INC = (7 << 0);  ///< Clock Period Of The Timestamping Clock (ts_clk) In Nanoseconds
        constexpr uint32_t INC_CORR = (7 << 8);  ///< Correction Increment Value
    }

    /// ATSTMP Register bits
    namespace atstmp_bits {
        constexpr uint32_t TIMESTAMP = (32 << 0);  ///< Timestamp of the last frame transmitted by the core that had TxBD[TS] set
    }

    /// TGSR Register bits
    namespace tgsr_bits {
        constexpr uint32_t TF0 = (1U << 0);  ///< Copy Of Timer Flag For Channel 0
        constexpr uint32_t TF1 = (1U << 1);  ///< Copy Of Timer Flag For Channel 1
        constexpr uint32_t TF2 = (1U << 2);  ///< Copy Of Timer Flag For Channel 2
        constexpr uint32_t TF3 = (1U << 3);  ///< Copy Of Timer Flag For Channel 3
    }

    /// TCSR%s Register bits
    namespace tcsr%s_bits {
        constexpr uint32_t TDRE = (1U << 0);  ///< Timer DMA Request Enable
        constexpr uint32_t TMODE = (4 << 2);  ///< Timer Mode
        constexpr uint32_t TIE = (1U << 6);  ///< Timer Interrupt Enable
        constexpr uint32_t TF = (1U << 7);  ///< Timer Flag
        constexpr uint32_t TPWC = (5 << 11);  ///< Timer PulseWidth Control
    }

    /// TCCR%s Register bits
    namespace tccr%s_bits {
        constexpr uint32_t TCC = (32 << 0);  ///< Timer Capture Compare
    }

}

// ============================================================================
// ENET2 Peripheral
// ============================================================================

namespace enet2 {
    /// Base addresses
    constexpr uint32_t ENET2_BASE = 0x402D4000;

    /// ENET2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ENET2 = reinterpret_cast<Registers*>(ENET2_BASE);

}

// ============================================================================
// SEMC Peripheral
// ============================================================================

namespace semc {
    /// Base addresses
    constexpr uint32_t SEMC_BASE = 0x402F0000;

    /// SEMC Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Control Register
        volatile uint32_t IOCR;  ///< Offset: 0x04 - IO Mux Control Register
        volatile uint32_t BMCR0;  ///< Offset: 0x08 - Master Bus (AXI) Control Register 0
        volatile uint32_t BMCR1;  ///< Offset: 0x0C - Master Bus (AXI) Control Register 1
        volatile uint32_t BR0;  ///< Offset: 0x10 - Base Register 0 (For SDRAM CS0 device)
        volatile uint32_t BR1;  ///< Offset: 0x14 - Base Register 1 (For SDRAM CS1 device)
        volatile uint32_t BR2;  ///< Offset: 0x18 - Base Register 2 (For SDRAM CS2 device)
        volatile uint32_t BR3;  ///< Offset: 0x1C - Base Register 3 (For SDRAM CS3 device)
        volatile uint32_t BR4;  ///< Offset: 0x20 - Base Register 4 (For NAND device)
        volatile uint32_t BR5;  ///< Offset: 0x24 - Base Register 5 (For NOR device)
        volatile uint32_t BR6;  ///< Offset: 0x28 - Base Register 6 (For PSRAM device)
        volatile uint32_t BR7;  ///< Offset: 0x2C - Base Register 7 (For DBI-B (MIPI Display Bus Interface...
        volatile uint32_t BR8;  ///< Offset: 0x30 - Base Register 8 (For NAND device)
        volatile uint32_t DLLCR;  ///< Offset: 0x34 - DLL Control Register
        volatile uint32_t INTEN;  ///< Offset: 0x38 - Interrupt Enable Register
        volatile uint32_t INTR;  ///< Offset: 0x3C - Interrupt Enable Register
        volatile uint32_t SDRAMCR0;  ///< Offset: 0x40 - SDRAM control register 0
        volatile uint32_t SDRAMCR1;  ///< Offset: 0x44 - SDRAM control register 1
        volatile uint32_t SDRAMCR2;  ///< Offset: 0x48 - SDRAM control register 2
        volatile uint32_t SDRAMCR3;  ///< Offset: 0x4C - SDRAM control register 3
        volatile uint32_t NANDCR0;  ///< Offset: 0x50 - NAND control register 0
        volatile uint32_t NANDCR1;  ///< Offset: 0x54 - NAND control register 1
        volatile uint32_t NANDCR2;  ///< Offset: 0x58 - NAND control register 2
        volatile uint32_t NANDCR3;  ///< Offset: 0x5C - NAND control register 3
        volatile uint32_t NORCR0;  ///< Offset: 0x60 - NOR control register 0
        volatile uint32_t NORCR1;  ///< Offset: 0x64 - NOR control register 1
        volatile uint32_t NORCR2;  ///< Offset: 0x68 - NOR control register 2
        volatile uint32_t NORCR3;  ///< Offset: 0x6C - NOR control register 3
        volatile uint32_t SRAMCR0;  ///< Offset: 0x70 - SRAM control register 0
        volatile uint32_t SRAMCR1;  ///< Offset: 0x74 - SRAM control register 1
        volatile uint32_t SRAMCR2;  ///< Offset: 0x78 - SRAM control register 2
        volatile uint32_t SRAMCR3;  ///< Offset: 0x7C - SRAM control register 3
        volatile uint32_t DBICR0;  ///< Offset: 0x80 - DBI-B control register 0
        volatile uint32_t DBICR1;  ///< Offset: 0x84 - DBI-B control register 1
        volatile uint32_t IPCR0;  ///< Offset: 0x90 - IP Command control register 0
        volatile uint32_t IPCR1;  ///< Offset: 0x94 - IP Command control register 1
        volatile uint32_t IPCR2;  ///< Offset: 0x98 - IP Command control register 2
        volatile uint32_t IPCMD;  ///< Offset: 0x9C - IP Command register
        volatile uint32_t IPTXDAT;  ///< Offset: 0xA0 - TX DATA register (for IP Command)
        volatile uint32_t IPRXDAT;  ///< Offset: 0xB0 - RX DATA register (for IP Command)
        volatile uint32_t STS0;  ///< Offset: 0xC0 - Status register 0
        volatile uint32_t STS1;  ///< Offset: 0xC4 - Status register 1
        volatile uint32_t STS2;  ///< Offset: 0xC8 - Status register 2
        volatile uint32_t STS3;  ///< Offset: 0xCC - Status register 3
        volatile uint32_t STS4;  ///< Offset: 0xD0 - Status register 4
        volatile uint32_t STS5;  ///< Offset: 0xD4 - Status register 5
        volatile uint32_t STS6;  ///< Offset: 0xD8 - Status register 6
        volatile uint32_t STS7;  ///< Offset: 0xDC - Status register 7
        volatile uint32_t STS8;  ///< Offset: 0xE0 - Status register 8
        volatile uint32_t STS9;  ///< Offset: 0xE4 - Status register 9
        volatile uint32_t STS10;  ///< Offset: 0xE8 - Status register 10
        volatile uint32_t STS11;  ///< Offset: 0xEC - Status register 11
        volatile uint32_t STS12;  ///< Offset: 0xF0 - Status register 12
        volatile uint32_t STS13;  ///< Offset: 0xF4 - Status register 13
        volatile uint32_t STS14;  ///< Offset: 0xF8 - Status register 14
        volatile uint32_t STS15;  ///< Offset: 0xFC - Status register 15
    };

    /// Peripheral instances
    inline Registers* SEMC = reinterpret_cast<Registers*>(SEMC_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t SWRST = (1U << 0);  ///< Software Reset
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable
        constexpr uint32_t DQSMD = (1U << 2);  ///< DQS (read strobe) mode
        constexpr uint32_t WPOL0 = (1U << 6);  ///< WAIT/RDY# polarity for NOR/PSRAM
        constexpr uint32_t WPOL1 = (1U << 7);  ///< WAIT/RDY# polarity for NAND
        constexpr uint32_t DQSSEL = (1U << 10);  ///< Select DQS source when DQSMD and DLLSEL both set.
        constexpr uint32_t DLLSEL = (1U << 11);  ///< Select DLL delay chain clock input.
        constexpr uint32_t CTO = (8 << 16);  ///< Command Execution timeout cycles
        constexpr uint32_t BTO = (5 << 24);  ///< Bus timeout cycles
    }

    /// IOCR Register bits
    namespace iocr_bits {
        constexpr uint32_t MUX_A8 = (3 << 0);  ///< SEMC_A8 output selection
        constexpr uint32_t MUX_CSX0 = (3 << 3);  ///< SEMC_CSX0 output selection
        constexpr uint32_t MUX_CSX1 = (3 << 6);  ///< SEMC_CSX1 output selection
        constexpr uint32_t MUX_CSX2 = (3 << 9);  ///< SEMC_CSX2 output selection
        constexpr uint32_t MUX_CSX3 = (3 << 12);  ///< SEMC_CSX3 output selection
        constexpr uint32_t MUX_RDY = (3 << 15);  ///< SEMC_RDY function selection
        constexpr uint32_t MUX_CLKX0 = (1U << 24);  ///< SEMC_CLKX0 function selection
        constexpr uint32_t MUX_CLKX1 = (1U << 25);  ///< SEMC_CLKX1 function selection
    }

    /// BMCR0 Register bits
    namespace bmcr0_bits {
        constexpr uint32_t WQOS = (4 << 0);  ///< Weight of QoS
        constexpr uint32_t WAGE = (4 << 4);  ///< Weight of Aging
        constexpr uint32_t WSH = (8 << 8);  ///< Weight of Slave Hit (no read/write switch)
        constexpr uint32_t WRWS = (8 << 16);  ///< Weight of Slave Hit (Read/Write switch)
    }

    /// BMCR1 Register bits
    namespace bmcr1_bits {
        constexpr uint32_t WQOS = (4 << 0);  ///< Weight of QoS
        constexpr uint32_t WAGE = (4 << 4);  ///< Weight of Aging
        constexpr uint32_t WPH = (8 << 8);  ///< Weight of Page Hit
        constexpr uint32_t WRWS = (8 << 16);  ///< Weight of Read/Write switch
        constexpr uint32_t WBR = (8 << 24);  ///< Weight of Bank Rotation
    }

    /// BR0 Register bits
    namespace br0_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t MS = (5 << 1);  ///< Memory size
        constexpr uint32_t BA = (20 << 12);  ///< Base Address
    }

    /// BR1 Register bits
    namespace br1_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t MS = (5 << 1);  ///< Memory size
        constexpr uint32_t BA = (20 << 12);  ///< Base Address
    }

    /// BR2 Register bits
    namespace br2_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t MS = (5 << 1);  ///< Memory size
        constexpr uint32_t BA = (20 << 12);  ///< Base Address
    }

    /// BR3 Register bits
    namespace br3_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t MS = (5 << 1);  ///< Memory size
        constexpr uint32_t BA = (20 << 12);  ///< Base Address
    }

    /// BR4 Register bits
    namespace br4_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t MS = (5 << 1);  ///< Memory size
        constexpr uint32_t BA = (20 << 12);  ///< Base Address
    }

    /// BR5 Register bits
    namespace br5_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t MS = (5 << 1);  ///< Memory size
        constexpr uint32_t BA = (20 << 12);  ///< Base Address
    }

    /// BR6 Register bits
    namespace br6_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t MS = (5 << 1);  ///< Memory size
        constexpr uint32_t BA = (20 << 12);  ///< Base Address
    }

    /// BR7 Register bits
    namespace br7_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t MS = (5 << 1);  ///< Memory size
        constexpr uint32_t BA = (20 << 12);  ///< Base Address
    }

    /// BR8 Register bits
    namespace br8_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t MS = (5 << 1);  ///< Memory size
        constexpr uint32_t BA = (20 << 12);  ///< Base Address
    }

    /// DLLCR Register bits
    namespace dllcr_bits {
        constexpr uint32_t DLLEN = (1U << 0);  ///< DLL calibration enable.
        constexpr uint32_t DLLRESET = (1U << 1);  ///< Software could force a reset on DLL by setting this field to 0x1. This will cause the DLL to lose lock and re-calibrate to detect an ref_clock half period phase shift. The reset action is edge triggered, so software need to clear this bit after set this bit (no delay limitation).
        constexpr uint32_t SLVDLYTARGET = (4 << 3);  ///< The delay target for slave delay line is: ((SLVDLYTARGET+1) * 1/32 * clock cycle of reference clock (ipgclock).
        constexpr uint32_t OVRDEN = (1U << 8);  ///< Slave clock delay line delay cell number selection override enable.
        constexpr uint32_t OVRDVAL = (6 << 9);  ///< Slave clock delay line delay cell number selection override value.
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t IPCMDDONEEN = (1U << 0);  ///< IP command done interrupt enable
        constexpr uint32_t IPCMDERREN = (1U << 1);  ///< IP command error interrupt enable
        constexpr uint32_t AXICMDERREN = (1U << 2);  ///< AXI command error interrupt enable
        constexpr uint32_t AXIBUSERREN = (1U << 3);  ///< AXI bus error interrupt enable
        constexpr uint32_t NDPAGEENDEN = (1U << 4);  ///< This bit enable/disable the NDPAGEEND interrupt generation.
        constexpr uint32_t NDNOPENDEN = (1U << 5);  ///< This bit enable/disable the NDNOPEND interrupt generation.
    }

    /// INTR Register bits
    namespace intr_bits {
        constexpr uint32_t IPCMDDONE = (1U << 0);  ///< IP command normal done interrupt
        constexpr uint32_t IPCMDERR = (1U << 1);  ///< IP command error done interrupt
        constexpr uint32_t AXICMDERR = (1U << 2);  ///< AXI command error interrupt
        constexpr uint32_t AXIBUSERR = (1U << 3);  ///< AXI bus error interrupt
        constexpr uint32_t NDPAGEEND = (1U << 4);  ///< This interrupt is generated when the last address of one page in NAND device is written by AXI command
        constexpr uint32_t NDNOPEND = (1U << 5);  ///< This interrupt is generated when all pending AXI write command to NAND is finished on NAND interface.
    }

    /// SDRAMCR0 Register bits
    namespace sdramcr0_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Port Size
        constexpr uint32_t BL = (3 << 4);  ///< Burst Length
        constexpr uint32_t COL8 = (1U << 7);  ///< Column 8 selection bit
        constexpr uint32_t COL = (2 << 8);  ///< Column address bit number
        constexpr uint32_t CL = (2 << 10);  ///< CAS Latency
        constexpr uint32_t BANK2 = (1U << 14);  ///< 2 Bank selection bit
    }

    /// SDRAMCR1 Register bits
    namespace sdramcr1_bits {
        constexpr uint32_t PRE2ACT = (4 << 0);  ///< PRECHARGE to ACT/Refresh wait time
        constexpr uint32_t ACT2RW = (4 << 4);  ///< ACT to Read/Write wait time
        constexpr uint32_t RFRC = (5 << 8);  ///< Refresh recovery time
        constexpr uint32_t WRC = (3 << 13);  ///< Write recovery time
        constexpr uint32_t CKEOFF = (4 << 16);  ///< CKE OFF minimum time
        constexpr uint32_t ACT2PRE = (4 << 20);  ///< ACT to Precharge minimum time
    }

    /// SDRAMCR2 Register bits
    namespace sdramcr2_bits {
        constexpr uint32_t SRRC = (8 << 0);  ///< Self Refresh Recovery time
        constexpr uint32_t REF2REF = (8 << 8);  ///< Refresh to Refresh wait time
        constexpr uint32_t ACT2ACT = (8 << 16);  ///< ACT to ACT wait time
        constexpr uint32_t ITO = (8 << 24);  ///< SDRAM Idle timeout
    }

    /// SDRAMCR3 Register bits
    namespace sdramcr3_bits {
        constexpr uint32_t REN = (1U << 0);  ///< Refresh enable
        constexpr uint32_t REBL = (3 << 1);  ///< Refresh burst length
        constexpr uint32_t PRESCALE = (8 << 8);  ///< Prescaler timer period
        constexpr uint32_t RT = (8 << 16);  ///< Refresh timer period
        constexpr uint32_t UT = (8 << 24);  ///< Refresh urgent threshold
    }

    /// NANDCR0 Register bits
    namespace nandcr0_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Port Size
        constexpr uint32_t SYNCEN = (1U << 1);  ///< Select NAND controller mode.
        constexpr uint32_t BL = (3 << 4);  ///< Burst Length
        constexpr uint32_t EDO = (1U << 7);  ///< EDO mode enabled
        constexpr uint32_t COL = (3 << 8);  ///< Column address bit number
    }

    /// NANDCR1 Register bits
    namespace nandcr1_bits {
        constexpr uint32_t CES = (4 << 0);  ///< CE setup time
        constexpr uint32_t CEH = (4 << 4);  ///< CE hold time
        constexpr uint32_t WEL = (4 << 8);  ///< WE# LOW time
        constexpr uint32_t WEH = (4 << 12);  ///< WE# HIGH time
        constexpr uint32_t REL = (4 << 16);  ///< RE# LOW time
        constexpr uint32_t REH = (4 << 20);  ///< RE# HIGH time
        constexpr uint32_t TA = (4 << 24);  ///< Turnaround time
        constexpr uint32_t CEITV = (4 << 28);  ///< CE# interval time
    }

    /// NANDCR2 Register bits
    namespace nandcr2_bits {
        constexpr uint32_t TWHR = (6 << 0);  ///< WE# HIGH to RE# LOW wait time
        constexpr uint32_t TRHW = (6 << 6);  ///< RE# HIGH to WE# LOW wait time
        constexpr uint32_t TADL = (6 << 12);  ///< ALE to WRITE Data start wait time
        constexpr uint32_t TRR = (6 << 18);  ///< Ready to RE# LOW min wait time
        constexpr uint32_t TWB = (6 << 24);  ///< WE# HIGH to busy wait time
    }

    /// NANDCR3 Register bits
    namespace nandcr3_bits {
        constexpr uint32_t NDOPT1 = (1U << 0);  ///< NAND option bit 1
        constexpr uint32_t NDOPT2 = (1U << 1);  ///< NAND option bit 2
        constexpr uint32_t NDOPT3 = (1U << 2);  ///< NAND option bit 3
        constexpr uint32_t CLE = (1U << 3);  ///< NAND CLE Option
        constexpr uint32_t RDS = (4 << 16);  ///< Read Data Setup cycle time.
        constexpr uint32_t RDH = (4 << 20);  ///< Read Data Hold cycle time.
        constexpr uint32_t WDS = (4 << 24);  ///< Write Data Setup cycle time.
        constexpr uint32_t WDH = (4 << 28);  ///< Write Data Hold cycle time.
    }

    /// NORCR0 Register bits
    namespace norcr0_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Port Size
        constexpr uint32_t SYNCEN = (1U << 1);  ///< Select NOR controller mode.
        constexpr uint32_t BL = (3 << 4);  ///< Burst Length
        constexpr uint32_t AM = (2 << 8);  ///< Address Mode
        constexpr uint32_t ADVP = (1U << 10);  ///< ADV# polarity
        constexpr uint32_t ADVH = (1U << 11);  ///< ADV# level control during address hold state
        constexpr uint32_t COL = (4 << 12);  ///< Column Address bit width
    }

    /// NORCR1 Register bits
    namespace norcr1_bits {
        constexpr uint32_t CES = (4 << 0);  ///< CE setup time cycle
        constexpr uint32_t CEH = (4 << 4);  ///< CE hold min time (CEH+1) cycle
        constexpr uint32_t AS = (4 << 8);  ///< Address setup time
        constexpr uint32_t AH = (4 << 12);  ///< Address hold time
        constexpr uint32_t WEL = (4 << 16);  ///< WE LOW time (WEL+1) cycle
        constexpr uint32_t WEH = (4 << 20);  ///< WE HIGH time (WEH+1) cycle
        constexpr uint32_t REL = (4 << 24);  ///< RE LOW time (REL+1) cycle
        constexpr uint32_t REH = (4 << 28);  ///< RE HIGH time (REH+1) cycle
    }

    /// NORCR2 Register bits
    namespace norcr2_bits {
        constexpr uint32_t TA = (4 << 8);  ///< Turnaround time cycle
        constexpr uint32_t AWDH = (4 << 12);  ///< Address to write data hold time cycle
        constexpr uint32_t LC = (4 << 16);  ///< Latency count
        constexpr uint32_t RD = (4 << 20);  ///< Read cycle time
        constexpr uint32_t CEITV = (4 << 24);  ///< CE# interval min time
        constexpr uint32_t RDH = (4 << 28);  ///< Read cycle hold time
    }

    /// NORCR3 Register bits
    namespace norcr3_bits {
        constexpr uint32_t ASSR = (4 << 0);  ///< Address setup time for synchronous read
        constexpr uint32_t AHSR = (4 << 4);  ///< Address hold time for synchronous read
    }

    /// SRAMCR0 Register bits
    namespace sramcr0_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Port Size
        constexpr uint32_t SYNCEN = (1U << 1);  ///< Select SRAM controller mode.
        constexpr uint32_t BL = (3 << 4);  ///< Burst Length
        constexpr uint32_t AM = (2 << 8);  ///< Address Mode
        constexpr uint32_t ADVP = (1U << 10);  ///< ADV# polarity
        constexpr uint32_t ADVH = (1U << 11);  ///< ADV# level control during address hold state
        constexpr uint32_t COL = (4 << 12);  ///< Column Address bit width
    }

    /// SRAMCR1 Register bits
    namespace sramcr1_bits {
        constexpr uint32_t CES = (4 << 0);  ///< CE setup time cycle
        constexpr uint32_t CEH = (4 << 4);  ///< CE hold min time
        constexpr uint32_t AS = (4 << 8);  ///< Address setup time
        constexpr uint32_t AH = (4 << 12);  ///< Address hold time
        constexpr uint32_t WEL = (4 << 16);  ///< WE LOW time (WEL+1) cycle
        constexpr uint32_t WEH = (4 << 20);  ///< WE HIGH time (WEH+1) cycle
        constexpr uint32_t REL = (4 << 24);  ///< RE LOW time (REL+1) cycle
        constexpr uint32_t REH = (4 << 28);  ///< RE HIGH time (REH+1) cycle
    }

    /// SRAMCR2 Register bits
    namespace sramcr2_bits {
        constexpr uint32_t WDS = (4 << 0);  ///< Write Data setup time (WDS+1) cycle
        constexpr uint32_t WDH = (4 << 4);  ///< Write Data hold time WDH cycle
        constexpr uint32_t TA = (4 << 8);  ///< Turnaround time cycle
        constexpr uint32_t AWDH = (4 << 12);  ///< Address to write data hold time cycle
        constexpr uint32_t LC = (4 << 16);  ///< Latency count
        constexpr uint32_t RD = (4 << 20);  ///< Read cycle time
        constexpr uint32_t CEITV = (4 << 24);  ///< CE# interval min time
        constexpr uint32_t RDH = (4 << 28);  ///< Read cycle hold time
    }

    /// DBICR0 Register bits
    namespace dbicr0_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Port Size
        constexpr uint32_t BL = (3 << 4);  ///< Burst Length
        constexpr uint32_t COL = (4 << 12);  ///< Column Address bit width
    }

    /// DBICR1 Register bits
    namespace dbicr1_bits {
        constexpr uint32_t CES = (4 << 0);  ///< CSX Setup Time
        constexpr uint32_t CEH = (4 << 4);  ///< CSX Hold Time
        constexpr uint32_t WEL = (4 << 8);  ///< WRX Low Time
        constexpr uint32_t WEH = (4 << 12);  ///< WRX High Time
        constexpr uint32_t REL = (6 << 16);  ///< RDX Low Time
        constexpr uint32_t REH = (6 << 22);  ///< RDX High Time
        constexpr uint32_t CEITV = (4 << 28);  ///< CSX interval min time
    }

    /// IPCR0 Register bits
    namespace ipcr0_bits {
        constexpr uint32_t SA = (32 << 0);  ///< Slave address
    }

    /// IPCR1 Register bits
    namespace ipcr1_bits {
        constexpr uint32_t DATSZ = (3 << 0);  ///< Data Size in Byte
        constexpr uint32_t NAND_EXT_ADDR = (8 << 8);  ///< NAND Extended Address
    }

    /// IPCR2 Register bits
    namespace ipcr2_bits {
        constexpr uint32_t BM0 = (1U << 0);  ///< Byte Mask for Byte 0 (IPTXD bit 7:0)
        constexpr uint32_t BM1 = (1U << 1);  ///< Byte Mask for Byte 1 (IPTXD bit 15:8)
        constexpr uint32_t BM2 = (1U << 2);  ///< Byte Mask for Byte 2 (IPTXD bit 23:16)
        constexpr uint32_t BM3 = (1U << 3);  ///< Byte Mask for Byte 3 (IPTXD bit 31:24)
    }

    /// IPCMD Register bits
    namespace ipcmd_bits {
        constexpr uint32_t CMD = (16 << 0);  ///< SDRAM Commands: 0x8: READ 0x9: WRITE 0xA: MODESET 0xB: ACTIVE 0xC: AUTO REFRESH 0xD: SELF REFRESH 0xE: PRECHARGE 0xF: PRECHARGE ALL Others: RSVD SELF REFRESH will be sent to all SDRAM devices because they shared same SEMC_CLK pin
        constexpr uint32_t KEY = (16 << 16);  ///< This field should be written with 0xA55A when trigging an IP command for all device types
    }

    /// IPTXDAT Register bits
    namespace iptxdat_bits {
        constexpr uint32_t DAT = (32 << 0);  ///< no description available
    }

    /// IPRXDAT Register bits
    namespace iprxdat_bits {
        constexpr uint32_t DAT = (32 << 0);  ///< no description available
    }

    /// STS0 Register bits
    namespace sts0_bits {
        constexpr uint32_t IDLE = (1U << 0);  ///< Indicating whether SEMC is in IDLE state.
        constexpr uint32_t NARDY = (1U << 1);  ///< Indicating NAND device Ready/WAIT# pin level.
    }

    /// STS2 Register bits
    namespace sts2_bits {
        constexpr uint32_t NDWRPEND = (1U << 3);  ///< This field indicating whether there is pending AXI command (write) to NAND device.
    }

    /// STS12 Register bits
    namespace sts12_bits {
        constexpr uint32_t NDADDR = (32 << 0);  ///< This field indicating the last write address (AXI command) to NAND device (without base address in SEMC_BR4).
    }

    /// STS13 Register bits
    namespace sts13_bits {
        constexpr uint32_t SLVLOCK = (1U << 0);  ///< Sample clock slave delay line locked.
        constexpr uint32_t REFLOCK = (1U << 1);  ///< Sample clock reference delay line locked.
        constexpr uint32_t SLVSEL = (6 << 2);  ///< Sample clock slave delay line delay cell number selection .
        constexpr uint32_t REFSEL = (6 << 8);  ///< Sample clock reference delay line delay cell number selection.
    }

}

// ============================================================================
// DCP Peripheral
// ============================================================================

namespace dcp {
    /// Base addresses
    constexpr uint32_t DCP_BASE = 0x402FC000;

    /// DCP Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - DCP control register 0
        volatile uint32_t CTRL_SET;  ///< Offset: 0x04 - DCP control register 0
        volatile uint32_t CTRL_CLR;  ///< Offset: 0x08 - DCP control register 0
        volatile uint32_t CTRL_TOG;  ///< Offset: 0x0C - DCP control register 0
        volatile uint32_t STAT;  ///< Offset: 0x10 - DCP status register
        volatile uint32_t STAT_SET;  ///< Offset: 0x14 - DCP status register
        volatile uint32_t STAT_CLR;  ///< Offset: 0x18 - DCP status register
        volatile uint32_t STAT_TOG;  ///< Offset: 0x1C - DCP status register
        volatile uint32_t CHANNELCTRL;  ///< Offset: 0x20 - DCP channel control register
        volatile uint32_t CHANNELCTRL_SET;  ///< Offset: 0x24 - DCP channel control register
        volatile uint32_t CHANNELCTRL_CLR;  ///< Offset: 0x28 - DCP channel control register
        volatile uint32_t CHANNELCTRL_TOG;  ///< Offset: 0x2C - DCP channel control register
        volatile uint32_t CAPABILITY0;  ///< Offset: 0x30 - DCP capability 0 register
        volatile uint32_t CAPABILITY1;  ///< Offset: 0x40 - DCP capability 1 register
        volatile uint32_t CONTEXT;  ///< Offset: 0x50 - DCP context buffer pointer
        volatile uint32_t KEY;  ///< Offset: 0x60 - DCP key index
        volatile uint32_t KEYDATA;  ///< Offset: 0x70 - DCP key data
        volatile uint32_t PACKET0;  ///< Offset: 0x80 - DCP work packet 0 status register
        volatile uint32_t PACKET1;  ///< Offset: 0x90 - DCP work packet 1 status register
        volatile uint32_t PACKET2;  ///< Offset: 0xA0 - DCP work packet 2 status register
        volatile uint32_t PACKET3;  ///< Offset: 0xB0 - DCP work packet 3 status register
        volatile uint32_t PACKET4;  ///< Offset: 0xC0 - DCP work packet 4 status register
        volatile uint32_t PACKET5;  ///< Offset: 0xD0 - DCP work packet 5 status register
        volatile uint32_t PACKET6;  ///< Offset: 0xE0 - DCP work packet 6 status register
        volatile uint32_t CH0CMDPTR;  ///< Offset: 0x100 - DCP channel 0 command pointer address register
        volatile uint32_t CH0SEMA;  ///< Offset: 0x110 - DCP channel 0 semaphore register
        volatile uint32_t CH0STAT;  ///< Offset: 0x120 - DCP channel 0 status register
        volatile uint32_t CH0STAT_SET;  ///< Offset: 0x124 - DCP channel 0 status register
        volatile uint32_t CH0STAT_CLR;  ///< Offset: 0x128 - DCP channel 0 status register
        volatile uint32_t CH0STAT_TOG;  ///< Offset: 0x12C - DCP channel 0 status register
        volatile uint32_t CH0OPTS;  ///< Offset: 0x130 - DCP channel 0 options register
        volatile uint32_t CH0OPTS_SET;  ///< Offset: 0x134 - DCP channel 0 options register
        volatile uint32_t CH0OPTS_CLR;  ///< Offset: 0x138 - DCP channel 0 options register
        volatile uint32_t CH0OPTS_TOG;  ///< Offset: 0x13C - DCP channel 0 options register
        volatile uint32_t CH1CMDPTR;  ///< Offset: 0x140 - DCP channel 1 command pointer address register
        volatile uint32_t CH1SEMA;  ///< Offset: 0x150 - DCP channel 1 semaphore register
        volatile uint32_t CH1STAT;  ///< Offset: 0x160 - DCP channel 1 status register
        volatile uint32_t CH1STAT_SET;  ///< Offset: 0x164 - DCP channel 1 status register
        volatile uint32_t CH1STAT_CLR;  ///< Offset: 0x168 - DCP channel 1 status register
        volatile uint32_t CH1STAT_TOG;  ///< Offset: 0x16C - DCP channel 1 status register
        volatile uint32_t CH1OPTS;  ///< Offset: 0x170 - DCP channel 1 options register
        volatile uint32_t CH1OPTS_SET;  ///< Offset: 0x174 - DCP channel 1 options register
        volatile uint32_t CH1OPTS_CLR;  ///< Offset: 0x178 - DCP channel 1 options register
        volatile uint32_t CH1OPTS_TOG;  ///< Offset: 0x17C - DCP channel 1 options register
        volatile uint32_t CH2CMDPTR;  ///< Offset: 0x180 - DCP channel 2 command pointer address register
        volatile uint32_t CH2SEMA;  ///< Offset: 0x190 - DCP channel 2 semaphore register
        volatile uint32_t CH2STAT;  ///< Offset: 0x1A0 - DCP channel 2 status register
        volatile uint32_t CH2STAT_SET;  ///< Offset: 0x1A4 - DCP channel 2 status register
        volatile uint32_t CH2STAT_CLR;  ///< Offset: 0x1A8 - DCP channel 2 status register
        volatile uint32_t CH2STAT_TOG;  ///< Offset: 0x1AC - DCP channel 2 status register
        volatile uint32_t CH2OPTS;  ///< Offset: 0x1B0 - DCP channel 2 options register
        volatile uint32_t CH2OPTS_SET;  ///< Offset: 0x1B4 - DCP channel 2 options register
        volatile uint32_t CH2OPTS_CLR;  ///< Offset: 0x1B8 - DCP channel 2 options register
        volatile uint32_t CH2OPTS_TOG;  ///< Offset: 0x1BC - DCP channel 2 options register
        volatile uint32_t CH3CMDPTR;  ///< Offset: 0x1C0 - DCP channel 3 command pointer address register
        volatile uint32_t CH3SEMA;  ///< Offset: 0x1D0 - DCP channel 3 semaphore register
        volatile uint32_t CH3STAT;  ///< Offset: 0x1E0 - DCP channel 3 status register
        volatile uint32_t CH3STAT_SET;  ///< Offset: 0x1E4 - DCP channel 3 status register
        volatile uint32_t CH3STAT_CLR;  ///< Offset: 0x1E8 - DCP channel 3 status register
        volatile uint32_t CH3STAT_TOG;  ///< Offset: 0x1EC - DCP channel 3 status register
        volatile uint32_t CH3OPTS;  ///< Offset: 0x1F0 - DCP channel 3 options register
        volatile uint32_t CH3OPTS_SET;  ///< Offset: 0x1F4 - DCP channel 3 options register
        volatile uint32_t CH3OPTS_CLR;  ///< Offset: 0x1F8 - DCP channel 3 options register
        volatile uint32_t CH3OPTS_TOG;  ///< Offset: 0x1FC - DCP channel 3 options register
        volatile uint32_t DBGSELECT;  ///< Offset: 0x400 - DCP debug select register
        volatile uint32_t DBGDATA;  ///< Offset: 0x410 - DCP debug data register
        volatile uint32_t PAGETABLE;  ///< Offset: 0x420 - DCP page table register
        volatile uint32_t VERSION;  ///< Offset: 0x430 - DCP version register
    };

    /// Peripheral instances
    inline Registers* DCP = reinterpret_cast<Registers*>(DCP_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t CHANNEL_INTERRUPT_ENABLE = (8 << 0);  ///< Per-channel interrupt enable bit
        constexpr uint32_t ENABLE_CONTEXT_SWITCHING = (1U << 21);  ///< Enable automatic context switching for the channels
        constexpr uint32_t ENABLE_CONTEXT_CACHING = (1U << 22);  ///< The software must set this bit to enable the caching of contexts between the operations
        constexpr uint32_t GATHER_RESIDUAL_WRITES = (1U << 23);  ///< The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
        constexpr uint32_t PRESENT_SHA = (1U << 28);  ///< Indicates whether the SHA1/SHA2 functions are present.
        constexpr uint32_t PRESENT_CRYPTO = (1U << 29);  ///< Indicates whether the crypto (cipher/hash) functions are present.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for a normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< Set this bit to zero to enable a normal DCP operation
    }

    /// CTRL_SET Register bits
    namespace ctrl_set_bits {
        constexpr uint32_t CHANNEL_INTERRUPT_ENABLE = (8 << 0);  ///< Per-channel interrupt enable bit
        constexpr uint32_t ENABLE_CONTEXT_SWITCHING = (1U << 21);  ///< Enable automatic context switching for the channels
        constexpr uint32_t ENABLE_CONTEXT_CACHING = (1U << 22);  ///< The software must set this bit to enable the caching of contexts between the operations
        constexpr uint32_t GATHER_RESIDUAL_WRITES = (1U << 23);  ///< The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
        constexpr uint32_t PRESENT_SHA = (1U << 28);  ///< Indicates whether the SHA1/SHA2 functions are present.
        constexpr uint32_t PRESENT_CRYPTO = (1U << 29);  ///< Indicates whether the crypto (cipher/hash) functions are present.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for a normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< Set this bit to zero to enable a normal DCP operation
    }

    /// CTRL_CLR Register bits
    namespace ctrl_clr_bits {
        constexpr uint32_t CHANNEL_INTERRUPT_ENABLE = (8 << 0);  ///< Per-channel interrupt enable bit
        constexpr uint32_t ENABLE_CONTEXT_SWITCHING = (1U << 21);  ///< Enable automatic context switching for the channels
        constexpr uint32_t ENABLE_CONTEXT_CACHING = (1U << 22);  ///< The software must set this bit to enable the caching of contexts between the operations
        constexpr uint32_t GATHER_RESIDUAL_WRITES = (1U << 23);  ///< The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
        constexpr uint32_t PRESENT_SHA = (1U << 28);  ///< Indicates whether the SHA1/SHA2 functions are present.
        constexpr uint32_t PRESENT_CRYPTO = (1U << 29);  ///< Indicates whether the crypto (cipher/hash) functions are present.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for a normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< Set this bit to zero to enable a normal DCP operation
    }

    /// CTRL_TOG Register bits
    namespace ctrl_tog_bits {
        constexpr uint32_t CHANNEL_INTERRUPT_ENABLE = (8 << 0);  ///< Per-channel interrupt enable bit
        constexpr uint32_t ENABLE_CONTEXT_SWITCHING = (1U << 21);  ///< Enable automatic context switching for the channels
        constexpr uint32_t ENABLE_CONTEXT_CACHING = (1U << 22);  ///< The software must set this bit to enable the caching of contexts between the operations
        constexpr uint32_t GATHER_RESIDUAL_WRITES = (1U << 23);  ///< The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
        constexpr uint32_t PRESENT_SHA = (1U << 28);  ///< Indicates whether the SHA1/SHA2 functions are present.
        constexpr uint32_t PRESENT_CRYPTO = (1U << 29);  ///< Indicates whether the crypto (cipher/hash) functions are present.
        constexpr uint32_t CLKGATE = (1U << 30);  ///< This bit must be set to zero for a normal operation
        constexpr uint32_t SFTRST = (1U << 31);  ///< Set this bit to zero to enable a normal DCP operation
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t IRQ = (4 << 0);  ///< Indicates which channels have pending interrupt requests
        constexpr uint32_t READY_CHANNELS = (8 << 16);  ///< Indicates which channels are ready to proceed with a transfer (the active channel is also included)
        constexpr uint32_t CUR_CHANNEL = (4 << 24);  ///< Current (active) channel (encoded)
        constexpr uint32_t OTP_KEY_READY = (1U << 28);  ///< When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
    }

    /// STAT_SET Register bits
    namespace stat_set_bits {
        constexpr uint32_t IRQ = (4 << 0);  ///< Indicates which channels have pending interrupt requests
        constexpr uint32_t READY_CHANNELS = (8 << 16);  ///< Indicates which channels are ready to proceed with a transfer (the active channel is also included)
        constexpr uint32_t CUR_CHANNEL = (4 << 24);  ///< Current (active) channel (encoded)
        constexpr uint32_t OTP_KEY_READY = (1U << 28);  ///< When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
    }

    /// STAT_CLR Register bits
    namespace stat_clr_bits {
        constexpr uint32_t IRQ = (4 << 0);  ///< Indicates which channels have pending interrupt requests
        constexpr uint32_t READY_CHANNELS = (8 << 16);  ///< Indicates which channels are ready to proceed with a transfer (the active channel is also included)
        constexpr uint32_t CUR_CHANNEL = (4 << 24);  ///< Current (active) channel (encoded)
        constexpr uint32_t OTP_KEY_READY = (1U << 28);  ///< When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
    }

    /// STAT_TOG Register bits
    namespace stat_tog_bits {
        constexpr uint32_t IRQ = (4 << 0);  ///< Indicates which channels have pending interrupt requests
        constexpr uint32_t READY_CHANNELS = (8 << 16);  ///< Indicates which channels are ready to proceed with a transfer (the active channel is also included)
        constexpr uint32_t CUR_CHANNEL = (4 << 24);  ///< Current (active) channel (encoded)
        constexpr uint32_t OTP_KEY_READY = (1U << 28);  ///< When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
    }

    /// CHANNELCTRL Register bits
    namespace channelctrl_bits {
        constexpr uint32_t ENABLE_CHANNEL = (8 << 0);  ///< Setting a bit in this field enables the DMA channel associated with it
        constexpr uint32_t HIGH_PRIORITY_CHANNEL = (8 << 8);  ///< Setting a bit in this field causes the corresponding channel to have high-priority arbitration
        constexpr uint32_t CH0_IRQ_MERGED = (1U << 16);  ///< Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
    }

    /// CHANNELCTRL_SET Register bits
    namespace channelctrl_set_bits {
        constexpr uint32_t ENABLE_CHANNEL = (8 << 0);  ///< Setting a bit in this field enables the DMA channel associated with it
        constexpr uint32_t HIGH_PRIORITY_CHANNEL = (8 << 8);  ///< Setting a bit in this field causes the corresponding channel to have high-priority arbitration
        constexpr uint32_t CH0_IRQ_MERGED = (1U << 16);  ///< Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
    }

    /// CHANNELCTRL_CLR Register bits
    namespace channelctrl_clr_bits {
        constexpr uint32_t ENABLE_CHANNEL = (8 << 0);  ///< Setting a bit in this field enables the DMA channel associated with it
        constexpr uint32_t HIGH_PRIORITY_CHANNEL = (8 << 8);  ///< Setting a bit in this field causes the corresponding channel to have high-priority arbitration
        constexpr uint32_t CH0_IRQ_MERGED = (1U << 16);  ///< Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
    }

    /// CHANNELCTRL_TOG Register bits
    namespace channelctrl_tog_bits {
        constexpr uint32_t ENABLE_CHANNEL = (8 << 0);  ///< Setting a bit in this field enables the DMA channel associated with it
        constexpr uint32_t HIGH_PRIORITY_CHANNEL = (8 << 8);  ///< Setting a bit in this field causes the corresponding channel to have high-priority arbitration
        constexpr uint32_t CH0_IRQ_MERGED = (1U << 16);  ///< Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
    }

    /// CAPABILITY0 Register bits
    namespace capability0_bits {
        constexpr uint32_t NUM_KEYS = (8 << 0);  ///< Encoded value indicating the number of key-storage locations implemented in the design
        constexpr uint32_t NUM_CHANNELS = (4 << 8);  ///< Encoded value indicating the number of channels implemented in the design
        constexpr uint32_t DISABLE_UNIQUE_KEY = (1U << 29);  ///< Write to a 1 to disable the per-device unique key
        constexpr uint32_t DISABLE_DECRYPT = (1U << 31);  ///< Write to 1 to disable the decryption
    }

    /// CAPABILITY1 Register bits
    namespace capability1_bits {
        constexpr uint32_t CIPHER_ALGORITHMS = (16 << 0);  ///< One-hot field indicating which cipher algorithms are available
        constexpr uint32_t HASH_ALGORITHMS = (16 << 16);  ///< One-hot field indicating which hashing features are implemented in the hardware
    }

    /// CONTEXT Register bits
    namespace context_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Context pointer address
    }

    /// KEY Register bits
    namespace key_bits {
        constexpr uint32_t SUBWORD = (2 << 0);  ///< Key subword pointer
        constexpr uint32_t INDEX = (2 << 4);  ///< Key index pointer. The valid indices are 0-[number_keys].
    }

    /// KEYDATA Register bits
    namespace keydata_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Word 0 data for the key. This is the least-significant word.
    }

    /// PACKET0 Register bits
    namespace packet0_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Next pointer register
    }

    /// PACKET1 Register bits
    namespace packet1_bits {
        constexpr uint32_t INTERRUPT = (1U << 0);  ///< Reflects whether the channel must issue an interrupt upon the completion of the packet.
        constexpr uint32_t DECR_SEMAPHORE = (1U << 1);  ///< Reflects whether the channel's semaphore must be decremented at the end of the current operation
        constexpr uint32_t CHAIN = (1U << 2);  ///< Reflects whether the next command pointer register must be loaded into the channel's current descriptor pointer
        constexpr uint32_t CHAIN_CONTIGUOUS = (1U << 3);  ///< Reflects whether the next packet's address is located following this packet's payload.
        constexpr uint32_t ENABLE_MEMCOPY = (1U << 4);  ///< Reflects whether the selected hashing function should be enabled for this operation.
        constexpr uint32_t ENABLE_CIPHER = (1U << 5);  ///< Reflects whether the selected cipher function must be enabled for this operation.
        constexpr uint32_t ENABLE_HASH = (1U << 6);  ///< Reflects whether the selected hashing function must be enabled for this operation.
        constexpr uint32_t ENABLE_BLIT = (1U << 7);  ///< Reflects whether the DCP must perform a blit operation
        constexpr uint32_t CIPHER_ENCRYPT = (1U << 8);  ///< When the cipher block is enabled, this bit indicates whether the operation is encryption or decryption
        constexpr uint32_t CIPHER_INIT = (1U << 9);  ///< Reflects whether the cipher block must load the initialization vector from the payload for this operation
        constexpr uint32_t OTP_KEY = (1U << 10);  ///< Reflects whether a hardware-based key must be used
        constexpr uint32_t PAYLOAD_KEY = (1U << 11);  ///< When set, it indicates the payload contains the key
        constexpr uint32_t HASH_INIT = (1U << 12);  ///< Reflects whether the current hashing block is the initial block in the hashing operation, so the hash registers must be initialized before the operation
        constexpr uint32_t HASH_TERM = (1U << 13);  ///< Reflects whether the current hashing block is the final block in the hashing operation, so the hash padding must be applied by the hardware
        constexpr uint32_t CHECK_HASH = (1U << 14);  ///< Reflects whether the calculated hash value must be compared to the hash provided in the payload.
        constexpr uint32_t HASH_OUTPUT = (1U << 15);  ///< When the hashing is enabled, this bit controls whether the input or output data is hashed.
        constexpr uint32_t CONSTANT_FILL = (1U << 16);  ///< When this bit is set (MEMCOPY and BLIT modes only), the DCP simply fills the destination buffer with the value found in the source address field
        constexpr uint32_t TEST_SEMA_IRQ = (1U << 17);  ///< This bit is used to test the channel semaphore transition to 0. FOR TEST USE ONLY!
        constexpr uint32_t KEY_BYTESWAP = (1U << 18);  ///< Reflects whether the DCP engine swaps the key bytes (big-endian key).
        constexpr uint32_t KEY_WORDSWAP = (1U << 19);  ///< Reflects whether the DCP engine swaps the key words (big-endian key).
        constexpr uint32_t INPUT_BYTESWAP = (1U << 20);  ///< Reflects whether the DCP engine byteswaps the input data (big-endian data).
        constexpr uint32_t INPUT_WORDSWAP = (1U << 21);  ///< Reflects whether the DCP engine wordswaps the input data (big-endian data).
        constexpr uint32_t OUTPUT_BYTESWAP = (1U << 22);  ///< Reflects whether the DCP engine byteswaps the output data (big-endian data).
        constexpr uint32_t OUTPUT_WORDSWAP = (1U << 23);  ///< Reflects whether the DCP engine wordswaps the output data (big-endian data).
        constexpr uint32_t TAG = (8 << 24);  ///< Packet Tag
    }

    /// PACKET2 Register bits
    namespace packet2_bits {
        constexpr uint32_t CIPHER_SELECT = (4 << 0);  ///< Cipher selection field
        constexpr uint32_t CIPHER_MODE = (4 << 4);  ///< Cipher mode selection field. Reflects the mode of operation for the cipher operations.
        constexpr uint32_t KEY_SELECT = (8 << 8);  ///< Key selection field
        constexpr uint32_t HASH_SELECT = (4 << 16);  ///< Hash Selection Field
        constexpr uint32_t CIPHER_CFG = (8 << 24);  ///< Cipher configuration bits. Optional configuration bits are required for the ciphers.
    }

    /// PACKET3 Register bits
    namespace packet3_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Source buffer address pointer
    }

    /// PACKET4 Register bits
    namespace packet4_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Destination buffer address pointer
    }

    /// PACKET5 Register bits
    namespace packet5_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< Byte count register. This value is the working value and updates as the operation proceeds.
    }

    /// PACKET6 Register bits
    namespace packet6_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< This regiser reflects the payload pointer for the current control packet.
    }

    /// CH0CMDPTR Register bits
    namespace ch0cmdptr_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Pointer to the descriptor structure to be processed for channel 0.
    }

    /// CH0SEMA Register bits
    namespace ch0sema_bits {
        constexpr uint32_t INCREMENT = (8 << 0);  ///< The value written to this field is added to the semaphore count in an atomic way such that the simultaneous software adds and DCP hardware substracts happening on the same clock are protected
        constexpr uint32_t VALUE = (8 << 16);  ///< This read-only field shows the current (instantaneous) value of the semaphore counter.
    }

    /// CH0STAT Register bits
    namespace ch0stat_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure
    }

    /// CH0STAT_SET Register bits
    namespace ch0stat_set_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure
    }

    /// CH0STAT_CLR Register bits
    namespace ch0stat_clr_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure
    }

    /// CH0STAT_TOG Register bits
    namespace ch0stat_tog_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure
    }

    /// CH0OPTS Register bits
    namespace ch0opts_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH0OPTS_SET Register bits
    namespace ch0opts_set_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH0OPTS_CLR Register bits
    namespace ch0opts_clr_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH0OPTS_TOG Register bits
    namespace ch0opts_tog_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH1CMDPTR Register bits
    namespace ch1cmdptr_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Pointer to the descriptor structure to be processed for channel 1.
    }

    /// CH1SEMA Register bits
    namespace ch1sema_bits {
        constexpr uint32_t INCREMENT = (8 << 0);  ///< The value written to this field is added to the semaphore count in an atomic way, such that the simultaneous software adds and the DCP hardware substracts happening on the same clock are protected
        constexpr uint32_t VALUE = (8 << 16);  ///< This read-only field shows the current (instantaneous) value of the semaphore counter.
    }

    /// CH1STAT Register bits
    namespace ch1stat_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH1STAT_SET Register bits
    namespace ch1stat_set_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH1STAT_CLR Register bits
    namespace ch1stat_clr_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH1STAT_TOG Register bits
    namespace ch1stat_tog_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates the additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH1OPTS Register bits
    namespace ch1opts_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH1OPTS_SET Register bits
    namespace ch1opts_set_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH1OPTS_CLR Register bits
    namespace ch1opts_clr_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH1OPTS_TOG Register bits
    namespace ch1opts_tog_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH2CMDPTR Register bits
    namespace ch2cmdptr_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Pointer to the descriptor structure to be processed for channel 2.
    }

    /// CH2SEMA Register bits
    namespace ch2sema_bits {
        constexpr uint32_t INCREMENT = (8 << 0);  ///< The value written to this field is added to the semaphore count in an atomic way, such that the simultaneous software adds and DCP hardware substracts happening on the same clock are protected
        constexpr uint32_t VALUE = (8 << 16);  ///< This read-only field shows the current (instantaneous) value of the semaphore counter.
    }

    /// CH2STAT Register bits
    namespace ch2stat_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH2STAT_SET Register bits
    namespace ch2stat_set_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH2STAT_CLR Register bits
    namespace ch2stat_clr_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH2STAT_TOG Register bits
    namespace ch2stat_tog_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH2OPTS Register bits
    namespace ch2opts_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH2OPTS_SET Register bits
    namespace ch2opts_set_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH2OPTS_CLR Register bits
    namespace ch2opts_clr_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH2OPTS_TOG Register bits
    namespace ch2opts_tog_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH3CMDPTR Register bits
    namespace ch3cmdptr_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Pointer to the descriptor structure to be processed for channel 3.
    }

    /// CH3SEMA Register bits
    namespace ch3sema_bits {
        constexpr uint32_t INCREMENT = (8 << 0);  ///< The value written to this field is added to the semaphore count in an atomic way, such that the simultaneous software adds and DCP hardware substracts happening on the same clock are protected
        constexpr uint32_t VALUE = (8 << 16);  ///< This read-only field shows the current (instantaneous) value of the semaphore counter.
    }

    /// CH3STAT Register bits
    namespace ch3stat_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH3STAT_SET Register bits
    namespace ch3stat_set_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH3STAT_CLR Register bits
    namespace ch3stat_clr_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH3STAT_TOG Register bits
    namespace ch3stat_tog_bits {
        constexpr uint32_t HASH_MISMATCH = (1U << 1);  ///< This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
        constexpr uint32_t ERROR_SETUP = (1U << 2);  ///< This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
        constexpr uint32_t ERROR_PACKET = (1U << 3);  ///< This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
        constexpr uint32_t ERROR_SRC = (1U << 4);  ///< This bit indicates that a bus error occurred when reading from the source buffer
        constexpr uint32_t ERROR_DST = (1U << 5);  ///< This bit indicates that a bus error occurred when storing to the destination buffer
        constexpr uint32_t ERROR_PAGEFAULT = (1U << 6);  ///< This bit indicates that a page fault occurred while converting a virtual address to a physical address
        constexpr uint32_t ERROR_CODE = (8 << 16);  ///< Indicates additional error codes for some of the error conditions.
        constexpr uint32_t TAG = (8 << 24);  ///< Indicates the tag from the last completed packet in the command structure.
    }

    /// CH3OPTS Register bits
    namespace ch3opts_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH3OPTS_SET Register bits
    namespace ch3opts_set_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH3OPTS_CLR Register bits
    namespace ch3opts_clr_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// CH3OPTS_TOG Register bits
    namespace ch3opts_tog_bits {
        constexpr uint32_t RECOVERY_TIMER = (16 << 0);  ///< This field indicates the recovery time for the channel
    }

    /// DBGSELECT Register bits
    namespace dbgselect_bits {
        constexpr uint32_t INDEX = (8 << 0);  ///< Selects a value to read via the debug data register.
    }

    /// DBGDATA Register bits
    namespace dbgdata_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Debug data
    }

    /// PAGETABLE Register bits
    namespace pagetable_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Page table enable control
        constexpr uint32_t FLUSH = (1U << 1);  ///< Page table flush control. To flush the TLB, write this bit to 1 and then back to 0.
        constexpr uint32_t BASE = (30 << 2);  ///< Page table base address
    }

    /// VERSION Register bits
    namespace version_bits {
        constexpr uint32_t STEP = (16 << 0);  ///< Fixed read-only value reflecting the stepping of the version of the design implementation.
        constexpr uint32_t MINOR = (8 << 16);  ///< Fixed read-only value reflecting the MINOR version of the design implementation.
        constexpr uint32_t MAJOR = (8 << 24);  ///< Fixed read-only value reflecting the MAJOR version of the design implementation.
    }

}

// ============================================================================
// SPDIF Peripheral
// ============================================================================

namespace spdif {
    /// Base addresses
    constexpr uint32_t SPDIF_BASE = 0x40380000;

    /// SPDIF Register structure
    struct Registers {
        volatile uint32_t SCR;  ///< Offset: 0x00 - SPDIF Configuration Register
        volatile uint32_t SRCD;  ///< Offset: 0x04 - CDText Control Register
        volatile uint32_t SRPC;  ///< Offset: 0x08 - PhaseConfig Register
        volatile uint32_t SIE;  ///< Offset: 0x0C - InterruptEn Register
        volatile uint32_t SIC;  ///< Offset: 0x10 - InterruptClear Register
        volatile uint32_t SIS;  ///< Offset: 0x10 - InterruptStat Register
        volatile uint32_t SRL;  ///< Offset: 0x14 - SPDIFRxLeft Register
        volatile uint32_t SRR;  ///< Offset: 0x18 - SPDIFRxRight Register
        volatile uint32_t SRCSH;  ///< Offset: 0x1C - SPDIFRxCChannel_h Register
        volatile uint32_t SRCSL;  ///< Offset: 0x20 - SPDIFRxCChannel_l Register
        volatile uint32_t SRU;  ///< Offset: 0x24 - UchannelRx Register
        volatile uint32_t SRQ;  ///< Offset: 0x28 - QchannelRx Register
        volatile uint32_t STL;  ///< Offset: 0x2C - SPDIFTxLeft Register
        volatile uint32_t STR;  ///< Offset: 0x30 - SPDIFTxRight Register
        volatile uint32_t STCSCH;  ///< Offset: 0x34 - SPDIFTxCChannelCons_h Register
        volatile uint32_t STCSCL;  ///< Offset: 0x38 - SPDIFTxCChannelCons_l Register
        volatile uint32_t SRFM;  ///< Offset: 0x44 - FreqMeas Register
        volatile uint32_t STC;  ///< Offset: 0x50 - SPDIFTxClk Register
    };

    /// Peripheral instances
    inline Registers* SPDIF = reinterpret_cast<Registers*>(SPDIF_BASE);

    // Bit definitions
    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t USrc_Sel = (2 << 0);  ///< no description available
        constexpr uint32_t TxSel = (3 << 2);  ///< no description available
        constexpr uint32_t ValCtrl = (1U << 5);  ///< no description available
        constexpr uint32_t DMA_TX_En = (1U << 8);  ///< DMA Transmit Request Enable (Tx FIFO empty)
        constexpr uint32_t DMA_Rx_En = (1U << 9);  ///< DMA Receive Request Enable (RX FIFO full)
        constexpr uint32_t TxFIFO_Ctrl = (2 << 10);  ///< no description available
        constexpr uint32_t soft_reset = (1U << 12);  ///< When write 1 to this bit, it will cause SPDIF software reset
        constexpr uint32_t LOW_POWER = (1U << 13);  ///< When write 1 to this bit, it will cause SPDIF enter low-power mode
        constexpr uint32_t TxFIFOEmpty_Sel = (2 << 15);  ///< no description available
        constexpr uint32_t TxAutoSync = (1U << 17);  ///< no description available
        constexpr uint32_t RxAutoSync = (1U << 18);  ///< no description available
        constexpr uint32_t RxFIFOFull_Sel = (2 << 19);  ///< no description available
        constexpr uint32_t RxFIFO_Rst = (1U << 21);  ///< no description available
        constexpr uint32_t RxFIFO_Off_On = (1U << 22);  ///< no description available
        constexpr uint32_t RxFIFO_Ctrl = (1U << 23);  ///< no description available
    }

    /// SRCD Register bits
    namespace srcd_bits {
        constexpr uint32_t USyncMode = (1U << 1);  ///< no description available
    }

    /// SRPC Register bits
    namespace srpc_bits {
        constexpr uint32_t GainSel = (3 << 3);  ///< Gain selection:
        constexpr uint32_t LOCK = (1U << 6);  ///< LOCK bit to show that the internal DPLL is locked, read only
        constexpr uint32_t ClkSrc_Sel = (4 << 7);  ///< Clock source selection, all other settings not shown are reserved:
    }

    /// SIE Register bits
    namespace sie_bits {
        constexpr uint32_t RxFIFOFul = (1U << 0);  ///< SPDIF Rx FIFO full, can't be cleared with reg. IntClear. To clear it, read from Rx FIFO.
        constexpr uint32_t TxEm = (1U << 1);  ///< SPDIF Tx FIFO empty, can't be cleared with reg. IntClear. To clear it, write toTx FIFO.
        constexpr uint32_t LockLoss = (1U << 2);  ///< SPDIF receiver loss of lock
        constexpr uint32_t RxFIFOResyn = (1U << 3);  ///< Rx FIFO resync
        constexpr uint32_t RxFIFOUnOv = (1U << 4);  ///< Rx FIFO underrun/overrun
        constexpr uint32_t UQErr = (1U << 5);  ///< U/Q Channel framing error
        constexpr uint32_t UQSync = (1U << 6);  ///< U/Q Channel sync found
        constexpr uint32_t QRxOv = (1U << 7);  ///< Q Channel receive register overrun
        constexpr uint32_t QRxFul = (1U << 8);  ///< Q Channel receive register full, can't be cleared with reg
        constexpr uint32_t URxOv = (1U << 9);  ///< U Channel receive register overrun
        constexpr uint32_t URxFul = (1U << 10);  ///< U Channel receive register full, can't be cleared with reg
        constexpr uint32_t BitErr = (1U << 14);  ///< SPDIF receiver found parity bit error
        constexpr uint32_t SymErr = (1U << 15);  ///< SPDIF receiver found illegal symbol
        constexpr uint32_t ValNoGood = (1U << 16);  ///< SPDIF validity flag no good
        constexpr uint32_t CNew = (1U << 17);  ///< SPDIF receive change in value of control channel
        constexpr uint32_t TxResyn = (1U << 18);  ///< SPDIF Tx FIFO resync
        constexpr uint32_t TxUnOv = (1U << 19);  ///< SPDIF Tx FIFO under/overrun
        constexpr uint32_t Lock = (1U << 20);  ///< SPDIF receiver's DPLL is locked
    }

    /// SIC Register bits
    namespace sic_bits {
        constexpr uint32_t LockLoss = (1U << 2);  ///< SPDIF receiver loss of lock
        constexpr uint32_t RxFIFOResyn = (1U << 3);  ///< Rx FIFO resync
        constexpr uint32_t RxFIFOUnOv = (1U << 4);  ///< Rx FIFO underrun/overrun
        constexpr uint32_t UQErr = (1U << 5);  ///< U/Q Channel framing error
        constexpr uint32_t UQSync = (1U << 6);  ///< U/Q Channel sync found
        constexpr uint32_t QRxOv = (1U << 7);  ///< Q Channel receive register overrun
        constexpr uint32_t URxOv = (1U << 9);  ///< U Channel receive register overrun
        constexpr uint32_t BitErr = (1U << 14);  ///< SPDIF receiver found parity bit error
        constexpr uint32_t SymErr = (1U << 15);  ///< SPDIF receiver found illegal symbol
        constexpr uint32_t ValNoGood = (1U << 16);  ///< SPDIF validity flag no good
        constexpr uint32_t CNew = (1U << 17);  ///< SPDIF receive change in value of control channel
        constexpr uint32_t TxResyn = (1U << 18);  ///< SPDIF Tx FIFO resync
        constexpr uint32_t TxUnOv = (1U << 19);  ///< SPDIF Tx FIFO under/overrun
        constexpr uint32_t Lock = (1U << 20);  ///< SPDIF receiver's DPLL is locked
    }

    /// SIS Register bits
    namespace sis_bits {
        constexpr uint32_t RxFIFOFul = (1U << 0);  ///< SPDIF Rx FIFO full, can't be cleared with reg. IntClear. To clear it, read from Rx FIFO.
        constexpr uint32_t TxEm = (1U << 1);  ///< SPDIF Tx FIFO empty, can't be cleared with reg. IntClear. To clear it, write toTx FIFO.
        constexpr uint32_t LockLoss = (1U << 2);  ///< SPDIF receiver loss of lock
        constexpr uint32_t RxFIFOResyn = (1U << 3);  ///< Rx FIFO resync
        constexpr uint32_t RxFIFOUnOv = (1U << 4);  ///< Rx FIFO underrun/overrun
        constexpr uint32_t UQErr = (1U << 5);  ///< U/Q Channel framing error
        constexpr uint32_t UQSync = (1U << 6);  ///< U/Q Channel sync found
        constexpr uint32_t QRxOv = (1U << 7);  ///< Q Channel receive register overrun
        constexpr uint32_t QRxFul = (1U << 8);  ///< Q Channel receive register full, can't be cleared with reg
        constexpr uint32_t URxOv = (1U << 9);  ///< U Channel receive register overrun
        constexpr uint32_t URxFul = (1U << 10);  ///< U Channel receive register full, can't be cleared with reg
        constexpr uint32_t BitErr = (1U << 14);  ///< SPDIF receiver found parity bit error
        constexpr uint32_t SymErr = (1U << 15);  ///< SPDIF receiver found illegal symbol
        constexpr uint32_t ValNoGood = (1U << 16);  ///< SPDIF validity flag no good
        constexpr uint32_t CNew = (1U << 17);  ///< SPDIF receive change in value of control channel
        constexpr uint32_t TxResyn = (1U << 18);  ///< SPDIF Tx FIFO resync
        constexpr uint32_t TxUnOv = (1U << 19);  ///< SPDIF Tx FIFO under/overrun
        constexpr uint32_t Lock = (1U << 20);  ///< SPDIF receiver's DPLL is locked
    }

    /// SRL Register bits
    namespace srl_bits {
        constexpr uint32_t RxDataLeft = (24 << 0);  ///< Processor receive SPDIF data left
    }

    /// SRR Register bits
    namespace srr_bits {
        constexpr uint32_t RxDataRight = (24 << 0);  ///< Processor receive SPDIF data right
    }

    /// SRCSH Register bits
    namespace srcsh_bits {
        constexpr uint32_t RxCChannel_h = (24 << 0);  ///< SPDIF receive C channel register, contains first 24 bits of C channel without interpretation
    }

    /// SRCSL Register bits
    namespace srcsl_bits {
        constexpr uint32_t RxCChannel_l = (24 << 0);  ///< SPDIF receive C channel register, contains next 24 bits of C channel without interpretation
    }

    /// SRU Register bits
    namespace sru_bits {
        constexpr uint32_t RxUChannel = (24 << 0);  ///< SPDIF receive U channel register, contains next 3 U channel bytes
    }

    /// SRQ Register bits
    namespace srq_bits {
        constexpr uint32_t RxQChannel = (24 << 0);  ///< SPDIF receive Q channel register, contains next 3 Q channel bytes
    }

    /// STL Register bits
    namespace stl_bits {
        constexpr uint32_t TxDataLeft = (24 << 0);  ///< SPDIF transmit left channel data. It is write-only, and always returns zeros when read
    }

    /// STR Register bits
    namespace str_bits {
        constexpr uint32_t TxDataRight = (24 << 0);  ///< SPDIF transmit right channel data. It is write-only, and always returns zeros when read
    }

    /// STCSCH Register bits
    namespace stcsch_bits {
        constexpr uint32_t TxCChannelCons_h = (24 << 0);  ///< SPDIF transmit Cons
    }

    /// STCSCL Register bits
    namespace stcscl_bits {
        constexpr uint32_t TxCChannelCons_l = (24 << 0);  ///< SPDIF transmit Cons
    }

    /// SRFM Register bits
    namespace srfm_bits {
        constexpr uint32_t FreqMeas = (24 << 0);  ///< Frequency measurement data
    }

    /// STC Register bits
    namespace stc_bits {
        constexpr uint32_t TxClk_DF = (7 << 0);  ///< Divider factor (1-128)
        constexpr uint32_t tx_all_clk_en = (1U << 7);  ///< Spdif transfer clock enable. When data is going to be transfered, this bit should be set to1.
        constexpr uint32_t TxClk_Source = (3 << 8);  ///< no description available
        constexpr uint32_t SYSCLK_DF = (9 << 11);  ///< system clock divider factor, 2~512.
    }

}

// ============================================================================
// SAI1 Peripheral
// ============================================================================

namespace sai1 {
    /// Base addresses
    constexpr uint32_t SAI1_BASE = 0x40384000;

    /// SAI1 Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t TCSR;  ///< Offset: 0x08 - SAI Transmit Control Register
        volatile uint32_t TCR1;  ///< Offset: 0x0C - SAI Transmit Configuration 1 Register
        volatile uint32_t TCR2;  ///< Offset: 0x10 - SAI Transmit Configuration 2 Register
        volatile uint32_t TCR3;  ///< Offset: 0x14 - SAI Transmit Configuration 3 Register
        volatile uint32_t TCR4;  ///< Offset: 0x18 - SAI Transmit Configuration 4 Register
        volatile uint32_t TCR5;  ///< Offset: 0x1C - SAI Transmit Configuration 5 Register
        volatile uint32_t TDR[%s];  ///< Offset: 0x20 - SAI Transmit Data Register
        volatile uint32_t TFR[%s];  ///< Offset: 0x40 - SAI Transmit FIFO Register
        volatile uint32_t TMR;  ///< Offset: 0x60 - SAI Transmit Mask Register
        volatile uint32_t RCSR;  ///< Offset: 0x88 - SAI Receive Control Register
        volatile uint32_t RCR1;  ///< Offset: 0x8C - SAI Receive Configuration 1 Register
        volatile uint32_t RCR2;  ///< Offset: 0x90 - SAI Receive Configuration 2 Register
        volatile uint32_t RCR3;  ///< Offset: 0x94 - SAI Receive Configuration 3 Register
        volatile uint32_t RCR4;  ///< Offset: 0x98 - SAI Receive Configuration 4 Register
        volatile uint32_t RCR5;  ///< Offset: 0x9C - SAI Receive Configuration 5 Register
        volatile uint32_t RDR[%s];  ///< Offset: 0xA0 - SAI Receive Data Register
        volatile uint32_t RFR[%s];  ///< Offset: 0xC0 - SAI Receive FIFO Register
        volatile uint32_t RMR;  ///< Offset: 0xE0 - SAI Receive Mask Register
    };

    /// Peripheral instances
    inline Registers* SAI1 = reinterpret_cast<Registers*>(SAI1_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t DATALINE = (4 << 0);  ///< Number of Datalines
        constexpr uint32_t FIFO = (4 << 8);  ///< FIFO Size
        constexpr uint32_t FRAME = (4 << 16);  ///< Frame Size
    }

    /// TCSR Register bits
    namespace tcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO Request DMA Enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO Request Interrupt Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO Request Flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t TE = (1U << 31);  ///< Transmitter Enable
    }

    /// TCR1 Register bits
    namespace tcr1_bits {
        constexpr uint32_t TFW = (5 << 0);  ///< Transmit FIFO Watermark
    }

    /// TCR2 Register bits
    namespace tcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// TCR3 Register bits
    namespace tcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word Flag Configuration
        constexpr uint32_t TCE = (4 << 16);  ///< Transmit Channel Enable
        constexpr uint32_t CFR = (4 << 24);  ///< Channel FIFO Reset
    }

    /// TCR4 Register bits
    namespace tcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t ONDEM = (1U << 2);  ///< On Demand Mode
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t CHMOD = (1U << 5);  ///< Channel Mode
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame size
        constexpr uint32_t FPACK = (2 << 24);  ///< FIFO Packing Mode
        constexpr uint32_t FCOMB = (2 << 26);  ///< FIFO Combine Mode
        constexpr uint32_t FCONT = (1U << 28);  ///< FIFO Continue on Error
    }

    /// TCR5 Register bits
    namespace tcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// TDR[%s] Register bits
    namespace tdr[%s]_bits {
        constexpr uint32_t TDR = (32 << 0);  ///< Transmit Data Register
    }

    /// TFR[%s] Register bits
    namespace tfr[%s]_bits {
        constexpr uint32_t RFP = (6 << 0);  ///< Read FIFO Pointer
        constexpr uint32_t WFP = (6 << 16);  ///< Write FIFO Pointer
        constexpr uint32_t WCP = (1U << 31);  ///< Write Channel Pointer
    }

    /// TMR Register bits
    namespace tmr_bits {
        constexpr uint32_t TWM = (32 << 0);  ///< Transmit Word Mask
    }

    /// RCSR Register bits
    namespace rcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO Request DMA Enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO Request Interrupt Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO Request Flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t RE = (1U << 31);  ///< Receiver Enable
    }

    /// RCR1 Register bits
    namespace rcr1_bits {
        constexpr uint32_t RFW = (5 << 0);  ///< Receive FIFO Watermark
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// RCR3 Register bits
    namespace rcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word Flag Configuration
        constexpr uint32_t RCE = (4 << 16);  ///< Receive Channel Enable
        constexpr uint32_t CFR = (4 << 24);  ///< Channel FIFO Reset
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t ONDEM = (1U << 2);  ///< On Demand Mode
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame Size
        constexpr uint32_t FPACK = (2 << 24);  ///< FIFO Packing Mode
        constexpr uint32_t FCOMB = (2 << 26);  ///< FIFO Combine Mode
        constexpr uint32_t FCONT = (1U << 28);  ///< FIFO Continue on Error
    }

    /// RCR5 Register bits
    namespace rcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// RDR[%s] Register bits
    namespace rdr[%s]_bits {
        constexpr uint32_t RDR = (32 << 0);  ///< Receive Data Register
    }

    /// RFR[%s] Register bits
    namespace rfr[%s]_bits {
        constexpr uint32_t RFP = (6 << 0);  ///< Read FIFO Pointer
        constexpr uint32_t RCP = (1U << 15);  ///< Receive Channel Pointer
        constexpr uint32_t WFP = (6 << 16);  ///< Write FIFO Pointer
    }

    /// RMR Register bits
    namespace rmr_bits {
        constexpr uint32_t RWM = (32 << 0);  ///< Receive Word Mask
    }

}

// ============================================================================
// SAI2 Peripheral
// ============================================================================

namespace sai2 {
    /// Base addresses
    constexpr uint32_t SAI2_BASE = 0x40388000;

    /// SAI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SAI2 = reinterpret_cast<Registers*>(SAI2_BASE);

}

// ============================================================================
// SAI3 Peripheral
// ============================================================================

namespace sai3 {
    /// Base addresses
    constexpr uint32_t SAI3_BASE = 0x4038C000;

    /// SAI3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SAI3 = reinterpret_cast<Registers*>(SAI3_BASE);

}

// ============================================================================
// AOI1 Peripheral
// ============================================================================

namespace aoi1 {
    /// Base addresses
    constexpr uint32_t AOI1_BASE = 0x403B4000;

    /// AOI1 Register structure
    struct Registers {
        volatile uint32_t BFCRT01%s;  ///< Offset: 0x00 - Boolean Function Term 0 and 1 Configuration Register for EVENTn
        volatile uint32_t BFCRT23%s;  ///< Offset: 0x02 - Boolean Function Term 2 and 3 Configuration Register for EVENTn
    };

    /// Peripheral instances
    inline Registers* AOI1 = reinterpret_cast<Registers*>(AOI1_BASE);

    // Bit definitions
    /// BFCRT01%s Register bits
    namespace bfcrt01%s_bits {
        constexpr uint32_t PT1_DC = (2 << 0);  ///< Product term 1, D input configuration
        constexpr uint32_t PT1_CC = (2 << 2);  ///< Product term 1, C input configuration
        constexpr uint32_t PT1_BC = (2 << 4);  ///< Product term 1, B input configuration
        constexpr uint32_t PT1_AC = (2 << 6);  ///< Product term 1, A input configuration
        constexpr uint32_t PT0_DC = (2 << 8);  ///< Product term 0, D input configuration
        constexpr uint32_t PT0_CC = (2 << 10);  ///< Product term 0, C input configuration
        constexpr uint32_t PT0_BC = (2 << 12);  ///< Product term 0, B input configuration
        constexpr uint32_t PT0_AC = (2 << 14);  ///< Product term 0, A input configuration
    }

    /// BFCRT23%s Register bits
    namespace bfcrt23%s_bits {
        constexpr uint32_t PT3_DC = (2 << 0);  ///< Product term 3, D input configuration
        constexpr uint32_t PT3_CC = (2 << 2);  ///< Product term 3, C input configuration
        constexpr uint32_t PT3_BC = (2 << 4);  ///< Product term 3, B input configuration
        constexpr uint32_t PT3_AC = (2 << 6);  ///< Product term 3, A input configuration
        constexpr uint32_t PT2_DC = (2 << 8);  ///< Product term 2, D input configuration
        constexpr uint32_t PT2_CC = (2 << 10);  ///< Product term 2, C input configuration
        constexpr uint32_t PT2_BC = (2 << 12);  ///< Product term 2, B input configuration
        constexpr uint32_t PT2_AC = (2 << 14);  ///< Product term 2, A input configuration
    }

}

// ============================================================================
// AOI2 Peripheral
// ============================================================================

namespace aoi2 {
    /// Base addresses
    constexpr uint32_t AOI2_BASE = 0x403B8000;

    /// AOI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AOI2 = reinterpret_cast<Registers*>(AOI2_BASE);

}

// ============================================================================
// XBARA1 Peripheral
// ============================================================================

namespace xbara1 {
    /// Base addresses
    constexpr uint32_t XBARA1_BASE = 0x403BC000;

    /// XBARA1 Register structure
    struct Registers {
        volatile uint32_t SEL0;  ///< Offset: 0x00 - Crossbar A Select Register 0
        volatile uint32_t SEL1;  ///< Offset: 0x02 - Crossbar A Select Register 1
        volatile uint32_t SEL2;  ///< Offset: 0x04 - Crossbar A Select Register 2
        volatile uint32_t SEL3;  ///< Offset: 0x06 - Crossbar A Select Register 3
        volatile uint32_t SEL4;  ///< Offset: 0x08 - Crossbar A Select Register 4
        volatile uint32_t SEL5;  ///< Offset: 0x0A - Crossbar A Select Register 5
        volatile uint32_t SEL6;  ///< Offset: 0x0C - Crossbar A Select Register 6
        volatile uint32_t SEL7;  ///< Offset: 0x0E - Crossbar A Select Register 7
        volatile uint32_t SEL8;  ///< Offset: 0x10 - Crossbar A Select Register 8
        volatile uint32_t SEL9;  ///< Offset: 0x12 - Crossbar A Select Register 9
        volatile uint32_t SEL10;  ///< Offset: 0x14 - Crossbar A Select Register 10
        volatile uint32_t SEL11;  ///< Offset: 0x16 - Crossbar A Select Register 11
        volatile uint32_t SEL12;  ///< Offset: 0x18 - Crossbar A Select Register 12
        volatile uint32_t SEL13;  ///< Offset: 0x1A - Crossbar A Select Register 13
        volatile uint32_t SEL14;  ///< Offset: 0x1C - Crossbar A Select Register 14
        volatile uint32_t SEL15;  ///< Offset: 0x1E - Crossbar A Select Register 15
        volatile uint32_t SEL16;  ///< Offset: 0x20 - Crossbar A Select Register 16
        volatile uint32_t SEL17;  ///< Offset: 0x22 - Crossbar A Select Register 17
        volatile uint32_t SEL18;  ///< Offset: 0x24 - Crossbar A Select Register 18
        volatile uint32_t SEL19;  ///< Offset: 0x26 - Crossbar A Select Register 19
        volatile uint32_t SEL20;  ///< Offset: 0x28 - Crossbar A Select Register 20
        volatile uint32_t SEL21;  ///< Offset: 0x2A - Crossbar A Select Register 21
        volatile uint32_t SEL22;  ///< Offset: 0x2C - Crossbar A Select Register 22
        volatile uint32_t SEL23;  ///< Offset: 0x2E - Crossbar A Select Register 23
        volatile uint32_t SEL24;  ///< Offset: 0x30 - Crossbar A Select Register 24
        volatile uint32_t SEL25;  ///< Offset: 0x32 - Crossbar A Select Register 25
        volatile uint32_t SEL26;  ///< Offset: 0x34 - Crossbar A Select Register 26
        volatile uint32_t SEL27;  ///< Offset: 0x36 - Crossbar A Select Register 27
        volatile uint32_t SEL28;  ///< Offset: 0x38 - Crossbar A Select Register 28
        volatile uint32_t SEL29;  ///< Offset: 0x3A - Crossbar A Select Register 29
        volatile uint32_t SEL30;  ///< Offset: 0x3C - Crossbar A Select Register 30
        volatile uint32_t SEL31;  ///< Offset: 0x3E - Crossbar A Select Register 31
        volatile uint32_t SEL32;  ///< Offset: 0x40 - Crossbar A Select Register 32
        volatile uint32_t SEL33;  ///< Offset: 0x42 - Crossbar A Select Register 33
        volatile uint32_t SEL34;  ///< Offset: 0x44 - Crossbar A Select Register 34
        volatile uint32_t SEL35;  ///< Offset: 0x46 - Crossbar A Select Register 35
        volatile uint32_t SEL36;  ///< Offset: 0x48 - Crossbar A Select Register 36
        volatile uint32_t SEL37;  ///< Offset: 0x4A - Crossbar A Select Register 37
        volatile uint32_t SEL38;  ///< Offset: 0x4C - Crossbar A Select Register 38
        volatile uint32_t SEL39;  ///< Offset: 0x4E - Crossbar A Select Register 39
        volatile uint32_t SEL40;  ///< Offset: 0x50 - Crossbar A Select Register 40
        volatile uint32_t SEL41;  ///< Offset: 0x52 - Crossbar A Select Register 41
        volatile uint32_t SEL42;  ///< Offset: 0x54 - Crossbar A Select Register 42
        volatile uint32_t SEL43;  ///< Offset: 0x56 - Crossbar A Select Register 43
        volatile uint32_t SEL44;  ///< Offset: 0x58 - Crossbar A Select Register 44
        volatile uint32_t SEL45;  ///< Offset: 0x5A - Crossbar A Select Register 45
        volatile uint32_t SEL46;  ///< Offset: 0x5C - Crossbar A Select Register 46
        volatile uint32_t SEL47;  ///< Offset: 0x5E - Crossbar A Select Register 47
        volatile uint32_t SEL48;  ///< Offset: 0x60 - Crossbar A Select Register 48
        volatile uint32_t SEL49;  ///< Offset: 0x62 - Crossbar A Select Register 49
        volatile uint32_t SEL50;  ///< Offset: 0x64 - Crossbar A Select Register 50
        volatile uint32_t SEL51;  ///< Offset: 0x66 - Crossbar A Select Register 51
        volatile uint32_t SEL52;  ///< Offset: 0x68 - Crossbar A Select Register 52
        volatile uint32_t SEL53;  ///< Offset: 0x6A - Crossbar A Select Register 53
        volatile uint32_t SEL54;  ///< Offset: 0x6C - Crossbar A Select Register 54
        volatile uint32_t SEL55;  ///< Offset: 0x6E - Crossbar A Select Register 55
        volatile uint32_t SEL56;  ///< Offset: 0x70 - Crossbar A Select Register 56
        volatile uint32_t SEL57;  ///< Offset: 0x72 - Crossbar A Select Register 57
        volatile uint32_t SEL58;  ///< Offset: 0x74 - Crossbar A Select Register 58
        volatile uint32_t SEL59;  ///< Offset: 0x76 - Crossbar A Select Register 59
        volatile uint32_t SEL60;  ///< Offset: 0x78 - Crossbar A Select Register 60
        volatile uint32_t SEL61;  ///< Offset: 0x7A - Crossbar A Select Register 61
        volatile uint32_t SEL62;  ///< Offset: 0x7C - Crossbar A Select Register 62
        volatile uint32_t SEL63;  ///< Offset: 0x7E - Crossbar A Select Register 63
        volatile uint32_t SEL64;  ///< Offset: 0x80 - Crossbar A Select Register 64
        volatile uint32_t SEL65;  ///< Offset: 0x82 - Crossbar A Select Register 65
        volatile uint32_t CTRL0;  ///< Offset: 0x84 - Crossbar A Control Register 0
        volatile uint32_t CTRL1;  ///< Offset: 0x86 - Crossbar A Control Register 1
    };

    /// Peripheral instances
    inline Registers* XBARA1 = reinterpret_cast<Registers*>(XBARA1_BASE);

    // Bit definitions
    /// SEL0 Register bits
    namespace sel0_bits {
        constexpr uint32_t SEL0 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT0 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL1 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT1 (refer to Functional Description section for input/output assignment)
    }

    /// SEL1 Register bits
    namespace sel1_bits {
        constexpr uint32_t SEL2 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT2 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL3 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT3 (refer to Functional Description section for input/output assignment)
    }

    /// SEL2 Register bits
    namespace sel2_bits {
        constexpr uint32_t SEL4 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT4 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL5 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT5 (refer to Functional Description section for input/output assignment)
    }

    /// SEL3 Register bits
    namespace sel3_bits {
        constexpr uint32_t SEL6 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT6 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL7 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT7 (refer to Functional Description section for input/output assignment)
    }

    /// SEL4 Register bits
    namespace sel4_bits {
        constexpr uint32_t SEL8 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT8 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL9 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT9 (refer to Functional Description section for input/output assignment)
    }

    /// SEL5 Register bits
    namespace sel5_bits {
        constexpr uint32_t SEL10 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT10 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL11 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT11 (refer to Functional Description section for input/output assignment)
    }

    /// SEL6 Register bits
    namespace sel6_bits {
        constexpr uint32_t SEL12 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT12 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL13 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT13 (refer to Functional Description section for input/output assignment)
    }

    /// SEL7 Register bits
    namespace sel7_bits {
        constexpr uint32_t SEL14 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT14 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL15 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT15 (refer to Functional Description section for input/output assignment)
    }

    /// SEL8 Register bits
    namespace sel8_bits {
        constexpr uint32_t SEL16 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT16 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL17 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT17 (refer to Functional Description section for input/output assignment)
    }

    /// SEL9 Register bits
    namespace sel9_bits {
        constexpr uint32_t SEL18 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT18 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL19 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT19 (refer to Functional Description section for input/output assignment)
    }

    /// SEL10 Register bits
    namespace sel10_bits {
        constexpr uint32_t SEL20 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT20 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL21 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT21 (refer to Functional Description section for input/output assignment)
    }

    /// SEL11 Register bits
    namespace sel11_bits {
        constexpr uint32_t SEL22 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT22 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL23 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT23 (refer to Functional Description section for input/output assignment)
    }

    /// SEL12 Register bits
    namespace sel12_bits {
        constexpr uint32_t SEL24 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT24 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL25 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT25 (refer to Functional Description section for input/output assignment)
    }

    /// SEL13 Register bits
    namespace sel13_bits {
        constexpr uint32_t SEL26 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT26 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL27 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT27 (refer to Functional Description section for input/output assignment)
    }

    /// SEL14 Register bits
    namespace sel14_bits {
        constexpr uint32_t SEL28 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT28 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL29 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT29 (refer to Functional Description section for input/output assignment)
    }

    /// SEL15 Register bits
    namespace sel15_bits {
        constexpr uint32_t SEL30 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT30 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL31 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT31 (refer to Functional Description section for input/output assignment)
    }

    /// SEL16 Register bits
    namespace sel16_bits {
        constexpr uint32_t SEL32 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT32 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL33 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT33 (refer to Functional Description section for input/output assignment)
    }

    /// SEL17 Register bits
    namespace sel17_bits {
        constexpr uint32_t SEL34 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT34 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL35 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT35 (refer to Functional Description section for input/output assignment)
    }

    /// SEL18 Register bits
    namespace sel18_bits {
        constexpr uint32_t SEL36 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT36 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL37 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT37 (refer to Functional Description section for input/output assignment)
    }

    /// SEL19 Register bits
    namespace sel19_bits {
        constexpr uint32_t SEL38 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT38 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL39 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT39 (refer to Functional Description section for input/output assignment)
    }

    /// SEL20 Register bits
    namespace sel20_bits {
        constexpr uint32_t SEL40 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT40 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL41 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT41 (refer to Functional Description section for input/output assignment)
    }

    /// SEL21 Register bits
    namespace sel21_bits {
        constexpr uint32_t SEL42 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT42 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL43 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT43 (refer to Functional Description section for input/output assignment)
    }

    /// SEL22 Register bits
    namespace sel22_bits {
        constexpr uint32_t SEL44 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT44 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL45 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT45 (refer to Functional Description section for input/output assignment)
    }

    /// SEL23 Register bits
    namespace sel23_bits {
        constexpr uint32_t SEL46 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT46 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL47 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT47 (refer to Functional Description section for input/output assignment)
    }

    /// SEL24 Register bits
    namespace sel24_bits {
        constexpr uint32_t SEL48 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT48 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL49 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT49 (refer to Functional Description section for input/output assignment)
    }

    /// SEL25 Register bits
    namespace sel25_bits {
        constexpr uint32_t SEL50 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT50 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL51 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT51 (refer to Functional Description section for input/output assignment)
    }

    /// SEL26 Register bits
    namespace sel26_bits {
        constexpr uint32_t SEL52 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT52 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL53 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT53 (refer to Functional Description section for input/output assignment)
    }

    /// SEL27 Register bits
    namespace sel27_bits {
        constexpr uint32_t SEL54 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT54 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL55 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT55 (refer to Functional Description section for input/output assignment)
    }

    /// SEL28 Register bits
    namespace sel28_bits {
        constexpr uint32_t SEL56 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT56 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL57 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT57 (refer to Functional Description section for input/output assignment)
    }

    /// SEL29 Register bits
    namespace sel29_bits {
        constexpr uint32_t SEL58 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT58 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL59 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT59 (refer to Functional Description section for input/output assignment)
    }

    /// SEL30 Register bits
    namespace sel30_bits {
        constexpr uint32_t SEL60 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT60 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL61 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT61 (refer to Functional Description section for input/output assignment)
    }

    /// SEL31 Register bits
    namespace sel31_bits {
        constexpr uint32_t SEL62 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT62 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL63 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT63 (refer to Functional Description section for input/output assignment)
    }

    /// SEL32 Register bits
    namespace sel32_bits {
        constexpr uint32_t SEL64 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT64 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL65 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT65 (refer to Functional Description section for input/output assignment)
    }

    /// SEL33 Register bits
    namespace sel33_bits {
        constexpr uint32_t SEL66 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT66 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL67 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT67 (refer to Functional Description section for input/output assignment)
    }

    /// SEL34 Register bits
    namespace sel34_bits {
        constexpr uint32_t SEL68 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT68 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL69 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT69 (refer to Functional Description section for input/output assignment)
    }

    /// SEL35 Register bits
    namespace sel35_bits {
        constexpr uint32_t SEL70 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT70 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL71 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT71 (refer to Functional Description section for input/output assignment)
    }

    /// SEL36 Register bits
    namespace sel36_bits {
        constexpr uint32_t SEL72 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT72 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL73 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT73 (refer to Functional Description section for input/output assignment)
    }

    /// SEL37 Register bits
    namespace sel37_bits {
        constexpr uint32_t SEL74 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT74 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL75 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT75 (refer to Functional Description section for input/output assignment)
    }

    /// SEL38 Register bits
    namespace sel38_bits {
        constexpr uint32_t SEL76 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT76 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL77 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT77 (refer to Functional Description section for input/output assignment)
    }

    /// SEL39 Register bits
    namespace sel39_bits {
        constexpr uint32_t SEL78 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT78 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL79 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT79 (refer to Functional Description section for input/output assignment)
    }

    /// SEL40 Register bits
    namespace sel40_bits {
        constexpr uint32_t SEL80 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT80 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL81 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT81 (refer to Functional Description section for input/output assignment)
    }

    /// SEL41 Register bits
    namespace sel41_bits {
        constexpr uint32_t SEL82 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT82 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL83 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT83 (refer to Functional Description section for input/output assignment)
    }

    /// SEL42 Register bits
    namespace sel42_bits {
        constexpr uint32_t SEL84 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT84 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL85 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT85 (refer to Functional Description section for input/output assignment)
    }

    /// SEL43 Register bits
    namespace sel43_bits {
        constexpr uint32_t SEL86 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT86 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL87 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT87 (refer to Functional Description section for input/output assignment)
    }

    /// SEL44 Register bits
    namespace sel44_bits {
        constexpr uint32_t SEL88 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT88 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL89 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT89 (refer to Functional Description section for input/output assignment)
    }

    /// SEL45 Register bits
    namespace sel45_bits {
        constexpr uint32_t SEL90 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT90 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL91 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT91 (refer to Functional Description section for input/output assignment)
    }

    /// SEL46 Register bits
    namespace sel46_bits {
        constexpr uint32_t SEL92 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT92 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL93 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT93 (refer to Functional Description section for input/output assignment)
    }

    /// SEL47 Register bits
    namespace sel47_bits {
        constexpr uint32_t SEL94 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT94 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL95 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT95 (refer to Functional Description section for input/output assignment)
    }

    /// SEL48 Register bits
    namespace sel48_bits {
        constexpr uint32_t SEL96 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT96 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL97 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT97 (refer to Functional Description section for input/output assignment)
    }

    /// SEL49 Register bits
    namespace sel49_bits {
        constexpr uint32_t SEL98 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT98 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL99 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT99 (refer to Functional Description section for input/output assignment)
    }

    /// SEL50 Register bits
    namespace sel50_bits {
        constexpr uint32_t SEL100 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT100 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL101 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT101 (refer to Functional Description section for input/output assignment)
    }

    /// SEL51 Register bits
    namespace sel51_bits {
        constexpr uint32_t SEL102 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT102 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL103 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT103 (refer to Functional Description section for input/output assignment)
    }

    /// SEL52 Register bits
    namespace sel52_bits {
        constexpr uint32_t SEL104 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT104 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL105 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT105 (refer to Functional Description section for input/output assignment)
    }

    /// SEL53 Register bits
    namespace sel53_bits {
        constexpr uint32_t SEL106 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT106 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL107 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT107 (refer to Functional Description section for input/output assignment)
    }

    /// SEL54 Register bits
    namespace sel54_bits {
        constexpr uint32_t SEL108 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT108 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL109 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT109 (refer to Functional Description section for input/output assignment)
    }

    /// SEL55 Register bits
    namespace sel55_bits {
        constexpr uint32_t SEL110 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT110 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL111 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT111 (refer to Functional Description section for input/output assignment)
    }

    /// SEL56 Register bits
    namespace sel56_bits {
        constexpr uint32_t SEL112 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT112 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL113 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT113 (refer to Functional Description section for input/output assignment)
    }

    /// SEL57 Register bits
    namespace sel57_bits {
        constexpr uint32_t SEL114 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT114 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL115 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT115 (refer to Functional Description section for input/output assignment)
    }

    /// SEL58 Register bits
    namespace sel58_bits {
        constexpr uint32_t SEL116 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT116 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL117 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT117 (refer to Functional Description section for input/output assignment)
    }

    /// SEL59 Register bits
    namespace sel59_bits {
        constexpr uint32_t SEL118 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT118 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL119 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT119 (refer to Functional Description section for input/output assignment)
    }

    /// SEL60 Register bits
    namespace sel60_bits {
        constexpr uint32_t SEL120 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT120 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL121 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT121 (refer to Functional Description section for input/output assignment)
    }

    /// SEL61 Register bits
    namespace sel61_bits {
        constexpr uint32_t SEL122 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT122 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL123 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT123 (refer to Functional Description section for input/output assignment)
    }

    /// SEL62 Register bits
    namespace sel62_bits {
        constexpr uint32_t SEL124 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT124 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL125 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT125 (refer to Functional Description section for input/output assignment)
    }

    /// SEL63 Register bits
    namespace sel63_bits {
        constexpr uint32_t SEL126 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT126 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL127 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT127 (refer to Functional Description section for input/output assignment)
    }

    /// SEL64 Register bits
    namespace sel64_bits {
        constexpr uint32_t SEL128 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT128 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL129 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT129 (refer to Functional Description section for input/output assignment)
    }

    /// SEL65 Register bits
    namespace sel65_bits {
        constexpr uint32_t SEL130 = (7 << 0);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT130 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL131 = (7 << 8);  ///< Input (XBARA_INn) to be muxed to XBARA_OUT131 (refer to Functional Description section for input/output assignment)
    }

    /// CTRL0 Register bits
    namespace ctrl0_bits {
        constexpr uint32_t DEN0 = (1U << 0);  ///< DMA Enable for XBAR_OUT0
        constexpr uint32_t IEN0 = (1U << 1);  ///< Interrupt Enable for XBAR_OUT0
        constexpr uint32_t EDGE0 = (2 << 2);  ///< Active edge for edge detection on XBAR_OUT0
        constexpr uint32_t STS0 = (1U << 4);  ///< Edge detection status for XBAR_OUT0
        constexpr uint32_t DEN1 = (1U << 8);  ///< DMA Enable for XBAR_OUT1
        constexpr uint32_t IEN1 = (1U << 9);  ///< Interrupt Enable for XBAR_OUT1
        constexpr uint32_t EDGE1 = (2 << 10);  ///< Active edge for edge detection on XBAR_OUT1
        constexpr uint32_t STS1 = (1U << 12);  ///< Edge detection status for XBAR_OUT1
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t DEN2 = (1U << 0);  ///< DMA Enable for XBAR_OUT2
        constexpr uint32_t IEN2 = (1U << 1);  ///< Interrupt Enable for XBAR_OUT2
        constexpr uint32_t EDGE2 = (2 << 2);  ///< Active edge for edge detection on XBAR_OUT2
        constexpr uint32_t STS2 = (1U << 4);  ///< Edge detection status for XBAR_OUT2
        constexpr uint32_t DEN3 = (1U << 8);  ///< DMA Enable for XBAR_OUT3
        constexpr uint32_t IEN3 = (1U << 9);  ///< Interrupt Enable for XBAR_OUT3
        constexpr uint32_t EDGE3 = (2 << 10);  ///< Active edge for edge detection on XBAR_OUT3
        constexpr uint32_t STS3 = (1U << 12);  ///< Edge detection status for XBAR_OUT3
    }

}

// ============================================================================
// XBARB2 Peripheral
// ============================================================================

namespace xbarb2 {
    /// Base addresses
    constexpr uint32_t XBARB2_BASE = 0x403C0000;

    /// XBARB2 Register structure
    struct Registers {
        volatile uint32_t SEL0;  ///< Offset: 0x00 - Crossbar B Select Register 0
        volatile uint32_t SEL1;  ///< Offset: 0x02 - Crossbar B Select Register 1
        volatile uint32_t SEL2;  ///< Offset: 0x04 - Crossbar B Select Register 2
        volatile uint32_t SEL3;  ///< Offset: 0x06 - Crossbar B Select Register 3
        volatile uint32_t SEL4;  ///< Offset: 0x08 - Crossbar B Select Register 4
        volatile uint32_t SEL5;  ///< Offset: 0x0A - Crossbar B Select Register 5
        volatile uint32_t SEL6;  ///< Offset: 0x0C - Crossbar B Select Register 6
        volatile uint32_t SEL7;  ///< Offset: 0x0E - Crossbar B Select Register 7
    };

    /// Peripheral instances
    inline Registers* XBARB2 = reinterpret_cast<Registers*>(XBARB2_BASE);

    // Bit definitions
    /// SEL0 Register bits
    namespace sel0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT0 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL1 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT1 (refer to Functional Description section for input/output assignment)
    }

    /// SEL1 Register bits
    namespace sel1_bits {
        constexpr uint32_t SEL2 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT2 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL3 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT3 (refer to Functional Description section for input/output assignment)
    }

    /// SEL2 Register bits
    namespace sel2_bits {
        constexpr uint32_t SEL4 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT4 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL5 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT5 (refer to Functional Description section for input/output assignment)
    }

    /// SEL3 Register bits
    namespace sel3_bits {
        constexpr uint32_t SEL6 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT6 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL7 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT7 (refer to Functional Description section for input/output assignment)
    }

    /// SEL4 Register bits
    namespace sel4_bits {
        constexpr uint32_t SEL8 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT8 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL9 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT9 (refer to Functional Description section for input/output assignment)
    }

    /// SEL5 Register bits
    namespace sel5_bits {
        constexpr uint32_t SEL10 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT10 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL11 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT11 (refer to Functional Description section for input/output assignment)
    }

    /// SEL6 Register bits
    namespace sel6_bits {
        constexpr uint32_t SEL12 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT12 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL13 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT13 (refer to Functional Description section for input/output assignment)
    }

    /// SEL7 Register bits
    namespace sel7_bits {
        constexpr uint32_t SEL14 = (6 << 0);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT14 (refer to Functional Description section for input/output assignment)
        constexpr uint32_t SEL15 = (6 << 8);  ///< Input (XBARB_INn) to be muxed to XBARB_OUT15 (refer to Functional Description section for input/output assignment)
    }

}

// ============================================================================
// XBARB3 Peripheral
// ============================================================================

namespace xbarb3 {
    /// Base addresses
    constexpr uint32_t XBARB3_BASE = 0x403C4000;

    /// XBARB3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* XBARB3 = reinterpret_cast<Registers*>(XBARB3_BASE);

}

// ============================================================================
// ENC1 Peripheral
// ============================================================================

namespace enc1 {
    /// Base addresses
    constexpr uint32_t ENC1_BASE = 0x403C8000;

    /// ENC1 Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t FILT;  ///< Offset: 0x02 - Input Filter Register
        volatile uint32_t WTR;  ///< Offset: 0x04 - Watchdog Timeout Register
        volatile uint32_t POSD;  ///< Offset: 0x06 - Position Difference Counter Register
        volatile uint32_t POSDH;  ///< Offset: 0x08 - Position Difference Hold Register
        volatile uint32_t REV;  ///< Offset: 0x0A - Revolution Counter Register
        volatile uint32_t REVH;  ///< Offset: 0x0C - Revolution Hold Register
        volatile uint32_t UPOS;  ///< Offset: 0x0E - Upper Position Counter Register
        volatile uint32_t LPOS;  ///< Offset: 0x10 - Lower Position Counter Register
        volatile uint32_t UPOSH;  ///< Offset: 0x12 - Upper Position Hold Register
        volatile uint32_t LPOSH;  ///< Offset: 0x14 - Lower Position Hold Register
        volatile uint32_t UINIT;  ///< Offset: 0x16 - Upper Initialization Register
        volatile uint32_t LINIT;  ///< Offset: 0x18 - Lower Initialization Register
        volatile uint32_t IMR;  ///< Offset: 0x1A - Input Monitor Register
        volatile uint32_t TST;  ///< Offset: 0x1C - Test Register
        volatile uint32_t CTRL2;  ///< Offset: 0x1E - Control 2 Register
        volatile uint32_t UMOD;  ///< Offset: 0x20 - Upper Modulus Register
        volatile uint32_t LMOD;  ///< Offset: 0x22 - Lower Modulus Register
        volatile uint32_t UCOMP;  ///< Offset: 0x24 - Upper Position Compare Register
        volatile uint32_t LCOMP;  ///< Offset: 0x26 - Lower Position Compare Register
    };

    /// Peripheral instances
    inline Registers* ENC1 = reinterpret_cast<Registers*>(ENC1_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t CMPIE = (1U << 0);  ///< Compare Interrupt Enable
        constexpr uint32_t CMPIRQ = (1U << 1);  ///< Compare Interrupt Request
        constexpr uint32_t WDE = (1U << 2);  ///< Watchdog Enable
        constexpr uint32_t DIE = (1U << 3);  ///< Watchdog Timeout Interrupt Enable
        constexpr uint32_t DIRQ = (1U << 4);  ///< Watchdog Timeout Interrupt Request
        constexpr uint32_t XNE = (1U << 5);  ///< Use Negative Edge of INDEX Pulse
        constexpr uint32_t XIP = (1U << 6);  ///< INDEX Triggered Initialization of Position Counters UPOS and LPOS
        constexpr uint32_t XIE = (1U << 7);  ///< INDEX Pulse Interrupt Enable
        constexpr uint32_t XIRQ = (1U << 8);  ///< INDEX Pulse Interrupt Request
        constexpr uint32_t PH1 = (1U << 9);  ///< Enable Signal Phase Count Mode
        constexpr uint32_t REV = (1U << 10);  ///< Enable Reverse Direction Counting
        constexpr uint32_t SWIP = (1U << 11);  ///< Software Triggered Initialization of Position Counters UPOS and LPOS
        constexpr uint32_t HNE = (1U << 12);  ///< Use Negative Edge of HOME Input
        constexpr uint32_t HIP = (1U << 13);  ///< Enable HOME to Initialize Position Counters UPOS and LPOS
        constexpr uint32_t HIE = (1U << 14);  ///< HOME Interrupt Enable
        constexpr uint32_t HIRQ = (1U << 15);  ///< HOME Signal Transition Interrupt Request
    }

    /// FILT Register bits
    namespace filt_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Input Filter Sample Period
        constexpr uint32_t FILT_CNT = (3 << 8);  ///< Input Filter Sample Count
    }

    /// WTR Register bits
    namespace wtr_bits {
        constexpr uint32_t WDOG = (16 << 0);  ///< WDOG[15:0] is a binary representation of the number of clock cycles plus one that the watchdog timer counts before timing out and optionally generating an interrupt
    }

    /// POSD Register bits
    namespace posd_bits {
        constexpr uint32_t POSD = (16 << 0);  ///< This read/write register contains the position change in value occurring between each read of the position register
    }

    /// POSDH Register bits
    namespace posdh_bits {
        constexpr uint32_t POSDH = (16 << 0);  ///< This read-only register contains a snapshot of the value of the POSD register
    }

    /// REV Register bits
    namespace rev_bits {
        constexpr uint32_t REV = (16 << 0);  ///< This read/write register contains the current value of the revolution counter.
    }

    /// REVH Register bits
    namespace revh_bits {
        constexpr uint32_t REVH = (16 << 0);  ///< This read-only register contains a snapshot of the value of the REV register.
    }

    /// UPOS Register bits
    namespace upos_bits {
        constexpr uint32_t POS = (16 << 0);  ///< This read/write register contains the upper (most significant) half of the position counter
    }

    /// LPOS Register bits
    namespace lpos_bits {
        constexpr uint32_t POS = (16 << 0);  ///< This read/write register contains the lower (least significant) half of the position counter
    }

    /// UPOSH Register bits
    namespace uposh_bits {
        constexpr uint32_t POSH = (16 << 0);  ///< This read-only register contains a snapshot of the UPOS register.
    }

    /// LPOSH Register bits
    namespace lposh_bits {
        constexpr uint32_t POSH = (16 << 0);  ///< This read-only register contains a snapshot of the LPOS register.
    }

    /// UINIT Register bits
    namespace uinit_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< This read/write register contains the value to be used to initialize the upper half of the position counter (UPOS)
    }

    /// LINIT Register bits
    namespace linit_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< This read/write register contains the value to be used to initialize the lower half of the position counter (LPOS)
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t HOME = (1U << 0);  ///< This is the raw HOME input.
        constexpr uint32_t INDEX = (1U << 1);  ///< This is the raw INDEX input.
        constexpr uint32_t PHB = (1U << 2);  ///< This is the raw PHASEB input.
        constexpr uint32_t PHA = (1U << 3);  ///< This is the raw PHASEA input.
        constexpr uint32_t FHOM = (1U << 4);  ///< This is the filtered version of HOME input.
        constexpr uint32_t FIND = (1U << 5);  ///< This is the filtered version of INDEX input.
        constexpr uint32_t FPHB = (1U << 6);  ///< This is the filtered version of PHASEB input.
        constexpr uint32_t FPHA = (1U << 7);  ///< This is the filtered version of PHASEA input.
    }

    /// TST Register bits
    namespace tst_bits {
        constexpr uint32_t TEST_COUNT = (8 << 0);  ///< These bits hold the number of quadrature advances to generate.
        constexpr uint32_t TEST_PERIOD = (5 << 8);  ///< These bits hold the period of quadrature phase in IPBus clock cycles.
        constexpr uint32_t QDN = (1U << 13);  ///< Quadrature Decoder Negative Signal
        constexpr uint32_t TCE = (1U << 14);  ///< Test Counter Enable
        constexpr uint32_t TEN = (1U << 15);  ///< Test Mode Enable
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t UPDHLD = (1U << 0);  ///< Update Hold Registers
        constexpr uint32_t UPDPOS = (1U << 1);  ///< Update Position Registers
        constexpr uint32_t MOD = (1U << 2);  ///< Enable Modulo Counting
        constexpr uint32_t DIR = (1U << 3);  ///< Count Direction Flag
        constexpr uint32_t RUIE = (1U << 4);  ///< Roll-under Interrupt Enable
        constexpr uint32_t RUIRQ = (1U << 5);  ///< Roll-under Interrupt Request
        constexpr uint32_t ROIE = (1U << 6);  ///< Roll-over Interrupt Enable
        constexpr uint32_t ROIRQ = (1U << 7);  ///< Roll-over Interrupt Request
        constexpr uint32_t REVMOD = (1U << 8);  ///< Revolution Counter Modulus Enable
        constexpr uint32_t OUTCTL = (1U << 9);  ///< Output Control
        constexpr uint32_t SABIE = (1U << 10);  ///< Simultaneous PHASEA and PHASEB Change Interrupt Enable
        constexpr uint32_t SABIRQ = (1U << 11);  ///< Simultaneous PHASEA and PHASEB Change Interrupt Request
    }

    /// UMOD Register bits
    namespace umod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< This read/write register contains the upper (most significant) half of the modulus register
    }

    /// LMOD Register bits
    namespace lmod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< This read/write register contains the lower (least significant) half of the modulus register
    }

    /// UCOMP Register bits
    namespace ucomp_bits {
        constexpr uint32_t COMP = (16 << 0);  ///< This read/write register contains the upper (most significant) half of the position compare register
    }

    /// LCOMP Register bits
    namespace lcomp_bits {
        constexpr uint32_t COMP = (16 << 0);  ///< This read/write register contains the lower (least significant) half of the position compare register
    }

}

// ============================================================================
// ENC2 Peripheral
// ============================================================================

namespace enc2 {
    /// Base addresses
    constexpr uint32_t ENC2_BASE = 0x403CC000;

    /// ENC2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ENC2 = reinterpret_cast<Registers*>(ENC2_BASE);

}

// ============================================================================
// ENC3 Peripheral
// ============================================================================

namespace enc3 {
    /// Base addresses
    constexpr uint32_t ENC3_BASE = 0x403D0000;

    /// ENC3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ENC3 = reinterpret_cast<Registers*>(ENC3_BASE);

}

// ============================================================================
// ENC4 Peripheral
// ============================================================================

namespace enc4 {
    /// Base addresses
    constexpr uint32_t ENC4_BASE = 0x403D4000;

    /// ENC4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ENC4 = reinterpret_cast<Registers*>(ENC4_BASE);

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t PWM1_BASE = 0x403DC000;
    constexpr uint32_t PWM2_BASE = 0x403E0000;
    constexpr uint32_t PWM3_BASE = 0x403E4000;
    constexpr uint32_t PWM4_BASE = 0x403E8000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t SM0CNT;  ///< Offset: 0x00 - Counter Register
        volatile uint32_t SM0INIT;  ///< Offset: 0x02 - Initial Count Register
        volatile uint32_t SM0CTRL2;  ///< Offset: 0x04 - Control 2 Register
        volatile uint32_t SM0CTRL;  ///< Offset: 0x06 - Control Register
        volatile uint32_t SM0VAL0;  ///< Offset: 0x0A - Value Register 0
        volatile uint32_t SM0FRACVAL1;  ///< Offset: 0x0C - Fractional Value Register 1
        volatile uint32_t SM0VAL1;  ///< Offset: 0x0E - Value Register 1
        volatile uint32_t SM0FRACVAL2;  ///< Offset: 0x10 - Fractional Value Register 2
        volatile uint32_t SM0VAL2;  ///< Offset: 0x12 - Value Register 2
        volatile uint32_t SM0FRACVAL3;  ///< Offset: 0x14 - Fractional Value Register 3
        volatile uint32_t SM0VAL3;  ///< Offset: 0x16 - Value Register 3
        volatile uint32_t SM0FRACVAL4;  ///< Offset: 0x18 - Fractional Value Register 4
        volatile uint32_t SM0VAL4;  ///< Offset: 0x1A - Value Register 4
        volatile uint32_t SM0FRACVAL5;  ///< Offset: 0x1C - Fractional Value Register 5
        volatile uint32_t SM0VAL5;  ///< Offset: 0x1E - Value Register 5
        volatile uint32_t SM0FRCTRL;  ///< Offset: 0x20 - Fractional Control Register
        volatile uint32_t SM0OCTRL;  ///< Offset: 0x22 - Output Control Register
        volatile uint32_t SM0STS;  ///< Offset: 0x24 - Status Register
        volatile uint32_t SM0INTEN;  ///< Offset: 0x26 - Interrupt Enable Register
        volatile uint32_t SM0DMAEN;  ///< Offset: 0x28 - DMA Enable Register
        volatile uint32_t SM0TCTRL;  ///< Offset: 0x2A - Output Trigger Control Register
        volatile uint32_t SM0DISMAP0;  ///< Offset: 0x2C - Fault Disable Mapping Register 0
        volatile uint32_t SM0DISMAP1;  ///< Offset: 0x2E - Fault Disable Mapping Register 1
        volatile uint32_t SM0DTCNT0;  ///< Offset: 0x30 - Deadtime Count Register 0
        volatile uint32_t SM0DTCNT1;  ///< Offset: 0x32 - Deadtime Count Register 1
        volatile uint32_t SM0CAPTCTRLA;  ///< Offset: 0x34 - Capture Control A Register
        volatile uint32_t SM0CAPTCOMPA;  ///< Offset: 0x36 - Capture Compare A Register
        volatile uint32_t SM0CAPTCTRLB;  ///< Offset: 0x38 - Capture Control B Register
        volatile uint32_t SM0CAPTCOMPB;  ///< Offset: 0x3A - Capture Compare B Register
        volatile uint32_t SM0CAPTCTRLX;  ///< Offset: 0x3C - Capture Control X Register
        volatile uint32_t SM0CAPTCOMPX;  ///< Offset: 0x3E - Capture Compare X Register
        volatile uint32_t SM0CVAL0;  ///< Offset: 0x40 - Capture Value 0 Register
        volatile uint32_t SM0CVAL0CYC;  ///< Offset: 0x42 - Capture Value 0 Cycle Register
        volatile uint32_t SM0CVAL1;  ///< Offset: 0x44 - Capture Value 1 Register
        volatile uint32_t SM0CVAL1CYC;  ///< Offset: 0x46 - Capture Value 1 Cycle Register
        volatile uint32_t SM0CVAL2;  ///< Offset: 0x48 - Capture Value 2 Register
        volatile uint32_t SM0CVAL2CYC;  ///< Offset: 0x4A - Capture Value 2 Cycle Register
        volatile uint32_t SM0CVAL3;  ///< Offset: 0x4C - Capture Value 3 Register
        volatile uint32_t SM0CVAL3CYC;  ///< Offset: 0x4E - Capture Value 3 Cycle Register
        volatile uint32_t SM0CVAL4;  ///< Offset: 0x50 - Capture Value 4 Register
        volatile uint32_t SM0CVAL4CYC;  ///< Offset: 0x52 - Capture Value 4 Cycle Register
        volatile uint32_t SM0CVAL5;  ///< Offset: 0x54 - Capture Value 5 Register
        volatile uint32_t SM0CVAL5CYC;  ///< Offset: 0x56 - Capture Value 5 Cycle Register
        volatile uint32_t SM1CNT;  ///< Offset: 0x60 - Counter Register
        volatile uint32_t SM1INIT;  ///< Offset: 0x62 - Initial Count Register
        volatile uint32_t SM1CTRL2;  ///< Offset: 0x64 - Control 2 Register
        volatile uint32_t SM1CTRL;  ///< Offset: 0x66 - Control Register
        volatile uint32_t SM1VAL0;  ///< Offset: 0x6A - Value Register 0
        volatile uint32_t SM1FRACVAL1;  ///< Offset: 0x6C - Fractional Value Register 1
        volatile uint32_t SM1VAL1;  ///< Offset: 0x6E - Value Register 1
        volatile uint32_t SM1FRACVAL2;  ///< Offset: 0x70 - Fractional Value Register 2
        volatile uint32_t SM1VAL2;  ///< Offset: 0x72 - Value Register 2
        volatile uint32_t SM1FRACVAL3;  ///< Offset: 0x74 - Fractional Value Register 3
        volatile uint32_t SM1VAL3;  ///< Offset: 0x76 - Value Register 3
        volatile uint32_t SM1FRACVAL4;  ///< Offset: 0x78 - Fractional Value Register 4
        volatile uint32_t SM1VAL4;  ///< Offset: 0x7A - Value Register 4
        volatile uint32_t SM1FRACVAL5;  ///< Offset: 0x7C - Fractional Value Register 5
        volatile uint32_t SM1VAL5;  ///< Offset: 0x7E - Value Register 5
        volatile uint32_t SM1FRCTRL;  ///< Offset: 0x80 - Fractional Control Register
        volatile uint32_t SM1OCTRL;  ///< Offset: 0x82 - Output Control Register
        volatile uint32_t SM1STS;  ///< Offset: 0x84 - Status Register
        volatile uint32_t SM1INTEN;  ///< Offset: 0x86 - Interrupt Enable Register
        volatile uint32_t SM1DMAEN;  ///< Offset: 0x88 - DMA Enable Register
        volatile uint32_t SM1TCTRL;  ///< Offset: 0x8A - Output Trigger Control Register
        volatile uint32_t SM1DISMAP0;  ///< Offset: 0x8C - Fault Disable Mapping Register 0
        volatile uint32_t SM1DISMAP1;  ///< Offset: 0x8E - Fault Disable Mapping Register 1
        volatile uint32_t SM1DTCNT0;  ///< Offset: 0x90 - Deadtime Count Register 0
        volatile uint32_t SM1DTCNT1;  ///< Offset: 0x92 - Deadtime Count Register 1
        volatile uint32_t SM1CAPTCTRLA;  ///< Offset: 0x94 - Capture Control A Register
        volatile uint32_t SM1CAPTCOMPA;  ///< Offset: 0x96 - Capture Compare A Register
        volatile uint32_t SM1CAPTCTRLB;  ///< Offset: 0x98 - Capture Control B Register
        volatile uint32_t SM1CAPTCOMPB;  ///< Offset: 0x9A - Capture Compare B Register
        volatile uint32_t SM1CAPTCTRLX;  ///< Offset: 0x9C - Capture Control X Register
        volatile uint32_t SM1CAPTCOMPX;  ///< Offset: 0x9E - Capture Compare X Register
        volatile uint32_t SM1CVAL0;  ///< Offset: 0xA0 - Capture Value 0 Register
        volatile uint32_t SM1CVAL0CYC;  ///< Offset: 0xA2 - Capture Value 0 Cycle Register
        volatile uint32_t SM1CVAL1;  ///< Offset: 0xA4 - Capture Value 1 Register
        volatile uint32_t SM1CVAL1CYC;  ///< Offset: 0xA6 - Capture Value 1 Cycle Register
        volatile uint32_t SM1CVAL2;  ///< Offset: 0xA8 - Capture Value 2 Register
        volatile uint32_t SM1CVAL2CYC;  ///< Offset: 0xAA - Capture Value 2 Cycle Register
        volatile uint32_t SM1CVAL3;  ///< Offset: 0xAC - Capture Value 3 Register
        volatile uint32_t SM1CVAL3CYC;  ///< Offset: 0xAE - Capture Value 3 Cycle Register
        volatile uint32_t SM1CVAL4;  ///< Offset: 0xB0 - Capture Value 4 Register
        volatile uint32_t SM1CVAL4CYC;  ///< Offset: 0xB2 - Capture Value 4 Cycle Register
        volatile uint32_t SM1CVAL5;  ///< Offset: 0xB4 - Capture Value 5 Register
        volatile uint32_t SM1CVAL5CYC;  ///< Offset: 0xB6 - Capture Value 5 Cycle Register
        volatile uint32_t SM2CNT;  ///< Offset: 0xC0 - Counter Register
        volatile uint32_t SM2INIT;  ///< Offset: 0xC2 - Initial Count Register
        volatile uint32_t SM2CTRL2;  ///< Offset: 0xC4 - Control 2 Register
        volatile uint32_t SM2CTRL;  ///< Offset: 0xC6 - Control Register
        volatile uint32_t SM2VAL0;  ///< Offset: 0xCA - Value Register 0
        volatile uint32_t SM2FRACVAL1;  ///< Offset: 0xCC - Fractional Value Register 1
        volatile uint32_t SM2VAL1;  ///< Offset: 0xCE - Value Register 1
        volatile uint32_t SM2FRACVAL2;  ///< Offset: 0xD0 - Fractional Value Register 2
        volatile uint32_t SM2VAL2;  ///< Offset: 0xD2 - Value Register 2
        volatile uint32_t SM2FRACVAL3;  ///< Offset: 0xD4 - Fractional Value Register 3
        volatile uint32_t SM2VAL3;  ///< Offset: 0xD6 - Value Register 3
        volatile uint32_t SM2FRACVAL4;  ///< Offset: 0xD8 - Fractional Value Register 4
        volatile uint32_t SM2VAL4;  ///< Offset: 0xDA - Value Register 4
        volatile uint32_t SM2FRACVAL5;  ///< Offset: 0xDC - Fractional Value Register 5
        volatile uint32_t SM2VAL5;  ///< Offset: 0xDE - Value Register 5
        volatile uint32_t SM2FRCTRL;  ///< Offset: 0xE0 - Fractional Control Register
        volatile uint32_t SM2OCTRL;  ///< Offset: 0xE2 - Output Control Register
        volatile uint32_t SM2STS;  ///< Offset: 0xE4 - Status Register
        volatile uint32_t SM2INTEN;  ///< Offset: 0xE6 - Interrupt Enable Register
        volatile uint32_t SM2DMAEN;  ///< Offset: 0xE8 - DMA Enable Register
        volatile uint32_t SM2TCTRL;  ///< Offset: 0xEA - Output Trigger Control Register
        volatile uint32_t SM2DISMAP0;  ///< Offset: 0xEC - Fault Disable Mapping Register 0
        volatile uint32_t SM2DISMAP1;  ///< Offset: 0xEE - Fault Disable Mapping Register 1
        volatile uint32_t SM2DTCNT0;  ///< Offset: 0xF0 - Deadtime Count Register 0
        volatile uint32_t SM2DTCNT1;  ///< Offset: 0xF2 - Deadtime Count Register 1
        volatile uint32_t SM2CAPTCTRLA;  ///< Offset: 0xF4 - Capture Control A Register
        volatile uint32_t SM2CAPTCOMPA;  ///< Offset: 0xF6 - Capture Compare A Register
        volatile uint32_t SM2CAPTCTRLB;  ///< Offset: 0xF8 - Capture Control B Register
        volatile uint32_t SM2CAPTCOMPB;  ///< Offset: 0xFA - Capture Compare B Register
        volatile uint32_t SM2CAPTCTRLX;  ///< Offset: 0xFC - Capture Control X Register
        volatile uint32_t SM2CAPTCOMPX;  ///< Offset: 0xFE - Capture Compare X Register
        volatile uint32_t SM2CVAL0;  ///< Offset: 0x100 - Capture Value 0 Register
        volatile uint32_t SM2CVAL0CYC;  ///< Offset: 0x102 - Capture Value 0 Cycle Register
        volatile uint32_t SM2CVAL1;  ///< Offset: 0x104 - Capture Value 1 Register
        volatile uint32_t SM2CVAL1CYC;  ///< Offset: 0x106 - Capture Value 1 Cycle Register
        volatile uint32_t SM2CVAL2;  ///< Offset: 0x108 - Capture Value 2 Register
        volatile uint32_t SM2CVAL2CYC;  ///< Offset: 0x10A - Capture Value 2 Cycle Register
        volatile uint32_t SM2CVAL3;  ///< Offset: 0x10C - Capture Value 3 Register
        volatile uint32_t SM2CVAL3CYC;  ///< Offset: 0x10E - Capture Value 3 Cycle Register
        volatile uint32_t SM2CVAL4;  ///< Offset: 0x110 - Capture Value 4 Register
        volatile uint32_t SM2CVAL4CYC;  ///< Offset: 0x112 - Capture Value 4 Cycle Register
        volatile uint32_t SM2CVAL5;  ///< Offset: 0x114 - Capture Value 5 Register
        volatile uint32_t SM2CVAL5CYC;  ///< Offset: 0x116 - Capture Value 5 Cycle Register
        volatile uint32_t SM3CNT;  ///< Offset: 0x120 - Counter Register
        volatile uint32_t SM3INIT;  ///< Offset: 0x122 - Initial Count Register
        volatile uint32_t SM3CTRL2;  ///< Offset: 0x124 - Control 2 Register
        volatile uint32_t SM3CTRL;  ///< Offset: 0x126 - Control Register
        volatile uint32_t SM3VAL0;  ///< Offset: 0x12A - Value Register 0
        volatile uint32_t SM3FRACVAL1;  ///< Offset: 0x12C - Fractional Value Register 1
        volatile uint32_t SM3VAL1;  ///< Offset: 0x12E - Value Register 1
        volatile uint32_t SM3FRACVAL2;  ///< Offset: 0x130 - Fractional Value Register 2
        volatile uint32_t SM3VAL2;  ///< Offset: 0x132 - Value Register 2
        volatile uint32_t SM3FRACVAL3;  ///< Offset: 0x134 - Fractional Value Register 3
        volatile uint32_t SM3VAL3;  ///< Offset: 0x136 - Value Register 3
        volatile uint32_t SM3FRACVAL4;  ///< Offset: 0x138 - Fractional Value Register 4
        volatile uint32_t SM3VAL4;  ///< Offset: 0x13A - Value Register 4
        volatile uint32_t SM3FRACVAL5;  ///< Offset: 0x13C - Fractional Value Register 5
        volatile uint32_t SM3VAL5;  ///< Offset: 0x13E - Value Register 5
        volatile uint32_t SM3FRCTRL;  ///< Offset: 0x140 - Fractional Control Register
        volatile uint32_t SM3OCTRL;  ///< Offset: 0x142 - Output Control Register
        volatile uint32_t SM3STS;  ///< Offset: 0x144 - Status Register
        volatile uint32_t SM3INTEN;  ///< Offset: 0x146 - Interrupt Enable Register
        volatile uint32_t SM3DMAEN;  ///< Offset: 0x148 - DMA Enable Register
        volatile uint32_t SM3TCTRL;  ///< Offset: 0x14A - Output Trigger Control Register
        volatile uint32_t SM3DISMAP0;  ///< Offset: 0x14C - Fault Disable Mapping Register 0
        volatile uint32_t SM3DISMAP1;  ///< Offset: 0x14E - Fault Disable Mapping Register 1
        volatile uint32_t SM3DTCNT0;  ///< Offset: 0x150 - Deadtime Count Register 0
        volatile uint32_t SM3DTCNT1;  ///< Offset: 0x152 - Deadtime Count Register 1
        volatile uint32_t SM3CAPTCTRLA;  ///< Offset: 0x154 - Capture Control A Register
        volatile uint32_t SM3CAPTCOMPA;  ///< Offset: 0x156 - Capture Compare A Register
        volatile uint32_t SM3CAPTCTRLB;  ///< Offset: 0x158 - Capture Control B Register
        volatile uint32_t SM3CAPTCOMPB;  ///< Offset: 0x15A - Capture Compare B Register
        volatile uint32_t SM3CAPTCTRLX;  ///< Offset: 0x15C - Capture Control X Register
        volatile uint32_t SM3CAPTCOMPX;  ///< Offset: 0x15E - Capture Compare X Register
        volatile uint32_t SM3CVAL0;  ///< Offset: 0x160 - Capture Value 0 Register
        volatile uint32_t SM3CVAL0CYC;  ///< Offset: 0x162 - Capture Value 0 Cycle Register
        volatile uint32_t SM3CVAL1;  ///< Offset: 0x164 - Capture Value 1 Register
        volatile uint32_t SM3CVAL1CYC;  ///< Offset: 0x166 - Capture Value 1 Cycle Register
        volatile uint32_t SM3CVAL2;  ///< Offset: 0x168 - Capture Value 2 Register
        volatile uint32_t SM3CVAL2CYC;  ///< Offset: 0x16A - Capture Value 2 Cycle Register
        volatile uint32_t SM3CVAL3;  ///< Offset: 0x16C - Capture Value 3 Register
        volatile uint32_t SM3CVAL3CYC;  ///< Offset: 0x16E - Capture Value 3 Cycle Register
        volatile uint32_t SM3CVAL4;  ///< Offset: 0x170 - Capture Value 4 Register
        volatile uint32_t SM3CVAL4CYC;  ///< Offset: 0x172 - Capture Value 4 Cycle Register
        volatile uint32_t SM3CVAL5;  ///< Offset: 0x174 - Capture Value 5 Register
        volatile uint32_t SM3CVAL5CYC;  ///< Offset: 0x176 - Capture Value 5 Cycle Register
        volatile uint32_t OUTEN;  ///< Offset: 0x180 - Output Enable Register
        volatile uint32_t MASK;  ///< Offset: 0x182 - Mask Register
        volatile uint32_t SWCOUT;  ///< Offset: 0x184 - Software Controlled Output Register
        volatile uint32_t DTSRCSEL;  ///< Offset: 0x186 - PWM Source Select Register
        volatile uint32_t MCTRL;  ///< Offset: 0x188 - Master Control Register
        volatile uint32_t MCTRL2;  ///< Offset: 0x18A - Master Control 2 Register
        volatile uint32_t FCTRL0;  ///< Offset: 0x18C - Fault Control Register
        volatile uint32_t FSTS0;  ///< Offset: 0x18E - Fault Status Register
        volatile uint32_t FFILT0;  ///< Offset: 0x190 - Fault Filter Register
        volatile uint32_t FTST0;  ///< Offset: 0x192 - Fault Test Register
        volatile uint32_t FCTRL20;  ///< Offset: 0x194 - Fault Control 2 Register
    };

    /// Peripheral instances
    inline Registers* PWM1 = reinterpret_cast<Registers*>(PWM1_BASE);
    inline Registers* PWM2 = reinterpret_cast<Registers*>(PWM2_BASE);
    inline Registers* PWM3 = reinterpret_cast<Registers*>(PWM3_BASE);
    inline Registers* PWM4 = reinterpret_cast<Registers*>(PWM4_BASE);

    // Bit definitions
    /// SM0CNT Register bits
    namespace sm0cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter Register Bits
    }

    /// SM0INIT Register bits
    namespace sm0init_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Count Register Bits
    }

    /// SM0CTRL2 Register bits
    namespace sm0ctrl2_bits {
        constexpr uint32_t CLK_SEL = (2 << 0);  ///< Clock Source Select
        constexpr uint32_t RELOAD_SEL = (1U << 2);  ///< Reload Source Select
        constexpr uint32_t FORCE_SEL = (3 << 3);  ///< This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
        constexpr uint32_t FORCE = (1U << 6);  ///< Force Initialization
        constexpr uint32_t FRCEN = (1U << 7);  ///< FRCEN
        constexpr uint32_t INIT_SEL = (2 << 8);  ///< Initialization Control Select
        constexpr uint32_t PWMX_INIT = (1U << 10);  ///< PWM_X Initial Value
        constexpr uint32_t PWM45_INIT = (1U << 11);  ///< PWM45 Initial Value
        constexpr uint32_t PWM23_INIT = (1U << 12);  ///< PWM23 Initial Value
        constexpr uint32_t INDEP = (1U << 13);  ///< Independent or Complementary Pair Operation
        constexpr uint32_t WAITEN = (1U << 14);  ///< WAIT Enable
        constexpr uint32_t DBGEN = (1U << 15);  ///< Debug Enable
    }

    /// SM0CTRL Register bits
    namespace sm0ctrl_bits {
        constexpr uint32_t DBLEN = (1U << 0);  ///< Double Switching Enable
        constexpr uint32_t DBLX = (1U << 1);  ///< PWMX Double Switching Enable
        constexpr uint32_t LDMOD = (1U << 2);  ///< Load Mode Select
        constexpr uint32_t SPLIT = (1U << 3);  ///< Split the DBLPWM signal to PWMA and PWMB
        constexpr uint32_t PRSC = (3 << 4);  ///< Prescaler
        constexpr uint32_t COMPMODE = (1U << 7);  ///< Compare Mode
        constexpr uint32_t DT = (2 << 8);  ///< Deadtime
        constexpr uint32_t FULL = (1U << 10);  ///< Full Cycle Reload
        constexpr uint32_t HALF = (1U << 11);  ///< Half Cycle Reload
        constexpr uint32_t LDFQ = (4 << 12);  ///< Load Frequency
    }

    /// SM0VAL0 Register bits
    namespace sm0val0_bits {
        constexpr uint32_t VAL0 = (16 << 0);  ///< Value Register 0
    }

    /// SM0FRACVAL1 Register bits
    namespace sm0fracval1_bits {
        constexpr uint32_t FRACVAL1 = (5 << 11);  ///< Fractional Value 1 Register
    }

    /// SM0VAL1 Register bits
    namespace sm0val1_bits {
        constexpr uint32_t VAL1 = (16 << 0);  ///< Value Register 1
    }

    /// SM0FRACVAL2 Register bits
    namespace sm0fracval2_bits {
        constexpr uint32_t FRACVAL2 = (5 << 11);  ///< Fractional Value 2
    }

    /// SM0VAL2 Register bits
    namespace sm0val2_bits {
        constexpr uint32_t VAL2 = (16 << 0);  ///< Value Register 2
    }

    /// SM0FRACVAL3 Register bits
    namespace sm0fracval3_bits {
        constexpr uint32_t FRACVAL3 = (5 << 11);  ///< Fractional Value 3
    }

    /// SM0VAL3 Register bits
    namespace sm0val3_bits {
        constexpr uint32_t VAL3 = (16 << 0);  ///< Value Register 3
    }

    /// SM0FRACVAL4 Register bits
    namespace sm0fracval4_bits {
        constexpr uint32_t FRACVAL4 = (5 << 11);  ///< Fractional Value 4
    }

    /// SM0VAL4 Register bits
    namespace sm0val4_bits {
        constexpr uint32_t VAL4 = (16 << 0);  ///< Value Register 4
    }

    /// SM0FRACVAL5 Register bits
    namespace sm0fracval5_bits {
        constexpr uint32_t FRACVAL5 = (5 << 11);  ///< Fractional Value 5
    }

    /// SM0VAL5 Register bits
    namespace sm0val5_bits {
        constexpr uint32_t VAL5 = (16 << 0);  ///< Value Register 5
    }

    /// SM0FRCTRL Register bits
    namespace sm0frctrl_bits {
        constexpr uint32_t FRAC1_EN = (1U << 1);  ///< Fractional Cycle PWM Period Enable
        constexpr uint32_t FRAC23_EN = (1U << 2);  ///< Fractional Cycle Placement Enable for PWM_A
        constexpr uint32_t FRAC45_EN = (1U << 4);  ///< Fractional Cycle Placement Enable for PWM_B
        constexpr uint32_t FRAC_PU = (1U << 8);  ///< Fractional Delay Circuit Power Up
        constexpr uint32_t TEST = (1U << 15);  ///< Test Status Bit
    }

    /// SM0OCTRL Register bits
    namespace sm0octrl_bits {
        constexpr uint32_t PWMXFS = (2 << 0);  ///< PWM_X Fault State
        constexpr uint32_t PWMBFS = (2 << 2);  ///< PWM_B Fault State
        constexpr uint32_t PWMAFS = (2 << 4);  ///< PWM_A Fault State
        constexpr uint32_t POLX = (1U << 8);  ///< PWM_X Output Polarity
        constexpr uint32_t POLB = (1U << 9);  ///< PWM_B Output Polarity
        constexpr uint32_t POLA = (1U << 10);  ///< PWM_A Output Polarity
        constexpr uint32_t PWMX_IN = (1U << 13);  ///< PWM_X Input
        constexpr uint32_t PWMB_IN = (1U << 14);  ///< PWM_B Input
        constexpr uint32_t PWMA_IN = (1U << 15);  ///< PWM_A Input
    }

    /// SM0STS Register bits
    namespace sm0sts_bits {
        constexpr uint32_t CMPF = (6 << 0);  ///< Compare Flags
        constexpr uint32_t CFX0 = (1U << 6);  ///< Capture Flag X0
        constexpr uint32_t CFX1 = (1U << 7);  ///< Capture Flag X1
        constexpr uint32_t CFB0 = (1U << 8);  ///< Capture Flag B0
        constexpr uint32_t CFB1 = (1U << 9);  ///< Capture Flag B1
        constexpr uint32_t CFA0 = (1U << 10);  ///< Capture Flag A0
        constexpr uint32_t CFA1 = (1U << 11);  ///< Capture Flag A1
        constexpr uint32_t RF = (1U << 12);  ///< Reload Flag
        constexpr uint32_t REF = (1U << 13);  ///< Reload Error Flag
        constexpr uint32_t RUF = (1U << 14);  ///< Registers Updated Flag
    }

    /// SM0INTEN Register bits
    namespace sm0inten_bits {
        constexpr uint32_t CMPIE = (6 << 0);  ///< Compare Interrupt Enables
        constexpr uint32_t CX0IE = (1U << 6);  ///< Capture X 0 Interrupt Enable
        constexpr uint32_t CX1IE = (1U << 7);  ///< Capture X 1 Interrupt Enable
        constexpr uint32_t CB0IE = (1U << 8);  ///< Capture B 0 Interrupt Enable
        constexpr uint32_t CB1IE = (1U << 9);  ///< Capture B 1 Interrupt Enable
        constexpr uint32_t CA0IE = (1U << 10);  ///< Capture A 0 Interrupt Enable
        constexpr uint32_t CA1IE = (1U << 11);  ///< Capture A 1 Interrupt Enable
        constexpr uint32_t RIE = (1U << 12);  ///< Reload Interrupt Enable
        constexpr uint32_t REIE = (1U << 13);  ///< Reload Error Interrupt Enable
    }

    /// SM0DMAEN Register bits
    namespace sm0dmaen_bits {
        constexpr uint32_t CX0DE = (1U << 0);  ///< Capture X0 FIFO DMA Enable
        constexpr uint32_t CX1DE = (1U << 1);  ///< Capture X1 FIFO DMA Enable
        constexpr uint32_t CB0DE = (1U << 2);  ///< Capture B0 FIFO DMA Enable
        constexpr uint32_t CB1DE = (1U << 3);  ///< Capture B1 FIFO DMA Enable
        constexpr uint32_t CA0DE = (1U << 4);  ///< Capture A0 FIFO DMA Enable
        constexpr uint32_t CA1DE = (1U << 5);  ///< Capture A1 FIFO DMA Enable
        constexpr uint32_t CAPTDE = (2 << 6);  ///< Capture DMA Enable Source Select
        constexpr uint32_t FAND = (1U << 8);  ///< FIFO Watermark AND Control
        constexpr uint32_t VALDE = (1U << 9);  ///< Value Registers DMA Enable
    }

    /// SM0TCTRL Register bits
    namespace sm0tctrl_bits {
        constexpr uint32_t OUT_TRIG_EN = (6 << 0);  ///< Output Trigger Enables
        constexpr uint32_t TRGFRQ = (1U << 12);  ///< Trigger frequency
        constexpr uint32_t PWBOT1 = (1U << 14);  ///< Output Trigger 1 Source Select
        constexpr uint32_t PWAOT0 = (1U << 15);  ///< Output Trigger 0 Source Select
    }

    /// SM0DISMAP0 Register bits
    namespace sm0dismap0_bits {
        constexpr uint32_t DIS0A = (4 << 0);  ///< PWM_A Fault Disable Mask 0
        constexpr uint32_t DIS0B = (4 << 4);  ///< PWM_B Fault Disable Mask 0
        constexpr uint32_t DIS0X = (4 << 8);  ///< PWM_X Fault Disable Mask 0
    }

    /// SM0DISMAP1 Register bits
    namespace sm0dismap1_bits {
        constexpr uint32_t DIS1A = (4 << 0);  ///< PWM_A Fault Disable Mask 1
        constexpr uint32_t DIS1B = (4 << 4);  ///< PWM_B Fault Disable Mask 1
        constexpr uint32_t DIS1X = (4 << 8);  ///< PWM_X Fault Disable Mask 1
    }

    /// SM0DTCNT0 Register bits
    namespace sm0dtcnt0_bits {
        constexpr uint32_t DTCNT0 = (16 << 0);  ///< DTCNT0
    }

    /// SM0DTCNT1 Register bits
    namespace sm0dtcnt1_bits {
        constexpr uint32_t DTCNT1 = (16 << 0);  ///< DTCNT1
    }

    /// SM0CAPTCTRLA Register bits
    namespace sm0captctrla_bits {
        constexpr uint32_t ARMA = (1U << 0);  ///< Arm A
        constexpr uint32_t ONESHOTA = (1U << 1);  ///< One Shot Mode A
        constexpr uint32_t EDGA0 = (2 << 2);  ///< Edge A 0
        constexpr uint32_t EDGA1 = (2 << 4);  ///< Edge A 1
        constexpr uint32_t INP_SELA = (1U << 6);  ///< Input Select A
        constexpr uint32_t EDGCNTA_EN = (1U << 7);  ///< Edge Counter A Enable
        constexpr uint32_t CFAWM = (2 << 8);  ///< Capture A FIFOs Water Mark
        constexpr uint32_t CA0CNT = (3 << 10);  ///< Capture A0 FIFO Word Count
        constexpr uint32_t CA1CNT = (3 << 13);  ///< Capture A1 FIFO Word Count
    }

    /// SM0CAPTCOMPA Register bits
    namespace sm0captcompa_bits {
        constexpr uint32_t EDGCMPA = (8 << 0);  ///< Edge Compare A
        constexpr uint32_t EDGCNTA = (8 << 8);  ///< Edge Counter A
    }

    /// SM0CAPTCTRLB Register bits
    namespace sm0captctrlb_bits {
        constexpr uint32_t ARMB = (1U << 0);  ///< Arm B
        constexpr uint32_t ONESHOTB = (1U << 1);  ///< One Shot Mode B
        constexpr uint32_t EDGB0 = (2 << 2);  ///< Edge B 0
        constexpr uint32_t EDGB1 = (2 << 4);  ///< Edge B 1
        constexpr uint32_t INP_SELB = (1U << 6);  ///< Input Select B
        constexpr uint32_t EDGCNTB_EN = (1U << 7);  ///< Edge Counter B Enable
        constexpr uint32_t CFBWM = (2 << 8);  ///< Capture B FIFOs Water Mark
        constexpr uint32_t CB0CNT = (3 << 10);  ///< Capture B0 FIFO Word Count
        constexpr uint32_t CB1CNT = (3 << 13);  ///< Capture B1 FIFO Word Count
    }

    /// SM0CAPTCOMPB Register bits
    namespace sm0captcompb_bits {
        constexpr uint32_t EDGCMPB = (8 << 0);  ///< Edge Compare B
        constexpr uint32_t EDGCNTB = (8 << 8);  ///< Edge Counter B
    }

    /// SM0CAPTCTRLX Register bits
    namespace sm0captctrlx_bits {
        constexpr uint32_t ARMX = (1U << 0);  ///< Arm X
        constexpr uint32_t ONESHOTX = (1U << 1);  ///< One Shot Mode Aux
        constexpr uint32_t EDGX0 = (2 << 2);  ///< Edge X 0
        constexpr uint32_t EDGX1 = (2 << 4);  ///< Edge X 1
        constexpr uint32_t INP_SELX = (1U << 6);  ///< Input Select X
        constexpr uint32_t EDGCNTX_EN = (1U << 7);  ///< Edge Counter X Enable
        constexpr uint32_t CFXWM = (2 << 8);  ///< Capture X FIFOs Water Mark
        constexpr uint32_t CX0CNT = (3 << 10);  ///< Capture X0 FIFO Word Count
        constexpr uint32_t CX1CNT = (3 << 13);  ///< Capture X1 FIFO Word Count
    }

    /// SM0CAPTCOMPX Register bits
    namespace sm0captcompx_bits {
        constexpr uint32_t EDGCMPX = (8 << 0);  ///< Edge Compare X
        constexpr uint32_t EDGCNTX = (8 << 8);  ///< Edge Counter X
    }

    /// SM0CVAL0 Register bits
    namespace sm0cval0_bits {
        constexpr uint32_t CAPTVAL0 = (16 << 0);  ///< CAPTVAL0
    }

    /// SM0CVAL0CYC Register bits
    namespace sm0cval0cyc_bits {
        constexpr uint32_t CVAL0CYC = (4 << 0);  ///< CVAL0CYC
    }

    /// SM0CVAL1 Register bits
    namespace sm0cval1_bits {
        constexpr uint32_t CAPTVAL1 = (16 << 0);  ///< CAPTVAL1
    }

    /// SM0CVAL1CYC Register bits
    namespace sm0cval1cyc_bits {
        constexpr uint32_t CVAL1CYC = (4 << 0);  ///< CVAL1CYC
    }

    /// SM0CVAL2 Register bits
    namespace sm0cval2_bits {
        constexpr uint32_t CAPTVAL2 = (16 << 0);  ///< CAPTVAL2
    }

    /// SM0CVAL2CYC Register bits
    namespace sm0cval2cyc_bits {
        constexpr uint32_t CVAL2CYC = (4 << 0);  ///< CVAL2CYC
    }

    /// SM0CVAL3 Register bits
    namespace sm0cval3_bits {
        constexpr uint32_t CAPTVAL3 = (16 << 0);  ///< CAPTVAL3
    }

    /// SM0CVAL3CYC Register bits
    namespace sm0cval3cyc_bits {
        constexpr uint32_t CVAL3CYC = (4 << 0);  ///< CVAL3CYC
    }

    /// SM0CVAL4 Register bits
    namespace sm0cval4_bits {
        constexpr uint32_t CAPTVAL4 = (16 << 0);  ///< CAPTVAL4
    }

    /// SM0CVAL4CYC Register bits
    namespace sm0cval4cyc_bits {
        constexpr uint32_t CVAL4CYC = (4 << 0);  ///< CVAL4CYC
    }

    /// SM0CVAL5 Register bits
    namespace sm0cval5_bits {
        constexpr uint32_t CAPTVAL5 = (16 << 0);  ///< CAPTVAL5
    }

    /// SM0CVAL5CYC Register bits
    namespace sm0cval5cyc_bits {
        constexpr uint32_t CVAL5CYC = (4 << 0);  ///< CVAL5CYC
    }

    /// SM1CNT Register bits
    namespace sm1cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter Register Bits
    }

    /// SM1INIT Register bits
    namespace sm1init_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Count Register Bits
    }

    /// SM1CTRL2 Register bits
    namespace sm1ctrl2_bits {
        constexpr uint32_t CLK_SEL = (2 << 0);  ///< Clock Source Select
        constexpr uint32_t RELOAD_SEL = (1U << 2);  ///< Reload Source Select
        constexpr uint32_t FORCE_SEL = (3 << 3);  ///< This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
        constexpr uint32_t FORCE = (1U << 6);  ///< Force Initialization
        constexpr uint32_t FRCEN = (1U << 7);  ///< FRCEN
        constexpr uint32_t INIT_SEL = (2 << 8);  ///< Initialization Control Select
        constexpr uint32_t PWMX_INIT = (1U << 10);  ///< PWM_X Initial Value
        constexpr uint32_t PWM45_INIT = (1U << 11);  ///< PWM45 Initial Value
        constexpr uint32_t PWM23_INIT = (1U << 12);  ///< PWM23 Initial Value
        constexpr uint32_t INDEP = (1U << 13);  ///< Independent or Complementary Pair Operation
        constexpr uint32_t WAITEN = (1U << 14);  ///< WAIT Enable
        constexpr uint32_t DBGEN = (1U << 15);  ///< Debug Enable
    }

    /// SM1CTRL Register bits
    namespace sm1ctrl_bits {
        constexpr uint32_t DBLEN = (1U << 0);  ///< Double Switching Enable
        constexpr uint32_t DBLX = (1U << 1);  ///< PWMX Double Switching Enable
        constexpr uint32_t LDMOD = (1U << 2);  ///< Load Mode Select
        constexpr uint32_t SPLIT = (1U << 3);  ///< Split the DBLPWM signal to PWMA and PWMB
        constexpr uint32_t PRSC = (3 << 4);  ///< Prescaler
        constexpr uint32_t COMPMODE = (1U << 7);  ///< Compare Mode
        constexpr uint32_t DT = (2 << 8);  ///< Deadtime
        constexpr uint32_t FULL = (1U << 10);  ///< Full Cycle Reload
        constexpr uint32_t HALF = (1U << 11);  ///< Half Cycle Reload
        constexpr uint32_t LDFQ = (4 << 12);  ///< Load Frequency
    }

    /// SM1VAL0 Register bits
    namespace sm1val0_bits {
        constexpr uint32_t VAL0 = (16 << 0);  ///< Value Register 0
    }

    /// SM1FRACVAL1 Register bits
    namespace sm1fracval1_bits {
        constexpr uint32_t FRACVAL1 = (5 << 11);  ///< Fractional Value 1 Register
    }

    /// SM1VAL1 Register bits
    namespace sm1val1_bits {
        constexpr uint32_t VAL1 = (16 << 0);  ///< Value Register 1
    }

    /// SM1FRACVAL2 Register bits
    namespace sm1fracval2_bits {
        constexpr uint32_t FRACVAL2 = (5 << 11);  ///< Fractional Value 2
    }

    /// SM1VAL2 Register bits
    namespace sm1val2_bits {
        constexpr uint32_t VAL2 = (16 << 0);  ///< Value Register 2
    }

    /// SM1FRACVAL3 Register bits
    namespace sm1fracval3_bits {
        constexpr uint32_t FRACVAL3 = (5 << 11);  ///< Fractional Value 3
    }

    /// SM1VAL3 Register bits
    namespace sm1val3_bits {
        constexpr uint32_t VAL3 = (16 << 0);  ///< Value Register 3
    }

    /// SM1FRACVAL4 Register bits
    namespace sm1fracval4_bits {
        constexpr uint32_t FRACVAL4 = (5 << 11);  ///< Fractional Value 4
    }

    /// SM1VAL4 Register bits
    namespace sm1val4_bits {
        constexpr uint32_t VAL4 = (16 << 0);  ///< Value Register 4
    }

    /// SM1FRACVAL5 Register bits
    namespace sm1fracval5_bits {
        constexpr uint32_t FRACVAL5 = (5 << 11);  ///< Fractional Value 5
    }

    /// SM1VAL5 Register bits
    namespace sm1val5_bits {
        constexpr uint32_t VAL5 = (16 << 0);  ///< Value Register 5
    }

    /// SM1FRCTRL Register bits
    namespace sm1frctrl_bits {
        constexpr uint32_t FRAC1_EN = (1U << 1);  ///< Fractional Cycle PWM Period Enable
        constexpr uint32_t FRAC23_EN = (1U << 2);  ///< Fractional Cycle Placement Enable for PWM_A
        constexpr uint32_t FRAC45_EN = (1U << 4);  ///< Fractional Cycle Placement Enable for PWM_B
        constexpr uint32_t FRAC_PU = (1U << 8);  ///< Fractional Delay Circuit Power Up
        constexpr uint32_t TEST = (1U << 15);  ///< Test Status Bit
    }

    /// SM1OCTRL Register bits
    namespace sm1octrl_bits {
        constexpr uint32_t PWMXFS = (2 << 0);  ///< PWM_X Fault State
        constexpr uint32_t PWMBFS = (2 << 2);  ///< PWM_B Fault State
        constexpr uint32_t PWMAFS = (2 << 4);  ///< PWM_A Fault State
        constexpr uint32_t POLX = (1U << 8);  ///< PWM_X Output Polarity
        constexpr uint32_t POLB = (1U << 9);  ///< PWM_B Output Polarity
        constexpr uint32_t POLA = (1U << 10);  ///< PWM_A Output Polarity
        constexpr uint32_t PWMX_IN = (1U << 13);  ///< PWM_X Input
        constexpr uint32_t PWMB_IN = (1U << 14);  ///< PWM_B Input
        constexpr uint32_t PWMA_IN = (1U << 15);  ///< PWM_A Input
    }

    /// SM1STS Register bits
    namespace sm1sts_bits {
        constexpr uint32_t CMPF = (6 << 0);  ///< Compare Flags
        constexpr uint32_t CFX0 = (1U << 6);  ///< Capture Flag X0
        constexpr uint32_t CFX1 = (1U << 7);  ///< Capture Flag X1
        constexpr uint32_t CFB0 = (1U << 8);  ///< Capture Flag B0
        constexpr uint32_t CFB1 = (1U << 9);  ///< Capture Flag B1
        constexpr uint32_t CFA0 = (1U << 10);  ///< Capture Flag A0
        constexpr uint32_t CFA1 = (1U << 11);  ///< Capture Flag A1
        constexpr uint32_t RF = (1U << 12);  ///< Reload Flag
        constexpr uint32_t REF = (1U << 13);  ///< Reload Error Flag
        constexpr uint32_t RUF = (1U << 14);  ///< Registers Updated Flag
    }

    /// SM1INTEN Register bits
    namespace sm1inten_bits {
        constexpr uint32_t CMPIE = (6 << 0);  ///< Compare Interrupt Enables
        constexpr uint32_t CX0IE = (1U << 6);  ///< Capture X 0 Interrupt Enable
        constexpr uint32_t CX1IE = (1U << 7);  ///< Capture X 1 Interrupt Enable
        constexpr uint32_t CB0IE = (1U << 8);  ///< Capture B 0 Interrupt Enable
        constexpr uint32_t CB1IE = (1U << 9);  ///< Capture B 1 Interrupt Enable
        constexpr uint32_t CA0IE = (1U << 10);  ///< Capture A 0 Interrupt Enable
        constexpr uint32_t CA1IE = (1U << 11);  ///< Capture A 1 Interrupt Enable
        constexpr uint32_t RIE = (1U << 12);  ///< Reload Interrupt Enable
        constexpr uint32_t REIE = (1U << 13);  ///< Reload Error Interrupt Enable
    }

    /// SM1DMAEN Register bits
    namespace sm1dmaen_bits {
        constexpr uint32_t CX0DE = (1U << 0);  ///< Capture X0 FIFO DMA Enable
        constexpr uint32_t CX1DE = (1U << 1);  ///< Capture X1 FIFO DMA Enable
        constexpr uint32_t CB0DE = (1U << 2);  ///< Capture B0 FIFO DMA Enable
        constexpr uint32_t CB1DE = (1U << 3);  ///< Capture B1 FIFO DMA Enable
        constexpr uint32_t CA0DE = (1U << 4);  ///< Capture A0 FIFO DMA Enable
        constexpr uint32_t CA1DE = (1U << 5);  ///< Capture A1 FIFO DMA Enable
        constexpr uint32_t CAPTDE = (2 << 6);  ///< Capture DMA Enable Source Select
        constexpr uint32_t FAND = (1U << 8);  ///< FIFO Watermark AND Control
        constexpr uint32_t VALDE = (1U << 9);  ///< Value Registers DMA Enable
    }

    /// SM1TCTRL Register bits
    namespace sm1tctrl_bits {
        constexpr uint32_t OUT_TRIG_EN = (6 << 0);  ///< Output Trigger Enables
        constexpr uint32_t TRGFRQ = (1U << 12);  ///< Trigger frequency
        constexpr uint32_t PWBOT1 = (1U << 14);  ///< Output Trigger 1 Source Select
        constexpr uint32_t PWAOT0 = (1U << 15);  ///< Output Trigger 0 Source Select
    }

    /// SM1DISMAP0 Register bits
    namespace sm1dismap0_bits {
        constexpr uint32_t DIS0A = (4 << 0);  ///< PWM_A Fault Disable Mask 0
        constexpr uint32_t DIS0B = (4 << 4);  ///< PWM_B Fault Disable Mask 0
        constexpr uint32_t DIS0X = (4 << 8);  ///< PWM_X Fault Disable Mask 0
    }

    /// SM1DISMAP1 Register bits
    namespace sm1dismap1_bits {
        constexpr uint32_t DIS1A = (4 << 0);  ///< PWM_A Fault Disable Mask 1
        constexpr uint32_t DIS1B = (4 << 4);  ///< PWM_B Fault Disable Mask 1
        constexpr uint32_t DIS1X = (4 << 8);  ///< PWM_X Fault Disable Mask 1
    }

    /// SM1DTCNT0 Register bits
    namespace sm1dtcnt0_bits {
        constexpr uint32_t DTCNT0 = (16 << 0);  ///< DTCNT0
    }

    /// SM1DTCNT1 Register bits
    namespace sm1dtcnt1_bits {
        constexpr uint32_t DTCNT1 = (16 << 0);  ///< DTCNT1
    }

    /// SM1CAPTCTRLA Register bits
    namespace sm1captctrla_bits {
        constexpr uint32_t ARMA = (1U << 0);  ///< Arm A
        constexpr uint32_t ONESHOTA = (1U << 1);  ///< One Shot Mode A
        constexpr uint32_t EDGA0 = (2 << 2);  ///< Edge A 0
        constexpr uint32_t EDGA1 = (2 << 4);  ///< Edge A 1
        constexpr uint32_t INP_SELA = (1U << 6);  ///< Input Select A
        constexpr uint32_t EDGCNTA_EN = (1U << 7);  ///< Edge Counter A Enable
        constexpr uint32_t CFAWM = (2 << 8);  ///< Capture A FIFOs Water Mark
        constexpr uint32_t CA0CNT = (3 << 10);  ///< Capture A0 FIFO Word Count
        constexpr uint32_t CA1CNT = (3 << 13);  ///< Capture A1 FIFO Word Count
    }

    /// SM1CAPTCOMPA Register bits
    namespace sm1captcompa_bits {
        constexpr uint32_t EDGCMPA = (8 << 0);  ///< Edge Compare A
        constexpr uint32_t EDGCNTA = (8 << 8);  ///< Edge Counter A
    }

    /// SM1CAPTCTRLB Register bits
    namespace sm1captctrlb_bits {
        constexpr uint32_t ARMB = (1U << 0);  ///< Arm B
        constexpr uint32_t ONESHOTB = (1U << 1);  ///< One Shot Mode B
        constexpr uint32_t EDGB0 = (2 << 2);  ///< Edge B 0
        constexpr uint32_t EDGB1 = (2 << 4);  ///< Edge B 1
        constexpr uint32_t INP_SELB = (1U << 6);  ///< Input Select B
        constexpr uint32_t EDGCNTB_EN = (1U << 7);  ///< Edge Counter B Enable
        constexpr uint32_t CFBWM = (2 << 8);  ///< Capture B FIFOs Water Mark
        constexpr uint32_t CB0CNT = (3 << 10);  ///< Capture B0 FIFO Word Count
        constexpr uint32_t CB1CNT = (3 << 13);  ///< Capture B1 FIFO Word Count
    }

    /// SM1CAPTCOMPB Register bits
    namespace sm1captcompb_bits {
        constexpr uint32_t EDGCMPB = (8 << 0);  ///< Edge Compare B
        constexpr uint32_t EDGCNTB = (8 << 8);  ///< Edge Counter B
    }

    /// SM1CAPTCTRLX Register bits
    namespace sm1captctrlx_bits {
        constexpr uint32_t ARMX = (1U << 0);  ///< Arm X
        constexpr uint32_t ONESHOTX = (1U << 1);  ///< One Shot Mode Aux
        constexpr uint32_t EDGX0 = (2 << 2);  ///< Edge X 0
        constexpr uint32_t EDGX1 = (2 << 4);  ///< Edge X 1
        constexpr uint32_t INP_SELX = (1U << 6);  ///< Input Select X
        constexpr uint32_t EDGCNTX_EN = (1U << 7);  ///< Edge Counter X Enable
        constexpr uint32_t CFXWM = (2 << 8);  ///< Capture X FIFOs Water Mark
        constexpr uint32_t CX0CNT = (3 << 10);  ///< Capture X0 FIFO Word Count
        constexpr uint32_t CX1CNT = (3 << 13);  ///< Capture X1 FIFO Word Count
    }

    /// SM1CAPTCOMPX Register bits
    namespace sm1captcompx_bits {
        constexpr uint32_t EDGCMPX = (8 << 0);  ///< Edge Compare X
        constexpr uint32_t EDGCNTX = (8 << 8);  ///< Edge Counter X
    }

    /// SM1CVAL0 Register bits
    namespace sm1cval0_bits {
        constexpr uint32_t CAPTVAL0 = (16 << 0);  ///< CAPTVAL0
    }

    /// SM1CVAL0CYC Register bits
    namespace sm1cval0cyc_bits {
        constexpr uint32_t CVAL0CYC = (4 << 0);  ///< CVAL0CYC
    }

    /// SM1CVAL1 Register bits
    namespace sm1cval1_bits {
        constexpr uint32_t CAPTVAL1 = (16 << 0);  ///< CAPTVAL1
    }

    /// SM1CVAL1CYC Register bits
    namespace sm1cval1cyc_bits {
        constexpr uint32_t CVAL1CYC = (4 << 0);  ///< CVAL1CYC
    }

    /// SM1CVAL2 Register bits
    namespace sm1cval2_bits {
        constexpr uint32_t CAPTVAL2 = (16 << 0);  ///< CAPTVAL2
    }

    /// SM1CVAL2CYC Register bits
    namespace sm1cval2cyc_bits {
        constexpr uint32_t CVAL2CYC = (4 << 0);  ///< CVAL2CYC
    }

    /// SM1CVAL3 Register bits
    namespace sm1cval3_bits {
        constexpr uint32_t CAPTVAL3 = (16 << 0);  ///< CAPTVAL3
    }

    /// SM1CVAL3CYC Register bits
    namespace sm1cval3cyc_bits {
        constexpr uint32_t CVAL3CYC = (4 << 0);  ///< CVAL3CYC
    }

    /// SM1CVAL4 Register bits
    namespace sm1cval4_bits {
        constexpr uint32_t CAPTVAL4 = (16 << 0);  ///< CAPTVAL4
    }

    /// SM1CVAL4CYC Register bits
    namespace sm1cval4cyc_bits {
        constexpr uint32_t CVAL4CYC = (4 << 0);  ///< CVAL4CYC
    }

    /// SM1CVAL5 Register bits
    namespace sm1cval5_bits {
        constexpr uint32_t CAPTVAL5 = (16 << 0);  ///< CAPTVAL5
    }

    /// SM1CVAL5CYC Register bits
    namespace sm1cval5cyc_bits {
        constexpr uint32_t CVAL5CYC = (4 << 0);  ///< CVAL5CYC
    }

    /// SM2CNT Register bits
    namespace sm2cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter Register Bits
    }

    /// SM2INIT Register bits
    namespace sm2init_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Count Register Bits
    }

    /// SM2CTRL2 Register bits
    namespace sm2ctrl2_bits {
        constexpr uint32_t CLK_SEL = (2 << 0);  ///< Clock Source Select
        constexpr uint32_t RELOAD_SEL = (1U << 2);  ///< Reload Source Select
        constexpr uint32_t FORCE_SEL = (3 << 3);  ///< This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
        constexpr uint32_t FORCE = (1U << 6);  ///< Force Initialization
        constexpr uint32_t FRCEN = (1U << 7);  ///< FRCEN
        constexpr uint32_t INIT_SEL = (2 << 8);  ///< Initialization Control Select
        constexpr uint32_t PWMX_INIT = (1U << 10);  ///< PWM_X Initial Value
        constexpr uint32_t PWM45_INIT = (1U << 11);  ///< PWM45 Initial Value
        constexpr uint32_t PWM23_INIT = (1U << 12);  ///< PWM23 Initial Value
        constexpr uint32_t INDEP = (1U << 13);  ///< Independent or Complementary Pair Operation
        constexpr uint32_t WAITEN = (1U << 14);  ///< WAIT Enable
        constexpr uint32_t DBGEN = (1U << 15);  ///< Debug Enable
    }

    /// SM2CTRL Register bits
    namespace sm2ctrl_bits {
        constexpr uint32_t DBLEN = (1U << 0);  ///< Double Switching Enable
        constexpr uint32_t DBLX = (1U << 1);  ///< PWMX Double Switching Enable
        constexpr uint32_t LDMOD = (1U << 2);  ///< Load Mode Select
        constexpr uint32_t SPLIT = (1U << 3);  ///< Split the DBLPWM signal to PWMA and PWMB
        constexpr uint32_t PRSC = (3 << 4);  ///< Prescaler
        constexpr uint32_t COMPMODE = (1U << 7);  ///< Compare Mode
        constexpr uint32_t DT = (2 << 8);  ///< Deadtime
        constexpr uint32_t FULL = (1U << 10);  ///< Full Cycle Reload
        constexpr uint32_t HALF = (1U << 11);  ///< Half Cycle Reload
        constexpr uint32_t LDFQ = (4 << 12);  ///< Load Frequency
    }

    /// SM2VAL0 Register bits
    namespace sm2val0_bits {
        constexpr uint32_t VAL0 = (16 << 0);  ///< Value Register 0
    }

    /// SM2FRACVAL1 Register bits
    namespace sm2fracval1_bits {
        constexpr uint32_t FRACVAL1 = (5 << 11);  ///< Fractional Value 1 Register
    }

    /// SM2VAL1 Register bits
    namespace sm2val1_bits {
        constexpr uint32_t VAL1 = (16 << 0);  ///< Value Register 1
    }

    /// SM2FRACVAL2 Register bits
    namespace sm2fracval2_bits {
        constexpr uint32_t FRACVAL2 = (5 << 11);  ///< Fractional Value 2
    }

    /// SM2VAL2 Register bits
    namespace sm2val2_bits {
        constexpr uint32_t VAL2 = (16 << 0);  ///< Value Register 2
    }

    /// SM2FRACVAL3 Register bits
    namespace sm2fracval3_bits {
        constexpr uint32_t FRACVAL3 = (5 << 11);  ///< Fractional Value 3
    }

    /// SM2VAL3 Register bits
    namespace sm2val3_bits {
        constexpr uint32_t VAL3 = (16 << 0);  ///< Value Register 3
    }

    /// SM2FRACVAL4 Register bits
    namespace sm2fracval4_bits {
        constexpr uint32_t FRACVAL4 = (5 << 11);  ///< Fractional Value 4
    }

    /// SM2VAL4 Register bits
    namespace sm2val4_bits {
        constexpr uint32_t VAL4 = (16 << 0);  ///< Value Register 4
    }

    /// SM2FRACVAL5 Register bits
    namespace sm2fracval5_bits {
        constexpr uint32_t FRACVAL5 = (5 << 11);  ///< Fractional Value 5
    }

    /// SM2VAL5 Register bits
    namespace sm2val5_bits {
        constexpr uint32_t VAL5 = (16 << 0);  ///< Value Register 5
    }

    /// SM2FRCTRL Register bits
    namespace sm2frctrl_bits {
        constexpr uint32_t FRAC1_EN = (1U << 1);  ///< Fractional Cycle PWM Period Enable
        constexpr uint32_t FRAC23_EN = (1U << 2);  ///< Fractional Cycle Placement Enable for PWM_A
        constexpr uint32_t FRAC45_EN = (1U << 4);  ///< Fractional Cycle Placement Enable for PWM_B
        constexpr uint32_t FRAC_PU = (1U << 8);  ///< Fractional Delay Circuit Power Up
        constexpr uint32_t TEST = (1U << 15);  ///< Test Status Bit
    }

    /// SM2OCTRL Register bits
    namespace sm2octrl_bits {
        constexpr uint32_t PWMXFS = (2 << 0);  ///< PWM_X Fault State
        constexpr uint32_t PWMBFS = (2 << 2);  ///< PWM_B Fault State
        constexpr uint32_t PWMAFS = (2 << 4);  ///< PWM_A Fault State
        constexpr uint32_t POLX = (1U << 8);  ///< PWM_X Output Polarity
        constexpr uint32_t POLB = (1U << 9);  ///< PWM_B Output Polarity
        constexpr uint32_t POLA = (1U << 10);  ///< PWM_A Output Polarity
        constexpr uint32_t PWMX_IN = (1U << 13);  ///< PWM_X Input
        constexpr uint32_t PWMB_IN = (1U << 14);  ///< PWM_B Input
        constexpr uint32_t PWMA_IN = (1U << 15);  ///< PWM_A Input
    }

    /// SM2STS Register bits
    namespace sm2sts_bits {
        constexpr uint32_t CMPF = (6 << 0);  ///< Compare Flags
        constexpr uint32_t CFX0 = (1U << 6);  ///< Capture Flag X0
        constexpr uint32_t CFX1 = (1U << 7);  ///< Capture Flag X1
        constexpr uint32_t CFB0 = (1U << 8);  ///< Capture Flag B0
        constexpr uint32_t CFB1 = (1U << 9);  ///< Capture Flag B1
        constexpr uint32_t CFA0 = (1U << 10);  ///< Capture Flag A0
        constexpr uint32_t CFA1 = (1U << 11);  ///< Capture Flag A1
        constexpr uint32_t RF = (1U << 12);  ///< Reload Flag
        constexpr uint32_t REF = (1U << 13);  ///< Reload Error Flag
        constexpr uint32_t RUF = (1U << 14);  ///< Registers Updated Flag
    }

    /// SM2INTEN Register bits
    namespace sm2inten_bits {
        constexpr uint32_t CMPIE = (6 << 0);  ///< Compare Interrupt Enables
        constexpr uint32_t CX0IE = (1U << 6);  ///< Capture X 0 Interrupt Enable
        constexpr uint32_t CX1IE = (1U << 7);  ///< Capture X 1 Interrupt Enable
        constexpr uint32_t CB0IE = (1U << 8);  ///< Capture B 0 Interrupt Enable
        constexpr uint32_t CB1IE = (1U << 9);  ///< Capture B 1 Interrupt Enable
        constexpr uint32_t CA0IE = (1U << 10);  ///< Capture A 0 Interrupt Enable
        constexpr uint32_t CA1IE = (1U << 11);  ///< Capture A 1 Interrupt Enable
        constexpr uint32_t RIE = (1U << 12);  ///< Reload Interrupt Enable
        constexpr uint32_t REIE = (1U << 13);  ///< Reload Error Interrupt Enable
    }

    /// SM2DMAEN Register bits
    namespace sm2dmaen_bits {
        constexpr uint32_t CX0DE = (1U << 0);  ///< Capture X0 FIFO DMA Enable
        constexpr uint32_t CX1DE = (1U << 1);  ///< Capture X1 FIFO DMA Enable
        constexpr uint32_t CB0DE = (1U << 2);  ///< Capture B0 FIFO DMA Enable
        constexpr uint32_t CB1DE = (1U << 3);  ///< Capture B1 FIFO DMA Enable
        constexpr uint32_t CA0DE = (1U << 4);  ///< Capture A0 FIFO DMA Enable
        constexpr uint32_t CA1DE = (1U << 5);  ///< Capture A1 FIFO DMA Enable
        constexpr uint32_t CAPTDE = (2 << 6);  ///< Capture DMA Enable Source Select
        constexpr uint32_t FAND = (1U << 8);  ///< FIFO Watermark AND Control
        constexpr uint32_t VALDE = (1U << 9);  ///< Value Registers DMA Enable
    }

    /// SM2TCTRL Register bits
    namespace sm2tctrl_bits {
        constexpr uint32_t OUT_TRIG_EN = (6 << 0);  ///< Output Trigger Enables
        constexpr uint32_t TRGFRQ = (1U << 12);  ///< Trigger frequency
        constexpr uint32_t PWBOT1 = (1U << 14);  ///< Output Trigger 1 Source Select
        constexpr uint32_t PWAOT0 = (1U << 15);  ///< Output Trigger 0 Source Select
    }

    /// SM2DISMAP0 Register bits
    namespace sm2dismap0_bits {
        constexpr uint32_t DIS0A = (4 << 0);  ///< PWM_A Fault Disable Mask 0
        constexpr uint32_t DIS0B = (4 << 4);  ///< PWM_B Fault Disable Mask 0
        constexpr uint32_t DIS0X = (4 << 8);  ///< PWM_X Fault Disable Mask 0
    }

    /// SM2DISMAP1 Register bits
    namespace sm2dismap1_bits {
        constexpr uint32_t DIS1A = (4 << 0);  ///< PWM_A Fault Disable Mask 1
        constexpr uint32_t DIS1B = (4 << 4);  ///< PWM_B Fault Disable Mask 1
        constexpr uint32_t DIS1X = (4 << 8);  ///< PWM_X Fault Disable Mask 1
    }

    /// SM2DTCNT0 Register bits
    namespace sm2dtcnt0_bits {
        constexpr uint32_t DTCNT0 = (16 << 0);  ///< DTCNT0
    }

    /// SM2DTCNT1 Register bits
    namespace sm2dtcnt1_bits {
        constexpr uint32_t DTCNT1 = (16 << 0);  ///< DTCNT1
    }

    /// SM2CAPTCTRLA Register bits
    namespace sm2captctrla_bits {
        constexpr uint32_t ARMA = (1U << 0);  ///< Arm A
        constexpr uint32_t ONESHOTA = (1U << 1);  ///< One Shot Mode A
        constexpr uint32_t EDGA0 = (2 << 2);  ///< Edge A 0
        constexpr uint32_t EDGA1 = (2 << 4);  ///< Edge A 1
        constexpr uint32_t INP_SELA = (1U << 6);  ///< Input Select A
        constexpr uint32_t EDGCNTA_EN = (1U << 7);  ///< Edge Counter A Enable
        constexpr uint32_t CFAWM = (2 << 8);  ///< Capture A FIFOs Water Mark
        constexpr uint32_t CA0CNT = (3 << 10);  ///< Capture A0 FIFO Word Count
        constexpr uint32_t CA1CNT = (3 << 13);  ///< Capture A1 FIFO Word Count
    }

    /// SM2CAPTCOMPA Register bits
    namespace sm2captcompa_bits {
        constexpr uint32_t EDGCMPA = (8 << 0);  ///< Edge Compare A
        constexpr uint32_t EDGCNTA = (8 << 8);  ///< Edge Counter A
    }

    /// SM2CAPTCTRLB Register bits
    namespace sm2captctrlb_bits {
        constexpr uint32_t ARMB = (1U << 0);  ///< Arm B
        constexpr uint32_t ONESHOTB = (1U << 1);  ///< One Shot Mode B
        constexpr uint32_t EDGB0 = (2 << 2);  ///< Edge B 0
        constexpr uint32_t EDGB1 = (2 << 4);  ///< Edge B 1
        constexpr uint32_t INP_SELB = (1U << 6);  ///< Input Select B
        constexpr uint32_t EDGCNTB_EN = (1U << 7);  ///< Edge Counter B Enable
        constexpr uint32_t CFBWM = (2 << 8);  ///< Capture B FIFOs Water Mark
        constexpr uint32_t CB0CNT = (3 << 10);  ///< Capture B0 FIFO Word Count
        constexpr uint32_t CB1CNT = (3 << 13);  ///< Capture B1 FIFO Word Count
    }

    /// SM2CAPTCOMPB Register bits
    namespace sm2captcompb_bits {
        constexpr uint32_t EDGCMPB = (8 << 0);  ///< Edge Compare B
        constexpr uint32_t EDGCNTB = (8 << 8);  ///< Edge Counter B
    }

    /// SM2CAPTCTRLX Register bits
    namespace sm2captctrlx_bits {
        constexpr uint32_t ARMX = (1U << 0);  ///< Arm X
        constexpr uint32_t ONESHOTX = (1U << 1);  ///< One Shot Mode Aux
        constexpr uint32_t EDGX0 = (2 << 2);  ///< Edge X 0
        constexpr uint32_t EDGX1 = (2 << 4);  ///< Edge X 1
        constexpr uint32_t INP_SELX = (1U << 6);  ///< Input Select X
        constexpr uint32_t EDGCNTX_EN = (1U << 7);  ///< Edge Counter X Enable
        constexpr uint32_t CFXWM = (2 << 8);  ///< Capture X FIFOs Water Mark
        constexpr uint32_t CX0CNT = (3 << 10);  ///< Capture X0 FIFO Word Count
        constexpr uint32_t CX1CNT = (3 << 13);  ///< Capture X1 FIFO Word Count
    }

    /// SM2CAPTCOMPX Register bits
    namespace sm2captcompx_bits {
        constexpr uint32_t EDGCMPX = (8 << 0);  ///< Edge Compare X
        constexpr uint32_t EDGCNTX = (8 << 8);  ///< Edge Counter X
    }

    /// SM2CVAL0 Register bits
    namespace sm2cval0_bits {
        constexpr uint32_t CAPTVAL0 = (16 << 0);  ///< CAPTVAL0
    }

    /// SM2CVAL0CYC Register bits
    namespace sm2cval0cyc_bits {
        constexpr uint32_t CVAL0CYC = (4 << 0);  ///< CVAL0CYC
    }

    /// SM2CVAL1 Register bits
    namespace sm2cval1_bits {
        constexpr uint32_t CAPTVAL1 = (16 << 0);  ///< CAPTVAL1
    }

    /// SM2CVAL1CYC Register bits
    namespace sm2cval1cyc_bits {
        constexpr uint32_t CVAL1CYC = (4 << 0);  ///< CVAL1CYC
    }

    /// SM2CVAL2 Register bits
    namespace sm2cval2_bits {
        constexpr uint32_t CAPTVAL2 = (16 << 0);  ///< CAPTVAL2
    }

    /// SM2CVAL2CYC Register bits
    namespace sm2cval2cyc_bits {
        constexpr uint32_t CVAL2CYC = (4 << 0);  ///< CVAL2CYC
    }

    /// SM2CVAL3 Register bits
    namespace sm2cval3_bits {
        constexpr uint32_t CAPTVAL3 = (16 << 0);  ///< CAPTVAL3
    }

    /// SM2CVAL3CYC Register bits
    namespace sm2cval3cyc_bits {
        constexpr uint32_t CVAL3CYC = (4 << 0);  ///< CVAL3CYC
    }

    /// SM2CVAL4 Register bits
    namespace sm2cval4_bits {
        constexpr uint32_t CAPTVAL4 = (16 << 0);  ///< CAPTVAL4
    }

    /// SM2CVAL4CYC Register bits
    namespace sm2cval4cyc_bits {
        constexpr uint32_t CVAL4CYC = (4 << 0);  ///< CVAL4CYC
    }

    /// SM2CVAL5 Register bits
    namespace sm2cval5_bits {
        constexpr uint32_t CAPTVAL5 = (16 << 0);  ///< CAPTVAL5
    }

    /// SM2CVAL5CYC Register bits
    namespace sm2cval5cyc_bits {
        constexpr uint32_t CVAL5CYC = (4 << 0);  ///< CVAL5CYC
    }

    /// SM3CNT Register bits
    namespace sm3cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter Register Bits
    }

    /// SM3INIT Register bits
    namespace sm3init_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Count Register Bits
    }

    /// SM3CTRL2 Register bits
    namespace sm3ctrl2_bits {
        constexpr uint32_t CLK_SEL = (2 << 0);  ///< Clock Source Select
        constexpr uint32_t RELOAD_SEL = (1U << 2);  ///< Reload Source Select
        constexpr uint32_t FORCE_SEL = (3 << 3);  ///< This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
        constexpr uint32_t FORCE = (1U << 6);  ///< Force Initialization
        constexpr uint32_t FRCEN = (1U << 7);  ///< FRCEN
        constexpr uint32_t INIT_SEL = (2 << 8);  ///< Initialization Control Select
        constexpr uint32_t PWMX_INIT = (1U << 10);  ///< PWM_X Initial Value
        constexpr uint32_t PWM45_INIT = (1U << 11);  ///< PWM45 Initial Value
        constexpr uint32_t PWM23_INIT = (1U << 12);  ///< PWM23 Initial Value
        constexpr uint32_t INDEP = (1U << 13);  ///< Independent or Complementary Pair Operation
        constexpr uint32_t WAITEN = (1U << 14);  ///< WAIT Enable
        constexpr uint32_t DBGEN = (1U << 15);  ///< Debug Enable
    }

    /// SM3CTRL Register bits
    namespace sm3ctrl_bits {
        constexpr uint32_t DBLEN = (1U << 0);  ///< Double Switching Enable
        constexpr uint32_t DBLX = (1U << 1);  ///< PWMX Double Switching Enable
        constexpr uint32_t LDMOD = (1U << 2);  ///< Load Mode Select
        constexpr uint32_t SPLIT = (1U << 3);  ///< Split the DBLPWM signal to PWMA and PWMB
        constexpr uint32_t PRSC = (3 << 4);  ///< Prescaler
        constexpr uint32_t COMPMODE = (1U << 7);  ///< Compare Mode
        constexpr uint32_t DT = (2 << 8);  ///< Deadtime
        constexpr uint32_t FULL = (1U << 10);  ///< Full Cycle Reload
        constexpr uint32_t HALF = (1U << 11);  ///< Half Cycle Reload
        constexpr uint32_t LDFQ = (4 << 12);  ///< Load Frequency
    }

    /// SM3VAL0 Register bits
    namespace sm3val0_bits {
        constexpr uint32_t VAL0 = (16 << 0);  ///< Value Register 0
    }

    /// SM3FRACVAL1 Register bits
    namespace sm3fracval1_bits {
        constexpr uint32_t FRACVAL1 = (5 << 11);  ///< Fractional Value 1 Register
    }

    /// SM3VAL1 Register bits
    namespace sm3val1_bits {
        constexpr uint32_t VAL1 = (16 << 0);  ///< Value Register 1
    }

    /// SM3FRACVAL2 Register bits
    namespace sm3fracval2_bits {
        constexpr uint32_t FRACVAL2 = (5 << 11);  ///< Fractional Value 2
    }

    /// SM3VAL2 Register bits
    namespace sm3val2_bits {
        constexpr uint32_t VAL2 = (16 << 0);  ///< Value Register 2
    }

    /// SM3FRACVAL3 Register bits
    namespace sm3fracval3_bits {
        constexpr uint32_t FRACVAL3 = (5 << 11);  ///< Fractional Value 3
    }

    /// SM3VAL3 Register bits
    namespace sm3val3_bits {
        constexpr uint32_t VAL3 = (16 << 0);  ///< Value Register 3
    }

    /// SM3FRACVAL4 Register bits
    namespace sm3fracval4_bits {
        constexpr uint32_t FRACVAL4 = (5 << 11);  ///< Fractional Value 4
    }

    /// SM3VAL4 Register bits
    namespace sm3val4_bits {
        constexpr uint32_t VAL4 = (16 << 0);  ///< Value Register 4
    }

    /// SM3FRACVAL5 Register bits
    namespace sm3fracval5_bits {
        constexpr uint32_t FRACVAL5 = (5 << 11);  ///< Fractional Value 5
    }

    /// SM3VAL5 Register bits
    namespace sm3val5_bits {
        constexpr uint32_t VAL5 = (16 << 0);  ///< Value Register 5
    }

    /// SM3FRCTRL Register bits
    namespace sm3frctrl_bits {
        constexpr uint32_t FRAC1_EN = (1U << 1);  ///< Fractional Cycle PWM Period Enable
        constexpr uint32_t FRAC23_EN = (1U << 2);  ///< Fractional Cycle Placement Enable for PWM_A
        constexpr uint32_t FRAC45_EN = (1U << 4);  ///< Fractional Cycle Placement Enable for PWM_B
        constexpr uint32_t FRAC_PU = (1U << 8);  ///< Fractional Delay Circuit Power Up
        constexpr uint32_t TEST = (1U << 15);  ///< Test Status Bit
    }

    /// SM3OCTRL Register bits
    namespace sm3octrl_bits {
        constexpr uint32_t PWMXFS = (2 << 0);  ///< PWM_X Fault State
        constexpr uint32_t PWMBFS = (2 << 2);  ///< PWM_B Fault State
        constexpr uint32_t PWMAFS = (2 << 4);  ///< PWM_A Fault State
        constexpr uint32_t POLX = (1U << 8);  ///< PWM_X Output Polarity
        constexpr uint32_t POLB = (1U << 9);  ///< PWM_B Output Polarity
        constexpr uint32_t POLA = (1U << 10);  ///< PWM_A Output Polarity
        constexpr uint32_t PWMX_IN = (1U << 13);  ///< PWM_X Input
        constexpr uint32_t PWMB_IN = (1U << 14);  ///< PWM_B Input
        constexpr uint32_t PWMA_IN = (1U << 15);  ///< PWM_A Input
    }

    /// SM3STS Register bits
    namespace sm3sts_bits {
        constexpr uint32_t CMPF = (6 << 0);  ///< Compare Flags
        constexpr uint32_t CFX0 = (1U << 6);  ///< Capture Flag X0
        constexpr uint32_t CFX1 = (1U << 7);  ///< Capture Flag X1
        constexpr uint32_t CFB0 = (1U << 8);  ///< Capture Flag B0
        constexpr uint32_t CFB1 = (1U << 9);  ///< Capture Flag B1
        constexpr uint32_t CFA0 = (1U << 10);  ///< Capture Flag A0
        constexpr uint32_t CFA1 = (1U << 11);  ///< Capture Flag A1
        constexpr uint32_t RF = (1U << 12);  ///< Reload Flag
        constexpr uint32_t REF = (1U << 13);  ///< Reload Error Flag
        constexpr uint32_t RUF = (1U << 14);  ///< Registers Updated Flag
    }

    /// SM3INTEN Register bits
    namespace sm3inten_bits {
        constexpr uint32_t CMPIE = (6 << 0);  ///< Compare Interrupt Enables
        constexpr uint32_t CX0IE = (1U << 6);  ///< Capture X 0 Interrupt Enable
        constexpr uint32_t CX1IE = (1U << 7);  ///< Capture X 1 Interrupt Enable
        constexpr uint32_t CB0IE = (1U << 8);  ///< Capture B 0 Interrupt Enable
        constexpr uint32_t CB1IE = (1U << 9);  ///< Capture B 1 Interrupt Enable
        constexpr uint32_t CA0IE = (1U << 10);  ///< Capture A 0 Interrupt Enable
        constexpr uint32_t CA1IE = (1U << 11);  ///< Capture A 1 Interrupt Enable
        constexpr uint32_t RIE = (1U << 12);  ///< Reload Interrupt Enable
        constexpr uint32_t REIE = (1U << 13);  ///< Reload Error Interrupt Enable
    }

    /// SM3DMAEN Register bits
    namespace sm3dmaen_bits {
        constexpr uint32_t CX0DE = (1U << 0);  ///< Capture X0 FIFO DMA Enable
        constexpr uint32_t CX1DE = (1U << 1);  ///< Capture X1 FIFO DMA Enable
        constexpr uint32_t CB0DE = (1U << 2);  ///< Capture B0 FIFO DMA Enable
        constexpr uint32_t CB1DE = (1U << 3);  ///< Capture B1 FIFO DMA Enable
        constexpr uint32_t CA0DE = (1U << 4);  ///< Capture A0 FIFO DMA Enable
        constexpr uint32_t CA1DE = (1U << 5);  ///< Capture A1 FIFO DMA Enable
        constexpr uint32_t CAPTDE = (2 << 6);  ///< Capture DMA Enable Source Select
        constexpr uint32_t FAND = (1U << 8);  ///< FIFO Watermark AND Control
        constexpr uint32_t VALDE = (1U << 9);  ///< Value Registers DMA Enable
    }

    /// SM3TCTRL Register bits
    namespace sm3tctrl_bits {
        constexpr uint32_t OUT_TRIG_EN = (6 << 0);  ///< Output Trigger Enables
        constexpr uint32_t TRGFRQ = (1U << 12);  ///< Trigger frequency
        constexpr uint32_t PWBOT1 = (1U << 14);  ///< Output Trigger 1 Source Select
        constexpr uint32_t PWAOT0 = (1U << 15);  ///< Output Trigger 0 Source Select
    }

    /// SM3DISMAP0 Register bits
    namespace sm3dismap0_bits {
        constexpr uint32_t DIS0A = (4 << 0);  ///< PWM_A Fault Disable Mask 0
        constexpr uint32_t DIS0B = (4 << 4);  ///< PWM_B Fault Disable Mask 0
        constexpr uint32_t DIS0X = (4 << 8);  ///< PWM_X Fault Disable Mask 0
    }

    /// SM3DISMAP1 Register bits
    namespace sm3dismap1_bits {
        constexpr uint32_t DIS1A = (4 << 0);  ///< PWM_A Fault Disable Mask 1
        constexpr uint32_t DIS1B = (4 << 4);  ///< PWM_B Fault Disable Mask 1
        constexpr uint32_t DIS1X = (4 << 8);  ///< PWM_X Fault Disable Mask 1
    }

    /// SM3DTCNT0 Register bits
    namespace sm3dtcnt0_bits {
        constexpr uint32_t DTCNT0 = (16 << 0);  ///< DTCNT0
    }

    /// SM3DTCNT1 Register bits
    namespace sm3dtcnt1_bits {
        constexpr uint32_t DTCNT1 = (16 << 0);  ///< DTCNT1
    }

    /// SM3CAPTCTRLA Register bits
    namespace sm3captctrla_bits {
        constexpr uint32_t ARMA = (1U << 0);  ///< Arm A
        constexpr uint32_t ONESHOTA = (1U << 1);  ///< One Shot Mode A
        constexpr uint32_t EDGA0 = (2 << 2);  ///< Edge A 0
        constexpr uint32_t EDGA1 = (2 << 4);  ///< Edge A 1
        constexpr uint32_t INP_SELA = (1U << 6);  ///< Input Select A
        constexpr uint32_t EDGCNTA_EN = (1U << 7);  ///< Edge Counter A Enable
        constexpr uint32_t CFAWM = (2 << 8);  ///< Capture A FIFOs Water Mark
        constexpr uint32_t CA0CNT = (3 << 10);  ///< Capture A0 FIFO Word Count
        constexpr uint32_t CA1CNT = (3 << 13);  ///< Capture A1 FIFO Word Count
    }

    /// SM3CAPTCOMPA Register bits
    namespace sm3captcompa_bits {
        constexpr uint32_t EDGCMPA = (8 << 0);  ///< Edge Compare A
        constexpr uint32_t EDGCNTA = (8 << 8);  ///< Edge Counter A
    }

    /// SM3CAPTCTRLB Register bits
    namespace sm3captctrlb_bits {
        constexpr uint32_t ARMB = (1U << 0);  ///< Arm B
        constexpr uint32_t ONESHOTB = (1U << 1);  ///< One Shot Mode B
        constexpr uint32_t EDGB0 = (2 << 2);  ///< Edge B 0
        constexpr uint32_t EDGB1 = (2 << 4);  ///< Edge B 1
        constexpr uint32_t INP_SELB = (1U << 6);  ///< Input Select B
        constexpr uint32_t EDGCNTB_EN = (1U << 7);  ///< Edge Counter B Enable
        constexpr uint32_t CFBWM = (2 << 8);  ///< Capture B FIFOs Water Mark
        constexpr uint32_t CB0CNT = (3 << 10);  ///< Capture B0 FIFO Word Count
        constexpr uint32_t CB1CNT = (3 << 13);  ///< Capture B1 FIFO Word Count
    }

    /// SM3CAPTCOMPB Register bits
    namespace sm3captcompb_bits {
        constexpr uint32_t EDGCMPB = (8 << 0);  ///< Edge Compare B
        constexpr uint32_t EDGCNTB = (8 << 8);  ///< Edge Counter B
    }

    /// SM3CAPTCTRLX Register bits
    namespace sm3captctrlx_bits {
        constexpr uint32_t ARMX = (1U << 0);  ///< Arm X
        constexpr uint32_t ONESHOTX = (1U << 1);  ///< One Shot Mode Aux
        constexpr uint32_t EDGX0 = (2 << 2);  ///< Edge X 0
        constexpr uint32_t EDGX1 = (2 << 4);  ///< Edge X 1
        constexpr uint32_t INP_SELX = (1U << 6);  ///< Input Select X
        constexpr uint32_t EDGCNTX_EN = (1U << 7);  ///< Edge Counter X Enable
        constexpr uint32_t CFXWM = (2 << 8);  ///< Capture X FIFOs Water Mark
        constexpr uint32_t CX0CNT = (3 << 10);  ///< Capture X0 FIFO Word Count
        constexpr uint32_t CX1CNT = (3 << 13);  ///< Capture X1 FIFO Word Count
    }

    /// SM3CAPTCOMPX Register bits
    namespace sm3captcompx_bits {
        constexpr uint32_t EDGCMPX = (8 << 0);  ///< Edge Compare X
        constexpr uint32_t EDGCNTX = (8 << 8);  ///< Edge Counter X
    }

    /// SM3CVAL0 Register bits
    namespace sm3cval0_bits {
        constexpr uint32_t CAPTVAL0 = (16 << 0);  ///< CAPTVAL0
    }

    /// SM3CVAL0CYC Register bits
    namespace sm3cval0cyc_bits {
        constexpr uint32_t CVAL0CYC = (4 << 0);  ///< CVAL0CYC
    }

    /// SM3CVAL1 Register bits
    namespace sm3cval1_bits {
        constexpr uint32_t CAPTVAL1 = (16 << 0);  ///< CAPTVAL1
    }

    /// SM3CVAL1CYC Register bits
    namespace sm3cval1cyc_bits {
        constexpr uint32_t CVAL1CYC = (4 << 0);  ///< CVAL1CYC
    }

    /// SM3CVAL2 Register bits
    namespace sm3cval2_bits {
        constexpr uint32_t CAPTVAL2 = (16 << 0);  ///< CAPTVAL2
    }

    /// SM3CVAL2CYC Register bits
    namespace sm3cval2cyc_bits {
        constexpr uint32_t CVAL2CYC = (4 << 0);  ///< CVAL2CYC
    }

    /// SM3CVAL3 Register bits
    namespace sm3cval3_bits {
        constexpr uint32_t CAPTVAL3 = (16 << 0);  ///< CAPTVAL3
    }

    /// SM3CVAL3CYC Register bits
    namespace sm3cval3cyc_bits {
        constexpr uint32_t CVAL3CYC = (4 << 0);  ///< CVAL3CYC
    }

    /// SM3CVAL4 Register bits
    namespace sm3cval4_bits {
        constexpr uint32_t CAPTVAL4 = (16 << 0);  ///< CAPTVAL4
    }

    /// SM3CVAL4CYC Register bits
    namespace sm3cval4cyc_bits {
        constexpr uint32_t CVAL4CYC = (4 << 0);  ///< CVAL4CYC
    }

    /// SM3CVAL5 Register bits
    namespace sm3cval5_bits {
        constexpr uint32_t CAPTVAL5 = (16 << 0);  ///< CAPTVAL5
    }

    /// SM3CVAL5CYC Register bits
    namespace sm3cval5cyc_bits {
        constexpr uint32_t CVAL5CYC = (4 << 0);  ///< CVAL5CYC
    }

    /// OUTEN Register bits
    namespace outen_bits {
        constexpr uint32_t PWMX_EN = (4 << 0);  ///< PWM_X Output Enables
        constexpr uint32_t PWMB_EN = (4 << 4);  ///< PWM_B Output Enables
        constexpr uint32_t PWMA_EN = (4 << 8);  ///< PWM_A Output Enables
    }

    /// MASK Register bits
    namespace mask_bits {
        constexpr uint32_t MASKX = (4 << 0);  ///< PWM_X Masks
        constexpr uint32_t MASKB = (4 << 4);  ///< PWM_B Masks
        constexpr uint32_t MASKA = (4 << 8);  ///< PWM_A Masks
        constexpr uint32_t UPDATE_MASK = (4 << 12);  ///< Update Mask Bits Immediately
    }

    /// SWCOUT Register bits
    namespace swcout_bits {
        constexpr uint32_t SM0OUT45 = (1U << 0);  ///< Submodule 0 Software Controlled Output 45
        constexpr uint32_t SM0OUT23 = (1U << 1);  ///< Submodule 0 Software Controlled Output 23
        constexpr uint32_t SM1OUT45 = (1U << 2);  ///< Submodule 1 Software Controlled Output 45
        constexpr uint32_t SM1OUT23 = (1U << 3);  ///< Submodule 1 Software Controlled Output 23
        constexpr uint32_t SM2OUT45 = (1U << 4);  ///< Submodule 2 Software Controlled Output 45
        constexpr uint32_t SM2OUT23 = (1U << 5);  ///< Submodule 2 Software Controlled Output 23
        constexpr uint32_t SM3OUT45 = (1U << 6);  ///< Submodule 3 Software Controlled Output 45
        constexpr uint32_t SM3OUT23 = (1U << 7);  ///< Submodule 3 Software Controlled Output 23
    }

    /// DTSRCSEL Register bits
    namespace dtsrcsel_bits {
        constexpr uint32_t SM0SEL45 = (2 << 0);  ///< Submodule 0 PWM45 Control Select
        constexpr uint32_t SM0SEL23 = (2 << 2);  ///< Submodule 0 PWM23 Control Select
        constexpr uint32_t SM1SEL45 = (2 << 4);  ///< Submodule 1 PWM45 Control Select
        constexpr uint32_t SM1SEL23 = (2 << 6);  ///< Submodule 1 PWM23 Control Select
        constexpr uint32_t SM2SEL45 = (2 << 8);  ///< Submodule 2 PWM45 Control Select
        constexpr uint32_t SM2SEL23 = (2 << 10);  ///< Submodule 2 PWM23 Control Select
        constexpr uint32_t SM3SEL45 = (2 << 12);  ///< Submodule 3 PWM45 Control Select
        constexpr uint32_t SM3SEL23 = (2 << 14);  ///< Submodule 3 PWM23 Control Select
    }

    /// MCTRL Register bits
    namespace mctrl_bits {
        constexpr uint32_t LDOK = (4 << 0);  ///< Load Okay
        constexpr uint32_t CLDOK = (4 << 4);  ///< Clear Load Okay
        constexpr uint32_t RUN = (4 << 8);  ///< Run
        constexpr uint32_t IPOL = (4 << 12);  ///< Current Polarity
    }

    /// MCTRL2 Register bits
    namespace mctrl2_bits {
        constexpr uint32_t MONPLL = (2 << 0);  ///< Monitor PLL State
    }

    /// FCTRL0 Register bits
    namespace fctrl0_bits {
        constexpr uint32_t FIE = (4 << 0);  ///< Fault Interrupt Enables
        constexpr uint32_t FSAFE = (4 << 4);  ///< Fault Safety Mode
        constexpr uint32_t FAUTO = (4 << 8);  ///< Automatic Fault Clearing
        constexpr uint32_t FLVL = (4 << 12);  ///< Fault Level
    }

    /// FSTS0 Register bits
    namespace fsts0_bits {
        constexpr uint32_t FFLAG = (4 << 0);  ///< Fault Flags
        constexpr uint32_t FFULL = (4 << 4);  ///< Full Cycle
        constexpr uint32_t FFPIN = (4 << 8);  ///< Filtered Fault Pins
        constexpr uint32_t FHALF = (4 << 12);  ///< Half Cycle Fault Recovery
    }

    /// FFILT0 Register bits
    namespace ffilt0_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Fault Filter Period
        constexpr uint32_t FILT_CNT = (3 << 8);  ///< Fault Filter Count
        constexpr uint32_t GSTR = (1U << 15);  ///< Fault Glitch Stretch Enable
    }

    /// FTST0 Register bits
    namespace ftst0_bits {
        constexpr uint32_t FTEST = (1U << 0);  ///< Fault Test
    }

    /// FCTRL20 Register bits
    namespace fctrl20_bits {
        constexpr uint32_t NOCOMB = (4 << 0);  ///< No Combinational Path From Fault Input To PWM Output
    }

}

// ============================================================================
// BEE Peripheral
// ============================================================================

namespace bee {
    /// Base addresses
    constexpr uint32_t BEE_BASE = 0x403EC000;

    /// BEE Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - BEE Control Register
        volatile uint32_t ADDR_OFFSET0;  ///< Offset: 0x04 - no description available
        volatile uint32_t ADDR_OFFSET1;  ///< Offset: 0x08 - no description available
        volatile uint32_t AES_KEY0_W0;  ///< Offset: 0x0C - no description available
        volatile uint32_t AES_KEY0_W1;  ///< Offset: 0x10 - no description available
        volatile uint32_t AES_KEY0_W2;  ///< Offset: 0x14 - no description available
        volatile uint32_t AES_KEY0_W3;  ///< Offset: 0x18 - no description available
        volatile uint32_t STATUS;  ///< Offset: 0x1C - no description available
        volatile uint32_t CTR_NONCE0_W0;  ///< Offset: 0x20 - no description available
        volatile uint32_t CTR_NONCE0_W1;  ///< Offset: 0x24 - no description available
        volatile uint32_t CTR_NONCE0_W2;  ///< Offset: 0x28 - no description available
        volatile uint32_t CTR_NONCE0_W3;  ///< Offset: 0x2C - no description available
        volatile uint32_t CTR_NONCE1_W0;  ///< Offset: 0x30 - no description available
        volatile uint32_t CTR_NONCE1_W1;  ///< Offset: 0x34 - no description available
        volatile uint32_t CTR_NONCE1_W2;  ///< Offset: 0x38 - no description available
        volatile uint32_t CTR_NONCE1_W3;  ///< Offset: 0x3C - no description available
        volatile uint32_t REGION1_TOP;  ///< Offset: 0x40 - no description available
        volatile uint32_t REGION1_BOT;  ///< Offset: 0x44 - no description available
    };

    /// Peripheral instances
    inline Registers* BEE = reinterpret_cast<Registers*>(BEE_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t BEE_ENABLE = (1U << 0);  ///< BEE enable bit
        constexpr uint32_t CTRL_CLK_EN = (1U << 1);  ///< Clock enable input, low inactive
        constexpr uint32_t CTRL_SFTRST_N = (1U << 2);  ///< Soft reset input, low active
        constexpr uint32_t KEY_VALID = (1U << 4);  ///< AES-128 key is ready
        constexpr uint32_t KEY_REGION_SEL = (1U << 5);  ///< AES key region select
        constexpr uint32_t AC_PROT_EN = (1U << 6);  ///< Enable access permission control When AC_PROT_EN is asserted, all encrypted regions are limited to be ARM core access only
        constexpr uint32_t LITTLE_ENDIAN = (1U << 7);  ///< Endian swap control for the 16 bytes input and output data of AES core.
        constexpr uint32_t SECURITY_LEVEL_R0 = (2 << 8);  ///< Security level of the allowed access for memory region0
        constexpr uint32_t CTRL_AES_MODE_R0 = (1U << 10);  ///< AES mode of region0
        constexpr uint32_t SECURITY_LEVEL_R1 = (2 << 12);  ///< Security level of the allowed access for memory region1
        constexpr uint32_t CTRL_AES_MODE_R1 = (1U << 14);  ///< AES mode of region1
        constexpr uint32_t BEE_ENABLE_LOCK = (1U << 16);  ///< Lock bit for bee_enable
        constexpr uint32_t CTRL_CLK_EN_LOCK = (1U << 17);  ///< Lock bit for ctrl_clk_en
        constexpr uint32_t CTRL_SFTRST_N_LOCK = (1U << 18);  ///< Lock bit for ctrl_sftrst
        constexpr uint32_t REGION1_ADDR_LOCK = (1U << 19);  ///< Lock bit for region1 address boundary
        constexpr uint32_t KEY_VALID_LOCK = (1U << 20);  ///< Lock bit for key_valid
        constexpr uint32_t KEY_REGION_SEL_LOCK = (1U << 21);  ///< Lock bit for key_region_sel
        constexpr uint32_t AC_PROT_EN_LOCK = (1U << 22);  ///< Lock bit for ac_prot
        constexpr uint32_t LITTLE_ENDIAN_LOCK = (1U << 23);  ///< Lock bit for little_endian
        constexpr uint32_t SECURITY_LEVEL_R0_LOCK = (2 << 24);  ///< Lock bits for security_level_r0
        constexpr uint32_t CTRL_AES_MODE_R0_LOCK = (1U << 26);  ///< Lock bit for region0 ctrl_aes_mode
        constexpr uint32_t REGION0_KEY_LOCK = (1U << 27);  ///< Lock bit for region0 AES key
        constexpr uint32_t SECURITY_LEVEL_R1_LOCK = (2 << 28);  ///< Lock bits for security_level_r1
        constexpr uint32_t CTRL_AES_MODE_R1_LOCK = (1U << 30);  ///< Lock bit for region1 ctrl_aes_mode
        constexpr uint32_t REGION1_KEY_LOCK = (1U << 31);  ///< Lock bit for region1 AES key
    }

    /// ADDR_OFFSET0 Register bits
    namespace addr_offset0_bits {
        constexpr uint32_t ADDR_OFFSET0 = (16 << 0);  ///< Signed offset for BEE region 0
        constexpr uint32_t ADDR_OFFSET0_LOCK = (16 << 16);  ///< Lock bits for addr_offset0
    }

    /// ADDR_OFFSET1 Register bits
    namespace addr_offset1_bits {
        constexpr uint32_t ADDR_OFFSET1 = (16 << 0);  ///< Signed offset for BEE region 1
        constexpr uint32_t ADDR_OFFSET1_LOCK = (16 << 16);  ///< Lock bits for addr_offset1
    }

    /// AES_KEY0_W0 Register bits
    namespace aes_key0_w0_bits {
        constexpr uint32_t KEY0 = (32 << 0);  ///< AES 128 key from software
    }

    /// AES_KEY0_W1 Register bits
    namespace aes_key0_w1_bits {
        constexpr uint32_t KEY1 = (32 << 0);  ///< AES 128 key from software
    }

    /// AES_KEY0_W2 Register bits
    namespace aes_key0_w2_bits {
        constexpr uint32_t KEY2 = (32 << 0);  ///< AES 128 key from software
    }

    /// AES_KEY0_W3 Register bits
    namespace aes_key0_w3_bits {
        constexpr uint32_t KEY3 = (32 << 0);  ///< AES 128 key from software
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t IRQ_VEC = (8 << 0);  ///< bit 7: Protected region-3 access violation bit 6: Protected region-2 access violation bit 5: Protected region-1 access violation bit 4: Protected region-0 access violation bit 3: Region-1 read channel security violation bit 2: Read channel illegal access detected bit 1: Region-0 read channel security violation bit 0: Disable abort
        constexpr uint32_t BEE_IDLE = (1U << 8);  ///< 1'b1: BEE is idle; 1'b0: BEE is active
    }

    /// CTR_NONCE0_W0 Register bits
    namespace ctr_nonce0_w0_bits {
        constexpr uint32_t NONCE00 = (32 << 0);  ///< Nonce0 from software for CTR, for region0. Nonce0={Nonce03,Nonce02,Nonce01,Nonce00}
    }

    /// CTR_NONCE0_W1 Register bits
    namespace ctr_nonce0_w1_bits {
        constexpr uint32_t NONCE01 = (32 << 0);  ///< Nonce0 from software for CTR, for region0. Nonce0={Nonce03,Nonce02,Nonce01,Nonce00}
    }

    /// CTR_NONCE0_W2 Register bits
    namespace ctr_nonce0_w2_bits {
        constexpr uint32_t NONCE02 = (32 << 0);  ///< Nonce0 from software for CTR, for region0. Nonce0={Nonce03,Nonce02,Nonce01,Nonce00}
    }

    /// CTR_NONCE0_W3 Register bits
    namespace ctr_nonce0_w3_bits {
        constexpr uint32_t NONCE03 = (32 << 0);  ///< Nonce0 from software for CTR, for region0. Nonce0={Nonce03,Nonce02,Nonce01,Nonce00}
    }

    /// CTR_NONCE1_W0 Register bits
    namespace ctr_nonce1_w0_bits {
        constexpr uint32_t NONCE10 = (32 << 0);  ///< Nonce1 from software for CTR, for region1. Nonce1={Nonce13,Nonce12,Nonce11,Nonce10}
    }

    /// CTR_NONCE1_W1 Register bits
    namespace ctr_nonce1_w1_bits {
        constexpr uint32_t NONCE11 = (32 << 0);  ///< Nonce1 from software for CTR, for region1. Nonce1={Nonce13,Nonce12,Nonce11,Nonce10}
    }

    /// CTR_NONCE1_W2 Register bits
    namespace ctr_nonce1_w2_bits {
        constexpr uint32_t NONCE12 = (32 << 0);  ///< Nonce1 from software for CTR, for region1. Nonce1={Nonce13,Nonce12,Nonce11,Nonce10}
    }

    /// CTR_NONCE1_W3 Register bits
    namespace ctr_nonce1_w3_bits {
        constexpr uint32_t NONCE13 = (32 << 0);  ///< Nonce1 from software for CTR, for region1. Nonce1={Nonce13,Nonce12,Nonce11,Nonce10}
    }

    /// REGION1_TOP Register bits
    namespace region1_top_bits {
        constexpr uint32_t REGION1_TOP = (32 << 0);  ///< Address upper limit of region1
    }

    /// REGION1_BOT Register bits
    namespace region1_bot_bits {
        constexpr uint32_t REGION1_BOT = (32 << 0);  ///< Address lower limit of region1
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t LPI2C1_BASE = 0x403F0000;
    constexpr uint32_t LPI2C2_BASE = 0x403F4000;
    constexpr uint32_t LPI2C3_BASE = 0x403F8000;
    constexpr uint32_t LPI2C4_BASE = 0x403FC000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t MCR;  ///< Offset: 0x10 - Master Control Register
        volatile uint32_t MSR;  ///< Offset: 0x14 - Master Status Register
        volatile uint32_t MIER;  ///< Offset: 0x18 - Master Interrupt Enable Register
        volatile uint32_t MDER;  ///< Offset: 0x1C - Master DMA Enable Register
        volatile uint32_t MCFGR0;  ///< Offset: 0x20 - Master Configuration Register 0
        volatile uint32_t MCFGR1;  ///< Offset: 0x24 - Master Configuration Register 1
        volatile uint32_t MCFGR2;  ///< Offset: 0x28 - Master Configuration Register 2
        volatile uint32_t MCFGR3;  ///< Offset: 0x2C - Master Configuration Register 3
        volatile uint32_t MDMR;  ///< Offset: 0x40 - Master Data Match Register
        volatile uint32_t MCCR0;  ///< Offset: 0x48 - Master Clock Configuration Register 0
        volatile uint32_t MCCR1;  ///< Offset: 0x50 - Master Clock Configuration Register 1
        volatile uint32_t MFCR;  ///< Offset: 0x58 - Master FIFO Control Register
        volatile uint32_t MFSR;  ///< Offset: 0x5C - Master FIFO Status Register
        volatile uint32_t MTDR;  ///< Offset: 0x60 - Master Transmit Data Register
        volatile uint32_t MRDR;  ///< Offset: 0x70 - Master Receive Data Register
        volatile uint32_t SCR;  ///< Offset: 0x110 - Slave Control Register
        volatile uint32_t SSR;  ///< Offset: 0x114 - Slave Status Register
        volatile uint32_t SIER;  ///< Offset: 0x118 - Slave Interrupt Enable Register
        volatile uint32_t SDER;  ///< Offset: 0x11C - Slave DMA Enable Register
        volatile uint32_t SCFGR1;  ///< Offset: 0x124 - Slave Configuration Register 1
        volatile uint32_t SCFGR2;  ///< Offset: 0x128 - Slave Configuration Register 2
        volatile uint32_t SAMR;  ///< Offset: 0x140 - Slave Address Match Register
        volatile uint32_t SASR;  ///< Offset: 0x150 - Slave Address Status Register
        volatile uint32_t STAR;  ///< Offset: 0x154 - Slave Transmit ACK Register
        volatile uint32_t STDR;  ///< Offset: 0x160 - Slave Transmit Data Register
        volatile uint32_t SRDR;  ///< Offset: 0x170 - Slave Receive Data Register
    };

    /// Peripheral instances
    inline Registers* LPI2C1 = reinterpret_cast<Registers*>(LPI2C1_BASE);
    inline Registers* LPI2C2 = reinterpret_cast<Registers*>(LPI2C2_BASE);
    inline Registers* LPI2C3 = reinterpret_cast<Registers*>(LPI2C3_BASE);
    inline Registers* LPI2C4 = reinterpret_cast<Registers*>(LPI2C4_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t MTXFIFO = (4 << 0);  ///< Master Transmit FIFO Size
        constexpr uint32_t MRXFIFO = (4 << 8);  ///< Master Receive FIFO Size
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MEN = (1U << 0);  ///< Master Enable
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
        constexpr uint32_t DOZEN = (1U << 2);  ///< Doze mode enable
        constexpr uint32_t DBGEN = (1U << 3);  ///< Debug Enable
        constexpr uint32_t RTF = (1U << 8);  ///< Reset Transmit FIFO
        constexpr uint32_t RRF = (1U << 9);  ///< Reset Receive FIFO
    }

    /// MSR Register bits
    namespace msr_bits {
        constexpr uint32_t TDF = (1U << 0);  ///< Transmit Data Flag
        constexpr uint32_t RDF = (1U << 1);  ///< Receive Data Flag
        constexpr uint32_t EPF = (1U << 8);  ///< End Packet Flag
        constexpr uint32_t SDF = (1U << 9);  ///< STOP Detect Flag
        constexpr uint32_t NDF = (1U << 10);  ///< NACK Detect Flag
        constexpr uint32_t ALF = (1U << 11);  ///< Arbitration Lost Flag
        constexpr uint32_t FEF = (1U << 12);  ///< FIFO Error Flag
        constexpr uint32_t PLTF = (1U << 13);  ///< Pin Low Timeout Flag
        constexpr uint32_t DMF = (1U << 14);  ///< Data Match Flag
        constexpr uint32_t MBF = (1U << 24);  ///< Master Busy Flag
        constexpr uint32_t BBF = (1U << 25);  ///< Bus Busy Flag
    }

    /// MIER Register bits
    namespace mier_bits {
        constexpr uint32_t TDIE = (1U << 0);  ///< Transmit Data Interrupt Enable
        constexpr uint32_t RDIE = (1U << 1);  ///< Receive Data Interrupt Enable
        constexpr uint32_t EPIE = (1U << 8);  ///< End Packet Interrupt Enable
        constexpr uint32_t SDIE = (1U << 9);  ///< STOP Detect Interrupt Enable
        constexpr uint32_t NDIE = (1U << 10);  ///< NACK Detect Interrupt Enable
        constexpr uint32_t ALIE = (1U << 11);  ///< Arbitration Lost Interrupt Enable
        constexpr uint32_t FEIE = (1U << 12);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t PLTIE = (1U << 13);  ///< Pin Low Timeout Interrupt Enable
        constexpr uint32_t DMIE = (1U << 14);  ///< Data Match Interrupt Enable
    }

    /// MDER Register bits
    namespace mder_bits {
        constexpr uint32_t TDDE = (1U << 0);  ///< Transmit Data DMA Enable
        constexpr uint32_t RDDE = (1U << 1);  ///< Receive Data DMA Enable
    }

    /// MCFGR0 Register bits
    namespace mcfgr0_bits {
        constexpr uint32_t HREN = (1U << 0);  ///< Host Request Enable
        constexpr uint32_t HRPOL = (1U << 1);  ///< Host Request Polarity
        constexpr uint32_t HRSEL = (1U << 2);  ///< Host Request Select
        constexpr uint32_t CIRFIFO = (1U << 8);  ///< Circular FIFO Enable
        constexpr uint32_t RDMO = (1U << 9);  ///< Receive Data Match Only
    }

    /// MCFGR1 Register bits
    namespace mcfgr1_bits {
        constexpr uint32_t PRESCALE = (3 << 0);  ///< Prescaler
        constexpr uint32_t AUTOSTOP = (1U << 8);  ///< Automatic STOP Generation
        constexpr uint32_t IGNACK = (1U << 9);  ///< IGNACK
        constexpr uint32_t TIMECFG = (1U << 10);  ///< Timeout Configuration
        constexpr uint32_t MATCFG = (3 << 16);  ///< Match Configuration
        constexpr uint32_t PINCFG = (3 << 24);  ///< Pin Configuration
    }

    /// MCFGR2 Register bits
    namespace mcfgr2_bits {
        constexpr uint32_t BUSIDLE = (12 << 0);  ///< Bus Idle Timeout
        constexpr uint32_t FILTSCL = (4 << 16);  ///< Glitch Filter SCL
        constexpr uint32_t FILTSDA = (4 << 24);  ///< Glitch Filter SDA
    }

    /// MCFGR3 Register bits
    namespace mcfgr3_bits {
        constexpr uint32_t PINLOW = (12 << 8);  ///< Pin Low Timeout
    }

    /// MDMR Register bits
    namespace mdmr_bits {
        constexpr uint32_t MATCH0 = (8 << 0);  ///< Match 0 Value
        constexpr uint32_t MATCH1 = (8 << 16);  ///< Match 1 Value
    }

    /// MCCR0 Register bits
    namespace mccr0_bits {
        constexpr uint32_t CLKLO = (6 << 0);  ///< Clock Low Period
        constexpr uint32_t CLKHI = (6 << 8);  ///< Clock High Period
        constexpr uint32_t SETHOLD = (6 << 16);  ///< Setup Hold Delay
        constexpr uint32_t DATAVD = (6 << 24);  ///< Data Valid Delay
    }

    /// MCCR1 Register bits
    namespace mccr1_bits {
        constexpr uint32_t CLKLO = (6 << 0);  ///< Clock Low Period
        constexpr uint32_t CLKHI = (6 << 8);  ///< Clock High Period
        constexpr uint32_t SETHOLD = (6 << 16);  ///< Setup Hold Delay
        constexpr uint32_t DATAVD = (6 << 24);  ///< Data Valid Delay
    }

    /// MFCR Register bits
    namespace mfcr_bits {
        constexpr uint32_t TXWATER = (2 << 0);  ///< Transmit FIFO Watermark
        constexpr uint32_t RXWATER = (2 << 16);  ///< Receive FIFO Watermark
    }

    /// MFSR Register bits
    namespace mfsr_bits {
        constexpr uint32_t TXCOUNT = (3 << 0);  ///< Transmit FIFO Count
        constexpr uint32_t RXCOUNT = (3 << 16);  ///< Receive FIFO Count
    }

    /// MTDR Register bits
    namespace mtdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Transmit Data
        constexpr uint32_t CMD = (3 << 8);  ///< Command Data
    }

    /// MRDR Register bits
    namespace mrdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Receive Data
        constexpr uint32_t RXEMPTY = (1U << 14);  ///< RX Empty
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SEN = (1U << 0);  ///< Slave Enable
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
        constexpr uint32_t FILTEN = (1U << 4);  ///< Filter Enable
        constexpr uint32_t FILTDZ = (1U << 5);  ///< Filter Doze Enable
        constexpr uint32_t RTF = (1U << 8);  ///< Reset Transmit FIFO
        constexpr uint32_t RRF = (1U << 9);  ///< Reset Receive FIFO
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t TDF = (1U << 0);  ///< Transmit Data Flag
        constexpr uint32_t RDF = (1U << 1);  ///< Receive Data Flag
        constexpr uint32_t AVF = (1U << 2);  ///< Address Valid Flag
        constexpr uint32_t TAF = (1U << 3);  ///< Transmit ACK Flag
        constexpr uint32_t RSF = (1U << 8);  ///< Repeated Start Flag
        constexpr uint32_t SDF = (1U << 9);  ///< STOP Detect Flag
        constexpr uint32_t BEF = (1U << 10);  ///< Bit Error Flag
        constexpr uint32_t FEF = (1U << 11);  ///< FIFO Error Flag
        constexpr uint32_t AM0F = (1U << 12);  ///< Address Match 0 Flag
        constexpr uint32_t AM1F = (1U << 13);  ///< Address Match 1 Flag
        constexpr uint32_t GCF = (1U << 14);  ///< General Call Flag
        constexpr uint32_t SARF = (1U << 15);  ///< SMBus Alert Response Flag
        constexpr uint32_t SBF = (1U << 24);  ///< Slave Busy Flag
        constexpr uint32_t BBF = (1U << 25);  ///< Bus Busy Flag
    }

    /// SIER Register bits
    namespace sier_bits {
        constexpr uint32_t TDIE = (1U << 0);  ///< Transmit Data Interrupt Enable
        constexpr uint32_t RDIE = (1U << 1);  ///< Receive Data Interrupt Enable
        constexpr uint32_t AVIE = (1U << 2);  ///< Address Valid Interrupt Enable
        constexpr uint32_t TAIE = (1U << 3);  ///< Transmit ACK Interrupt Enable
        constexpr uint32_t RSIE = (1U << 8);  ///< Repeated Start Interrupt Enable
        constexpr uint32_t SDIE = (1U << 9);  ///< STOP Detect Interrupt Enable
        constexpr uint32_t BEIE = (1U << 10);  ///< Bit Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 11);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t AM0IE = (1U << 12);  ///< Address Match 0 Interrupt Enable
        constexpr uint32_t AM1F = (1U << 13);  ///< Address Match 1 Interrupt Enable
        constexpr uint32_t GCIE = (1U << 14);  ///< General Call Interrupt Enable
        constexpr uint32_t SARIE = (1U << 15);  ///< SMBus Alert Response Interrupt Enable
    }

    /// SDER Register bits
    namespace sder_bits {
        constexpr uint32_t TDDE = (1U << 0);  ///< Transmit Data DMA Enable
        constexpr uint32_t RDDE = (1U << 1);  ///< Receive Data DMA Enable
        constexpr uint32_t AVDE = (1U << 2);  ///< Address Valid DMA Enable
    }

    /// SCFGR1 Register bits
    namespace scfgr1_bits {
        constexpr uint32_t ADRSTALL = (1U << 0);  ///< Address SCL Stall
        constexpr uint32_t RXSTALL = (1U << 1);  ///< RX SCL Stall
        constexpr uint32_t TXDSTALL = (1U << 2);  ///< TX Data SCL Stall
        constexpr uint32_t ACKSTALL = (1U << 3);  ///< ACK SCL Stall
        constexpr uint32_t GCEN = (1U << 8);  ///< General Call Enable
        constexpr uint32_t SAEN = (1U << 9);  ///< SMBus Alert Enable
        constexpr uint32_t TXCFG = (1U << 10);  ///< Transmit Flag Configuration
        constexpr uint32_t RXCFG = (1U << 11);  ///< Receive Data Configuration
        constexpr uint32_t IGNACK = (1U << 12);  ///< Ignore NACK
        constexpr uint32_t HSMEN = (1U << 13);  ///< High Speed Mode Enable
        constexpr uint32_t ADDRCFG = (3 << 16);  ///< Address Configuration
    }

    /// SCFGR2 Register bits
    namespace scfgr2_bits {
        constexpr uint32_t CLKHOLD = (4 << 0);  ///< Clock Hold Time
        constexpr uint32_t DATAVD = (6 << 8);  ///< Data Valid Delay
        constexpr uint32_t FILTSCL = (4 << 16);  ///< Glitch Filter SCL
        constexpr uint32_t FILTSDA = (4 << 24);  ///< Glitch Filter SDA
    }

    /// SAMR Register bits
    namespace samr_bits {
        constexpr uint32_t ADDR0 = (10 << 1);  ///< Address 0 Value
        constexpr uint32_t ADDR1 = (10 << 17);  ///< Address 1 Value
    }

    /// SASR Register bits
    namespace sasr_bits {
        constexpr uint32_t RADDR = (11 << 0);  ///< Received Address
        constexpr uint32_t ANV = (1U << 14);  ///< Address Not Valid
    }

    /// STAR Register bits
    namespace star_bits {
        constexpr uint32_t TXNACK = (1U << 0);  ///< Transmit NACK
    }

    /// STDR Register bits
    namespace stdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Transmit Data
    }

    /// SRDR Register bits
    namespace srdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Receive Data
        constexpr uint32_t RXEMPTY = (1U << 14);  ///< RX Empty
        constexpr uint32_t SOF = (1U << 15);  ///< Start Of Frame
    }

}

// ============================================================================
// SystemControl Peripheral
// ============================================================================

namespace systemcontrol {
    /// Base addresses
    constexpr uint32_t SystemControl_BASE = 0xE000E000;

    /// SystemControl Register structure
    struct Registers {
        volatile uint32_t ACTLR;  ///< Offset: 0x08 - Auxiliary Control Register,
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control and State Register
        volatile uint32_t VTOR;  ///< Offset: 0xD08 - Vector Table Offset Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt and Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration and Control Register
        volatile uint32_t SHPR1;  ///< Offset: 0xD18 - System Handler Priority Register 1
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
        volatile uint32_t CFSR;  ///< Offset: 0xD28 - Configurable Fault Status Register
        volatile uint32_t HFSR;  ///< Offset: 0xD2C - HardFault Status register
        volatile uint32_t DFSR;  ///< Offset: 0xD30 - Debug Fault Status Register
        volatile uint32_t MMFAR;  ///< Offset: 0xD34 - MemManage Fault Address Register
        volatile uint32_t BFAR;  ///< Offset: 0xD38 - BusFault Address Register
        volatile uint32_t ID_PFR0;  ///< Offset: 0xD40 - Processor Feature Register 0
        volatile uint32_t ID_PFR1;  ///< Offset: 0xD44 - Processor Feature Register 1
        volatile uint32_t ID_DFR0;  ///< Offset: 0xD48 - Debug Feature Register
        volatile uint32_t ID_AFR0;  ///< Offset: 0xD4C - Auxiliary Feature Register
        volatile uint32_t ID_MMFR0;  ///< Offset: 0xD50 - Memory Model Feature Register 0
        volatile uint32_t ID_MMFR1;  ///< Offset: 0xD54 - Memory Model Feature Register 1
        volatile uint32_t ID_MMFR2;  ///< Offset: 0xD58 - Memory Model Feature Register 2
        volatile uint32_t ID_MMFR3;  ///< Offset: 0xD5C - Memory Model Feature Register 3
        volatile uint32_t ID_ISAR0;  ///< Offset: 0xD60 - Instruction Set Attributes Register 0
        volatile uint32_t ID_ISAR1;  ///< Offset: 0xD64 - Instruction Set Attributes Register 1
        volatile uint32_t ID_ISAR2;  ///< Offset: 0xD68 - Instruction Set Attributes Register 2
        volatile uint32_t ID_ISAR3;  ///< Offset: 0xD6C - Instruction Set Attributes Register 3
        volatile uint32_t ID_ISAR4;  ///< Offset: 0xD70 - Instruction Set Attributes Register 4
        volatile uint32_t CLIDR;  ///< Offset: 0xD78 - Cache Level ID register
        volatile uint32_t CTR;  ///< Offset: 0xD7C - Cache Type register
        volatile uint32_t CCSIDR;  ///< Offset: 0xD80 - Cache Size ID Register
        volatile uint32_t CSSELR;  ///< Offset: 0xD84 - Cache Size Selection Register
        volatile uint32_t CPACR;  ///< Offset: 0xD88 - Coprocessor Access Control Register
        volatile uint32_t STIR;  ///< Offset: 0xF00 - Instruction cache invalidate all to Point of Unification (PoU)
        volatile uint32_t ICIALLU;  ///< Offset: 0xF50 - Instruction cache invalidate all to Point of Unification (PoU)
        volatile uint32_t ICIMVAU;  ///< Offset: 0xF58 - Instruction cache invalidate by address to PoU
        volatile uint32_t DCIMVAC;  ///< Offset: 0xF5C - Data cache invalidate by address to Point of Coherency (PoC)
        volatile uint32_t DCISW;  ///< Offset: 0xF60 - Data cache invalidate by set/way
        volatile uint32_t DCCMVAU;  ///< Offset: 0xF64 - Data cache by address to PoU
        volatile uint32_t DCCMVAC;  ///< Offset: 0xF68 - Data cache clean by address to PoC
        volatile uint32_t DCCSW;  ///< Offset: 0xF6C - Data cache clean by set/way
        volatile uint32_t DCCIMVAC;  ///< Offset: 0xF70 - Data cache clean and invalidate by address to PoC
        volatile uint32_t DCCISW;  ///< Offset: 0xF74 - Data cache clean and invalidate by set/way
        volatile uint32_t CM7_ITCMCR;  ///< Offset: 0xF90 - Instruction Tightly-Coupled Memory Control Register
        volatile uint32_t CM7_DTCMCR;  ///< Offset: 0xF94 - Data Tightly-Coupled Memory Control Register
        volatile uint32_t CM7_AHBPCR;  ///< Offset: 0xF98 - AHBP Control Register
        volatile uint32_t CM7_CACR;  ///< Offset: 0xF9C - L1 Cache Control Register
        volatile uint32_t CM7_AHBSCR;  ///< Offset: 0xFA0 - AHB Slave Control Register
        volatile uint32_t CM7_ABFSR;  ///< Offset: 0xFA8 - Auxiliary Bus Fault Status Register
    };

    /// Peripheral instances
    inline Registers* SystemControl = reinterpret_cast<Registers*>(SystemControl_BASE);

    // Bit definitions
    /// ACTLR Register bits
    namespace actlr_bits {
        constexpr uint32_t DISFOLD = (1U << 2);  ///< Disables folding of IT instructions.
        constexpr uint32_t FPEXCODIS = (1U << 10);  ///< Disables FPU exception outputs.
        constexpr uint32_t DISRAMODE = (1U << 11);  ///< Disables dynamic read allocate mode for Write-Back Write-Allocate memory regions.
        constexpr uint32_t DISITMATBFLUSH = (1U << 12);  ///< Disables ITM and DWT ATB flush.
        constexpr uint32_t DISBTACREAD = (1U << 13);  ///< Disables BTAC read.
        constexpr uint32_t DISBTACALLOC = (1U << 14);  ///< Disables BTAC allocate.
        constexpr uint32_t DISCRITAXIRUR = (1U << 15);  ///< Disables critical AXI Read-Under-Read.
        constexpr uint32_t DISDI = (5 << 16);  ///< Disables dual-issued.
        constexpr uint32_t DISISSCH1 = (5 << 21);  ///< Disables dual-issued.
        constexpr uint32_t DISDYNADD = (1U << 26);  ///< Disables dynamic allocation of ADD and SUB instructions
        constexpr uint32_t DISCRITAXIRUW = (1U << 27);  ///< Disables critical AXI read-under-write
        constexpr uint32_t DISFPUISSOPT = (1U << 28);  ///< Disables critical AXI read-under-write
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t REVISION = (4 << 0);  ///< Indicates patch release: 0x0 = Patch 0
        constexpr uint32_t PARTNO = (12 << 4);  ///< Indicates part number
        constexpr uint32_t ARCHITECTURE = (4 << 16);  ///< ARCHITECTURE
        constexpr uint32_t VARIANT = (4 << 20);  ///< Indicates processor revision: 0x2 = Revision 2
        constexpr uint32_t IMPLEMENTER = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active exception number
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< Indicates whether there are preempted active exceptions
        constexpr uint32_t VECTPENDING = (9 << 12);  ///< Exception number of the highest priority pending enabled exception
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag, excluding NMI and Faults
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick exception clear-pending bit
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick exception set-pending bit
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV clear-pending bit
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV set-pending bit
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI set-pending bit
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (25 << 7);  ///< Vector table base offset
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTRESET = (1U << 0);  ///< Writing 1 to this bit causes a local system reset
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< Writing 1 to this bit clears all active state information for fixed and configurable exceptions.
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< System reset request
        constexpr uint32_t PRIGROUP = (3 << 8);  ///< Interrupt priority grouping field. This field determines the split of group priority from subpriority.
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< Data endianness
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< Indicates sleep-on-exit when returning from Handler mode to Thread mode
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< Controls whether the processor uses sleep or deep sleep as its low power mode
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< Send Event on Pending bit
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< Indicates how the processor enters Thread mode
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< Enables unprivileged software access to the STIR
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Enables unaligned access traps
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions.
        constexpr uint32_t STKALIGN = (1U << 9);  ///< Indicates stack alignment on exception entry
        constexpr uint32_t DC = (1U << 16);  ///< Enables L1 data cache.
        constexpr uint32_t IC = (1U << 17);  ///< Enables L1 instruction cache.
        constexpr uint32_t BP = (1U << 18);  ///< Always reads-as-one. It indicates branch prediction is enabled.
    }

    /// SHPR1 Register bits
    namespace shpr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of system handler 4, MemManage
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of system handler 5, BusFault
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of system handler 6, UsageFault
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11, SVCall
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14, PendSV
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15, SysTick exception
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t MEMFAULTACT = (1U << 0);  ///< MemManage exception active bit
        constexpr uint32_t BUSFAULTACT = (1U << 1);  ///< BusFault exception active bit
        constexpr uint32_t USGFAULTACT = (1U << 3);  ///< UsageFault exception active bit
        constexpr uint32_t SVCALLACT = (1U << 7);  ///< SVCall active bit
        constexpr uint32_t MONITORACT = (1U << 8);  ///< Debug monitor active bit
        constexpr uint32_t PENDSVACT = (1U << 10);  ///< PendSV exception active bit
        constexpr uint32_t SYSTICKACT = (1U << 11);  ///< SysTick exception active bit
        constexpr uint32_t USGFAULTPENDED = (1U << 12);  ///< UsageFault exception pending bit
        constexpr uint32_t MEMFAULTPENDED = (1U << 13);  ///< MemManage exception pending bit
        constexpr uint32_t BUSFAULTPENDED = (1U << 14);  ///< BusFault exception pending bit
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVCall pending bit
        constexpr uint32_t MEMFAULTENA = (1U << 16);  ///< MemManage enable bit
        constexpr uint32_t BUSFAULTENA = (1U << 17);  ///< BusFault enable bit
        constexpr uint32_t USGFAULTENA = (1U << 18);  ///< UsageFault enable bit
    }

    /// CFSR Register bits
    namespace cfsr_bits {
        constexpr uint32_t IACCVIOL = (1U << 0);  ///< Instruction access violation flag
        constexpr uint32_t DACCVIOL = (1U << 1);  ///< Data access violation flag
        constexpr uint32_t MUNSTKERR = (1U << 3);  ///< MemManage fault on unstacking for a return from exception
        constexpr uint32_t MSTKERR = (1U << 4);  ///< MemManage fault on stacking for exception entry
        constexpr uint32_t MLSPERR = (1U << 5);  ///< MemManage fault occurred during floating-point lazy state preservation
        constexpr uint32_t MMARVALID = (1U << 7);  ///< MemManage Fault Address Register (MMFAR) valid flag
        constexpr uint32_t IBUSERR = (1U << 8);  ///< Instruction bus error
        constexpr uint32_t PRECISERR = (1U << 9);  ///< Precise data bus error
        constexpr uint32_t IMPRECISERR = (1U << 10);  ///< Imprecise data bus error
        constexpr uint32_t UNSTKERR = (1U << 11);  ///< BusFault on unstacking for a return from exception
        constexpr uint32_t STKERR = (1U << 12);  ///< BusFault on stacking for exception entry
        constexpr uint32_t LSPERR = (1U << 13);  ///< Bus fault occurred during floating-point lazy state preservation
        constexpr uint32_t BFARVALID = (1U << 15);  ///< BusFault Address Register (BFAR) valid flag
        constexpr uint32_t UNDEFINSTR = (1U << 16);  ///< Undefined instruction UsageFault
        constexpr uint32_t INVSTATE = (1U << 17);  ///< Invalid state UsageFault
        constexpr uint32_t INVPC = (1U << 18);  ///< Invalid PC load UsageFault, caused by an invalid PC load by EXC_RETURN
        constexpr uint32_t NOCP = (1U << 19);  ///< No coprocessor UsageFault
        constexpr uint32_t UNALIGNED = (1U << 24);  ///< Unaligned access UsageFault
        constexpr uint32_t DIVBYZERO = (1U << 25);  ///< Divide by zero UsageFault
    }

    /// HFSR Register bits
    namespace hfsr_bits {
        constexpr uint32_t VECTTBL = (1U << 1);  ///< Indicates a BusFault on a vector table read during exception processing.
        constexpr uint32_t FORCED = (1U << 30);  ///< Indicates a forced hard fault, generated by escalation of a fault with configurable priority that cannot be handles, either because of priority or because it is disabled.
        constexpr uint32_t DEBUGEVT = (1U << 31);  ///< Reserved for Debug use. When writing to the register you must write 0 to this bit, otherwise behavior is Unpredictable.
    }

    /// DFSR Register bits
    namespace dfsr_bits {
        constexpr uint32_t HALTED = (1U << 0);  ///< Indicates a debug event generated by either a C_HALT or C_STEP request, triggered by a write to the DHCSR or a step request triggered by setting DEMCR.MON_STEP to 1.
        constexpr uint32_t BKPT = (1U << 1);  ///< Debug event generated by BKPT instruction execution or a breakpoint match in FPB
        constexpr uint32_t DWTTRAP = (1U << 2);  ///< Debug event generated by the DWT
        constexpr uint32_t VCATCH = (1U << 3);  ///< Indicates triggering of a Vector catch
        constexpr uint32_t EXTERNAL = (1U << 4);  ///< Debug event generated because of the assertion of an external debug request
    }

    /// MMFAR Register bits
    namespace mmfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address of MemManage fault location
    }

    /// BFAR Register bits
    namespace bfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address of the BusFault location
    }

    /// ID_PFR0 Register bits
    namespace id_pfr0_bits {
        constexpr uint32_t STATE0 = (4 << 0);  ///< ARM instruction set support
        constexpr uint32_t STATE1 = (4 << 4);  ///< Thumb instruction set support
        constexpr uint32_t STATE2 = (4 << 8);  ///< ARMv7-M unused
        constexpr uint32_t STATE3 = (4 << 12);  ///< ARMv7-M unused
    }

    /// ID_PFR1 Register bits
    namespace id_pfr1_bits {
        constexpr uint32_t PROGMODEL = (4 << 8);  ///< M profile programmers' model
    }

    /// ID_DFR0 Register bits
    namespace id_dfr0_bits {
        constexpr uint32_t DEBUGMODEL = (4 << 20);  ///< Support for memory-mapped debug model for M profile processors
    }

    /// ID_AFR0 Register bits
    namespace id_afr0_bits {
        constexpr uint32_t IMPLEMENTATION_DEFINED0 = (4 << 0);  ///< Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
        constexpr uint32_t IMPLEMENTATION_DEFINED1 = (4 << 4);  ///< Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
        constexpr uint32_t IMPLEMENTATION_DEFINED2 = (4 << 8);  ///< Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
        constexpr uint32_t IMPLEMENTATION_DEFINED3 = (4 << 12);  ///< Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
    }

    /// ID_MMFR0 Register bits
    namespace id_mmfr0_bits {
        constexpr uint32_t PMSASUPPORT = (4 << 4);  ///< Indicates support for a PMSA
        constexpr uint32_t OUTERMOST_SHAREABILITY = (4 << 8);  ///< Indicates the outermost shareability domain implemented
        constexpr uint32_t SHAREABILITY_LEVELS = (4 << 12);  ///< Indicates the number of shareability levels implemented
        constexpr uint32_t TCM_SUPPORT = (4 << 16);  ///< Indicates the support for Tightly Coupled Memory
        constexpr uint32_t AUXILIARY_REGISTERS = (4 << 20);  ///< Indicates the support for Auxiliary registers
    }

    /// ID_MMFR1 Register bits
    namespace id_mmfr1_bits {
        constexpr uint32_t ID_MMFR1 = (32 << 0);  ///< Gives information about the implemented memory model and memory management support.
    }

    /// ID_MMFR2 Register bits
    namespace id_mmfr2_bits {
        constexpr uint32_t WFI_STALL = (4 << 24);  ///< Indicates the support for Wait For Interrupt (WFI) stalling
    }

    /// ID_MMFR3 Register bits
    namespace id_mmfr3_bits {
        constexpr uint32_t ID_MMFR3 = (32 << 0);  ///< Gives information about the implemented memory model and memory management support.
    }

    /// ID_ISAR0 Register bits
    namespace id_isar0_bits {
        constexpr uint32_t BITCOUNT_INSTRS = (4 << 4);  ///< Indicates the supported Bit Counting instructions
        constexpr uint32_t BITFIELD_INSTRS = (4 << 8);  ///< Indicates the supported BitField instructions
        constexpr uint32_t CMPBRANCH_INSTRS = (4 << 12);  ///< Indicates the supported combined Compare and Branch instructions
        constexpr uint32_t COPROC_INSTRS = (4 << 16);  ///< Indicates the supported Coprocessor instructions
        constexpr uint32_t DEBUG_INSTRS = (4 << 20);  ///< Indicates the supported Debug instructions
        constexpr uint32_t DIVIDE_INSTRS = (4 << 24);  ///< Indicates the supported Divide instructions
    }

    /// ID_ISAR1 Register bits
    namespace id_isar1_bits {
        constexpr uint32_t EXTEND_INSTRS = (4 << 12);  ///< Indicates the supported Extend instructions
        constexpr uint32_t IFTHEN_INSTRS = (4 << 16);  ///< Indicates the supported IfThen instructions
        constexpr uint32_t IMMEDIATE_INSTRS = (4 << 20);  ///< Indicates the support for data-processing instructions with long immediate
        constexpr uint32_t INTERWORK_INSTRS = (4 << 24);  ///< Indicates the supported Interworking instructions
    }

    /// ID_ISAR2 Register bits
    namespace id_isar2_bits {
        constexpr uint32_t LOADSTORE_INSTRS = (4 << 0);  ///< Indicates the supported additional load and store instructions
        constexpr uint32_t MEMHINT_INSTRS = (4 << 4);  ///< Indicates the supported Memory Hint instructions
        constexpr uint32_t MULTIACCESSINT_INSTRS = (4 << 8);  ///< Indicates the support for multi-access interruptible instructions
        constexpr uint32_t MULT_INSTRS = (4 << 12);  ///< Indicates the supported additional Multiply instructions
        constexpr uint32_t MULTS_INSTRS = (4 << 16);  ///< Indicates the supported advanced signed Multiply instructions
        constexpr uint32_t MULTU_INSTRS = (4 << 20);  ///< Indicates the supported advanced unsigned Multiply instructions
        constexpr uint32_t REVERSAL_INSTRS = (4 << 28);  ///< Indicates the supported Reversal instructions
    }

    /// ID_ISAR3 Register bits
    namespace id_isar3_bits {
        constexpr uint32_t SATURATE_INSTRS = (4 << 0);  ///< Indicates the supported Saturate instructions
        constexpr uint32_t SIMD_INSTRS = (4 << 4);  ///< Indicates the supported SIMD instructions
        constexpr uint32_t SVC_INSTRS = (4 << 8);  ///< Indicates the supported SVC instructions
        constexpr uint32_t SYNCHPRIM_INSTRS = (4 << 12);  ///< Together with the ID_ISAR4[SYNCHPRIM_INSTRS_FRAC] indicates the supported Synchronization Primitives
        constexpr uint32_t TABBRANCH_INSTRS = (4 << 16);  ///< Indicates the supported Table Branch instructions
        constexpr uint32_t THUMBCOPY_INSTRS = (4 << 20);  ///< Indicates the supported non flag-setting MOV instructions
        constexpr uint32_t TRUENOP_INSTRS = (4 << 24);  ///< Indicates the supported non flag-setting MOV instructions
    }

    /// ID_ISAR4 Register bits
    namespace id_isar4_bits {
        constexpr uint32_t UNPRIV_INSTRS = (4 << 0);  ///< Indicates the supported unprivileged instructions. These are the instruction variants indicated by a T suffix.
        constexpr uint32_t WITHSHIFTS_INSTRS = (4 << 4);  ///< Indicates the support for instructions with shifts
        constexpr uint32_t WRITEBACK_INSTRS = (4 << 8);  ///< Indicates the support for Writeback addressing modes
        constexpr uint32_t BARRIER_INSTRS = (4 << 16);  ///< Indicates the supported Barrier instructions
        constexpr uint32_t SYNCHPRIM_INSTRS_FRAC = (4 << 20);  ///< Together with the ID_ISAR3[SYNCHPRIM_INSTRS] indicates the supported Synchronization Primitives
        constexpr uint32_t PSR_M_INSTRS = (4 << 24);  ///< Indicates the supported M profile instructions to modify the PSRs
    }

    /// CLIDR Register bits
    namespace clidr_bits {
        constexpr uint32_t CL1 = (3 << 0);  ///< Indicate the type of cache implemented at level 1.
        constexpr uint32_t CL2 = (3 << 3);  ///< Indicate the type of cache implemented at level 2.
        constexpr uint32_t CL3 = (3 << 6);  ///< Indicate the type of cache implemented at level 3.
        constexpr uint32_t CL4 = (3 << 9);  ///< Indicate the type of cache implemented at level 4.
        constexpr uint32_t CL5 = (3 << 12);  ///< Indicate the type of cache implemented at level 5.
        constexpr uint32_t CL6 = (3 << 15);  ///< Indicate the type of cache implemented at level 6.
        constexpr uint32_t CL7 = (3 << 18);  ///< Indicate the type of cache implemented at level 7.
        constexpr uint32_t LOUIS = (3 << 21);  ///< Level of Unification Inner Shareable for the cache hierarchy. This field is RAZ.
        constexpr uint32_t LOC = (3 << 24);  ///< Level of Coherency for the cache hierarchy
        constexpr uint32_t LOU = (3 << 27);  ///< Level of Unification for the cache hierarchy
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t IMINLINE = (4 << 0);  ///< Log2 of the number of words in the smallest cache line of all the instruction caches that are controlled by the processor.
        constexpr uint32_t DMINLINE = (4 << 16);  ///< Log2 of the number of words in the smallest cache line of all the data caches and unified caches that are controlled by the processor.
        constexpr uint32_t ERG = (4 << 20);  ///< Exclusives Reservation Granule. The maximum size of the reservation granule that has been implemented for the Load-Exclusive and Store-Exclusive instructions, encoded as Log2 of the number of words.
        constexpr uint32_t CWG = (4 << 24);  ///< Cache Write-back Granule. The maximum size of memory that can be overwritten as a result of the eviction of a cache entry that has had a memory location in it modified, encoded as Log2 of the number of words.
        constexpr uint32_t FORMAT = (3 << 29);  ///< Indicates the implemented CTR format.
    }

    /// CCSIDR Register bits
    namespace ccsidr_bits {
        constexpr uint32_t LINESIZE = (3 << 0);  ///< (Log2(Number of words in cache line)) - 2.
        constexpr uint32_t ASSOCIATIVITY = (10 << 3);  ///< (Associativity of cache) - 1, therefore a value of 0 indicates an associativity of 1. The associativity does not have to be a power of 2.
        constexpr uint32_t NUMSETS = (15 << 13);  ///< (Number of sets in cache) - 1, therefore a value of 0 indicates 1 set in the cache. The number of sets does not have to be a power of 2.
        constexpr uint32_t WA = (1U << 28);  ///< Indicates whether the cache level supports write-allocation
        constexpr uint32_t RA = (1U << 29);  ///< Indicates whether the cache level supports read-allocation
        constexpr uint32_t WB = (1U << 30);  ///< Indicates whether the cache level supports write-back
        constexpr uint32_t WT = (1U << 31);  ///< Indicates whether the cache level supports write-through
    }

    /// CSSELR Register bits
    namespace csselr_bits {
        constexpr uint32_t IND = (1U << 0);  ///< Instruction not data bit
        constexpr uint32_t LEVEL = (3 << 1);  ///< Cache level of required cache
    }

    /// CPACR Register bits
    namespace cpacr_bits {
        constexpr uint32_t CP0 = (2 << 0);  ///< Access privileges for coprocessor 0.
        constexpr uint32_t CP1 = (2 << 2);  ///< Access privileges for coprocessor 1.
        constexpr uint32_t CP2 = (2 << 4);  ///< Access privileges for coprocessor 2.
        constexpr uint32_t CP3 = (2 << 6);  ///< Access privileges for coprocessor 3.
        constexpr uint32_t CP4 = (2 << 8);  ///< Access privileges for coprocessor 4.
        constexpr uint32_t CP5 = (2 << 10);  ///< Access privileges for coprocessor 5.
        constexpr uint32_t CP6 = (2 << 12);  ///< Access privileges for coprocessor 6.
        constexpr uint32_t CP7 = (2 << 14);  ///< Access privileges for coprocessor 7.
        constexpr uint32_t CP10 = (2 << 20);  ///< Access privileges for coprocessor 10.
        constexpr uint32_t CP11 = (2 << 22);  ///< Access privileges for coprocessor 11.
    }

    /// STIR Register bits
    namespace stir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< Indicates the interrupt to be triggered
    }

    /// ICIALLU Register bits
    namespace iciallu_bits {
        constexpr uint32_t ICIALLU = (32 << 0);  ///< I-cache invalidate all to PoU
    }

    /// ICIMVAU Register bits
    namespace icimvau_bits {
        constexpr uint32_t ICIMVAU = (32 << 0);  ///< I-cache invalidate by MVA to PoU
    }

    /// DCIMVAC Register bits
    namespace dcimvac_bits {
        constexpr uint32_t DCIMVAC = (32 << 0);  ///< D-cache invalidate by MVA to PoC
    }

    /// DCISW Register bits
    namespace dcisw_bits {
        constexpr uint32_t DCISW = (32 << 0);  ///< D-cache invalidate by set-way
    }

    /// DCCMVAU Register bits
    namespace dccmvau_bits {
        constexpr uint32_t DCCMVAU = (32 << 0);  ///< D-cache clean by MVA to PoU
    }

    /// DCCMVAC Register bits
    namespace dccmvac_bits {
        constexpr uint32_t DCCMVAC = (32 << 0);  ///< D-cache clean by MVA to PoC
    }

    /// DCCSW Register bits
    namespace dccsw_bits {
        constexpr uint32_t DCCSW = (32 << 0);  ///< D-cache clean by set-way
    }

    /// DCCIMVAC Register bits
    namespace dccimvac_bits {
        constexpr uint32_t DCCIMVAC = (32 << 0);  ///< D-cache clean and invalidate by MVA to PoC
    }

    /// DCCISW Register bits
    namespace dccisw_bits {
        constexpr uint32_t DCCISW = (32 << 0);  ///< D-cache clean and invalidate by set-way
    }

    /// CM7_ITCMCR Register bits
    namespace cm7_itcmcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< TCM enable. When a TCM is disabled all accesses are made to the AXIM interface.
        constexpr uint32_t RMW = (1U << 1);  ///< Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that are not the full width of the TCM RAM, use a RMW sequence.
        constexpr uint32_t RETEN = (1U << 2);  ///< Retry phase enable. When enabled the processor guarantees to honor the retry output on the corresponding TCM interface, re-executing the instruction which carried out the TCM access.
        constexpr uint32_t SZ = (4 << 3);  ///< TCM size. Indicates the size of the relevant TCM.
    }

    /// CM7_DTCMCR Register bits
    namespace cm7_dtcmcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< TCM enable. When a TCM is disabled all accesses are made to the AXIM interface.
        constexpr uint32_t RMW = (1U << 1);  ///< Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that are not the full width of the TCM RAM, use a RMW sequence.
        constexpr uint32_t RETEN = (1U << 2);  ///< Retry phase enable. When enabled the processor guarantees to honor the retry output on the corresponding TCM interface, re-executing the instruction which carried out the TCM access.
        constexpr uint32_t SZ = (4 << 3);  ///< TCM size. Indicates the size of the relevant TCM.
    }

    /// CM7_AHBPCR Register bits
    namespace cm7_ahbpcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< AHBP enable.
        constexpr uint32_t SZ = (3 << 1);  ///< AHBP size.
    }

    /// CM7_CACR Register bits
    namespace cm7_cacr_bits {
        constexpr uint32_t SIWT = (1U << 0);  ///< Shared cacheable-is-WT for data cache. Enables limited cache coherency usage.
        constexpr uint32_t ECCDIS = (1U << 1);  ///< Enables ECC in the instruction and data cache.
        constexpr uint32_t FORCEWT = (1U << 2);  ///< Enables Force Write-Through in the data cache.
    }

    /// CM7_AHBSCR Register bits
    namespace cm7_ahbscr_bits {
        constexpr uint32_t CTL = (2 << 0);  ///< AHBS prioritization control.
        constexpr uint32_t TPRI = (9 << 2);  ///< Threshold execution priority for AHBS traffic demotion.
        constexpr uint32_t INITCOUNT = (5 << 11);  ///< Fairness counter initialization value.
    }

    /// CM7_ABFSR Register bits
    namespace cm7_abfsr_bits {
        constexpr uint32_t ITCM = (1U << 0);  ///< Asynchronous fault on ITCM interface.
        constexpr uint32_t DTCM = (1U << 1);  ///< Asynchronous fault on DTCM interface.
        constexpr uint32_t AHBP = (1U << 2);  ///< Asynchronous fault on AHBP interface.
        constexpr uint32_t AXIM = (1U << 3);  ///< Asynchronous fault on AXIM interface.
        constexpr uint32_t EPPB = (1U << 4);  ///< Asynchronous fault on EPPB interface.
        constexpr uint32_t AXIMTYPE = (2 << 8);  ///< Indicates the type of fault on the AXIM interface. Only valid when AXIM is 1.
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t NVICISER0;  ///< Offset: 0x00 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER1;  ///< Offset: 0x04 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER2;  ///< Offset: 0x08 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER3;  ///< Offset: 0x0C - Interrupt Set Enable Register n
        volatile uint32_t NVICISER4;  ///< Offset: 0x10 - Interrupt Set Enable Register n
        volatile uint32_t NVICICER0;  ///< Offset: 0x80 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER1;  ///< Offset: 0x84 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER2;  ///< Offset: 0x88 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER3;  ///< Offset: 0x8C - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER4;  ///< Offset: 0x90 - Interrupt Clear Enable Register n
        volatile uint32_t NVICISPR0;  ///< Offset: 0x100 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR1;  ///< Offset: 0x104 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR2;  ///< Offset: 0x108 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR3;  ///< Offset: 0x10C - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR4;  ///< Offset: 0x110 - Interrupt Set Pending Register n
        volatile uint32_t NVICICPR0;  ///< Offset: 0x180 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR1;  ///< Offset: 0x184 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR2;  ///< Offset: 0x188 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR3;  ///< Offset: 0x18C - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR4;  ///< Offset: 0x190 - Interrupt Clear Pending Register n
        volatile uint32_t NVICIABR0;  ///< Offset: 0x200 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR1;  ///< Offset: 0x204 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR2;  ///< Offset: 0x208 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR3;  ///< Offset: 0x20C - Interrupt Active bit Register n
        volatile uint32_t NVICIABR4;  ///< Offset: 0x210 - Interrupt Active bit Register n
        volatile uint32_t NVICIP0;  ///< Offset: 0x300 - Interrupt Priority Register 0
        volatile uint32_t NVICIP1;  ///< Offset: 0x301 - Interrupt Priority Register 1
        volatile uint32_t NVICIP2;  ///< Offset: 0x302 - Interrupt Priority Register 2
        volatile uint32_t NVICIP3;  ///< Offset: 0x303 - Interrupt Priority Register 3
        volatile uint32_t NVICIP4;  ///< Offset: 0x304 - Interrupt Priority Register 4
        volatile uint32_t NVICIP5;  ///< Offset: 0x305 - Interrupt Priority Register 5
        volatile uint32_t NVICIP6;  ///< Offset: 0x306 - Interrupt Priority Register 6
        volatile uint32_t NVICIP7;  ///< Offset: 0x307 - Interrupt Priority Register 7
        volatile uint32_t NVICIP8;  ///< Offset: 0x308 - Interrupt Priority Register 8
        volatile uint32_t NVICIP9;  ///< Offset: 0x309 - Interrupt Priority Register 9
        volatile uint32_t NVICIP10;  ///< Offset: 0x30A - Interrupt Priority Register 10
        volatile uint32_t NVICIP11;  ///< Offset: 0x30B - Interrupt Priority Register 11
        volatile uint32_t NVICIP12;  ///< Offset: 0x30C - Interrupt Priority Register 12
        volatile uint32_t NVICIP13;  ///< Offset: 0x30D - Interrupt Priority Register 13
        volatile uint32_t NVICIP14;  ///< Offset: 0x30E - Interrupt Priority Register 14
        volatile uint32_t NVICIP15;  ///< Offset: 0x30F - Interrupt Priority Register 15
        volatile uint32_t NVICIP16;  ///< Offset: 0x310 - Interrupt Priority Register 16
        volatile uint32_t NVICIP17;  ///< Offset: 0x311 - Interrupt Priority Register 17
        volatile uint32_t NVICIP18;  ///< Offset: 0x312 - Interrupt Priority Register 18
        volatile uint32_t NVICIP19;  ///< Offset: 0x313 - Interrupt Priority Register 19
        volatile uint32_t NVICIP20;  ///< Offset: 0x314 - Interrupt Priority Register 20
        volatile uint32_t NVICIP21;  ///< Offset: 0x315 - Interrupt Priority Register 21
        volatile uint32_t NVICIP22;  ///< Offset: 0x316 - Interrupt Priority Register 22
        volatile uint32_t NVICIP23;  ///< Offset: 0x317 - Interrupt Priority Register 23
        volatile uint32_t NVICIP24;  ///< Offset: 0x318 - Interrupt Priority Register 24
        volatile uint32_t NVICIP25;  ///< Offset: 0x319 - Interrupt Priority Register 25
        volatile uint32_t NVICIP26;  ///< Offset: 0x31A - Interrupt Priority Register 26
        volatile uint32_t NVICIP27;  ///< Offset: 0x31B - Interrupt Priority Register 27
        volatile uint32_t NVICIP28;  ///< Offset: 0x31C - Interrupt Priority Register 28
        volatile uint32_t NVICIP29;  ///< Offset: 0x31D - Interrupt Priority Register 29
        volatile uint32_t NVICIP30;  ///< Offset: 0x31E - Interrupt Priority Register 30
        volatile uint32_t NVICIP31;  ///< Offset: 0x31F - Interrupt Priority Register 31
        volatile uint32_t NVICIP32;  ///< Offset: 0x320 - Interrupt Priority Register 32
        volatile uint32_t NVICIP33;  ///< Offset: 0x321 - Interrupt Priority Register 33
        volatile uint32_t NVICIP34;  ///< Offset: 0x322 - Interrupt Priority Register 34
        volatile uint32_t NVICIP35;  ///< Offset: 0x323 - Interrupt Priority Register 35
        volatile uint32_t NVICIP36;  ///< Offset: 0x324 - Interrupt Priority Register 36
        volatile uint32_t NVICIP37;  ///< Offset: 0x325 - Interrupt Priority Register 37
        volatile uint32_t NVICIP38;  ///< Offset: 0x326 - Interrupt Priority Register 38
        volatile uint32_t NVICIP39;  ///< Offset: 0x327 - Interrupt Priority Register 39
        volatile uint32_t NVICIP40;  ///< Offset: 0x328 - Interrupt Priority Register 40
        volatile uint32_t NVICIP41;  ///< Offset: 0x329 - Interrupt Priority Register 41
        volatile uint32_t NVICIP42;  ///< Offset: 0x32A - Interrupt Priority Register 42
        volatile uint32_t NVICIP43;  ///< Offset: 0x32B - Interrupt Priority Register 43
        volatile uint32_t NVICIP44;  ///< Offset: 0x32C - Interrupt Priority Register 44
        volatile uint32_t NVICIP45;  ///< Offset: 0x32D - Interrupt Priority Register 45
        volatile uint32_t NVICIP46;  ///< Offset: 0x32E - Interrupt Priority Register 46
        volatile uint32_t NVICIP47;  ///< Offset: 0x32F - Interrupt Priority Register 47
        volatile uint32_t NVICIP48;  ///< Offset: 0x330 - Interrupt Priority Register 48
        volatile uint32_t NVICIP49;  ///< Offset: 0x331 - Interrupt Priority Register 49
        volatile uint32_t NVICIP50;  ///< Offset: 0x332 - Interrupt Priority Register 50
        volatile uint32_t NVICIP51;  ///< Offset: 0x333 - Interrupt Priority Register 51
        volatile uint32_t NVICIP52;  ///< Offset: 0x334 - Interrupt Priority Register 52
        volatile uint32_t NVICIP53;  ///< Offset: 0x335 - Interrupt Priority Register 53
        volatile uint32_t NVICIP54;  ///< Offset: 0x336 - Interrupt Priority Register 54
        volatile uint32_t NVICIP55;  ///< Offset: 0x337 - Interrupt Priority Register 55
        volatile uint32_t NVICIP56;  ///< Offset: 0x338 - Interrupt Priority Register 56
        volatile uint32_t NVICIP57;  ///< Offset: 0x339 - Interrupt Priority Register 57
        volatile uint32_t NVICIP58;  ///< Offset: 0x33A - Interrupt Priority Register 58
        volatile uint32_t NVICIP59;  ///< Offset: 0x33B - Interrupt Priority Register 59
        volatile uint32_t NVICIP60;  ///< Offset: 0x33C - Interrupt Priority Register 60
        volatile uint32_t NVICIP61;  ///< Offset: 0x33D - Interrupt Priority Register 61
        volatile uint32_t NVICIP62;  ///< Offset: 0x33E - Interrupt Priority Register 62
        volatile uint32_t NVICIP63;  ///< Offset: 0x33F - Interrupt Priority Register 63
        volatile uint32_t NVICIP64;  ///< Offset: 0x340 - Interrupt Priority Register 64
        volatile uint32_t NVICIP65;  ///< Offset: 0x341 - Interrupt Priority Register 65
        volatile uint32_t NVICIP66;  ///< Offset: 0x342 - Interrupt Priority Register 66
        volatile uint32_t NVICIP67;  ///< Offset: 0x343 - Interrupt Priority Register 67
        volatile uint32_t NVICIP68;  ///< Offset: 0x344 - Interrupt Priority Register 68
        volatile uint32_t NVICIP69;  ///< Offset: 0x345 - Interrupt Priority Register 69
        volatile uint32_t NVICIP70;  ///< Offset: 0x346 - Interrupt Priority Register 70
        volatile uint32_t NVICIP71;  ///< Offset: 0x347 - Interrupt Priority Register 71
        volatile uint32_t NVICIP72;  ///< Offset: 0x348 - Interrupt Priority Register 72
        volatile uint32_t NVICIP73;  ///< Offset: 0x349 - Interrupt Priority Register 73
        volatile uint32_t NVICIP74;  ///< Offset: 0x34A - Interrupt Priority Register 74
        volatile uint32_t NVICIP75;  ///< Offset: 0x34B - Interrupt Priority Register 75
        volatile uint32_t NVICIP76;  ///< Offset: 0x34C - Interrupt Priority Register 76
        volatile uint32_t NVICIP77;  ///< Offset: 0x34D - Interrupt Priority Register 77
        volatile uint32_t NVICIP78;  ///< Offset: 0x34E - Interrupt Priority Register 78
        volatile uint32_t NVICIP79;  ///< Offset: 0x34F - Interrupt Priority Register 79
        volatile uint32_t NVICIP80;  ///< Offset: 0x350 - Interrupt Priority Register 80
        volatile uint32_t NVICIP81;  ///< Offset: 0x351 - Interrupt Priority Register 81
        volatile uint32_t NVICIP82;  ///< Offset: 0x352 - Interrupt Priority Register 82
        volatile uint32_t NVICIP83;  ///< Offset: 0x353 - Interrupt Priority Register 83
        volatile uint32_t NVICIP84;  ///< Offset: 0x354 - Interrupt Priority Register 84
        volatile uint32_t NVICIP85;  ///< Offset: 0x355 - Interrupt Priority Register 85
        volatile uint32_t NVICIP86;  ///< Offset: 0x356 - Interrupt Priority Register 86
        volatile uint32_t NVICIP87;  ///< Offset: 0x357 - Interrupt Priority Register 87
        volatile uint32_t NVICIP88;  ///< Offset: 0x358 - Interrupt Priority Register 88
        volatile uint32_t NVICIP89;  ///< Offset: 0x359 - Interrupt Priority Register 89
        volatile uint32_t NVICIP90;  ///< Offset: 0x35A - Interrupt Priority Register 90
        volatile uint32_t NVICIP91;  ///< Offset: 0x35B - Interrupt Priority Register 91
        volatile uint32_t NVICIP92;  ///< Offset: 0x35C - Interrupt Priority Register 92
        volatile uint32_t NVICIP93;  ///< Offset: 0x35D - Interrupt Priority Register 93
        volatile uint32_t NVICIP94;  ///< Offset: 0x35E - Interrupt Priority Register 94
        volatile uint32_t NVICIP95;  ///< Offset: 0x35F - Interrupt Priority Register 95
        volatile uint32_t NVICIP96;  ///< Offset: 0x360 - Interrupt Priority Register 96
        volatile uint32_t NVICIP97;  ///< Offset: 0x361 - Interrupt Priority Register 97
        volatile uint32_t NVICIP98;  ///< Offset: 0x362 - Interrupt Priority Register 98
        volatile uint32_t NVICIP99;  ///< Offset: 0x363 - Interrupt Priority Register 99
        volatile uint32_t NVICIP100;  ///< Offset: 0x364 - Interrupt Priority Register 100
        volatile uint32_t NVICIP101;  ///< Offset: 0x365 - Interrupt Priority Register 101
        volatile uint32_t NVICIP102;  ///< Offset: 0x366 - Interrupt Priority Register 102
        volatile uint32_t NVICIP103;  ///< Offset: 0x367 - Interrupt Priority Register 103
        volatile uint32_t NVICIP104;  ///< Offset: 0x368 - Interrupt Priority Register 104
        volatile uint32_t NVICIP105;  ///< Offset: 0x369 - Interrupt Priority Register 105
        volatile uint32_t NVICIP106;  ///< Offset: 0x36A - Interrupt Priority Register 106
        volatile uint32_t NVICIP107;  ///< Offset: 0x36B - Interrupt Priority Register 107
        volatile uint32_t NVICIP108;  ///< Offset: 0x36C - Interrupt Priority Register 108
        volatile uint32_t NVICIP109;  ///< Offset: 0x36D - Interrupt Priority Register 109
        volatile uint32_t NVICIP110;  ///< Offset: 0x36E - Interrupt Priority Register 110
        volatile uint32_t NVICIP111;  ///< Offset: 0x36F - Interrupt Priority Register 111
        volatile uint32_t NVICIP112;  ///< Offset: 0x370 - Interrupt Priority Register 112
        volatile uint32_t NVICIP113;  ///< Offset: 0x371 - Interrupt Priority Register 113
        volatile uint32_t NVICIP114;  ///< Offset: 0x372 - Interrupt Priority Register 114
        volatile uint32_t NVICIP115;  ///< Offset: 0x373 - Interrupt Priority Register 115
        volatile uint32_t NVICIP116;  ///< Offset: 0x374 - Interrupt Priority Register 116
        volatile uint32_t NVICIP117;  ///< Offset: 0x375 - Interrupt Priority Register 117
        volatile uint32_t NVICIP118;  ///< Offset: 0x376 - Interrupt Priority Register 118
        volatile uint32_t NVICIP119;  ///< Offset: 0x377 - Interrupt Priority Register 119
        volatile uint32_t NVICIP120;  ///< Offset: 0x378 - Interrupt Priority Register 120
        volatile uint32_t NVICIP121;  ///< Offset: 0x379 - Interrupt Priority Register 121
        volatile uint32_t NVICIP122;  ///< Offset: 0x37A - Interrupt Priority Register 122
        volatile uint32_t NVICIP123;  ///< Offset: 0x37B - Interrupt Priority Register 123
        volatile uint32_t NVICIP124;  ///< Offset: 0x37C - Interrupt Priority Register 124
        volatile uint32_t NVICIP125;  ///< Offset: 0x37D - Interrupt Priority Register 125
        volatile uint32_t NVICIP126;  ///< Offset: 0x37E - Interrupt Priority Register 126
        volatile uint32_t NVICIP127;  ///< Offset: 0x37F - Interrupt Priority Register 127
        volatile uint32_t NVICIP128;  ///< Offset: 0x380 - Interrupt Priority Register 128
        volatile uint32_t NVICIP129;  ///< Offset: 0x381 - Interrupt Priority Register 129
        volatile uint32_t NVICIP130;  ///< Offset: 0x382 - Interrupt Priority Register 130
        volatile uint32_t NVICIP131;  ///< Offset: 0x383 - Interrupt Priority Register 131
        volatile uint32_t NVICIP132;  ///< Offset: 0x384 - Interrupt Priority Register 132
        volatile uint32_t NVICIP133;  ///< Offset: 0x385 - Interrupt Priority Register 133
        volatile uint32_t NVICIP134;  ///< Offset: 0x386 - Interrupt Priority Register 134
        volatile uint32_t NVICIP135;  ///< Offset: 0x387 - Interrupt Priority Register 135
        volatile uint32_t NVICIP136;  ///< Offset: 0x388 - Interrupt Priority Register 136
        volatile uint32_t NVICIP137;  ///< Offset: 0x389 - Interrupt Priority Register 137
        volatile uint32_t NVICIP138;  ///< Offset: 0x38A - Interrupt Priority Register 138
        volatile uint32_t NVICIP139;  ///< Offset: 0x38B - Interrupt Priority Register 139
        volatile uint32_t NVICIP140;  ///< Offset: 0x38C - Interrupt Priority Register 140
        volatile uint32_t NVICIP141;  ///< Offset: 0x38D - Interrupt Priority Register 141
        volatile uint32_t NVICIP142;  ///< Offset: 0x38E - Interrupt Priority Register 142
        volatile uint32_t NVICIP143;  ///< Offset: 0x38F - Interrupt Priority Register 143
        volatile uint32_t NVICIP144;  ///< Offset: 0x390 - Interrupt Priority Register 144
        volatile uint32_t NVICIP145;  ///< Offset: 0x391 - Interrupt Priority Register 145
        volatile uint32_t NVICIP146;  ///< Offset: 0x392 - Interrupt Priority Register 146
        volatile uint32_t NVICIP147;  ///< Offset: 0x393 - Interrupt Priority Register 147
        volatile uint32_t NVICIP148;  ///< Offset: 0x394 - Interrupt Priority Register 148
        volatile uint32_t NVICIP149;  ///< Offset: 0x395 - Interrupt Priority Register 149
        volatile uint32_t NVICIP150;  ///< Offset: 0x396 - Interrupt Priority Register 150
        volatile uint32_t NVICIP151;  ///< Offset: 0x397 - Interrupt Priority Register 151
        volatile uint32_t NVICIP152;  ///< Offset: 0x398 - Interrupt Priority Register 152
        volatile uint32_t NVICIP153;  ///< Offset: 0x399 - Interrupt Priority Register 153
        volatile uint32_t NVICIP154;  ///< Offset: 0x39A - Interrupt Priority Register 154
        volatile uint32_t NVICIP155;  ///< Offset: 0x39B - Interrupt Priority Register 155
        volatile uint32_t NVICIP156;  ///< Offset: 0x39C - Interrupt Priority Register 156
        volatile uint32_t NVICIP157;  ///< Offset: 0x39D - Interrupt Priority Register 157
        volatile uint32_t NVICSTIR;  ///< Offset: 0xE00 - Software Trigger Interrupt Register
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

    // Bit definitions
    /// NVICISER0 Register bits
    namespace nviciser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER1 Register bits
    namespace nviciser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER2 Register bits
    namespace nviciser2_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER3 Register bits
    namespace nviciser3_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER4 Register bits
    namespace nviciser4_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICICER0 Register bits
    namespace nvicicer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER1 Register bits
    namespace nvicicer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER2 Register bits
    namespace nvicicer2_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER3 Register bits
    namespace nvicicer3_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER4 Register bits
    namespace nvicicer4_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICISPR0 Register bits
    namespace nvicispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR1 Register bits
    namespace nvicispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR2 Register bits
    namespace nvicispr2_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR3 Register bits
    namespace nvicispr3_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR4 Register bits
    namespace nvicispr4_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICICPR0 Register bits
    namespace nvicicpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR1 Register bits
    namespace nvicicpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR2 Register bits
    namespace nvicicpr2_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR3 Register bits
    namespace nvicicpr3_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR4 Register bits
    namespace nvicicpr4_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICIABR0 Register bits
    namespace nviciabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR1 Register bits
    namespace nviciabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR2 Register bits
    namespace nviciabr2_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR3 Register bits
    namespace nviciabr3_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR4 Register bits
    namespace nviciabr4_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIP0 Register bits
    namespace nvicip0_bits {
        constexpr uint32_t PRI0 = (4 << 4);  ///< Priority of the INT_DMA0_DMA16 interrupt 0
    }

    /// NVICIP1 Register bits
    namespace nvicip1_bits {
        constexpr uint32_t PRI1 = (4 << 4);  ///< Priority of the INT_DMA1_DMA17 interrupt 1
    }

    /// NVICIP2 Register bits
    namespace nvicip2_bits {
        constexpr uint32_t PRI2 = (4 << 4);  ///< Priority of the INT_DMA2_DMA18 interrupt 2
    }

    /// NVICIP3 Register bits
    namespace nvicip3_bits {
        constexpr uint32_t PRI3 = (4 << 4);  ///< Priority of the INT_DMA3_DMA19 interrupt 3
    }

    /// NVICIP4 Register bits
    namespace nvicip4_bits {
        constexpr uint32_t PRI4 = (4 << 4);  ///< Priority of the INT_DMA4_DMA20 interrupt 4
    }

    /// NVICIP5 Register bits
    namespace nvicip5_bits {
        constexpr uint32_t PRI5 = (4 << 4);  ///< Priority of the INT_DMA5_DMA21 interrupt 5
    }

    /// NVICIP6 Register bits
    namespace nvicip6_bits {
        constexpr uint32_t PRI6 = (4 << 4);  ///< Priority of the INT_DMA6_DMA22 interrupt 6
    }

    /// NVICIP7 Register bits
    namespace nvicip7_bits {
        constexpr uint32_t PRI7 = (4 << 4);  ///< Priority of the INT_DMA7_DMA23 interrupt 7
    }

    /// NVICIP8 Register bits
    namespace nvicip8_bits {
        constexpr uint32_t PRI8 = (4 << 4);  ///< Priority of the INT_DMA8_DMA24 interrupt 8
    }

    /// NVICIP9 Register bits
    namespace nvicip9_bits {
        constexpr uint32_t PRI9 = (4 << 4);  ///< Priority of the INT_DMA9_DMA25 interrupt 9
    }

    /// NVICIP10 Register bits
    namespace nvicip10_bits {
        constexpr uint32_t PRI10 = (4 << 4);  ///< Priority of the INT_DMA10_DMA26 interrupt 10
    }

    /// NVICIP11 Register bits
    namespace nvicip11_bits {
        constexpr uint32_t PRI11 = (4 << 4);  ///< Priority of the INT_DMA11_DMA27 interrupt 11
    }

    /// NVICIP12 Register bits
    namespace nvicip12_bits {
        constexpr uint32_t PRI12 = (4 << 4);  ///< Priority of the INT_DMA12_DMA28 interrupt 12
    }

    /// NVICIP13 Register bits
    namespace nvicip13_bits {
        constexpr uint32_t PRI13 = (4 << 4);  ///< Priority of the INT_DMA13_DMA29 interrupt 13
    }

    /// NVICIP14 Register bits
    namespace nvicip14_bits {
        constexpr uint32_t PRI14 = (4 << 4);  ///< Priority of the INT_DMA14_DMA30 interrupt 14
    }

    /// NVICIP15 Register bits
    namespace nvicip15_bits {
        constexpr uint32_t PRI15 = (4 << 4);  ///< Priority of the INT_DMA15_DMA31 interrupt 15
    }

    /// NVICIP16 Register bits
    namespace nvicip16_bits {
        constexpr uint32_t PRI16 = (4 << 4);  ///< Priority of the INT_DMA_ERROR interrupt 16
    }

    /// NVICIP17 Register bits
    namespace nvicip17_bits {
        constexpr uint32_t PRI17 = (4 << 4);  ///< Priority of the INT_CTI0_ERROR interrupt 17
    }

    /// NVICIP18 Register bits
    namespace nvicip18_bits {
        constexpr uint32_t PRI18 = (4 << 4);  ///< Priority of the INT_CTI1_ERROR interrupt 18
    }

    /// NVICIP19 Register bits
    namespace nvicip19_bits {
        constexpr uint32_t PRI19 = (4 << 4);  ///< Priority of the INT_CORE interrupt 19
    }

    /// NVICIP20 Register bits
    namespace nvicip20_bits {
        constexpr uint32_t PRI20 = (4 << 4);  ///< Priority of the INT_LPUART1 interrupt 20
    }

    /// NVICIP21 Register bits
    namespace nvicip21_bits {
        constexpr uint32_t PRI21 = (4 << 4);  ///< Priority of the INT_LPUART2 interrupt 21
    }

    /// NVICIP22 Register bits
    namespace nvicip22_bits {
        constexpr uint32_t PRI22 = (4 << 4);  ///< Priority of the INT_LPUART3 interrupt 22
    }

    /// NVICIP23 Register bits
    namespace nvicip23_bits {
        constexpr uint32_t PRI23 = (4 << 4);  ///< Priority of the INT_LPUART4 interrupt 23
    }

    /// NVICIP24 Register bits
    namespace nvicip24_bits {
        constexpr uint32_t PRI24 = (4 << 4);  ///< Priority of the INT_LPUART5 interrupt 24
    }

    /// NVICIP25 Register bits
    namespace nvicip25_bits {
        constexpr uint32_t PRI25 = (4 << 4);  ///< Priority of the INT_LPUART6 interrupt 25
    }

    /// NVICIP26 Register bits
    namespace nvicip26_bits {
        constexpr uint32_t PRI26 = (4 << 4);  ///< Priority of the INT_LPUART7 interrupt 26
    }

    /// NVICIP27 Register bits
    namespace nvicip27_bits {
        constexpr uint32_t PRI27 = (4 << 4);  ///< Priority of the INT_LPUART8 interrupt 27
    }

    /// NVICIP28 Register bits
    namespace nvicip28_bits {
        constexpr uint32_t PRI28 = (4 << 4);  ///< Priority of the INT_LPI2C1 interrupt 28
    }

    /// NVICIP29 Register bits
    namespace nvicip29_bits {
        constexpr uint32_t PRI29 = (4 << 4);  ///< Priority of the INT_LPI2C2 interrupt 29
    }

    /// NVICIP30 Register bits
    namespace nvicip30_bits {
        constexpr uint32_t PRI30 = (4 << 4);  ///< Priority of the INT_LPI2C3 interrupt 30
    }

    /// NVICIP31 Register bits
    namespace nvicip31_bits {
        constexpr uint32_t PRI31 = (4 << 4);  ///< Priority of the INT_LPI2C4 interrupt 31
    }

    /// NVICIP32 Register bits
    namespace nvicip32_bits {
        constexpr uint32_t PRI32 = (4 << 4);  ///< Priority of the INT_LPSPI1 interrupt 32
    }

    /// NVICIP33 Register bits
    namespace nvicip33_bits {
        constexpr uint32_t PRI33 = (4 << 4);  ///< Priority of the INT_LPSPI2 interrupt 33
    }

    /// NVICIP34 Register bits
    namespace nvicip34_bits {
        constexpr uint32_t PRI34 = (4 << 4);  ///< Priority of the INT_LPSPI3 interrupt 34
    }

    /// NVICIP35 Register bits
    namespace nvicip35_bits {
        constexpr uint32_t PRI35 = (4 << 4);  ///< Priority of the INT_LPSPI4 interrupt 35
    }

    /// NVICIP36 Register bits
    namespace nvicip36_bits {
        constexpr uint32_t PRI36 = (4 << 4);  ///< Priority of the INT_CAN1 interrupt 36
    }

    /// NVICIP37 Register bits
    namespace nvicip37_bits {
        constexpr uint32_t PRI37 = (4 << 4);  ///< Priority of the INT_CAN2 interrupt 37
    }

    /// NVICIP38 Register bits
    namespace nvicip38_bits {
        constexpr uint32_t PRI38 = (4 << 4);  ///< Priority of the INT_FLEXRAM interrupt 38
    }

    /// NVICIP39 Register bits
    namespace nvicip39_bits {
        constexpr uint32_t PRI39 = (4 << 4);  ///< Priority of the INT_KPP interrupt 39
    }

    /// NVICIP40 Register bits
    namespace nvicip40_bits {
        constexpr uint32_t PRI40 = (4 << 4);  ///< Priority of the INT_TSC_DIG interrupt 40
    }

    /// NVICIP41 Register bits
    namespace nvicip41_bits {
        constexpr uint32_t PRI41 = (4 << 4);  ///< Priority of the INT_GPR_IRQ interrupt 41
    }

    /// NVICIP42 Register bits
    namespace nvicip42_bits {
        constexpr uint32_t PRI42 = (4 << 4);  ///< Priority of the INT_LCDIF interrupt 42
    }

    /// NVICIP43 Register bits
    namespace nvicip43_bits {
        constexpr uint32_t PRI43 = (4 << 4);  ///< Priority of the INT_CSI interrupt 43
    }

    /// NVICIP44 Register bits
    namespace nvicip44_bits {
        constexpr uint32_t PRI44 = (4 << 4);  ///< Priority of the INT_PXP interrupt 44
    }

    /// NVICIP45 Register bits
    namespace nvicip45_bits {
        constexpr uint32_t PRI45 = (4 << 4);  ///< Priority of the INT_WDOG2 interrupt 45
    }

    /// NVICIP46 Register bits
    namespace nvicip46_bits {
        constexpr uint32_t PRI46 = (4 << 4);  ///< Priority of the INT_SNVS_HP_WRAPPER interrupt 46
    }

    /// NVICIP47 Register bits
    namespace nvicip47_bits {
        constexpr uint32_t PRI47 = (4 << 4);  ///< Priority of the INT_SNVS_HP_WRAPPER_TZ interrupt 47
    }

    /// NVICIP48 Register bits
    namespace nvicip48_bits {
        constexpr uint32_t PRI48 = (4 << 4);  ///< Priority of the INT_SNVS_LP_WRAPPER interrupt 48
    }

    /// NVICIP49 Register bits
    namespace nvicip49_bits {
        constexpr uint32_t PRI49 = (4 << 4);  ///< Priority of the INT_CSU interrupt 49
    }

    /// NVICIP50 Register bits
    namespace nvicip50_bits {
        constexpr uint32_t PRI50 = (4 << 4);  ///< Priority of the INT_DCP interrupt 50
    }

    /// NVICIP51 Register bits
    namespace nvicip51_bits {
        constexpr uint32_t PRI51 = (4 << 4);  ///< Priority of the INT_DCP_VMI interrupt 51
    }

    /// NVICIP52 Register bits
    namespace nvicip52_bits {
        constexpr uint32_t PRI52 = (4 << 4);  ///< Priority of the INT_Reserved68 interrupt 52
    }

    /// NVICIP53 Register bits
    namespace nvicip53_bits {
        constexpr uint32_t PRI53 = (4 << 4);  ///< Priority of the INT_TRNG interrupt 53
    }

    /// NVICIP54 Register bits
    namespace nvicip54_bits {
        constexpr uint32_t PRI54 = (4 << 4);  ///< Priority of the INT_SJC interrupt 54
    }

    /// NVICIP55 Register bits
    namespace nvicip55_bits {
        constexpr uint32_t PRI55 = (4 << 4);  ///< Priority of the INT_BEE interrupt 55
    }

    /// NVICIP56 Register bits
    namespace nvicip56_bits {
        constexpr uint32_t PRI56 = (4 << 4);  ///< Priority of the INT_SAI1 interrupt 56
    }

    /// NVICIP57 Register bits
    namespace nvicip57_bits {
        constexpr uint32_t PRI57 = (4 << 4);  ///< Priority of the INT_SAI2 interrupt 57
    }

    /// NVICIP58 Register bits
    namespace nvicip58_bits {
        constexpr uint32_t PRI58 = (4 << 4);  ///< Priority of the INT_SAI3_RX interrupt 58
    }

    /// NVICIP59 Register bits
    namespace nvicip59_bits {
        constexpr uint32_t PRI59 = (4 << 4);  ///< Priority of the INT_SAI3_TX interrupt 59
    }

    /// NVICIP60 Register bits
    namespace nvicip60_bits {
        constexpr uint32_t PRI60 = (4 << 4);  ///< Priority of the INT_SPDIF interrupt 60
    }

    /// NVICIP61 Register bits
    namespace nvicip61_bits {
        constexpr uint32_t PRI61 = (4 << 4);  ///< Priority of the INT_PMU_EVENT interrupt 61
    }

    /// NVICIP62 Register bits
    namespace nvicip62_bits {
        constexpr uint32_t PRI62 = (4 << 4);  ///< Priority of the INT_Reserved78 interrupt 62
    }

    /// NVICIP63 Register bits
    namespace nvicip63_bits {
        constexpr uint32_t PRI63 = (4 << 4);  ///< Priority of the INT_TEMP_LOW_HIGH interrupt 63
    }

    /// NVICIP64 Register bits
    namespace nvicip64_bits {
        constexpr uint32_t PRI64 = (4 << 4);  ///< Priority of the INT_TEMP_PANIC interrupt 64
    }

    /// NVICIP65 Register bits
    namespace nvicip65_bits {
        constexpr uint32_t PRI65 = (4 << 4);  ///< Priority of the INT_USB_PHY1 interrupt 65
    }

    /// NVICIP66 Register bits
    namespace nvicip66_bits {
        constexpr uint32_t PRI66 = (4 << 4);  ///< Priority of the INT_USB_PHY2 interrupt 66
    }

    /// NVICIP67 Register bits
    namespace nvicip67_bits {
        constexpr uint32_t PRI67 = (4 << 4);  ///< Priority of the INT_ADC1 interrupt 67
    }

    /// NVICIP68 Register bits
    namespace nvicip68_bits {
        constexpr uint32_t PRI68 = (4 << 4);  ///< Priority of the INT_ADC2 interrupt 68
    }

    /// NVICIP69 Register bits
    namespace nvicip69_bits {
        constexpr uint32_t PRI69 = (4 << 4);  ///< Priority of the INT_DCDC interrupt 69
    }

    /// NVICIP70 Register bits
    namespace nvicip70_bits {
        constexpr uint32_t PRI70 = (4 << 4);  ///< Priority of the INT_Reserved86 interrupt 70
    }

    /// NVICIP71 Register bits
    namespace nvicip71_bits {
        constexpr uint32_t PRI71 = (4 << 4);  ///< Priority of the INT_Reserved87 interrupt 71
    }

    /// NVICIP72 Register bits
    namespace nvicip72_bits {
        constexpr uint32_t PRI72 = (4 << 4);  ///< Priority of the INT_GPIO1_INT0 interrupt 72
    }

    /// NVICIP73 Register bits
    namespace nvicip73_bits {
        constexpr uint32_t PRI73 = (4 << 4);  ///< Priority of the INT_GPIO1_INT1 interrupt 73
    }

    /// NVICIP74 Register bits
    namespace nvicip74_bits {
        constexpr uint32_t PRI74 = (4 << 4);  ///< Priority of the INT_GPIO1_INT2 interrupt 74
    }

    /// NVICIP75 Register bits
    namespace nvicip75_bits {
        constexpr uint32_t PRI75 = (4 << 4);  ///< Priority of the INT_GPIO1_INT3 interrupt 75
    }

    /// NVICIP76 Register bits
    namespace nvicip76_bits {
        constexpr uint32_t PRI76 = (4 << 4);  ///< Priority of the INT_GPIO1_INT4 interrupt 76
    }

    /// NVICIP77 Register bits
    namespace nvicip77_bits {
        constexpr uint32_t PRI77 = (4 << 4);  ///< Priority of the INT_GPIO1_INT5 interrupt 77
    }

    /// NVICIP78 Register bits
    namespace nvicip78_bits {
        constexpr uint32_t PRI78 = (4 << 4);  ///< Priority of the INT_GPIO1_INT6 interrupt 78
    }

    /// NVICIP79 Register bits
    namespace nvicip79_bits {
        constexpr uint32_t PRI79 = (4 << 4);  ///< Priority of the INT_GPIO1_INT7 interrupt 79
    }

    /// NVICIP80 Register bits
    namespace nvicip80_bits {
        constexpr uint32_t PRI80 = (4 << 4);  ///< Priority of the INT_GPIO1_Combined_0_15 interrupt 80
    }

    /// NVICIP81 Register bits
    namespace nvicip81_bits {
        constexpr uint32_t PRI81 = (4 << 4);  ///< Priority of the INT_GPIO1_Combined_16_31 interrupt 81
    }

    /// NVICIP82 Register bits
    namespace nvicip82_bits {
        constexpr uint32_t PRI82 = (4 << 4);  ///< Priority of the INT_GPIO2_Combined_0_15 interrupt 82
    }

    /// NVICIP83 Register bits
    namespace nvicip83_bits {
        constexpr uint32_t PRI83 = (4 << 4);  ///< Priority of the INT_GPIO2_Combined_16_31 interrupt 83
    }

    /// NVICIP84 Register bits
    namespace nvicip84_bits {
        constexpr uint32_t PRI84 = (4 << 4);  ///< Priority of the INT_GPIO3_Combined_0_15 interrupt 84
    }

    /// NVICIP85 Register bits
    namespace nvicip85_bits {
        constexpr uint32_t PRI85 = (4 << 4);  ///< Priority of the INT_GPIO3_Combined_16_31 interrupt 85
    }

    /// NVICIP86 Register bits
    namespace nvicip86_bits {
        constexpr uint32_t PRI86 = (4 << 4);  ///< Priority of the INT_GPIO4_Combined_0_15 interrupt 86
    }

    /// NVICIP87 Register bits
    namespace nvicip87_bits {
        constexpr uint32_t PRI87 = (4 << 4);  ///< Priority of the INT_GPIO4_Combined_16_31 interrupt 87
    }

    /// NVICIP88 Register bits
    namespace nvicip88_bits {
        constexpr uint32_t PRI88 = (4 << 4);  ///< Priority of the INT_GPIO5_Combined_0_15 interrupt 88
    }

    /// NVICIP89 Register bits
    namespace nvicip89_bits {
        constexpr uint32_t PRI89 = (4 << 4);  ///< Priority of the INT_GPIO5_Combined_16_31 interrupt 89
    }

    /// NVICIP90 Register bits
    namespace nvicip90_bits {
        constexpr uint32_t PRI90 = (4 << 4);  ///< Priority of the INT_FLEXIO1 interrupt 90
    }

    /// NVICIP91 Register bits
    namespace nvicip91_bits {
        constexpr uint32_t PRI91 = (4 << 4);  ///< Priority of the INT_FLEXIO2 interrupt 91
    }

    /// NVICIP92 Register bits
    namespace nvicip92_bits {
        constexpr uint32_t PRI92 = (4 << 4);  ///< Priority of the INT_WDOG1 interrupt 92
    }

    /// NVICIP93 Register bits
    namespace nvicip93_bits {
        constexpr uint32_t PRI93 = (4 << 4);  ///< Priority of the INT_RTWDOG interrupt 93
    }

    /// NVICIP94 Register bits
    namespace nvicip94_bits {
        constexpr uint32_t PRI94 = (4 << 4);  ///< Priority of the INT_EWM interrupt 94
    }

    /// NVICIP95 Register bits
    namespace nvicip95_bits {
        constexpr uint32_t PRI95 = (4 << 4);  ///< Priority of the INT_CCM_1 interrupt 95
    }

    /// NVICIP96 Register bits
    namespace nvicip96_bits {
        constexpr uint32_t PRI96 = (4 << 4);  ///< Priority of the INT_CCM_2 interrupt 96
    }

    /// NVICIP97 Register bits
    namespace nvicip97_bits {
        constexpr uint32_t PRI97 = (4 << 4);  ///< Priority of the INT_GPC interrupt 97
    }

    /// NVICIP98 Register bits
    namespace nvicip98_bits {
        constexpr uint32_t PRI98 = (4 << 4);  ///< Priority of the INT_SRC interrupt 98
    }

    /// NVICIP99 Register bits
    namespace nvicip99_bits {
        constexpr uint32_t PRI99 = (4 << 4);  ///< Priority of the INT_Reserved115 interrupt 99
    }

    /// NVICIP100 Register bits
    namespace nvicip100_bits {
        constexpr uint32_t PRI100 = (4 << 4);  ///< Priority of the INT_GPT1 interrupt 100
    }

    /// NVICIP101 Register bits
    namespace nvicip101_bits {
        constexpr uint32_t PRI101 = (4 << 4);  ///< Priority of the INT_GPT2 interrupt 101
    }

    /// NVICIP102 Register bits
    namespace nvicip102_bits {
        constexpr uint32_t PRI102 = (4 << 4);  ///< Priority of the INT_PWM1_0 interrupt 102
    }

    /// NVICIP103 Register bits
    namespace nvicip103_bits {
        constexpr uint32_t PRI103 = (4 << 4);  ///< Priority of the INT_PWM1_1 interrupt 103
    }

    /// NVICIP104 Register bits
    namespace nvicip104_bits {
        constexpr uint32_t PRI104 = (4 << 4);  ///< Priority of the INT_PWM1_2 interrupt 104
    }

    /// NVICIP105 Register bits
    namespace nvicip105_bits {
        constexpr uint32_t PRI105 = (4 << 4);  ///< Priority of the INT_PWM1_3 interrupt 105
    }

    /// NVICIP106 Register bits
    namespace nvicip106_bits {
        constexpr uint32_t PRI106 = (4 << 4);  ///< Priority of the INT_PWM1_FAULT interrupt 106
    }

    /// NVICIP107 Register bits
    namespace nvicip107_bits {
        constexpr uint32_t PRI107 = (4 << 4);  ///< Priority of the INT_FLEXSPI2 interrupt 107
    }

    /// NVICIP108 Register bits
    namespace nvicip108_bits {
        constexpr uint32_t PRI108 = (4 << 4);  ///< Priority of the INT_FLEXSPI interrupt 108
    }

    /// NVICIP109 Register bits
    namespace nvicip109_bits {
        constexpr uint32_t PRI109 = (4 << 4);  ///< Priority of the INT_SEMC interrupt 109
    }

    /// NVICIP110 Register bits
    namespace nvicip110_bits {
        constexpr uint32_t PRI110 = (4 << 4);  ///< Priority of the INT_USDHC1 interrupt 110
    }

    /// NVICIP111 Register bits
    namespace nvicip111_bits {
        constexpr uint32_t PRI111 = (4 << 4);  ///< Priority of the INT_USDHC2 interrupt 111
    }

    /// NVICIP112 Register bits
    namespace nvicip112_bits {
        constexpr uint32_t PRI112 = (4 << 4);  ///< Priority of the INT_USB_OTG2 interrupt 112
    }

    /// NVICIP113 Register bits
    namespace nvicip113_bits {
        constexpr uint32_t PRI113 = (4 << 4);  ///< Priority of the INT_USB_OTG1 interrupt 113
    }

    /// NVICIP114 Register bits
    namespace nvicip114_bits {
        constexpr uint32_t PRI114 = (4 << 4);  ///< Priority of the INT_ENET interrupt 114
    }

    /// NVICIP115 Register bits
    namespace nvicip115_bits {
        constexpr uint32_t PRI115 = (4 << 4);  ///< Priority of the INT_ENET_1588_Timer interrupt 115
    }

    /// NVICIP116 Register bits
    namespace nvicip116_bits {
        constexpr uint32_t PRI116 = (4 << 4);  ///< Priority of the INT_XBAR1_IRQ_0_1 interrupt 116
    }

    /// NVICIP117 Register bits
    namespace nvicip117_bits {
        constexpr uint32_t PRI117 = (4 << 4);  ///< Priority of the INT_XBAR1_IRQ_2_3 interrupt 117
    }

    /// NVICIP118 Register bits
    namespace nvicip118_bits {
        constexpr uint32_t PRI118 = (4 << 4);  ///< Priority of the INT_ADC_ETC_IRQ0 interrupt 118
    }

    /// NVICIP119 Register bits
    namespace nvicip119_bits {
        constexpr uint32_t PRI119 = (4 << 4);  ///< Priority of the INT_ADC_ETC_IRQ1 interrupt 119
    }

    /// NVICIP120 Register bits
    namespace nvicip120_bits {
        constexpr uint32_t PRI120 = (4 << 4);  ///< Priority of the INT_ADC_ETC_IRQ2 interrupt 120
    }

    /// NVICIP121 Register bits
    namespace nvicip121_bits {
        constexpr uint32_t PRI121 = (4 << 4);  ///< Priority of the INT_ADC_ETC_ERROR_IRQ interrupt 121
    }

    /// NVICIP122 Register bits
    namespace nvicip122_bits {
        constexpr uint32_t PRI122 = (4 << 4);  ///< Priority of the INT_PIT interrupt 122
    }

    /// NVICIP123 Register bits
    namespace nvicip123_bits {
        constexpr uint32_t PRI123 = (4 << 4);  ///< Priority of the INT_ACMP1 interrupt 123
    }

    /// NVICIP124 Register bits
    namespace nvicip124_bits {
        constexpr uint32_t PRI124 = (4 << 4);  ///< Priority of the INT_ACMP2 interrupt 124
    }

    /// NVICIP125 Register bits
    namespace nvicip125_bits {
        constexpr uint32_t PRI125 = (4 << 4);  ///< Priority of the INT_ACMP3 interrupt 125
    }

    /// NVICIP126 Register bits
    namespace nvicip126_bits {
        constexpr uint32_t PRI126 = (4 << 4);  ///< Priority of the INT_ACMP4 interrupt 126
    }

    /// NVICIP127 Register bits
    namespace nvicip127_bits {
        constexpr uint32_t PRI127 = (4 << 4);  ///< Priority of the INT_Reserved143 interrupt 127
    }

    /// NVICIP128 Register bits
    namespace nvicip128_bits {
        constexpr uint32_t PRI128 = (4 << 4);  ///< Priority of the INT_Reserved144 interrupt 128
    }

    /// NVICIP129 Register bits
    namespace nvicip129_bits {
        constexpr uint32_t PRI129 = (4 << 4);  ///< Priority of the INT_ENC1 interrupt 129
    }

    /// NVICIP130 Register bits
    namespace nvicip130_bits {
        constexpr uint32_t PRI130 = (4 << 4);  ///< Priority of the INT_ENC2 interrupt 130
    }

    /// NVICIP131 Register bits
    namespace nvicip131_bits {
        constexpr uint32_t PRI131 = (4 << 4);  ///< Priority of the INT_ENC3 interrupt 131
    }

    /// NVICIP132 Register bits
    namespace nvicip132_bits {
        constexpr uint32_t PRI132 = (4 << 4);  ///< Priority of the INT_ENC4 interrupt 132
    }

    /// NVICIP133 Register bits
    namespace nvicip133_bits {
        constexpr uint32_t PRI133 = (4 << 4);  ///< Priority of the INT_TMR1 interrupt 133
    }

    /// NVICIP134 Register bits
    namespace nvicip134_bits {
        constexpr uint32_t PRI134 = (4 << 4);  ///< Priority of the INT_TMR2 interrupt 134
    }

    /// NVICIP135 Register bits
    namespace nvicip135_bits {
        constexpr uint32_t PRI135 = (4 << 4);  ///< Priority of the INT_TMR3 interrupt 135
    }

    /// NVICIP136 Register bits
    namespace nvicip136_bits {
        constexpr uint32_t PRI136 = (4 << 4);  ///< Priority of the INT_TMR4 interrupt 136
    }

    /// NVICIP137 Register bits
    namespace nvicip137_bits {
        constexpr uint32_t PRI137 = (4 << 4);  ///< Priority of the INT_PWM2_0 interrupt 137
    }

    /// NVICIP138 Register bits
    namespace nvicip138_bits {
        constexpr uint32_t PRI138 = (4 << 4);  ///< Priority of the INT_PWM2_1 interrupt 138
    }

    /// NVICIP139 Register bits
    namespace nvicip139_bits {
        constexpr uint32_t PRI139 = (4 << 4);  ///< Priority of the INT_PWM2_2 interrupt 139
    }

    /// NVICIP140 Register bits
    namespace nvicip140_bits {
        constexpr uint32_t PRI140 = (4 << 4);  ///< Priority of the INT_PWM2_3 interrupt 140
    }

    /// NVICIP141 Register bits
    namespace nvicip141_bits {
        constexpr uint32_t PRI141 = (4 << 4);  ///< Priority of the INT_PWM2_FAULT interrupt 141
    }

    /// NVICIP142 Register bits
    namespace nvicip142_bits {
        constexpr uint32_t PRI142 = (4 << 4);  ///< Priority of the INT_PWM3_0 interrupt 142
    }

    /// NVICIP143 Register bits
    namespace nvicip143_bits {
        constexpr uint32_t PRI143 = (4 << 4);  ///< Priority of the INT_PWM3_1 interrupt 143
    }

    /// NVICIP144 Register bits
    namespace nvicip144_bits {
        constexpr uint32_t PRI144 = (4 << 4);  ///< Priority of the INT_PWM3_2 interrupt 144
    }

    /// NVICIP145 Register bits
    namespace nvicip145_bits {
        constexpr uint32_t PRI145 = (4 << 4);  ///< Priority of the INT_PWM3_3 interrupt 145
    }

    /// NVICIP146 Register bits
    namespace nvicip146_bits {
        constexpr uint32_t PRI146 = (4 << 4);  ///< Priority of the INT_PWM3_FAULT interrupt 146
    }

    /// NVICIP147 Register bits
    namespace nvicip147_bits {
        constexpr uint32_t PRI147 = (4 << 4);  ///< Priority of the INT_PWM4_0 interrupt 147
    }

    /// NVICIP148 Register bits
    namespace nvicip148_bits {
        constexpr uint32_t PRI148 = (4 << 4);  ///< Priority of the INT_PWM4_1 interrupt 148
    }

    /// NVICIP149 Register bits
    namespace nvicip149_bits {
        constexpr uint32_t PRI149 = (4 << 4);  ///< Priority of the INT_PWM4_2 interrupt 149
    }

    /// NVICIP150 Register bits
    namespace nvicip150_bits {
        constexpr uint32_t PRI150 = (4 << 4);  ///< Priority of the INT_PWM4_3 interrupt 150
    }

    /// NVICIP151 Register bits
    namespace nvicip151_bits {
        constexpr uint32_t PRI151 = (4 << 4);  ///< Priority of the INT_PWM4_FAULT interrupt 151
    }

    /// NVICIP152 Register bits
    namespace nvicip152_bits {
        constexpr uint32_t PRI152 = (4 << 4);  ///< Priority of the INT_ENET2 interrupt 152
    }

    /// NVICIP153 Register bits
    namespace nvicip153_bits {
        constexpr uint32_t PRI153 = (4 << 4);  ///< Priority of the INT_ENET2_1588_Timer interrupt 153
    }

    /// NVICIP154 Register bits
    namespace nvicip154_bits {
        constexpr uint32_t PRI154 = (4 << 4);  ///< Priority of the INT_CAN3 interrupt 154
    }

    /// NVICIP155 Register bits
    namespace nvicip155_bits {
        constexpr uint32_t PRI155 = (4 << 4);  ///< Priority of the INT_Reserved171 interrupt 155
    }

    /// NVICIP156 Register bits
    namespace nvicip156_bits {
        constexpr uint32_t PRI156 = (4 << 4);  ///< Priority of the INT_FLEXIO3 interrupt 156
    }

    /// NVICIP157 Register bits
    namespace nvicip157_bits {
        constexpr uint32_t PRI157 = (4 << 4);  ///< Priority of the INT_GPIO6_7_8_9 interrupt 157
    }

    /// NVICSTIR Register bits
    namespace nvicstir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< Interrupt ID of the interrupt to trigger, in the range 0-239. For example, a value of 0x03 specifies interrupt IRQ3.
    }

}


} // namespace alloy::generated::mimxrt1064

#endif // ALLOY_GENERATED_MIMXRT1064_PERIPHERALS_HPP