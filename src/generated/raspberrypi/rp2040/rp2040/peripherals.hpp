/// Auto-generated code for RP2040
/// Generated by Alloy Code Generator
/// Source: raspberrypi_rp2040.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:29
#ifndef ALLOY_GENERATED_RP2040_PERIPHERALS_HPP
#define ALLOY_GENERATED_RP2040_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::rp2040 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_xip = true;
    constexpr uint32_t num_xip_instances = 2;
    constexpr bool has_sysinfo = true;
    constexpr uint32_t num_sysinfo_instances = 1;
    constexpr bool has_syscfg = true;
    constexpr uint32_t num_syscfg_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_resets = true;
    constexpr uint32_t num_resets_instances = 1;
    constexpr bool has_psm = true;
    constexpr uint32_t num_psm_instances = 1;
    constexpr bool has_io = true;
    constexpr uint32_t num_io_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 4;
    constexpr bool has_pads = true;
    constexpr uint32_t num_pads_instances = 1;
    constexpr bool has_xosc = true;
    constexpr uint32_t num_xosc_instances = 1;
    constexpr bool has_pll = true;
    constexpr uint32_t num_pll_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 2;
    constexpr bool has_busctrl = true;
    constexpr uint32_t num_busctrl_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 1;
    constexpr bool has_watchdog = true;
    constexpr uint32_t num_watchdog_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_rosc = true;
    constexpr uint32_t num_rosc_instances = 1;
    constexpr bool has_vreg = true;
    constexpr uint32_t num_vreg_instances = 1;
    constexpr bool has_tbman = true;
    constexpr uint32_t num_tbman_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_pio0 = true;
    constexpr uint32_t num_pio0_instances = 1;
    constexpr bool has_pio1 = true;
    constexpr uint32_t num_pio1_instances = 1;
    constexpr bool has_sio = true;
    constexpr uint32_t num_sio_instances = 1;
    constexpr bool has_ppb = true;
    constexpr uint32_t num_ppb_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct xip_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct sysinfo_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct syscfg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct resets_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct psm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct io_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct pads_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct xosc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pll_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct busctrl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct watchdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rosc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vreg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tbman_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pio0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pio1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ppb_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits

    // USART-specific traits
    constexpr bool has_uart0_irq = true;
    constexpr bool has_uart1_irq = true;
}

// ============================================================================
// XIP Peripheral
// ============================================================================

namespace xip {
    /// Base addresses
    constexpr uint32_t XIP_IRQ_BASE = 0x14000000;
    constexpr uint32_t XIP_SSI_BASE = 0x18000000;

    /// XIP Register structure
    struct Registers {
        volatile uint32_t POWER_DOWN;  ///< Offset: 0x00 - Cache control
        volatile uint32_t FLUSH;  ///< Offset: 0x04 - Cache Flush control
        volatile uint32_t FIFO_FULL;  ///< Offset: 0x08 - Cache Status
        volatile uint32_t CTR_HIT;  ///< Offset: 0x0C - Cache Hit counter\n A 32 bit saturating counter that...
        volatile uint32_t CTR_ACC;  ///< Offset: 0x10 - Cache Access counter\n A 32 bit saturating counter that...
        volatile uint32_t STREAM_ADDR;  ///< Offset: 0x14 - FIFO stream address
        volatile uint32_t STREAM_CTR;  ///< Offset: 0x18 - FIFO stream control
        volatile uint32_t STREAM_FIFO;  ///< Offset: 0x1C - FIFO stream data\n Streamed data is buffered here, for...
    };

    /// Peripheral instances
    inline Registers* XIP_IRQ = reinterpret_cast<Registers*>(XIP_IRQ_BASE);
    inline Registers* XIP_SSI = reinterpret_cast<Registers*>(XIP_SSI_BASE);

}

// ============================================================================
// SYSINFO Peripheral
// ============================================================================

namespace sysinfo {
    /// Base addresses
    constexpr uint32_t SYSINFO_BASE = 0x40000000;

    /// SYSINFO Register structure
    struct Registers {
        volatile uint32_t REVISION;  ///< Offset: 0x00 - JEDEC JEP-106 compliant chip identifier.
        volatile uint32_t ASIC;  ///< Offset: 0x04 - Platform register. Allows software to know what...
        volatile uint32_t GITREF_RP2040;  ///< Offset: 0x40 - Git hash of the chip source. Used to identify chip version.
    };

    /// Peripheral instances
    inline Registers* SYSINFO = reinterpret_cast<Registers*>(SYSINFO_BASE);

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x40004000;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t PROC0_NMI_MASK;  ///< Offset: 0x00 - Processor core 0 NMI source mask\n Set a bit high to...
        volatile uint32_t PROC1_NMI_MASK;  ///< Offset: 0x04 - Processor core 1 NMI source mask\n Set a bit high to...
        volatile uint32_t PROC1_DAP_INSTID;  ///< Offset: 0x08 - Configuration for processors
        volatile uint32_t PROC_IN_SYNC_BYPASS;  ///< Offset: 0x0C - For each bit, if 1, bypass the input synchronizer...
        volatile uint32_t PROC_IN_SYNC_BYPASS_HI;  ///< Offset: 0x10 - For each bit, if 1, bypass the input synchronizer...
        volatile uint32_t PROC1_ATTACH;  ///< Offset: 0x14 - Directly control the SWD debug port of either processor
        volatile uint32_t ROM;  ///< Offset: 0x18 - Control power downs to memories. Set high to power down...
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t CLOCKS_IRQ_BASE = 0x40008000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t NUDGE;  ///< Offset: 0x6C - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t INT;  ///< Offset: 0x70 - Clock divisor, can be changed on-the-fly
        volatile uint32_t CLK_GPOUT0_SELECTED;  ///< Offset: 0x08 - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_GPOUT1_SELECTED;  ///< Offset: 0x14 - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_GPOUT2_SELECTED;  ///< Offset: 0x20 - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_GPOUT3_SELECTED;  ///< Offset: 0x2C - Indicates which src is currently selected (one-hot)
        volatile uint32_t clksrc_pll_usb;  ///< Offset: 0x30 - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t CLK_REF_SELECTED;  ///< Offset: 0x38 - Indicates which src is currently selected (one-hot)
        volatile uint32_t clksrc_pll_sys;  ///< Offset: 0x3C - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t CLK_SYS_SELECTED;  ///< Offset: 0x44 - Indicates which src is currently selected (one-hot)
        volatile uint32_t ENABLE;  ///< Offset: 0x48 - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t CLK_PERI_SELECTED;  ///< Offset: 0x50 - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_USB_SELECTED;  ///< Offset: 0x5C - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_ADC_SELECTED;  ///< Offset: 0x68 - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_RTC_SELECTED;  ///< Offset: 0x74 - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLEAR;  ///< Offset: 0x78 - For clearing the resus after the fault that triggered it...
        volatile uint32_t RESUSSED;  ///< Offset: 0x7C - Clock has been resuscitated, correct the error then send...
        volatile uint32_t FC0_REF_KHZ;  ///< Offset: 0x80 - Reference clock frequency in kHz
        volatile uint32_t FC0_MIN_KHZ;  ///< Offset: 0x84 - Minimum pass frequency in kHz. This is optional. Set to...
        volatile uint32_t FC0_MAX_KHZ;  ///< Offset: 0x88 - Maximum pass frequency in kHz. This is optional. Set to...
        volatile uint32_t FC0_DELAY;  ///< Offset: 0x8C - Delays the start of frequency counting to allow the mux...
        volatile uint32_t FC0_INTERVAL;  ///< Offset: 0x90 - The test interval is 0.98us * 2**interval, but let's...
        volatile uint32_t NULL;  ///< Offset: 0x94 - Clock sent to frequency counter, set to 0 when not...
        volatile uint32_t DIED;  ///< Offset: 0x98 - Frequency counter status
        volatile uint32_t KHZ;  ///< Offset: 0x9C - Result of frequency measurement, only valid when status_done=1
        volatile uint32_t clk_sys_sram3;  ///< Offset: 0xB0 - indicates the state of the clock enable
        volatile uint32_t clk_sys_xosc;  ///< Offset: 0xB4 - indicates the state of the clock enable
        volatile uint32_t CLK_SYS_RESUS;  ///< Offset: 0xC4 - Interrupt status after masking & forcing
    };

    /// Peripheral instances
    inline Registers* CLOCKS_IRQ = reinterpret_cast<Registers*>(CLOCKS_IRQ_BASE);

}

// ============================================================================
// RESETS Peripheral
// ============================================================================

namespace resets {
    /// Base addresses
    constexpr uint32_t RESETS_BASE = 0x4000C000;

    /// RESETS Register structure
    struct Registers {
        volatile uint32_t usbctrl;  ///< Offset: 0x08 - Reset done. If a bit is set then a reset done signal has...
    };

    /// Peripheral instances
    inline Registers* RESETS = reinterpret_cast<Registers*>(RESETS_BASE);

}

// ============================================================================
// PSM Peripheral
// ============================================================================

namespace psm {
    /// Base addresses
    constexpr uint32_t PSM_BASE = 0x40010000;

    /// PSM Register structure
    struct Registers {
        volatile uint32_t proc1;  ///< Offset: 0x0C - Indicates the peripheral's registers are ready to access.
    };

    /// Peripheral instances
    inline Registers* PSM = reinterpret_cast<Registers*>(PSM_BASE);

}

// ============================================================================
// IO Peripheral
// ============================================================================

namespace io {
    /// Base addresses
    constexpr uint32_t IO_IRQ_BANK0_BASE = 0x40014000;

    /// IO Register structure
    struct Registers {
        volatile uint32_t IRQTOPROC;  ///< Offset: 0xE8 - GPIO status
        volatile uint32_t NORMAL;  ///< Offset: 0xEC - GPIO control including function select and overrides.
        volatile uint32_t GPIO7_EDGE_HIGH;  ///< Offset: 0x180 - Interrupt status after masking & forcing for dormant_wake
        volatile uint32_t GPIO15_EDGE_HIGH;  ///< Offset: 0x184 - Interrupt status after masking & forcing for dormant_wake
        volatile uint32_t GPIO23_EDGE_HIGH;  ///< Offset: 0x188 - Interrupt status after masking & forcing for dormant_wake
        volatile uint32_t GPIO29_EDGE_HIGH;  ///< Offset: 0x18C - Interrupt status after masking & forcing for dormant_wake
    };

    /// Peripheral instances
    inline Registers* IO_IRQ_BANK0 = reinterpret_cast<Registers*>(IO_IRQ_BANK0_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t IO_IRQ_QSPI_BASE = 0x40018000;
    constexpr uint32_t PADS_QSPI_BASE = 0x40020000;
    constexpr uint32_t SPI0_IRQ_BASE = 0x4003C000;
    constexpr uint32_t SPI1_IRQ_BASE = 0x40040000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t IRQTOPROC;  ///< Offset: 0x28 - GPIO status
        volatile uint32_t NORMAL;  ///< Offset: 0x2C - GPIO control including function select and overrides.
        volatile uint32_t GPIO_QSPI_SD3_EDGE_HIGH;  ///< Offset: 0x54 - Interrupt status after masking & forcing for dormant_wake
    };

    /// Peripheral instances
    inline Registers* IO_IRQ_QSPI = reinterpret_cast<Registers*>(IO_IRQ_QSPI_BASE);
    inline Registers* PADS_QSPI = reinterpret_cast<Registers*>(PADS_QSPI_BASE);
    inline Registers* SPI0_IRQ = reinterpret_cast<Registers*>(SPI0_IRQ_BASE);
    inline Registers* SPI1_IRQ = reinterpret_cast<Registers*>(SPI1_IRQ_BASE);

}

// ============================================================================
// PADS Peripheral
// ============================================================================

namespace pads {
    /// Base addresses
    constexpr uint32_t PADS_BANK0_BASE = 0x4001C000;

    /// PADS Register structure
    struct Registers {
        volatile uint32_t 3v3;  ///< Offset: 0x00 - Voltage select. Per bank control
        volatile uint32_t OD;  ///< Offset: 0x80 - Pad control register
    };

    /// Peripheral instances
    inline Registers* PADS_BANK0 = reinterpret_cast<Registers*>(PADS_BANK0_BASE);

}

// ============================================================================
// XOSC Peripheral
// ============================================================================

namespace xosc {
    /// Base addresses
    constexpr uint32_t XOSC_BASE = 0x40024000;

    /// XOSC Register structure
    struct Registers {
        volatile uint32_t DISABLE;  ///< Offset: 0x00 - Crystal Oscillator Control
        volatile uint32_t STABLE;  ///< Offset: 0x04 - Crystal Oscillator Status
        volatile uint32_t DORMANT;  ///< Offset: 0x08 - Crystal Oscillator pause control\n This is used to save...
        volatile uint32_t X4;  ///< Offset: 0x0C - Controls the startup delay
        volatile uint32_t COUNT;  ///< Offset: 0x1C - A down counter running at the xosc frequency which...
    };

    /// Peripheral instances
    inline Registers* XOSC = reinterpret_cast<Registers*>(XOSC_BASE);

}

// ============================================================================
// PLL Peripheral
// ============================================================================

namespace pll {
    /// Base addresses
    constexpr uint32_t PLL_SYS_BASE = 0x40028000;

    /// PLL Register structure
    struct Registers {
        volatile uint32_t LOCK;  ///< Offset: 0x00 - Control and Status\n GENERAL CONSTRAINTS:\n Reference...
        volatile uint32_t VCOPD;  ///< Offset: 0x04 - Controls the PLL power modes.
        volatile uint32_t FBDIV_INT;  ///< Offset: 0x08 - Feedback divisor\n (note: this PLL does not support...
        volatile uint32_t POSTDIV1;  ///< Offset: 0x0C - Controls the PLL post dividers for the primary output\n...
    };

    /// Peripheral instances
    inline Registers* PLL_SYS = reinterpret_cast<Registers*>(PLL_SYS_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t PLL_USB_BASE = 0x4002C000;
    constexpr uint32_t USBCTRL_IRQ_BASE = 0x50110000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t ENDPOINT;  ///< Offset: 0x00 - Device address and endpoint control
        volatile uint32_t INTEP_PREAMBLE;  ///< Offset: 0x3C - Interrupt endpoint 15. Only valid for HOST mode.
        volatile uint32_t SIM_TIMING;  ///< Offset: 0x40 - Main control register
        volatile uint32_t COUNT;  ///< Offset: 0x48 - Read the last SOF (Start of Frame) frame number seen. In...
        volatile uint32_t EP0_INT_STALL;  ///< Offset: 0x4C - SIE control register
        volatile uint32_t DATA_SEQ_ERROR;  ///< Offset: 0x50 - SIE status register
        volatile uint32_t INT_EP_ACTIVE;  ///< Offset: 0x54 - interrupt endpoint control register
        volatile uint32_t EP15_OUT;  ///< Offset: 0x70 - Device: bits are set when the `IRQ_ON_NAK` or...
        volatile uint32_t EP0_OUT;  ///< Offset: 0x68 - Device: this bit must be set in conjunction with the...
        volatile uint32_t DELAY_FS;  ///< Offset: 0x6C - Used by the host controller. Sets the wait time in...
        volatile uint32_t SOFTCON;  ///< Offset: 0x74 - Where to connect the USB controller. Should be to_phy by default.
        volatile uint32_t OVERCURR_DETECT_EN;  ///< Offset: 0x78 - Overrides for the power signals in the event that the...
        volatile uint32_t DM_OVV;  ///< Offset: 0x7C - This register allows for direct control of the USB phy....
        volatile uint32_t TX_DIFFMODE_OVERRIDE_EN;  ///< Offset: 0x80 - Override enable for each control in usbphy_direct
        volatile uint32_t DM_PULLDN_TRIM;  ///< Offset: 0x84 - Used to adjust trim values of USB phy pull down resistors.
        volatile uint32_t EP_STALL_NAK;  ///< Offset: 0x98 - Interrupt status after masking & forcing
    };

    /// Peripheral instances
    inline Registers* PLL_USB = reinterpret_cast<Registers*>(PLL_USB_BASE);
    inline Registers* USBCTRL_IRQ = reinterpret_cast<Registers*>(USBCTRL_IRQ_BASE);

}

// ============================================================================
// BUSCTRL Peripheral
// ============================================================================

namespace busctrl {
    /// Base addresses
    constexpr uint32_t BUSCTRL_BASE = 0x40030000;

    /// BUSCTRL Register structure
    struct Registers {
        volatile uint32_t DMA_W;  ///< Offset: 0x00 - Set the priority of each master for bus arbitration.
        volatile uint32_t BUS_PRIORITY_ACK;  ///< Offset: 0x04 - Bus priority acknowledge
        volatile uint32_t PERFCTR0;  ///< Offset: 0x08 - Bus fabric performance counter 0
        volatile uint32_t PERFSEL0;  ///< Offset: 0x0C - Bus fabric performance event select for PERFCTR0
        volatile uint32_t PERFCTR1;  ///< Offset: 0x10 - Bus fabric performance counter 1
        volatile uint32_t PERFSEL1;  ///< Offset: 0x14 - Bus fabric performance event select for PERFCTR1
        volatile uint32_t PERFCTR2;  ///< Offset: 0x18 - Bus fabric performance counter 2
        volatile uint32_t PERFSEL2;  ///< Offset: 0x1C - Bus fabric performance event select for PERFCTR2
        volatile uint32_t PERFCTR3;  ///< Offset: 0x20 - Bus fabric performance counter 3
        volatile uint32_t PERFSEL3;  ///< Offset: 0x24 - Bus fabric performance event select for PERFCTR3
    };

    /// Peripheral instances
    inline Registers* BUSCTRL = reinterpret_cast<Registers*>(BUSCTRL_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_IRQ_BASE = 0x40034000;
    constexpr uint32_t UART1_IRQ_BASE = 0x40038000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t OE;  ///< Offset: 0x04 - Receive Status Register/Error Clear Register, UARTRSR/UARTECR
        volatile uint32_t RI;  ///< Offset: 0x18 - Flag Register, UARTFR
        volatile uint32_t ILPDVSR;  ///< Offset: 0x20 - IrDA Low-Power Counter Register, UARTILPR
        volatile uint32_t BAUD_DIVINT;  ///< Offset: 0x24 - Integer Baud Rate Register, UARTIBRD
        volatile uint32_t BAUD_DIVFRAC;  ///< Offset: 0x28 - Fractional Baud Rate Register, UARTFBRD
        volatile uint32_t SPS;  ///< Offset: 0x2C - Line Control Register, UARTLCR_H
        volatile uint32_t CTSEN;  ///< Offset: 0x30 - Control Register, UARTCR
        volatile uint32_t RXIFLSEL;  ///< Offset: 0x34 - Interrupt FIFO Level Select Register, UARTIFLS
        volatile uint32_t OEIM;  ///< Offset: 0x38 - Interrupt Mask Set/Clear Register, UARTIMSC
        volatile uint32_t OERIS;  ///< Offset: 0x3C - Raw Interrupt Status Register, UARTRIS
        volatile uint32_t OEMIS;  ///< Offset: 0x40 - Masked Interrupt Status Register, UARTMIS
        volatile uint32_t OEIC;  ///< Offset: 0x44 - Interrupt Clear Register, UARTICR
        volatile uint32_t DMAONERR;  ///< Offset: 0x48 - DMA Control Register, UARTDMACR
        volatile uint32_t PARTNUMBER0;  ///< Offset: 0xFE0 - UARTPeriphID0 Register
        volatile uint32_t DESIGNER0;  ///< Offset: 0xFE4 - UARTPeriphID1 Register
        volatile uint32_t REVISION;  ///< Offset: 0xFE8 - UARTPeriphID2 Register
        volatile uint32_t CONFIGURATION;  ///< Offset: 0xFEC - UARTPeriphID3 Register
        volatile uint32_t UARTPCELLID0;  ///< Offset: 0xFF0 - UARTPCellID0 Register
        volatile uint32_t UARTPCELLID1;  ///< Offset: 0xFF4 - UARTPCellID1 Register
        volatile uint32_t UARTPCELLID2;  ///< Offset: 0xFF8 - UARTPCellID2 Register
        volatile uint32_t UARTPCELLID3;  ///< Offset: 0xFFC - UARTPCellID3 Register
    };

    /// Peripheral instances
    inline Registers* UART0_IRQ = reinterpret_cast<Registers*>(UART0_IRQ_BASE);
    inline Registers* UART1_IRQ = reinterpret_cast<Registers*>(UART1_IRQ_BASE);

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_IRQ_BASE = 0x40044000;
    constexpr uint32_t I2C1_IRQ_BASE = 0x40048000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t STOP_DET_IF_MASTER_ACTIVE;  ///< Offset: 0x00 - I2C Control Register. This register can be written only...
        volatile uint32_t DISABLED;  ///< Offset: 0x98 - I2C ACK General Call Register\n\n The register controls...
        volatile uint32_t IC_SAR;  ///< Offset: 0x08 - I2C Slave Address Register
        volatile uint32_t INACTIVE;  ///< Offset: 0x9C - I2C Enable Status Register\n\n The register is used to...
        volatile uint32_t IC_SS_SCL_HCNT;  ///< Offset: 0x14 - Standard Speed I2C Clock SCL High Count Register
        volatile uint32_t IC_SS_SCL_LCNT;  ///< Offset: 0x18 - Standard Speed I2C Clock SCL Low Count Register
        volatile uint32_t IC_FS_SCL_HCNT;  ///< Offset: 0x1C - Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
        volatile uint32_t IC_FS_SCL_LCNT;  ///< Offset: 0x20 - Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
        volatile uint32_t ENABLED;  ///< Offset: 0x30 - I2C Interrupt Mask Register.\n\n These bits mask their...
        volatile uint32_t RX_TL;  ///< Offset: 0x38 - I2C Receive FIFO Threshold Register
        volatile uint32_t TX_TL;  ///< Offset: 0x3C - I2C Transmit FIFO Threshold Register
        volatile uint32_t CLR_INTR;  ///< Offset: 0x40 - Clear Combined and Individual Interrupt Register
        volatile uint32_t CLR_RX_UNDER;  ///< Offset: 0x44 - Clear RX_UNDER Interrupt Register
        volatile uint32_t CLR_RX_OVER;  ///< Offset: 0x48 - Clear RX_OVER Interrupt Register
        volatile uint32_t CLR_TX_OVER;  ///< Offset: 0x4C - Clear TX_OVER Interrupt Register
        volatile uint32_t CLR_RD_REQ;  ///< Offset: 0x50 - Clear RD_REQ Interrupt Register
        volatile uint32_t CLR_TX_ABRT;  ///< Offset: 0x54 - Clear TX_ABRT Interrupt Register
        volatile uint32_t CLR_RX_DONE;  ///< Offset: 0x58 - Clear RX_DONE Interrupt Register
        volatile uint32_t CLR_ACTIVITY;  ///< Offset: 0x5C - Clear ACTIVITY Interrupt Register
        volatile uint32_t CLR_STOP_DET;  ///< Offset: 0x60 - Clear STOP_DET Interrupt Register
        volatile uint32_t CLR_START_DET;  ///< Offset: 0x64 - Clear START_DET Interrupt Register
        volatile uint32_t CLR_GEN_CALL;  ///< Offset: 0x68 - Clear GEN_CALL Interrupt Register
        volatile uint32_t NOT_BLOCKED;  ///< Offset: 0x6C - I2C Enable Register
        volatile uint32_t IDLE;  ///< Offset: 0x70 - I2C Status Register\n\n This is a read-only register...
        volatile uint32_t TXFLR;  ///< Offset: 0x74 - I2C Transmit FIFO Level Register This register contains...
        volatile uint32_t RXFLR;  ///< Offset: 0x78 - I2C Receive FIFO Level Register This register contains...
        volatile uint32_t IC_SDA_RX_HOLD;  ///< Offset: 0x7C - I2C SDA Hold Time Length Register\n\n The bits [15:0] of...
        volatile uint32_t TX_FLUSH_CNT;  ///< Offset: 0x80 - I2C Transmit Abort Source Register\n\n This register has...
        volatile uint32_t DMATDL;  ///< Offset: 0x8C - DMA Transmit Data Level Register
        volatile uint32_t DMARDL;  ///< Offset: 0x90 - I2C Receive Data Level Register
        volatile uint32_t SDA_SETUP;  ///< Offset: 0x94 - I2C SDA Setup Register\n\n This register controls the...
        volatile uint32_t IC_FS_SPKLEN;  ///< Offset: 0xA0 - I2C SS, FS or FM+ spike suppression limit\n\n This...
        volatile uint32_t CLR_RESTART_DET;  ///< Offset: 0xA8 - Clear RESTART_DET Interrupt Register
        volatile uint32_t TX_BUFFER_DEPTH;  ///< Offset: 0xF4 - Component Parameter Register 1\n\n Note This register is...
        volatile uint32_t IC_COMP_VERSION;  ///< Offset: 0xF8 - I2C Component Version Register
        volatile uint32_t IC_COMP_TYPE;  ///< Offset: 0xFC - I2C Component Type Register
    };

    /// Peripheral instances
    inline Registers* I2C0_IRQ = reinterpret_cast<Registers*>(I2C0_IRQ_BASE);
    inline Registers* I2C1_IRQ = reinterpret_cast<Registers*>(I2C1_IRQ_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_IRQ_FIFO_BASE = 0x4004C000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t RROBIN;  ///< Offset: 0x00 - ADC Control and Status
        volatile uint32_t RESULT;  ///< Offset: 0x04 - Result of most recent ADC conversion
        volatile uint32_t THRESH;  ///< Offset: 0x08 - FIFO control and status
        volatile uint32_t ERR;  ///< Offset: 0x0C - Conversion result FIFO
        volatile uint32_t INT;  ///< Offset: 0x10 - Clock divider. If non-zero, CS_START_MANY will start...
        volatile uint32_t FIFO;  ///< Offset: 0x20 - Interrupt status after masking & forcing
    };

    /// Peripheral instances
    inline Registers* ADC_IRQ_FIFO = reinterpret_cast<Registers*>(ADC_IRQ_FIFO_BASE);

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t PWM_IRQ_WRAP_BASE = 0x40050000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t PH_ADV;  ///< Offset: 0x8C - Control and status register
        volatile uint32_t INT;  ///< Offset: 0x90 - INT and FRAC form a fixed-point fractional number.\n...
        volatile uint32_t CH0_CTR;  ///< Offset: 0x08 - Direct access to the PWM counter
        volatile uint32_t B;  ///< Offset: 0x98 - Counter compare values
        volatile uint32_t CH0_TOP;  ///< Offset: 0x10 - Counter wrap value
        volatile uint32_t CH1_CTR;  ///< Offset: 0x1C - Direct access to the PWM counter
        volatile uint32_t CH1_TOP;  ///< Offset: 0x24 - Counter wrap value
        volatile uint32_t CH2_CTR;  ///< Offset: 0x30 - Direct access to the PWM counter
        volatile uint32_t CH2_TOP;  ///< Offset: 0x38 - Counter wrap value
        volatile uint32_t CH3_CTR;  ///< Offset: 0x44 - Direct access to the PWM counter
        volatile uint32_t CH3_TOP;  ///< Offset: 0x4C - Counter wrap value
        volatile uint32_t CH4_CTR;  ///< Offset: 0x58 - Direct access to the PWM counter
        volatile uint32_t CH4_TOP;  ///< Offset: 0x60 - Counter wrap value
        volatile uint32_t CH5_CTR;  ///< Offset: 0x6C - Direct access to the PWM counter
        volatile uint32_t CH5_TOP;  ///< Offset: 0x74 - Counter wrap value
        volatile uint32_t CH6_CTR;  ///< Offset: 0x80 - Direct access to the PWM counter
        volatile uint32_t CH6_TOP;  ///< Offset: 0x88 - Counter wrap value
        volatile uint32_t CH7_CTR;  ///< Offset: 0x94 - Direct access to the PWM counter
        volatile uint32_t CH7_TOP;  ///< Offset: 0x9C - Counter wrap value
        volatile uint32_t CH7;  ///< Offset: 0xB0 - Interrupt status after masking & forcing
    };

    /// Peripheral instances
    inline Registers* PWM_IRQ_WRAP = reinterpret_cast<Registers*>(PWM_IRQ_WRAP_BASE);

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER_IRQ_0_BASE = 0x40054000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TIMEHW;  ///< Offset: 0x00 - Write to bits 63:32 of time\n always write timelw before timehw
        volatile uint32_t TIMELW;  ///< Offset: 0x04 - Write to bits 31:0 of time\n writes do not get copied to...
        volatile uint32_t TIMEHR;  ///< Offset: 0x08 - Read from bits 63:32 of time\n always read timelr before timehr
        volatile uint32_t TIMELR;  ///< Offset: 0x0C - Read from bits 31:0 of time
        volatile uint32_t ALARM0;  ///< Offset: 0x10 - Arm alarm 0, and configure the time it will fire.\n Once...
        volatile uint32_t ALARM1;  ///< Offset: 0x14 - Arm alarm 1, and configure the time it will fire.\n Once...
        volatile uint32_t ALARM2;  ///< Offset: 0x18 - Arm alarm 2, and configure the time it will fire.\n Once...
        volatile uint32_t ALARM3;  ///< Offset: 0x1C - Arm alarm 3, and configure the time it will fire.\n Once...
        volatile uint32_t ARMED;  ///< Offset: 0x20 - Indicates the armed/disarmed status of each alarm.\n A...
        volatile uint32_t TIMERAWH;  ///< Offset: 0x24 - Raw read from bits 63:32 of time (no side effects)
        volatile uint32_t TIMERAWL;  ///< Offset: 0x28 - Raw read from bits 31:0 of time (no side effects)
        volatile uint32_t DBG1;  ///< Offset: 0x2C - Set bits high to enable pause when the corresponding...
        volatile uint32_t PAUSE;  ///< Offset: 0x30 - Set high to pause the timer
        volatile uint32_t ALARM_3;  ///< Offset: 0x40 - Interrupt status after masking & forcing
    };

    /// Peripheral instances
    inline Registers* TIMER_IRQ_0 = reinterpret_cast<Registers*>(TIMER_IRQ_0_BASE);

}

// ============================================================================
// WATCHDOG Peripheral
// ============================================================================

namespace watchdog {
    /// Base addresses
    constexpr uint32_t WATCHDOG_BASE = 0x40058000;

    /// WATCHDOG Register structure
    struct Registers {
        volatile uint32_t TRIGGER;  ///< Offset: 0x00 - Watchdog control\n The rst_wdsel register determines...
        volatile uint32_t LOAD;  ///< Offset: 0x04 - Load the watchdog timer. The maximum setting is 0xffffff...
        volatile uint32_t FORCE;  ///< Offset: 0x08 - Logs the reason for the last reset. Both bits are zero...
        volatile uint32_t SCRATCH0;  ///< Offset: 0x0C - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH1;  ///< Offset: 0x10 - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH2;  ///< Offset: 0x14 - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH3;  ///< Offset: 0x18 - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH4;  ///< Offset: 0x1C - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH5;  ///< Offset: 0x20 - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH6;  ///< Offset: 0x24 - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH7;  ///< Offset: 0x28 - Scratch register. Information persists through soft...
        volatile uint32_t COUNT;  ///< Offset: 0x2C - Controls the tick generator
    };

    /// Peripheral instances
    inline Registers* WATCHDOG = reinterpret_cast<Registers*>(WATCHDOG_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_IRQ_BASE = 0x4005C000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t CLKDIV_M1;  ///< Offset: 0x00 - Divider minus 1 for the 1 second counter. Safe to change...
        volatile uint32_t YEAR;  ///< Offset: 0x18 - RTC register 1.
        volatile uint32_t DOTW;  ///< Offset: 0x1C - RTC register 0\n Read this before RTC 1!
        volatile uint32_t FORCE_NOTLEAPYEAR;  ///< Offset: 0x0C - RTC Control and status
        volatile uint32_t MATCH_ACTIVE;  ///< Offset: 0x10 - Interrupt setup register 0
        volatile uint32_t DOTW_ENA;  ///< Offset: 0x14 - Interrupt setup register 1
        volatile uint32_t RTC;  ///< Offset: 0x2C - Interrupt status after masking & forcing
    };

    /// Peripheral instances
    inline Registers* RTC_IRQ = reinterpret_cast<Registers*>(RTC_IRQ_BASE);

}

// ============================================================================
// ROSC Peripheral
// ============================================================================

namespace rosc {
    /// Base addresses
    constexpr uint32_t ROSC_BASE = 0x40060000;

    /// ROSC Register structure
    struct Registers {
        volatile uint32_t DISABLE;  ///< Offset: 0x00 - Ring Oscillator control
        volatile uint32_t PASS;  ///< Offset: 0x10 - Controls the output divider
        volatile uint32_t DORMANT;  ///< Offset: 0x0C - Ring Oscillator pause control\n This is used to save...
        volatile uint32_t PASSWD;  ///< Offset: 0x14 - Controls the phase shifted output
        volatile uint32_t STABLE;  ///< Offset: 0x18 - Ring Oscillator Status
        volatile uint32_t RANDOMBIT;  ///< Offset: 0x1C - This just reads the state of the oscillator output so...
        volatile uint32_t COUNT;  ///< Offset: 0x20 - A down counter running at the ROSC frequency which...
    };

    /// Peripheral instances
    inline Registers* ROSC = reinterpret_cast<Registers*>(ROSC_BASE);

}

// ============================================================================
// VREG Peripheral
// ============================================================================

namespace vreg {
    /// Base addresses
    constexpr uint32_t VREG_AND_CHIP_RESET_BASE = 0x40064000;

    /// VREG Register structure
    struct Registers {
        volatile uint32_t ROK;  ///< Offset: 0x00 - Voltage regulator control and status
        volatile uint32_t VSEL;  ///< Offset: 0x04 - brown-out detection control
        volatile uint32_t PSM_RESTART_FLAG;  ///< Offset: 0x08 - Chip reset control and status
    };

    /// Peripheral instances
    inline Registers* VREG_AND_CHIP_RESET = reinterpret_cast<Registers*>(VREG_AND_CHIP_RESET_BASE);

}

// ============================================================================
// TBMAN Peripheral
// ============================================================================

namespace tbman {
    /// Base addresses
    constexpr uint32_t TBMAN_BASE = 0x4006C000;

    /// TBMAN Register structure
    struct Registers {
        volatile uint32_t FPGA;  ///< Offset: 0x00 - Indicates the type of platform in use
    };

    /// Peripheral instances
    inline Registers* TBMAN = reinterpret_cast<Registers*>(TBMAN_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_IRQ_0_BASE = 0x50000000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CH0_READ_ADDR;  ///< Offset: 0x00 - DMA Channel 0 Read Address pointer\n This register...
        volatile uint32_t CH0_WRITE_ADDR;  ///< Offset: 0x04 - DMA Channel 0 Write Address pointer\n This register...
        volatile uint32_t CH0_TRANS_COUNT;  ///< Offset: 0x08 - DMA Channel 0 Transfer Count\n Program the number of bus...
        volatile uint32_t AHB_ERROR;  ///< Offset: 0x2CC - DMA Channel 11 Control and Status
        volatile uint32_t CH0_AL1_CTRL;  ///< Offset: 0x10 - Alias for channel 0 CTRL register
        volatile uint32_t CH0_AL1_READ_ADDR;  ///< Offset: 0x14 - Alias for channel 0 READ_ADDR register
        volatile uint32_t CH0_AL1_WRITE_ADDR;  ///< Offset: 0x18 - Alias for channel 0 WRITE_ADDR register
        volatile uint32_t CH0_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x1C - Alias for channel 0 TRANS_COUNT register\n This is a...
        volatile uint32_t CH0_AL2_CTRL;  ///< Offset: 0x20 - Alias for channel 0 CTRL register
        volatile uint32_t CH0_AL2_TRANS_COUNT;  ///< Offset: 0x24 - Alias for channel 0 TRANS_COUNT register
        volatile uint32_t CH0_AL2_READ_ADDR;  ///< Offset: 0x28 - Alias for channel 0 READ_ADDR register
        volatile uint32_t CH0_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x2C - Alias for channel 0 WRITE_ADDR register\n This is a...
        volatile uint32_t CH0_AL3_CTRL;  ///< Offset: 0x30 - Alias for channel 0 CTRL register
        volatile uint32_t CH0_AL3_WRITE_ADDR;  ///< Offset: 0x34 - Alias for channel 0 WRITE_ADDR register
        volatile uint32_t CH0_AL3_TRANS_COUNT;  ///< Offset: 0x38 - Alias for channel 0 TRANS_COUNT register
        volatile uint32_t CH0_AL3_READ_ADDR_TRIG;  ///< Offset: 0x3C - Alias for channel 0 READ_ADDR register\n This is a...
        volatile uint32_t CH1_READ_ADDR;  ///< Offset: 0x40 - DMA Channel 1 Read Address pointer\n This register...
        volatile uint32_t CH1_WRITE_ADDR;  ///< Offset: 0x44 - DMA Channel 1 Write Address pointer\n This register...
        volatile uint32_t CH1_TRANS_COUNT;  ///< Offset: 0x48 - DMA Channel 1 Transfer Count\n Program the number of bus...
        volatile uint32_t CH1_AL1_CTRL;  ///< Offset: 0x50 - Alias for channel 1 CTRL register
        volatile uint32_t CH1_AL1_READ_ADDR;  ///< Offset: 0x54 - Alias for channel 1 READ_ADDR register
        volatile uint32_t CH1_AL1_WRITE_ADDR;  ///< Offset: 0x58 - Alias for channel 1 WRITE_ADDR register
        volatile uint32_t CH1_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x5C - Alias for channel 1 TRANS_COUNT register\n This is a...
        volatile uint32_t CH1_AL2_CTRL;  ///< Offset: 0x60 - Alias for channel 1 CTRL register
        volatile uint32_t CH1_AL2_TRANS_COUNT;  ///< Offset: 0x64 - Alias for channel 1 TRANS_COUNT register
        volatile uint32_t CH1_AL2_READ_ADDR;  ///< Offset: 0x68 - Alias for channel 1 READ_ADDR register
        volatile uint32_t CH1_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x6C - Alias for channel 1 WRITE_ADDR register\n This is a...
        volatile uint32_t CH1_AL3_CTRL;  ///< Offset: 0x70 - Alias for channel 1 CTRL register
        volatile uint32_t CH1_AL3_WRITE_ADDR;  ///< Offset: 0x74 - Alias for channel 1 WRITE_ADDR register
        volatile uint32_t CH1_AL3_TRANS_COUNT;  ///< Offset: 0x78 - Alias for channel 1 TRANS_COUNT register
        volatile uint32_t CH1_AL3_READ_ADDR_TRIG;  ///< Offset: 0x7C - Alias for channel 1 READ_ADDR register\n This is a...
        volatile uint32_t CH2_READ_ADDR;  ///< Offset: 0x80 - DMA Channel 2 Read Address pointer\n This register...
        volatile uint32_t CH2_WRITE_ADDR;  ///< Offset: 0x84 - DMA Channel 2 Write Address pointer\n This register...
        volatile uint32_t CH2_TRANS_COUNT;  ///< Offset: 0x88 - DMA Channel 2 Transfer Count\n Program the number of bus...
        volatile uint32_t CH2_AL1_CTRL;  ///< Offset: 0x90 - Alias for channel 2 CTRL register
        volatile uint32_t CH2_AL1_READ_ADDR;  ///< Offset: 0x94 - Alias for channel 2 READ_ADDR register
        volatile uint32_t CH2_AL1_WRITE_ADDR;  ///< Offset: 0x98 - Alias for channel 2 WRITE_ADDR register
        volatile uint32_t CH2_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x9C - Alias for channel 2 TRANS_COUNT register\n This is a...
        volatile uint32_t CH2_AL2_CTRL;  ///< Offset: 0xA0 - Alias for channel 2 CTRL register
        volatile uint32_t CH2_AL2_TRANS_COUNT;  ///< Offset: 0xA4 - Alias for channel 2 TRANS_COUNT register
        volatile uint32_t CH2_AL2_READ_ADDR;  ///< Offset: 0xA8 - Alias for channel 2 READ_ADDR register
        volatile uint32_t CH2_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0xAC - Alias for channel 2 WRITE_ADDR register\n This is a...
        volatile uint32_t CH2_AL3_CTRL;  ///< Offset: 0xB0 - Alias for channel 2 CTRL register
        volatile uint32_t CH2_AL3_WRITE_ADDR;  ///< Offset: 0xB4 - Alias for channel 2 WRITE_ADDR register
        volatile uint32_t CH2_AL3_TRANS_COUNT;  ///< Offset: 0xB8 - Alias for channel 2 TRANS_COUNT register
        volatile uint32_t CH2_AL3_READ_ADDR_TRIG;  ///< Offset: 0xBC - Alias for channel 2 READ_ADDR register\n This is a...
        volatile uint32_t CH3_READ_ADDR;  ///< Offset: 0xC0 - DMA Channel 3 Read Address pointer\n This register...
        volatile uint32_t CH3_WRITE_ADDR;  ///< Offset: 0xC4 - DMA Channel 3 Write Address pointer\n This register...
        volatile uint32_t CH3_TRANS_COUNT;  ///< Offset: 0xC8 - DMA Channel 3 Transfer Count\n Program the number of bus...
        volatile uint32_t CH3_AL1_CTRL;  ///< Offset: 0xD0 - Alias for channel 3 CTRL register
        volatile uint32_t CH3_AL1_READ_ADDR;  ///< Offset: 0xD4 - Alias for channel 3 READ_ADDR register
        volatile uint32_t CH3_AL1_WRITE_ADDR;  ///< Offset: 0xD8 - Alias for channel 3 WRITE_ADDR register
        volatile uint32_t CH3_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0xDC - Alias for channel 3 TRANS_COUNT register\n This is a...
        volatile uint32_t CH3_AL2_CTRL;  ///< Offset: 0xE0 - Alias for channel 3 CTRL register
        volatile uint32_t CH3_AL2_TRANS_COUNT;  ///< Offset: 0xE4 - Alias for channel 3 TRANS_COUNT register
        volatile uint32_t CH3_AL2_READ_ADDR;  ///< Offset: 0xE8 - Alias for channel 3 READ_ADDR register
        volatile uint32_t CH3_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0xEC - Alias for channel 3 WRITE_ADDR register\n This is a...
        volatile uint32_t CH3_AL3_CTRL;  ///< Offset: 0xF0 - Alias for channel 3 CTRL register
        volatile uint32_t CH3_AL3_WRITE_ADDR;  ///< Offset: 0xF4 - Alias for channel 3 WRITE_ADDR register
        volatile uint32_t CH3_AL3_TRANS_COUNT;  ///< Offset: 0xF8 - Alias for channel 3 TRANS_COUNT register
        volatile uint32_t CH3_AL3_READ_ADDR_TRIG;  ///< Offset: 0xFC - Alias for channel 3 READ_ADDR register\n This is a...
        volatile uint32_t CH4_READ_ADDR;  ///< Offset: 0x100 - DMA Channel 4 Read Address pointer\n This register...
        volatile uint32_t CH4_WRITE_ADDR;  ///< Offset: 0x104 - DMA Channel 4 Write Address pointer\n This register...
        volatile uint32_t CH4_TRANS_COUNT;  ///< Offset: 0x108 - DMA Channel 4 Transfer Count\n Program the number of bus...
        volatile uint32_t CH4_AL1_CTRL;  ///< Offset: 0x110 - Alias for channel 4 CTRL register
        volatile uint32_t CH4_AL1_READ_ADDR;  ///< Offset: 0x114 - Alias for channel 4 READ_ADDR register
        volatile uint32_t CH4_AL1_WRITE_ADDR;  ///< Offset: 0x118 - Alias for channel 4 WRITE_ADDR register
        volatile uint32_t CH4_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x11C - Alias for channel 4 TRANS_COUNT register\n This is a...
        volatile uint32_t CH4_AL2_CTRL;  ///< Offset: 0x120 - Alias for channel 4 CTRL register
        volatile uint32_t CH4_AL2_TRANS_COUNT;  ///< Offset: 0x124 - Alias for channel 4 TRANS_COUNT register
        volatile uint32_t CH4_AL2_READ_ADDR;  ///< Offset: 0x128 - Alias for channel 4 READ_ADDR register
        volatile uint32_t CH4_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x12C - Alias for channel 4 WRITE_ADDR register\n This is a...
        volatile uint32_t CH4_AL3_CTRL;  ///< Offset: 0x130 - Alias for channel 4 CTRL register
        volatile uint32_t CH4_AL3_WRITE_ADDR;  ///< Offset: 0x134 - Alias for channel 4 WRITE_ADDR register
        volatile uint32_t CH4_AL3_TRANS_COUNT;  ///< Offset: 0x138 - Alias for channel 4 TRANS_COUNT register
        volatile uint32_t CH4_AL3_READ_ADDR_TRIG;  ///< Offset: 0x13C - Alias for channel 4 READ_ADDR register\n This is a...
        volatile uint32_t CH5_READ_ADDR;  ///< Offset: 0x140 - DMA Channel 5 Read Address pointer\n This register...
        volatile uint32_t CH5_WRITE_ADDR;  ///< Offset: 0x144 - DMA Channel 5 Write Address pointer\n This register...
        volatile uint32_t CH5_TRANS_COUNT;  ///< Offset: 0x148 - DMA Channel 5 Transfer Count\n Program the number of bus...
        volatile uint32_t CH5_AL1_CTRL;  ///< Offset: 0x150 - Alias for channel 5 CTRL register
        volatile uint32_t CH5_AL1_READ_ADDR;  ///< Offset: 0x154 - Alias for channel 5 READ_ADDR register
        volatile uint32_t CH5_AL1_WRITE_ADDR;  ///< Offset: 0x158 - Alias for channel 5 WRITE_ADDR register
        volatile uint32_t CH5_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x15C - Alias for channel 5 TRANS_COUNT register\n This is a...
        volatile uint32_t CH5_AL2_CTRL;  ///< Offset: 0x160 - Alias for channel 5 CTRL register
        volatile uint32_t CH5_AL2_TRANS_COUNT;  ///< Offset: 0x164 - Alias for channel 5 TRANS_COUNT register
        volatile uint32_t CH5_AL2_READ_ADDR;  ///< Offset: 0x168 - Alias for channel 5 READ_ADDR register
        volatile uint32_t CH5_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x16C - Alias for channel 5 WRITE_ADDR register\n This is a...
        volatile uint32_t CH5_AL3_CTRL;  ///< Offset: 0x170 - Alias for channel 5 CTRL register
        volatile uint32_t CH5_AL3_WRITE_ADDR;  ///< Offset: 0x174 - Alias for channel 5 WRITE_ADDR register
        volatile uint32_t CH5_AL3_TRANS_COUNT;  ///< Offset: 0x178 - Alias for channel 5 TRANS_COUNT register
        volatile uint32_t CH5_AL3_READ_ADDR_TRIG;  ///< Offset: 0x17C - Alias for channel 5 READ_ADDR register\n This is a...
        volatile uint32_t CH6_READ_ADDR;  ///< Offset: 0x180 - DMA Channel 6 Read Address pointer\n This register...
        volatile uint32_t CH6_WRITE_ADDR;  ///< Offset: 0x184 - DMA Channel 6 Write Address pointer\n This register...
        volatile uint32_t CH6_TRANS_COUNT;  ///< Offset: 0x188 - DMA Channel 6 Transfer Count\n Program the number of bus...
        volatile uint32_t CH6_AL1_CTRL;  ///< Offset: 0x190 - Alias for channel 6 CTRL register
        volatile uint32_t CH6_AL1_READ_ADDR;  ///< Offset: 0x194 - Alias for channel 6 READ_ADDR register
        volatile uint32_t CH6_AL1_WRITE_ADDR;  ///< Offset: 0x198 - Alias for channel 6 WRITE_ADDR register
        volatile uint32_t CH6_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x19C - Alias for channel 6 TRANS_COUNT register\n This is a...
        volatile uint32_t CH6_AL2_CTRL;  ///< Offset: 0x1A0 - Alias for channel 6 CTRL register
        volatile uint32_t CH6_AL2_TRANS_COUNT;  ///< Offset: 0x1A4 - Alias for channel 6 TRANS_COUNT register
        volatile uint32_t CH6_AL2_READ_ADDR;  ///< Offset: 0x1A8 - Alias for channel 6 READ_ADDR register
        volatile uint32_t CH6_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x1AC - Alias for channel 6 WRITE_ADDR register\n This is a...
        volatile uint32_t CH6_AL3_CTRL;  ///< Offset: 0x1B0 - Alias for channel 6 CTRL register
        volatile uint32_t CH6_AL3_WRITE_ADDR;  ///< Offset: 0x1B4 - Alias for channel 6 WRITE_ADDR register
        volatile uint32_t CH6_AL3_TRANS_COUNT;  ///< Offset: 0x1B8 - Alias for channel 6 TRANS_COUNT register
        volatile uint32_t CH6_AL3_READ_ADDR_TRIG;  ///< Offset: 0x1BC - Alias for channel 6 READ_ADDR register\n This is a...
        volatile uint32_t CH7_READ_ADDR;  ///< Offset: 0x1C0 - DMA Channel 7 Read Address pointer\n This register...
        volatile uint32_t CH7_WRITE_ADDR;  ///< Offset: 0x1C4 - DMA Channel 7 Write Address pointer\n This register...
        volatile uint32_t CH7_TRANS_COUNT;  ///< Offset: 0x1C8 - DMA Channel 7 Transfer Count\n Program the number of bus...
        volatile uint32_t CH7_AL1_CTRL;  ///< Offset: 0x1D0 - Alias for channel 7 CTRL register
        volatile uint32_t CH7_AL1_READ_ADDR;  ///< Offset: 0x1D4 - Alias for channel 7 READ_ADDR register
        volatile uint32_t CH7_AL1_WRITE_ADDR;  ///< Offset: 0x1D8 - Alias for channel 7 WRITE_ADDR register
        volatile uint32_t CH7_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x1DC - Alias for channel 7 TRANS_COUNT register\n This is a...
        volatile uint32_t CH7_AL2_CTRL;  ///< Offset: 0x1E0 - Alias for channel 7 CTRL register
        volatile uint32_t CH7_AL2_TRANS_COUNT;  ///< Offset: 0x1E4 - Alias for channel 7 TRANS_COUNT register
        volatile uint32_t CH7_AL2_READ_ADDR;  ///< Offset: 0x1E8 - Alias for channel 7 READ_ADDR register
        volatile uint32_t CH7_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x1EC - Alias for channel 7 WRITE_ADDR register\n This is a...
        volatile uint32_t CH7_AL3_CTRL;  ///< Offset: 0x1F0 - Alias for channel 7 CTRL register
        volatile uint32_t CH7_AL3_WRITE_ADDR;  ///< Offset: 0x1F4 - Alias for channel 7 WRITE_ADDR register
        volatile uint32_t CH7_AL3_TRANS_COUNT;  ///< Offset: 0x1F8 - Alias for channel 7 TRANS_COUNT register
        volatile uint32_t CH7_AL3_READ_ADDR_TRIG;  ///< Offset: 0x1FC - Alias for channel 7 READ_ADDR register\n This is a...
        volatile uint32_t CH8_READ_ADDR;  ///< Offset: 0x200 - DMA Channel 8 Read Address pointer\n This register...
        volatile uint32_t CH8_WRITE_ADDR;  ///< Offset: 0x204 - DMA Channel 8 Write Address pointer\n This register...
        volatile uint32_t CH8_TRANS_COUNT;  ///< Offset: 0x208 - DMA Channel 8 Transfer Count\n Program the number of bus...
        volatile uint32_t CH8_AL1_CTRL;  ///< Offset: 0x210 - Alias for channel 8 CTRL register
        volatile uint32_t CH8_AL1_READ_ADDR;  ///< Offset: 0x214 - Alias for channel 8 READ_ADDR register
        volatile uint32_t CH8_AL1_WRITE_ADDR;  ///< Offset: 0x218 - Alias for channel 8 WRITE_ADDR register
        volatile uint32_t CH8_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x21C - Alias for channel 8 TRANS_COUNT register\n This is a...
        volatile uint32_t CH8_AL2_CTRL;  ///< Offset: 0x220 - Alias for channel 8 CTRL register
        volatile uint32_t CH8_AL2_TRANS_COUNT;  ///< Offset: 0x224 - Alias for channel 8 TRANS_COUNT register
        volatile uint32_t CH8_AL2_READ_ADDR;  ///< Offset: 0x228 - Alias for channel 8 READ_ADDR register
        volatile uint32_t CH8_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x22C - Alias for channel 8 WRITE_ADDR register\n This is a...
        volatile uint32_t CH8_AL3_CTRL;  ///< Offset: 0x230 - Alias for channel 8 CTRL register
        volatile uint32_t CH8_AL3_WRITE_ADDR;  ///< Offset: 0x234 - Alias for channel 8 WRITE_ADDR register
        volatile uint32_t CH8_AL3_TRANS_COUNT;  ///< Offset: 0x238 - Alias for channel 8 TRANS_COUNT register
        volatile uint32_t CH8_AL3_READ_ADDR_TRIG;  ///< Offset: 0x23C - Alias for channel 8 READ_ADDR register\n This is a...
        volatile uint32_t CH9_READ_ADDR;  ///< Offset: 0x240 - DMA Channel 9 Read Address pointer\n This register...
        volatile uint32_t CH9_WRITE_ADDR;  ///< Offset: 0x244 - DMA Channel 9 Write Address pointer\n This register...
        volatile uint32_t CH9_TRANS_COUNT;  ///< Offset: 0x248 - DMA Channel 9 Transfer Count\n Program the number of bus...
        volatile uint32_t CH9_AL1_CTRL;  ///< Offset: 0x250 - Alias for channel 9 CTRL register
        volatile uint32_t CH9_AL1_READ_ADDR;  ///< Offset: 0x254 - Alias for channel 9 READ_ADDR register
        volatile uint32_t CH9_AL1_WRITE_ADDR;  ///< Offset: 0x258 - Alias for channel 9 WRITE_ADDR register
        volatile uint32_t CH9_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x25C - Alias for channel 9 TRANS_COUNT register\n This is a...
        volatile uint32_t CH9_AL2_CTRL;  ///< Offset: 0x260 - Alias for channel 9 CTRL register
        volatile uint32_t CH9_AL2_TRANS_COUNT;  ///< Offset: 0x264 - Alias for channel 9 TRANS_COUNT register
        volatile uint32_t CH9_AL2_READ_ADDR;  ///< Offset: 0x268 - Alias for channel 9 READ_ADDR register
        volatile uint32_t CH9_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x26C - Alias for channel 9 WRITE_ADDR register\n This is a...
        volatile uint32_t CH9_AL3_CTRL;  ///< Offset: 0x270 - Alias for channel 9 CTRL register
        volatile uint32_t CH9_AL3_WRITE_ADDR;  ///< Offset: 0x274 - Alias for channel 9 WRITE_ADDR register
        volatile uint32_t CH9_AL3_TRANS_COUNT;  ///< Offset: 0x278 - Alias for channel 9 TRANS_COUNT register
        volatile uint32_t CH9_AL3_READ_ADDR_TRIG;  ///< Offset: 0x27C - Alias for channel 9 READ_ADDR register\n This is a...
        volatile uint32_t CH10_READ_ADDR;  ///< Offset: 0x280 - DMA Channel 10 Read Address pointer\n This register...
        volatile uint32_t CH10_WRITE_ADDR;  ///< Offset: 0x284 - DMA Channel 10 Write Address pointer\n This register...
        volatile uint32_t CH10_TRANS_COUNT;  ///< Offset: 0x288 - DMA Channel 10 Transfer Count\n Program the number of...
        volatile uint32_t CH10_AL1_CTRL;  ///< Offset: 0x290 - Alias for channel 10 CTRL register
        volatile uint32_t CH10_AL1_READ_ADDR;  ///< Offset: 0x294 - Alias for channel 10 READ_ADDR register
        volatile uint32_t CH10_AL1_WRITE_ADDR;  ///< Offset: 0x298 - Alias for channel 10 WRITE_ADDR register
        volatile uint32_t CH10_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x29C - Alias for channel 10 TRANS_COUNT register\n This is a...
        volatile uint32_t CH10_AL2_CTRL;  ///< Offset: 0x2A0 - Alias for channel 10 CTRL register
        volatile uint32_t CH10_AL2_TRANS_COUNT;  ///< Offset: 0x2A4 - Alias for channel 10 TRANS_COUNT register
        volatile uint32_t CH10_AL2_READ_ADDR;  ///< Offset: 0x2A8 - Alias for channel 10 READ_ADDR register
        volatile uint32_t CH10_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x2AC - Alias for channel 10 WRITE_ADDR register\n This is a...
        volatile uint32_t CH10_AL3_CTRL;  ///< Offset: 0x2B0 - Alias for channel 10 CTRL register
        volatile uint32_t CH10_AL3_WRITE_ADDR;  ///< Offset: 0x2B4 - Alias for channel 10 WRITE_ADDR register
        volatile uint32_t CH10_AL3_TRANS_COUNT;  ///< Offset: 0x2B8 - Alias for channel 10 TRANS_COUNT register
        volatile uint32_t CH10_AL3_READ_ADDR_TRIG;  ///< Offset: 0x2BC - Alias for channel 10 READ_ADDR register\n This is a...
        volatile uint32_t CH11_READ_ADDR;  ///< Offset: 0x2C0 - DMA Channel 11 Read Address pointer\n This register...
        volatile uint32_t CH11_WRITE_ADDR;  ///< Offset: 0x2C4 - DMA Channel 11 Write Address pointer\n This register...
        volatile uint32_t CH11_TRANS_COUNT;  ///< Offset: 0x2C8 - DMA Channel 11 Transfer Count\n Program the number of...
        volatile uint32_t CH11_AL1_CTRL;  ///< Offset: 0x2D0 - Alias for channel 11 CTRL register
        volatile uint32_t CH11_AL1_READ_ADDR;  ///< Offset: 0x2D4 - Alias for channel 11 READ_ADDR register
        volatile uint32_t CH11_AL1_WRITE_ADDR;  ///< Offset: 0x2D8 - Alias for channel 11 WRITE_ADDR register
        volatile uint32_t CH11_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x2DC - Alias for channel 11 TRANS_COUNT register\n This is a...
        volatile uint32_t CH11_AL2_CTRL;  ///< Offset: 0x2E0 - Alias for channel 11 CTRL register
        volatile uint32_t CH11_AL2_TRANS_COUNT;  ///< Offset: 0x2E4 - Alias for channel 11 TRANS_COUNT register
        volatile uint32_t CH11_AL2_READ_ADDR;  ///< Offset: 0x2E8 - Alias for channel 11 READ_ADDR register
        volatile uint32_t CH11_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x2EC - Alias for channel 11 WRITE_ADDR register\n This is a...
        volatile uint32_t CH11_AL3_CTRL;  ///< Offset: 0x2F0 - Alias for channel 11 CTRL register
        volatile uint32_t CH11_AL3_WRITE_ADDR;  ///< Offset: 0x2F4 - Alias for channel 11 WRITE_ADDR register
        volatile uint32_t CH11_AL3_TRANS_COUNT;  ///< Offset: 0x2F8 - Alias for channel 11 TRANS_COUNT register
        volatile uint32_t CH11_AL3_READ_ADDR_TRIG;  ///< Offset: 0x2FC - Alias for channel 11 READ_ADDR register\n This is a...
        volatile uint32_t INTR;  ///< Offset: 0x400 - Interrupt Status (raw)
        volatile uint32_t INTE0;  ///< Offset: 0x404 - Interrupt Enables for IRQ 0
        volatile uint32_t INTF0;  ///< Offset: 0x408 - Force Interrupts
        volatile uint32_t INTS0;  ///< Offset: 0x40C - Interrupt Status for IRQ 0
        volatile uint32_t INTE1;  ///< Offset: 0x414 - Interrupt Enables for IRQ 1
        volatile uint32_t INTF1;  ///< Offset: 0x418 - Force Interrupts for IRQ 1
        volatile uint32_t INTS1;  ///< Offset: 0x41C - Interrupt Status (masked) for IRQ 1
        volatile uint32_t X;  ///< Offset: 0x424 - Pacing (X/Y) Fractional Timer\n The pacing timer...
        volatile uint32_t MULTI_CHAN_TRIGGER;  ///< Offset: 0x430 - Trigger one or more channels simultaneously
        volatile uint32_t OUT_INV;  ///< Offset: 0x434 - Sniffer Control
        volatile uint32_t SNIFF_DATA;  ///< Offset: 0x438 - Data accumulator for sniff hardware\n Write an initial...
        volatile uint32_t RAF_LVL;  ///< Offset: 0x440 - Debug RAF, WAF, TDF levels
        volatile uint32_t CHAN_ABORT;  ///< Offset: 0x444 - Abort an in-progress transfer sequence on one or more channels
        volatile uint32_t N_CHANNELS;  ///< Offset: 0x448 - The number of channels this DMA instance is equipped...
        volatile uint32_t CH0_DBG_CTDREQ;  ///< Offset: 0x800 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH0_DBG_TCR;  ///< Offset: 0x804 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH1_DBG_CTDREQ;  ///< Offset: 0x840 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH1_DBG_TCR;  ///< Offset: 0x844 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH2_DBG_CTDREQ;  ///< Offset: 0x880 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH2_DBG_TCR;  ///< Offset: 0x884 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH3_DBG_CTDREQ;  ///< Offset: 0x8C0 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH3_DBG_TCR;  ///< Offset: 0x8C4 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH4_DBG_CTDREQ;  ///< Offset: 0x900 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH4_DBG_TCR;  ///< Offset: 0x904 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH5_DBG_CTDREQ;  ///< Offset: 0x940 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH5_DBG_TCR;  ///< Offset: 0x944 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH6_DBG_CTDREQ;  ///< Offset: 0x980 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH6_DBG_TCR;  ///< Offset: 0x984 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH7_DBG_CTDREQ;  ///< Offset: 0x9C0 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH7_DBG_TCR;  ///< Offset: 0x9C4 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH8_DBG_CTDREQ;  ///< Offset: 0xA00 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH8_DBG_TCR;  ///< Offset: 0xA04 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH9_DBG_CTDREQ;  ///< Offset: 0xA40 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH9_DBG_TCR;  ///< Offset: 0xA44 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH10_DBG_CTDREQ;  ///< Offset: 0xA80 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH10_DBG_TCR;  ///< Offset: 0xA84 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH11_DBG_CTDREQ;  ///< Offset: 0xAC0 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH11_DBG_TCR;  ///< Offset: 0xAC4 - Read to get channel TRANS_COUNT reload value, i.e. the...
    };

    /// Peripheral instances
    inline Registers* DMA_IRQ_0 = reinterpret_cast<Registers*>(DMA_IRQ_0_BASE);

}

// ============================================================================
// PIO0 Peripheral
// ============================================================================

namespace pio0 {
    /// Base addresses
    constexpr uint32_t PIO0_IRQ_0_BASE = 0x50200000;

    /// PIO0 Register structure
    struct Registers {
        volatile uint32_t CLKDIV_RESTART;  ///< Offset: 0x00 - PIO control register
        volatile uint32_t TXEMPTY;  ///< Offset: 0x04 - FIFO status register
        volatile uint32_t TXSTALL;  ///< Offset: 0x08 - FIFO debug register
        volatile uint32_t RX3;  ///< Offset: 0x0C - FIFO levels
        volatile uint32_t TXF0;  ///< Offset: 0x10 - Direct write access to the TX FIFO for this state...
        volatile uint32_t TXF1;  ///< Offset: 0x14 - Direct write access to the TX FIFO for this state...
        volatile uint32_t TXF2;  ///< Offset: 0x18 - Direct write access to the TX FIFO for this state...
        volatile uint32_t TXF3;  ///< Offset: 0x1C - Direct write access to the TX FIFO for this state...
        volatile uint32_t RXF0;  ///< Offset: 0x20 - Direct read access to the RX FIFO for this state...
        volatile uint32_t RXF1;  ///< Offset: 0x24 - Direct read access to the RX FIFO for this state...
        volatile uint32_t RXF2;  ///< Offset: 0x28 - Direct read access to the RX FIFO for this state...
        volatile uint32_t RXF3;  ///< Offset: 0x2C - Direct read access to the RX FIFO for this state...
        volatile uint32_t IRQ;  ///< Offset: 0x30 - Interrupt request register. Write 1 to clear
        volatile uint32_t IRQ_FORCE;  ///< Offset: 0x34 - Writing a 1 to each of these bits will forcibly assert...
        volatile uint32_t INPUT_SYNC_BYPASS;  ///< Offset: 0x38 - There is a 2-flipflop synchronizer on each GPIO input,...
        volatile uint32_t DBG_PADOUT;  ///< Offset: 0x3C - Read to sample the pad output values PIO is currently...
        volatile uint32_t DBG_PADOE;  ///< Offset: 0x40 - Read to sample the pad output enables (direction) PIO is...
        volatile uint32_t IMEM_SIZE;  ///< Offset: 0x44 - The PIO hardware has some free parameters that may vary...
        volatile uint32_t INSTR_MEM0;  ///< Offset: 0x48 - Write-only access to instruction memory location 0
        volatile uint32_t INSTR_MEM1;  ///< Offset: 0x4C - Write-only access to instruction memory location 1
        volatile uint32_t INSTR_MEM2;  ///< Offset: 0x50 - Write-only access to instruction memory location 2
        volatile uint32_t INSTR_MEM3;  ///< Offset: 0x54 - Write-only access to instruction memory location 3
        volatile uint32_t INSTR_MEM4;  ///< Offset: 0x58 - Write-only access to instruction memory location 4
        volatile uint32_t INSTR_MEM5;  ///< Offset: 0x5C - Write-only access to instruction memory location 5
        volatile uint32_t INSTR_MEM6;  ///< Offset: 0x60 - Write-only access to instruction memory location 6
        volatile uint32_t INSTR_MEM7;  ///< Offset: 0x64 - Write-only access to instruction memory location 7
        volatile uint32_t INSTR_MEM8;  ///< Offset: 0x68 - Write-only access to instruction memory location 8
        volatile uint32_t INSTR_MEM9;  ///< Offset: 0x6C - Write-only access to instruction memory location 9
        volatile uint32_t INSTR_MEM10;  ///< Offset: 0x70 - Write-only access to instruction memory location 10
        volatile uint32_t INSTR_MEM11;  ///< Offset: 0x74 - Write-only access to instruction memory location 11
        volatile uint32_t INSTR_MEM12;  ///< Offset: 0x78 - Write-only access to instruction memory location 12
        volatile uint32_t INSTR_MEM13;  ///< Offset: 0x7C - Write-only access to instruction memory location 13
        volatile uint32_t INSTR_MEM14;  ///< Offset: 0x80 - Write-only access to instruction memory location 14
        volatile uint32_t INSTR_MEM15;  ///< Offset: 0x84 - Write-only access to instruction memory location 15
        volatile uint32_t INSTR_MEM16;  ///< Offset: 0x88 - Write-only access to instruction memory location 16
        volatile uint32_t INSTR_MEM17;  ///< Offset: 0x8C - Write-only access to instruction memory location 17
        volatile uint32_t INSTR_MEM18;  ///< Offset: 0x90 - Write-only access to instruction memory location 18
        volatile uint32_t INSTR_MEM19;  ///< Offset: 0x94 - Write-only access to instruction memory location 19
        volatile uint32_t INSTR_MEM20;  ///< Offset: 0x98 - Write-only access to instruction memory location 20
        volatile uint32_t INSTR_MEM21;  ///< Offset: 0x9C - Write-only access to instruction memory location 21
        volatile uint32_t INSTR_MEM22;  ///< Offset: 0xA0 - Write-only access to instruction memory location 22
        volatile uint32_t INSTR_MEM23;  ///< Offset: 0xA4 - Write-only access to instruction memory location 23
        volatile uint32_t INSTR_MEM24;  ///< Offset: 0xA8 - Write-only access to instruction memory location 24
        volatile uint32_t INSTR_MEM25;  ///< Offset: 0xAC - Write-only access to instruction memory location 25
        volatile uint32_t INSTR_MEM26;  ///< Offset: 0xB0 - Write-only access to instruction memory location 26
        volatile uint32_t INSTR_MEM27;  ///< Offset: 0xB4 - Write-only access to instruction memory location 27
        volatile uint32_t INSTR_MEM28;  ///< Offset: 0xB8 - Write-only access to instruction memory location 28
        volatile uint32_t INSTR_MEM29;  ///< Offset: 0xBC - Write-only access to instruction memory location 29
        volatile uint32_t INSTR_MEM30;  ///< Offset: 0xC0 - Write-only access to instruction memory location 30
        volatile uint32_t INSTR_MEM31;  ///< Offset: 0xC4 - Write-only access to instruction memory location 31
        volatile uint32_t INT;  ///< Offset: 0x110 - Clock divider register for state machine 3\n Frequency =...
        volatile uint32_t EXEC_STALLED;  ///< Offset: 0x114 - Execution/behavioural settings for state machine 3
        volatile uint32_t FJOIN_RX;  ///< Offset: 0x118 - Control behaviour of the input/output shift registers...
        volatile uint32_t SM0_ADDR;  ///< Offset: 0xD4 - Current instruction address of state machine 0
        volatile uint32_t SM0_INSTR;  ///< Offset: 0xD8 - Instruction currently being executed by state machine...
        volatile uint32_t SIDESET_COUNT;  ///< Offset: 0x124 - State machine pin control
        volatile uint32_t SM1_ADDR;  ///< Offset: 0xEC - Current instruction address of state machine 1
        volatile uint32_t SM1_INSTR;  ///< Offset: 0xF0 - Instruction currently being executed by state machine...
        volatile uint32_t SM2_ADDR;  ///< Offset: 0x104 - Current instruction address of state machine 2
        volatile uint32_t SM2_INSTR;  ///< Offset: 0x108 - Instruction currently being executed by state machine...
        volatile uint32_t SM3_ADDR;  ///< Offset: 0x11C - Current instruction address of state machine 3
        volatile uint32_t SM3_INSTR;  ///< Offset: 0x120 - Instruction currently being executed by state machine...
        volatile uint32_t SM3;  ///< Offset: 0x140 - Interrupt status after masking & forcing for irq1
    };

    /// Peripheral instances
    inline Registers* PIO0_IRQ_0 = reinterpret_cast<Registers*>(PIO0_IRQ_0_BASE);

}

// ============================================================================
// PIO1 Peripheral
// ============================================================================

namespace pio1 {
    /// Base addresses
    constexpr uint32_t PIO1_IRQ_0_BASE = 0x50300000;

    /// PIO1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* PIO1_IRQ_0 = reinterpret_cast<Registers*>(PIO1_IRQ_0_BASE);

}

// ============================================================================
// SIO Peripheral
// ============================================================================

namespace sio {
    /// Base addresses
    constexpr uint32_t SIO_IRQ_PROC0_BASE = 0xD0000000;

    /// SIO Register structure
    struct Registers {
        volatile uint32_t CPUID;  ///< Offset: 0x00 - Processor core identifier\n Value is 0 when read from...
        volatile uint32_t GPIO_IN;  ///< Offset: 0x04 - Input value for GPIO pins
        volatile uint32_t GPIO_HI_IN;  ///< Offset: 0x08 - Input value for QSPI pins
        volatile uint32_t GPIO_OUT;  ///< Offset: 0x10 - GPIO output value
        volatile uint32_t GPIO_OUT_SET;  ///< Offset: 0x14 - GPIO output value set
        volatile uint32_t GPIO_OUT_CLR;  ///< Offset: 0x18 - GPIO output value clear
        volatile uint32_t GPIO_OUT_XOR;  ///< Offset: 0x1C - GPIO output value XOR
        volatile uint32_t GPIO_OE;  ///< Offset: 0x20 - GPIO output enable
        volatile uint32_t GPIO_OE_SET;  ///< Offset: 0x24 - GPIO output enable set
        volatile uint32_t GPIO_OE_CLR;  ///< Offset: 0x28 - GPIO output enable clear
        volatile uint32_t GPIO_OE_XOR;  ///< Offset: 0x2C - GPIO output enable XOR
        volatile uint32_t GPIO_HI_OUT;  ///< Offset: 0x30 - QSPI output value
        volatile uint32_t GPIO_HI_OUT_SET;  ///< Offset: 0x34 - QSPI output value set
        volatile uint32_t GPIO_HI_OUT_CLR;  ///< Offset: 0x38 - QSPI output value clear
        volatile uint32_t GPIO_HI_OUT_XOR;  ///< Offset: 0x3C - QSPI output value XOR
        volatile uint32_t GPIO_HI_OE;  ///< Offset: 0x40 - QSPI output enable
        volatile uint32_t GPIO_HI_OE_SET;  ///< Offset: 0x44 - QSPI output enable set
        volatile uint32_t GPIO_HI_OE_CLR;  ///< Offset: 0x48 - QSPI output enable clear
        volatile uint32_t GPIO_HI_OE_XOR;  ///< Offset: 0x4C - QSPI output enable XOR
        volatile uint32_t ROE;  ///< Offset: 0x50 - Status register for inter-core FIFOs (mailboxes).\n...
        volatile uint32_t FIFO_WR;  ///< Offset: 0x54 - Write access to this core's TX FIFO
        volatile uint32_t FIFO_RD;  ///< Offset: 0x58 - Read access to this core's RX FIFO
        volatile uint32_t SPINLOCK_ST;  ///< Offset: 0x5C - Spinlock state\n A bitmap containing the state of all 32...
        volatile uint32_t DIV_UDIVIDEND;  ///< Offset: 0x60 - Divider unsigned dividend\n Write to the DIVIDEND...
        volatile uint32_t DIV_UDIVISOR;  ///< Offset: 0x64 - Divider unsigned divisor\n Write to the DIVISOR operand...
        volatile uint32_t DIV_SDIVIDEND;  ///< Offset: 0x68 - Divider signed dividend\n The same as UDIVIDEND, but...
        volatile uint32_t DIV_SDIVISOR;  ///< Offset: 0x6C - Divider signed divisor\n The same as UDIVISOR, but...
        volatile uint32_t DIV_QUOTIENT;  ///< Offset: 0x70 - Divider result quotient\n The result of `DIVIDEND /...
        volatile uint32_t DIV_REMAINDER;  ///< Offset: 0x74 - Divider result remainder\n The result of `DIVIDEND %...
        volatile uint32_t DIRTY;  ///< Offset: 0x78 - Control and status register for divider.
        volatile uint32_t INTERP0_ACCUM0;  ///< Offset: 0x80 - Read/write access to accumulator 0
        volatile uint32_t INTERP0_ACCUM1;  ///< Offset: 0x84 - Read/write access to accumulator 1
        volatile uint32_t INTERP0_BASE0;  ///< Offset: 0x88 - Read/write access to BASE0 register.
        volatile uint32_t INTERP0_BASE1;  ///< Offset: 0x8C - Read/write access to BASE1 register.
        volatile uint32_t INTERP0_BASE2;  ///< Offset: 0x90 - Read/write access to BASE2 register.
        volatile uint32_t INTERP0_POP_LANE0;  ///< Offset: 0x94 - Read LANE0 result, and simultaneously write lane results...
        volatile uint32_t INTERP0_POP_LANE1;  ///< Offset: 0x98 - Read LANE1 result, and simultaneously write lane results...
        volatile uint32_t INTERP0_POP_FULL;  ///< Offset: 0x9C - Read FULL result, and simultaneously write lane results...
        volatile uint32_t INTERP0_PEEK_LANE0;  ///< Offset: 0xA0 - Read LANE0 result, without altering any internal state (PEEK).
        volatile uint32_t INTERP0_PEEK_LANE1;  ///< Offset: 0xA4 - Read LANE1 result, without altering any internal state (PEEK).
        volatile uint32_t INTERP0_PEEK_FULL;  ///< Offset: 0xA8 - Read FULL result, without altering any internal state (PEEK).
        volatile uint32_t OVERF;  ///< Offset: 0xEC - Control register for lane 0
        volatile uint32_t FORCE_MSB;  ///< Offset: 0xF0 - Control register for lane 1
        volatile uint32_t INTERP0_ACCUM0_ADD;  ///< Offset: 0xB4 - Values written here are atomically added to ACCUM0\n...
        volatile uint32_t INTERP0_ACCUM1_ADD;  ///< Offset: 0xB8 - Values written here are atomically added to ACCUM1\n...
        volatile uint32_t INTERP0_BASE_1AND0;  ///< Offset: 0xBC - On write, the lower 16 bits go to BASE0, upper bits to...
        volatile uint32_t INTERP1_ACCUM0;  ///< Offset: 0xC0 - Read/write access to accumulator 0
        volatile uint32_t INTERP1_ACCUM1;  ///< Offset: 0xC4 - Read/write access to accumulator 1
        volatile uint32_t INTERP1_BASE0;  ///< Offset: 0xC8 - Read/write access to BASE0 register.
        volatile uint32_t INTERP1_BASE1;  ///< Offset: 0xCC - Read/write access to BASE1 register.
        volatile uint32_t INTERP1_BASE2;  ///< Offset: 0xD0 - Read/write access to BASE2 register.
        volatile uint32_t INTERP1_POP_LANE0;  ///< Offset: 0xD4 - Read LANE0 result, and simultaneously write lane results...
        volatile uint32_t INTERP1_POP_LANE1;  ///< Offset: 0xD8 - Read LANE1 result, and simultaneously write lane results...
        volatile uint32_t INTERP1_POP_FULL;  ///< Offset: 0xDC - Read FULL result, and simultaneously write lane results...
        volatile uint32_t INTERP1_PEEK_LANE0;  ///< Offset: 0xE0 - Read LANE0 result, without altering any internal state (PEEK).
        volatile uint32_t INTERP1_PEEK_LANE1;  ///< Offset: 0xE4 - Read LANE1 result, without altering any internal state (PEEK).
        volatile uint32_t INTERP1_PEEK_FULL;  ///< Offset: 0xE8 - Read FULL result, without altering any internal state (PEEK).
        volatile uint32_t INTERP1_ACCUM0_ADD;  ///< Offset: 0xF4 - Values written here are atomically added to ACCUM0\n...
        volatile uint32_t INTERP1_ACCUM1_ADD;  ///< Offset: 0xF8 - Values written here are atomically added to ACCUM1\n...
        volatile uint32_t INTERP1_BASE_1AND0;  ///< Offset: 0xFC - On write, the lower 16 bits go to BASE0, upper bits to...
        volatile uint32_t SPINLOCK0;  ///< Offset: 0x100 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK1;  ///< Offset: 0x104 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK2;  ///< Offset: 0x108 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK3;  ///< Offset: 0x10C - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK4;  ///< Offset: 0x110 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK5;  ///< Offset: 0x114 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK6;  ///< Offset: 0x118 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK7;  ///< Offset: 0x11C - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK8;  ///< Offset: 0x120 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK9;  ///< Offset: 0x124 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK10;  ///< Offset: 0x128 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK11;  ///< Offset: 0x12C - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK12;  ///< Offset: 0x130 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK13;  ///< Offset: 0x134 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK14;  ///< Offset: 0x138 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK15;  ///< Offset: 0x13C - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK16;  ///< Offset: 0x140 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK17;  ///< Offset: 0x144 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK18;  ///< Offset: 0x148 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK19;  ///< Offset: 0x14C - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK20;  ///< Offset: 0x150 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK21;  ///< Offset: 0x154 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK22;  ///< Offset: 0x158 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK23;  ///< Offset: 0x15C - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK24;  ///< Offset: 0x160 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK25;  ///< Offset: 0x164 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK26;  ///< Offset: 0x168 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK27;  ///< Offset: 0x16C - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK28;  ///< Offset: 0x170 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK29;  ///< Offset: 0x174 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK30;  ///< Offset: 0x178 - Reading from a spinlock address will:\n - Return 0 if...
        volatile uint32_t SPINLOCK31;  ///< Offset: 0x17C - Reading from a spinlock address will:\n - Return 0 if...
    };

    /// Peripheral instances
    inline Registers* SIO_IRQ_PROC0 = reinterpret_cast<Registers*>(SIO_IRQ_PROC0_BASE);

}

// ============================================================================
// PPB Peripheral
// ============================================================================

namespace ppb {
    /// Base addresses
    constexpr uint32_t PPB_BASE = 0xE0000000;

    /// PPB Register structure
    struct Registers {
        volatile uint32_t COUNTFLAG;  ///< Offset: 0xE010 - Use the SysTick Control and Status Register to enable...
        volatile uint32_t RELOAD;  ///< Offset: 0xE014 - Use the SysTick Reload Value Register to specify the...
        volatile uint32_t CURRENT;  ///< Offset: 0xE018 - Use the SysTick Current Value Register to find the...
        volatile uint32_t NOREF;  ///< Offset: 0xE01C - Use the SysTick Calibration Value Register to enable...
        volatile uint32_t SETENA;  ///< Offset: 0xE100 - Use the Interrupt Set-Enable Register to enable...
        volatile uint32_t CLRENA;  ///< Offset: 0xE180 - Use the Interrupt Clear-Enable Registers to disable...
        volatile uint32_t SETPEND;  ///< Offset: 0xE200 - The NVIC_ISPR forces interrupts into the pending state,...
        volatile uint32_t CLRPEND;  ///< Offset: 0xE280 - Use the Interrupt Clear-Pending Register to clear...
        volatile uint32_t IP_3;  ///< Offset: 0xE400 - Use the Interrupt Priority Registers to assign a...
        volatile uint32_t IP_7;  ///< Offset: 0xE404 - Use the Interrupt Priority Registers to assign a...
        volatile uint32_t IP_11;  ///< Offset: 0xE408 - Use the Interrupt Priority Registers to assign a...
        volatile uint32_t IP_15;  ///< Offset: 0xE40C - Use the Interrupt Priority Registers to assign a...
        volatile uint32_t IP_19;  ///< Offset: 0xE410 - Use the Interrupt Priority Registers to assign a...
        volatile uint32_t IP_23;  ///< Offset: 0xE414 - Use the Interrupt Priority Registers to assign a...
        volatile uint32_t IP_27;  ///< Offset: 0xE418 - Use the Interrupt Priority Registers to assign a...
        volatile uint32_t IP_31;  ///< Offset: 0xE41C - Use the Interrupt Priority Registers to assign a...
        volatile uint32_t IMPLEMENTER;  ///< Offset: 0xED00 - Read the CPU ID Base Register to determine: the ID...
        volatile uint32_t NMIPENDSET;  ///< Offset: 0xED04 - Use the Interrupt Control State Register to set a...
        volatile uint32_t TBLOFF;  ///< Offset: 0xED08 - The VTOR holds the vector table offset address.
        volatile uint32_t VECTKEY;  ///< Offset: 0xED0C - Use the Application Interrupt and Reset Control Register...
        volatile uint32_t SEVONPEND;  ///< Offset: 0xED10 - System Control Register. Use the System Control Register...
        volatile uint32_t STKALIGN;  ///< Offset: 0xED14 - The Configuration and Control Register permanently...
        volatile uint32_t PRI_11;  ///< Offset: 0xED1C - System handlers are a special class of exception handler...
        volatile uint32_t PRI_15;  ///< Offset: 0xED20 - System handlers are a special class of exception handler...
        volatile uint32_t SVCALLPENDED;  ///< Offset: 0xED24 - Use the System Handler Control and State Register to...
        volatile uint32_t IREGION;  ///< Offset: 0xED90 - Read the MPU Type Register to determine if the processor...
        volatile uint32_t PRIVDEFENA;  ///< Offset: 0xED94 - Use the MPU Control Register to enable and disable the...
        volatile uint32_t REGION;  ///< Offset: 0xED98 - Use the MPU Region Number Register to select the region...
        volatile uint32_t ADDR;  ///< Offset: 0xED9C - Read the MPU Region Base Address Register to determine...
        volatile uint32_t ATTRS;  ///< Offset: 0xEDA0 - Use the MPU Region Attribute and Size Register to define...
    };

    /// Peripheral instances
    inline Registers* PPB = reinterpret_cast<Registers*>(PPB_BASE);

}


} // namespace alloy::generated::rp2040

#endif // ALLOY_GENERATED_RP2040_PERIPHERALS_HPP