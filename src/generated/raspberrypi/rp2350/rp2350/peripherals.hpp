/// Auto-generated code for RP2350
/// Generated by Alloy Code Generator
/// Source: raspberrypi_rp2350.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:45:04
#ifndef ALLOY_GENERATED_RP2350_PERIPHERALS_HPP
#define ALLOY_GENERATED_RP2350_PERIPHERALS_HPP

#include <stdint.h>

namespace alloy::generated::rp2350 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_resets = true;
    constexpr uint32_t num_resets_instances = 1;
    constexpr bool has_psm = true;
    constexpr uint32_t num_psm_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_ticks = true;
    constexpr uint32_t num_ticks_instances = 1;
    constexpr bool has_pads = true;
    constexpr uint32_t num_pads_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 4;
    constexpr bool has_io = true;
    constexpr uint32_t num_io_instances = 1;
    constexpr bool has_sysinfo = true;
    constexpr uint32_t num_sysinfo_instances = 1;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 1;
    constexpr bool has_hstx = true;
    constexpr uint32_t num_hstx_instances = 2;
    constexpr bool has_eppb = true;
    constexpr uint32_t num_eppb_instances = 1;
    constexpr bool has_ppb = true;
    constexpr uint32_t num_ppb_instances = 2;
    constexpr bool has_qmi = true;
    constexpr uint32_t num_qmi_instances = 1;
    constexpr bool has_xip = true;
    constexpr uint32_t num_xip_instances = 2;
    constexpr bool has_syscfg = true;
    constexpr uint32_t num_syscfg_instances = 1;
    constexpr bool has_xosc = true;
    constexpr uint32_t num_xosc_instances = 1;
    constexpr bool has_pll = true;
    constexpr uint32_t num_pll_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 3;
    constexpr bool has_accessctrl = true;
    constexpr uint32_t num_accessctrl_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;
    constexpr bool has_rosc = true;
    constexpr uint32_t num_rosc_instances = 1;
    constexpr bool has_powman = true;
    constexpr uint32_t num_powman_instances = 1;
    constexpr bool has_watchdog = true;
    constexpr uint32_t num_watchdog_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 2;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_pio0 = true;
    constexpr uint32_t num_pio0_instances = 1;
    constexpr bool has_pio1 = true;
    constexpr uint32_t num_pio1_instances = 1;
    constexpr bool has_pio2 = true;
    constexpr uint32_t num_pio2_instances = 1;
    constexpr bool has_busctrl = true;
    constexpr uint32_t num_busctrl_instances = 1;
    constexpr bool has_sio = true;
    constexpr uint32_t num_sio_instances = 2;
    constexpr bool has_bootram = true;
    constexpr uint32_t num_bootram_instances = 1;
    constexpr bool has_coresight = true;
    constexpr uint32_t num_coresight_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_glitch = true;
    constexpr uint32_t num_glitch_instances = 1;
    constexpr bool has_otp = true;
    constexpr uint32_t num_otp_instances = 3;
    constexpr bool has_tbman = true;
    constexpr uint32_t num_tbman_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct resets_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct psm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ticks_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pads_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct io_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sysinfo_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hstx_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct eppb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ppb_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct qmi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct xip_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct syscfg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct xosc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pll_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct accessctrl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rosc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct powman_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct watchdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pio0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pio1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pio2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct busctrl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct bootram_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct coresight_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct glitch_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct otp_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct tbman_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
}

// ============================================================================
// RESETS Peripheral
// ============================================================================

namespace resets {
    /// Base addresses
    constexpr uint32_t RESETS_BASE = 0x40020000;

    /// RESETS Register structure
    struct Registers {
        volatile uint32_t RESET;  ///< Offset: 0x00 - 
        volatile uint32_t WDSEL;  ///< Offset: 0x04 - 
        volatile uint32_t RESET_DONE;  ///< Offset: 0x08 - 
    };

    /// Peripheral instances
    inline Registers* RESETS = reinterpret_cast<Registers*>(RESETS_BASE);

}

// ============================================================================
// PSM Peripheral
// ============================================================================

namespace psm {
    /// Base addresses
    constexpr uint32_t PSM_BASE = 0x40018000;

    /// PSM Register structure
    struct Registers {
        volatile uint32_t FRCE_ON;  ///< Offset: 0x00 - Force block out of reset (i.e. power it on)
        volatile uint32_t FRCE_OFF;  ///< Offset: 0x04 - Force into reset (i.e. power it off)
        volatile uint32_t WDSEL;  ///< Offset: 0x08 - Set to 1 if the watchdog should reset this
        volatile uint32_t DONE;  ///< Offset: 0x0C - Is the subsystem ready?
    };

    /// Peripheral instances
    inline Registers* PSM = reinterpret_cast<Registers*>(PSM_BASE);

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t CLOCKS_BASE = 0x40010000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t CLK_GPOUT0_CTRL;  ///< Offset: 0x00 - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t CLK_GPOUT0_DIV;  ///< Offset: 0x04 - Integer part of clock divisor, 0 -> max+1, can be...
        volatile uint32_t CLK_GPOUT0_SELECTED;  ///< Offset: 0x08 - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_GPOUT1_CTRL;  ///< Offset: 0x0C - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t CLK_GPOUT1_DIV;  ///< Offset: 0x10 - Integer part of clock divisor, 0 -> max+1, can be...
        volatile uint32_t CLK_GPOUT1_SELECTED;  ///< Offset: 0x14 - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_GPOUT2_CTRL;  ///< Offset: 0x18 - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t CLK_GPOUT2_DIV;  ///< Offset: 0x1C - Integer part of clock divisor, 0 -> max+1, can be...
        volatile uint32_t CLK_GPOUT2_SELECTED;  ///< Offset: 0x20 - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_GPOUT3_CTRL;  ///< Offset: 0x24 - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t CLK_GPOUT3_DIV;  ///< Offset: 0x28 - Integer part of clock divisor, 0 -> max+1, can be...
        volatile uint32_t CLK_GPOUT3_SELECTED;  ///< Offset: 0x2C - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_REF_CTRL;  ///< Offset: 0x30 - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t CLK_REF_DIV;  ///< Offset: 0x34 - Integer part of clock divisor, 0 -> max+1, can be...
        volatile uint32_t CLK_REF_SELECTED;  ///< Offset: 0x38 - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_SYS_CTRL;  ///< Offset: 0x3C - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t CLK_SYS_DIV;  ///< Offset: 0x40 - Integer part of clock divisor, 0 -> max+1, can be...
        volatile uint32_t CLK_SYS_SELECTED;  ///< Offset: 0x44 - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_PERI_CTRL;  ///< Offset: 0x48 - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t CLK_PERI_DIV;  ///< Offset: 0x4C - Integer part of clock divisor, 0 -> max+1, can be...
        volatile uint32_t CLK_PERI_SELECTED;  ///< Offset: 0x50 - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_HSTX_CTRL;  ///< Offset: 0x54 - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t CLK_HSTX_DIV;  ///< Offset: 0x58 - Integer part of clock divisor, 0 -> max+1, can be...
        volatile uint32_t CLK_HSTX_SELECTED;  ///< Offset: 0x5C - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_USB_CTRL;  ///< Offset: 0x60 - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t CLK_USB_DIV;  ///< Offset: 0x64 - Integer part of clock divisor, 0 -> max+1, can be...
        volatile uint32_t CLK_USB_SELECTED;  ///< Offset: 0x68 - Indicates which src is currently selected (one-hot)
        volatile uint32_t CLK_ADC_CTRL;  ///< Offset: 0x6C - Clock control, can be changed on-the-fly (except for auxsrc)
        volatile uint32_t CLK_ADC_DIV;  ///< Offset: 0x70 - Integer part of clock divisor, 0 -> max+1, can be...
        volatile uint32_t CLK_ADC_SELECTED;  ///< Offset: 0x74 - Indicates which src is currently selected (one-hot)
        volatile uint32_t DFTCLK_XOSC_CTRL;  ///< Offset: 0x78 - 
        volatile uint32_t DFTCLK_ROSC_CTRL;  ///< Offset: 0x7C - 
        volatile uint32_t DFTCLK_LPOSC_CTRL;  ///< Offset: 0x80 - 
        volatile uint32_t CLK_SYS_RESUS_CTRL;  ///< Offset: 0x84 - For clearing the resus after the fault that triggered it...
        volatile uint32_t CLK_SYS_RESUS_STATUS;  ///< Offset: 0x88 - Clock has been resuscitated, correct the error then send...
        volatile uint32_t FC0_REF_KHZ;  ///< Offset: 0x8C - Reference clock frequency in kHz
        volatile uint32_t FC0_MIN_KHZ;  ///< Offset: 0x90 - Minimum pass frequency in kHz. This is optional. Set to...
        volatile uint32_t FC0_MAX_KHZ;  ///< Offset: 0x94 - Maximum pass frequency in kHz. This is optional. Set to...
        volatile uint32_t FC0_DELAY;  ///< Offset: 0x98 - Delays the start of frequency counting to allow the mux...
        volatile uint32_t FC0_INTERVAL;  ///< Offset: 0x9C - The test interval is 0.98us * 2**interval, but let's...
        volatile uint32_t FC0_SRC;  ///< Offset: 0xA0 - Clock sent to frequency counter, set to 0 when not...
        volatile uint32_t FC0_STATUS;  ///< Offset: 0xA4 - Frequency counter status
        volatile uint32_t FC0_RESULT;  ///< Offset: 0xA8 - Result of frequency measurement, only valid when status_done=1
        volatile uint32_t WAKE_EN0;  ///< Offset: 0xAC - enable clock in wake mode
        volatile uint32_t WAKE_EN1;  ///< Offset: 0xB0 - enable clock in wake mode
        volatile uint32_t SLEEP_EN0;  ///< Offset: 0xB4 - enable clock in sleep mode
        volatile uint32_t SLEEP_EN1;  ///< Offset: 0xB8 - enable clock in sleep mode
        volatile uint32_t ENABLED0;  ///< Offset: 0xBC - indicates the state of the clock enable
        volatile uint32_t ENABLED1;  ///< Offset: 0xC0 - indicates the state of the clock enable
        volatile uint32_t INTR;  ///< Offset: 0xC4 - Raw Interrupts
        volatile uint32_t INTE;  ///< Offset: 0xC8 - Interrupt Enable
        volatile uint32_t INTF;  ///< Offset: 0xCC - Interrupt Force
        volatile uint32_t INTS;  ///< Offset: 0xD0 - Interrupt status after masking & forcing
    };

    /// Peripheral instances
    inline Registers* CLOCKS = reinterpret_cast<Registers*>(CLOCKS_BASE);

}

// ============================================================================
// TICKS Peripheral
// ============================================================================

namespace ticks {
    /// Base addresses
    constexpr uint32_t TICKS_BASE = 0x40108000;

    /// TICKS Register structure
    struct Registers {
        volatile uint32_t PROC0_CTRL;  ///< Offset: 0x00 - Controls the tick generator
        volatile uint32_t PROC0_CYCLES;  ///< Offset: 0x04 - Total number of clk_tick cycles before the next tick.
        volatile uint32_t PROC0_COUNT;  ///< Offset: 0x08 - Count down timer: the remaining number clk_tick cycles...
        volatile uint32_t PROC1_CTRL;  ///< Offset: 0x0C - Controls the tick generator
        volatile uint32_t PROC1_CYCLES;  ///< Offset: 0x10 - Total number of clk_tick cycles before the next tick.
        volatile uint32_t PROC1_COUNT;  ///< Offset: 0x14 - Count down timer: the remaining number clk_tick cycles...
        volatile uint32_t TIMER0_CTRL;  ///< Offset: 0x18 - Controls the tick generator
        volatile uint32_t TIMER0_CYCLES;  ///< Offset: 0x1C - Total number of clk_tick cycles before the next tick.
        volatile uint32_t TIMER0_COUNT;  ///< Offset: 0x20 - Count down timer: the remaining number clk_tick cycles...
        volatile uint32_t TIMER1_CTRL;  ///< Offset: 0x24 - Controls the tick generator
        volatile uint32_t TIMER1_CYCLES;  ///< Offset: 0x28 - Total number of clk_tick cycles before the next tick.
        volatile uint32_t TIMER1_COUNT;  ///< Offset: 0x2C - Count down timer: the remaining number clk_tick cycles...
        volatile uint32_t WATCHDOG_CTRL;  ///< Offset: 0x30 - Controls the tick generator
        volatile uint32_t WATCHDOG_CYCLES;  ///< Offset: 0x34 - Total number of clk_tick cycles before the next tick.
        volatile uint32_t WATCHDOG_COUNT;  ///< Offset: 0x38 - Count down timer: the remaining number clk_tick cycles...
        volatile uint32_t RISCV_CTRL;  ///< Offset: 0x3C - Controls the tick generator
        volatile uint32_t RISCV_CYCLES;  ///< Offset: 0x40 - Total number of clk_tick cycles before the next tick.
        volatile uint32_t RISCV_COUNT;  ///< Offset: 0x44 - Count down timer: the remaining number clk_tick cycles...
    };

    /// Peripheral instances
    inline Registers* TICKS = reinterpret_cast<Registers*>(TICKS_BASE);

}

// ============================================================================
// PADS Peripheral
// ============================================================================

namespace pads {
    /// Base addresses
    constexpr uint32_t PADS_BANK0_BASE = 0x40038000;

    /// PADS Register structure
    struct Registers {
        volatile uint32_t VOLTAGE_SELECT;  ///< Offset: 0x00 - Voltage select. Per bank control
        volatile uint32_t GPIO0;  ///< Offset: 0x04 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO1;  ///< Offset: 0x08 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO2;  ///< Offset: 0x0C - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO3;  ///< Offset: 0x10 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO4;  ///< Offset: 0x14 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO5;  ///< Offset: 0x18 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO6;  ///< Offset: 0x1C - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO7;  ///< Offset: 0x20 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO8;  ///< Offset: 0x24 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO9;  ///< Offset: 0x28 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO10;  ///< Offset: 0x2C - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO11;  ///< Offset: 0x30 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO12;  ///< Offset: 0x34 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO13;  ///< Offset: 0x38 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO14;  ///< Offset: 0x3C - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO15;  ///< Offset: 0x40 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO16;  ///< Offset: 0x44 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO17;  ///< Offset: 0x48 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO18;  ///< Offset: 0x4C - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO19;  ///< Offset: 0x50 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO20;  ///< Offset: 0x54 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO21;  ///< Offset: 0x58 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO22;  ///< Offset: 0x5C - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO23;  ///< Offset: 0x60 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO24;  ///< Offset: 0x64 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO25;  ///< Offset: 0x68 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO26;  ///< Offset: 0x6C - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO27;  ///< Offset: 0x70 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO28;  ///< Offset: 0x74 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO29;  ///< Offset: 0x78 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO30;  ///< Offset: 0x7C - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO31;  ///< Offset: 0x80 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO32;  ///< Offset: 0x84 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO33;  ///< Offset: 0x88 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO34;  ///< Offset: 0x8C - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO35;  ///< Offset: 0x90 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO36;  ///< Offset: 0x94 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO37;  ///< Offset: 0x98 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO38;  ///< Offset: 0x9C - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO39;  ///< Offset: 0xA0 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO40;  ///< Offset: 0xA4 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO41;  ///< Offset: 0xA8 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO42;  ///< Offset: 0xAC - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO43;  ///< Offset: 0xB0 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO44;  ///< Offset: 0xB4 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO45;  ///< Offset: 0xB8 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO46;  ///< Offset: 0xBC - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO47;  ///< Offset: 0xC0 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t SWCLK;  ///< Offset: 0xC4 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t SWD;  ///< Offset: 0xC8 - Pad isolation control. Remove this once the pad is...
    };

    /// Peripheral instances
    inline Registers* PADS_BANK0 = reinterpret_cast<Registers*>(PADS_BANK0_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t PADS_QSPI_BASE = 0x40040000;
    constexpr uint32_t IO_QSPI_BASE = 0x40030000;
    constexpr uint32_t SPI0_BASE = 0x40080000;
    constexpr uint32_t SPI1_BASE = 0x40088000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t VOLTAGE_SELECT;  ///< Offset: 0x00 - Voltage select. Per bank control
        volatile uint32_t GPIO_QSPI_SCLK;  ///< Offset: 0x04 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO_QSPI_SD0;  ///< Offset: 0x08 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO_QSPI_SD1;  ///< Offset: 0x0C - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO_QSPI_SD2;  ///< Offset: 0x10 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO_QSPI_SD3;  ///< Offset: 0x14 - Pad isolation control. Remove this once the pad is...
        volatile uint32_t GPIO_QSPI_SS;  ///< Offset: 0x18 - Pad isolation control. Remove this once the pad is...
    };

    /// Peripheral instances
    inline Registers* PADS_QSPI = reinterpret_cast<Registers*>(PADS_QSPI_BASE);
    inline Registers* IO_QSPI = reinterpret_cast<Registers*>(IO_QSPI_BASE);
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

}

// ============================================================================
// IO Peripheral
// ============================================================================

namespace io {
    /// Base addresses
    constexpr uint32_t IO_BANK0_BASE = 0x40028000;

    /// IO Register structure
    struct Registers {
        volatile uint32_t GPIO0_STATUS;  ///< Offset: 0x00 - interrupt to processors, after override is applied
        volatile uint32_t GPIO0_CTRL;  ///< Offset: 0x04 - don't invert the interrupt
        volatile uint32_t GPIO1_STATUS;  ///< Offset: 0x08 - interrupt to processors, after override is applied
        volatile uint32_t GPIO1_CTRL;  ///< Offset: 0x0C - don't invert the interrupt
        volatile uint32_t GPIO2_STATUS;  ///< Offset: 0x10 - interrupt to processors, after override is applied
        volatile uint32_t GPIO2_CTRL;  ///< Offset: 0x14 - don't invert the interrupt
        volatile uint32_t GPIO3_STATUS;  ///< Offset: 0x18 - interrupt to processors, after override is applied
        volatile uint32_t GPIO3_CTRL;  ///< Offset: 0x1C - don't invert the interrupt
        volatile uint32_t GPIO4_STATUS;  ///< Offset: 0x20 - interrupt to processors, after override is applied
        volatile uint32_t GPIO4_CTRL;  ///< Offset: 0x24 - don't invert the interrupt
        volatile uint32_t GPIO5_STATUS;  ///< Offset: 0x28 - interrupt to processors, after override is applied
        volatile uint32_t GPIO5_CTRL;  ///< Offset: 0x2C - don't invert the interrupt
        volatile uint32_t GPIO6_STATUS;  ///< Offset: 0x30 - interrupt to processors, after override is applied
        volatile uint32_t GPIO6_CTRL;  ///< Offset: 0x34 - don't invert the interrupt
        volatile uint32_t GPIO7_STATUS;  ///< Offset: 0x38 - interrupt to processors, after override is applied
        volatile uint32_t GPIO7_CTRL;  ///< Offset: 0x3C - don't invert the interrupt
        volatile uint32_t GPIO8_STATUS;  ///< Offset: 0x40 - interrupt to processors, after override is applied
        volatile uint32_t GPIO8_CTRL;  ///< Offset: 0x44 - don't invert the interrupt
        volatile uint32_t GPIO9_STATUS;  ///< Offset: 0x48 - interrupt to processors, after override is applied
        volatile uint32_t GPIO9_CTRL;  ///< Offset: 0x4C - don't invert the interrupt
        volatile uint32_t GPIO10_STATUS;  ///< Offset: 0x50 - interrupt to processors, after override is applied
        volatile uint32_t GPIO10_CTRL;  ///< Offset: 0x54 - don't invert the interrupt
        volatile uint32_t GPIO11_STATUS;  ///< Offset: 0x58 - interrupt to processors, after override is applied
        volatile uint32_t GPIO11_CTRL;  ///< Offset: 0x5C - don't invert the interrupt
        volatile uint32_t GPIO12_STATUS;  ///< Offset: 0x60 - interrupt to processors, after override is applied
        volatile uint32_t GPIO12_CTRL;  ///< Offset: 0x64 - don't invert the interrupt
        volatile uint32_t GPIO13_STATUS;  ///< Offset: 0x68 - interrupt to processors, after override is applied
        volatile uint32_t GPIO13_CTRL;  ///< Offset: 0x6C - don't invert the interrupt
        volatile uint32_t GPIO14_STATUS;  ///< Offset: 0x70 - interrupt to processors, after override is applied
        volatile uint32_t GPIO14_CTRL;  ///< Offset: 0x74 - don't invert the interrupt
        volatile uint32_t GPIO15_STATUS;  ///< Offset: 0x78 - interrupt to processors, after override is applied
        volatile uint32_t GPIO15_CTRL;  ///< Offset: 0x7C - don't invert the interrupt
        volatile uint32_t GPIO16_STATUS;  ///< Offset: 0x80 - interrupt to processors, after override is applied
        volatile uint32_t GPIO16_CTRL;  ///< Offset: 0x84 - don't invert the interrupt
        volatile uint32_t GPIO17_STATUS;  ///< Offset: 0x88 - interrupt to processors, after override is applied
        volatile uint32_t GPIO17_CTRL;  ///< Offset: 0x8C - don't invert the interrupt
        volatile uint32_t GPIO18_STATUS;  ///< Offset: 0x90 - interrupt to processors, after override is applied
        volatile uint32_t GPIO18_CTRL;  ///< Offset: 0x94 - don't invert the interrupt
        volatile uint32_t GPIO19_STATUS;  ///< Offset: 0x98 - interrupt to processors, after override is applied
        volatile uint32_t GPIO19_CTRL;  ///< Offset: 0x9C - don't invert the interrupt
        volatile uint32_t GPIO20_STATUS;  ///< Offset: 0xA0 - interrupt to processors, after override is applied
        volatile uint32_t GPIO20_CTRL;  ///< Offset: 0xA4 - don't invert the interrupt
        volatile uint32_t GPIO21_STATUS;  ///< Offset: 0xA8 - interrupt to processors, after override is applied
        volatile uint32_t GPIO21_CTRL;  ///< Offset: 0xAC - don't invert the interrupt
        volatile uint32_t GPIO22_STATUS;  ///< Offset: 0xB0 - interrupt to processors, after override is applied
        volatile uint32_t GPIO22_CTRL;  ///< Offset: 0xB4 - don't invert the interrupt
        volatile uint32_t GPIO23_STATUS;  ///< Offset: 0xB8 - interrupt to processors, after override is applied
        volatile uint32_t GPIO23_CTRL;  ///< Offset: 0xBC - don't invert the interrupt
        volatile uint32_t GPIO24_STATUS;  ///< Offset: 0xC0 - interrupt to processors, after override is applied
        volatile uint32_t GPIO24_CTRL;  ///< Offset: 0xC4 - don't invert the interrupt
        volatile uint32_t GPIO25_STATUS;  ///< Offset: 0xC8 - interrupt to processors, after override is applied
        volatile uint32_t GPIO25_CTRL;  ///< Offset: 0xCC - don't invert the interrupt
        volatile uint32_t GPIO26_STATUS;  ///< Offset: 0xD0 - interrupt to processors, after override is applied
        volatile uint32_t GPIO26_CTRL;  ///< Offset: 0xD4 - don't invert the interrupt
        volatile uint32_t GPIO27_STATUS;  ///< Offset: 0xD8 - interrupt to processors, after override is applied
        volatile uint32_t GPIO27_CTRL;  ///< Offset: 0xDC - don't invert the interrupt
        volatile uint32_t GPIO28_STATUS;  ///< Offset: 0xE0 - interrupt to processors, after override is applied
        volatile uint32_t GPIO28_CTRL;  ///< Offset: 0xE4 - don't invert the interrupt
        volatile uint32_t GPIO29_STATUS;  ///< Offset: 0xE8 - interrupt to processors, after override is applied
        volatile uint32_t GPIO29_CTRL;  ///< Offset: 0xEC - don't invert the interrupt
        volatile uint32_t GPIO30_STATUS;  ///< Offset: 0xF0 - interrupt to processors, after override is applied
        volatile uint32_t GPIO30_CTRL;  ///< Offset: 0xF4 - don't invert the interrupt
        volatile uint32_t GPIO31_STATUS;  ///< Offset: 0xF8 - interrupt to processors, after override is applied
        volatile uint32_t GPIO31_CTRL;  ///< Offset: 0xFC - don't invert the interrupt
        volatile uint32_t GPIO32_STATUS;  ///< Offset: 0x100 - interrupt to processors, after override is applied
        volatile uint32_t GPIO32_CTRL;  ///< Offset: 0x104 - don't invert the interrupt
        volatile uint32_t GPIO33_STATUS;  ///< Offset: 0x108 - interrupt to processors, after override is applied
        volatile uint32_t GPIO33_CTRL;  ///< Offset: 0x10C - don't invert the interrupt
        volatile uint32_t GPIO34_STATUS;  ///< Offset: 0x110 - interrupt to processors, after override is applied
        volatile uint32_t GPIO34_CTRL;  ///< Offset: 0x114 - don't invert the interrupt
        volatile uint32_t GPIO35_STATUS;  ///< Offset: 0x118 - interrupt to processors, after override is applied
        volatile uint32_t GPIO35_CTRL;  ///< Offset: 0x11C - don't invert the interrupt
        volatile uint32_t GPIO36_STATUS;  ///< Offset: 0x120 - interrupt to processors, after override is applied
        volatile uint32_t GPIO36_CTRL;  ///< Offset: 0x124 - don't invert the interrupt
        volatile uint32_t GPIO37_STATUS;  ///< Offset: 0x128 - interrupt to processors, after override is applied
        volatile uint32_t GPIO37_CTRL;  ///< Offset: 0x12C - don't invert the interrupt
        volatile uint32_t GPIO38_STATUS;  ///< Offset: 0x130 - interrupt to processors, after override is applied
        volatile uint32_t GPIO38_CTRL;  ///< Offset: 0x134 - don't invert the interrupt
        volatile uint32_t GPIO39_STATUS;  ///< Offset: 0x138 - interrupt to processors, after override is applied
        volatile uint32_t GPIO39_CTRL;  ///< Offset: 0x13C - don't invert the interrupt
        volatile uint32_t GPIO40_STATUS;  ///< Offset: 0x140 - interrupt to processors, after override is applied
        volatile uint32_t GPIO40_CTRL;  ///< Offset: 0x144 - don't invert the interrupt
        volatile uint32_t GPIO41_STATUS;  ///< Offset: 0x148 - interrupt to processors, after override is applied
        volatile uint32_t GPIO41_CTRL;  ///< Offset: 0x14C - don't invert the interrupt
        volatile uint32_t GPIO42_STATUS;  ///< Offset: 0x150 - interrupt to processors, after override is applied
        volatile uint32_t GPIO42_CTRL;  ///< Offset: 0x154 - don't invert the interrupt
        volatile uint32_t GPIO43_STATUS;  ///< Offset: 0x158 - interrupt to processors, after override is applied
        volatile uint32_t GPIO43_CTRL;  ///< Offset: 0x15C - don't invert the interrupt
        volatile uint32_t GPIO44_STATUS;  ///< Offset: 0x160 - interrupt to processors, after override is applied
        volatile uint32_t GPIO44_CTRL;  ///< Offset: 0x164 - don't invert the interrupt
        volatile uint32_t GPIO45_STATUS;  ///< Offset: 0x168 - interrupt to processors, after override is applied
        volatile uint32_t GPIO45_CTRL;  ///< Offset: 0x16C - don't invert the interrupt
        volatile uint32_t GPIO46_STATUS;  ///< Offset: 0x170 - interrupt to processors, after override is applied
        volatile uint32_t GPIO46_CTRL;  ///< Offset: 0x174 - don't invert the interrupt
        volatile uint32_t GPIO47_STATUS;  ///< Offset: 0x178 - interrupt to processors, after override is applied
        volatile uint32_t GPIO47_CTRL;  ///< Offset: 0x17C - don't invert the interrupt
        volatile uint32_t IRQSUMMARY_PROC0_SECURE0;  ///< Offset: 0x200 - 
        volatile uint32_t IRQSUMMARY_PROC0_SECURE1;  ///< Offset: 0x204 - 
        volatile uint32_t IRQSUMMARY_PROC0_NONSECURE0;  ///< Offset: 0x208 - 
        volatile uint32_t IRQSUMMARY_PROC0_NONSECURE1;  ///< Offset: 0x20C - 
        volatile uint32_t IRQSUMMARY_PROC1_SECURE0;  ///< Offset: 0x210 - 
        volatile uint32_t IRQSUMMARY_PROC1_SECURE1;  ///< Offset: 0x214 - 
        volatile uint32_t IRQSUMMARY_PROC1_NONSECURE0;  ///< Offset: 0x218 - 
        volatile uint32_t IRQSUMMARY_PROC1_NONSECURE1;  ///< Offset: 0x21C - 
        volatile uint32_t IRQSUMMARY_DORMANT_WAKE_SECURE0;  ///< Offset: 0x220 - 
        volatile uint32_t IRQSUMMARY_DORMANT_WAKE_SECURE1;  ///< Offset: 0x224 - 
        volatile uint32_t IRQSUMMARY_DORMANT_WAKE_NONSECURE0;  ///< Offset: 0x228 - 
        volatile uint32_t IRQSUMMARY_DORMANT_WAKE_NONSECURE1;  ///< Offset: 0x22C - 
        volatile uint32_t INTR0;  ///< Offset: 0x230 - Raw Interrupts
        volatile uint32_t INTR1;  ///< Offset: 0x234 - Raw Interrupts
        volatile uint32_t INTR2;  ///< Offset: 0x238 - Raw Interrupts
        volatile uint32_t INTR3;  ///< Offset: 0x23C - Raw Interrupts
        volatile uint32_t INTR4;  ///< Offset: 0x240 - Raw Interrupts
        volatile uint32_t INTR5;  ///< Offset: 0x244 - Raw Interrupts
        volatile uint32_t PROC0_INTE0;  ///< Offset: 0x248 - Interrupt Enable for proc0
        volatile uint32_t PROC0_INTE1;  ///< Offset: 0x24C - Interrupt Enable for proc0
        volatile uint32_t PROC0_INTE2;  ///< Offset: 0x250 - Interrupt Enable for proc0
        volatile uint32_t PROC0_INTE3;  ///< Offset: 0x254 - Interrupt Enable for proc0
        volatile uint32_t PROC0_INTE4;  ///< Offset: 0x258 - Interrupt Enable for proc0
        volatile uint32_t PROC0_INTE5;  ///< Offset: 0x25C - Interrupt Enable for proc0
        volatile uint32_t PROC0_INTF0;  ///< Offset: 0x260 - Interrupt Force for proc0
        volatile uint32_t PROC0_INTF1;  ///< Offset: 0x264 - Interrupt Force for proc0
        volatile uint32_t PROC0_INTF2;  ///< Offset: 0x268 - Interrupt Force for proc0
        volatile uint32_t PROC0_INTF3;  ///< Offset: 0x26C - Interrupt Force for proc0
        volatile uint32_t PROC0_INTF4;  ///< Offset: 0x270 - Interrupt Force for proc0
        volatile uint32_t PROC0_INTF5;  ///< Offset: 0x274 - Interrupt Force for proc0
        volatile uint32_t PROC0_INTS0;  ///< Offset: 0x278 - Interrupt status after masking & forcing for proc0
        volatile uint32_t PROC0_INTS1;  ///< Offset: 0x27C - Interrupt status after masking & forcing for proc0
        volatile uint32_t PROC0_INTS2;  ///< Offset: 0x280 - Interrupt status after masking & forcing for proc0
        volatile uint32_t PROC0_INTS3;  ///< Offset: 0x284 - Interrupt status after masking & forcing for proc0
        volatile uint32_t PROC0_INTS4;  ///< Offset: 0x288 - Interrupt status after masking & forcing for proc0
        volatile uint32_t PROC0_INTS5;  ///< Offset: 0x28C - Interrupt status after masking & forcing for proc0
        volatile uint32_t PROC1_INTE0;  ///< Offset: 0x290 - Interrupt Enable for proc1
        volatile uint32_t PROC1_INTE1;  ///< Offset: 0x294 - Interrupt Enable for proc1
        volatile uint32_t PROC1_INTE2;  ///< Offset: 0x298 - Interrupt Enable for proc1
        volatile uint32_t PROC1_INTE3;  ///< Offset: 0x29C - Interrupt Enable for proc1
        volatile uint32_t PROC1_INTE4;  ///< Offset: 0x2A0 - Interrupt Enable for proc1
        volatile uint32_t PROC1_INTE5;  ///< Offset: 0x2A4 - Interrupt Enable for proc1
        volatile uint32_t PROC1_INTF0;  ///< Offset: 0x2A8 - Interrupt Force for proc1
        volatile uint32_t PROC1_INTF1;  ///< Offset: 0x2AC - Interrupt Force for proc1
        volatile uint32_t PROC1_INTF2;  ///< Offset: 0x2B0 - Interrupt Force for proc1
        volatile uint32_t PROC1_INTF3;  ///< Offset: 0x2B4 - Interrupt Force for proc1
        volatile uint32_t PROC1_INTF4;  ///< Offset: 0x2B8 - Interrupt Force for proc1
        volatile uint32_t PROC1_INTF5;  ///< Offset: 0x2BC - Interrupt Force for proc1
        volatile uint32_t PROC1_INTS0;  ///< Offset: 0x2C0 - Interrupt status after masking & forcing for proc1
        volatile uint32_t PROC1_INTS1;  ///< Offset: 0x2C4 - Interrupt status after masking & forcing for proc1
        volatile uint32_t PROC1_INTS2;  ///< Offset: 0x2C8 - Interrupt status after masking & forcing for proc1
        volatile uint32_t PROC1_INTS3;  ///< Offset: 0x2CC - Interrupt status after masking & forcing for proc1
        volatile uint32_t PROC1_INTS4;  ///< Offset: 0x2D0 - Interrupt status after masking & forcing for proc1
        volatile uint32_t PROC1_INTS5;  ///< Offset: 0x2D4 - Interrupt status after masking & forcing for proc1
        volatile uint32_t DORMANT_WAKE_INTE0;  ///< Offset: 0x2D8 - Interrupt Enable for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTE1;  ///< Offset: 0x2DC - Interrupt Enable for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTE2;  ///< Offset: 0x2E0 - Interrupt Enable for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTE3;  ///< Offset: 0x2E4 - Interrupt Enable for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTE4;  ///< Offset: 0x2E8 - Interrupt Enable for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTE5;  ///< Offset: 0x2EC - Interrupt Enable for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTF0;  ///< Offset: 0x2F0 - Interrupt Force for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTF1;  ///< Offset: 0x2F4 - Interrupt Force for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTF2;  ///< Offset: 0x2F8 - Interrupt Force for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTF3;  ///< Offset: 0x2FC - Interrupt Force for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTF4;  ///< Offset: 0x300 - Interrupt Force for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTF5;  ///< Offset: 0x304 - Interrupt Force for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTS0;  ///< Offset: 0x308 - Interrupt status after masking & forcing for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTS1;  ///< Offset: 0x30C - Interrupt status after masking & forcing for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTS2;  ///< Offset: 0x310 - Interrupt status after masking & forcing for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTS3;  ///< Offset: 0x314 - Interrupt status after masking & forcing for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTS4;  ///< Offset: 0x318 - Interrupt status after masking & forcing for dormant_wake
        volatile uint32_t DORMANT_WAKE_INTS5;  ///< Offset: 0x31C - Interrupt status after masking & forcing for dormant_wake
    };

    /// Peripheral instances
    inline Registers* IO_BANK0 = reinterpret_cast<Registers*>(IO_BANK0_BASE);

}

// ============================================================================
// SYSINFO Peripheral
// ============================================================================

namespace sysinfo {
    /// Base addresses
    constexpr uint32_t SYSINFO_BASE = 0x40000000;

    /// SYSINFO Register structure
    struct Registers {
        volatile uint32_t CHIP_ID;  ///< Offset: 0x00 - JEDEC JEP-106 compliant chip identifier.
        volatile uint32_t PACKAGE_SEL;  ///< Offset: 0x04 - 
        volatile uint32_t PLATFORM;  ///< Offset: 0x08 - Platform register. Allows software to know what...
        volatile uint32_t GITREF_RP2350;  ///< Offset: 0x14 - Git hash of the chip source. Used to identify chip version.
    };

    /// Peripheral instances
    inline Registers* SYSINFO = reinterpret_cast<Registers*>(SYSINFO_BASE);

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t SHA256_BASE = 0x400F8000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - Control and status register
        volatile uint32_t WDATA;  ///< Offset: 0x04 - Write data register
        volatile uint32_t SUM0;  ///< Offset: 0x08 - 256-bit checksum result. Contents are undefined when...
        volatile uint32_t SUM1;  ///< Offset: 0x0C - 256-bit checksum result. Contents are undefined when...
        volatile uint32_t SUM2;  ///< Offset: 0x10 - 256-bit checksum result. Contents are undefined when...
        volatile uint32_t SUM3;  ///< Offset: 0x14 - 256-bit checksum result. Contents are undefined when...
        volatile uint32_t SUM4;  ///< Offset: 0x18 - 256-bit checksum result. Contents are undefined when...
        volatile uint32_t SUM5;  ///< Offset: 0x1C - 256-bit checksum result. Contents are undefined when...
        volatile uint32_t SUM6;  ///< Offset: 0x20 - 256-bit checksum result. Contents are undefined when...
        volatile uint32_t SUM7;  ///< Offset: 0x24 - 256-bit checksum result. Contents are undefined when...
    };

    /// Peripheral instances
    inline Registers* SHA256 = reinterpret_cast<Registers*>(SHA256_BASE);

}

// ============================================================================
// HSTX Peripheral
// ============================================================================

namespace hstx {
    /// Base addresses
    constexpr uint32_t HSTX_FIFO_BASE = 0x50600000;
    constexpr uint32_t HSTX_CTRL_BASE = 0x400C0000;

    /// HSTX Register structure
    struct Registers {
        volatile uint32_t STAT;  ///< Offset: 0x00 - FIFO status
        volatile uint32_t FIFO;  ///< Offset: 0x04 - Write access to FIFO
    };

    /// Peripheral instances
    inline Registers* HSTX_FIFO = reinterpret_cast<Registers*>(HSTX_FIFO_BASE);
    inline Registers* HSTX_CTRL = reinterpret_cast<Registers*>(HSTX_CTRL_BASE);

}

// ============================================================================
// EPPB Peripheral
// ============================================================================

namespace eppb {
    /// Base addresses
    constexpr uint32_t EPPB_BASE = 0xE0080000;

    /// EPPB Register structure
    struct Registers {
        volatile uint32_t NMI_MASK0;  ///< Offset: 0x00 - NMI mask for IRQs 0 through 31. This register is...
        volatile uint32_t NMI_MASK1;  ///< Offset: 0x04 - NMI mask for IRQs 0 though 51. This register is...
        volatile uint32_t SLEEPCTRL;  ///< Offset: 0x08 - Nonstandard sleep control register
    };

    /// Peripheral instances
    inline Registers* EPPB = reinterpret_cast<Registers*>(EPPB_BASE);

}

// ============================================================================
// PPB Peripheral
// ============================================================================

namespace ppb {
    /// Base addresses
    constexpr uint32_t PPB_BASE = 0xE0000000;
    constexpr uint32_t PPB_NS_BASE = 0xE0020000;

    /// PPB Register structure
    struct Registers {
        volatile uint32_t ITM_STIM0;  ///< Offset: 0x00 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM1;  ///< Offset: 0x04 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM2;  ///< Offset: 0x08 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM3;  ///< Offset: 0x0C - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM4;  ///< Offset: 0x10 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM5;  ///< Offset: 0x14 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM6;  ///< Offset: 0x18 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM7;  ///< Offset: 0x1C - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM8;  ///< Offset: 0x20 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM9;  ///< Offset: 0x24 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM10;  ///< Offset: 0x28 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM11;  ///< Offset: 0x2C - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM12;  ///< Offset: 0x30 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM13;  ///< Offset: 0x34 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM14;  ///< Offset: 0x38 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM15;  ///< Offset: 0x3C - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM16;  ///< Offset: 0x40 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM17;  ///< Offset: 0x44 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM18;  ///< Offset: 0x48 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM19;  ///< Offset: 0x4C - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM20;  ///< Offset: 0x50 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM21;  ///< Offset: 0x54 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM22;  ///< Offset: 0x58 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM23;  ///< Offset: 0x5C - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM24;  ///< Offset: 0x60 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM25;  ///< Offset: 0x64 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM26;  ///< Offset: 0x68 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM27;  ///< Offset: 0x6C - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM28;  ///< Offset: 0x70 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM29;  ///< Offset: 0x74 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM30;  ///< Offset: 0x78 - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_STIM31;  ///< Offset: 0x7C - Provides the interface for generating Instrumentation packets
        volatile uint32_t ITM_TER0;  ///< Offset: 0xE00 - Provide an individual enable bit for each ITM_STIM register
        volatile uint32_t ITM_TPR;  ///< Offset: 0xE40 - Controls which stimulus ports can be accessed by...
        volatile uint32_t ITM_TCR;  ///< Offset: 0xE80 - Configures and controls transfers through the ITM interface
        volatile uint32_t INT_ATREADY;  ///< Offset: 0xEF0 - Integration Mode: Read ATB Ready
        volatile uint32_t INT_ATVALID;  ///< Offset: 0xEF8 - Integration Mode: Write ATB Valid
        volatile uint32_t ITM_ITCTRL;  ///< Offset: 0xF00 - Integration Mode Control Register
        volatile uint32_t ITM_DEVARCH;  ///< Offset: 0xFBC - Provides CoreSight discovery information for the ITM
        volatile uint32_t ITM_DEVTYPE;  ///< Offset: 0xFCC - Provides CoreSight discovery information for the ITM
        volatile uint32_t ITM_PIDR4;  ///< Offset: 0xFD0 - Provides CoreSight discovery information for the ITM
        volatile uint32_t ITM_PIDR5;  ///< Offset: 0xFD4 - Provides CoreSight discovery information for the ITM
        volatile uint32_t ITM_PIDR6;  ///< Offset: 0xFD8 - Provides CoreSight discovery information for the ITM
        volatile uint32_t ITM_PIDR7;  ///< Offset: 0xFDC - Provides CoreSight discovery information for the ITM
        volatile uint32_t ITM_PIDR0;  ///< Offset: 0xFE0 - Provides CoreSight discovery information for the ITM
        volatile uint32_t ITM_PIDR1;  ///< Offset: 0xFE4 - Provides CoreSight discovery information for the ITM
        volatile uint32_t ITM_PIDR2;  ///< Offset: 0xFE8 - Provides CoreSight discovery information for the ITM
        volatile uint32_t ITM_PIDR3;  ///< Offset: 0xFEC - Provides CoreSight discovery information for the ITM
        volatile uint32_t ITM_CIDR0;  ///< Offset: 0xFF0 - Provides CoreSight discovery information for the ITM
        volatile uint32_t ITM_CIDR1;  ///< Offset: 0xFF4 - Provides CoreSight discovery information for the ITM
        volatile uint32_t ITM_CIDR2;  ///< Offset: 0xFF8 - Provides CoreSight discovery information for the ITM
        volatile uint32_t ITM_CIDR3;  ///< Offset: 0xFFC - Provides CoreSight discovery information for the ITM
        volatile uint32_t DWT_CTRL;  ///< Offset: 0x1000 - Provides configuration and status information for the...
        volatile uint32_t DWT_CYCCNT;  ///< Offset: 0x1004 - Shows or sets the value of the processor cycle counter, CYCCNT
        volatile uint32_t DWT_EXCCNT;  ///< Offset: 0x100C - Counts the total cycles spent in exception processing
        volatile uint32_t DWT_LSUCNT;  ///< Offset: 0x1014 - Increments on the additional cycles required to execute...
        volatile uint32_t DWT_FOLDCNT;  ///< Offset: 0x1018 - Increments on the additional cycles required to execute...
        volatile uint32_t DWT_COMP0;  ///< Offset: 0x1020 - Provides a reference value for use by watchpoint comparator 0
        volatile uint32_t DWT_FUNCTION0;  ///< Offset: 0x1028 - Controls the operation of watchpoint comparator 0
        volatile uint32_t DWT_COMP1;  ///< Offset: 0x1030 - Provides a reference value for use by watchpoint comparator 1
        volatile uint32_t DWT_FUNCTION1;  ///< Offset: 0x1038 - Controls the operation of watchpoint comparator 1
        volatile uint32_t DWT_COMP2;  ///< Offset: 0x1040 - Provides a reference value for use by watchpoint comparator 2
        volatile uint32_t DWT_FUNCTION2;  ///< Offset: 0x1048 - Controls the operation of watchpoint comparator 2
        volatile uint32_t DWT_COMP3;  ///< Offset: 0x1050 - Provides a reference value for use by watchpoint comparator 3
        volatile uint32_t DWT_FUNCTION3;  ///< Offset: 0x1058 - Controls the operation of watchpoint comparator 3
        volatile uint32_t DWT_DEVARCH;  ///< Offset: 0x1FBC - Provides CoreSight discovery information for the DWT
        volatile uint32_t DWT_DEVTYPE;  ///< Offset: 0x1FCC - Provides CoreSight discovery information for the DWT
        volatile uint32_t DWT_PIDR4;  ///< Offset: 0x1FD0 - Provides CoreSight discovery information for the DWT
        volatile uint32_t DWT_PIDR5;  ///< Offset: 0x1FD4 - Provides CoreSight discovery information for the DWT
        volatile uint32_t DWT_PIDR6;  ///< Offset: 0x1FD8 - Provides CoreSight discovery information for the DWT
        volatile uint32_t DWT_PIDR7;  ///< Offset: 0x1FDC - Provides CoreSight discovery information for the DWT
        volatile uint32_t DWT_PIDR0;  ///< Offset: 0x1FE0 - Provides CoreSight discovery information for the DWT
        volatile uint32_t DWT_PIDR1;  ///< Offset: 0x1FE4 - Provides CoreSight discovery information for the DWT
        volatile uint32_t DWT_PIDR2;  ///< Offset: 0x1FE8 - Provides CoreSight discovery information for the DWT
        volatile uint32_t DWT_PIDR3;  ///< Offset: 0x1FEC - Provides CoreSight discovery information for the DWT
        volatile uint32_t DWT_CIDR0;  ///< Offset: 0x1FF0 - Provides CoreSight discovery information for the DWT
        volatile uint32_t DWT_CIDR1;  ///< Offset: 0x1FF4 - Provides CoreSight discovery information for the DWT
        volatile uint32_t DWT_CIDR2;  ///< Offset: 0x1FF8 - Provides CoreSight discovery information for the DWT
        volatile uint32_t DWT_CIDR3;  ///< Offset: 0x1FFC - Provides CoreSight discovery information for the DWT
        volatile uint32_t FP_CTRL;  ///< Offset: 0x2000 - Provides FPB implementation information, and the global...
        volatile uint32_t FP_REMAP;  ///< Offset: 0x2004 - Indicates whether the implementation supports Flash...
        volatile uint32_t FP_COMP0;  ///< Offset: 0x2008 - Holds an address for comparison. The effect of the match...
        volatile uint32_t FP_COMP1;  ///< Offset: 0x200C - Holds an address for comparison. The effect of the match...
        volatile uint32_t FP_COMP2;  ///< Offset: 0x2010 - Holds an address for comparison. The effect of the match...
        volatile uint32_t FP_COMP3;  ///< Offset: 0x2014 - Holds an address for comparison. The effect of the match...
        volatile uint32_t FP_COMP4;  ///< Offset: 0x2018 - Holds an address for comparison. The effect of the match...
        volatile uint32_t FP_COMP5;  ///< Offset: 0x201C - Holds an address for comparison. The effect of the match...
        volatile uint32_t FP_COMP6;  ///< Offset: 0x2020 - Holds an address for comparison. The effect of the match...
        volatile uint32_t FP_COMP7;  ///< Offset: 0x2024 - Holds an address for comparison. The effect of the match...
        volatile uint32_t FP_DEVARCH;  ///< Offset: 0x2FBC - Provides CoreSight discovery information for the FPB
        volatile uint32_t FP_DEVTYPE;  ///< Offset: 0x2FCC - Provides CoreSight discovery information for the FPB
        volatile uint32_t FP_PIDR4;  ///< Offset: 0x2FD0 - Provides CoreSight discovery information for the FP
        volatile uint32_t FP_PIDR5;  ///< Offset: 0x2FD4 - Provides CoreSight discovery information for the FP
        volatile uint32_t FP_PIDR6;  ///< Offset: 0x2FD8 - Provides CoreSight discovery information for the FP
        volatile uint32_t FP_PIDR7;  ///< Offset: 0x2FDC - Provides CoreSight discovery information for the FP
        volatile uint32_t FP_PIDR0;  ///< Offset: 0x2FE0 - Provides CoreSight discovery information for the FP
        volatile uint32_t FP_PIDR1;  ///< Offset: 0x2FE4 - Provides CoreSight discovery information for the FP
        volatile uint32_t FP_PIDR2;  ///< Offset: 0x2FE8 - Provides CoreSight discovery information for the FP
        volatile uint32_t FP_PIDR3;  ///< Offset: 0x2FEC - Provides CoreSight discovery information for the FP
        volatile uint32_t FP_CIDR0;  ///< Offset: 0x2FF0 - Provides CoreSight discovery information for the FP
        volatile uint32_t FP_CIDR1;  ///< Offset: 0x2FF4 - Provides CoreSight discovery information for the FP
        volatile uint32_t FP_CIDR2;  ///< Offset: 0x2FF8 - Provides CoreSight discovery information for the FP
        volatile uint32_t FP_CIDR3;  ///< Offset: 0x2FFC - Provides CoreSight discovery information for the FP
        volatile uint32_t ICTR;  ///< Offset: 0xE004 - Provides information about the interrupt controller
        volatile uint32_t ACTLR;  ///< Offset: 0xE008 - Provides IMPLEMENTATION DEFINED configuration and control options
        volatile uint32_t SYST_CSR;  ///< Offset: 0xE010 - Use the SysTick Control and Status Register to enable...
        volatile uint32_t SYST_RVR;  ///< Offset: 0xE014 - Use the SysTick Reload Value Register to specify the...
        volatile uint32_t SYST_CVR;  ///< Offset: 0xE018 - Use the SysTick Current Value Register to find the...
        volatile uint32_t SYST_CALIB;  ///< Offset: 0xE01C - Use the SysTick Calibration Value Register to enable...
        volatile uint32_t NVIC_ISER0;  ///< Offset: 0xE100 - Enables or reads the enabled state of each group of 32 interrupts
        volatile uint32_t NVIC_ISER1;  ///< Offset: 0xE104 - Enables or reads the enabled state of each group of 32 interrupts
        volatile uint32_t NVIC_ICER0;  ///< Offset: 0xE180 - Clears or reads the enabled state of each group of 32 interrupts
        volatile uint32_t NVIC_ICER1;  ///< Offset: 0xE184 - Clears or reads the enabled state of each group of 32 interrupts
        volatile uint32_t NVIC_ISPR0;  ///< Offset: 0xE200 - Enables or reads the pending state of each group of 32 interrupts
        volatile uint32_t NVIC_ISPR1;  ///< Offset: 0xE204 - Enables or reads the pending state of each group of 32 interrupts
        volatile uint32_t NVIC_ICPR0;  ///< Offset: 0xE280 - Clears or reads the pending state of each group of 32 interrupts
        volatile uint32_t NVIC_ICPR1;  ///< Offset: 0xE284 - Clears or reads the pending state of each group of 32 interrupts
        volatile uint32_t NVIC_IABR0;  ///< Offset: 0xE300 - For each group of 32 interrupts, shows the active state...
        volatile uint32_t NVIC_IABR1;  ///< Offset: 0xE304 - For each group of 32 interrupts, shows the active state...
        volatile uint32_t NVIC_ITNS0;  ///< Offset: 0xE380 - For each group of 32 interrupts, determines whether each...
        volatile uint32_t NVIC_ITNS1;  ///< Offset: 0xE384 - For each group of 32 interrupts, determines whether each...
        volatile uint32_t NVIC_IPR0;  ///< Offset: 0xE400 - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR1;  ///< Offset: 0xE404 - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR2;  ///< Offset: 0xE408 - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR3;  ///< Offset: 0xE40C - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR4;  ///< Offset: 0xE410 - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR5;  ///< Offset: 0xE414 - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR6;  ///< Offset: 0xE418 - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR7;  ///< Offset: 0xE41C - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR8;  ///< Offset: 0xE420 - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR9;  ///< Offset: 0xE424 - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR10;  ///< Offset: 0xE428 - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR11;  ///< Offset: 0xE42C - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR12;  ///< Offset: 0xE430 - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR13;  ///< Offset: 0xE434 - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR14;  ///< Offset: 0xE438 - Sets or reads interrupt priorities
        volatile uint32_t NVIC_IPR15;  ///< Offset: 0xE43C - Sets or reads interrupt priorities
        volatile uint32_t CPUID;  ///< Offset: 0xED00 - Provides identification information for the PE,...
        volatile uint32_t ICSR;  ///< Offset: 0xED04 - Controls and provides status information for NMI,...
        volatile uint32_t VTOR;  ///< Offset: 0xED08 - The VTOR indicates the offset of the vector table base...
        volatile uint32_t AIRCR;  ///< Offset: 0xED0C - Use the Application Interrupt and Reset Control Register...
        volatile uint32_t SCR;  ///< Offset: 0xED10 - System Control Register. Use the System Control Register...
        volatile uint32_t CCR;  ///< Offset: 0xED14 - Sets or returns configuration and control data
        volatile uint32_t SHPR1;  ///< Offset: 0xED18 - Sets or returns priority for system handlers 4 - 7
        volatile uint32_t SHPR2;  ///< Offset: 0xED1C - Sets or returns priority for system handlers 8 - 11
        volatile uint32_t SHPR3;  ///< Offset: 0xED20 - Sets or returns priority for system handlers 12 - 15
        volatile uint32_t SHCSR;  ///< Offset: 0xED24 - Provides access to the active and pending status of...
        volatile uint32_t CFSR;  ///< Offset: 0xED28 - Contains the three Configurable Fault Status Registers....
        volatile uint32_t HFSR;  ///< Offset: 0xED2C - Shows the cause of any HardFaults
        volatile uint32_t DFSR;  ///< Offset: 0xED30 - Shows which debug event occurred
        volatile uint32_t MMFAR;  ///< Offset: 0xED34 - Shows the address of the memory location that caused an MPU fault
        volatile uint32_t BFAR;  ///< Offset: 0xED38 - Shows the address associated with a precise data access BusFault
        volatile uint32_t ID_PFR0;  ///< Offset: 0xED40 - Gives top-level information about the instruction set...
        volatile uint32_t ID_PFR1;  ///< Offset: 0xED44 - Gives information about the programmers' model and...
        volatile uint32_t ID_DFR0;  ///< Offset: 0xED48 - Provides top level information about the debug system
        volatile uint32_t ID_AFR0;  ///< Offset: 0xED4C - Provides information about the IMPLEMENTATION DEFINED...
        volatile uint32_t ID_MMFR0;  ///< Offset: 0xED50 - Provides information about the implemented memory model...
        volatile uint32_t ID_MMFR1;  ///< Offset: 0xED54 - Provides information about the implemented memory model...
        volatile uint32_t ID_MMFR2;  ///< Offset: 0xED58 - Provides information about the implemented memory model...
        volatile uint32_t ID_MMFR3;  ///< Offset: 0xED5C - Provides information about the implemented memory model...
        volatile uint32_t ID_ISAR0;  ///< Offset: 0xED60 - Provides information about the instruction set...
        volatile uint32_t ID_ISAR1;  ///< Offset: 0xED64 - Provides information about the instruction set...
        volatile uint32_t ID_ISAR2;  ///< Offset: 0xED68 - Provides information about the instruction set...
        volatile uint32_t ID_ISAR3;  ///< Offset: 0xED6C - Provides information about the instruction set...
        volatile uint32_t ID_ISAR4;  ///< Offset: 0xED70 - Provides information about the instruction set...
        volatile uint32_t ID_ISAR5;  ///< Offset: 0xED74 - Provides information about the instruction set...
        volatile uint32_t CTR;  ///< Offset: 0xED7C - Provides information about the architecture of the...
        volatile uint32_t CPACR;  ///< Offset: 0xED88 - Specifies the access privileges for coprocessors and the...
        volatile uint32_t NSACR;  ///< Offset: 0xED8C - Defines the Non-secure access permissions for both the...
        volatile uint32_t MPU_TYPE;  ///< Offset: 0xED90 - The MPU Type Register indicates how many regions the MPU...
        volatile uint32_t MPU_CTRL;  ///< Offset: 0xED94 - Enables the MPU and, when the MPU is enabled, controls...
        volatile uint32_t MPU_RNR;  ///< Offset: 0xED98 - Selects the region currently accessed by MPU_RBAR and MPU_RLAR
        volatile uint32_t MPU_RBAR;  ///< Offset: 0xED9C - Provides indirect read and write access to the base...
        volatile uint32_t MPU_RLAR;  ///< Offset: 0xEDA0 - Provides indirect read and write access to the limit...
        volatile uint32_t MPU_RBAR_A1;  ///< Offset: 0xEDA4 - Provides indirect read and write access to the base...
        volatile uint32_t MPU_RLAR_A1;  ///< Offset: 0xEDA8 - Provides indirect read and write access to the limit...
        volatile uint32_t MPU_RBAR_A2;  ///< Offset: 0xEDAC - Provides indirect read and write access to the base...
        volatile uint32_t MPU_RLAR_A2;  ///< Offset: 0xEDB0 - Provides indirect read and write access to the limit...
        volatile uint32_t MPU_RBAR_A3;  ///< Offset: 0xEDB4 - Provides indirect read and write access to the base...
        volatile uint32_t MPU_RLAR_A3;  ///< Offset: 0xEDB8 - Provides indirect read and write access to the limit...
        volatile uint32_t MPU_MAIR0;  ///< Offset: 0xEDC0 - Along with MPU_MAIR1, provides the memory attribute...
        volatile uint32_t MPU_MAIR1;  ///< Offset: 0xEDC4 - Along with MPU_MAIR0, provides the memory attribute...
        volatile uint32_t SAU_CTRL;  ///< Offset: 0xEDD0 - Allows enabling of the Security Attribution Unit
        volatile uint32_t SAU_TYPE;  ///< Offset: 0xEDD4 - Indicates the number of regions implemented by the...
        volatile uint32_t SAU_RNR;  ///< Offset: 0xEDD8 - Selects the region currently accessed by SAU_RBAR and SAU_RLAR
        volatile uint32_t SAU_RBAR;  ///< Offset: 0xEDDC - Provides indirect read and write access to the base...
        volatile uint32_t SAU_RLAR;  ///< Offset: 0xEDE0 - Provides indirect read and write access to the limit...
        volatile uint32_t SFSR;  ///< Offset: 0xEDE4 - Provides information about any security related faults
        volatile uint32_t SFAR;  ///< Offset: 0xEDE8 - Shows the address of the memory location that caused a...
        volatile uint32_t DHCSR;  ///< Offset: 0xEDF0 - Controls halting debug
        volatile uint32_t DCRSR;  ///< Offset: 0xEDF4 - With the DCRDR, provides debug access to the...
        volatile uint32_t DCRDR;  ///< Offset: 0xEDF8 - With the DCRSR, provides debug access to the...
        volatile uint32_t DEMCR;  ///< Offset: 0xEDFC - Manages vector catch behavior and DebugMonitor handling...
        volatile uint32_t DSCSR;  ///< Offset: 0xEE08 - Provides control and status information for Secure debug
        volatile uint32_t STIR;  ///< Offset: 0xEF00 - Provides a mechanism for software to generate an interrupt
        volatile uint32_t FPCCR;  ///< Offset: 0xEF34 - Holds control data for the Floating-point extension
        volatile uint32_t FPCAR;  ///< Offset: 0xEF38 - Holds the location of the unpopulated floating-point...
        volatile uint32_t FPDSCR;  ///< Offset: 0xEF3C - Holds the default values for the floating-point status...
        volatile uint32_t MVFR0;  ///< Offset: 0xEF40 - Describes the features provided by the Floating-point Extension
        volatile uint32_t MVFR1;  ///< Offset: 0xEF44 - Describes the features provided by the Floating-point Extension
        volatile uint32_t MVFR2;  ///< Offset: 0xEF48 - Describes the features provided by the Floating-point Extension
        volatile uint32_t DDEVARCH;  ///< Offset: 0xEFBC - Provides CoreSight discovery information for the SCS
        volatile uint32_t DDEVTYPE;  ///< Offset: 0xEFCC - Provides CoreSight discovery information for the SCS
        volatile uint32_t DPIDR4;  ///< Offset: 0xEFD0 - Provides CoreSight discovery information for the SCS
        volatile uint32_t DPIDR5;  ///< Offset: 0xEFD4 - Provides CoreSight discovery information for the SCS
        volatile uint32_t DPIDR6;  ///< Offset: 0xEFD8 - Provides CoreSight discovery information for the SCS
        volatile uint32_t DPIDR7;  ///< Offset: 0xEFDC - Provides CoreSight discovery information for the SCS
        volatile uint32_t DPIDR0;  ///< Offset: 0xEFE0 - Provides CoreSight discovery information for the SCS
        volatile uint32_t DPIDR1;  ///< Offset: 0xEFE4 - Provides CoreSight discovery information for the SCS
        volatile uint32_t DPIDR2;  ///< Offset: 0xEFE8 - Provides CoreSight discovery information for the SCS
        volatile uint32_t DPIDR3;  ///< Offset: 0xEFEC - Provides CoreSight discovery information for the SCS
        volatile uint32_t DCIDR0;  ///< Offset: 0xEFF0 - Provides CoreSight discovery information for the SCS
        volatile uint32_t DCIDR1;  ///< Offset: 0xEFF4 - Provides CoreSight discovery information for the SCS
        volatile uint32_t DCIDR2;  ///< Offset: 0xEFF8 - Provides CoreSight discovery information for the SCS
        volatile uint32_t DCIDR3;  ///< Offset: 0xEFFC - Provides CoreSight discovery information for the SCS
        volatile uint32_t TRCPRGCTLR;  ///< Offset: 0x41004 - Programming Control Register
        volatile uint32_t TRCSTATR;  ///< Offset: 0x4100C - The TRCSTATR indicates the ETM-Teal status
        volatile uint32_t TRCCONFIGR;  ///< Offset: 0x41010 - The TRCCONFIGR sets the basic tracing options for the trace unit
        volatile uint32_t TRCEVENTCTL0R;  ///< Offset: 0x41020 - The TRCEVENTCTL0R controls the tracing of events in the...
        volatile uint32_t TRCEVENTCTL1R;  ///< Offset: 0x41024 - The TRCEVENTCTL1R controls how the events selected by...
        volatile uint32_t TRCSTALLCTLR;  ///< Offset: 0x4102C - The TRCSTALLCTLR enables ETM-Teal to stall the processor...
        volatile uint32_t TRCTSCTLR;  ///< Offset: 0x41030 - The TRCTSCTLR controls the insertion of global...
        volatile uint32_t TRCSYNCPR;  ///< Offset: 0x41034 - The TRCSYNCPR specifies the period of trace...
        volatile uint32_t TRCCCCTLR;  ///< Offset: 0x41038 - The TRCCCCTLR sets the threshold value for instruction...
        volatile uint32_t TRCVICTLR;  ///< Offset: 0x41080 - The TRCVICTLR controls instruction trace filtering
        volatile uint32_t TRCCNTRLDVR0;  ///< Offset: 0x41140 - The TRCCNTRLDVR defines the reload value for the reduced...
        volatile uint32_t TRCIDR8;  ///< Offset: 0x41180 - TRCIDR8
        volatile uint32_t TRCIDR9;  ///< Offset: 0x41184 - TRCIDR9
        volatile uint32_t TRCIDR10;  ///< Offset: 0x41188 - TRCIDR10
        volatile uint32_t TRCIDR11;  ///< Offset: 0x4118C - TRCIDR11
        volatile uint32_t TRCIDR12;  ///< Offset: 0x41190 - TRCIDR12
        volatile uint32_t TRCIDR13;  ///< Offset: 0x41194 - TRCIDR13
        volatile uint32_t TRCIMSPEC;  ///< Offset: 0x411C0 - The TRCIMSPEC shows the presence of any IMPLEMENTATION...
        volatile uint32_t TRCIDR0;  ///< Offset: 0x411E0 - TRCIDR0
        volatile uint32_t TRCIDR1;  ///< Offset: 0x411E4 - TRCIDR1
        volatile uint32_t TRCIDR2;  ///< Offset: 0x411E8 - TRCIDR2
        volatile uint32_t TRCIDR3;  ///< Offset: 0x411EC - TRCIDR3
        volatile uint32_t TRCIDR4;  ///< Offset: 0x411F0 - TRCIDR4
        volatile uint32_t TRCIDR5;  ///< Offset: 0x411F4 - TRCIDR5
        volatile uint32_t TRCIDR6;  ///< Offset: 0x411F8 - TRCIDR6
        volatile uint32_t TRCIDR7;  ///< Offset: 0x411FC - TRCIDR7
        volatile uint32_t TRCRSCTLR2;  ///< Offset: 0x41208 - The TRCRSCTLR controls the trace resources
        volatile uint32_t TRCRSCTLR3;  ///< Offset: 0x4120C - The TRCRSCTLR controls the trace resources
        volatile uint32_t TRCSSCSR;  ///< Offset: 0x412A0 - Controls the corresponding single-shot comparator resource
        volatile uint32_t TRCSSPCICR;  ///< Offset: 0x412C0 - Selects the PE comparator inputs for Single-shot control
        volatile uint32_t TRCPDCR;  ///< Offset: 0x41310 - Requests the system to provide power to the trace unit
        volatile uint32_t TRCPDSR;  ///< Offset: 0x41314 - Returns the following information about the trace unit:...
        volatile uint32_t TRCITATBIDR;  ///< Offset: 0x41EE4 - Trace Integration ATB Identification Register
        volatile uint32_t TRCITIATBINR;  ///< Offset: 0x41EF4 - Trace Integration Instruction ATB In Register
        volatile uint32_t TRCITIATBOUTR;  ///< Offset: 0x41EFC - Trace Integration Instruction ATB Out Register
        volatile uint32_t TRCCLAIMSET;  ///< Offset: 0x41FA0 - Claim Tag Set Register
        volatile uint32_t TRCCLAIMCLR;  ///< Offset: 0x41FA4 - Claim Tag Clear Register
        volatile uint32_t TRCAUTHSTATUS;  ///< Offset: 0x41FB8 - Returns the level of tracing that the trace unit can support
        volatile uint32_t TRCDEVARCH;  ///< Offset: 0x41FBC - TRCDEVARCH
        volatile uint32_t TRCDEVID;  ///< Offset: 0x41FC8 - TRCDEVID
        volatile uint32_t TRCDEVTYPE;  ///< Offset: 0x41FCC - TRCDEVTYPE
        volatile uint32_t TRCPIDR4;  ///< Offset: 0x41FD0 - TRCPIDR4
        volatile uint32_t TRCPIDR5;  ///< Offset: 0x41FD4 - TRCPIDR5
        volatile uint32_t TRCPIDR6;  ///< Offset: 0x41FD8 - TRCPIDR6
        volatile uint32_t TRCPIDR7;  ///< Offset: 0x41FDC - TRCPIDR7
        volatile uint32_t TRCPIDR0;  ///< Offset: 0x41FE0 - TRCPIDR0
        volatile uint32_t TRCPIDR1;  ///< Offset: 0x41FE4 - TRCPIDR1
        volatile uint32_t TRCPIDR2;  ///< Offset: 0x41FE8 - TRCPIDR2
        volatile uint32_t TRCPIDR3;  ///< Offset: 0x41FEC - TRCPIDR3
        volatile uint32_t TRCCIDR0;  ///< Offset: 0x41FF0 - TRCCIDR0
        volatile uint32_t TRCCIDR1;  ///< Offset: 0x41FF4 - TRCCIDR1
        volatile uint32_t TRCCIDR2;  ///< Offset: 0x41FF8 - TRCCIDR2
        volatile uint32_t TRCCIDR3;  ///< Offset: 0x41FFC - TRCCIDR3
        volatile uint32_t CTICONTROL;  ///< Offset: 0x42000 - CTI Control Register
        volatile uint32_t CTIINTACK;  ///< Offset: 0x42010 - CTI Interrupt Acknowledge Register
        volatile uint32_t CTIAPPSET;  ///< Offset: 0x42014 - CTI Application Trigger Set Register
        volatile uint32_t CTIAPPCLEAR;  ///< Offset: 0x42018 - CTI Application Trigger Clear Register
        volatile uint32_t CTIAPPPULSE;  ///< Offset: 0x4201C - CTI Application Pulse Register
        volatile uint32_t CTIINEN0;  ///< Offset: 0x42020 - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIINEN1;  ///< Offset: 0x42024 - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIINEN2;  ///< Offset: 0x42028 - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIINEN3;  ///< Offset: 0x4202C - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIINEN4;  ///< Offset: 0x42030 - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIINEN5;  ///< Offset: 0x42034 - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIINEN6;  ///< Offset: 0x42038 - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIINEN7;  ///< Offset: 0x4203C - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIOUTEN0;  ///< Offset: 0x420A0 - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIOUTEN1;  ///< Offset: 0x420A4 - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIOUTEN2;  ///< Offset: 0x420A8 - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIOUTEN3;  ///< Offset: 0x420AC - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIOUTEN4;  ///< Offset: 0x420B0 - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIOUTEN5;  ///< Offset: 0x420B4 - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIOUTEN6;  ///< Offset: 0x420B8 - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTIOUTEN7;  ///< Offset: 0x420BC - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTITRIGINSTATUS;  ///< Offset: 0x42130 - CTI Trigger to Channel Enable Registers
        volatile uint32_t CTITRIGOUTSTATUS;  ///< Offset: 0x42134 - CTI Trigger In Status Register
        volatile uint32_t CTICHINSTATUS;  ///< Offset: 0x42138 - CTI Channel In Status Register
        volatile uint32_t CTIGATE;  ///< Offset: 0x42140 - Enable CTI Channel Gate register
        volatile uint32_t ASICCTL;  ///< Offset: 0x42144 - External Multiplexer Control register
        volatile uint32_t ITCHOUT;  ///< Offset: 0x42EE4 - Integration Test Channel Output register
        volatile uint32_t ITTRIGOUT;  ///< Offset: 0x42EE8 - Integration Test Trigger Output register
        volatile uint32_t ITCHIN;  ///< Offset: 0x42EF4 - Integration Test Channel Input register
        volatile uint32_t ITCTRL;  ///< Offset: 0x42F00 - Integration Mode Control register
        volatile uint32_t DEVARCH;  ///< Offset: 0x42FBC - Device Architecture register
        volatile uint32_t DEVID;  ///< Offset: 0x42FC8 - Device Configuration register
        volatile uint32_t DEVTYPE;  ///< Offset: 0x42FCC - Device Type Identifier register
        volatile uint32_t PIDR4;  ///< Offset: 0x42FD0 - CoreSight Peripheral ID4
        volatile uint32_t PIDR5;  ///< Offset: 0x42FD4 - CoreSight Peripheral ID5
        volatile uint32_t PIDR6;  ///< Offset: 0x42FD8 - CoreSight Peripheral ID6
        volatile uint32_t PIDR7;  ///< Offset: 0x42FDC - CoreSight Peripheral ID7
        volatile uint32_t PIDR0;  ///< Offset: 0x42FE0 - CoreSight Peripheral ID0
        volatile uint32_t PIDR1;  ///< Offset: 0x42FE4 - CoreSight Peripheral ID1
        volatile uint32_t PIDR2;  ///< Offset: 0x42FE8 - CoreSight Peripheral ID2
        volatile uint32_t PIDR3;  ///< Offset: 0x42FEC - CoreSight Peripheral ID3
        volatile uint32_t CIDR0;  ///< Offset: 0x42FF0 - CoreSight Component ID0
        volatile uint32_t CIDR1;  ///< Offset: 0x42FF4 - CoreSight Component ID1
        volatile uint32_t CIDR2;  ///< Offset: 0x42FF8 - CoreSight Component ID2
        volatile uint32_t CIDR3;  ///< Offset: 0x42FFC - CoreSight Component ID3
    };

    /// Peripheral instances
    inline Registers* PPB = reinterpret_cast<Registers*>(PPB_BASE);
    inline Registers* PPB_NS = reinterpret_cast<Registers*>(PPB_NS_BASE);

}

// ============================================================================
// QMI Peripheral
// ============================================================================

namespace qmi {
    /// Base addresses
    constexpr uint32_t QMI_BASE = 0x400D0000;

    /// QMI Register structure
    struct Registers {
        volatile uint32_t DIRECT_CSR;  ///< Offset: 0x00 - Control and status for direct serial mode Direct serial...
        volatile uint32_t DIRECT_TX;  ///< Offset: 0x04 - Transmit FIFO for direct mode
        volatile uint32_t DIRECT_RX;  ///< Offset: 0x08 - Receive FIFO for direct mode
        volatile uint32_t M0_TIMING;  ///< Offset: 0x0C - Timing configuration register for memory address window 0.
        volatile uint32_t M0_RFMT;  ///< Offset: 0x10 - Read transfer format configuration for memory address...
        volatile uint32_t M0_RCMD;  ///< Offset: 0x14 - Command constants used for reads from memory address...
        volatile uint32_t M0_WFMT;  ///< Offset: 0x18 - Write transfer format configuration for memory address...
        volatile uint32_t M0_WCMD;  ///< Offset: 0x1C - Command constants used for writes to memory address...
        volatile uint32_t M1_TIMING;  ///< Offset: 0x20 - Timing configuration register for memory address window 1.
        volatile uint32_t M1_RFMT;  ///< Offset: 0x24 - Read transfer format configuration for memory address...
        volatile uint32_t M1_RCMD;  ///< Offset: 0x28 - Command constants used for reads from memory address...
        volatile uint32_t M1_WFMT;  ///< Offset: 0x2C - Write transfer format configuration for memory address...
        volatile uint32_t M1_WCMD;  ///< Offset: 0x30 - Command constants used for writes to memory address...
        volatile uint32_t ATRANS0;  ///< Offset: 0x34 - Configure address translation for XIP virtual addresses...
        volatile uint32_t ATRANS1;  ///< Offset: 0x38 - Configure address translation for XIP virtual addresses...
        volatile uint32_t ATRANS2;  ///< Offset: 0x3C - Configure address translation for XIP virtual addresses...
        volatile uint32_t ATRANS3;  ///< Offset: 0x40 - Configure address translation for XIP virtual addresses...
        volatile uint32_t ATRANS4;  ///< Offset: 0x44 - Configure address translation for XIP virtual addresses...
        volatile uint32_t ATRANS5;  ///< Offset: 0x48 - Configure address translation for XIP virtual addresses...
        volatile uint32_t ATRANS6;  ///< Offset: 0x4C - Configure address translation for XIP virtual addresses...
        volatile uint32_t ATRANS7;  ///< Offset: 0x50 - Configure address translation for XIP virtual addresses...
    };

    /// Peripheral instances
    inline Registers* QMI = reinterpret_cast<Registers*>(QMI_BASE);

}

// ============================================================================
// XIP Peripheral
// ============================================================================

namespace xip {
    /// Base addresses
    constexpr uint32_t XIP_CTRL_BASE = 0x400C8000;
    constexpr uint32_t XIP_AUX_BASE = 0x50500000;

    /// XIP Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Cache control register. Read-only from a Non-secure context.
        volatile uint32_t STAT;  ///< Offset: 0x08 - When 1, indicates the XIP streaming FIFO is completely...
        volatile uint32_t CTR_HIT;  ///< Offset: 0x0C - Cache Hit counter
        volatile uint32_t CTR_ACC;  ///< Offset: 0x10 - Cache Access counter
        volatile uint32_t STREAM_ADDR;  ///< Offset: 0x14 - FIFO stream address
        volatile uint32_t STREAM_CTR;  ///< Offset: 0x18 - FIFO stream control
        volatile uint32_t STREAM_FIFO;  ///< Offset: 0x1C - FIFO stream data
    };

    /// Peripheral instances
    inline Registers* XIP_CTRL = reinterpret_cast<Registers*>(XIP_CTRL_BASE);
    inline Registers* XIP_AUX = reinterpret_cast<Registers*>(XIP_AUX_BASE);

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x40008000;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t PROC_CONFIG;  ///< Offset: 0x00 - Configuration for processors
        volatile uint32_t PROC_IN_SYNC_BYPASS;  ///< Offset: 0x04 - For each bit, if 1, bypass the input synchronizer...
        volatile uint32_t PROC_IN_SYNC_BYPASS_HI;  ///< Offset: 0x08 - For each bit, if 1, bypass the input synchronizer...
        volatile uint32_t DBGFORCE;  ///< Offset: 0x0C - Directly control the chip SWD debug port
        volatile uint32_t MEMPOWERDOWN;  ///< Offset: 0x10 - Control PD pins to memories. Set high to put memories to...
        volatile uint32_t AUXCTRL;  ///< Offset: 0x14 - Auxiliary system control register
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

}

// ============================================================================
// XOSC Peripheral
// ============================================================================

namespace xosc {
    /// Base addresses
    constexpr uint32_t XOSC_BASE = 0x40048000;

    /// XOSC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Crystal Oscillator Control
        volatile uint32_t STATUS;  ///< Offset: 0x04 - Crystal Oscillator Status
        volatile uint32_t DORMANT;  ///< Offset: 0x08 - Crystal Oscillator pause control
        volatile uint32_t STARTUP;  ///< Offset: 0x0C - Controls the startup delay
        volatile uint32_t COUNT;  ///< Offset: 0x10 - A down counter running at the xosc frequency which...
    };

    /// Peripheral instances
    inline Registers* XOSC = reinterpret_cast<Registers*>(XOSC_BASE);

}

// ============================================================================
// PLL Peripheral
// ============================================================================

namespace pll {
    /// Base addresses
    constexpr uint32_t PLL_SYS_BASE = 0x40050000;

    /// PLL Register structure
    struct Registers {
        volatile uint32_t CS;  ///< Offset: 0x00 - Control and Status GENERAL CONSTRAINTS: Reference clock...
        volatile uint32_t PWR;  ///< Offset: 0x04 - Controls the PLL power modes.
        volatile uint32_t FBDIV_INT;  ///< Offset: 0x08 - Feedback divisor (note: this PLL does not support...
        volatile uint32_t PRIM;  ///< Offset: 0x0C - Controls the PLL post dividers for the primary output...
        volatile uint32_t INTR;  ///< Offset: 0x10 - Raw Interrupts
        volatile uint32_t INTE;  ///< Offset: 0x14 - Interrupt Enable
        volatile uint32_t INTF;  ///< Offset: 0x18 - Interrupt Force
        volatile uint32_t INTS;  ///< Offset: 0x1C - Interrupt status after masking & forcing
    };

    /// Peripheral instances
    inline Registers* PLL_SYS = reinterpret_cast<Registers*>(PLL_SYS_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t PLL_USB_BASE = 0x40058000;
    constexpr uint32_t USB_BASE = 0x50110000;
    constexpr uint32_t USB_DPRAM_BASE = 0x50100000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t ADDR_ENDP;  ///< Offset: 0x00 - Device address and endpoint control
        volatile uint32_t ADDR_ENDP1;  ///< Offset: 0x04 - Interrupt endpoint 1. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP2;  ///< Offset: 0x08 - Interrupt endpoint 2. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP3;  ///< Offset: 0x0C - Interrupt endpoint 3. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP4;  ///< Offset: 0x10 - Interrupt endpoint 4. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP5;  ///< Offset: 0x14 - Interrupt endpoint 5. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP6;  ///< Offset: 0x18 - Interrupt endpoint 6. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP7;  ///< Offset: 0x1C - Interrupt endpoint 7. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP8;  ///< Offset: 0x20 - Interrupt endpoint 8. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP9;  ///< Offset: 0x24 - Interrupt endpoint 9. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP10;  ///< Offset: 0x28 - Interrupt endpoint 10. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP11;  ///< Offset: 0x2C - Interrupt endpoint 11. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP12;  ///< Offset: 0x30 - Interrupt endpoint 12. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP13;  ///< Offset: 0x34 - Interrupt endpoint 13. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP14;  ///< Offset: 0x38 - Interrupt endpoint 14. Only valid for HOST mode.
        volatile uint32_t ADDR_ENDP15;  ///< Offset: 0x3C - Interrupt endpoint 15. Only valid for HOST mode.
        volatile uint32_t MAIN_CTRL;  ///< Offset: 0x40 - Main control register
        volatile uint32_t SOF_WR;  ///< Offset: 0x44 - Set the SOF (Start of Frame) frame number in the host...
        volatile uint32_t SOF_RD;  ///< Offset: 0x48 - Read the last SOF (Start of Frame) frame number seen. In...
        volatile uint32_t SIE_CTRL;  ///< Offset: 0x4C - SIE control register
        volatile uint32_t SIE_STATUS;  ///< Offset: 0x50 - SIE status register
        volatile uint32_t INT_EP_CTRL;  ///< Offset: 0x54 - interrupt endpoint control register
        volatile uint32_t BUFF_STATUS;  ///< Offset: 0x58 - Buffer status register. A bit set here indicates that a...
        volatile uint32_t BUFF_CPU_SHOULD_HANDLE;  ///< Offset: 0x5C - Which of the double buffers should be handled. Only...
        volatile uint32_t EP_ABORT;  ///< Offset: 0x60 - Device only: Can be set to ignore the buffer control...
        volatile uint32_t EP_ABORT_DONE;  ///< Offset: 0x64 - Device only: Used in conjunction with `EP_ABORT`. Set...
        volatile uint32_t EP_STALL_ARM;  ///< Offset: 0x68 - Device: this bit must be set in conjunction with the...
        volatile uint32_t NAK_POLL;  ///< Offset: 0x6C - Used by the host controller. Sets the wait time in...
        volatile uint32_t EP_STATUS_STALL_NAK;  ///< Offset: 0x70 - Device: bits are set when the `IRQ_ON_NAK` or...
        volatile uint32_t USB_MUXING;  ///< Offset: 0x74 - Where to connect the USB controller. Should be to_phy by default.
        volatile uint32_t USB_PWR;  ///< Offset: 0x78 - Overrides for the power signals in the event that the...
        volatile uint32_t USBPHY_DIRECT;  ///< Offset: 0x7C - This register allows for direct control of the USB phy....
        volatile uint32_t USBPHY_DIRECT_OVERRIDE;  ///< Offset: 0x80 - Override enable for each control in usbphy_direct
        volatile uint32_t USBPHY_TRIM;  ///< Offset: 0x84 - Used to adjust trim values of USB phy pull down resistors.
        volatile uint32_t LINESTATE_TUNING;  ///< Offset: 0x88 - Used for debug only.
        volatile uint32_t INTR;  ///< Offset: 0x8C - Raw Interrupts
        volatile uint32_t INTE;  ///< Offset: 0x90 - Interrupt Enable
        volatile uint32_t INTF;  ///< Offset: 0x94 - Interrupt Force
        volatile uint32_t INTS;  ///< Offset: 0x98 - Interrupt status after masking & forcing
        volatile uint32_t SOF_TIMESTAMP_RAW;  ///< Offset: 0x100 - Device only. Raw value of free-running PHY clock counter...
        volatile uint32_t SOF_TIMESTAMP_LAST;  ///< Offset: 0x104 - Device only. Value of free-running PHY clock counter...
        volatile uint32_t SM_STATE;  ///< Offset: 0x108 - 
        volatile uint32_t EP_TX_ERROR;  ///< Offset: 0x10C - TX error count for each endpoint. Write to each field to...
        volatile uint32_t EP_RX_ERROR;  ///< Offset: 0x110 - RX error count for each endpoint. Write to each field to...
        volatile uint32_t DEV_SM_WATCHDOG;  ///< Offset: 0x114 - Watchdog that forces the device state machine to idle...
    };

    /// Peripheral instances
    inline Registers* PLL_USB = reinterpret_cast<Registers*>(PLL_USB_BASE);
    inline Registers* USB = reinterpret_cast<Registers*>(USB_BASE);
    inline Registers* USB_DPRAM = reinterpret_cast<Registers*>(USB_DPRAM_BASE);

}

// ============================================================================
// ACCESSCTRL Peripheral
// ============================================================================

namespace accessctrl {
    /// Base addresses
    constexpr uint32_t ACCESSCTRL_BASE = 0x40060000;

    /// ACCESSCTRL Register structure
    struct Registers {
        volatile uint32_t LOCK;  ///< Offset: 0x00 - Once a LOCK bit is written to 1, ACCESSCTRL silently...
        volatile uint32_t FORCE_CORE_NS;  ///< Offset: 0x04 - Force core 1's bus accesses to always be Non-secure, no...
        volatile uint32_t CFGRESET;  ///< Offset: 0x08 - Write 1 to reset all ACCESSCTRL configuration, except...
        volatile uint32_t GPIO_NSMASK0;  ///< Offset: 0x0C - Control whether GPIO0...31 are accessible to Non-secure...
        volatile uint32_t GPIO_NSMASK1;  ///< Offset: 0x10 - Control whether GPIO32..47 are accessible to Non-secure...
        volatile uint32_t ROM;  ///< Offset: 0x14 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t XIP_MAIN;  ///< Offset: 0x18 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SRAM0;  ///< Offset: 0x1C - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SRAM1;  ///< Offset: 0x20 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SRAM2;  ///< Offset: 0x24 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SRAM3;  ///< Offset: 0x28 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SRAM4;  ///< Offset: 0x2C - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SRAM5;  ///< Offset: 0x30 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SRAM6;  ///< Offset: 0x34 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SRAM7;  ///< Offset: 0x38 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SRAM8;  ///< Offset: 0x3C - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SRAM9;  ///< Offset: 0x40 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t DMA;  ///< Offset: 0x44 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t USBCTRL;  ///< Offset: 0x48 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t PIO0;  ///< Offset: 0x4C - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t PIO1;  ///< Offset: 0x50 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t PIO2;  ///< Offset: 0x54 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t CORESIGHT_TRACE;  ///< Offset: 0x58 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t CORESIGHT_PERIPH;  ///< Offset: 0x5C - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SYSINFO;  ///< Offset: 0x60 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t RESETS;  ///< Offset: 0x64 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t IO_BANK0;  ///< Offset: 0x68 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t IO_BANK1;  ///< Offset: 0x6C - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t PADS_BANK0;  ///< Offset: 0x70 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t PADS_QSPI;  ///< Offset: 0x74 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t BUSCTRL;  ///< Offset: 0x78 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t ADC0;  ///< Offset: 0x7C - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t HSTX;  ///< Offset: 0x80 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t I2C0;  ///< Offset: 0x84 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t I2C1;  ///< Offset: 0x88 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t PWM;  ///< Offset: 0x8C - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SPI0;  ///< Offset: 0x90 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SPI1;  ///< Offset: 0x94 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t TIMER0;  ///< Offset: 0x98 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t TIMER1;  ///< Offset: 0x9C - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t UART0;  ///< Offset: 0xA0 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t UART1;  ///< Offset: 0xA4 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t OTP;  ///< Offset: 0xA8 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t TBMAN;  ///< Offset: 0xAC - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t POWMAN;  ///< Offset: 0xB0 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t TRNG;  ///< Offset: 0xB4 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SHA256;  ///< Offset: 0xB8 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t SYSCFG;  ///< Offset: 0xBC - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t CLOCKS;  ///< Offset: 0xC0 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t XOSC;  ///< Offset: 0xC4 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t ROSC;  ///< Offset: 0xC8 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t PLL_SYS;  ///< Offset: 0xCC - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t PLL_USB;  ///< Offset: 0xD0 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t TICKS;  ///< Offset: 0xD4 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t WATCHDOG;  ///< Offset: 0xD8 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t RSM;  ///< Offset: 0xDC - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t XIP_CTRL;  ///< Offset: 0xE0 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t XIP_QMI;  ///< Offset: 0xE4 - Control whether debugger, DMA, core 0 and core 1 can...
        volatile uint32_t XIP_AUX;  ///< Offset: 0xE8 - Control whether debugger, DMA, core 0 and core 1 can...
    };

    /// Peripheral instances
    inline Registers* ACCESSCTRL = reinterpret_cast<Registers*>(ACCESSCTRL_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x40070000;
    constexpr uint32_t UART1_BASE = 0x40078000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t UARTDR;  ///< Offset: 0x00 - Data Register, UARTDR
        volatile uint32_t UARTRSR;  ///< Offset: 0x04 - Receive Status Register/Error Clear Register, UARTRSR/UARTECR
        volatile uint32_t UARTFR;  ///< Offset: 0x18 - Flag Register, UARTFR
        volatile uint32_t UARTILPR;  ///< Offset: 0x20 - IrDA Low-Power Counter Register, UARTILPR
        volatile uint32_t UARTIBRD;  ///< Offset: 0x24 - Integer Baud Rate Register, UARTIBRD
        volatile uint32_t UARTFBRD;  ///< Offset: 0x28 - Fractional Baud Rate Register, UARTFBRD
        volatile uint32_t UARTLCR_H;  ///< Offset: 0x2C - Line Control Register, UARTLCR_H
        volatile uint32_t UARTCR;  ///< Offset: 0x30 - Control Register, UARTCR
        volatile uint32_t UARTIFLS;  ///< Offset: 0x34 - Interrupt FIFO Level Select Register, UARTIFLS
        volatile uint32_t UARTIMSC;  ///< Offset: 0x38 - Interrupt Mask Set/Clear Register, UARTIMSC
        volatile uint32_t UARTRIS;  ///< Offset: 0x3C - Raw Interrupt Status Register, UARTRIS
        volatile uint32_t UARTMIS;  ///< Offset: 0x40 - Masked Interrupt Status Register, UARTMIS
        volatile uint32_t UARTICR;  ///< Offset: 0x44 - Interrupt Clear Register, UARTICR
        volatile uint32_t UARTDMACR;  ///< Offset: 0x48 - DMA Control Register, UARTDMACR
        volatile uint32_t UARTPERIPHID0;  ///< Offset: 0xFE0 - UARTPeriphID0 Register
        volatile uint32_t UARTPERIPHID1;  ///< Offset: 0xFE4 - UARTPeriphID1 Register
        volatile uint32_t UARTPERIPHID2;  ///< Offset: 0xFE8 - UARTPeriphID2 Register
        volatile uint32_t UARTPERIPHID3;  ///< Offset: 0xFEC - UARTPeriphID3 Register
        volatile uint32_t UARTPCELLID0;  ///< Offset: 0xFF0 - UARTPCellID0 Register
        volatile uint32_t UARTPCELLID1;  ///< Offset: 0xFF4 - UARTPCellID1 Register
        volatile uint32_t UARTPCELLID2;  ///< Offset: 0xFF8 - UARTPCellID2 Register
        volatile uint32_t UARTPCELLID3;  ///< Offset: 0xFFC - UARTPCellID3 Register
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);

}

// ============================================================================
// ROSC Peripheral
// ============================================================================

namespace rosc {
    /// Base addresses
    constexpr uint32_t ROSC_BASE = 0x400E8000;

    /// ROSC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Ring Oscillator control
        volatile uint32_t FREQA;  ///< Offset: 0x04 - The FREQA & FREQB registers control the frequency by...
        volatile uint32_t FREQB;  ///< Offset: 0x08 - For a detailed description see freqa register
        volatile uint32_t RANDOM;  ///< Offset: 0x0C - Loads a value to the LFSR randomiser
        volatile uint32_t DORMANT;  ///< Offset: 0x10 - Ring Oscillator pause control
        volatile uint32_t DIV;  ///< Offset: 0x14 - Controls the output divider
        volatile uint32_t PHASE;  ///< Offset: 0x18 - Controls the phase shifted output
        volatile uint32_t STATUS;  ///< Offset: 0x1C - Ring Oscillator Status
        volatile uint32_t RANDOMBIT;  ///< Offset: 0x20 - This just reads the state of the oscillator output so...
        volatile uint32_t COUNT;  ///< Offset: 0x24 - A down counter running at the ROSC frequency which...
    };

    /// Peripheral instances
    inline Registers* ROSC = reinterpret_cast<Registers*>(ROSC_BASE);

}

// ============================================================================
// POWMAN Peripheral
// ============================================================================

namespace powman {
    /// Base addresses
    constexpr uint32_t POWMAN_BASE = 0x40100000;

    /// POWMAN Register structure
    struct Registers {
        volatile uint32_t BADPASSWD;  ///< Offset: 0x00 - Indicates a bad password has been used
        volatile uint32_t VREG_CTRL;  ///< Offset: 0x04 - Voltage Regulator Control
        volatile uint32_t VREG_STS;  ///< Offset: 0x08 - Voltage Regulator Status
        volatile uint32_t VREG;  ///< Offset: 0x0C - Voltage Regulator Settings
        volatile uint32_t VREG_LP_ENTRY;  ///< Offset: 0x10 - Voltage Regulator Low Power Entry Settings
        volatile uint32_t VREG_LP_EXIT;  ///< Offset: 0x14 - Voltage Regulator Low Power Exit Settings
        volatile uint32_t BOD_CTRL;  ///< Offset: 0x18 - Brown-out Detection Control
        volatile uint32_t BOD;  ///< Offset: 0x1C - Brown-out Detection Settings
        volatile uint32_t BOD_LP_ENTRY;  ///< Offset: 0x20 - Brown-out Detection Low Power Entry Settings
        volatile uint32_t BOD_LP_EXIT;  ///< Offset: 0x24 - Brown-out Detection Low Power Exit Settings
        volatile uint32_t LPOSC;  ///< Offset: 0x28 - Low power oscillator control register.
        volatile uint32_t CHIP_RESET;  ///< Offset: 0x2C - Chip reset control and status
        volatile uint32_t WDSEL;  ///< Offset: 0x30 - Allows a watchdog reset to reset the internal state of...
        volatile uint32_t SEQ_CFG;  ///< Offset: 0x34 - For configuration of the power sequencer Writes are...
        volatile uint32_t STATE;  ///< Offset: 0x38 - This register controls the power state of the 4 power...
        volatile uint32_t POW_FASTDIV;  ///< Offset: 0x3C - divides the POWMAN clock to provide a tick for the delay...
        volatile uint32_t POW_DELAY;  ///< Offset: 0x40 - power state machine delays
        volatile uint32_t EXT_CTRL0;  ///< Offset: 0x44 - Configures a gpio as a power mode aware control output
        volatile uint32_t EXT_CTRL1;  ///< Offset: 0x48 - Configures a gpio as a power mode aware control output
        volatile uint32_t EXT_TIME_REF;  ///< Offset: 0x4C - Select a GPIO to use as a time reference, the source can...
        volatile uint32_t LPOSC_FREQ_KHZ_INT;  ///< Offset: 0x50 - Informs the AON Timer of the integer component of the...
        volatile uint32_t LPOSC_FREQ_KHZ_FRAC;  ///< Offset: 0x54 - Informs the AON Timer of the fractional component of the...
        volatile uint32_t XOSC_FREQ_KHZ_INT;  ///< Offset: 0x58 - Informs the AON Timer of the integer component of the...
        volatile uint32_t XOSC_FREQ_KHZ_FRAC;  ///< Offset: 0x5C - Informs the AON Timer of the fractional component of the...
        volatile uint32_t SET_TIME_63TO48;  ///< Offset: 0x60 - For setting the time, do not use for reading the time,...
        volatile uint32_t SET_TIME_47TO32;  ///< Offset: 0x64 - For setting the time, do not use for reading the time,...
        volatile uint32_t SET_TIME_31TO16;  ///< Offset: 0x68 - For setting the time, do not use for reading the time,...
        volatile uint32_t SET_TIME_15TO0;  ///< Offset: 0x6C - For setting the time, do not use for reading the time,...
        volatile uint32_t READ_TIME_UPPER;  ///< Offset: 0x70 - For reading bits 63:32 of the timer. When reading all 64...
        volatile uint32_t READ_TIME_LOWER;  ///< Offset: 0x74 - For reading bits 31:0 of the timer.
        volatile uint32_t ALARM_TIME_63TO48;  ///< Offset: 0x78 - This field must only be written when POWMAN_ALARM_ENAB=0
        volatile uint32_t ALARM_TIME_47TO32;  ///< Offset: 0x7C - This field must only be written when POWMAN_ALARM_ENAB=0
        volatile uint32_t ALARM_TIME_31TO16;  ///< Offset: 0x80 - This field must only be written when POWMAN_ALARM_ENAB=0
        volatile uint32_t ALARM_TIME_15TO0;  ///< Offset: 0x84 - This field must only be written when POWMAN_ALARM_ENAB=0
        volatile uint32_t TIMER;  ///< Offset: 0x88 - Timer is synchronised to a 1hz gpio source
        volatile uint32_t PWRUP0;  ///< Offset: 0x8C - 4 GPIO powerup events can be configured to wake the chip...
        volatile uint32_t PWRUP1;  ///< Offset: 0x90 - 4 GPIO powerup events can be configured to wake the chip...
        volatile uint32_t PWRUP2;  ///< Offset: 0x94 - 4 GPIO powerup events can be configured to wake the chip...
        volatile uint32_t PWRUP3;  ///< Offset: 0x98 - 4 GPIO powerup events can be configured to wake the chip...
        volatile uint32_t CURRENT_PWRUP_REQ;  ///< Offset: 0x9C - Indicates current powerup request state pwrup events can...
        volatile uint32_t LAST_SWCORE_PWRUP;  ///< Offset: 0xA0 - Indicates which pwrup source triggered the last...
        volatile uint32_t DBG_PWRCFG;  ///< Offset: 0xA4 - Ignore pwrup req from debugger. If pwrup req is asserted...
        volatile uint32_t BOOTDIS;  ///< Offset: 0xA8 - Tell the bootrom to ignore the BOOT0..3 registers...
        volatile uint32_t DBGCONFIG;  ///< Offset: 0xAC - Configure DP instance ID for SWD multidrop selection....
        volatile uint32_t SCRATCH0;  ///< Offset: 0xB0 - Scratch register. Information persists in low power mode
        volatile uint32_t SCRATCH1;  ///< Offset: 0xB4 - Scratch register. Information persists in low power mode
        volatile uint32_t SCRATCH2;  ///< Offset: 0xB8 - Scratch register. Information persists in low power mode
        volatile uint32_t SCRATCH3;  ///< Offset: 0xBC - Scratch register. Information persists in low power mode
        volatile uint32_t SCRATCH4;  ///< Offset: 0xC0 - Scratch register. Information persists in low power mode
        volatile uint32_t SCRATCH5;  ///< Offset: 0xC4 - Scratch register. Information persists in low power mode
        volatile uint32_t SCRATCH6;  ///< Offset: 0xC8 - Scratch register. Information persists in low power mode
        volatile uint32_t SCRATCH7;  ///< Offset: 0xCC - Scratch register. Information persists in low power mode
        volatile uint32_t BOOT0;  ///< Offset: 0xD0 - Scratch register. Information persists in low power mode
        volatile uint32_t BOOT1;  ///< Offset: 0xD4 - Scratch register. Information persists in low power mode
        volatile uint32_t BOOT2;  ///< Offset: 0xD8 - Scratch register. Information persists in low power mode
        volatile uint32_t BOOT3;  ///< Offset: 0xDC - Scratch register. Information persists in low power mode
        volatile uint32_t INTR;  ///< Offset: 0xE0 - Raw Interrupts
        volatile uint32_t INTE;  ///< Offset: 0xE4 - Interrupt Enable
        volatile uint32_t INTF;  ///< Offset: 0xE8 - Interrupt Force
        volatile uint32_t INTS;  ///< Offset: 0xEC - Interrupt status after masking & forcing
    };

    /// Peripheral instances
    inline Registers* POWMAN = reinterpret_cast<Registers*>(POWMAN_BASE);

}

// ============================================================================
// WATCHDOG Peripheral
// ============================================================================

namespace watchdog {
    /// Base addresses
    constexpr uint32_t WATCHDOG_BASE = 0x400D8000;

    /// WATCHDOG Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Watchdog control The rst_wdsel register determines which...
        volatile uint32_t LOAD;  ///< Offset: 0x04 - Load the watchdog timer. The maximum setting is 0xffffff...
        volatile uint32_t REASON;  ///< Offset: 0x08 - Logs the reason for the last reset. Both bits are zero...
        volatile uint32_t SCRATCH0;  ///< Offset: 0x0C - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH1;  ///< Offset: 0x10 - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH2;  ///< Offset: 0x14 - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH3;  ///< Offset: 0x18 - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH4;  ///< Offset: 0x1C - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH5;  ///< Offset: 0x20 - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH6;  ///< Offset: 0x24 - Scratch register. Information persists through soft...
        volatile uint32_t SCRATCH7;  ///< Offset: 0x28 - Scratch register. Information persists through soft...
    };

    /// Peripheral instances
    inline Registers* WATCHDOG = reinterpret_cast<Registers*>(WATCHDOG_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x50000000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CH0_READ_ADDR;  ///< Offset: 0x00 - DMA Channel 0 Read Address pointer
        volatile uint32_t CH0_WRITE_ADDR;  ///< Offset: 0x04 - DMA Channel 0 Write Address pointer
        volatile uint32_t CH0_TRANS_COUNT;  ///< Offset: 0x08 - DMA Channel 0 Transfer Count
        volatile uint32_t CH0_CTRL_TRIG;  ///< Offset: 0x0C - DMA Channel 0 Control and Status
        volatile uint32_t CH0_AL1_CTRL;  ///< Offset: 0x10 - Alias for channel 0 CTRL register
        volatile uint32_t CH0_AL1_READ_ADDR;  ///< Offset: 0x14 - Alias for channel 0 READ_ADDR register
        volatile uint32_t CH0_AL1_WRITE_ADDR;  ///< Offset: 0x18 - Alias for channel 0 WRITE_ADDR register
        volatile uint32_t CH0_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x1C - Alias for channel 0 TRANS_COUNT register This is a...
        volatile uint32_t CH0_AL2_CTRL;  ///< Offset: 0x20 - Alias for channel 0 CTRL register
        volatile uint32_t CH0_AL2_TRANS_COUNT;  ///< Offset: 0x24 - Alias for channel 0 TRANS_COUNT register
        volatile uint32_t CH0_AL2_READ_ADDR;  ///< Offset: 0x28 - Alias for channel 0 READ_ADDR register
        volatile uint32_t CH0_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x2C - Alias for channel 0 WRITE_ADDR register This is a...
        volatile uint32_t CH0_AL3_CTRL;  ///< Offset: 0x30 - Alias for channel 0 CTRL register
        volatile uint32_t CH0_AL3_WRITE_ADDR;  ///< Offset: 0x34 - Alias for channel 0 WRITE_ADDR register
        volatile uint32_t CH0_AL3_TRANS_COUNT;  ///< Offset: 0x38 - Alias for channel 0 TRANS_COUNT register
        volatile uint32_t CH0_AL3_READ_ADDR_TRIG;  ///< Offset: 0x3C - Alias for channel 0 READ_ADDR register This is a trigger...
        volatile uint32_t CH1_READ_ADDR;  ///< Offset: 0x40 - DMA Channel 1 Read Address pointer
        volatile uint32_t CH1_WRITE_ADDR;  ///< Offset: 0x44 - DMA Channel 1 Write Address pointer
        volatile uint32_t CH1_TRANS_COUNT;  ///< Offset: 0x48 - DMA Channel 1 Transfer Count
        volatile uint32_t CH1_CTRL_TRIG;  ///< Offset: 0x4C - DMA Channel 1 Control and Status
        volatile uint32_t CH1_AL1_CTRL;  ///< Offset: 0x50 - Alias for channel 1 CTRL register
        volatile uint32_t CH1_AL1_READ_ADDR;  ///< Offset: 0x54 - Alias for channel 1 READ_ADDR register
        volatile uint32_t CH1_AL1_WRITE_ADDR;  ///< Offset: 0x58 - Alias for channel 1 WRITE_ADDR register
        volatile uint32_t CH1_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x5C - Alias for channel 1 TRANS_COUNT register This is a...
        volatile uint32_t CH1_AL2_CTRL;  ///< Offset: 0x60 - Alias for channel 1 CTRL register
        volatile uint32_t CH1_AL2_TRANS_COUNT;  ///< Offset: 0x64 - Alias for channel 1 TRANS_COUNT register
        volatile uint32_t CH1_AL2_READ_ADDR;  ///< Offset: 0x68 - Alias for channel 1 READ_ADDR register
        volatile uint32_t CH1_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x6C - Alias for channel 1 WRITE_ADDR register This is a...
        volatile uint32_t CH1_AL3_CTRL;  ///< Offset: 0x70 - Alias for channel 1 CTRL register
        volatile uint32_t CH1_AL3_WRITE_ADDR;  ///< Offset: 0x74 - Alias for channel 1 WRITE_ADDR register
        volatile uint32_t CH1_AL3_TRANS_COUNT;  ///< Offset: 0x78 - Alias for channel 1 TRANS_COUNT register
        volatile uint32_t CH1_AL3_READ_ADDR_TRIG;  ///< Offset: 0x7C - Alias for channel 1 READ_ADDR register This is a trigger...
        volatile uint32_t CH2_READ_ADDR;  ///< Offset: 0x80 - DMA Channel 2 Read Address pointer
        volatile uint32_t CH2_WRITE_ADDR;  ///< Offset: 0x84 - DMA Channel 2 Write Address pointer
        volatile uint32_t CH2_TRANS_COUNT;  ///< Offset: 0x88 - DMA Channel 2 Transfer Count
        volatile uint32_t CH2_CTRL_TRIG;  ///< Offset: 0x8C - DMA Channel 2 Control and Status
        volatile uint32_t CH2_AL1_CTRL;  ///< Offset: 0x90 - Alias for channel 2 CTRL register
        volatile uint32_t CH2_AL1_READ_ADDR;  ///< Offset: 0x94 - Alias for channel 2 READ_ADDR register
        volatile uint32_t CH2_AL1_WRITE_ADDR;  ///< Offset: 0x98 - Alias for channel 2 WRITE_ADDR register
        volatile uint32_t CH2_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x9C - Alias for channel 2 TRANS_COUNT register This is a...
        volatile uint32_t CH2_AL2_CTRL;  ///< Offset: 0xA0 - Alias for channel 2 CTRL register
        volatile uint32_t CH2_AL2_TRANS_COUNT;  ///< Offset: 0xA4 - Alias for channel 2 TRANS_COUNT register
        volatile uint32_t CH2_AL2_READ_ADDR;  ///< Offset: 0xA8 - Alias for channel 2 READ_ADDR register
        volatile uint32_t CH2_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0xAC - Alias for channel 2 WRITE_ADDR register This is a...
        volatile uint32_t CH2_AL3_CTRL;  ///< Offset: 0xB0 - Alias for channel 2 CTRL register
        volatile uint32_t CH2_AL3_WRITE_ADDR;  ///< Offset: 0xB4 - Alias for channel 2 WRITE_ADDR register
        volatile uint32_t CH2_AL3_TRANS_COUNT;  ///< Offset: 0xB8 - Alias for channel 2 TRANS_COUNT register
        volatile uint32_t CH2_AL3_READ_ADDR_TRIG;  ///< Offset: 0xBC - Alias for channel 2 READ_ADDR register This is a trigger...
        volatile uint32_t CH3_READ_ADDR;  ///< Offset: 0xC0 - DMA Channel 3 Read Address pointer
        volatile uint32_t CH3_WRITE_ADDR;  ///< Offset: 0xC4 - DMA Channel 3 Write Address pointer
        volatile uint32_t CH3_TRANS_COUNT;  ///< Offset: 0xC8 - DMA Channel 3 Transfer Count
        volatile uint32_t CH3_CTRL_TRIG;  ///< Offset: 0xCC - DMA Channel 3 Control and Status
        volatile uint32_t CH3_AL1_CTRL;  ///< Offset: 0xD0 - Alias for channel 3 CTRL register
        volatile uint32_t CH3_AL1_READ_ADDR;  ///< Offset: 0xD4 - Alias for channel 3 READ_ADDR register
        volatile uint32_t CH3_AL1_WRITE_ADDR;  ///< Offset: 0xD8 - Alias for channel 3 WRITE_ADDR register
        volatile uint32_t CH3_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0xDC - Alias for channel 3 TRANS_COUNT register This is a...
        volatile uint32_t CH3_AL2_CTRL;  ///< Offset: 0xE0 - Alias for channel 3 CTRL register
        volatile uint32_t CH3_AL2_TRANS_COUNT;  ///< Offset: 0xE4 - Alias for channel 3 TRANS_COUNT register
        volatile uint32_t CH3_AL2_READ_ADDR;  ///< Offset: 0xE8 - Alias for channel 3 READ_ADDR register
        volatile uint32_t CH3_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0xEC - Alias for channel 3 WRITE_ADDR register This is a...
        volatile uint32_t CH3_AL3_CTRL;  ///< Offset: 0xF0 - Alias for channel 3 CTRL register
        volatile uint32_t CH3_AL3_WRITE_ADDR;  ///< Offset: 0xF4 - Alias for channel 3 WRITE_ADDR register
        volatile uint32_t CH3_AL3_TRANS_COUNT;  ///< Offset: 0xF8 - Alias for channel 3 TRANS_COUNT register
        volatile uint32_t CH3_AL3_READ_ADDR_TRIG;  ///< Offset: 0xFC - Alias for channel 3 READ_ADDR register This is a trigger...
        volatile uint32_t CH4_READ_ADDR;  ///< Offset: 0x100 - DMA Channel 4 Read Address pointer
        volatile uint32_t CH4_WRITE_ADDR;  ///< Offset: 0x104 - DMA Channel 4 Write Address pointer
        volatile uint32_t CH4_TRANS_COUNT;  ///< Offset: 0x108 - DMA Channel 4 Transfer Count
        volatile uint32_t CH4_CTRL_TRIG;  ///< Offset: 0x10C - DMA Channel 4 Control and Status
        volatile uint32_t CH4_AL1_CTRL;  ///< Offset: 0x110 - Alias for channel 4 CTRL register
        volatile uint32_t CH4_AL1_READ_ADDR;  ///< Offset: 0x114 - Alias for channel 4 READ_ADDR register
        volatile uint32_t CH4_AL1_WRITE_ADDR;  ///< Offset: 0x118 - Alias for channel 4 WRITE_ADDR register
        volatile uint32_t CH4_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x11C - Alias for channel 4 TRANS_COUNT register This is a...
        volatile uint32_t CH4_AL2_CTRL;  ///< Offset: 0x120 - Alias for channel 4 CTRL register
        volatile uint32_t CH4_AL2_TRANS_COUNT;  ///< Offset: 0x124 - Alias for channel 4 TRANS_COUNT register
        volatile uint32_t CH4_AL2_READ_ADDR;  ///< Offset: 0x128 - Alias for channel 4 READ_ADDR register
        volatile uint32_t CH4_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x12C - Alias for channel 4 WRITE_ADDR register This is a...
        volatile uint32_t CH4_AL3_CTRL;  ///< Offset: 0x130 - Alias for channel 4 CTRL register
        volatile uint32_t CH4_AL3_WRITE_ADDR;  ///< Offset: 0x134 - Alias for channel 4 WRITE_ADDR register
        volatile uint32_t CH4_AL3_TRANS_COUNT;  ///< Offset: 0x138 - Alias for channel 4 TRANS_COUNT register
        volatile uint32_t CH4_AL3_READ_ADDR_TRIG;  ///< Offset: 0x13C - Alias for channel 4 READ_ADDR register This is a trigger...
        volatile uint32_t CH5_READ_ADDR;  ///< Offset: 0x140 - DMA Channel 5 Read Address pointer
        volatile uint32_t CH5_WRITE_ADDR;  ///< Offset: 0x144 - DMA Channel 5 Write Address pointer
        volatile uint32_t CH5_TRANS_COUNT;  ///< Offset: 0x148 - DMA Channel 5 Transfer Count
        volatile uint32_t CH5_CTRL_TRIG;  ///< Offset: 0x14C - DMA Channel 5 Control and Status
        volatile uint32_t CH5_AL1_CTRL;  ///< Offset: 0x150 - Alias for channel 5 CTRL register
        volatile uint32_t CH5_AL1_READ_ADDR;  ///< Offset: 0x154 - Alias for channel 5 READ_ADDR register
        volatile uint32_t CH5_AL1_WRITE_ADDR;  ///< Offset: 0x158 - Alias for channel 5 WRITE_ADDR register
        volatile uint32_t CH5_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x15C - Alias for channel 5 TRANS_COUNT register This is a...
        volatile uint32_t CH5_AL2_CTRL;  ///< Offset: 0x160 - Alias for channel 5 CTRL register
        volatile uint32_t CH5_AL2_TRANS_COUNT;  ///< Offset: 0x164 - Alias for channel 5 TRANS_COUNT register
        volatile uint32_t CH5_AL2_READ_ADDR;  ///< Offset: 0x168 - Alias for channel 5 READ_ADDR register
        volatile uint32_t CH5_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x16C - Alias for channel 5 WRITE_ADDR register This is a...
        volatile uint32_t CH5_AL3_CTRL;  ///< Offset: 0x170 - Alias for channel 5 CTRL register
        volatile uint32_t CH5_AL3_WRITE_ADDR;  ///< Offset: 0x174 - Alias for channel 5 WRITE_ADDR register
        volatile uint32_t CH5_AL3_TRANS_COUNT;  ///< Offset: 0x178 - Alias for channel 5 TRANS_COUNT register
        volatile uint32_t CH5_AL3_READ_ADDR_TRIG;  ///< Offset: 0x17C - Alias for channel 5 READ_ADDR register This is a trigger...
        volatile uint32_t CH6_READ_ADDR;  ///< Offset: 0x180 - DMA Channel 6 Read Address pointer
        volatile uint32_t CH6_WRITE_ADDR;  ///< Offset: 0x184 - DMA Channel 6 Write Address pointer
        volatile uint32_t CH6_TRANS_COUNT;  ///< Offset: 0x188 - DMA Channel 6 Transfer Count
        volatile uint32_t CH6_CTRL_TRIG;  ///< Offset: 0x18C - DMA Channel 6 Control and Status
        volatile uint32_t CH6_AL1_CTRL;  ///< Offset: 0x190 - Alias for channel 6 CTRL register
        volatile uint32_t CH6_AL1_READ_ADDR;  ///< Offset: 0x194 - Alias for channel 6 READ_ADDR register
        volatile uint32_t CH6_AL1_WRITE_ADDR;  ///< Offset: 0x198 - Alias for channel 6 WRITE_ADDR register
        volatile uint32_t CH6_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x19C - Alias for channel 6 TRANS_COUNT register This is a...
        volatile uint32_t CH6_AL2_CTRL;  ///< Offset: 0x1A0 - Alias for channel 6 CTRL register
        volatile uint32_t CH6_AL2_TRANS_COUNT;  ///< Offset: 0x1A4 - Alias for channel 6 TRANS_COUNT register
        volatile uint32_t CH6_AL2_READ_ADDR;  ///< Offset: 0x1A8 - Alias for channel 6 READ_ADDR register
        volatile uint32_t CH6_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x1AC - Alias for channel 6 WRITE_ADDR register This is a...
        volatile uint32_t CH6_AL3_CTRL;  ///< Offset: 0x1B0 - Alias for channel 6 CTRL register
        volatile uint32_t CH6_AL3_WRITE_ADDR;  ///< Offset: 0x1B4 - Alias for channel 6 WRITE_ADDR register
        volatile uint32_t CH6_AL3_TRANS_COUNT;  ///< Offset: 0x1B8 - Alias for channel 6 TRANS_COUNT register
        volatile uint32_t CH6_AL3_READ_ADDR_TRIG;  ///< Offset: 0x1BC - Alias for channel 6 READ_ADDR register This is a trigger...
        volatile uint32_t CH7_READ_ADDR;  ///< Offset: 0x1C0 - DMA Channel 7 Read Address pointer
        volatile uint32_t CH7_WRITE_ADDR;  ///< Offset: 0x1C4 - DMA Channel 7 Write Address pointer
        volatile uint32_t CH7_TRANS_COUNT;  ///< Offset: 0x1C8 - DMA Channel 7 Transfer Count
        volatile uint32_t CH7_CTRL_TRIG;  ///< Offset: 0x1CC - DMA Channel 7 Control and Status
        volatile uint32_t CH7_AL1_CTRL;  ///< Offset: 0x1D0 - Alias for channel 7 CTRL register
        volatile uint32_t CH7_AL1_READ_ADDR;  ///< Offset: 0x1D4 - Alias for channel 7 READ_ADDR register
        volatile uint32_t CH7_AL1_WRITE_ADDR;  ///< Offset: 0x1D8 - Alias for channel 7 WRITE_ADDR register
        volatile uint32_t CH7_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x1DC - Alias for channel 7 TRANS_COUNT register This is a...
        volatile uint32_t CH7_AL2_CTRL;  ///< Offset: 0x1E0 - Alias for channel 7 CTRL register
        volatile uint32_t CH7_AL2_TRANS_COUNT;  ///< Offset: 0x1E4 - Alias for channel 7 TRANS_COUNT register
        volatile uint32_t CH7_AL2_READ_ADDR;  ///< Offset: 0x1E8 - Alias for channel 7 READ_ADDR register
        volatile uint32_t CH7_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x1EC - Alias for channel 7 WRITE_ADDR register This is a...
        volatile uint32_t CH7_AL3_CTRL;  ///< Offset: 0x1F0 - Alias for channel 7 CTRL register
        volatile uint32_t CH7_AL3_WRITE_ADDR;  ///< Offset: 0x1F4 - Alias for channel 7 WRITE_ADDR register
        volatile uint32_t CH7_AL3_TRANS_COUNT;  ///< Offset: 0x1F8 - Alias for channel 7 TRANS_COUNT register
        volatile uint32_t CH7_AL3_READ_ADDR_TRIG;  ///< Offset: 0x1FC - Alias for channel 7 READ_ADDR register This is a trigger...
        volatile uint32_t CH8_READ_ADDR;  ///< Offset: 0x200 - DMA Channel 8 Read Address pointer
        volatile uint32_t CH8_WRITE_ADDR;  ///< Offset: 0x204 - DMA Channel 8 Write Address pointer
        volatile uint32_t CH8_TRANS_COUNT;  ///< Offset: 0x208 - DMA Channel 8 Transfer Count
        volatile uint32_t CH8_CTRL_TRIG;  ///< Offset: 0x20C - DMA Channel 8 Control and Status
        volatile uint32_t CH8_AL1_CTRL;  ///< Offset: 0x210 - Alias for channel 8 CTRL register
        volatile uint32_t CH8_AL1_READ_ADDR;  ///< Offset: 0x214 - Alias for channel 8 READ_ADDR register
        volatile uint32_t CH8_AL1_WRITE_ADDR;  ///< Offset: 0x218 - Alias for channel 8 WRITE_ADDR register
        volatile uint32_t CH8_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x21C - Alias for channel 8 TRANS_COUNT register This is a...
        volatile uint32_t CH8_AL2_CTRL;  ///< Offset: 0x220 - Alias for channel 8 CTRL register
        volatile uint32_t CH8_AL2_TRANS_COUNT;  ///< Offset: 0x224 - Alias for channel 8 TRANS_COUNT register
        volatile uint32_t CH8_AL2_READ_ADDR;  ///< Offset: 0x228 - Alias for channel 8 READ_ADDR register
        volatile uint32_t CH8_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x22C - Alias for channel 8 WRITE_ADDR register This is a...
        volatile uint32_t CH8_AL3_CTRL;  ///< Offset: 0x230 - Alias for channel 8 CTRL register
        volatile uint32_t CH8_AL3_WRITE_ADDR;  ///< Offset: 0x234 - Alias for channel 8 WRITE_ADDR register
        volatile uint32_t CH8_AL3_TRANS_COUNT;  ///< Offset: 0x238 - Alias for channel 8 TRANS_COUNT register
        volatile uint32_t CH8_AL3_READ_ADDR_TRIG;  ///< Offset: 0x23C - Alias for channel 8 READ_ADDR register This is a trigger...
        volatile uint32_t CH9_READ_ADDR;  ///< Offset: 0x240 - DMA Channel 9 Read Address pointer
        volatile uint32_t CH9_WRITE_ADDR;  ///< Offset: 0x244 - DMA Channel 9 Write Address pointer
        volatile uint32_t CH9_TRANS_COUNT;  ///< Offset: 0x248 - DMA Channel 9 Transfer Count
        volatile uint32_t CH9_CTRL_TRIG;  ///< Offset: 0x24C - DMA Channel 9 Control and Status
        volatile uint32_t CH9_AL1_CTRL;  ///< Offset: 0x250 - Alias for channel 9 CTRL register
        volatile uint32_t CH9_AL1_READ_ADDR;  ///< Offset: 0x254 - Alias for channel 9 READ_ADDR register
        volatile uint32_t CH9_AL1_WRITE_ADDR;  ///< Offset: 0x258 - Alias for channel 9 WRITE_ADDR register
        volatile uint32_t CH9_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x25C - Alias for channel 9 TRANS_COUNT register This is a...
        volatile uint32_t CH9_AL2_CTRL;  ///< Offset: 0x260 - Alias for channel 9 CTRL register
        volatile uint32_t CH9_AL2_TRANS_COUNT;  ///< Offset: 0x264 - Alias for channel 9 TRANS_COUNT register
        volatile uint32_t CH9_AL2_READ_ADDR;  ///< Offset: 0x268 - Alias for channel 9 READ_ADDR register
        volatile uint32_t CH9_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x26C - Alias for channel 9 WRITE_ADDR register This is a...
        volatile uint32_t CH9_AL3_CTRL;  ///< Offset: 0x270 - Alias for channel 9 CTRL register
        volatile uint32_t CH9_AL3_WRITE_ADDR;  ///< Offset: 0x274 - Alias for channel 9 WRITE_ADDR register
        volatile uint32_t CH9_AL3_TRANS_COUNT;  ///< Offset: 0x278 - Alias for channel 9 TRANS_COUNT register
        volatile uint32_t CH9_AL3_READ_ADDR_TRIG;  ///< Offset: 0x27C - Alias for channel 9 READ_ADDR register This is a trigger...
        volatile uint32_t CH10_READ_ADDR;  ///< Offset: 0x280 - DMA Channel 10 Read Address pointer
        volatile uint32_t CH10_WRITE_ADDR;  ///< Offset: 0x284 - DMA Channel 10 Write Address pointer
        volatile uint32_t CH10_TRANS_COUNT;  ///< Offset: 0x288 - DMA Channel 10 Transfer Count
        volatile uint32_t CH10_CTRL_TRIG;  ///< Offset: 0x28C - DMA Channel 10 Control and Status
        volatile uint32_t CH10_AL1_CTRL;  ///< Offset: 0x290 - Alias for channel 10 CTRL register
        volatile uint32_t CH10_AL1_READ_ADDR;  ///< Offset: 0x294 - Alias for channel 10 READ_ADDR register
        volatile uint32_t CH10_AL1_WRITE_ADDR;  ///< Offset: 0x298 - Alias for channel 10 WRITE_ADDR register
        volatile uint32_t CH10_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x29C - Alias for channel 10 TRANS_COUNT register This is a...
        volatile uint32_t CH10_AL2_CTRL;  ///< Offset: 0x2A0 - Alias for channel 10 CTRL register
        volatile uint32_t CH10_AL2_TRANS_COUNT;  ///< Offset: 0x2A4 - Alias for channel 10 TRANS_COUNT register
        volatile uint32_t CH10_AL2_READ_ADDR;  ///< Offset: 0x2A8 - Alias for channel 10 READ_ADDR register
        volatile uint32_t CH10_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x2AC - Alias for channel 10 WRITE_ADDR register This is a...
        volatile uint32_t CH10_AL3_CTRL;  ///< Offset: 0x2B0 - Alias for channel 10 CTRL register
        volatile uint32_t CH10_AL3_WRITE_ADDR;  ///< Offset: 0x2B4 - Alias for channel 10 WRITE_ADDR register
        volatile uint32_t CH10_AL3_TRANS_COUNT;  ///< Offset: 0x2B8 - Alias for channel 10 TRANS_COUNT register
        volatile uint32_t CH10_AL3_READ_ADDR_TRIG;  ///< Offset: 0x2BC - Alias for channel 10 READ_ADDR register This is a...
        volatile uint32_t CH11_READ_ADDR;  ///< Offset: 0x2C0 - DMA Channel 11 Read Address pointer
        volatile uint32_t CH11_WRITE_ADDR;  ///< Offset: 0x2C4 - DMA Channel 11 Write Address pointer
        volatile uint32_t CH11_TRANS_COUNT;  ///< Offset: 0x2C8 - DMA Channel 11 Transfer Count
        volatile uint32_t CH11_CTRL_TRIG;  ///< Offset: 0x2CC - DMA Channel 11 Control and Status
        volatile uint32_t CH11_AL1_CTRL;  ///< Offset: 0x2D0 - Alias for channel 11 CTRL register
        volatile uint32_t CH11_AL1_READ_ADDR;  ///< Offset: 0x2D4 - Alias for channel 11 READ_ADDR register
        volatile uint32_t CH11_AL1_WRITE_ADDR;  ///< Offset: 0x2D8 - Alias for channel 11 WRITE_ADDR register
        volatile uint32_t CH11_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x2DC - Alias for channel 11 TRANS_COUNT register This is a...
        volatile uint32_t CH11_AL2_CTRL;  ///< Offset: 0x2E0 - Alias for channel 11 CTRL register
        volatile uint32_t CH11_AL2_TRANS_COUNT;  ///< Offset: 0x2E4 - Alias for channel 11 TRANS_COUNT register
        volatile uint32_t CH11_AL2_READ_ADDR;  ///< Offset: 0x2E8 - Alias for channel 11 READ_ADDR register
        volatile uint32_t CH11_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x2EC - Alias for channel 11 WRITE_ADDR register This is a...
        volatile uint32_t CH11_AL3_CTRL;  ///< Offset: 0x2F0 - Alias for channel 11 CTRL register
        volatile uint32_t CH11_AL3_WRITE_ADDR;  ///< Offset: 0x2F4 - Alias for channel 11 WRITE_ADDR register
        volatile uint32_t CH11_AL3_TRANS_COUNT;  ///< Offset: 0x2F8 - Alias for channel 11 TRANS_COUNT register
        volatile uint32_t CH11_AL3_READ_ADDR_TRIG;  ///< Offset: 0x2FC - Alias for channel 11 READ_ADDR register This is a...
        volatile uint32_t CH12_READ_ADDR;  ///< Offset: 0x300 - DMA Channel 12 Read Address pointer
        volatile uint32_t CH12_WRITE_ADDR;  ///< Offset: 0x304 - DMA Channel 12 Write Address pointer
        volatile uint32_t CH12_TRANS_COUNT;  ///< Offset: 0x308 - DMA Channel 12 Transfer Count
        volatile uint32_t CH12_CTRL_TRIG;  ///< Offset: 0x30C - DMA Channel 12 Control and Status
        volatile uint32_t CH12_AL1_CTRL;  ///< Offset: 0x310 - Alias for channel 12 CTRL register
        volatile uint32_t CH12_AL1_READ_ADDR;  ///< Offset: 0x314 - Alias for channel 12 READ_ADDR register
        volatile uint32_t CH12_AL1_WRITE_ADDR;  ///< Offset: 0x318 - Alias for channel 12 WRITE_ADDR register
        volatile uint32_t CH12_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x31C - Alias for channel 12 TRANS_COUNT register This is a...
        volatile uint32_t CH12_AL2_CTRL;  ///< Offset: 0x320 - Alias for channel 12 CTRL register
        volatile uint32_t CH12_AL2_TRANS_COUNT;  ///< Offset: 0x324 - Alias for channel 12 TRANS_COUNT register
        volatile uint32_t CH12_AL2_READ_ADDR;  ///< Offset: 0x328 - Alias for channel 12 READ_ADDR register
        volatile uint32_t CH12_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x32C - Alias for channel 12 WRITE_ADDR register This is a...
        volatile uint32_t CH12_AL3_CTRL;  ///< Offset: 0x330 - Alias for channel 12 CTRL register
        volatile uint32_t CH12_AL3_WRITE_ADDR;  ///< Offset: 0x334 - Alias for channel 12 WRITE_ADDR register
        volatile uint32_t CH12_AL3_TRANS_COUNT;  ///< Offset: 0x338 - Alias for channel 12 TRANS_COUNT register
        volatile uint32_t CH12_AL3_READ_ADDR_TRIG;  ///< Offset: 0x33C - Alias for channel 12 READ_ADDR register This is a...
        volatile uint32_t CH13_READ_ADDR;  ///< Offset: 0x340 - DMA Channel 13 Read Address pointer
        volatile uint32_t CH13_WRITE_ADDR;  ///< Offset: 0x344 - DMA Channel 13 Write Address pointer
        volatile uint32_t CH13_TRANS_COUNT;  ///< Offset: 0x348 - DMA Channel 13 Transfer Count
        volatile uint32_t CH13_CTRL_TRIG;  ///< Offset: 0x34C - DMA Channel 13 Control and Status
        volatile uint32_t CH13_AL1_CTRL;  ///< Offset: 0x350 - Alias for channel 13 CTRL register
        volatile uint32_t CH13_AL1_READ_ADDR;  ///< Offset: 0x354 - Alias for channel 13 READ_ADDR register
        volatile uint32_t CH13_AL1_WRITE_ADDR;  ///< Offset: 0x358 - Alias for channel 13 WRITE_ADDR register
        volatile uint32_t CH13_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x35C - Alias for channel 13 TRANS_COUNT register This is a...
        volatile uint32_t CH13_AL2_CTRL;  ///< Offset: 0x360 - Alias for channel 13 CTRL register
        volatile uint32_t CH13_AL2_TRANS_COUNT;  ///< Offset: 0x364 - Alias for channel 13 TRANS_COUNT register
        volatile uint32_t CH13_AL2_READ_ADDR;  ///< Offset: 0x368 - Alias for channel 13 READ_ADDR register
        volatile uint32_t CH13_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x36C - Alias for channel 13 WRITE_ADDR register This is a...
        volatile uint32_t CH13_AL3_CTRL;  ///< Offset: 0x370 - Alias for channel 13 CTRL register
        volatile uint32_t CH13_AL3_WRITE_ADDR;  ///< Offset: 0x374 - Alias for channel 13 WRITE_ADDR register
        volatile uint32_t CH13_AL3_TRANS_COUNT;  ///< Offset: 0x378 - Alias for channel 13 TRANS_COUNT register
        volatile uint32_t CH13_AL3_READ_ADDR_TRIG;  ///< Offset: 0x37C - Alias for channel 13 READ_ADDR register This is a...
        volatile uint32_t CH14_READ_ADDR;  ///< Offset: 0x380 - DMA Channel 14 Read Address pointer
        volatile uint32_t CH14_WRITE_ADDR;  ///< Offset: 0x384 - DMA Channel 14 Write Address pointer
        volatile uint32_t CH14_TRANS_COUNT;  ///< Offset: 0x388 - DMA Channel 14 Transfer Count
        volatile uint32_t CH14_CTRL_TRIG;  ///< Offset: 0x38C - DMA Channel 14 Control and Status
        volatile uint32_t CH14_AL1_CTRL;  ///< Offset: 0x390 - Alias for channel 14 CTRL register
        volatile uint32_t CH14_AL1_READ_ADDR;  ///< Offset: 0x394 - Alias for channel 14 READ_ADDR register
        volatile uint32_t CH14_AL1_WRITE_ADDR;  ///< Offset: 0x398 - Alias for channel 14 WRITE_ADDR register
        volatile uint32_t CH14_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x39C - Alias for channel 14 TRANS_COUNT register This is a...
        volatile uint32_t CH14_AL2_CTRL;  ///< Offset: 0x3A0 - Alias for channel 14 CTRL register
        volatile uint32_t CH14_AL2_TRANS_COUNT;  ///< Offset: 0x3A4 - Alias for channel 14 TRANS_COUNT register
        volatile uint32_t CH14_AL2_READ_ADDR;  ///< Offset: 0x3A8 - Alias for channel 14 READ_ADDR register
        volatile uint32_t CH14_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x3AC - Alias for channel 14 WRITE_ADDR register This is a...
        volatile uint32_t CH14_AL3_CTRL;  ///< Offset: 0x3B0 - Alias for channel 14 CTRL register
        volatile uint32_t CH14_AL3_WRITE_ADDR;  ///< Offset: 0x3B4 - Alias for channel 14 WRITE_ADDR register
        volatile uint32_t CH14_AL3_TRANS_COUNT;  ///< Offset: 0x3B8 - Alias for channel 14 TRANS_COUNT register
        volatile uint32_t CH14_AL3_READ_ADDR_TRIG;  ///< Offset: 0x3BC - Alias for channel 14 READ_ADDR register This is a...
        volatile uint32_t CH15_READ_ADDR;  ///< Offset: 0x3C0 - DMA Channel 15 Read Address pointer
        volatile uint32_t CH15_WRITE_ADDR;  ///< Offset: 0x3C4 - DMA Channel 15 Write Address pointer
        volatile uint32_t CH15_TRANS_COUNT;  ///< Offset: 0x3C8 - DMA Channel 15 Transfer Count
        volatile uint32_t CH15_CTRL_TRIG;  ///< Offset: 0x3CC - DMA Channel 15 Control and Status
        volatile uint32_t CH15_AL1_CTRL;  ///< Offset: 0x3D0 - Alias for channel 15 CTRL register
        volatile uint32_t CH15_AL1_READ_ADDR;  ///< Offset: 0x3D4 - Alias for channel 15 READ_ADDR register
        volatile uint32_t CH15_AL1_WRITE_ADDR;  ///< Offset: 0x3D8 - Alias for channel 15 WRITE_ADDR register
        volatile uint32_t CH15_AL1_TRANS_COUNT_TRIG;  ///< Offset: 0x3DC - Alias for channel 15 TRANS_COUNT register This is a...
        volatile uint32_t CH15_AL2_CTRL;  ///< Offset: 0x3E0 - Alias for channel 15 CTRL register
        volatile uint32_t CH15_AL2_TRANS_COUNT;  ///< Offset: 0x3E4 - Alias for channel 15 TRANS_COUNT register
        volatile uint32_t CH15_AL2_READ_ADDR;  ///< Offset: 0x3E8 - Alias for channel 15 READ_ADDR register
        volatile uint32_t CH15_AL2_WRITE_ADDR_TRIG;  ///< Offset: 0x3EC - Alias for channel 15 WRITE_ADDR register This is a...
        volatile uint32_t CH15_AL3_CTRL;  ///< Offset: 0x3F0 - Alias for channel 15 CTRL register
        volatile uint32_t CH15_AL3_WRITE_ADDR;  ///< Offset: 0x3F4 - Alias for channel 15 WRITE_ADDR register
        volatile uint32_t CH15_AL3_TRANS_COUNT;  ///< Offset: 0x3F8 - Alias for channel 15 TRANS_COUNT register
        volatile uint32_t CH15_AL3_READ_ADDR_TRIG;  ///< Offset: 0x3FC - Alias for channel 15 READ_ADDR register This is a...
        volatile uint32_t INTR;  ///< Offset: 0x400 - Interrupt Status (raw)
        volatile uint32_t INTE0;  ///< Offset: 0x404 - Interrupt Enables for IRQ 0
        volatile uint32_t INTF0;  ///< Offset: 0x408 - Force Interrupts
        volatile uint32_t INTS0;  ///< Offset: 0x40C - Interrupt Status for IRQ 0
        volatile uint32_t INTR1;  ///< Offset: 0x410 - Interrupt Status (raw)
        volatile uint32_t INTE1;  ///< Offset: 0x414 - Interrupt Enables for IRQ 1
        volatile uint32_t INTF1;  ///< Offset: 0x418 - Force Interrupts
        volatile uint32_t INTS1;  ///< Offset: 0x41C - Interrupt Status for IRQ 1
        volatile uint32_t INTR2;  ///< Offset: 0x420 - Interrupt Status (raw)
        volatile uint32_t INTE2;  ///< Offset: 0x424 - Interrupt Enables for IRQ 2
        volatile uint32_t INTF2;  ///< Offset: 0x428 - Force Interrupts
        volatile uint32_t INTS2;  ///< Offset: 0x42C - Interrupt Status for IRQ 2
        volatile uint32_t INTR3;  ///< Offset: 0x430 - Interrupt Status (raw)
        volatile uint32_t INTE3;  ///< Offset: 0x434 - Interrupt Enables for IRQ 3
        volatile uint32_t INTF3;  ///< Offset: 0x438 - Force Interrupts
        volatile uint32_t INTS3;  ///< Offset: 0x43C - Interrupt Status for IRQ 3
        volatile uint32_t TIMER0;  ///< Offset: 0x440 - Pacing (X/Y) fractional timer The pacing timer produces...
        volatile uint32_t TIMER1;  ///< Offset: 0x444 - Pacing (X/Y) fractional timer The pacing timer produces...
        volatile uint32_t TIMER2;  ///< Offset: 0x448 - Pacing (X/Y) fractional timer The pacing timer produces...
        volatile uint32_t TIMER3;  ///< Offset: 0x44C - Pacing (X/Y) fractional timer The pacing timer produces...
        volatile uint32_t MULTI_CHAN_TRIGGER;  ///< Offset: 0x450 - Trigger one or more channels simultaneously
        volatile uint32_t SNIFF_CTRL;  ///< Offset: 0x454 - Sniffer Control
        volatile uint32_t SNIFF_DATA;  ///< Offset: 0x458 - Data accumulator for sniff hardware
        volatile uint32_t FIFO_LEVELS;  ///< Offset: 0x460 - Debug RAF, WAF, TDF levels
        volatile uint32_t CHAN_ABORT;  ///< Offset: 0x464 - Abort an in-progress transfer sequence on one or more channels
        volatile uint32_t N_CHANNELS;  ///< Offset: 0x468 - The number of channels this DMA instance is equipped...
        volatile uint32_t SECCFG_CH0;  ///< Offset: 0x480 - Security configuration for channel 0. Control whether...
        volatile uint32_t SECCFG_CH1;  ///< Offset: 0x484 - Security configuration for channel 1. Control whether...
        volatile uint32_t SECCFG_CH2;  ///< Offset: 0x488 - Security configuration for channel 2. Control whether...
        volatile uint32_t SECCFG_CH3;  ///< Offset: 0x48C - Security configuration for channel 3. Control whether...
        volatile uint32_t SECCFG_CH4;  ///< Offset: 0x490 - Security configuration for channel 4. Control whether...
        volatile uint32_t SECCFG_CH5;  ///< Offset: 0x494 - Security configuration for channel 5. Control whether...
        volatile uint32_t SECCFG_CH6;  ///< Offset: 0x498 - Security configuration for channel 6. Control whether...
        volatile uint32_t SECCFG_CH7;  ///< Offset: 0x49C - Security configuration for channel 7. Control whether...
        volatile uint32_t SECCFG_CH8;  ///< Offset: 0x4A0 - Security configuration for channel 8. Control whether...
        volatile uint32_t SECCFG_CH9;  ///< Offset: 0x4A4 - Security configuration for channel 9. Control whether...
        volatile uint32_t SECCFG_CH10;  ///< Offset: 0x4A8 - Security configuration for channel 10. Control whether...
        volatile uint32_t SECCFG_CH11;  ///< Offset: 0x4AC - Security configuration for channel 11. Control whether...
        volatile uint32_t SECCFG_CH12;  ///< Offset: 0x4B0 - Security configuration for channel 12. Control whether...
        volatile uint32_t SECCFG_CH13;  ///< Offset: 0x4B4 - Security configuration for channel 13. Control whether...
        volatile uint32_t SECCFG_CH14;  ///< Offset: 0x4B8 - Security configuration for channel 14. Control whether...
        volatile uint32_t SECCFG_CH15;  ///< Offset: 0x4BC - Security configuration for channel 15. Control whether...
        volatile uint32_t SECCFG_IRQ0;  ///< Offset: 0x4C0 - Security configuration for IRQ 0. Control whether the...
        volatile uint32_t SECCFG_IRQ1;  ///< Offset: 0x4C4 - Security configuration for IRQ 1. Control whether the...
        volatile uint32_t SECCFG_IRQ2;  ///< Offset: 0x4C8 - Security configuration for IRQ 2. Control whether the...
        volatile uint32_t SECCFG_IRQ3;  ///< Offset: 0x4CC - Security configuration for IRQ 3. Control whether the...
        volatile uint32_t SECCFG_MISC;  ///< Offset: 0x4D0 - Miscellaneous security configuration
        volatile uint32_t MPU_CTRL;  ///< Offset: 0x500 - Control register for DMA MPU. Accessible only from a...
        volatile uint32_t MPU_BAR0;  ///< Offset: 0x504 - Base address register for MPU region 0. Writable only...
        volatile uint32_t MPU_LAR0;  ///< Offset: 0x508 - Limit address register for MPU region 0. Writable only...
        volatile uint32_t MPU_BAR1;  ///< Offset: 0x50C - Base address register for MPU region 1. Writable only...
        volatile uint32_t MPU_LAR1;  ///< Offset: 0x510 - Limit address register for MPU region 1. Writable only...
        volatile uint32_t MPU_BAR2;  ///< Offset: 0x514 - Base address register for MPU region 2. Writable only...
        volatile uint32_t MPU_LAR2;  ///< Offset: 0x518 - Limit address register for MPU region 2. Writable only...
        volatile uint32_t MPU_BAR3;  ///< Offset: 0x51C - Base address register for MPU region 3. Writable only...
        volatile uint32_t MPU_LAR3;  ///< Offset: 0x520 - Limit address register for MPU region 3. Writable only...
        volatile uint32_t MPU_BAR4;  ///< Offset: 0x524 - Base address register for MPU region 4. Writable only...
        volatile uint32_t MPU_LAR4;  ///< Offset: 0x528 - Limit address register for MPU region 4. Writable only...
        volatile uint32_t MPU_BAR5;  ///< Offset: 0x52C - Base address register for MPU region 5. Writable only...
        volatile uint32_t MPU_LAR5;  ///< Offset: 0x530 - Limit address register for MPU region 5. Writable only...
        volatile uint32_t MPU_BAR6;  ///< Offset: 0x534 - Base address register for MPU region 6. Writable only...
        volatile uint32_t MPU_LAR6;  ///< Offset: 0x538 - Limit address register for MPU region 6. Writable only...
        volatile uint32_t MPU_BAR7;  ///< Offset: 0x53C - Base address register for MPU region 7. Writable only...
        volatile uint32_t MPU_LAR7;  ///< Offset: 0x540 - Limit address register for MPU region 7. Writable only...
        volatile uint32_t CH0_DBG_CTDREQ;  ///< Offset: 0x800 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH0_DBG_TCR;  ///< Offset: 0x804 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH1_DBG_CTDREQ;  ///< Offset: 0x840 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH1_DBG_TCR;  ///< Offset: 0x844 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH2_DBG_CTDREQ;  ///< Offset: 0x880 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH2_DBG_TCR;  ///< Offset: 0x884 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH3_DBG_CTDREQ;  ///< Offset: 0x8C0 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH3_DBG_TCR;  ///< Offset: 0x8C4 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH4_DBG_CTDREQ;  ///< Offset: 0x900 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH4_DBG_TCR;  ///< Offset: 0x904 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH5_DBG_CTDREQ;  ///< Offset: 0x940 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH5_DBG_TCR;  ///< Offset: 0x944 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH6_DBG_CTDREQ;  ///< Offset: 0x980 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH6_DBG_TCR;  ///< Offset: 0x984 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH7_DBG_CTDREQ;  ///< Offset: 0x9C0 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH7_DBG_TCR;  ///< Offset: 0x9C4 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH8_DBG_CTDREQ;  ///< Offset: 0xA00 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH8_DBG_TCR;  ///< Offset: 0xA04 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH9_DBG_CTDREQ;  ///< Offset: 0xA40 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH9_DBG_TCR;  ///< Offset: 0xA44 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH10_DBG_CTDREQ;  ///< Offset: 0xA80 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH10_DBG_TCR;  ///< Offset: 0xA84 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH11_DBG_CTDREQ;  ///< Offset: 0xAC0 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH11_DBG_TCR;  ///< Offset: 0xAC4 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH12_DBG_CTDREQ;  ///< Offset: 0xB00 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH12_DBG_TCR;  ///< Offset: 0xB04 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH13_DBG_CTDREQ;  ///< Offset: 0xB40 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH13_DBG_TCR;  ///< Offset: 0xB44 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH14_DBG_CTDREQ;  ///< Offset: 0xB80 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH14_DBG_TCR;  ///< Offset: 0xB84 - Read to get channel TRANS_COUNT reload value, i.e. the...
        volatile uint32_t CH15_DBG_CTDREQ;  ///< Offset: 0xBC0 - Read: get channel DREQ counter (i.e. how many accesses...
        volatile uint32_t CH15_DBG_TCR;  ///< Offset: 0xBC4 - Read to get channel TRANS_COUNT reload value, i.e. the...
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER0_BASE = 0x400B0000;
    constexpr uint32_t TIMER1_BASE = 0x400B8000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TIMEHW;  ///< Offset: 0x00 - Write to bits 63:32 of time always write timelw before timehw
        volatile uint32_t TIMELW;  ///< Offset: 0x04 - Write to bits 31:0 of time writes do not get copied to...
        volatile uint32_t TIMEHR;  ///< Offset: 0x08 - Read from bits 63:32 of time always read timelr before timehr
        volatile uint32_t TIMELR;  ///< Offset: 0x0C - Read from bits 31:0 of time
        volatile uint32_t ALARM0;  ///< Offset: 0x10 - Arm alarm 0, and configure the time it will fire. Once...
        volatile uint32_t ALARM1;  ///< Offset: 0x14 - Arm alarm 1, and configure the time it will fire. Once...
        volatile uint32_t ALARM2;  ///< Offset: 0x18 - Arm alarm 2, and configure the time it will fire. Once...
        volatile uint32_t ALARM3;  ///< Offset: 0x1C - Arm alarm 3, and configure the time it will fire. Once...
        volatile uint32_t ARMED;  ///< Offset: 0x20 - Indicates the armed/disarmed status of each alarm. A...
        volatile uint32_t TIMERAWH;  ///< Offset: 0x24 - Raw read from bits 63:32 of time (no side effects)
        volatile uint32_t TIMERAWL;  ///< Offset: 0x28 - Raw read from bits 31:0 of time (no side effects)
        volatile uint32_t DBGPAUSE;  ///< Offset: 0x2C - Set bits high to enable pause when the corresponding...
        volatile uint32_t PAUSE;  ///< Offset: 0x30 - Set high to pause the timer
        volatile uint32_t LOCKED;  ///< Offset: 0x34 - Set locked bit to disable write access to timer Once...
        volatile uint32_t SOURCE;  ///< Offset: 0x38 - Selects the source for the timer. Defaults to the normal...
        volatile uint32_t INTR;  ///< Offset: 0x3C - Raw Interrupts
        volatile uint32_t INTE;  ///< Offset: 0x40 - Interrupt Enable
        volatile uint32_t INTF;  ///< Offset: 0x44 - Interrupt Force
        volatile uint32_t INTS;  ///< Offset: 0x48 - Interrupt status after masking & forcing
    };

    /// Peripheral instances
    inline Registers* TIMER0 = reinterpret_cast<Registers*>(TIMER0_BASE);
    inline Registers* TIMER1 = reinterpret_cast<Registers*>(TIMER1_BASE);

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t PWM_BASE = 0x400A8000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t CH0_CSR;  ///< Offset: 0x00 - Control and status register
        volatile uint32_t CH0_DIV;  ///< Offset: 0x04 - INT and FRAC form a fixed-point fractional number....
        volatile uint32_t CH0_CTR;  ///< Offset: 0x08 - Direct access to the PWM counter
        volatile uint32_t CH0_CC;  ///< Offset: 0x0C - Counter compare values
        volatile uint32_t CH0_TOP;  ///< Offset: 0x10 - Counter wrap value
        volatile uint32_t CH1_CSR;  ///< Offset: 0x14 - Control and status register
        volatile uint32_t CH1_DIV;  ///< Offset: 0x18 - INT and FRAC form a fixed-point fractional number....
        volatile uint32_t CH1_CTR;  ///< Offset: 0x1C - Direct access to the PWM counter
        volatile uint32_t CH1_CC;  ///< Offset: 0x20 - Counter compare values
        volatile uint32_t CH1_TOP;  ///< Offset: 0x24 - Counter wrap value
        volatile uint32_t CH2_CSR;  ///< Offset: 0x28 - Control and status register
        volatile uint32_t CH2_DIV;  ///< Offset: 0x2C - INT and FRAC form a fixed-point fractional number....
        volatile uint32_t CH2_CTR;  ///< Offset: 0x30 - Direct access to the PWM counter
        volatile uint32_t CH2_CC;  ///< Offset: 0x34 - Counter compare values
        volatile uint32_t CH2_TOP;  ///< Offset: 0x38 - Counter wrap value
        volatile uint32_t CH3_CSR;  ///< Offset: 0x3C - Control and status register
        volatile uint32_t CH3_DIV;  ///< Offset: 0x40 - INT and FRAC form a fixed-point fractional number....
        volatile uint32_t CH3_CTR;  ///< Offset: 0x44 - Direct access to the PWM counter
        volatile uint32_t CH3_CC;  ///< Offset: 0x48 - Counter compare values
        volatile uint32_t CH3_TOP;  ///< Offset: 0x4C - Counter wrap value
        volatile uint32_t CH4_CSR;  ///< Offset: 0x50 - Control and status register
        volatile uint32_t CH4_DIV;  ///< Offset: 0x54 - INT and FRAC form a fixed-point fractional number....
        volatile uint32_t CH4_CTR;  ///< Offset: 0x58 - Direct access to the PWM counter
        volatile uint32_t CH4_CC;  ///< Offset: 0x5C - Counter compare values
        volatile uint32_t CH4_TOP;  ///< Offset: 0x60 - Counter wrap value
        volatile uint32_t CH5_CSR;  ///< Offset: 0x64 - Control and status register
        volatile uint32_t CH5_DIV;  ///< Offset: 0x68 - INT and FRAC form a fixed-point fractional number....
        volatile uint32_t CH5_CTR;  ///< Offset: 0x6C - Direct access to the PWM counter
        volatile uint32_t CH5_CC;  ///< Offset: 0x70 - Counter compare values
        volatile uint32_t CH5_TOP;  ///< Offset: 0x74 - Counter wrap value
        volatile uint32_t CH6_CSR;  ///< Offset: 0x78 - Control and status register
        volatile uint32_t CH6_DIV;  ///< Offset: 0x7C - INT and FRAC form a fixed-point fractional number....
        volatile uint32_t CH6_CTR;  ///< Offset: 0x80 - Direct access to the PWM counter
        volatile uint32_t CH6_CC;  ///< Offset: 0x84 - Counter compare values
        volatile uint32_t CH6_TOP;  ///< Offset: 0x88 - Counter wrap value
        volatile uint32_t CH7_CSR;  ///< Offset: 0x8C - Control and status register
        volatile uint32_t CH7_DIV;  ///< Offset: 0x90 - INT and FRAC form a fixed-point fractional number....
        volatile uint32_t CH7_CTR;  ///< Offset: 0x94 - Direct access to the PWM counter
        volatile uint32_t CH7_CC;  ///< Offset: 0x98 - Counter compare values
        volatile uint32_t CH7_TOP;  ///< Offset: 0x9C - Counter wrap value
        volatile uint32_t CH8_CSR;  ///< Offset: 0xA0 - Control and status register
        volatile uint32_t CH8_DIV;  ///< Offset: 0xA4 - INT and FRAC form a fixed-point fractional number....
        volatile uint32_t CH8_CTR;  ///< Offset: 0xA8 - Direct access to the PWM counter
        volatile uint32_t CH8_CC;  ///< Offset: 0xAC - Counter compare values
        volatile uint32_t CH8_TOP;  ///< Offset: 0xB0 - Counter wrap value
        volatile uint32_t CH9_CSR;  ///< Offset: 0xB4 - Control and status register
        volatile uint32_t CH9_DIV;  ///< Offset: 0xB8 - INT and FRAC form a fixed-point fractional number....
        volatile uint32_t CH9_CTR;  ///< Offset: 0xBC - Direct access to the PWM counter
        volatile uint32_t CH9_CC;  ///< Offset: 0xC0 - Counter compare values
        volatile uint32_t CH9_TOP;  ///< Offset: 0xC4 - Counter wrap value
        volatile uint32_t CH10_CSR;  ///< Offset: 0xC8 - Control and status register
        volatile uint32_t CH10_DIV;  ///< Offset: 0xCC - INT and FRAC form a fixed-point fractional number....
        volatile uint32_t CH10_CTR;  ///< Offset: 0xD0 - Direct access to the PWM counter
        volatile uint32_t CH10_CC;  ///< Offset: 0xD4 - Counter compare values
        volatile uint32_t CH10_TOP;  ///< Offset: 0xD8 - Counter wrap value
        volatile uint32_t CH11_CSR;  ///< Offset: 0xDC - Control and status register
        volatile uint32_t CH11_DIV;  ///< Offset: 0xE0 - INT and FRAC form a fixed-point fractional number....
        volatile uint32_t CH11_CTR;  ///< Offset: 0xE4 - Direct access to the PWM counter
        volatile uint32_t CH11_CC;  ///< Offset: 0xE8 - Counter compare values
        volatile uint32_t CH11_TOP;  ///< Offset: 0xEC - Counter wrap value
        volatile uint32_t EN;  ///< Offset: 0xF0 - This register aliases the CSR_EN bits for all channels....
        volatile uint32_t INTR;  ///< Offset: 0xF4 - Raw Interrupts
        volatile uint32_t IRQ0_INTE;  ///< Offset: 0xF8 - Interrupt Enable for irq0
        volatile uint32_t IRQ0_INTF;  ///< Offset: 0xFC - Interrupt Force for irq0
        volatile uint32_t IRQ0_INTS;  ///< Offset: 0x100 - Interrupt status after masking & forcing for irq0
        volatile uint32_t IRQ1_INTE;  ///< Offset: 0x104 - Interrupt Enable for irq1
        volatile uint32_t IRQ1_INTF;  ///< Offset: 0x108 - Interrupt Force for irq1
        volatile uint32_t IRQ1_INTS;  ///< Offset: 0x10C - Interrupt status after masking & forcing for irq1
    };

    /// Peripheral instances
    inline Registers* PWM = reinterpret_cast<Registers*>(PWM_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x400A0000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CS;  ///< Offset: 0x00 - ADC Control and Status
        volatile uint32_t RESULT;  ///< Offset: 0x04 - Result of most recent ADC conversion
        volatile uint32_t FCS;  ///< Offset: 0x08 - FIFO control and status
        volatile uint32_t FIFO;  ///< Offset: 0x0C - Conversion result FIFO
        volatile uint32_t DIV;  ///< Offset: 0x10 - Clock divider. If non-zero, CS_START_MANY will start...
        volatile uint32_t INTR;  ///< Offset: 0x14 - Raw Interrupts
        volatile uint32_t INTE;  ///< Offset: 0x18 - Interrupt Enable
        volatile uint32_t INTF;  ///< Offset: 0x1C - Interrupt Force
        volatile uint32_t INTS;  ///< Offset: 0x20 - Interrupt status after masking & forcing
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40090000;
    constexpr uint32_t I2C1_BASE = 0x40098000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t IC_CON;  ///< Offset: 0x00 - I2C Control Register. This register can be written only...
        volatile uint32_t IC_TAR;  ///< Offset: 0x04 - I2C Target Address Register This register is 12 bits...
        volatile uint32_t IC_SAR;  ///< Offset: 0x08 - I2C Slave Address Register
        volatile uint32_t IC_DATA_CMD;  ///< Offset: 0x10 - I2C Rx/Tx Data Buffer and Command Register; this is the...
        volatile uint32_t IC_SS_SCL_HCNT;  ///< Offset: 0x14 - Standard Speed I2C Clock SCL High Count Register
        volatile uint32_t IC_SS_SCL_LCNT;  ///< Offset: 0x18 - Standard Speed I2C Clock SCL Low Count Register
        volatile uint32_t IC_FS_SCL_HCNT;  ///< Offset: 0x1C - Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
        volatile uint32_t IC_FS_SCL_LCNT;  ///< Offset: 0x20 - Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
        volatile uint32_t IC_INTR_STAT;  ///< Offset: 0x2C - I2C Interrupt Status Register Each bit in this register...
        volatile uint32_t IC_INTR_MASK;  ///< Offset: 0x30 - I2C Interrupt Mask Register. These bits mask their...
        volatile uint32_t IC_RAW_INTR_STAT;  ///< Offset: 0x34 - I2C Raw Interrupt Status Register Unlike the...
        volatile uint32_t IC_RX_TL;  ///< Offset: 0x38 - I2C Receive FIFO Threshold Register
        volatile uint32_t IC_TX_TL;  ///< Offset: 0x3C - I2C Transmit FIFO Threshold Register
        volatile uint32_t IC_CLR_INTR;  ///< Offset: 0x40 - Clear Combined and Individual Interrupt Register
        volatile uint32_t IC_CLR_RX_UNDER;  ///< Offset: 0x44 - Clear RX_UNDER Interrupt Register
        volatile uint32_t IC_CLR_RX_OVER;  ///< Offset: 0x48 - Clear RX_OVER Interrupt Register
        volatile uint32_t IC_CLR_TX_OVER;  ///< Offset: 0x4C - Clear TX_OVER Interrupt Register
        volatile uint32_t IC_CLR_RD_REQ;  ///< Offset: 0x50 - Clear RD_REQ Interrupt Register
        volatile uint32_t IC_CLR_TX_ABRT;  ///< Offset: 0x54 - Clear TX_ABRT Interrupt Register
        volatile uint32_t IC_CLR_RX_DONE;  ///< Offset: 0x58 - Clear RX_DONE Interrupt Register
        volatile uint32_t IC_CLR_ACTIVITY;  ///< Offset: 0x5C - Clear ACTIVITY Interrupt Register
        volatile uint32_t IC_CLR_STOP_DET;  ///< Offset: 0x60 - Clear STOP_DET Interrupt Register
        volatile uint32_t IC_CLR_START_DET;  ///< Offset: 0x64 - Clear START_DET Interrupt Register
        volatile uint32_t IC_CLR_GEN_CALL;  ///< Offset: 0x68 - Clear GEN_CALL Interrupt Register
        volatile uint32_t IC_ENABLE;  ///< Offset: 0x6C - I2C Enable Register
        volatile uint32_t IC_STATUS;  ///< Offset: 0x70 - I2C Status Register This is a read-only register used to...
        volatile uint32_t IC_TXFLR;  ///< Offset: 0x74 - I2C Transmit FIFO Level Register This register contains...
        volatile uint32_t IC_RXFLR;  ///< Offset: 0x78 - I2C Receive FIFO Level Register This register contains...
        volatile uint32_t IC_SDA_HOLD;  ///< Offset: 0x7C - I2C SDA Hold Time Length Register The bits [15:0] of...
        volatile uint32_t IC_TX_ABRT_SOURCE;  ///< Offset: 0x80 - I2C Transmit Abort Source Register This register has 32...
        volatile uint32_t IC_SLV_DATA_NACK_ONLY;  ///< Offset: 0x84 - Generate Slave Data NACK Register The register is used...
        volatile uint32_t IC_DMA_CR;  ///< Offset: 0x88 - DMA Control Register The register is used to enable the...
        volatile uint32_t IC_DMA_TDLR;  ///< Offset: 0x8C - DMA Transmit Data Level Register
        volatile uint32_t IC_DMA_RDLR;  ///< Offset: 0x90 - I2C Receive Data Level Register
        volatile uint32_t IC_SDA_SETUP;  ///< Offset: 0x94 - I2C SDA Setup Register This register controls the amount...
        volatile uint32_t IC_ACK_GENERAL_CALL;  ///< Offset: 0x98 - I2C ACK General Call Register The register controls...
        volatile uint32_t IC_ENABLE_STATUS;  ///< Offset: 0x9C - I2C Enable Status Register The register is used to...
        volatile uint32_t IC_FS_SPKLEN;  ///< Offset: 0xA0 - I2C SS, FS or FM+ spike suppression limit This register...
        volatile uint32_t IC_CLR_RESTART_DET;  ///< Offset: 0xA8 - Clear RESTART_DET Interrupt Register
        volatile uint32_t IC_COMP_PARAM_1;  ///< Offset: 0xF4 - Component Parameter Register 1 Note This register is not...
        volatile uint32_t IC_COMP_VERSION;  ///< Offset: 0xF8 - I2C Component Version Register
        volatile uint32_t IC_COMP_TYPE;  ///< Offset: 0xFC - I2C Component Type Register
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

}

// ============================================================================
// PIO0 Peripheral
// ============================================================================

namespace pio0 {
    /// Base addresses
    constexpr uint32_t PIO0_BASE = 0x50200000;

    /// PIO0 Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - PIO control register
        volatile uint32_t FSTAT;  ///< Offset: 0x04 - FIFO status register
        volatile uint32_t FDEBUG;  ///< Offset: 0x08 - FIFO debug register
        volatile uint32_t FLEVEL;  ///< Offset: 0x0C - FIFO levels
        volatile uint32_t TXF0;  ///< Offset: 0x10 - Direct write access to the TX FIFO for this state...
        volatile uint32_t TXF1;  ///< Offset: 0x14 - Direct write access to the TX FIFO for this state...
        volatile uint32_t TXF2;  ///< Offset: 0x18 - Direct write access to the TX FIFO for this state...
        volatile uint32_t TXF3;  ///< Offset: 0x1C - Direct write access to the TX FIFO for this state...
        volatile uint32_t RXF0;  ///< Offset: 0x20 - Direct read access to the RX FIFO for this state...
        volatile uint32_t RXF1;  ///< Offset: 0x24 - Direct read access to the RX FIFO for this state...
        volatile uint32_t RXF2;  ///< Offset: 0x28 - Direct read access to the RX FIFO for this state...
        volatile uint32_t RXF3;  ///< Offset: 0x2C - Direct read access to the RX FIFO for this state...
        volatile uint32_t IRQ;  ///< Offset: 0x30 - State machine IRQ flags register. Write 1 to clear....
        volatile uint32_t IRQ_FORCE;  ///< Offset: 0x34 - Writing a 1 to each of these bits will forcibly assert...
        volatile uint32_t INPUT_SYNC_BYPASS;  ///< Offset: 0x38 - There is a 2-flipflop synchronizer on each GPIO input,...
        volatile uint32_t DBG_PADOUT;  ///< Offset: 0x3C - Read to sample the pad output values PIO is currently...
        volatile uint32_t DBG_PADOE;  ///< Offset: 0x40 - Read to sample the pad output enables (direction) PIO is...
        volatile uint32_t DBG_CFGINFO;  ///< Offset: 0x44 - The PIO hardware has some free parameters that may vary...
        volatile uint32_t INSTR_MEM0;  ///< Offset: 0x48 - Write-only access to instruction memory location 0
        volatile uint32_t INSTR_MEM1;  ///< Offset: 0x4C - Write-only access to instruction memory location 1
        volatile uint32_t INSTR_MEM2;  ///< Offset: 0x50 - Write-only access to instruction memory location 2
        volatile uint32_t INSTR_MEM3;  ///< Offset: 0x54 - Write-only access to instruction memory location 3
        volatile uint32_t INSTR_MEM4;  ///< Offset: 0x58 - Write-only access to instruction memory location 4
        volatile uint32_t INSTR_MEM5;  ///< Offset: 0x5C - Write-only access to instruction memory location 5
        volatile uint32_t INSTR_MEM6;  ///< Offset: 0x60 - Write-only access to instruction memory location 6
        volatile uint32_t INSTR_MEM7;  ///< Offset: 0x64 - Write-only access to instruction memory location 7
        volatile uint32_t INSTR_MEM8;  ///< Offset: 0x68 - Write-only access to instruction memory location 8
        volatile uint32_t INSTR_MEM9;  ///< Offset: 0x6C - Write-only access to instruction memory location 9
        volatile uint32_t INSTR_MEM10;  ///< Offset: 0x70 - Write-only access to instruction memory location 10
        volatile uint32_t INSTR_MEM11;  ///< Offset: 0x74 - Write-only access to instruction memory location 11
        volatile uint32_t INSTR_MEM12;  ///< Offset: 0x78 - Write-only access to instruction memory location 12
        volatile uint32_t INSTR_MEM13;  ///< Offset: 0x7C - Write-only access to instruction memory location 13
        volatile uint32_t INSTR_MEM14;  ///< Offset: 0x80 - Write-only access to instruction memory location 14
        volatile uint32_t INSTR_MEM15;  ///< Offset: 0x84 - Write-only access to instruction memory location 15
        volatile uint32_t INSTR_MEM16;  ///< Offset: 0x88 - Write-only access to instruction memory location 16
        volatile uint32_t INSTR_MEM17;  ///< Offset: 0x8C - Write-only access to instruction memory location 17
        volatile uint32_t INSTR_MEM18;  ///< Offset: 0x90 - Write-only access to instruction memory location 18
        volatile uint32_t INSTR_MEM19;  ///< Offset: 0x94 - Write-only access to instruction memory location 19
        volatile uint32_t INSTR_MEM20;  ///< Offset: 0x98 - Write-only access to instruction memory location 20
        volatile uint32_t INSTR_MEM21;  ///< Offset: 0x9C - Write-only access to instruction memory location 21
        volatile uint32_t INSTR_MEM22;  ///< Offset: 0xA0 - Write-only access to instruction memory location 22
        volatile uint32_t INSTR_MEM23;  ///< Offset: 0xA4 - Write-only access to instruction memory location 23
        volatile uint32_t INSTR_MEM24;  ///< Offset: 0xA8 - Write-only access to instruction memory location 24
        volatile uint32_t INSTR_MEM25;  ///< Offset: 0xAC - Write-only access to instruction memory location 25
        volatile uint32_t INSTR_MEM26;  ///< Offset: 0xB0 - Write-only access to instruction memory location 26
        volatile uint32_t INSTR_MEM27;  ///< Offset: 0xB4 - Write-only access to instruction memory location 27
        volatile uint32_t INSTR_MEM28;  ///< Offset: 0xB8 - Write-only access to instruction memory location 28
        volatile uint32_t INSTR_MEM29;  ///< Offset: 0xBC - Write-only access to instruction memory location 29
        volatile uint32_t INSTR_MEM30;  ///< Offset: 0xC0 - Write-only access to instruction memory location 30
        volatile uint32_t INSTR_MEM31;  ///< Offset: 0xC4 - Write-only access to instruction memory location 31
        volatile uint32_t SM0_CLKDIV;  ///< Offset: 0xC8 - Clock divisor register for state machine 0 Frequency =...
        volatile uint32_t SM0_EXECCTRL;  ///< Offset: 0xCC - Execution/behavioural settings for state machine 0
        volatile uint32_t SM0_SHIFTCTRL;  ///< Offset: 0xD0 - Control behaviour of the input/output shift registers...
        volatile uint32_t SM0_ADDR;  ///< Offset: 0xD4 - Current instruction address of state machine 0
        volatile uint32_t SM0_INSTR;  ///< Offset: 0xD8 - Read to see the instruction currently addressed by state...
        volatile uint32_t SM0_PINCTRL;  ///< Offset: 0xDC - State machine pin control
        volatile uint32_t SM1_CLKDIV;  ///< Offset: 0xE0 - Clock divisor register for state machine 1 Frequency =...
        volatile uint32_t SM1_EXECCTRL;  ///< Offset: 0xE4 - Execution/behavioural settings for state machine 1
        volatile uint32_t SM1_SHIFTCTRL;  ///< Offset: 0xE8 - Control behaviour of the input/output shift registers...
        volatile uint32_t SM1_ADDR;  ///< Offset: 0xEC - Current instruction address of state machine 1
        volatile uint32_t SM1_INSTR;  ///< Offset: 0xF0 - Read to see the instruction currently addressed by state...
        volatile uint32_t SM1_PINCTRL;  ///< Offset: 0xF4 - State machine pin control
        volatile uint32_t SM2_CLKDIV;  ///< Offset: 0xF8 - Clock divisor register for state machine 2 Frequency =...
        volatile uint32_t SM2_EXECCTRL;  ///< Offset: 0xFC - Execution/behavioural settings for state machine 2
        volatile uint32_t SM2_SHIFTCTRL;  ///< Offset: 0x100 - Control behaviour of the input/output shift registers...
        volatile uint32_t SM2_ADDR;  ///< Offset: 0x104 - Current instruction address of state machine 2
        volatile uint32_t SM2_INSTR;  ///< Offset: 0x108 - Read to see the instruction currently addressed by state...
        volatile uint32_t SM2_PINCTRL;  ///< Offset: 0x10C - State machine pin control
        volatile uint32_t SM3_CLKDIV;  ///< Offset: 0x110 - Clock divisor register for state machine 3 Frequency =...
        volatile uint32_t SM3_EXECCTRL;  ///< Offset: 0x114 - Execution/behavioural settings for state machine 3
        volatile uint32_t SM3_SHIFTCTRL;  ///< Offset: 0x118 - Control behaviour of the input/output shift registers...
        volatile uint32_t SM3_ADDR;  ///< Offset: 0x11C - Current instruction address of state machine 3
        volatile uint32_t SM3_INSTR;  ///< Offset: 0x120 - Read to see the instruction currently addressed by state...
        volatile uint32_t SM3_PINCTRL;  ///< Offset: 0x124 - State machine pin control
        volatile uint32_t RXF0_PUTGET0;  ///< Offset: 0x128 - Direct read/write access to entry 0 of SM0's RX FIFO, if...
        volatile uint32_t RXF0_PUTGET1;  ///< Offset: 0x12C - Direct read/write access to entry 1 of SM0's RX FIFO, if...
        volatile uint32_t RXF0_PUTGET2;  ///< Offset: 0x130 - Direct read/write access to entry 2 of SM0's RX FIFO, if...
        volatile uint32_t RXF0_PUTGET3;  ///< Offset: 0x134 - Direct read/write access to entry 3 of SM0's RX FIFO, if...
        volatile uint32_t RXF1_PUTGET0;  ///< Offset: 0x138 - Direct read/write access to entry 0 of SM1's RX FIFO, if...
        volatile uint32_t RXF1_PUTGET1;  ///< Offset: 0x13C - Direct read/write access to entry 1 of SM1's RX FIFO, if...
        volatile uint32_t RXF1_PUTGET2;  ///< Offset: 0x140 - Direct read/write access to entry 2 of SM1's RX FIFO, if...
        volatile uint32_t RXF1_PUTGET3;  ///< Offset: 0x144 - Direct read/write access to entry 3 of SM1's RX FIFO, if...
        volatile uint32_t RXF2_PUTGET0;  ///< Offset: 0x148 - Direct read/write access to entry 0 of SM2's RX FIFO, if...
        volatile uint32_t RXF2_PUTGET1;  ///< Offset: 0x14C - Direct read/write access to entry 1 of SM2's RX FIFO, if...
        volatile uint32_t RXF2_PUTGET2;  ///< Offset: 0x150 - Direct read/write access to entry 2 of SM2's RX FIFO, if...
        volatile uint32_t RXF2_PUTGET3;  ///< Offset: 0x154 - Direct read/write access to entry 3 of SM2's RX FIFO, if...
        volatile uint32_t RXF3_PUTGET0;  ///< Offset: 0x158 - Direct read/write access to entry 0 of SM3's RX FIFO, if...
        volatile uint32_t RXF3_PUTGET1;  ///< Offset: 0x15C - Direct read/write access to entry 1 of SM3's RX FIFO, if...
        volatile uint32_t RXF3_PUTGET2;  ///< Offset: 0x160 - Direct read/write access to entry 2 of SM3's RX FIFO, if...
        volatile uint32_t RXF3_PUTGET3;  ///< Offset: 0x164 - Direct read/write access to entry 3 of SM3's RX FIFO, if...
        volatile uint32_t GPIOBASE;  ///< Offset: 0x168 - Relocate GPIO 0 (from PIO's point of view) in the system...
        volatile uint32_t INTR;  ///< Offset: 0x16C - Raw Interrupts
        volatile uint32_t IRQ0_INTE;  ///< Offset: 0x170 - Interrupt Enable for irq0
        volatile uint32_t IRQ0_INTF;  ///< Offset: 0x174 - Interrupt Force for irq0
        volatile uint32_t IRQ0_INTS;  ///< Offset: 0x178 - Interrupt status after masking & forcing for irq0
        volatile uint32_t IRQ1_INTE;  ///< Offset: 0x17C - Interrupt Enable for irq1
        volatile uint32_t IRQ1_INTF;  ///< Offset: 0x180 - Interrupt Force for irq1
        volatile uint32_t IRQ1_INTS;  ///< Offset: 0x184 - Interrupt status after masking & forcing for irq1
    };

    /// Peripheral instances
    inline Registers* PIO0 = reinterpret_cast<Registers*>(PIO0_BASE);

}

// ============================================================================
// PIO1 Peripheral
// ============================================================================

namespace pio1 {
    /// Base addresses
    constexpr uint32_t PIO1_BASE = 0x50300000;

    /// PIO1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* PIO1 = reinterpret_cast<Registers*>(PIO1_BASE);

}

// ============================================================================
// PIO2 Peripheral
// ============================================================================

namespace pio2 {
    /// Base addresses
    constexpr uint32_t PIO2_BASE = 0x50400000;

    /// PIO2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* PIO2 = reinterpret_cast<Registers*>(PIO2_BASE);

}

// ============================================================================
// BUSCTRL Peripheral
// ============================================================================

namespace busctrl {
    /// Base addresses
    constexpr uint32_t BUSCTRL_BASE = 0x40068000;

    /// BUSCTRL Register structure
    struct Registers {
        volatile uint32_t BUS_PRIORITY;  ///< Offset: 0x00 - Set the priority of each master for bus arbitration.
        volatile uint32_t BUS_PRIORITY_ACK;  ///< Offset: 0x04 - Bus priority acknowledge
        volatile uint32_t PERFCTR_EN;  ///< Offset: 0x08 - Enable the performance counters. If 0, the performance...
        volatile uint32_t PERFCTR0;  ///< Offset: 0x0C - Bus fabric performance counter 0
        volatile uint32_t PERFSEL0;  ///< Offset: 0x10 - Bus fabric performance event select for PERFCTR0
        volatile uint32_t PERFCTR1;  ///< Offset: 0x14 - Bus fabric performance counter 1
        volatile uint32_t PERFSEL1;  ///< Offset: 0x18 - Bus fabric performance event select for PERFCTR1
        volatile uint32_t PERFCTR2;  ///< Offset: 0x1C - Bus fabric performance counter 2
        volatile uint32_t PERFSEL2;  ///< Offset: 0x20 - Bus fabric performance event select for PERFCTR2
        volatile uint32_t PERFCTR3;  ///< Offset: 0x24 - Bus fabric performance counter 3
        volatile uint32_t PERFSEL3;  ///< Offset: 0x28 - Bus fabric performance event select for PERFCTR3
    };

    /// Peripheral instances
    inline Registers* BUSCTRL = reinterpret_cast<Registers*>(BUSCTRL_BASE);

}

// ============================================================================
// SIO Peripheral
// ============================================================================

namespace sio {
    /// Base addresses
    constexpr uint32_t SIO_BASE = 0xD0000000;
    constexpr uint32_t SIO_NS_BASE = 0xD0020000;

    /// SIO Register structure
    struct Registers {
        volatile uint32_t CPUID;  ///< Offset: 0x00 - Processor core identifier
        volatile uint32_t GPIO_IN;  ///< Offset: 0x04 - Input value for GPIO0...31. In the Non-secure SIO,...
        volatile uint32_t GPIO_HI_IN;  ///< Offset: 0x08 - Input value on GPIO32...47, QSPI IOs and USB pins In the...
        volatile uint32_t GPIO_OUT;  ///< Offset: 0x10 - GPIO0...31 output value
        volatile uint32_t GPIO_HI_OUT;  ///< Offset: 0x14 - Output value for GPIO32...47, QSPI IOs and USB pins....
        volatile uint32_t GPIO_OUT_SET;  ///< Offset: 0x18 - GPIO0...31 output value set
        volatile uint32_t GPIO_HI_OUT_SET;  ///< Offset: 0x1C - Output value set for GPIO32..47, QSPI IOs and USB pins....
        volatile uint32_t GPIO_OUT_CLR;  ///< Offset: 0x20 - GPIO0...31 output value clear
        volatile uint32_t GPIO_HI_OUT_CLR;  ///< Offset: 0x24 - Output value clear for GPIO32..47, QSPI IOs and USB...
        volatile uint32_t GPIO_OUT_XOR;  ///< Offset: 0x28 - GPIO0...31 output value XOR
        volatile uint32_t GPIO_HI_OUT_XOR;  ///< Offset: 0x2C - Output value XOR for GPIO32..47, QSPI IOs and USB pins....
        volatile uint32_t GPIO_OE;  ///< Offset: 0x30 - GPIO0...31 output enable
        volatile uint32_t GPIO_HI_OE;  ///< Offset: 0x34 - Output enable value for GPIO32...47, QSPI IOs and USB...
        volatile uint32_t GPIO_OE_SET;  ///< Offset: 0x38 - GPIO0...31 output enable set
        volatile uint32_t GPIO_HI_OE_SET;  ///< Offset: 0x3C - Output enable set for GPIO32...47, QSPI IOs and USB...
        volatile uint32_t GPIO_OE_CLR;  ///< Offset: 0x40 - GPIO0...31 output enable clear
        volatile uint32_t GPIO_HI_OE_CLR;  ///< Offset: 0x44 - Output enable clear for GPIO32...47, QSPI IOs and USB...
        volatile uint32_t GPIO_OE_XOR;  ///< Offset: 0x48 - GPIO0...31 output enable XOR
        volatile uint32_t GPIO_HI_OE_XOR;  ///< Offset: 0x4C - Output enable XOR for GPIO32...47, QSPI IOs and USB...
        volatile uint32_t FIFO_ST;  ///< Offset: 0x50 - Status register for inter-core FIFOs (mailboxes). There...
        volatile uint32_t FIFO_WR;  ///< Offset: 0x54 - Write access to this core's TX FIFO
        volatile uint32_t FIFO_RD;  ///< Offset: 0x58 - Read access to this core's RX FIFO
        volatile uint32_t SPINLOCK_ST;  ///< Offset: 0x5C - Spinlock state A bitmap containing the state of all 32...
        volatile uint32_t INTERP0_ACCUM0;  ///< Offset: 0x80 - Read/write access to accumulator 0
        volatile uint32_t INTERP0_ACCUM1;  ///< Offset: 0x84 - Read/write access to accumulator 1
        volatile uint32_t INTERP0_BASE0;  ///< Offset: 0x88 - Read/write access to BASE0 register.
        volatile uint32_t INTERP0_BASE1;  ///< Offset: 0x8C - Read/write access to BASE1 register.
        volatile uint32_t INTERP0_BASE2;  ///< Offset: 0x90 - Read/write access to BASE2 register.
        volatile uint32_t INTERP0_POP_LANE0;  ///< Offset: 0x94 - Read LANE0 result, and simultaneously write lane results...
        volatile uint32_t INTERP0_POP_LANE1;  ///< Offset: 0x98 - Read LANE1 result, and simultaneously write lane results...
        volatile uint32_t INTERP0_POP_FULL;  ///< Offset: 0x9C - Read FULL result, and simultaneously write lane results...
        volatile uint32_t INTERP0_PEEK_LANE0;  ///< Offset: 0xA0 - Read LANE0 result, without altering any internal state (PEEK).
        volatile uint32_t INTERP0_PEEK_LANE1;  ///< Offset: 0xA4 - Read LANE1 result, without altering any internal state (PEEK).
        volatile uint32_t INTERP0_PEEK_FULL;  ///< Offset: 0xA8 - Read FULL result, without altering any internal state (PEEK).
        volatile uint32_t INTERP0_CTRL_LANE0;  ///< Offset: 0xAC - Control register for lane 0
        volatile uint32_t INTERP0_CTRL_LANE1;  ///< Offset: 0xB0 - Control register for lane 1
        volatile uint32_t INTERP0_ACCUM0_ADD;  ///< Offset: 0xB4 - Values written here are atomically added to ACCUM0...
        volatile uint32_t INTERP0_ACCUM1_ADD;  ///< Offset: 0xB8 - Values written here are atomically added to ACCUM1...
        volatile uint32_t INTERP0_BASE_1AND0;  ///< Offset: 0xBC - On write, the lower 16 bits go to BASE0, upper bits to...
        volatile uint32_t INTERP1_ACCUM0;  ///< Offset: 0xC0 - Read/write access to accumulator 0
        volatile uint32_t INTERP1_ACCUM1;  ///< Offset: 0xC4 - Read/write access to accumulator 1
        volatile uint32_t INTERP1_BASE0;  ///< Offset: 0xC8 - Read/write access to BASE0 register.
        volatile uint32_t INTERP1_BASE1;  ///< Offset: 0xCC - Read/write access to BASE1 register.
        volatile uint32_t INTERP1_BASE2;  ///< Offset: 0xD0 - Read/write access to BASE2 register.
        volatile uint32_t INTERP1_POP_LANE0;  ///< Offset: 0xD4 - Read LANE0 result, and simultaneously write lane results...
        volatile uint32_t INTERP1_POP_LANE1;  ///< Offset: 0xD8 - Read LANE1 result, and simultaneously write lane results...
        volatile uint32_t INTERP1_POP_FULL;  ///< Offset: 0xDC - Read FULL result, and simultaneously write lane results...
        volatile uint32_t INTERP1_PEEK_LANE0;  ///< Offset: 0xE0 - Read LANE0 result, without altering any internal state (PEEK).
        volatile uint32_t INTERP1_PEEK_LANE1;  ///< Offset: 0xE4 - Read LANE1 result, without altering any internal state (PEEK).
        volatile uint32_t INTERP1_PEEK_FULL;  ///< Offset: 0xE8 - Read FULL result, without altering any internal state (PEEK).
        volatile uint32_t INTERP1_CTRL_LANE0;  ///< Offset: 0xEC - Control register for lane 0
        volatile uint32_t INTERP1_CTRL_LANE1;  ///< Offset: 0xF0 - Control register for lane 1
        volatile uint32_t INTERP1_ACCUM0_ADD;  ///< Offset: 0xF4 - Values written here are atomically added to ACCUM0...
        volatile uint32_t INTERP1_ACCUM1_ADD;  ///< Offset: 0xF8 - Values written here are atomically added to ACCUM1...
        volatile uint32_t INTERP1_BASE_1AND0;  ///< Offset: 0xFC - On write, the lower 16 bits go to BASE0, upper bits to...
        volatile uint32_t SPINLOCK0;  ///< Offset: 0x100 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK1;  ///< Offset: 0x104 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK2;  ///< Offset: 0x108 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK3;  ///< Offset: 0x10C - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK4;  ///< Offset: 0x110 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK5;  ///< Offset: 0x114 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK6;  ///< Offset: 0x118 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK7;  ///< Offset: 0x11C - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK8;  ///< Offset: 0x120 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK9;  ///< Offset: 0x124 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK10;  ///< Offset: 0x128 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK11;  ///< Offset: 0x12C - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK12;  ///< Offset: 0x130 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK13;  ///< Offset: 0x134 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK14;  ///< Offset: 0x138 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK15;  ///< Offset: 0x13C - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK16;  ///< Offset: 0x140 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK17;  ///< Offset: 0x144 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK18;  ///< Offset: 0x148 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK19;  ///< Offset: 0x14C - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK20;  ///< Offset: 0x150 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK21;  ///< Offset: 0x154 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK22;  ///< Offset: 0x158 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK23;  ///< Offset: 0x15C - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK24;  ///< Offset: 0x160 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK25;  ///< Offset: 0x164 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK26;  ///< Offset: 0x168 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK27;  ///< Offset: 0x16C - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK28;  ///< Offset: 0x170 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK29;  ///< Offset: 0x174 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK30;  ///< Offset: 0x178 - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t SPINLOCK31;  ///< Offset: 0x17C - Reading from a spinlock address will: - Return 0 if lock...
        volatile uint32_t DOORBELL_OUT_SET;  ///< Offset: 0x180 - Trigger a doorbell interrupt on the opposite core. Write...
        volatile uint32_t DOORBELL_OUT_CLR;  ///< Offset: 0x184 - Clear doorbells which have been posted to the opposite...
        volatile uint32_t DOORBELL_IN_SET;  ///< Offset: 0x188 - Write 1s to trigger doorbell interrupts on this core....
        volatile uint32_t DOORBELL_IN_CLR;  ///< Offset: 0x18C - Check and acknowledge doorbells posted to this core....
        volatile uint32_t PERI_NONSEC;  ///< Offset: 0x190 - Detach certain core-local peripherals from Secure SIO,...
        volatile uint32_t RISCV_SOFTIRQ;  ///< Offset: 0x1A0 - Control the assertion of the standard software interrupt...
        volatile uint32_t MTIME_CTRL;  ///< Offset: 0x1A4 - Control register for the RISC-V 64-bit Machine-mode...
        volatile uint32_t MTIME;  ///< Offset: 0x1B0 - Read/write access to the high half of RISC-V...
        volatile uint32_t MTIMEH;  ///< Offset: 0x1B4 - Read/write access to the high half of RISC-V...
        volatile uint32_t MTIMECMP;  ///< Offset: 0x1B8 - Low half of RISC-V Machine-mode timer comparator. This...
        volatile uint32_t MTIMECMPH;  ///< Offset: 0x1BC - High half of RISC-V Machine-mode timer comparator. This...
        volatile uint32_t TMDS_CTRL;  ///< Offset: 0x1C0 - Control register for TMDS encoder.
        volatile uint32_t TMDS_WDATA;  ///< Offset: 0x1C4 - Write-only access to the TMDS colour data register.
        volatile uint32_t TMDS_PEEK_SINGLE;  ///< Offset: 0x1C8 - Get the encoding of one pixel's worth of colour data,...
        volatile uint32_t TMDS_POP_SINGLE;  ///< Offset: 0x1CC - Get the encoding of one pixel's worth of colour data,...
        volatile uint32_t TMDS_PEEK_DOUBLE_L0;  ///< Offset: 0x1D0 - Get lane 0 of the encoding of two pixels' worth of...
        volatile uint32_t TMDS_POP_DOUBLE_L0;  ///< Offset: 0x1D4 - Get lane 0 of the encoding of two pixels' worth of...
        volatile uint32_t TMDS_PEEK_DOUBLE_L1;  ///< Offset: 0x1D8 - Get lane 1 of the encoding of two pixels' worth of...
        volatile uint32_t TMDS_POP_DOUBLE_L1;  ///< Offset: 0x1DC - Get lane 1 of the encoding of two pixels' worth of...
        volatile uint32_t TMDS_PEEK_DOUBLE_L2;  ///< Offset: 0x1E0 - Get lane 2 of the encoding of two pixels' worth of...
        volatile uint32_t TMDS_POP_DOUBLE_L2;  ///< Offset: 0x1E4 - Get lane 2 of the encoding of two pixels' worth of...
    };

    /// Peripheral instances
    inline Registers* SIO = reinterpret_cast<Registers*>(SIO_BASE);
    inline Registers* SIO_NS = reinterpret_cast<Registers*>(SIO_NS_BASE);

}

// ============================================================================
// BOOTRAM Peripheral
// ============================================================================

namespace bootram {
    /// Base addresses
    constexpr uint32_t BOOTRAM_BASE = 0x400E0000;

    /// BOOTRAM Register structure
    struct Registers {
        volatile uint32_t WRITE_ONCE0;  ///< Offset: 0x800 - This registers always ORs writes into its current...
        volatile uint32_t WRITE_ONCE1;  ///< Offset: 0x804 - This registers always ORs writes into its current...
        volatile uint32_t BOOTLOCK_STAT;  ///< Offset: 0x808 - Bootlock status register. 1=unclaimed, 0=claimed. These...
        volatile uint32_t BOOTLOCK0;  ///< Offset: 0x80C - Read to claim and check. Write to unclaim. The value...
        volatile uint32_t BOOTLOCK1;  ///< Offset: 0x810 - Read to claim and check. Write to unclaim. The value...
        volatile uint32_t BOOTLOCK2;  ///< Offset: 0x814 - Read to claim and check. Write to unclaim. The value...
        volatile uint32_t BOOTLOCK3;  ///< Offset: 0x818 - Read to claim and check. Write to unclaim. The value...
        volatile uint32_t BOOTLOCK4;  ///< Offset: 0x81C - Read to claim and check. Write to unclaim. The value...
        volatile uint32_t BOOTLOCK5;  ///< Offset: 0x820 - Read to claim and check. Write to unclaim. The value...
        volatile uint32_t BOOTLOCK6;  ///< Offset: 0x824 - Read to claim and check. Write to unclaim. The value...
        volatile uint32_t BOOTLOCK7;  ///< Offset: 0x828 - Read to claim and check. Write to unclaim. The value...
    };

    /// Peripheral instances
    inline Registers* BOOTRAM = reinterpret_cast<Registers*>(BOOTRAM_BASE);

}

// ============================================================================
// CORESIGHT Peripheral
// ============================================================================

namespace coresight {
    /// Base addresses
    constexpr uint32_t CORESIGHT_TRACE_BASE = 0x50700000;

    /// CORESIGHT Register structure
    struct Registers {
        volatile uint32_t CTRL_STATUS;  ///< Offset: 0x00 - Control and status register
        volatile uint32_t TRACE_CAPTURE_FIFO;  ///< Offset: 0x04 - FIFO for trace data captured from the TPIU
    };

    /// Peripheral instances
    inline Registers* CORESIGHT_TRACE = reinterpret_cast<Registers*>(CORESIGHT_TRACE_BASE);

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t TRNG_BASE = 0x400F0000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t RNG_IMR;  ///< Offset: 0x100 - Interrupt masking.
        volatile uint32_t RNG_ISR;  ///< Offset: 0x104 - RNG status register. If corresponding RNG_IMR bit is...
        volatile uint32_t RNG_ICR;  ///< Offset: 0x108 - Interrupt/status bit clear Register.
        volatile uint32_t TRNG_CONFIG;  ///< Offset: 0x10C - Selecting the inverter-chain length.
        volatile uint32_t TRNG_VALID;  ///< Offset: 0x110 - 192 bit collection indication.
        volatile uint32_t EHR_DATA0;  ///< Offset: 0x114 - RNG collected bits.
        volatile uint32_t EHR_DATA1;  ///< Offset: 0x118 - RNG collected bits.
        volatile uint32_t EHR_DATA2;  ///< Offset: 0x11C - RNG collected bits.
        volatile uint32_t EHR_DATA3;  ///< Offset: 0x120 - RNG collected bits.
        volatile uint32_t EHR_DATA4;  ///< Offset: 0x124 - RNG collected bits.
        volatile uint32_t EHR_DATA5;  ///< Offset: 0x128 - RNG collected bits.
        volatile uint32_t RND_SOURCE_ENABLE;  ///< Offset: 0x12C - Enable signal for the random source.
        volatile uint32_t SAMPLE_CNT1;  ///< Offset: 0x130 - Counts clocks between sampling of random bit.
        volatile uint32_t AUTOCORR_STATISTIC;  ///< Offset: 0x134 - Statistic about Autocorrelation test activations.
        volatile uint32_t TRNG_DEBUG_CONTROL;  ///< Offset: 0x138 - Debug register.
        volatile uint32_t TRNG_SW_RESET;  ///< Offset: 0x140 - Generate internal SW reset within the RNG block.
        volatile uint32_t RNG_DEBUG_EN_INPUT;  ///< Offset: 0x1B4 - Enable the RNG debug mode
        volatile uint32_t TRNG_BUSY;  ///< Offset: 0x1B8 - RNG Busy indication.
        volatile uint32_t RST_BITS_COUNTER;  ///< Offset: 0x1BC - Reset the counter of collected bits in the RNG.
        volatile uint32_t RNG_VERSION;  ///< Offset: 0x1C0 - Displays the version settings of the TRNG.
        volatile uint32_t RNG_BIST_CNTR_0;  ///< Offset: 0x1E0 - Collected BIST results.
        volatile uint32_t RNG_BIST_CNTR_1;  ///< Offset: 0x1E4 - Collected BIST results.
        volatile uint32_t RNG_BIST_CNTR_2;  ///< Offset: 0x1E8 - Collected BIST results.
    };

    /// Peripheral instances
    inline Registers* TRNG = reinterpret_cast<Registers*>(TRNG_BASE);

}

// ============================================================================
// GLITCH Peripheral
// ============================================================================

namespace glitch {
    /// Base addresses
    constexpr uint32_t GLITCH_DETECTOR_BASE = 0x40158000;

    /// GLITCH Register structure
    struct Registers {
        volatile uint32_t ARM;  ///< Offset: 0x00 - Forcibly arm the glitch detectors, if they are not...
        volatile uint32_t DISARM;  ///< Offset: 0x04 - Forcibly disarm the glitch detectors, if they are armed...
        volatile uint32_t SENSITIVITY;  ///< Offset: 0x08 - Adjust the sensitivity of glitch detectors to values...
        volatile uint32_t LOCK;  ///< Offset: 0x0C - Write any nonzero value to disable writes to ARM,...
        volatile uint32_t TRIG_STATUS;  ///< Offset: 0x10 - Set when a detector output triggers. Write-1-clear. (May...
        volatile uint32_t TRIG_FORCE;  ///< Offset: 0x14 - Simulate the firing of one or more detectors. Writing...
    };

    /// Peripheral instances
    inline Registers* GLITCH_DETECTOR = reinterpret_cast<Registers*>(GLITCH_DETECTOR_BASE);

}

// ============================================================================
// OTP Peripheral
// ============================================================================

namespace otp {
    /// Base addresses
    constexpr uint32_t OTP_BASE = 0x40120000;
    constexpr uint32_t OTP_DATA_BASE = 0x40130000;
    constexpr uint32_t OTP_DATA_RAW_BASE = 0x40134000;

    /// OTP Register structure
    struct Registers {
        volatile uint32_t SW_LOCK0;  ///< Offset: 0x00 - Software lock register for page 0. Locks are initialised...
        volatile uint32_t SW_LOCK1;  ///< Offset: 0x04 - Software lock register for page 1. Locks are initialised...
        volatile uint32_t SW_LOCK2;  ///< Offset: 0x08 - Software lock register for page 2. Locks are initialised...
        volatile uint32_t SW_LOCK3;  ///< Offset: 0x0C - Software lock register for page 3. Locks are initialised...
        volatile uint32_t SW_LOCK4;  ///< Offset: 0x10 - Software lock register for page 4. Locks are initialised...
        volatile uint32_t SW_LOCK5;  ///< Offset: 0x14 - Software lock register for page 5. Locks are initialised...
        volatile uint32_t SW_LOCK6;  ///< Offset: 0x18 - Software lock register for page 6. Locks are initialised...
        volatile uint32_t SW_LOCK7;  ///< Offset: 0x1C - Software lock register for page 7. Locks are initialised...
        volatile uint32_t SW_LOCK8;  ///< Offset: 0x20 - Software lock register for page 8. Locks are initialised...
        volatile uint32_t SW_LOCK9;  ///< Offset: 0x24 - Software lock register for page 9. Locks are initialised...
        volatile uint32_t SW_LOCK10;  ///< Offset: 0x28 - Software lock register for page 10. Locks are...
        volatile uint32_t SW_LOCK11;  ///< Offset: 0x2C - Software lock register for page 11. Locks are...
        volatile uint32_t SW_LOCK12;  ///< Offset: 0x30 - Software lock register for page 12. Locks are...
        volatile uint32_t SW_LOCK13;  ///< Offset: 0x34 - Software lock register for page 13. Locks are...
        volatile uint32_t SW_LOCK14;  ///< Offset: 0x38 - Software lock register for page 14. Locks are...
        volatile uint32_t SW_LOCK15;  ///< Offset: 0x3C - Software lock register for page 15. Locks are...
        volatile uint32_t SW_LOCK16;  ///< Offset: 0x40 - Software lock register for page 16. Locks are...
        volatile uint32_t SW_LOCK17;  ///< Offset: 0x44 - Software lock register for page 17. Locks are...
        volatile uint32_t SW_LOCK18;  ///< Offset: 0x48 - Software lock register for page 18. Locks are...
        volatile uint32_t SW_LOCK19;  ///< Offset: 0x4C - Software lock register for page 19. Locks are...
        volatile uint32_t SW_LOCK20;  ///< Offset: 0x50 - Software lock register for page 20. Locks are...
        volatile uint32_t SW_LOCK21;  ///< Offset: 0x54 - Software lock register for page 21. Locks are...
        volatile uint32_t SW_LOCK22;  ///< Offset: 0x58 - Software lock register for page 22. Locks are...
        volatile uint32_t SW_LOCK23;  ///< Offset: 0x5C - Software lock register for page 23. Locks are...
        volatile uint32_t SW_LOCK24;  ///< Offset: 0x60 - Software lock register for page 24. Locks are...
        volatile uint32_t SW_LOCK25;  ///< Offset: 0x64 - Software lock register for page 25. Locks are...
        volatile uint32_t SW_LOCK26;  ///< Offset: 0x68 - Software lock register for page 26. Locks are...
        volatile uint32_t SW_LOCK27;  ///< Offset: 0x6C - Software lock register for page 27. Locks are...
        volatile uint32_t SW_LOCK28;  ///< Offset: 0x70 - Software lock register for page 28. Locks are...
        volatile uint32_t SW_LOCK29;  ///< Offset: 0x74 - Software lock register for page 29. Locks are...
        volatile uint32_t SW_LOCK30;  ///< Offset: 0x78 - Software lock register for page 30. Locks are...
        volatile uint32_t SW_LOCK31;  ///< Offset: 0x7C - Software lock register for page 31. Locks are...
        volatile uint32_t SW_LOCK32;  ///< Offset: 0x80 - Software lock register for page 32. Locks are...
        volatile uint32_t SW_LOCK33;  ///< Offset: 0x84 - Software lock register for page 33. Locks are...
        volatile uint32_t SW_LOCK34;  ///< Offset: 0x88 - Software lock register for page 34. Locks are...
        volatile uint32_t SW_LOCK35;  ///< Offset: 0x8C - Software lock register for page 35. Locks are...
        volatile uint32_t SW_LOCK36;  ///< Offset: 0x90 - Software lock register for page 36. Locks are...
        volatile uint32_t SW_LOCK37;  ///< Offset: 0x94 - Software lock register for page 37. Locks are...
        volatile uint32_t SW_LOCK38;  ///< Offset: 0x98 - Software lock register for page 38. Locks are...
        volatile uint32_t SW_LOCK39;  ///< Offset: 0x9C - Software lock register for page 39. Locks are...
        volatile uint32_t SW_LOCK40;  ///< Offset: 0xA0 - Software lock register for page 40. Locks are...
        volatile uint32_t SW_LOCK41;  ///< Offset: 0xA4 - Software lock register for page 41. Locks are...
        volatile uint32_t SW_LOCK42;  ///< Offset: 0xA8 - Software lock register for page 42. Locks are...
        volatile uint32_t SW_LOCK43;  ///< Offset: 0xAC - Software lock register for page 43. Locks are...
        volatile uint32_t SW_LOCK44;  ///< Offset: 0xB0 - Software lock register for page 44. Locks are...
        volatile uint32_t SW_LOCK45;  ///< Offset: 0xB4 - Software lock register for page 45. Locks are...
        volatile uint32_t SW_LOCK46;  ///< Offset: 0xB8 - Software lock register for page 46. Locks are...
        volatile uint32_t SW_LOCK47;  ///< Offset: 0xBC - Software lock register for page 47. Locks are...
        volatile uint32_t SW_LOCK48;  ///< Offset: 0xC0 - Software lock register for page 48. Locks are...
        volatile uint32_t SW_LOCK49;  ///< Offset: 0xC4 - Software lock register for page 49. Locks are...
        volatile uint32_t SW_LOCK50;  ///< Offset: 0xC8 - Software lock register for page 50. Locks are...
        volatile uint32_t SW_LOCK51;  ///< Offset: 0xCC - Software lock register for page 51. Locks are...
        volatile uint32_t SW_LOCK52;  ///< Offset: 0xD0 - Software lock register for page 52. Locks are...
        volatile uint32_t SW_LOCK53;  ///< Offset: 0xD4 - Software lock register for page 53. Locks are...
        volatile uint32_t SW_LOCK54;  ///< Offset: 0xD8 - Software lock register for page 54. Locks are...
        volatile uint32_t SW_LOCK55;  ///< Offset: 0xDC - Software lock register for page 55. Locks are...
        volatile uint32_t SW_LOCK56;  ///< Offset: 0xE0 - Software lock register for page 56. Locks are...
        volatile uint32_t SW_LOCK57;  ///< Offset: 0xE4 - Software lock register for page 57. Locks are...
        volatile uint32_t SW_LOCK58;  ///< Offset: 0xE8 - Software lock register for page 58. Locks are...
        volatile uint32_t SW_LOCK59;  ///< Offset: 0xEC - Software lock register for page 59. Locks are...
        volatile uint32_t SW_LOCK60;  ///< Offset: 0xF0 - Software lock register for page 60. Locks are...
        volatile uint32_t SW_LOCK61;  ///< Offset: 0xF4 - Software lock register for page 61. Locks are...
        volatile uint32_t SW_LOCK62;  ///< Offset: 0xF8 - Software lock register for page 62. Locks are...
        volatile uint32_t SW_LOCK63;  ///< Offset: 0xFC - Software lock register for page 63. Locks are...
        volatile uint32_t SBPI_INSTR;  ///< Offset: 0x100 - Dispatch instructions to the SBPI interface, used for...
        volatile uint32_t SBPI_WDATA_0;  ///< Offset: 0x104 - SBPI write payload bytes 3..0
        volatile uint32_t SBPI_WDATA_1;  ///< Offset: 0x108 - SBPI write payload bytes 7..4
        volatile uint32_t SBPI_WDATA_2;  ///< Offset: 0x10C - SBPI write payload bytes 11..8
        volatile uint32_t SBPI_WDATA_3;  ///< Offset: 0x110 - SBPI write payload bytes 15..12
        volatile uint32_t SBPI_RDATA_0;  ///< Offset: 0x114 - Read payload bytes 3..0. Once read, the data in the...
        volatile uint32_t SBPI_RDATA_1;  ///< Offset: 0x118 - Read payload bytes 7..4. Once read, the data in the...
        volatile uint32_t SBPI_RDATA_2;  ///< Offset: 0x11C - Read payload bytes 11..8. Once read, the data in the...
        volatile uint32_t SBPI_RDATA_3;  ///< Offset: 0x120 - Read payload bytes 15..12. Once read, the data in the...
        volatile uint32_t SBPI_STATUS;  ///< Offset: 0x124 - SBPI MISO (master in - slave out): response from SBPI
        volatile uint32_t USR;  ///< Offset: 0x128 - Controls for APB data read interface (USER interface)
        volatile uint32_t DBG;  ///< Offset: 0x12C - Debug for OTP power-on state machine
        volatile uint32_t BIST;  ///< Offset: 0x134 - During BIST, count address locations that have at least...
        volatile uint32_t CRT_KEY_W0;  ///< Offset: 0x138 - Word 0 (bits 31..0) of the key. Write only, read returns 0x0
        volatile uint32_t CRT_KEY_W1;  ///< Offset: 0x13C - Word 1 (bits 63..32) of the key. Write only, read returns 0x0
        volatile uint32_t CRT_KEY_W2;  ///< Offset: 0x140 - Word 2 (bits 95..64) of the key. Write only, read returns 0x0
        volatile uint32_t CRT_KEY_W3;  ///< Offset: 0x144 - Word 3 (bits 127..96) of the key. Write only, read returns 0x0
        volatile uint32_t CRITICAL;  ///< Offset: 0x148 - Quickly check values of critical flags read during boot up
        volatile uint32_t KEY_VALID;  ///< Offset: 0x14C - Which keys were valid (enrolled) at boot time
        volatile uint32_t DEBUGEN;  ///< Offset: 0x150 - Enable a debug feature that has been disabled. Debug...
        volatile uint32_t DEBUGEN_LOCK;  ///< Offset: 0x154 - Write 1s to lock corresponding bits in DEBUGEN. This...
        volatile uint32_t ARCHSEL;  ///< Offset: 0x158 - Architecture select (Arm/RISC-V). The default and...
        volatile uint32_t ARCHSEL_STATUS;  ///< Offset: 0x15C - Get the current architecture select state of each core....
        volatile uint32_t BOOTDIS;  ///< Offset: 0x160 - Tell the bootrom to ignore scratch register boot vectors...
        volatile uint32_t INTR;  ///< Offset: 0x164 - Raw Interrupts
        volatile uint32_t INTE;  ///< Offset: 0x168 - Interrupt Enable
        volatile uint32_t INTF;  ///< Offset: 0x16C - Interrupt Force
        volatile uint32_t INTS;  ///< Offset: 0x170 - Interrupt status after masking & forcing
    };

    /// Peripheral instances
    inline Registers* OTP = reinterpret_cast<Registers*>(OTP_BASE);
    inline Registers* OTP_DATA = reinterpret_cast<Registers*>(OTP_DATA_BASE);
    inline Registers* OTP_DATA_RAW = reinterpret_cast<Registers*>(OTP_DATA_RAW_BASE);

}

// ============================================================================
// TBMAN Peripheral
// ============================================================================

namespace tbman {
    /// Base addresses
    constexpr uint32_t TBMAN_BASE = 0x40160000;

    /// TBMAN Register structure
    struct Registers {
        volatile uint32_t PLATFORM;  ///< Offset: 0x00 - Indicates the type of platform in use
    };

    /// Peripheral instances
    inline Registers* TBMAN = reinterpret_cast<Registers*>(TBMAN_BASE);

}


} // namespace alloy::generated::rp2350

#endif // ALLOY_GENERATED_RP2350_PERIPHERALS_HPP