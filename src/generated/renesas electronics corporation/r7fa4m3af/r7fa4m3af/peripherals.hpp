/// Auto-generated code for R7FA4M3AF
/// Generated by Alloy Code Generator
/// Source: renesas_r7fa4m3af.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:22:07
#ifndef ALLOY_GENERATED_R7FA4M3AF_PERIPHERALS_HPP
#define ALLOY_GENERATED_R7FA4M3AF_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::r7fa4m3af {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// RMPU Peripheral
// ============================================================================

namespace rmpu {
    /// Base addresses
    constexpr uint32_t RMPU_BASE = 0x40000000;

    /// RMPU Register structure
    struct Registers {
        volatile uint32_t MMPUOAD;  ///< Offset: 0x00 - MMPU Operation After Detection Register
        volatile uint32_t MMPUOADPT;  ///< Offset: 0x04 - MMPU Operation After Detection Protect Register
        volatile uint32_t MMPUENDMAC;  ///< Offset: 0x100 - MMPU Enable Register for DMAC
        volatile uint32_t MMPUENPTDMAC;  ///< Offset: 0x104 - MMPU Enable Protect Register for DMAC
        volatile uint32_t MMPURPTDMAC;  ///< Offset: 0x108 - MMPU Regions Protect Register for DMAC
        volatile uint32_t MMPURPTDMAC_SEC;  ///< Offset: 0x10C - MMPU Regions Protect register for DMAC Secure
        volatile uint32_t MMPUACDMAC%s;  ///< Offset: 0x200 - MMPU Access Control Register for DMAC
        volatile uint32_t MMPUSDMAC%s;  ///< Offset: 0x204 - MMPU Start Address Register for DMAC
        volatile uint32_t MMPUEDMAC%s;  ///< Offset: 0x208 - MMPU End Address Register for DMAC
    };

    /// Peripheral instances
    inline Registers* RMPU = reinterpret_cast<Registers*>(RMPU_BASE);

    // Bit definitions
    /// MMPUOAD Register bits
    namespace mmpuoad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after detection
        constexpr uint32_t KEY = (8 << 8);  ///< This bit enables or disables writes to the OAD bit.
    }

    /// MMPUOADPT Register bits
    namespace mmpuoadpt_bits {
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register
        constexpr uint32_t KEY = (8 << 8);  ///< Key code
    }

    /// MMPUENDMAC Register bits
    namespace mmpuendmac_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Bus Master MPU of DMAC enable
        constexpr uint32_t KEY = (8 << 8);  ///< These bits enable or disable writes to the ENABLE bit.
    }

    /// MMPUENPTDMAC Register bits
    namespace mmpuenptdmac_bits {
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register
        constexpr uint32_t KEY = (8 << 8);  ///< These bits enable or disable writes to the PROTECT bit.
    }

    /// MMPURPTDMAC Register bits
    namespace mmpurptdmac_bits {
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register
        constexpr uint32_t KEY = (8 << 8);  ///< These bits enable or disable writes to the PROTECT bit.
    }

    /// MMPURPTDMAC_SEC Register bits
    namespace mmpurptdmac_sec_bits {
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register
        constexpr uint32_t KEY = (8 << 8);  ///< These bits enable or disable writes to the PROTECT bit.
    }

    /// MMPUACDMAC%s Register bits
    namespace mmpuacdmac%s_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable
        constexpr uint32_t RP = (1U << 1);  ///< Read protection
        constexpr uint32_t WP = (1U << 2);  ///< Write protection
    }

    /// MMPUSDMAC%s Register bits
    namespace mmpusdmac%s_bits {
        constexpr uint32_t MMPUS = (27 << 5);  ///< Region start address register
    }

    /// MMPUEDMAC%s Register bits
    namespace mmpuedmac%s_bits {
        constexpr uint32_t MMPUE = (27 << 5);  ///< Region end address register
    }

}

// ============================================================================
// TZF Peripheral
// ============================================================================

namespace tzf {
    /// Base addresses
    constexpr uint32_t TZF_BASE = 0x40000E00;

    /// TZF Register structure
    struct Registers {
        volatile uint32_t TZFOAD;  ///< Offset: 0x00 - TrustZone Filter Operation After Detection Register
        volatile uint32_t TZFPT;  ///< Offset: 0x04 - TrustZone Filter Protect Register
    };

    /// Peripheral instances
    inline Registers* TZF = reinterpret_cast<Registers*>(TZF_BASE);

    // Bit definitions
    /// TZFOAD Register bits
    namespace tzfoad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after detection
        constexpr uint32_t KEY = (8 << 8);  ///< KeyCode
    }

    /// TZFPT Register bits
    namespace tzfpt_bits {
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register
        constexpr uint32_t KEY = (8 << 8);  ///< KeyCode
    }

}

// ============================================================================
// SRAM Peripheral
// ============================================================================

namespace sram {
    /// Base addresses
    constexpr uint32_t SRAM_BASE = 0x40002000;

    /// SRAM Register structure
    struct Registers {
        volatile uint32_t PARIOAD;  ///< Offset: 0x00 - SRAM Parity Error Operation After Detection Register
        volatile uint32_t SRAMPRCR;  ///< Offset: 0x04 - SRAM Protection Register
        volatile uint32_t SRAMWTSC;  ///< Offset: 0x08 - SRAM Wait State Control Register
        volatile uint32_t SRAMPRCR2;  ///< Offset: 0x0C - SRAM Protection Register 2
        volatile uint32_t ECCMODE;  ///< Offset: 0xC0 - ECC Operating Mode Control Register
        volatile uint32_t ECC2STS;  ///< Offset: 0xC1 - ECC 2-Bit Error Status Register
        volatile uint32_t ECC1STSEN;  ///< Offset: 0xC2 - ECC 1-Bit Error Information Update Enable Register
        volatile uint32_t ECC1STS;  ///< Offset: 0xC3 - ECC 1-Bit Error Status Register
        volatile uint32_t ECCPRCR;  ///< Offset: 0xC4 - ECC Protection Register
        volatile uint32_t ECCPRCR2;  ///< Offset: 0xD0 - ECC Protection Register 2
        volatile uint32_t ECCETST;  ///< Offset: 0xD4 - ECC Test Control Register
        volatile uint32_t ECCOAD;  ///< Offset: 0xD8 - SRAM ECC Error Operation After Detection Register
    };

    /// Peripheral instances
    inline Registers* SRAM = reinterpret_cast<Registers*>(SRAM_BASE);

    // Bit definitions
    /// PARIOAD Register bits
    namespace parioad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation After Detection
    }

    /// SRAMPRCR Register bits
    namespace sramprcr_bits {
        constexpr uint32_t SRAMPRCR = (1U << 0);  ///< Register Write Control
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
    }

    /// SRAMWTSC Register bits
    namespace sramwtsc_bits {
        constexpr uint32_t SRAM0WTEN = (1U << 0);  ///< SRAM0 wait enable
    }

    /// SRAMPRCR2 Register bits
    namespace sramprcr2_bits {
        constexpr uint32_t SRAMPRCR2 = (1U << 0);  ///< Register Write Control
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
    }

    /// ECCMODE Register bits
    namespace eccmode_bits {
        constexpr uint32_t ECCMOD = (2 << 0);  ///< ECC Operating Mode Select
    }

    /// ECC2STS Register bits
    namespace ecc2sts_bits {
        constexpr uint32_t ECC2ERR = (1U << 0);  ///< ECC 2-Bit Error Status
    }

    /// ECC1STSEN Register bits
    namespace ecc1stsen_bits {
        constexpr uint32_t E1STSEN = (1U << 0);  ///< ECC 1-Bit Error Information Update Enable
    }

    /// ECC1STS Register bits
    namespace ecc1sts_bits {
        constexpr uint32_t ECC1ERR = (1U << 0);  ///< ECC 1-Bit Error Status
    }

    /// ECCPRCR Register bits
    namespace eccprcr_bits {
        constexpr uint32_t ECCPRCR = (1U << 0);  ///< Register Write Control
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
    }

    /// ECCPRCR2 Register bits
    namespace eccprcr2_bits {
        constexpr uint32_t ECCPRCR2 = (1U << 0);  ///< Register Write Control
        constexpr uint32_t KW2 = (7 << 1);  ///< Write Key Code
    }

    /// ECCETST Register bits
    namespace eccetst_bits {
        constexpr uint32_t TSTBYP = (1U << 0);  ///< ECC Bypass Select
    }

    /// ECCOAD Register bits
    namespace eccoad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation After Detection
    }

}

// ============================================================================
// BUS Peripheral
// ============================================================================

namespace bus {
    /// Base addresses
    constexpr uint32_t BUS_BASE = 0x40003000;

    /// BUS Register structure
    struct Registers {
        volatile uint32_t BUSSCNTFHBIU;  ///< Offset: 0x1100 - Slave Bus Control Register
        volatile uint32_t BUSSCNTFLBIU;  ///< Offset: 0x1104 - Slave Bus Control Register
        volatile uint32_t BUSSCNTS0BIU;  ///< Offset: 0x1110 - Slave Bus Control Register
        volatile uint32_t BUSSCNTPSBIU;  ///< Offset: 0x1120 - Slave Bus Control Register
        volatile uint32_t BUSSCNTPLBIU;  ///< Offset: 0x1130 - Slave Bus Control Register
        volatile uint32_t BUSSCNTPHBIU;  ///< Offset: 0x1134 - Slave Bus Control Register
        volatile uint32_t BUSSCNTEQBIU;  ///< Offset: 0x1140 - Slave Bus Control Register
        volatile uint32_t BUS%sERRADD;  ///< Offset: 0x1800 - BUS Error Address Register
        volatile uint32_t BUS%sERRRW;  ///< Offset: 0x1804 - BUS Error Read Write Register
        volatile uint32_t BTZF%sERRADD;  ///< Offset: 0x1900 - BUS TZF Error Address Register
        volatile uint32_t BTZF%sERRRW;  ///< Offset: 0x1904 - BUS TZF Error Read Write Register
        volatile uint32_t BUS%sERRSTAT;  ///< Offset: 0x1A00 - BUS Error Status Register %s
        volatile uint32_t BUS%sERRCLR;  ///< Offset: 0x1A08 - BUS Error Clear Register %s
        volatile uint32_t DMACDTCERRSTAT;  ///< Offset: 0x1A24 - DMAC/DTC Error Status Register
        volatile uint32_t DMACDTCERRCLR;  ///< Offset: 0x1A2C - DMAC/DTC Error Clear Register
    };

    /// Peripheral instances
    inline Registers* BUS = reinterpret_cast<Registers*>(BUS_BASE);

    // Bit definitions
    /// BUSSCNTFHBIU Register bits
    namespace busscntfhbiu_bits {
        constexpr uint32_t ARBS = (2 << 0);  ///< Arbitration Select for two masters
    }

    /// BUSSCNTFLBIU Register bits
    namespace busscntflbiu_bits {
        constexpr uint32_t ARBS = (2 << 0);  ///< Arbitration Select for two masters
    }

    /// BUSSCNTS0BIU Register bits
    namespace busscnts0biu_bits {
        constexpr uint32_t ARBS = (2 << 0);  ///< Arbitration Select for two masters
    }

    /// BUSSCNTPSBIU Register bits
    namespace busscntpsbiu_bits {
        constexpr uint32_t ARBS = (1U << 0);  ///< Arbitration Select for two masters
    }

    /// BUSSCNTPLBIU Register bits
    namespace busscntplbiu_bits {
        constexpr uint32_t ARBS = (1U << 0);  ///< Arbitration Select for two masters
    }

    /// BUSSCNTPHBIU Register bits
    namespace busscntphbiu_bits {
        constexpr uint32_t ARBS = (1U << 0);  ///< Arbitration Select for two masters
    }

    /// BUSSCNTEQBIU Register bits
    namespace busscnteqbiu_bits {
        constexpr uint32_t ARBS = (2 << 0);  ///< Arbitration Select for two masters
    }

    /// BUS%sERRADD Register bits
    namespace bus%serradd_bits {
        constexpr uint32_t BERAD = (32 << 0);  ///< Bus Error Address
    }

    /// BUS%sERRRW Register bits
    namespace bus%serrrw_bits {
        constexpr uint32_t RWSTAT = (1U << 0);  ///< Error Access Read/Write Status
    }

    /// BTZF%sERRADD Register bits
    namespace btzf%serradd_bits {
        constexpr uint32_t BTZFERAD = (32 << 0);  ///< Bus TrustZone Filter Error Address
    }

    /// BTZF%sERRRW Register bits
    namespace btzf%serrrw_bits {
        constexpr uint32_t TRWSTAT = (1U << 0);  ///< TrustZone filter error access Read/Write Status
    }

    /// BUS%sERRSTAT Register bits
    namespace bus%serrstat_bits {
        constexpr uint32_t SLERRSTAT = (1U << 0);  ///< Slave bus Error Status
        constexpr uint32_t STERRSTAT = (1U << 1);  ///< Slave TrustZone filter Error Status
        constexpr uint32_t MMERRSTAT = (1U << 3);  ///< Master MPU Error Status
        constexpr uint32_t ILERRSTAT = (1U << 4);  ///< Illegal address access Error Status
    }

    /// BUS%sERRCLR Register bits
    namespace bus%serrclr_bits {
        constexpr uint32_t SLERRCLR = (1U << 0);  ///< Slave bus Error Clear
        constexpr uint32_t STERRCLR = (1U << 1);  ///< Slave TrustZone filter Error Clear
        constexpr uint32_t MMERRCLR = (1U << 3);  ///< Master MPU Error Clear
        constexpr uint32_t ILERRCLR = (1U << 4);  ///< Illegal Address Access Error Clear
    }

    /// DMACDTCERRSTAT Register bits
    namespace dmacdtcerrstat_bits {
        constexpr uint32_t MTERRSTAT = (1U << 0);  ///< Master TrustZone Filter Error Status
    }

    /// DMACDTCERRCLR Register bits
    namespace dmacdtcerrclr_bits {
        constexpr uint32_t MTERRCLR = (1U << 0);  ///< Master TrustZone filter Error Clear
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMAC0_BASE = 0x40005000;
    constexpr uint32_t DMAC1_BASE = 0x40005040;
    constexpr uint32_t DMAC2_BASE = 0x40005080;
    constexpr uint32_t DMAC3_BASE = 0x400050C0;
    constexpr uint32_t DMAC4_BASE = 0x40005100;
    constexpr uint32_t DMAC5_BASE = 0x40005140;
    constexpr uint32_t DMAC6_BASE = 0x40005180;
    constexpr uint32_t DMAC7_BASE = 0x400051C0;
    constexpr uint32_t DMA_BASE = 0x40005200;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMSAR;  ///< Offset: 0x00 - DMA Source Address Register
        volatile uint32_t DMDAR;  ///< Offset: 0x04 - DMA Destination Address Register
        volatile uint32_t DMCRA;  ///< Offset: 0x08 - DMA Transfer Count Register
        volatile uint32_t DMCRB;  ///< Offset: 0x0C - DMA Block Transfer Count Register
        volatile uint32_t DMTMD;  ///< Offset: 0x10 - DMA Transfer Mode Register
        volatile uint32_t DMINT;  ///< Offset: 0x13 - DMA Interrupt Setting Register
        volatile uint32_t DMAMD;  ///< Offset: 0x14 - DMA Address Mode Register
        volatile uint32_t DMOFR;  ///< Offset: 0x18 - DMA Offset Register
        volatile uint32_t DMCNT;  ///< Offset: 0x1C - DMA Transfer Enable Register
        volatile uint32_t DMREQ;  ///< Offset: 0x1D - DMA Software Start Register
        volatile uint32_t DMSTS;  ///< Offset: 0x1E - DMA Status Register
        volatile uint32_t DMSRR;  ///< Offset: 0x20 - DMA Source Reload Address Register
        volatile uint32_t DMDRR;  ///< Offset: 0x24 - DMA Destination Reload Address Register
        volatile uint32_t DMSBS;  ///< Offset: 0x28 - DMA Source Buffer Size Register
        volatile uint32_t DMDBS;  ///< Offset: 0x2C - DMA Destination Buffer Size Register
    };

    /// Peripheral instances
    inline Registers* DMAC0 = reinterpret_cast<Registers*>(DMAC0_BASE);
    inline Registers* DMAC1 = reinterpret_cast<Registers*>(DMAC1_BASE);
    inline Registers* DMAC2 = reinterpret_cast<Registers*>(DMAC2_BASE);
    inline Registers* DMAC3 = reinterpret_cast<Registers*>(DMAC3_BASE);
    inline Registers* DMAC4 = reinterpret_cast<Registers*>(DMAC4_BASE);
    inline Registers* DMAC5 = reinterpret_cast<Registers*>(DMAC5_BASE);
    inline Registers* DMAC6 = reinterpret_cast<Registers*>(DMAC6_BASE);
    inline Registers* DMAC7 = reinterpret_cast<Registers*>(DMAC7_BASE);
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

    // Bit definitions
    /// DMCRA Register bits
    namespace dmcra_bits {
        constexpr uint32_t DMCRAL = (16 << 0);  ///< Lower bits of transfer count
        constexpr uint32_t DMCRAH = (10 << 16);  ///< Upper bits of transfer count
    }

    /// DMCRB Register bits
    namespace dmcrb_bits {
        constexpr uint32_t DMCRBL = (16 << 0);  ///< Functions as a number of block, repeat or repeat-block transfer counter.
        constexpr uint32_t DMCRBH = (16 << 16);  ///< Specifies the number of block, repeat or repeat-block transfer operations.
    }

    /// DMTMD Register bits
    namespace dmtmd_bits {
        constexpr uint32_t DCTG = (2 << 0);  ///< Transfer Request Source Select
        constexpr uint32_t SZ = (2 << 8);  ///< Transfer Data Size Select
        constexpr uint32_t TKP = (1U << 10);  ///< Transfer Keeping
        constexpr uint32_t DTS = (2 << 12);  ///< Repeat Area Select
        constexpr uint32_t MD = (2 << 14);  ///< Transfer Mode Select
    }

    /// DMINT Register bits
    namespace dmint_bits {
        constexpr uint32_t DARIE = (1U << 0);  ///< Destination Address Extended Repeat Area Overflow Interrupt Enable
        constexpr uint32_t SARIE = (1U << 1);  ///< Source Address Extended Repeat Area Overflow Interrupt Enable
        constexpr uint32_t RPTIE = (1U << 2);  ///< Repeat Size End Interrupt Enable
        constexpr uint32_t ESIE = (1U << 3);  ///< Transfer Escape End Interrupt Enable
        constexpr uint32_t DTIE = (1U << 4);  ///< Transfer End Interrupt Enable
    }

    /// DMAMD Register bits
    namespace dmamd_bits {
        constexpr uint32_t DARA = (5 << 0);  ///< Destination Address Extended Repeat Area
        constexpr uint32_t DADR = (1U << 5);  ///< Destination Address Update Select After Reload
        constexpr uint32_t DM = (2 << 6);  ///< Destination Address Update Mode
        constexpr uint32_t SARA = (5 << 8);  ///< Source Address Extended Repeat Area
        constexpr uint32_t SADR = (1U << 13);  ///< Source Address Update Select After Reload
        constexpr uint32_t SM = (2 << 14);  ///< Source Address Update Mode
    }

    /// DMCNT Register bits
    namespace dmcnt_bits {
        constexpr uint32_t DTE = (1U << 0);  ///< DMA Transfer Enable
    }

    /// DMREQ Register bits
    namespace dmreq_bits {
        constexpr uint32_t SWREQ = (1U << 0);  ///< DMA Software Start
        constexpr uint32_t CLRS = (1U << 4);  ///< DMA Software Start Bit Auto Clear Select
    }

    /// DMSTS Register bits
    namespace dmsts_bits {
        constexpr uint32_t ESIF = (1U << 0);  ///< Transfer Escape End Interrupt Flag
        constexpr uint32_t DTIF = (1U << 4);  ///< Transfer End Interrupt Flag
        constexpr uint32_t ACT = (1U << 7);  ///< DMAC Active Flag
    }

    /// DMSBS Register bits
    namespace dmsbs_bits {
        constexpr uint32_t DMSBSL = (16 << 0);  ///< Functions as data transfer counter in repeat-block transfer mode
        constexpr uint32_t DMSBSH = (16 << 16);  ///< Specifies the repeat-area size in repeat-block transfer mode
    }

    /// DMDBS Register bits
    namespace dmdbs_bits {
        constexpr uint32_t DMDBSL = (16 << 0);  ///< Functions as data transfer counter in repeat-block transfer mode.
        constexpr uint32_t DMDBSH = (16 << 16);  ///< Specifies the repeat-area size in repeat-block transfer mode.
    }

}

// ============================================================================
// DTC Peripheral
// ============================================================================

namespace dtc {
    /// Base addresses
    constexpr uint32_t DTC_BASE = 0x40005400;

    /// DTC Register structure
    struct Registers {
        volatile uint32_t DTCCR;  ///< Offset: 0x00 - DTC Control Register
        volatile uint32_t DTCVBR;  ///< Offset: 0x04 - DTC Vector Base Register
        volatile uint32_t DTCST;  ///< Offset: 0x0C - DTC Module Start Register
        volatile uint32_t DTCSTS;  ///< Offset: 0x0E - DTC Status Register
        volatile uint32_t DTCCR_SEC;  ///< Offset: 0x10 - DTC Control Register for secure Region
        volatile uint32_t DTCVBR_SEC;  ///< Offset: 0x14 - DTC Vector Base Register for secure Region
        volatile uint32_t DTEVR;  ///< Offset: 0x20 - DTC Error Vector Register
    };

    /// Peripheral instances
    inline Registers* DTC = reinterpret_cast<Registers*>(DTC_BASE);

    // Bit definitions
    /// DTCCR Register bits
    namespace dtccr_bits {
        constexpr uint32_t RRS = (1U << 4);  ///< DTC Transfer Information Read Skip Enable
    }

    /// DTCST Register bits
    namespace dtcst_bits {
        constexpr uint32_t DTCST = (1U << 0);  ///< DTC Module Start
    }

    /// DTCSTS Register bits
    namespace dtcsts_bits {
        constexpr uint32_t VECN = (8 << 0);  ///< DTC-Activating Vector Number Monitoring
        constexpr uint32_t ACT = (1U << 15);  ///< DTC Active Flag
    }

    /// DTCCR_SEC Register bits
    namespace dtccr_sec_bits {
        constexpr uint32_t RRS = (1U << 4);  ///< DTC Transfer Information Read Skip Enable for Secure
    }

    /// DTEVR Register bits
    namespace dtevr_bits {
        constexpr uint32_t DTEV = (8 << 0);  ///< DTC Error Vector Number
        constexpr uint32_t DTEVSAM = (1U << 8);  ///< DTC Error Vector Number SA Monitor
        constexpr uint32_t DTESTA = (1U << 16);  ///< DTC Error Status Flag
    }

}

// ============================================================================
// ICU Peripheral
// ============================================================================

namespace icu {
    /// Base addresses
    constexpr uint32_t ICU_BASE = 0x40006000;

    /// ICU Register structure
    struct Registers {
        volatile uint32_t IRQCR%s;  ///< Offset: 0x00 - IRQ Control Register %s
        volatile uint32_t NMICR;  ///< Offset: 0x100 - NMI Pin Interrupt Control Register
        volatile uint32_t NMIER;  ///< Offset: 0x120 - Non-Maskable Interrupt Enable Register
        volatile uint32_t NMICLR;  ///< Offset: 0x130 - Non-Maskable Interrupt Status Clear Register
        volatile uint32_t NMISR;  ///< Offset: 0x140 - Non-Maskable Interrupt Status Register
        volatile uint32_t WUPEN0;  ///< Offset: 0x1A0 - Wake Up Interrupt Enable Register 0
        volatile uint32_t WUPEN1;  ///< Offset: 0x1A4 - Wake Up interrupt enable register 1
        volatile uint32_t SELSR0;  ///< Offset: 0x200 - SYS Event Link Setting Register
        volatile uint32_t DELSR%s;  ///< Offset: 0x280 - DMAC Event Link Setting Register %s
        volatile uint32_t IELSR%s;  ///< Offset: 0x300 - ICU Event Link Setting Register %s
    };

    /// Peripheral instances
    inline Registers* ICU = reinterpret_cast<Registers*>(ICU_BASE);

    // Bit definitions
    /// IRQCR%s Register bits
    namespace irqcr%s_bits {
        constexpr uint32_t IRQMD = (2 << 0);  ///< IRQi Detection Sense Select
        constexpr uint32_t FCLKSEL = (2 << 4);  ///< IRQi Digital Filter Sampling Clock Select
        constexpr uint32_t FLTEN = (1U << 7);  ///< IRQi Digital Filter Enable
    }

    /// NMICR Register bits
    namespace nmicr_bits {
        constexpr uint32_t NMIMD = (1U << 0);  ///< NMI Detection Set
        constexpr uint32_t NFCLKSEL = (2 << 4);  ///< NMI Digital Filter Sampling Clock Select
        constexpr uint32_t NFLTEN = (1U << 7);  ///< NMI Digital Filter Enable
    }

    /// NMIER Register bits
    namespace nmier_bits {
        constexpr uint32_t IWDTEN = (1U << 0);  ///< IWDT Underflow/Refresh Error Interrupt Enable
        constexpr uint32_t WDTEN = (1U << 1);  ///< WDT Underflow/Refresh Error Interrupt Enable
        constexpr uint32_t LVD1EN = (1U << 2);  ///< Voltage monitor 1 Interrupt Enable
        constexpr uint32_t LVD2EN = (1U << 3);  ///< Voltage monitor 2 Interrupt Enable
        constexpr uint32_t OSTEN = (1U << 6);  ///< Main Clock Oscillation Stop Detection Interrupt Enable
        constexpr uint32_t NMIEN = (1U << 7);  ///< NMI Pin Interrupt Enable
        constexpr uint32_t RPEEN = (1U << 8);  ///< SRAM Parity Error Interrupt Enable
        constexpr uint32_t RECCEN = (1U << 9);  ///< SRAM ECC Error Interrupt Enable
        constexpr uint32_t BUSMEN = (1U << 11);  ///< Bus Master MPU Error Interrupt Enable
        constexpr uint32_t TZFEN = (1U << 13);  ///< Disabled
        constexpr uint32_t CPEEN = (1U << 15);  ///< Disabled
    }

    /// NMICLR Register bits
    namespace nmiclr_bits {
        constexpr uint32_t IWDTCLR = (1U << 0);  ///< IWDT Underflow/Refresh Error Interrupt Status Flag Clear
        constexpr uint32_t WDTCLR = (1U << 1);  ///< WDT Underflow/Refresh Error Interrupt Status Flag Clear
        constexpr uint32_t LVD1CLR = (1U << 2);  ///< Voltage Monitor 1 Interrupt Status Flag Clear
        constexpr uint32_t LVD2CLR = (1U << 3);  ///< Voltage Monitor 2 Interrupt Status Flag Clear
        constexpr uint32_t OSTCLR = (1U << 6);  ///< Oscillation Stop Detection Interrupt Status Flag Clear
        constexpr uint32_t NMICLR = (1U << 7);  ///< NMI Pin Interrupt Status Flag Clear
        constexpr uint32_t RPECLR = (1U << 8);  ///< SRAM Parity Error Interrupt Status Flag Clear
        constexpr uint32_t RECCCLR = (1U << 9);  ///< SRAM ECC Error Interrupt Status Flag Clear
        constexpr uint32_t BUSMCLR = (1U << 11);  ///< Bus Master MPU Error Interrupt Status Flag Clear
        constexpr uint32_t TZFCLR = (1U << 13);  ///< No effect
        constexpr uint32_t CPECLR = (1U << 15);  ///< No effect
    }

    /// NMISR Register bits
    namespace nmisr_bits {
        constexpr uint32_t IWDTST = (1U << 0);  ///< IWDT Underflow/Refresh Error Interrupt Status Flag
        constexpr uint32_t WDTST = (1U << 1);  ///< WDT Underflow/Refresh Error Interrupt Status Flag
        constexpr uint32_t LVD1ST = (1U << 2);  ///< Voltage Monitor 1 Interrupt Status Flag
        constexpr uint32_t LVD2ST = (1U << 3);  ///< Voltage Monitor 2 Interrupt Status Flag
        constexpr uint32_t OSTST = (1U << 6);  ///< Main Clock Oscillation Stop Detection Interrupt Status Flag
        constexpr uint32_t NMIST = (1U << 7);  ///< NMI Pin Interrupt Status Flag
        constexpr uint32_t RPEST = (1U << 8);  ///< SRAM Parity Error Interrupt Status Flag
        constexpr uint32_t RECCST = (1U << 9);  ///< SRAM ECC Error Interrupt Status Flag
        constexpr uint32_t BUSMST = (1U << 11);  ///< Bus Master MPU Error Interrupt Status Flag
        constexpr uint32_t TZFST = (1U << 13);  ///< Interrupt not requested
        constexpr uint32_t CPEST = (1U << 15);  ///< Interrupt not requested
    }

    /// WUPEN0 Register bits
    namespace wupen0_bits {
        constexpr uint32_t IRQWUPEN = (16 << 0);  ///< IRQn Interrupt Software Standby/Snooze Mode Returns Enable bit (n = 0 to 15)
        constexpr uint32_t IWDTWUPEN = (1U << 16);  ///< IWDT Interrupt Software Standby/Snooze Mode Returns Enable bit
        constexpr uint32_t LVD1WUPEN = (1U << 18);  ///< LVD1 Interrupt Software Standby/Snooze Mode Returns Enable bit
        constexpr uint32_t LVD2WUPEN = (1U << 19);  ///< LVD2 Interrupt Software Standby/Snooze Mode Returns Enable bit
        constexpr uint32_t RTCALMWUPEN = (1U << 24);  ///< RTC Alarm Interrupt Software Standby/Snooze Mode Returns Enable bit
        constexpr uint32_t RTCPRDWUPEN = (1U << 25);  ///< RTC Period Interrupt Software Standby/Snooze Mode Returns Enable bit
        constexpr uint32_t USBFS0WUPEN = (1U << 27);  ///< USBFS0 Interrupt Software Standby/Snooze Mode Returns Enable bit
        constexpr uint32_t AGT1UDWUPEN = (1U << 28);  ///< AGT1 Underflow Interrupt Software Standby/Snooze Mode Returns Enable bit
        constexpr uint32_t AGT1CAWUPEN = (1U << 29);  ///< AGT1 Compare Match A Interrupt Software Standby/Snooze Mode Returns Enable bit
        constexpr uint32_t AGT1CBWUPEN = (1U << 30);  ///< AGT1 Compare Match B Interrupt Software Standby/Snooze Mode Returns Enable bit
        constexpr uint32_t IIC0WUPEN = (1U << 31);  ///< IIC0 Address Match Interrupt Software Standby/Snooze Mode Returns Enable bit
    }

    /// WUPEN1 Register bits
    namespace wupen1_bits {
        constexpr uint32_t AGT3UDWUPEN = (1U << 0);  ///< AGT3 Underflow Interrupt Software Standby Return Enable bit
        constexpr uint32_t AGT3CAWUPEN = (1U << 1);  ///< AGT3 Compare Match A Interrupt Software Standby Return Enable bit
        constexpr uint32_t AGT3CBWUPEN = (1U << 2);  ///< AGT3 Compare Match B Interrupt Software Standby Return Enable bit
    }

    /// DELSR%s Register bits
    namespace delsr%s_bits {
        constexpr uint32_t DELS = (9 << 0);  ///< DMAC Event Link Select
        constexpr uint32_t IR = (1U << 16);  ///< DMAC Activation Request Status Flag
    }

}

// ============================================================================
// CACHE Peripheral
// ============================================================================

namespace cache {
    /// Base addresses
    constexpr uint32_t CACHE_BASE = 0x40007000;

    /// CACHE Register structure
    struct Registers {
        volatile uint32_t CCACTL;  ///< Offset: 0x00 - C-Cache Control Register
        volatile uint32_t CCAFCT;  ///< Offset: 0x04 - C-Cache Flush Control Register
        volatile uint32_t CCALCF;  ///< Offset: 0x08 - C-Cache Line Configuration Register
        volatile uint32_t SCACTL;  ///< Offset: 0x40 - S-Cache Control Register
        volatile uint32_t SCAFCT;  ///< Offset: 0x44 - S-Cache Flush Control Register
        volatile uint32_t SCALCF;  ///< Offset: 0x48 - S-Cache Line Configuration Register
        volatile uint32_t CAPOAD;  ///< Offset: 0x200 - Cache Parity Error Operation After Detection Register
        volatile uint32_t CAPRCR;  ///< Offset: 0x204 - Cache Protection Register
    };

    /// Peripheral instances
    inline Registers* CACHE = reinterpret_cast<Registers*>(CACHE_BASE);

    // Bit definitions
    /// CCACTL Register bits
    namespace ccactl_bits {
        constexpr uint32_t ENC = (1U << 0);  ///< C-Cache Enable
    }

    /// CCAFCT Register bits
    namespace ccafct_bits {
        constexpr uint32_t FC = (1U << 0);  ///< C-Cache Flush
    }

    /// CCALCF Register bits
    namespace ccalcf_bits {
        constexpr uint32_t CC = (2 << 0);  ///< C-Cache Line Size
    }

    /// SCACTL Register bits
    namespace scactl_bits {
        constexpr uint32_t ENS = (1U << 0);  ///< S-Cache Enable
    }

    /// SCAFCT Register bits
    namespace scafct_bits {
        constexpr uint32_t FS = (1U << 0);  ///< S-Cache Flush
    }

    /// SCALCF Register bits
    namespace scalcf_bits {
        constexpr uint32_t CS = (2 << 0);  ///< S-Cache Line Size
    }

    /// CAPOAD Register bits
    namespace capoad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after Detection
    }

    /// CAPRCR Register bits
    namespace caprcr_bits {
        constexpr uint32_t PRCR = (1U << 0);  ///< Register Write Control
        constexpr uint32_t KW = (7 << 1);  ///< Write key code
    }

}

// ============================================================================
// CPSCU Peripheral
// ============================================================================

namespace cpscu {
    /// Base addresses
    constexpr uint32_t CPSCU_BASE = 0x40008000;

    /// CPSCU Register structure
    struct Registers {
        volatile uint32_t CSAR;  ///< Offset: 0x00 - Cache Security Attribution Register
        volatile uint32_t SRAMSAR;  ///< Offset: 0x10 - SRAM Security Attribution Register
        volatile uint32_t STBRAMSAR;  ///< Offset: 0x14 - Standby RAM memory Security Attribution Register
        volatile uint32_t DTCSAR;  ///< Offset: 0x30 - DTC Controller Security Attribution Register
        volatile uint32_t DMACSAR;  ///< Offset: 0x34 - DMAC Controller Security Attribution Register
        volatile uint32_t ICUSARA;  ///< Offset: 0x40 - Interrupt Controller Unit Security Attribution Register A
        volatile uint32_t ICUSARB;  ///< Offset: 0x44 - Interrupt Controller Unit Security Attribution Register B
        volatile uint32_t ICUSARC;  ///< Offset: 0x48 - Interrupt Controller Unit Security Attribution Register C
        volatile uint32_t ICUSARD;  ///< Offset: 0x4C - Interrupt Controller Unit Security Attribution Register D
        volatile uint32_t ICUSARF;  ///< Offset: 0x54 - Interrupt Controller Unit Security Attribution Register F
        volatile uint32_t ICUSARG;  ///< Offset: 0x70 - Interrupt Controller Unit Security Attribution Register G
        volatile uint32_t ICUSARH;  ///< Offset: 0x74 - Interrupt Controller Unit Security Attribution Register H
        volatile uint32_t ICUSARI;  ///< Offset: 0x78 - Interrupt Controller Unit Security Attribution Register I
        volatile uint32_t BUSSARA;  ///< Offset: 0x100 - BUS Security Attribution Register A
        volatile uint32_t BUSSARB;  ///< Offset: 0x104 - BUS Security Attribution Register B
        volatile uint32_t MMPUSARA;  ///< Offset: 0x130 - Master Memory Protection Unit Security Attribution Register A
        volatile uint32_t MMPUSARB;  ///< Offset: 0x134 - Master Memory Protection Unit Security Attribution Register B
        volatile uint32_t TZFSAR;  ///< Offset: 0x180 - TrustZone Filter Security Attribution Register
        volatile uint32_t CPUDSAR;  ///< Offset: 0x1B0 - CPU Debug Security Attribution Register
    };

    /// Peripheral instances
    inline Registers* CPSCU = reinterpret_cast<Registers*>(CPSCU_BASE);

    // Bit definitions
    /// CSAR Register bits
    namespace csar_bits {
        constexpr uint32_t CACHESA = (1U << 0);  ///< Security Attributes of Registers for Cache Control
        constexpr uint32_t CACHELSA = (1U << 1);  ///< Security Attributes of Registers for Cache Line Configuration
        constexpr uint32_t CACHEESA = (1U << 2);  ///< Security Attributes of Registers for Cache Error
    }

    /// SRAMSAR Register bits
    namespace sramsar_bits {
        constexpr uint32_t SRAMSA0 = (1U << 0);  ///< Security attributes of registers for SRAM Protection
        constexpr uint32_t SRAMSA1 = (1U << 1);  ///< Security attributes of registers for SRAM Protection 2
        constexpr uint32_t SRAMSA2 = (1U << 2);  ///< Security attributes of registers for ECC Relation
    }

    /// STBRAMSAR Register bits
    namespace stbramsar_bits {
        constexpr uint32_t NSBSTBR = (4 << 0);  ///< Security attributes of each region for Standby RAM
    }

    /// DTCSAR Register bits
    namespace dtcsar_bits {
        constexpr uint32_t DTCSTSA = (1U << 0);  ///< DTC Security Attribution
    }

    /// DMACSAR Register bits
    namespace dmacsar_bits {
        constexpr uint32_t DMASTSA = (1U << 0);  ///< DMAST Security Attribution
    }

    /// ICUSARA Register bits
    namespace icusara_bits {
        constexpr uint32_t SAIRQCR00 = (1U << 0);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR01 = (1U << 1);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR02 = (1U << 2);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR03 = (1U << 3);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR04 = (1U << 4);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR05 = (1U << 5);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR06 = (1U << 6);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR07 = (1U << 7);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR08 = (1U << 8);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR09 = (1U << 9);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR10 = (1U << 10);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR11 = (1U << 11);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR12 = (1U << 12);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR13 = (1U << 13);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR14 = (1U << 14);  ///< Security attributes of registers for the IRQCRn register
        constexpr uint32_t SAIRQCR15 = (1U << 15);  ///< Security attributes of registers for the IRQCRn register
    }

    /// ICUSARB Register bits
    namespace icusarb_bits {
        constexpr uint32_t SANMI = (1U << 0);  ///< Security attributes of registers for nonmaskable interrupt
    }

    /// ICUSARC Register bits
    namespace icusarc_bits {
        constexpr uint32_t SADMAC0 = (1U << 0);  ///< Security attributes of registers for DMAC channel
        constexpr uint32_t SADMAC1 = (1U << 1);  ///< Security attributes of registers for DMAC channel
        constexpr uint32_t SADMAC2 = (1U << 2);  ///< Security attributes of registers for DMAC channel
        constexpr uint32_t SADMAC3 = (1U << 3);  ///< Security attributes of registers for DMAC channel
        constexpr uint32_t SADMAC4 = (1U << 4);  ///< Security attributes of registers for DMAC channel
        constexpr uint32_t SADMAC5 = (1U << 5);  ///< Security attributes of registers for DMAC channel
        constexpr uint32_t SADMAC6 = (1U << 6);  ///< Security attributes of registers for DMAC channel
        constexpr uint32_t SADMAC7 = (1U << 7);  ///< Security attributes of registers for DMAC channel
    }

    /// ICUSARD Register bits
    namespace icusard_bits {
        constexpr uint32_t SASELSR0 = (1U << 0);  ///< Security attributes of registers for SELSR0
    }

    /// ICUSARF Register bits
    namespace icusarf_bits {
        constexpr uint32_t SAAGT3UDWUP = (1U << 0);  ///< Security attributes of registers for WUPEN1.b0
        constexpr uint32_t SAAGT3CAWUP = (1U << 1);  ///< Security attributes of registers for WUPEN1.b1
        constexpr uint32_t SAAGT3CBWUP = (1U << 2);  ///< Security attributes of registers for WUPEN1.b2
    }

    /// ICUSARG Register bits
    namespace icusarg_bits {
        constexpr uint32_t SAIELSR00 = (1U << 0);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR01 = (1U << 1);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR02 = (1U << 2);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR03 = (1U << 3);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR04 = (1U << 4);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR05 = (1U << 5);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR06 = (1U << 6);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR07 = (1U << 7);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR08 = (1U << 8);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR09 = (1U << 9);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR10 = (1U << 10);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR11 = (1U << 11);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR12 = (1U << 12);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR13 = (1U << 13);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR14 = (1U << 14);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR15 = (1U << 15);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR16 = (1U << 16);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR17 = (1U << 17);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR18 = (1U << 18);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR19 = (1U << 19);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR20 = (1U << 20);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR21 = (1U << 21);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR22 = (1U << 22);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR23 = (1U << 23);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR24 = (1U << 24);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR25 = (1U << 25);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR26 = (1U << 26);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR27 = (1U << 27);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR28 = (1U << 28);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR29 = (1U << 29);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR30 = (1U << 30);  ///< Security attributes of registers for IELSR31 to IELSR0
        constexpr uint32_t SAIELSR31 = (1U << 31);  ///< Security attributes of registers for IELSR31 to IELSR0
    }

    /// ICUSARH Register bits
    namespace icusarh_bits {
        constexpr uint32_t SAIELSR32 = (1U << 0);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR33 = (1U << 1);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR34 = (1U << 2);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR35 = (1U << 3);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR36 = (1U << 4);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR37 = (1U << 5);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR38 = (1U << 6);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR39 = (1U << 7);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR40 = (1U << 8);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR41 = (1U << 9);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR42 = (1U << 10);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR43 = (1U << 11);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR44 = (1U << 12);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR45 = (1U << 13);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR46 = (1U << 14);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR47 = (1U << 15);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR48 = (1U << 16);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR49 = (1U << 17);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR50 = (1U << 18);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR51 = (1U << 19);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR52 = (1U << 20);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR53 = (1U << 21);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR54 = (1U << 22);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR55 = (1U << 23);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR56 = (1U << 24);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR57 = (1U << 25);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR58 = (1U << 26);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR59 = (1U << 27);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR60 = (1U << 28);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR61 = (1U << 29);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR62 = (1U << 30);  ///< Security attributes of registers for IELSR63 to IELSR32
        constexpr uint32_t SAIELSR63 = (1U << 31);  ///< Security attributes of registers for IELSR63 to IELSR32
    }

    /// ICUSARI Register bits
    namespace icusari_bits {
        constexpr uint32_t SAIELSR64 = (1U << 0);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR65 = (1U << 1);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR66 = (1U << 2);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR67 = (1U << 3);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR68 = (1U << 4);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR69 = (1U << 5);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR70 = (1U << 6);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR71 = (1U << 7);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR72 = (1U << 8);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR73 = (1U << 9);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR74 = (1U << 10);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR75 = (1U << 11);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR76 = (1U << 12);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR77 = (1U << 13);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR78 = (1U << 14);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR79 = (1U << 15);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR80 = (1U << 16);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR81 = (1U << 17);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR82 = (1U << 18);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR83 = (1U << 19);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR84 = (1U << 20);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR85 = (1U << 21);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR86 = (1U << 22);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR87 = (1U << 23);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR88 = (1U << 24);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR89 = (1U << 25);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR90 = (1U << 26);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR91 = (1U << 27);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR92 = (1U << 28);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR93 = (1U << 29);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR94 = (1U << 30);  ///< Security attributes of registers for IELSR95 to IELSR64
        constexpr uint32_t SAIELSR95 = (1U << 31);  ///< Security attributes of registers for IELSR95 to IELSR64
    }

    /// BUSSARA Register bits
    namespace bussara_bits {
        constexpr uint32_t BUSSA0 = (1U << 0);  ///< BUS Security Attribution A0
    }

    /// BUSSARB Register bits
    namespace bussarb_bits {
        constexpr uint32_t BUSSB0 = (1U << 0);  ///< BUS Security Attribution B0
    }

    /// MMPUSARA Register bits
    namespace mmpusara_bits {
        constexpr uint32_t MMPUASAn = (8 << 0);  ///< MMPUA Security Attribution (n = 0 to 7)
    }

    /// MMPUSARB Register bits
    namespace mmpusarb_bits {
        constexpr uint32_t MMPUBSA0 = (1U << 0);  ///< MMPUB Security Attribution
    }

    /// TZFSAR Register bits
    namespace tzfsar_bits {
        constexpr uint32_t TZFSA0 = (1U << 0);  ///< Security attributes of registers for TrustZone Filter
    }

    /// CPUDSAR Register bits
    namespace cpudsar_bits {
        constexpr uint32_t CPUDSA0 = (1U << 0);  ///< CPU Debug Security Attribution 0
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0x4001B000;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t DBGSTR;  ///< Offset: 0x00 - Debug Status Register
        volatile uint32_t DBGSTOPCR;  ///< Offset: 0x10 - Debug Stop Control Register
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// DBGSTR Register bits
    namespace dbgstr_bits {
        constexpr uint32_t CDBGPWRUPREQ = (1U << 28);  ///< Debug power-up request
        constexpr uint32_t CDBGPWRUPACK = (1U << 29);  ///< Debug power-up acknowledge
    }

    /// DBGSTOPCR Register bits
    namespace dbgstopcr_bits {
        constexpr uint32_t DBGSTOP_IWDT = (1U << 0);  ///< Mask bit for IWDT reset/interrupt in the OCD run mode
        constexpr uint32_t DBGSTOP_WDT = (1U << 1);  ///< Mask bit for WDT reset/interrupt in the OCD run mode
        constexpr uint32_t DBGSTOP_LVD0 = (1U << 16);  ///< Mask bit for LVD0 reset
        constexpr uint32_t DBGSTOP_LVD1 = (1U << 17);  ///< Mask bit for LVD1 reset/interrupt
        constexpr uint32_t DBGSTOP_LVD2 = (1U << 18);  ///< Mask bit for LVD2 reset/interrupt
        constexpr uint32_t DBGSTOP_RPER = (1U << 24);  ///< Mask bit for SRAM parity error reset/interrupt
        constexpr uint32_t DBGSTOP_RECCR = (1U << 25);  ///< Mask bit for SRAM ECC error reset/interrupt
        constexpr uint32_t DBGSTOP_CPER = (1U << 31);  ///< Mask bit for Cache SRAM parity error reset/interrupt
    }

}

// ============================================================================
// FCACHE Peripheral
// ============================================================================

namespace fcache {
    /// Base addresses
    constexpr uint32_t FCACHE_BASE = 0x4001C100;

    /// FCACHE Register structure
    struct Registers {
        volatile uint32_t FCACHEE;  ///< Offset: 0x00 - Flash Cache Enable Register
        volatile uint32_t FCACHEIV;  ///< Offset: 0x04 - Flash Cache Invalidate Register
        volatile uint32_t FLWT;  ///< Offset: 0x1C - Flash Wait Cycle Register
        volatile uint32_t FSAR;  ///< Offset: 0x40 - Flash Security Attribution Register
    };

    /// Peripheral instances
    inline Registers* FCACHE = reinterpret_cast<Registers*>(FCACHE_BASE);

    // Bit definitions
    /// FCACHEE Register bits
    namespace fcachee_bits {
        constexpr uint32_t FCACHEEN = (1U << 0);  ///< Flash Cache Enable
    }

    /// FCACHEIV Register bits
    namespace fcacheiv_bits {
        constexpr uint32_t FCACHEIV = (1U << 0);  ///< Flash Cache Invalidate
    }

    /// FLWT Register bits
    namespace flwt_bits {
        constexpr uint32_t FLWT = (3 << 0);  ///< Flash Wait Cycle
    }

    /// FSAR Register bits
    namespace fsar_bits {
        constexpr uint32_t FLWTSA = (1U << 0);  ///< FLWT Security Attribution
        constexpr uint32_t FCKMHZSA = (1U << 8);  ///< FCKMHZ Security Attribution
    }

}

// ============================================================================
// SYSC Peripheral
// ============================================================================

namespace sysc {
    /// Base addresses
    constexpr uint32_t SYSC_BASE = 0x4001E000;

    /// SYSC Register structure
    struct Registers {
        volatile uint32_t SBYCR;  ///< Offset: 0x0C - Standby Control Register
        volatile uint32_t SCKDIVCR;  ///< Offset: 0x20 - System Clock Division Control Register
        volatile uint32_t SCKSCR;  ///< Offset: 0x26 - System Clock Source Control Register
        volatile uint32_t PLLCCR;  ///< Offset: 0x28 - PLL Clock Control Register
        volatile uint32_t PLLCR;  ///< Offset: 0x2A - PLL Control Register
        volatile uint32_t MOSCCR;  ///< Offset: 0x32 - Main Clock Oscillator Control Register
        volatile uint32_t HOCOCR;  ///< Offset: 0x36 - High-Speed On-Chip Oscillator Control Register
        volatile uint32_t MOCOCR;  ///< Offset: 0x38 - Middle-Speed On-Chip Oscillator Control Register
        volatile uint32_t FLLCR1;  ///< Offset: 0x39 - FLL Control Register1
        volatile uint32_t FLLCR2;  ///< Offset: 0x3A - FLL Control Register2
        volatile uint32_t OSCSF;  ///< Offset: 0x3C - Oscillation Stabilization Flag Register
        volatile uint32_t CKOCR;  ///< Offset: 0x3E - Clock Out Control Register
        volatile uint32_t TRCKCR;  ///< Offset: 0x3F - Trace Clock Control Register
        volatile uint32_t OSTDCR;  ///< Offset: 0x40 - Oscillation Stop Detection Control Register
        volatile uint32_t OSTDSR;  ///< Offset: 0x41 - Oscillation Stop Detection Status Register
        volatile uint32_t PLL2CCR;  ///< Offset: 0x48 - PLL2 Clock Control Register
        volatile uint32_t PLL2CR;  ///< Offset: 0x4A - PLL2 Control Register
        volatile uint32_t MOCOUTCR;  ///< Offset: 0x61 - MOCO User Trimming Control Register
        volatile uint32_t HOCOUTCR;  ///< Offset: 0x62 - HOCO User Trimming Control Register
        volatile uint32_t USBCKDIVCR;  ///< Offset: 0x6C - USB Clock Division Control Register
        volatile uint32_t USBCKCR;  ///< Offset: 0x74 - USB Clock Control Register
        volatile uint32_t SNZREQCR1;  ///< Offset: 0x88 - Snooze Request Control Register 1
        volatile uint32_t SNZCR;  ///< Offset: 0x92 - Snooze Control Register
        volatile uint32_t SNZEDCR0;  ///< Offset: 0x94 - Snooze End Control Register 0
        volatile uint32_t SNZEDCR1;  ///< Offset: 0x95 - Snooze End Control Register 1
        volatile uint32_t SNZREQCR0;  ///< Offset: 0x98 - Snooze Request Control Register 0
        volatile uint32_t OPCCR;  ///< Offset: 0xA0 - Operating Power Control Register
        volatile uint32_t MOSCWTCR;  ///< Offset: 0xA2 - Main Clock Oscillator Wait Control Register
        volatile uint32_t SOPCCR;  ///< Offset: 0xAA - Sub Operating Power Control Register
        volatile uint32_t RSTSR1;  ///< Offset: 0xC0 - Reset Status Register 1
        volatile uint32_t LVD1CR1;  ///< Offset: 0xE0 - Voltage Monitor 1 Circuit Control Register
        volatile uint32_t LVD1SR;  ///< Offset: 0xE1 - Voltage Monitor 1 Circuit Status Register
        volatile uint32_t LVD2CR1;  ///< Offset: 0xE2 - Voltage Monitor 2 Circuit Control Register 1
        volatile uint32_t LVD2SR;  ///< Offset: 0xE3 - Voltage Monitor 2 Circuit Status Register
        volatile uint32_t CGFSAR;  ///< Offset: 0x3C0 - Clock Generation Function Security Attribute Register
        volatile uint32_t RSTSAR;  ///< Offset: 0x3C4 - Reset Security Attribution Register
        volatile uint32_t LPMSAR;  ///< Offset: 0x3C8 - Low Power Mode Security Attribution Register
        volatile uint32_t LVDSAR;  ///< Offset: 0x3CC - Low Voltage Detection Security Attribution Register
        volatile uint32_t BBFSAR;  ///< Offset: 0x3D0 - Battery Backup Function Security Attribute Register
        volatile uint32_t DPFSAR;  ///< Offset: 0x3E0 - Deep Software Standby Interrupt Factor Security...
        volatile uint32_t PRCR;  ///< Offset: 0x3FE - Protect Register
        volatile uint32_t DPSBYCR;  ///< Offset: 0x400 - Deep Software Standby Control Register
        volatile uint32_t DPSWCR;  ///< Offset: 0x401 - Deep Software Standby Wait Control Register
        volatile uint32_t DPSIER0;  ///< Offset: 0x402 - Deep Software Standby Interrupt Enable Register 0
        volatile uint32_t DPSIER1;  ///< Offset: 0x403 - Deep Software Standby Interrupt Enable Register 1
        volatile uint32_t DPSIER2;  ///< Offset: 0x404 - Deep Software Standby Interrupt Enable Register 2
        volatile uint32_t DPSIER3;  ///< Offset: 0x405 - Deep Software Standby Interrupt Enable Register 3
        volatile uint32_t DPSIFR0;  ///< Offset: 0x406 - Deep Software Standby Interrupt Flag Register 0
        volatile uint32_t DPSIFR1;  ///< Offset: 0x407 - Deep Software Standby Interrupt Flag Register 1
        volatile uint32_t DPSIFR2;  ///< Offset: 0x408 - Deep Software Standby Interrupt Flag Register 2
        volatile uint32_t DPSIFR3;  ///< Offset: 0x409 - Deep Software Standby Interrupt Flag Register 3
        volatile uint32_t DPSIEGR0;  ///< Offset: 0x40A - Deep Software Standby Interrupt Edge Register 0
        volatile uint32_t DPSIEGR1;  ///< Offset: 0x40B - Deep Software Standby Interrupt Edge Register 1
        volatile uint32_t DPSIEGR2;  ///< Offset: 0x40C - Deep Software Standby Interrupt Edge Register 2
        volatile uint32_t SYOCDCR;  ///< Offset: 0x40E - System Control OCD Control Register
        volatile uint32_t RSTSR0;  ///< Offset: 0x410 - Reset Status Register 0
        volatile uint32_t RSTSR2;  ///< Offset: 0x411 - Reset Status Register 2
        volatile uint32_t MOMCR;  ///< Offset: 0x413 - Main Clock Oscillator Mode Oscillation Control Register
        volatile uint32_t FWEPROR;  ///< Offset: 0x416 - Flash P/E Protect Register
        volatile uint32_t LVD1CMPCR;  ///< Offset: 0x417 - Voltage Monitoring 1 Comparator Control Register
        volatile uint32_t LVD2CMPCR;  ///< Offset: 0x418 - Voltage Monitoring 2 Comparator Control Register
        volatile uint32_t LVD1CR0;  ///< Offset: 0x41A - Voltage Monitor 1 Circuit Control Register 0
        volatile uint32_t LVD2CR0;  ///< Offset: 0x41B - Voltage Monitor 2 Circuit Control Register 0
        volatile uint32_t VBATTMNSELR;  ///< Offset: 0x41D - Battery Backup Voltage Monitor Function Select Register
        volatile uint32_t VBATTMONR;  ///< Offset: 0x41E - Battery Backup Voltage Monitor Register
        volatile uint32_t SOSCCR;  ///< Offset: 0x480 - Sub-Clock Oscillator Control Register
        volatile uint32_t SOMCR;  ///< Offset: 0x481 - Sub-Clock Oscillator Mode Control Register
        volatile uint32_t LOCOCR;  ///< Offset: 0x490 - Low-Speed On-Chip Oscillator Control Register
        volatile uint32_t LOCOUTCR;  ///< Offset: 0x492 - LOCO User Trimming Control Register
        volatile uint32_t VBTICTLR;  ///< Offset: 0x4BB - VBATT Input Control Register
        volatile uint32_t VBTBER;  ///< Offset: 0x4C0 - VBATT Backup Enable Register
        volatile uint32_t VBTBKR[%s];  ///< Offset: 0x500 - VBATT Backup Register
    };

    /// Peripheral instances
    inline Registers* SYSC = reinterpret_cast<Registers*>(SYSC_BASE);

    // Bit definitions
    /// SBYCR Register bits
    namespace sbycr_bits {
        constexpr uint32_t SSBY = (1U << 15);  ///< Software Standby Mode Select
    }

    /// SCKDIVCR Register bits
    namespace sckdivcr_bits {
        constexpr uint32_t PCKD = (3 << 0);  ///< Peripheral Module Clock D (PCLKD) Select
        constexpr uint32_t PCKC = (3 << 4);  ///< Peripheral Module Clock C (PCLKC) Select
        constexpr uint32_t PCKB = (3 << 8);  ///< Peripheral Module Clock B (PCLKB) Select
        constexpr uint32_t PCKA = (3 << 12);  ///< Peripheral Module Clock A (PCLKA) Select
        constexpr uint32_t RSV = (3 << 16);  ///< Reserved. Set these bits to the same value as PCKB[2:0].
        constexpr uint32_t ICK = (3 << 24);  ///< System Clock (ICLK) Select
        constexpr uint32_t FCK = (3 << 28);  ///< FlashIF Clock (FCLK) Select
    }

    /// SCKSCR Register bits
    namespace sckscr_bits {
        constexpr uint32_t CKSEL = (3 << 0);  ///< Clock Source Select
    }

    /// PLLCCR Register bits
    namespace pllccr_bits {
        constexpr uint32_t PLIDIV = (2 << 0);  ///< PLL Input Frequency Division Ratio Select
        constexpr uint32_t PLSRCSEL = (1U << 4);  ///< PLL Clock Source Select
        constexpr uint32_t PLLMUL = (6 << 8);  ///< PLL Frequency Multiplication Factor Select
    }

    /// PLLCR Register bits
    namespace pllcr_bits {
        constexpr uint32_t PLLSTP = (1U << 0);  ///< PLL Stop Control
    }

    /// MOSCCR Register bits
    namespace mosccr_bits {
        constexpr uint32_t MOSTP = (1U << 0);  ///< Main Clock Oscillator Stop
    }

    /// HOCOCR Register bits
    namespace hococr_bits {
        constexpr uint32_t HCSTP = (1U << 0);  ///< HOCO Stop
    }

    /// MOCOCR Register bits
    namespace mococr_bits {
        constexpr uint32_t MCSTP = (1U << 0);  ///< MOCO Stop
    }

    /// FLLCR1 Register bits
    namespace fllcr1_bits {
        constexpr uint32_t FLLEN = (1U << 0);  ///< FLL Enable
    }

    /// FLLCR2 Register bits
    namespace fllcr2_bits {
        constexpr uint32_t FLLCNTL = (11 << 0);  ///< FLL Multiplication Control
    }

    /// OSCSF Register bits
    namespace oscsf_bits {
        constexpr uint32_t HOCOSF = (1U << 0);  ///< HOCO Clock Oscillation Stabilization Flag
        constexpr uint32_t MOSCSF = (1U << 3);  ///< Main Clock Oscillation Stabilization Flag
        constexpr uint32_t PLLSF = (1U << 5);  ///< PLL Clock Oscillation Stabilization Flag
        constexpr uint32_t PLL2SF = (1U << 6);  ///< PLL2 Clock Oscillation Stabilization Flag
    }

    /// CKOCR Register bits
    namespace ckocr_bits {
        constexpr uint32_t CKOSEL = (3 << 0);  ///< Clock Out Source Select
        constexpr uint32_t CKODIV = (3 << 4);  ///< Clock Output Frequency Division Ratio
        constexpr uint32_t CKOEN = (1U << 7);  ///< Clock Out Enable
    }

    /// TRCKCR Register bits
    namespace trckcr_bits {
        constexpr uint32_t TRCK = (4 << 0);  ///< Trace Clock operating frequency select
        constexpr uint32_t TRCKEN = (1U << 7);  ///< Trace Clock operating Enable
    }

    /// OSTDCR Register bits
    namespace ostdcr_bits {
        constexpr uint32_t OSTDIE = (1U << 0);  ///< Oscillation Stop Detection Interrupt Enable
        constexpr uint32_t OSTDE = (1U << 7);  ///< Oscillation Stop Detection Function Enable
    }

    /// OSTDSR Register bits
    namespace ostdsr_bits {
        constexpr uint32_t OSTDF = (1U << 0);  ///< Oscillation Stop Detection Flag
    }

    /// PLL2CCR Register bits
    namespace pll2ccr_bits {
        constexpr uint32_t PL2IDIV = (2 << 0);  ///< PLL2 Input Frequency Division Ratio Select
        constexpr uint32_t PL2SRCSEL = (1U << 4);  ///< PLL2 Clock Source Select
        constexpr uint32_t PLL2MUL = (6 << 8);  ///< PLL2 Frequency Multiplication Factor Select
    }

    /// PLL2CR Register bits
    namespace pll2cr_bits {
        constexpr uint32_t PLL2STP = (1U << 0);  ///< PLL2 Stop Control
    }

    /// MOCOUTCR Register bits
    namespace mocoutcr_bits {
        constexpr uint32_t MOCOUTRM = (8 << 0);  ///< MOCO User Trimming
    }

    /// HOCOUTCR Register bits
    namespace hocoutcr_bits {
        constexpr uint32_t HOCOUTRM = (8 << 0);  ///< HOCO User Trimming
    }

    /// USBCKDIVCR Register bits
    namespace usbckdivcr_bits {
        constexpr uint32_t USBCKDIV = (3 << 0);  ///< USB Clock (USBCLK) Division Select
    }

    /// USBCKCR Register bits
    namespace usbckcr_bits {
        constexpr uint32_t USBCKSEL = (3 << 0);  ///< USB Clock (USBCLK) Source Select
        constexpr uint32_t USBCKSREQ = (1U << 6);  ///< USB Clock (USBCLK) Switching Request
        constexpr uint32_t USBCKSRDY = (1U << 7);  ///< USB Clock (USBCLK) Switching Ready state flag
    }

    /// SNZREQCR1 Register bits
    namespace snzreqcr1_bits {
        constexpr uint32_t SNZREQEN0 = (1U << 0);  ///< Enable AGT3 underflow snooze request
        constexpr uint32_t SNZREQEN1 = (1U << 1);  ///< Enable AGT3 compare match A snooze request
        constexpr uint32_t SNZREQEN2 = (1U << 2);  ///< Enable AGT3 compare match B snooze request
    }

    /// SNZCR Register bits
    namespace snzcr_bits {
        constexpr uint32_t RXDREQEN = (1U << 0);  ///< RXD0 Snooze Request Enable
        constexpr uint32_t SNZDTCEN = (1U << 1);  ///< DTC Enable in Snooze mode
        constexpr uint32_t SNZE = (1U << 7);  ///< Snooze mode Enable
    }

    /// SNZEDCR0 Register bits
    namespace snzedcr0_bits {
        constexpr uint32_t AGTUNFED = (1U << 0);  ///< AGT1 Underflow Snooze End Enable
        constexpr uint32_t DTCZRED = (1U << 1);  ///< Last DTC Transmission Completion Snooze End Enable
        constexpr uint32_t DTCNZRED = (1U << 2);  ///< Not Last DTC Transmission Completion Snooze End Enable
        constexpr uint32_t AD0MATED = (1U << 3);  ///< ADC120 Compare Match Snooze End Enable
        constexpr uint32_t AD0UMTED = (1U << 4);  ///< ADC120 Compare Mismatch Snooze End Enable
        constexpr uint32_t AD1MATED = (1U << 5);  ///< ADC121 Compare Match Snooze End Enable
        constexpr uint32_t AD1UMTED = (1U << 6);  ///< ADC121 Compare Mismatch Snooze End Enable
        constexpr uint32_t SCI0UMTED = (1U << 7);  ///< SCI0 Address Mismatch Snooze End Enable
    }

    /// SNZEDCR1 Register bits
    namespace snzedcr1_bits {
        constexpr uint32_t AGT3UNFED = (1U << 0);  ///< AGT3 underflow Snooze End Enable
    }

    /// SNZREQCR0 Register bits
    namespace snzreqcr0_bits {
        constexpr uint32_t SNZREQEN0 = (1U << 0);  ///< Enable IRQ0 pin snooze request
        constexpr uint32_t SNZREQEN1 = (1U << 1);  ///< Enable IRQ1 pin snooze request
        constexpr uint32_t SNZREQEN2 = (1U << 2);  ///< Enable IRQ2 pin snooze request
        constexpr uint32_t SNZREQEN3 = (1U << 3);  ///< Enable IRQ3 pin snooze request
        constexpr uint32_t SNZREQEN4 = (1U << 4);  ///< Enable IRQ4 pin snooze request
        constexpr uint32_t SNZREQEN5 = (1U << 5);  ///< Enable IRQ5 pin snooze request
        constexpr uint32_t SNZREQEN6 = (1U << 6);  ///< Enable IRQ6 pin snooze request
        constexpr uint32_t SNZREQEN7 = (1U << 7);  ///< Enable IRQ7 pin snooze request
        constexpr uint32_t SNZREQEN8 = (1U << 8);  ///< Enable IRQ8 pin snooze request
        constexpr uint32_t SNZREQEN9 = (1U << 9);  ///< Enable IRQ9 pin snooze request
        constexpr uint32_t SNZREQEN10 = (1U << 10);  ///< Enable IRQ10 pin snooze request
        constexpr uint32_t SNZREQEN11 = (1U << 11);  ///< Enable IRQ11 pin snooze request
        constexpr uint32_t SNZREQEN12 = (1U << 12);  ///< Enable IRQ12 pin snooze request
        constexpr uint32_t SNZREQEN13 = (1U << 13);  ///< Enable IRQ13 pin snooze request
        constexpr uint32_t SNZREQEN14 = (1U << 14);  ///< Enable IRQ14 pin snooze request
        constexpr uint32_t SNZREQEN15 = (1U << 15);  ///< Enable IRQ15 pin snooze request
        constexpr uint32_t SNZREQEN24 = (1U << 24);  ///< Enable RTC alarm snooze request
        constexpr uint32_t SNZREQEN25 = (1U << 25);  ///< Enable RTC period snooze request
        constexpr uint32_t SNZREQEN28 = (1U << 28);  ///< Enable AGT1 underflow snooze request
        constexpr uint32_t SNZREQEN29 = (1U << 29);  ///< Enable AGT1 compare match A snooze request
        constexpr uint32_t SNZREQEN30 = (1U << 30);  ///< Enable AGT1 compare match B snooze request
    }

    /// OPCCR Register bits
    namespace opccr_bits {
        constexpr uint32_t OPCM = (2 << 0);  ///< Operating Power Control Mode Select
        constexpr uint32_t OPCMTSF = (1U << 4);  ///< Operating Power Control Mode Transition Status Flag
    }

    /// MOSCWTCR Register bits
    namespace moscwtcr_bits {
        constexpr uint32_t MSTS = (4 << 0);  ///< Main Clock Oscillator Wait Time Setting
    }

    /// SOPCCR Register bits
    namespace sopccr_bits {
        constexpr uint32_t SOPCM = (1U << 0);  ///< Sub Operating Power Control Mode Select
        constexpr uint32_t SOPCMTSF = (1U << 4);  ///< Operating Power Control Mode Transition Status Flag
    }

    /// RSTSR1 Register bits
    namespace rstsr1_bits {
        constexpr uint32_t IWDTRF = (1U << 0);  ///< Independent Watchdog Timer Reset Detect Flag
        constexpr uint32_t WDTRF = (1U << 1);  ///< Watchdog Timer Reset Detect Flag
        constexpr uint32_t SWRF = (1U << 2);  ///< Software Reset Detect Flag
        constexpr uint32_t RPERF = (1U << 8);  ///< SRAM Parity Error Reset Detect Flag
        constexpr uint32_t REERF = (1U << 9);  ///< SRAM ECC Error Reset Detect Flag
        constexpr uint32_t BUSMRF = (1U << 11);  ///< Bus Master MPU Error Reset Detect Flag
        constexpr uint32_t TZERF = (1U << 13);  ///< TrustZone Error Reset Detect Flag
        constexpr uint32_t CPERF = (1U << 15);  ///< Cache Parity Error Reset Detect Flag
    }

    /// LVD1CR1 Register bits
    namespace lvd1cr1_bits {
        constexpr uint32_t IDTSEL = (2 << 0);  ///< Voltage Monitor 1 Interrupt Generation Condition Select
        constexpr uint32_t IRQSEL = (1U << 2);  ///< Voltage Monitor 1 Interrupt Type Select
    }

    /// LVD1SR Register bits
    namespace lvd1sr_bits {
        constexpr uint32_t DET = (1U << 0);  ///< Voltage Monitor 1 Voltage Variation Detection Flag
        constexpr uint32_t MON = (1U << 1);  ///< Voltage Monitor 1 Signal Monitor Flag
    }

    /// LVD2CR1 Register bits
    namespace lvd2cr1_bits {
        constexpr uint32_t IDTSEL = (2 << 0);  ///< Voltage Monitor 2 Interrupt Generation Condition Select
        constexpr uint32_t IRQSEL = (1U << 2);  ///< Voltage Monitor 2 Interrupt Type Select
    }

    /// LVD2SR Register bits
    namespace lvd2sr_bits {
        constexpr uint32_t DET = (1U << 0);  ///< Voltage Monitor 2 Voltage Variation Detection Flag
        constexpr uint32_t MON = (1U << 1);  ///< Voltage Monitor 2 Signal Monitor Flag
    }

    /// CGFSAR Register bits
    namespace cgfsar_bits {
        constexpr uint32_t NONSEC00 = (1U << 0);  ///< Non Secure Attribute bit 00
        constexpr uint32_t NONSEC02 = (1U << 2);  ///< Non Secure Attribute bit 02
        constexpr uint32_t NONSEC03 = (1U << 3);  ///< Non Secure Attribute bit 03
        constexpr uint32_t NONSEC04 = (1U << 4);  ///< Non Secure Attribute bit 04
        constexpr uint32_t NONSEC05 = (1U << 5);  ///< Non Secure Attribute bit 05
        constexpr uint32_t NONSEC06 = (1U << 6);  ///< Non Secure Attribute bit 06
        constexpr uint32_t NONSEC07 = (1U << 7);  ///< Non Secure Attribute bit 07
        constexpr uint32_t NONSEC08 = (1U << 8);  ///< Non Secure Attribute bit 08
        constexpr uint32_t NONSEC09 = (1U << 9);  ///< Non Secure Attribute bit 09
        constexpr uint32_t NONSEC11 = (1U << 11);  ///< Non Secure Attribute bit 11
        constexpr uint32_t NONSEC16 = (1U << 16);  ///< Non Secure Attribute bit 16
    }

    /// RSTSAR Register bits
    namespace rstsar_bits {
        constexpr uint32_t NONSEC0 = (1U << 0);  ///< Non Secure Attribute bit 0
        constexpr uint32_t NONSEC1 = (1U << 1);  ///< Non Secure Attribute bit 1
        constexpr uint32_t NONSEC2 = (1U << 2);  ///< Non Secure Attribute bit 2
    }

    /// LPMSAR Register bits
    namespace lpmsar_bits {
        constexpr uint32_t NONSEC0 = (1U << 0);  ///< Non Secure Attribute bit 0
        constexpr uint32_t NONSEC2 = (1U << 2);  ///< Non Secure Attribute bit 2
        constexpr uint32_t NONSEC4 = (1U << 4);  ///< Non Secure Attribute bit 4
        constexpr uint32_t NONSEC8 = (1U << 8);  ///< Non Secure Attribute bit 8
        constexpr uint32_t NONSEC9 = (1U << 9);  ///< Non Secure Attribute bit 9
    }

    /// LVDSAR Register bits
    namespace lvdsar_bits {
        constexpr uint32_t NONSEC0 = (1U << 0);  ///< Non Secure Attribute bit 0
        constexpr uint32_t NONSEC1 = (1U << 1);  ///< Non Secure Attribute bit 1
    }

    /// BBFSAR Register bits
    namespace bbfsar_bits {
        constexpr uint32_t NONSEC0 = (1U << 0);  ///< Non Secure Attribute bit 0
        constexpr uint32_t NONSEC1 = (1U << 1);  ///< Non Secure Attribute bit 1
        constexpr uint32_t NONSEC2 = (1U << 2);  ///< Non Secure Attribute bit 2
        constexpr uint32_t NONSEC16 = (1U << 16);  ///< Non Secure Attribute bit 16
        constexpr uint32_t NONSEC17 = (1U << 17);  ///< Non Secure Attribute bit 17
        constexpr uint32_t NONSEC18 = (1U << 18);  ///< Non Secure Attribute bit 18
        constexpr uint32_t NONSEC19 = (1U << 19);  ///< Non Secure Attribute bit 19
        constexpr uint32_t NONSEC20 = (1U << 20);  ///< Non Secure Attribute bit 20
        constexpr uint32_t NONSEC21 = (1U << 21);  ///< Non Secure Attribute bit 21
        constexpr uint32_t NONSEC22 = (1U << 22);  ///< Non Secure Attribute bit 22
        constexpr uint32_t NONSEC23 = (1U << 23);  ///< Non Secure Attribute bit 23
    }

    /// DPFSAR Register bits
    namespace dpfsar_bits {
        constexpr uint32_t DPFSA0 = (1U << 0);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 0 to 7)
        constexpr uint32_t DPFSA1 = (1U << 1);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 0 to 7)
        constexpr uint32_t DPFSA2 = (1U << 2);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 0 to 7)
        constexpr uint32_t DPFSA3 = (1U << 3);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 0 to 7)
        constexpr uint32_t DPFSA4 = (1U << 4);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 0 to 7)
        constexpr uint32_t DPFSA5 = (1U << 5);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 0 to 7)
        constexpr uint32_t DPFSA6 = (1U << 6);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 0 to 7)
        constexpr uint32_t DPFSA7 = (1U << 7);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 0 to 7)
        constexpr uint32_t DPFSA08 = (1U << 8);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 8 to 15)
        constexpr uint32_t DPFSA09 = (1U << 9);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 8 to 15)
        constexpr uint32_t DPFSA10 = (1U << 10);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 8 to 15)
        constexpr uint32_t DPFSA11 = (1U << 11);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 8 to 15)
        constexpr uint32_t DPFSA12 = (1U << 12);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 8 to 15)
        constexpr uint32_t DPFSA13 = (1U << 13);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 8 to 15)
        constexpr uint32_t DPFSA14 = (1U << 14);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 8 to 15)
        constexpr uint32_t DPFSA15 = (1U << 15);  ///< Deep Software Standby Interrupt Factor Security Attribute bit n (n = 8 to 15)
        constexpr uint32_t DPFSA16 = (1U << 16);  ///< Deep Software Standby Interrupt Factor Security Attribute bit 16
        constexpr uint32_t DPFSA17 = (1U << 17);  ///< Deep Software Standby Interrupt Factor Security Attribute bit 17
        constexpr uint32_t DPFSA18 = (1U << 18);  ///< Deep Software Standby Interrupt Factor Security Attribute bit 18
        constexpr uint32_t DPFSA19 = (1U << 19);  ///< Deep Software Standby Interrupt Factor Security Attribute bit 19
        constexpr uint32_t DPFSA20 = (1U << 20);  ///< Deep Software Standby Interrupt Factor Security Attribute bit 20
        constexpr uint32_t DPFSA24 = (1U << 24);  ///< Deep Software Standby Interrupt Factor Security Attribute bit 24
        constexpr uint32_t DPFSA26 = (1U << 26);  ///< Deep Software Standby Interrupt Factor Security Attribute bit 26
        constexpr uint32_t DPFSA27 = (1U << 27);  ///< Deep Software Standby Interrupt Factor Security Attribute bit 27
    }

    /// PRCR Register bits
    namespace prcr_bits {
        constexpr uint32_t PRC0 = (1U << 0);  ///< Enable writing to the registers related to the clock generation circuit
        constexpr uint32_t PRC1 = (1U << 1);  ///< Enable writing to the registers related to the low power modes, and the battery backup function
        constexpr uint32_t PRC3 = (1U << 3);  ///< Enable writing to the registers related to the LVD
        constexpr uint32_t PRC4 = (1U << 4);  ///< Disable writes
        constexpr uint32_t PRKEY = (8 << 8);  ///< PRC Key Code
    }

    /// DPSBYCR Register bits
    namespace dpsbycr_bits {
        constexpr uint32_t DEEPCUT = (2 << 0);  ///< Power-Supply Control
        constexpr uint32_t IOKEEP = (1U << 6);  ///< I/O Port Rentention
        constexpr uint32_t DPSBY = (1U << 7);  ///< Deep Software Standby
    }

    /// DPSWCR Register bits
    namespace dpswcr_bits {
        constexpr uint32_t WTSTS = (6 << 0);  ///< Deep Software Wait Standby Time Setting Bit
    }

    /// DPSIER0 Register bits
    namespace dpsier0_bits {
        constexpr uint32_t DIRQ0E = (1U << 0);  ///< IRQ0-DS Pin Enable
        constexpr uint32_t DIRQ1E = (1U << 1);  ///< IRQ1-DS Pin Enable
        constexpr uint32_t DIRQ2E = (1U << 2);  ///< IRQ2-DS Pin Enable
        constexpr uint32_t DIRQ3E = (1U << 3);  ///< IRQ3-DS Pin Enable
        constexpr uint32_t DIRQ4E = (1U << 4);  ///< IRQ4-DS Pin Enable
        constexpr uint32_t DIRQ5E = (1U << 5);  ///< IRQ5-DS Pin Enable
        constexpr uint32_t DIRQ6E = (1U << 6);  ///< IRQ6-DS Pin Enable
        constexpr uint32_t DIRQ7E = (1U << 7);  ///< IRQ7-DS Pin Enable
    }

    /// DPSIER1 Register bits
    namespace dpsier1_bits {
        constexpr uint32_t DIRQ8E = (1U << 0);  ///< IRQ8-DS Pin Enable
        constexpr uint32_t DIRQ9E = (1U << 1);  ///< IRQ9-DS Pin Enable
        constexpr uint32_t DIRQ10E = (1U << 2);  ///< IRQ10-DS Pin Enable
        constexpr uint32_t DIRQ11E = (1U << 3);  ///< IRQ11-DS Pin Enable
        constexpr uint32_t DIRQ12E = (1U << 4);  ///< IRQ12-DS Pin Enable
        constexpr uint32_t DIRQ13E = (1U << 5);  ///< IRQ13-DS Pin Enable
        constexpr uint32_t DIRQ14E = (1U << 6);  ///< IRQ14-DS Pin Enable
        constexpr uint32_t DIRQ15E = (1U << 7);  ///< IRQ15-DS Pin Enable
    }

    /// DPSIER2 Register bits
    namespace dpsier2_bits {
        constexpr uint32_t DLVD1IE = (1U << 0);  ///< LVD1 Deep Software Standby Cancel Signal Enable
        constexpr uint32_t DLVD2IE = (1U << 1);  ///< LVD2 Deep Software Standby Cancel Signal Enable
        constexpr uint32_t DRTCIIE = (1U << 2);  ///< RTC Interval interrupt Deep Software Standby Cancel Signal Enable
        constexpr uint32_t DRTCAIE = (1U << 3);  ///< RTC Alarm interrupt Deep Software Standby Cancel Signal Enable
        constexpr uint32_t DNMIE = (1U << 4);  ///< NMI Pin Enable
    }

    /// DPSIER3 Register bits
    namespace dpsier3_bits {
        constexpr uint32_t DUSBFS0IE = (1U << 0);  ///< USBFS0 Suspend/Resume Deep Software Standby Cancel Signal Enable
        constexpr uint32_t DAGT1IE = (1U << 2);  ///< AGT1 Underflow Deep Software Standby Cancel Signal Enable
        constexpr uint32_t DAGT3IE = (1U << 3);  ///< AGT3 Underflow Deep Software Standby Cancel Signal Enable
    }

    /// DPSIFR0 Register bits
    namespace dpsifr0_bits {
        constexpr uint32_t DIRQ0F = (1U << 0);  ///< IRQ0-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ1F = (1U << 1);  ///< IRQ1-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ2F = (1U << 2);  ///< IRQ2-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ3F = (1U << 3);  ///< IRQ3-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ4F = (1U << 4);  ///< IRQ4-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ5F = (1U << 5);  ///< IRQ5-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ6F = (1U << 6);  ///< IRQ6-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ7F = (1U << 7);  ///< IRQ7-DS Pin Deep Software Standby Cancel Flag
    }

    /// DPSIFR1 Register bits
    namespace dpsifr1_bits {
        constexpr uint32_t DIRQ8F = (1U << 0);  ///< IRQ8-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ9F = (1U << 1);  ///< IRQ9-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ10F = (1U << 2);  ///< IRQ10-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ11F = (1U << 3);  ///< IRQ11-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ12F = (1U << 4);  ///< IRQ12-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ13F = (1U << 5);  ///< IRQ13-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ14F = (1U << 6);  ///< IRQ14-DS Pin Deep Software Standby Cancel Flag
        constexpr uint32_t DIRQ15F = (1U << 7);  ///< IRQ15-DS Pin Deep Software Standby Cancel Flag
    }

    /// DPSIFR2 Register bits
    namespace dpsifr2_bits {
        constexpr uint32_t DLVD1IF = (1U << 0);  ///< LVD1 Deep Software Standby Cancel Flag
        constexpr uint32_t DLVD2IF = (1U << 1);  ///< LVD2 Deep Software Standby Cancel Flag
        constexpr uint32_t DRTCIIF = (1U << 2);  ///< RTC Interval Interrupt Deep Software Standby Cancel Flag
        constexpr uint32_t DRTCAIF = (1U << 3);  ///< RTC Alarm Interrupt Deep Software Standby Cancel Flag
        constexpr uint32_t DNMIF = (1U << 4);  ///< NMI Pin Deep Software Standby Cancel Flag
    }

    /// DPSIFR3 Register bits
    namespace dpsifr3_bits {
        constexpr uint32_t DUSBFS0IF = (1U << 0);  ///< USBFS0 Suspend/Resume Deep Software Standby Cancel Flag
        constexpr uint32_t DAGT1IF = (1U << 2);  ///< AGT1 Underflow Deep Software Standby Cancel Flag
        constexpr uint32_t DAGT3IF = (1U << 3);  ///< AGT3 Underflow Deep Software Standby Cancel Flag
    }

    /// DPSIEGR0 Register bits
    namespace dpsiegr0_bits {
        constexpr uint32_t DIRQ0EG = (1U << 0);  ///< IRQ0-DS Pin Edge Select
        constexpr uint32_t DIRQ1EG = (1U << 1);  ///< IRQ1-DS Pin Edge Select
        constexpr uint32_t DIRQ2EG = (1U << 2);  ///< IRQ2-DS Pin Edge Select
        constexpr uint32_t DIRQ3EG = (1U << 3);  ///< IRQ3-DS Pin Edge Select
        constexpr uint32_t DIRQ4EG = (1U << 4);  ///< IRQ4-DS Pin Edge Select
        constexpr uint32_t DIRQ5EG = (1U << 5);  ///< IRQ5-DS Pin Edge Select
        constexpr uint32_t DIRQ6EG = (1U << 6);  ///< IRQ6-DS Pin Edge Select
        constexpr uint32_t DIRQ7EG = (1U << 7);  ///< IRQ7-DS Pin Edge Select
    }

    /// DPSIEGR1 Register bits
    namespace dpsiegr1_bits {
        constexpr uint32_t DIRQ8EG = (1U << 0);  ///< IRQ8-DS Pin Edge Select
        constexpr uint32_t DIRQ9EG = (1U << 1);  ///< IRQ9-DS Pin Edge Select
        constexpr uint32_t DIRQ10EG = (1U << 2);  ///< IRQ10-DS Pin Edge Select
        constexpr uint32_t DIRQ11EG = (1U << 3);  ///< IRQ11-DS Pin Edge Select
        constexpr uint32_t DIRQ12EG = (1U << 4);  ///< IRQ12-DS Pin Edge Select
        constexpr uint32_t DIRQ13EG = (1U << 5);  ///< IRQ13-DS Pin Edge Select
        constexpr uint32_t DIRQ14EG = (1U << 6);  ///< IRQ14-DS Pin Edge Select
        constexpr uint32_t DIRQ15EG = (1U << 7);  ///< IRQ15-DS Pin Edge Select
    }

    /// DPSIEGR2 Register bits
    namespace dpsiegr2_bits {
        constexpr uint32_t DLVD1EG = (1U << 0);  ///< LVD1 Edge Select
        constexpr uint32_t DLVD2EG = (1U << 1);  ///< LVD2 Edge Select
        constexpr uint32_t DNMIEG = (1U << 4);  ///< NMI Pin Edge Select
    }

    /// SYOCDCR Register bits
    namespace syocdcr_bits {
        constexpr uint32_t DOCDF = (1U << 0);  ///< Deep Software Standby OCD flag
        constexpr uint32_t DBGEN = (1U << 7);  ///< Debugger Enable bit
    }

    /// RSTSR0 Register bits
    namespace rstsr0_bits {
        constexpr uint32_t PORF = (1U << 0);  ///< Power-On Reset Detect Flag
        constexpr uint32_t LVD0RF = (1U << 1);  ///< Voltage Monitor 0 Reset Detect Flag
        constexpr uint32_t LVD1RF = (1U << 2);  ///< Voltage Monitor 1 Reset Detect Flag
        constexpr uint32_t LVD2RF = (1U << 3);  ///< Voltage Monitor 2 Reset Detect Flag
        constexpr uint32_t DPSRSTF = (1U << 7);  ///< Deep Software Standby Reset Detect Flag
    }

    /// RSTSR2 Register bits
    namespace rstsr2_bits {
        constexpr uint32_t CWSF = (1U << 0);  ///< Cold/Warm Start Determination Flag
    }

    /// MOMCR Register bits
    namespace momcr_bits {
        constexpr uint32_t MODRV = (2 << 4);  ///< Main Clock Oscillator Drive Capability 0 Switching
        constexpr uint32_t MOSEL = (1U << 6);  ///< Main Clock Oscillator Switching
    }

    /// FWEPROR Register bits
    namespace fwepror_bits {
        constexpr uint32_t FLWE = (2 << 0);  ///< Flash Programming and Erasure
    }

    /// LVD1CMPCR Register bits
    namespace lvd1cmpcr_bits {
        constexpr uint32_t LVD1LVL = (5 << 0);  ///< Voltage Detection 1 Level Select (Standard voltage during drop in voltage)
        constexpr uint32_t LVD1E = (1U << 7);  ///< Voltage Detection 1 Enable
    }

    /// LVD2CMPCR Register bits
    namespace lvd2cmpcr_bits {
        constexpr uint32_t LVD2LVL = (3 << 0);  ///< Voltage Detection 2 Level Select (Standard voltage during drop in voltage)
        constexpr uint32_t LVD2E = (1U << 7);  ///< Voltage Detection 2 Enable
    }

    /// LVD1CR0 Register bits
    namespace lvd1cr0_bits {
        constexpr uint32_t RIE = (1U << 0);  ///< Voltage Monitor 1 Interrupt/Reset Enable
        constexpr uint32_t DFDIS = (1U << 1);  ///< Voltage monitor 1 Digital Filter Disabled Mode Select
        constexpr uint32_t CMPE = (1U << 2);  ///< Voltage Monitor 1 Circuit Comparison Result Output Enable
        constexpr uint32_t FSAMP = (2 << 4);  ///< Sampling Clock Select
        constexpr uint32_t RI = (1U << 6);  ///< Voltage Monitor 1 Circuit Mode Select
        constexpr uint32_t RN = (1U << 7);  ///< Voltage Monitor 1 Reset Negate Select
    }

    /// LVD2CR0 Register bits
    namespace lvd2cr0_bits {
        constexpr uint32_t RIE = (1U << 0);  ///< Voltage Monitor 2 Interrupt/Reset Enable
        constexpr uint32_t DFDIS = (1U << 1);  ///< Voltage monitor 2 Digital Filter Disabled Mode Select
        constexpr uint32_t CMPE = (1U << 2);  ///< Voltage Monitor 2 Circuit Comparison Result Output Enable
        constexpr uint32_t FSAMP = (2 << 4);  ///< Sampling Clock Select
        constexpr uint32_t RI = (1U << 6);  ///< Voltage Monitor 2 Circuit Mode Select
        constexpr uint32_t RN = (1U << 7);  ///< Voltage Monitor 2 Reset Negate Select
    }

    /// VBATTMNSELR Register bits
    namespace vbattmnselr_bits {
        constexpr uint32_t VBATTMNSEL = (1U << 0);  ///< VBATT Low Voltage Detect Function Select Bit
    }

    /// VBATTMONR Register bits
    namespace vbattmonr_bits {
        constexpr uint32_t VBATTMON = (1U << 0);  ///< VBATT Voltage Monitor Bit
    }

    /// SOSCCR Register bits
    namespace sosccr_bits {
        constexpr uint32_t SOSTP = (1U << 0);  ///< Sub Clock Oscillator Stop
    }

    /// SOMCR Register bits
    namespace somcr_bits {
        constexpr uint32_t SODRV = (1U << 1);  ///< Sub-Clock Oscillator Drive Capability Switching
    }

    /// LOCOCR Register bits
    namespace lococr_bits {
        constexpr uint32_t LCSTP = (1U << 0);  ///< LOCO Stop
    }

    /// LOCOUTCR Register bits
    namespace locoutcr_bits {
        constexpr uint32_t LOCOUTRM = (8 << 0);  ///< LOCO User Trimming
    }

    /// VBTICTLR Register bits
    namespace vbtictlr_bits {
        constexpr uint32_t VCH0INEN = (1U << 0);  ///< VBATT CH0 Input Enable
        constexpr uint32_t VCH1INEN = (1U << 1);  ///< VBATT CH1 Input Enable
        constexpr uint32_t VCH2INEN = (1U << 2);  ///< VBATT CH2 Input Enable
    }

    /// VBTBER Register bits
    namespace vbtber_bits {
        constexpr uint32_t VBAE = (1U << 3);  ///< VBATT backup register access enable bit
    }

    /// VBTBKR[%s] Register bits
    namespace vbtbkr[%s]_bits {
        constexpr uint32_t VBTBKR = (8 << 0);  ///< VBATT Backup Register
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT0_BASE = 0x40080000;
    constexpr uint32_t PORT1_BASE = 0x40080020;
    constexpr uint32_t PORT2_BASE = 0x40080040;
    constexpr uint32_t PORT3_BASE = 0x40080060;
    constexpr uint32_t PORT4_BASE = 0x40080080;
    constexpr uint32_t PORT5_BASE = 0x400800A0;
    constexpr uint32_t PORT6_BASE = 0x400800C0;
    constexpr uint32_t PORT7_BASE = 0x400800E0;
    constexpr uint32_t PORT8_BASE = 0x40080100;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCNTR1;  ///< Offset: 0x00 - Port Control Register 1
        volatile uint32_t PODR;  ///< Offset: 0x00 - Port Control Register 1
        volatile uint32_t PDR;  ///< Offset: 0x02 - Port Control Register 1
        volatile uint32_t PCNTR2;  ///< Offset: 0x04 - Port Control Register 2
        volatile uint32_t PIDR;  ///< Offset: 0x06 - Port Control Register 2
        volatile uint32_t PCNTR3;  ///< Offset: 0x08 - Port Control Register 3
        volatile uint32_t PORR;  ///< Offset: 0x08 - Port Control Register 3
        volatile uint32_t POSR;  ///< Offset: 0x0A - Port Control Register 3
    };

    /// Peripheral instances
    inline Registers* PORT0 = reinterpret_cast<Registers*>(PORT0_BASE);
    inline Registers* PORT1 = reinterpret_cast<Registers*>(PORT1_BASE);
    inline Registers* PORT2 = reinterpret_cast<Registers*>(PORT2_BASE);
    inline Registers* PORT3 = reinterpret_cast<Registers*>(PORT3_BASE);
    inline Registers* PORT4 = reinterpret_cast<Registers*>(PORT4_BASE);
    inline Registers* PORT5 = reinterpret_cast<Registers*>(PORT5_BASE);
    inline Registers* PORT6 = reinterpret_cast<Registers*>(PORT6_BASE);
    inline Registers* PORT7 = reinterpret_cast<Registers*>(PORT7_BASE);
    inline Registers* PORT8 = reinterpret_cast<Registers*>(PORT8_BASE);

    // Bit definitions
    /// PCNTR1 Register bits
    namespace pcntr1_bits {
        constexpr uint32_t PDR00 = (1U << 0);  ///< Pmn Direction
        constexpr uint32_t PDR01 = (1U << 1);  ///< Pmn Direction
        constexpr uint32_t PDR02 = (1U << 2);  ///< Pmn Direction
        constexpr uint32_t PDR03 = (1U << 3);  ///< Pmn Direction
        constexpr uint32_t PDR04 = (1U << 4);  ///< Pmn Direction
        constexpr uint32_t PDR05 = (1U << 5);  ///< Pmn Direction
        constexpr uint32_t PDR06 = (1U << 6);  ///< Pmn Direction
        constexpr uint32_t PDR07 = (1U << 7);  ///< Pmn Direction
        constexpr uint32_t PDR08 = (1U << 8);  ///< Pmn Direction
        constexpr uint32_t PDR09 = (1U << 9);  ///< Pmn Direction
        constexpr uint32_t PDR10 = (1U << 10);  ///< Pmn Direction
        constexpr uint32_t PDR11 = (1U << 11);  ///< Pmn Direction
        constexpr uint32_t PDR12 = (1U << 12);  ///< Pmn Direction
        constexpr uint32_t PDR13 = (1U << 13);  ///< Pmn Direction
        constexpr uint32_t PDR14 = (1U << 14);  ///< Pmn Direction
        constexpr uint32_t PDR15 = (1U << 15);  ///< Pmn Direction
        constexpr uint32_t PODR00 = (1U << 16);  ///< Pmn Output Data
        constexpr uint32_t PODR01 = (1U << 17);  ///< Pmn Output Data
        constexpr uint32_t PODR02 = (1U << 18);  ///< Pmn Output Data
        constexpr uint32_t PODR03 = (1U << 19);  ///< Pmn Output Data
        constexpr uint32_t PODR04 = (1U << 20);  ///< Pmn Output Data
        constexpr uint32_t PODR05 = (1U << 21);  ///< Pmn Output Data
        constexpr uint32_t PODR06 = (1U << 22);  ///< Pmn Output Data
        constexpr uint32_t PODR07 = (1U << 23);  ///< Pmn Output Data
        constexpr uint32_t PODR08 = (1U << 24);  ///< Pmn Output Data
        constexpr uint32_t PODR09 = (1U << 25);  ///< Pmn Output Data
        constexpr uint32_t PODR10 = (1U << 26);  ///< Pmn Output Data
        constexpr uint32_t PODR11 = (1U << 27);  ///< Pmn Output Data
        constexpr uint32_t PODR12 = (1U << 28);  ///< Pmn Output Data
        constexpr uint32_t PODR13 = (1U << 29);  ///< Pmn Output Data
        constexpr uint32_t PODR14 = (1U << 30);  ///< Pmn Output Data
        constexpr uint32_t PODR15 = (1U << 31);  ///< Pmn Output Data
    }

    /// PODR Register bits
    namespace podr_bits {
        constexpr uint32_t PODR00 = (1U << 0);  ///< Pmn Output Data
        constexpr uint32_t PODR01 = (1U << 1);  ///< Pmn Output Data
        constexpr uint32_t PODR02 = (1U << 2);  ///< Pmn Output Data
        constexpr uint32_t PODR03 = (1U << 3);  ///< Pmn Output Data
        constexpr uint32_t PODR04 = (1U << 4);  ///< Pmn Output Data
        constexpr uint32_t PODR05 = (1U << 5);  ///< Pmn Output Data
        constexpr uint32_t PODR06 = (1U << 6);  ///< Pmn Output Data
        constexpr uint32_t PODR07 = (1U << 7);  ///< Pmn Output Data
        constexpr uint32_t PODR08 = (1U << 8);  ///< Pmn Output Data
        constexpr uint32_t PODR09 = (1U << 9);  ///< Pmn Output Data
        constexpr uint32_t PODR10 = (1U << 10);  ///< Pmn Output Data
        constexpr uint32_t PODR11 = (1U << 11);  ///< Pmn Output Data
        constexpr uint32_t PODR12 = (1U << 12);  ///< Pmn Output Data
        constexpr uint32_t PODR13 = (1U << 13);  ///< Pmn Output Data
        constexpr uint32_t PODR14 = (1U << 14);  ///< Pmn Output Data
        constexpr uint32_t PODR15 = (1U << 15);  ///< Pmn Output Data
    }

    /// PDR Register bits
    namespace pdr_bits {
        constexpr uint32_t PDR00 = (1U << 0);  ///< Pmn Direction
        constexpr uint32_t PDR01 = (1U << 1);  ///< Pmn Direction
        constexpr uint32_t PDR02 = (1U << 2);  ///< Pmn Direction
        constexpr uint32_t PDR03 = (1U << 3);  ///< Pmn Direction
        constexpr uint32_t PDR04 = (1U << 4);  ///< Pmn Direction
        constexpr uint32_t PDR05 = (1U << 5);  ///< Pmn Direction
        constexpr uint32_t PDR06 = (1U << 6);  ///< Pmn Direction
        constexpr uint32_t PDR07 = (1U << 7);  ///< Pmn Direction
        constexpr uint32_t PDR08 = (1U << 8);  ///< Pmn Direction
        constexpr uint32_t PDR09 = (1U << 9);  ///< Pmn Direction
        constexpr uint32_t PDR10 = (1U << 10);  ///< Pmn Direction
        constexpr uint32_t PDR11 = (1U << 11);  ///< Pmn Direction
        constexpr uint32_t PDR12 = (1U << 12);  ///< Pmn Direction
        constexpr uint32_t PDR13 = (1U << 13);  ///< Pmn Direction
        constexpr uint32_t PDR14 = (1U << 14);  ///< Pmn Direction
        constexpr uint32_t PDR15 = (1U << 15);  ///< Pmn Direction
    }

    /// PCNTR2 Register bits
    namespace pcntr2_bits {
        constexpr uint32_t PIDR00 = (1U << 0);  ///< Pmn State
        constexpr uint32_t PIDR01 = (1U << 1);  ///< Pmn State
        constexpr uint32_t PIDR02 = (1U << 2);  ///< Pmn State
        constexpr uint32_t PIDR03 = (1U << 3);  ///< Pmn State
        constexpr uint32_t PIDR04 = (1U << 4);  ///< Pmn State
        constexpr uint32_t PIDR05 = (1U << 5);  ///< Pmn State
        constexpr uint32_t PIDR06 = (1U << 6);  ///< Pmn State
        constexpr uint32_t PIDR07 = (1U << 7);  ///< Pmn State
        constexpr uint32_t PIDR08 = (1U << 8);  ///< Pmn State
        constexpr uint32_t PIDR09 = (1U << 9);  ///< Pmn State
        constexpr uint32_t PIDR10 = (1U << 10);  ///< Pmn State
        constexpr uint32_t PIDR11 = (1U << 11);  ///< Pmn State
        constexpr uint32_t PIDR12 = (1U << 12);  ///< Pmn State
        constexpr uint32_t PIDR13 = (1U << 13);  ///< Pmn State
        constexpr uint32_t PIDR14 = (1U << 14);  ///< Pmn State
        constexpr uint32_t PIDR15 = (1U << 15);  ///< Pmn State
    }

    /// PIDR Register bits
    namespace pidr_bits {
        constexpr uint32_t PIDR00 = (1U << 0);  ///< Pmn State
        constexpr uint32_t PIDR01 = (1U << 1);  ///< Pmn State
        constexpr uint32_t PIDR02 = (1U << 2);  ///< Pmn State
        constexpr uint32_t PIDR03 = (1U << 3);  ///< Pmn State
        constexpr uint32_t PIDR04 = (1U << 4);  ///< Pmn State
        constexpr uint32_t PIDR05 = (1U << 5);  ///< Pmn State
        constexpr uint32_t PIDR06 = (1U << 6);  ///< Pmn State
        constexpr uint32_t PIDR07 = (1U << 7);  ///< Pmn State
        constexpr uint32_t PIDR08 = (1U << 8);  ///< Pmn State
        constexpr uint32_t PIDR09 = (1U << 9);  ///< Pmn State
        constexpr uint32_t PIDR10 = (1U << 10);  ///< Pmn State
        constexpr uint32_t PIDR11 = (1U << 11);  ///< Pmn State
        constexpr uint32_t PIDR12 = (1U << 12);  ///< Pmn State
        constexpr uint32_t PIDR13 = (1U << 13);  ///< Pmn State
        constexpr uint32_t PIDR14 = (1U << 14);  ///< Pmn State
        constexpr uint32_t PIDR15 = (1U << 15);  ///< Pmn State
    }

    /// PCNTR3 Register bits
    namespace pcntr3_bits {
        constexpr uint32_t POSR00 = (1U << 0);  ///< Pmn Output Set
        constexpr uint32_t POSR01 = (1U << 1);  ///< Pmn Output Set
        constexpr uint32_t POSR02 = (1U << 2);  ///< Pmn Output Set
        constexpr uint32_t POSR03 = (1U << 3);  ///< Pmn Output Set
        constexpr uint32_t POSR04 = (1U << 4);  ///< Pmn Output Set
        constexpr uint32_t POSR05 = (1U << 5);  ///< Pmn Output Set
        constexpr uint32_t POSR06 = (1U << 6);  ///< Pmn Output Set
        constexpr uint32_t POSR07 = (1U << 7);  ///< Pmn Output Set
        constexpr uint32_t POSR08 = (1U << 8);  ///< Pmn Output Set
        constexpr uint32_t POSR09 = (1U << 9);  ///< Pmn Output Set
        constexpr uint32_t POSR10 = (1U << 10);  ///< Pmn Output Set
        constexpr uint32_t POSR11 = (1U << 11);  ///< Pmn Output Set
        constexpr uint32_t POSR12 = (1U << 12);  ///< Pmn Output Set
        constexpr uint32_t POSR13 = (1U << 13);  ///< Pmn Output Set
        constexpr uint32_t POSR14 = (1U << 14);  ///< Pmn Output Set
        constexpr uint32_t POSR15 = (1U << 15);  ///< Pmn Output Set
        constexpr uint32_t PORR00 = (1U << 16);  ///< Pmn Output Reset
        constexpr uint32_t PORR01 = (1U << 17);  ///< Pmn Output Reset
        constexpr uint32_t PORR02 = (1U << 18);  ///< Pmn Output Reset
        constexpr uint32_t PORR03 = (1U << 19);  ///< Pmn Output Reset
        constexpr uint32_t PORR04 = (1U << 20);  ///< Pmn Output Reset
        constexpr uint32_t PORR05 = (1U << 21);  ///< Pmn Output Reset
        constexpr uint32_t PORR06 = (1U << 22);  ///< Pmn Output Reset
        constexpr uint32_t PORR07 = (1U << 23);  ///< Pmn Output Reset
        constexpr uint32_t PORR08 = (1U << 24);  ///< Pmn Output Reset
        constexpr uint32_t PORR09 = (1U << 25);  ///< Pmn Output Reset
        constexpr uint32_t PORR10 = (1U << 26);  ///< Pmn Output Reset
        constexpr uint32_t PORR11 = (1U << 27);  ///< Pmn Output Reset
        constexpr uint32_t PORR12 = (1U << 28);  ///< Pmn Output Reset
        constexpr uint32_t PORR13 = (1U << 29);  ///< Pmn Output Reset
        constexpr uint32_t PORR14 = (1U << 30);  ///< Pmn Output Reset
        constexpr uint32_t PORR15 = (1U << 31);  ///< Pmn Output Reset
    }

    /// PORR Register bits
    namespace porr_bits {
        constexpr uint32_t PORR00 = (1U << 0);  ///< Pmn Output Reset
        constexpr uint32_t PORR01 = (1U << 1);  ///< Pmn Output Reset
        constexpr uint32_t PORR02 = (1U << 2);  ///< Pmn Output Reset
        constexpr uint32_t PORR03 = (1U << 3);  ///< Pmn Output Reset
        constexpr uint32_t PORR04 = (1U << 4);  ///< Pmn Output Reset
        constexpr uint32_t PORR05 = (1U << 5);  ///< Pmn Output Reset
        constexpr uint32_t PORR06 = (1U << 6);  ///< Pmn Output Reset
        constexpr uint32_t PORR07 = (1U << 7);  ///< Pmn Output Reset
        constexpr uint32_t PORR08 = (1U << 8);  ///< Pmn Output Reset
        constexpr uint32_t PORR09 = (1U << 9);  ///< Pmn Output Reset
        constexpr uint32_t PORR10 = (1U << 10);  ///< Pmn Output Reset
        constexpr uint32_t PORR11 = (1U << 11);  ///< Pmn Output Reset
        constexpr uint32_t PORR12 = (1U << 12);  ///< Pmn Output Reset
        constexpr uint32_t PORR13 = (1U << 13);  ///< Pmn Output Reset
        constexpr uint32_t PORR14 = (1U << 14);  ///< Pmn Output Reset
        constexpr uint32_t PORR15 = (1U << 15);  ///< Pmn Output Reset
    }

    /// POSR Register bits
    namespace posr_bits {
        constexpr uint32_t POSR00 = (1U << 0);  ///< Pmn Output Set
        constexpr uint32_t POSR01 = (1U << 1);  ///< Pmn Output Set
        constexpr uint32_t POSR02 = (1U << 2);  ///< Pmn Output Set
        constexpr uint32_t POSR03 = (1U << 3);  ///< Pmn Output Set
        constexpr uint32_t POSR04 = (1U << 4);  ///< Pmn Output Set
        constexpr uint32_t POSR05 = (1U << 5);  ///< Pmn Output Set
        constexpr uint32_t POSR06 = (1U << 6);  ///< Pmn Output Set
        constexpr uint32_t POSR07 = (1U << 7);  ///< Pmn Output Set
        constexpr uint32_t POSR08 = (1U << 8);  ///< Pmn Output Set
        constexpr uint32_t POSR09 = (1U << 9);  ///< Pmn Output Set
        constexpr uint32_t POSR10 = (1U << 10);  ///< Pmn Output Set
        constexpr uint32_t POSR11 = (1U << 11);  ///< Pmn Output Set
        constexpr uint32_t POSR12 = (1U << 12);  ///< Pmn Output Set
        constexpr uint32_t POSR13 = (1U << 13);  ///< Pmn Output Set
        constexpr uint32_t POSR14 = (1U << 14);  ///< Pmn Output Set
        constexpr uint32_t POSR15 = (1U << 15);  ///< Pmn Output Set
    }

}

// ============================================================================
// PFS Peripheral
// ============================================================================

namespace pfs {
    /// Base addresses
    constexpr uint32_t PFS_BASE = 0x40080800;

    /// PFS Register structure
    struct Registers {
        volatile uint32_t P00%sPFS;  ///< Offset: 0x00 - Port 00%s Pin Function Select Register
        volatile uint32_t P00%sPFS_HA;  ///< Offset: 0x02 - Port 00%s Pin Function Select Register
        volatile uint32_t P00%sPFS_BY;  ///< Offset: 0x03 - Port 00%s Pin Function Select Register
        volatile uint32_t P008PFS;  ///< Offset: 0x20 - Port 008 Pin Function Select Register
        volatile uint32_t P008PFS_HA;  ///< Offset: 0x22 - Port 008 Pin Function Select Register
        volatile uint32_t P008PFS_BY;  ///< Offset: 0x23 - Port 008 Pin Function Select Register
        volatile uint32_t P009PFS;  ///< Offset: 0x24 - Port 009 Pin Function Select Register
        volatile uint32_t P009PFS_HA;  ///< Offset: 0x26 - Port 009 Pin Function Select Register
        volatile uint32_t P009PFS_BY;  ///< Offset: 0x27 - Port 009 Pin Function Select Register
        volatile uint32_t P0%sPFS;  ///< Offset: 0x38 - Port 0%s Pin Function Select Register
        volatile uint32_t P0%sPFS_HA;  ///< Offset: 0x3A - Port 0%s Pin Function Select Register
        volatile uint32_t P0%sPFS_BY;  ///< Offset: 0x3B - Port 0%s Pin Function Select Register
        volatile uint32_t P10%sPFS;  ///< Offset: 0x40 - Port 10%s Pin Function Select Register
        volatile uint32_t P10%sPFS_HA;  ///< Offset: 0x42 - Port 10%s Pin Function Select Register
        volatile uint32_t P10%sPFS_BY;  ///< Offset: 0x43 - Port 10%s Pin Function Select Register
        volatile uint32_t P1%sPFS;  ///< Offset: 0x68 - Port 1%s Pin Function Select Register
        volatile uint32_t P1%sPFS_HA;  ///< Offset: 0x6A - Port 1%s Pin Function Select Register
        volatile uint32_t P1%sPFS_BY;  ///< Offset: 0x6B - Port 1%s Pin Function Select Register
        volatile uint32_t P200PFS;  ///< Offset: 0x80 - Port 200 Pin Function Select Register
        volatile uint32_t P200PFS_HA;  ///< Offset: 0x82 - Port 200 Pin Function Select Register
        volatile uint32_t P200PFS_BY;  ///< Offset: 0x83 - Port 200 Pin Function Select Register
        volatile uint32_t P201PFS;  ///< Offset: 0x84 - Port 201 Pin Function Select Register
        volatile uint32_t P201PFS_HA;  ///< Offset: 0x86 - Port 201 Pin Function Select Register
        volatile uint32_t P201PFS_BY;  ///< Offset: 0x87 - Port 201 Pin Function Select Register
        volatile uint32_t P20%sPFS;  ///< Offset: 0x88 - Port 20%s Pin Function Select Register
        volatile uint32_t P20%sPFS_HA;  ///< Offset: 0x8A - Port 20%s Pin Function Select Register
        volatile uint32_t P20%sPFS_BY;  ///< Offset: 0x8B - Port 20%s Pin Function Select Register
        volatile uint32_t P2%sPFS;  ///< Offset: 0xA8 - Port 2%s Pin Function Select Register
        volatile uint32_t P2%sPFS_HA;  ///< Offset: 0xAA - Port 2%s Pin Function Select Register
        volatile uint32_t P2%sPFS_BY;  ///< Offset: 0xAB - Port 2%s Pin Function Select Register
        volatile uint32_t P300PFS;  ///< Offset: 0xC0 - Port 300 Pin Function Select Register
        volatile uint32_t P300PFS_HA;  ///< Offset: 0xC2 - Port 300 Pin Function Select Register
        volatile uint32_t P300PFS_BY;  ///< Offset: 0xC3 - Port 300 Pin Function Select Register
        volatile uint32_t P30%sPFS;  ///< Offset: 0xC4 - Port 30%s Pin Function Select Register
        volatile uint32_t P30%sPFS_HA;  ///< Offset: 0xC6 - Port 30%s Pin Function Select Register
        volatile uint32_t P30%sPFS_BY;  ///< Offset: 0xC7 - Port 30%s Pin Function Select Register
        volatile uint32_t P3%sPFS;  ///< Offset: 0xE8 - Port 3%s Pin Function Select Register
        volatile uint32_t P3%sPFS_HA;  ///< Offset: 0xEA - Port 3%s Pin Function Select Register
        volatile uint32_t P3%sPFS_BY;  ///< Offset: 0xEB - Port 3%s Pin Function Select Register
        volatile uint32_t P40%sPFS;  ///< Offset: 0x100 - Port 40%s Pin Function Select Register
        volatile uint32_t P40%sPFS_HA;  ///< Offset: 0x102 - Port 40%s Pin Function Select Register
        volatile uint32_t P40%sPFS_BY;  ///< Offset: 0x103 - Port 40%s Pin Function Select Register
        volatile uint32_t P4%sPFS;  ///< Offset: 0x128 - Port 4%s Pin Function Select Register
        volatile uint32_t P4%sPFS_HA;  ///< Offset: 0x12A - Port 4%s Pin Function Select Register
        volatile uint32_t P4%sPFS_BY;  ///< Offset: 0x12B - Port 4%s Pin Function Select Register
        volatile uint32_t P50%sPFS;  ///< Offset: 0x140 - Port 50%s Pin Function Select Register
        volatile uint32_t P50%sPFS_HA;  ///< Offset: 0x142 - Port 50%s Pin Function Select Register
        volatile uint32_t P50%sPFS_BY;  ///< Offset: 0x143 - Port 50%s Pin Function Select Register
        volatile uint32_t P5%sPFS;  ///< Offset: 0x16C - Port 5%s Pin Function Select Register
        volatile uint32_t P5%sPFS_HA;  ///< Offset: 0x16E - Port 5%s Pin Function Select Register
        volatile uint32_t P5%sPFS_BY;  ///< Offset: 0x16F - Port 5%s Pin Function Select Register
        volatile uint32_t P60%sPFS;  ///< Offset: 0x1A0 - Port 60%s Pin Function Select Register
        volatile uint32_t P60%sPFS_HA;  ///< Offset: 0x1A2 - Port 60%s Pin Function Select Register
        volatile uint32_t P60%sPFS_BY;  ///< Offset: 0x1A3 - Port 60%s Pin Function Select Register
        volatile uint32_t P6%sPFS;  ///< Offset: 0x1A8 - Port 6%s Pin Function Select Register
        volatile uint32_t P6%sPFS_HA;  ///< Offset: 0x1AA - Port 6%s Pin Function Select Register
        volatile uint32_t P6%sPFS_BY;  ///< Offset: 0x1AB - Port 6%s Pin Function Select Register
        volatile uint32_t P70%sPFS;  ///< Offset: 0x1E0 - Port 70%s Pin Function Select Register
        volatile uint32_t P70%sPFS_HA;  ///< Offset: 0x1E2 - Port 70%s Pin Function Select Register
        volatile uint32_t P70%sPFS_BY;  ///< Offset: 0x1E3 - Port 70%s Pin Function Select Register
        volatile uint32_t P7%sPFS;  ///< Offset: 0x1E8 - Port 7%s Pin Function Select Register
        volatile uint32_t P7%sPFS_HA;  ///< Offset: 0x1EA - Port 7%s Pin Function Select Register
        volatile uint32_t P7%sPFS_BY;  ///< Offset: 0x1EB - Port 7%s Pin Function Select Register
        volatile uint32_t P80%sPFS;  ///< Offset: 0x200 - Port 80%s Pin Function Select Register
        volatile uint32_t P80%sPFS_HA;  ///< Offset: 0x202 - Port 80%s Pin Function Select Register
        volatile uint32_t P80%sPFS_BY;  ///< Offset: 0x203 - Port 80%s Pin Function Select Register
        volatile uint32_t PWPR;  ///< Offset: 0x503 - Write-Protect Register
        volatile uint32_t PWPRS;  ///< Offset: 0x505 - Write-Protect Register for Secure
        volatile uint32_t P%sSAR;  ///< Offset: 0x510 - Port Security Attribution register
    };

    /// Peripheral instances
    inline Registers* PFS = reinterpret_cast<Registers*>(PFS_BASE);

    // Bit definitions
    /// P00%sPFS Register bits
    namespace p00%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P00%sPFS_HA Register bits
    namespace p00%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P00%sPFS_BY Register bits
    namespace p00%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P008PFS Register bits
    namespace p008pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P008PFS_HA Register bits
    namespace p008pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P008PFS_BY Register bits
    namespace p008pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P009PFS Register bits
    namespace p009pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P009PFS_HA Register bits
    namespace p009pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P009PFS_BY Register bits
    namespace p009pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P0%sPFS Register bits
    namespace p0%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P0%sPFS_HA Register bits
    namespace p0%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P0%sPFS_BY Register bits
    namespace p0%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P10%sPFS Register bits
    namespace p10%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P10%sPFS_HA Register bits
    namespace p10%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P10%sPFS_BY Register bits
    namespace p10%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P1%sPFS Register bits
    namespace p1%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P1%sPFS_HA Register bits
    namespace p1%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P1%sPFS_BY Register bits
    namespace p1%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P200PFS Register bits
    namespace p200pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P200PFS_HA Register bits
    namespace p200pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P200PFS_BY Register bits
    namespace p200pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P201PFS Register bits
    namespace p201pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P201PFS_HA Register bits
    namespace p201pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P201PFS_BY Register bits
    namespace p201pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P20%sPFS Register bits
    namespace p20%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P20%sPFS_HA Register bits
    namespace p20%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P20%sPFS_BY Register bits
    namespace p20%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P2%sPFS Register bits
    namespace p2%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P2%sPFS_HA Register bits
    namespace p2%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P2%sPFS_BY Register bits
    namespace p2%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P300PFS Register bits
    namespace p300pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P300PFS_HA Register bits
    namespace p300pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P300PFS_BY Register bits
    namespace p300pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P30%sPFS Register bits
    namespace p30%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P30%sPFS_HA Register bits
    namespace p30%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P30%sPFS_BY Register bits
    namespace p30%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P3%sPFS Register bits
    namespace p3%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P3%sPFS_HA Register bits
    namespace p3%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P3%sPFS_BY Register bits
    namespace p3%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P40%sPFS Register bits
    namespace p40%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P40%sPFS_HA Register bits
    namespace p40%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P40%sPFS_BY Register bits
    namespace p40%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P4%sPFS Register bits
    namespace p4%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P4%sPFS_HA Register bits
    namespace p4%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P4%sPFS_BY Register bits
    namespace p4%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P50%sPFS Register bits
    namespace p50%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P50%sPFS_HA Register bits
    namespace p50%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P50%sPFS_BY Register bits
    namespace p50%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P5%sPFS Register bits
    namespace p5%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P5%sPFS_HA Register bits
    namespace p5%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P5%sPFS_BY Register bits
    namespace p5%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P60%sPFS Register bits
    namespace p60%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P60%sPFS_HA Register bits
    namespace p60%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P60%sPFS_BY Register bits
    namespace p60%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P6%sPFS Register bits
    namespace p6%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P6%sPFS_HA Register bits
    namespace p6%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P6%sPFS_BY Register bits
    namespace p6%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P70%sPFS Register bits
    namespace p70%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P70%sPFS_HA Register bits
    namespace p70%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P70%sPFS_BY Register bits
    namespace p70%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P7%sPFS Register bits
    namespace p7%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P7%sPFS_HA Register bits
    namespace p7%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P7%sPFS_BY Register bits
    namespace p7%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P80%sPFS Register bits
    namespace p80%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P80%sPFS_HA Register bits
    namespace p80%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P80%sPFS_BY Register bits
    namespace p80%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// PWPR Register bits
    namespace pwpr_bits {
        constexpr uint32_t PFSWE = (1U << 6);  ///< PmnPFS Register Write Enable
        constexpr uint32_t B0WI = (1U << 7);  ///< PFSWE Bit Write Disable
    }

    /// PWPRS Register bits
    namespace pwprs_bits {
        constexpr uint32_t PFSWE = (1U << 6);  ///< PmnPFS Register Write Enable
        constexpr uint32_t B0WI = (1U << 7);  ///< PFSWE Bit Write Disable
    }

    /// P%sSAR Register bits
    namespace p%ssar_bits {
        constexpr uint32_t PMNSA = (16 << 0);  ///< Pmn Security Attribution
    }

}

// ============================================================================
// ELC Peripheral
// ============================================================================

namespace elc {
    /// Base addresses
    constexpr uint32_t ELC_BASE = 0x40082000;

    /// ELC Register structure
    struct Registers {
        volatile uint32_t ELCR;  ///< Offset: 0x00 - Event Link Controller Register
        volatile uint32_t ELSEGR%s;  ///< Offset: 0x02 - Event Link Software Event Generation Register %s
        volatile uint32_t ELSR%s;  ///< Offset: 0x10 - Event Link Setting Register %s
        volatile uint32_t ELCSARA;  ///< Offset: 0x74 - Event Link Controller Security Attribution Register A
        volatile uint32_t ELCSARB;  ///< Offset: 0x78 - Event Link Controller Security Attribution Register B
        volatile uint32_t ELCSARC;  ///< Offset: 0x7C - Event Link Controller Security Attribution Register C
    };

    /// Peripheral instances
    inline Registers* ELC = reinterpret_cast<Registers*>(ELC_BASE);

    // Bit definitions
    /// ELCR Register bits
    namespace elcr_bits {
        constexpr uint32_t ELCON = (1U << 7);  ///< All Event Link Enable
    }

    /// ELSEGR%s Register bits
    namespace elsegr%s_bits {
        constexpr uint32_t SEG = (1U << 0);  ///< Software Event Generation
        constexpr uint32_t WE = (1U << 6);  ///< SEG Bit Write Enable
        constexpr uint32_t WI = (1U << 7);  ///< ELSEGR Register Write Disable
    }

    /// ELSR%s Register bits
    namespace elsr%s_bits {
        constexpr uint32_t ELS = (9 << 0);  ///< Event Link Select
    }

    /// ELCSARA Register bits
    namespace elcsara_bits {
        constexpr uint32_t ELCR = (1U << 0);  ///< Event Link Controller Register Security Attribution
        constexpr uint32_t ELSEGR0 = (1U << 1);  ///< Event Link Software Event Generation Register 0 Security Attribution
        constexpr uint32_t ELSEGR1 = (1U << 2);  ///< Event Link Software Event Generation Register 1 Security Attribution
    }

    /// ELCSARB Register bits
    namespace elcsarb_bits {
        constexpr uint32_t ELSR = (16 << 0);  ///< Event Link Setting Register n Security Attribution
    }

    /// ELCSARC Register bits
    namespace elcsarc_bits {
        constexpr uint32_t ELSR = (3 << 0);  ///< Event Link Setting Register n Security Attribution (n = 16 to 18)
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40083000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t R64CNT;  ///< Offset: 0x00 - 64-Hz Counter
        volatile uint32_t BCNT%s;  ///< Offset: 0x02 - Binary Counter %s
        volatile uint32_t RSECCNT;  ///< Offset: 0x02 - Second Counter (in Calendar Count Mode)
        volatile uint32_t RMINCNT;  ///< Offset: 0x04 - Minute Counter (in Calendar Count Mode)
        volatile uint32_t RHRCNT;  ///< Offset: 0x06 - Hour Counter (in Calendar Count Mode)
        volatile uint32_t RWKCNT;  ///< Offset: 0x08 - Day-of-Week Counter (in Calendar Count Mode)
        volatile uint32_t RDAYCNT;  ///< Offset: 0x0A - Day Counter
        volatile uint32_t RMONCNT;  ///< Offset: 0x0C - Month Counter
        volatile uint32_t RYRCNT;  ///< Offset: 0x0E - Year Counter
        volatile uint32_t BCNT%sAR;  ///< Offset: 0x10 - Binary Counter %s Alarm Register
        volatile uint32_t RSECAR;  ///< Offset: 0x10 - Second Alarm Register (in Calendar Count Mode)
        volatile uint32_t RMINAR;  ///< Offset: 0x12 - Minute Alarm Register (in Calendar Count Mode)
        volatile uint32_t RHRAR;  ///< Offset: 0x14 - Hour Alarm Register (in Calendar Count Mode)
        volatile uint32_t RWKAR;  ///< Offset: 0x16 - Day-of-Week Alarm Register (in Calendar Count Mode)
        volatile uint32_t BCNT%sAER;  ///< Offset: 0x18 - Binary Counter %s Alarm Enable Register
        volatile uint32_t RDAYAR;  ///< Offset: 0x18 - Date Alarm Register (in Calendar Count Mode)
        volatile uint32_t RMONAR;  ///< Offset: 0x1A - Month Alarm Register (in Calendar Count Mode)
        volatile uint32_t BCNT2AER;  ///< Offset: 0x1C - Binary Counter 2 Alarm Enable Register
        volatile uint32_t RYRAR;  ///< Offset: 0x1C - Year Alarm Register (in Calendar Count Mode)
        volatile uint32_t BCNT3AER;  ///< Offset: 0x1E - Binary Counter 3 Alarm Enable Register
        volatile uint32_t RYRAREN;  ///< Offset: 0x1E - Year Alarm Enable Register (in Calendar Count Mode)
        volatile uint32_t RCR1;  ///< Offset: 0x22 - RTC Control Register 1
        volatile uint32_t RCR2;  ///< Offset: 0x24 - RTC Control Register 2 (in Calendar Count Mode)
        volatile uint32_t RCR2_BCNT;  ///< Offset: 0x24 - RTC Control Register 2 (in Binary Count Mode)
        volatile uint32_t RCR4;  ///< Offset: 0x28 - RTC Control Register 4
        volatile uint32_t RFRH;  ///< Offset: 0x2A - Frequency Register H
        volatile uint32_t RFRL;  ///< Offset: 0x2C - Frequency Register L
        volatile uint32_t RADJ;  ///< Offset: 0x2E - Time Error Adjustment Register
        volatile uint32_t RTCCR%s;  ///< Offset: 0x40 - Time Capture Control Register %s
        volatile uint32_t BCNT0CP%s;  ///< Offset: 0x52 - BCNT0 Capture Register %s
        volatile uint32_t RSECCP%s;  ///< Offset: 0x52 - Second Capture Register %s
        volatile uint32_t BCNT1CP%s;  ///< Offset: 0x54 - BCNT1 Capture Register %s
        volatile uint32_t RMINCP%s;  ///< Offset: 0x54 - Minute Capture Register %s
        volatile uint32_t BCNT2CP%s;  ///< Offset: 0x56 - BCNT2 Capture Register %s
        volatile uint32_t RHRCP%s;  ///< Offset: 0x56 - Hour Capture Register %s
        volatile uint32_t BCNT3CP%s;  ///< Offset: 0x5A - BCNT3 Capture Register %s
        volatile uint32_t RDAYCP%s;  ///< Offset: 0x5A - Date Capture Register %s
        volatile uint32_t RMONCP%s;  ///< Offset: 0x5C - Month Capture Register %s
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// R64CNT Register bits
    namespace r64cnt_bits {
        constexpr uint32_t F64HZ = (1U << 0);  ///< 64-Hz Flag
        constexpr uint32_t F32HZ = (1U << 1);  ///< 32-Hz Flag
        constexpr uint32_t F16HZ = (1U << 2);  ///< 16-Hz Flag
        constexpr uint32_t F8HZ = (1U << 3);  ///< 8-Hz Flag
        constexpr uint32_t F4HZ = (1U << 4);  ///< 4-Hz Flag
        constexpr uint32_t F2HZ = (1U << 5);  ///< 2-Hz Flag
        constexpr uint32_t F1HZ = (1U << 6);  ///< 1-Hz Flag
    }

    /// BCNT%s Register bits
    namespace bcnt%s_bits {
        constexpr uint32_t BCNT = (8 << 0);  ///< Binary Counter
    }

    /// RSECCNT Register bits
    namespace rseccnt_bits {
        constexpr uint32_t SEC1 = (4 << 0);  ///< 1-Second Count
        constexpr uint32_t SEC10 = (3 << 4);  ///< 10-Second Count
    }

    /// RMINCNT Register bits
    namespace rmincnt_bits {
        constexpr uint32_t MIN1 = (4 << 0);  ///< 1-Minute Count
        constexpr uint32_t MIN10 = (3 << 4);  ///< 10-Minute Count
    }

    /// RHRCNT Register bits
    namespace rhrcnt_bits {
        constexpr uint32_t HR1 = (4 << 0);  ///< 1-Hour Count
        constexpr uint32_t HR10 = (2 << 4);  ///< 10-Hour Count
        constexpr uint32_t PM = (1U << 6);  ///< AM/PM select for time counter setting.
    }

    /// RWKCNT Register bits
    namespace rwkcnt_bits {
        constexpr uint32_t DAYW = (3 << 0);  ///< Day-of-Week Counting
    }

    /// RDAYCNT Register bits
    namespace rdaycnt_bits {
        constexpr uint32_t DATE1 = (4 << 0);  ///< 1-Day Count
        constexpr uint32_t DATE10 = (2 << 4);  ///< 10-Day Count
    }

    /// RMONCNT Register bits
    namespace rmoncnt_bits {
        constexpr uint32_t MON1 = (4 << 0);  ///< 1-Month Count
        constexpr uint32_t MON10 = (1U << 4);  ///< 10-Month Count
    }

    /// RYRCNT Register bits
    namespace ryrcnt_bits {
        constexpr uint32_t YR1 = (4 << 0);  ///< 1-Year Count
        constexpr uint32_t YR10 = (4 << 4);  ///< 10-Year Count
    }

    /// BCNT%sAR Register bits
    namespace bcnt%sar_bits {
        constexpr uint32_t BCNTAR = (8 << 0);  ///< Alarm register associated with the 32-bit binary counter
    }

    /// RSECAR Register bits
    namespace rsecar_bits {
        constexpr uint32_t SEC1 = (4 << 0);  ///< 1 Second
        constexpr uint32_t SEC10 = (3 << 4);  ///< 10 Seconds
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// RMINAR Register bits
    namespace rminar_bits {
        constexpr uint32_t MIN1 = (4 << 0);  ///< 1 Minute
        constexpr uint32_t MIN10 = (3 << 4);  ///< 10 Minutes
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// RHRAR Register bits
    namespace rhrar_bits {
        constexpr uint32_t HR1 = (4 << 0);  ///< 1 Hour
        constexpr uint32_t HR10 = (2 << 4);  ///< 10 Hours
        constexpr uint32_t PM = (1U << 6);  ///< AM/PM select for alarm setting.
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// RWKAR Register bits
    namespace rwkar_bits {
        constexpr uint32_t DAYW = (3 << 0);  ///< Day-of-Week Setting
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// BCNT%sAER Register bits
    namespace bcnt%saer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< Setting the alarm enable associated with the 32-bit binary counter
    }

    /// RDAYAR Register bits
    namespace rdayar_bits {
        constexpr uint32_t DATE1 = (4 << 0);  ///< 1 Day
        constexpr uint32_t DATE10 = (2 << 4);  ///< 10 Days
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// RMONAR Register bits
    namespace rmonar_bits {
        constexpr uint32_t MON1 = (4 << 0);  ///< 1 Month
        constexpr uint32_t MON10 = (1U << 4);  ///< 10 Months
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// BCNT2AER Register bits
    namespace bcnt2aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< Setting the alarm enable associated with the 32-bit binary counter
    }

    /// RYRAR Register bits
    namespace ryrar_bits {
        constexpr uint32_t YR1 = (4 << 0);  ///< 1 Year
        constexpr uint32_t YR10 = (4 << 4);  ///< 10 Years
    }

    /// BCNT3AER Register bits
    namespace bcnt3aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< Setting the alarm enable associated with the 32-bit binary counter
    }

    /// RYRAREN Register bits
    namespace ryraren_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// RCR1 Register bits
    namespace rcr1_bits {
        constexpr uint32_t AIE = (1U << 0);  ///< Alarm Interrupt Enable
        constexpr uint32_t CIE = (1U << 1);  ///< Carry Interrupt Enable
        constexpr uint32_t PIE = (1U << 2);  ///< Periodic Interrupt Enable
        constexpr uint32_t RTCOS = (1U << 3);  ///< RTCOUT Output Select
        constexpr uint32_t PES = (4 << 4);  ///< Periodic Interrupt Select
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start
        constexpr uint32_t RESET = (1U << 1);  ///< RTC Software Reset
        constexpr uint32_t ADJ30 = (1U << 2);  ///< 30-Second Adjustment
        constexpr uint32_t RTCOE = (1U << 3);  ///< RTCOUT Output Enable
        constexpr uint32_t AADJE = (1U << 4);  ///< Automatic Adjustment Enable
        constexpr uint32_t AADJP = (1U << 5);  ///< Automatic Adjustment Period Select
        constexpr uint32_t HR24 = (1U << 6);  ///< Hours Mode
        constexpr uint32_t CNTMD = (1U << 7);  ///< Count Mode Select
    }

    /// RCR2_BCNT Register bits
    namespace rcr2_bcnt_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start
        constexpr uint32_t RESET = (1U << 1);  ///< RTC Software Reset
        constexpr uint32_t RTCOE = (1U << 3);  ///< RTCOUT Output Enable
        constexpr uint32_t AADJE = (1U << 4);  ///< Automatic Adjustment Enable
        constexpr uint32_t AADJP = (1U << 5);  ///< Automatic Adjustment Period Select
        constexpr uint32_t CNTMD = (1U << 7);  ///< Count Mode Select
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t RCKSEL = (1U << 0);  ///< Count Source Select
    }

    /// RFRH Register bits
    namespace rfrh_bits {
        constexpr uint32_t RFC16 = (1U << 0);  ///< Write 0 before writing to the RFRL register after a cold start.
    }

    /// RFRL Register bits
    namespace rfrl_bits {
        constexpr uint32_t RFC = (16 << 0);  ///< Frequency Comparison Value
    }

    /// RADJ Register bits
    namespace radj_bits {
        constexpr uint32_t ADJ = (6 << 0);  ///< Adjustment Value
        constexpr uint32_t PMADJ = (2 << 6);  ///< Plus-Minus
    }

    /// RTCCR%s Register bits
    namespace rtccr%s_bits {
        constexpr uint32_t TCCT = (2 << 0);  ///< Time Capture Control
        constexpr uint32_t TCST = (1U << 2);  ///< Time Capture Status
        constexpr uint32_t TCNF = (2 << 4);  ///< Time Capture Noise Filter Control
        constexpr uint32_t TCEN = (1U << 7);  ///< Time Capture Event Input Pin Enable
    }

    /// RSECCP%s Register bits
    namespace rseccp%s_bits {
        constexpr uint32_t SEC1 = (4 << 0);  ///< 1-Second Capture
        constexpr uint32_t SEC10 = (3 << 4);  ///< 10-Second Capture
    }

    /// RMINCP%s Register bits
    namespace rmincp%s_bits {
        constexpr uint32_t MIN1 = (4 << 0);  ///< 1-Minute Capture
        constexpr uint32_t MIN10 = (3 << 4);  ///< 10-Minute Capture
    }

    /// RHRCP%s Register bits
    namespace rhrcp%s_bits {
        constexpr uint32_t HR1 = (4 << 0);  ///< 1-Hour Capture
        constexpr uint32_t HR10 = (2 << 4);  ///< 10-Hour Capture
        constexpr uint32_t PM = (1U << 6);  ///< PM
    }

    /// RDAYCP%s Register bits
    namespace rdaycp%s_bits {
        constexpr uint32_t DATE1 = (4 << 0);  ///< 1-Day Capture
        constexpr uint32_t DATE10 = (2 << 4);  ///< 10-Day Capture
    }

    /// RMONCP%s Register bits
    namespace rmoncp%s_bits {
        constexpr uint32_t MON1 = (4 << 0);  ///< 1-Month Capture
        constexpr uint32_t MON10 = (1U << 4);  ///< 10-Month Capture
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDT_BASE = 0x40083200;
    constexpr uint32_t WDT_BASE = 0x40083400;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t IWDTRR;  ///< Offset: 0x00 - IWDT Refresh Register
        volatile uint32_t IWDTSR;  ///< Offset: 0x04 - IWDT Status Register
    };

    /// Peripheral instances
    inline Registers* IWDT = reinterpret_cast<Registers*>(IWDT_BASE);
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// IWDTSR Register bits
    namespace iwdtsr_bits {
        constexpr uint32_t CNTVAL = (14 << 0);  ///< Down-counter Value
        constexpr uint32_t UNDFF = (1U << 14);  ///< Underflow Flag
        constexpr uint32_t REFEF = (1U << 15);  ///< Refresh Error Flag
    }

}

// ============================================================================
// CAC Peripheral
// ============================================================================

namespace cac {
    /// Base addresses
    constexpr uint32_t CAC_BASE = 0x40083600;

    /// CAC Register structure
    struct Registers {
        volatile uint32_t CACR0;  ///< Offset: 0x00 - CAC Control Register 0
        volatile uint32_t CACR1;  ///< Offset: 0x01 - CAC Control Register 1
        volatile uint32_t CACR2;  ///< Offset: 0x02 - CAC Control Register 2
        volatile uint32_t CAICR;  ///< Offset: 0x03 - CAC Interrupt Control Register
        volatile uint32_t CASTR;  ///< Offset: 0x04 - CAC Status Register
        volatile uint32_t CAULVR;  ///< Offset: 0x06 - CAC Upper-Limit Value Setting Register
        volatile uint32_t CALLVR;  ///< Offset: 0x08 - CAC Lower-Limit Value Setting Register
        volatile uint32_t CACNTBR;  ///< Offset: 0x0A - CAC Counter Buffer Register
    };

    /// Peripheral instances
    inline Registers* CAC = reinterpret_cast<Registers*>(CAC_BASE);

    // Bit definitions
    /// CACR0 Register bits
    namespace cacr0_bits {
        constexpr uint32_t CFME = (1U << 0);  ///< Clock Frequency Measurement Enable
    }

    /// CACR1 Register bits
    namespace cacr1_bits {
        constexpr uint32_t CACREFE = (1U << 0);  ///< CACREF Pin Input Enable
        constexpr uint32_t FMCS = (3 << 1);  ///< Measurement Target Clock Select
        constexpr uint32_t TCSS = (2 << 4);  ///< Timer Count Clock Source Select
        constexpr uint32_t EDGES = (2 << 6);  ///< Valid Edge Select
    }

    /// CACR2 Register bits
    namespace cacr2_bits {
        constexpr uint32_t RPS = (1U << 0);  ///< Reference Signal Select
        constexpr uint32_t RSCS = (3 << 1);  ///< Measurement Reference Clock Select
        constexpr uint32_t RCDS = (2 << 4);  ///< Measurement Reference Clock Frequency Division Ratio Select
        constexpr uint32_t DFS = (2 << 6);  ///< Digital Filter Select
    }

    /// CAICR Register bits
    namespace caicr_bits {
        constexpr uint32_t FERRIE = (1U << 0);  ///< Frequency Error Interrupt Request Enable
        constexpr uint32_t MENDIE = (1U << 1);  ///< Measurement End Interrupt Request Enable
        constexpr uint32_t OVFIE = (1U << 2);  ///< Overflow Interrupt Request Enable
        constexpr uint32_t FERRFCL = (1U << 4);  ///< FERRF Clear
        constexpr uint32_t MENDFCL = (1U << 5);  ///< MENDF Clear
        constexpr uint32_t OVFFCL = (1U << 6);  ///< OVFF Clear
    }

    /// CASTR Register bits
    namespace castr_bits {
        constexpr uint32_t FERRF = (1U << 0);  ///< Frequency Error Flag
        constexpr uint32_t MENDF = (1U << 1);  ///< Measurement End Flag
        constexpr uint32_t OVFF = (1U << 2);  ///< Overflow Flag
    }

}

// ============================================================================
// MSTP Peripheral
// ============================================================================

namespace mstp {
    /// Base addresses
    constexpr uint32_t MSTP_BASE = 0x40084000;

    /// MSTP Register structure
    struct Registers {
        volatile uint32_t MSTPCRA;  ///< Offset: 0x00 - Module Stop Control Register A
        volatile uint32_t MSTPCRB;  ///< Offset: 0x04 - Module Stop Control Register B
        volatile uint32_t MSTPCRC;  ///< Offset: 0x08 - Module Stop Control Register C
        volatile uint32_t MSTPCRD;  ///< Offset: 0x0C - Module Stop Control Register D
        volatile uint32_t MSTPCRE;  ///< Offset: 0x10 - Module Stop Control Register E
    };

    /// Peripheral instances
    inline Registers* MSTP = reinterpret_cast<Registers*>(MSTP_BASE);

    // Bit definitions
    /// MSTPCRA Register bits
    namespace mstpcra_bits {
        constexpr uint32_t MSTPA0 = (1U << 0);  ///< SRAM0 Module Stop
        constexpr uint32_t MSTPA7 = (1U << 7);  ///< Standby SRAM Module Stop
        constexpr uint32_t MSTPA22 = (1U << 22);  ///< DMA Controller/Data Transfer Controller Module Stop
    }

    /// MSTPCRB Register bits
    namespace mstpcrb_bits {
        constexpr uint32_t MSTPB1 = (1U << 1);  ///< Controller Area Network 1 Module Stop
        constexpr uint32_t MSTPB2 = (1U << 2);  ///< Controller Area Network 0 Module Stop
        constexpr uint32_t MSTPB6 = (1U << 6);  ///< Quad Serial Peripheral Interface Module Stop
        constexpr uint32_t MSTPB8 = (1U << 8);  ///< I2C Bus Interface 1 Module Stop
        constexpr uint32_t MSTPB9 = (1U << 9);  ///< I2C Bus Interface 0 Module Stop
        constexpr uint32_t MSTPB11 = (1U << 11);  ///< Universal Serial Bus 2.0 FS Interface 0 Module Stop
        constexpr uint32_t MSTPB19 = (1U << 19);  ///< Serial Peripheral Interface 0 Module Stop
        constexpr uint32_t MSTPB22 = (1U << 22);  ///< Serial Communication Interface 9 Module Stop
        constexpr uint32_t MSTPB27 = (1U << 27);  ///< Serial Communication Interface 4 Module Stop
        constexpr uint32_t MSTPB28 = (1U << 28);  ///< Serial Communication Interface 3 Module Stop
        constexpr uint32_t MSTPB29 = (1U << 29);  ///< Serial Communication Interface 2 Module Stop
        constexpr uint32_t MSTPB30 = (1U << 30);  ///< Serial Communication Interface 1 Module Stop
        constexpr uint32_t MSTPB31 = (1U << 31);  ///< Serial Communication Interface 0 Module Stop
    }

    /// MSTPCRC Register bits
    namespace mstpcrc_bits {
        constexpr uint32_t MSTPC0 = (1U << 0);  ///< Clock Frequency Accuracy Measurement Circuit Module Stop
        constexpr uint32_t MSTPC1 = (1U << 1);  ///< Cyclic Redundancy Check Calculator Module Stop
        constexpr uint32_t MSTPC3 = (1U << 3);  ///< Capacitive Touch Sensing Unit Module Stop
        constexpr uint32_t MSTPC8 = (1U << 8);  ///< Serial Sound Interface Enhanced Module Stop
        constexpr uint32_t MSTPC12 = (1U << 12);  ///< Secure Digital HOST IF / Multi Media Card 0 Module Stop
        constexpr uint32_t MSTPC13 = (1U << 13);  ///< Data Operation Circuit Module Stop
        constexpr uint32_t MSTPC14 = (1U << 14);  ///< Event Link Controller Module Stop
        constexpr uint32_t MSTPC31 = (1U << 31);  ///< SCE9 Module Stop
    }

    /// MSTPCRD Register bits
    namespace mstpcrd_bits {
        constexpr uint32_t MSTPD0 = (1U << 0);  ///< Low Power Asynchronous General Purpose Timer 3 Module Stop
        constexpr uint32_t MSTPD1 = (1U << 1);  ///< Low Power Asynchronous General Purpose Timer 2 Module Stop
        constexpr uint32_t MSTPD2 = (1U << 2);  ///< Low Power Asynchronous General Purpose Timer 1 Module Stop
        constexpr uint32_t MSTPD3 = (1U << 3);  ///< Low Power Asynchronous General Purpose Timer 0 Module Stop
        constexpr uint32_t MSTPD11 = (1U << 11);  ///< Port Output Enable for GPT Group D Module Stop
        constexpr uint32_t MSTPD12 = (1U << 12);  ///< Port Output Enable for GPT Group C Module Stop
        constexpr uint32_t MSTPD13 = (1U << 13);  ///< Port Output Enable for GPT Group B Module Stop
        constexpr uint32_t MSTPD14 = (1U << 14);  ///< Port Output Enable for GPT Group A Module Stop
        constexpr uint32_t MSTPD15 = (1U << 15);  ///< 12-bit A/D Converter 1 Module Stop
        constexpr uint32_t MSTPD16 = (1U << 16);  ///< 12-bit A/D Converter 0 Module Stop
        constexpr uint32_t MSTPD20 = (1U << 20);  ///< 12-bit D/A Converter Module Stop
        constexpr uint32_t MSTPD22 = (1U << 22);  ///< Temperature Sensor Module Stop
    }

    /// MSTPCRE Register bits
    namespace mstpcre_bits {
        constexpr uint32_t MSTPE14 = (1U << 14);  ///< Low Power Asynchronous General Purpose Timer 5 Module Stop
        constexpr uint32_t MSTPE15 = (1U << 15);  ///< Low Power Asynchronous General Purpose Timer 4 Module Stop
        constexpr uint32_t MSTPE24 = (1U << 24);  ///< GPT7 Module Stop
        constexpr uint32_t MSTPE25 = (1U << 25);  ///< GPT6 Module Stop
        constexpr uint32_t MSTPE26 = (1U << 26);  ///< GPT5 Module Stop
        constexpr uint32_t MSTPE27 = (1U << 27);  ///< GPT4 Module Stop
        constexpr uint32_t MSTPE28 = (1U << 28);  ///< GPT3 Module Stop
        constexpr uint32_t MSTPE29 = (1U << 29);  ///< GPT2 Module Stop
        constexpr uint32_t MSTPE30 = (1U << 30);  ///< GPT1 Module Stop
        constexpr uint32_t MSTPE31 = (1U << 31);  ///< GPT0 Module Stop
    }

}

// ============================================================================
// POEG Peripheral
// ============================================================================

namespace poeg {
    /// Base addresses
    constexpr uint32_t POEG_BASE = 0x4008A000;

    /// POEG Register structure
    struct Registers {
        volatile uint32_t POEGGA;  ///< Offset: 0x00 - POEG Group A Setting Register
        volatile uint32_t POEGGB;  ///< Offset: 0x100 - POEG Group B Setting Register
        volatile uint32_t POEGGC;  ///< Offset: 0x200 - POEG Group C Setting Register
        volatile uint32_t POEGGD;  ///< Offset: 0x300 - POEG Group D Setting Register
    };

    /// Peripheral instances
    inline Registers* POEG = reinterpret_cast<Registers*>(POEG_BASE);

    // Bit definitions
    /// POEGGA Register bits
    namespace poegga_bits {
        constexpr uint32_t PIDF = (1U << 0);  ///< Port Input Detection Flag
        constexpr uint32_t IOCF = (1U << 1);  ///< Detection Flag for GPT Output-Disable Request
        constexpr uint32_t OSTPF = (1U << 2);  ///< Oscillation Stop Detection Flag
        constexpr uint32_t SSF = (1U << 3);  ///< Software Stop Flag
        constexpr uint32_t PIDE = (1U << 4);  ///< Port Input Detection Enable
        constexpr uint32_t IOCE = (1U << 5);  ///< Enable for GPT Output-Disable Request
        constexpr uint32_t OSTPE = (1U << 6);  ///< Oscillation Stop Detection Enable
        constexpr uint32_t ST = (1U << 16);  ///< GTETRGn Input Status Flag
        constexpr uint32_t INV = (1U << 28);  ///< GTETRGn Input Reverse
        constexpr uint32_t NFEN = (1U << 29);  ///< Noise Filter Enable
        constexpr uint32_t NFCS = (2 << 30);  ///< Noise Filter Clock Select
    }

    /// POEGGB Register bits
    namespace poeggb_bits {
        constexpr uint32_t PIDF = (1U << 0);  ///< Port Input Detection Flag
        constexpr uint32_t IOCF = (1U << 1);  ///< Detection Flag for GPT Output-Disable Request
        constexpr uint32_t OSTPF = (1U << 2);  ///< Oscillation Stop Detection Flag
        constexpr uint32_t SSF = (1U << 3);  ///< Software Stop Flag
        constexpr uint32_t PIDE = (1U << 4);  ///< Port Input Detection Enable
        constexpr uint32_t IOCE = (1U << 5);  ///< Enable for GPT Output-Disable Request
        constexpr uint32_t OSTPE = (1U << 6);  ///< Oscillation Stop Detection Enable
        constexpr uint32_t ST = (1U << 16);  ///< GTETRGn Input Status Flag
        constexpr uint32_t INV = (1U << 28);  ///< GTETRGn Input Reverse
        constexpr uint32_t NFEN = (1U << 29);  ///< Noise Filter Enable
        constexpr uint32_t NFCS = (2 << 30);  ///< Noise Filter Clock Select
    }

    /// POEGGC Register bits
    namespace poeggc_bits {
        constexpr uint32_t PIDF = (1U << 0);  ///< Port Input Detection Flag
        constexpr uint32_t IOCF = (1U << 1);  ///< Detection Flag for GPT Output-Disable Request
        constexpr uint32_t OSTPF = (1U << 2);  ///< Oscillation Stop Detection Flag
        constexpr uint32_t SSF = (1U << 3);  ///< Software Stop Flag
        constexpr uint32_t PIDE = (1U << 4);  ///< Port Input Detection Enable
        constexpr uint32_t IOCE = (1U << 5);  ///< Enable for GPT Output-Disable Request
        constexpr uint32_t OSTPE = (1U << 6);  ///< Oscillation Stop Detection Enable
        constexpr uint32_t ST = (1U << 16);  ///< GTETRGn Input Status Flag
        constexpr uint32_t INV = (1U << 28);  ///< GTETRGn Input Reverse
        constexpr uint32_t NFEN = (1U << 29);  ///< Noise Filter Enable
        constexpr uint32_t NFCS = (2 << 30);  ///< Noise Filter Clock Select
    }

    /// POEGGD Register bits
    namespace poeggd_bits {
        constexpr uint32_t PIDF = (1U << 0);  ///< Port Input Detection Flag
        constexpr uint32_t IOCF = (1U << 1);  ///< Detection Flag for GPT Output-Disable Request
        constexpr uint32_t OSTPF = (1U << 2);  ///< Oscillation Stop Detection Flag
        constexpr uint32_t SSF = (1U << 3);  ///< Software Stop Flag
        constexpr uint32_t PIDE = (1U << 4);  ///< Port Input Detection Enable
        constexpr uint32_t IOCE = (1U << 5);  ///< Enable for GPT Output-Disable Request
        constexpr uint32_t OSTPE = (1U << 6);  ///< Oscillation Stop Detection Enable
        constexpr uint32_t ST = (1U << 16);  ///< GTETRGn Input Status Flag
        constexpr uint32_t INV = (1U << 28);  ///< GTETRGn Input Reverse
        constexpr uint32_t NFEN = (1U << 29);  ///< Noise Filter Enable
        constexpr uint32_t NFCS = (2 << 30);  ///< Noise Filter Clock Select
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USBFS_BASE = 0x40090000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t SYSCFG;  ///< Offset: 0x00 - System Configuration Control Register
        volatile uint32_t SYSSTS0;  ///< Offset: 0x04 - System Configuration Status Register 0
        volatile uint32_t DVSTCTR0;  ///< Offset: 0x08 - Device State Control Register 0
        volatile uint32_t CFIFO;  ///< Offset: 0x14 - CFIFO Port Register
        volatile uint32_t CFIFOL;  ///< Offset: 0x14 - CFIFO Port Register
        volatile uint32_t D%sFIFO;  ///< Offset: 0x18 - D%sFIFO Port Register
        volatile uint32_t D%sFIFOL;  ///< Offset: 0x18 - D%sFIFO Port Register
        volatile uint32_t CFIFOSEL;  ///< Offset: 0x20 - CFIFO Port Select Register
        volatile uint32_t CFIFOCTR;  ///< Offset: 0x22 - CFIFO Port Control Register
        volatile uint32_t D%sFIFOSEL;  ///< Offset: 0x28 - D%sFIFO Port Select Register
        volatile uint32_t D%sFIFOCTR;  ///< Offset: 0x2A - D%sFIFO Port Control Register
        volatile uint32_t INTENB0;  ///< Offset: 0x30 - Interrupt Enable Register 0
        volatile uint32_t INTENB1;  ///< Offset: 0x32 - Interrupt Enable Register 1
        volatile uint32_t BRDYENB;  ///< Offset: 0x36 - BRDY Interrupt Enable Register
        volatile uint32_t NRDYENB;  ///< Offset: 0x38 - NRDY Interrupt Enable Register
        volatile uint32_t BEMPENB;  ///< Offset: 0x3A - BEMP Interrupt Enable Register
        volatile uint32_t SOFCFG;  ///< Offset: 0x3C - SOF Output Configuration Register
        volatile uint32_t INTSTS0;  ///< Offset: 0x40 - Interrupt Status Register 0
        volatile uint32_t INTSTS1;  ///< Offset: 0x42 - Interrupt Status Register 1
        volatile uint32_t BRDYSTS;  ///< Offset: 0x46 - BRDY Interrupt Status Register
        volatile uint32_t NRDYSTS;  ///< Offset: 0x48 - NRDY Interrupt Status Register
        volatile uint32_t BEMPSTS;  ///< Offset: 0x4A - BEMP Interrupt Status Register
        volatile uint32_t FRMNUM;  ///< Offset: 0x4C - Frame Number Register
        volatile uint32_t DVCHGR;  ///< Offset: 0x4E - Device State Change Register
        volatile uint32_t USBADDR;  ///< Offset: 0x50 - USB Address Register
        volatile uint32_t USBREQ;  ///< Offset: 0x54 - USB Request Type Register
        volatile uint32_t USBVAL;  ///< Offset: 0x56 - USB Request Value Register
        volatile uint32_t USBINDX;  ///< Offset: 0x58 - USB Request Index Register
        volatile uint32_t USBLENG;  ///< Offset: 0x5A - USB Request Length Register
        volatile uint32_t DCPCFG;  ///< Offset: 0x5C - DCP Configuration Register
        volatile uint32_t DCPMAXP;  ///< Offset: 0x5E - DCP Maximum Packet Size Register
        volatile uint32_t DCPCTR;  ///< Offset: 0x60 - DCP Control Register
        volatile uint32_t PIPESEL;  ///< Offset: 0x64 - Pipe Window Select Register
        volatile uint32_t PIPECFG;  ///< Offset: 0x68 - Pipe Configuration Register
        volatile uint32_t PIPEMAXP;  ///< Offset: 0x6C - Pipe Maximum Packet Size Register
        volatile uint32_t PIPEPERI;  ///< Offset: 0x6E - Pipe Cycle Control Register
        volatile uint32_t PIPE%sCTR;  ///< Offset: 0x7A - PIPE%s Control Registers
        volatile uint32_t PIPE%sTRE;  ///< Offset: 0x90 - PIPE%s Transaction Counter Enable Register
        volatile uint32_t PIPE%sTRN;  ///< Offset: 0x92 - PIPE%s Transaction Counter Register
        volatile uint32_t BCCTRL1;  ///< Offset: 0xB0 - Battery Charging Control Register 1
        volatile uint32_t BCCTRL2;  ///< Offset: 0xB4 - Battery Charging Control Register 2
        volatile uint32_t DEVADD%s;  ///< Offset: 0xD0 - Device Address %s Configuration Register
        volatile uint32_t PHYSECTRL;  ///< Offset: 0xF4 - PHY Single-ended Receiver Control Register
        volatile uint32_t DPUSR0R;  ///< Offset: 0x400 - Deep Software Standby USB Transceiver Control/Pin...
        volatile uint32_t DPUSR1R;  ///< Offset: 0x404 - Deep Software Standby USB Suspend/Resume Interrupt Register
    };

    /// Peripheral instances
    inline Registers* USBFS = reinterpret_cast<Registers*>(USBFS_BASE);

    // Bit definitions
    /// SYSCFG Register bits
    namespace syscfg_bits {
        constexpr uint32_t USBE = (1U << 0);  ///< USBFS Operation Enable
        constexpr uint32_t DPRPU = (1U << 4);  ///< D+ Line Resistor Control
        constexpr uint32_t DRPD = (1U << 5);  ///< D+/D Line Resistor Control
        constexpr uint32_t DCFM = (1U << 6);  ///< Controller Function Select
        constexpr uint32_t SCKE = (1U << 10);  ///< USB Clock Enable
    }

    /// SYSSTS0 Register bits
    namespace syssts0_bits {
        constexpr uint32_t LNST = (2 << 0);  ///< USB Data Line Status Monitor
        constexpr uint32_t IDMON = (1U << 2);  ///< External ID0 Input Pin Monitor
        constexpr uint32_t SOFEA = (1U << 5);  ///< Active Monitor When the Host Controller Is Selected
        constexpr uint32_t HTACT = (1U << 6);  ///< USB Host Sequencer Status Monitor
        constexpr uint32_t OVCMON = (2 << 14);  ///< External USB_OVRCURA/ USB_OVRCURB Input Pin Monitor
    }

    /// DVSTCTR0 Register bits
    namespace dvstctr0_bits {
        constexpr uint32_t RHST = (3 << 0);  ///< USB Bus Reset Status
        constexpr uint32_t UACT = (1U << 4);  ///< USB Bus Enable
        constexpr uint32_t RESUME = (1U << 5);  ///< Resume Output
        constexpr uint32_t USBRST = (1U << 6);  ///< USB Bus Reset Output
        constexpr uint32_t RWUPE = (1U << 7);  ///< Wakeup Detection Enable
        constexpr uint32_t WKUP = (1U << 8);  ///< Wakeup Output
        constexpr uint32_t VBUSEN = (1U << 9);  ///< USB_VBUSEN Output Pin Control
        constexpr uint32_t EXICEN = (1U << 10);  ///< USB_EXICEN Output Pin Control
        constexpr uint32_t HNPBTOA = (1U << 11);  ///< Host Negotiation Protocol (HNP) Control
    }

    /// CFIFO Register bits
    namespace cfifo_bits {
        constexpr uint32_t FIFOPORT = (16 << 0);  ///< FIFO Port
    }

    /// D%sFIFO Register bits
    namespace d%sfifo_bits {
        constexpr uint32_t FIFOPORT = (16 << 0);  ///< FIFO Port
    }

    /// CFIFOSEL Register bits
    namespace cfifosel_bits {
        constexpr uint32_t CURPIPE = (4 << 0);  ///< CFIFO Port Access Pipe Specification
        constexpr uint32_t ISEL = (1U << 5);  ///< CFIFO Port Access Direction When DCP Is Selected
        constexpr uint32_t BIGEND = (1U << 8);  ///< CFIFO Port Endian Control
        constexpr uint32_t MBW = (1U << 10);  ///< CFIFO Port Access Bit Width
        constexpr uint32_t REW = (1U << 14);  ///< Buffer Pointer Rewind
        constexpr uint32_t RCNT = (1U << 15);  ///< Read Count Mode
    }

    /// CFIFOCTR Register bits
    namespace cfifoctr_bits {
        constexpr uint32_t DTLN = (9 << 0);  ///< Receive Data Length
        constexpr uint32_t FRDY = (1U << 13);  ///< FIFO Port Ready
        constexpr uint32_t BCLR = (1U << 14);  ///< CPU Buffer Clear
        constexpr uint32_t BVAL = (1U << 15);  ///< Buffer Memory Valid Flag
    }

    /// D%sFIFOSEL Register bits
    namespace d%sfifosel_bits {
        constexpr uint32_t CURPIPE = (4 << 0);  ///< FIFO Port Access Pipe Specification
        constexpr uint32_t BIGEND = (1U << 8);  ///< FIFO Port Endian Control
        constexpr uint32_t MBW = (1U << 10);  ///< FIFO Port Access Bit Width
        constexpr uint32_t DREQE = (1U << 12);  ///< DMA/DTC Transfer Request Enable
        constexpr uint32_t DCLRM = (1U << 13);  ///< Auto Buffer Memory Clear Mode Accessed after Specified Pipe Data is Read
        constexpr uint32_t REW = (1U << 14);  ///< Buffer Pointer Rewind
        constexpr uint32_t RCNT = (1U << 15);  ///< Read Count Mode
    }

    /// D%sFIFOCTR Register bits
    namespace d%sfifoctr_bits {
        constexpr uint32_t DTLN = (9 << 0);  ///< Receive Data Length
        constexpr uint32_t FRDY = (1U << 13);  ///< FIFO Port Ready
        constexpr uint32_t BCLR = (1U << 14);  ///< CPU Buffer Clear
        constexpr uint32_t BVAL = (1U << 15);  ///< Buffer Memory Valid Flag
    }

    /// INTENB0 Register bits
    namespace intenb0_bits {
        constexpr uint32_t BRDYE = (1U << 8);  ///< Buffer Ready Interrupt Enable
        constexpr uint32_t NRDYE = (1U << 9);  ///< Buffer Not Ready Response Interrupt Enable
        constexpr uint32_t BEMPE = (1U << 10);  ///< Buffer Empty Interrupt Enable
        constexpr uint32_t CTRE = (1U << 11);  ///< Control Transfer Stage Transition Interrupt Enable
        constexpr uint32_t DVSE = (1U << 12);  ///< Device State Transition Interrupt Enable
        constexpr uint32_t SOFE = (1U << 13);  ///< Frame Number Update Interrupt Enable
        constexpr uint32_t RSME = (1U << 14);  ///< Resume Interrupt Enable
        constexpr uint32_t VBSE = (1U << 15);  ///< VBUS Interrupt Enable
    }

    /// INTENB1 Register bits
    namespace intenb1_bits {
        constexpr uint32_t PDDETINTE = (1U << 0);  ///< PDDETINT Detection Interrupt Request Enable
        constexpr uint32_t SACKE = (1U << 4);  ///< Setup Transaction Normal Response Interrupt Enable
        constexpr uint32_t SIGNE = (1U << 5);  ///< Setup Transaction Error Interrupt Enable
        constexpr uint32_t EOFERRE = (1U << 6);  ///< EOF Error Detection Interrupt Enable
        constexpr uint32_t ATTCHE = (1U << 11);  ///< Connection Detection Interrupt Enable
        constexpr uint32_t DTCHE = (1U << 12);  ///< Disconnection Detection Interrupt Enable
        constexpr uint32_t BCHGE = (1U << 14);  ///< USB Bus Change Interrupt Enable
        constexpr uint32_t OVRCRE = (1U << 15);  ///< Overcurrent Input Change Interrupt Enable
    }

    /// BRDYENB Register bits
    namespace brdyenb_bits {
        constexpr uint32_t PIPE0BRDYE = (1U << 0);  ///< BRDY Interrupt Enable for Pipe 0
        constexpr uint32_t PIPE1BRDYE = (1U << 1);  ///< BRDY Interrupt Enable for Pipe 1
        constexpr uint32_t PIPE2BRDYE = (1U << 2);  ///< BRDY Interrupt Enable for Pipe 2
        constexpr uint32_t PIPE3BRDYE = (1U << 3);  ///< BRDY Interrupt Enable for Pipe 3
        constexpr uint32_t PIPE4BRDYE = (1U << 4);  ///< BRDY Interrupt Enable for Pipe 4
        constexpr uint32_t PIPE5BRDYE = (1U << 5);  ///< BRDY Interrupt Enable for Pipe 5
        constexpr uint32_t PIPE6BRDYE = (1U << 6);  ///< BRDY Interrupt Enable for Pipe 6
        constexpr uint32_t PIPE7BRDYE = (1U << 7);  ///< BRDY Interrupt Enable for Pipe 7
        constexpr uint32_t PIPE8BRDYE = (1U << 8);  ///< BRDY Interrupt Enable for Pipe 8
        constexpr uint32_t PIPE9BRDYE = (1U << 9);  ///< BRDY Interrupt Enable for Pipe 9
    }

    /// NRDYENB Register bits
    namespace nrdyenb_bits {
        constexpr uint32_t PIPE0NRDYE = (1U << 0);  ///< NRDY Interrupt Enable for Pipe 0
        constexpr uint32_t PIPE1NRDYE = (1U << 1);  ///< NRDY Interrupt Enable for Pipe 1
        constexpr uint32_t PIPE2NRDYE = (1U << 2);  ///< NRDY Interrupt Enable for Pipe 2
        constexpr uint32_t PIPE3NRDYE = (1U << 3);  ///< NRDY Interrupt Enable for Pipe 3
        constexpr uint32_t PIPE4NRDYE = (1U << 4);  ///< NRDY Interrupt Enable for Pipe 4
        constexpr uint32_t PIPE5NRDYE = (1U << 5);  ///< NRDY Interrupt Enable for Pipe 5
        constexpr uint32_t PIPE6NRDYE = (1U << 6);  ///< NRDY Interrupt Enable for Pipe 6
        constexpr uint32_t PIPE7NRDYE = (1U << 7);  ///< NRDY Interrupt Enable for Pipe 7
        constexpr uint32_t PIPE8NRDYE = (1U << 8);  ///< NRDY Interrupt Enable for Pipe 8
        constexpr uint32_t PIPE9NRDYE = (1U << 9);  ///< NRDY Interrupt Enable for Pipe 9
    }

    /// BEMPENB Register bits
    namespace bempenb_bits {
        constexpr uint32_t PIPE0BEMPE = (1U << 0);  ///< BEMP Interrupt Enable for Pipe 0
        constexpr uint32_t PIPE1BEMPE = (1U << 1);  ///< BEMP Interrupt Enable for Pipe 1
        constexpr uint32_t PIPE2BEMPE = (1U << 2);  ///< BEMP Interrupt Enable for Pipe 2
        constexpr uint32_t PIPE3BEMPE = (1U << 3);  ///< BEMP Interrupt Enable for Pipe 3
        constexpr uint32_t PIPE4BEMPE = (1U << 4);  ///< BEMP Interrupt Enable for Pipe 4
        constexpr uint32_t PIPE5BEMPE = (1U << 5);  ///< BEMP Interrupt Enable for Pipe 5
        constexpr uint32_t PIPE6BEMPE = (1U << 6);  ///< BEMP Interrupt Enable for Pipe 6
        constexpr uint32_t PIPE7BEMPE = (1U << 7);  ///< BEMP Interrupt Enable for Pipe 7
        constexpr uint32_t PIPE8BEMPE = (1U << 8);  ///< BEMP Interrupt Enable for Pipe 8
        constexpr uint32_t PIPE9BEMPE = (1U << 9);  ///< BEMP Interrupt Enable for Pipe 9
    }

    /// SOFCFG Register bits
    namespace sofcfg_bits {
        constexpr uint32_t EDGESTS = (1U << 4);  ///< Edge Interrupt Output Status Monitor
        constexpr uint32_t BRDYM = (1U << 6);  ///< BRDY Interrupt Status Clear Timing
        constexpr uint32_t TRNENSEL = (1U << 8);  ///< Transaction-Enabled Time Select
    }

    /// INTSTS0 Register bits
    namespace intsts0_bits {
        constexpr uint32_t CTSQ = (3 << 0);  ///< Control Transfer Stage
        constexpr uint32_t VALID = (1U << 3);  ///< USB Request Reception
        constexpr uint32_t DVSQ = (3 << 4);  ///< Device State
        constexpr uint32_t VBSTS = (1U << 7);  ///< VBUS Input Status
        constexpr uint32_t BRDY = (1U << 8);  ///< Buffer Ready Interrupt Status
        constexpr uint32_t NRDY = (1U << 9);  ///< Buffer Not Ready Interrupt Status
        constexpr uint32_t BEMP = (1U << 10);  ///< Buffer Empty Interrupt Status
        constexpr uint32_t CTRT = (1U << 11);  ///< Control Transfer Stage Transition Interrupt Status
        constexpr uint32_t DVST = (1U << 12);  ///< Device State Transition Interrupt Status
        constexpr uint32_t SOFR = (1U << 13);  ///< Frame Number Refresh Interrupt Status
        constexpr uint32_t RESM = (1U << 14);  ///< Resume Interrupt Status
        constexpr uint32_t VBINT = (1U << 15);  ///< VBUS Interrupt Status
    }

    /// INTSTS1 Register bits
    namespace intsts1_bits {
        constexpr uint32_t PDDETINT = (1U << 0);  ///< PDDET Detection Interrupt Status Flag
        constexpr uint32_t SACK = (1U << 4);  ///< Setup Transaction Normal Response Interrupt Status
        constexpr uint32_t SIGN = (1U << 5);  ///< Setup Transaction Error Interrupt Status
        constexpr uint32_t EOFERR = (1U << 6);  ///< EOF Error Detection Interrupt Status
        constexpr uint32_t ATTCH = (1U << 11);  ///< ATTCH Interrupt Status
        constexpr uint32_t DTCH = (1U << 12);  ///< USB Disconnection Detection Interrupt Status
        constexpr uint32_t BCHG = (1U << 14);  ///< USB Bus Change Interrupt Status
        constexpr uint32_t OVRCR = (1U << 15);  ///< Overcurrent Input Change Interrupt Status
    }

    /// BRDYSTS Register bits
    namespace brdysts_bits {
        constexpr uint32_t PIPE0BRDY = (1U << 0);  ///< BRDY Interrupt Status for Pipe 0
        constexpr uint32_t PIPE1BRDY = (1U << 1);  ///< BRDY Interrupt Status for Pipe 1
        constexpr uint32_t PIPE2BRDY = (1U << 2);  ///< BRDY Interrupt Status for Pipe 2
        constexpr uint32_t PIPE3BRDY = (1U << 3);  ///< BRDY Interrupt Status for Pipe 3
        constexpr uint32_t PIPE4BRDY = (1U << 4);  ///< BRDY Interrupt Status for Pipe 4
        constexpr uint32_t PIPE5BRDY = (1U << 5);  ///< BRDY Interrupt Status for Pipe 5
        constexpr uint32_t PIPE6BRDY = (1U << 6);  ///< BRDY Interrupt Status for Pipe 6
        constexpr uint32_t PIPE7BRDY = (1U << 7);  ///< BRDY Interrupt Status for Pipe 7
        constexpr uint32_t PIPE8BRDY = (1U << 8);  ///< BRDY Interrupt Status for Pipe 8
        constexpr uint32_t PIPE9BRDY = (1U << 9);  ///< BRDY Interrupt Status for Pipe 9
    }

    /// NRDYSTS Register bits
    namespace nrdysts_bits {
        constexpr uint32_t PIPE0NRDY = (1U << 0);  ///< NRDY Interrupt Status for Pipe 0
        constexpr uint32_t PIPE1NRDY = (1U << 1);  ///< NRDY Interrupt Status for Pipe 1
        constexpr uint32_t PIPE2NRDY = (1U << 2);  ///< NRDY Interrupt Status for Pipe 2
        constexpr uint32_t PIPE3NRDY = (1U << 3);  ///< NRDY Interrupt Status for Pipe 3
        constexpr uint32_t PIPE4NRDY = (1U << 4);  ///< NRDY Interrupt Status for Pipe 4
        constexpr uint32_t PIPE5NRDY = (1U << 5);  ///< NRDY Interrupt Status for Pipe 5
        constexpr uint32_t PIPE6NRDY = (1U << 6);  ///< NRDY Interrupt Status for Pipe 6
        constexpr uint32_t PIPE7NRDY = (1U << 7);  ///< NRDY Interrupt Status for Pipe 7
        constexpr uint32_t PIPE8NRDY = (1U << 8);  ///< NRDY Interrupt Status for Pipe 8
        constexpr uint32_t PIPE9NRDY = (1U << 9);  ///< NRDY Interrupt Status for Pipe 9
    }

    /// BEMPSTS Register bits
    namespace bempsts_bits {
        constexpr uint32_t PIPE0BEMP = (1U << 0);  ///< BEMP Interrupt Status for Pipe 0
        constexpr uint32_t PIPE1BEMP = (1U << 1);  ///< BEMP Interrupt Status for Pipe 1
        constexpr uint32_t PIPE2BEMP = (1U << 2);  ///< BEMP Interrupt Status for Pipe 2
        constexpr uint32_t PIPE3BEMP = (1U << 3);  ///< BEMP Interrupt Status for Pipe 3
        constexpr uint32_t PIPE4BEMP = (1U << 4);  ///< BEMP Interrupt Status for Pipe 4
        constexpr uint32_t PIPE5BEMP = (1U << 5);  ///< BEMP Interrupt Status for Pipe 5
        constexpr uint32_t PIPE6BEMP = (1U << 6);  ///< BEMP Interrupt Status for Pipe 6
        constexpr uint32_t PIPE7BEMP = (1U << 7);  ///< BEMP Interrupt Status for Pipe 7
        constexpr uint32_t PIPE8BEMP = (1U << 8);  ///< BEMP Interrupt Status for Pipe 8
        constexpr uint32_t PIPE9BEMP = (1U << 9);  ///< BEMP Interrupt Status for Pipe 9
    }

    /// FRMNUM Register bits
    namespace frmnum_bits {
        constexpr uint32_t FRNM = (11 << 0);  ///< Frame Number
        constexpr uint32_t CRCE = (1U << 14);  ///< Receive Data Error
        constexpr uint32_t OVRN = (1U << 15);  ///< Overrun/Underrun Detection Status
    }

    /// DVCHGR Register bits
    namespace dvchgr_bits {
        constexpr uint32_t DVCHG = (1U << 15);  ///< Device State Change
    }

    /// USBADDR Register bits
    namespace usbaddr_bits {
        constexpr uint32_t USBADDR = (7 << 0);  ///< USB Address
        constexpr uint32_t STSRECOV = (4 << 8);  ///< Status Recovery
    }

    /// USBREQ Register bits
    namespace usbreq_bits {
        constexpr uint32_t BMREQUESTTYPE = (8 << 0);  ///< Request Type
        constexpr uint32_t BREQUEST = (8 << 8);  ///< Request
    }

    /// USBVAL Register bits
    namespace usbval_bits {
        constexpr uint32_t WVALUE = (16 << 0);  ///< Value
    }

    /// USBINDX Register bits
    namespace usbindx_bits {
        constexpr uint32_t WINDEX = (16 << 0);  ///< Index
    }

    /// USBLENG Register bits
    namespace usbleng_bits {
        constexpr uint32_t WLENTUH = (16 << 0);  ///< Length
    }

    /// DCPCFG Register bits
    namespace dcpcfg_bits {
        constexpr uint32_t DIR = (1U << 4);  ///< Transfer Direction
        constexpr uint32_t SHTNAK = (1U << 7);  ///< Pipe Disabled at End of Transfer
    }

    /// DCPMAXP Register bits
    namespace dcpmaxp_bits {
        constexpr uint32_t MXPS = (7 << 0);  ///< Maximum Packet Size
        constexpr uint32_t DEVSEL = (4 << 12);  ///< Device Select
    }

    /// DCPCTR Register bits
    namespace dcpctr_bits {
        constexpr uint32_t PID = (2 << 0);  ///< Response PID
        constexpr uint32_t CCPL = (1U << 2);  ///< Control Transfer End Enable
        constexpr uint32_t PBUSY = (1U << 5);  ///< Pipe Busy
        constexpr uint32_t SQMON = (1U << 6);  ///< Sequence Toggle Bit Monitor
        constexpr uint32_t SQSET = (1U << 7);  ///< Sequence Toggle Bit Set
        constexpr uint32_t SQCLR = (1U << 8);  ///< Sequence Toggle Bit Clear
        constexpr uint32_t SUREQCLR = (1U << 11);  ///< SUREQ Bit Clear
        constexpr uint32_t SUREQ = (1U << 14);  ///< Setup Token Transmission
        constexpr uint32_t BSTS = (1U << 15);  ///< Buffer Status
    }

    /// PIPESEL Register bits
    namespace pipesel_bits {
        constexpr uint32_t PIPESEL = (4 << 0);  ///< Pipe Window Select
    }

    /// PIPECFG Register bits
    namespace pipecfg_bits {
        constexpr uint32_t EPNUM = (4 << 0);  ///< Endpoint Number
        constexpr uint32_t DIR = (1U << 4);  ///< Transfer Direction
        constexpr uint32_t SHTNAK = (1U << 7);  ///< Pipe Disabled at End of Transfer
        constexpr uint32_t DBLB = (1U << 9);  ///< Double Buffer Mode
        constexpr uint32_t BFRE = (1U << 10);  ///< BRDY Interrupt Operation Specification
        constexpr uint32_t TYPE = (2 << 14);  ///< Transfer Type
    }

    /// PIPEMAXP Register bits
    namespace pipemaxp_bits {
        constexpr uint32_t MXPS = (9 << 0);  ///< Maximum Packet Size
        constexpr uint32_t DEVSEL = (4 << 12);  ///< Device Select
    }

    /// PIPEPERI Register bits
    namespace pipeperi_bits {
        constexpr uint32_t IITV = (3 << 0);  ///< Interval Error Detection Interval
        constexpr uint32_t IFIS = (1U << 12);  ///< Isochronous IN Buffer Flush
    }

    /// PIPE%sCTR Register bits
    namespace pipe%sctr_bits {
        constexpr uint32_t PID = (2 << 0);  ///< Response PID
        constexpr uint32_t PBUSY = (1U << 5);  ///< Pipe Busy
        constexpr uint32_t SQMON = (1U << 6);  ///< Sequence Toggle Bit Confirmation
        constexpr uint32_t SQSET = (1U << 7);  ///< Sequence Toggle Bit Set
        constexpr uint32_t SQCLR = (1U << 8);  ///< Sequence Toggle Bit Clear
        constexpr uint32_t ACLRM = (1U << 9);  ///< Auto Buffer Clear Mode
        constexpr uint32_t BSTS = (1U << 15);  ///< Buffer Status
    }

    /// PIPE%sTRE Register bits
    namespace pipe%stre_bits {
        constexpr uint32_t TRCLR = (1U << 8);  ///< Transaction Counter Clear
        constexpr uint32_t TRENB = (1U << 9);  ///< Transaction Counter Enable
    }

    /// PIPE%sTRN Register bits
    namespace pipe%strn_bits {
        constexpr uint32_t TRNCNT = (16 << 0);  ///< Transaction Counter
    }

    /// BCCTRL1 Register bits
    namespace bcctrl1_bits {
        constexpr uint32_t RPDME = (1U << 0);  ///< D- Line Pull-down Control
        constexpr uint32_t IDPSRCE = (1U << 1);  ///< D+ Line IDPSRC Output Control
        constexpr uint32_t VDMSRCE = (1U << 2);  ///< D- Line VDMSRC (0.6 V) Output Control
        constexpr uint32_t VDPSRCE = (1U << 3);  ///< D+ Line VDPSRC (0.6 V) Output Control
        constexpr uint32_t PDDETE = (1U << 4);  ///< D+ Line 0.6V Input Detection Control
        constexpr uint32_t CHGDETE = (1U << 5);  ///< D- Line 0.6V Input Detection Control
        constexpr uint32_t PDDETSTS = (1U << 8);  ///< D+ Line 0.6 V Input Detection Status Flag
        constexpr uint32_t CHGDETSTS = (1U << 9);  ///< D- Line 0.6 V Input Detection Status Flag
    }

    /// BCCTRL2 Register bits
    namespace bcctrl2_bits {
        constexpr uint32_t DCPMODE = (1U << 6);  ///< Dedicated Charging Port (DCP) Mode Control
        constexpr uint32_t BATCHGE = (1U << 7);  ///< Battery Charging Enable
        constexpr uint32_t PHYDET = (2 << 12);  ///< Detect Sensitivity Adjustment
    }

    /// DEVADD%s Register bits
    namespace devadd%s_bits {
        constexpr uint32_t USBSPD = (2 << 6);  ///< Transfer Speed of Communication Target Device
    }

    /// PHYSECTRL Register bits
    namespace physectrl_bits {
        constexpr uint32_t CNEN = (1U << 4);  ///< Single-ended Receiver Enable
    }

    /// DPUSR0R Register bits
    namespace dpusr0r_bits {
        constexpr uint32_t SRPC0 = (1U << 0);  ///< USB Single-ended Receiver Control
        constexpr uint32_t RPUE0 = (1U << 1);  ///< DP Pull-Up Resistor Control
        constexpr uint32_t DRPD0 = (1U << 3);  ///< D+/D- Pull-Down Resistor Control
        constexpr uint32_t FIXPHY0 = (1U << 4);  ///< USB Transceiver Output Fix
        constexpr uint32_t DP0 = (1U << 16);  ///< USB D+ Input
        constexpr uint32_t DM0 = (1U << 17);  ///< USB D- Input
        constexpr uint32_t DOVCA0 = (1U << 20);  ///< USB OVRCURA Input
        constexpr uint32_t DOVCB0 = (1U << 21);  ///< USB OVRCURB Input
        constexpr uint32_t DVBSTS0 = (1U << 23);  ///< USB VBUS Input
    }

    /// DPUSR1R Register bits
    namespace dpusr1r_bits {
        constexpr uint32_t DPINTE0 = (1U << 0);  ///< USB DP Interrupt Enable/Clear
        constexpr uint32_t DMINTE0 = (1U << 1);  ///< USB DM Interrupt Enable/Clear
        constexpr uint32_t DOVRCRAE0 = (1U << 4);  ///< USB OVRCURA Interrupt Enable/Clear
        constexpr uint32_t DOVRCRBE0 = (1U << 5);  ///< USB OVRCURB Interrupt Enable/Clear
        constexpr uint32_t DVBSE0 = (1U << 7);  ///< USB VBUS Interrupt Enable/Clear
        constexpr uint32_t DPINT0 = (1U << 16);  ///< USB DP Interrupt Source Recovery
        constexpr uint32_t DMINT0 = (1U << 17);  ///< USB DM Interrupt Source Recovery
        constexpr uint32_t DOVRCRA0 = (1U << 20);  ///< USB OVRCURA Interrupt Source Recovery
        constexpr uint32_t DOVRCRB0 = (1U << 21);  ///< USB OVRCURB Interrupt Source Recovery
        constexpr uint32_t DVBINT0 = (1U << 23);  ///< USB VBUS Interrupt Source Recovery
    }

}

// ============================================================================
// SDHI0 Peripheral
// ============================================================================

namespace sdhi0 {
    /// Base addresses
    constexpr uint32_t SDHI0_BASE = 0x40092000;

    /// SDHI0 Register structure
    struct Registers {
        volatile uint32_t SD_CMD;  ///< Offset: 0x00 - Command Type Register
        volatile uint32_t SD_ARG;  ///< Offset: 0x08 - SD Command Argument Register
        volatile uint32_t SD_ARG1;  ///< Offset: 0x0C - SD Command Argument Register 1
        volatile uint32_t SD_STOP;  ///< Offset: 0x10 - Data Stop Register
        volatile uint32_t SD_SECCNT;  ///< Offset: 0x14 - Block Count Register
        volatile uint32_t SD_RSP10;  ///< Offset: 0x18 - SD Card Response Register 10
        volatile uint32_t SD_RSP1;  ///< Offset: 0x1C - SD Card Response Register 1
        volatile uint32_t SD_RSP32;  ///< Offset: 0x20 - SD Card Response Register 32
        volatile uint32_t SD_RSP3;  ///< Offset: 0x24 - SD Card Response Register 3
        volatile uint32_t SD_RSP54;  ///< Offset: 0x28 - SD Card Response Register 54
        volatile uint32_t SD_RSP5;  ///< Offset: 0x2C - SD Card Response Register 5
        volatile uint32_t SD_RSP76;  ///< Offset: 0x30 - SD Card Response Register 76
        volatile uint32_t SD_RSP7;  ///< Offset: 0x34 - SD Card Response Register 7
        volatile uint32_t SD_INFO1;  ///< Offset: 0x38 - SD Card Interrupt Flag Register 1
        volatile uint32_t SD_INFO2;  ///< Offset: 0x3C - SD Card Interrupt Flag Register 2
        volatile uint32_t SD_INFO1_MASK;  ///< Offset: 0x40 - SD INFO1 Interrupt Mask Register
        volatile uint32_t SD_INFO2_MASK;  ///< Offset: 0x44 - SD INFO2 Interrupt Mask Register
        volatile uint32_t SD_CLK_CTRL;  ///< Offset: 0x48 - SD Clock Control Register
        volatile uint32_t SD_SIZE;  ///< Offset: 0x4C - Transfer Data Length Register
        volatile uint32_t SD_OPTION;  ///< Offset: 0x50 - SD Card Access Control Option Register
        volatile uint32_t SD_ERR_STS1;  ///< Offset: 0x58 - SD Error Status Register 1
        volatile uint32_t SD_ERR_STS2;  ///< Offset: 0x5C - SD Error Status Register 2
        volatile uint32_t SD_BUF0;  ///< Offset: 0x60 - SD Buffer Register
        volatile uint32_t SDIO_MODE;  ///< Offset: 0x68 - SDIO Mode Control Register
        volatile uint32_t SDIO_INFO1;  ///< Offset: 0x6C - SDIO Interrupt Flag Register
        volatile uint32_t SDIO_INFO1_MASK;  ///< Offset: 0x70 - SDIO INFO1 Interrupt Mask Register
        volatile uint32_t SD_DMAEN;  ///< Offset: 0x1B0 - DMA Mode Enable Register
        volatile uint32_t SOFT_RST;  ///< Offset: 0x1C0 - Software Reset Register
        volatile uint32_t SDIF_MODE;  ///< Offset: 0x1CC - SD Interface Mode Setting Register
        volatile uint32_t EXT_SWAP;  ///< Offset: 0x1E0 - Swap Control Register
    };

    /// Peripheral instances
    inline Registers* SDHI0 = reinterpret_cast<Registers*>(SDHI0_BASE);

    // Bit definitions
    /// SD_CMD Register bits
    namespace sd_cmd_bits {
        constexpr uint32_t CMDIDX = (6 << 0);  ///< Command Index Field Value Select
        constexpr uint32_t ACMD = (2 << 6);  ///< Command Type Select
        constexpr uint32_t RSPTP = (3 << 8);  ///< Response Type Select
        constexpr uint32_t CMDTP = (1U << 11);  ///< Data Transfer Select
        constexpr uint32_t CMDRW = (1U << 12);  ///< Data Transfer Direction Select
        constexpr uint32_t TRSTP = (1U << 13);  ///< Block Transfer Select
        constexpr uint32_t CMD12AT = (2 << 14);  ///< CMD12 Automatic Issue Select
    }

    /// SD_STOP Register bits
    namespace sd_stop_bits {
        constexpr uint32_t STP = (1U << 0);  ///< Transfer Stop
        constexpr uint32_t SEC = (1U << 8);  ///< Block Count Register Value Select
    }

    /// SD_RSP76 Register bits
    namespace sd_rsp76_bits {
        constexpr uint32_t SD_RSP76 = (24 << 0);  ///< These bits store the response from the SD card/MMC.
    }

    /// SD_RSP7 Register bits
    namespace sd_rsp7_bits {
        constexpr uint32_t SD_RSP7 = (8 << 0);  ///< These bits store the response from the SD card/MMC.
    }

    /// SD_INFO1 Register bits
    namespace sd_info1_bits {
        constexpr uint32_t RSPEND = (1U << 0);  ///< Response End Detection Flag
        constexpr uint32_t ACEND = (1U << 2);  ///< Access End Detection Flag
        constexpr uint32_t SDCDRM = (1U << 3);  ///< SDnCD Removal Flag
        constexpr uint32_t SDCDIN = (1U << 4);  ///< SDnCD Insertion Flag
        constexpr uint32_t SDCDMON = (1U << 5);  ///< SDnCD Pin Monitor Flag
        constexpr uint32_t SDWPMON = (1U << 7);  ///< SDnWP Pin Monitor Flag
        constexpr uint32_t SDD3RM = (1U << 8);  ///< SDnDAT3 Removal Flag
        constexpr uint32_t SDD3IN = (1U << 9);  ///< SDnDAT3 Insertion Flag
        constexpr uint32_t SDD3MON = (1U << 10);  ///< SDnDAT3 Pin Monitor Flag
    }

    /// SD_INFO2 Register bits
    namespace sd_info2_bits {
        constexpr uint32_t CMDE = (1U << 0);  ///< Command Error Detection Flag
        constexpr uint32_t CRCE = (1U << 1);  ///< CRC Error Detection Flag
        constexpr uint32_t ENDE = (1U << 2);  ///< End Bit Error Detection Flag
        constexpr uint32_t DTO = (1U << 3);  ///< Data Timeout Detection Flag
        constexpr uint32_t ILW = (1U << 4);  ///< SD_BUF0 Illegal Write Access Detection Flag
        constexpr uint32_t ILR = (1U << 5);  ///< SD_BUF0 Illegal Read Access Detection Flag
        constexpr uint32_t RSPTO = (1U << 6);  ///< Response Timeout Detection Flag
        constexpr uint32_t SDD0MON = (1U << 7);  ///< SDnDAT0 Pin Status Flag
        constexpr uint32_t BRE = (1U << 8);  ///< SD_BUF0 Read Enable Flag
        constexpr uint32_t BWE = (1U << 9);  ///< SD_BUF0 Write Enable Flag
        constexpr uint32_t SD_CLK_CTRLEN = (1U << 13);  ///< SD_CLK_CTRL Write Enable Flag
        constexpr uint32_t CBSY = (1U << 14);  ///< Command Sequence Status Flag
        constexpr uint32_t ILA = (1U << 15);  ///< Illegal Access Error Detection Flag
    }

    /// SD_INFO1_MASK Register bits
    namespace sd_info1_mask_bits {
        constexpr uint32_t RSPENDM = (1U << 0);  ///< Response End Interrupt Request Mask
        constexpr uint32_t ACENDM = (1U << 2);  ///< Access End Interrupt Request Mask
        constexpr uint32_t SDCDRMM = (1U << 3);  ///< SDnCD Removal Interrupt Request Mask
        constexpr uint32_t SDCDINM = (1U << 4);  ///< SDnCD Insertion Interrupt Request Mask
        constexpr uint32_t SDD3RMM = (1U << 8);  ///< SDnDAT3 Removal Interrupt Request Mask
        constexpr uint32_t SDD3INM = (1U << 9);  ///< SDnDAT3 Insertion Interrupt Request Mask
    }

    /// SD_INFO2_MASK Register bits
    namespace sd_info2_mask_bits {
        constexpr uint32_t CMDEM = (1U << 0);  ///< Command Error Interrupt Request Mask
        constexpr uint32_t CRCEM = (1U << 1);  ///< CRC Error Interrupt Request Mask
        constexpr uint32_t ENDEM = (1U << 2);  ///< End Bit Error Interrupt Request Mask
        constexpr uint32_t DTOM = (1U << 3);  ///< Data Timeout Interrupt Request Mask
        constexpr uint32_t ILWM = (1U << 4);  ///< SD_BUF0 Register Illegal Write Interrupt Request Mask
        constexpr uint32_t ILRM = (1U << 5);  ///< SD_BUF0 Register Illegal Read Interrupt Request Mask
        constexpr uint32_t RSPTOM = (1U << 6);  ///< Response Timeout Interrupt Request Mask
        constexpr uint32_t BREM = (1U << 8);  ///< BRE Interrupt Request Mask
        constexpr uint32_t BWEM = (1U << 9);  ///< BWE Interrupt Request Mask
        constexpr uint32_t ILAM = (1U << 15);  ///< Illegal Access Error Interrupt Request Mask
    }

    /// SD_CLK_CTRL Register bits
    namespace sd_clk_ctrl_bits {
        constexpr uint32_t CLKSEL = (8 << 0);  ///< SDHI Clock Frequency Select
        constexpr uint32_t CLKEN = (1U << 8);  ///< SD/MMC Clock Output Control
        constexpr uint32_t CLKCTRLEN = (1U << 9);  ///< SD/MMC Clock Output Automatic Control Select
    }

    /// SD_SIZE Register bits
    namespace sd_size_bits {
        constexpr uint32_t LEN = (10 << 0);  ///< Transfer Data Size Setting
    }

    /// SD_OPTION Register bits
    namespace sd_option_bits {
        constexpr uint32_t CTOP = (4 << 0);  ///< Card Detection Time Counter
        constexpr uint32_t TOP = (4 << 4);  ///< Timeout Counter
        constexpr uint32_t TOUTMASK = (1U << 8);  ///< Timeout Mask
        constexpr uint32_t WIDTH8 = (1U << 13);  ///< Bus Width
        constexpr uint32_t WIDTH = (1U << 15);  ///< Bus Width
    }

    /// SD_ERR_STS1 Register bits
    namespace sd_err_sts1_bits {
        constexpr uint32_t CMDE0 = (1U << 0);  ///< Command Error Flag 0
        constexpr uint32_t CMDE1 = (1U << 1);  ///< Command Error Flag 1
        constexpr uint32_t RSPLENE0 = (1U << 2);  ///< Response Length Error Flag 0
        constexpr uint32_t RSPLENE1 = (1U << 3);  ///< Response Length Error Flag 1
        constexpr uint32_t RDLENE = (1U << 4);  ///< Read Data Length Error Flag
        constexpr uint32_t CRCLENE = (1U << 5);  ///< CRC Status Token Length Error Flag
        constexpr uint32_t RSPCRCE0 = (1U << 8);  ///< Response CRC Error Flag 0
        constexpr uint32_t RSPCRCE1 = (1U << 9);  ///< Response CRC Error Flag 1
        constexpr uint32_t RDCRCE = (1U << 10);  ///< Read Data CRC Error Flag
        constexpr uint32_t CRCTKE = (1U << 11);  ///< CRC Status Token Error Flag
        constexpr uint32_t CRCTK = (3 << 12);  ///< CRC Status Token
    }

    /// SD_ERR_STS2 Register bits
    namespace sd_err_sts2_bits {
        constexpr uint32_t RSPTO0 = (1U << 0);  ///< Response Timeout Flag 0
        constexpr uint32_t RSPTO1 = (1U << 1);  ///< Response Timeout Flag 1
        constexpr uint32_t BSYTO0 = (1U << 2);  ///< Busy Timeout Flag 0
        constexpr uint32_t BSYTO1 = (1U << 3);  ///< Busy Timeout Flag 1
        constexpr uint32_t RDTO = (1U << 4);  ///< Read Data Timeout Flag
        constexpr uint32_t CRCTO = (1U << 5);  ///< CRC Status Token Timeout Flag
        constexpr uint32_t CRCBSYTO = (1U << 6);  ///< CRC Status Token Busy Timeout Flag
    }

    /// SDIO_MODE Register bits
    namespace sdio_mode_bits {
        constexpr uint32_t INTEN = (1U << 0);  ///< SDIO Interrupt Acceptance Enable
        constexpr uint32_t RWREQ = (1U << 2);  ///< Read Wait Request
        constexpr uint32_t IOABT = (1U << 8);  ///< SDIO Abort
        constexpr uint32_t C52PUB = (1U << 9);  ///< SDIO None Abort
    }

    /// SDIO_INFO1 Register bits
    namespace sdio_info1_bits {
        constexpr uint32_t IOIRQ = (1U << 0);  ///< SDIO Interrupt Status Flag
        constexpr uint32_t EXPUB52 = (1U << 14);  ///< EXPUB52 Status Flag
        constexpr uint32_t EXWT = (1U << 15);  ///< EXWT Status Flag
    }

    /// SDIO_INFO1_MASK Register bits
    namespace sdio_info1_mask_bits {
        constexpr uint32_t IOIRQM = (1U << 0);  ///< IOIRQ Interrupt Mask Control
        constexpr uint32_t EXPUB52M = (1U << 14);  ///< EXPUB52 Interrupt Request Mask Control
        constexpr uint32_t EXWTM = (1U << 15);  ///< EXWT Interrupt Request Mask Control
    }

    /// SD_DMAEN Register bits
    namespace sd_dmaen_bits {
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Transfer Enable
    }

    /// SOFT_RST Register bits
    namespace soft_rst_bits {
        constexpr uint32_t SDRST = (1U << 0);  ///< Software Reset Control
    }

    /// SDIF_MODE Register bits
    namespace sdif_mode_bits {
        constexpr uint32_t NOCHKCR = (1U << 8);  ///< CRC Check Mask
    }

    /// EXT_SWAP Register bits
    namespace ext_swap_bits {
        constexpr uint32_t BWSWP = (1U << 6);  ///< SD_BUF0 Swap Write
        constexpr uint32_t BRSWP = (1U << 7);  ///< SD_BUF0 Swap Read
    }

}

// ============================================================================
// SSIE0 Peripheral
// ============================================================================

namespace ssie0 {
    /// Base addresses
    constexpr uint32_t SSIE0_BASE = 0x4009D000;

    /// SSIE0 Register structure
    struct Registers {
        volatile uint32_t SSICR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SSISR;  ///< Offset: 0x04 - Status Register
        volatile uint32_t SSIFCR;  ///< Offset: 0x10 - FIFO Control Register
        volatile uint32_t SSIFSR;  ///< Offset: 0x14 - FIFO Status Register
        volatile uint32_t SSIFTDR;  ///< Offset: 0x18 - Transmit FIFO Data Register
        volatile uint32_t SSIFRDR;  ///< Offset: 0x1C - Receive FIFO Data Register
        volatile uint32_t SSIOFR;  ///< Offset: 0x20 - Audio Format Register
        volatile uint32_t SSISCR;  ///< Offset: 0x24 - Status Control Register
    };

    /// Peripheral instances
    inline Registers* SSIE0 = reinterpret_cast<Registers*>(SSIE0_BASE);

    // Bit definitions
    /// SSICR Register bits
    namespace ssicr_bits {
        constexpr uint32_t REN = (1U << 0);  ///< Reception Enable
        constexpr uint32_t TEN = (1U << 1);  ///< Transmission Enable
        constexpr uint32_t MUEN = (1U << 3);  ///< Mute Enable
        constexpr uint32_t CKDV = (4 << 4);  ///< Selects Bit Clock Division Ratio
        constexpr uint32_t DEL = (1U << 8);  ///< Selects Serial Data Delay
        constexpr uint32_t PDTA = (1U << 9);  ///< Selects Placement Data Alignment
        constexpr uint32_t SDTA = (1U << 10);  ///< Selects Serial Data Alignment
        constexpr uint32_t SPDP = (1U << 11);  ///< Selects Serial Padding Polarity
        constexpr uint32_t LRCKP = (1U << 12);  ///< Selects the Initial Value and Polarity of LR Clock/Frame Synchronization Signal
        constexpr uint32_t BCKP = (1U << 13);  ///< Selects Bit Clock Polarity
        constexpr uint32_t MST = (1U << 14);  ///< Master Enable
        constexpr uint32_t SWL = (3 << 16);  ///< Selects System Word Length
        constexpr uint32_t DWL = (3 << 19);  ///< Selects Data Word Length
        constexpr uint32_t FRM = (2 << 22);  ///< Selects Frame Word Number
        constexpr uint32_t IIEN = (1U << 25);  ///< Idle Mode Interrupt Output Enable
        constexpr uint32_t ROIEN = (1U << 26);  ///< Receive Overflow Interrupt Output Enable
        constexpr uint32_t RUIEN = (1U << 27);  ///< Receive Underflow Interrupt Output Enable
        constexpr uint32_t TOIEN = (1U << 28);  ///< Transmit Overflow Interrupt Output Enable
        constexpr uint32_t TUIEN = (1U << 29);  ///< Transmit Underflow Interrupt Output Enable
        constexpr uint32_t CKS = (1U << 30);  ///< Selects an Audio Clock for Master-mode Communication
    }

    /// SSISR Register bits
    namespace ssisr_bits {
        constexpr uint32_t IIRQ = (1U << 25);  ///< Idle Mode Status Flag
        constexpr uint32_t ROIRQ = (1U << 26);  ///< Receive Overflow Error Status Flag
        constexpr uint32_t RUIRQ = (1U << 27);  ///< Receive Underflow Error Status Flag
        constexpr uint32_t TOIRQ = (1U << 28);  ///< Transmit Overflow Error Status Flag
        constexpr uint32_t TUIRQ = (1U << 29);  ///< Transmit Underflow Error Status flag
    }

    /// SSIFCR Register bits
    namespace ssifcr_bits {
        constexpr uint32_t RFRST = (1U << 0);  ///< Receive FIFO Data Register Reset
        constexpr uint32_t TFRST = (1U << 1);  ///< Transmit FIFO Data Register Reset
        constexpr uint32_t RIE = (1U << 2);  ///< Receive Data Full Interrupt Output Enable
        constexpr uint32_t TIE = (1U << 3);  ///< Transmit Data Empty Interrupt Output Enable
        constexpr uint32_t BSW = (1U << 11);  ///< Byte Swap Enable
        constexpr uint32_t SSIRST = (1U << 16);  ///< Software Reset
        constexpr uint32_t AUCKE = (1U << 31);  ///< AUDIO_MCK Enable in Mastermode Communication
    }

    /// SSIFSR Register bits
    namespace ssifsr_bits {
        constexpr uint32_t RDF = (1U << 0);  ///< Receive Data Full Flag
        constexpr uint32_t RDC = (6 << 8);  ///< Number of Receive FIFO Data Indication Flag
        constexpr uint32_t TDE = (1U << 16);  ///< Transmit Data Empty Flag
        constexpr uint32_t TDC = (6 << 24);  ///< Number of Transmit FIFO Data Indication Flag
    }

    /// SSIFTDR Register bits
    namespace ssiftdr_bits {
        constexpr uint32_t SSIFTDR = (32 << 0);  ///< Transmit FIFO Data
    }

    /// SSIFRDR Register bits
    namespace ssifrdr_bits {
        constexpr uint32_t SSIFRDR = (32 << 0);  ///< Receive FIFO Data
    }

    /// SSIOFR Register bits
    namespace ssiofr_bits {
        constexpr uint32_t OMOD = (2 << 0);  ///< Audio Format Select
        constexpr uint32_t LRCONT = (1U << 8);  ///< Whether to Enable LRCK/FS Continuation
        constexpr uint32_t BCKASTP = (1U << 9);  ///< Whether to Enable Stopping BCK Output When SSIE is in Idle Status
    }

    /// SSISCR Register bits
    namespace ssiscr_bits {
        constexpr uint32_t RDFS = (5 << 0);  ///< RDF Setting Condition Select
        constexpr uint32_t TDES = (5 << 8);  ///< TDE Setting Condition Select
    }

}

// ============================================================================
// IIC0 Peripheral
// ============================================================================

namespace iic0 {
    /// Base addresses
    constexpr uint32_t IIC0_BASE = 0x4009F000;

    /// IIC0 Register structure
    struct Registers {
        volatile uint32_t ICCR1;  ///< Offset: 0x00 - I2C Bus Control Register 1
        volatile uint32_t ICCR2;  ///< Offset: 0x01 - I2C Bus Control Register 2
        volatile uint32_t ICMR1;  ///< Offset: 0x02 - I2C Bus Mode Register 1
        volatile uint32_t ICMR2;  ///< Offset: 0x03 - I2C Bus Mode Register 2
        volatile uint32_t ICMR3;  ///< Offset: 0x04 - I2C Bus Mode Register 3
        volatile uint32_t ICFER;  ///< Offset: 0x05 - I2C Bus Function Enable Register
        volatile uint32_t ICSER;  ///< Offset: 0x06 - I2C Bus Status Enable Register
        volatile uint32_t ICIER;  ///< Offset: 0x07 - I2C Bus Interrupt Enable Register
        volatile uint32_t ICSR1;  ///< Offset: 0x08 - I2C Bus Status Register 1
        volatile uint32_t ICSR2;  ///< Offset: 0x09 - I2C Bus Status Register 2
        volatile uint32_t SARL%s;  ///< Offset: 0x0A - Slave Address Register Ly
        volatile uint32_t SARU%s;  ///< Offset: 0x0B - Slave Address Register Uy
        volatile uint32_t ICBRL;  ///< Offset: 0x10 - I2C Bus Bit Rate Low-Level Register
        volatile uint32_t ICBRH;  ///< Offset: 0x11 - I2C Bus Bit Rate High-Level Register
        volatile uint32_t ICDRT;  ///< Offset: 0x12 - I2C Bus Transmit Data Register
        volatile uint32_t ICDRR;  ///< Offset: 0x13 - I2C Bus Receive Data Register
    };

    /// Peripheral instances
    inline Registers* IIC0 = reinterpret_cast<Registers*>(IIC0_BASE);

    // Bit definitions
    /// ICCR1 Register bits
    namespace iccr1_bits {
        constexpr uint32_t SDAI = (1U << 0);  ///< SDA Line Monitor
        constexpr uint32_t SCLI = (1U << 1);  ///< SCL Line Monitor
        constexpr uint32_t SDAO = (1U << 2);  ///< SDA Output Control/Monitor
        constexpr uint32_t SCLO = (1U << 3);  ///< SCL Output Control/Monitor
        constexpr uint32_t SOWP = (1U << 4);  ///< SCLO/SDAO Write Protect
        constexpr uint32_t CLO = (1U << 5);  ///< Extra SCL Clock Cycle Output
        constexpr uint32_t IICRST = (1U << 6);  ///< I2C Bus Interface Internal Reset
        constexpr uint32_t ICE = (1U << 7);  ///< I2C Bus Interface Enable
    }

    /// ICCR2 Register bits
    namespace iccr2_bits {
        constexpr uint32_t ST = (1U << 1);  ///< Start Condition Issuance Request
        constexpr uint32_t RS = (1U << 2);  ///< Restart Condition Issuance Request
        constexpr uint32_t SP = (1U << 3);  ///< Stop Condition Issuance Request
        constexpr uint32_t TRS = (1U << 5);  ///< Transmit/Receive Mode
        constexpr uint32_t MST = (1U << 6);  ///< Master/Slave Mode
        constexpr uint32_t BBSY = (1U << 7);  ///< Bus Busy Detection Flag
    }

    /// ICMR1 Register bits
    namespace icmr1_bits {
        constexpr uint32_t BC = (3 << 0);  ///< Bit Counter
        constexpr uint32_t BCWP = (1U << 3);  ///< BC Write Protect
        constexpr uint32_t CKS = (3 << 4);  ///< Internal Reference Clock Select
        constexpr uint32_t MTWP = (1U << 7);  ///< MST/TRS Write Protect
    }

    /// ICMR2 Register bits
    namespace icmr2_bits {
        constexpr uint32_t TMOS = (1U << 0);  ///< Timeout Detection Time Select
        constexpr uint32_t TMOL = (1U << 1);  ///< Timeout L Count Control
        constexpr uint32_t TMOH = (1U << 2);  ///< Timeout H Count Control
        constexpr uint32_t SDDL = (3 << 4);  ///< SDA Output Delay Counter
        constexpr uint32_t DLCS = (1U << 7);  ///< SDA Output Delay Clock Source Select
    }

    /// ICMR3 Register bits
    namespace icmr3_bits {
        constexpr uint32_t NF = (2 << 0);  ///< Noise Filter Stage Select
        constexpr uint32_t ACKBR = (1U << 2);  ///< Receive Acknowledge
        constexpr uint32_t ACKBT = (1U << 3);  ///< Transmit Acknowledge
        constexpr uint32_t ACKWP = (1U << 4);  ///< ACKBT Write Protect
        constexpr uint32_t RDRFS = (1U << 5);  ///< RDRF Flag Set Timing Select
        constexpr uint32_t WAIT = (1U << 6);  ///< Low-hold is released by reading ICDRR.
        constexpr uint32_t SMBS = (1U << 7);  ///< SMBus/I2C Bus Select
    }

    /// ICFER Register bits
    namespace icfer_bits {
        constexpr uint32_t TMOE = (1U << 0);  ///< Timeout Function Enable
        constexpr uint32_t MALE = (1U << 1);  ///< Master Arbitration-Lost Detection Enable
        constexpr uint32_t NALE = (1U << 2);  ///< NACK Transmission Arbitration-Lost Detection Enable
        constexpr uint32_t SALE = (1U << 3);  ///< Slave Arbitration-Lost Detection Enable
        constexpr uint32_t NACKE = (1U << 4);  ///< NACK Reception Transfer Suspension Enable
        constexpr uint32_t NFE = (1U << 5);  ///< Digital Noise Filter Circuit Enable
        constexpr uint32_t SCLE = (1U << 6);  ///< SCL Synchronous Circuit Enable
        constexpr uint32_t FMPE = (1U << 7);  ///< Fast-Mode Plus Enable
    }

    /// ICSER Register bits
    namespace icser_bits {
        constexpr uint32_t SAR0E = (1U << 0);  ///< Slave Address Register 0 Enable
        constexpr uint32_t SAR1E = (1U << 1);  ///< Slave Address Register 1 Enable
        constexpr uint32_t SAR2E = (1U << 2);  ///< Slave Address Register 2 Enable
        constexpr uint32_t GCAE = (1U << 3);  ///< General Call Address Enable
        constexpr uint32_t DIDE = (1U << 5);  ///< Device-ID Address Detection Enable
        constexpr uint32_t HOAE = (1U << 7);  ///< Host Address Enable
    }

    /// ICIER Register bits
    namespace icier_bits {
        constexpr uint32_t TMOIE = (1U << 0);  ///< Timeout Interrupt Request Enable
        constexpr uint32_t ALIE = (1U << 1);  ///< Arbitration-Lost Interrupt Request Enable
        constexpr uint32_t STIE = (1U << 2);  ///< Start Condition Detection Interrupt Request Enable
        constexpr uint32_t SPIE = (1U << 3);  ///< Stop Condition Detection Interrupt Request Enable
        constexpr uint32_t NAKIE = (1U << 4);  ///< NACK Reception Interrupt Request Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receive Data Full Interrupt Request Enable
        constexpr uint32_t TEIE = (1U << 6);  ///< Transmit End Interrupt Request Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Data Empty Interrupt Request Enable
    }

    /// ICSR1 Register bits
    namespace icsr1_bits {
        constexpr uint32_t AAS0 = (1U << 0);  ///< Slave Address 0 Detection Flag
        constexpr uint32_t AAS1 = (1U << 1);  ///< Slave Address 1 Detection Flag
        constexpr uint32_t AAS2 = (1U << 2);  ///< Slave Address 2 Detection Flag
        constexpr uint32_t GCA = (1U << 3);  ///< General Call Address Detection Flag
        constexpr uint32_t DID = (1U << 5);  ///< Device-ID Address Detection Flag
        constexpr uint32_t HOA = (1U << 7);  ///< Host Address Detection Flag
    }

    /// ICSR2 Register bits
    namespace icsr2_bits {
        constexpr uint32_t TMOF = (1U << 0);  ///< Timeout Detection Flag
        constexpr uint32_t AL = (1U << 1);  ///< Arbitration-Lost Flag
        constexpr uint32_t START = (1U << 2);  ///< Start Condition Detection Flag
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Condition Detection Flag
        constexpr uint32_t NACKF = (1U << 4);  ///< NACK Detection Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Full Flag
        constexpr uint32_t TEND = (1U << 6);  ///< Transmit End Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SARL%s Register bits
    namespace sarl%s_bits {
        constexpr uint32_t SVA0 = (1U << 0);  ///< 10-bit Address LSB
        constexpr uint32_t SVA = (7 << 1);  ///< 7-bit Address/10-bit Address Lower Bits
    }

    /// SARU%s Register bits
    namespace saru%s_bits {
        constexpr uint32_t FS = (1U << 0);  ///< 7-bit/10-bit Address Format Select
        constexpr uint32_t SVA = (2 << 1);  ///< 10-bit Address Upper Bits
    }

    /// ICBRL Register bits
    namespace icbrl_bits {
        constexpr uint32_t BRL = (5 << 0);  ///< Bit Rate Low-Level Period
    }

    /// ICBRH Register bits
    namespace icbrh_bits {
        constexpr uint32_t BRH = (5 << 0);  ///< Bit Rate High-Level Period
    }

}

// ============================================================================
// IIC0WU Peripheral
// ============================================================================

namespace iic0wu {
    /// Base addresses
    constexpr uint32_t IIC0WU_BASE = 0x4009F014;

    /// IIC0WU Register structure
    struct Registers {
        volatile uint32_t ICWUR;  ///< Offset: 0x02 - I2C Bus Wakeup Unit Register
        volatile uint32_t ICWUR2;  ///< Offset: 0x03 - I2C Bus Wakeup Unit Register 2
    };

    /// Peripheral instances
    inline Registers* IIC0WU = reinterpret_cast<Registers*>(IIC0WU_BASE);

    // Bit definitions
    /// ICWUR Register bits
    namespace icwur_bits {
        constexpr uint32_t WUAFA = (1U << 0);  ///< Wakeup Analog Filter Additional Selection
        constexpr uint32_t WUACK = (1U << 4);  ///< ACK Bit for Wakeup Mode
        constexpr uint32_t WUF = (1U << 5);  ///< Wakeup Event Occurrence Flag
        constexpr uint32_t WUIE = (1U << 6);  ///< Wakeup Interrupt Request Enable
        constexpr uint32_t WUE = (1U << 7);  ///< Wakeup Function Enable
    }

    /// ICWUR2 Register bits
    namespace icwur2_bits {
        constexpr uint32_t WUSEN = (1U << 0);  ///< Wakeup Function Synchronous Enable
        constexpr uint32_t WUASYF = (1U << 1);  ///< Wakeup Function Asynchronous Operation Status Flag
        constexpr uint32_t WUSYF = (1U << 2);  ///< Wakeup Function Synchronous Operation Status Flag
    }

}

// ============================================================================
// IIC1 Peripheral
// ============================================================================

namespace iic1 {
    /// Base addresses
    constexpr uint32_t IIC1_BASE = 0x4009F100;

    /// IIC1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* IIC1 = reinterpret_cast<Registers*>(IIC1_BASE);

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN0_BASE = 0x400A8000;
    constexpr uint32_t CAN1_BASE = 0x400A9000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MB%s_ID;  ///< Offset: 0x200 - Mailbox ID Register %s
        volatile uint32_t MB%s_DL;  ///< Offset: 0x204 - Mailbox Data Length Register %s
        volatile uint32_t MB%s_D0;  ///< Offset: 0x206 - Mailbox Data Register %s
        volatile uint32_t MB%s_D1;  ///< Offset: 0x207 - Mailbox Data Register %s
        volatile uint32_t MB%s_D2;  ///< Offset: 0x208 - Mailbox Data Register %s
        volatile uint32_t MB%s_D3;  ///< Offset: 0x209 - Mailbox Data Register %s
        volatile uint32_t MB%s_D4;  ///< Offset: 0x20A - Mailbox Data Register %s
        volatile uint32_t MB%s_D5;  ///< Offset: 0x20B - Mailbox Data Register %s
        volatile uint32_t MB%s_D6;  ///< Offset: 0x20C - Mailbox Data Register %s
        volatile uint32_t MB%s_D7;  ///< Offset: 0x20D - Mailbox Data Register %s
        volatile uint32_t MB%s_TS;  ///< Offset: 0x20E - Mailbox Time Stamp Register %s
        volatile uint32_t MKR[%s];  ///< Offset: 0x400 - Mask Register %s
        volatile uint32_t FIDCR%s;  ///< Offset: 0x420 - FIFO Received ID Compare Register %s
        volatile uint32_t MKIVLR;  ///< Offset: 0x428 - Mask Invalid Register
        volatile uint32_t MIER;  ///< Offset: 0x42C - Mailbox Interrupt Enable Register
        volatile uint32_t MIER_FIFO;  ///< Offset: 0x42C - Mailbox Interrupt Enable Register for FIFO Mailbox Mode
        volatile uint32_t MCTL_RX[%s];  ///< Offset: 0x820 - Message Control Register for Receive
        volatile uint32_t MCTL_TX[%s];  ///< Offset: 0x820 - Message Control Register for Transmit
        volatile uint32_t CTLR;  ///< Offset: 0x840 - Control Register
        volatile uint32_t STR;  ///< Offset: 0x842 - Status Register
        volatile uint32_t BCR;  ///< Offset: 0x844 - Bit Configuration Register
        volatile uint32_t RFCR;  ///< Offset: 0x848 - Receive FIFO Control Register
        volatile uint32_t RFPCR;  ///< Offset: 0x849 - Receive FIFO Pointer Control Register
        volatile uint32_t TFCR;  ///< Offset: 0x84A - Transmit FIFO Control Register
        volatile uint32_t TFPCR;  ///< Offset: 0x84B - Transmit FIFO Pointer Control Register
        volatile uint32_t EIER;  ///< Offset: 0x84C - Error Interrupt Enable Register
        volatile uint32_t EIFR;  ///< Offset: 0x84D - Error Interrupt Factor Judge Register
        volatile uint32_t RECR;  ///< Offset: 0x84E - Receive Error Count Register
        volatile uint32_t TECR;  ///< Offset: 0x84F - Transmit Error Count Register
        volatile uint32_t ECSR;  ///< Offset: 0x850 - Error Code Store Register
        volatile uint32_t CSSR;  ///< Offset: 0x851 - Channel Search Support Register
        volatile uint32_t MSSR;  ///< Offset: 0x852 - Mailbox Search Status Register
        volatile uint32_t MSMR;  ///< Offset: 0x853 - Mailbox Search Mode Register
        volatile uint32_t TSR;  ///< Offset: 0x854 - Time Stamp Register
        volatile uint32_t AFSR;  ///< Offset: 0x856 - Acceptance Filter Support Register
        volatile uint32_t TCR;  ///< Offset: 0x858 - Test Control Register
    };

    /// Peripheral instances
    inline Registers* CAN0 = reinterpret_cast<Registers*>(CAN0_BASE);
    inline Registers* CAN1 = reinterpret_cast<Registers*>(CAN1_BASE);

    // Bit definitions
    /// MB%s_ID Register bits
    namespace mb%s_id_bits {
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID of data and remote frames
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID of data and remote frames
        constexpr uint32_t RTR = (1U << 30);  ///< Remote Transmission Request
        constexpr uint32_t IDE = (1U << 31);  ///< ID Extension
    }

    /// MB%s_DL Register bits
    namespace mb%s_dl_bits {
        constexpr uint32_t DLC = (4 << 0);  ///< Data Length Code
    }

    /// MB%s_D0 Register bits
    namespace mb%s_d0_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< Data Bytes 0
    }

    /// MB%s_D1 Register bits
    namespace mb%s_d1_bits {
        constexpr uint32_t DATA1 = (8 << 0);  ///< Data Bytes 1
    }

    /// MB%s_D2 Register bits
    namespace mb%s_d2_bits {
        constexpr uint32_t DATA2 = (8 << 0);  ///< Data Bytes 2
    }

    /// MB%s_D3 Register bits
    namespace mb%s_d3_bits {
        constexpr uint32_t DATA3 = (8 << 0);  ///< Data Bytes 3
    }

    /// MB%s_D4 Register bits
    namespace mb%s_d4_bits {
        constexpr uint32_t DATA4 = (8 << 0);  ///< Data Bytes 4
    }

    /// MB%s_D5 Register bits
    namespace mb%s_d5_bits {
        constexpr uint32_t DATA5 = (8 << 0);  ///< Data Bytes 5
    }

    /// MB%s_D6 Register bits
    namespace mb%s_d6_bits {
        constexpr uint32_t DATA6 = (8 << 0);  ///< Data Bytes 6
    }

    /// MB%s_D7 Register bits
    namespace mb%s_d7_bits {
        constexpr uint32_t DATA7 = (8 << 0);  ///< Data Bytes 7
    }

    /// MB%s_TS Register bits
    namespace mb%s_ts_bits {
        constexpr uint32_t TSL = (8 << 0);  ///< Time Stamp Lower Byte
        constexpr uint32_t TSH = (8 << 8);  ///< Time Stamp Higher Byte
    }

    /// MKR[%s] Register bits
    namespace mkr[%s]_bits {
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID
    }

    /// FIDCR%s Register bits
    namespace fidcr%s_bits {
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID of data and remote frames
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID of data and remote frames
        constexpr uint32_t RTR = (1U << 30);  ///< Remote Transmission Request
        constexpr uint32_t IDE = (1U << 31);  ///< ID Extension
    }

    /// MKIVLR Register bits
    namespace mkivlr_bits {
        constexpr uint32_t MB00 = (1U << 0);  ///< Mask Invalid
        constexpr uint32_t MB01 = (1U << 1);  ///< Mask Invalid
        constexpr uint32_t MB02 = (1U << 2);  ///< Mask Invalid
        constexpr uint32_t MB03 = (1U << 3);  ///< Mask Invalid
        constexpr uint32_t MB04 = (1U << 4);  ///< Mask Invalid
        constexpr uint32_t MB05 = (1U << 5);  ///< Mask Invalid
        constexpr uint32_t MB06 = (1U << 6);  ///< Mask Invalid
        constexpr uint32_t MB07 = (1U << 7);  ///< Mask Invalid
        constexpr uint32_t MB08 = (1U << 8);  ///< Mask Invalid
        constexpr uint32_t MB09 = (1U << 9);  ///< Mask Invalid
        constexpr uint32_t MB10 = (1U << 10);  ///< Mask Invalid
        constexpr uint32_t MB11 = (1U << 11);  ///< Mask Invalid
        constexpr uint32_t MB12 = (1U << 12);  ///< Mask Invalid
        constexpr uint32_t MB13 = (1U << 13);  ///< Mask Invalid
        constexpr uint32_t MB14 = (1U << 14);  ///< Mask Invalid
        constexpr uint32_t MB15 = (1U << 15);  ///< Mask Invalid
        constexpr uint32_t MB16 = (1U << 16);  ///< Mask Invalid
        constexpr uint32_t MB17 = (1U << 17);  ///< Mask Invalid
        constexpr uint32_t MB18 = (1U << 18);  ///< Mask Invalid
        constexpr uint32_t MB19 = (1U << 19);  ///< Mask Invalid
        constexpr uint32_t MB20 = (1U << 20);  ///< Mask Invalid
        constexpr uint32_t MB21 = (1U << 21);  ///< Mask Invalid
        constexpr uint32_t MB22 = (1U << 22);  ///< Mask Invalid
        constexpr uint32_t MB23 = (1U << 23);  ///< Mask Invalid
        constexpr uint32_t MB24 = (1U << 24);  ///< Mask Invalid
        constexpr uint32_t MB25 = (1U << 25);  ///< Mask Invalid
        constexpr uint32_t MB26 = (1U << 26);  ///< Mask Invalid
        constexpr uint32_t MB27 = (1U << 27);  ///< Mask Invalid
        constexpr uint32_t MB28 = (1U << 28);  ///< Mask Invalid
        constexpr uint32_t MB29 = (1U << 29);  ///< Mask Invalid
        constexpr uint32_t MB30 = (1U << 30);  ///< Mask Invalid
        constexpr uint32_t MB31 = (1U << 31);  ///< Mask Invalid
    }

    /// MIER Register bits
    namespace mier_bits {
        constexpr uint32_t MB00 = (1U << 0);  ///< Interrupt Enable
        constexpr uint32_t MB01 = (1U << 1);  ///< Interrupt Enable
        constexpr uint32_t MB02 = (1U << 2);  ///< Interrupt Enable
        constexpr uint32_t MB03 = (1U << 3);  ///< Interrupt Enable
        constexpr uint32_t MB04 = (1U << 4);  ///< Interrupt Enable
        constexpr uint32_t MB05 = (1U << 5);  ///< Interrupt Enable
        constexpr uint32_t MB06 = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t MB07 = (1U << 7);  ///< Interrupt Enable
        constexpr uint32_t MB08 = (1U << 8);  ///< Interrupt Enable
        constexpr uint32_t MB09 = (1U << 9);  ///< Interrupt Enable
        constexpr uint32_t MB10 = (1U << 10);  ///< Interrupt Enable
        constexpr uint32_t MB11 = (1U << 11);  ///< Interrupt Enable
        constexpr uint32_t MB12 = (1U << 12);  ///< Interrupt Enable
        constexpr uint32_t MB13 = (1U << 13);  ///< Interrupt Enable
        constexpr uint32_t MB14 = (1U << 14);  ///< Interrupt Enable
        constexpr uint32_t MB15 = (1U << 15);  ///< Interrupt Enable
        constexpr uint32_t MB16 = (1U << 16);  ///< Interrupt Enable
        constexpr uint32_t MB17 = (1U << 17);  ///< Interrupt Enable
        constexpr uint32_t MB18 = (1U << 18);  ///< Interrupt Enable
        constexpr uint32_t MB19 = (1U << 19);  ///< Interrupt Enable
        constexpr uint32_t MB20 = (1U << 20);  ///< Interrupt Enable
        constexpr uint32_t MB21 = (1U << 21);  ///< Interrupt Enable
        constexpr uint32_t MB22 = (1U << 22);  ///< Interrupt Enable
        constexpr uint32_t MB23 = (1U << 23);  ///< Interrupt Enable
        constexpr uint32_t MB24 = (1U << 24);  ///< Interrupt Enable
        constexpr uint32_t MB25 = (1U << 25);  ///< Interrupt Enable
        constexpr uint32_t MB26 = (1U << 26);  ///< Interrupt Enable
        constexpr uint32_t MB27 = (1U << 27);  ///< Interrupt Enable
        constexpr uint32_t MB28 = (1U << 28);  ///< Interrupt Enable
        constexpr uint32_t MB29 = (1U << 29);  ///< Interrupt Enable
        constexpr uint32_t MB30 = (1U << 30);  ///< Interrupt Enable
        constexpr uint32_t MB31 = (1U << 31);  ///< Interrupt Enable
    }

    /// MIER_FIFO Register bits
    namespace mier_fifo_bits {
        constexpr uint32_t MB00 = (1U << 0);  ///< Interrupt Enable
        constexpr uint32_t MB01 = (1U << 1);  ///< Interrupt Enable
        constexpr uint32_t MB02 = (1U << 2);  ///< Interrupt Enable
        constexpr uint32_t MB03 = (1U << 3);  ///< Interrupt Enable
        constexpr uint32_t MB04 = (1U << 4);  ///< Interrupt Enable
        constexpr uint32_t MB05 = (1U << 5);  ///< Interrupt Enable
        constexpr uint32_t MB06 = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t MB07 = (1U << 7);  ///< Interrupt Enable
        constexpr uint32_t MB08 = (1U << 8);  ///< Interrupt Enable
        constexpr uint32_t MB09 = (1U << 9);  ///< Interrupt Enable
        constexpr uint32_t MB10 = (1U << 10);  ///< Interrupt Enable
        constexpr uint32_t MB11 = (1U << 11);  ///< Interrupt Enable
        constexpr uint32_t MB12 = (1U << 12);  ///< Interrupt Enable
        constexpr uint32_t MB13 = (1U << 13);  ///< Interrupt Enable
        constexpr uint32_t MB14 = (1U << 14);  ///< Interrupt Enable
        constexpr uint32_t MB15 = (1U << 15);  ///< Interrupt Enable
        constexpr uint32_t MB16 = (1U << 16);  ///< Interrupt Enable
        constexpr uint32_t MB17 = (1U << 17);  ///< Interrupt Enable
        constexpr uint32_t MB18 = (1U << 18);  ///< Interrupt Enable
        constexpr uint32_t MB19 = (1U << 19);  ///< Interrupt Enable
        constexpr uint32_t MB20 = (1U << 20);  ///< Interrupt Enable
        constexpr uint32_t MB21 = (1U << 21);  ///< Interrupt Enable
        constexpr uint32_t MB22 = (1U << 22);  ///< Interrupt Enable
        constexpr uint32_t MB23 = (1U << 23);  ///< Interrupt Enable
        constexpr uint32_t MB24 = (1U << 24);  ///< Transmit FIFO Interrupt Enable
        constexpr uint32_t MB25 = (1U << 25);  ///< Transmit FIFO Interrupt Generation Timing Control
        constexpr uint32_t MB28 = (1U << 28);  ///< Receive FIFO Interrupt Enable
        constexpr uint32_t MB29 = (1U << 29);  ///< Receive FIFO Interrupt Generation Timing Control
    }

    /// MCTL_RX[%s] Register bits
    namespace mctl_rx[%s]_bits {
        constexpr uint32_t NEWDATA = (1U << 0);  ///< Reception Complete Flag
        constexpr uint32_t INVALDATA = (1U << 1);  ///< Reception-in-Progress Status Flag
        constexpr uint32_t MSGLOST = (1U << 2);  ///< Message Lost Flag
        constexpr uint32_t ONESHOT = (1U << 4);  ///< One-Shot Enable
        constexpr uint32_t RECREQ = (1U << 6);  ///< Receive Mailbox Request
        constexpr uint32_t TRMREQ = (1U << 7);  ///< Transmit Mailbox Request
    }

    /// MCTL_TX[%s] Register bits
    namespace mctl_tx[%s]_bits {
        constexpr uint32_t SENTDATA = (1U << 0);  ///< Transmission Complete Flag
        constexpr uint32_t TRMACTIVE = (1U << 1);  ///< Transmission-in-Progress Status Flag
        constexpr uint32_t TRMABT = (1U << 2);  ///< Transmission Abort Complete Flag
        constexpr uint32_t ONESHOT = (1U << 4);  ///< One-Shot Enable
        constexpr uint32_t RECREQ = (1U << 6);  ///< Receive Mailbox Request
        constexpr uint32_t TRMREQ = (1U << 7);  ///< Transmit Mailbox Request
    }

    /// CTLR Register bits
    namespace ctlr_bits {
        constexpr uint32_t MBM = (1U << 0);  ///< CAN Mailbox Mode Select
        constexpr uint32_t IDFM = (2 << 1);  ///< ID Format Mode Select
        constexpr uint32_t MLM = (1U << 3);  ///< Message Lost Mode Select
        constexpr uint32_t TPM = (1U << 4);  ///< Transmission Priority Mode Select
        constexpr uint32_t TSRC = (1U << 5);  ///< Time Stamp Counter Reset Command
        constexpr uint32_t TSPS = (2 << 6);  ///< Time Stamp Prescaler Select
        constexpr uint32_t CANM = (2 << 8);  ///< CAN Operating Mode Select
        constexpr uint32_t SLPM = (1U << 10);  ///< CAN Sleep Mode
        constexpr uint32_t BOM = (2 << 11);  ///< Bus-Off Recovery Mode
        constexpr uint32_t RBOC = (1U << 13);  ///< Forcible Return from Bus-Off
    }

    /// STR Register bits
    namespace str_bits {
        constexpr uint32_t NDST = (1U << 0);  ///< NEWDATA Status Flag
        constexpr uint32_t SDST = (1U << 1);  ///< SENTDATA Status Flag
        constexpr uint32_t RFST = (1U << 2);  ///< Receive FIFO Status Flag
        constexpr uint32_t TFST = (1U << 3);  ///< Transmit FIFO Status Flag
        constexpr uint32_t NMLST = (1U << 4);  ///< Normal Mailbox Message Lost Status Flag
        constexpr uint32_t FMLST = (1U << 5);  ///< FIFO Mailbox Message Lost Status Flag
        constexpr uint32_t TABST = (1U << 6);  ///< Transmission Abort Status Flag
        constexpr uint32_t EST = (1U << 7);  ///< Error Status Flag
        constexpr uint32_t RSTST = (1U << 8);  ///< CAN Reset Status Flag
        constexpr uint32_t HLTST = (1U << 9);  ///< CAN Halt Status Flag
        constexpr uint32_t SLPST = (1U << 10);  ///< CAN Sleep Status Flag
        constexpr uint32_t EPST = (1U << 11);  ///< Error-Passive Status Flag
        constexpr uint32_t BOST = (1U << 12);  ///< Bus-Off Status Flag
        constexpr uint32_t TRMST = (1U << 13);  ///< Transmit Status Flag
        constexpr uint32_t RECST = (1U << 14);  ///< Receive Status Flag
    }

    /// BCR Register bits
    namespace bcr_bits {
        constexpr uint32_t CCLKS = (1U << 0);  ///< CAN Clock Source Selection
        constexpr uint32_t TSEG2 = (3 << 8);  ///< Time Segment 2 Control
        constexpr uint32_t SJW = (2 << 12);  ///< Synchronization Jump Width Control
        constexpr uint32_t BRP = (10 << 16);  ///< Baud Rate Prescaler Select
        constexpr uint32_t TSEG1 = (4 << 28);  ///< Time Segment 1 Control
    }

    /// RFCR Register bits
    namespace rfcr_bits {
        constexpr uint32_t RFE = (1U << 0);  ///< Receive FIFO Enable
        constexpr uint32_t RFUST = (3 << 1);  ///< Receive FIFO Unread Message Number Status
        constexpr uint32_t RFMLF = (1U << 4);  ///< Receive FIFO Message Lost Flag
        constexpr uint32_t RFFST = (1U << 5);  ///< Receive FIFO Full Status Flag
        constexpr uint32_t RFWST = (1U << 6);  ///< Receive FIFO Buffer Warning Status Flag
        constexpr uint32_t RFEST = (1U << 7);  ///< Receive FIFO Empty Status Flag
    }

    /// TFCR Register bits
    namespace tfcr_bits {
        constexpr uint32_t TFE = (1U << 0);  ///< Transmit FIFO Enable
        constexpr uint32_t TFUST = (3 << 1);  ///< Transmit FIFO Unsent Message Number Status
        constexpr uint32_t TFFST = (1U << 6);  ///< Transmit FIFO Full Status
        constexpr uint32_t TFEST = (1U << 7);  ///< Transmit FIFO Empty Status
    }

    /// EIER Register bits
    namespace eier_bits {
        constexpr uint32_t BEIE = (1U << 0);  ///< Bus Error Interrupt Enable
        constexpr uint32_t EWIE = (1U << 1);  ///< Error-Warning Interrupt Enable
        constexpr uint32_t EPIE = (1U << 2);  ///< Error-Passive Interrupt Enable
        constexpr uint32_t BOEIE = (1U << 3);  ///< Bus-Off Entry Interrupt Enable
        constexpr uint32_t BORIE = (1U << 4);  ///< Bus-Off Recovery Interrupt Enable
        constexpr uint32_t ORIE = (1U << 5);  ///< Overrun Interrupt Enable
        constexpr uint32_t OLIE = (1U << 6);  ///< Overload Frame Transmit Interrupt Enable
        constexpr uint32_t BLIE = (1U << 7);  ///< Bus Lock Interrupt Enable
    }

    /// EIFR Register bits
    namespace eifr_bits {
        constexpr uint32_t BEIF = (1U << 0);  ///< Bus Error Detect Flag
        constexpr uint32_t EWIF = (1U << 1);  ///< Error-Warning Detect Flag
        constexpr uint32_t EPIF = (1U << 2);  ///< Error-Passive Detect Flag
        constexpr uint32_t BOEIF = (1U << 3);  ///< Bus-Off Entry Detect Flag
        constexpr uint32_t BORIF = (1U << 4);  ///< Bus-Off Recovery Detect Flag
        constexpr uint32_t ORIF = (1U << 5);  ///< Receive Overrun Detect Flag
        constexpr uint32_t OLIF = (1U << 6);  ///< Overload Frame Transmission Detect Flag
        constexpr uint32_t BLIF = (1U << 7);  ///< Bus Lock Detect Flag
    }

    /// ECSR Register bits
    namespace ecsr_bits {
        constexpr uint32_t SEF = (1U << 0);  ///< Stuff Error Flag
        constexpr uint32_t FEF = (1U << 1);  ///< Form Error Flag
        constexpr uint32_t AEF = (1U << 2);  ///< ACK Error Flag
        constexpr uint32_t CEF = (1U << 3);  ///< CRC Error Flag
        constexpr uint32_t BE1F = (1U << 4);  ///< Bit Error (recessive) Flag
        constexpr uint32_t BE0F = (1U << 5);  ///< Bit Error (dominant) Flag
        constexpr uint32_t ADEF = (1U << 6);  ///< ACK Delimiter Error Flag
        constexpr uint32_t EDPM = (1U << 7);  ///< Error Display Mode Select
    }

    /// MSSR Register bits
    namespace mssr_bits {
        constexpr uint32_t MBNST = (5 << 0);  ///< Search Result Mailbox Number Status
        constexpr uint32_t SEST = (1U << 7);  ///< Search Result Status
    }

    /// MSMR Register bits
    namespace msmr_bits {
        constexpr uint32_t MBSM = (2 << 0);  ///< Mailbox Search Mode Select
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TSTE = (1U << 0);  ///< CAN Test Mode Enable
        constexpr uint32_t TSTM = (2 << 1);  ///< CAN Test Mode Select
    }

}

// ============================================================================
// CTSU Peripheral
// ============================================================================

namespace ctsu {
    /// Base addresses
    constexpr uint32_t CTSU_BASE = 0x400D0000;

    /// CTSU Register structure
    struct Registers {
        volatile uint32_t CTSUCR0;  ///< Offset: 0x00 - CTSU Control Register 0
        volatile uint32_t CTSUCR1;  ///< Offset: 0x01 - CTSU Control Register 1
        volatile uint32_t CTSUSDPRS;  ///< Offset: 0x02 - CTSU Synchronous Noise Reduction Setting Register
        volatile uint32_t CTSUSST;  ///< Offset: 0x03 - CTSU Sensor Stabilization Wait Control Register
        volatile uint32_t CTSUMCH0;  ///< Offset: 0x04 - CTSU Measurement Channel Register 0
        volatile uint32_t CTSUMCH1;  ///< Offset: 0x05 - CTSU Measurement Channel Register 1
        volatile uint32_t CTSUCHAC0;  ///< Offset: 0x06 - CTSU Channel Enable Control Register 0
        volatile uint32_t CTSUCHAC1;  ///< Offset: 0x07 - CTSU Channel Enable Control Register 1
        volatile uint32_t CTSUCHAC2;  ///< Offset: 0x08 - CTSU Channel Enable Control Register 2
        volatile uint32_t CTSUCHTRC0;  ///< Offset: 0x0B - CTSU Channel Transmit/Receive Control Register 0
        volatile uint32_t CTSUCHTRC1;  ///< Offset: 0x0C - CTSU Channel Transmit/Receive Control Register 1
        volatile uint32_t CTSUCHTRC2;  ///< Offset: 0x0D - CTSU Channel Transmit/Receive Control Register 2
        volatile uint32_t CTSUDCLKC;  ///< Offset: 0x10 - CTSU High-Pass Noise Reduction Control Register
        volatile uint32_t CTSUST;  ///< Offset: 0x11 - CTSU Status Register
        volatile uint32_t CTSUSSC;  ///< Offset: 0x12 - CTSU High-Pass Noise Reduction Spectrum Diffusion...
        volatile uint32_t CTSUSO0;  ///< Offset: 0x14 - CTSU Sensor Offset Register 0
        volatile uint32_t CTSUSO1;  ///< Offset: 0x16 - CTSU Sensor Offset Register 1
        volatile uint32_t CTSUSC;  ///< Offset: 0x18 - CTSU Sensor Counter
        volatile uint32_t CTSURC;  ///< Offset: 0x1A - CTSU Reference Counter
        volatile uint32_t CTSUERRS;  ///< Offset: 0x1C - CTSU Error Status Register
        volatile uint32_t CTSUTRMR;  ///< Offset: 0x20 - CTSU Reference Current Calibration Register
    };

    /// Peripheral instances
    inline Registers* CTSU = reinterpret_cast<Registers*>(CTSU_BASE);

    // Bit definitions
    /// CTSUSSC Register bits
    namespace ctsussc_bits {
        constexpr uint32_t CTSUSSDIV = (4 << 8);  ///< CTSU Spectrum Diffusion Frequency Division Setting
    }

    /// CTSURC Register bits
    namespace ctsurc_bits {
        constexpr uint32_t CTSURC = (16 << 0);  ///< CTSU Reference Counter
    }

    /// CTSUERRS Register bits
    namespace ctsuerrs_bits {
        constexpr uint32_t CTSUSPMD = (2 << 0);  ///< Calibration Mode
        constexpr uint32_t CTSUTSOD = (1U << 2);  ///< TS Pin Fixed Output
        constexpr uint32_t CTSUDRV = (1U << 3);  ///< Calibration Setting 1
        constexpr uint32_t CTSUCLKSEL1 = (1U << 6);  ///< Calibration Setting 3
        constexpr uint32_t CTSUTSOC = (1U << 7);  ///< Calibration Setting 2
        constexpr uint32_t CTSUICOMP = (1U << 15);  ///< TSCAP Voltage Error Monitor
    }

}

// ============================================================================
// PSCU Peripheral
// ============================================================================

namespace pscu {
    /// Base addresses
    constexpr uint32_t PSCU_BASE = 0x400E0000;

    /// PSCU Register structure
    struct Registers {
        volatile uint32_t PSARB;  ///< Offset: 0x04 - Peripheral Security Attribution Register B
        volatile uint32_t PSARC;  ///< Offset: 0x08 - Peripheral Security Attribution Register C
        volatile uint32_t PSARD;  ///< Offset: 0x0C - Peripheral Security Attribution Register D
        volatile uint32_t PSARE;  ///< Offset: 0x10 - Peripheral Security Attribution Register E
        volatile uint32_t MSSAR;  ///< Offset: 0x14 - Module Stop Security Attribution Register
        volatile uint32_t CFSAMONA;  ///< Offset: 0x18 - Code Flash Security Attribution Monitor Register A
        volatile uint32_t CFSAMONB;  ///< Offset: 0x1C - Code Flash Security Attribution Monitor Register B
        volatile uint32_t DFSAMON;  ///< Offset: 0x20 - Data Flash Security Attribution Monitor Register
        volatile uint32_t SSAMONA;  ///< Offset: 0x24 - SRAM Security Attribution Monitor Register A
        volatile uint32_t SSAMONB;  ///< Offset: 0x28 - SRAM Security Attribution Monitor Register B
        volatile uint32_t DLMMON;  ///< Offset: 0x2C - Device Lifecycle Management State Monitor Register
    };

    /// Peripheral instances
    inline Registers* PSCU = reinterpret_cast<Registers*>(PSCU_BASE);

    // Bit definitions
    /// PSARB Register bits
    namespace psarb_bits {
        constexpr uint32_t PSARB1 = (1U << 1);  ///< CAN1 and the MSTPCRB.MSTPB1 bit security attribution
        constexpr uint32_t PSARB2 = (1U << 2);  ///< CAN0 and the MSTPCRB.MSTPB2 bit security attribution
        constexpr uint32_t PSARB6 = (1U << 6);  ///< QSPI and the MSTPCRB.MSTPB6 bit security attribution
        constexpr uint32_t PSARB8 = (1U << 8);  ///< IIC1 and the MSTPCRB.MSTPB8 bit security attribution
        constexpr uint32_t PSARB9 = (1U << 9);  ///< IIC0 and the MSTPCRB.MSTPB9 bit security attribution
        constexpr uint32_t PSARB11 = (1U << 11);  ///< USBFS and the MSTPCRB.MSTPB11 bit security attribution
        constexpr uint32_t PSARB19 = (1U << 19);  ///< SPI0 and the MSTPCRB.MSTPB19 bit security attribution
        constexpr uint32_t PSARB22 = (1U << 22);  ///< SCI9 and the MSTPCRB.MSTPB22 bit security attribution
        constexpr uint32_t PSARB27 = (1U << 27);  ///< SCI4 and the MSTPCRB.MSTPB27 bit security attribution
        constexpr uint32_t PSARB28 = (1U << 28);  ///< SCI3 and the MSTPCRB.MSTPB28 bit security attribution
        constexpr uint32_t PSARB29 = (1U << 29);  ///< SCI2 and the MSTPCRB.MSTPB29 bit security attribution
        constexpr uint32_t PSARB30 = (1U << 30);  ///< SCI1 and the MSTPCRB.MSTPB30 bit security attribution
        constexpr uint32_t PSARB31 = (1U << 31);  ///< SCI0 and the MSTPCRB.MSTPB31 bit security attribution
    }

    /// PSARC Register bits
    namespace psarc_bits {
        constexpr uint32_t PSARC0 = (1U << 0);  ///< CAC and the MSTPCRC.MSTPC0 bit security attribution
        constexpr uint32_t PSARC1 = (1U << 1);  ///< CRC and the MSTPCRC.MSTPC1 bit security attribution
        constexpr uint32_t PSARC3 = (1U << 3);  ///< CTSU and the MSTPCRC.MSTPC3 bit security attribution
        constexpr uint32_t PSARC8 = (1U << 8);  ///< SSIE0 and the MSTPCRC.MSTPC8 bit security attribution
        constexpr uint32_t PSARC12 = (1U << 12);  ///< SDHI0 and the MSTPCRC.MSTPC12 bit security attribution
        constexpr uint32_t PSARC13 = (1U << 13);  ///< DOC and the MSTPCRC.MSTPC13 bit security attribution
        constexpr uint32_t PSARC31 = (1U << 31);  ///< SCE9 and the MSTPCRC.MSTPC31 bit security attribution
    }

    /// PSARD Register bits
    namespace psard_bits {
        constexpr uint32_t PSARD0 = (1U << 0);  ///< AGT3 and the MSTPCRD.MSTPD0 bit security attribution
        constexpr uint32_t PSARD1 = (1U << 1);  ///< AGT2 and the MSTPCRD.MSTPD1 bit security attribution
        constexpr uint32_t PSARD2 = (1U << 2);  ///< AGT1 and the MSTPCRD.MSTPD2 bit security attribution
        constexpr uint32_t PSARD3 = (1U << 3);  ///< AGT0 and the MSTPCRD.MSTPD3 bit security attribution
        constexpr uint32_t PSARD11 = (1U << 11);  ///< POEG Group D and the MSTPCRD.MSTPD11 bit security attribution
        constexpr uint32_t PSARD12 = (1U << 12);  ///< POEG Group C and the MSTPCRD.MSTPD12 bit security attribution
        constexpr uint32_t PSARD13 = (1U << 13);  ///< POEG Group B and the MSTPCRD.MSTPD13 bit security attribution
        constexpr uint32_t PSARD14 = (1U << 14);  ///< POEG Group A and the MSTPCRD.MSTPD14 bit security attribution
        constexpr uint32_t PSARD15 = (1U << 15);  ///< ADC121 and the MSTPCRD.MSTPD15 bit security attribution
        constexpr uint32_t PSARD16 = (1U << 16);  ///< ADC120 and the MSTPCRD.MSTPD16 bit security attribution
        constexpr uint32_t PSARD20 = (1U << 20);  ///< DAC12 and the MSTPCRD.MSTPD20 bit security attribution
        constexpr uint32_t PSARD22 = (1U << 22);  ///< TSN and the MSTPCRD.MSTPD22 bit security attribution
    }

    /// PSARE Register bits
    namespace psare_bits {
        constexpr uint32_t PSARE0 = (1U << 0);  ///< WDT security attribution
        constexpr uint32_t PSARE1 = (1U << 1);  ///< IWDT security attribution
        constexpr uint32_t PSARE2 = (1U << 2);  ///< RTC security attribution
        constexpr uint32_t PSARE14 = (1U << 14);  ///< AGT5 and the MSTPCRE.MSTPE14 bit security attribution
        constexpr uint32_t PSARE15 = (1U << 15);  ///< AGT4 and the MSTPCRE.MSTPE15 bit security attribution
        constexpr uint32_t PSARE24 = (1U << 24);  ///< GPT7 and the MSTPCRE.MSTPE24 bit security attribution
        constexpr uint32_t PSARE25 = (1U << 25);  ///< GPT6 and the MSTPCRE.MSTPE25 bit security attribution
        constexpr uint32_t PSARE26 = (1U << 26);  ///< GPT5 and the MSTPCRE.MSTPE26 bit security attribution
        constexpr uint32_t PSARE27 = (1U << 27);  ///< GPT4 and the MSTPCRE.MSTPE27 bit security attribution
        constexpr uint32_t PSARE28 = (1U << 28);  ///< GPT3 and the MSTPCRE.MSTPE28 bit security attribution
        constexpr uint32_t PSARE29 = (1U << 29);  ///< GPT2 and the MSTPCRE.MSTPE29 bit security attribution
        constexpr uint32_t PSARE30 = (1U << 30);  ///< GPT1 and the MSTPCRE.MSTPE30 bit security attribution
        constexpr uint32_t PSARE31 = (1U << 31);  ///< GPT0, GPT_OPS and the MSTPCRE.MSTPE31 bit security attribution
    }

    /// MSSAR Register bits
    namespace mssar_bits {
        constexpr uint32_t MSSAR0 = (1U << 0);  ///< The MSTPCRC.MSTPC14 bit security attribution
        constexpr uint32_t MSSAR1 = (1U << 1);  ///< The MSTPCRA.MSTPA22 bit security attribution
        constexpr uint32_t MSSAR2 = (1U << 2);  ///< The MSTPCRA.MSTPA7 bit security attribution
        constexpr uint32_t MSSAR3 = (1U << 3);  ///< The MSTPCRA.MSTPA0 bit security attribution
    }

    /// CFSAMONA Register bits
    namespace cfsamona_bits {
        constexpr uint32_t CFS2 = (9 << 15);  ///< Code Flash Secure area 2
    }

    /// CFSAMONB Register bits
    namespace cfsamonb_bits {
        constexpr uint32_t CFS1 = (14 << 10);  ///< Code Flash Secure area 1
    }

    /// DFSAMON Register bits
    namespace dfsamon_bits {
        constexpr uint32_t DFS = (6 << 10);  ///< Data flash Secure area
    }

    /// SSAMONA Register bits
    namespace ssamona_bits {
        constexpr uint32_t SS2 = (8 << 13);  ///< SRAM Secure area 2
    }

    /// SSAMONB Register bits
    namespace ssamonb_bits {
        constexpr uint32_t SS1 = (11 << 10);  ///< SRAM secure area 1
    }

    /// DLMMON Register bits
    namespace dlmmon_bits {
        constexpr uint32_t DLMMON = (4 << 0);  ///< Device Lifecycle Management State Monitor
    }

}

// ============================================================================
// AGT0 Peripheral
// ============================================================================

namespace agt0 {
    /// Base addresses
    constexpr uint32_t AGT0_BASE = 0x400E8000;

    /// AGT0 Register structure
    struct Registers {
        volatile uint32_t AGT;  ///< Offset: 0x00 - AGT Counter Register
        volatile uint32_t AGTCMA;  ///< Offset: 0x02 - AGT Compare Match A Register
        volatile uint32_t AGTCMB;  ///< Offset: 0x04 - AGT Compare Match B Register
        volatile uint32_t AGTCR;  ///< Offset: 0x08 - AGT Control Register
        volatile uint32_t AGTMR1;  ///< Offset: 0x09 - AGT Mode Register 1
        volatile uint32_t AGTMR2;  ///< Offset: 0x0A - AGT Mode Register 2
        volatile uint32_t AGTIOC;  ///< Offset: 0x0C - AGT I/O Control Register
        volatile uint32_t AGTISR;  ///< Offset: 0x0D - AGT Event Pin Select Register
        volatile uint32_t AGTCMSR;  ///< Offset: 0x0E - AGT Compare Match Function Select Register
        volatile uint32_t AGTIOSEL;  ///< Offset: 0x0F - AGT Pin Select Register
    };

    /// Peripheral instances
    inline Registers* AGT0 = reinterpret_cast<Registers*>(AGT0_BASE);

    // Bit definitions
    /// AGTCR Register bits
    namespace agtcr_bits {
        constexpr uint32_t TSTART = (1U << 0);  ///< AGT Count Start
        constexpr uint32_t TCSTF = (1U << 1);  ///< AGT Count Status Flag
        constexpr uint32_t TSTOP = (1U << 2);  ///< AGT Count Forced Stop
        constexpr uint32_t TEDGF = (1U << 4);  ///< Active Edge Judgment Flag
        constexpr uint32_t TUNDF = (1U << 5);  ///< Underflow Flag
        constexpr uint32_t TCMAF = (1U << 6);  ///< Compare Match A Flag
        constexpr uint32_t TCMBF = (1U << 7);  ///< Compare Match B Flag
    }

    /// AGTMR1 Register bits
    namespace agtmr1_bits {
        constexpr uint32_t TMOD = (3 << 0);  ///< Operating Mode
        constexpr uint32_t TEDGPL = (1U << 3);  ///< Edge Polarity
        constexpr uint32_t TCK = (3 << 4);  ///< Count Source
    }

    /// AGTMR2 Register bits
    namespace agtmr2_bits {
        constexpr uint32_t CKS = (3 << 0);  ///< AGTLCLK or AGTSCLK Count Source Clock Frequency Division Ratio
        constexpr uint32_t LPM = (1U << 7);  ///< Low Power Mode
    }

    /// AGTIOC Register bits
    namespace agtioc_bits {
        constexpr uint32_t TEDGSEL = (1U << 0);  ///< I/O Polarity Switch
        constexpr uint32_t TOE = (1U << 2);  ///< AGTOn pin Output Enable
        constexpr uint32_t TIPF = (2 << 4);  ///< Input Filter
        constexpr uint32_t TIOGT = (2 << 6);  ///< Count Control
    }

    /// AGTISR Register bits
    namespace agtisr_bits {
        constexpr uint32_t EEPS = (1U << 2);  ///< AGTEEn Polarity Selection
    }

    /// AGTCMSR Register bits
    namespace agtcmsr_bits {
        constexpr uint32_t TCMEA = (1U << 0);  ///< AGT Compare Match A Register Enable
        constexpr uint32_t TOEA = (1U << 1);  ///< AGTOAn Pin Output Enable
        constexpr uint32_t TOPOLA = (1U << 2);  ///< AGTOAn Pin Polarity Select
        constexpr uint32_t TCMEB = (1U << 4);  ///< AGT Compare Match B Register Enable
        constexpr uint32_t TOEB = (1U << 5);  ///< AGTOBn Pin Output Enable
        constexpr uint32_t TOPOLB = (1U << 6);  ///< AGTOBn Pin Polarity Select
    }

    /// AGTIOSEL Register bits
    namespace agtiosel_bits {
        constexpr uint32_t SEL = (2 << 0);  ///< AGTIOn Pin Select
        constexpr uint32_t TIES = (1U << 4);  ///< AGTIOn Pin Input Enable
    }

}

// ============================================================================
// AGT1 Peripheral
// ============================================================================

namespace agt1 {
    /// Base addresses
    constexpr uint32_t AGT1_BASE = 0x400E8100;

    /// AGT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AGT1 = reinterpret_cast<Registers*>(AGT1_BASE);

}

// ============================================================================
// AGT2 Peripheral
// ============================================================================

namespace agt2 {
    /// Base addresses
    constexpr uint32_t AGT2_BASE = 0x400E8200;

    /// AGT2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AGT2 = reinterpret_cast<Registers*>(AGT2_BASE);

}

// ============================================================================
// AGT3 Peripheral
// ============================================================================

namespace agt3 {
    /// Base addresses
    constexpr uint32_t AGT3_BASE = 0x400E8300;

    /// AGT3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AGT3 = reinterpret_cast<Registers*>(AGT3_BASE);

}

// ============================================================================
// AGT4 Peripheral
// ============================================================================

namespace agt4 {
    /// Base addresses
    constexpr uint32_t AGT4_BASE = 0x400E8400;

    /// AGT4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AGT4 = reinterpret_cast<Registers*>(AGT4_BASE);

}

// ============================================================================
// AGT5 Peripheral
// ============================================================================

namespace agt5 {
    /// Base addresses
    constexpr uint32_t AGT5_BASE = 0x400E8500;

    /// AGT5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AGT5 = reinterpret_cast<Registers*>(AGT5_BASE);

}

// ============================================================================
// TSN Peripheral
// ============================================================================

namespace tsn {
    /// Base addresses
    constexpr uint32_t TSN_BASE = 0x400F3000;

    /// TSN Register structure
    struct Registers {
        volatile uint32_t TSCR;  ///< Offset: 0x00 - Temperature Sensor Control Register
    };

    /// Peripheral instances
    inline Registers* TSN = reinterpret_cast<Registers*>(TSN_BASE);

    // Bit definitions
    /// TSCR Register bits
    namespace tscr_bits {
        constexpr uint32_t TSOE = (1U << 4);  ///< Temperature Sensor Output Enable
        constexpr uint32_t TSEN = (1U << 7);  ///< Temperature Sensor Enable
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40108000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRCCR0;  ///< Offset: 0x00 - CRC Control Register 0
        volatile uint32_t CRCDIR;  ///< Offset: 0x04 - CRC Data Input Register
        volatile uint32_t CRCDIR_BY;  ///< Offset: 0x04 - CRC Data Input Register
        volatile uint32_t CRCDOR;  ///< Offset: 0x08 - CRC Data Output Register
        volatile uint32_t CRCDOR_HA;  ///< Offset: 0x08 - CRC Data Output Register
        volatile uint32_t CRCDOR_BY;  ///< Offset: 0x08 - CRC Data Output Register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRCCR0 Register bits
    namespace crccr0_bits {
        constexpr uint32_t GPS = (3 << 0);  ///< CRC Generating Polynomial Switching
        constexpr uint32_t LMS = (1U << 6);  ///< CRC Calculation Switching
        constexpr uint32_t DORCLR = (1U << 7);  ///< CRCDOR/CRCDOR_HA/CRCDOR_BY Register Clear
    }

}

// ============================================================================
// DOC Peripheral
// ============================================================================

namespace doc {
    /// Base addresses
    constexpr uint32_t DOC_BASE = 0x40109000;

    /// DOC Register structure
    struct Registers {
        volatile uint32_t DOCR;  ///< Offset: 0x00 - DOC Control Register
        volatile uint32_t DODIR;  ///< Offset: 0x02 - DOC Data Input Register
        volatile uint32_t DODSR;  ///< Offset: 0x04 - DOC Data Setting Register
    };

    /// Peripheral instances
    inline Registers* DOC = reinterpret_cast<Registers*>(DOC_BASE);

    // Bit definitions
    /// DOCR Register bits
    namespace docr_bits {
        constexpr uint32_t OMS = (2 << 0);  ///< Operating Mode Select
        constexpr uint32_t DCSEL = (1U << 2);  ///< Detection Condition Select
        constexpr uint32_t DOPCF = (1U << 5);  ///< DOC Flag
        constexpr uint32_t DOPCFCL = (1U << 6);  ///< DOPCF Clear
    }

}

// ============================================================================
// SCI0 Peripheral
// ============================================================================

namespace sci0 {
    /// Base addresses
    constexpr uint32_t SCI0_BASE = 0x40118000;

    /// SCI0 Register structure
    struct Registers {
        volatile uint32_t SMR;  ///< Offset: 0x00 - Serial Mode Register for Non-Smart Card Interface Mode...
        volatile uint32_t SMR_SMCI;  ///< Offset: 0x00 - Serial Mode Register for Smart Card Interface Mode...
        volatile uint32_t BRR;  ///< Offset: 0x01 - Bit Rate Register
        volatile uint32_t SCR;  ///< Offset: 0x02 - Serial Control Register for Non-Smart Card Interface...
        volatile uint32_t SCR_SMCI;  ///< Offset: 0x02 - Serial Control Register for Smart Card Interface Mode...
        volatile uint32_t TDR;  ///< Offset: 0x03 - Transmit Data Register
        volatile uint32_t SSR;  ///< Offset: 0x04 - Serial Status Register for Non-Smart Card Interface and...
        volatile uint32_t SSR_FIFO;  ///< Offset: 0x04 - Serial Status Register for Non-Smart Card Interface and...
        volatile uint32_t SSR_SMCI;  ///< Offset: 0x04 - Serial Status Register for Smart Card Interface Mode...
        volatile uint32_t RDR;  ///< Offset: 0x05 - Receive Data Register
        volatile uint32_t SCMR;  ///< Offset: 0x06 - Smart Card Mode Register
        volatile uint32_t SEMR;  ///< Offset: 0x07 - Serial Extended Mode Register
        volatile uint32_t SNFR;  ///< Offset: 0x08 - Noise Filter Setting Register
        volatile uint32_t SIMR1;  ///< Offset: 0x09 - IIC Mode Register 1
        volatile uint32_t SIMR2;  ///< Offset: 0x0A - IIC Mode Register 2
        volatile uint32_t SIMR3;  ///< Offset: 0x0B - IIC Mode Register 3
        volatile uint32_t SISR;  ///< Offset: 0x0C - IIC Status Register
        volatile uint32_t SPMR;  ///< Offset: 0x0D - SPI Mode Register
        volatile uint32_t FTDRHL;  ///< Offset: 0x0E - Transmit FIFO Data Register
        volatile uint32_t TDRHL;  ///< Offset: 0x0E - Transmit Data Register for Non-Manchester mode (MMR.MANEN = 0)
        volatile uint32_t FTDRH;  ///< Offset: 0x0E - Transmit FIFO Data Register
        volatile uint32_t FTDRL;  ///< Offset: 0x0F - Transmit FIFO Data Register
        volatile uint32_t FRDRHL;  ///< Offset: 0x10 - Receive FIFO Data Register
        volatile uint32_t RDRHL;  ///< Offset: 0x10 - Receive Data Register for Non-Manchester mode (MMR.MANEN = 0)
        volatile uint32_t FRDRH;  ///< Offset: 0x10 - Receive FIFO Data Register
        volatile uint32_t FRDRL;  ///< Offset: 0x11 - Receive FIFO Data Register
        volatile uint32_t MDDR;  ///< Offset: 0x12 - Modulation Duty Register
        volatile uint32_t DCCR;  ///< Offset: 0x13 - Data Compare Match Control Register
        volatile uint32_t FCR;  ///< Offset: 0x14 - FIFO Control Register
        volatile uint32_t FDR;  ///< Offset: 0x16 - FIFO Data Count Register
        volatile uint32_t LSR;  ///< Offset: 0x18 - Line Status Register
        volatile uint32_t CDR;  ///< Offset: 0x1A - Compare Match Data Register
        volatile uint32_t SPTR;  ///< Offset: 0x1C - Serial Port Register
        volatile uint32_t ACTR;  ///< Offset: 0x1D - Adjustment Communication Timing Register
    };

    /// Peripheral instances
    inline Registers* SCI0 = reinterpret_cast<Registers*>(SCI0_BASE);

    // Bit definitions
    /// SMR Register bits
    namespace smr_bits {
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
        constexpr uint32_t MP = (1U << 2);  ///< Multi-Processor Mode
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Bit Length
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable
        constexpr uint32_t CHR = (1U << 6);  ///< Character Length
        constexpr uint32_t CM = (1U << 7);  ///< Communication Mode
    }

    /// SMR_SMCI Register bits
    namespace smr_smci_bits {
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
        constexpr uint32_t BCP = (2 << 2);  ///< Base Clock Pulse
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable
        constexpr uint32_t BLK = (1U << 6);  ///< Block Transfer Mode
        constexpr uint32_t GM = (1U << 7);  ///< GSM Mode
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
    }

    /// SCR_SMCI Register bits
    namespace scr_smci_bits {
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SSR_FIFO Register bits
    namespace ssr_fifo_bits {
        constexpr uint32_t DR = (1U << 0);  ///< Receive Data Ready Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO Data Full Flag
        constexpr uint32_t TDFE = (1U << 7);  ///< Transmit FIFO Data Empty Flag
    }

    /// SSR_SMCI Register bits
    namespace ssr_smci_bits {
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t ERS = (1U << 4);  ///< Error Signal Status Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SCMR Register bits
    namespace scmr_bits {
        constexpr uint32_t SMIF = (1U << 0);  ///< Smart Card Interface Mode Select
        constexpr uint32_t SINV = (1U << 2);  ///< Transmitted/Received Data Invert
        constexpr uint32_t SDIR = (1U << 3);  ///< Transmitted/Received Data Transfer Direction
        constexpr uint32_t CHR1 = (1U << 4);  ///< Character Length 1
        constexpr uint32_t BCP2 = (1U << 7);  ///< Base Clock Pulse 2
    }

    /// SEMR Register bits
    namespace semr_bits {
        constexpr uint32_t ACS0 = (1U << 0);  ///< Asynchronous Mode Clock Source Select
        constexpr uint32_t PADIS = (1U << 1);  ///< Preamble function Disable
        constexpr uint32_t BRME = (1U << 2);  ///< Bit Rate Modulation Enable
        constexpr uint32_t ABCSE = (1U << 3);  ///< Asynchronous Mode Extended Base Clock Select 1
        constexpr uint32_t ABCS = (1U << 4);  ///< Asynchronous Mode Base Clock Select
        constexpr uint32_t NFEN = (1U << 5);  ///< Digital Noise Filter Function Enable
        constexpr uint32_t BGDM = (1U << 6);  ///< Baud Rate Generator Double-Speed Mode Select
        constexpr uint32_t RXDESEL = (1U << 7);  ///< Asynchronous Start Bit Edge Detection Select
    }

    /// SNFR Register bits
    namespace snfr_bits {
        constexpr uint32_t NFCS = (3 << 0);  ///< Noise Filter Clock Select
    }

    /// SIMR1 Register bits
    namespace simr1_bits {
        constexpr uint32_t IICM = (1U << 0);  ///< Simple IIC Mode Select
        constexpr uint32_t IICDL = (5 << 3);  ///< SDAn Delay Output Select
    }

    /// SIMR2 Register bits
    namespace simr2_bits {
        constexpr uint32_t IICINTM = (1U << 0);  ///< IIC Interrupt Mode Select
        constexpr uint32_t IICCSC = (1U << 1);  ///< Clock Synchronization
        constexpr uint32_t IICACKT = (1U << 5);  ///< ACK Transmission Data
    }

    /// SIMR3 Register bits
    namespace simr3_bits {
        constexpr uint32_t IICSTAREQ = (1U << 0);  ///< Start Condition Generation
        constexpr uint32_t IICRSTAREQ = (1U << 1);  ///< Restart Condition Generation
        constexpr uint32_t IICSTPREQ = (1U << 2);  ///< Stop Condition Generation
        constexpr uint32_t IICSTIF = (1U << 3);  ///< Issuing of Start, Restart, or Stop Condition Completed Flag
        constexpr uint32_t IICSDAS = (2 << 4);  ///< SDAn Output Select
        constexpr uint32_t IICSCLS = (2 << 6);  ///< SCLn Output Select
    }

    /// SISR Register bits
    namespace sisr_bits {
        constexpr uint32_t IICACKR = (1U << 0);  ///< ACK Reception Data Flag
    }

    /// SPMR Register bits
    namespace spmr_bits {
        constexpr uint32_t SSE = (1U << 0);  ///< SSn Pin Function Enable
        constexpr uint32_t CTSE = (1U << 1);  ///< CTS Enable
        constexpr uint32_t MSS = (1U << 2);  ///< Master Slave Select
        constexpr uint32_t CTSPEN = (1U << 3);  ///< CTS external pin Enable
        constexpr uint32_t MFF = (1U << 4);  ///< Mode Fault Flag
        constexpr uint32_t CKPOL = (1U << 6);  ///< Clock Polarity Select
        constexpr uint32_t CKPH = (1U << 7);  ///< Clock Phase Select
    }

    /// FTDRHL Register bits
    namespace ftdrhl_bits {
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial transmit data
        constexpr uint32_t MPBT = (1U << 9);  ///< Multi-Processor Transfer Bit Flag
    }

    /// TDRHL Register bits
    namespace tdrhl_bits {
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial Transmit Data
    }

    /// FTDRH Register bits
    namespace ftdrh_bits {
        constexpr uint32_t MPBT = (1U << 1);  ///< Multi-Processor Transfer Bit Flag
    }

    /// FTDRL Register bits
    namespace ftdrl_bits {
        constexpr uint32_t TDAT = (8 << 0);  ///< Serial transmit data
    }

    /// FRDRHL Register bits
    namespace frdrhl_bits {
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial receive data
        constexpr uint32_t MPB = (1U << 9);  ///< Multi-Processor Bit Flag
        constexpr uint32_t DR = (1U << 10);  ///< Receive Data Ready Flag
        constexpr uint32_t PER = (1U << 11);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 12);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 13);  ///< Overrun Error Flag
        constexpr uint32_t RDF = (1U << 14);  ///< Receive FIFO Data Full Flag
    }

    /// RDRHL Register bits
    namespace rdrhl_bits {
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial Receive Data
    }

    /// FRDRH Register bits
    namespace frdrh_bits {
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor Bit Flag
        constexpr uint32_t DR = (1U << 2);  ///< Receive Data Ready Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO Data Full Flag
    }

    /// FRDRL Register bits
    namespace frdrl_bits {
        constexpr uint32_t RDAT = (8 << 0);  ///< Serial receive data
    }

    /// DCCR Register bits
    namespace dccr_bits {
        constexpr uint32_t DCMF = (1U << 0);  ///< Data Compare Match Flag
        constexpr uint32_t DPER = (1U << 3);  ///< Data Compare Match Parity Error Flag
        constexpr uint32_t DFER = (1U << 4);  ///< Data Compare Match Framing Error Flag
        constexpr uint32_t IDSEL = (1U << 6);  ///< ID Frame Select
        constexpr uint32_t DCME = (1U << 7);  ///< Data Compare Match Enable
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t FM = (1U << 0);  ///< FIFO Mode Select
        constexpr uint32_t RFRST = (1U << 1);  ///< Receive FIFO Data Register Reset
        constexpr uint32_t TFRST = (1U << 2);  ///< Transmit FIFO Data Register Reset
        constexpr uint32_t DRES = (1U << 3);  ///< Receive Data Ready Error Select
        constexpr uint32_t TTRG = (4 << 4);  ///< Transmit FIFO Data Trigger Number
        constexpr uint32_t RTRG = (4 << 8);  ///< Receive FIFO Data Trigger Number
        constexpr uint32_t RSTRG = (4 << 12);  ///< RTS Output Active Trigger Number Select
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t R = (5 << 0);  ///< Receive FIFO Data Count
        constexpr uint32_t T = (5 << 8);  ///< Transmit FIFO Data Count
    }

    /// LSR Register bits
    namespace lsr_bits {
        constexpr uint32_t ORER = (1U << 0);  ///< Overrun Error Flag
        constexpr uint32_t FNUM = (5 << 2);  ///< Framing Error Count
        constexpr uint32_t PNUM = (5 << 8);  ///< Parity Error Count
    }

    /// CDR Register bits
    namespace cdr_bits {
        constexpr uint32_t CMPD = (9 << 0);  ///< Compare Match Data
    }

    /// SPTR Register bits
    namespace sptr_bits {
        constexpr uint32_t RXDMON = (1U << 0);  ///< Serial Input Data Monitor
        constexpr uint32_t SPB2DT = (1U << 1);  ///< Serial Port Break Data Select
        constexpr uint32_t SPB2IO = (1U << 2);  ///< Serial Port Break I/O
        constexpr uint32_t RINV = (1U << 4);  ///< RXD invert bit
        constexpr uint32_t TINV = (1U << 5);  ///< TXD invert bit
        constexpr uint32_t ASEN = (1U << 6);  ///< Adjust receive sampling timing enable
        constexpr uint32_t ATEN = (1U << 7);  ///< Adjust transmit timing enable
    }

    /// ACTR Register bits
    namespace actr_bits {
        constexpr uint32_t AST = (3 << 0);  ///< Adjustment value for receive Sampling Timing
        constexpr uint32_t AJD = (1U << 3);  ///< Adjustment Direction for receive sampling timing
        constexpr uint32_t ATT = (3 << 4);  ///< Adjustment value for Transmit timing
        constexpr uint32_t AET = (1U << 7);  ///< Adjustment edge for transmit timing
    }

}

// ============================================================================
// SCI1 Peripheral
// ============================================================================

namespace sci1 {
    /// Base addresses
    constexpr uint32_t SCI1_BASE = 0x40118100;

    /// SCI1 Register structure
    struct Registers {
        volatile uint32_t SMR;  ///< Offset: 0x00 - Serial Mode Register for Non-Smart Card Interface Mode...
        volatile uint32_t SMR_SMCI;  ///< Offset: 0x00 - Serial Mode Register for Smart Card Interface Mode...
        volatile uint32_t BRR;  ///< Offset: 0x01 - Bit Rate Register
        volatile uint32_t SCR;  ///< Offset: 0x02 - Serial Control Register for Non-Smart Card Interface...
        volatile uint32_t SCR_SMCI;  ///< Offset: 0x02 - Serial Control Register for Smart Card Interface Mode...
        volatile uint32_t TDR;  ///< Offset: 0x03 - Transmit Data Register
        volatile uint32_t SSR;  ///< Offset: 0x04 - Serial Status Register for Non-Smart Card Interface and...
        volatile uint32_t SSR_SMCI;  ///< Offset: 0x04 - Serial Status Register for Smart Card Interface Mode...
        volatile uint32_t RDR;  ///< Offset: 0x05 - Receive Data Register
        volatile uint32_t SCMR;  ///< Offset: 0x06 - Smart Card Mode Register
        volatile uint32_t SEMR;  ///< Offset: 0x07 - Serial Extended Mode Register
        volatile uint32_t SNFR;  ///< Offset: 0x08 - Noise Filter Setting Register
        volatile uint32_t SIMR1;  ///< Offset: 0x09 - IIC Mode Register 1
        volatile uint32_t SIMR2;  ///< Offset: 0x0A - IIC Mode Register 2
        volatile uint32_t SIMR3;  ///< Offset: 0x0B - IIC Mode Register 3
        volatile uint32_t SISR;  ///< Offset: 0x0C - IIC Status Register
        volatile uint32_t SPMR;  ///< Offset: 0x0D - SPI Mode Register
        volatile uint32_t TDRHL;  ///< Offset: 0x0E - Transmit Data Register for Non-Manchester mode (MMR.MANEN = 0)
        volatile uint32_t RDRHL;  ///< Offset: 0x10 - Receive Data Register for Non-Manchester mode (MMR.MANEN = 0)
        volatile uint32_t MDDR;  ///< Offset: 0x12 - Modulation Duty Register
        volatile uint32_t ESMER;  ///< Offset: 0x20 - Extended Serial Module Enable Register
        volatile uint32_t CR0;  ///< Offset: 0x21 - Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x22 - Control Register 1
        volatile uint32_t CR2;  ///< Offset: 0x23 - Control Register 2
        volatile uint32_t CR3;  ///< Offset: 0x24 - Control Register 3
        volatile uint32_t PCR;  ///< Offset: 0x25 - Port Control Register
        volatile uint32_t ICR;  ///< Offset: 0x26 - Interrupt Control Register
        volatile uint32_t STR;  ///< Offset: 0x27 - Status Register
        volatile uint32_t STCR;  ///< Offset: 0x28 - Status Clear Register
        volatile uint32_t CF0DR;  ///< Offset: 0x29 - Control Field 0 Data Register
        volatile uint32_t CF0CR;  ///< Offset: 0x2A - Control Field 0 Compare Enable Register
        volatile uint32_t CF0RR;  ///< Offset: 0x2B - Control Field 0 Receive Data Register
        volatile uint32_t PCF1DR;  ///< Offset: 0x2C - Primary Control Field 1 Data Register
        volatile uint32_t SCF1DR;  ///< Offset: 0x2D - Secondary Control Field 1 Data Register
        volatile uint32_t CF1CR;  ///< Offset: 0x2E - Control Field 1 Compare Enable Register
        volatile uint32_t CF1RR;  ///< Offset: 0x2F - Control Field 1 Receive Data Register
        volatile uint32_t TCR;  ///< Offset: 0x30 - Timer Control Register
        volatile uint32_t TMR;  ///< Offset: 0x31 - Timer Mode Register
        volatile uint32_t TPRE;  ///< Offset: 0x32 - Timer Prescaler Register
        volatile uint32_t TCNT;  ///< Offset: 0x33 - Timer Count Register
    };

    /// Peripheral instances
    inline Registers* SCI1 = reinterpret_cast<Registers*>(SCI1_BASE);

    // Bit definitions
    /// SMR Register bits
    namespace smr_bits {
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
        constexpr uint32_t MP = (1U << 2);  ///< Multi-Processor Mode
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Bit Length
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable
        constexpr uint32_t CHR = (1U << 6);  ///< Character Length
        constexpr uint32_t CM = (1U << 7);  ///< Communication Mode
    }

    /// SMR_SMCI Register bits
    namespace smr_smci_bits {
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
        constexpr uint32_t BCP = (2 << 2);  ///< Base Clock Pulse
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable
        constexpr uint32_t BLK = (1U << 6);  ///< Block Transfer Mode
        constexpr uint32_t GM = (1U << 7);  ///< GSM Mode
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
    }

    /// SCR_SMCI Register bits
    namespace scr_smci_bits {
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SSR_SMCI Register bits
    namespace ssr_smci_bits {
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t ERS = (1U << 4);  ///< Error Signal Status Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SCMR Register bits
    namespace scmr_bits {
        constexpr uint32_t SMIF = (1U << 0);  ///< Smart Card Interface Mode Select
        constexpr uint32_t SINV = (1U << 2);  ///< Transmitted/Received Data Invert
        constexpr uint32_t SDIR = (1U << 3);  ///< Transmitted/Received Data Transfer Direction
        constexpr uint32_t CHR1 = (1U << 4);  ///< Character Length 1
        constexpr uint32_t BCP2 = (1U << 7);  ///< Base Clock Pulse 2
    }

    /// SEMR Register bits
    namespace semr_bits {
        constexpr uint32_t ACS0 = (1U << 0);  ///< Asynchronous Mode Clock Source Select
        constexpr uint32_t PADIS = (1U << 1);  ///< Preamble function Disable
        constexpr uint32_t BRME = (1U << 2);  ///< Bit Rate Modulation Enable
        constexpr uint32_t ABCSE = (1U << 3);  ///< Asynchronous Mode Extended Base Clock Select 1
        constexpr uint32_t ABCS = (1U << 4);  ///< Asynchronous Mode Base Clock Select
        constexpr uint32_t NFEN = (1U << 5);  ///< Digital Noise Filter Function Enable
        constexpr uint32_t BGDM = (1U << 6);  ///< Baud Rate Generator Double-Speed Mode Select
        constexpr uint32_t RXDESEL = (1U << 7);  ///< Asynchronous Start Bit Edge Detection Select
    }

    /// SNFR Register bits
    namespace snfr_bits {
        constexpr uint32_t NFCS = (3 << 0);  ///< Noise Filter Clock Select
    }

    /// SIMR1 Register bits
    namespace simr1_bits {
        constexpr uint32_t IICM = (1U << 0);  ///< Simple IIC Mode Select
        constexpr uint32_t IICDL = (5 << 3);  ///< SDAn Delay Output Select
    }

    /// SIMR2 Register bits
    namespace simr2_bits {
        constexpr uint32_t IICINTM = (1U << 0);  ///< IIC Interrupt Mode Select
        constexpr uint32_t IICCSC = (1U << 1);  ///< Clock Synchronization
        constexpr uint32_t IICACKT = (1U << 5);  ///< ACK Transmission Data
    }

    /// SIMR3 Register bits
    namespace simr3_bits {
        constexpr uint32_t IICSTAREQ = (1U << 0);  ///< Start Condition Generation
        constexpr uint32_t IICRSTAREQ = (1U << 1);  ///< Restart Condition Generation
        constexpr uint32_t IICSTPREQ = (1U << 2);  ///< Stop Condition Generation
        constexpr uint32_t IICSTIF = (1U << 3);  ///< Issuing of Start, Restart, or Stop Condition Completed Flag
        constexpr uint32_t IICSDAS = (2 << 4);  ///< SDAn Output Select
        constexpr uint32_t IICSCLS = (2 << 6);  ///< SCLn Output Select
    }

    /// SISR Register bits
    namespace sisr_bits {
        constexpr uint32_t IICACKR = (1U << 0);  ///< ACK Reception Data Flag
    }

    /// SPMR Register bits
    namespace spmr_bits {
        constexpr uint32_t SSE = (1U << 0);  ///< SSn Pin Function Enable
        constexpr uint32_t CTSE = (1U << 1);  ///< CTS Enable
        constexpr uint32_t MSS = (1U << 2);  ///< Master Slave Select
        constexpr uint32_t CTSPEN = (1U << 3);  ///< CTS external pin Enable
        constexpr uint32_t MFF = (1U << 4);  ///< Mode Fault Flag
        constexpr uint32_t CKPOL = (1U << 6);  ///< Clock Polarity Select
        constexpr uint32_t CKPH = (1U << 7);  ///< Clock Phase Select
    }

    /// TDRHL Register bits
    namespace tdrhl_bits {
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial Transmit Data
    }

    /// RDRHL Register bits
    namespace rdrhl_bits {
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial Receive Data
    }

    /// ESMER Register bits
    namespace esmer_bits {
        constexpr uint32_t ESME = (1U << 0);  ///< Extended Serial Mode Enable
    }

    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t SFSF = (1U << 1);  ///< Start Frame Status Flag
        constexpr uint32_t RXDSF = (1U << 2);  ///< RXDXn Input Status Flag
        constexpr uint32_t BRME = (1U << 3);  ///< Bit Rate Measurement Enable
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t BFE = (1U << 0);  ///< Break Field Enable
        constexpr uint32_t CF0RE = (1U << 1);  ///< Control Field 0 Reception Enable
        constexpr uint32_t CF1DS = (2 << 2);  ///< Control Field 1 Data Register Select
        constexpr uint32_t PIBE = (1U << 4);  ///< Priority Interrupt Bit Enable
        constexpr uint32_t PIBS = (3 << 5);  ///< Priority Interrupt Bit Select
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t DFCS = (3 << 0);  ///< RXDXn Signal Digital Filter Clock Select
        constexpr uint32_t BCCS = (2 << 4);  ///< Bus Collision Detection Clock Select
        constexpr uint32_t RTS = (2 << 6);  ///< RXDXn Reception Sampling Timing Select
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t SDST = (1U << 0);  ///< Start Frame Detection Start
    }

    /// PCR Register bits
    namespace pcr_bits {
        constexpr uint32_t TXDXPS = (1U << 0);  ///< TXDXn Signal Polarity Select
        constexpr uint32_t RXDXPS = (1U << 1);  ///< RXDXn Signal Polarity Select
        constexpr uint32_t SHARPS = (1U << 4);  ///< TXDXn/RXDXn Pin Multiplexing Select
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t BFDIE = (1U << 0);  ///< Break Field Low Width Detected Interrupt Enable
        constexpr uint32_t CF0MIE = (1U << 1);  ///< Control Field 0 Match Detected Interrupt Enable
        constexpr uint32_t CF1MIE = (1U << 2);  ///< Control Field 1 Match Detected Interrupt Enable
        constexpr uint32_t PIBDIE = (1U << 3);  ///< Priority Interrupt Bit Detected Interrupt Enable
        constexpr uint32_t BCDIE = (1U << 4);  ///< Bus Collision Detected Interrupt Enable
        constexpr uint32_t AEDIE = (1U << 5);  ///< Valid Edge Detected Interrupt Enable
    }

    /// STR Register bits
    namespace str_bits {
        constexpr uint32_t BFDF = (1U << 0);  ///< Break Field Low Width Detection Flag
        constexpr uint32_t CF0MF = (1U << 1);  ///< Control Field 0 Match Flag
        constexpr uint32_t CF1MF = (1U << 2);  ///< Control Field 1 Match Flag
        constexpr uint32_t PIBDF = (1U << 3);  ///< Priority Interrupt Bit Detection Flag
        constexpr uint32_t BCDF = (1U << 4);  ///< Bus Collision Detected Flag
        constexpr uint32_t AEDF = (1U << 5);  ///< Valid Edge Detection Flag
    }

    /// STCR Register bits
    namespace stcr_bits {
        constexpr uint32_t BFDCL = (1U << 0);  ///< BFDF Clear
        constexpr uint32_t CF0MCL = (1U << 1);  ///< CF0MF Clear
        constexpr uint32_t CF1MCL = (1U << 2);  ///< CF1MF Clear
        constexpr uint32_t PIBDCL = (1U << 3);  ///< PIBDF Clear
        constexpr uint32_t BCDCL = (1U << 4);  ///< BCDF Clear
        constexpr uint32_t AEDCL = (1U << 5);  ///< AEDF Clear
    }

    /// CF0CR Register bits
    namespace cf0cr_bits {
        constexpr uint32_t CF0CE0 = (1U << 0);  ///< Control Field 0 Bit 0 Compare Enable
        constexpr uint32_t CF0CE1 = (1U << 1);  ///< Control Field 1 Bit 0 Compare Enable
        constexpr uint32_t CF0CE2 = (1U << 2);  ///< Control Field 2 Bit 0 Compare Enable
        constexpr uint32_t CF0CE3 = (1U << 3);  ///< Control Field 3 Bit 0 Compare Enable
        constexpr uint32_t CF0CE4 = (1U << 4);  ///< Control Field 4 Bit 0 Compare Enable
        constexpr uint32_t CF0CE5 = (1U << 5);  ///< Control Field 5 Bit 0 Compare Enable
        constexpr uint32_t CF0CE6 = (1U << 6);  ///< Control Field 6 Bit 0 Compare Enable
        constexpr uint32_t CF0CE7 = (1U << 7);  ///< Control Field 7 Bit 0 Compare Enable
    }

    /// CF1CR Register bits
    namespace cf1cr_bits {
        constexpr uint32_t CF1CE0 = (1U << 0);  ///< Control Field 1 Bit 0 Compare Enable
        constexpr uint32_t CF1CE1 = (1U << 1);  ///< Control Field 1 Bit 1 Compare Enable
        constexpr uint32_t CF1CE2 = (1U << 2);  ///< Control Field 1 Bit 2 Compare Enable
        constexpr uint32_t CF1CE3 = (1U << 3);  ///< Control Field 1 Bit 3 Compare Enable
        constexpr uint32_t CF1CE4 = (1U << 4);  ///< Control Field 1 Bit 4 Compare Enable
        constexpr uint32_t CF1CE5 = (1U << 5);  ///< Control Field 1 Bit 5 Compare Enable
        constexpr uint32_t CF1CE6 = (1U << 6);  ///< Control Field 1 Bit 6 Compare Enable
        constexpr uint32_t CF1CE7 = (1U << 7);  ///< Control Field 1 Bit 7 Compare Enable
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCST = (1U << 0);  ///< Timer Count Start
    }

    /// TMR Register bits
    namespace tmr_bits {
        constexpr uint32_t TOMS = (2 << 0);  ///< Timer Operating Mode Select
        constexpr uint32_t TWRC = (1U << 3);  ///< Counter Write Control
        constexpr uint32_t TCSS = (3 << 4);  ///< Timer Count Clock Source Select
    }

}

// ============================================================================
// SCI2 Peripheral
// ============================================================================

namespace sci2 {
    /// Base addresses
    constexpr uint32_t SCI2_BASE = 0x40118200;

    /// SCI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI2 = reinterpret_cast<Registers*>(SCI2_BASE);

}

// ============================================================================
// SCI3 Peripheral
// ============================================================================

namespace sci3 {
    /// Base addresses
    constexpr uint32_t SCI3_BASE = 0x40118300;

    /// SCI3 Register structure
    struct Registers {
        volatile uint32_t SMR;  ///< Offset: 0x00 - Serial Mode Register for Non-Smart Card Interface Mode...
        volatile uint32_t SMR_SMCI;  ///< Offset: 0x00 - Serial Mode Register for Smart Card Interface Mode...
        volatile uint32_t BRR;  ///< Offset: 0x01 - Bit Rate Register
        volatile uint32_t SCR;  ///< Offset: 0x02 - Serial Control Register for Non-Smart Card Interface...
        volatile uint32_t SCR_SMCI;  ///< Offset: 0x02 - Serial Control Register for Smart Card Interface Mode...
        volatile uint32_t TDR;  ///< Offset: 0x03 - Transmit Data Register
        volatile uint32_t SSR;  ///< Offset: 0x04 - Serial Status Register for Non-Smart Card Interface and...
        volatile uint32_t SSR_FIFO;  ///< Offset: 0x04 - Serial Status Register for Non-Smart Card Interface and...
        volatile uint32_t SSR_MANC;  ///< Offset: 0x04 - Serial Status Register for Manchester Mode (SCMR.SMIF =...
        volatile uint32_t SSR_SMCI;  ///< Offset: 0x04 - Serial Status Register for Smart Card Interface Mode...
        volatile uint32_t RDR;  ///< Offset: 0x05 - Receive Data Register
        volatile uint32_t SCMR;  ///< Offset: 0x06 - Smart Card Mode Register
        volatile uint32_t SEMR;  ///< Offset: 0x07 - Serial Extended Mode Register
        volatile uint32_t SNFR;  ///< Offset: 0x08 - Noise Filter Setting Register
        volatile uint32_t SIMR1;  ///< Offset: 0x09 - IIC Mode Register 1
        volatile uint32_t SIMR2;  ///< Offset: 0x0A - IIC Mode Register 2
        volatile uint32_t SIMR3;  ///< Offset: 0x0B - IIC Mode Register 3
        volatile uint32_t SISR;  ///< Offset: 0x0C - IIC Status Register
        volatile uint32_t SPMR;  ///< Offset: 0x0D - SPI Mode Register
        volatile uint32_t FTDRHL;  ///< Offset: 0x0E - Transmit FIFO Data Register
        volatile uint32_t TDRHL;  ///< Offset: 0x0E - Transmit Data Register for Non-Manchester mode (MMR.MANEN = 0)
        volatile uint32_t TDRHL_MAN;  ///< Offset: 0x0E - Transmit Data Register for Manchester mode (MMR.MANEN = 1)
        volatile uint32_t FTDRH;  ///< Offset: 0x0E - Transmit FIFO Data Register
        volatile uint32_t FTDRL;  ///< Offset: 0x0F - Transmit FIFO Data Register
        volatile uint32_t FRDRHL;  ///< Offset: 0x10 - Receive FIFO Data Register
        volatile uint32_t RDRHL;  ///< Offset: 0x10 - Receive Data Register for Non-Manchester mode (MMR.MANEN = 0)
        volatile uint32_t RDRHL_MAN;  ///< Offset: 0x10 - Receive Data Register for Manchester mode (MMR.MANEN = 1)
        volatile uint32_t FRDRH;  ///< Offset: 0x10 - Receive FIFO Data Register
        volatile uint32_t FRDRL;  ///< Offset: 0x11 - Receive FIFO Data Register
        volatile uint32_t MDDR;  ///< Offset: 0x12 - Modulation Duty Register
        volatile uint32_t DCCR;  ///< Offset: 0x13 - Data Compare Match Control Register
        volatile uint32_t FCR;  ///< Offset: 0x14 - FIFO Control Register
        volatile uint32_t FDR;  ///< Offset: 0x16 - FIFO Data Count Register
        volatile uint32_t LSR;  ///< Offset: 0x18 - Line Status Register
        volatile uint32_t CDR;  ///< Offset: 0x1A - Compare Match Data Register
        volatile uint32_t SPTR;  ///< Offset: 0x1C - Serial Port Register
        volatile uint32_t ACTR;  ///< Offset: 0x1D - Adjustment Communication Timing Register
        volatile uint32_t MMR;  ///< Offset: 0x20 - Manchester Mode Register
        volatile uint32_t TMPR;  ///< Offset: 0x22 - Transmit Manchester Preface Setting Register
        volatile uint32_t RMPR;  ///< Offset: 0x23 - Receive Manchester Preface Setting Register
        volatile uint32_t MESR;  ///< Offset: 0x24 - Manchester Extended Error Status Register
        volatile uint32_t MECR;  ///< Offset: 0x25 - Manchester Extended Error Control Register
    };

    /// Peripheral instances
    inline Registers* SCI3 = reinterpret_cast<Registers*>(SCI3_BASE);

    // Bit definitions
    /// SMR Register bits
    namespace smr_bits {
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
        constexpr uint32_t MP = (1U << 2);  ///< Multi-Processor Mode
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Bit Length
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable
        constexpr uint32_t CHR = (1U << 6);  ///< Character Length
        constexpr uint32_t CM = (1U << 7);  ///< Communication Mode
    }

    /// SMR_SMCI Register bits
    namespace smr_smci_bits {
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
        constexpr uint32_t BCP = (2 << 2);  ///< Base Clock Pulse
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable
        constexpr uint32_t BLK = (1U << 6);  ///< Block Transfer Mode
        constexpr uint32_t GM = (1U << 7);  ///< GSM Mode
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
    }

    /// SCR_SMCI Register bits
    namespace scr_smci_bits {
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SSR_FIFO Register bits
    namespace ssr_fifo_bits {
        constexpr uint32_t DR = (1U << 0);  ///< Receive Data Ready Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO Data Full Flag
        constexpr uint32_t TDFE = (1U << 7);  ///< Transmit FIFO Data Empty Flag
    }

    /// SSR_MANC Register bits
    namespace ssr_manc_bits {
        constexpr uint32_t MER = (1U << 0);  ///< Manchester Error Flag
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SSR_SMCI Register bits
    namespace ssr_smci_bits {
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t ERS = (1U << 4);  ///< Error Signal Status Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SCMR Register bits
    namespace scmr_bits {
        constexpr uint32_t SMIF = (1U << 0);  ///< Smart Card Interface Mode Select
        constexpr uint32_t SINV = (1U << 2);  ///< Transmitted/Received Data Invert
        constexpr uint32_t SDIR = (1U << 3);  ///< Transmitted/Received Data Transfer Direction
        constexpr uint32_t CHR1 = (1U << 4);  ///< Character Length 1
        constexpr uint32_t BCP2 = (1U << 7);  ///< Base Clock Pulse 2
    }

    /// SEMR Register bits
    namespace semr_bits {
        constexpr uint32_t ACS0 = (1U << 0);  ///< Asynchronous Mode Clock Source Select
        constexpr uint32_t PADIS = (1U << 1);  ///< Preamble function Disable
        constexpr uint32_t BRME = (1U << 2);  ///< Bit Rate Modulation Enable
        constexpr uint32_t ABCSE = (1U << 3);  ///< Asynchronous Mode Extended Base Clock Select 1
        constexpr uint32_t ABCS = (1U << 4);  ///< Asynchronous Mode Base Clock Select
        constexpr uint32_t NFEN = (1U << 5);  ///< Digital Noise Filter Function Enable
        constexpr uint32_t BGDM = (1U << 6);  ///< Baud Rate Generator Double-Speed Mode Select
        constexpr uint32_t RXDESEL = (1U << 7);  ///< Asynchronous Start Bit Edge Detection Select
    }

    /// SNFR Register bits
    namespace snfr_bits {
        constexpr uint32_t NFCS = (3 << 0);  ///< Noise Filter Clock Select
    }

    /// SIMR1 Register bits
    namespace simr1_bits {
        constexpr uint32_t IICM = (1U << 0);  ///< Simple IIC Mode Select
        constexpr uint32_t IICDL = (5 << 3);  ///< SDAn Delay Output Select
    }

    /// SIMR2 Register bits
    namespace simr2_bits {
        constexpr uint32_t IICINTM = (1U << 0);  ///< IIC Interrupt Mode Select
        constexpr uint32_t IICCSC = (1U << 1);  ///< Clock Synchronization
        constexpr uint32_t IICACKT = (1U << 5);  ///< ACK Transmission Data
    }

    /// SIMR3 Register bits
    namespace simr3_bits {
        constexpr uint32_t IICSTAREQ = (1U << 0);  ///< Start Condition Generation
        constexpr uint32_t IICRSTAREQ = (1U << 1);  ///< Restart Condition Generation
        constexpr uint32_t IICSTPREQ = (1U << 2);  ///< Stop Condition Generation
        constexpr uint32_t IICSTIF = (1U << 3);  ///< Issuing of Start, Restart, or Stop Condition Completed Flag
        constexpr uint32_t IICSDAS = (2 << 4);  ///< SDAn Output Select
        constexpr uint32_t IICSCLS = (2 << 6);  ///< SCLn Output Select
    }

    /// SISR Register bits
    namespace sisr_bits {
        constexpr uint32_t IICACKR = (1U << 0);  ///< ACK Reception Data Flag
    }

    /// SPMR Register bits
    namespace spmr_bits {
        constexpr uint32_t SSE = (1U << 0);  ///< SSn Pin Function Enable
        constexpr uint32_t CTSE = (1U << 1);  ///< CTS Enable
        constexpr uint32_t MSS = (1U << 2);  ///< Master Slave Select
        constexpr uint32_t CTSPEN = (1U << 3);  ///< CTS external pin Enable
        constexpr uint32_t MFF = (1U << 4);  ///< Mode Fault Flag
        constexpr uint32_t CKPOL = (1U << 6);  ///< Clock Polarity Select
        constexpr uint32_t CKPH = (1U << 7);  ///< Clock Phase Select
    }

    /// FTDRHL Register bits
    namespace ftdrhl_bits {
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial transmit data
        constexpr uint32_t MPBT = (1U << 9);  ///< Multi-Processor Transfer Bit Flag
    }

    /// TDRHL Register bits
    namespace tdrhl_bits {
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial Transmit Data
    }

    /// TDRHL_MAN Register bits
    namespace tdrhl_man_bits {
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial transmit data
        constexpr uint32_t MPBT = (1U << 9);  ///< Multi-processor transfer bit flag
        constexpr uint32_t TSYNC = (1U << 12);  ///< Transmit SYNC data bit
    }

    /// FTDRH Register bits
    namespace ftdrh_bits {
        constexpr uint32_t MPBT = (1U << 1);  ///< Multi-Processor Transfer Bit Flag
    }

    /// FTDRL Register bits
    namespace ftdrl_bits {
        constexpr uint32_t TDAT = (8 << 0);  ///< Serial transmit data
    }

    /// FRDRHL Register bits
    namespace frdrhl_bits {
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial receive data
        constexpr uint32_t MPB = (1U << 9);  ///< Multi-Processor Bit Flag
        constexpr uint32_t DR = (1U << 10);  ///< Receive Data Ready Flag
        constexpr uint32_t PER = (1U << 11);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 12);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 13);  ///< Overrun Error Flag
        constexpr uint32_t RDF = (1U << 14);  ///< Receive FIFO Data Full Flag
    }

    /// RDRHL Register bits
    namespace rdrhl_bits {
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial Receive Data
    }

    /// RDRHL_MAN Register bits
    namespace rdrhl_man_bits {
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial receive data
        constexpr uint32_t MPB = (1U << 9);  ///< Multi-processor bit
        constexpr uint32_t RSYNC = (1U << 12);  ///< Receive SYNC data bit
    }

    /// FRDRH Register bits
    namespace frdrh_bits {
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor Bit Flag
        constexpr uint32_t DR = (1U << 2);  ///< Receive Data Ready Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO Data Full Flag
    }

    /// FRDRL Register bits
    namespace frdrl_bits {
        constexpr uint32_t RDAT = (8 << 0);  ///< Serial receive data
    }

    /// DCCR Register bits
    namespace dccr_bits {
        constexpr uint32_t DCMF = (1U << 0);  ///< Data Compare Match Flag
        constexpr uint32_t DPER = (1U << 3);  ///< Data Compare Match Parity Error Flag
        constexpr uint32_t DFER = (1U << 4);  ///< Data Compare Match Framing Error Flag
        constexpr uint32_t IDSEL = (1U << 6);  ///< ID Frame Select
        constexpr uint32_t DCME = (1U << 7);  ///< Data Compare Match Enable
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t FM = (1U << 0);  ///< FIFO Mode Select
        constexpr uint32_t RFRST = (1U << 1);  ///< Receive FIFO Data Register Reset
        constexpr uint32_t TFRST = (1U << 2);  ///< Transmit FIFO Data Register Reset
        constexpr uint32_t DRES = (1U << 3);  ///< Receive Data Ready Error Select
        constexpr uint32_t TTRG = (4 << 4);  ///< Transmit FIFO Data Trigger Number
        constexpr uint32_t RTRG = (4 << 8);  ///< Receive FIFO Data Trigger Number
        constexpr uint32_t RSTRG = (4 << 12);  ///< RTS Output Active Trigger Number Select
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t R = (5 << 0);  ///< Receive FIFO Data Count
        constexpr uint32_t T = (5 << 8);  ///< Transmit FIFO Data Count
    }

    /// LSR Register bits
    namespace lsr_bits {
        constexpr uint32_t ORER = (1U << 0);  ///< Overrun Error Flag
        constexpr uint32_t FNUM = (5 << 2);  ///< Framing Error Count
        constexpr uint32_t PNUM = (5 << 8);  ///< Parity Error Count
    }

    /// CDR Register bits
    namespace cdr_bits {
        constexpr uint32_t CMPD = (9 << 0);  ///< Compare Match Data
    }

    /// SPTR Register bits
    namespace sptr_bits {
        constexpr uint32_t RXDMON = (1U << 0);  ///< Serial Input Data Monitor
        constexpr uint32_t SPB2DT = (1U << 1);  ///< Serial Port Break Data Select
        constexpr uint32_t SPB2IO = (1U << 2);  ///< Serial Port Break I/O
        constexpr uint32_t RINV = (1U << 4);  ///< RXD invert bit
        constexpr uint32_t TINV = (1U << 5);  ///< TXD invert bit
        constexpr uint32_t ASEN = (1U << 6);  ///< Adjust receive sampling timing enable
        constexpr uint32_t ATEN = (1U << 7);  ///< Adjust transmit timing enable
    }

    /// ACTR Register bits
    namespace actr_bits {
        constexpr uint32_t AST = (3 << 0);  ///< Adjustment value for receive Sampling Timing
        constexpr uint32_t AJD = (1U << 3);  ///< Adjustment Direction for receive sampling timing
        constexpr uint32_t ATT = (3 << 4);  ///< Adjustment value for Transmit timing
        constexpr uint32_t AET = (1U << 7);  ///< Adjustment edge for transmit timing
    }

    /// MMR Register bits
    namespace mmr_bits {
        constexpr uint32_t RMPOL = (1U << 0);  ///< Polarity of Received Manchester Code
        constexpr uint32_t TMPOL = (1U << 1);  ///< Polarity of Transmit Manchester Code
        constexpr uint32_t ERTEN = (1U << 2);  ///< Manchester Edge Retiming Enable
        constexpr uint32_t SYNVAL = (1U << 4);  ///< SYNC value Setting
        constexpr uint32_t SYNSEL = (1U << 5);  ///< SYNC Select
        constexpr uint32_t SBSEL = (1U << 6);  ///< Start Bit Select
        constexpr uint32_t MANEN = (1U << 7);  ///< Manchester Mode Enable
    }

    /// TMPR Register bits
    namespace tmpr_bits {
        constexpr uint32_t TPLEN = (4 << 0);  ///< Transmit preface length
        constexpr uint32_t TPPAT = (2 << 4);  ///< Transmit preface pattern
    }

    /// RMPR Register bits
    namespace rmpr_bits {
        constexpr uint32_t RPLEN = (4 << 0);  ///< Receive Preface Length
        constexpr uint32_t RPPAT = (2 << 4);  ///< Receive Preface Pattern
    }

    /// MESR Register bits
    namespace mesr_bits {
        constexpr uint32_t PFER = (1U << 0);  ///< Preface Error flag
        constexpr uint32_t SYER = (1U << 1);  ///< SYNC Error flag
        constexpr uint32_t SBER = (1U << 2);  ///< Start Bit Error flag
    }

    /// MECR Register bits
    namespace mecr_bits {
        constexpr uint32_t PFEREN = (1U << 0);  ///< Preface Error Enable
        constexpr uint32_t SYEREN = (1U << 1);  ///< Receive SYNC Error Enable
        constexpr uint32_t SBEREN = (1U << 2);  ///< Start Bit Error Enable
    }

}

// ============================================================================
// SCI4 Peripheral
// ============================================================================

namespace sci4 {
    /// Base addresses
    constexpr uint32_t SCI4_BASE = 0x40118400;

    /// SCI4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI4 = reinterpret_cast<Registers*>(SCI4_BASE);

}

// ============================================================================
// SCI9 Peripheral
// ============================================================================

namespace sci9 {
    /// Base addresses
    constexpr uint32_t SCI9_BASE = 0x40118900;

    /// SCI9 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI9 = reinterpret_cast<Registers*>(SCI9_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x4011A000;
    constexpr uint32_t QSPI_BASE = 0x64000000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPCR;  ///< Offset: 0x00 - SPI Control Register
        volatile uint32_t SSLP;  ///< Offset: 0x01 - SPI Slave Select Polarity Register
        volatile uint32_t SPPCR;  ///< Offset: 0x02 - SPI Pin Control Register
        volatile uint32_t SPSR;  ///< Offset: 0x03 - SPI Status Register
        volatile uint32_t SPDR;  ///< Offset: 0x04 - SPI Data Register
        volatile uint32_t SPDR_HA;  ///< Offset: 0x04 - SPI Data Register
        volatile uint32_t SPDR_BY;  ///< Offset: 0x04 - SPI Data Register
        volatile uint32_t SPSCR;  ///< Offset: 0x08 - SPI Sequence Control Register
        volatile uint32_t SPSSR;  ///< Offset: 0x09 - SPI Sequence Status Register
        volatile uint32_t SPBR;  ///< Offset: 0x0A - SPI Bit Rate Register
        volatile uint32_t SPDCR;  ///< Offset: 0x0B - SPI Data Control Register
        volatile uint32_t SPCKD;  ///< Offset: 0x0C - SPI Clock Delay Register
        volatile uint32_t SSLND;  ///< Offset: 0x0D - SPI Slave Select Negation Delay Register
        volatile uint32_t SPND;  ///< Offset: 0x0E - SPI Next-Access Delay Register
        volatile uint32_t SPCR2;  ///< Offset: 0x0F - SPI Control Register 2
        volatile uint32_t SPCMD%s;  ///< Offset: 0x10 - SPI Command Register %s
        volatile uint32_t SPDCR2;  ///< Offset: 0x20 - SPI Data Control Register 2
        volatile uint32_t SPCR3;  ///< Offset: 0x21 - SPI Control Register 3
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* QSPI = reinterpret_cast<Registers*>(QSPI_BASE);

    // Bit definitions
    /// SPCR Register bits
    namespace spcr_bits {
        constexpr uint32_t SPMS = (1U << 0);  ///< SPI Mode Select
        constexpr uint32_t TXMD = (1U << 1);  ///< Communications Operating Mode Select
        constexpr uint32_t MODFEN = (1U << 2);  ///< Mode Fault Error Detection Enable
        constexpr uint32_t MSTR = (1U << 3);  ///< SPI Master/Slave Mode Select
        constexpr uint32_t SPEIE = (1U << 4);  ///< SPI Error Interrupt Enable
        constexpr uint32_t SPTIE = (1U << 5);  ///< Transmit Buffer Empty Interrupt Enable
        constexpr uint32_t SPE = (1U << 6);  ///< SPI Function Enable
        constexpr uint32_t SPRIE = (1U << 7);  ///< SPI Receive Buffer Full Interrupt Enable
    }

    /// SSLP Register bits
    namespace sslp_bits {
        constexpr uint32_t SSL0P = (1U << 0);  ///< SSLn0 Signal Polarity Setting
        constexpr uint32_t SSL1P = (1U << 1);  ///< SSLn1 Signal Polarity Setting
        constexpr uint32_t SSL2P = (1U << 2);  ///< SSLn2 Signal Polarity Setting
        constexpr uint32_t SSL3P = (1U << 3);  ///< SSLn3 Signal Polarity Setting
    }

    /// SPPCR Register bits
    namespace sppcr_bits {
        constexpr uint32_t SPLP = (1U << 0);  ///< SPI Loopback
        constexpr uint32_t SPLP2 = (1U << 1);  ///< SPI Loopback 2
        constexpr uint32_t MOIFV = (1U << 4);  ///< MOSI Idle Fixed Value
        constexpr uint32_t MOIFE = (1U << 5);  ///< MOSI Idle Value Fixing Enable
    }

    /// SPSR Register bits
    namespace spsr_bits {
        constexpr uint32_t OVRF = (1U << 0);  ///< Overrun Error Flag
        constexpr uint32_t IDLNF = (1U << 1);  ///< SPI Idle Flag
        constexpr uint32_t MODF = (1U << 2);  ///< Mode Fault Error Flag
        constexpr uint32_t PERF = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t UDRF = (1U << 4);  ///< Underrun Error Flag
        constexpr uint32_t SPTEF = (1U << 5);  ///< SPI Transmit Buffer Empty Flag
        constexpr uint32_t CENDF = (1U << 6);  ///< Communication End Flag
        constexpr uint32_t SPRF = (1U << 7);  ///< SPI Receive Buffer Full Flag
    }

    /// SPSCR Register bits
    namespace spscr_bits {
        constexpr uint32_t SPSLN = (3 << 0);  ///< SPI Sequence Length Specification
    }

    /// SPSSR Register bits
    namespace spssr_bits {
        constexpr uint32_t SPCP = (3 << 0);  ///< SPI Command Pointer
        constexpr uint32_t SPECM = (3 << 4);  ///< SPI Error Command
    }

    /// SPDCR Register bits
    namespace spdcr_bits {
        constexpr uint32_t SPFC = (2 << 0);  ///< Number of Frames Specification
        constexpr uint32_t SPRDTD = (1U << 4);  ///< SPI Receive/Transmit Data Select
        constexpr uint32_t SPLW = (1U << 5);  ///< SPI Word Access/Halfword Access Specification
        constexpr uint32_t SPBYT = (1U << 6);  ///< SPI Byte Access Specification
    }

    /// SPCKD Register bits
    namespace spckd_bits {
        constexpr uint32_t SCKDL = (3 << 0);  ///< RSPCK Delay Setting
    }

    /// SSLND Register bits
    namespace sslnd_bits {
        constexpr uint32_t SLNDL = (3 << 0);  ///< SSL Negation Delay Setting
    }

    /// SPND Register bits
    namespace spnd_bits {
        constexpr uint32_t SPNDL = (3 << 0);  ///< SPI Next-Access Delay Setting
    }

    /// SPCR2 Register bits
    namespace spcr2_bits {
        constexpr uint32_t SPPE = (1U << 0);  ///< Parity Enable
        constexpr uint32_t SPOE = (1U << 1);  ///< Parity Mode
        constexpr uint32_t SPIIE = (1U << 2);  ///< SPI Idle Interrupt Enable
        constexpr uint32_t PTE = (1U << 3);  ///< Parity Self-Testing
        constexpr uint32_t SCKASE = (1U << 4);  ///< RSPCK Auto-Stop Function Enable
    }

    /// SPCMD%s Register bits
    namespace spcmd%s_bits {
        constexpr uint32_t CPHA = (1U << 0);  ///< RSPCK Phase Setting
        constexpr uint32_t CPOL = (1U << 1);  ///< RSPCK Polarity Setting
        constexpr uint32_t BRDV = (2 << 2);  ///< Bit Rate Division Setting
        constexpr uint32_t SSLA = (3 << 4);  ///< SSL Signal Assertion Setting
        constexpr uint32_t SSLKP = (1U << 7);  ///< SSL Signal Level Keeping
        constexpr uint32_t SPB = (4 << 8);  ///< SPI Data Length Setting
        constexpr uint32_t LSBF = (1U << 12);  ///< SPI LSB First
        constexpr uint32_t SPNDEN = (1U << 13);  ///< SPI Next-Access Delay Enable
        constexpr uint32_t SLNDEN = (1U << 14);  ///< SSL Negation Delay Setting Enable
        constexpr uint32_t SCKDEN = (1U << 15);  ///< RSPCK Delay Setting Enable
    }

    /// SPDCR2 Register bits
    namespace spdcr2_bits {
        constexpr uint32_t BYSW = (1U << 0);  ///< Byte Swap Operating Mode Select
        constexpr uint32_t SINV = (1U << 1);  ///< Serial Data Invert Bit
    }

    /// SPCR3 Register bits
    namespace spcr3_bits {
        constexpr uint32_t ETXMD = (1U << 0);  ///< Extended Communication Mode Select
        constexpr uint32_t BFDS = (1U << 1);  ///< Between Burst Transfer Frames Delay Select
        constexpr uint32_t CENDIE = (1U << 4);  ///< SPI Communication End Interrupt Enable
    }

}

// ============================================================================
// GPT320 Peripheral
// ============================================================================

namespace gpt320 {
    /// Base addresses
    constexpr uint32_t GPT320_BASE = 0x40169000;

    /// GPT320 Register structure
    struct Registers {
        volatile uint32_t GTWP;  ///< Offset: 0x00 - General PWM Timer Write-Protection Register
        volatile uint32_t GTSTR;  ///< Offset: 0x04 - General PWM Timer Software Start Register
        volatile uint32_t GTSTP;  ///< Offset: 0x08 - General PWM Timer Software Stop Register
        volatile uint32_t GTCLR;  ///< Offset: 0x0C - General PWM Timer Software Clear Register
        volatile uint32_t GTSSR;  ///< Offset: 0x10 - General PWM Timer Start Source Select Register
        volatile uint32_t GTPSR;  ///< Offset: 0x14 - General PWM Timer Stop Source Select Register
        volatile uint32_t GTCSR;  ///< Offset: 0x18 - General PWM Timer Clear Source Select Register
        volatile uint32_t GTUPSR;  ///< Offset: 0x1C - General PWM Timer Up Count Source Select Register
        volatile uint32_t GTDNSR;  ///< Offset: 0x20 - General PWM Timer Down Count Source Select Register
        volatile uint32_t GTICASR;  ///< Offset: 0x24 - General PWM Timer Input Capture Source Select Register A
        volatile uint32_t GTICBSR;  ///< Offset: 0x28 - General PWM Timer Input Capture Source Select Register B
        volatile uint32_t GTCR;  ///< Offset: 0x2C - General PWM Timer Control Register
        volatile uint32_t GTUDDTYC;  ///< Offset: 0x30 - General PWM Timer Count Direction and Duty Setting Register
        volatile uint32_t GTIOR;  ///< Offset: 0x34 - General PWM Timer I/O Control Register
        volatile uint32_t GTINTAD;  ///< Offset: 0x38 - General PWM Timer Interrupt Output Setting Register
        volatile uint32_t GTST;  ///< Offset: 0x3C - General PWM Timer Status Register
        volatile uint32_t GTBER;  ///< Offset: 0x40 - General PWM Timer Buffer Enable Register
        volatile uint32_t GTCNT;  ///< Offset: 0x48 - General PWM Timer Counter
        volatile uint32_t GTCCRA;  ///< Offset: 0x4C - General PWM Timer Compare Capture Register A
        volatile uint32_t GTCCRB;  ///< Offset: 0x50 - General PWM Timer Compare Capture Register B
        volatile uint32_t GTCCRC;  ///< Offset: 0x54 - General PWM Timer Compare Capture Register C
        volatile uint32_t GTCCRE;  ///< Offset: 0x58 - General PWM Timer Compare Capture Register E
        volatile uint32_t GTCCRD;  ///< Offset: 0x5C - General PWM Timer Compare Capture Register D
        volatile uint32_t GTCCRF;  ///< Offset: 0x60 - General PWM Timer Compare Capture Register F
        volatile uint32_t GTPR;  ///< Offset: 0x64 - General PWM Timer Cycle Setting Register
        volatile uint32_t GTPBR;  ///< Offset: 0x68 - General PWM Timer Cycle Setting Buffer Register
        volatile uint32_t GTDTCR;  ///< Offset: 0x88 - General PWM Timer Dead Time Control Register
        volatile uint32_t GTDVU;  ///< Offset: 0x8C - General PWM Timer Dead Time Value Register U
        volatile uint32_t GTICLF;  ///< Offset: 0xB8 - General PWM Timer Inter Channel Logical Operation...
        volatile uint32_t GTPC;  ///< Offset: 0xBC - General PWM Timer Period Count Register
        volatile uint32_t GTSECSR;  ///< Offset: 0xD0 - General PWM Timer Operation Enable Bit Simultaneous...
        volatile uint32_t GTSECR;  ///< Offset: 0xD4 - General PWM Timer Operation Enable Bit Simultaneous...
    };

    /// Peripheral instances
    inline Registers* GPT320 = reinterpret_cast<Registers*>(GPT320_BASE);

    // Bit definitions
    /// GTWP Register bits
    namespace gtwp_bits {
        constexpr uint32_t WP = (1U << 0);  ///< Register Write Disable
        constexpr uint32_t STRWP = (1U << 1);  ///< GTSTR.CSTRT Bit Write Disable
        constexpr uint32_t STPWP = (1U << 2);  ///< GTSTP.CSTOP Bit Write Disable
        constexpr uint32_t CLRWP = (1U << 3);  ///< GTCLR.CCLR Bit Write Disable
        constexpr uint32_t CMNWP = (1U << 4);  ///< Common Register Write Disabled
        constexpr uint32_t PRKEY = (8 << 8);  ///< GTWP Key Code
    }

    /// GTSTR Register bits
    namespace gtstr_bits {
        constexpr uint32_t CSTRT0 = (1U << 0);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT1 = (1U << 1);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT2 = (1U << 2);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT3 = (1U << 3);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT4 = (1U << 4);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT5 = (1U << 5);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT6 = (1U << 6);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT7 = (1U << 7);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT8 = (1U << 8);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT9 = (1U << 9);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
    }

    /// GTSTP Register bits
    namespace gtstp_bits {
        constexpr uint32_t CSTOP0 = (1U << 0);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP1 = (1U << 1);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP2 = (1U << 2);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP3 = (1U << 3);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP4 = (1U << 4);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP5 = (1U << 5);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP6 = (1U << 6);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP7 = (1U << 7);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP8 = (1U << 8);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP9 = (1U << 9);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
    }

    /// GTCLR Register bits
    namespace gtclr_bits {
        constexpr uint32_t CCLR0 = (1U << 0);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR1 = (1U << 1);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR2 = (1U << 2);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR3 = (1U << 3);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR4 = (1U << 4);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR5 = (1U << 5);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR6 = (1U << 6);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR7 = (1U << 7);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR8 = (1U << 8);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR9 = (1U << 9);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
    }

    /// GTSSR Register bits
    namespace gtssr_bits {
        constexpr uint32_t SSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Start Enable
        constexpr uint32_t SSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Start Enable
        constexpr uint32_t SSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Start Enable
        constexpr uint32_t SSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Start Enable
        constexpr uint32_t SSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Start Enable
        constexpr uint32_t SSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Start Enable
        constexpr uint32_t SSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Start Enable
        constexpr uint32_t SSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Start Enable
        constexpr uint32_t SSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Start Enable
        constexpr uint32_t SSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Start Enable
        constexpr uint32_t SSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Start Enable
        constexpr uint32_t SSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Start Enable
        constexpr uint32_t SSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Start Enable
        constexpr uint32_t SSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Start Enable
        constexpr uint32_t CSTRT = (1U << 31);  ///< Software Source Counter Start Enable
    }

    /// GTPSR Register bits
    namespace gtpsr_bits {
        constexpr uint32_t PSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Stop Enable
        constexpr uint32_t PSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Stop Enable
        constexpr uint32_t PSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Stop Enable
        constexpr uint32_t PSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Stop Enable
        constexpr uint32_t PSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Stop Enable
        constexpr uint32_t PSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Stop Enable
        constexpr uint32_t PSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Stop Enable
        constexpr uint32_t PSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Stop Enable
        constexpr uint32_t PSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Stop Enable
        constexpr uint32_t PSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Stop Enable
        constexpr uint32_t PSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Stop Enable
        constexpr uint32_t CSTOP = (1U << 31);  ///< Software Source Counter Stop Enable
    }

    /// GTCSR Register bits
    namespace gtcsr_bits {
        constexpr uint32_t CSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Clear Enable
        constexpr uint32_t CSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Clear Enable
        constexpr uint32_t CSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Clear Enable
        constexpr uint32_t CSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Clear Enable
        constexpr uint32_t CSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Clear Enable
        constexpr uint32_t CSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Clear Enable
        constexpr uint32_t CSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Clear Enable
        constexpr uint32_t CSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Clear Enable
        constexpr uint32_t CSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Clear Enable
        constexpr uint32_t CSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Clear Enable
        constexpr uint32_t CSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Clear Enable
        constexpr uint32_t CCLR = (1U << 31);  ///< Software Source Counter Clear Enable
    }

    /// GTUPSR Register bits
    namespace gtupsr_bits {
        constexpr uint32_t USGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Up Enable
        constexpr uint32_t USCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Up Enable
        constexpr uint32_t USCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Up Enable
        constexpr uint32_t USELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Up Enable
        constexpr uint32_t USELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Up Enable
        constexpr uint32_t USELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Up Enable
        constexpr uint32_t USELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Up Enable
        constexpr uint32_t USELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Up Enable
        constexpr uint32_t USELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Up Enable
        constexpr uint32_t USELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Up Enable
        constexpr uint32_t USELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Count Up Enable
    }

    /// GTDNSR Register bits
    namespace gtdnsr_bits {
        constexpr uint32_t DSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Down Enable
        constexpr uint32_t DSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Down Enable
        constexpr uint32_t DSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Down Enable
        constexpr uint32_t DSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Down Enable
        constexpr uint32_t DSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Down Enable
        constexpr uint32_t DSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Down Enable
        constexpr uint32_t DSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Down Enable
        constexpr uint32_t DSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Down Enable
        constexpr uint32_t DSELCH = (1U << 23);  ///< ELC_GPTF Event Source Counter Count Down Enable
    }

    /// GTICASR Register bits
    namespace gticasr_bits {
        constexpr uint32_t ASGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRA Input Capture Enable
    }

    /// GTICBSR Register bits
    namespace gticbsr_bits {
        constexpr uint32_t BSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRB Input Capture Enable
    }

    /// GTCR Register bits
    namespace gtcr_bits {
        constexpr uint32_t CST = (1U << 0);  ///< Count Start
        constexpr uint32_t MD = (3 << 16);  ///< Mode Select
        constexpr uint32_t TPCS = (4 << 23);  ///< Timer Prescaler Select
    }

    /// GTUDDTYC Register bits
    namespace gtuddtyc_bits {
        constexpr uint32_t UD = (1U << 0);  ///< Count Direction Setting
        constexpr uint32_t UDF = (1U << 1);  ///< Forcible Count Direction Setting
        constexpr uint32_t OADTY = (2 << 16);  ///< GTIOCnA Output Duty Setting
        constexpr uint32_t OADTYF = (1U << 18);  ///< Forcible GTIOCnA Output Duty Setting
        constexpr uint32_t OADTYR = (1U << 19);  ///< GTIOCnA Output Value Selecting after Releasing 0%/100% Duty Setting
        constexpr uint32_t OBDTY = (2 << 24);  ///< GTIOCnB Output Duty Setting
        constexpr uint32_t OBDTYF = (1U << 26);  ///< Forcible GTIOCnB Output Duty Setting
        constexpr uint32_t OBDTYR = (1U << 27);  ///< GTIOCnB Output Value Selecting after Releasing 0%/100% Duty Setting
    }

    /// GTIOR Register bits
    namespace gtior_bits {
        constexpr uint32_t GTIOA = (5 << 0);  ///< GTIOCnA Pin Function Select
        constexpr uint32_t OADFLT = (1U << 6);  ///< GTIOCnA Pin Output Value Setting at the Count Stop
        constexpr uint32_t OAHLD = (1U << 7);  ///< GTIOCnA Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OAE = (1U << 8);  ///< GTIOCnA Pin Output Enable
        constexpr uint32_t OADF = (2 << 9);  ///< GTIOCnA Pin Disable Value Setting
        constexpr uint32_t NFAEN = (1U << 13);  ///< Noise Filter A Enable
        constexpr uint32_t NFCSA = (2 << 14);  ///< Noise Filter A Sampling Clock Select
        constexpr uint32_t GTIOB = (5 << 16);  ///< GTIOCnB Pin Function Select
        constexpr uint32_t OBDFLT = (1U << 22);  ///< GTIOCnB Pin Output Value Setting at the Count Stop
        constexpr uint32_t OBHLD = (1U << 23);  ///< GTIOCnB Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OBE = (1U << 24);  ///< GTIOCnB Pin Output Enable
        constexpr uint32_t OBDF = (2 << 25);  ///< GTIOCnB Pin Disable Value Setting
        constexpr uint32_t NFBEN = (1U << 29);  ///< Noise Filter B Enable
        constexpr uint32_t NFCSB = (2 << 30);  ///< Noise Filter B Sampling Clock Select
    }

    /// GTINTAD Register bits
    namespace gtintad_bits {
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disable Source Select
        constexpr uint32_t GRPABH = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t GRPABL = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
    }

    /// GTST Register bits
    namespace gtst_bits {
        constexpr uint32_t TCFA = (1U << 0);  ///< Input Capture/Compare Match Flag A
        constexpr uint32_t TCFB = (1U << 1);  ///< Input Capture/Compare Match Flag B
        constexpr uint32_t TCFC = (1U << 2);  ///< Input Compare Match Flag C
        constexpr uint32_t TCFD = (1U << 3);  ///< Input Compare Match Flag D
        constexpr uint32_t TCFE = (1U << 4);  ///< Input Compare Match Flag E
        constexpr uint32_t TCFF = (1U << 5);  ///< Input Compare Match Flag F
        constexpr uint32_t TCFPO = (1U << 6);  ///< Overflow Flag
        constexpr uint32_t TCFPU = (1U << 7);  ///< Underflow Flag
        constexpr uint32_t TUCF = (1U << 15);  ///< Count Direction Flag
        constexpr uint32_t ODF = (1U << 24);  ///< Output Disable Flag
        constexpr uint32_t OABHF = (1U << 29);  ///< Same Time Output Level High Flag
        constexpr uint32_t OABLF = (1U << 30);  ///< Same Time Output Level Low Flag
        constexpr uint32_t PCF = (1U << 31);  ///< Period Count Function Finish Flag
    }

    /// GTBER Register bits
    namespace gtber_bits {
        constexpr uint32_t BD0 = (1U << 0);  ///< GTCCR Buffer Operation Disable
        constexpr uint32_t BD1 = (1U << 1);  ///< GTPR Buffer Operation Disable
        constexpr uint32_t CCRA = (2 << 16);  ///< GTCCRA Buffer Operation
        constexpr uint32_t CCRB = (2 << 18);  ///< GTCCRB Buffer Operation
        constexpr uint32_t PR = (2 << 20);  ///< GTPR Buffer Operation
        constexpr uint32_t CCRSWT = (1U << 22);  ///< GTCCRA and GTCCRB Forcible Buffer Operation
    }

    /// GTDTCR Register bits
    namespace gtdtcr_bits {
        constexpr uint32_t TDE = (1U << 0);  ///< Negative-Phase Waveform Setting
    }

    /// GTICLF Register bits
    namespace gticlf_bits {
        constexpr uint32_t ICLFA = (3 << 0);  ///< GTIOCnA Output Logical Operation Function Select
        constexpr uint32_t ICLFSELC = (6 << 4);  ///< Inter Channel Signal C Select
        constexpr uint32_t ICLFB = (3 << 16);  ///< GTIOCnB Output Logical Operation Function Select
        constexpr uint32_t ICLFSELD = (6 << 20);  ///< Inter Channel Signal D Select
    }

    /// GTPC Register bits
    namespace gtpc_bits {
        constexpr uint32_t PCEN = (1U << 0);  ///< Period Count Function Enable
        constexpr uint32_t ASTP = (1U << 8);  ///< Automatic Stop Function Enable
        constexpr uint32_t PCNT = (12 << 16);  ///< Period Counter
    }

    /// GTSECSR Register bits
    namespace gtsecsr_bits {
        constexpr uint32_t SECSEL0 = (1U << 0);  ///< Channel 0 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL1 = (1U << 1);  ///< Channel 1 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL2 = (1U << 2);  ///< Channel 2 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL3 = (1U << 3);  ///< Channel 3 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL4 = (1U << 4);  ///< Channel 4 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL5 = (1U << 5);  ///< Channel 5 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL6 = (1U << 6);  ///< Channel 6 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL7 = (1U << 7);  ///< Channel 7 Operation Enable Bit Simultaneous Control Channel Select
    }

    /// GTSECR Register bits
    namespace gtsecr_bits {
        constexpr uint32_t SBDCE = (1U << 0);  ///< GTCCR Register Buffer Operation Simultaneous Enable
        constexpr uint32_t SBDPE = (1U << 1);  ///< GTPR Register Buffer Operation Simultaneous Enable
        constexpr uint32_t SBDCD = (1U << 8);  ///< GTCCR Register Buffer Operation Simultaneous Disable
        constexpr uint32_t SBDPD = (1U << 9);  ///< GTPR Register Buffer Operation Simultaneous Disable
        constexpr uint32_t SPCE = (1U << 16);  ///< Period Count Function Simultaneous Enable
        constexpr uint32_t SPCD = (1U << 24);  ///< Period Count Function Simultaneous Disable
    }

}

// ============================================================================
// GPT321 Peripheral
// ============================================================================

namespace gpt321 {
    /// Base addresses
    constexpr uint32_t GPT321_BASE = 0x40169100;

    /// GPT321 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT321 = reinterpret_cast<Registers*>(GPT321_BASE);

}

// ============================================================================
// GPT322 Peripheral
// ============================================================================

namespace gpt322 {
    /// Base addresses
    constexpr uint32_t GPT322_BASE = 0x40169200;

    /// GPT322 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT322 = reinterpret_cast<Registers*>(GPT322_BASE);

}

// ============================================================================
// GPT323 Peripheral
// ============================================================================

namespace gpt323 {
    /// Base addresses
    constexpr uint32_t GPT323_BASE = 0x40169300;

    /// GPT323 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT323 = reinterpret_cast<Registers*>(GPT323_BASE);

}

// ============================================================================
// GPT164 Peripheral
// ============================================================================

namespace gpt164 {
    /// Base addresses
    constexpr uint32_t GPT164_BASE = 0x40169400;

    /// GPT164 Register structure
    struct Registers {
        volatile uint32_t GTWP;  ///< Offset: 0x00 - General PWM Timer Write-Protection Register
        volatile uint32_t GTSTR;  ///< Offset: 0x04 - General PWM Timer Software Start Register
        volatile uint32_t GTSTP;  ///< Offset: 0x08 - General PWM Timer Software Stop Register
        volatile uint32_t GTCLR;  ///< Offset: 0x0C - General PWM Timer Software Clear Register
        volatile uint32_t GTSSR;  ///< Offset: 0x10 - General PWM Timer Start Source Select Register
        volatile uint32_t GTPSR;  ///< Offset: 0x14 - General PWM Timer Stop Source Select Register
        volatile uint32_t GTCSR;  ///< Offset: 0x18 - General PWM Timer Clear Source Select Register
        volatile uint32_t GTUPSR;  ///< Offset: 0x1C - General PWM Timer Up Count Source Select Register
        volatile uint32_t GTDNSR;  ///< Offset: 0x20 - General PWM Timer Down Count Source Select Register
        volatile uint32_t GTICASR;  ///< Offset: 0x24 - General PWM Timer Input Capture Source Select Register A
        volatile uint32_t GTICBSR;  ///< Offset: 0x28 - General PWM Timer Input Capture Source Select Register B
        volatile uint32_t GTCR;  ///< Offset: 0x2C - General PWM Timer Control Register
        volatile uint32_t GTUDDTYC;  ///< Offset: 0x30 - General PWM Timer Count Direction and Duty Setting Register
        volatile uint32_t GTIOR;  ///< Offset: 0x34 - General PWM Timer I/O Control Register
        volatile uint32_t GTINTAD;  ///< Offset: 0x38 - General PWM Timer Interrupt Output Setting Register
        volatile uint32_t GTST;  ///< Offset: 0x3C - General PWM Timer Status Register
        volatile uint32_t GTBER;  ///< Offset: 0x40 - General PWM Timer Buffer Enable Register
        volatile uint32_t GTCNT;  ///< Offset: 0x48 - General PWM Timer Counter
        volatile uint32_t GTCCRA;  ///< Offset: 0x4C - General PWM Timer Compare Capture Register A
        volatile uint32_t GTCCRB;  ///< Offset: 0x50 - General PWM Timer Compare Capture Register B
        volatile uint32_t GTCCRC;  ///< Offset: 0x54 - General PWM Timer Compare Capture Register C
        volatile uint32_t GTCCRE;  ///< Offset: 0x58 - General PWM Timer Compare Capture Register E
        volatile uint32_t GTCCRD;  ///< Offset: 0x5C - General PWM Timer Compare Capture Register D
        volatile uint32_t GTCCRF;  ///< Offset: 0x60 - General PWM Timer Compare Capture Register F
        volatile uint32_t GTPR;  ///< Offset: 0x64 - General PWM Timer Cycle Setting Register
        volatile uint32_t GTPBR;  ///< Offset: 0x68 - General PWM Timer Cycle Setting Buffer Register
        volatile uint32_t GTDTCR;  ///< Offset: 0x88 - General PWM Timer Dead Time Control Register
        volatile uint32_t GTDVU;  ///< Offset: 0x8C - General PWM Timer Dead Time Value Register U
        volatile uint32_t GTICLF;  ///< Offset: 0xB8 - General PWM Timer Inter Channel Logical Operation...
        volatile uint32_t GTPC;  ///< Offset: 0xBC - General PWM Timer Period Count Register
        volatile uint32_t GTSECSR;  ///< Offset: 0xD0 - General PWM Timer Operation Enable Bit Simultaneous...
        volatile uint32_t GTSECR;  ///< Offset: 0xD4 - General PWM Timer Operation Enable Bit Simultaneous...
    };

    /// Peripheral instances
    inline Registers* GPT164 = reinterpret_cast<Registers*>(GPT164_BASE);

    // Bit definitions
    /// GTWP Register bits
    namespace gtwp_bits {
        constexpr uint32_t WP = (1U << 0);  ///< Register Write Disable
        constexpr uint32_t STRWP = (1U << 1);  ///< GTSTR.CSTRT Bit Write Disable
        constexpr uint32_t STPWP = (1U << 2);  ///< GTSTP.CSTOP Bit Write Disable
        constexpr uint32_t CLRWP = (1U << 3);  ///< GTCLR.CCLR Bit Write Disable
        constexpr uint32_t CMNWP = (1U << 4);  ///< Common Register Write Disabled
        constexpr uint32_t PRKEY = (8 << 8);  ///< GTWP Key Code
    }

    /// GTSTR Register bits
    namespace gtstr_bits {
        constexpr uint32_t CSTRT0 = (1U << 0);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT1 = (1U << 1);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT2 = (1U << 2);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT3 = (1U << 3);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT4 = (1U << 4);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT5 = (1U << 5);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT6 = (1U << 6);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT7 = (1U << 7);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT8 = (1U << 8);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT9 = (1U << 9);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
    }

    /// GTSTP Register bits
    namespace gtstp_bits {
        constexpr uint32_t CSTOP0 = (1U << 0);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP1 = (1U << 1);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP2 = (1U << 2);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP3 = (1U << 3);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP4 = (1U << 4);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP5 = (1U << 5);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP6 = (1U << 6);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP7 = (1U << 7);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP8 = (1U << 8);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP9 = (1U << 9);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
    }

    /// GTCLR Register bits
    namespace gtclr_bits {
        constexpr uint32_t CCLR0 = (1U << 0);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR1 = (1U << 1);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR2 = (1U << 2);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR3 = (1U << 3);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR4 = (1U << 4);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR5 = (1U << 5);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR6 = (1U << 6);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR7 = (1U << 7);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR8 = (1U << 8);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR9 = (1U << 9);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
    }

    /// GTSSR Register bits
    namespace gtssr_bits {
        constexpr uint32_t SSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Start Enable
        constexpr uint32_t SSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Start Enable
        constexpr uint32_t SSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Start Enable
        constexpr uint32_t SSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Start Enable
        constexpr uint32_t SSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Start Enable
        constexpr uint32_t SSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Start Enable
        constexpr uint32_t SSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Start Enable
        constexpr uint32_t SSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Start Enable
        constexpr uint32_t SSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Start Enable
        constexpr uint32_t SSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Start Enable
        constexpr uint32_t SSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Start Enable
        constexpr uint32_t SSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Start Enable
        constexpr uint32_t SSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Start Enable
        constexpr uint32_t SSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Start Enable
        constexpr uint32_t CSTRT = (1U << 31);  ///< Software Source Counter Start Enable
    }

    /// GTPSR Register bits
    namespace gtpsr_bits {
        constexpr uint32_t PSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Stop Enable
        constexpr uint32_t PSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Stop Enable
        constexpr uint32_t PSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Stop Enable
        constexpr uint32_t PSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Stop Enable
        constexpr uint32_t PSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Stop Enable
        constexpr uint32_t PSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Stop Enable
        constexpr uint32_t PSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Stop Enable
        constexpr uint32_t PSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Stop Enable
        constexpr uint32_t PSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Stop Enable
        constexpr uint32_t PSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Stop Enable
        constexpr uint32_t PSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Stop Enable
        constexpr uint32_t CSTOP = (1U << 31);  ///< Software Source Counter Stop Enable
    }

    /// GTCSR Register bits
    namespace gtcsr_bits {
        constexpr uint32_t CSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Clear Enable
        constexpr uint32_t CSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Clear Enable
        constexpr uint32_t CSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Clear Enable
        constexpr uint32_t CSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Clear Enable
        constexpr uint32_t CSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Clear Enable
        constexpr uint32_t CSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Clear Enable
        constexpr uint32_t CSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Clear Enable
        constexpr uint32_t CSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Clear Enable
        constexpr uint32_t CSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Clear Enable
        constexpr uint32_t CSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Clear Enable
        constexpr uint32_t CSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Clear Enable
        constexpr uint32_t CCLR = (1U << 31);  ///< Software Source Counter Clear Enable
    }

    /// GTUPSR Register bits
    namespace gtupsr_bits {
        constexpr uint32_t USGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Up Enable
        constexpr uint32_t USCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Up Enable
        constexpr uint32_t USCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Up Enable
        constexpr uint32_t USELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Up Enable
        constexpr uint32_t USELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Up Enable
        constexpr uint32_t USELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Up Enable
        constexpr uint32_t USELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Up Enable
        constexpr uint32_t USELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Up Enable
        constexpr uint32_t USELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Up Enable
        constexpr uint32_t USELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Up Enable
        constexpr uint32_t USELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Count Up Enable
    }

    /// GTDNSR Register bits
    namespace gtdnsr_bits {
        constexpr uint32_t DSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Down Enable
        constexpr uint32_t DSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Down Enable
        constexpr uint32_t DSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Down Enable
        constexpr uint32_t DSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Down Enable
        constexpr uint32_t DSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Down Enable
        constexpr uint32_t DSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Down Enable
        constexpr uint32_t DSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Down Enable
        constexpr uint32_t DSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Down Enable
        constexpr uint32_t DSELCH = (1U << 23);  ///< ELC_GPTF Event Source Counter Count Down Enable
    }

    /// GTICASR Register bits
    namespace gticasr_bits {
        constexpr uint32_t ASGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRA Input Capture Enable
    }

    /// GTICBSR Register bits
    namespace gticbsr_bits {
        constexpr uint32_t BSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRB Input Capture Enable
    }

    /// GTCR Register bits
    namespace gtcr_bits {
        constexpr uint32_t CST = (1U << 0);  ///< Count Start
        constexpr uint32_t MD = (3 << 16);  ///< Mode Select
        constexpr uint32_t TPCS = (4 << 23);  ///< Timer Prescaler Select
    }

    /// GTUDDTYC Register bits
    namespace gtuddtyc_bits {
        constexpr uint32_t UD = (1U << 0);  ///< Count Direction Setting
        constexpr uint32_t UDF = (1U << 1);  ///< Forcible Count Direction Setting
        constexpr uint32_t OADTY = (2 << 16);  ///< GTIOCnA Output Duty Setting
        constexpr uint32_t OADTYF = (1U << 18);  ///< Forcible GTIOCnA Output Duty Setting
        constexpr uint32_t OADTYR = (1U << 19);  ///< GTIOCnA Output Value Selecting after Releasing 0%/100% Duty Setting
        constexpr uint32_t OBDTY = (2 << 24);  ///< GTIOCnB Output Duty Setting
        constexpr uint32_t OBDTYF = (1U << 26);  ///< Forcible GTIOCnB Output Duty Setting
        constexpr uint32_t OBDTYR = (1U << 27);  ///< GTIOCnB Output Value Selecting after Releasing 0%/100% Duty Setting
    }

    /// GTIOR Register bits
    namespace gtior_bits {
        constexpr uint32_t GTIOA = (5 << 0);  ///< GTIOCnA Pin Function Select
        constexpr uint32_t OADFLT = (1U << 6);  ///< GTIOCnA Pin Output Value Setting at the Count Stop
        constexpr uint32_t OAHLD = (1U << 7);  ///< GTIOCnA Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OAE = (1U << 8);  ///< GTIOCnA Pin Output Enable
        constexpr uint32_t OADF = (2 << 9);  ///< GTIOCnA Pin Disable Value Setting
        constexpr uint32_t NFAEN = (1U << 13);  ///< Noise Filter A Enable
        constexpr uint32_t NFCSA = (2 << 14);  ///< Noise Filter A Sampling Clock Select
        constexpr uint32_t GTIOB = (5 << 16);  ///< GTIOCnB Pin Function Select
        constexpr uint32_t OBDFLT = (1U << 22);  ///< GTIOCnB Pin Output Value Setting at the Count Stop
        constexpr uint32_t OBHLD = (1U << 23);  ///< GTIOCnB Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OBE = (1U << 24);  ///< GTIOCnB Pin Output Enable
        constexpr uint32_t OBDF = (2 << 25);  ///< GTIOCnB Pin Disable Value Setting
        constexpr uint32_t NFBEN = (1U << 29);  ///< Noise Filter B Enable
        constexpr uint32_t NFCSB = (2 << 30);  ///< Noise Filter B Sampling Clock Select
    }

    /// GTINTAD Register bits
    namespace gtintad_bits {
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disable Source Select
        constexpr uint32_t GRPABH = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t GRPABL = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
    }

    /// GTST Register bits
    namespace gtst_bits {
        constexpr uint32_t TCFA = (1U << 0);  ///< Input Capture/Compare Match Flag A
        constexpr uint32_t TCFB = (1U << 1);  ///< Input Capture/Compare Match Flag B
        constexpr uint32_t TCFC = (1U << 2);  ///< Input Compare Match Flag C
        constexpr uint32_t TCFD = (1U << 3);  ///< Input Compare Match Flag D
        constexpr uint32_t TCFE = (1U << 4);  ///< Input Compare Match Flag E
        constexpr uint32_t TCFF = (1U << 5);  ///< Input Compare Match Flag F
        constexpr uint32_t TCFPO = (1U << 6);  ///< Overflow Flag
        constexpr uint32_t TCFPU = (1U << 7);  ///< Underflow Flag
        constexpr uint32_t TUCF = (1U << 15);  ///< Count Direction Flag
        constexpr uint32_t ODF = (1U << 24);  ///< Output Disable Flag
        constexpr uint32_t OABHF = (1U << 29);  ///< Same Time Output Level High Flag
        constexpr uint32_t OABLF = (1U << 30);  ///< Same Time Output Level Low Flag
        constexpr uint32_t PCF = (1U << 31);  ///< Period Count Function Finish Flag
    }

    /// GTBER Register bits
    namespace gtber_bits {
        constexpr uint32_t BD0 = (1U << 0);  ///< GTCCR Buffer Operation Disable
        constexpr uint32_t BD1 = (1U << 1);  ///< GTPR Buffer Operation Disable
        constexpr uint32_t CCRA = (2 << 16);  ///< GTCCRA Buffer Operation
        constexpr uint32_t CCRB = (2 << 18);  ///< GTCCRB Buffer Operation
        constexpr uint32_t PR = (2 << 20);  ///< GTPR Buffer Operation
        constexpr uint32_t CCRSWT = (1U << 22);  ///< GTCCRA and GTCCRB Forcible Buffer Operation
    }

    /// GTDTCR Register bits
    namespace gtdtcr_bits {
        constexpr uint32_t TDE = (1U << 0);  ///< Negative-Phase Waveform Setting
    }

    /// GTICLF Register bits
    namespace gticlf_bits {
        constexpr uint32_t ICLFA = (3 << 0);  ///< GTIOCnA Output Logical Operation Function Select
        constexpr uint32_t ICLFSELC = (6 << 4);  ///< Inter Channel Signal C Select
        constexpr uint32_t ICLFB = (3 << 16);  ///< GTIOCnB Output Logical Operation Function Select
        constexpr uint32_t ICLFSELD = (6 << 20);  ///< Inter Channel Signal D Select
    }

    /// GTPC Register bits
    namespace gtpc_bits {
        constexpr uint32_t PCEN = (1U << 0);  ///< Period Count Function Enable
        constexpr uint32_t ASTP = (1U << 8);  ///< Automatic Stop Function Enable
        constexpr uint32_t PCNT = (12 << 16);  ///< Period Counter
    }

    /// GTSECSR Register bits
    namespace gtsecsr_bits {
        constexpr uint32_t SECSEL0 = (1U << 0);  ///< Channel 0 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL1 = (1U << 1);  ///< Channel 1 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL2 = (1U << 2);  ///< Channel 2 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL3 = (1U << 3);  ///< Channel 3 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL4 = (1U << 4);  ///< Channel 4 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL5 = (1U << 5);  ///< Channel 5 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL6 = (1U << 6);  ///< Channel 6 Operation Enable Bit Simultaneous Control Channel Select
        constexpr uint32_t SECSEL7 = (1U << 7);  ///< Channel 7 Operation Enable Bit Simultaneous Control Channel Select
    }

    /// GTSECR Register bits
    namespace gtsecr_bits {
        constexpr uint32_t SBDCE = (1U << 0);  ///< GTCCR Register Buffer Operation Simultaneous Enable
        constexpr uint32_t SBDPE = (1U << 1);  ///< GTPR Register Buffer Operation Simultaneous Enable
        constexpr uint32_t SBDCD = (1U << 8);  ///< GTCCR Register Buffer Operation Simultaneous Disable
        constexpr uint32_t SBDPD = (1U << 9);  ///< GTPR Register Buffer Operation Simultaneous Disable
        constexpr uint32_t SPCE = (1U << 16);  ///< Period Count Function Simultaneous Enable
        constexpr uint32_t SPCD = (1U << 24);  ///< Period Count Function Simultaneous Disable
    }

}

// ============================================================================
// GPT165 Peripheral
// ============================================================================

namespace gpt165 {
    /// Base addresses
    constexpr uint32_t GPT165_BASE = 0x40169500;

    /// GPT165 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT165 = reinterpret_cast<Registers*>(GPT165_BASE);

}

// ============================================================================
// GPT166 Peripheral
// ============================================================================

namespace gpt166 {
    /// Base addresses
    constexpr uint32_t GPT166_BASE = 0x40169600;

    /// GPT166 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT166 = reinterpret_cast<Registers*>(GPT166_BASE);

}

// ============================================================================
// GPT167 Peripheral
// ============================================================================

namespace gpt167 {
    /// Base addresses
    constexpr uint32_t GPT167_BASE = 0x40169700;

    /// GPT167 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT167 = reinterpret_cast<Registers*>(GPT167_BASE);

}

// ============================================================================
// GPT Peripheral
// ============================================================================

namespace gpt {
    /// Base addresses
    constexpr uint32_t GPT_OPS_BASE = 0x40169A00;

    /// GPT Register structure
    struct Registers {
        volatile uint32_t OPSCR;  ///< Offset: 0x00 - Output Phase Switching Control Register
    };

    /// Peripheral instances
    inline Registers* GPT_OPS = reinterpret_cast<Registers*>(GPT_OPS_BASE);

    // Bit definitions
    /// OPSCR Register bits
    namespace opscr_bits {
        constexpr uint32_t UF = (1U << 0);  ///< UF
        constexpr uint32_t VF = (1U << 1);  ///< VF
        constexpr uint32_t WF = (1U << 2);  ///< WF
        constexpr uint32_t U = (1U << 4);  ///< Input U-Phase Monitor
        constexpr uint32_t V = (1U << 5);  ///< Input V-Phase Monitor
        constexpr uint32_t W = (1U << 6);  ///< Input W-Phase Monitor
        constexpr uint32_t EN = (1U << 8);  ///< Output Phase Enable
        constexpr uint32_t FB = (1U << 16);  ///< External Feedback Signal Enable
        constexpr uint32_t P = (1U << 17);  ///< Positive-Phase Output (P) Control
        constexpr uint32_t N = (1U << 18);  ///< Negative-Phase Output (N) Control
        constexpr uint32_t INV = (1U << 19);  ///< Output Phase Invert Control
        constexpr uint32_t RV = (1U << 20);  ///< Output Phase Rotation Direction Reversal Control
        constexpr uint32_t ALIGN = (1U << 21);  ///< Input Phase Alignment
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disabled Source Selection
        constexpr uint32_t GODF = (1U << 26);  ///< Group Output Disable Function
        constexpr uint32_t NFEN = (1U << 29);  ///< External Input Noise Filter Enable
        constexpr uint32_t NFCS = (2 << 30);  ///< External Input Noise Filter Clock Selection
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC120_BASE = 0x40170000;
    constexpr uint32_t ADC121_BASE = 0x40170200;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADCSR;  ///< Offset: 0x00 - A/D Control Register
        volatile uint32_t ADANSA0;  ///< Offset: 0x04 - A/D Channel Select Register A0
        volatile uint32_t ADANSA1;  ///< Offset: 0x06 - A/D Channel Select Register A1
        volatile uint32_t ADADS0;  ///< Offset: 0x08 - A/D-Converted Value Addition/Average Channel Select Register 0
        volatile uint32_t ADADS1;  ///< Offset: 0x0A - A/D-Converted Value Addition/Average Channel Select Register 1
        volatile uint32_t ADADC;  ///< Offset: 0x0C - A/D-Converted Value Addition/Average Count Select Register
        volatile uint32_t ADCER;  ///< Offset: 0x0E - A/D Control Extended Register
        volatile uint32_t ADSTRGR;  ///< Offset: 0x10 - A/D Conversion Start Trigger Select Register
        volatile uint32_t ADEXICR;  ///< Offset: 0x12 - A/D Conversion Extended Input Control Registers
        volatile uint32_t ADANSB0;  ///< Offset: 0x14 - A/D Channel Select Register B0
        volatile uint32_t ADANSB1;  ///< Offset: 0x16 - A/D Channel Select Register B1
        volatile uint32_t ADDBLDR;  ///< Offset: 0x18 - A/D Data Duplexing Register
        volatile uint32_t ADTSDR;  ///< Offset: 0x1A - A/D Temperature Sensor Data Register
        volatile uint32_t ADOCDR;  ///< Offset: 0x1C - A/D Internal Reference Voltage Data Register
        volatile uint32_t ADRD;  ///< Offset: 0x1E - A/D Self-Diagnosis Data Register
        volatile uint32_t ADDR%s;  ///< Offset: 0x38 - A/D Data Registers %s
        volatile uint32_t ADDISCR;  ///< Offset: 0x7A - A/D Disconnection Detection Control Register
        volatile uint32_t ADGSPCR;  ///< Offset: 0x80 - A/D Group Scan Priority Control Register
        volatile uint32_t ADDBLDRA;  ///< Offset: 0x84 - A/D Data Duplexing Register A
        volatile uint32_t ADDBLDRB;  ///< Offset: 0x86 - A/D Data Duplexing Register B
        volatile uint32_t ADWINMON;  ///< Offset: 0x8C - A/D Compare Function Window A/B Status Monitor Register
        volatile uint32_t ADCMPCR;  ///< Offset: 0x90 - A/D Compare Function Control Register
        volatile uint32_t ADCMPANSER;  ///< Offset: 0x92 - A/D Compare Function Window A Extended Input Select Register
        volatile uint32_t ADCMPLER;  ///< Offset: 0x93 - A/D Compare Function Window A Extended Input Comparison...
        volatile uint32_t ADCMPANSR0;  ///< Offset: 0x94 - A/D Compare Function Window A Channel Select Register 0
        volatile uint32_t ADCMPANSR1;  ///< Offset: 0x96 - A/D Compare Function Window A Channel Select Register 1
        volatile uint32_t ADCMPLR0;  ///< Offset: 0x98 - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPLR1;  ///< Offset: 0x9A - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPDR%s;  ///< Offset: 0x9C - A/D Compare Function Window A Lower-Side/Upper-Side...
        volatile uint32_t ADCMPSR0;  ///< Offset: 0xA0 - A/D Compare Function Window A Channel Status Register 0
        volatile uint32_t ADCMPSR1;  ///< Offset: 0xA2 - A/D Compare Function Window A Channel Status Register1
        volatile uint32_t ADCMPSER;  ///< Offset: 0xA4 - A/D Compare Function Window A Extended Input Channel...
        volatile uint32_t ADCMPBNSR;  ///< Offset: 0xA6 - A/D Compare Function Window B Channel Select Register
        volatile uint32_t ADWINLLB;  ///< Offset: 0xA8 - A/D Compare Function Window B Lower-Side/Upper-Side...
        volatile uint32_t ADWINULB;  ///< Offset: 0xAA - A/D Compare Function Window B Lower-Side/Upper-Side...
        volatile uint32_t ADCMPBSR;  ///< Offset: 0xAC - A/D Compare Function Window B Status Register
        volatile uint32_t ADBUF%s;  ///< Offset: 0xB0 - A/D Data Buffer Registers %s
        volatile uint32_t ADBUFEN;  ///< Offset: 0xD0 - A/D Data Buffer Enable Register
        volatile uint32_t ADBUFPTR;  ///< Offset: 0xD2 - A/D Data Buffer Pointer Register
        volatile uint32_t ADSSTRL;  ///< Offset: 0xDD - A/D Sampling State Register
        volatile uint32_t ADSSTRT;  ///< Offset: 0xDE - A/D Sampling State Register
        volatile uint32_t ADSSTRO;  ///< Offset: 0xDF - A/D Sampling State Register
        volatile uint32_t ADSSTR%s;  ///< Offset: 0xEC - A/D Sampling State Register
    };

    /// Peripheral instances
    inline Registers* ADC120 = reinterpret_cast<Registers*>(ADC120_BASE);
    inline Registers* ADC121 = reinterpret_cast<Registers*>(ADC121_BASE);

    // Bit definitions
    /// ADCSR Register bits
    namespace adcsr_bits {
        constexpr uint32_t DBLANS = (5 << 0);  ///< Double Trigger Channel Select
        constexpr uint32_t GBADIE = (1U << 6);  ///< Group B Scan End Interrupt and ELC Event Enable
        constexpr uint32_t DBLE = (1U << 7);  ///< Double Trigger Mode Select
        constexpr uint32_t EXTRG = (1U << 8);  ///< Trigger Select
        constexpr uint32_t TRGE = (1U << 9);  ///< Trigger Start Enable
        constexpr uint32_t ADCS = (2 << 13);  ///< Scan Mode Select
        constexpr uint32_t ADST = (1U << 15);  ///< A/D Conversion Start
    }

    /// ADANSA0 Register bits
    namespace adansa0_bits {
        constexpr uint32_t ANSA0 = (1U << 0);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA1 = (1U << 1);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA2 = (1U << 2);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA3 = (1U << 3);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA4 = (1U << 4);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA5 = (1U << 5);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA6 = (1U << 6);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA7 = (1U << 7);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA8 = (1U << 8);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA9 = (1U << 9);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA12 = (1U << 12);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA13 = (1U << 13);  ///< A/D Conversion Channels Select
    }

    /// ADANSA1 Register bits
    namespace adansa1_bits {
        constexpr uint32_t ANSA16 = (1U << 0);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA17 = (1U << 1);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA18 = (1U << 2);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA19 = (1U << 3);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA20 = (1U << 4);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA21 = (1U << 5);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA22 = (1U << 6);  ///< A/D Conversion Channels Select
    }

    /// ADADS0 Register bits
    namespace adads0_bits {
        constexpr uint32_t ADS0 = (1U << 0);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS1 = (1U << 1);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS2 = (1U << 2);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS3 = (1U << 3);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS4 = (1U << 4);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS5 = (1U << 5);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS6 = (1U << 6);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS7 = (1U << 7);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS8 = (1U << 8);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS9 = (1U << 9);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS12 = (1U << 12);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS13 = (1U << 13);  ///< A/D-Converted Value Addition/Average Channel Select
    }

    /// ADADS1 Register bits
    namespace adads1_bits {
        constexpr uint32_t ADS16 = (1U << 0);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS17 = (1U << 1);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS18 = (1U << 2);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS19 = (1U << 3);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS20 = (1U << 4);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS21 = (1U << 5);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS22 = (1U << 6);  ///< A/D-Converted Value Addition/Average Channel Select
    }

    /// ADADC Register bits
    namespace adadc_bits {
        constexpr uint32_t ADC = (3 << 0);  ///< Addition/Average Count Select
        constexpr uint32_t AVEE = (1U << 7);  ///< Average Mode Select
    }

    /// ADCER Register bits
    namespace adcer_bits {
        constexpr uint32_t ADPRC = (2 << 1);  ///< 12-bit accuracy
        constexpr uint32_t ACE = (1U << 5);  ///< A/D Data Register Automatic Clearing Enable
        constexpr uint32_t DIAGVAL = (2 << 8);  ///< Self-Diagnosis Conversion Voltage Select
        constexpr uint32_t DIAGLD = (1U << 10);  ///< Self-Diagnosis Mode Select
        constexpr uint32_t DIAGM = (1U << 11);  ///< Self-Diagnosis Enable
        constexpr uint32_t ADRFMT = (1U << 15);  ///< A/D Data Register Format Select
    }

    /// ADSTRGR Register bits
    namespace adstrgr_bits {
        constexpr uint32_t TRSB = (6 << 0);  ///< A/D Conversion Start Trigger Select for Group B
        constexpr uint32_t TRSA = (6 << 8);  ///< A/D Conversion Start Trigger Select
    }

    /// ADEXICR Register bits
    namespace adexicr_bits {
        constexpr uint32_t TSSAD = (1U << 0);  ///< Temperature Sensor Output A/D-Converted Value Addition/Average Mode Select
        constexpr uint32_t OCSAD = (1U << 1);  ///< Internal Reference Voltage A/D-Converted Value Addition/Average Mode Select
        constexpr uint32_t TSSA = (1U << 8);  ///< Temperature Sensor Output A/D Conversion Select
        constexpr uint32_t OCSA = (1U << 9);  ///< Internal Reference Voltage A/D Conversion Select
        constexpr uint32_t TSSB = (1U << 10);  ///< Temperature Sensor Output A/D Conversion Select for Group B
        constexpr uint32_t OCSB = (1U << 11);  ///< Internal Reference Voltage A/D Conversion Select for Group B
    }

    /// ADANSB0 Register bits
    namespace adansb0_bits {
        constexpr uint32_t ANSB0 = (1U << 0);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB1 = (1U << 1);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB2 = (1U << 2);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB3 = (1U << 3);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB4 = (1U << 4);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB5 = (1U << 5);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB6 = (1U << 6);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB7 = (1U << 7);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB8 = (1U << 8);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB9 = (1U << 9);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB12 = (1U << 12);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB13 = (1U << 13);  ///< A/D Conversion Channels Select
    }

    /// ADANSB1 Register bits
    namespace adansb1_bits {
        constexpr uint32_t ANSB16 = (1U << 0);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB17 = (1U << 1);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB18 = (1U << 2);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB19 = (1U << 3);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB20 = (1U << 4);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB21 = (1U << 5);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB22 = (1U << 6);  ///< A/D Conversion Channels Select
    }

    /// ADDBLDR Register bits
    namespace addbldr_bits {
        constexpr uint32_t ADDBLDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADTSDR Register bits
    namespace adtsdr_bits {
        constexpr uint32_t ADTSDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADOCDR Register bits
    namespace adocdr_bits {
        constexpr uint32_t ADOCDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADRD Register bits
    namespace adrd_bits {
        constexpr uint32_t AD = (12 << 0);  ///< Converted Value 11 to 0
        constexpr uint32_t DIAGST = (2 << 14);  ///< Self-Diagnosis Status
    }

    /// ADDR%s Register bits
    namespace addr%s_bits {
        constexpr uint32_t ADDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADDISCR Register bits
    namespace addiscr_bits {
        constexpr uint32_t ADNDIS = (4 << 0);  ///< Disconnection Detection Assist Setting
        constexpr uint32_t PCHG = (1U << 4);  ///< Precharge/discharge select
    }

    /// ADGSPCR Register bits
    namespace adgspcr_bits {
        constexpr uint32_t PGS = (1U << 0);  ///< Group Priority Operation Setting
        constexpr uint32_t GBRSCN = (1U << 1);  ///< Lower-Priority Group Restart Setting
        constexpr uint32_t LGRRS = (1U << 14);  ///< Enabled only when PGS = 1 and GBRSCN = 1.
        constexpr uint32_t GBRP = (1U << 15);  ///< Single Scan Continuous Start
    }

    /// ADDBLDRA Register bits
    namespace addbldra_bits {
        constexpr uint32_t ADDBLDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADDBLDRB Register bits
    namespace addbldrb_bits {
        constexpr uint32_t ADDBLDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADWINMON Register bits
    namespace adwinmon_bits {
        constexpr uint32_t MONCOMB = (1U << 0);  ///< Combination Result Monitor
        constexpr uint32_t MONCMPA = (1U << 4);  ///< Comparison Result Monitor A
        constexpr uint32_t MONCMPB = (1U << 5);  ///< Comparison Result Monitor B
    }

    /// ADCMPCR Register bits
    namespace adcmpcr_bits {
        constexpr uint32_t CMPAB = (2 << 0);  ///< Window A/B Composite Conditions Setting
        constexpr uint32_t CMPBE = (1U << 9);  ///< Compare Window B Operation Enable
        constexpr uint32_t CMPAE = (1U << 11);  ///< Compare Window A Operation Enable
        constexpr uint32_t CMPBIE = (1U << 13);  ///< Compare B Interrupt Enable
        constexpr uint32_t WCMPE = (1U << 14);  ///< Window Function Setting
        constexpr uint32_t CMPAIE = (1U << 15);  ///< Compare A Interrupt Enable
    }

    /// ADCMPANSER Register bits
    namespace adcmpanser_bits {
        constexpr uint32_t CMPTSA = (1U << 0);  ///< Temperature Sensor Output Compare Select
        constexpr uint32_t CMPOCA = (1U << 1);  ///< Internal Reference Voltage Compare Select
    }

    /// ADCMPLER Register bits
    namespace adcmpler_bits {
        constexpr uint32_t CMPLTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Comparison Condition Select
        constexpr uint32_t CMPLOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage Comparison Condition Select
    }

    /// ADCMPANSR0 Register bits
    namespace adcmpansr0_bits {
        constexpr uint32_t CMPCHA0 = (1U << 0);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA1 = (1U << 1);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA2 = (1U << 2);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA3 = (1U << 3);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA4 = (1U << 4);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA5 = (1U << 5);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA6 = (1U << 6);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA7 = (1U << 7);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA8 = (1U << 8);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA9 = (1U << 9);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA12 = (1U << 12);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA13 = (1U << 13);  ///< Compare Window A Channel Select
    }

    /// ADCMPANSR1 Register bits
    namespace adcmpansr1_bits {
        constexpr uint32_t CMPCHA16 = (1U << 0);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA17 = (1U << 1);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA18 = (1U << 2);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA19 = (1U << 3);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA20 = (1U << 4);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA21 = (1U << 5);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA22 = (1U << 6);  ///< Compare Window A Channel Select
    }

    /// ADCMPLR0 Register bits
    namespace adcmplr0_bits {
        constexpr uint32_t CMPLCHA0 = (1U << 0);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA1 = (1U << 1);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA2 = (1U << 2);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA3 = (1U << 3);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA4 = (1U << 4);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA5 = (1U << 5);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA6 = (1U << 6);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA7 = (1U << 7);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA8 = (1U << 8);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA9 = (1U << 9);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA12 = (1U << 12);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA13 = (1U << 13);  ///< Compare Window A Comparison Condition Select
    }

    /// ADCMPLR1 Register bits
    namespace adcmplr1_bits {
        constexpr uint32_t CMPLCHA16 = (1U << 0);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA17 = (1U << 1);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA18 = (1U << 2);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA19 = (1U << 3);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA20 = (1U << 4);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA21 = (1U << 5);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA22 = (1U << 6);  ///< Compare Window A Comparison Condition Select
    }

    /// ADCMPSR0 Register bits
    namespace adcmpsr0_bits {
        constexpr uint32_t CMPSTCHA0 = (1U << 0);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA1 = (1U << 1);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA2 = (1U << 2);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA3 = (1U << 3);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA4 = (1U << 4);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA5 = (1U << 5);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA6 = (1U << 6);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA7 = (1U << 7);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA8 = (1U << 8);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA9 = (1U << 9);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA12 = (1U << 12);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA13 = (1U << 13);  ///< Compare Window A Flag
    }

    /// ADCMPSR1 Register bits
    namespace adcmpsr1_bits {
        constexpr uint32_t CMPSTCHA16 = (1U << 0);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA17 = (1U << 1);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA18 = (1U << 2);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA19 = (1U << 3);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA20 = (1U << 4);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA21 = (1U << 5);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA22 = (1U << 6);  ///< Compare Window A Flag
    }

    /// ADCMPSER Register bits
    namespace adcmpser_bits {
        constexpr uint32_t CMPSTTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Compare Flag
        constexpr uint32_t CMPSTOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage Compare Flag
    }

    /// ADCMPBNSR Register bits
    namespace adcmpbnsr_bits {
        constexpr uint32_t CMPCHB = (6 << 0);  ///< Compare Window B Channel Select
        constexpr uint32_t CMPLB = (1U << 7);  ///< Compare Window B Comparison Condition Setting
    }

    /// ADCMPBSR Register bits
    namespace adcmpbsr_bits {
        constexpr uint32_t CMPSTB = (1U << 0);  ///< Compare Window B Flag
    }

    /// ADBUF%s Register bits
    namespace adbuf%s_bits {
        constexpr uint32_t ADBUF = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADBUFEN Register bits
    namespace adbufen_bits {
        constexpr uint32_t BUFEN = (1U << 0);  ///< Data Buffer Enable
    }

    /// ADBUFPTR Register bits
    namespace adbufptr_bits {
        constexpr uint32_t BUFPTR = (4 << 0);  ///< Data Buffer Pointer
        constexpr uint32_t PTROVF = (1U << 4);  ///< Pointer Overflow Flag
    }

    /// ADSSTRL Register bits
    namespace adsstrl_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting
    }

    /// ADSSTRT Register bits
    namespace adsstrt_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting
    }

    /// ADSSTRO Register bits
    namespace adsstro_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting
    }

    /// ADSSTR%s Register bits
    namespace adsstr%s_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC12_BASE = 0x40171000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DADR%s;  ///< Offset: 0x00 - D/A Data Register %s
        volatile uint32_t DACR;  ///< Offset: 0x04 - D/A Control Register
        volatile uint32_t DADPR;  ///< Offset: 0x05 - DADRn Format Select Register
        volatile uint32_t DAADSCR;  ///< Offset: 0x06 - D/A A/D Synchronous Start Control Register
        volatile uint32_t DAAMPCR;  ///< Offset: 0x08 - D/A Output Amplifier Control Register
        volatile uint32_t DAASWCR;  ///< Offset: 0x1C - D/A Amplifier Stabilization Wait Control Register
        volatile uint32_t DAADUSR;  ///< Offset: 0x10C0 - D/A A/D Synchronous Unit Select Register
    };

    /// Peripheral instances
    inline Registers* DAC12 = reinterpret_cast<Registers*>(DAC12_BASE);

    // Bit definitions
    /// DACR Register bits
    namespace dacr_bits {
        constexpr uint32_t DAE = (1U << 5);  ///< D/A Enable
        constexpr uint32_t DAOE0 = (1U << 6);  ///< D/A Output Enable 0
        constexpr uint32_t DAOE1 = (1U << 7);  ///< D/A Output Enable 1
    }

    /// DADPR Register bits
    namespace dadpr_bits {
        constexpr uint32_t DPSEL = (1U << 7);  ///< DADRn Format Select
    }

    /// DAADSCR Register bits
    namespace daadscr_bits {
        constexpr uint32_t DAADST = (1U << 7);  ///< D/A A/D Synchronous Conversion
    }

    /// DAAMPCR Register bits
    namespace daampcr_bits {
        constexpr uint32_t DAAMP0 = (1U << 6);  ///< Amplifier Control 0
        constexpr uint32_t DAAMP1 = (1U << 7);  ///< Amplifier Control 1
    }

    /// DAASWCR Register bits
    namespace daaswcr_bits {
        constexpr uint32_t DAASW0 = (1U << 6);  ///< D/A Amplifier Stabilization Wait 0
        constexpr uint32_t DAASW1 = (1U << 7);  ///< D/A Amplifier Stabilization Wait 1
    }

    /// DAADUSR Register bits
    namespace daadusr_bits {
        constexpr uint32_t AMADSEL1 = (1U << 1);  ///< A/D Unit 1 Select
    }

}

// ============================================================================
// TSD Peripheral
// ============================================================================

namespace tsd {
    /// Base addresses
    constexpr uint32_t TSD_BASE = 0x407FB000;

    /// TSD Register structure
    struct Registers {
        volatile uint32_t TSCDR;  ///< Offset: 0x17C - Temperature Sensor Calibration Data Register
    };

    /// Peripheral instances
    inline Registers* TSD = reinterpret_cast<Registers*>(TSD_BASE);

    // Bit definitions
    /// TSCDR Register bits
    namespace tscdr_bits {
        constexpr uint32_t TSCDR = (16 << 0);  ///< Temperature Sensor Calibration Data
    }

}

// ============================================================================
// FLAD Peripheral
// ============================================================================

namespace flad {
    /// Base addresses
    constexpr uint32_t FLAD_BASE = 0x407FC000;

    /// FLAD Register structure
    struct Registers {
        volatile uint32_t FCKMHZ;  ///< Offset: 0x40 - Data Flash Access Frequency Register
    };

    /// Peripheral instances
    inline Registers* FLAD = reinterpret_cast<Registers*>(FLAD_BASE);

    // Bit definitions
    /// FCKMHZ Register bits
    namespace fckmhz_bits {
        constexpr uint32_t FCKMHZ = (8 << 0);  ///< Data Flash Access Frequency Register
    }

}

// ============================================================================
// FACI Peripheral
// ============================================================================

namespace faci {
    /// Base addresses
    constexpr uint32_t FACI_BASE = 0x407FE000;

    /// FACI Register structure
    struct Registers {
        volatile uint32_t FASTAT;  ///< Offset: 0x10 - Flash Access Status Register
        volatile uint32_t FAEINT;  ///< Offset: 0x14 - Flash Access Error Interrupt Enable Register
        volatile uint32_t FRDYIE;  ///< Offset: 0x18 - Flash Ready Interrupt Enable Register
        volatile uint32_t FSADDR;  ///< Offset: 0x30 - FACI Command Start Address Register
        volatile uint32_t FEADDR;  ///< Offset: 0x34 - FACI Command End Address Register
        volatile uint32_t FMEPROT;  ///< Offset: 0x44 - Flash P/E Mode Entry Protection Register
        volatile uint32_t FBPROT0;  ///< Offset: 0x78 - Flash Block Protection Register
        volatile uint32_t FBPROT1;  ///< Offset: 0x7C - Flash Block Protection for Secure Register
        volatile uint32_t FSTATR;  ///< Offset: 0x80 - Flash Status Register
        volatile uint32_t FENTRYR;  ///< Offset: 0x84 - Flash P/E Mode Entry Register
        volatile uint32_t FSUINITR;  ///< Offset: 0x8C - Flash Sequencer Setup Initialization Register
        volatile uint32_t FCMDR;  ///< Offset: 0xA0 - FACI Command Register
        volatile uint32_t FBCCNT;  ///< Offset: 0xD0 - Blank Check Control Register
        volatile uint32_t FBCSTAT;  ///< Offset: 0xD4 - Blank Check Status Register
        volatile uint32_t FPSADDR;  ///< Offset: 0xD8 - Data Flash Programming Start Address Register
        volatile uint32_t FSUASMON;  ///< Offset: 0xDC - Flash Startup Area Select Monitor Register
        volatile uint32_t FCPSR;  ///< Offset: 0xE0 - Flash Sequencer Processing Switching Register
        volatile uint32_t FPCKAR;  ///< Offset: 0xE4 - Flash Sequencer Processing Clock Notification Register
        volatile uint32_t FSUACR;  ///< Offset: 0xE8 - Flash Startup Area Control Register
    };

    /// Peripheral instances
    inline Registers* FACI = reinterpret_cast<Registers*>(FACI_BASE);

    // Bit definitions
    /// FASTAT Register bits
    namespace fastat_bits {
        constexpr uint32_t DFAE = (1U << 3);  ///< Data Flash Memory Access Violation Flag
        constexpr uint32_t CMDLK = (1U << 4);  ///< Command Lock Flag
        constexpr uint32_t CFAE = (1U << 7);  ///< Code Flash Memory Access Violation Flag
    }

    /// FAEINT Register bits
    namespace faeint_bits {
        constexpr uint32_t DFAEIE = (1U << 3);  ///< Data Flash Memory Access Violation Interrupt Enable
        constexpr uint32_t CMDLKIE = (1U << 4);  ///< Command Lock Interrupt Enable
        constexpr uint32_t CFAEIE = (1U << 7);  ///< Code Flash Memory Access Violation Interrupt Enable
    }

    /// FRDYIE Register bits
    namespace frdyie_bits {
        constexpr uint32_t FRDYIE = (1U << 0);  ///< Flash Ready Interrupt Enable
    }

    /// FSADDR Register bits
    namespace fsaddr_bits {
        constexpr uint32_t FSADDR = (32 << 0);  ///< Start Address for FACI Command Processing
    }

    /// FEADDR Register bits
    namespace feaddr_bits {
        constexpr uint32_t FEADDR = (32 << 0);  ///< End Address for FACI Command Processing
    }

    /// FMEPROT Register bits
    namespace fmeprot_bits {
        constexpr uint32_t CEPROT = (1U << 0);  ///< Code Flash P/E Mode Entry Protection
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// FBPROT0 Register bits
    namespace fbprot0_bits {
        constexpr uint32_t BPCN0 = (1U << 0);  ///< Block Protection for Non-secure Cancel
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// FBPROT1 Register bits
    namespace fbprot1_bits {
        constexpr uint32_t BPCN1 = (1U << 0);  ///< Block Protection for Secure Cancel
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// FSTATR Register bits
    namespace fstatr_bits {
        constexpr uint32_t FLWEERR = (1U << 6);  ///< Flash Write/Erase Protect Error Flag
        constexpr uint32_t PRGSPD = (1U << 8);  ///< Programming Suspend Status Flag
        constexpr uint32_t ERSSPD = (1U << 9);  ///< Erasure Suspend Status Flag
        constexpr uint32_t DBFULL = (1U << 10);  ///< Data Buffer Full Flag
        constexpr uint32_t SUSRDY = (1U << 11);  ///< Suspend Ready Flag
        constexpr uint32_t PRGERR = (1U << 12);  ///< Programming Error Flag
        constexpr uint32_t ERSERR = (1U << 13);  ///< Erasure Error Flag
        constexpr uint32_t ILGLERR = (1U << 14);  ///< Illegal Command Error Flag
        constexpr uint32_t FRDY = (1U << 15);  ///< Flash Ready Flag
        constexpr uint32_t OTERR = (1U << 20);  ///< Other Error
        constexpr uint32_t SECERR = (1U << 21);  ///< Security Error
        constexpr uint32_t FESETERR = (1U << 22);  ///< FENTRY Setting Error
        constexpr uint32_t ILGCOMERR = (1U << 23);  ///< Illegal Command Error
    }

    /// FENTRYR Register bits
    namespace fentryr_bits {
        constexpr uint32_t FENTRYC = (1U << 0);  ///< Code Flash P/E Mode Entry
        constexpr uint32_t FENTRYD = (1U << 7);  ///< Data Flash P/E Mode Entry
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// FSUINITR Register bits
    namespace fsuinitr_bits {
        constexpr uint32_t SUINIT = (1U << 0);  ///< Set-Up Initialization
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// FCMDR Register bits
    namespace fcmdr_bits {
        constexpr uint32_t PCMDR = (8 << 0);  ///< Pre-command Flag
        constexpr uint32_t CMDR = (8 << 8);  ///< Command Flag
    }

    /// FBCCNT Register bits
    namespace fbccnt_bits {
        constexpr uint32_t BCDIR = (1U << 0);  ///< Blank Check Direction
    }

    /// FBCSTAT Register bits
    namespace fbcstat_bits {
        constexpr uint32_t BCST = (1U << 0);  ///< Blank Check Status Flag
    }

    /// FPSADDR Register bits
    namespace fpsaddr_bits {
        constexpr uint32_t PSADR = (17 << 0);  ///< Programmed Area Start Address
    }

    /// FSUASMON Register bits
    namespace fsuasmon_bits {
        constexpr uint32_t FSPR = (1U << 15);  ///< Protection Programming Flag to set Boot Flag and Startup Area Control
        constexpr uint32_t BTFLG = (1U << 31);  ///< Flag of Startup Area Select for Boot Swap
    }

    /// FCPSR Register bits
    namespace fcpsr_bits {
        constexpr uint32_t ESUSPMD = (1U << 0);  ///< Erasure Suspend Mode
    }

    /// FPCKAR Register bits
    namespace fpckar_bits {
        constexpr uint32_t PCKA = (8 << 0);  ///< Flash Sequencer Operating Clock Notification
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// FSUACR Register bits
    namespace fsuacr_bits {
        constexpr uint32_t SAS = (2 << 0);  ///< Startup Area Select
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

}


} // namespace alloy::generated::r7fa4m3af

#endif // ALLOY_GENERATED_R7FA4M3AF_PERIPHERALS_HPP