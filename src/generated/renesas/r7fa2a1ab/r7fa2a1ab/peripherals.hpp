/// Auto-generated code for R7FA2A1AB
/// Generated by Alloy Code Generator
/// Source: renesas_r7fa2a1ab.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:45:07
#ifndef ALLOY_GENERATED_R7FA2A1AB_PERIPHERALS_HPP
#define ALLOY_GENERATED_R7FA2A1AB_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::r7fa2a1ab {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_acmphs0 = true;
    constexpr uint32_t num_acmphs0_instances = 1;
    constexpr bool has_acmplp = true;
    constexpr uint32_t num_acmplp_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_ctsu = true;
    constexpr uint32_t num_ctsu_instances = 1;
    constexpr bool has_opamp = true;
    constexpr uint32_t num_opamp_instances = 1;
    constexpr bool has_tsn = true;
    constexpr uint32_t num_tsn_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 2;
    constexpr bool has_elc = true;
    constexpr uint32_t num_elc_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_kint = true;
    constexpr uint32_t num_kint_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_cac = true;
    constexpr uint32_t num_cac_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_doc = true;
    constexpr uint32_t num_doc_instances = 1;
    constexpr bool has_sci0 = true;
    constexpr uint32_t num_sci0_instances = 1;
    constexpr bool has_sci1 = true;
    constexpr uint32_t num_sci1_instances = 1;
    constexpr bool has_sci9 = true;
    constexpr uint32_t num_sci9_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 1;
    constexpr bool has_iic0 = true;
    constexpr uint32_t num_iic0_instances = 1;
    constexpr bool has_iic1 = true;
    constexpr uint32_t num_iic1_instances = 1;
    constexpr bool has_mmf = true;
    constexpr uint32_t num_mmf_instances = 1;
    constexpr bool has_mmpu = true;
    constexpr uint32_t num_mmpu_instances = 1;
    constexpr bool has_smpu = true;
    constexpr uint32_t num_smpu_instances = 1;
    constexpr bool has_spmon = true;
    constexpr uint32_t num_spmon_instances = 1;
    constexpr bool has_sram = true;
    constexpr uint32_t num_sram_instances = 1;
    constexpr bool has_bus = true;
    constexpr uint32_t num_bus_instances = 1;
    constexpr bool has_dbg = true;
    constexpr uint32_t num_dbg_instances = 1;
    constexpr bool has_dtc = true;
    constexpr uint32_t num_dtc_instances = 1;
    constexpr bool has_icu = true;
    constexpr uint32_t num_icu_instances = 1;
    constexpr bool has_system = true;
    constexpr uint32_t num_system_instances = 1;
    constexpr bool has_mstp = true;
    constexpr uint32_t num_mstp_instances = 1;
    constexpr bool has_agt0 = true;
    constexpr uint32_t num_agt0_instances = 1;
    constexpr bool has_agt1 = true;
    constexpr uint32_t num_agt1_instances = 1;
    constexpr bool has_gpt320 = true;
    constexpr uint32_t num_gpt320_instances = 1;
    constexpr bool has_gpt = true;
    constexpr uint32_t num_gpt_instances = 1;
    constexpr bool has_gpt161 = true;
    constexpr uint32_t num_gpt161_instances = 1;
    constexpr bool has_gpt162 = true;
    constexpr uint32_t num_gpt162_instances = 1;
    constexpr bool has_gpt163 = true;
    constexpr uint32_t num_gpt163_instances = 1;
    constexpr bool has_gpt164 = true;
    constexpr uint32_t num_gpt164_instances = 1;
    constexpr bool has_gpt165 = true;
    constexpr uint32_t num_gpt165_instances = 1;
    constexpr bool has_gpt166 = true;
    constexpr uint32_t num_gpt166_instances = 1;
    constexpr bool has_poeg = true;
    constexpr uint32_t num_poeg_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_fcache = true;
    constexpr uint32_t num_fcache_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 7;
    constexpr bool has_pfs = true;
    constexpr uint32_t num_pfs_instances = 1;
    constexpr bool has_pmisc = true;
    constexpr uint32_t num_pmisc_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct acmphs0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct acmplp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ctsu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct opamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsn_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct elc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct kint_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct doc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci9_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct iic0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct iic1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mmf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mmpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spmon_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sram_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bus_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dbg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct icu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct system_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mstp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct agt0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct agt1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt320_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt161_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt162_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt163_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt164_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt165_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt166_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct poeg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fcache_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 7;
    };
    template<>
    struct peripheral_count<struct pfs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmisc_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 7;
    constexpr uint32_t max_gpio_pins = 112;  // 16 pins per port

    // USART-specific traits
}

// ============================================================================
// ACMPHS0 Peripheral
// ============================================================================

namespace acmphs0 {
    /// Base addresses
    constexpr uint32_t ACMPHS0_BASE = 0x40085000;

    /// ACMPHS0 Register structure
    struct Registers {
        volatile uint32_t CMPCTL;  ///< Offset: 0x00 - Comparator Control Register
        volatile uint32_t CMPSEL0;  ///< Offset: 0x04 - Comparator Input Select Register
        volatile uint32_t CMPSEL1;  ///< Offset: 0x08 - Comparator Reference Voltage Select Register
        volatile uint32_t CMPMON;  ///< Offset: 0x0C - Comparator Output Monitor Register
        volatile uint32_t CPIOC;  ///< Offset: 0x10 - Comparator Output Control Register
    };

    /// Peripheral instances
    inline Registers* ACMPHS0 = reinterpret_cast<Registers*>(ACMPHS0_BASE);

    // Bit definitions
    /// CMPCTL Register bits
    namespace cmpctl_bits {
        constexpr uint32_t HCMPON = (1U << 7);  ///< Comparator operation control
        constexpr uint32_t CDFS = (2 << 5);  ///< Noise filter selection
        constexpr uint32_t CEG = (2 << 3);  ///< Selection of valid edge (Edge selector)
        constexpr uint32_t Reserved = (1U << 2);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t COE = (1U << 1);  ///< Comparator output enable
        constexpr uint32_t CINV = (1U << 0);  ///< Comparator output polarity selection
    }

    /// CMPSEL0 Register bits
    namespace cmpsel0_bits {
        constexpr uint32_t CMPSEL = (3 << 0);  ///< Comparator input selection
    }

    /// CMPSEL1 Register bits
    namespace cmpsel1_bits {
        constexpr uint32_t CRVS = (6 << 0);  ///< Reference voltage selection
    }

    /// CMPMON Register bits
    namespace cmpmon_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000.
        constexpr uint32_t CMPMON = (1U << 0);  ///< Comparator output monitor
    }

    /// CPIOC Register bits
    namespace cpioc_bits {
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Vref enable
        constexpr uint32_t Reserved = (6 << 1);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t CPOE = (1U << 0);  ///< Comparator output selection
    }

}

// ============================================================================
// ACMPLP Peripheral
// ============================================================================

namespace acmplp {
    /// Base addresses
    constexpr uint32_t ACMPLP_BASE = 0x40085E00;

    /// ACMPLP Register structure
    struct Registers {
        volatile uint32_t COMPMDR;  ///< Offset: 0x00 - ACMPLP Mode Setting Register
        volatile uint32_t COMPFIR;  ///< Offset: 0x01 - ACMPLP Filter Control Register
        volatile uint32_t COMPOCR;  ///< Offset: 0x02 - ACMPLP Output Control Register
        volatile uint32_t COMPSEL0;  ///< Offset: 0x04 - Comparator Input Select Register
        volatile uint32_t COMPSEL1;  ///< Offset: 0x05 - Comparator Reference voltage Select Register
    };

    /// Peripheral instances
    inline Registers* ACMPLP = reinterpret_cast<Registers*>(ACMPLP_BASE);

    // Bit definitions
    /// COMPMDR Register bits
    namespace compmdr_bits {
        constexpr uint32_t C1MON = (1U << 7);  ///< ACMPLP1 Monitor Flag
        constexpr uint32_t C1VRF = (1U << 6);  ///< ACMPLP1 Reference Voltage SelectionNote1: It's effective only at the time of standard mode.IVREF0 and IVREF1 are chosen at window mode condition in spite of setting of this bit.
        constexpr uint32_t C1WDE = (1U << 5);  ///< ACMPLP1 Window Function Mode Enable
        constexpr uint32_t C1ENB = (1U << 4);  ///< ACMPLP1 Operation Enable
        constexpr uint32_t C0MON = (1U << 3);  ///< ACMPLP0 Monitor Flag
        constexpr uint32_t C0VRF = (1U << 2);  ///< ACMPLP0 Reference Voltage SelectionNote1: It's effective only at the time of standard mode.IVREF0 and IVREF1 are chosen at window mode condition in spite of setting of this bit.
        constexpr uint32_t C0WDE = (1U << 1);  ///< ACMPLP0 Window Function Mode Enable
        constexpr uint32_t C0ENB = (1U << 0);  ///< ACMPLP0 Operation Enable
    }

    /// COMPFIR Register bits
    namespace compfir_bits {
        constexpr uint32_t C1EDG = (1U << 7);  ///< ACMPLP1 Filter Select
        constexpr uint32_t C1EPO = (1U << 6);  ///< ACMPLP1 Edge Polarity Switching
        constexpr uint32_t C1FCK = (2 << 4);  ///< ACMPLP1 Edge Detection Selection
        constexpr uint32_t C0EDG = (1U << 3);  ///< ACMPLP0 Filter Select
        constexpr uint32_t C0EPO = (1U << 2);  ///< ACMPLP0 Edge Polarity Switching
        constexpr uint32_t C0FCK = (2 << 0);  ///< ACMPLP0 Edge Detection Selection
    }

    /// COMPOCR Register bits
    namespace compocr_bits {
        constexpr uint32_t SPDMD = (1U << 7);  ///< ACMPLP0/ACMPLP1 Speed Selection
        constexpr uint32_t C1OP = (1U << 6);  ///< ACMPLP1 VCOUT Output Polarity Selection
        constexpr uint32_t C1OE = (1U << 5);  ///< ACMPLP1 VCOUT Pin Output Enable
        constexpr uint32_t Reserved = (1U << 0);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t C0OP = (1U << 2);  ///< ACMPLP0 VCOUT Output Polarity Selection
        constexpr uint32_t C0OE = (1U << 1);  ///< ACMPLP0 VCOUT Pin Output Enable
    }

    /// COMPSEL0 Register bits
    namespace compsel0_bits {
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t CMPSEL54 = (2 << 4);  ///< ACMPLP1 Input (IVCMP1) Selection
        constexpr uint32_t CMPSEL10 = (2 << 0);  ///< ACMPLP0 Input (IVCMP0) Selection
    }

    /// COMPSEL1 Register bits
    namespace compsel1_bits {
        constexpr uint32_t C1VRF2 = (1U << 7);  ///< ACMPLP1 Reference Voltage Selection
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t CRVS54 = (2 << 4);  ///< ACMPLP1 Reference Voltage(IVREF1) Selection
        constexpr uint32_t CRVS10 = (2 << 0);  ///< ACMPLP0 Reference Voltage (IVREF0) Selection
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC160_BASE = 0x4005C000;
    constexpr uint32_t SDADC24_BASE = 0x4009C000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADCSR;  ///< Offset: 0x00 - A/D Control Register
        volatile uint32_t ADANSA0;  ///< Offset: 0x04 - A/D Channel Select Register A0
        volatile uint32_t ADANSA1;  ///< Offset: 0x06 - A/D Channel Select Register A1
        volatile uint32_t ADADS0;  ///< Offset: 0x08 - A/D-Converted Value Average Channel Select Register 0
        volatile uint32_t ADADS1;  ///< Offset: 0x0A - A/D-Converted Value Average Channel Select Register 1
        volatile uint32_t ADADC;  ///< Offset: 0x0C - A/D-Converted Value Average Count Select Register
        volatile uint32_t ADCER;  ///< Offset: 0x0E - A/D Control Extended Register
        volatile uint32_t ADSTRGR;  ///< Offset: 0x10 - A/D Conversion Start Trigger Select Register
        volatile uint32_t ADEXICR;  ///< Offset: 0x12 - A/D Conversion Extended Input Control Register
        volatile uint32_t ADANSB0;  ///< Offset: 0x14 - A/D Channel Select Register B0
        volatile uint32_t ADANSB1;  ///< Offset: 0x16 - A/D Channel Select Register B1
        volatile uint32_t ADDBLDR;  ///< Offset: 0x18 - A/D Data Duplexing Register
        volatile uint32_t ADTSDR;  ///< Offset: 0x1A - A/D Temperature Sensor Data Register
        volatile uint32_t ADOCDR;  ///< Offset: 0x1C - A/D Internal Reference Voltage Data Register
        volatile uint32_t ADDR;  ///< Offset: 0x40 - A/D Data Register %s (renamed from ADDR)
        volatile uint32_t ADDISCR;  ///< Offset: 0x7A - A/D Disconnection Detection Control Register
        volatile uint32_t ADICR;  ///< Offset: 0x7D - A/D Interrupt Control Register
        volatile uint32_t ADGSPCR;  ///< Offset: 0x80 - A/D Group Scan Priority Control Register
        volatile uint32_t ADDBLDRA;  ///< Offset: 0x84 - A/D Data Duplexing Register A
        volatile uint32_t ADDBLDRB;  ///< Offset: 0x86 - A/D Data Duplexing Register B
        volatile uint32_t ADWINMON;  ///< Offset: 0x8C - A/D Compare Function Window A/B Status Monitor Register
        volatile uint32_t ADCMPCR;  ///< Offset: 0x90 - A/D Compare Function Control Register
        volatile uint32_t ADCMPANSER;  ///< Offset: 0x92 - A/D Compare Function Window A Extended Input Select Register
        volatile uint32_t ADCMPLER;  ///< Offset: 0x93 - A/D Compare Function Window A Extended Input Comparison...
        volatile uint32_t ADCMPANSR0;  ///< Offset: 0x94 - A/D Compare Function Window A Channel Select Register 0
        volatile uint32_t ADCMPANSR1;  ///< Offset: 0x96 - A/D Compare Function Window A Channel Select Register 1
        volatile uint32_t ADCMPLR0;  ///< Offset: 0x98 - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPLR1;  ///< Offset: 0x9A - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPDR0;  ///< Offset: 0x9C - A/D Compare Function Window A Lower-Side Level Setting Register
        volatile uint32_t ADCMPDR1;  ///< Offset: 0x9E - A/D Compare Function Window A Upper-Side Level Setting Register
        volatile uint32_t ADCMPSR0;  ///< Offset: 0xA0 - A/D Compare Function Window A Channel Status Register 0
        volatile uint32_t ADCMPSR1;  ///< Offset: 0xA2 - A/D Compare Function Window A Channel Status Register 1
        volatile uint32_t ADCMPSER;  ///< Offset: 0xA4 - A/D Compare Function Window A Extended Input Channel...
        volatile uint32_t ADCMPBNSR;  ///< Offset: 0xA6 - A/D Compare Function Window B Channel Selection Register
        volatile uint32_t ADWINLLB;  ///< Offset: 0xA8 - A/D Compare Function Window B Lower-Side Level Setting Register
        volatile uint32_t ADWINULB;  ///< Offset: 0xAA - A/D Compare Function Window B Upper-Side Level Setting Register
        volatile uint32_t ADCMPBSR;  ///< Offset: 0xAC - A/D Compare Function Window B Status Register
        volatile uint32_t ADSSTRL;  ///< Offset: 0xDD - A/D Sampling State Register L
        volatile uint32_t ADSSTRT;  ///< Offset: 0xDE - A/D Sampling State Register T
        volatile uint32_t ADSSTRO;  ///< Offset: 0xDF - A/D Sampling State Register O
        volatile uint32_t ADSSTR0;  ///< Offset: 0xE0 - A/D Sampling State Register %s (renamed from ADSSTR0)
        volatile uint32_t ADANIM;  ///< Offset: 0xF0 - A/D Channel Input Mode Select Register
        volatile uint32_t ADCALEXE;  ///< Offset: 0xF2 - A/D Calibration Execution Register
        volatile uint32_t VREFAMPCNT;  ///< Offset: 0xF4 - A/D Dedicated Reference Voltage Circuit Control Register
        volatile uint32_t ADRD;  ///< Offset: 0xF8 - A/D Self-Diagnosis Data Register
        volatile uint32_t ADRST;  ///< Offset: 0xFA - A/D Self-Diagnostic Status Register
    };

    /// Peripheral instances
    inline Registers* ADC160 = reinterpret_cast<Registers*>(ADC160_BASE);
    inline Registers* SDADC24 = reinterpret_cast<Registers*>(SDADC24_BASE);

    // Bit definitions
    /// ADCSR Register bits
    namespace adcsr_bits {
        constexpr uint32_t ADST = (1U << 15);  ///< A/D Conversion Start
        constexpr uint32_t ADCS = (2 << 13);  ///< Scan Mode Select
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t ADHSC = (1U << 10);  ///< A/D Conversion Operation Mode Select
        constexpr uint32_t TRGE = (1U << 9);  ///< Trigger Start Enable
        constexpr uint32_t EXTRG = (1U << 8);  ///< Trigger Select
        constexpr uint32_t DBLE = (1U << 7);  ///< Double Trigger Mode Select
        constexpr uint32_t GBADIE = (1U << 6);  ///< Group B Scan End Interrupt Enable
        constexpr uint32_t DBLANS = (5 << 0);  ///< Double Trigger Channel SelectThese bits select one analog input channel for double triggered operation. The setting is only effective while double trigger mode is selected.
    }

    /// ADANSA0 Register bits
    namespace adansa0_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ANSA08 = (1U << 8);  ///< AN008 Select
        constexpr uint32_t ANSA07 = (1U << 7);  ///< AN007 Select
        constexpr uint32_t ANSA06 = (1U << 6);  ///< AN006 Select
        constexpr uint32_t ANSA05 = (1U << 5);  ///< AN005 Select
        constexpr uint32_t ANSA04 = (1U << 4);  ///< AN004 Select
        constexpr uint32_t ANSA03 = (1U << 3);  ///< AN003 Select
        constexpr uint32_t ANSA02 = (1U << 2);  ///< AN002 Select
        constexpr uint32_t ANSA01 = (1U << 1);  ///< AN001 Select
        constexpr uint32_t ANSA00 = (1U << 0);  ///< AN000 Select
    }

    /// ADANSA1 Register bits
    namespace adansa1_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ANSA24 = (1U << 8);  ///< AN024 Select
        constexpr uint32_t ANSA23 = (1U << 7);  ///< AN023 Select
        constexpr uint32_t ANSA22 = (1U << 6);  ///< AN022 Select
        constexpr uint32_t ANSA21 = (1U << 5);  ///< AN021 Select
        constexpr uint32_t ANSA20 = (1U << 4);  ///< AN020 Select
        constexpr uint32_t ANSA19 = (1U << 3);  ///< AN019 Select
        constexpr uint32_t ANSA18 = (1U << 2);  ///< AN018 Select
        constexpr uint32_t ANSA17 = (1U << 1);  ///< AN017 Select
        constexpr uint32_t ANSA16 = (1U << 0);  ///< AN016 Select
    }

    /// ADADS0 Register bits
    namespace adads0_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ADS08 = (1U << 8);  ///< A/D-Converted Value Average Channel AN008 Select
        constexpr uint32_t ADS07 = (1U << 7);  ///< A/D-Converted Value Average Channel AN007 Select
        constexpr uint32_t ADS06 = (1U << 6);  ///< A/D-Converted Value Average Channel AN006 Select
        constexpr uint32_t ADS05 = (1U << 5);  ///< A/D-Converted Value Average Channel AN005 Select
        constexpr uint32_t ADS04 = (1U << 4);  ///< A/D-Converted Value Average Channel AN004 Select
        constexpr uint32_t ADS03 = (1U << 3);  ///< A/D-Converted Value Average Channel AN003 Select
        constexpr uint32_t ADS02 = (1U << 2);  ///< A/D-Converted Value Average Channel AN002 Select
        constexpr uint32_t ADS01 = (1U << 1);  ///< A/D-Converted Value Average Channel AN001 Select
        constexpr uint32_t ADS00 = (1U << 0);  ///< A/D-Converted Value Average Channel AN000 Select
    }

    /// ADADS1 Register bits
    namespace adads1_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ADS24 = (1U << 8);  ///< A/D-Converted Value Average Channel AN024 Select
        constexpr uint32_t ADS23 = (1U << 7);  ///< A/D-Converted Value Average Channel AN023 Select
        constexpr uint32_t ADS22 = (1U << 6);  ///< A/D-Converted Value Average Channel AN022 Select
        constexpr uint32_t ADS21 = (1U << 5);  ///< A/D-Converted Value Average Channel AN021 Select
        constexpr uint32_t ADS20 = (1U << 4);  ///< A/D-Converted Value Average Channel AN020 Select
        constexpr uint32_t ADS19 = (1U << 3);  ///< A/D-Converted Value Average Channel AN019 Select
        constexpr uint32_t ADS18 = (1U << 2);  ///< A/D-Converted Value Average Channel AN018 Select
        constexpr uint32_t ADS17 = (1U << 1);  ///< A/D-Converted Value Average Channel AN017 Select
        constexpr uint32_t ADS16 = (1U << 0);  ///< A/D-Converted Value Average Channel AN016 Select
    }

    /// ADADC Register bits
    namespace adadc_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t ADC = (3 << 0);  ///< Count Select
    }

    /// ADCER Register bits
    namespace adcer_bits {
        constexpr uint32_t Reserved = (5 << 0);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t ADINV = (1U << 14);  ///< Single-End Input A/D Converted Data Inversion Select
        constexpr uint32_t DIAGM = (1U << 11);  ///< Self-Diagnosis Enable
        constexpr uint32_t DIAGLD = (1U << 10);  ///< Self-Diagnosis Mode Select
        constexpr uint32_t DIAGVAL = (2 << 8);  ///< Self-Diagnosis Conversion Voltage Select
        constexpr uint32_t ACE = (1U << 5);  ///< A/D Data Register Automatic Clearing Enable
    }

    /// ADSTRGR Register bits
    namespace adstrgr_bits {
        constexpr uint32_t Reserved = (2 << 6);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t TRSA = (6 << 8);  ///< A/D Conversion Start Trigger SelectSelect the A/D conversion start trigger in single scan mode and continuous mode. In group scan mode, the A/D conversion start trigger for group A is selected.
        constexpr uint32_t TRSB = (6 << 0);  ///< A/D Conversion Start Trigger Select for Group BSelect the A/D conversion start trigger for group B in group scan mode.
    }

    /// ADEXICR Register bits
    namespace adexicr_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t OCSA = (1U << 9);  ///< Internal Reference Voltage A/D Conversion Select
        constexpr uint32_t TSSA = (1U << 8);  ///< Temperature Sensor Output A/D Conversion Select
        constexpr uint32_t OCSAD = (1U << 1);  ///< Internal Reference Voltage A/D converted Value Average Mode Select
        constexpr uint32_t TSSAD = (1U << 0);  ///< Temperature Sensor Output A/D converted Value Average Mode Select
    }

    /// ADANSB0 Register bits
    namespace adansb0_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ANSB08 = (1U << 8);  ///< AN008 Select
        constexpr uint32_t ANSB07 = (1U << 7);  ///< AN007 Select
        constexpr uint32_t ANSB06 = (1U << 6);  ///< AN006 Select
        constexpr uint32_t ANSB05 = (1U << 5);  ///< AN005 Select
        constexpr uint32_t ANSB04 = (1U << 4);  ///< AN004 Select
        constexpr uint32_t ANSB03 = (1U << 3);  ///< AN003 Select
        constexpr uint32_t ANSB02 = (1U << 2);  ///< AN002 Select
        constexpr uint32_t ANSB01 = (1U << 1);  ///< AN001 Select
        constexpr uint32_t ANSB00 = (1U << 0);  ///< AN000 Select
    }

    /// ADANSB1 Register bits
    namespace adansb1_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ANSB24 = (1U << 8);  ///< AN024 Select
        constexpr uint32_t ANSB23 = (1U << 7);  ///< AN023 Select
        constexpr uint32_t ANSB22 = (1U << 6);  ///< AN022 Select
        constexpr uint32_t ANSB21 = (1U << 5);  ///< AN021 Select
        constexpr uint32_t ANSB20 = (1U << 4);  ///< AN020 Select
        constexpr uint32_t ANSB19 = (1U << 3);  ///< AN019 Select
        constexpr uint32_t ANSB18 = (1U << 2);  ///< AN018 Select
        constexpr uint32_t ANSB17 = (1U << 1);  ///< AN017 Select
        constexpr uint32_t ANSB16 = (1U << 0);  ///< AN016 Select
    }

    /// ADDBLDR Register bits
    namespace addbldr_bits {
        constexpr uint32_t ADDBLDR = (16 << 0);  ///< This is a 16-bit read-only register for storing the result of A/D conversion in response to the second trigger in double trigger mode.
    }

    /// ADTSDR Register bits
    namespace adtsdr_bits {
        constexpr uint32_t ADTSDR = (16 << 0);  ///< This is a 16-bit read-only register for storing the A/D conversion result of temperature sensor output.
    }

    /// ADOCDR Register bits
    namespace adocdr_bits {
        constexpr uint32_t ADOCDR = (16 << 0);  ///< This is a 16-bit read-only register for storing the A/D result of internal reference voltage.
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (16 << 0);  ///< The ADDR register is a 16-bit read-only registers for storing the result of A/D conversion.
    }

    /// ADDISCR Register bits
    namespace addiscr_bits {
        constexpr uint32_t Reserved = (2 << 6);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t PCHG1 = (1U << 5);  ///< Precharge/discharge select for even analog input channels from AN000 to AN008 or analog input channels from AN016 to AN023
        constexpr uint32_t PCHG2 = (1U << 4);  ///< Precharge/discharge select for odd analog input channels from AN000 to AN007
        constexpr uint32_t ADNDIS = (4 << 0);  ///< Precharg/discharge period
    }

    /// ADICR Register bits
    namespace adicr_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t ADIC = (2 << 0);  ///< A/D Interrupt Control
    }

    /// ADGSPCR Register bits
    namespace adgspcr_bits {
        constexpr uint32_t GBRP = (1U << 15);  ///< Group B Single Scan Continuous Start(Enabled only when PGS = 1. Reserved when PGS = 0.)Note: When the GBRP bit has been set to 1, single scan is performed continuously for group B regardless of the setting of the GBRSCN bit.
        constexpr uint32_t Reserved = (13 << 2);  ///< These bits are read as 0000000000000. The write value should be 0000000000000.
        constexpr uint32_t GBRSCN = (1U << 1);  ///< Group B Restart Setting(Enabled only when PGS = 1. Reserved when PGS = 0.)
        constexpr uint32_t PGS = (1U << 0);  ///< Group A priority control setting bit.Note: When the PGS bit is to be set to 1, the ADCSR.ADCS[1:0] bits must be set to 01b (group scan mode). If the bits are set to any other values, proper operation is not guaranteed.
    }

    /// ADDBLDRA Register bits
    namespace addbldra_bits {
        constexpr uint32_t ADDBLDRA = (16 << 0);  ///< This register is a 16-bit read-only registers for storing the result of A/D conversion in response to the respective triggers during extended operation in double trigger mode.
    }

    /// ADDBLDRB Register bits
    namespace addbldrb_bits {
        constexpr uint32_t ADDBLDRB = (16 << 0);  ///< This register is a 16-bit read-only registers for storing the result of A/D conversion in response to the respective triggers during extended operation in double trigger mode.
    }

    /// ADWINMON Register bits
    namespace adwinmon_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000.
        constexpr uint32_t MONCMPB = (1U << 5);  ///< Comparison Result Monitor B
        constexpr uint32_t MONCMPA = (1U << 4);  ///< Comparison Result Monitor A
        constexpr uint32_t MONCOMB = (1U << 0);  ///< Combination result monitorThis bit indicates the combination result. This bit is valid when both window A operation and window B operation are enabled.
    }

    /// ADCMPCR Register bits
    namespace adcmpcr_bits {
        constexpr uint32_t CMPAIE = (1U << 15);  ///< Compare A Interrupt Enable
        constexpr uint32_t WCMPE = (1U << 14);  ///< Window Function Setting
        constexpr uint32_t CMPBIE = (1U << 13);  ///< Compare B Interrupt Enable
        constexpr uint32_t Reserved = (7 << 2);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPAE = (1U << 11);  ///< Compare Window A Operation Enable
        constexpr uint32_t CMPBE = (1U << 9);  ///< Compare Window B Operation Enable
        constexpr uint32_t CMPAB = (2 << 0);  ///< Window A/B Composite Conditions SettingNOTE: These bits are valid when both window A and window B are enabled (CMPAE = 1 and CMPBE = 1).
    }

    /// ADCMPANSER Register bits
    namespace adcmpanser_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t CMPOCA = (1U << 1);  ///< Internal reference voltage Compare selection bit.
        constexpr uint32_t CMPTSA = (1U << 0);  ///< Temperature sensor output Compare selection bit.
    }

    /// ADCMPLER Register bits
    namespace adcmpler_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t CMPLOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage ComparisonCondition Select
        constexpr uint32_t CMPLTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Comparison Condition Select
    }

    /// ADCMPANSR0 Register bits
    namespace adcmpansr0_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPCHA08 = (1U << 8);  ///< AN008 Select
        constexpr uint32_t CMPCHA07 = (1U << 7);  ///< AN007 Select
        constexpr uint32_t CMPCHA06 = (1U << 6);  ///< AN006 Select
        constexpr uint32_t CMPCHA05 = (1U << 5);  ///< AN005 Select
        constexpr uint32_t CMPCHA04 = (1U << 4);  ///< AN004 Select
        constexpr uint32_t CMPCHA03 = (1U << 3);  ///< AN003 Select
        constexpr uint32_t CMPCHA02 = (1U << 2);  ///< AN002 Select
        constexpr uint32_t CMPCHA01 = (1U << 1);  ///< AN001 Select
        constexpr uint32_t CMPCHA00 = (1U << 0);  ///< AN000 Select
    }

    /// ADCMPANSR1 Register bits
    namespace adcmpansr1_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPCHA24 = (1U << 8);  ///< AN024 Select
        constexpr uint32_t CMPCHA23 = (1U << 7);  ///< AN023 Select
        constexpr uint32_t CMPCHA22 = (1U << 6);  ///< AN022 Select
        constexpr uint32_t CMPCHA21 = (1U << 5);  ///< AN021 Select
        constexpr uint32_t CMPCHA20 = (1U << 4);  ///< AN020 Select
        constexpr uint32_t CMPCHA19 = (1U << 3);  ///< AN019 Select
        constexpr uint32_t CMPCHA18 = (1U << 2);  ///< AN018 Select
        constexpr uint32_t CMPCHA17 = (1U << 1);  ///< AN017 Select
        constexpr uint32_t CMPCHA16 = (1U << 0);  ///< AN016 Select
    }

    /// ADCMPLR0 Register bits
    namespace adcmplr0_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPLCHA08 = (1U << 8);  ///< Comparison condition of AN008
        constexpr uint32_t CMPLCHA07 = (1U << 7);  ///< Comparison condition of AN007
        constexpr uint32_t CMPLCHA06 = (1U << 6);  ///< Comparison condition of AN006
        constexpr uint32_t CMPLCHA05 = (1U << 5);  ///< Comparison condition of AN005
        constexpr uint32_t CMPLCHA04 = (1U << 4);  ///< Comparison condition of AN004
        constexpr uint32_t CMPLCHA03 = (1U << 3);  ///< Comparison condition of AN003
        constexpr uint32_t CMPLCHA02 = (1U << 2);  ///< Comparison condition of AN002
        constexpr uint32_t CMPLCHA01 = (1U << 1);  ///< Comparison condition of AN001
        constexpr uint32_t CMPLCHA00 = (1U << 0);  ///< Comparison condition of AN000
    }

    /// ADCMPLR1 Register bits
    namespace adcmplr1_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPLCHA24 = (1U << 8);  ///< Comparison condition for AN024
        constexpr uint32_t CMPLCHA23 = (1U << 7);  ///< Comparison condition for AN023
        constexpr uint32_t CMPLCHA22 = (1U << 6);  ///< Comparison condition for AN022
        constexpr uint32_t CMPLCHA21 = (1U << 5);  ///< Comparison condition for AN021
        constexpr uint32_t CMPLCHA20 = (1U << 4);  ///< Comparison condition for AN020
        constexpr uint32_t CMPLCHA19 = (1U << 3);  ///< Comparison condition for AN019
        constexpr uint32_t CMPLCHA18 = (1U << 2);  ///< Comparison condition for AN018
        constexpr uint32_t CMPLCHA17 = (1U << 1);  ///< Comparison condition for AN017
        constexpr uint32_t CMPLCHA16 = (1U << 0);  ///< Comparison condition for AN016
    }

    /// ADCMPDR0 Register bits
    namespace adcmpdr0_bits {
        constexpr uint32_t ADCMPDR0 = (16 << 0);  ///< The ADCMPDR0 register sets the reference data when the compare window A function is used. ADCMPDR0 sets the lower-side level of window A.
    }

    /// ADCMPDR1 Register bits
    namespace adcmpdr1_bits {
        constexpr uint32_t ADCMPDR1 = (16 << 0);  ///< The ADCMPDR1 register sets the reference data when the compare window A function is used. ADCMPDR1 sets the upper-side level of window A.
    }

    /// ADCMPSR0 Register bits
    namespace adcmpsr0_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPSTCHA08 = (1U << 8);  ///< Compare window A flag for AN008
        constexpr uint32_t CMPSTCHA07 = (1U << 7);  ///< Compare window A flag for AN007
        constexpr uint32_t CMPSTCHA06 = (1U << 6);  ///< Compare window A flag for AN006
        constexpr uint32_t CMPSTCHA05 = (1U << 5);  ///< Compare window A flag for AN005
        constexpr uint32_t CMPSTCHA04 = (1U << 4);  ///< Compare window A flag for AN004
        constexpr uint32_t CMPSTCHA03 = (1U << 3);  ///< Compare window A flag for AN003
        constexpr uint32_t CMPSTCHA02 = (1U << 2);  ///< Compare window A flag for AN002
        constexpr uint32_t CMPSTCHA01 = (1U << 1);  ///< Compare window A flag for AN001
        constexpr uint32_t CMPSTCHA00 = (1U << 0);  ///< Compare window A flag for AN000
    }

    /// ADCMPSR1 Register bits
    namespace adcmpsr1_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPSTCHA24 = (1U << 8);  ///< Compare window A flag for AN024
        constexpr uint32_t CMPSTCHA23 = (1U << 7);  ///< Compare window A flag for AN023
        constexpr uint32_t CMPSTCHA22 = (1U << 6);  ///< Compare window A flag for AN022
        constexpr uint32_t CMPSTCHA21 = (1U << 5);  ///< Compare window A flag for AN021
        constexpr uint32_t CMPSTCHA20 = (1U << 4);  ///< Compare window A flag for AN020
        constexpr uint32_t CMPSTCHA19 = (1U << 3);  ///< Compare window A flag for AN019
        constexpr uint32_t CMPSTCHA18 = (1U << 2);  ///< Compare window A flag for AN018
        constexpr uint32_t CMPSTCHA17 = (1U << 1);  ///< Compare window A flag for AN017
        constexpr uint32_t CMPSTCHA16 = (1U << 0);  ///< Compare window A flag for AN016
    }

    /// ADCMPSER Register bits
    namespace adcmpser_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t CMPSTOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage Compare Flag When window A operation is enabled (ADCMPCR.CMPAE = 1b), this bit indicates the temperature sensor output comparison result. When window A operation is disabled (ADCMPCR.CMPAE = 0b), comparison conditions for CMPSTTSA are not met any time.
        constexpr uint32_t CMPSTTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Compare Flag When window A operation is enabled (ADCMPCR.CMPAE = 1b), this bit indicates the temperature sensor output comparison result. When window A operation is disabled (ADCMPCR.CMPAE = 0b), comparison conditions for CMPSTTSA are not met any time.
    }

    /// ADCMPBNSR Register bits
    namespace adcmpbnsr_bits {
        constexpr uint32_t CMPLB = (1U << 7);  ///< Compare window B Compare condition setting bit.
        constexpr uint32_t Reserved = (1U << 6);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CMPCHB = (6 << 0);  ///< Compare window B channel selection bit.The channel that compares it on the condition of compare window B is selected.
    }

    /// ADWINLLB Register bits
    namespace adwinllb_bits {
        constexpr uint32_t ADWINLLB = (16 << 0);  ///< This register is used to compare A window function is used to set the lower level of the window B.
    }

    /// ADWINULB Register bits
    namespace adwinulb_bits {
        constexpr uint32_t ADWINULB = (16 << 0);  ///< This register is used to compare A window function is used to set the higher level of the window B.
    }

    /// ADCMPBSR Register bits
    namespace adcmpbsr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPSTB = (1U << 0);  ///< Compare window B flagWhen window B operation is enabled (ADCMPCR.CMPBE = 1), this bit indicates the comparison result of channels AN000 to AN008, AN016 to AN023, reference voltage of SDADC24 (SBIAS/VREFI), temperature sensor output, and internal reference voltage to which window B comparison conditions are applied.
    }

    /// ADSSTRL Register bits
    namespace adsstrl_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting (AN016-AN023, SBIAS/VREFI)
    }

    /// ADSSTRT Register bits
    namespace adsstrt_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting (Temperature sensor output)
    }

    /// ADSSTRO Register bits
    namespace adsstro_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting (Internal reference voltage)
    }

    /// ADSSTR0 Register bits
    namespace adsstr0_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling time setting
    }

    /// ADANIM Register bits
    namespace adanim_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t ANIM = (4 << 0);  ///< Analog Channel Input Mode Select
    }

    /// ADCALEXE Register bits
    namespace adcalexe_bits {
        constexpr uint32_t CALEXE = (1U << 7);  ///< Calibration Start
        constexpr uint32_t CALMON = (1U << 6);  ///< Calibration Status Flag
        constexpr uint32_t Reserved = (6 << 0);  ///< These bits are read as 000000. The write value should be 000000.
    }

    /// VREFAMPCNT Register bits
    namespace vrefampcnt_bits {
        constexpr uint32_t ADSLP = (1U << 7);  ///< Sleep
        constexpr uint32_t Reserved = (2 << 5);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t BGREN = (1U << 4);  ///< Low-Potential Reference Voltage Select
        constexpr uint32_t VREFADCEN = (1U << 3);  ///< VREFADCG Enable
        constexpr uint32_t VREFADCG = (2 << 1);  ///< VREFADC Output Voltage Control
        constexpr uint32_t OLDETEN = (1U << 0);  ///< OLDET Enable
    }

    /// ADRD Register bits
    namespace adrd_bits {
        constexpr uint32_t ADRD = (16 << 0);  ///< The ADRD register is a 16-bit read-only register that holds the A/D conversion results based on the self-diagnosis of the ADC16.
    }

    /// ADRST Register bits
    namespace adrst_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t DIAGST = (2 << 0);  ///< Self-Diagnosis Status
    }

}

// ============================================================================
// CTSU Peripheral
// ============================================================================

namespace ctsu {
    /// Base addresses
    constexpr uint32_t CTSU_BASE = 0x40081000;

    /// CTSU Register structure
    struct Registers {
        volatile uint32_t CTSUCR0;  ///< Offset: 0x00 - CTSU Control Register 0
        volatile uint32_t CTSUCR1;  ///< Offset: 0x01 - CTSU Control Register 1
        volatile uint32_t CTSUSDPRS;  ///< Offset: 0x02 - CTSU Synchronous Noise Reduction Setting Register
        volatile uint32_t CTSUSST;  ///< Offset: 0x03 - CTSU Sensor Stabilization Wait Control Register
        volatile uint32_t CTSUMCH0;  ///< Offset: 0x04 - CTSU Measurement Channel Register 0
        volatile uint32_t CTSUMCH1;  ///< Offset: 0x05 - CTSU Measurement Channel Register 1
        volatile uint32_t CTSUCHAC0;  ///< Offset: 0x06 - CTSU Channel Enable Control Register 0
        volatile uint32_t CTSUCHAC1;  ///< Offset: 0x07 - CTSU Channel Enable Control Register 1
        volatile uint32_t CTSUCHAC2;  ///< Offset: 0x08 - CTSU Channel Enable Control Register 2
        volatile uint32_t CTSUCHAC3;  ///< Offset: 0x09 - CTSU Channel Enable Control Register 3
        volatile uint32_t CTSUCHTRC0;  ///< Offset: 0x0B - CTSU Channel Transmit/Receive Control Register 0
        volatile uint32_t CTSUCHTRC1;  ///< Offset: 0x0C - CTSU Channel Transmit/Receive Control Register 1
        volatile uint32_t CTSUCHTRC2;  ///< Offset: 0x0D - CTSU Channel Transmit/Receive Control Register 2
        volatile uint32_t CTSUCHTRC3;  ///< Offset: 0x0E - CTSU Channel Transmit/Receive Control Register 3
        volatile uint32_t CTSUDCLKC;  ///< Offset: 0x10 - CTSU High-Pass Noise Reduction Control Register
        volatile uint32_t CTSUST;  ///< Offset: 0x11 - CTSU Status Register
        volatile uint32_t CTSUSSC;  ///< Offset: 0x12 - CTSU High-Pass Noise Reduction Spectrum Diffusion...
        volatile uint32_t CTSUSO0;  ///< Offset: 0x14 - CTSU Sensor Offset Register 0
        volatile uint32_t CTSUSO1;  ///< Offset: 0x16 - CTSU Sensor Offset Register 1
        volatile uint32_t CTSUSC;  ///< Offset: 0x18 - CTSU Sensor Counter
        volatile uint32_t CTSURC;  ///< Offset: 0x1A - CTSU Reference Counter
        volatile uint32_t CTSUERRS;  ///< Offset: 0x1C - CTSU Error Status Register
    };

    /// Peripheral instances
    inline Registers* CTSU = reinterpret_cast<Registers*>(CTSU_BASE);

    // Bit definitions
    /// CTSUCR0 Register bits
    namespace ctsucr0_bits {
        constexpr uint32_t CTSUINIT = (1U << 4);  ///< CTSU Control Block Initialization
        constexpr uint32_t CTSUSNZ = (1U << 2);  ///< CTSU Wait State Power-Saving Enable
        constexpr uint32_t CTSUCAP = (1U << 1);  ///< CTSU Measurement Operation Start Trigger Select
        constexpr uint32_t CTSUSTRT = (1U << 0);  ///< CTSU Measurement Operation Start
    }

    /// CTSUCR1 Register bits
    namespace ctsucr1_bits {
        constexpr uint32_t CTSUMD = (2 << 6);  ///< CTSU Measurement Mode Select
        constexpr uint32_t CTSUCLK = (2 << 4);  ///< CTSU Operating Clock Select
        constexpr uint32_t CTSUATUNE1 = (1U << 3);  ///< CTSU Power Supply Capacity Adjustment
        constexpr uint32_t CTSUATUNE0 = (1U << 2);  ///< CTSU Power Supply Operating Mode Setting
        constexpr uint32_t CTSUCSW = (1U << 1);  ///< CTSU LPF Capacitance Charging Control
        constexpr uint32_t CTSUPON = (1U << 0);  ///< CTSU Power Supply Enable
    }

    /// CTSUSDPRS Register bits
    namespace ctsusdprs_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CTSUSOFF = (1U << 6);  ///< CTSU High-Pass Noise Reduction Function Off Setting
        constexpr uint32_t CTSUPRMODE = (2 << 4);  ///< CTSU Base Period and Pulse Count Setting
        constexpr uint32_t CTSUPRRATIO = (4 << 0);  ///< CTSU Measurement Time and Pulse Count AdjustmentRecommended setting: 3 (0011b)
    }

    /// CTSUSST Register bits
    namespace ctsusst_bits {
        constexpr uint32_t CTSUSST = (8 << 0);  ///< CTSU Sensor Stabilization Wait ControlNOTE: The value of these bits should be fixed to 00010000b.
    }

    /// CTSUMCH0 Register bits
    namespace ctsumch0_bits {
        constexpr uint32_t Reserved = (2 << 6);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t CTSUMCH0 = (6 << 0);  ///< CTSU Measurement Channel 0.Note1: Writing to these bits is enabled only in self-capacitance single scan mode (CTSUCR1.CTSUMD[1:0] bits = 00b).Note2: If the value of CTSUMCH0 was set to b'111111 in mode other than self-capacitor single scan mode, the measurement is stopped.
    }

    /// CTSUMCH1 Register bits
    namespace ctsumch1_bits {
        constexpr uint32_t Reserved = (2 << 6);  ///< These bits are read as 00.
        constexpr uint32_t CTSUMCH1 = (6 << 0);  ///< CTSU Measurement Channel 1Note1: If the value of CTSUMCH1 was set to b'111111, the measurement is stopped.
    }

    /// CTSUCHAC0 Register bits
    namespace ctsuchac0_bits {
        constexpr uint32_t CTSUCHAC0 = (8 << 0);  ///< CTSU Channel Enable Control 0.0: Not measurement target1: Measurement targetNote: CTSUCHAC0[0] corresponds to TS00 and CTSUCHAC0[7] corresponds to TS07.
    }

    /// CTSUCHAC1 Register bits
    namespace ctsuchac1_bits {
        constexpr uint32_t CTSUCHAC1 = (8 << 0);  ///< CTSU Channel Enable Control 1.0: Not measurement target1: Measurement targetNote: CTSUCHAC1[0] corresponds to TS08 and CTSUCHAC1[7] corresponds to TS15.
    }

    /// CTSUCHAC2 Register bits
    namespace ctsuchac2_bits {
        constexpr uint32_t CTSUCHAC2 = (8 << 0);  ///< CTSU Channel Enable Control 2.0: Not measurement target1: Measurement targetNote: CTSUCHAC2[0] corresponds to TS16 and CTSUCHAC2[7] corresponds to TS23.
    }

    /// CTSUCHAC3 Register bits
    namespace ctsuchac3_bits {
        constexpr uint32_t CTSUCHAC3 = (8 << 0);  ///< CTSU Channel Enable Control 3.0: Not measurement target1: Measurement targetNote: CTSUCHAC3[0] corresponds to TS24 and CTSUCHAC3[3] corresponds to TS27.
    }

    /// CTSUCHTRC0 Register bits
    namespace ctsuchtrc0_bits {
        constexpr uint32_t CTSUCHTRC0 = (8 << 0);  ///< CTSU Channel Transmit/Receive Control 0
    }

    /// CTSUCHTRC1 Register bits
    namespace ctsuchtrc1_bits {
        constexpr uint32_t CTSUCHTRC1 = (8 << 0);  ///< CTSU Channel Transmit/Receive Control 1
    }

    /// CTSUCHTRC2 Register bits
    namespace ctsuchtrc2_bits {
        constexpr uint32_t CTSUCHRC2 = (8 << 0);  ///< CTSU Channel Transmit/Receive Control 2
    }

    /// CTSUCHTRC3 Register bits
    namespace ctsuchtrc3_bits {
        constexpr uint32_t CTSUCHRC3 = (8 << 0);  ///< CTSU Channel Transmit/Receive Control 3
    }

    /// CTSUDCLKC Register bits
    namespace ctsudclkc_bits {
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t CTSUSSCNT = (2 << 4);  ///< CTSU Diffusion Clock Mode ControlNOTE: This bit should be set to 11b.
        constexpr uint32_t CTSUSSMOD = (2 << 0);  ///< CTSU Diffusion Clock Mode SelectNOTE: This bit should be set to 00b.
    }

    /// CTSUST Register bits
    namespace ctsust_bits {
        constexpr uint32_t CTSUPS = (1U << 7);  ///< CTSU Mutual Capacitance Status Flag
        constexpr uint32_t CTSUROVF = (1U << 6);  ///< CTSU Reference Counter Overflow Flag
        constexpr uint32_t CTSUSOVF = (1U << 5);  ///< CTSU Sensor Counter Overflow Flag
        constexpr uint32_t CTSUDTSR = (1U << 4);  ///< CTSU Data Transfer Status Flag
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CTSUSTC = (3 << 0);  ///< CTSU Measurement Status Counter
    }

    /// CTSUSSC Register bits
    namespace ctsussc_bits {
        constexpr uint32_t Reserved = (8 << 0);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t CTSUSSDIV = (4 << 8);  ///< CTSU Spectrum Diffusion Frequency Division Setting
    }

    /// CTSUSO0 Register bits
    namespace ctsuso0_bits {
        constexpr uint32_t CTSUSNUM = (6 << 10);  ///< CTSU Measurement Count Setting
        constexpr uint32_t CTSUSO = (10 << 0);  ///< CTSU Sensor Offset AdjustmentCurrent offset amount is CTSUSO ( 0 to 1023 )
    }

    /// CTSUSO1 Register bits
    namespace ctsuso1_bits {
        constexpr uint32_t Reserved = (1U << 15);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CTSUICOG = (2 << 13);  ///< CTSU ICO Gain Adjustment
        constexpr uint32_t CTSUSDPA = (5 << 8);  ///< CTSU Base Clock SettingOperating clock divided by ( CTSUSDPA + 1 ) x 2
        constexpr uint32_t CTSURICOA = (8 << 0);  ///< CTSU Reference ICO Current AdjustmentCurrent offset amount is CTSUSO ( 0 to 255 )
    }

    /// CTSUSC Register bits
    namespace ctsusc_bits {
        constexpr uint32_t CTSUSC = (16 << 0);  ///< CTSU Sensor CounterThese bits indicate the measurement result of the CTSU. These bits indicate FFFFh when an overflow occurs.
    }

    /// CTSURC Register bits
    namespace ctsurc_bits {
        constexpr uint32_t CTSURC = (16 << 0);  ///< CTSU Reference Counter
    }

    /// CTSUERRS Register bits
    namespace ctsuerrs_bits {
        constexpr uint32_t CTSUICOMP = (1U << 15);  ///< TSCAP Voltage Error Monitor
        constexpr uint32_t Reserved = (15 << 0);  ///< These bits are read as 000000000000000.
    }

}

// ============================================================================
// OPAMP Peripheral
// ============================================================================

namespace opamp {
    /// Base addresses
    constexpr uint32_t OPAMP_BASE = 0x40086800;

    /// OPAMP Register structure
    struct Registers {
        volatile uint32_t AMPMC;  ///< Offset: 0x00 - Operational amplifier mode control register
        volatile uint32_t AMPTRM;  ///< Offset: 0x01 - Operational amplifier trigger mode control register
        volatile uint32_t AMPTRS;  ///< Offset: 0x02 - Operational Amplifier Activation Trigger Select Register
        volatile uint32_t AMPC;  ///< Offset: 0x03 - Operational amplifier control register
        volatile uint32_t AMPMON;  ///< Offset: 0x04 - Operational amplifier monitor register
        volatile uint32_t AMP0OS;  ///< Offset: 0x06 - Operational Amplifier 0 Output Select Register
        volatile uint32_t AMP0MS;  ///< Offset: 0x07 - Operational Amplifier 0 Minus Input Select Register
        volatile uint32_t AMP0PS;  ///< Offset: 0x08 - Operational Amplifier 0 Plus Input Select Register
        volatile uint32_t AMP1MS;  ///< Offset: 0x0A - Operational Amplifier 1 Minus Input Select Register
        volatile uint32_t AMP1PS;  ///< Offset: 0x0B - Operational Amplifier 1 Plus Input Select Register
        volatile uint32_t AMP2MS;  ///< Offset: 0x0D - Operational Amplifier 2 Minus Input Select Register
        volatile uint32_t AMP2PS;  ///< Offset: 0x0E - Operational Amplifier 2 Plus Input Select Register
        volatile uint32_t AMPCPC;  ///< Offset: 0x12 - Operational Amplifier Switch Charge Pump Control Register
        volatile uint32_t AMPUOTE;  ///< Offset: 0x17 - Operational Amplifier User Offset Trimming Enable Register
        volatile uint32_t AMP0OTP;  ///< Offset: 0x18 - Operational Amplifier 0 Offset Trimming Pch Register
        volatile uint32_t AMP0OTN;  ///< Offset: 0x19 - Operational Amplifier 0 Offset Trimming Nch Register
        volatile uint32_t AMP1OTP;  ///< Offset: 0x1A - Operational Amplifier 1 Offset Trimming Pch Register
        volatile uint32_t AMP1OTN;  ///< Offset: 0x1B - Operational Amplifier 1 Offset Trimming Nch Register
        volatile uint32_t AMP2OTP;  ///< Offset: 0x1C - Operational Amplifier 2 Offset Trimming Pch Register
        volatile uint32_t AMP2OTN;  ///< Offset: 0x1D - Operational Amplifier 2 Offset Trimming Nch Register
    };

    /// Peripheral instances
    inline Registers* OPAMP = reinterpret_cast<Registers*>(OPAMP_BASE);

    // Bit definitions
    /// AMPMC Register bits
    namespace ampmc_bits {
        constexpr uint32_t AMPSP = (2 << 6);  ///< OPAMP Operation mode selection
        constexpr uint32_t Reserved = (6 << 0);  ///< These bits are read as 000000. The write value should be 000000.
    }

    /// AMPTRM Register bits
    namespace amptrm_bits {
        constexpr uint32_t Reserved = (2 << 6);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t AMPTRM21 = (1U << 5);  ///< OPAMP function activation/stop trigger control
        constexpr uint32_t AMPTRM20 = (1U << 4);  ///< OPAMP function activation/stop trigger control
        constexpr uint32_t AMPTRM11 = (1U << 3);  ///< OPAMP function activation/stop trigger control
        constexpr uint32_t AMPTRM10 = (1U << 2);  ///< OPAMP function activation/stop trigger control
        constexpr uint32_t AMPTRM01 = (1U << 1);  ///< OPAMP function activation/stop trigger control
        constexpr uint32_t AMPTRM00 = (1U << 0);  ///< OPAMP function activation/stop trigger control
    }

    /// AMPTRS Register bits
    namespace amptrs_bits {
        constexpr uint32_t AMPTRS = (2 << 0);  ///< Activation Trigger SelectionNote: Do not change the value of the AMPTRS register after setting the AMPTRM register.
    }

    /// AMPC Register bits
    namespace ampc_bits {
        constexpr uint32_t IREFE = (1U << 7);  ///< Reference Current Circuit Operation Control
        constexpr uint32_t Reserved = (4 << 3);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t AMPE2 = (1U << 2);  ///< Operation control of operational amplifier 2
        constexpr uint32_t AMPE1 = (1U << 1);  ///< Operation control of operational amplifier 1
        constexpr uint32_t AMPE0 = (1U << 0);  ///< Operation control of operational amplifier 0
    }

    /// AMPMON Register bits
    namespace ampmon_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000.
        constexpr uint32_t AMPMON2 = (1U << 2);  ///< OPAMP2 Status
        constexpr uint32_t AMPMON1 = (1U << 1);  ///< OPAMP1 Status
        constexpr uint32_t AMPMON0 = (1U << 0);  ///< OPAMP0 Status
    }

    /// AMP0OS Register bits
    namespace amp0os_bits {
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t AMPOS3 = (1U << 3);  ///< AMP2+ pin select
        constexpr uint32_t AMPOS2 = (1U << 2);  ///< AMP2- pin select
        constexpr uint32_t AMPOS1 = (1U << 1);  ///< AMP1+ pin select
        constexpr uint32_t AMPOS0 = (1U << 0);  ///< AMP1- pin select
    }

    /// AMP0MS Register bits
    namespace amp0ms_bits {
        constexpr uint32_t AMPMS7 = (1U << 7);  ///< OPAMP0 output select
        constexpr uint32_t Reserved = (2 << 5);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t AMPMS4 = (1U << 4);  ///< AMP2- pin select
        constexpr uint32_t AMPMS3 = (1U << 3);  ///< AMP1+ pin select
        constexpr uint32_t AMPMS2 = (1U << 2);  ///< AMP1- pin select
        constexpr uint32_t AMPMS1 = (1U << 1);  ///< AMP0+ pin select
        constexpr uint32_t AMPMS0 = (1U << 0);  ///< AMP0- pin select
    }

    /// AMP0PS Register bits
    namespace amp0ps_bits {
        constexpr uint32_t AMPMS7 = (1U << 7);  ///< DAC12 output select
        constexpr uint32_t Reserved = (3 << 4);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t AMPPS3 = (1U << 3);  ///< AMP2+ pin select
        constexpr uint32_t AMPPS2 = (1U << 2);  ///< AMP1+pin select
        constexpr uint32_t AMPPS1 = (1U << 1);  ///< AMP1- pin select
        constexpr uint32_t AMPPS0 = (1U << 0);  ///< AMP0+ pin select
    }

    /// AMP1MS Register bits
    namespace amp1ms_bits {
        constexpr uint32_t AMPMS7 = (1U << 7);  ///< OPAMP1 output select
        constexpr uint32_t Reserved = (6 << 1);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t AMPMS0 = (1U << 0);  ///< AMP1- pin select
    }

    /// AMP1PS Register bits
    namespace amp1ps_bits {
        constexpr uint32_t AMPMS7 = (1U << 7);  ///< OPAMP2 output select
        constexpr uint32_t Reserved = (3 << 4);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t AMPPS3 = (1U << 3);  ///< AMP2+ pin select
        constexpr uint32_t AMPPS2 = (1U << 2);  ///< AMP2- pin select
        constexpr uint32_t AMPPS1 = (1U << 1);  ///< AMP1+ pin select
        constexpr uint32_t AMPPS0 = (1U << 0);  ///< AMP1- pin select
    }

    /// AMP2MS Register bits
    namespace amp2ms_bits {
        constexpr uint32_t AMPMS7 = (1U << 7);  ///< OPAMP2 output select
        constexpr uint32_t Reserved = (6 << 1);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t AMPMS0 = (1U << 0);  ///< AMP2- pin select
    }

    /// AMP2PS Register bits
    namespace amp2ps_bits {
        constexpr uint32_t AMPPS7 = (1U << 7);  ///< DAC8 channel 1output select
        constexpr uint32_t Reserved = (5 << 2);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t AMPPS1 = (1U << 1);  ///< AMP2+ pin select
        constexpr uint32_t AMPPS0 = (1U << 0);  ///< AMP2- pin select
    }

    /// AMPCPC Register bits
    namespace ampcpc_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t PUMP2EN = (1U << 2);  ///< Charge Pump for AMP2 Enable
        constexpr uint32_t PUMP1EN = (1U << 1);  ///< Charge Pump for AMP1 Enable
        constexpr uint32_t PUMP0EN = (1U << 0);  ///< Charge Pump for AMP0 Enable
    }

    /// AMPUOTE Register bits
    namespace ampuote_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t AMP2TE = (1U << 2);  ///< AMP2OT write enable
        constexpr uint32_t AMP1TE = (1U << 1);  ///< AMP1OT write enable
        constexpr uint32_t AMP0TE = (1U << 0);  ///< AMP0OT write enable
    }

    /// AMP0OTP Register bits
    namespace amp0otp_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t TRMP = (5 << 0);  ///< AMP0 input offset trimming Pch side
    }

    /// AMP0OTN Register bits
    namespace amp0otn_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t TRMN = (5 << 0);  ///< AMP0 input offset trimming Nch side
    }

    /// AMP1OTP Register bits
    namespace amp1otp_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t TRMP = (5 << 0);  ///< AMP1 input offset trimming Pch side
    }

    /// AMP1OTN Register bits
    namespace amp1otn_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t TRMN = (5 << 0);  ///< AMP1 input offset trimming Nch side
    }

    /// AMP2OTP Register bits
    namespace amp2otp_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t TRMP = (5 << 0);  ///< AMP2 input offset trimming Pch side
    }

    /// AMP2OTN Register bits
    namespace amp2otn_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t TRMN = (5 << 0);  ///< AMP2 input offset trimming Nch side
    }

}

// ============================================================================
// TSN Peripheral
// ============================================================================

namespace tsn {
    /// Base addresses
    constexpr uint32_t TSN_BASE = 0x407EC000;

    /// TSN Register structure
    struct Registers {
        volatile uint32_t TSCDRH;  ///< Offset: 0x229 - Temperature Sensor Calibration Data Register H
        volatile uint32_t TSCDRL;  ///< Offset: 0x228 - Temperature Sensor Calibration Data Register L
    };

    /// Peripheral instances
    inline Registers* TSN = reinterpret_cast<Registers*>(TSN_BASE);

    // Bit definitions
    /// TSCDRH Register bits
    namespace tscdrh_bits {
        constexpr uint32_t TSCDRH = (8 << 0);  ///< The calibration data stores the higher 8 bits of the convertedvalue.
    }

    /// TSCDRL Register bits
    namespace tscdrl_bits {
        constexpr uint32_t TSCDRL = (8 << 0);  ///< The calibration data stores the lower 8 bits of the convertedvalue.
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC12_BASE = 0x4005E000;
    constexpr uint32_t DAC8_BASE = 0x4009E000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DADR0;  ///< Offset: 0x00 - D/A Data Register 0
        volatile uint32_t DACR;  ///< Offset: 0x04 - D/A Control Register
        volatile uint32_t DADPR;  ///< Offset: 0x05 - DADR0 Format Select Register
        volatile uint32_t DAADSCR;  ///< Offset: 0x06 - D/A-A/D Synchronous Start Control Register
        volatile uint32_t DAVREFCR;  ///< Offset: 0x07 - D/A VREF Control Register
        volatile uint32_t DAPC;  ///< Offset: 0x09 - D/A Switch Charge Pump Control Register
    };

    /// Peripheral instances
    inline Registers* DAC12 = reinterpret_cast<Registers*>(DAC12_BASE);
    inline Registers* DAC8 = reinterpret_cast<Registers*>(DAC8_BASE);

    // Bit definitions
    /// DADR0 Register bits
    namespace dadr0_bits {
        constexpr uint32_t DADR = (16 << 0);  ///< D/A Data RegisterNOTE: When DADPR.DPSEL = 0, the high-order 4 bits are fixed to 0: right justified format. When DADPR.DPSEL = 1, the low-order 4 bits are fixed to 0: left justified format.
    }

    /// DACR Register bits
    namespace dacr_bits {
        constexpr uint32_t Reserved = (5 << 0);  ///< These bits are read as 11111. The write value should be 11111.
        constexpr uint32_t DAOE0 = (1U << 6);  ///< D/A Output Enable 0
    }

    /// DADPR Register bits
    namespace dadpr_bits {
        constexpr uint32_t DPSEL = (1U << 7);  ///< DADRm Format Select
        constexpr uint32_t Reserved = (7 << 0);  ///< These bits are read as 0000000. The write value should be 0000000.
    }

    /// DAADSCR Register bits
    namespace daadscr_bits {
        constexpr uint32_t DAADST = (1U << 7);  ///< D/A-A/D Synchronous Conversion
        constexpr uint32_t Reserved = (7 << 0);  ///< These bits are read as 0000000. The write value should be 0000000.
    }

    /// DAVREFCR Register bits
    namespace davrefcr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t REF = (3 << 0);  ///< D/A Reference Voltage Select
    }

    /// DAPC Register bits
    namespace dapc_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PUMPEN = (1U << 0);  ///< Charge Pump Enable
    }

}

// ============================================================================
// ELC Peripheral
// ============================================================================

namespace elc {
    /// Base addresses
    constexpr uint32_t ELC_BASE = 0x40041000;

    /// ELC Register structure
    struct Registers {
        volatile uint32_t ELCR;  ///< Offset: 0x00 - Event Link Controller Register
        volatile uint32_t ELSEGR;  ///< Offset: 0x02 - Event Link Software Event Generation Register %s (renamed from ELSEGR)
        volatile uint32_t ELSR;  ///< Offset: 0x58 - Event Link Setting Register %s (renamed from ELSR)
        volatile uint32_t ELSR12;  ///< Offset: 0x40 - Event Link Setting Register 12
        volatile uint32_t ELSR22;  ///< Offset: 0x68 - Event Link Setting Register 22
    };

    /// Peripheral instances
    inline Registers* ELC = reinterpret_cast<Registers*>(ELC_BASE);

    // Bit definitions
    /// ELCR Register bits
    namespace elcr_bits {
        constexpr uint32_t ELCON = (1U << 7);  ///< All Event Link Enable
        constexpr uint32_t Reserved = (7 << 0);  ///< These bits are read as 0000000. The write value should be 0000000.
    }

    /// ELSEGR Register bits
    namespace elsegr_bits {
        constexpr uint32_t WI = (1U << 7);  ///< ELSEGR Register Write Disable
        constexpr uint32_t WE = (1U << 6);  ///< SEG Bit Write Enable
        constexpr uint32_t Reserved = (5 << 1);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SEG = (1U << 0);  ///< Software Event Generation
    }

    /// ELSR Register bits
    namespace elsr_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t ELS = (8 << 0);  ///< Event Link Select
    }

    /// ELSR12 Register bits
    namespace elsr12_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t ELS = (8 << 0);  ///< Event Link Select
    }

    /// ELSR22 Register bits
    namespace elsr22_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t ELS = (8 << 0);  ///< Event Link Select
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDT_BASE = 0x40044400;
    constexpr uint32_t WDT_BASE = 0x40044200;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t IWDTRR;  ///< Offset: 0x00 - IWDT Refresh Register
        volatile uint32_t IWDTSR;  ///< Offset: 0x04 - IWDT Status Register
    };

    /// Peripheral instances
    inline Registers* IWDT = reinterpret_cast<Registers*>(IWDT_BASE);
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// IWDTRR Register bits
    namespace iwdtrr_bits {
        constexpr uint32_t IWDTRR = (8 << 0);  ///< The counter is refreshed by writing 0x00 and then writing 0xFF to this register.
    }

    /// IWDTSR Register bits
    namespace iwdtsr_bits {
        constexpr uint32_t REFEF = (1U << 15);  ///< Refresh Error Flag
        constexpr uint32_t UNDFF = (1U << 14);  ///< Underflow Flag
        constexpr uint32_t CNTVAL = (14 << 0);  ///< Counter ValueValue counted by the counter
    }

}

// ============================================================================
// KINT Peripheral
// ============================================================================

namespace kint {
    /// Base addresses
    constexpr uint32_t KINT_BASE = 0x40080000;

    /// KINT Register structure
    struct Registers {
        volatile uint32_t KRCTL;  ///< Offset: 0x00 - KEY Return Control Register
        volatile uint32_t KRF;  ///< Offset: 0x04 - KEY Return Flag Register
        volatile uint32_t KRM;  ///< Offset: 0x08 - KEY Return Mode Register
    };

    /// Peripheral instances
    inline Registers* KINT = reinterpret_cast<Registers*>(KINT_BASE);

    // Bit definitions
    /// KRCTL Register bits
    namespace krctl_bits {
        constexpr uint32_t KRMD = (1U << 7);  ///< Usage of Key Interrupt Flags(KR0 to KR7)
        constexpr uint32_t Reserved = (6 << 1);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t KREG = (1U << 0);  ///< Detection Edge Selection (KRF0 to KRF7)
    }

    /// KRF Register bits
    namespace krf_bits {
        constexpr uint32_t KRF7 = (1U << 7);  ///< Key interrupt flag 7
        constexpr uint32_t KRF6 = (1U << 6);  ///< Key interrupt flag 6
        constexpr uint32_t KRF5 = (1U << 5);  ///< Key interrupt flag 5
        constexpr uint32_t KRF4 = (1U << 4);  ///< Key interrupt flag 4
        constexpr uint32_t KRF3 = (1U << 3);  ///< Key interrupt flag 3
        constexpr uint32_t KRF2 = (1U << 2);  ///< Key interrupt flag 2
        constexpr uint32_t KRF1 = (1U << 1);  ///< Key interrupt flag 1
        constexpr uint32_t KRF0 = (1U << 0);  ///< Key interrupt flag 0
    }

    /// KRM Register bits
    namespace krm_bits {
        constexpr uint32_t KRM7 = (1U << 7);  ///< Key interrupt mode control 7
        constexpr uint32_t KRM6 = (1U << 6);  ///< Key interrupt mode control 6
        constexpr uint32_t KRM5 = (1U << 5);  ///< Key interrupt mode control 5
        constexpr uint32_t KRM4 = (1U << 4);  ///< Key interrupt mode control 4
        constexpr uint32_t KRM3 = (1U << 3);  ///< Key interrupt mode control 3
        constexpr uint32_t KRM2 = (1U << 2);  ///< Key interrupt mode control 2
        constexpr uint32_t KRM1 = (1U << 1);  ///< Key interrupt mode control 1
        constexpr uint32_t KRM0 = (1U << 0);  ///< Key interrupt mode control 0
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USBFS_BASE = 0x40090000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t SYSCFG;  ///< Offset: 0x00 - System Configuration Control Register
        volatile uint32_t SYSSTS0;  ///< Offset: 0x04 - System Configuration Status Register 0
        volatile uint32_t DVSTCTR0;  ///< Offset: 0x08 - Device State Control Register 0
        volatile uint32_t CFIFO;  ///< Offset: 0x14 - CFIFO Port Register
        volatile uint32_t CFIFOL;  ///< Offset: 0x14 - CFIFO Port Register L
        volatile uint32_t CFIFOSEL;  ///< Offset: 0x20 - CFIFO Port Select Register
        volatile uint32_t CFIFOCTR;  ///< Offset: 0x22 - CFIFO Port Control Register
        volatile uint32_t INTENB0;  ///< Offset: 0x30 - Interrupt Enable Register 0
        volatile uint32_t BRDYENB;  ///< Offset: 0x36 - BRDY Interrupt Enable Register
        volatile uint32_t NRDYENB;  ///< Offset: 0x38 - NRDY Interrupt Enable Register
        volatile uint32_t BEMPENB;  ///< Offset: 0x3A - BEMP Interrupt Enable Register
        volatile uint32_t SOFCFG;  ///< Offset: 0x3C - SOF Output Configuration Register
        volatile uint32_t INTSTS0;  ///< Offset: 0x40 - Interrupt Status Register 0
        volatile uint32_t BRDYSTS;  ///< Offset: 0x46 - BRDY Interrupt Status Register
        volatile uint32_t NRDYSTS;  ///< Offset: 0x48 - NRDY Interrupt Status Register
        volatile uint32_t BEMPSTS;  ///< Offset: 0x4A - BEMP Interrupt Status Register
        volatile uint32_t FRMNUM;  ///< Offset: 0x4C - Frame Number Register
        volatile uint32_t USBREQ;  ///< Offset: 0x54 - USB Request Type Register
        volatile uint32_t USBVAL;  ///< Offset: 0x56 - USB Request Value Register
        volatile uint32_t USBINDX;  ///< Offset: 0x58 - USB Request Index Register
        volatile uint32_t USBLENG;  ///< Offset: 0x5A - USB Request Length Register
        volatile uint32_t DCPCFG;  ///< Offset: 0x5C - DCP Configuration Register
        volatile uint32_t DCPMAXP;  ///< Offset: 0x5E - DCP Maximum Packet Size Register
        volatile uint32_t DCPCTR;  ///< Offset: 0x60 - DCP Control Register
        volatile uint32_t PIPESEL;  ///< Offset: 0x64 - Pipe Window Select Register
        volatile uint32_t PIPECFG;  ///< Offset: 0x68 - Pipe Configuration Register
        volatile uint32_t PIPEMAXP;  ///< Offset: 0x6C - Pipe Maximum Packet Size Register
        volatile uint32_t PIPECTR;  ///< Offset: 0x7A - Pipe %s Control Register (renamed from PIPECTR)
        volatile uint32_t PIPETRE;  ///< Offset: 0x9C - Pipe %s Transaction Counter Enable Register (renamed from PIPETRE)
        volatile uint32_t PIPETRN;  ///< Offset: 0x9E - Pipe %s Transaction Counter Register (renamed from PIPETRN)
        volatile uint32_t USBMC;  ///< Offset: 0xCC - USB Module Control Register
        volatile uint32_t USBBCCTRL0;  ///< Offset: 0xB0 - BC Control Register 0
        volatile uint32_t UCKSEL;  ///< Offset: 0xC4 - USB Clock Selection Register
    };

    /// Peripheral instances
    inline Registers* USBFS = reinterpret_cast<Registers*>(USBFS_BASE);

    // Bit definitions
    /// SYSCFG Register bits
    namespace syscfg_bits {
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t SCKE = (1U << 10);  ///< USB Clock Enable
        constexpr uint32_t CNEN = (1U << 8);  ///< CNEN Single End Receiver Enable
        constexpr uint32_t DPRPU = (1U << 4);  ///< D+ Line Resistor Control
        constexpr uint32_t DMRPU = (1U << 3);  ///< D- Line Resistor Control
        constexpr uint32_t USBE = (1U << 0);  ///< USB Operation Enable
    }

    /// SYSSTS0 Register bits
    namespace syssts0_bits {
        constexpr uint32_t Reserved = (14 << 2);  ///< These bits are read as 00000000000000.
        constexpr uint32_t LNST = (2 << 0);  ///< USB Data Line Status Monitor
    }

    /// DVSTCTR0 Register bits
    namespace dvstctr0_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t WKUP = (1U << 8);  ///< Wakeup Detection Enable
        constexpr uint32_t RHST = (3 << 0);  ///< USB Bus Reset Status
    }

    /// CFIFO Register bits
    namespace cfifo_bits {
        constexpr uint32_t FIFOPORT = (16 << 0);  ///< FIFO PortRead receive data from the FIFO buffer or write transmit data to the FIFO buffer by accessing these bits.
    }

    /// CFIFOSEL Register bits
    namespace cfifosel_bits {
        constexpr uint32_t RCNT = (1U << 15);  ///< Read Count Mode
        constexpr uint32_t REW = (1U << 14);  ///< Buffer Pointer Rewind
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t MBW = (1U << 10);  ///< CFIFO Port Access Bit Width
        constexpr uint32_t BIGEND = (1U << 8);  ///< CFIFO Port Endian Control
        constexpr uint32_t ISEL = (1U << 5);  ///< CFIFO Port Access Direction When DCP is Selected
        constexpr uint32_t CURPIPE = (4 << 0);  ///< CFIFO Port Access Pipe Specification
    }

    /// CFIFOCTR Register bits
    namespace cfifoctr_bits {
        constexpr uint32_t BVAL = (1U << 15);  ///< Buffer Memory Valid Flag
        constexpr uint32_t BCLR = (1U << 14);  ///< CPU Buffer Clear
        constexpr uint32_t FRDY = (1U << 13);  ///< FIFO Port Ready
        constexpr uint32_t Reserved = (4 << 9);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t DTLN = (9 << 0);  ///< Receive Data LengthIndicates the length of the receive data.
    }

    /// INTENB0 Register bits
    namespace intenb0_bits {
        constexpr uint32_t VBSE = (1U << 15);  ///< VBUS Interrupt Enable
        constexpr uint32_t RSME = (1U << 14);  ///< Resume Interrupt Enable
        constexpr uint32_t SOFE = (1U << 13);  ///< Frame Number Update Interrupt Enable
        constexpr uint32_t DVSE = (1U << 12);  ///< Device State Transition Interrupt Enable
        constexpr uint32_t CTRE = (1U << 11);  ///< Control Transfer Stage Transition Interrupt Enable
        constexpr uint32_t BEMPE = (1U << 10);  ///< Buffer Empty Interrupt Enable
        constexpr uint32_t NRDYE = (1U << 9);  ///< Buffer Not Ready Response Interrupt Enable
        constexpr uint32_t BRDYE = (1U << 8);  ///< Buffer Ready Interrupt Enable
        constexpr uint32_t Reserved = (8 << 0);  ///< These bits are read as 00000000. The write value should be 00000000.
    }

    /// BRDYENB Register bits
    namespace brdyenb_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PIPE9BRDYE = (1U << 9);  ///< BRDY Interrupt Enable for PIPE9
        constexpr uint32_t PIPE8BRDYE = (1U << 8);  ///< BRDY Interrupt Enable for PIPE8
        constexpr uint32_t PIPE7BRDYE = (1U << 7);  ///< BRDY Interrupt Enable for PIPE7
        constexpr uint32_t PIPE6BRDYE = (1U << 6);  ///< BRDY Interrupt Enable for PIPE6
        constexpr uint32_t PIPE5BRDYE = (1U << 5);  ///< BRDY Interrupt Enable for PIPE5
        constexpr uint32_t PIPE4BRDYE = (1U << 4);  ///< BRDY Interrupt Enable for PIPE4
        constexpr uint32_t PIPE3BRDYE = (1U << 3);  ///< BRDY Interrupt Enable for PIPE3
        constexpr uint32_t PIPE2BRDYE = (1U << 2);  ///< BRDY Interrupt Enable for PIPE2
        constexpr uint32_t PIPE1BRDYE = (1U << 1);  ///< BRDY Interrupt Enable for PIPE1
        constexpr uint32_t PIPE0BRDYE = (1U << 0);  ///< BRDY Interrupt Enable for PIPE0
    }

    /// NRDYENB Register bits
    namespace nrdyenb_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PIPE9NRDYE = (1U << 9);  ///< NRDY Interrupt Enable for PIPE9
        constexpr uint32_t PIPE8NRDYE = (1U << 8);  ///< NRDY Interrupt Enable for PIPE8
        constexpr uint32_t PIPE7NRDYE = (1U << 7);  ///< NRDY Interrupt Enable for PIPE7
        constexpr uint32_t PIPE6NRDYE = (1U << 6);  ///< NRDY Interrupt Enable for PIPE6
        constexpr uint32_t PIPE5NRDYE = (1U << 5);  ///< NRDY Interrupt Enable for PIPE5
        constexpr uint32_t PIPE4NRDYE = (1U << 4);  ///< NRDY Interrupt Enable for PIPE4
        constexpr uint32_t PIPE3NRDYE = (1U << 3);  ///< NRDY Interrupt Enable for PIPE3
        constexpr uint32_t PIPE2NRDYE = (1U << 2);  ///< NRDY Interrupt Enable for PIPE2
        constexpr uint32_t PIPE1NRDYE = (1U << 1);  ///< NRDY Interrupt Enable for PIPE1
        constexpr uint32_t PIPE0NRDYE = (1U << 0);  ///< NRDY Interrupt Enable for PIPE0
    }

    /// BEMPENB Register bits
    namespace bempenb_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PIPE9BEMPE = (1U << 9);  ///< BEMP Interrupt Enable for PIPE9
        constexpr uint32_t PIPE8BEMPE = (1U << 8);  ///< BEMP Interrupt Enable for PIPE8
        constexpr uint32_t PIPE7BEMPE = (1U << 7);  ///< BEMP Interrupt Enable for PIPE7
        constexpr uint32_t PIPE6BEMPE = (1U << 6);  ///< BEMP Interrupt Enable for PIPE6
        constexpr uint32_t PIPE5BEMPE = (1U << 5);  ///< BEMP Interrupt Enable for PIPE5
        constexpr uint32_t PIPE4BEMPE = (1U << 4);  ///< BEMP Interrupt Enable for PIPE4
        constexpr uint32_t PIPE3BEMPE = (1U << 3);  ///< BEMP Interrupt Enable for PIPE3
        constexpr uint32_t PIPE2BEMPE = (1U << 2);  ///< BEMP Interrupt Enable for PIPE2
        constexpr uint32_t PIPE1BEMPE = (1U << 1);  ///< BEMP Interrupt Enable for PIPE1
        constexpr uint32_t PIPE0BEMPE = (1U << 0);  ///< BEMP Interrupt Enable for PIPE0
    }

    /// SOFCFG Register bits
    namespace sofcfg_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t TRNENSEL = (1U << 8);  ///< Transaction-Enabled Time Select
        constexpr uint32_t BRDYM = (1U << 6);  ///< BRDY Interrupt Status Clear Timing
        constexpr uint32_t EDGESTS = (1U << 4);  ///< Edge Interrupt Output Status Monitor
    }

    /// INTSTS0 Register bits
    namespace intsts0_bits {
        constexpr uint32_t VBINT = (1U << 15);  ///< VBUS Interrupt Status
        constexpr uint32_t RESM = (1U << 14);  ///< Resume Interrupt Status
        constexpr uint32_t SOFR = (1U << 13);  ///< Frame Number Refresh Interrupt Status
        constexpr uint32_t DVST = (1U << 12);  ///< Device State Transition Interrupt Status
        constexpr uint32_t CTRT = (1U << 11);  ///< Control Transfer Stage Transition Interrupt Status
        constexpr uint32_t BEMP = (1U << 10);  ///< Buffer Empty Interrupt Status
        constexpr uint32_t NRDY = (1U << 9);  ///< Buffer Not Ready Interrupt Status
        constexpr uint32_t BRDY = (1U << 8);  ///< Buffer Ready Interrupt Status
        constexpr uint32_t VBSTS = (1U << 7);  ///< VBUS Input Status
        constexpr uint32_t DVSQ = (3 << 4);  ///< Device State
        constexpr uint32_t VALID = (1U << 3);  ///< USB Request Reception
        constexpr uint32_t CTSQ = (3 << 0);  ///< Control Transfer Stage
    }

    /// BRDYSTS Register bits
    namespace brdysts_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PIPE9BRDY = (1U << 9);  ///< BRDY Interrupt Status for PIPE9
        constexpr uint32_t PIPE8BRDY = (1U << 8);  ///< BRDY Interrupt Status for PIPE8
        constexpr uint32_t PIPE7BRDY = (1U << 7);  ///< BRDY Interrupt Status for PIPE7
        constexpr uint32_t PIPE6BRDY = (1U << 6);  ///< BRDY Interrupt Status for PIPE6
        constexpr uint32_t PIPE5BRDY = (1U << 5);  ///< BRDY Interrupt Status for PIPE5
        constexpr uint32_t PIPE4BRDY = (1U << 4);  ///< BRDY Interrupt Status for PIPE4
        constexpr uint32_t PIPE3BRDY = (1U << 3);  ///< BRDY Interrupt Status for PIPE3
        constexpr uint32_t PIPE2BRDY = (1U << 2);  ///< BRDY Interrupt Status for PIPE2
        constexpr uint32_t PIPE1BRDY = (1U << 1);  ///< BRDY Interrupt Status for PIPE1
        constexpr uint32_t PIPE0BRDY = (1U << 0);  ///< BRDY Interrupt Status for PIPE0
    }

    /// NRDYSTS Register bits
    namespace nrdysts_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PIPE9NRDY = (1U << 9);  ///< NRDY Interrupt Status for PIPE9
        constexpr uint32_t PIPE8NRDY = (1U << 8);  ///< NRDY Interrupt Status for PIPE8
        constexpr uint32_t PIPE7NRDY = (1U << 7);  ///< NRDY Interrupt Status for PIPE7
        constexpr uint32_t PIPE6NRDY = (1U << 6);  ///< NRDY Interrupt Status for PIPE6
        constexpr uint32_t PIPE5NRDY = (1U << 5);  ///< NRDY Interrupt Status for PIPE5
        constexpr uint32_t PIPE4NRDY = (1U << 4);  ///< NRDY Interrupt Status for PIPE4
        constexpr uint32_t PIPE3NRDY = (1U << 3);  ///< NRDY Interrupt Status for PIPE3
        constexpr uint32_t PIPE2NRDY = (1U << 2);  ///< NRDY Interrupt Status for PIPE2
        constexpr uint32_t PIPE1NRDY = (1U << 1);  ///< NRDY Interrupt Status for PIPE1
        constexpr uint32_t PIPE0NRDY = (1U << 0);  ///< NRDY Interrupt Status for PIPE0
    }

    /// BEMPSTS Register bits
    namespace bempsts_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PIPE9BEMP = (1U << 9);  ///< BEMP Interrupt Status for PIPE9
        constexpr uint32_t PIPE8BEMP = (1U << 8);  ///< BEMP Interrupt Status for PIPE8
        constexpr uint32_t PIPE7BEMP = (1U << 7);  ///< BEMP Interrupt Status for PIPE7
        constexpr uint32_t PIPE6BEMP = (1U << 6);  ///< BEMP Interrupt Status for PIPE6
        constexpr uint32_t PIPE5BEMP = (1U << 5);  ///< BEMP Interrupt Status for PIPE5
        constexpr uint32_t PIPE4BEMP = (1U << 4);  ///< BEMP Interrupt Status for PIPE4
        constexpr uint32_t PIPE3BEMP = (1U << 3);  ///< BEMP Interrupt Status for PIPE3
        constexpr uint32_t PIPE2BEMP = (1U << 2);  ///< BEMP Interrupt Status for PIPE2
        constexpr uint32_t PIPE1BEMP = (1U << 1);  ///< BEMP Interrupt Status for PIPE1
        constexpr uint32_t PIPE0BEMP = (1U << 0);  ///< BEMP Interrupt Status for PIPE0
    }

    /// FRMNUM Register bits
    namespace frmnum_bits {
        constexpr uint32_t OVRN = (1U << 15);  ///< Overrun/Underrun Detection Status
        constexpr uint32_t CRCE = (1U << 14);  ///< Receive Data Error
        constexpr uint32_t Reserved = (3 << 11);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t FRNM = (11 << 0);  ///< Frame NumberLatest frame number
    }

    /// USBREQ Register bits
    namespace usbreq_bits {
        constexpr uint32_t BREQUEST = (8 << 8);  ///< RequestThese bits store the USB request bRequest value.
        constexpr uint32_t BMREQUESTTYPE = (8 << 0);  ///< Request TypeThese bits store the USB request bmRequestType value.
    }

    /// USBVAL Register bits
    namespace usbval_bits {
        constexpr uint32_t WVALUE = (16 << 0);  ///< ValueThese bits store the USB request wValue value.
    }

    /// USBINDX Register bits
    namespace usbindx_bits {
        constexpr uint32_t WINDEX = (16 << 0);  ///< IndexThese bits store the USB request wIndex value.
    }

    /// USBLENG Register bits
    namespace usbleng_bits {
        constexpr uint32_t WLENGTUH = (16 << 0);  ///< LengthThese bits store the USB request wLength value.
    }

    /// DCPCFG Register bits
    namespace dcpcfg_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t SHTNAK = (1U << 7);  ///< Pipe Disabled at End of Transfer
        constexpr uint32_t DIR = (1U << 4);  ///< Transfer Direction
    }

    /// DCPMAXP Register bits
    namespace dcpmaxp_bits {
        constexpr uint32_t DEVSEL = (4 << 12);  ///< Device Select
        constexpr uint32_t Reserved = (5 << 7);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t MXPS = (7 << 0);  ///< Maximum Packet SizeThese bits set the maximum amount of data (maximum packet size) in payloads for the DCP.
    }

    /// DCPCTR Register bits
    namespace dcpctr_bits {
        constexpr uint32_t BSTS = (1U << 15);  ///< Buffer Status
        constexpr uint32_t SUREQ = (1U << 14);  ///< Setup Token Transmission
        constexpr uint32_t Reserved = (2 << 3);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t SUREQCLR = (1U << 11);  ///< SUREQ Bit Clear
        constexpr uint32_t SQCLR = (1U << 8);  ///< Sequence Toggle Bit Clear
        constexpr uint32_t SQSET = (1U << 7);  ///< Sequence Toggle Bit Set
        constexpr uint32_t SQMON = (1U << 6);  ///< Sequence Toggle Bit Monitor
        constexpr uint32_t PBUSY = (1U << 5);  ///< Pipe Busy
        constexpr uint32_t CCPL = (1U << 2);  ///< Control Transfer End Enable
        constexpr uint32_t PID = (2 << 0);  ///< Response PID
    }

    /// PIPESEL Register bits
    namespace pipesel_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t PIPESEL = (4 << 0);  ///< Pipe Window Select
    }

    /// PIPECFG Register bits
    namespace pipecfg_bits {
        constexpr uint32_t TYPE = (2 << 14);  ///< Transfer Type
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t BFRE = (1U << 10);  ///< BRDY Interrupt Operation Specification
        constexpr uint32_t DBLB = (1U << 9);  ///< Double Buffer Mode
        constexpr uint32_t SHTNAK = (1U << 7);  ///< Pipe Disabled at End of Transfer
        constexpr uint32_t DIR = (1U << 4);  ///< Transfer Direction
        constexpr uint32_t EPNUM = (4 << 0);  ///< Endpoint NumberThese bits specify the endpoint number for the selected pipe.Setting 0000b means unused pipe.
    }

    /// PIPEMAXP Register bits
    namespace pipemaxp_bits {
        constexpr uint32_t DEVSEL = (4 << 12);  ///< Device Select
        constexpr uint32_t Reserved = (3 << 9);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t MXPS = (9 << 0);  ///< Maximum Packet SizePIPE1 and PIPE2: 1 byte (001h) to 256 bytes (100h)PIPE3 to PIPE5: 8 bytes (008h), 16 bytes (010h), 32 bytes (020h), 64 bytes (040h) (Bits [8:7] and [2:0] are not provided.)PIPE6 to PIPE9: 1 byte (001h) to 64 bytes (040h) (Bits [8:7] are not provided.)
    }

    /// PIPECTR Register bits
    namespace pipectr_bits {
        constexpr uint32_t BSTS = (1U << 15);  ///< Buffer Status
        constexpr uint32_t Reserved = (3 << 2);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t ACLRM = (1U << 9);  ///< Auto Buffer Clear Mode
        constexpr uint32_t SQCLR = (1U << 8);  ///< Sequence Toggle Bit Clear
        constexpr uint32_t SQSET = (1U << 7);  ///< Sequence Toggle Bit Set
        constexpr uint32_t SQMON = (1U << 6);  ///< Sequence Toggle Bit Confirmation
        constexpr uint32_t PBUSY = (1U << 5);  ///< Pipe Busy
        constexpr uint32_t PID = (2 << 0);  ///< Response PID
    }

    /// PIPETRE Register bits
    namespace pipetre_bits {
        constexpr uint32_t Reserved = (8 << 0);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t TRENB = (1U << 9);  ///< Transaction Counter Enable
        constexpr uint32_t TRCLR = (1U << 8);  ///< Transaction Counter Clear
    }

    /// PIPETRN Register bits
    namespace pipetrn_bits {
        constexpr uint32_t TRNCNT = (16 << 0);  ///< Transaction Counter
    }

    /// USBMC Register bits
    namespace usbmc_bits {
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 1. The write value should be 1.
        constexpr uint32_t VDCEN = (1U << 7);  ///< USB Regulator On/Off Control
        constexpr uint32_t VDDUSBE = (1U << 0);  ///< USB Reference Power Supply Circuit On/Off Control
    }

    /// USBBCCTRL0 Register bits
    namespace usbbcctrl0_bits {
        constexpr uint32_t Reserved = (1U << 6);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PDDETSTS0 = (1U << 9);  ///< D+ Pin 0.6 V Input Detection Status
        constexpr uint32_t CHGDETSTS0 = (1U << 8);  ///< D- Pin 0.6 V Input Detection Status
        constexpr uint32_t BATCHGE0 = (1U << 7);  ///< BC (Battery Charger) Function General Enable Control
        constexpr uint32_t VDMSRCE0 = (1U << 5);  ///< D- Pin VDMSRC (0.6 V) Output Control
        constexpr uint32_t IDPSINKE0 = (1U << 4);  ///< D+ Pin 0.6 V Input Detection (Comparator and Sink) Control
        constexpr uint32_t VDPSRCE0 = (1U << 3);  ///< D+ Pin VDPSRC (0.6 V) Output Control
        constexpr uint32_t IDMSINKE0 = (1U << 2);  ///< D- Pin 0.6 V Input Detection (Comparator and Sink) Control
        constexpr uint32_t IDPSRCE0 = (1U << 1);  ///< D+ Pin IDPSRC Output Control
        constexpr uint32_t RPDME0 = (1U << 0);  ///< D- Pin Pull-Down Control
    }

    /// UCKSEL Register bits
    namespace ucksel_bits {
        constexpr uint32_t Reserved = (15 << 1);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
        constexpr uint32_t UCKSELC = (1U << 0);  ///< USB Clock Selection
    }

}

// ============================================================================
// CAC Peripheral
// ============================================================================

namespace cac {
    /// Base addresses
    constexpr uint32_t CAC_BASE = 0x40044600;

    /// CAC Register structure
    struct Registers {
        volatile uint32_t CACR0;  ///< Offset: 0x00 - CAC Control Register 0
        volatile uint32_t CACR1;  ///< Offset: 0x01 - CAC Control Register 1
        volatile uint32_t CACR2;  ///< Offset: 0x02 - CAC Control Register 2
        volatile uint32_t CAICR;  ///< Offset: 0x03 - CAC Interrupt Control Register
        volatile uint32_t CASTR;  ///< Offset: 0x04 - CAC Status Register
        volatile uint32_t CAULVR;  ///< Offset: 0x06 - CAC Upper-Limit Value Setting Register
        volatile uint32_t CALLVR;  ///< Offset: 0x08 - CAC Lower-Limit Value Setting Register
        volatile uint32_t CACNTBR;  ///< Offset: 0x0A - CAC Counter Buffer Register
    };

    /// Peripheral instances
    inline Registers* CAC = reinterpret_cast<Registers*>(CAC_BASE);

    // Bit definitions
    /// CACR0 Register bits
    namespace cacr0_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CFME = (1U << 0);  ///< Clock Frequency Measurement Enable.
    }

    /// CACR1 Register bits
    namespace cacr1_bits {
        constexpr uint32_t EDGES = (2 << 6);  ///< Valid Edge Select
        constexpr uint32_t TCSS = (2 << 4);  ///< Measurement Target Clock Frequency Division Ratio Select
        constexpr uint32_t FMCS = (3 << 1);  ///< Measurement Target Clock Select
        constexpr uint32_t CACREFE = (1U << 0);  ///< CACREF Pin Input Enable
    }

    /// CACR2 Register bits
    namespace cacr2_bits {
        constexpr uint32_t DFS = (2 << 6);  ///< Digital Filter Selection
        constexpr uint32_t RCDS = (2 << 4);  ///< Measurement Reference Clock Frequency Division Ratio Select
        constexpr uint32_t RSCS = (3 << 1);  ///< Measurement Reference Clock Select
        constexpr uint32_t RPS = (1U << 0);  ///< Reference Signal Select
    }

    /// CAICR Register bits
    namespace caicr_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t OVFFCL = (1U << 6);  ///< OVFF Clear
        constexpr uint32_t MENDFCL = (1U << 5);  ///< MENDF Clear
        constexpr uint32_t FERRFCL = (1U << 4);  ///< FERRF Clear
        constexpr uint32_t OVFIE = (1U << 2);  ///< Overflow Interrupt Request Enable
        constexpr uint32_t MENDIE = (1U << 1);  ///< Measurement End Interrupt Request Enable
        constexpr uint32_t FERRIE = (1U << 0);  ///< Frequency Error Interrupt Request Enable
    }

    /// CASTR Register bits
    namespace castr_bits {
        constexpr uint32_t OVFF = (1U << 2);  ///< Counter Overflow Flag
        constexpr uint32_t MENDF = (1U << 1);  ///< Measurement End Flag
        constexpr uint32_t FERRF = (1U << 0);  ///< Frequency Error Flag
    }

    /// CAULVR Register bits
    namespace caulvr_bits {
        constexpr uint32_t CAULVR = (16 << 0);  ///< CAULVR is a 16-bit readable/writable register that stores the upper-limit value of the frequency.
    }

    /// CALLVR Register bits
    namespace callvr_bits {
        constexpr uint32_t CALLVR = (16 << 0);  ///< CALLVR is a 16-bit readable/writable register that stores the lower-limit value of the frequency.
    }

    /// CACNTBR Register bits
    namespace cacntbr_bits {
        constexpr uint32_t CACNTBR = (16 << 0);  ///< CACNTBR is a 16-bit read-only register that retains the counter value at the time a valid reference signal edge is input
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40074000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRCCR0;  ///< Offset: 0x00 - CRC Control Register0
        volatile uint32_t CRCCR1;  ///< Offset: 0x01 - CRC Control Register1
        volatile uint32_t CRCDIR;  ///< Offset: 0x04 - CRC Data Input Register
        volatile uint32_t CRCDIR_BY;  ///< Offset: 0x04 - CRC Data Input Register (byte access)
        volatile uint32_t CRCDOR;  ///< Offset: 0x08 - CRC Data Output Register
        volatile uint32_t CRCDOR_HA;  ///< Offset: 0x08 - CRC Data Output Register (halfword access)
        volatile uint32_t CRCDOR_BY;  ///< Offset: 0x08 - CRC Data Output Register(byte access)
        volatile uint32_t CRCSAR;  ///< Offset: 0x0C - Snoop Address Register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRCCR0 Register bits
    namespace crccr0_bits {
        constexpr uint32_t DORCLR = (1U << 7);  ///< CRCDOR Register Clear
        constexpr uint32_t LMS = (1U << 6);  ///< CRC Calculation Switching
        constexpr uint32_t Reserved = (3 << 3);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t GPS = (3 << 0);  ///< CRC Generating Polynomial Switching
    }

    /// CRCCR1 Register bits
    namespace crccr1_bits {
        constexpr uint32_t CRCSEN = (1U << 7);  ///< Snoop enable bit
        constexpr uint32_t CRCSWR = (1U << 6);  ///< Snoop-on-write/read switch bit
        constexpr uint32_t Reserved = (6 << 0);  ///< These bits are read as 000000. The write value should be 000000.
    }

    /// CRCDIR Register bits
    namespace crcdir_bits {
        constexpr uint32_t CRCDIR = (32 << 0);  ///< Calculation input Data (Case of CRC-32, CRC-32C )
    }

    /// CRCDIR_BY Register bits
    namespace crcdir_by_bits {
        constexpr uint32_t CRCDIR_BY = (8 << 0);  ///< Calculation input Data ( Case of CRC-8, CRC-16 or CRC-CCITT )
    }

    /// CRCDOR Register bits
    namespace crcdor_bits {
        constexpr uint32_t CRCDOR = (32 << 0);  ///< Calculation output Data (Case of CRC-32, CRC-32C )
    }

    /// CRCDOR_HA Register bits
    namespace crcdor_ha_bits {
        constexpr uint32_t CRCDOR_HA = (16 << 0);  ///< Calculation output Data (Case of CRC-16 or CRC-CCITT )
    }

    /// CRCDOR_BY Register bits
    namespace crcdor_by_bits {
        constexpr uint32_t CRCDOR_BY = (8 << 0);  ///< Calculation output Data (Case of CRC-8 )
    }

    /// CRCSAR Register bits
    namespace crcsar_bits {
        constexpr uint32_t Reserved = (2 << 14);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t CRCSA = (14 << 0);  ///< snoop address bitSet the I/O register address to snoop
    }

}

// ============================================================================
// DOC Peripheral
// ============================================================================

namespace doc {
    /// Base addresses
    constexpr uint32_t DOC_BASE = 0x40054100;

    /// DOC Register structure
    struct Registers {
        volatile uint32_t DOCR;  ///< Offset: 0x00 - DOC Control Register
        volatile uint32_t DODIR;  ///< Offset: 0x02 - DOC Data Input Register
        volatile uint32_t DODSR;  ///< Offset: 0x04 - DOC Data Setting Register
    };

    /// Peripheral instances
    inline Registers* DOC = reinterpret_cast<Registers*>(DOC_BASE);

    // Bit definitions
    /// DOCR Register bits
    namespace docr_bits {
        constexpr uint32_t Reserved = (2 << 3);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t DOPCFCL = (1U << 6);  ///< DOPCF Clear
        constexpr uint32_t DOPCF = (1U << 5);  ///< Data Operation Circuit FlagIndicates the result of an operation.
        constexpr uint32_t DCSEL = (1U << 2);  ///< Detection Condition Select
        constexpr uint32_t OMS = (2 << 0);  ///< Operating Mode Select
    }

    /// DODIR Register bits
    namespace dodir_bits {
        constexpr uint32_t DODIR = (16 << 0);  ///< 16-bit read-write register in which 16-bit data for use in the operations are stored.
    }

    /// DODSR Register bits
    namespace dodsr_bits {
        constexpr uint32_t DODSR = (16 << 0);  ///< This register stores 16-bit data for use as a reference in data comparison mode. This register also stores the results of operations in data addition and data subtraction modes.
    }

}

// ============================================================================
// SCI0 Peripheral
// ============================================================================

namespace sci0 {
    /// Base addresses
    constexpr uint32_t SCI0_BASE = 0x40070000;

    /// SCI0 Register structure
    struct Registers {
        volatile uint32_t SMR;  ///< Offset: 0x00 - Serial Mode Register (SCMR.SMIF = 0)
        volatile uint32_t SMR_SMCI;  ///< Offset: 0x00 - Serial mode register (SCMR.SMIF = 1)
        volatile uint32_t BRR;  ///< Offset: 0x01 - Bit Rate Register
        volatile uint32_t SCR;  ///< Offset: 0x02 - Serial Control Register (SCMR.SMIF = 0)
        volatile uint32_t SCR_SMCI;  ///< Offset: 0x02 - Serial Control Register (SCMR.SMIF =1)
        volatile uint32_t TDR;  ///< Offset: 0x03 - Transmit Data Register
        volatile uint32_t SSR;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
        volatile uint32_t SSR_FIFO;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 0 and FCR.FM=1)
        volatile uint32_t SSR_SMCI;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 1)
        volatile uint32_t RDR;  ///< Offset: 0x05 - Receive Data Register
        volatile uint32_t SCMR;  ///< Offset: 0x06 - Smart Card Mode Register
        volatile uint32_t SEMR;  ///< Offset: 0x07 - Serial Extended Mode Register
        volatile uint32_t SNFR;  ///< Offset: 0x08 - Noise Filter Setting Register
        volatile uint32_t SIMR1;  ///< Offset: 0x09 - I2C Mode Register 1
        volatile uint32_t SIMR2;  ///< Offset: 0x0A - I2C Mode Register 2
        volatile uint32_t SIMR3;  ///< Offset: 0x0B - IIC Mode Register 3
        volatile uint32_t SISR;  ///< Offset: 0x0C - IIC Status Register
        volatile uint32_t SPMR;  ///< Offset: 0x0D - SPI Mode Register
        volatile uint32_t TDRHL;  ///< Offset: 0x0E - Transmit 9-bit Data Register
        volatile uint32_t FTDRHL;  ///< Offset: 0x0E - Transmit FIFO Data Register HL
        volatile uint32_t FTDRH;  ///< Offset: 0x0E - Transmit FIFO Data Register H
        volatile uint32_t FTDRL;  ///< Offset: 0x0F - Transmit FIFO Data Register L
        volatile uint32_t RDRHL;  ///< Offset: 0x10 - Receive 9-bit Data Register
        volatile uint32_t FRDRHL;  ///< Offset: 0x10 - Receive FIFO Data Register HL
        volatile uint32_t FRDRH;  ///< Offset: 0x10 - Receive FIFO Data Register H
        volatile uint32_t FRDRL;  ///< Offset: 0x11 - Receive FIFO Data Register L
        volatile uint32_t MDDR;  ///< Offset: 0x12 - Modulation Duty Register
        volatile uint32_t DCCR;  ///< Offset: 0x13 - Data Compare Match Control Register
        volatile uint32_t FCR;  ///< Offset: 0x14 - FIFO Control Register
        volatile uint32_t FDR;  ///< Offset: 0x16 - FIFO Data Count Register
        volatile uint32_t LSR;  ///< Offset: 0x18 - Line Status Register
        volatile uint32_t CDR;  ///< Offset: 0x1A - Compare Match Data Register
        volatile uint32_t SPTR;  ///< Offset: 0x1C - Serial Port Register
    };

    /// Peripheral instances
    inline Registers* SCI0 = reinterpret_cast<Registers*>(SCI0_BASE);

    // Bit definitions
    /// SMR Register bits
    namespace smr_bits {
        constexpr uint32_t CM = (1U << 7);  ///< Communications Mode
        constexpr uint32_t CHR = (1U << 6);  ///< Character Length(Valid only in asynchronous mode)
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable(Valid only in asynchronous mode)
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode (Valid only when the PE bit is 1)
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Bit Length(Valid only in asynchronous mode)
        constexpr uint32_t MP = (1U << 2);  ///< Multi-Processor Mode(Valid only in asynchronous mode)
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
    }

    /// SMR_SMCI Register bits
    namespace smr_smci_bits {
        constexpr uint32_t GM = (1U << 7);  ///< GSM Mode
        constexpr uint32_t BLK = (1U << 6);  ///< Block Transfer Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable(Valid only in asynchronous mode)
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode (Valid only when the PE bit is 1)
        constexpr uint32_t BCP = (2 << 2);  ///< Base Clock Pulse
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR = (8 << 0);  ///< BRR is an 8-bit register that adjusts the bit rate.
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable(Valid in asynchronous mode when SMR.MP = 1)
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
    }

    /// SCR_SMCI Register bits
    namespace scr_smci_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< This bit should be 0 in smart card interface mode.
        constexpr uint32_t TEIE = (1U << 2);  ///< This bit should be 0 in smart card interface mode.
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (8 << 0);  ///< TDR is an 8-bit register that stores transmit data.
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor Bit. Value of the multi-processor bit in the reception frame
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer. Sets the multi-processor bit for adding to the transmission frame
    }

    /// SSR_FIFO Register bits
    namespace ssr_fifo_bits {
        constexpr uint32_t TDFE = (1U << 7);  ///< Transmit FIFO data empty flag
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO data full flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DR = (1U << 0);  ///< Receive Data Ready flag(Valid only in asynchronous mode(including multi-processor) and FIFO selected)
    }

    /// SSR_SMCI Register bits
    namespace ssr_smci_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t ERS = (1U << 4);  ///< Error Signal Status Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-ProcessorThis bit should be 0 in smart card interface mode.
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit TransferThis bit should be 0 in smart card interface mode.
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (8 << 0);  ///< RDR is an 8-bit register that stores receive data.
    }

    /// SCMR Register bits
    namespace scmr_bits {
        constexpr uint32_t BCP2 = (1U << 7);  ///< Base Clock Pulse 2Selects the number of base clock cycles in combination with the SMR.BCP[1:0] bits
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 1. The write value should be 1.
        constexpr uint32_t CHR1 = (1U << 4);  ///< Character Length 1(Only valid in asynchronous mode)
        constexpr uint32_t SDIR = (1U << 3);  ///< Transmitted/Received Data Transfer DirectionNOTE: The setting is invalid and a fixed data length of 8 bits is used in modes other than asynchronous mode.Set this bit to 1 if operation is to be in simple I2C mode.
        constexpr uint32_t SINV = (1U << 2);  ///< Transmitted/Received Data InvertSet this bit to 0 if operation is to be in simple I2C mode.
        constexpr uint32_t SMIF = (1U << 0);  ///< Smart Card Interface Mode Select
    }

    /// SEMR Register bits
    namespace semr_bits {
        constexpr uint32_t RXDESEL = (1U << 7);  ///< Asynchronous Start Bit Edge Detection Select(Valid only in asynchronous mode)
        constexpr uint32_t BGDM = (1U << 6);  ///< Baud Rate Generator Double-Speed Mode Select(Only valid the CKE[1] bit in SCR is 0 in asynchronous mode).
        constexpr uint32_t NFEN = (1U << 5);  ///< Digital Noise Filter Function Enable(The NFEN bit should be 0 without simple I2C mode and asynchronous mode.)In asynchronous mode, for RXDn input only. In simple I2C mode, for RXDn/TxDn input.
        constexpr uint32_t ABCS = (1U << 4);  ///< Asynchronous Mode Base Clock Select(Valid only in asynchronous mode)
        constexpr uint32_t ABCSE = (1U << 3);  ///< Asynchronous Mode Extended Base Clock Select1(Valid only in asynchronous mode and SCR.CKE[1]=0)
        constexpr uint32_t BRME = (1U << 2);  ///< Bit Rate Modulation Enable
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 00. The write value should be 00.
    }

    /// SNFR Register bits
    namespace snfr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t NFCS = (3 << 0);  ///< Noise Filter Clock Select
    }

    /// SIMR1 Register bits
    namespace simr1_bits {
        constexpr uint32_t IICDL = (5 << 3);  ///< SSDA Delay Output SelectCycles below are of the clock signal from the on-chip baud rate generator.
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t IICM = (1U << 0);  ///< Simple I2C Mode Select
    }

    /// SIMR2 Register bits
    namespace simr2_bits {
        constexpr uint32_t Reserved = (3 << 2);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t IICACKT = (1U << 5);  ///< ACK Transmission Data
        constexpr uint32_t IICCSC = (1U << 1);  ///< Clock Synchronization
        constexpr uint32_t IICINTM = (1U << 0);  ///< I2C Interrupt Mode Select
    }

    /// SIMR3 Register bits
    namespace simr3_bits {
        constexpr uint32_t IICSCLS = (2 << 6);  ///< SCL Output Select
        constexpr uint32_t IICSDAS = (2 << 4);  ///< SDA Output Select
        constexpr uint32_t IICSTIF = (1U << 3);  ///< Issuing of Start, Restart, or Stop Condition Completed Flag(When 0 is written to IICSTIF, it is cleared to 0.)
        constexpr uint32_t IICSTPREQ = (1U << 2);  ///< Stop Condition Generation
        constexpr uint32_t IICRSTAREQ = (1U << 1);  ///< Restart Condition Generation
        constexpr uint32_t IICSTAREQ = (1U << 0);  ///< Start Condition Generation
    }

    /// SISR Register bits
    namespace sisr_bits {
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0.
        constexpr uint32_t IICACKR = (1U << 0);  ///< ACK Reception Data Flag
    }

    /// SPMR Register bits
    namespace spmr_bits {
        constexpr uint32_t CKPH = (1U << 7);  ///< Clock Phase Select
        constexpr uint32_t CKPOL = (1U << 6);  ///< Clock Polarity Select
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t MFF = (1U << 4);  ///< Mode Fault Flag
        constexpr uint32_t MSS = (1U << 2);  ///< Master Slave Select
        constexpr uint32_t CTSE = (1U << 1);  ///< CTS Enable
        constexpr uint32_t SSE = (1U << 0);  ///< SSn# Pin Function Enable
    }

    /// TDRHL Register bits
    namespace tdrhl_bits {
        constexpr uint32_t TDRHL = (16 << 0);  ///< TDRHL is a 16-bit register that stores transmit data.
    }

    /// FTDRHL Register bits
    namespace ftdrhl_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< The write value should be 111111.
        constexpr uint32_t MPBT = (1U << 9);  ///< Multi-processor transfer bit flag(Valid only in asynchronous mode and SMR.MP=1 and FIFO selected)
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial transmit data (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FTDRH Register bits
    namespace ftdrh_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< The write value should be 111111.
        constexpr uint32_t MPBT = (1U << 1);  ///< Multi-processor transfer bit flag(Valid only in asynchronous mode and SMR.MP=1 and FIFO selected)
        constexpr uint32_t TDATH = (1U << 0);  ///< Serial transmit data (b8) (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FTDRL Register bits
    namespace ftdrl_bits {
        constexpr uint32_t TDATL = (8 << 0);  ///< Serial transmit data(b7-b0) (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// RDRHL Register bits
    namespace rdrhl_bits {
        constexpr uint32_t RDRHL = (16 << 0);  ///< RDRHL is an 16-bit register that stores receive data.
    }

    /// FRDRHL Register bits
    namespace frdrhl_bits {
        constexpr uint32_t Reserved = (1U << 15);  ///< This bit is read as 0.
        constexpr uint32_t RDF = (1U << 14);  ///< Receive FIFO data full flag(It is same as SSR.RDF)
        constexpr uint32_t ORER = (1U << 13);  ///< Overrun error flag(It is same as SSR.ORER)
        constexpr uint32_t FER = (1U << 12);  ///< Framing error flag
        constexpr uint32_t PER = (1U << 11);  ///< Parity error flag
        constexpr uint32_t DR = (1U << 10);  ///< Receive data ready flag(It is same as SSR.DR)
        constexpr uint32_t MPB = (1U << 9);  ///< Multi-processor bit flag(Valid only in asynchronous mode with SMR.MP=1 and FIFO selected) It can read multi-processor bit corresponded to serial receive data(RDATA[8:0])
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial receive data(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FRDRH Register bits
    namespace frdrh_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0.
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO data full flag(It is same as SSR.RDF)
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun error flag(It is same as SSR.ORER)
        constexpr uint32_t FER = (1U << 4);  ///< Framing error flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity error flag
        constexpr uint32_t DR = (1U << 2);  ///< Receive data ready flag(It is same as SSR.DR)
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-processor bit flag(Valid only in asynchronous mode with SMR.MP=1 and FIFO selected) It can read multi-processor bit corresponded to serial receive data(RDATA[8:0])
        constexpr uint32_t RDATH = (1U << 0);  ///< Serial receive data(b8)(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FRDRL Register bits
    namespace frdrl_bits {
        constexpr uint32_t RDATL = (8 << 0);  ///< Serial receive data(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)NOTE: When reading both of FRDRH register and FRDRL register, please read by an order of the FRDRH register and the FRDRL register.
    }

    /// MDDR Register bits
    namespace mddr_bits {
        constexpr uint32_t MDDR = (8 << 0);  ///< MDDR corrects the bit rate adjusted by the BRR register.
    }

    /// DCCR Register bits
    namespace dccr_bits {
        constexpr uint32_t DCME = (1U << 7);  ///< Data Compare Match Enable(Valid only in asynchronous mode(including multi-processor)
        constexpr uint32_t IDSEL = (1U << 6);  ///< ID frame select Bit(Valid only in asynchronous mode(including multi-processor)
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t DFER = (1U << 4);  ///< Data Compare Match Framing Error Flag
        constexpr uint32_t DPER = (1U << 3);  ///< Data Compare Match Parity Error Flag
        constexpr uint32_t DCMF = (1U << 0);  ///< Data Compare Match Flag
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t RSTRG = (4 << 12);  ///< RTS# Output Active Trigger Number Select(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode)
        constexpr uint32_t RTRG = (4 << 8);  ///< Receive FIFO data trigger number
        constexpr uint32_t TTRG = (4 << 4);  ///< Transmit FIFO data trigger number(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode)
        constexpr uint32_t DRES = (1U << 3);  ///< Receive data ready error select bit(When detecting a reception data ready, the interrupt request is selected.)
        constexpr uint32_t TFRST = (1U << 2);  ///< Transmit FIFO Data Register Reset(Valid only in FCR.FM=1)
        constexpr uint32_t RFRST = (1U << 1);  ///< Receive FIFO Data Register Reset(Valid only in FCR.FM=1)
        constexpr uint32_t FM = (1U << 0);  ///< FIFO Mode Select(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode)
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000.
        constexpr uint32_t T = (5 << 8);  ///< Transmit FIFO Data CountIndicate the quantity of non-transmit data stored in FTDRH and FTDRL(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, while FCR.FM=1)
        constexpr uint32_t R = (5 << 0);  ///< Receive FIFO Data CountIndicate the quantity of receive data stored in FRDRH and FRDRL(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, while FCR.FM=1)
    }

    /// LSR Register bits
    namespace lsr_bits {
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0.
        constexpr uint32_t PNUM = (5 << 8);  ///< Parity Error CountIndicates the quantity of data with a parity error among the receive data stored in the receive FIFO data register (FRDRH and FRDRL).
        constexpr uint32_t FNUM = (5 << 2);  ///< Framing Error CountIndicates the quantity of data with a framing error among the receive data stored in the receive FIFO data register (FRDRH and FRDRL).
        constexpr uint32_t ORER = (1U << 0);  ///< Overrun Error Flag (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// CDR Register bits
    namespace cdr_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPD = (9 << 0);  ///< Compare Match DataCompare data pattern for address match wake-up function
    }

    /// SPTR Register bits
    namespace sptr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SPB2IO = (1U << 2);  ///< Serial port break I/O bit(It's selected whether the value of SPB2DT is output to TxD terminal.)
        constexpr uint32_t SPB2DT = (1U << 1);  ///< Serial port break data select bit(The output level of TxD terminal is selected when SCR.TE = 0.)
        constexpr uint32_t RXDMON = (1U << 0);  ///< Serial input data monitor bit(The state of the RXD terminal is shown.)
    }

}

// ============================================================================
// SCI1 Peripheral
// ============================================================================

namespace sci1 {
    /// Base addresses
    constexpr uint32_t SCI1_BASE = 0x40070020;

    /// SCI1 Register structure
    struct Registers {
        volatile uint32_t SMR;  ///< Offset: 0x00 - Serial Mode Register (SCMR.SMIF = 0)
        volatile uint32_t SMR_SMCI;  ///< Offset: 0x00 - Serial mode register (SCMR.SMIF = 1)
        volatile uint32_t BRR;  ///< Offset: 0x01 - Bit Rate Register
        volatile uint32_t SCR;  ///< Offset: 0x02 - Serial Control Register (SCMR.SMIF = 0)
        volatile uint32_t SCR_SMCI;  ///< Offset: 0x02 - Serial Control Register (SCMR.SMIF =1)
        volatile uint32_t TDR;  ///< Offset: 0x03 - Transmit Data Register
        volatile uint32_t SSR;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
        volatile uint32_t SSR_SMCI;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 1)
        volatile uint32_t RDR;  ///< Offset: 0x05 - Receive Data Register
        volatile uint32_t SCMR;  ///< Offset: 0x06 - Smart Card Mode Register
        volatile uint32_t SEMR;  ///< Offset: 0x07 - Serial Extended Mode Register
        volatile uint32_t SNFR;  ///< Offset: 0x08 - Noise Filter Setting Register
        volatile uint32_t SIMR1;  ///< Offset: 0x09 - I2C Mode Register 1
        volatile uint32_t SIMR2;  ///< Offset: 0x0A - I2C Mode Register 2
        volatile uint32_t SIMR3;  ///< Offset: 0x0B - IIC Mode Register 3
        volatile uint32_t SISR;  ///< Offset: 0x0C - IIC Status Register
        volatile uint32_t SPMR;  ///< Offset: 0x0D - SPI Mode Register
        volatile uint32_t TDRHL;  ///< Offset: 0x0E - Transmit 9-bit Data Register
        volatile uint32_t RDRHL;  ///< Offset: 0x10 - Receive 9-bit Data Register
        volatile uint32_t MDDR;  ///< Offset: 0x12 - Modulation Duty Register
        volatile uint32_t DCCR;  ///< Offset: 0x13 - Data Compare Match Control Register
        volatile uint32_t CDR;  ///< Offset: 0x1A - Compare Match Data Register
        volatile uint32_t SPTR;  ///< Offset: 0x1C - Serial Port Register
    };

    /// Peripheral instances
    inline Registers* SCI1 = reinterpret_cast<Registers*>(SCI1_BASE);

    // Bit definitions
    /// SMR Register bits
    namespace smr_bits {
        constexpr uint32_t CM = (1U << 7);  ///< Communications Mode
        constexpr uint32_t CHR = (1U << 6);  ///< Character Length(Valid only in asynchronous mode)
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable(Valid only in asynchronous mode)
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode (Valid only when the PE bit is 1)
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Bit Length(Valid only in asynchronous mode)
        constexpr uint32_t MP = (1U << 2);  ///< Multi-Processor Mode(Valid only in asynchronous mode)
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
    }

    /// SMR_SMCI Register bits
    namespace smr_smci_bits {
        constexpr uint32_t GM = (1U << 7);  ///< GSM Mode
        constexpr uint32_t BLK = (1U << 6);  ///< Block Transfer Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable(Valid only in asynchronous mode)
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode (Valid only when the PE bit is 1)
        constexpr uint32_t BCP = (2 << 2);  ///< Base Clock Pulse
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR = (8 << 0);  ///< BRR is an 8-bit register that adjusts the bit rate.
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable(Valid in asynchronous mode when SMR.MP = 1)
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
    }

    /// SCR_SMCI Register bits
    namespace scr_smci_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< This bit should be 0 in smart card interface mode.
        constexpr uint32_t TEIE = (1U << 2);  ///< This bit should be 0 in smart card interface mode.
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (8 << 0);  ///< TDR is an 8-bit register that stores transmit data.
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor Bit. Value of the multi-processor bit in the reception frame
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer. Sets the multi-processor bit for adding to the transmission frame
    }

    /// SSR_SMCI Register bits
    namespace ssr_smci_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t ERS = (1U << 4);  ///< Error Signal Status Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-ProcessorThis bit should be 0 in smart card interface mode.
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit TransferThis bit should be 0 in smart card interface mode.
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (8 << 0);  ///< RDR is an 8-bit register that stores receive data.
    }

    /// SCMR Register bits
    namespace scmr_bits {
        constexpr uint32_t BCP2 = (1U << 7);  ///< Base Clock Pulse 2Selects the number of base clock cycles in combination with the SMR.BCP[1:0] bits
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 1. The write value should be 1.
        constexpr uint32_t CHR1 = (1U << 4);  ///< Character Length 1(Only valid in asynchronous mode)
        constexpr uint32_t SDIR = (1U << 3);  ///< Transmitted/Received Data Transfer DirectionNOTE: The setting is invalid and a fixed data length of 8 bits is used in modes other than asynchronous mode.Set this bit to 1 if operation is to be in simple I2C mode.
        constexpr uint32_t SINV = (1U << 2);  ///< Transmitted/Received Data InvertSet this bit to 0 if operation is to be in simple I2C mode.
        constexpr uint32_t SMIF = (1U << 0);  ///< Smart Card Interface Mode Select
    }

    /// SEMR Register bits
    namespace semr_bits {
        constexpr uint32_t RXDESEL = (1U << 7);  ///< Asynchronous Start Bit Edge Detection Select(Valid only in asynchronous mode)
        constexpr uint32_t BGDM = (1U << 6);  ///< Baud Rate Generator Double-Speed Mode Select(Only valid the CKE[1] bit in SCR is 0 in asynchronous mode).
        constexpr uint32_t NFEN = (1U << 5);  ///< Digital Noise Filter Function Enable(The NFEN bit should be 0 without simple I2C mode and asynchronous mode.)In asynchronous mode, for RXDn input only. In simple I2C mode, for RXDn/TxDn input.
        constexpr uint32_t ABCS = (1U << 4);  ///< Asynchronous Mode Base Clock Select(Valid only in asynchronous mode)
        constexpr uint32_t ABCSE = (1U << 3);  ///< Asynchronous Mode Extended Base Clock Select1(Valid only in asynchronous mode and SCR.CKE[1]=0)
        constexpr uint32_t BRME = (1U << 2);  ///< Bit Rate Modulation Enable
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 00. The write value should be 00.
    }

    /// SNFR Register bits
    namespace snfr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t NFCS = (3 << 0);  ///< Noise Filter Clock Select
    }

    /// SIMR1 Register bits
    namespace simr1_bits {
        constexpr uint32_t IICDL = (5 << 3);  ///< SSDA Delay Output SelectCycles below are of the clock signal from the on-chip baud rate generator.
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t IICM = (1U << 0);  ///< Simple I2C Mode Select
    }

    /// SIMR2 Register bits
    namespace simr2_bits {
        constexpr uint32_t Reserved = (3 << 2);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t IICACKT = (1U << 5);  ///< ACK Transmission Data
        constexpr uint32_t IICCSC = (1U << 1);  ///< Clock Synchronization
        constexpr uint32_t IICINTM = (1U << 0);  ///< I2C Interrupt Mode Select
    }

    /// SIMR3 Register bits
    namespace simr3_bits {
        constexpr uint32_t IICSCLS = (2 << 6);  ///< SCL Output Select
        constexpr uint32_t IICSDAS = (2 << 4);  ///< SDA Output Select
        constexpr uint32_t IICSTIF = (1U << 3);  ///< Issuing of Start, Restart, or Stop Condition Completed Flag(When 0 is written to IICSTIF, it is cleared to 0.)
        constexpr uint32_t IICSTPREQ = (1U << 2);  ///< Stop Condition Generation
        constexpr uint32_t IICRSTAREQ = (1U << 1);  ///< Restart Condition Generation
        constexpr uint32_t IICSTAREQ = (1U << 0);  ///< Start Condition Generation
    }

    /// SISR Register bits
    namespace sisr_bits {
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0.
        constexpr uint32_t IICACKR = (1U << 0);  ///< ACK Reception Data Flag
    }

    /// SPMR Register bits
    namespace spmr_bits {
        constexpr uint32_t CKPH = (1U << 7);  ///< Clock Phase Select
        constexpr uint32_t CKPOL = (1U << 6);  ///< Clock Polarity Select
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t MFF = (1U << 4);  ///< Mode Fault Flag
        constexpr uint32_t MSS = (1U << 2);  ///< Master Slave Select
        constexpr uint32_t CTSE = (1U << 1);  ///< CTS Enable
        constexpr uint32_t SSE = (1U << 0);  ///< SSn# Pin Function Enable
    }

    /// TDRHL Register bits
    namespace tdrhl_bits {
        constexpr uint32_t TDRHL = (16 << 0);  ///< TDRHL is a 16-bit register that stores transmit data.
    }

    /// RDRHL Register bits
    namespace rdrhl_bits {
        constexpr uint32_t RDRHL = (16 << 0);  ///< RDRHL is an 16-bit register that stores receive data.
    }

    /// MDDR Register bits
    namespace mddr_bits {
        constexpr uint32_t MDDR = (8 << 0);  ///< MDDR corrects the bit rate adjusted by the BRR register.
    }

    /// DCCR Register bits
    namespace dccr_bits {
        constexpr uint32_t DCME = (1U << 7);  ///< Data Compare Match Enable(Valid only in asynchronous mode(including multi-processor)
        constexpr uint32_t IDSEL = (1U << 6);  ///< ID frame select Bit(Valid only in asynchronous mode(including multi-processor)
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t DFER = (1U << 4);  ///< Data Compare Match Framing Error Flag
        constexpr uint32_t DPER = (1U << 3);  ///< Data Compare Match Parity Error Flag
        constexpr uint32_t DCMF = (1U << 0);  ///< Data Compare Match Flag
    }

    /// CDR Register bits
    namespace cdr_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPD = (9 << 0);  ///< Compare Match DataCompare data pattern for address match wake-up function
    }

    /// SPTR Register bits
    namespace sptr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SPB2IO = (1U << 2);  ///< Serial port break I/O bit(It's selected whether the value of SPB2DT is output to TxD terminal.)
        constexpr uint32_t SPB2DT = (1U << 1);  ///< Serial port break data select bit(The output level of TxD terminal is selected when SCR.TE = 0.)
        constexpr uint32_t RXDMON = (1U << 0);  ///< Serial input data monitor bit(The state of the RXD terminal is shown.)
    }

}

// ============================================================================
// SCI9 Peripheral
// ============================================================================

namespace sci9 {
    /// Base addresses
    constexpr uint32_t SCI9_BASE = 0x40070120;

    /// SCI9 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI9 = reinterpret_cast<Registers*>(SCI9_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40072000;
    constexpr uint32_t SPI1_BASE = 0x40072100;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPCR;  ///< Offset: 0x00 - SPI Control Register
        volatile uint32_t SSLP;  ///< Offset: 0x01 - SPI Slave Select Polarity Register
        volatile uint32_t SPPCR;  ///< Offset: 0x02 - SPI Pin Control Register
        volatile uint32_t SPSR;  ///< Offset: 0x03 - SPI Status Register
        volatile uint32_t SPDR;  ///< Offset: 0x04 - SPI Data Register
        volatile uint32_t SPDR_HA;  ///< Offset: 0x04 - SPI Data Register ( halfword access )
        volatile uint32_t SPBR;  ///< Offset: 0x0A - SPI Bit Rate Register
        volatile uint32_t SPDCR;  ///< Offset: 0x0B - SPI Data Control Register
        volatile uint32_t SPCKD;  ///< Offset: 0x0C - SPI Clock Delay Register
        volatile uint32_t SSLND;  ///< Offset: 0x0D - SPI Slave Select Negation Delay Register
        volatile uint32_t SPND;  ///< Offset: 0x0E - SPI Next-Access Delay Register
        volatile uint32_t SPCR2;  ///< Offset: 0x0F - SPI Control Register 2
        volatile uint32_t SPCMD0;  ///< Offset: 0x10 - SPI Command Register 0
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

    // Bit definitions
    /// SPCR Register bits
    namespace spcr_bits {
        constexpr uint32_t SPRIE = (1U << 7);  ///< SPI Receive Buffer Full Interrupt Enable
        constexpr uint32_t SPE = (1U << 6);  ///< SPI Function Enable
        constexpr uint32_t SPTIE = (1U << 5);  ///< Transmit Buffer Empty Interrupt Enable
        constexpr uint32_t SPEIE = (1U << 4);  ///< SPI Error Interrupt Enable
        constexpr uint32_t MSTR = (1U << 3);  ///< SPI Master/Slave Mode Select
        constexpr uint32_t MODFEN = (1U << 2);  ///< Mode Fault Error Detection Enable
        constexpr uint32_t TXMD = (1U << 1);  ///< Communications Operating Mode Select
        constexpr uint32_t SPMS = (1U << 0);  ///< SPI Mode Select
    }

    /// SSLP Register bits
    namespace sslp_bits {
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t SSL3P = (1U << 3);  ///< SSL3 Signal Polarity Setting
        constexpr uint32_t SSL2P = (1U << 2);  ///< SSL2 Signal Polarity Setting
        constexpr uint32_t SSL1P = (1U << 1);  ///< SSL1 Signal Polarity Setting
        constexpr uint32_t SSL0P = (1U << 0);  ///< SSL0 Signal Polarity Setting
    }

    /// SPPCR Register bits
    namespace sppcr_bits {
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t MOIFE = (1U << 5);  ///< MOSI Idle Value Fixing Enable
        constexpr uint32_t MOIFV = (1U << 4);  ///< MOSI Idle Fixed Value
        constexpr uint32_t SPLP2 = (1U << 1);  ///< SPI Loopback 2
        constexpr uint32_t SPLP = (1U << 0);  ///< SPI Loopback
    }

    /// SPSR Register bits
    namespace spsr_bits {
        constexpr uint32_t SPRF = (1U << 7);  ///< SPI Receive Buffer Full Flag
        constexpr uint32_t Reserved = (1U << 6);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SPTEF = (1U << 5);  ///< SPI Transmit Buffer Empty Flag
        constexpr uint32_t UDRF = (1U << 4);  ///< Underrun Error Flag(When MODF is 0, This bit is invalid.)
        constexpr uint32_t PERF = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t MODF = (1U << 2);  ///< Mode Fault Error Flag
        constexpr uint32_t IDLNF = (1U << 1);  ///< SPI Idle Flag
        constexpr uint32_t OVRF = (1U << 0);  ///< Overrun Error Flag
    }

    /// SPDR Register bits
    namespace spdr_bits {
        constexpr uint32_t SPDR = (32 << 0);  ///< SPDR is the interface with the buffers that hold data for transmission and reception by the RSPI.When accessing in word (SPDCR.SPLW=1), access SPDR.
    }

    /// SPDR_HA Register bits
    namespace spdr_ha_bits {
        constexpr uint32_t SPDR_HA = (16 << 0);  ///< SPDR is the interface with the buffers that hold data for transmission and reception by the SPI.When accessing in halfword (SPDCR.SPLW=0), access SPDR_HA.
    }

    /// SPBR Register bits
    namespace spbr_bits {
        constexpr uint32_t SPR = (8 << 0);  ///< SPBR sets the bit rate in master mode.
    }

    /// SPDCR Register bits
    namespace spdcr_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t SPLW = (1U << 5);  ///< SPI Word Access/Halfword Access Specification
        constexpr uint32_t SPRDTD = (1U << 4);  ///< SPI Receive/Transmit Data Selection
    }

    /// SPCKD Register bits
    namespace spckd_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SCKDL = (3 << 0);  ///< RSPCK Delay Setting
    }

    /// SSLND Register bits
    namespace sslnd_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SLNDL = (3 << 0);  ///< SSL Negation Delay Setting
    }

    /// SPND Register bits
    namespace spnd_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SPNDL = (3 << 0);  ///< SPI Next-Access Delay Setting
    }

    /// SPCR2 Register bits
    namespace spcr2_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t SCKASE = (1U << 4);  ///< RSPCK Auto-Stop Function Enable
        constexpr uint32_t PTE = (1U << 3);  ///< Parity Self-Testing
        constexpr uint32_t SPIIE = (1U << 2);  ///< SPI Idle Interrupt Enable
        constexpr uint32_t SPOE = (1U << 1);  ///< Parity Mode
        constexpr uint32_t SPPE = (1U << 0);  ///< Parity Enable
    }

    /// SPCMD0 Register bits
    namespace spcmd0_bits {
        constexpr uint32_t SCKDEN = (1U << 15);  ///< RSPCK Delay Setting Enable
        constexpr uint32_t SLNDEN = (1U << 14);  ///< SSL Negation Delay Setting Enable
        constexpr uint32_t SPNDEN = (1U << 13);  ///< SPI Next-Access Delay Enable
        constexpr uint32_t LSBF = (1U << 12);  ///< SPI LSB First
        constexpr uint32_t SPB = (4 << 8);  ///< SPI Data Length Setting
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SSLA = (3 << 4);  ///< SSL Signal Assertion Setting
        constexpr uint32_t BRDV = (2 << 2);  ///< Bit Rate Division Setting
        constexpr uint32_t CPOL = (1U << 1);  ///< RSPCK Polarity Setting
        constexpr uint32_t CPHA = (1U << 0);  ///< RSPCK Phase Setting
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN0_BASE = 0x40050000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MB_ID;  ///< Offset: 0x200 - Mailbox Register (renamed from MB_ID)
        volatile uint32_t MB_DL;  ///< Offset: 0x204 - Mailbox Register (renamed from MB_DL)
        volatile uint32_t MB_D0;  ///< Offset: 0x206 - Mailbox Register (renamed from MB_D0)
        volatile uint32_t MB_D1;  ///< Offset: 0x207 - Mailbox Register (renamed from MB_D1)
        volatile uint32_t MB_D2;  ///< Offset: 0x208 - Mailbox Register (renamed from MB_D2)
        volatile uint32_t MB_D3;  ///< Offset: 0x209 - Mailbox Register (renamed from MB_D3)
        volatile uint32_t MB_D4;  ///< Offset: 0x20A - Mailbox Register (renamed from MB_D4)
        volatile uint32_t MB_D5;  ///< Offset: 0x20B - Mailbox Register (renamed from MB_D5)
        volatile uint32_t MB_D6;  ///< Offset: 0x20C - Mailbox Register (renamed from MB_D6)
        volatile uint32_t MB_D7;  ///< Offset: 0x20D - Mailbox Register (renamed from MB_D7)
        volatile uint32_t MB_TS;  ///< Offset: 0x20E - Mailbox Register (renamed from MB_TS)
        volatile uint32_t MKR__;  ///< Offset: 0x400 - Mask Register (renamed from MKR__)
        volatile uint32_t FIDCR;  ///< Offset: 0x420 - FIFO Received ID Compare Registers (renamed from FIDCR)
        volatile uint32_t MKIVLR;  ///< Offset: 0x428 - Mask Invalid Register
        volatile uint32_t MIER;  ///< Offset: 0x42C - Mailbox Interrupt Enable Register (Normal mailbox mode)
        volatile uint32_t MIER_FIFO;  ///< Offset: 0x42C - Mailbox Interrupt Enable Register(FIFO mailbox mode)
        volatile uint32_t MCTL_TX__;  ///< Offset: 0x820 - Message Control Register(Transmit mode (when the TRMREQ... (renamed from MCTL_TX__)
        volatile uint32_t MCTL_RX__;  ///< Offset: 0x820 - Message Control Register( Receive mode (when the TRMREQ... (renamed from MCTL_RX__)
        volatile uint32_t CTLR;  ///< Offset: 0x840 - Control Register
        volatile uint32_t STR;  ///< Offset: 0x842 - Status Register
        volatile uint32_t BCR;  ///< Offset: 0x844 - Bit Configuration Register
        volatile uint32_t RFCR;  ///< Offset: 0x848 - Receive FIFO Control Register
        volatile uint32_t RFPCR;  ///< Offset: 0x849 - Receive FIFO Pointer Control Register
        volatile uint32_t TFCR;  ///< Offset: 0x84A - Transmit FIFO Control Register
        volatile uint32_t TFPCR;  ///< Offset: 0x84B - Transmit FIFO Pointer Control Register
        volatile uint32_t EIER;  ///< Offset: 0x84C - Error Interrupt Enable Register
        volatile uint32_t EIFR;  ///< Offset: 0x84D - Error Interrupt Factor Judge Register
        volatile uint32_t RECR;  ///< Offset: 0x84E - Receive Error Count Register
        volatile uint32_t TECR;  ///< Offset: 0x84F - Transmit Error Count Register
        volatile uint32_t ECSR;  ///< Offset: 0x850 - Error Code Store Register
        volatile uint32_t CSSR;  ///< Offset: 0x851 - Channel Search Support Register
        volatile uint32_t MSSR;  ///< Offset: 0x852 - Mailbox Search Status Register
        volatile uint32_t MSMR;  ///< Offset: 0x853 - Mailbox Search Mode Register
        volatile uint32_t TSR;  ///< Offset: 0x854 - Time Stamp Register
        volatile uint32_t AFSR;  ///< Offset: 0x856 - Acceptance Filter Support Register
        volatile uint32_t TCR;  ///< Offset: 0x858 - Test Control Register
    };

    /// Peripheral instances
    inline Registers* CAN0 = reinterpret_cast<Registers*>(CAN0_BASE);

    // Bit definitions
    /// MB_ID Register bits
    namespace mb_id_bits {
        constexpr uint32_t IDE = (1U << 31);  ///< ID Extension
        constexpr uint32_t RTR = (1U << 30);  ///< Remote Transmission Request
        constexpr uint32_t Reserved = (1U << 29);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID
    }

    /// MB_DL Register bits
    namespace mb_dl_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t DLC = (4 << 0);  ///< Data Length Code
    }

    /// MB_D0 Register bits
    namespace mb_d0_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< Data Bytes 0.DATA0 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D1 Register bits
    namespace mb_d1_bits {
        constexpr uint32_t DATA1 = (8 << 0);  ///< Data Bytes 1DATA1 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D2 Register bits
    namespace mb_d2_bits {
        constexpr uint32_t DATA2 = (8 << 0);  ///< Data Bytes 2DATA2 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D3 Register bits
    namespace mb_d3_bits {
        constexpr uint32_t DATA3 = (8 << 0);  ///< Data Bytes 3DATA3 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D4 Register bits
    namespace mb_d4_bits {
        constexpr uint32_t DATA4 = (8 << 0);  ///< Data Bytes 4DATA4 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D5 Register bits
    namespace mb_d5_bits {
        constexpr uint32_t DATA5 = (8 << 0);  ///< Data Bytes 5DATA5 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D6 Register bits
    namespace mb_d6_bits {
        constexpr uint32_t DATA6 = (8 << 0);  ///< Data Bytes 6DATA6 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D7 Register bits
    namespace mb_d7_bits {
        constexpr uint32_t DATA7 = (8 << 0);  ///< Data Bytes 7DATA7 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_TS Register bits
    namespace mb_ts_bits {
        constexpr uint32_t TSH = (8 << 8);  ///< Time Stamp Lower ByteBits TSH[7:0] store the counter value of the time stamp when received messages are stored in the mailbox.
        constexpr uint32_t TSL = (8 << 0);  ///< Time Stamp Higher ByteBits TSL[7:0] store the counter value of the time stamp when received messages are stored in the mailbox.
    }

    /// MKR__ Register bits
    namespace mkr___bits {
        constexpr uint32_t Reserved = (3 << 29);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID
    }

    /// FIDCR Register bits
    namespace fidcr_bits {
        constexpr uint32_t IDE = (1U << 31);  ///< ID Extension
        constexpr uint32_t RTR = (1U << 30);  ///< Remote Transmission Request
        constexpr uint32_t Reserved = (1U << 29);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID
    }

    /// MKIVLR Register bits
    namespace mkivlr_bits {
        constexpr uint32_t MB31 = (1U << 31);  ///< mailbox 31 Mask Invalid
        constexpr uint32_t MB30 = (1U << 30);  ///< mailbox 30 Mask Invalid
        constexpr uint32_t MB29 = (1U << 29);  ///< mailbox 29 Mask Invalid
        constexpr uint32_t MB28 = (1U << 28);  ///< mailbox 28 Mask Invalid
        constexpr uint32_t MB27 = (1U << 27);  ///< mailbox 27 Mask Invalid
        constexpr uint32_t MB26 = (1U << 26);  ///< mailbox 26 Mask Invalid
        constexpr uint32_t MB25 = (1U << 25);  ///< mailbox 25 Mask Invalid
        constexpr uint32_t MB24 = (1U << 24);  ///< mailbox 24 Mask Invalid
        constexpr uint32_t MB23 = (1U << 23);  ///< mailbox 23 Mask Invalid
        constexpr uint32_t MB22 = (1U << 22);  ///< mailbox 22 Mask Invalid
        constexpr uint32_t MB21 = (1U << 21);  ///< mailbox 21 Mask Invalid
        constexpr uint32_t MB20 = (1U << 20);  ///< mailbox 20 Mask Invalid
        constexpr uint32_t MB19 = (1U << 19);  ///< mailbox 19 Mask Invalid
        constexpr uint32_t MB18 = (1U << 18);  ///< mailbox 18 Mask Invalid
        constexpr uint32_t MB17 = (1U << 17);  ///< mailbox 17 Mask Invalid
        constexpr uint32_t MB16 = (1U << 16);  ///< mailbox 16 Mask Invalid
        constexpr uint32_t MB15 = (1U << 15);  ///< mailbox 15 Mask Invalid
        constexpr uint32_t MB14 = (1U << 14);  ///< mailbox 14 Mask Invalid
        constexpr uint32_t MB13 = (1U << 13);  ///< mailbox 13 Mask Invalid
        constexpr uint32_t MB12 = (1U << 12);  ///< mailbox 12 Mask Invalid
        constexpr uint32_t MB11 = (1U << 11);  ///< mailbox 11 Mask Invalid
        constexpr uint32_t MB10 = (1U << 10);  ///< mailbox 10 Mask Invalid
        constexpr uint32_t MB9 = (1U << 9);  ///< mailbox 9 Mask Invalid
        constexpr uint32_t MB8 = (1U << 8);  ///< mailbox 8 Mask Invalid
        constexpr uint32_t MB7 = (1U << 7);  ///< mailbox 7 Mask Invalid
        constexpr uint32_t MB6 = (1U << 6);  ///< mailbox 6 Mask Invalid
        constexpr uint32_t MB5 = (1U << 5);  ///< mailbox 5 Mask Invalid
        constexpr uint32_t MB4 = (1U << 4);  ///< mailbox 4 Mask Invalid
        constexpr uint32_t MB3 = (1U << 3);  ///< mailbox 3 Mask Invalid
        constexpr uint32_t MB2 = (1U << 2);  ///< mailbox 2 Mask Invalid
        constexpr uint32_t MB1 = (1U << 1);  ///< mailbox 1 Mask Invalid
        constexpr uint32_t MB0 = (1U << 0);  ///< mailbox 0 Mask Invalid
    }

    /// MIER Register bits
    namespace mier_bits {
        constexpr uint32_t MB31 = (1U << 31);  ///< mailbox 31 Interrupt Enable
        constexpr uint32_t MB30 = (1U << 30);  ///< mailbox 30 Interrupt Enable
        constexpr uint32_t MB29 = (1U << 29);  ///< mailbox 29 Interrupt Enable
        constexpr uint32_t MB28 = (1U << 28);  ///< mailbox 28 Interrupt Enable
        constexpr uint32_t MB27 = (1U << 27);  ///< mailbox 27 Interrupt Enable
        constexpr uint32_t MB26 = (1U << 26);  ///< mailbox 26 Interrupt Enable
        constexpr uint32_t MB25 = (1U << 25);  ///< mailbox 25 Interrupt Enable
        constexpr uint32_t MB24 = (1U << 24);  ///< mailbox 24 Interrupt Enable
        constexpr uint32_t MB23 = (1U << 23);  ///< mailbox 23 Interrupt Enable
        constexpr uint32_t MB22 = (1U << 22);  ///< mailbox 22 Interrupt Enable
        constexpr uint32_t MB21 = (1U << 21);  ///< mailbox 21 Interrupt Enable
        constexpr uint32_t MB20 = (1U << 20);  ///< mailbox 20 Interrupt Enable
        constexpr uint32_t MB19 = (1U << 19);  ///< mailbox 19 Interrupt Enable
        constexpr uint32_t MB18 = (1U << 18);  ///< mailbox 18 Interrupt Enable
        constexpr uint32_t MB17 = (1U << 17);  ///< mailbox 17 Interrupt Enable
        constexpr uint32_t MB16 = (1U << 16);  ///< mailbox 16 Interrupt Enable
        constexpr uint32_t MB15 = (1U << 15);  ///< mailbox 15 Interrupt Enable
        constexpr uint32_t MB14 = (1U << 14);  ///< mailbox 14 Interrupt Enable
        constexpr uint32_t MB13 = (1U << 13);  ///< mailbox 13 Interrupt Enable
        constexpr uint32_t MB12 = (1U << 12);  ///< mailbox 12 Interrupt Enable
        constexpr uint32_t MB11 = (1U << 11);  ///< mailbox 11 Interrupt Enable
        constexpr uint32_t MB10 = (1U << 10);  ///< mailbox 10 Interrupt Enable
        constexpr uint32_t MB9 = (1U << 9);  ///< mailbox 9 Interrupt Enable
        constexpr uint32_t MB8 = (1U << 8);  ///< mailbox 8 Interrupt Enable
        constexpr uint32_t MB7 = (1U << 7);  ///< mailbox 7 Interrupt Enable
        constexpr uint32_t MB6 = (1U << 6);  ///< mailbox 6 Interrupt Enable
        constexpr uint32_t MB5 = (1U << 5);  ///< mailbox 5 Interrupt Enable
        constexpr uint32_t MB4 = (1U << 4);  ///< mailbox 4 Interrupt Enable
        constexpr uint32_t MB3 = (1U << 3);  ///< mailbox 3 Interrupt Enable
        constexpr uint32_t MB2 = (1U << 2);  ///< mailbox 2 Interrupt Enable
        constexpr uint32_t MB1 = (1U << 1);  ///< mailbox 1 Interrupt Enable
        constexpr uint32_t MB0 = (1U << 0);  ///< mailbox 0 Interrupt Enable
    }

    /// MIER_FIFO Register bits
    namespace mier_fifo_bits {
        constexpr uint32_t MB29 = (1U << 29);  ///< Receive FIFO Interrupt Generation Timing Control
        constexpr uint32_t MB28 = (1U << 28);  ///< Receive FIFO Interrupt Enable
        constexpr uint32_t Reserved = (2 << 26);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t MB25 = (1U << 25);  ///< Transmit FIFO Interrupt Generation Timing Control
        constexpr uint32_t MB24 = (1U << 24);  ///< Transmit FIFO Interrupt Enable
        constexpr uint32_t MB23 = (1U << 23);  ///< mailbox 23 Interrupt Enable
        constexpr uint32_t MB22 = (1U << 22);  ///< mailbox 22 Interrupt Enable
        constexpr uint32_t MB21 = (1U << 21);  ///< mailbox 21 Interrupt Enable
        constexpr uint32_t MB20 = (1U << 20);  ///< mailbox 20 Interrupt Enable
        constexpr uint32_t MB19 = (1U << 19);  ///< mailbox 19 Interrupt Enable
        constexpr uint32_t MB18 = (1U << 18);  ///< mailbox 18 Interrupt Enable
        constexpr uint32_t MB17 = (1U << 17);  ///< mailbox 17 Interrupt Enable
        constexpr uint32_t MB16 = (1U << 16);  ///< mailbox 16 Interrupt Enable
        constexpr uint32_t MB15 = (1U << 15);  ///< mailbox 15 Interrupt Enable
        constexpr uint32_t MB14 = (1U << 14);  ///< mailbox 14 Interrupt Enable
        constexpr uint32_t MB13 = (1U << 13);  ///< mailbox 13 Interrupt Enable
        constexpr uint32_t MB12 = (1U << 12);  ///< mailbox 12 Interrupt Enable
        constexpr uint32_t MB11 = (1U << 11);  ///< mailbox 11 Interrupt Enable
        constexpr uint32_t MB10 = (1U << 10);  ///< mailbox 10 Interrupt Enable
        constexpr uint32_t MB9 = (1U << 9);  ///< mailbox 9 Interrupt Enable
        constexpr uint32_t MB8 = (1U << 8);  ///< mailbox 8 Interrupt Enable
        constexpr uint32_t MB7 = (1U << 7);  ///< mailbox 7 Interrupt Enable
        constexpr uint32_t MB6 = (1U << 6);  ///< mailbox 6 Interrupt Enable
        constexpr uint32_t MB5 = (1U << 5);  ///< mailbox 5 Interrupt Enable
        constexpr uint32_t MB4 = (1U << 4);  ///< mailbox 4 Interrupt Enable
        constexpr uint32_t MB3 = (1U << 3);  ///< mailbox 3 Interrupt Enable
        constexpr uint32_t MB2 = (1U << 2);  ///< mailbox 2 Interrupt Enable
        constexpr uint32_t MB1 = (1U << 1);  ///< mailbox 1 Interrupt Enable
        constexpr uint32_t MB0 = (1U << 0);  ///< mailbox 0 Interrupt Enable
    }

    /// MCTL_TX__ Register bits
    namespace mctl_tx___bits {
        constexpr uint32_t TRMREQ = (1U << 7);  ///< Transmit Mailbox Request
        constexpr uint32_t RECREQ = (1U << 6);  ///< Receive Mailbox Request
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t ONESHOT = (1U << 4);  ///< One-Shot Enable
        constexpr uint32_t TRMABT = (1U << 2);  ///< Transmission Abort Complete Flag (Transmit mailbox setting enabled)
        constexpr uint32_t TRMACTIVE = (1U << 1);  ///< Transmission-in-Progress Status Flag (Transmit mailbox setting enabled)
        constexpr uint32_t SENTDATA = (1U << 0);  ///< Transmission Complete Flag
    }

    /// MCTL_RX__ Register bits
    namespace mctl_rx___bits {
        constexpr uint32_t TRMREQ = (1U << 7);  ///< Transmit Mailbox Request
        constexpr uint32_t RECREQ = (1U << 6);  ///< Receive Mailbox Request
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t ONESHOT = (1U << 4);  ///< One-Shot Enable
        constexpr uint32_t MSGLOST = (1U << 2);  ///< Message Lost Flag(Receive mailbox setting enabled)
        constexpr uint32_t INVALDATA = (1U << 1);  ///< Reception-in-Progress Status Flag (Receive mailbox setting enabled)
        constexpr uint32_t NEWDATA = (1U << 0);  ///< Reception Complete Flag
    }

    /// CTLR Register bits
    namespace ctlr_bits {
        constexpr uint32_t Reserved = (2 << 14);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t RBOC = (1U << 13);  ///< Forcible Return From Bus-Off
        constexpr uint32_t BOM = (2 << 11);  ///< Bus-Off Recovery Mode
        constexpr uint32_t SLPM = (1U << 10);  ///< CAN Sleep Mode
        constexpr uint32_t CANM = (2 << 8);  ///< CAN Mode of Operation Select
        constexpr uint32_t TSPS = (2 << 6);  ///< Time Stamp Prescaler Select
        constexpr uint32_t TSRC = (1U << 5);  ///< Time Stamp Counter Reset Command
        constexpr uint32_t TPM = (1U << 4);  ///< Transmission Priority Mode Select
        constexpr uint32_t MLM = (1U << 3);  ///< Message Lost Mode Select
        constexpr uint32_t IDFM = (2 << 1);  ///< ID Format Mode Select
        constexpr uint32_t MBM = (1U << 0);  ///< CAN Mailbox Mode Select
    }

    /// STR Register bits
    namespace str_bits {
        constexpr uint32_t Reserved = (1U << 15);  ///< This bit is read as 0.
        constexpr uint32_t RECST = (1U << 14);  ///< Receive Status Flag (receiver)
        constexpr uint32_t TRMST = (1U << 13);  ///< Transmit Status Flag (transmitter)
        constexpr uint32_t BOST = (1U << 12);  ///< Bus-Off Status Flag
        constexpr uint32_t EPST = (1U << 11);  ///< Error-Passive Status Flag
        constexpr uint32_t SLPST = (1U << 10);  ///< CAN Sleep Status Flag
        constexpr uint32_t HLTST = (1U << 9);  ///< CAN Halt Status Flag
        constexpr uint32_t RSTST = (1U << 8);  ///< CAN Reset Status Flag
        constexpr uint32_t EST = (1U << 7);  ///< Error Status Flag
        constexpr uint32_t TABST = (1U << 6);  ///< Transmission Abort Status Flag
        constexpr uint32_t FMLST = (1U << 5);  ///< FIFO Mailbox Message Lost Status Flag
        constexpr uint32_t NMLST = (1U << 4);  ///< Normal Mailbox Message Lost Status Flag
        constexpr uint32_t TFST = (1U << 3);  ///< Transmit FIFO Status Flag
        constexpr uint32_t RFST = (1U << 2);  ///< Receive FIFO Status Flag
        constexpr uint32_t SDST = (1U << 1);  ///< SENTDATA Status Flag
        constexpr uint32_t NDST = (1U << 0);  ///< NEWDATA Status Flag
    }

    /// BCR Register bits
    namespace bcr_bits {
        constexpr uint32_t TSEG1 = (4 << 28);  ///< Time Segment 1 Control
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t BRP = (10 << 16);  ///< Baud Rate Prescaler select . These bits set the frequency of the CAN communication clock (fCANCLK).
        constexpr uint32_t SJW = (2 << 12);  ///< Resynchronization Jump Width Control
        constexpr uint32_t TSEG2 = (3 << 8);  ///< Time Segment 2 Control
        constexpr uint32_t CCLKS = (1U << 0);  ///< CAN Clock Source Selection
    }

    /// RFCR Register bits
    namespace rfcr_bits {
        constexpr uint32_t RFEST = (1U << 7);  ///< Receive FIFO Empty Status Flag
        constexpr uint32_t RFWST = (1U << 6);  ///< Receive FIFO Buffer Warning Status Flag
        constexpr uint32_t RFFST = (1U << 5);  ///< Receive FIFO Full Status Flag
        constexpr uint32_t RFMLF = (1U << 4);  ///< Receive FIFO Message Lost Flag
        constexpr uint32_t RFUST = (3 << 1);  ///< Receive FIFO Unread Message Number Status
        constexpr uint32_t RFE = (1U << 0);  ///< Receive FIFO Enable
    }

    /// RFPCR Register bits
    namespace rfpcr_bits {
        constexpr uint32_t RFPCR = (8 << 0);  ///< The CPU-side pointer for the receive FIFO is incremented by writing FFh to RFPCR.
    }

    /// TFCR Register bits
    namespace tfcr_bits {
        constexpr uint32_t TFEST = (1U << 7);  ///< Transmit FIFO Empty Status
        constexpr uint32_t TFFST = (1U << 6);  ///< Transmit FIFO Full Status
        constexpr uint32_t Reserved = (2 << 4);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t TFUST = (3 << 1);  ///< Transmit FIFO Unsent Message Number Status
        constexpr uint32_t TFE = (1U << 0);  ///< Transmit FIFO Enable
    }

    /// TFPCR Register bits
    namespace tfpcr_bits {
        constexpr uint32_t TFPCR = (8 << 0);  ///< The CPU-side pointer for the transmit FIFO is incremented by writing FFh to TFPCR.
    }

    /// EIER Register bits
    namespace eier_bits {
        constexpr uint32_t BLIE = (1U << 7);  ///< Bus Lock Interrupt Enable
        constexpr uint32_t OLIE = (1U << 6);  ///< Overload Frame Transmit Interrupt Enable
        constexpr uint32_t ORIE = (1U << 5);  ///< Overrun Interrupt Enable
        constexpr uint32_t BORIE = (1U << 4);  ///< Bus-Off Recovery Interrupt Enable
        constexpr uint32_t BOEIE = (1U << 3);  ///< Bus-Off Entry Interrupt Enable
        constexpr uint32_t EPIE = (1U << 2);  ///< Error-Passive Interrupt Enable
        constexpr uint32_t EWIE = (1U << 1);  ///< Error-Warning Interrupt Enable
        constexpr uint32_t BEIE = (1U << 0);  ///< Bus Error Interrupt Enable
    }

    /// EIFR Register bits
    namespace eifr_bits {
        constexpr uint32_t BLIF = (1U << 7);  ///< Bus Lock Detect Flag
        constexpr uint32_t OLIF = (1U << 6);  ///< Overload Frame Transmission Detect Flag
        constexpr uint32_t ORIF = (1U << 5);  ///< Receive Overrun Detect Flag
        constexpr uint32_t BORIF = (1U << 4);  ///< Bus-Off Recovery Detect Flag
        constexpr uint32_t BOEIF = (1U << 3);  ///< Bus-Off Entry Detect Flag
        constexpr uint32_t EPIF = (1U << 2);  ///< Error-Passive Detect Flag
        constexpr uint32_t EWIF = (1U << 1);  ///< Error-Warning Detect Flag
        constexpr uint32_t BEIF = (1U << 0);  ///< Bus Error Detect Flag
    }

    /// RECR Register bits
    namespace recr_bits {
        constexpr uint32_t RECR = (8 << 0);  ///< Receive error count functionRECR increments or decrements the counter value according to the error status of the CAN module during reception.
    }

    /// TECR Register bits
    namespace tecr_bits {
        constexpr uint32_t TECR = (8 << 0);  ///< Transmit error count functionTECR increments or decrements the counter value according to the error status of the CAN module during transmission.
    }

    /// ECSR Register bits
    namespace ecsr_bits {
        constexpr uint32_t EDPM = (1U << 7);  ///< Error Display Mode Select
        constexpr uint32_t ADEF = (1U << 6);  ///< ACK Delimiter Error Flag
        constexpr uint32_t BE0F = (1U << 5);  ///< Bit Error (dominant) Flag
        constexpr uint32_t BE1F = (1U << 4);  ///< Bit Error (recessive) Flag
        constexpr uint32_t CEF = (1U << 3);  ///< CRC Error Flag
        constexpr uint32_t AEF = (1U << 2);  ///< ACK Error Flag
        constexpr uint32_t FEF = (1U << 1);  ///< Form Error Flag
        constexpr uint32_t SEF = (1U << 0);  ///< Stuff Error Flag
    }

    /// CSSR Register bits
    namespace cssr_bits {
        constexpr uint32_t CSSR = (8 << 0);  ///< When the value for the channel search is input, the channel number is output to MSSR.
    }

    /// MSSR Register bits
    namespace mssr_bits {
        constexpr uint32_t SEST = (1U << 7);  ///< Search Result Status
        constexpr uint32_t Reserved = (2 << 5);  ///< These bits are read as 00.
        constexpr uint32_t MBNST = (5 << 0);  ///< Search Result Mailbox Number Status These bits output the smallest mailbox number that is searched in each mode of MSMR.
    }

    /// MSMR Register bits
    namespace msmr_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t MBSM = (2 << 0);  ///< Mailbox Search Mode Select
    }

    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (16 << 0);  ///< Free-running counter value for the time stamp function
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t AFSR = (16 << 0);  ///< After the standard ID of a received message is written, the value converted for data table search can be read.
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t TSTM = (2 << 1);  ///< CAN Test Mode Select
        constexpr uint32_t TSTE = (1U << 0);  ///< CAN Test Mode Enable
    }

}

// ============================================================================
// IIC0 Peripheral
// ============================================================================

namespace iic0 {
    /// Base addresses
    constexpr uint32_t IIC0_BASE = 0x40053000;

    /// IIC0 Register structure
    struct Registers {
        volatile uint32_t ICCR1;  ///< Offset: 0x00 - I2C Bus Control Register 1
        volatile uint32_t ICCR2;  ///< Offset: 0x01 - I2C Bus Control Register 2
        volatile uint32_t ICMR1;  ///< Offset: 0x02 - I2C Bus Mode Register 1
        volatile uint32_t ICMR2;  ///< Offset: 0x03 - I2C Bus Mode Register 2
        volatile uint32_t ICMR3;  ///< Offset: 0x04 - I2C Bus Mode Register 3
        volatile uint32_t ICFER;  ///< Offset: 0x05 - I2C Bus Function Enable Register
        volatile uint32_t ICSER;  ///< Offset: 0x06 - I2C Bus Status Enable Register
        volatile uint32_t ICIER;  ///< Offset: 0x07 - I2C Bus Interrupt Enable Register
        volatile uint32_t ICSR1;  ///< Offset: 0x08 - I2C Bus Status Register 1
        volatile uint32_t ICSR2;  ///< Offset: 0x09 - I2C Bus Status Register 2
        volatile uint32_t SARL;  ///< Offset: 0x0A - Slave Address Register L%s (renamed from SARL)
        volatile uint32_t SARU;  ///< Offset: 0x0B - Slave Address Register U%s (renamed from SARU)
        volatile uint32_t ICBRL;  ///< Offset: 0x10 - I2C Bus Bit Rate Low-Level Register
        volatile uint32_t ICBRH;  ///< Offset: 0x11 - I2C Bus Bit Rate High-Level Register
        volatile uint32_t ICDRT;  ///< Offset: 0x12 - I2C Bus Transmit Data Register
        volatile uint32_t ICDRR;  ///< Offset: 0x13 - I2C Bus Receive Data Register
        volatile uint32_t ICWUR;  ///< Offset: 0x16 - I2C Bus Wake Up Unit Register
        volatile uint32_t ICWUR2;  ///< Offset: 0x17 - Reserved
    };

    /// Peripheral instances
    inline Registers* IIC0 = reinterpret_cast<Registers*>(IIC0_BASE);

    // Bit definitions
    /// ICCR1 Register bits
    namespace iccr1_bits {
        constexpr uint32_t ICE = (1U << 7);  ///< I2C Bus Interface Enable
        constexpr uint32_t IICRST = (1U << 6);  ///< I2C Bus Interface Internal ResetNote:If an internal reset is initiated using the IICRST bit for a bus hang-up occurred during communication with the master device in slave mode, the states may become different between the slave device and the master device (due to the difference in the bit counter information).
        constexpr uint32_t CLO = (1U << 5);  ///< Extra SCL Clock Cycle Output
        constexpr uint32_t SOWP = (1U << 4);  ///< SCLO/SDAO Write Protect
        constexpr uint32_t SCLO = (1U << 3);  ///< SCL Output Control/Monitor
        constexpr uint32_t SDAO = (1U << 2);  ///< SDA Output Control/Monitor
        constexpr uint32_t SCLI = (1U << 1);  ///< SCL Line Monitor
        constexpr uint32_t SDAI = (1U << 0);  ///< SDA Line Monitor
    }

    /// ICCR2 Register bits
    namespace iccr2_bits {
        constexpr uint32_t BBSY = (1U << 7);  ///< Bus Busy Detection Flag
        constexpr uint32_t MST = (1U << 6);  ///< Master/Slave Mode
        constexpr uint32_t TRS = (1U << 5);  ///< Transmit/Receive Mode
        constexpr uint32_t Reserved = (1U << 0);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SP = (1U << 3);  ///< Stop Condition Issuance RequestNote: Writing to the SP bit is not possible while the setting of the BBSY flag is 0 (bus free state).Note: Do not set the SP bit to 1 while a restart condition is being issued.
        constexpr uint32_t RS = (1U << 2);  ///< Restart Condition Issuance RequestNote: Do not set the RS bit to 1 while issuing a stop condition.
        constexpr uint32_t ST = (1U << 1);  ///< Start Condition Issuance RequestSet the ST bit to 1 (start condition issuance request) when the BBSY flag is set to 0 (bus free state).
    }

    /// ICMR1 Register bits
    namespace icmr1_bits {
        constexpr uint32_t MTWP = (1U << 7);  ///< MST/TRS Write Protect
        constexpr uint32_t CKS = (3 << 4);  ///< Internal Reference Clock (fIIC) Selection ( fIIC = PCLKB / 2^CKS )
        constexpr uint32_t BCWP = (1U << 3);  ///< BC Write Protect(This bit is read as 1.)
        constexpr uint32_t BC = (3 << 0);  ///< Bit Counter
    }

    /// ICMR2 Register bits
    namespace icmr2_bits {
        constexpr uint32_t DLCS = (1U << 7);  ///< SDA Output Delay Clock Source Selection
        constexpr uint32_t SDDL = (3 << 4);  ///< SDA Output Delay Counter
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TMOH = (1U << 2);  ///< Timeout H Count Control
        constexpr uint32_t TMOL = (1U << 1);  ///< Timeout L Count Control
        constexpr uint32_t TMOS = (1U << 0);  ///< Timeout Detection Time Selection
    }

    /// ICMR3 Register bits
    namespace icmr3_bits {
        constexpr uint32_t SMBS = (1U << 7);  ///< SMBus/I2C Bus Selection
        constexpr uint32_t WAIT = (1U << 6);  ///< WAITNote: When the value of the WAIT bit is to be read, be sure to read the ICDRR beforehand.
        constexpr uint32_t RDRFS = (1U << 5);  ///< RDRF Flag Set Timing Selection
        constexpr uint32_t ACKWP = (1U << 4);  ///< ACKBT Write Protect
        constexpr uint32_t ACKBT = (1U << 3);  ///< Transmit Acknowledge
        constexpr uint32_t ACKBR = (1U << 2);  ///< Receive Acknowledge
        constexpr uint32_t NF = (2 << 0);  ///< Noise Filter Stage Selection
    }

    /// ICFER Register bits
    namespace icfer_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SCLE = (1U << 6);  ///< SCL Synchronous Circuit Enable
        constexpr uint32_t NFE = (1U << 5);  ///< Digital Noise Filter Circuit Enable
        constexpr uint32_t NACKE = (1U << 4);  ///< NACK Reception Transfer Suspension Enable
        constexpr uint32_t SALE = (1U << 3);  ///< Slave Arbitration-Lost Detection Enable
        constexpr uint32_t NALE = (1U << 2);  ///< NACK Transmission Arbitration-Lost Detection Enable
        constexpr uint32_t MALE = (1U << 1);  ///< Master Arbitration-Lost Detection Enable
        constexpr uint32_t TMOE = (1U << 0);  ///< Timeout Function Enable
    }

    /// ICSER Register bits
    namespace icser_bits {
        constexpr uint32_t HOAE = (1U << 7);  ///< Host Address Enable
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DIDE = (1U << 5);  ///< Device-ID Address Detection Enable
        constexpr uint32_t GCAE = (1U << 3);  ///< General Call Address Enable
        constexpr uint32_t SAR2E = (1U << 2);  ///< Slave Address Register 2 Enable
        constexpr uint32_t SAR1E = (1U << 1);  ///< Slave Address Register 1 Enable
        constexpr uint32_t SAR0E = (1U << 0);  ///< Slave Address Register 0 Enable
    }

    /// ICIER Register bits
    namespace icier_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Data Empty Interrupt Request Enable
        constexpr uint32_t TEIE = (1U << 6);  ///< Transmit End Interrupt Request Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receive Data Full Interrupt Request Enable
        constexpr uint32_t NAKIE = (1U << 4);  ///< NACK Reception Interrupt Request Enable
        constexpr uint32_t SPIE = (1U << 3);  ///< Stop Condition Detection Interrupt Request Enable
        constexpr uint32_t STIE = (1U << 2);  ///< Start Condition Detection Interrupt Request Enable
        constexpr uint32_t ALIE = (1U << 1);  ///< Arbitration-Lost Interrupt Request Enable
        constexpr uint32_t TMOIE = (1U << 0);  ///< Timeout Interrupt Request Enable
    }

    /// ICSR1 Register bits
    namespace icsr1_bits {
        constexpr uint32_t HOA = (1U << 7);  ///< Host Address Detection Flag
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DID = (1U << 5);  ///< Device-ID Address Detection Flag
        constexpr uint32_t GCA = (1U << 3);  ///< General Call Address Detection Flag
        constexpr uint32_t AAS2 = (1U << 2);  ///< Slave Address 2 Detection Flag
        constexpr uint32_t AAS1 = (1U << 1);  ///< Slave Address 1 Detection Flag
        constexpr uint32_t AAS0 = (1U << 0);  ///< Slave Address 0 Detection Flag
    }

    /// ICSR2 Register bits
    namespace icsr2_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t TEND = (1U << 6);  ///< Transmit End Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Full Flag
        constexpr uint32_t NACKF = (1U << 4);  ///< NACK Detection Flag
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Condition Detection Flag
        constexpr uint32_t START = (1U << 2);  ///< Start Condition Detection Flag
        constexpr uint32_t AL = (1U << 1);  ///< Arbitration-Lost Flag
        constexpr uint32_t TMOF = (1U << 0);  ///< Timeout Detection Flag
    }

    /// SARL Register bits
    namespace sarl_bits {
        constexpr uint32_t SVA = (8 << 0);  ///< A slave address is set.7-Bit Address = SVA[7:1] 10-Bit Address = { SVA9,SVA8,SVA[7:0] }
    }

    /// SARU Register bits
    namespace saru_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SVA9 = (1U << 2);  ///< 10-Bit Address(bit9)
        constexpr uint32_t SVA8 = (1U << 1);  ///< 10-Bit Address(bit8)
        constexpr uint32_t FS = (1U << 0);  ///< 7-Bit/10-Bit Address Format Selection
    }

    /// ICBRL Register bits
    namespace icbrl_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 111. The write value should be 111.
        constexpr uint32_t BRL = (5 << 0);  ///< Bit Rate Low-Level Period(Low-level period of SCL clock)
    }

    /// ICBRH Register bits
    namespace icbrh_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 111. The write value should be 111.
        constexpr uint32_t BRH = (5 << 0);  ///< Bit Rate High-Level Period(High-level period of SCL clock)
    }

    /// ICDRT Register bits
    namespace icdrt_bits {
        constexpr uint32_t ICDRT = (8 << 0);  ///< 8-bit read-write register that stores transmit data.
    }

    /// ICDRR Register bits
    namespace icdrr_bits {
        constexpr uint32_t ICDRR = (8 << 0);  ///< 8-bit register that stores the received data
    }

    /// ICWUR Register bits
    namespace icwur_bits {
        constexpr uint32_t WUE = (1U << 7);  ///< Wake Up function Enable
        constexpr uint32_t WUIE = (1U << 6);  ///< Wake Up Interrupt Request Enable
        constexpr uint32_t WUF = (1U << 5);  ///< Wake-Up Event Occurrence Flag
        constexpr uint32_t WUACK = (1U << 4);  ///< Asynchronous/Synchronous Operation State Flag
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t WUAFA = (1U << 0);  ///< Wake-Up Analog Filter Additional Selection
    }

    /// ICWUR2 Register bits
    namespace icwur2_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 11111. The write value should be 11111.
        constexpr uint32_t WUSYF = (1U << 2);  ///< Wake-Up function Synchronous operation status Flag
        constexpr uint32_t WUASYF = (1U << 1);  ///< Wake-Up function Asynchronous operation status Flag
        constexpr uint32_t WUSEN = (1U << 0);  ///< Wake-Up function Synchronous Enable
    }

}

// ============================================================================
// IIC1 Peripheral
// ============================================================================

namespace iic1 {
    /// Base addresses
    constexpr uint32_t IIC1_BASE = 0x40053100;

    /// IIC1 Register structure
    struct Registers {
        volatile uint32_t ICCR1;  ///< Offset: 0x00 - I2C Bus Control Register 1
        volatile uint32_t ICCR2;  ///< Offset: 0x01 - I2C Bus Control Register 2
        volatile uint32_t ICMR1;  ///< Offset: 0x02 - I2C Bus Mode Register 1
        volatile uint32_t ICMR2;  ///< Offset: 0x03 - I2C Bus Mode Register 2
        volatile uint32_t ICMR3;  ///< Offset: 0x04 - I2C Bus Mode Register 3
        volatile uint32_t ICFER;  ///< Offset: 0x05 - I2C Bus Function Enable Register
        volatile uint32_t ICSER;  ///< Offset: 0x06 - I2C Bus Status Enable Register
        volatile uint32_t ICIER;  ///< Offset: 0x07 - I2C Bus Interrupt Enable Register
        volatile uint32_t ICSR1;  ///< Offset: 0x08 - I2C Bus Status Register 1
        volatile uint32_t ICSR2;  ///< Offset: 0x09 - I2C Bus Status Register 2
        volatile uint32_t SARL;  ///< Offset: 0x0A - Slave Address Register L%s (renamed from SARL)
        volatile uint32_t SARU;  ///< Offset: 0x0B - Slave Address Register U%s (renamed from SARU)
        volatile uint32_t ICBRL;  ///< Offset: 0x10 - I2C Bus Bit Rate Low-Level Register
        volatile uint32_t ICBRH;  ///< Offset: 0x11 - I2C Bus Bit Rate High-Level Register
        volatile uint32_t ICDRT;  ///< Offset: 0x12 - I2C Bus Transmit Data Register
        volatile uint32_t ICDRR;  ///< Offset: 0x13 - I2C Bus Receive Data Register
    };

    /// Peripheral instances
    inline Registers* IIC1 = reinterpret_cast<Registers*>(IIC1_BASE);

    // Bit definitions
    /// ICCR1 Register bits
    namespace iccr1_bits {
        constexpr uint32_t ICE = (1U << 7);  ///< I2C Bus Interface Enable
        constexpr uint32_t IICRST = (1U << 6);  ///< I2C Bus Interface Internal ResetNote:If an internal reset is initiated using the IICRST bit for a bus hang-up occurred during communication with the master device in slave mode, the states may become different between the slave device and the master device (due to the difference in the bit counter information).
        constexpr uint32_t CLO = (1U << 5);  ///< Extra SCL Clock Cycle Output
        constexpr uint32_t SOWP = (1U << 4);  ///< SCLO/SDAO Write Protect
        constexpr uint32_t SCLO = (1U << 3);  ///< SCL Output Control/Monitor
        constexpr uint32_t SDAO = (1U << 2);  ///< SDA Output Control/Monitor
        constexpr uint32_t SCLI = (1U << 1);  ///< SCL Line Monitor
        constexpr uint32_t SDAI = (1U << 0);  ///< SDA Line Monitor
    }

    /// ICCR2 Register bits
    namespace iccr2_bits {
        constexpr uint32_t BBSY = (1U << 7);  ///< Bus Busy Detection Flag
        constexpr uint32_t MST = (1U << 6);  ///< Master/Slave Mode
        constexpr uint32_t TRS = (1U << 5);  ///< Transmit/Receive Mode
        constexpr uint32_t Reserved = (1U << 0);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SP = (1U << 3);  ///< Stop Condition Issuance RequestNote: Writing to the SP bit is not possible while the setting of the BBSY flag is 0 (bus free state).Note: Do not set the SP bit to 1 while a restart condition is being issued.
        constexpr uint32_t RS = (1U << 2);  ///< Restart Condition Issuance RequestNote: Do not set the RS bit to 1 while issuing a stop condition.
        constexpr uint32_t ST = (1U << 1);  ///< Start Condition Issuance RequestSet the ST bit to 1 (start condition issuance request) when the BBSY flag is set to 0 (bus free state).
    }

    /// ICMR1 Register bits
    namespace icmr1_bits {
        constexpr uint32_t MTWP = (1U << 7);  ///< MST/TRS Write Protect
        constexpr uint32_t CKS = (3 << 4);  ///< Internal Reference Clock (fIIC) Selection ( fIIC = PCLKB / 2^CKS )
        constexpr uint32_t BCWP = (1U << 3);  ///< BC Write Protect(This bit is read as 1.)
        constexpr uint32_t BC = (3 << 0);  ///< Bit Counter
    }

    /// ICMR2 Register bits
    namespace icmr2_bits {
        constexpr uint32_t DLCS = (1U << 7);  ///< SDA Output Delay Clock Source Selection
        constexpr uint32_t SDDL = (3 << 4);  ///< SDA Output Delay Counter
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TMOH = (1U << 2);  ///< Timeout H Count Control
        constexpr uint32_t TMOL = (1U << 1);  ///< Timeout L Count Control
        constexpr uint32_t TMOS = (1U << 0);  ///< Timeout Detection Time Selection
    }

    /// ICMR3 Register bits
    namespace icmr3_bits {
        constexpr uint32_t SMBE = (1U << 7);  ///< SMBus/I2C Bus Selection
        constexpr uint32_t WAIT = (1U << 6);  ///< WAITNote: When the value of the WAIT bit is to be read, be sure to read the ICDRR beforehand.
        constexpr uint32_t RDRFS = (1U << 5);  ///< RDRF Flag Set Timing Selection
        constexpr uint32_t ACKWP = (1U << 4);  ///< ACKBT Write Protect
        constexpr uint32_t ACKBT = (1U << 3);  ///< Transmit Acknowledge
        constexpr uint32_t ACKBR = (1U << 2);  ///< Receive Acknowledge
        constexpr uint32_t NF = (2 << 0);  ///< Noise Filter Stage Selection
    }

    /// ICFER Register bits
    namespace icfer_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SCLE = (1U << 6);  ///< SCL Synchronous Circuit Enable
        constexpr uint32_t NFE = (1U << 5);  ///< Digital Noise Filter Circuit Enable
        constexpr uint32_t NACKE = (1U << 4);  ///< NACK Reception Transfer Suspension Enable
        constexpr uint32_t SALE = (1U << 3);  ///< Slave Arbitration-Lost Detection Enable
        constexpr uint32_t NALE = (1U << 2);  ///< NACK Transmission Arbitration-Lost Detection Enable
        constexpr uint32_t MALE = (1U << 1);  ///< Master Arbitration-Lost Detection Enable
        constexpr uint32_t TMOE = (1U << 0);  ///< Timeout Function Enable
    }

    /// ICSER Register bits
    namespace icser_bits {
        constexpr uint32_t HOAE = (1U << 7);  ///< Host Address Enable
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DIDE = (1U << 5);  ///< Device-ID Address Detection Enable
        constexpr uint32_t GCAE = (1U << 3);  ///< General Call Address Enable
        constexpr uint32_t SAR2E = (1U << 2);  ///< Slave Address Register 2 Enable
        constexpr uint32_t SAR1E = (1U << 1);  ///< Slave Address Register 1 Enable
        constexpr uint32_t SAR0E = (1U << 0);  ///< Slave Address Register 0 Enable
    }

    /// ICIER Register bits
    namespace icier_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Data Empty Interrupt Request Enable
        constexpr uint32_t TEIE = (1U << 6);  ///< Transmit End Interrupt Request Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receive Data Full Interrupt Request Enable
        constexpr uint32_t NAKIE = (1U << 4);  ///< NACK Reception Interrupt Request Enable
        constexpr uint32_t SPIE = (1U << 3);  ///< Stop Condition Detection Interrupt Request Enable
        constexpr uint32_t STIE = (1U << 2);  ///< Start Condition Detection Interrupt Request Enable
        constexpr uint32_t ALIE = (1U << 1);  ///< Arbitration-Lost Interrupt Request Enable
        constexpr uint32_t TMOIE = (1U << 0);  ///< Timeout Interrupt Request Enable
    }

    /// ICSR1 Register bits
    namespace icsr1_bits {
        constexpr uint32_t HOA = (1U << 7);  ///< Host Address Detection Flag
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DID = (1U << 5);  ///< Device-ID Address Detection Flag
        constexpr uint32_t GCA = (1U << 3);  ///< General Call Address Detection Flag
        constexpr uint32_t AAS2 = (1U << 2);  ///< Slave Address 2 Detection Flag
        constexpr uint32_t AAS1 = (1U << 1);  ///< Slave Address 1 Detection Flag
        constexpr uint32_t AAS0 = (1U << 0);  ///< Slave Address 0 Detection Flag
    }

    /// ICSR2 Register bits
    namespace icsr2_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t TEND = (1U << 6);  ///< Transmit End Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Full Flag
        constexpr uint32_t NACKF = (1U << 4);  ///< NACK Detection Flag
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Condition Detection Flag
        constexpr uint32_t START = (1U << 2);  ///< Start Condition Detection Flag
        constexpr uint32_t AL = (1U << 1);  ///< Arbitration-Lost Flag
        constexpr uint32_t TMOF = (1U << 0);  ///< Timeout Detection Flag
    }

    /// SARL Register bits
    namespace sarl_bits {
        constexpr uint32_t SVA = (8 << 0);  ///< A slave address is set.7-Bit Address = SVA[7:1] 10-Bit Address = { SVA9,SVA8,SVA[7:0] }
    }

    /// SARU Register bits
    namespace saru_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SVA9 = (1U << 2);  ///< 10-Bit Address(bit9)
        constexpr uint32_t SVA8 = (1U << 1);  ///< 10-Bit Address(bit8)
        constexpr uint32_t FS = (1U << 0);  ///< 7-Bit/10-Bit Address Format Selection
    }

    /// ICBRL Register bits
    namespace icbrl_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 111. The write value should be 111.
        constexpr uint32_t BRL = (5 << 0);  ///< Bit Rate Low-Level Period(Low-level period of SCL clock)
    }

    /// ICBRH Register bits
    namespace icbrh_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 111. The write value should be 111.
        constexpr uint32_t BRH = (5 << 0);  ///< Bit Rate High-Level Period(High-level period of SCL clock)
    }

    /// ICDRT Register bits
    namespace icdrt_bits {
        constexpr uint32_t ICDRT = (8 << 0);  ///< 8-bit read-write register that stores transmit data.
    }

    /// ICDRR Register bits
    namespace icdrr_bits {
        constexpr uint32_t ICDRR = (8 << 0);  ///< 8-bit register that stores the received data
    }

}

// ============================================================================
// MMF Peripheral
// ============================================================================

namespace mmf {
    /// Base addresses
    constexpr uint32_t MMF_BASE = 0x40001000;

    /// MMF Register structure
    struct Registers {
        volatile uint32_t MMSFR;  ///< Offset: 0x00 - MemMirror Special Function Register
        volatile uint32_t MMEN;  ///< Offset: 0x04 - MemMirror Enable Register
    };

    /// Peripheral instances
    inline Registers* MMF = reinterpret_cast<Registers*>(MMF_BASE);

    // Bit definitions
    /// MMSFR Register bits
    namespace mmsfr_bits {
        constexpr uint32_t KEY = (8 << 24);  ///< MMSFR Key Code
        constexpr uint32_t Reserved = (7 << 0);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t MEMMIRADDR = (16 << 7);  ///< Specifies the memory mirror address.NOTE: A value cannot be set in the low-order 7 bits. These bits are fixed to 0.
    }

    /// MMEN Register bits
    namespace mmen_bits {
        constexpr uint32_t KEY = (8 << 24);  ///< MMEN Key Code
        constexpr uint32_t Reserved = (23 << 1);  ///< These bits are read as 00000000000000000000000. The write value should be 00000000000000000000000.
        constexpr uint32_t EN = (1U << 0);  ///< Memory Mirror Function Enable
    }

}

// ============================================================================
// MMPU Peripheral
// ============================================================================

namespace mmpu {
    /// Base addresses
    constexpr uint32_t MMPU_BASE = 0x40000000;

    /// MMPU Register structure
    struct Registers {
        volatile uint32_t MMPUCTLA;  ///< Offset: 0x00 - Bus Master MPU Control Register
        volatile uint32_t MMPUPTA;  ///< Offset: 0x102 - Group A Protection of Register
        volatile uint32_t MMPUACA;  ///< Offset: 0x200 - Group A Region %s Access Control Register (renamed from MMPUACA)
        volatile uint32_t MMPUSA;  ///< Offset: 0x204 - Group A Region %s Start Address Register (renamed from MMPUSA)
        volatile uint32_t MMPUEA;  ///< Offset: 0x208 - Group A Region %s End Address Register (renamed from MMPUEA)
    };

    /// Peripheral instances
    inline Registers* MMPU = reinterpret_cast<Registers*>(MMPU_BASE);

    // Bit definitions
    /// MMPUCTLA Register bits
    namespace mmpuctla_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t OAD = (1U << 1);  ///< Operation After Detection
        constexpr uint32_t ENABLE = (1U << 0);  ///< Master Group Enable
    }

    /// MMPUPTA Register bits
    namespace mmpupta_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register(MMPUSAn, MMPUEAn, MMPUACAn and MMPUCTLA )
    }

    /// MMPUACA Register bits
    namespace mmpuaca_bits {
        constexpr uint32_t Reserved = (13 << 3);  ///< These bits are read as 0000000000000. The write value should be 0000000000000.
        constexpr uint32_t WP = (1U << 2);  ///< Write protection
        constexpr uint32_t RP = (1U << 1);  ///< Read protection
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable
    }

    /// MMPUSA Register bits
    namespace mmpusa_bits {
        constexpr uint32_t MMPUSA = (32 << 0);  ///< Address where the region starts, for use in region determination.NOTE: The low-order 2 bits are fixed to 0.
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 00. The write value should be 00.
    }

    /// MMPUEA Register bits
    namespace mmpuea_bits {
        constexpr uint32_t MMPUEA = (32 << 0);  ///< Region end address registerAddress where the region end, for use in region determination.NOTE: The low-order 2 bits are fixed to 1.
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 11. The write value should be 11.
    }

}

// ============================================================================
// SMPU Peripheral
// ============================================================================

namespace smpu {
    /// Base addresses
    constexpr uint32_t SMPU_BASE = 0x40000C00;

    /// SMPU Register structure
    struct Registers {
        volatile uint32_t SMPUCTL;  ///< Offset: 0x00 - Slave MPU Control Register
        volatile uint32_t SMPUMBIU;  ///< Offset: 0x10 - Access Control Register for MBIU
        volatile uint32_t SMPUFBIU;  ///< Offset: 0x14 - Access Control Register for FBIU
        volatile uint32_t SMPUSRAM0;  ///< Offset: 0x18 - Access Control Register for SRAM
        volatile uint32_t SMPUPBIU;  ///< Offset: 0x20 - Access Control Register for P%sBIU (renamed from SMPUPBIU)
    };

    /// Peripheral instances
    inline Registers* SMPU = reinterpret_cast<Registers*>(SMPU_BASE);

    // Bit definitions
    /// SMPUCTL Register bits
    namespace smpuctl_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code This bit is used to enable or disable writing of the PROTECT and OAD bit.
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PROTECT = (1U << 1);  ///< Protection of register
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after detection
    }

    /// SMPUMBIU Register bits
    namespace smpumbiu_bits {
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
    }

    /// SMPUFBIU Register bits
    namespace smpufbiu_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUSRAM0 Register bits
    namespace smpusram0_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUPBIU Register bits
    namespace smpupbiu_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read protection
    }

}

// ============================================================================
// SPMON Peripheral
// ============================================================================

namespace spmon {
    /// Base addresses
    constexpr uint32_t SPMON_BASE = 0x40000D00;

    /// SPMON Register structure
    struct Registers {
        volatile uint32_t MSPMPUOAD;  ///< Offset: 0x00 - Stack Pointer Monitor Operation After Detection Register
        volatile uint32_t MSPMPUCTL;  ///< Offset: 0x04 - Stack Pointer Monitor Access Control Register
        volatile uint32_t MSPMPUPT;  ///< Offset: 0x06 - Stack Pointer Monitor Protection Register
        volatile uint32_t MSPMPUSA;  ///< Offset: 0x08 - Main Stack Pointer Monitor Start Address Register
        volatile uint32_t MSPMPUEA;  ///< Offset: 0x0C - Main Stack Pointer Monitor End Address Register
        volatile uint32_t PSPMPUOAD;  ///< Offset: 0x10 - Stack Pointer Monitor Operation After Detection Register
        volatile uint32_t PSPMPUCTL;  ///< Offset: 0x14 - Stack Pointer Monitor Access Control Register
        volatile uint32_t PSPMPUPT;  ///< Offset: 0x16 - Stack Pointer Monitor Protection Register
        volatile uint32_t PSPMPUSA;  ///< Offset: 0x18 - Process Stack Pointer Monitor Start Address Register
        volatile uint32_t PSPMPUEA;  ///< Offset: 0x1C - Process Stack Pointer Monitor End Address Register
    };

    /// Peripheral instances
    inline Registers* SPMON = reinterpret_cast<Registers*>(SPMON_BASE);

    // Bit definitions
    /// MSPMPUOAD Register bits
    namespace mspmpuoad_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after detection
    }

    /// MSPMPUCTL Register bits
    namespace mspmpuctl_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ERROR = (1U << 8);  ///< SP_main monitor error flag
        constexpr uint32_t ENABLE = (1U << 0);  ///< SP_main monitor enable
    }

    /// MSPMPUPT Register bits
    namespace mspmpupt_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register (MSPMPUAC, MSPMPUSA and MSPMPUSE)
    }

    /// MSPMPUSA Register bits
    namespace mspmpusa_bits {
        constexpr uint32_t MSPMPUSA = (32 << 0);  ///< Region start address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00000-0x200FFFFC The low-order 2 bits are fixed to 0.
    }

    /// MSPMPUEA Register bits
    namespace mspmpuea_bits {
        constexpr uint32_t MSPMPUEA = (32 << 0);  ///< Region end address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00003-0x200FFFFF The low-order 2 bits are fixed to 1.
    }

    /// PSPMPUOAD Register bits
    namespace pspmpuoad_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after detection
    }

    /// PSPMPUCTL Register bits
    namespace pspmpuctl_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ERROR = (1U << 8);  ///< SP_process monitor error flag
        constexpr uint32_t ENABLE = (1U << 0);  ///< SP_process monitor enable
    }

    /// PSPMPUPT Register bits
    namespace pspmpupt_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register (PSPMPUAC, PSPMPUSA and PSPMPUSE)
    }

    /// PSPMPUSA Register bits
    namespace pspmpusa_bits {
        constexpr uint32_t PSPMPUSA = (32 << 0);  ///< Region start address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00000-0x200FFFFC The low-order 2 bits are fixed to 0.
    }

    /// PSPMPUEA Register bits
    namespace pspmpuea_bits {
        constexpr uint32_t PSPMPUEA = (32 << 0);  ///< Region end address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00003-0x200FFFFF The low-order 2 bits are fixed to 1.
    }

}

// ============================================================================
// SRAM Peripheral
// ============================================================================

namespace sram {
    /// Base addresses
    constexpr uint32_t SRAM_BASE = 0x40002000;

    /// SRAM Register structure
    struct Registers {
        volatile uint32_t PARIOAD;  ///< Offset: 0x00 - SRAM Parity Error Operation After Detection Register
        volatile uint32_t SRAMPRCR;  ///< Offset: 0x04 - SRAM Protection Register
        volatile uint32_t ECCMODE;  ///< Offset: 0xC0 - ECC Operating Mode Control Register
        volatile uint32_t ECC2STS;  ///< Offset: 0xC1 - ECC 2-Bit Error Status Register
        volatile uint32_t ECC1STSEN;  ///< Offset: 0xC2 - ECC 1-Bit Error Information Update Enable Register
        volatile uint32_t ECC1STS;  ///< Offset: 0xC3 - ECC 1-Bit Error Status Register
        volatile uint32_t ECCPRCR;  ///< Offset: 0xC4 - ECC Protection Register
        volatile uint32_t ECCPRCR2;  ///< Offset: 0xD0 - ECC Protection Register 2
        volatile uint32_t ECCETST;  ///< Offset: 0xD4 - ECC Test Control Register
        volatile uint32_t ECCOAD;  ///< Offset: 0xD8 - SRAM ECC Error Operation After Detection Register
    };

    /// Peripheral instances
    inline Registers* SRAM = reinterpret_cast<Registers*>(SRAM_BASE);

    // Bit definitions
    /// PARIOAD Register bits
    namespace parioad_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after Detection
    }

    /// SRAMPRCR Register bits
    namespace sramprcr_bits {
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
        constexpr uint32_t SRAMPRCR = (1U << 0);  ///< Register Write Control
    }

    /// ECCMODE Register bits
    namespace eccmode_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t ECCMOD = (2 << 0);  ///< ECC Operating Mode Select
    }

    /// ECC2STS Register bits
    namespace ecc2sts_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ECC2ERR = (1U << 0);  ///< ECC 2-Bit Error Status
    }

    /// ECC1STSEN Register bits
    namespace ecc1stsen_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t E1STSEN = (1U << 0);  ///< ECC 1-Bit Error Information Update Enable
    }

    /// ECC1STS Register bits
    namespace ecc1sts_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ECC1ERR = (1U << 0);  ///< ECC 1-Bit Error Status
    }

    /// ECCPRCR Register bits
    namespace eccprcr_bits {
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
        constexpr uint32_t ECCPRCR = (1U << 0);  ///< Register Write Control
    }

    /// ECCPRCR2 Register bits
    namespace eccprcr2_bits {
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
        constexpr uint32_t ECCPRCR2 = (1U << 0);  ///< Register Write Control
    }

    /// ECCETST Register bits
    namespace eccetst_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t TSTBYP = (1U << 0);  ///< ECC Bypass Select
    }

    /// ECCOAD Register bits
    namespace eccoad_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after Detection
    }

}

// ============================================================================
// BUS Peripheral
// ============================================================================

namespace bus {
    /// Base addresses
    constexpr uint32_t BUS_BASE = 0x40003000;

    /// BUS Register structure
    struct Registers {
        volatile uint32_t BUSMCNTSYS;  ///< Offset: 0x1008 - Master Bus Control Register SYS
        volatile uint32_t BUSMCNTDMA;  ///< Offset: 0x100C - Master Bus Control Register DMA
        volatile uint32_t BUSSCNTFLI;  ///< Offset: 0x1100 - Slave Bus Control Register FLI
        volatile uint32_t BUSSCNTRAM0;  ///< Offset: 0x110C - Slave Bus Control Register RAM0
        volatile uint32_t BUSSCNT;  ///< Offset: 0x1114 - Slave Bus Control Register %s (renamed from BUSSCNT)
        volatile uint32_t BUSSCNTP4B;  ///< Offset: 0x1120 - Slave Bus Control Register P4B
        volatile uint32_t BUSSCNTP6B;  ///< Offset: 0x1128 - Slave Bus Control Register P6B
        volatile uint32_t BUSSCNTFBU;  ///< Offset: 0x1130 - Slave Bus Control Register FBU
        volatile uint32_t BUSERRADD;  ///< Offset: 0x1820 - Bus Error Address Register %s (renamed from BUSERRADD)
        volatile uint32_t BUSERRSTAT;  ///< Offset: 0x1824 - Bus Error Status Register %s (renamed from BUSERRSTAT)
    };

    /// Peripheral instances
    inline Registers* BUS = reinterpret_cast<Registers*>(BUS_BASE);

    // Bit definitions
    /// BUSMCNTSYS Register bits
    namespace busmcntsys_bits {
        constexpr uint32_t IERES = (1U << 15);  ///< Ignore Error Responses
        constexpr uint32_t Reserved = (15 << 0);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
    }

    /// BUSMCNTDMA Register bits
    namespace busmcntdma_bits {
        constexpr uint32_t IERES = (1U << 15);  ///< Ignore Error Responses
        constexpr uint32_t Reserved = (15 << 0);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
    }

    /// BUSSCNTFLI Register bits
    namespace busscntfli_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration MethodSpecify the priority between groups
    }

    /// BUSSCNTRAM0 Register bits
    namespace busscntram0_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration MethodSpecify the priority between groups
    }

    /// BUSSCNT Register bits
    namespace busscnt_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration MethodSpecify the priority between groups
    }

    /// BUSSCNTP4B Register bits
    namespace busscntp4b_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration MethodSpecify the priority between groups
    }

    /// BUSSCNTP6B Register bits
    namespace busscntp6b_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration MethodSpecify the priority between groups
    }

    /// BUSSCNTFBU Register bits
    namespace busscntfbu_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration MethodSpecify the priority between groups
    }

    /// BUSERRADD Register bits
    namespace buserradd_bits {
        constexpr uint32_t BERAD = (32 << 0);  ///< Bus Error AddressWhen a bus error occurs, It stores an error address.
    }

    /// BUSERRSTAT Register bits
    namespace buserrstat_bits {
        constexpr uint32_t ERRSTAT = (1U << 7);  ///< Bus Error StatusWhen bus error assert, error flag occurs.
        constexpr uint32_t Reserved = (6 << 1);  ///< These bits are read as 000000.
        constexpr uint32_t ACCSTAT = (1U << 0);  ///< Error access statusThe status at the time of the error
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0x4001B000;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t DBGSTR;  ///< Offset: 0x00 - Debug Status Register
        volatile uint32_t DBGSTOPCR;  ///< Offset: 0x10 - Debug Stop Control Register
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// DBGSTR Register bits
    namespace dbgstr_bits {
        constexpr uint32_t Reserved = (28 << 0);  ///< These bits are read as 0000000000000000000000000000.
        constexpr uint32_t CDBGPWRUPACK = (1U << 29);  ///< Debug power-up acknowledge
        constexpr uint32_t CDBGPWRUPREQ = (1U << 28);  ///< Debug power-up request
    }

    /// DBGSTOPCR Register bits
    namespace dbgstopcr_bits {
        constexpr uint32_t Reserved = (14 << 2);  ///< These bits are read as 00000000000000. The write value should be 00000000000000.
        constexpr uint32_t DBGSTOP_RECCR = (1U << 25);  ///< Mask bit for SRAM ECC error reset/interrupt
        constexpr uint32_t DBGSTOP_RPER = (1U << 24);  ///< Mask bit for RAM parity error reset/interrupt
        constexpr uint32_t DBGSTOP_LVD = (3 << 16);  ///< b18: Mask bit for LVD2 reset/interrupt (0:enable / 1:Mask)b17: Mask bit for LVD1 reset/interrupt (0:enable / 1:Mask)b16: Mask bit for LVD0 reset (0:enable / 1:Mask)
        constexpr uint32_t DBGSTOP_WDT = (1U << 1);  ///< Mask bit for WDT reset/interrupt
        constexpr uint32_t DBGSTOP_IWDT = (1U << 0);  ///< Mask bit for IWDT reset/interrupt
    }

}

// ============================================================================
// DTC Peripheral
// ============================================================================

namespace dtc {
    /// Base addresses
    constexpr uint32_t DTC_BASE = 0x40005400;

    /// DTC Register structure
    struct Registers {
        volatile uint32_t DTCCR;  ///< Offset: 0x00 - DTC Control Register
        volatile uint32_t DTCVBR;  ///< Offset: 0x04 - DTC Vector Base Register
        volatile uint32_t DTCST;  ///< Offset: 0x0C - DTC Module Start Register
        volatile uint32_t DTCSTS;  ///< Offset: 0x0E - DTC Status Register
    };

    /// Peripheral instances
    inline Registers* DTC = reinterpret_cast<Registers*>(DTC_BASE);

    // Bit definitions
    /// DTCCR Register bits
    namespace dtccr_bits {
        constexpr uint32_t Reserved = (3 << 0);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t RRS = (1U << 4);  ///< DTC Transfer Information Read Skip Enable.
    }

    /// DTCVBR Register bits
    namespace dtcvbr_bits {
        constexpr uint32_t DTCVBR = (32 << 0);  ///< DTC Vector Base Address.Note: A value cannot be set in the lower-order 10 bits. These bits are fixed to 0.
    }

    /// DTCST Register bits
    namespace dtcst_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t DTCST = (1U << 0);  ///< DTC Module Start
    }

    /// DTCSTS Register bits
    namespace dtcsts_bits {
        constexpr uint32_t ACT = (1U << 15);  ///< DTC Active Flag
        constexpr uint32_t Reserved = (7 << 8);  ///< These bits are read as 0000000.
        constexpr uint32_t VECN = (8 << 0);  ///< DTC-Activating Vector Number MonitoringThese bits indicate the vector number for the activating source when DTC transfer is in progress.The value is only valid if DTC transfer is in progress (the value of the ACT flag is 1)
    }

}

// ============================================================================
// ICU Peripheral
// ============================================================================

namespace icu {
    /// Base addresses
    constexpr uint32_t ICU_BASE = 0x40006000;

    /// ICU Register structure
    struct Registers {
        volatile uint32_t IRQCR;  ///< Offset: 0x00 - IRQ Control Register %s (renamed from IRQCR)
        volatile uint32_t NMISR;  ///< Offset: 0x140 - Non-Maskable Interrupt Status Register
        volatile uint32_t NMIER;  ///< Offset: 0x120 - Non-Maskable Interrupt Enable Register
        volatile uint32_t NMICLR;  ///< Offset: 0x130 - Non-Maskable Interrupt Status Clear Register
        volatile uint32_t NMICR;  ///< Offset: 0x100 - NMI Pin Interrupt Control Register
        volatile uint32_t WUPEN;  ///< Offset: 0x1A0 - Wake Up Interrupt Enable Register
        volatile uint32_t SELSR0;  ///< Offset: 0x200 - SYS Event Link Setting Register
        volatile uint32_t IELSR;  ///< Offset: 0x300 - ICU Event Link Setting Register %s (renamed from IELSR)
    };

    /// Peripheral instances
    inline Registers* ICU = reinterpret_cast<Registers*>(ICU_BASE);

    // Bit definitions
    /// IRQCR Register bits
    namespace irqcr_bits {
        constexpr uint32_t FLTEN = (1U << 7);  ///< IRQ Digital Filter Enable
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t FCLKSEL = (2 << 4);  ///< IRQi Digital Filter Sampling Clock Select
        constexpr uint32_t IRQMD = (2 << 0);  ///< IRQ Detection Sense Select
    }

    /// NMISR Register bits
    namespace nmisr_bits {
        constexpr uint32_t Reserved = (2 << 4);  ///< These bits are read as 00.
        constexpr uint32_t SPEST = (1U << 12);  ///< CPU Stack Pointer Monitor Interrupt Status Flag
        constexpr uint32_t BUSMST = (1U << 11);  ///< MPU Bus Master Error Interrupt Status Flag
        constexpr uint32_t BUSSST = (1U << 10);  ///< MPU Bus Slave Error Interrupt Status Flag
        constexpr uint32_t RECCST = (1U << 9);  ///< SRAM ECC Error Interrupt Status Flag
        constexpr uint32_t RPEST = (1U << 8);  ///< RAM Parity Error Interrupt Status Flag
        constexpr uint32_t NMIST = (1U << 7);  ///< NMI Status Flag
        constexpr uint32_t OSTST = (1U << 6);  ///< Oscillation Stop Detection Interrupt Status Flag
        constexpr uint32_t LVD2ST = (1U << 3);  ///< Voltage-Monitoring 2 Interrupt Status Flag
        constexpr uint32_t LVD1ST = (1U << 2);  ///< Voltage-Monitoring 1 Interrupt Status Flag
        constexpr uint32_t WDTST = (1U << 1);  ///< WDT Underflow/Refresh Error Status Flag
        constexpr uint32_t IWDTST = (1U << 0);  ///< IWDT Underflow/Refresh Error Status Flag
    }

    /// NMIER Register bits
    namespace nmier_bits {
        constexpr uint32_t Reserved = (2 << 4);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t SPEEN = (1U << 12);  ///< CPU Stack Pointer Monitor Interrupt Enable
        constexpr uint32_t BUSMEN = (1U << 11);  ///< MPU Bus Master Error Interrupt Enable
        constexpr uint32_t BUSSEN = (1U << 10);  ///< MPU Bus Slave Error Interrupt Enable
        constexpr uint32_t RECCEN = (1U << 9);  ///< SRAM ECC Error Interrupt Enable
        constexpr uint32_t RPEEN = (1U << 8);  ///< RAM Parity Error Interrupt Enable
        constexpr uint32_t NMIEN = (1U << 7);  ///< NMI Pin Interrupt Enable
        constexpr uint32_t OSTEN = (1U << 6);  ///< Oscillation Stop Detection Interrupt Enable
        constexpr uint32_t LVD2EN = (1U << 3);  ///< Voltage-Monitoring 2 Interrupt Enable
        constexpr uint32_t LVD1EN = (1U << 2);  ///< Voltage-Monitoring 1 Interrupt Enable
        constexpr uint32_t WDTEN = (1U << 1);  ///< WDT Underflow/Refresh Error Interrupt Enable
        constexpr uint32_t IWDTEN = (1U << 0);  ///< IWDT Underflow/Refresh Error Interrupt Enable
    }

    /// NMICLR Register bits
    namespace nmiclr_bits {
        constexpr uint32_t Reserved = (2 << 4);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t SPECLR = (1U << 12);  ///< CPU Stack Pointer Monitor Interrupt Clear
        constexpr uint32_t BUSMCLR = (1U << 11);  ///< MPU Bus Master Error Interrupt Clear
        constexpr uint32_t BUSSCLR = (1U << 10);  ///< MPU Bus Slave Error Interrupt Clear
        constexpr uint32_t RECCCLR = (1U << 9);  ///< SRAM ECC Error Interrupt Clear
        constexpr uint32_t RPECLR = (1U << 8);  ///< SRAM Parity Error Clear
        constexpr uint32_t NMICLR = (1U << 7);  ///< NMIST Clear
        constexpr uint32_t OSTCLR = (1U << 6);  ///< OSTST Clear
        constexpr uint32_t LVD2CLR = (1U << 3);  ///< LVD2ST Clear
        constexpr uint32_t LVD1CLR = (1U << 2);  ///< LVD1ST Clear
        constexpr uint32_t WDTCLR = (1U << 1);  ///< WDTST Clear
        constexpr uint32_t IWDTCLR = (1U << 0);  ///< IWDTST Clear
    }

    /// NMICR Register bits
    namespace nmicr_bits {
        constexpr uint32_t NFLTEN = (1U << 7);  ///< NMI Digital Filter Enable
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t NFCLKSEL = (2 << 4);  ///< NMI Digital Filter Sampling Clock Select
        constexpr uint32_t NMIMD = (1U << 0);  ///< NMI Detection Set
    }

    /// WUPEN Register bits
    namespace wupen_bits {
        constexpr uint32_t IIC0WUPEN = (1U << 31);  ///< IIC0 address match interrupt S/W standby returns enable bit
        constexpr uint32_t AGT1CBWUPEN = (1U << 30);  ///< AGT1 compare match B interrupt S/W standby returns enable bit
        constexpr uint32_t AGT1CAWUPEN = (1U << 29);  ///< AGT1 compare match A interrupt S/W standby returns enable bit
        constexpr uint32_t AGT1UDWUPEN = (1U << 28);  ///< AGT1 underflow interrupt S/W standby returns enable bit
        constexpr uint32_t USBFSWUPEN = (1U << 27);  ///< USBFS interrupt S/W standby returns enable bit
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t RTCPRDWUPEN = (1U << 25);  ///< RCT period interrupt S/W standby returns enable bit
        constexpr uint32_t RTCALMWUPEN = (1U << 24);  ///< RTC alarm interrupt S/W standby returns enable bit
        constexpr uint32_t ACMPLP0WUPEN = (1U << 23);  ///< ACMPLP0 interrupt S/W standby returns enable bit
        constexpr uint32_t LVD2WUPEN = (1U << 19);  ///< LVD2 interrupt S/W standby returns enable bit
        constexpr uint32_t LVD1WUPEN = (1U << 18);  ///< LVD1 interrupt S/W standby returns enable bit
        constexpr uint32_t KEYWUPEN = (1U << 17);  ///< Key interrupt S/W standby returns enable bit
        constexpr uint32_t IWDTWUPEN = (1U << 16);  ///< IWDT interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN7 = (1U << 7);  ///< IRQ7 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN6 = (1U << 6);  ///< IRQ6 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN5 = (1U << 5);  ///< IRQ5 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN4 = (1U << 4);  ///< IRQ4 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN3 = (1U << 3);  ///< IRQ3 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN2 = (1U << 2);  ///< IRQ2 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN1 = (1U << 1);  ///< IRQ1 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN0 = (1U << 0);  ///< IRQ0 interrupt S/W standby returns enable bit
    }

    /// SELSR0 Register bits
    namespace selsr0_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t SELS = (8 << 0);  ///< SYS Event Link Select
    }

    /// IELSR Register bits
    namespace ielsr_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t DTCE = (1U << 24);  ///< DTC Activation Enable
        constexpr uint32_t IR = (1U << 16);  ///< Interrupt Status Flag
        constexpr uint32_t IELS = (8 << 0);  ///< ICU Event selection to NVICSet the number for the event signal to be linked .
    }

}

// ============================================================================
// SYSTEM Peripheral
// ============================================================================

namespace system {
    /// Base addresses
    constexpr uint32_t SYSTEM_BASE = 0x4001E000;

    /// SYSTEM Register structure
    struct Registers {
        volatile uint32_t SCKDIVCR;  ///< Offset: 0x20 - System Clock Division Control Register
        volatile uint32_t SCKSCR;  ///< Offset: 0x26 - System Clock Source Control Register
        volatile uint32_t MEMWAIT;  ///< Offset: 0x31 - Memory Wait Cycle Control Register
        volatile uint32_t MOSCCR;  ///< Offset: 0x32 - Main Clock Oscillator Control Register
        volatile uint32_t HOCOCR;  ///< Offset: 0x36 - High-Speed On-Chip Oscillator Control Register
        volatile uint32_t MOCOCR;  ///< Offset: 0x38 - Middle-Speed On-Chip Oscillator Control Register
        volatile uint32_t OSCSF;  ///< Offset: 0x3C - Oscillation Stabilization Flag Register
        volatile uint32_t CKOCR;  ///< Offset: 0x3E - Clock Out Control Register
        volatile uint32_t OSTDCR;  ///< Offset: 0x40 - Oscillation Stop Detection Control Register
        volatile uint32_t OSTDSR;  ///< Offset: 0x41 - Oscillation Stop Detection Status Register
        volatile uint32_t MOCOUTCR;  ///< Offset: 0x61 - MOCO User Trimming Control Register
        volatile uint32_t HOCOUTCR;  ///< Offset: 0x62 - HOCO User Trimming Control Register
        volatile uint32_t SDADCCKCR;  ///< Offset: 0xD1 - 24-bit Sigma-Delta A/D Converter Clock Control Register
        volatile uint32_t MOMCR;  ///< Offset: 0x413 - Main Clock Oscillator Mode Oscillation Control Register
        volatile uint32_t SOSCCR;  ///< Offset: 0x480 - Sub-clock Oscillator Control Register
        volatile uint32_t SOMCR;  ///< Offset: 0x481 - Sub-clock Oscillator Mode Control Register
        volatile uint32_t LOCOCR;  ///< Offset: 0x490 - Low-Speed On-Chip Oscillator Control Register
        volatile uint32_t LOCOUTCR;  ///< Offset: 0x492 - LOCO User Trimming Control Register
        volatile uint32_t MOSCWTCR;  ///< Offset: 0xA2 - Main Clock Oscillator Wait Control Register
        volatile uint32_t HOCOWTCR;  ///< Offset: 0xA5 - High-Speed On-Chip Oscillator Wait Control Register
        volatile uint32_t SBYCR;  ///< Offset: 0x0C - Standby Control Register
        volatile uint32_t MSTPCRA;  ///< Offset: 0x1C - Module Stop Control Register A
        volatile uint32_t SNZCR;  ///< Offset: 0x92 - Snooze Control Register
        volatile uint32_t SNZEDCR;  ///< Offset: 0x94 - Snooze End Control Register
        volatile uint32_t SNZREQCR;  ///< Offset: 0x98 - Snooze Request Control Register
        volatile uint32_t FLSTOP;  ///< Offset: 0x9E - Flash Operation Control Register
        volatile uint32_t OPCCR;  ///< Offset: 0xA0 - Operating Power Control Register
        volatile uint32_t SOPCCR;  ///< Offset: 0xAA - Sub Operating Power Control Register
        volatile uint32_t LVCMPCR;  ///< Offset: 0x417 - Voltage Monitor Circuit Control Register
        volatile uint32_t LVDLVLR;  ///< Offset: 0x418 - Voltage Detection Level Select Register
        volatile uint32_t LVD1CR0;  ///< Offset: 0x41A - Voltage Monitor 1 Circuit Control Register 0
        volatile uint32_t LVD2CR0;  ///< Offset: 0x41B - Voltage Monitor 2 Circuit Control Register 0
        volatile uint32_t LVD1CR1;  ///< Offset: 0xE0 - Voltage Monitor 1 Circuit Control Register 1
        volatile uint32_t LVD1SR;  ///< Offset: 0xE1 - Voltage Monitor 1 Circuit Status Register
        volatile uint32_t LVD2CR1;  ///< Offset: 0xE2 - Voltage Monitor 2 Circuit Control Register 1
        volatile uint32_t LVD2SR;  ///< Offset: 0xE3 - Voltage Monitor 2 Circuit Status Register
        volatile uint32_t SYOCDCR;  ///< Offset: 0x40E - System Control OCD Control Register
        volatile uint32_t PRCR;  ///< Offset: 0x3FE - Protect Register
        volatile uint32_t RSTSR0;  ///< Offset: 0x410 - Reset Status Register 0
        volatile uint32_t RSTSR2;  ///< Offset: 0x411 - Reset Status Register 2
        volatile uint32_t RSTSR1;  ///< Offset: 0xC0 - Reset Status Register 1
    };

    /// Peripheral instances
    inline Registers* SYSTEM = reinterpret_cast<Registers*>(SYSTEM_BASE);

    // Bit definitions
    /// SCKDIVCR Register bits
    namespace sckdivcr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t FCK = (3 << 28);  ///< Flash IF Clock (FCLK) Select
        constexpr uint32_t ICK = (3 << 24);  ///< System Clock (ICLK) Select
        constexpr uint32_t PCKB = (3 << 8);  ///< Peripheral Module Clock B (PCLKB) Select
        constexpr uint32_t PCKD = (3 << 0);  ///< Peripheral Module Clock D (PCLKD) Select
    }

    /// SCKSCR Register bits
    namespace sckscr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t CKSEL = (3 << 0);  ///< Clock Source Select
    }

    /// MEMWAIT Register bits
    namespace memwait_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t MEMWAIT = (1U << 0);  ///< Memory Wait Cycle Select
    }

    /// MOSCCR Register bits
    namespace mosccr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t MOSTP = (1U << 0);  ///< Main Clock Oscillator Stop
    }

    /// HOCOCR Register bits
    namespace hococr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t HCSTP = (1U << 0);  ///< HOCO Stop
    }

    /// MOCOCR Register bits
    namespace mococr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t MCSTP = (1U << 0);  ///< MOCO Stop
    }

    /// OSCSF Register bits
    namespace oscsf_bits {
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00.
        constexpr uint32_t MOSCSF = (1U << 3);  ///< Main Clock Oscillation Stabilization Flag
        constexpr uint32_t HOCOSF = (1U << 0);  ///< HOCO Clock Oscillation Stabilization FlagNOTE: The HOCOSF bit value after a reset is 1 when the OFS1.HOCOEN bit is 0. It is 0 when the OFS1.HOCOEN bit is 1.
    }

    /// CKOCR Register bits
    namespace ckocr_bits {
        constexpr uint32_t CKOEN = (1U << 7);  ///< Clock out enable
        constexpr uint32_t CKODIV = (3 << 4);  ///< Clock out input frequency Division Select
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CKOSEL = (3 << 0);  ///< Clock out source select
    }

    /// OSTDCR Register bits
    namespace ostdcr_bits {
        constexpr uint32_t OSTDE = (1U << 7);  ///< Oscillation Stop Detection Function Enable
        constexpr uint32_t Reserved = (6 << 1);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t OSTDIE = (1U << 0);  ///< Oscillation Stop Detection Interrupt Enable
    }

    /// OSTDSR Register bits
    namespace ostdsr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t OSTDF = (1U << 0);  ///< Oscillation Stop Detection Flag
    }

    /// MOCOUTCR Register bits
    namespace mocoutcr_bits {
        constexpr uint32_t MOCOUTRM = (8 << 0);  ///< MOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original MOCO trimming bits
    }

    /// HOCOUTCR Register bits
    namespace hocoutcr_bits {
        constexpr uint32_t HOCOUTRM = (8 << 0);  ///< HOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original HOCO trimming bits
    }

    /// SDADCCKCR Register bits
    namespace sdadcckcr_bits {
        constexpr uint32_t SDADCCKEN = (1U << 7);  ///< 24-bit Sigma-Delta A/D Converter Clock Select
        constexpr uint32_t Reserved = (6 << 1);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t SDADCCKSEL = (1U << 0);  ///< 24-bit Sigma-Delta A/D Converter Clock Enable
    }

    /// MOMCR Register bits
    namespace momcr_bits {
        constexpr uint32_t Reserved = (3 << 0);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t MOSEL = (1U << 6);  ///< Main Clock Oscillator Switching
        constexpr uint32_t MODRV1 = (1U << 3);  ///< Main Clock Oscillator Drive Capability 1 Switching
    }

    /// SOSCCR Register bits
    namespace sosccr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t SOSTP = (1U << 0);  ///< Sub-Clock Oscillator Stop
    }

    /// SOMCR Register bits
    namespace somcr_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t SODRV = (2 << 0);  ///< Sub Clock Oscillator Drive Capability Switching
    }

    /// LOCOCR Register bits
    namespace lococr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t LCSTP = (1U << 0);  ///< LOCO Stop
    }

    /// LOCOUTCR Register bits
    namespace locoutcr_bits {
        constexpr uint32_t LOCOUTRM = (8 << 0);  ///< LOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original LOCO trimming bits
    }

    /// MOSCWTCR Register bits
    namespace moscwtcr_bits {
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t MSTS = (4 << 0);  ///< Main clock oscillator wait time setting
    }

    /// HOCOWTCR Register bits
    namespace hocowtcr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t HSTS = (3 << 0);  ///< HOCO wait time setting
    }

    /// SBYCR Register bits
    namespace sbycr_bits {
        constexpr uint32_t SSBY = (1U << 15);  ///< Software Standby
        constexpr uint32_t Reserved = (15 << 0);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
    }

    /// MSTPCRA Register bits
    namespace mstpcra_bits {
        constexpr uint32_t Reserved = (22 << 0);  ///< These bits are read as 1111111111111111111111. The write value should be 1111111111111111111111.
        constexpr uint32_t MSTPA22 = (1U << 22);  ///< Data Transfer Controller Module Stop
    }

    /// SNZCR Register bits
    namespace snzcr_bits {
        constexpr uint32_t SNZE = (1U << 7);  ///< Snooze Mode Enable
        constexpr uint32_t Reserved = (5 << 2);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SNZDTCEN = (1U << 1);  ///< DTC Enable in Snooze Mode
        constexpr uint32_t RXDREQEN = (1U << 0);  ///< RXD0 Snooze Request Enable NOTE: Do not set to 1 other than in asynchronous mode.
    }

    /// SNZEDCR Register bits
    namespace snzedcr_bits {
        constexpr uint32_t SCI0UMTED = (1U << 7);  ///< SCI0 address unmatch Snooze End EnableNote: Do not set to 1 other than in asynchronous mode.
        constexpr uint32_t Reserved = (2 << 5);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t AD0UMTED = (1U << 4);  ///< AD compare mismatch 0 Snooze End Enable
        constexpr uint32_t AD0MATED = (1U << 3);  ///< AD compare match 0 Snooze End Enable
        constexpr uint32_t DTCNZRED = (1U << 2);  ///< Not Last DTC transmission completion Snooze End Enable
        constexpr uint32_t DTCZRED = (1U << 1);  ///< Last DTC transmission completion Snooze End Enable
        constexpr uint32_t AGTUNFED = (1U << 0);  ///< AGT1 underflow Snooze End Enable
    }

    /// SNZREQCR Register bits
    namespace snzreqcr_bits {
        constexpr uint32_t Reserved = (9 << 8);  ///< These bits are read as 000000000. The write value should be 000000000.
        constexpr uint32_t SNZREQEN30 = (1U << 30);  ///< Snooze Request Enable 30Enable AGT1 compare match B snooze request
        constexpr uint32_t SNZREQEN29 = (1U << 29);  ///< Snooze Request Enable 29Enable AGT1 compare match A snooze request
        constexpr uint32_t SNZREQEN28 = (1U << 28);  ///< Snooze Request Enable 28Enable AGT1 underflow snooze request
        constexpr uint32_t SNZREQEN25 = (1U << 25);  ///< Snooze Request Enable 25Enable RTC period snooze request
        constexpr uint32_t SNZREQEN24 = (1U << 24);  ///< Snooze Request Enable 24Enable RTC alarm snooze request
        constexpr uint32_t SNZREQEN23 = (1U << 23);  ///< Snooze Request Enable 24Enable RTC alarm snooze request
        constexpr uint32_t SNZREQEN17 = (1U << 17);  ///< Snooze Request Enable 17Enable KINT snooze request
        constexpr uint32_t SNZREQEN7 = (1U << 7);  ///< Snooze Request Enable 7Enable IRQ7 pin snooze request
        constexpr uint32_t SNZREQEN6 = (1U << 6);  ///< Snooze Request Enable 6Enable IRQ6 pin snooze request
        constexpr uint32_t SNZREQEN5 = (1U << 5);  ///< Snooze Request Enable 5Enable IRQ5 pin snooze request
        constexpr uint32_t SNZREQEN4 = (1U << 4);  ///< Snooze Request Enable 4Enable IRQ4 pin snooze request
        constexpr uint32_t SNZREQEN3 = (1U << 3);  ///< Snooze Request Enable 3Enable IRQ3 pin snooze request
        constexpr uint32_t SNZREQEN2 = (1U << 2);  ///< Snooze Request Enable 2Enable IRQ2 pin snooze request
        constexpr uint32_t SNZREQEN1 = (1U << 1);  ///< Snooze Request Enable 1Enable IRQ1 pin snooze request
        constexpr uint32_t SNZREQEN0 = (1U << 0);  ///< Snooze Request Enable 0Enable IRQ0 pin snooze request
    }

    /// FLSTOP Register bits
    namespace flstop_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t FLSTPF = (1U << 4);  ///< Flash Memory Operation Status Flag
        constexpr uint32_t FLSTOP = (1U << 0);  ///< Selecting ON/OFF of the Flash Memory Operation
    }

    /// OPCCR Register bits
    namespace opccr_bits {
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t OPCMTSF = (1U << 4);  ///< Operating Power Control Mode Transition Status Flag
        constexpr uint32_t OPCM = (2 << 0);  ///< Operating Power Control Mode Select
    }

    /// SOPCCR Register bits
    namespace sopccr_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t SOPCMTSF = (1U << 4);  ///< Sub Operating Power Control Mode Transition Status Flag
        constexpr uint32_t SOPCM = (1U << 0);  ///< Sub Operating Power Control Mode Select
    }

    /// LVCMPCR Register bits
    namespace lvcmpcr_bits {
        constexpr uint32_t Reserved = (5 << 0);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t LVD2E = (1U << 6);  ///< Voltage Detection 2 Enable
        constexpr uint32_t LVD1E = (1U << 5);  ///< Voltage Detection 1 Enable
    }

    /// LVDLVLR Register bits
    namespace lvdlvlr_bits {
        constexpr uint32_t LVD2LVL = (3 << 5);  ///< Voltage Detection 2 Level Select (Standard voltage during drop in voltage)
        constexpr uint32_t LVD1LVL = (5 << 0);  ///< Voltage Detection 1 Level Select (Standard voltage during drop in voltage)
    }

    /// LVD1CR0 Register bits
    namespace lvd1cr0_bits {
        constexpr uint32_t RN = (1U << 7);  ///< Voltage Monitor 1 Reset Negate Select
        constexpr uint32_t RI = (1U << 6);  ///< Voltage Monitor 1 Circuit Mode Select
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CMPE = (1U << 2);  ///< Voltage Monitor 1 Circuit Comparison Result Output Enable
        constexpr uint32_t RIE = (1U << 0);  ///< Voltage Monitor 1 Interrupt/ Reset Enable
    }

    /// LVD2CR0 Register bits
    namespace lvd2cr0_bits {
        constexpr uint32_t RN = (1U << 7);  ///< Voltage Monitor 2 Reset Negate Select
        constexpr uint32_t RI = (1U << 6);  ///< Voltage Monitor 2 Circuit Mode Select
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CMPE = (1U << 2);  ///< Voltage Monitor 2 Circuit Comparison Result Output Enable
        constexpr uint32_t RIE = (1U << 0);  ///< Voltage Monitor 2 Interrupt/Reset Enable
    }

    /// LVD1CR1 Register bits
    namespace lvd1cr1_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t IRQSEL = (1U << 2);  ///< Voltage Monitor 1 Interrupt Type Select
        constexpr uint32_t IDTSEL = (2 << 0);  ///< Voltage Monitor 1 Interrupt Generation Condition Select
    }

    /// LVD1SR Register bits
    namespace lvd1sr_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t MON = (1U << 1);  ///< Voltage Monitor 1 Signal Monitor Flag
        constexpr uint32_t DET = (1U << 0);  ///< Voltage Monitor 1 Voltage Change Detection Flag
    }

    /// LVD2CR1 Register bits
    namespace lvd2cr1_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t IRQSEL = (1U << 2);  ///< Voltage Monitor 2 Interrupt Type Select
        constexpr uint32_t IDTSEL = (2 << 0);  ///< Voltage Monitor 2 Interrupt Generation Condition Select
    }

    /// LVD2SR Register bits
    namespace lvd2sr_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t MON = (1U << 1);  ///< Voltage Monitor 2 Signal Monitor Flag
        constexpr uint32_t DET = (1U << 0);  ///< Voltage Monitor 2 Voltage Change Detection Flag
    }

    /// SYOCDCR Register bits
    namespace syocdcr_bits {
        constexpr uint32_t DBGEN = (1U << 7);  ///< Debugger Enable
        constexpr uint32_t Reserved = (7 << 0);  ///< These bits are read as 0000000. The write value should be 0000000.
    }

    /// PRCR Register bits
    namespace prcr_bits {
        constexpr uint32_t PRKEY = (8 << 8);  ///< PRKEY Key Code
        constexpr uint32_t Reserved = (1U << 2);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PRC3 = (1U << 3);  ///< Enables writing to the registers related to the LVD.
        constexpr uint32_t PRC1 = (1U << 1);  ///< Enables writing to the registers related to the operating modes, the low power consumption modes and the battery backup function.
        constexpr uint32_t PRC0 = (1U << 0);  ///< Enables writing to the registers related to the clock generation circuit.
    }

    /// RSTSR0 Register bits
    namespace rstsr0_bits {
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t LVD2RF = (1U << 3);  ///< Voltage Monitor 2 Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1.
        constexpr uint32_t LVD1RF = (1U << 2);  ///< Voltage Monitor 1 Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1.
        constexpr uint32_t LVD0RF = (1U << 1);  ///< Voltage Monitor 0 Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1.
        constexpr uint32_t PORF = (1U << 0);  ///< Power-On Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1.
    }

    /// RSTSR2 Register bits
    namespace rstsr2_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CWSF = (1U << 0);  ///< Cold/Warm Start Determination FlagNote: Only 1 can be written to set the flag.
    }

    /// RSTSR1 Register bits
    namespace rstsr1_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SPERF = (1U << 12);  ///< SP Error Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t BUSMRF = (1U << 11);  ///< Bus Master MPU Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t BUSSRF = (1U << 10);  ///< Bus Slave MPU Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t REERF = (1U << 9);  ///< RAM ECC Error Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t RPERF = (1U << 8);  ///< RAM Parity Error Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t SWRF = (1U << 2);  ///< Software Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t WDTRF = (1U << 1);  ///< Watchdog Timer Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t IWDTRF = (1U << 0);  ///< Independent Watchdog Timer Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
    }

}

// ============================================================================
// MSTP Peripheral
// ============================================================================

namespace mstp {
    /// Base addresses
    constexpr uint32_t MSTP_BASE = 0x40047000;

    /// MSTP Register structure
    struct Registers {
        volatile uint32_t MSTPCRB;  ///< Offset: 0x00 - Module Stop Control Register B
        volatile uint32_t MSTPCRC;  ///< Offset: 0x04 - Module Stop Control Register C
        volatile uint32_t MSTPCRD;  ///< Offset: 0x08 - Module Stop Control Register D
    };

    /// Peripheral instances
    inline Registers* MSTP = reinterpret_cast<Registers*>(MSTP_BASE);

    // Bit definitions
    /// MSTPCRB Register bits
    namespace mstpcrb_bits {
        constexpr uint32_t MSTPB31 = (1U << 31);  ///< Serial Communication Interface 0 Module Stop
        constexpr uint32_t MSTPB30 = (1U << 30);  ///< Serial Communication Interface 1 Module Stop
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 11. The write value should be 11.
        constexpr uint32_t MSTPB22 = (1U << 22);  ///< Serial Communication Interface 9 Module Stop
        constexpr uint32_t MSTPB19 = (1U << 19);  ///< Serial Peripheral Interface 0 Module Stop
        constexpr uint32_t MSTPB18 = (1U << 18);  ///< Serial Peripheral Interface 1 Module Stop
        constexpr uint32_t MSTPB11 = (1U << 11);  ///< Universal Serial Bus 2.0 FS Interface Module Stop
        constexpr uint32_t MSTPB9 = (1U << 9);  ///< I2C Bus Interface 0 Module Stop
        constexpr uint32_t MSTPB8 = (1U << 8);  ///< I2C Bus Interface 1 Module Stop
        constexpr uint32_t MSTPB2 = (1U << 2);  ///< CAN0 Module Stop
    }

    /// MSTPCRC Register bits
    namespace mstpcrc_bits {
        constexpr uint32_t MSTPC31 = (1U << 31);  ///< AES Module Stop
        constexpr uint32_t Reserved = (1U << 2);  ///< This bit is read as 1. The write value should be 1.
        constexpr uint32_t MSTPC28 = (1U << 28);  ///< Random Number Generator Module Stop
        constexpr uint32_t MSTPC14 = (1U << 14);  ///< Event Link Controller Module Stop
        constexpr uint32_t MSTPC13 = (1U << 13);  ///< Data Operation Circuit Module Stop
        constexpr uint32_t MSTPC3 = (1U << 3);  ///< Capacitive Touch Sensing Unit Module Stop
        constexpr uint32_t MSTPC1 = (1U << 1);  ///< CRC Calculator Module Stop
        constexpr uint32_t MSTPC0 = (1U << 0);  ///< CAC Module Stop
    }

    /// MSTPCRD Register bits
    namespace mstpcrd_bits {
        constexpr uint32_t MSTPD31 = (1U << 31);  ///< Operational Amplifier Module Stop
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 11. The write value should be 11.
        constexpr uint32_t MSTPD29 = (1U << 29);  ///< Comparator-LP Module Stop
        constexpr uint32_t MSTPD28 = (1U << 28);  ///< ACMPHS0 Module Stop
        constexpr uint32_t MSTPD20 = (1U << 20);  ///< 12-bit D/A Converter Module Stop
        constexpr uint32_t MSTPD19 = (1U << 19);  ///< 8-Bit D/A Converter Module Stop
        constexpr uint32_t MSTPD17 = (1U << 17);  ///< 24-bit Sigma-Delta A/DConverter Module Stop
        constexpr uint32_t MSTPD16 = (1U << 16);  ///< 16-Bit A/D Converter Module Stop
        constexpr uint32_t MSTPD14 = (1U << 14);  ///< POEG Module Stop
        constexpr uint32_t MSTPD6 = (1U << 6);  ///< GPT ch6 - ch1 Module Stop
        constexpr uint32_t MSTPD5 = (1U << 5);  ///< GPT ch0 Module Stop
        constexpr uint32_t MSTPD3 = (1U << 3);  ///< AGT0 Module StopNote: AGT0 is in the module stop state when the count source is either of PCLKB, PCLKB/2 or PCLKB/8. In case the count source is sub-clock or LOCO, this bit should be set to 1 except when accessing the registers of AGT0.
        constexpr uint32_t MSTPD2 = (1U << 2);  ///< AGT1 Module StopNote: AGT1 is in the module stop state when the count source is either of PCLKB, PCLKB/2 or PCLKB/8. In case the count source is sub-clock or LOCO, this bit should be set to 1 except when accessing the registers of AGT1.
    }

}

// ============================================================================
// AGT0 Peripheral
// ============================================================================

namespace agt0 {
    /// Base addresses
    constexpr uint32_t AGT0_BASE = 0x40084000;

    /// AGT0 Register structure
    struct Registers {
        volatile uint32_t AGT;  ///< Offset: 0x00 - AGT Counter Register
        volatile uint32_t AGTCMA;  ///< Offset: 0x02 - AGT Compare Match A Register
        volatile uint32_t AGTCMB;  ///< Offset: 0x04 - AGT Compare Match B Register
        volatile uint32_t AGTCR;  ///< Offset: 0x08 - AGT Control Register
        volatile uint32_t AGTMR1;  ///< Offset: 0x09 - AGT Mode Register 1
        volatile uint32_t AGTMR2;  ///< Offset: 0x0A - AGT Mode Register 2
        volatile uint32_t AGTIOC;  ///< Offset: 0x0C - AGT I/O Control Register
        volatile uint32_t AGTISR;  ///< Offset: 0x0D - AGT Event Pin Select Register
        volatile uint32_t AGTCMSR;  ///< Offset: 0x0E - AGT Compare Match Function Select Register
        volatile uint32_t AGTIOSEL;  ///< Offset: 0x0F - AGT Pin Select Register
    };

    /// Peripheral instances
    inline Registers* AGT0 = reinterpret_cast<Registers*>(AGT0_BASE);

    // Bit definitions
    /// AGT Register bits
    namespace agt_bits {
        constexpr uint32_t AGT = (16 << 0);  ///< 16bit counter and reload registerNOTE : When 1 is written to the TSTOP bit in the AGTCRn register, the 16-bit counter is forcibly stopped and set to FFFFH.
    }

    /// AGTCMA Register bits
    namespace agtcma_bits {
        constexpr uint32_t AGTCMA = (16 << 0);  ///< AGT Compare Match A RegisterNOTE : When 1 is written to the TSTOP bit in the AGTCRn register, set to FFFFH
    }

    /// AGTCMB Register bits
    namespace agtcmb_bits {
        constexpr uint32_t AGTCMB = (16 << 0);  ///< AGT Compare Match B RegisterNOTE : When 1 is written to the TSTOP bit in the AGTCR register, set to FFFFH
    }

    /// AGTCR Register bits
    namespace agtcr_bits {
        constexpr uint32_t TCMBF = (1U << 7);  ///< AGT compare match B flag
        constexpr uint32_t TCMAF = (1U << 6);  ///< AGT compare match A flag
        constexpr uint32_t TUNDF = (1U << 5);  ///< AGT underflow flag
        constexpr uint32_t TEDGF = (1U << 4);  ///< Active edge judgement flag
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TSTOP = (1U << 2);  ///< AGT count forced stop
        constexpr uint32_t TCSTF = (1U << 1);  ///< AGT count status flag
        constexpr uint32_t TSTART = (1U << 0);  ///< AGT count start
    }

    /// AGTMR1 Register bits
    namespace agtmr1_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TCK = (3 << 4);  ///< AGT count source select
        constexpr uint32_t TEDGPL = (1U << 3);  ///< AGTIO edge polarity select
        constexpr uint32_t TMOD = (3 << 0);  ///< AGT operating mode select
    }

    /// AGTMR2 Register bits
    namespace agtmr2_bits {
        constexpr uint32_t LPM = (1U << 7);  ///< Low Power Mode
        constexpr uint32_t Reserved = (4 << 3);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t CKS = (3 << 0);  ///< fsub/LOCO count source clock frequency division ratio select
    }

    /// AGTIOC Register bits
    namespace agtioc_bits {
        constexpr uint32_t TIOGT = (2 << 6);  ///< AGTIO count control
        constexpr uint32_t TIPF = (2 << 4);  ///< AGTIO input filter select
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TOE = (1U << 2);  ///< AGTO output enable
        constexpr uint32_t TEDGSEL = (1U << 0);  ///< I/O polarity switchFunction varies depending on the operating mode.
    }

    /// AGTISR Register bits
    namespace agtisr_bits {
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t EEPS = (1U << 2);  ///< AGTEE polarty selection
    }

    /// AGTCMSR Register bits
    namespace agtcmsr_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TOPOLB = (1U << 6);  ///< AGTOB polarity select
        constexpr uint32_t TOEB = (1U << 5);  ///< AGTOB output enable
        constexpr uint32_t TCMEB = (1U << 4);  ///< Compare match B register enable
        constexpr uint32_t TOPOLA = (1U << 2);  ///< AGTOA polarity select
        constexpr uint32_t TOEA = (1U << 1);  ///< AGTOA output enable
        constexpr uint32_t TCMEA = (1U << 0);  ///< Compare match A register enable
    }

    /// AGTIOSEL Register bits
    namespace agtiosel_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t TIES = (1U << 4);  ///< AGTIO input enable
    }

}

// ============================================================================
// AGT1 Peripheral
// ============================================================================

namespace agt1 {
    /// Base addresses
    constexpr uint32_t AGT1_BASE = 0x40084100;

    /// AGT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AGT1 = reinterpret_cast<Registers*>(AGT1_BASE);

}

// ============================================================================
// GPT320 Peripheral
// ============================================================================

namespace gpt320 {
    /// Base addresses
    constexpr uint32_t GPT320_BASE = 0x40078000;

    /// GPT320 Register structure
    struct Registers {
        volatile uint32_t GTWP;  ///< Offset: 0x00 - General PWM Timer Write-Protection Register
        volatile uint32_t GTSTR;  ///< Offset: 0x04 - General PWM Timer Software Start Register
        volatile uint32_t GTSTP;  ///< Offset: 0x08 - General PWM Timer Software Stop Register
        volatile uint32_t GTCLR;  ///< Offset: 0x0C - General PWM Timer Software Clear Register
        volatile uint32_t GTSSR;  ///< Offset: 0x10 - General PWM Timer Start Source Select Register
        volatile uint32_t GTPSR;  ///< Offset: 0x14 - General PWM Timer Stop Source Select Register
        volatile uint32_t GTCSR;  ///< Offset: 0x18 - General PWM Timer Clear Source Select Register
        volatile uint32_t GTUPSR;  ///< Offset: 0x1C - General PWM Timer Up Count Source Select Register
        volatile uint32_t GTDNSR;  ///< Offset: 0x20 - General PWM Timer Down Count Source Select Register
        volatile uint32_t GTICASR;  ///< Offset: 0x24 - General PWM Timer Input Capture Source Select Register A
        volatile uint32_t GTICBSR;  ///< Offset: 0x28 - General PWM Timer Input Capture Source Select Register B
        volatile uint32_t GTCR;  ///< Offset: 0x2C - General PWM Timer Control Register
        volatile uint32_t GTUDDTYC;  ///< Offset: 0x30 - General PWM Timer Count Direction and Duty Setting Register
        volatile uint32_t GTIOR;  ///< Offset: 0x34 - General PWM Timer I/O Control Register
        volatile uint32_t GTINTAD;  ///< Offset: 0x38 - General PWM Timer Interrupt Output Setting Register
        volatile uint32_t GTST;  ///< Offset: 0x3C - General PWM Timer Status Register
        volatile uint32_t GTBER;  ///< Offset: 0x40 - General PWM Timer Buffer Enable Register
        volatile uint32_t GTCNT;  ///< Offset: 0x48 - General PWM Timer Counter
        volatile uint32_t GTCCRA;  ///< Offset: 0x4C - General PWM Timer Compare Capture Register A
        volatile uint32_t GTCCRB;  ///< Offset: 0x50 - General PWM Timer Compare Capture Register B
        volatile uint32_t GTCCRC;  ///< Offset: 0x54 - General PWM Timer Compare Capture Register C
        volatile uint32_t GTCCRE;  ///< Offset: 0x58 - General PWM Timer Compare Capture Register E
        volatile uint32_t GTCCRD;  ///< Offset: 0x5C - General PWM Timer Compare Capture Register D
        volatile uint32_t GTCCRF;  ///< Offset: 0x60 - General PWM Timer Compare Capture Register F
        volatile uint32_t GTPR;  ///< Offset: 0x64 - General PWM Timer Cycle Setting Register
        volatile uint32_t GTPBR;  ///< Offset: 0x68 - General PWM Timer Cycle Setting Buffer Register
        volatile uint32_t GTDTCR;  ///< Offset: 0x88 - General PWM Timer Dead Time Control Register
        volatile uint32_t GTDVU;  ///< Offset: 0x8C - General PWM Timer Dead Time Value Register U
    };

    /// Peripheral instances
    inline Registers* GPT320 = reinterpret_cast<Registers*>(GPT320_BASE);

    // Bit definitions
    /// GTWP Register bits
    namespace gtwp_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PRKEY = (8 << 8);  ///< GTWP Key Code
        constexpr uint32_t WP = (1U << 0);  ///< Register Write Disable
    }

    /// GTSTR Register bits
    namespace gtstr_bits {
        constexpr uint32_t Reserved = (25 << 7);  ///< These bits are read as 0000000000000000000000000. The write value should be 0000000000000000000000000.
        constexpr uint32_t CSTRT6 = (1U << 6);  ///< Channel 6 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT5 = (1U << 5);  ///< Channel 5 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT4 = (1U << 4);  ///< Channel 4 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT3 = (1U << 3);  ///< Channel 3 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT2 = (1U << 2);  ///< Channel 2 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT1 = (1U << 1);  ///< Channel 1 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT0 = (1U << 0);  ///< Channel 0 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
    }

    /// GTSTP Register bits
    namespace gtstp_bits {
        constexpr uint32_t Reserved = (25 << 7);  ///< These bits are read as 1111111111111111111111111. The write value should be 1111111111111111111111111.
        constexpr uint32_t CSTOP6 = (1U << 6);  ///< Channel 6 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP5 = (1U << 5);  ///< Channel 5 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP4 = (1U << 4);  ///< Channel 4 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP3 = (1U << 3);  ///< Channel 3 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP2 = (1U << 2);  ///< Channel 2 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP1 = (1U << 1);  ///< Channel 1 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP0 = (1U << 0);  ///< Channel 0 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
    }

    /// GTCLR Register bits
    namespace gtclr_bits {
        constexpr uint32_t Reserved = (25 << 7);  ///< The write value should be 0000000000000000000000000.
        constexpr uint32_t CCLR6 = (1U << 6);  ///< Channel 6 GTCNT Count Clear
        constexpr uint32_t CCLR5 = (1U << 5);  ///< Channel 5 GTCNT Count Clear
        constexpr uint32_t CCLR4 = (1U << 4);  ///< Channel 4 GTCNT Count Clear
        constexpr uint32_t CCLR3 = (1U << 3);  ///< Channel 3 GTCNT Count Clear
        constexpr uint32_t CCLR2 = (1U << 2);  ///< Channel 2 GTCNT Count Clear
        constexpr uint32_t CCLR1 = (1U << 1);  ///< Channel 1 GTCNT Count Clear
        constexpr uint32_t CCLR0 = (1U << 0);  ///< Channel 0 GTCNT Count Clear
    }

    /// GTSSR Register bits
    namespace gtssr_bits {
        constexpr uint32_t CSTRT = (1U << 31);  ///< Software Source Counter Start Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t SSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Start Enable
        constexpr uint32_t SSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Start Enable
        constexpr uint32_t SSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Start Enable
        constexpr uint32_t SSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Start Enable
        constexpr uint32_t SSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Start Enable
    }

    /// GTPSR Register bits
    namespace gtpsr_bits {
        constexpr uint32_t CSTOP = (1U << 31);  ///< Software Source Counter Stop Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t PSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Stop Enable
        constexpr uint32_t PSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Stop Enable
        constexpr uint32_t PSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Stop Enable
        constexpr uint32_t PSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Stop Enable
        constexpr uint32_t PSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Stop Enable
    }

    /// GTCSR Register bits
    namespace gtcsr_bits {
        constexpr uint32_t CCLR = (1U << 31);  ///< Software Source Counter Clear Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t CSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Clear Enable
        constexpr uint32_t CSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Clear Enable
        constexpr uint32_t CSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Clear Enable
        constexpr uint32_t CSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Clear Enable
        constexpr uint32_t CSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Clear Enable
    }

    /// GTUPSR Register bits
    namespace gtupsr_bits {
        constexpr uint32_t USELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Up Enable
        constexpr uint32_t USELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Up Enable
        constexpr uint32_t USELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Up Enable
        constexpr uint32_t USELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Up Enable
        constexpr uint32_t USCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Up Enable
    }

    /// GTDNSR Register bits
    namespace gtdnsr_bits {
        constexpr uint32_t DSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Down Enable
        constexpr uint32_t DSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Down Enable
        constexpr uint32_t DSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Down Enable
        constexpr uint32_t DSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Down Enable
        constexpr uint32_t DSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Down Enable
    }

    /// GTICASR Register bits
    namespace gticasr_bits {
        constexpr uint32_t ASELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable
    }

    /// GTICBSR Register bits
    namespace gticbsr_bits {
        constexpr uint32_t BSELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable
    }

    /// GTCR Register bits
    namespace gtcr_bits {
        constexpr uint32_t TPCS = (3 << 24);  ///< Timer Prescaler Select
        constexpr uint32_t Reserved = (15 << 1);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
        constexpr uint32_t MD = (3 << 16);  ///< Mode Select
        constexpr uint32_t CST = (1U << 0);  ///< Count Start
    }

    /// GTUDDTYC Register bits
    namespace gtuddtyc_bits {
        constexpr uint32_t OBDTYR = (1U << 27);  ///< GTIOCB Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OBDTYF = (1U << 26);  ///< Forcible GTIOCB Output Duty Setting
        constexpr uint32_t OBDTY = (2 << 24);  ///< GTIOCB Output Duty Setting
        constexpr uint32_t Reserved = (4 << 20);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t OADTYR = (1U << 19);  ///< GTIOCA Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OADTYF = (1U << 18);  ///< Forcible GTIOCA Output Duty Setting
        constexpr uint32_t OADTY = (2 << 16);  ///< GTIOCA Output Duty Setting
        constexpr uint32_t UDF = (1U << 1);  ///< Forcible Count Direction Setting
        constexpr uint32_t UD = (1U << 0);  ///< Count Direction Setting
    }

    /// GTIOR Register bits
    namespace gtior_bits {
        constexpr uint32_t NFCSB = (2 << 30);  ///< Noise Filter B Sampling Clock Select
        constexpr uint32_t NFBEN = (1U << 29);  ///< Noise Filter B Enable
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t OBDF = (2 << 25);  ///< GTIOCB Pin Disable Value Setting
        constexpr uint32_t OBE = (1U << 24);  ///< GTIOCB Pin Output Enable
        constexpr uint32_t OBHLD = (1U << 23);  ///< GTIOCB Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OBDFLT = (1U << 22);  ///< GTIOCB Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOB = (5 << 16);  ///< GTIOCB Pin Function Select
        constexpr uint32_t NFCSA = (2 << 14);  ///< Noise Filter A Sampling Clock Select
        constexpr uint32_t NFAEN = (1U << 13);  ///< Noise Filter A Enable
        constexpr uint32_t OADF = (2 << 9);  ///< GTIOCA Pin Disable Value Setting
        constexpr uint32_t OAE = (1U << 8);  ///< GTIOCA Pin Output Enable
        constexpr uint32_t OAHLD = (1U << 7);  ///< GTIOCA Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OADFLT = (1U << 6);  ///< GTIOCA Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOA = (5 << 0);  ///< GTIOCA Pin Function Select
    }

    /// GTINTAD Register bits
    namespace gtintad_bits {
        constexpr uint32_t GRPABL = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t GRPABH = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t Reserved = (24 << 0);  ///< These bits are read as 000000000000000000000000. The write value should be 000000000000000000000000.
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disable Source Select
    }

    /// GTST Register bits
    namespace gtst_bits {
        constexpr uint32_t OABLF = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t OABHF = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t Reserved = (7 << 8);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ODF = (1U << 24);  ///< Output Disable Flag
        constexpr uint32_t GTCF = (1U << 15);  ///< Count Direction Flag
        constexpr uint32_t TCFPU = (1U << 7);  ///< Underflow Flag
        constexpr uint32_t TCPFO = (1U << 6);  ///< Overflow Flag
        constexpr uint32_t TCFF = (1U << 5);  ///< Input Compare Match Flag F
        constexpr uint32_t TCFE = (1U << 4);  ///< Input Compare Match Flag E
        constexpr uint32_t TCFD = (1U << 3);  ///< Input Compare Match Flag D
        constexpr uint32_t TCFC = (1U << 2);  ///< Input Compare Match Flag C
        constexpr uint32_t TCFB = (1U << 1);  ///< Input Capture/Compare Match Flag B
        constexpr uint32_t TCFA = (1U << 0);  ///< Input Capture/Compare Match Flag A
    }

    /// GTBER Register bits
    namespace gtber_bits {
        constexpr uint32_t CCRSWT = (1U << 22);  ///< GTCCRA and GTCCRB Forcible Buffer OperationThis bit is read as 0.
        constexpr uint32_t PR = (2 << 20);  ///< GTPR Buffer Operation
        constexpr uint32_t CCRB = (2 << 18);  ///< GTCCRB Buffer Operation
        constexpr uint32_t CCRA = (2 << 16);  ///< GTCCRA Buffer Operation
        constexpr uint32_t BD = (2 << 0);  ///< BD[1]: GTPR Buffer Operation DisableBD[0]: GTCCR Buffer Operation Disable
    }

    /// GTCNT Register bits
    namespace gtcnt_bits {
        constexpr uint32_t GTCNT = (32 << 0);  ///< Counter
    }

    /// GTCCRA Register bits
    namespace gtccra_bits {
        constexpr uint32_t GTCCRA = (32 << 0);  ///< Compare Capture Register A
    }

    /// GTCCRB Register bits
    namespace gtccrb_bits {
        constexpr uint32_t GTCCRB = (32 << 0);  ///< Compare Capture Register B
    }

    /// GTCCRC Register bits
    namespace gtccrc_bits {
        constexpr uint32_t GTCCRC = (32 << 0);  ///< Compare Capture Register C
    }

    /// GTCCRE Register bits
    namespace gtccre_bits {
        constexpr uint32_t GTCCRE = (32 << 0);  ///< Compare Capture Register E
    }

    /// GTCCRD Register bits
    namespace gtccrd_bits {
        constexpr uint32_t GTCCRD = (32 << 0);  ///< Compare Capture Register D
    }

    /// GTCCRF Register bits
    namespace gtccrf_bits {
        constexpr uint32_t GTCCRF = (32 << 0);  ///< Compare Capture Register F
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GTPR = (32 << 0);  ///< Cycle Setting Register
    }

    /// GTPBR Register bits
    namespace gtpbr_bits {
        constexpr uint32_t GTPBR = (32 << 0);  ///< Cycle Setting Buffer Register
    }

    /// GTDTCR Register bits
    namespace gtdtcr_bits {
        constexpr uint32_t Reserved = (31 << 1);  ///< These bits are read as 0000000000000000000000000000000. The write value should be 0000000000000000000000000000000.
        constexpr uint32_t TDE = (1U << 0);  ///< Negative-Phase Waveform Setting
    }

    /// GTDVU Register bits
    namespace gtdvu_bits {
        constexpr uint32_t GTDVU = (32 << 0);  ///< Dead Time Value Register U
    }

}

// ============================================================================
// GPT Peripheral
// ============================================================================

namespace gpt {
    /// Base addresses
    constexpr uint32_t GPT_OPS_BASE = 0x40078FF0;

    /// GPT Register structure
    struct Registers {
        volatile uint32_t OPSCR;  ///< Offset: 0x00 - Output Phase Switching Control Register
    };

    /// Peripheral instances
    inline Registers* GPT_OPS = reinterpret_cast<Registers*>(GPT_OPS_BASE);

    // Bit definitions
    /// OPSCR Register bits
    namespace opscr_bits {
        constexpr uint32_t NFCS = (2 << 30);  ///< External Input Noise Filter Clock selectionNoise filter sampling clock setting of the external input.
        constexpr uint32_t NFEN = (1U << 29);  ///< External Input Noise Filter Enable
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t GODF = (1U << 26);  ///< Group output disable function
        constexpr uint32_t GRP = (1U << 24);  ///< Output disabled source selection
        constexpr uint32_t ALIGN = (1U << 21);  ///< Input phase alignment
        constexpr uint32_t RV = (1U << 20);  ///< Output phase rotation direction reversal
        constexpr uint32_t INV = (1U << 19);  ///< Invert-Phase Output Control
        constexpr uint32_t N = (1U << 18);  ///< Negative-Phase Output (N) Control
        constexpr uint32_t P = (1U << 17);  ///< Positive-Phase Output (P) Control
        constexpr uint32_t FB = (1U << 16);  ///< External Feedback Signal EnableThis bit selects the input phase from the software settings and external input.
        constexpr uint32_t EN = (1U << 8);  ///< Enable-Phase Output Control
        constexpr uint32_t W = (1U << 6);  ///< Input W-Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)
        constexpr uint32_t V = (1U << 5);  ///< Input V-Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)
        constexpr uint32_t U = (1U << 4);  ///< Input U-Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)
        constexpr uint32_t WF = (1U << 2);  ///< Input Phase Soft Setting UFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1.
        constexpr uint32_t VF = (1U << 1);  ///< Input Phase Soft Setting VFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1.
        constexpr uint32_t UF = (1U << 0);  ///< Input Phase Soft Setting WFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1.
    }

}

// ============================================================================
// GPT161 Peripheral
// ============================================================================

namespace gpt161 {
    /// Base addresses
    constexpr uint32_t GPT161_BASE = 0x40078100;

    /// GPT161 Register structure
    struct Registers {
        volatile uint32_t GTWP;  ///< Offset: 0x00 - General PWM Timer Write-Protection Register
        volatile uint32_t GTSTR;  ///< Offset: 0x04 - General PWM Timer Software Start Register
        volatile uint32_t GTSTP;  ///< Offset: 0x08 - General PWM Timer Software Stop Register
        volatile uint32_t GTCLR;  ///< Offset: 0x0C - General PWM Timer Software Clear Register
        volatile uint32_t GTSSR;  ///< Offset: 0x10 - General PWM Timer Start Source Select Register
        volatile uint32_t GTPSR;  ///< Offset: 0x14 - General PWM Timer Stop Source Select Register
        volatile uint32_t GTCSR;  ///< Offset: 0x18 - General PWM Timer Clear Source Select Register
        volatile uint32_t GTUPSR;  ///< Offset: 0x1C - General PWM Timer Up Count Source Select Register
        volatile uint32_t GTDNSR;  ///< Offset: 0x20 - General PWM Timer Down Count Source Select Register
        volatile uint32_t GTICASR;  ///< Offset: 0x24 - General PWM Timer Input Capture Source Select Register A
        volatile uint32_t GTICBSR;  ///< Offset: 0x28 - General PWM Timer Input Capture Source Select Register B
        volatile uint32_t GTCR;  ///< Offset: 0x2C - General PWM Timer Control Register
        volatile uint32_t GTUDDTYC;  ///< Offset: 0x30 - General PWM Timer Count Direction and Duty Setting Register
        volatile uint32_t GTIOR;  ///< Offset: 0x34 - General PWM Timer I/O Control Register
        volatile uint32_t GTINTAD;  ///< Offset: 0x38 - General PWM Timer Interrupt Output Setting Register
        volatile uint32_t GTST;  ///< Offset: 0x3C - General PWM Timer Status Register
        volatile uint32_t GTBER;  ///< Offset: 0x40 - General PWM Timer Buffer Enable Register
        volatile uint32_t GTCNT;  ///< Offset: 0x48 - General PWM Timer Counter
        volatile uint32_t GTCCRA;  ///< Offset: 0x4C - General PWM Timer Compare Capture Register A
        volatile uint32_t GTCCRB;  ///< Offset: 0x50 - General PWM Timer Compare Capture Register B
        volatile uint32_t GTCCRC;  ///< Offset: 0x54 - General PWM Timer Compare Capture Register C
        volatile uint32_t GTCCRE;  ///< Offset: 0x58 - General PWM Timer Compare Capture Register E
        volatile uint32_t GTCCRD;  ///< Offset: 0x5C - General PWM Timer Compare Capture Register D
        volatile uint32_t GTCCRF;  ///< Offset: 0x60 - General PWM Timer Compare Capture Register F
        volatile uint32_t GTPR;  ///< Offset: 0x64 - General PWM Timer Cycle Setting Register
        volatile uint32_t GTPBR;  ///< Offset: 0x68 - General PWM Timer Cycle Setting Buffer Register
        volatile uint32_t GTDTCR;  ///< Offset: 0x88 - General PWM Timer Dead Time Control Register
        volatile uint32_t GTDVU;  ///< Offset: 0x8C - General PWM Timer Dead Time Value Register U
    };

    /// Peripheral instances
    inline Registers* GPT161 = reinterpret_cast<Registers*>(GPT161_BASE);

    // Bit definitions
    /// GTWP Register bits
    namespace gtwp_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PRKEY = (8 << 8);  ///< GTWP Key Code
        constexpr uint32_t WP = (1U << 0);  ///< Register Write Disable
    }

    /// GTSTR Register bits
    namespace gtstr_bits {
        constexpr uint32_t Reserved = (25 << 7);  ///< These bits are read as 0000000000000000000000000. The write value should be 0000000000000000000000000.
        constexpr uint32_t CSTRT6 = (1U << 6);  ///< Channel 6 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT5 = (1U << 5);  ///< Channel 5 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT4 = (1U << 4);  ///< Channel 4 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT3 = (1U << 3);  ///< Channel 3 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT2 = (1U << 2);  ///< Channel 2 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT1 = (1U << 1);  ///< Channel 1 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT0 = (1U << 0);  ///< Channel 0 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
    }

    /// GTSTP Register bits
    namespace gtstp_bits {
        constexpr uint32_t Reserved = (25 << 7);  ///< These bits are read as 1111111111111111111111111. The write value should be 1111111111111111111111111.
        constexpr uint32_t CSTOP6 = (1U << 6);  ///< Channel 6 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP5 = (1U << 5);  ///< Channel 5 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP4 = (1U << 4);  ///< Channel 4 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP3 = (1U << 3);  ///< Channel 3 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP2 = (1U << 2);  ///< Channel 2 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP1 = (1U << 1);  ///< Channel 1 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP0 = (1U << 0);  ///< Channel 0 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
    }

    /// GTCLR Register bits
    namespace gtclr_bits {
        constexpr uint32_t Reserved = (25 << 7);  ///< The write value should be 0000000000000000000000000.
        constexpr uint32_t CCLR6 = (1U << 6);  ///< Channel 6 GTCNT Count Clear
        constexpr uint32_t CCLR5 = (1U << 5);  ///< Channel 5 GTCNT Count Clear
        constexpr uint32_t CCLR4 = (1U << 4);  ///< Channel 4 GTCNT Count Clear
        constexpr uint32_t CCLR3 = (1U << 3);  ///< Channel 3 GTCNT Count Clear
        constexpr uint32_t CCLR2 = (1U << 2);  ///< Channel 2 GTCNT Count Clear
        constexpr uint32_t CCLR1 = (1U << 1);  ///< Channel 1 GTCNT Count Clear
        constexpr uint32_t CCLR0 = (1U << 0);  ///< Channel 0 GTCNT Count Clear
    }

    /// GTSSR Register bits
    namespace gtssr_bits {
        constexpr uint32_t CSTRT = (1U << 31);  ///< Software Source Counter Start Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t SSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Start Enable
        constexpr uint32_t SSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Start Enable
        constexpr uint32_t SSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Start Enable
        constexpr uint32_t SSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Start Enable
        constexpr uint32_t SSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Start Enable
    }

    /// GTPSR Register bits
    namespace gtpsr_bits {
        constexpr uint32_t CSTOP = (1U << 31);  ///< Software Source Counter Stop Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t PSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Stop Enable
        constexpr uint32_t PSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Stop Enable
        constexpr uint32_t PSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Stop Enable
        constexpr uint32_t PSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Stop Enable
        constexpr uint32_t PSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Stop Enable
    }

    /// GTCSR Register bits
    namespace gtcsr_bits {
        constexpr uint32_t CCLR = (1U << 31);  ///< Software Source Counter Clear Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t CSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Clear Enable
        constexpr uint32_t CSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Clear Enable
        constexpr uint32_t CSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Clear Enable
        constexpr uint32_t CSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Clear Enable
        constexpr uint32_t CSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Clear Enable
    }

    /// GTUPSR Register bits
    namespace gtupsr_bits {
        constexpr uint32_t USELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Up Enable
        constexpr uint32_t USELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Up Enable
        constexpr uint32_t USELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Up Enable
        constexpr uint32_t USELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Up Enable
        constexpr uint32_t USCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Up Enable
    }

    /// GTDNSR Register bits
    namespace gtdnsr_bits {
        constexpr uint32_t DSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Down Enable
        constexpr uint32_t DSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Down Enable
        constexpr uint32_t DSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Down Enable
        constexpr uint32_t DSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Down Enable
        constexpr uint32_t DSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Down Enable
    }

    /// GTICASR Register bits
    namespace gticasr_bits {
        constexpr uint32_t ASELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable
    }

    /// GTICBSR Register bits
    namespace gticbsr_bits {
        constexpr uint32_t BSELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable
    }

    /// GTCR Register bits
    namespace gtcr_bits {
        constexpr uint32_t TPCS = (3 << 24);  ///< Timer Prescaler Select
        constexpr uint32_t Reserved = (15 << 1);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
        constexpr uint32_t MD = (3 << 16);  ///< Mode Select
        constexpr uint32_t CST = (1U << 0);  ///< Count Start
    }

    /// GTUDDTYC Register bits
    namespace gtuddtyc_bits {
        constexpr uint32_t OBDTYR = (1U << 27);  ///< GTIOCB Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OBDTYF = (1U << 26);  ///< Forcible GTIOCB Output Duty Setting
        constexpr uint32_t OBDTY = (2 << 24);  ///< GTIOCB Output Duty Setting
        constexpr uint32_t Reserved = (4 << 20);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t OADTYR = (1U << 19);  ///< GTIOCA Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OADTYF = (1U << 18);  ///< Forcible GTIOCA Output Duty Setting
        constexpr uint32_t OADTY = (2 << 16);  ///< GTIOCA Output Duty Setting
        constexpr uint32_t UDF = (1U << 1);  ///< Forcible Count Direction Setting
        constexpr uint32_t UD = (1U << 0);  ///< Count Direction Setting
    }

    /// GTIOR Register bits
    namespace gtior_bits {
        constexpr uint32_t NFCSB = (2 << 30);  ///< Noise Filter B Sampling Clock Select
        constexpr uint32_t NFBEN = (1U << 29);  ///< Noise Filter B Enable
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t OBDF = (2 << 25);  ///< GTIOCB Pin Disable Value Setting
        constexpr uint32_t OBE = (1U << 24);  ///< GTIOCB Pin Output Enable
        constexpr uint32_t OBHLD = (1U << 23);  ///< GTIOCB Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OBDFLT = (1U << 22);  ///< GTIOCB Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOB = (5 << 16);  ///< GTIOCB Pin Function Select
        constexpr uint32_t NFCSA = (2 << 14);  ///< Noise Filter A Sampling Clock Select
        constexpr uint32_t NFAEN = (1U << 13);  ///< Noise Filter A Enable
        constexpr uint32_t OADF = (2 << 9);  ///< GTIOCA Pin Disable Value Setting
        constexpr uint32_t OAE = (1U << 8);  ///< GTIOCA Pin Output Enable
        constexpr uint32_t OAHLD = (1U << 7);  ///< GTIOCA Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OADFLT = (1U << 6);  ///< GTIOCA Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOA = (5 << 0);  ///< GTIOCA Pin Function Select
    }

    /// GTINTAD Register bits
    namespace gtintad_bits {
        constexpr uint32_t GRPABL = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t GRPABH = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t Reserved = (24 << 0);  ///< These bits are read as 000000000000000000000000. The write value should be 000000000000000000000000.
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disable Source Select
    }

    /// GTST Register bits
    namespace gtst_bits {
        constexpr uint32_t OABLF = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t OABHF = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t Reserved = (7 << 8);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ODF = (1U << 24);  ///< Output Disable Flag
        constexpr uint32_t GTCF = (1U << 15);  ///< Count Direction Flag
        constexpr uint32_t TCFPU = (1U << 7);  ///< Underflow Flag
        constexpr uint32_t TCPFO = (1U << 6);  ///< Overflow Flag
        constexpr uint32_t TCFF = (1U << 5);  ///< Input Compare Match Flag F
        constexpr uint32_t TCFE = (1U << 4);  ///< Input Compare Match Flag E
        constexpr uint32_t TCFD = (1U << 3);  ///< Input Compare Match Flag D
        constexpr uint32_t TCFC = (1U << 2);  ///< Input Compare Match Flag C
        constexpr uint32_t TCFB = (1U << 1);  ///< Input Capture/Compare Match Flag B
        constexpr uint32_t TCFA = (1U << 0);  ///< Input Capture/Compare Match Flag A
    }

    /// GTBER Register bits
    namespace gtber_bits {
        constexpr uint32_t CCRSWT = (1U << 22);  ///< GTCCRA and GTCCRB Forcible Buffer OperationThis bit is read as 0.
        constexpr uint32_t PR = (2 << 20);  ///< GTPR Buffer Operation
        constexpr uint32_t CCRB = (2 << 18);  ///< GTCCRB Buffer Operation
        constexpr uint32_t CCRA = (2 << 16);  ///< GTCCRA Buffer Operation
        constexpr uint32_t BD = (2 << 0);  ///< BD[1]: GTPR Buffer Operation DisableBD[0]: GTCCR Buffer Operation Disable
    }

    /// GTCNT Register bits
    namespace gtcnt_bits {
        constexpr uint32_t GTCNT = (32 << 0);  ///< Counter
    }

    /// GTCCRA Register bits
    namespace gtccra_bits {
        constexpr uint32_t Reserved = (16 << 16);  ///< These bits are read as 0000000000000000. The write value should be 0000000000000000.
        constexpr uint32_t GTCCRA = (16 << 0);  ///< Compare Capture Register A
    }

    /// GTCCRB Register bits
    namespace gtccrb_bits {
        constexpr uint32_t Reserved = (16 << 16);  ///< These bits are read as 0000000000000000. The write value should be 0000000000000000.
        constexpr uint32_t GTCCRB = (16 << 0);  ///< Compare Capture Register B
    }

    /// GTCCRC Register bits
    namespace gtccrc_bits {
        constexpr uint32_t Reserved = (16 << 16);  ///< These bits are read as 0000000000000000. The write value should be 0000000000000000.
        constexpr uint32_t GTCCRC = (16 << 0);  ///< Compare Capture Register C
    }

    /// GTCCRE Register bits
    namespace gtccre_bits {
        constexpr uint32_t Reserved = (16 << 16);  ///< These bits are read as 0000000000000000. The write value should be 0000000000000000.
        constexpr uint32_t GTCCRE = (16 << 0);  ///< Compare Capture Register E
    }

    /// GTCCRD Register bits
    namespace gtccrd_bits {
        constexpr uint32_t Reserved = (16 << 16);  ///< These bits are read as 0000000000000000. The write value should be 0000000000000000.
        constexpr uint32_t GTCCRD = (16 << 0);  ///< Compare Capture Register D
    }

    /// GTCCRF Register bits
    namespace gtccrf_bits {
        constexpr uint32_t Reserved = (16 << 16);  ///< These bits are read as 0000000000000000. The write value should be 0000000000000000.
        constexpr uint32_t GTCCRF = (16 << 0);  ///< Compare Capture Register F
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t Reserved = (16 << 16);  ///< These bits are read as 0000000000000000. The write value should be 0000000000000000.
        constexpr uint32_t GTPR = (16 << 0);  ///< Cycle Setting Register
    }

    /// GTPBR Register bits
    namespace gtpbr_bits {
        constexpr uint32_t Reserved = (16 << 16);  ///< These bits are read as 0000000000000000. The write value should be 0000000000000000.
        constexpr uint32_t GTPBR = (16 << 0);  ///< Cycle Setting Buffer Register
    }

    /// GTDTCR Register bits
    namespace gtdtcr_bits {
        constexpr uint32_t Reserved = (31 << 1);  ///< These bits are read as 0000000000000000000000000000000. The write value should be 0000000000000000000000000000000.
        constexpr uint32_t TDE = (1U << 0);  ///< Negative-Phase Waveform Setting
    }

    /// GTDVU Register bits
    namespace gtdvu_bits {
        constexpr uint32_t Reserved = (16 << 16);  ///< These bits are read as 0000000000000000. The write value should be 0000000000000000.
        constexpr uint32_t GTDVU = (16 << 0);  ///< Dead Time Value Register U
    }

}

// ============================================================================
// GPT162 Peripheral
// ============================================================================

namespace gpt162 {
    /// Base addresses
    constexpr uint32_t GPT162_BASE = 0x40078200;

    /// GPT162 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT162 = reinterpret_cast<Registers*>(GPT162_BASE);

}

// ============================================================================
// GPT163 Peripheral
// ============================================================================

namespace gpt163 {
    /// Base addresses
    constexpr uint32_t GPT163_BASE = 0x40078300;

    /// GPT163 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT163 = reinterpret_cast<Registers*>(GPT163_BASE);

}

// ============================================================================
// GPT164 Peripheral
// ============================================================================

namespace gpt164 {
    /// Base addresses
    constexpr uint32_t GPT164_BASE = 0x40078400;

    /// GPT164 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT164 = reinterpret_cast<Registers*>(GPT164_BASE);

}

// ============================================================================
// GPT165 Peripheral
// ============================================================================

namespace gpt165 {
    /// Base addresses
    constexpr uint32_t GPT165_BASE = 0x40078500;

    /// GPT165 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT165 = reinterpret_cast<Registers*>(GPT165_BASE);

}

// ============================================================================
// GPT166 Peripheral
// ============================================================================

namespace gpt166 {
    /// Base addresses
    constexpr uint32_t GPT166_BASE = 0x40078600;

    /// GPT166 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT166 = reinterpret_cast<Registers*>(GPT166_BASE);

}

// ============================================================================
// POEG Peripheral
// ============================================================================

namespace poeg {
    /// Base addresses
    constexpr uint32_t POEG_BASE = 0x40042000;

    /// POEG Register structure
    struct Registers {
        volatile uint32_t POEGG;  ///< Offset: 0x00 - POEG Group %s Setting Register (renamed from POEGG)
    };

    /// Peripheral instances
    inline Registers* POEG = reinterpret_cast<Registers*>(POEG_BASE);

    // Bit definitions
    /// POEGG Register bits
    namespace poegg_bits {
        constexpr uint32_t NFCS = (2 << 30);  ///< Noise Filter Clock Select
        constexpr uint32_t NFEN = (1U << 29);  ///< Noise Filter Enable
        constexpr uint32_t INV = (1U << 28);  ///< GTETRG Input Reverse
        constexpr uint32_t Reserved = (3 << 9);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t ST = (1U << 16);  ///< GTETRG Input Status Flag
        constexpr uint32_t CDRE5 = (1U << 13);  ///< ACMP_LP1 EnableNote: Can be modified only once after a reset.
        constexpr uint32_t CDRE4 = (1U << 12);  ///< ACMP_LP0 EnableNote: Can be modified only once after a reset.
        constexpr uint32_t CDRE0 = (1U << 8);  ///< ACMP_HS0 EnableNote: Can be modified only once after a reset.
        constexpr uint32_t OSTPE = (1U << 6);  ///< Oscillation Stop Detection EnableNote: Can be modified only once after a reset.
        constexpr uint32_t IOCE = (1U << 5);  ///< Real Time Overcurrent EnableNote: Can be modified only once after a reset.
        constexpr uint32_t PIDE = (1U << 4);  ///< Port Input Detection EnableNote: Can be modified only once after a reset.
        constexpr uint32_t SSF = (1U << 3);  ///< Software Stop Flag
        constexpr uint32_t OSTPF = (1U << 2);  ///< Oscillation Stop Detection Flag
        constexpr uint32_t IOCF = (1U << 1);  ///< Real Time Overcurrent Detection Flag
        constexpr uint32_t PIDF = (1U << 0);  ///< Port Input Detection Flag
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40044000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t R64CNT;  ///< Offset: 0x00 - 64-Hz Counter
        volatile uint32_t RSECCNT;  ///< Offset: 0x02 - Second Counter
        volatile uint32_t BCNT0;  ///< Offset: 0x02 - Binary Counter 0
        volatile uint32_t RMINCNT;  ///< Offset: 0x04 - Minute Counter
        volatile uint32_t BCNT1;  ///< Offset: 0x04 - Binary Counter 1
        volatile uint32_t RHRCNT;  ///< Offset: 0x06 - Hour Counter
        volatile uint32_t BCNT2;  ///< Offset: 0x06 - Binary Counter 2
        volatile uint32_t RWKCNT;  ///< Offset: 0x08 - Day-of-Week Counter
        volatile uint32_t BCNT3;  ///< Offset: 0x08 - Binary Counter 3
        volatile uint32_t RDAYCNT;  ///< Offset: 0x0A - Day Counter
        volatile uint32_t RMONCNT;  ///< Offset: 0x0C - Month Counter
        volatile uint32_t RYRCNT;  ///< Offset: 0x0E - Year Counter
        volatile uint32_t RSECAR;  ///< Offset: 0x10 - Second Alarm Register
        volatile uint32_t BCNT0AR;  ///< Offset: 0x10 - Binary Counter 0 Alarm Register
        volatile uint32_t RMINAR;  ///< Offset: 0x12 - Minute Alarm Register
        volatile uint32_t BCNT1AR;  ///< Offset: 0x12 - Binary Counter 1 Alarm Register
        volatile uint32_t RHRAR;  ///< Offset: 0x14 - Hour Alarm Register
        volatile uint32_t BCNT2AR;  ///< Offset: 0x14 - Binary Counter 2 Alarm Register
        volatile uint32_t RWKAR;  ///< Offset: 0x16 - Day-of-Week Alarm Register
        volatile uint32_t BCNT3AR;  ///< Offset: 0x16 - Binary Counter 3 Alarm Register
        volatile uint32_t RDAYAR;  ///< Offset: 0x18 - Date Alarm Register
        volatile uint32_t BCNT0AER;  ///< Offset: 0x18 - Binary Counter 0 Alarm Enable Register
        volatile uint32_t RMONAR;  ///< Offset: 0x1A - Month Alarm Register
        volatile uint32_t BCNT1AER;  ///< Offset: 0x1A - Binary Counter 1 Alarm Enable Register
        volatile uint32_t RYRAR;  ///< Offset: 0x1C - Year Alarm Register
        volatile uint32_t BCNT2AER;  ///< Offset: 0x1C - Binary Counter 2 Alarm Enable Register
        volatile uint32_t RYRAREN;  ///< Offset: 0x1E - Year Alarm Enable Register
        volatile uint32_t BCNT3AER;  ///< Offset: 0x1E - Binary Counter 3 Alarm Enable Register
        volatile uint32_t RCR1;  ///< Offset: 0x22 - RTC Control Register 1
        volatile uint32_t RCR2;  ///< Offset: 0x24 - RTC Control Register 2
        volatile uint32_t RCR4;  ///< Offset: 0x28 - RTC Control Register 4
        volatile uint32_t RFRH;  ///< Offset: 0x2A - Frequency Register H
        volatile uint32_t RFRL;  ///< Offset: 0x2C - Frequency Register L
        volatile uint32_t RADJ;  ///< Offset: 0x2E - Time Error Adjustment Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// R64CNT Register bits
    namespace r64cnt_bits {
        constexpr uint32_t F1HZ = (1U << 6);  ///< 1Hz
        constexpr uint32_t F2HZ = (1U << 5);  ///< 2Hz
        constexpr uint32_t F4HZ = (1U << 4);  ///< 4Hz
        constexpr uint32_t F8HZ = (1U << 3);  ///< 8Hz
        constexpr uint32_t F16HZ = (1U << 2);  ///< 16Hz
        constexpr uint32_t F32HZ = (1U << 1);  ///< 32Hz
        constexpr uint32_t F64HZ = (1U << 0);  ///< 64Hz
    }

    /// RSECCNT Register bits
    namespace rseccnt_bits {
        constexpr uint32_t SEC10 = (3 << 4);  ///< 10-Second Count Counts from 0 to 5 for 60-second counting.
        constexpr uint32_t SEC1 = (4 << 0);  ///< 1-Second Count Counts from 0 to 9 every second. When a carry is generated, 1 is added to the tens place.
    }

    /// BCNT0 Register bits
    namespace bcnt0_bits {
        constexpr uint32_t BCNT0 = (8 << 0);  ///< The BCNT0 counter is a readable/writable 32-bit binary counter b7 to b0.
    }

    /// RMINCNT Register bits
    namespace rmincnt_bits {
        constexpr uint32_t MIN10 = (3 << 4);  ///< 10-Minute Count Counts from 0 to 5 for 60-minute counting.
        constexpr uint32_t MIN1 = (4 << 0);  ///< 1-Minute Count Counts from 0 to 9 every minute. When a carry is generated, 1 is added to the tens place.
    }

    /// BCNT1 Register bits
    namespace bcnt1_bits {
        constexpr uint32_t BCNT1 = (8 << 0);  ///< The BCNT1 counter is a readable/writable 32-bit binary counter b15 to b8.
    }

    /// RHRCNT Register bits
    namespace rhrcnt_bits {
        constexpr uint32_t PM = (1U << 6);  ///< Time Counter Setting for a.m./p.m.
        constexpr uint32_t HR10 = (2 << 4);  ///< 10-Hour Count Counts from 0 to 2 once per carry from the ones place.
        constexpr uint32_t HR1 = (4 << 0);  ///< 1-Hour Count Counts from 0 to 9 once per hour. When a carry is generated, 1 is added to the tens place.
    }

    /// BCNT2 Register bits
    namespace bcnt2_bits {
        constexpr uint32_t BCNT2 = (8 << 0);  ///< The BCNT2 counter is a readable/writable 32-bit binary counter b23 to b16.
    }

    /// RWKCNT Register bits
    namespace rwkcnt_bits {
        constexpr uint32_t DAYW = (3 << 0);  ///< Day-of-Week Counting
    }

    /// BCNT3 Register bits
    namespace bcnt3_bits {
        constexpr uint32_t BCNT3 = (8 << 0);  ///< The BCNT3 counter is a readable/writable 32-bit binary counter b31 to b24.
    }

    /// RDAYCNT Register bits
    namespace rdaycnt_bits {
        constexpr uint32_t DATE10 = (2 << 4);  ///< 10-Day Count Counts from 0 to 3 once per carry from the ones place.
        constexpr uint32_t DATE1 = (4 << 0);  ///< 1-Day Count Counts from 0 to 9 once per day. When a carry is generated, 1 is added to the tens place.
    }

    /// RMONCNT Register bits
    namespace rmoncnt_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t MON10 = (1U << 4);  ///< 10-Month Count Counts from 0 to 1 once per carry from the ones place.
        constexpr uint32_t MON1 = (4 << 0);  ///< 1-Month Count Counts from 0 to 9 once per month. When a carry is generated, 1 is added to the tens place.
    }

    /// RYRCNT Register bits
    namespace ryrcnt_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t YR10 = (4 << 4);  ///< 10-Year Count Counts from 0 to 9 once per carry from ones place. When a carry is generated in the tens place, 1 is added to the hundreds place.
        constexpr uint32_t YR1 = (4 << 0);  ///< 1-Year Count Counts from 0 to 9 once per year. When a carry is generated, 1 is added to the tens place.
    }

    /// RSECAR Register bits
    namespace rsecar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
        constexpr uint32_t SEC10 = (3 << 4);  ///< 10-Seconds Value for the tens place of seconds
        constexpr uint32_t SEC1 = (4 << 0);  ///< 1-Second Value for the ones place of seconds
    }

    /// BCNT0AR Register bits
    namespace bcnt0ar_bits {
        constexpr uint32_t BCNT0AR = (8 << 0);  ///< he BCNT0AR counter is a readable/writable alarm register corresponding to 32-bit binary counter b7 to b0.
    }

    /// RMINAR Register bits
    namespace rminar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
        constexpr uint32_t MIN10 = (3 << 4);  ///< 10-Minute Count Value for the tens place of minutes
        constexpr uint32_t MIN1 = (4 << 0);  ///< 1-Minute Count Value for the ones place of minutes
    }

    /// BCNT1AR Register bits
    namespace bcnt1ar_bits {
        constexpr uint32_t BCNT1AR = (8 << 0);  ///< he BCNT1AR counter is a readable/writable alarm register corresponding to 32-bit binary counter b15 to b8.
    }

    /// RHRAR Register bits
    namespace rhrar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
        constexpr uint32_t PM = (1U << 6);  ///< Time Counter Setting for a.m./p.m.
        constexpr uint32_t HR10 = (2 << 4);  ///< 10-Hour Count Value for the tens place of hours
        constexpr uint32_t HR1 = (4 << 0);  ///< 1-Hour Count Value for the ones place of hours
    }

    /// BCNT2AR Register bits
    namespace bcnt2ar_bits {
        constexpr uint32_t BCNT2AR = (8 << 0);  ///< The BCNT2AR counter is a readable/writable 32-bit binary counter b23 to b16.
    }

    /// RWKAR Register bits
    namespace rwkar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
        constexpr uint32_t Reserved = (4 << 3);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t DAYW = (3 << 0);  ///< Day-of-Week Counting
    }

    /// BCNT3AR Register bits
    namespace bcnt3ar_bits {
        constexpr uint32_t BCNT3AR = (8 << 0);  ///< The BCNT3AR counter is a readable/writable 32-bit binary counter b31 to b24.
    }

    /// RDAYAR Register bits
    namespace rdayar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
        constexpr uint32_t Reserved = (1U << 6);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DATE10 = (2 << 4);  ///< 10 Days Value for the tens place of days
        constexpr uint32_t DATE1 = (4 << 0);  ///< 1 Day Value for the ones place of days
    }

    /// BCNT0AER Register bits
    namespace bcnt0aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< The BCNT0AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b7 to b0.
    }

    /// RMONAR Register bits
    namespace rmonar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
        constexpr uint32_t Reserved = (2 << 5);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t MON10 = (1U << 4);  ///< 10 Months Value for the tens place of months
        constexpr uint32_t MON1 = (4 << 0);  ///< 1 Month Value for the ones place of months
    }

    /// BCNT1AER Register bits
    namespace bcnt1aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< The BCNT1AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b15 to b8.
    }

    /// RYRAR Register bits
    namespace ryrar_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t YR10 = (4 << 4);  ///< 10 Years Value for the tens place of years
        constexpr uint32_t YR1 = (4 << 0);  ///< 1 Year Value for the ones place of years
    }

    /// BCNT2AER Register bits
    namespace bcnt2aer_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t ENB = (8 << 0);  ///< The BCNT2AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b23 to b16.
    }

    /// RYRAREN Register bits
    namespace ryraren_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
        constexpr uint32_t Reserved = (7 << 0);  ///< These bits are read as 0000000. The write value should be 0000000.
    }

    /// BCNT3AER Register bits
    namespace bcnt3aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< The BCNT3AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b31 to b24.
    }

    /// RCR1 Register bits
    namespace rcr1_bits {
        constexpr uint32_t PES = (4 << 4);  ///< Periodic Interrupt Select
        constexpr uint32_t RTCOS = (1U << 3);  ///< RTCOUT Output Select
        constexpr uint32_t PIE = (1U << 2);  ///< Periodic Interrupt Enable
        constexpr uint32_t CIE = (1U << 1);  ///< Carry Interrupt Enable
        constexpr uint32_t AIE = (1U << 0);  ///< Alarm Interrupt Enable
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t CNTMD = (1U << 7);  ///< Count Mode Select
        constexpr uint32_t HR24 = (1U << 6);  ///< Hours Mode
        constexpr uint32_t AADJP = (1U << 5);  ///< Automatic Adjustment Period Select (When the LOCO clock is selected, the setting of this bit is disabled.)
        constexpr uint32_t AADJE = (1U << 4);  ///< Automatic Adjustment Enable (When the LOCO clock is selected, the setting of this bit is disabled.)
        constexpr uint32_t RTCOE = (1U << 3);  ///< RTCOUT Output Enable
        constexpr uint32_t ADJ30 = (1U << 2);  ///< 30-Second Adjustment
        constexpr uint32_t RESET = (1U << 1);  ///< RTC Software Reset
        constexpr uint32_t START = (1U << 0);  ///< Start
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t RCKSEL = (1U << 0);  ///< Count Source Select
    }

    /// RFRH Register bits
    namespace rfrh_bits {
        constexpr uint32_t Reserved = (15 << 1);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
        constexpr uint32_t RFC16 = (1U << 0);  ///< Frequency Comparison Value (b16) To generate the operating clock from the LOCOclock, this bit sets the comparison value of the 128-Hz clock cycle.
    }

    /// RFRL Register bits
    namespace rfrl_bits {
        constexpr uint32_t RFC = (16 << 0);  ///< Frequency Comparison Value(b15-b0) To generate the operating clock from the main clock, this bit sets the comparison value of the 128-Hz clock cycle.
    }

    /// RADJ Register bits
    namespace radj_bits {
        constexpr uint32_t PMADJ = (2 << 6);  ///< Plus-Minus
        constexpr uint32_t ADJ = (6 << 0);  ///< Adjustment Value These bits specify the adjustment value from the prescaler.
    }

}

// ============================================================================
// FCACHE Peripheral
// ============================================================================

namespace fcache {
    /// Base addresses
    constexpr uint32_t FCACHE_BASE = 0x4001C000;

    /// FCACHE Register structure
    struct Registers {
        volatile uint32_t FCACHEE;  ///< Offset: 0x100 - Flash Cache Enable Register
        volatile uint32_t FCACHEIV;  ///< Offset: 0x104 - Flash Cache Invalidate Register
    };

    /// Peripheral instances
    inline Registers* FCACHE = reinterpret_cast<Registers*>(FCACHE_BASE);

    // Bit definitions
    /// FCACHEE Register bits
    namespace fcachee_bits {
        constexpr uint32_t Reserved = (15 << 1);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
        constexpr uint32_t FCACHEEN = (1U << 0);  ///< FCACHE Enable
    }

    /// FCACHEIV Register bits
    namespace fcacheiv_bits {
        constexpr uint32_t Reserved = (15 << 1);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
        constexpr uint32_t FCACHEIV = (1U << 0);  ///< FCACHE Invalidation
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT0_BASE = 0x40040000;
    constexpr uint32_t PORT1_BASE = 0x40040020;
    constexpr uint32_t PORT2_BASE = 0x40040040;
    constexpr uint32_t PORT3_BASE = 0x40040060;
    constexpr uint32_t PORT4_BASE = 0x40040080;
    constexpr uint32_t PORT5_BASE = 0x400400A0;
    constexpr uint32_t PORT9_BASE = 0x40040120;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCNTR1;  ///< Offset: 0x00 - Port Control Register 1
        volatile uint32_t PODR;  ///< Offset: 0x00 - Output data register
        volatile uint32_t PDR;  ///< Offset: 0x02 - Direction register
        volatile uint32_t PCNTR2;  ///< Offset: 0x04 - Port Control Register 2
        volatile uint32_t PIDR;  ///< Offset: 0x06 - Input data register
        volatile uint32_t PCNTR3;  ///< Offset: 0x08 - Port Control Register 3
        volatile uint32_t PORR;  ///< Offset: 0x08 - Output reset register
        volatile uint32_t POSR;  ///< Offset: 0x0A - Output set register
    };

    /// Peripheral instances
    inline Registers* PORT0 = reinterpret_cast<Registers*>(PORT0_BASE);
    inline Registers* PORT1 = reinterpret_cast<Registers*>(PORT1_BASE);
    inline Registers* PORT2 = reinterpret_cast<Registers*>(PORT2_BASE);
    inline Registers* PORT3 = reinterpret_cast<Registers*>(PORT3_BASE);
    inline Registers* PORT4 = reinterpret_cast<Registers*>(PORT4_BASE);
    inline Registers* PORT5 = reinterpret_cast<Registers*>(PORT5_BASE);
    inline Registers* PORT9 = reinterpret_cast<Registers*>(PORT9_BASE);

}

// ============================================================================
// PFS Peripheral
// ============================================================================

namespace pfs {
    /// Base addresses
    constexpr uint32_t PFS_BASE = 0x40040800;

    /// PFS Register structure
    struct Registers {
        volatile uint32_t P000PFS;  ///< Offset: 0x00 - P000 Pin Function Control Register
        volatile uint32_t P000PFS_HA;  ///< Offset: 0x02 - P000 Pin Function Control Register
        volatile uint32_t P000PFS_BY;  ///< Offset: 0x03 - P000 Pin Function Control Register
        volatile uint32_t P00PFS;  ///< Offset: 0x04 - P00%s Pin Function Control Register (renamed from P00PFS)
        volatile uint32_t P00PFS_HA;  ///< Offset: 0x06 - P00%s Pin Function Control Register (renamed from P00PFS_HA)
        volatile uint32_t P00PFS_BY;  ///< Offset: 0x07 - P00%s Pin Function Control Register (renamed from P00PFS_BY)
        volatile uint32_t P0PFS;  ///< Offset: 0x30 - P0%s Pin Function Control Register (renamed from P0PFS)
        volatile uint32_t P0PFS_HA;  ///< Offset: 0x32 - P0%s Pin Function Control Register (renamed from P0PFS_HA)
        volatile uint32_t P0PFS_BY;  ///< Offset: 0x33 - P0%s Pin Function Control Register (renamed from P0PFS_BY)
        volatile uint32_t P100PFS;  ///< Offset: 0x40 - P100 Pin Function Control Register
        volatile uint32_t P100PFS_HA;  ///< Offset: 0x42 - P100 Pin Function Control Register
        volatile uint32_t P100PFS_BY;  ///< Offset: 0x43 - P100 Pin Function Control Register
        volatile uint32_t P10PFS;  ///< Offset: 0x44 - P10%s Pin Function Control Register (renamed from P10PFS)
        volatile uint32_t P10PFS_HA;  ///< Offset: 0x46 - P10%s Pin Function Control Register (renamed from P10PFS_HA)
        volatile uint32_t P10PFS_BY;  ///< Offset: 0x47 - P10%s Pin Function Control Register (renamed from P10PFS_BY)
        volatile uint32_t P108PFS;  ///< Offset: 0x60 - P108 Pin Function Control Register
        volatile uint32_t P108PFS_HA;  ///< Offset: 0x62 - P108 Pin Function Control Register
        volatile uint32_t P108PFS_BY;  ///< Offset: 0x63 - P108 Pin Function Control Register
        volatile uint32_t P109PFS;  ///< Offset: 0x64 - P109 Pin Function Control Register
        volatile uint32_t P109PFS_HA;  ///< Offset: 0x66 - P109 Pin Function Control Register
        volatile uint32_t P109PFS_BY;  ///< Offset: 0x67 - P109 Pin Function Control Register
        volatile uint32_t P1PFS;  ///< Offset: 0x68 - P1%s Pin Function Control Register (renamed from P1PFS)
        volatile uint32_t P1PFS_HA;  ///< Offset: 0x6A - P1%s Pin Function Control Register (renamed from P1PFS_HA)
        volatile uint32_t P1PFS_BY;  ///< Offset: 0x6B - P1%s Pin Function Control Register (renamed from P1PFS_BY)
        volatile uint32_t P200PFS;  ///< Offset: 0x80 - P200 Pin Function Control Register
        volatile uint32_t P200PFS_HA;  ///< Offset: 0x82 - P200 Pin Function Control Register
        volatile uint32_t P200PFS_BY;  ///< Offset: 0x83 - P200 Pin Function Control Register
        volatile uint32_t P201PFS;  ///< Offset: 0x84 - P201 Pin Function Control Register
        volatile uint32_t P201PFS_HA;  ///< Offset: 0x86 - P201 Pin Function Control Register
        volatile uint32_t P201PFS_BY;  ///< Offset: 0x87 - P201 Pin Function Control Register
        volatile uint32_t P20PFS;  ///< Offset: 0x90 - P20%s Pin Function Control Register (renamed from P20PFS)
        volatile uint32_t P20PFS_HA;  ///< Offset: 0x92 - P20%s Pin Function Control Register (renamed from P20PFS_HA)
        volatile uint32_t P20PFS_BY;  ///< Offset: 0x93 - P20%s Pin Function Control Register (renamed from P20PFS_BY)
        volatile uint32_t P2PFS;  ///< Offset: 0xB0 - P2%s Pin Function Control Register (renamed from P2PFS)
        volatile uint32_t P2PFS_HA;  ///< Offset: 0xB2 - P2%s Pin Function Control Register (renamed from P2PFS_HA)
        volatile uint32_t P2PFS_BY;  ///< Offset: 0xB3 - P2%s Pin Function Control Register (renamed from P2PFS_BY)
        volatile uint32_t P300PFS;  ///< Offset: 0xC0 - P300 Pin Function Control Register
        volatile uint32_t P300PFS_HA;  ///< Offset: 0xC2 - P300 Pin Function Control Register
        volatile uint32_t P300PFS_BY;  ///< Offset: 0xC3 - P300 Pin Function Control Register
        volatile uint32_t P30PFS;  ///< Offset: 0xC4 - P30%s Pin Function Control Register (renamed from P30PFS)
        volatile uint32_t P30PFS_HA;  ///< Offset: 0xC6 - P30%s Pin Function Control Register (renamed from P30PFS_HA)
        volatile uint32_t P30PFS_BY;  ///< Offset: 0xC7 - P30%s Pin Function Control Register (renamed from P30PFS_BY)
        volatile uint32_t P40PFS;  ///< Offset: 0x120 - P40%s Pin Function Control Register (renamed from P40PFS)
        volatile uint32_t P40PFS_HA;  ///< Offset: 0x122 - P40%s Pin Function Control Register (renamed from P40PFS_HA)
        volatile uint32_t P40PFS_BY;  ///< Offset: 0x123 - P40%s Pin Function Control Register (renamed from P40PFS_BY)
        volatile uint32_t P407PFS;  ///< Offset: 0x11C - P407 Pin Function Control Register
        volatile uint32_t P407PFS_HA;  ///< Offset: 0x11E - P407 Pin Function Control Register
        volatile uint32_t P407PFS_BY;  ///< Offset: 0x11F - P407 Pin Function Control Register
        volatile uint32_t P4PFS;  ///< Offset: 0x128 - P4%s Pin Function Control Register (renamed from P4PFS)
        volatile uint32_t P4PFS_HA;  ///< Offset: 0x12A - P4%s Pin Function Control Register (renamed from P4PFS_HA)
        volatile uint32_t P4PFS_BY;  ///< Offset: 0x12B - P4%s Pin Function Control Register (renamed from P4PFS_BY)
        volatile uint32_t P50PFS;  ///< Offset: 0x140 - P50%s Pin Function Control Register (renamed from P50PFS)
        volatile uint32_t P50PFS_HA;  ///< Offset: 0x142 - P50%s Pin Function Control Register (renamed from P50PFS_HA)
        volatile uint32_t P50PFS_BY;  ///< Offset: 0x143 - P50%s Pin Function Control Register (renamed from P50PFS_BY)
        volatile uint32_t P914PFS;  ///< Offset: 0x278 - P914 Pin Function Control Register
        volatile uint32_t P914PFS_HA;  ///< Offset: 0x27A - P914 Pin Function Control Register
        volatile uint32_t P914PFS_BY;  ///< Offset: 0x27B - P914 Pin Function Control Register
        volatile uint32_t P915PFS;  ///< Offset: 0x27C - P915 Pin Function Control Register
        volatile uint32_t P915PFS_HA;  ///< Offset: 0x27E - P915 Pin Function Control Register
        volatile uint32_t P915PFS_BY;  ///< Offset: 0x27F - P915 Pin Function Control Register
    };

    /// Peripheral instances
    inline Registers* PFS = reinterpret_cast<Registers*>(PFS_BASE);

    // Bit definitions
    /// P000PFS Register bits
    namespace p000pfs_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t DSCR = (1U << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P000PFS_HA Register bits
    namespace p000pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DSCR = (1U << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P000PFS_BY Register bits
    namespace p000pfs_by_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P100PFS Register bits
    namespace p100pfs_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t DSCR = (1U << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P100PFS_HA Register bits
    namespace p100pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DSCR = (1U << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P100PFS_BY Register bits
    namespace p100pfs_by_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P407PFS Register bits
    namespace p407pfs_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t DSCR1 = (1U << 11);  ///< Drive Strength Control Register
        constexpr uint32_t DSCR = (1U << 10);  ///< DSCR
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P407PFS_HA Register bits
    namespace p407pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DSCR1 = (1U << 11);  ///< Drive Strength Control Register
        constexpr uint32_t DSCR = (1U << 10);  ///< DSCR
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P407PFS_BY Register bits
    namespace p407pfs_by_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

}

// ============================================================================
// PMISC Peripheral
// ============================================================================

namespace pmisc {
    /// Base addresses
    constexpr uint32_t PMISC_BASE = 0x40040D00;

    /// PMISC Register structure
    struct Registers {
        volatile uint32_t PWPR;  ///< Offset: 0x03 - Write-Protect Register
    };

    /// Peripheral instances
    inline Registers* PMISC = reinterpret_cast<Registers*>(PMISC_BASE);

    // Bit definitions
    /// PWPR Register bits
    namespace pwpr_bits {
        constexpr uint32_t B0WI = (1U << 7);  ///< PFSWE Bit Write Disable
        constexpr uint32_t PFSWE = (1U << 6);  ///< PFS Register Write Enable
        constexpr uint32_t Reserved = (6 << 0);  ///< These bits are read as 000000. The write value should be 000000.
    }

}


} // namespace alloy::generated::r7fa2a1ab

#endif // ALLOY_GENERATED_R7FA2A1AB_PERIPHERALS_HPP