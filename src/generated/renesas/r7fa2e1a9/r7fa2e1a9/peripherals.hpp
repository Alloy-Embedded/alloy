/// Auto-generated code for R7FA2E1A9
/// Generated by Alloy Code Generator
/// Source: renesas_r7fa2e1a9.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:38
#ifndef ALLOY_GENERATED_R7FA2E1A9_PERIPHERALS_HPP
#define ALLOY_GENERATED_R7FA2E1A9_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::r7fa2e1a9 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_rmpu = true;
    constexpr uint32_t num_rmpu_instances = 1;
    constexpr bool has_sram = true;
    constexpr uint32_t num_sram_instances = 1;
    constexpr bool has_bus = true;
    constexpr uint32_t num_bus_instances = 1;
    constexpr bool has_dtc = true;
    constexpr uint32_t num_dtc_instances = 1;
    constexpr bool has_icu = true;
    constexpr uint32_t num_icu_instances = 1;
    constexpr bool has_dbg = true;
    constexpr uint32_t num_dbg_instances = 1;
    constexpr bool has_sysc = true;
    constexpr uint32_t num_sysc_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 7;
    constexpr bool has_pfs = true;
    constexpr uint32_t num_pfs_instances = 1;
    constexpr bool has_elc = true;
    constexpr uint32_t num_elc_instances = 1;
    constexpr bool has_poeg = true;
    constexpr uint32_t num_poeg_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_cac = true;
    constexpr uint32_t num_cac_instances = 1;
    constexpr bool has_mstp = true;
    constexpr uint32_t num_mstp_instances = 1;
    constexpr bool has_iic0 = true;
    constexpr uint32_t num_iic0_instances = 1;
    constexpr bool has_iic0wu = true;
    constexpr uint32_t num_iic0wu_instances = 1;
    constexpr bool has_doc = true;
    constexpr uint32_t num_doc_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_sci0 = true;
    constexpr uint32_t num_sci0_instances = 1;
    constexpr bool has_sci1 = true;
    constexpr uint32_t num_sci1_instances = 1;
    constexpr bool has_sci2 = true;
    constexpr uint32_t num_sci2_instances = 1;
    constexpr bool has_sci9 = true;
    constexpr uint32_t num_sci9_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_gpt320 = true;
    constexpr uint32_t num_gpt320_instances = 1;
    constexpr bool has_gpt164 = true;
    constexpr uint32_t num_gpt164_instances = 1;
    constexpr bool has_gpt165 = true;
    constexpr uint32_t num_gpt165_instances = 1;
    constexpr bool has_gpt166 = true;
    constexpr uint32_t num_gpt166_instances = 1;
    constexpr bool has_gpt167 = true;
    constexpr uint32_t num_gpt167_instances = 1;
    constexpr bool has_gpt168 = true;
    constexpr uint32_t num_gpt168_instances = 1;
    constexpr bool has_gpt169 = true;
    constexpr uint32_t num_gpt169_instances = 1;
    constexpr bool has_gpt = true;
    constexpr uint32_t num_gpt_instances = 1;
    constexpr bool has_kint = true;
    constexpr uint32_t num_kint_instances = 1;
    constexpr bool has_ctsu = true;
    constexpr uint32_t num_ctsu_instances = 1;
    constexpr bool has_agt0 = true;
    constexpr uint32_t num_agt0_instances = 1;
    constexpr bool has_agt1 = true;
    constexpr uint32_t num_agt1_instances = 1;
    constexpr bool has_acmplp = true;
    constexpr uint32_t num_acmplp_instances = 1;
    constexpr bool has_flcn = true;
    constexpr uint32_t num_flcn_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct rmpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sram_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bus_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct icu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dbg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sysc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 7;
    };
    template<>
    struct peripheral_count<struct pfs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct elc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct poeg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct cac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mstp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct iic0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct iic0wu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct doc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci9_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt320_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt164_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt165_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt166_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt167_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt168_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt169_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct kint_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ctsu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct agt0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct agt1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct acmplp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flcn_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 7;
    constexpr uint32_t max_gpio_pins = 112;  // 16 pins per port

    // USART-specific traits
}

// ============================================================================
// RMPU Peripheral
// ============================================================================

namespace rmpu {
    /// Base addresses
    constexpr uint32_t RMPU_BASE = 0x40000000;

    /// RMPU Register structure
    struct Registers {
        volatile uint32_t MMPUCTLA;  ///< Offset: 0x00 - Bus Master MPU Control Register
        volatile uint32_t MMPUPTA;  ///< Offset: 0x102 - Group A Protection of Register
        volatile uint32_t MMPUACA%s;  ///< Offset: 0x200 - Group A Region %s access control register
        volatile uint32_t MMPUSA%s;  ///< Offset: 0x204 - Group A Region %s Start Address Register
        volatile uint32_t MMPUEA%s;  ///< Offset: 0x208 - Group A Region %s End Address Register
        volatile uint32_t SMPUCTL;  ///< Offset: 0xC00 - Slave MPU Control Register
        volatile uint32_t SMPUMBIU;  ///< Offset: 0xC10 - Access Control Register for Memory Bus 1
        volatile uint32_t SMPUFBIU;  ///< Offset: 0xC14 - Access Control Register for Internal Peripheral Bus 9
        volatile uint32_t SMPUSRAM0;  ///< Offset: 0xC18 - Access Control Register for Memory Bus 4
        volatile uint32_t SMPUP0BIU;  ///< Offset: 0xC20 - Access Control Register for Internal Peripheral Bus 1
        volatile uint32_t SMPUP2BIU;  ///< Offset: 0xC24 - Access Control Register for Internal Peripheral Bus 3
        volatile uint32_t SMPUP6BIU;  ///< Offset: 0xC28 - Access Control Register for Internal Peripheral Bus 7
        volatile uint32_t MSPMPUOAD;  ///< Offset: 0xD00 - Stack Pointer Monitor Operation After Detection Register
        volatile uint32_t MSPMPUCTL;  ///< Offset: 0xD04 - Stack Pointer Monitor Access Control Register
        volatile uint32_t MSPMPUPT;  ///< Offset: 0xD06 - Stack Pointer Monitor Protection Register
        volatile uint32_t MSPMPUSA;  ///< Offset: 0xD08 - Main Stack Pointer (MSP) Monitor Start Address Register
        volatile uint32_t MSPMPUEA;  ///< Offset: 0xD0C - Main Stack Pointer (MSP) Monitor End Address Register
        volatile uint32_t PSPMPUOAD;  ///< Offset: 0xD10 - Stack Pointer Monitor Operation After Detection Register
        volatile uint32_t PSPMPUCTL;  ///< Offset: 0xD14 - Stack Pointer Monitor Access Control Register
        volatile uint32_t PSPMPUPT;  ///< Offset: 0xD16 - Stack Pointer Monitor Protection Register
        volatile uint32_t PSPMPUSA;  ///< Offset: 0xD18 - Process Stack Pointer (PSP) Monitor Start Address Register
        volatile uint32_t PSPMPUEA;  ///< Offset: 0xD1C - Process Stack Pointer (PSP) Monitor End Address Register
    };

    /// Peripheral instances
    inline Registers* RMPU = reinterpret_cast<Registers*>(RMPU_BASE);

    // Bit definitions
    /// MMPUCTLA Register bits
    namespace mmpuctla_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Master Group Enable
        constexpr uint32_t OAD = (1U << 1);  ///< Operation After Detection
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// MMPUPTA Register bits
    namespace mmpupta_bits {
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of Register
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// MMPUACA%s Register bits
    namespace mmpuaca%s_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region Enable
        constexpr uint32_t RP = (1U << 1);  ///< Read Protection
        constexpr uint32_t WP = (1U << 2);  ///< Write Protection
    }

    /// MMPUSA%s Register bits
    namespace mmpusa%s_bits {
        constexpr uint32_t MMPUSA = (32 << 0);  ///< Region Start Address
    }

    /// MMPUEA%s Register bits
    namespace mmpuea%s_bits {
        constexpr uint32_t MMPUEA = (32 << 0);  ///< Region End Address
    }

    /// SMPUCTL Register bits
    namespace smpuctl_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation After Detection
        constexpr uint32_t PROTECT = (1U << 1);  ///< Protection of Register
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// SMPUMBIU Register bits
    namespace smpumbiu_bits {
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master MPU Group A Read Protection
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master MPU Group A Write Protection
    }

    /// SMPUFBIU Register bits
    namespace smpufbiu_bits {
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read Protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write Protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master MPU Group A Read Protection
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master MPU Group A Write Protection
    }

    /// SMPUSRAM0 Register bits
    namespace smpusram0_bits {
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read Protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write Protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master MPU Group A Read Protection
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master MPU Group A Write Protection
    }

    /// SMPUP0BIU Register bits
    namespace smpup0biu_bits {
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read Protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write Protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master MPU Group A Read Protection
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master MPU Group A Write Protection
    }

    /// SMPUP2BIU Register bits
    namespace smpup2biu_bits {
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read Protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write Protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master MPU Group A Read Protection
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master MPU Group A Write Protection
    }

    /// SMPUP6BIU Register bits
    namespace smpup6biu_bits {
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read Protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write Protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master MPU Group A Read Protection
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master MPU Group A Write Protection
    }

    /// MSPMPUOAD Register bits
    namespace mspmpuoad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after Detection
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// MSPMPUCTL Register bits
    namespace mspmpuctl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Stack Pointer Monitor Enable
        constexpr uint32_t ERROR = (1U << 8);  ///< Stack Pointer Monitor Error Flag
    }

    /// MSPMPUPT Register bits
    namespace mspmpupt_bits {
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of Register
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// MSPMPUSA Register bits
    namespace mspmpusa_bits {
        constexpr uint32_t MSPMPUSA = (32 << 0);  ///< Region Start Address
    }

    /// MSPMPUEA Register bits
    namespace mspmpuea_bits {
        constexpr uint32_t MSPMPUEA = (32 << 0);  ///< Region End Address
    }

    /// PSPMPUOAD Register bits
    namespace pspmpuoad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after Detection
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// PSPMPUCTL Register bits
    namespace pspmpuctl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Stack Pointer Monitor Enable
        constexpr uint32_t ERROR = (1U << 8);  ///< Stack Pointer Monitor Error Flag
    }

    /// PSPMPUPT Register bits
    namespace pspmpupt_bits {
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of Register
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// PSPMPUSA Register bits
    namespace pspmpusa_bits {
        constexpr uint32_t PSPMPUSA = (32 << 0);  ///< Region Start Address
    }

    /// PSPMPUEA Register bits
    namespace pspmpuea_bits {
        constexpr uint32_t PSPMPUEA = (32 << 0);  ///< Region End Address
    }

}

// ============================================================================
// SRAM Peripheral
// ============================================================================

namespace sram {
    /// Base addresses
    constexpr uint32_t SRAM_BASE = 0x40002000;

    /// SRAM Register structure
    struct Registers {
        volatile uint32_t PARIOAD;  ///< Offset: 0x00 - SRAM Parity Error Operation After Detection Register
        volatile uint32_t SRAMPRCR;  ///< Offset: 0x04 - SRAM Protection Register
    };

    /// Peripheral instances
    inline Registers* SRAM = reinterpret_cast<Registers*>(SRAM_BASE);

    // Bit definitions
    /// PARIOAD Register bits
    namespace parioad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation After Detection
    }

    /// SRAMPRCR Register bits
    namespace sramprcr_bits {
        constexpr uint32_t SRAMPRCR = (1U << 0);  ///< Register Write Control
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
    }

}

// ============================================================================
// BUS Peripheral
// ============================================================================

namespace bus {
    /// Base addresses
    constexpr uint32_t BUS_BASE = 0x40003000;

    /// BUS Register structure
    struct Registers {
        volatile uint32_t BUSMCNTSYS;  ///< Offset: 0x1008 - Master Bus Control Register SYS
        volatile uint32_t BUSMCNTDMA;  ///< Offset: 0x100C - Master Bus Control Register DMA
        volatile uint32_t BUS3ERRADD;  ///< Offset: 0x1820 - Bus Error Address Register 3
        volatile uint32_t BUS3ERRSTAT;  ///< Offset: 0x1824 - BUS Error Status Register 3
        volatile uint32_t BUS4ERRADD;  ///< Offset: 0x1830 - Bus Error Address Register 4
        volatile uint32_t BUS4ERRSTAT;  ///< Offset: 0x1834 - BUS Error Status Register 4
    };

    /// Peripheral instances
    inline Registers* BUS = reinterpret_cast<Registers*>(BUS_BASE);

    // Bit definitions
    /// BUSMCNTSYS Register bits
    namespace busmcntsys_bits {
        constexpr uint32_t IERES = (1U << 15);  ///< Ignore Error Responses
    }

    /// BUSMCNTDMA Register bits
    namespace busmcntdma_bits {
        constexpr uint32_t IERES = (1U << 15);  ///< Ignore Error Responses
    }

    /// BUS3ERRADD Register bits
    namespace bus3erradd_bits {
        constexpr uint32_t BERAD = (32 << 0);  ///< Bus Error Address
    }

    /// BUS3ERRSTAT Register bits
    namespace bus3errstat_bits {
        constexpr uint32_t ACCSTAT = (1U << 0);  ///< Error Access Status flag
        constexpr uint32_t ERRSTAT = (1U << 7);  ///< Bus Error Status flag
    }

    /// BUS4ERRADD Register bits
    namespace bus4erradd_bits {
        constexpr uint32_t BERAD = (32 << 0);  ///< Bus Error Address
    }

    /// BUS4ERRSTAT Register bits
    namespace bus4errstat_bits {
        constexpr uint32_t ACCSTAT = (1U << 0);  ///< Error Access Status flag
        constexpr uint32_t ERRSTAT = (1U << 7);  ///< Bus Error Status flag
    }

}

// ============================================================================
// DTC Peripheral
// ============================================================================

namespace dtc {
    /// Base addresses
    constexpr uint32_t DTC_BASE = 0x40005400;

    /// DTC Register structure
    struct Registers {
        volatile uint32_t DTCCR;  ///< Offset: 0x00 - DTC Control Register
        volatile uint32_t DTCVBR;  ///< Offset: 0x04 - DTC Vector Base Register
        volatile uint32_t DTCST;  ///< Offset: 0x0C - DTC Module Start Register
        volatile uint32_t DTCSTS;  ///< Offset: 0x0E - DTC Status Register
    };

    /// Peripheral instances
    inline Registers* DTC = reinterpret_cast<Registers*>(DTC_BASE);

    // Bit definitions
    /// DTCCR Register bits
    namespace dtccr_bits {
        constexpr uint32_t RRS = (1U << 4);  ///< DTC Transfer Information Read Skip Enable
    }

    /// DTCST Register bits
    namespace dtcst_bits {
        constexpr uint32_t DTCST = (1U << 0);  ///< DTC Module Start
    }

    /// DTCSTS Register bits
    namespace dtcsts_bits {
        constexpr uint32_t VECN = (8 << 0);  ///< DTC-Activating Vector Number Monitoring
        constexpr uint32_t ACT = (1U << 15);  ///< DTC Active Flag
    }

}

// ============================================================================
// ICU Peripheral
// ============================================================================

namespace icu {
    /// Base addresses
    constexpr uint32_t ICU_BASE = 0x40006000;

    /// ICU Register structure
    struct Registers {
        volatile uint32_t IRQCR%s;  ///< Offset: 0x00 - IRQ Control Register %s
        volatile uint32_t NMICR;  ///< Offset: 0x100 - NMI Pin Interrupt Control Register
        volatile uint32_t NMIER;  ///< Offset: 0x120 - Non-Maskable Interrupt Enable Register
        volatile uint32_t NMICLR;  ///< Offset: 0x130 - Non-Maskable Interrupt Status Clear Register
        volatile uint32_t NMISR;  ///< Offset: 0x140 - Non-Maskable Interrupt Status Register
        volatile uint32_t WUPEN;  ///< Offset: 0x1A0 - Wake Up Interrupt Enable Register
        volatile uint32_t IELEN;  ///< Offset: 0x1C0 - ICU event Enable Register
        volatile uint32_t SELSR0;  ///< Offset: 0x200 - SYS Event Link Setting Register
        volatile uint32_t IELSR%s;  ///< Offset: 0x300 - ICU Event Link Setting Register %s
    };

    /// Peripheral instances
    inline Registers* ICU = reinterpret_cast<Registers*>(ICU_BASE);

    // Bit definitions
    /// IRQCR%s Register bits
    namespace irqcr%s_bits {
        constexpr uint32_t IRQMD = (2 << 0);  ///< IRQi Detection Sense Select
        constexpr uint32_t FCLKSEL = (2 << 4);  ///< IRQi Digital Filter Sampling Clock Select
        constexpr uint32_t FLTEN = (1U << 7);  ///< IRQi Digital Filter Enable
    }

    /// NMICR Register bits
    namespace nmicr_bits {
        constexpr uint32_t NMIMD = (1U << 0);  ///< NMI Detection Set
        constexpr uint32_t NFCLKSEL = (2 << 4);  ///< NMI Digital Filter Sampling Clock Select
        constexpr uint32_t NFLTEN = (1U << 7);  ///< NMI Digital Filter Enable
    }

    /// NMIER Register bits
    namespace nmier_bits {
        constexpr uint32_t IWDTEN = (1U << 0);  ///< IWDT Underflow/Refresh Error Interrupt Enable
        constexpr uint32_t WDTEN = (1U << 1);  ///< WDT Underflow/Refresh Error Interrupt Enable
        constexpr uint32_t LVD1EN = (1U << 2);  ///< Voltage monitor 1 Interrupt Enable
        constexpr uint32_t LVD2EN = (1U << 3);  ///< Voltage monitor 2 Interrupt Enable
        constexpr uint32_t OSTEN = (1U << 6);  ///< Main Clock Oscillation Stop Detection Interrupt Enable
        constexpr uint32_t NMIEN = (1U << 7);  ///< NMI Pin Interrupt Enable
        constexpr uint32_t RPEEN = (1U << 8);  ///< SRAM Parity Error Interrupt Enable
        constexpr uint32_t BUSSEN = (1U << 10);  ///< Bus Slave MPU Error Interrupt Enable
        constexpr uint32_t BUSMEN = (1U << 11);  ///< Bus Master MPU Error Interrupt Enable
        constexpr uint32_t SPEEN = (1U << 12);  ///< CPU Stack Pointer Monitor Interrupt Enable
    }

    /// NMICLR Register bits
    namespace nmiclr_bits {
        constexpr uint32_t IWDTCLR = (1U << 0);  ///< IWDT Underflow/Refresh Error Interrupt Status Flag Clear
        constexpr uint32_t WDTCLR = (1U << 1);  ///< WDT Underflow/Refresh Error Interrupt Status Flag Clear
        constexpr uint32_t LVD1CLR = (1U << 2);  ///< Voltage Monitor 1 Interrupt Status Flag Clear
        constexpr uint32_t LVD2CLR = (1U << 3);  ///< Voltage Monitor 2 Interrupt Status Flag Clear
        constexpr uint32_t OSTCLR = (1U << 6);  ///< Oscillation Stop Detection Interrupt Status Flag Clear
        constexpr uint32_t NMICLR = (1U << 7);  ///< NMI Pin Interrupt Status Flag Clear
        constexpr uint32_t RPECLR = (1U << 8);  ///< SRAM Parity Error Interrupt Status Flag Clear
        constexpr uint32_t BUSSCLR = (1U << 10);  ///< Bus Slave MPU Error Interrupt Status Flag Clear
        constexpr uint32_t BUSMCLR = (1U << 11);  ///< Bus Master MPU Error Interrupt Status Flag Clear
        constexpr uint32_t SPECLR = (1U << 12);  ///< CPU Stack Pointer Monitor Interrupt Status Flag Clear
    }

    /// NMISR Register bits
    namespace nmisr_bits {
        constexpr uint32_t IWDTST = (1U << 0);  ///< IWDT Underflow/Refresh Error Interrupt Status Flag
        constexpr uint32_t WDTST = (1U << 1);  ///< WDT Underflow/Refresh Error Interrupt Status Flag
        constexpr uint32_t LVD1ST = (1U << 2);  ///< Voltage Monitor 1 Interrupt Status Flag
        constexpr uint32_t LVD2ST = (1U << 3);  ///< Voltage Monitor 2 Interrupt Status Flag
        constexpr uint32_t OSTST = (1U << 6);  ///< Main Clock Oscillation Stop Detection Interrupt Status Flag
        constexpr uint32_t NMIST = (1U << 7);  ///< NMI Pin Interrupt Status Flag
        constexpr uint32_t RPEST = (1U << 8);  ///< SRAM Parity Error Interrupt Status Flag
        constexpr uint32_t BUSSST = (1U << 10);  ///< Bus Slave MPU Error Interrupt Status Flag
        constexpr uint32_t BUSMST = (1U << 11);  ///< Bus Master MPU Error Interrupt Status Flag
        constexpr uint32_t SPEST = (1U << 12);  ///< CPU Stack Pointer Monitor Interrupt Status Flag
    }

    /// WUPEN Register bits
    namespace wupen_bits {
        constexpr uint32_t IRQWUPEN = (8 << 0);  ///< IRQ Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t IWDTWUPEN = (1U << 16);  ///< IWDT Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t KEYWUPEN = (1U << 17);  ///< Key Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t LVD1WUPEN = (1U << 18);  ///< LVD1 Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t LVD2WUPEN = (1U << 19);  ///< LVD2 Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t ACMPLP0WUPEN = (1U << 23);  ///< ACMPLP0 Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t RTCALMWUPEN = (1U << 24);  ///< RTC Alarm Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t RTCPRDWUPEN = (1U << 25);  ///< RTC Period Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t AGT1UDWUPEN = (1U << 28);  ///< AGT1 Underflow Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t AGT1CAWUPEN = (1U << 29);  ///< AGT1 Compare Match A Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t AGT1CBWUPEN = (1U << 30);  ///< AGT1 Compare Match B Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t IIC0WUPEN = (1U << 31);  ///< IIC0 Address Match Interrupt Software Standby/Snooze Mode Returns Enable
    }

    /// IELEN Register bits
    namespace ielen_bits {
        constexpr uint32_t RTCINTEN = (1U << 0);  ///< RTCALM and RTCPRD Interrupts Enable (when LPOPTEN bit = 1)
        constexpr uint32_t IELEN = (1U << 1);  ///< Parts Asynchronous Interrupts Enable except RTC (when LPOPTEN bit = 1)
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0x4001B000;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t DBGSTR;  ///< Offset: 0x00 - Debug Status Register
        volatile uint32_t DBGSTOPCR;  ///< Offset: 0x10 - Debug Stop Control Register
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// DBGSTR Register bits
    namespace dbgstr_bits {
        constexpr uint32_t CDBGPWRUPREQ = (1U << 28);  ///< Debug power-up request
        constexpr uint32_t CDBGPWRUPACK = (1U << 29);  ///< Debug power-up acknowledge
    }

    /// DBGSTOPCR Register bits
    namespace dbgstopcr_bits {
        constexpr uint32_t DBGSTOP_IWDT = (1U << 0);  ///< Mask bit for IWDT reset/interrupt in the OCD run mode
        constexpr uint32_t DBGSTOP_WDT = (1U << 1);  ///< Mask bit for WDT reset/interrupt in the OCD run mode
        constexpr uint32_t DBGSTOP_LVD0 = (1U << 16);  ///< Mask bit for LVD0 reset
        constexpr uint32_t DBGSTOP_LVD1 = (1U << 17);  ///< Mask bit for LVD1 reset/interrupt
        constexpr uint32_t DBGSTOP_LVD2 = (1U << 18);  ///< Mask bit for LVD2 reset/interrupt
        constexpr uint32_t DBGSTOP_RPER = (1U << 24);  ///< Mask bit for SRAM parity error reset/interrupt
    }

}

// ============================================================================
// SYSC Peripheral
// ============================================================================

namespace sysc {
    /// Base addresses
    constexpr uint32_t SYSC_BASE = 0x4001E000;

    /// SYSC Register structure
    struct Registers {
        volatile uint32_t SBYCR;  ///< Offset: 0x0C - Standby Control Register
        volatile uint32_t MSTPCRA;  ///< Offset: 0x1C - Module Stop Control Register A
        volatile uint32_t SCKDIVCR;  ///< Offset: 0x20 - System Clock Division Control Register
        volatile uint32_t SCKSCR;  ///< Offset: 0x26 - System Clock Source Control Register
        volatile uint32_t MEMWAIT;  ///< Offset: 0x31 - Memory Wait Cycle Control Register for Code Flash
        volatile uint32_t MOSCCR;  ///< Offset: 0x32 - Main Clock Oscillator Control Register
        volatile uint32_t HOCOCR;  ///< Offset: 0x36 - High-Speed On-Chip Oscillator Control Register
        volatile uint32_t MOCOCR;  ///< Offset: 0x38 - Middle-Speed On-Chip Oscillator Control Register
        volatile uint32_t OSCSF;  ///< Offset: 0x3C - Oscillation Stabilization Flag Register
        volatile uint32_t CKOCR;  ///< Offset: 0x3E - Clock Out Control Register
        volatile uint32_t OSTDCR;  ///< Offset: 0x40 - Oscillation Stop Detection Control Register
        volatile uint32_t OSTDSR;  ///< Offset: 0x41 - Oscillation Stop Detection Status Register
        volatile uint32_t LPOPT;  ///< Offset: 0x4C - Lower Power Operation Control Register
        volatile uint32_t MOCOUTCR;  ///< Offset: 0x61 - MOCO User Trimming Control Register
        volatile uint32_t HOCOUTCR;  ///< Offset: 0x62 - HOCO User Trimming Control Register
        volatile uint32_t SNZCR;  ///< Offset: 0x92 - Snooze Control Register
        volatile uint32_t SNZEDCR0;  ///< Offset: 0x94 - Snooze End Control Register 0
        volatile uint32_t SNZREQCR0;  ///< Offset: 0x98 - Snooze Request Control Register 0
        volatile uint32_t PSMCR;  ///< Offset: 0x9F - Power Save Memory Control Register
        volatile uint32_t OPCCR;  ///< Offset: 0xA0 - Operating Power Control Register
        volatile uint32_t MOSCWTCR;  ///< Offset: 0xA2 - Main Clock Oscillator Wait Control Register
        volatile uint32_t HOCOWTCR;  ///< Offset: 0xA5 - High-Speed On-Chip Oscillator Wait Control Register
        volatile uint32_t SOPCCR;  ///< Offset: 0xAA - Sub Operating Power Control Register
        volatile uint32_t RSTSR1;  ///< Offset: 0xC0 - Reset Status Register 1
        volatile uint32_t LVD1CR1;  ///< Offset: 0xE0 - Voltage Monitor 1 Circuit Control Register
        volatile uint32_t LVD1SR;  ///< Offset: 0xE1 - Voltage Monitor 1 Circuit Status Register
        volatile uint32_t LVD2CR1;  ///< Offset: 0xE2 - Voltage Monitor 2 Circuit Control Register 1
        volatile uint32_t LVD2SR;  ///< Offset: 0xE3 - Voltage Monitor 2 Circuit Status Register
        volatile uint32_t PRCR;  ///< Offset: 0x3FE - Protect Register
        volatile uint32_t SYOCDCR;  ///< Offset: 0x40E - System Control OCD Control Register
        volatile uint32_t RSTSR0;  ///< Offset: 0x410 - Reset Status Register 0
        volatile uint32_t RSTSR2;  ///< Offset: 0x411 - Reset Status Register 2
        volatile uint32_t MOMCR;  ///< Offset: 0x413 - Main Clock Oscillator Mode Oscillation Control Register
        volatile uint32_t LVCMPCR;  ///< Offset: 0x417 - Voltage Monitor Circuit Control Register
        volatile uint32_t LVDLVLR;  ///< Offset: 0x418 - Voltage Detection Level Select Register
        volatile uint32_t LVD1CR0;  ///< Offset: 0x41A - Voltage Monitor 1 Circuit Control Register 0
        volatile uint32_t LVD2CR0;  ///< Offset: 0x41B - Voltage Monitor 2 Circuit Control Register 0
        volatile uint32_t SOSCCR;  ///< Offset: 0x480 - Sub-Clock Oscillator Control Register
        volatile uint32_t SOMCR;  ///< Offset: 0x481 - Sub-Clock Oscillator Mode Control Register
        volatile uint32_t SOMRG;  ///< Offset: 0x482 - Sub-Clock Oscillator Margin Check Register
        volatile uint32_t LOCOCR;  ///< Offset: 0x490 - Low-Speed On-Chip Oscillator Control Register
        volatile uint32_t LOCOUTCR;  ///< Offset: 0x492 - LOCO User Trimming Control Register
    };

    /// Peripheral instances
    inline Registers* SYSC = reinterpret_cast<Registers*>(SYSC_BASE);

    // Bit definitions
    /// SBYCR Register bits
    namespace sbycr_bits {
        constexpr uint32_t SSBY = (1U << 15);  ///< Software Standby Mode Select
    }

    /// MSTPCRA Register bits
    namespace mstpcra_bits {
        constexpr uint32_t MSTPA22 = (1U << 22);  ///< DTC Module Stop
    }

    /// SCKDIVCR Register bits
    namespace sckdivcr_bits {
        constexpr uint32_t PCKD = (3 << 0);  ///< Peripheral Module Clock D (PCLKD) Select
        constexpr uint32_t PCKB = (3 << 8);  ///< Peripheral Module Clock B (PCLKB) Select
        constexpr uint32_t ICK = (3 << 24);  ///< System Clock (ICLK) Select
    }

    /// SCKSCR Register bits
    namespace sckscr_bits {
        constexpr uint32_t CKSEL = (3 << 0);  ///< Clock Source Select
    }

    /// MEMWAIT Register bits
    namespace memwait_bits {
        constexpr uint32_t MEMWAIT = (1U << 0);  ///< Memory Wait Cycle Select for Code Flash
    }

    /// MOSCCR Register bits
    namespace mosccr_bits {
        constexpr uint32_t MOSTP = (1U << 0);  ///< Main Clock Oscillator Stop
    }

    /// HOCOCR Register bits
    namespace hococr_bits {
        constexpr uint32_t HCSTP = (1U << 0);  ///< HOCO Stop
    }

    /// MOCOCR Register bits
    namespace mococr_bits {
        constexpr uint32_t MCSTP = (1U << 0);  ///< MOCO Stop
    }

    /// OSCSF Register bits
    namespace oscsf_bits {
        constexpr uint32_t HOCOSF = (1U << 0);  ///< HOCO Clock Oscillation Stabilization Flag
        constexpr uint32_t MOSCSF = (1U << 3);  ///< Main Clock Oscillation Stabilization Flag
    }

    /// CKOCR Register bits
    namespace ckocr_bits {
        constexpr uint32_t CKOSEL = (3 << 0);  ///< Clock Out Source Select
        constexpr uint32_t CKODIV = (3 << 4);  ///< Clock Output Frequency Division Ratio
        constexpr uint32_t CKOEN = (1U << 7);  ///< Clock Out Enable
    }

    /// OSTDCR Register bits
    namespace ostdcr_bits {
        constexpr uint32_t OSTDIE = (1U << 0);  ///< Oscillation Stop Detection Interrupt Enable
        constexpr uint32_t OSTDE = (1U << 7);  ///< Oscillation Stop Detection Function Enable
    }

    /// OSTDSR Register bits
    namespace ostdsr_bits {
        constexpr uint32_t OSTDF = (1U << 0);  ///< Oscillation Stop Detection Flag
    }

    /// LPOPT Register bits
    namespace lpopt_bits {
        constexpr uint32_t MPUDIS = (1U << 0);  ///< MPU Clock Disable Control
        constexpr uint32_t DCLKDIS = (2 << 1);  ///< Debug Clock Disable Control
        constexpr uint32_t BPFCLKDIS = (1U << 3);  ///< BPF Clock Disable Control
        constexpr uint32_t LPOPTEN = (1U << 7);  ///< Lower Power Operation Enable
    }

    /// MOCOUTCR Register bits
    namespace mocoutcr_bits {
        constexpr uint32_t MOCOUTRM = (8 << 0);  ///< MOCO User Trimming
    }

    /// HOCOUTCR Register bits
    namespace hocoutcr_bits {
        constexpr uint32_t HOCOUTRM = (8 << 0);  ///< HOCO User Trimming
    }

    /// SNZCR Register bits
    namespace snzcr_bits {
        constexpr uint32_t RXDREQEN = (1U << 0);  ///< RXD0 Snooze Request Enable
        constexpr uint32_t SNZDTCEN = (1U << 1);  ///< DTC Enable in Snooze mode
        constexpr uint32_t SNZE = (1U << 7);  ///< Snooze mode Enable
    }

    /// SNZEDCR0 Register bits
    namespace snzedcr0_bits {
        constexpr uint32_t AGTUNFED = (1U << 0);  ///< AGT1 Underflow Snooze End Enable
        constexpr uint32_t DTCZRED = (1U << 1);  ///< Last DTC Transmission Completion Snooze End Enable
        constexpr uint32_t DTCNZRED = (1U << 2);  ///< Not Last DTC Transmission Completion Snooze End Enable
        constexpr uint32_t AD0MATED = (1U << 3);  ///< ADC12 Compare Match Snooze End Enable
        constexpr uint32_t AD0UMTED = (1U << 4);  ///< ADC12 Compare Mismatch Snooze End Enable
        constexpr uint32_t SCI0UMTED = (1U << 7);  ///< SCI0 Address Mismatch Snooze End Enable
    }

    /// SNZREQCR0 Register bits
    namespace snzreqcr0_bits {
        constexpr uint32_t SNZREQEN0 = (1U << 0);  ///< Enable IRQ0 pin snooze request
        constexpr uint32_t SNZREQEN1 = (1U << 1);  ///< Enable IRQ1 pin snooze request
        constexpr uint32_t SNZREQEN2 = (1U << 2);  ///< Enable IRQ2 pin snooze request
        constexpr uint32_t SNZREQEN3 = (1U << 3);  ///< Enable IRQ3 pin snooze request
        constexpr uint32_t SNZREQEN4 = (1U << 4);  ///< Enable IRQ4 pin snooze request
        constexpr uint32_t SNZREQEN5 = (1U << 5);  ///< Enable IRQ5 pin snooze request
        constexpr uint32_t SNZREQEN6 = (1U << 6);  ///< Enable IRQ6 pin snooze request
        constexpr uint32_t SNZREQEN7 = (1U << 7);  ///< Enable IRQ7 pin snooze request
        constexpr uint32_t SNZREQEN17 = (1U << 17);  ///< Enable KEY_INTKR snooze request
        constexpr uint32_t SNZREQEN23 = (1U << 23);  ///< Enable ACMPLP snooze request
        constexpr uint32_t SNZREQEN24 = (1U << 24);  ///< Enable RTC alarm snooze request
        constexpr uint32_t SNZREQEN25 = (1U << 25);  ///< Enable RTC period snooze request
        constexpr uint32_t SNZREQEN28 = (1U << 28);  ///< Enable AGT1 underflow snooze request
        constexpr uint32_t SNZREQEN29 = (1U << 29);  ///< Enable AGT1 compare match A snooze request
        constexpr uint32_t SNZREQEN30 = (1U << 30);  ///< Enable AGT1 compare match B snooze request
    }

    /// PSMCR Register bits
    namespace psmcr_bits {
        constexpr uint32_t PSMC = (2 << 0);  ///< Power Save Memory Control
    }

    /// OPCCR Register bits
    namespace opccr_bits {
        constexpr uint32_t OPCM = (2 << 0);  ///< Operating Power Control Mode Select
        constexpr uint32_t OPCMTSF = (1U << 4);  ///< Operating Power Control Mode Transition Status Flag
    }

    /// MOSCWTCR Register bits
    namespace moscwtcr_bits {
        constexpr uint32_t MSTS = (4 << 0);  ///< Main Clock Oscillator Wait Time Setting
    }

    /// HOCOWTCR Register bits
    namespace hocowtcr_bits {
        constexpr uint32_t HSTS = (3 << 0);  ///< HOCO Wait Time Setting
    }

    /// SOPCCR Register bits
    namespace sopccr_bits {
        constexpr uint32_t SOPCM = (1U << 0);  ///< Sub Operating Power Control Mode Select
        constexpr uint32_t SOPCMTSF = (1U << 4);  ///< Operating Power Control Mode Transition Status Flag
    }

    /// RSTSR1 Register bits
    namespace rstsr1_bits {
        constexpr uint32_t IWDTRF = (1U << 0);  ///< Independent Watchdog Timer Reset Detect Flag
        constexpr uint32_t WDTRF = (1U << 1);  ///< Watchdog Timer Reset Detect Flag
        constexpr uint32_t SWRF = (1U << 2);  ///< Software Reset Detect Flag
        constexpr uint32_t RPERF = (1U << 8);  ///< SRAM Parity Error Reset Detect Flag
        constexpr uint32_t BUSSRF = (1U << 10);  ///< Bus Slave MPU Error Reset Detect Flag
        constexpr uint32_t BUSMRF = (1U << 11);  ///< Bus Master MPU Error Reset Detect Flag
        constexpr uint32_t SPERF = (1U << 12);  ///< CPU Stack Pointer Error Reset Detect Flag
    }

    /// LVD1CR1 Register bits
    namespace lvd1cr1_bits {
        constexpr uint32_t IDTSEL = (2 << 0);  ///< Voltage Monitor 1 Interrupt Generation Condition Select
        constexpr uint32_t IRQSEL = (1U << 2);  ///< Voltage Monitor 1 Interrupt Type Select
    }

    /// LVD1SR Register bits
    namespace lvd1sr_bits {
        constexpr uint32_t DET = (1U << 0);  ///< Voltage Monitor 1 Voltage Variation Detection Flag
        constexpr uint32_t MON = (1U << 1);  ///< Voltage Monitor 1 Signal Monitor Flag
    }

    /// LVD2CR1 Register bits
    namespace lvd2cr1_bits {
        constexpr uint32_t IDTSEL = (2 << 0);  ///< Voltage Monitor 2 Interrupt Generation Condition Select
        constexpr uint32_t IRQSEL = (1U << 2);  ///< Voltage Monitor 2 Interrupt Type Select
    }

    /// LVD2SR Register bits
    namespace lvd2sr_bits {
        constexpr uint32_t DET = (1U << 0);  ///< Voltage Monitor 2 Voltage Variation Detection Flag
        constexpr uint32_t MON = (1U << 1);  ///< Voltage Monitor 2 Signal Monitor Flag
    }

    /// PRCR Register bits
    namespace prcr_bits {
        constexpr uint32_t PRC0 = (1U << 0);  ///< Enable writing to the registers related to the clock generation circuit
        constexpr uint32_t PRC1 = (1U << 1);  ///< Enable writing to the registers related to the low power modes
        constexpr uint32_t PRC3 = (1U << 3);  ///< Enable writing to the registers related to the LVD
        constexpr uint32_t PRKEY = (8 << 8);  ///< PRC Key Code
    }

    /// SYOCDCR Register bits
    namespace syocdcr_bits {
        constexpr uint32_t DBGEN = (1U << 7);  ///< Debugger Enable bit
    }

    /// RSTSR0 Register bits
    namespace rstsr0_bits {
        constexpr uint32_t PORF = (1U << 0);  ///< Power-On Reset Detect Flag
        constexpr uint32_t LVD0RF = (1U << 1);  ///< Voltage Monitor 0 Reset Detect Flag
        constexpr uint32_t LVD1RF = (1U << 2);  ///< Voltage Monitor 1 Reset Detect Flag
        constexpr uint32_t LVD2RF = (1U << 3);  ///< Voltage Monitor 2 Reset Detect Flag
    }

    /// RSTSR2 Register bits
    namespace rstsr2_bits {
        constexpr uint32_t CWSF = (1U << 0);  ///< Cold/Warm Start Determination Flag
    }

    /// MOMCR Register bits
    namespace momcr_bits {
        constexpr uint32_t MODRV1 = (1U << 3);  ///< Main Clock Oscillator Drive Capability 1 Switching
        constexpr uint32_t MOSEL = (1U << 6);  ///< Main Clock Oscillator Switching
    }

    /// LVCMPCR Register bits
    namespace lvcmpcr_bits {
        constexpr uint32_t LVD1E = (1U << 5);  ///< Voltage Detection 1 Enable
        constexpr uint32_t LVD2E = (1U << 6);  ///< Voltage Detection 2 Enable
    }

    /// LVDLVLR Register bits
    namespace lvdlvlr_bits {
        constexpr uint32_t LVD1LVL = (5 << 0);  ///< Voltage Detection 1 Level Select (Standard voltage during fall in voltage)
        constexpr uint32_t LVD2LVL = (3 << 5);  ///< Voltage Detection 2 Level Select (Standard voltage during fall in voltage)
    }

    /// LVD1CR0 Register bits
    namespace lvd1cr0_bits {
        constexpr uint32_t RIE = (1U << 0);  ///< Voltage Monitor 1 Interrupt/Reset Enable
        constexpr uint32_t CMPE = (1U << 2);  ///< Voltage Monitor 1 Circuit Comparison Result Output Enable
        constexpr uint32_t RI = (1U << 6);  ///< Voltage Monitor 1 Circuit Mode Select
        constexpr uint32_t RN = (1U << 7);  ///< Voltage Monitor 1 Reset Negate Select
    }

    /// LVD2CR0 Register bits
    namespace lvd2cr0_bits {
        constexpr uint32_t RIE = (1U << 0);  ///< Voltage Monitor 2 Interrupt/Reset Enable
        constexpr uint32_t CMPE = (1U << 2);  ///< Voltage Monitor 2 Circuit Comparison Result Output Enable
        constexpr uint32_t RI = (1U << 6);  ///< Voltage Monitor 2 Circuit Mode Select
        constexpr uint32_t RN = (1U << 7);  ///< Voltage Monitor 2 Reset Negate Select
    }

    /// SOSCCR Register bits
    namespace sosccr_bits {
        constexpr uint32_t SOSTP = (1U << 0);  ///< Sub Clock Oscillator Stop
    }

    /// SOMCR Register bits
    namespace somcr_bits {
        constexpr uint32_t SODRV = (2 << 0);  ///< Sub-Clock Oscillator Drive Capability Switching
    }

    /// SOMRG Register bits
    namespace somrg_bits {
        constexpr uint32_t SOSCMRG = (2 << 0);  ///< Sub Clock Oscillator Margin check Switching
    }

    /// LOCOCR Register bits
    namespace lococr_bits {
        constexpr uint32_t LCSTP = (1U << 0);  ///< LOCO Stop
    }

    /// LOCOUTCR Register bits
    namespace locoutcr_bits {
        constexpr uint32_t LOCOUTRM = (8 << 0);  ///< LOCO User Trimming
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT0_BASE = 0x40040000;
    constexpr uint32_t PORT1_BASE = 0x40040020;
    constexpr uint32_t PORT2_BASE = 0x40040040;
    constexpr uint32_t PORT3_BASE = 0x40040060;
    constexpr uint32_t PORT4_BASE = 0x40040080;
    constexpr uint32_t PORT5_BASE = 0x400400A0;
    constexpr uint32_t PORT9_BASE = 0x40040120;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCNTR1;  ///< Offset: 0x00 - Port Control Register 1
        volatile uint32_t PODR;  ///< Offset: 0x00 - Port Control Register 1
        volatile uint32_t PDR;  ///< Offset: 0x02 - Port Control Register 1
        volatile uint32_t PCNTR2;  ///< Offset: 0x04 - Port Control Register 2
        volatile uint32_t PIDR;  ///< Offset: 0x06 - Port Control Register 2
        volatile uint32_t PCNTR3;  ///< Offset: 0x08 - Port Control Register 3
        volatile uint32_t PORR;  ///< Offset: 0x08 - Port Control Register 3
        volatile uint32_t POSR;  ///< Offset: 0x0A - Port Control Register 3
    };

    /// Peripheral instances
    inline Registers* PORT0 = reinterpret_cast<Registers*>(PORT0_BASE);
    inline Registers* PORT1 = reinterpret_cast<Registers*>(PORT1_BASE);
    inline Registers* PORT2 = reinterpret_cast<Registers*>(PORT2_BASE);
    inline Registers* PORT3 = reinterpret_cast<Registers*>(PORT3_BASE);
    inline Registers* PORT4 = reinterpret_cast<Registers*>(PORT4_BASE);
    inline Registers* PORT5 = reinterpret_cast<Registers*>(PORT5_BASE);
    inline Registers* PORT9 = reinterpret_cast<Registers*>(PORT9_BASE);

    // Bit definitions
    /// PCNTR1 Register bits
    namespace pcntr1_bits {
        constexpr uint32_t PDR00 = (1U << 0);  ///< Pmn Direction
        constexpr uint32_t PDR01 = (1U << 1);  ///< Pmn Direction
        constexpr uint32_t PDR02 = (1U << 2);  ///< Pmn Direction
        constexpr uint32_t PDR03 = (1U << 3);  ///< Pmn Direction
        constexpr uint32_t PDR04 = (1U << 4);  ///< Pmn Direction
        constexpr uint32_t PDR05 = (1U << 5);  ///< Pmn Direction
        constexpr uint32_t PDR06 = (1U << 6);  ///< Pmn Direction
        constexpr uint32_t PDR07 = (1U << 7);  ///< Pmn Direction
        constexpr uint32_t PDR08 = (1U << 8);  ///< Pmn Direction
        constexpr uint32_t PDR09 = (1U << 9);  ///< Pmn Direction
        constexpr uint32_t PDR10 = (1U << 10);  ///< Pmn Direction
        constexpr uint32_t PDR11 = (1U << 11);  ///< Pmn Direction
        constexpr uint32_t PDR12 = (1U << 12);  ///< Pmn Direction
        constexpr uint32_t PDR13 = (1U << 13);  ///< Pmn Direction
        constexpr uint32_t PDR14 = (1U << 14);  ///< Pmn Direction
        constexpr uint32_t PDR15 = (1U << 15);  ///< Pmn Direction
        constexpr uint32_t PODR00 = (1U << 16);  ///< Pmn Output Data
        constexpr uint32_t PODR01 = (1U << 17);  ///< Pmn Output Data
        constexpr uint32_t PODR02 = (1U << 18);  ///< Pmn Output Data
        constexpr uint32_t PODR03 = (1U << 19);  ///< Pmn Output Data
        constexpr uint32_t PODR04 = (1U << 20);  ///< Pmn Output Data
        constexpr uint32_t PODR05 = (1U << 21);  ///< Pmn Output Data
        constexpr uint32_t PODR06 = (1U << 22);  ///< Pmn Output Data
        constexpr uint32_t PODR07 = (1U << 23);  ///< Pmn Output Data
        constexpr uint32_t PODR08 = (1U << 24);  ///< Pmn Output Data
        constexpr uint32_t PODR09 = (1U << 25);  ///< Pmn Output Data
        constexpr uint32_t PODR10 = (1U << 26);  ///< Pmn Output Data
        constexpr uint32_t PODR11 = (1U << 27);  ///< Pmn Output Data
        constexpr uint32_t PODR12 = (1U << 28);  ///< Pmn Output Data
        constexpr uint32_t PODR13 = (1U << 29);  ///< Pmn Output Data
        constexpr uint32_t PODR14 = (1U << 30);  ///< Pmn Output Data
        constexpr uint32_t PODR15 = (1U << 31);  ///< Pmn Output Data
    }

    /// PODR Register bits
    namespace podr_bits {
        constexpr uint32_t PODR00 = (1U << 0);  ///< Pmn Output Data
        constexpr uint32_t PODR01 = (1U << 1);  ///< Pmn Output Data
        constexpr uint32_t PODR02 = (1U << 2);  ///< Pmn Output Data
        constexpr uint32_t PODR03 = (1U << 3);  ///< Pmn Output Data
        constexpr uint32_t PODR04 = (1U << 4);  ///< Pmn Output Data
        constexpr uint32_t PODR05 = (1U << 5);  ///< Pmn Output Data
        constexpr uint32_t PODR06 = (1U << 6);  ///< Pmn Output Data
        constexpr uint32_t PODR07 = (1U << 7);  ///< Pmn Output Data
        constexpr uint32_t PODR08 = (1U << 8);  ///< Pmn Output Data
        constexpr uint32_t PODR09 = (1U << 9);  ///< Pmn Output Data
        constexpr uint32_t PODR10 = (1U << 10);  ///< Pmn Output Data
        constexpr uint32_t PODR11 = (1U << 11);  ///< Pmn Output Data
        constexpr uint32_t PODR12 = (1U << 12);  ///< Pmn Output Data
        constexpr uint32_t PODR13 = (1U << 13);  ///< Pmn Output Data
        constexpr uint32_t PODR14 = (1U << 14);  ///< Pmn Output Data
        constexpr uint32_t PODR15 = (1U << 15);  ///< Pmn Output Data
    }

    /// PDR Register bits
    namespace pdr_bits {
        constexpr uint32_t PDR00 = (1U << 0);  ///< Pmn Direction
        constexpr uint32_t PDR01 = (1U << 1);  ///< Pmn Direction
        constexpr uint32_t PDR02 = (1U << 2);  ///< Pmn Direction
        constexpr uint32_t PDR03 = (1U << 3);  ///< Pmn Direction
        constexpr uint32_t PDR04 = (1U << 4);  ///< Pmn Direction
        constexpr uint32_t PDR05 = (1U << 5);  ///< Pmn Direction
        constexpr uint32_t PDR06 = (1U << 6);  ///< Pmn Direction
        constexpr uint32_t PDR07 = (1U << 7);  ///< Pmn Direction
        constexpr uint32_t PDR08 = (1U << 8);  ///< Pmn Direction
        constexpr uint32_t PDR09 = (1U << 9);  ///< Pmn Direction
        constexpr uint32_t PDR10 = (1U << 10);  ///< Pmn Direction
        constexpr uint32_t PDR11 = (1U << 11);  ///< Pmn Direction
        constexpr uint32_t PDR12 = (1U << 12);  ///< Pmn Direction
        constexpr uint32_t PDR13 = (1U << 13);  ///< Pmn Direction
        constexpr uint32_t PDR14 = (1U << 14);  ///< Pmn Direction
        constexpr uint32_t PDR15 = (1U << 15);  ///< Pmn Direction
    }

    /// PCNTR2 Register bits
    namespace pcntr2_bits {
        constexpr uint32_t PIDR00 = (1U << 0);  ///< Pmn State
        constexpr uint32_t PIDR01 = (1U << 1);  ///< Pmn State
        constexpr uint32_t PIDR02 = (1U << 2);  ///< Pmn State
        constexpr uint32_t PIDR03 = (1U << 3);  ///< Pmn State
        constexpr uint32_t PIDR04 = (1U << 4);  ///< Pmn State
        constexpr uint32_t PIDR05 = (1U << 5);  ///< Pmn State
        constexpr uint32_t PIDR06 = (1U << 6);  ///< Pmn State
        constexpr uint32_t PIDR07 = (1U << 7);  ///< Pmn State
        constexpr uint32_t PIDR08 = (1U << 8);  ///< Pmn State
        constexpr uint32_t PIDR09 = (1U << 9);  ///< Pmn State
        constexpr uint32_t PIDR10 = (1U << 10);  ///< Pmn State
        constexpr uint32_t PIDR11 = (1U << 11);  ///< Pmn State
        constexpr uint32_t PIDR12 = (1U << 12);  ///< Pmn State
        constexpr uint32_t PIDR13 = (1U << 13);  ///< Pmn State
        constexpr uint32_t PIDR14 = (1U << 14);  ///< Pmn State
        constexpr uint32_t PIDR15 = (1U << 15);  ///< Pmn State
    }

    /// PIDR Register bits
    namespace pidr_bits {
        constexpr uint32_t PIDR00 = (1U << 0);  ///< Pmn State
        constexpr uint32_t PIDR01 = (1U << 1);  ///< Pmn State
        constexpr uint32_t PIDR02 = (1U << 2);  ///< Pmn State
        constexpr uint32_t PIDR03 = (1U << 3);  ///< Pmn State
        constexpr uint32_t PIDR04 = (1U << 4);  ///< Pmn State
        constexpr uint32_t PIDR05 = (1U << 5);  ///< Pmn State
        constexpr uint32_t PIDR06 = (1U << 6);  ///< Pmn State
        constexpr uint32_t PIDR07 = (1U << 7);  ///< Pmn State
        constexpr uint32_t PIDR08 = (1U << 8);  ///< Pmn State
        constexpr uint32_t PIDR09 = (1U << 9);  ///< Pmn State
        constexpr uint32_t PIDR10 = (1U << 10);  ///< Pmn State
        constexpr uint32_t PIDR11 = (1U << 11);  ///< Pmn State
        constexpr uint32_t PIDR12 = (1U << 12);  ///< Pmn State
        constexpr uint32_t PIDR13 = (1U << 13);  ///< Pmn State
        constexpr uint32_t PIDR14 = (1U << 14);  ///< Pmn State
        constexpr uint32_t PIDR15 = (1U << 15);  ///< Pmn State
    }

    /// PCNTR3 Register bits
    namespace pcntr3_bits {
        constexpr uint32_t POSR00 = (1U << 0);  ///< Pmn Output Set
        constexpr uint32_t POSR01 = (1U << 1);  ///< Pmn Output Set
        constexpr uint32_t POSR02 = (1U << 2);  ///< Pmn Output Set
        constexpr uint32_t POSR03 = (1U << 3);  ///< Pmn Output Set
        constexpr uint32_t POSR04 = (1U << 4);  ///< Pmn Output Set
        constexpr uint32_t POSR05 = (1U << 5);  ///< Pmn Output Set
        constexpr uint32_t POSR06 = (1U << 6);  ///< Pmn Output Set
        constexpr uint32_t POSR07 = (1U << 7);  ///< Pmn Output Set
        constexpr uint32_t POSR08 = (1U << 8);  ///< Pmn Output Set
        constexpr uint32_t POSR09 = (1U << 9);  ///< Pmn Output Set
        constexpr uint32_t POSR10 = (1U << 10);  ///< Pmn Output Set
        constexpr uint32_t POSR11 = (1U << 11);  ///< Pmn Output Set
        constexpr uint32_t POSR12 = (1U << 12);  ///< Pmn Output Set
        constexpr uint32_t POSR13 = (1U << 13);  ///< Pmn Output Set
        constexpr uint32_t POSR14 = (1U << 14);  ///< Pmn Output Set
        constexpr uint32_t POSR15 = (1U << 15);  ///< Pmn Output Set
        constexpr uint32_t PORR00 = (1U << 16);  ///< Pmn Output Reset
        constexpr uint32_t PORR01 = (1U << 17);  ///< Pmn Output Reset
        constexpr uint32_t PORR02 = (1U << 18);  ///< Pmn Output Reset
        constexpr uint32_t PORR03 = (1U << 19);  ///< Pmn Output Reset
        constexpr uint32_t PORR04 = (1U << 20);  ///< Pmn Output Reset
        constexpr uint32_t PORR05 = (1U << 21);  ///< Pmn Output Reset
        constexpr uint32_t PORR06 = (1U << 22);  ///< Pmn Output Reset
        constexpr uint32_t PORR07 = (1U << 23);  ///< Pmn Output Reset
        constexpr uint32_t PORR08 = (1U << 24);  ///< Pmn Output Reset
        constexpr uint32_t PORR09 = (1U << 25);  ///< Pmn Output Reset
        constexpr uint32_t PORR10 = (1U << 26);  ///< Pmn Output Reset
        constexpr uint32_t PORR11 = (1U << 27);  ///< Pmn Output Reset
        constexpr uint32_t PORR12 = (1U << 28);  ///< Pmn Output Reset
        constexpr uint32_t PORR13 = (1U << 29);  ///< Pmn Output Reset
        constexpr uint32_t PORR14 = (1U << 30);  ///< Pmn Output Reset
        constexpr uint32_t PORR15 = (1U << 31);  ///< Pmn Output Reset
    }

    /// PORR Register bits
    namespace porr_bits {
        constexpr uint32_t PORR00 = (1U << 0);  ///< Pmn Output Reset
        constexpr uint32_t PORR01 = (1U << 1);  ///< Pmn Output Reset
        constexpr uint32_t PORR02 = (1U << 2);  ///< Pmn Output Reset
        constexpr uint32_t PORR03 = (1U << 3);  ///< Pmn Output Reset
        constexpr uint32_t PORR04 = (1U << 4);  ///< Pmn Output Reset
        constexpr uint32_t PORR05 = (1U << 5);  ///< Pmn Output Reset
        constexpr uint32_t PORR06 = (1U << 6);  ///< Pmn Output Reset
        constexpr uint32_t PORR07 = (1U << 7);  ///< Pmn Output Reset
        constexpr uint32_t PORR08 = (1U << 8);  ///< Pmn Output Reset
        constexpr uint32_t PORR09 = (1U << 9);  ///< Pmn Output Reset
        constexpr uint32_t PORR10 = (1U << 10);  ///< Pmn Output Reset
        constexpr uint32_t PORR11 = (1U << 11);  ///< Pmn Output Reset
        constexpr uint32_t PORR12 = (1U << 12);  ///< Pmn Output Reset
        constexpr uint32_t PORR13 = (1U << 13);  ///< Pmn Output Reset
        constexpr uint32_t PORR14 = (1U << 14);  ///< Pmn Output Reset
        constexpr uint32_t PORR15 = (1U << 15);  ///< Pmn Output Reset
    }

    /// POSR Register bits
    namespace posr_bits {
        constexpr uint32_t POSR00 = (1U << 0);  ///< Pmn Output Set
        constexpr uint32_t POSR01 = (1U << 1);  ///< Pmn Output Set
        constexpr uint32_t POSR02 = (1U << 2);  ///< Pmn Output Set
        constexpr uint32_t POSR03 = (1U << 3);  ///< Pmn Output Set
        constexpr uint32_t POSR04 = (1U << 4);  ///< Pmn Output Set
        constexpr uint32_t POSR05 = (1U << 5);  ///< Pmn Output Set
        constexpr uint32_t POSR06 = (1U << 6);  ///< Pmn Output Set
        constexpr uint32_t POSR07 = (1U << 7);  ///< Pmn Output Set
        constexpr uint32_t POSR08 = (1U << 8);  ///< Pmn Output Set
        constexpr uint32_t POSR09 = (1U << 9);  ///< Pmn Output Set
        constexpr uint32_t POSR10 = (1U << 10);  ///< Pmn Output Set
        constexpr uint32_t POSR11 = (1U << 11);  ///< Pmn Output Set
        constexpr uint32_t POSR12 = (1U << 12);  ///< Pmn Output Set
        constexpr uint32_t POSR13 = (1U << 13);  ///< Pmn Output Set
        constexpr uint32_t POSR14 = (1U << 14);  ///< Pmn Output Set
        constexpr uint32_t POSR15 = (1U << 15);  ///< Pmn Output Set
    }

}

// ============================================================================
// PFS Peripheral
// ============================================================================

namespace pfs {
    /// Base addresses
    constexpr uint32_t PFS_BASE = 0x40040800;

    /// PFS Register structure
    struct Registers {
        volatile uint32_t P00%sPFS;  ///< Offset: 0x00 - Port 00%s Pin Function Select Register
        volatile uint32_t P00%sPFS_HA;  ///< Offset: 0x02 - Port 00%s Pin Function Select Register
        volatile uint32_t P00%sPFS_BY;  ///< Offset: 0x03 - Port 00%s Pin Function Select Register
        volatile uint32_t P0%sPFS;  ///< Offset: 0x28 - Port 0%s Pin Function Select Register
        volatile uint32_t P0%sPFS_HA;  ///< Offset: 0x2A - Port 0%s Pin Function Select Register
        volatile uint32_t P0%sPFS_BY;  ///< Offset: 0x2B - Port 0%s Pin Function Select Register
        volatile uint32_t P10%sPFS;  ///< Offset: 0x40 - Port 10%s Pin Function Select Register
        volatile uint32_t P10%sPFS_HA;  ///< Offset: 0x42 - Port 10%s Pin Function Select Register
        volatile uint32_t P10%sPFS_BY;  ///< Offset: 0x43 - Port 10%s Pin Function Select Register
        volatile uint32_t P108PFS;  ///< Offset: 0x60 - Port 108 Pin Function Select Register
        volatile uint32_t P108PFS_HA;  ///< Offset: 0x62 - Port 108 Pin Function Select Register
        volatile uint32_t P108PFS_BY;  ///< Offset: 0x63 - Port 108 Pin Function Select Register
        volatile uint32_t P109PFS;  ///< Offset: 0x64 - Port 109 Pin Function Select Register
        volatile uint32_t P109PFS_HA;  ///< Offset: 0x66 - Port 109 Pin Function Select Register
        volatile uint32_t P109PFS_BY;  ///< Offset: 0x67 - Port 109 Pin Function Select Register
        volatile uint32_t P1%sPFS;  ///< Offset: 0x68 - Port 1%s Pin Function Select Register
        volatile uint32_t P1%sPFS_HA;  ///< Offset: 0x6A - Port 1%s Pin Function Select Register
        volatile uint32_t P1%sPFS_BY;  ///< Offset: 0x6B - Port 1%s Pin Function Select Register
        volatile uint32_t P200PFS;  ///< Offset: 0x80 - Port 200 Pin Function Select Register
        volatile uint32_t P200PFS_HA;  ///< Offset: 0x82 - Port 200 Pin Function Select Register
        volatile uint32_t P200PFS_BY;  ///< Offset: 0x83 - Port 200 Pin Function Select Register
        volatile uint32_t P201PFS;  ///< Offset: 0x84 - Port 201 Pin Function Select Register
        volatile uint32_t P201PFS_HA;  ///< Offset: 0x86 - Port 201 Pin Function Select Register
        volatile uint32_t P201PFS_BY;  ///< Offset: 0x87 - Port 201 Pin Function Select Register
        volatile uint32_t P20%sPFS;  ///< Offset: 0x88 - Port 20%s Pin Function Select Register
        volatile uint32_t P20%sPFS_HA;  ///< Offset: 0x8A - Port 20%s Pin Function Select Register
        volatile uint32_t P20%sPFS_BY;  ///< Offset: 0x8B - Port 20%s Pin Function Select Register
        volatile uint32_t P2%sPFS;  ///< Offset: 0xB0 - Port 2%s Pin Function Select Register
        volatile uint32_t P2%sPFS_HA;  ///< Offset: 0xB2 - Port 2%s Pin Function Select Register
        volatile uint32_t P2%sPFS_BY;  ///< Offset: 0xB3 - Port 2%s Pin Function Select Register
        volatile uint32_t P300PFS;  ///< Offset: 0xC0 - Port 300 Pin Function Select Register
        volatile uint32_t P300PFS_HA;  ///< Offset: 0xC2 - Port 300 Pin Function Select Register
        volatile uint32_t P300PFS_BY;  ///< Offset: 0xC3 - Port 300 Pin Function Select Register
        volatile uint32_t P30%sPFS;  ///< Offset: 0xC4 - Port 30%s Pin Function Select Register
        volatile uint32_t P30%sPFS_HA;  ///< Offset: 0xC6 - Port 30%s Pin Function Select Register
        volatile uint32_t P30%sPFS_BY;  ///< Offset: 0xC7 - Port 30%s Pin Function Select Register
        volatile uint32_t P40%sPFS;  ///< Offset: 0x100 - Port 40%s Pin Function Select Register
        volatile uint32_t P40%sPFS_HA;  ///< Offset: 0x102 - Port 40%s Pin Function Select Register
        volatile uint32_t P40%sPFS_BY;  ///< Offset: 0x103 - Port 40%s Pin Function Select Register
        volatile uint32_t P4%sPFS;  ///< Offset: 0x128 - Port 4%s Pin Function Select Register
        volatile uint32_t P4%sPFS_HA;  ///< Offset: 0x12A - Port 4%s Pin Function Select Register
        volatile uint32_t P4%sPFS_BY;  ///< Offset: 0x12B - Port 4%s Pin Function Select Register
        volatile uint32_t P50%sPFS;  ///< Offset: 0x140 - Port 50%s Pin Function Select Register
        volatile uint32_t P50%sPFS_HA;  ///< Offset: 0x142 - Port 50%s Pin Function Select Register
        volatile uint32_t P50%sPFS_BY;  ///< Offset: 0x143 - Port 50%s Pin Function Select Register
        volatile uint32_t P9%sPFS;  ///< Offset: 0x274 - Port 9%s Pin Function Select Register
        volatile uint32_t P9%sPFS_HA;  ///< Offset: 0x276 - Port 9%s Pin Function Select Register
        volatile uint32_t P9%sPFS_BY;  ///< Offset: 0x277 - Port 9%s Pin Function Select Register
        volatile uint32_t PWPR;  ///< Offset: 0x503 - Write-Protect Register
        volatile uint32_t PRWCNTR;  ///< Offset: 0x50F - Port Read Wait Control Register
    };

    /// Peripheral instances
    inline Registers* PFS = reinterpret_cast<Registers*>(PFS_BASE);

    // Bit definitions
    /// P00%sPFS Register bits
    namespace p00%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P00%sPFS_HA Register bits
    namespace p00%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P00%sPFS_BY Register bits
    namespace p00%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P0%sPFS Register bits
    namespace p0%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P0%sPFS_HA Register bits
    namespace p0%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P0%sPFS_BY Register bits
    namespace p0%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P10%sPFS Register bits
    namespace p10%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P10%sPFS_HA Register bits
    namespace p10%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P10%sPFS_BY Register bits
    namespace p10%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P108PFS Register bits
    namespace p108pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P108PFS_HA Register bits
    namespace p108pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P108PFS_BY Register bits
    namespace p108pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P109PFS Register bits
    namespace p109pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P109PFS_HA Register bits
    namespace p109pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P109PFS_BY Register bits
    namespace p109pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P1%sPFS Register bits
    namespace p1%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P1%sPFS_HA Register bits
    namespace p1%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P1%sPFS_BY Register bits
    namespace p1%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P200PFS Register bits
    namespace p200pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P200PFS_HA Register bits
    namespace p200pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P200PFS_BY Register bits
    namespace p200pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P201PFS Register bits
    namespace p201pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P201PFS_HA Register bits
    namespace p201pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P201PFS_BY Register bits
    namespace p201pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P20%sPFS Register bits
    namespace p20%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P20%sPFS_HA Register bits
    namespace p20%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P20%sPFS_BY Register bits
    namespace p20%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P2%sPFS Register bits
    namespace p2%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P2%sPFS_HA Register bits
    namespace p2%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P2%sPFS_BY Register bits
    namespace p2%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P300PFS Register bits
    namespace p300pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P300PFS_HA Register bits
    namespace p300pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P300PFS_BY Register bits
    namespace p300pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P30%sPFS Register bits
    namespace p30%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P30%sPFS_HA Register bits
    namespace p30%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P30%sPFS_BY Register bits
    namespace p30%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P40%sPFS Register bits
    namespace p40%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P40%sPFS_HA Register bits
    namespace p40%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P40%sPFS_BY Register bits
    namespace p40%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P4%sPFS Register bits
    namespace p4%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P4%sPFS_HA Register bits
    namespace p4%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P4%sPFS_BY Register bits
    namespace p4%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P50%sPFS Register bits
    namespace p50%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P50%sPFS_HA Register bits
    namespace p50%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P50%sPFS_BY Register bits
    namespace p50%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P9%sPFS Register bits
    namespace p9%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P9%sPFS_HA Register bits
    namespace p9%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P9%sPFS_BY Register bits
    namespace p9%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// PWPR Register bits
    namespace pwpr_bits {
        constexpr uint32_t PFSWE = (1U << 6);  ///< PmnPFS Register Write Enable
        constexpr uint32_t B0WI = (1U << 7);  ///< PFSWE Bit Write Disable
    }

    /// PRWCNTR Register bits
    namespace prwcntr_bits {
        constexpr uint32_t WAIT = (2 << 0);  ///< Wait Cycle Control
    }

}

// ============================================================================
// ELC Peripheral
// ============================================================================

namespace elc {
    /// Base addresses
    constexpr uint32_t ELC_BASE = 0x40041000;

    /// ELC Register structure
    struct Registers {
        volatile uint32_t ELCR;  ///< Offset: 0x00 - Event Link Controller Register
        volatile uint32_t ELSEGR%s;  ///< Offset: 0x02 - Event Link Software Event Generation Register %s
        volatile uint32_t ELSR%s;  ///< Offset: 0x48 - Event Link Setting Register %s
        volatile uint32_t ELSR12;  ///< Offset: 0x40 - Event Link Setting Register 12
        volatile uint32_t ELSR18;  ///< Offset: 0x58 - Event Link Setting Register 18
    };

    /// Peripheral instances
    inline Registers* ELC = reinterpret_cast<Registers*>(ELC_BASE);

    // Bit definitions
    /// ELCR Register bits
    namespace elcr_bits {
        constexpr uint32_t ELCON = (1U << 7);  ///< All Event Link Enable
    }

    /// ELSEGR%s Register bits
    namespace elsegr%s_bits {
        constexpr uint32_t SEG = (1U << 0);  ///< Software Event Generation
        constexpr uint32_t WE = (1U << 6);  ///< SEG Bit Write Enable
        constexpr uint32_t WI = (1U << 7);  ///< ELSEGR Register Write Disable
    }

    /// ELSR%s Register bits
    namespace elsr%s_bits {
        constexpr uint32_t ELS = (8 << 0);  ///< Event Link Select
    }

    /// ELSR12 Register bits
    namespace elsr12_bits {
        constexpr uint32_t ELS = (8 << 0);  ///< Event Link Select
    }

    /// ELSR18 Register bits
    namespace elsr18_bits {
        constexpr uint32_t ELS = (8 << 0);  ///< Event Link Select
    }

}

// ============================================================================
// POEG Peripheral
// ============================================================================

namespace poeg {
    /// Base addresses
    constexpr uint32_t POEG_BASE = 0x40042000;

    /// POEG Register structure
    struct Registers {
        volatile uint32_t POEGGA;  ///< Offset: 0x00 - POEG Group A Setting Register
        volatile uint32_t POEGGB;  ///< Offset: 0x100 - POEG Group B Setting Register
    };

    /// Peripheral instances
    inline Registers* POEG = reinterpret_cast<Registers*>(POEG_BASE);

    // Bit definitions
    /// POEGGA Register bits
    namespace poegga_bits {
        constexpr uint32_t PIDF = (1U << 0);  ///< Port Input Detection Flag
        constexpr uint32_t IOCF = (1U << 1);  ///< Detection Flag for GPT Output-Disable Request
        constexpr uint32_t OSTPF = (1U << 2);  ///< Oscillation Stop Detection Flag
        constexpr uint32_t SSF = (1U << 3);  ///< Software Stop Flag
        constexpr uint32_t PIDE = (1U << 4);  ///< Port Input Detection Enable
        constexpr uint32_t IOCE = (1U << 5);  ///< Enable for GPT Output-Disable Request
        constexpr uint32_t OSTPE = (1U << 6);  ///< Oscillation Stop Detection Enable
        constexpr uint32_t ST = (1U << 16);  ///< GTETRGn Input Status Flag
        constexpr uint32_t INV = (1U << 28);  ///< GTETRGn Input Reverse
        constexpr uint32_t NFEN = (1U << 29);  ///< Noise Filter Enable
        constexpr uint32_t NFCS = (2 << 30);  ///< Noise Filter Clock Select
    }

    /// POEGGB Register bits
    namespace poeggb_bits {
        constexpr uint32_t PIDF = (1U << 0);  ///< Port Input Detection Flag
        constexpr uint32_t IOCF = (1U << 1);  ///< Detection Flag for GPT Output-Disable Request
        constexpr uint32_t OSTPF = (1U << 2);  ///< Oscillation Stop Detection Flag
        constexpr uint32_t SSF = (1U << 3);  ///< Software Stop Flag
        constexpr uint32_t PIDE = (1U << 4);  ///< Port Input Detection Enable
        constexpr uint32_t IOCE = (1U << 5);  ///< Enable for GPT Output-Disable Request
        constexpr uint32_t OSTPE = (1U << 6);  ///< Oscillation Stop Detection Enable
        constexpr uint32_t ST = (1U << 16);  ///< GTETRGn Input Status Flag
        constexpr uint32_t INV = (1U << 28);  ///< GTETRGn Input Reverse
        constexpr uint32_t NFEN = (1U << 29);  ///< Noise Filter Enable
        constexpr uint32_t NFCS = (2 << 30);  ///< Noise Filter Clock Select
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40044000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t R64CNT;  ///< Offset: 0x00 - 64-Hz Counter
        volatile uint32_t BCNT%s;  ///< Offset: 0x02 - Binary Counter %s
        volatile uint32_t RSECCNT;  ///< Offset: 0x02 - Second Counter (in Calendar Count Mode)
        volatile uint32_t RMINCNT;  ///< Offset: 0x04 - Minute Counter (in Calendar Count Mode)
        volatile uint32_t RHRCNT;  ///< Offset: 0x06 - Hour Counter (in Calendar Count Mode)
        volatile uint32_t RWKCNT;  ///< Offset: 0x08 - Day-of-Week Counter (in Calendar Count Mode)
        volatile uint32_t RDAYCNT;  ///< Offset: 0x0A - Day Counter
        volatile uint32_t RMONCNT;  ///< Offset: 0x0C - Month Counter
        volatile uint32_t RYRCNT;  ///< Offset: 0x0E - Year Counter
        volatile uint32_t BCNT%sAR;  ///< Offset: 0x10 - Binary Counter %s Alarm Register
        volatile uint32_t RSECAR;  ///< Offset: 0x10 - Second Alarm Register (in Calendar Count Mode)
        volatile uint32_t RMINAR;  ///< Offset: 0x12 - Minute Alarm Register (in Calendar Count Mode)
        volatile uint32_t RHRAR;  ///< Offset: 0x14 - Hour Alarm Register (in Calendar Count Mode)
        volatile uint32_t RWKAR;  ///< Offset: 0x16 - Day-of-Week Alarm Register (in Calendar Count Mode)
        volatile uint32_t BCNT%sAER;  ///< Offset: 0x18 - Binary Counter %s Alarm Enable Register
        volatile uint32_t RDAYAR;  ///< Offset: 0x18 - Date Alarm Register (in Calendar Count Mode)
        volatile uint32_t RMONAR;  ///< Offset: 0x1A - Month Alarm Register (in Calendar Count Mode)
        volatile uint32_t BCNT2AER;  ///< Offset: 0x1C - Binary Counter 2 Alarm Enable Register
        volatile uint32_t RYRAR;  ///< Offset: 0x1C - Year Alarm Register (in Calendar Count Mode)
        volatile uint32_t BCNT3AER;  ///< Offset: 0x1E - Binary Counter 3 Alarm Enable Register
        volatile uint32_t RYRAREN;  ///< Offset: 0x1E - Year Alarm Enable Register (in Calendar Count Mode)
        volatile uint32_t RCR1;  ///< Offset: 0x22 - RTC Control Register 1
        volatile uint32_t RCR2;  ///< Offset: 0x24 - RTC Control Register 2 (in Calendar Count Mode)
        volatile uint32_t RCR2_BCNT;  ///< Offset: 0x24 - RTC Control Register 2 (in Binary Count Mode)
        volatile uint32_t RCR4;  ///< Offset: 0x28 - RTC Control Register 4
        volatile uint32_t RFRH;  ///< Offset: 0x2A - Frequency Register H
        volatile uint32_t RFRL;  ///< Offset: 0x2C - Frequency Register L
        volatile uint32_t RADJ;  ///< Offset: 0x2E - Time Error Adjustment Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// R64CNT Register bits
    namespace r64cnt_bits {
        constexpr uint32_t F64HZ = (1U << 0);  ///< 64-Hz Flag
        constexpr uint32_t F32HZ = (1U << 1);  ///< 32-Hz Flag
        constexpr uint32_t F16HZ = (1U << 2);  ///< 16-Hz Flag
        constexpr uint32_t F8HZ = (1U << 3);  ///< 8-Hz Flag
        constexpr uint32_t F4HZ = (1U << 4);  ///< 4-Hz Flag
        constexpr uint32_t F2HZ = (1U << 5);  ///< 2-Hz Flag
        constexpr uint32_t F1HZ = (1U << 6);  ///< 1-Hz Flag
        constexpr uint32_t R64OVF = (1U << 7);  ///< R64OVF
    }

    /// BCNT%s Register bits
    namespace bcnt%s_bits {
        constexpr uint32_t BCNT = (8 << 0);  ///< Binary Counter
    }

    /// RSECCNT Register bits
    namespace rseccnt_bits {
        constexpr uint32_t SEC1 = (4 << 0);  ///< 1-Second Count
        constexpr uint32_t SEC10 = (3 << 4);  ///< 10-Second Count
    }

    /// RMINCNT Register bits
    namespace rmincnt_bits {
        constexpr uint32_t MIN1 = (4 << 0);  ///< 1-Minute Count
        constexpr uint32_t MIN10 = (3 << 4);  ///< 10-Minute Count
    }

    /// RHRCNT Register bits
    namespace rhrcnt_bits {
        constexpr uint32_t HR1 = (4 << 0);  ///< 1-Hour Count
        constexpr uint32_t HR10 = (2 << 4);  ///< 10-Hour Count
        constexpr uint32_t PM = (1U << 6);  ///< AM/PM select for time counter setting.
    }

    /// RWKCNT Register bits
    namespace rwkcnt_bits {
        constexpr uint32_t DAYW = (3 << 0);  ///< Day-of-Week Counting
    }

    /// RDAYCNT Register bits
    namespace rdaycnt_bits {
        constexpr uint32_t DATE1 = (4 << 0);  ///< 1-Day Count
        constexpr uint32_t DATE10 = (2 << 4);  ///< 10-Day Count
    }

    /// RMONCNT Register bits
    namespace rmoncnt_bits {
        constexpr uint32_t MON1 = (4 << 0);  ///< 1-Month Count
        constexpr uint32_t MON10 = (1U << 4);  ///< 10-Month Count
    }

    /// RYRCNT Register bits
    namespace ryrcnt_bits {
        constexpr uint32_t YR1 = (4 << 0);  ///< 1-Year Count
        constexpr uint32_t YR10 = (4 << 4);  ///< 10-Year Count
    }

    /// BCNT%sAR Register bits
    namespace bcnt%sar_bits {
        constexpr uint32_t BCNTAR = (8 << 0);  ///< Alarm register associated with the 32-bit binary counter
    }

    /// RSECAR Register bits
    namespace rsecar_bits {
        constexpr uint32_t SEC1 = (4 << 0);  ///< 1 Second
        constexpr uint32_t SEC10 = (3 << 4);  ///< 10 Seconds
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// RMINAR Register bits
    namespace rminar_bits {
        constexpr uint32_t MIN1 = (4 << 0);  ///< 1 Minute
        constexpr uint32_t MIN10 = (3 << 4);  ///< 10 Minutes
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// RHRAR Register bits
    namespace rhrar_bits {
        constexpr uint32_t HR1 = (4 << 0);  ///< 1 Hour
        constexpr uint32_t HR10 = (2 << 4);  ///< 10 Hours
        constexpr uint32_t PM = (1U << 6);  ///< AM/PM select for alarm setting.
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// RWKAR Register bits
    namespace rwkar_bits {
        constexpr uint32_t DAYW = (3 << 0);  ///< Day-of-Week Setting
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// BCNT%sAER Register bits
    namespace bcnt%saer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< Setting the alarm enable associated with the 32-bit binary counter
    }

    /// RDAYAR Register bits
    namespace rdayar_bits {
        constexpr uint32_t DATE1 = (4 << 0);  ///< 1 Day
        constexpr uint32_t DATE10 = (2 << 4);  ///< 10 Days
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// RMONAR Register bits
    namespace rmonar_bits {
        constexpr uint32_t MON1 = (4 << 0);  ///< 1 Month
        constexpr uint32_t MON10 = (1U << 4);  ///< 10 Months
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// BCNT2AER Register bits
    namespace bcnt2aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< Setting the alarm enable associated with the 32-bit binary counter
    }

    /// RYRAR Register bits
    namespace ryrar_bits {
        constexpr uint32_t YR1 = (4 << 0);  ///< 1 Year
        constexpr uint32_t YR10 = (4 << 4);  ///< 10 Years
    }

    /// BCNT3AER Register bits
    namespace bcnt3aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< Setting the alarm enable associated with the 32-bit binary counter
    }

    /// RYRAREN Register bits
    namespace ryraren_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< ENB
    }

    /// RCR1 Register bits
    namespace rcr1_bits {
        constexpr uint32_t AIE = (1U << 0);  ///< Alarm Interrupt Enable
        constexpr uint32_t CIE = (1U << 1);  ///< Carry Interrupt Enable
        constexpr uint32_t PIE = (1U << 2);  ///< Periodic Interrupt Enable
        constexpr uint32_t RTCOS = (1U << 3);  ///< RTCOUT Output Select
        constexpr uint32_t PES = (4 << 4);  ///< Periodic Interrupt Select
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start
        constexpr uint32_t RESET = (1U << 1);  ///< RTC Software Reset
        constexpr uint32_t ADJ30 = (1U << 2);  ///< 30-Second Adjustment
        constexpr uint32_t RTCOE = (1U << 3);  ///< RTCOUT Output Enable
        constexpr uint32_t AADJE = (1U << 4);  ///< Automatic Adjustment Enable
        constexpr uint32_t AADJP = (1U << 5);  ///< Automatic Adjustment Period Select
        constexpr uint32_t HR24 = (1U << 6);  ///< Hours Mode
        constexpr uint32_t CNTMD = (1U << 7);  ///< Count Mode Select
    }

    /// RCR2_BCNT Register bits
    namespace rcr2_bcnt_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start
        constexpr uint32_t RESET = (1U << 1);  ///< RTC Software Reset
        constexpr uint32_t RTCOE = (1U << 3);  ///< RTCOUT Output Enable
        constexpr uint32_t AADJE = (1U << 4);  ///< Automatic Adjustment Enable
        constexpr uint32_t AADJP = (1U << 5);  ///< Automatic Adjustment Period Select
        constexpr uint32_t CNTMD = (1U << 7);  ///< Count Mode Select
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t RCKSEL = (1U << 0);  ///< Count Source Select in normal operation mode
        constexpr uint32_t ROPSEL = (1U << 7);  ///< RTC Operation Mode Select
    }

    /// RFRH Register bits
    namespace rfrh_bits {
        constexpr uint32_t RFC16 = (1U << 0);  ///< Write 0 before writing to the RFRL register after a cold start.
    }

    /// RFRL Register bits
    namespace rfrl_bits {
        constexpr uint32_t RFC = (16 << 0);  ///< Frequency Comparison Value
    }

    /// RADJ Register bits
    namespace radj_bits {
        constexpr uint32_t ADJ = (6 << 0);  ///< Adjustment Value
        constexpr uint32_t PMADJ = (2 << 6);  ///< Plus-Minus
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40044200;
    constexpr uint32_t IWDT_BASE = 0x40044400;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDTRR;  ///< Offset: 0x00 - WDT Refresh Register
        volatile uint32_t WDTCR;  ///< Offset: 0x02 - WDT Control Register
        volatile uint32_t WDTSR;  ///< Offset: 0x04 - WDT Status Register
        volatile uint32_t WDTRCR;  ///< Offset: 0x06 - WDT Reset Control Register
        volatile uint32_t WDTCSTPR;  ///< Offset: 0x08 - WDT Count Stop Control Register
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);
    inline Registers* IWDT = reinterpret_cast<Registers*>(IWDT_BASE);

    // Bit definitions
    /// WDTCR Register bits
    namespace wdtcr_bits {
        constexpr uint32_t TOPS = (2 << 0);  ///< Timeout Period Select
        constexpr uint32_t CKS = (4 << 4);  ///< Clock Division Ratio Select
        constexpr uint32_t RPES = (2 << 8);  ///< Window End Position Select
        constexpr uint32_t RPSS = (2 << 12);  ///< Window Start Position Select
    }

    /// WDTSR Register bits
    namespace wdtsr_bits {
        constexpr uint32_t CNTVAL = (14 << 0);  ///< Down-Counter Value
        constexpr uint32_t UNDFF = (1U << 14);  ///< Underflow Flag
        constexpr uint32_t REFEF = (1U << 15);  ///< Refresh Error Flag
    }

    /// WDTRCR Register bits
    namespace wdtrcr_bits {
        constexpr uint32_t RSTIRQS = (1U << 7);  ///< WDT Behavior Selection
    }

    /// WDTCSTPR Register bits
    namespace wdtcstpr_bits {
        constexpr uint32_t SLCSTP = (1U << 7);  ///< Sleep-Mode Count Stop Control Register
    }

}

// ============================================================================
// CAC Peripheral
// ============================================================================

namespace cac {
    /// Base addresses
    constexpr uint32_t CAC_BASE = 0x40044600;

    /// CAC Register structure
    struct Registers {
        volatile uint32_t CACR0;  ///< Offset: 0x00 - CAC Control Register 0
        volatile uint32_t CACR1;  ///< Offset: 0x01 - CAC Control Register 1
        volatile uint32_t CACR2;  ///< Offset: 0x02 - CAC Control Register 2
        volatile uint32_t CAICR;  ///< Offset: 0x03 - CAC Interrupt Control Register
        volatile uint32_t CASTR;  ///< Offset: 0x04 - CAC Status Register
        volatile uint32_t CAULVR;  ///< Offset: 0x06 - CAC Upper-Limit Value Setting Register
        volatile uint32_t CALLVR;  ///< Offset: 0x08 - CAC Lower-Limit Value Setting Register
        volatile uint32_t CACNTBR;  ///< Offset: 0x0A - CAC Counter Buffer Register
    };

    /// Peripheral instances
    inline Registers* CAC = reinterpret_cast<Registers*>(CAC_BASE);

    // Bit definitions
    /// CACR0 Register bits
    namespace cacr0_bits {
        constexpr uint32_t CFME = (1U << 0);  ///< Clock Frequency Measurement Enable
    }

    /// CACR1 Register bits
    namespace cacr1_bits {
        constexpr uint32_t CACREFE = (1U << 0);  ///< CACREF Pin Input Enable
        constexpr uint32_t FMCS = (3 << 1);  ///< Measurement Target Clock Select
        constexpr uint32_t TCSS = (2 << 4);  ///< Timer Count Clock Source Select
        constexpr uint32_t EDGES = (2 << 6);  ///< Valid Edge Select
    }

    /// CACR2 Register bits
    namespace cacr2_bits {
        constexpr uint32_t RPS = (1U << 0);  ///< Reference Signal Select
        constexpr uint32_t RSCS = (3 << 1);  ///< Measurement Reference Clock Select
        constexpr uint32_t RCDS = (2 << 4);  ///< Measurement Reference Clock Frequency Division Ratio Select
        constexpr uint32_t DFS = (2 << 6);  ///< Digital Filter Select
    }

    /// CAICR Register bits
    namespace caicr_bits {
        constexpr uint32_t FERRIE = (1U << 0);  ///< Frequency Error Interrupt Request Enable
        constexpr uint32_t MENDIE = (1U << 1);  ///< Measurement End Interrupt Request Enable
        constexpr uint32_t OVFIE = (1U << 2);  ///< Overflow Interrupt Request Enable
        constexpr uint32_t FERRFCL = (1U << 4);  ///< FERRF Clear
        constexpr uint32_t MENDFCL = (1U << 5);  ///< MENDF Clear
        constexpr uint32_t OVFFCL = (1U << 6);  ///< OVFF Clear
    }

    /// CASTR Register bits
    namespace castr_bits {
        constexpr uint32_t FERRF = (1U << 0);  ///< Frequency Error Flag
        constexpr uint32_t MENDF = (1U << 1);  ///< Measurement End Flag
        constexpr uint32_t OVFF = (1U << 2);  ///< Overflow Flag
    }

}

// ============================================================================
// MSTP Peripheral
// ============================================================================

namespace mstp {
    /// Base addresses
    constexpr uint32_t MSTP_BASE = 0x40047000;

    /// MSTP Register structure
    struct Registers {
        volatile uint32_t MSTPCRB;  ///< Offset: 0x00 - Module Stop Control Register B
        volatile uint32_t MSTPCRC;  ///< Offset: 0x04 - Module Stop Control Register C
        volatile uint32_t MSTPCRD;  ///< Offset: 0x08 - Module Stop Control Register D
        volatile uint32_t LSMRWDIS;  ///< Offset: 0x0C - Low Speed Module R/W Disable Control Register
    };

    /// Peripheral instances
    inline Registers* MSTP = reinterpret_cast<Registers*>(MSTP_BASE);

    // Bit definitions
    /// MSTPCRB Register bits
    namespace mstpcrb_bits {
        constexpr uint32_t MSTPB9 = (1U << 9);  ///< I2C Bus Interface 0 Module Stop
        constexpr uint32_t MSTPB19 = (1U << 19);  ///< Serial Peripheral Interface 0 Module Stop
        constexpr uint32_t MSTPB22 = (1U << 22);  ///< Serial Communication Interface 9 Module Stop
        constexpr uint32_t MSTPB29 = (1U << 29);  ///< Serial Communication Interface 2 Module Stop
        constexpr uint32_t MSTPB30 = (1U << 30);  ///< Serial Communication Interface 1 Module Stop
        constexpr uint32_t MSTPB31 = (1U << 31);  ///< Serial Communication Interface 0 Module Stop
    }

    /// MSTPCRC Register bits
    namespace mstpcrc_bits {
        constexpr uint32_t MSTPC0 = (1U << 0);  ///< Clock Frequency Accuracy Measurement Circuit Module Stop
        constexpr uint32_t MSTPC1 = (1U << 1);  ///< Cyclic Redundancy Check Calculator Module Stop
        constexpr uint32_t MSTPC3 = (1U << 3);  ///< Capacitive Sensing Unit Module Stop
        constexpr uint32_t MSTPC13 = (1U << 13);  ///< Data Operation Circuit Module Stop
        constexpr uint32_t MSTPC14 = (1U << 14);  ///< Event Link Controller Module Stop
        constexpr uint32_t MSTPC28 = (1U << 28);  ///< True Random Number Generator Module Stop
        constexpr uint32_t MSTPC31 = (1U << 31);  ///< AES Module Stop
    }

    /// MSTPCRD Register bits
    namespace mstpcrd_bits {
        constexpr uint32_t MSTPD2 = (1U << 2);  ///< Low Power Asynchronous General Purpose Timer 1 Module Stop
        constexpr uint32_t MSTPD3 = (1U << 3);  ///< Low Power Asynchronous General Purpose Timer 0 Module Stop
        constexpr uint32_t MSTPD5 = (1U << 5);  ///< General PWM Timer 32n Module Stop
        constexpr uint32_t MSTPD6 = (1U << 6);  ///< General PWM Timer 164 to 169 and PWM Delay Generation Circuit Module Stop
        constexpr uint32_t MSTPD14 = (1U << 14);  ///< Port Output Enable for GPT Module Stop
        constexpr uint32_t MSTPD16 = (1U << 16);  ///< 12-bit A/D Converter Module Stop
        constexpr uint32_t MSTPD29 = (1U << 29);  ///< Low-Power Analog Comparator Module Stop
    }

    /// LSMRWDIS Register bits
    namespace lsmrwdis_bits {
        constexpr uint32_t RTCRWDIS = (1U << 0);  ///< RTC Register R/W Enable Control
        constexpr uint32_t WDTDIS = (1U << 1);  ///< WDT Operate Clock Control
        constexpr uint32_t IWDTIDS = (1U << 2);  ///< IWDT Register Clock Control
        constexpr uint32_t WREN = (1U << 7);  ///< Write Enable for bits [2:0]
        constexpr uint32_t PRKEY = (8 << 8);  ///< LSMRWDIS Key Code
    }

}

// ============================================================================
// IIC0 Peripheral
// ============================================================================

namespace iic0 {
    /// Base addresses
    constexpr uint32_t IIC0_BASE = 0x40053000;

    /// IIC0 Register structure
    struct Registers {
        volatile uint32_t ICCR1;  ///< Offset: 0x00 - I2C Bus Control Register 1
        volatile uint32_t ICCR2;  ///< Offset: 0x01 - I2C Bus Control Register 2
        volatile uint32_t ICMR1;  ///< Offset: 0x02 - I2C Bus Mode Register 1
        volatile uint32_t ICMR2;  ///< Offset: 0x03 - I2C Bus Mode Register 2
        volatile uint32_t ICMR3;  ///< Offset: 0x04 - I2C Bus Mode Register 3
        volatile uint32_t ICFER;  ///< Offset: 0x05 - I2C Bus Function Enable Register
        volatile uint32_t ICSER;  ///< Offset: 0x06 - I2C Bus Status Enable Register
        volatile uint32_t ICIER;  ///< Offset: 0x07 - I2C Bus Interrupt Enable Register
        volatile uint32_t ICSR1;  ///< Offset: 0x08 - I2C Bus Status Register 1
        volatile uint32_t ICSR2;  ///< Offset: 0x09 - I2C Bus Status Register 2
        volatile uint32_t SARL%s;  ///< Offset: 0x0A - Slave Address Register Ly
        volatile uint32_t SARU%s;  ///< Offset: 0x0B - Slave Address Register Uy
        volatile uint32_t ICBRL;  ///< Offset: 0x10 - I2C Bus Bit Rate Low-Level Register
        volatile uint32_t ICBRH;  ///< Offset: 0x11 - I2C Bus Bit Rate High-Level Register
        volatile uint32_t ICDRT;  ///< Offset: 0x12 - I2C Bus Transmit Data Register
        volatile uint32_t ICDRR;  ///< Offset: 0x13 - I2C Bus Receive Data Register
    };

    /// Peripheral instances
    inline Registers* IIC0 = reinterpret_cast<Registers*>(IIC0_BASE);

    // Bit definitions
    /// ICCR1 Register bits
    namespace iccr1_bits {
        constexpr uint32_t SDAI = (1U << 0);  ///< SDA Line Monitor
        constexpr uint32_t SCLI = (1U << 1);  ///< SCL Line Monitor
        constexpr uint32_t SDAO = (1U << 2);  ///< SDA Output Control/Monitor
        constexpr uint32_t SCLO = (1U << 3);  ///< SCL Output Control/Monitor
        constexpr uint32_t SOWP = (1U << 4);  ///< SCLO/SDAO Write Protect
        constexpr uint32_t CLO = (1U << 5);  ///< Extra SCL Clock Cycle Output
        constexpr uint32_t IICRST = (1U << 6);  ///< I2C Bus Interface Internal Reset
        constexpr uint32_t ICE = (1U << 7);  ///< I2C Bus Interface Enable
    }

    /// ICCR2 Register bits
    namespace iccr2_bits {
        constexpr uint32_t ST = (1U << 1);  ///< Start Condition Issuance Request
        constexpr uint32_t RS = (1U << 2);  ///< Restart Condition Issuance Request
        constexpr uint32_t SP = (1U << 3);  ///< Stop Condition Issuance Request
        constexpr uint32_t TRS = (1U << 5);  ///< Transmit/Receive Mode
        constexpr uint32_t MST = (1U << 6);  ///< Master/Slave Mode
        constexpr uint32_t BBSY = (1U << 7);  ///< Bus Busy Detection Flag
    }

    /// ICMR1 Register bits
    namespace icmr1_bits {
        constexpr uint32_t BC = (3 << 0);  ///< Bit Counter
        constexpr uint32_t BCWP = (1U << 3);  ///< BC Write Protect
        constexpr uint32_t CKS = (3 << 4);  ///< Internal Reference Clock Select
        constexpr uint32_t MTWP = (1U << 7);  ///< MST/TRS Write Protect
    }

    /// ICMR2 Register bits
    namespace icmr2_bits {
        constexpr uint32_t TMOS = (1U << 0);  ///< Timeout Detection Time Select
        constexpr uint32_t TMOL = (1U << 1);  ///< Timeout L Count Control
        constexpr uint32_t TMOH = (1U << 2);  ///< Timeout H Count Control
        constexpr uint32_t SDDL = (3 << 4);  ///< SDA Output Delay Counter
        constexpr uint32_t DLCS = (1U << 7);  ///< SDA Output Delay Clock Source Select
    }

    /// ICMR3 Register bits
    namespace icmr3_bits {
        constexpr uint32_t NF = (2 << 0);  ///< Noise Filter Stage Select
        constexpr uint32_t ACKBR = (1U << 2);  ///< Receive Acknowledge
        constexpr uint32_t ACKBT = (1U << 3);  ///< Transmit Acknowledge
        constexpr uint32_t ACKWP = (1U << 4);  ///< ACKBT Write Protect
        constexpr uint32_t RDRFS = (1U << 5);  ///< RDRF Flag Set Timing Select
        constexpr uint32_t WAIT = (1U << 6);  ///< Low-hold is released by reading ICDRR.
        constexpr uint32_t SMBS = (1U << 7);  ///< SMBus/I2C Bus Select
    }

    /// ICFER Register bits
    namespace icfer_bits {
        constexpr uint32_t TMOE = (1U << 0);  ///< Timeout Function Enable
        constexpr uint32_t MALE = (1U << 1);  ///< Master Arbitration-Lost Detection Enable
        constexpr uint32_t NALE = (1U << 2);  ///< NACK Transmission Arbitration-Lost Detection Enable
        constexpr uint32_t SALE = (1U << 3);  ///< Slave Arbitration-Lost Detection Enable
        constexpr uint32_t NACKE = (1U << 4);  ///< NACK Reception Transfer Suspension Enable
        constexpr uint32_t NFE = (1U << 5);  ///< Digital Noise Filter Circuit Enable
        constexpr uint32_t SCLE = (1U << 6);  ///< SCL Synchronous Circuit Enable
    }

    /// ICSER Register bits
    namespace icser_bits {
        constexpr uint32_t SAR0E = (1U << 0);  ///< Slave Address Register 0 Enable
        constexpr uint32_t SAR1E = (1U << 1);  ///< Slave Address Register 1 Enable
        constexpr uint32_t SAR2E = (1U << 2);  ///< Slave Address Register 2 Enable
        constexpr uint32_t GCAE = (1U << 3);  ///< General Call Address Enable
        constexpr uint32_t DIDE = (1U << 5);  ///< Device-ID Address Detection Enable
        constexpr uint32_t HOAE = (1U << 7);  ///< Host Address Enable
    }

    /// ICIER Register bits
    namespace icier_bits {
        constexpr uint32_t TMOIE = (1U << 0);  ///< Timeout Interrupt Request Enable
        constexpr uint32_t ALIE = (1U << 1);  ///< Arbitration-Lost Interrupt Request Enable
        constexpr uint32_t STIE = (1U << 2);  ///< Start Condition Detection Interrupt Request Enable
        constexpr uint32_t SPIE = (1U << 3);  ///< Stop Condition Detection Interrupt Request Enable
        constexpr uint32_t NAKIE = (1U << 4);  ///< NACK Reception Interrupt Request Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receive Data Full Interrupt Request Enable
        constexpr uint32_t TEIE = (1U << 6);  ///< Transmit End Interrupt Request Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Data Empty Interrupt Request Enable
    }

    /// ICSR1 Register bits
    namespace icsr1_bits {
        constexpr uint32_t AAS0 = (1U << 0);  ///< Slave Address 0 Detection Flag
        constexpr uint32_t AAS1 = (1U << 1);  ///< Slave Address 1 Detection Flag
        constexpr uint32_t AAS2 = (1U << 2);  ///< Slave Address 2 Detection Flag
        constexpr uint32_t GCA = (1U << 3);  ///< General Call Address Detection Flag
        constexpr uint32_t DID = (1U << 5);  ///< Device-ID Address Detection Flag
        constexpr uint32_t HOA = (1U << 7);  ///< Host Address Detection Flag
    }

    /// ICSR2 Register bits
    namespace icsr2_bits {
        constexpr uint32_t TMOF = (1U << 0);  ///< Timeout Detection Flag
        constexpr uint32_t AL = (1U << 1);  ///< Arbitration-Lost Flag
        constexpr uint32_t START = (1U << 2);  ///< Start Condition Detection Flag
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Condition Detection Flag
        constexpr uint32_t NACKF = (1U << 4);  ///< NACK Detection Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Full Flag
        constexpr uint32_t TEND = (1U << 6);  ///< Transmit End Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SARL%s Register bits
    namespace sarl%s_bits {
        constexpr uint32_t SVA0 = (1U << 0);  ///< 10-bit Address LSB
        constexpr uint32_t SVA = (7 << 1);  ///< 7-bit Address/10-bit Address Lower Bits
    }

    /// SARU%s Register bits
    namespace saru%s_bits {
        constexpr uint32_t FS = (1U << 0);  ///< 7-bit/10-bit Address Format Select
        constexpr uint32_t SVA = (2 << 1);  ///< 10-bit Address Upper Bits
    }

    /// ICBRL Register bits
    namespace icbrl_bits {
        constexpr uint32_t BRL = (5 << 0);  ///< Bit Rate Low-Level Period
    }

    /// ICBRH Register bits
    namespace icbrh_bits {
        constexpr uint32_t BRH = (5 << 0);  ///< Bit Rate High-Level Period
    }

}

// ============================================================================
// IIC0WU Peripheral
// ============================================================================

namespace iic0wu {
    /// Base addresses
    constexpr uint32_t IIC0WU_BASE = 0x40053014;

    /// IIC0WU Register structure
    struct Registers {
        volatile uint32_t ICWUR;  ///< Offset: 0x02 - I2C Bus Wakeup Unit Register
        volatile uint32_t ICWUR2;  ///< Offset: 0x03 - I2C Bus Wakeup Unit Register 2
    };

    /// Peripheral instances
    inline Registers* IIC0WU = reinterpret_cast<Registers*>(IIC0WU_BASE);

    // Bit definitions
    /// ICWUR Register bits
    namespace icwur_bits {
        constexpr uint32_t WUAFA = (1U << 0);  ///< Wakeup Analog Filter Additional Selection
        constexpr uint32_t WUACK = (1U << 4);  ///< ACK Bit for Wakeup Mode
        constexpr uint32_t WUF = (1U << 5);  ///< Wakeup Event Occurrence Flag
        constexpr uint32_t WUIE = (1U << 6);  ///< Wakeup Interrupt Request Enable
        constexpr uint32_t WUE = (1U << 7);  ///< Wakeup Function Enable
    }

    /// ICWUR2 Register bits
    namespace icwur2_bits {
        constexpr uint32_t WUSEN = (1U << 0);  ///< Wakeup Function Synchronous Enable
        constexpr uint32_t WUASYF = (1U << 1);  ///< Wakeup Function Asynchronous Operation Status Flag
        constexpr uint32_t WUSYF = (1U << 2);  ///< Wakeup Function Synchronous Operation Status Flag
    }

}

// ============================================================================
// DOC Peripheral
// ============================================================================

namespace doc {
    /// Base addresses
    constexpr uint32_t DOC_BASE = 0x40054100;

    /// DOC Register structure
    struct Registers {
        volatile uint32_t DOCR;  ///< Offset: 0x00 - DOC Control Register
        volatile uint32_t DODIR;  ///< Offset: 0x02 - DOC Data Input Register
        volatile uint32_t DODSR;  ///< Offset: 0x04 - DOC Data Setting Register
    };

    /// Peripheral instances
    inline Registers* DOC = reinterpret_cast<Registers*>(DOC_BASE);

    // Bit definitions
    /// DOCR Register bits
    namespace docr_bits {
        constexpr uint32_t OMS = (2 << 0);  ///< Operating Mode Select
        constexpr uint32_t DCSEL = (1U << 2);  ///< Detection Condition Select
        constexpr uint32_t DOPCF = (1U << 5);  ///< DOC Flag
        constexpr uint32_t DOPCFCL = (1U << 6);  ///< DOPCF Clear
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC120_BASE = 0x4005C000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADCSR;  ///< Offset: 0x00 - A/D Control Register
        volatile uint32_t ADANSA0;  ///< Offset: 0x04 - A/D Channel Select Register A0
        volatile uint32_t ADANSA1;  ///< Offset: 0x06 - A/D Channel Select Register A1
        volatile uint32_t ADADS0;  ///< Offset: 0x08 - A/D-Converted Value Addition/Average Channel Select Register 0
        volatile uint32_t ADADS1;  ///< Offset: 0x0A - A/D-Converted Value Addition/Average Channel Select Register 1
        volatile uint32_t ADADC;  ///< Offset: 0x0C - A/D-Converted Value Addition/Average Count Select Register
        volatile uint32_t ADCER;  ///< Offset: 0x0E - A/D Control Extended Register
        volatile uint32_t ADSTRGR;  ///< Offset: 0x10 - A/D Conversion Start Trigger Select Register
        volatile uint32_t ADEXICR;  ///< Offset: 0x12 - A/D Conversion Extended Input Control Registers
        volatile uint32_t ADANSB0;  ///< Offset: 0x14 - A/D Channel Select Register B0
        volatile uint32_t ADANSB1;  ///< Offset: 0x16 - A/D Channel Select Register B1
        volatile uint32_t ADDBLDR;  ///< Offset: 0x18 - A/D Data Duplexing Register
        volatile uint32_t ADTSDR;  ///< Offset: 0x1A - A/D Temperature Sensor Data Register
        volatile uint32_t ADOCDR;  ///< Offset: 0x1C - A/D Internal Reference Voltage Data Register
        volatile uint32_t ADRD;  ///< Offset: 0x1E - A/D Self-Diagnosis Data Register
        volatile uint32_t ADDR%s;  ///< Offset: 0x42 - A/D Data Registers %s
        volatile uint32_t ADCTDR;  ///< Offset: 0x40 - A/D CTSU TSCAP Voltage Data Register
        volatile uint32_t ADDISCR;  ///< Offset: 0x7A - A/D Disconnection Detection Control Register
        volatile uint32_t ADACSR;  ///< Offset: 0x7E - A/D Conversion Operation Mode Select Register
        volatile uint32_t ADGSPCR;  ///< Offset: 0x80 - A/D Group Scan Priority Control Register
        volatile uint32_t ADDBLDRA;  ///< Offset: 0x84 - A/D Data Duplexing Register A
        volatile uint32_t ADDBLDRB;  ///< Offset: 0x86 - A/D Data Duplexing Register B
        volatile uint32_t ADHVREFCNT;  ///< Offset: 0x8A - A/D High-Potential/Low-Potential Reference Voltage...
        volatile uint32_t ADWINMON;  ///< Offset: 0x8C - A/D Compare Function Window A/B Status Monitor Register
        volatile uint32_t ADCMPCR;  ///< Offset: 0x90 - A/D Compare Function Control Register
        volatile uint32_t ADCMPANSER;  ///< Offset: 0x92 - A/D Compare Function Window A Extended Input Select Register
        volatile uint32_t ADCMPLER;  ///< Offset: 0x93 - A/D Compare Function Window A Extended Input Comparison...
        volatile uint32_t ADCMPANSR0;  ///< Offset: 0x94 - A/D Compare Function Window A Channel Select Register 0
        volatile uint32_t ADCMPANSR1;  ///< Offset: 0x96 - A/D Compare Function Window A Channel Select Register 1
        volatile uint32_t ADCMPLR0;  ///< Offset: 0x98 - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPLR1;  ///< Offset: 0x9A - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPDR%s;  ///< Offset: 0x9C - A/D Compare Function Window A Lower-Side/Upper-Side...
        volatile uint32_t ADCMPSR0;  ///< Offset: 0xA0 - A/D Compare Function Window A Channel Status Register 0
        volatile uint32_t ADCMPSR1;  ///< Offset: 0xA2 - A/D Compare Function Window A Channel Status Register1
        volatile uint32_t ADCMPSER;  ///< Offset: 0xA4 - A/D Compare Function Window A Extended Input Channel...
        volatile uint32_t ADCMPBNSR;  ///< Offset: 0xA6 - A/D Compare Function Window B Channel Select Register
        volatile uint32_t ADWINLLB;  ///< Offset: 0xA8 - A/D Compare Function Window B Lower-Side/Upper-Side...
        volatile uint32_t ADWINULB;  ///< Offset: 0xAA - A/D Compare Function Window B Lower-Side/Upper-Side...
        volatile uint32_t ADCMPBSR;  ///< Offset: 0xAC - A/D Compare Function Window B Status Register
        volatile uint32_t ADSSTRL;  ///< Offset: 0xDD - A/D Sampling State Register
        volatile uint32_t ADSSTRT;  ///< Offset: 0xDE - A/D Sampling State Register
        volatile uint32_t ADSSTRO;  ///< Offset: 0xDF - A/D Sampling State Register
        volatile uint32_t ADSSTR%s;  ///< Offset: 0xE0 - A/D Sampling State Register
    };

    /// Peripheral instances
    inline Registers* ADC120 = reinterpret_cast<Registers*>(ADC120_BASE);

    // Bit definitions
    /// ADCSR Register bits
    namespace adcsr_bits {
        constexpr uint32_t DBLANS = (5 << 0);  ///< Double Trigger Channel Select
        constexpr uint32_t GBADIE = (1U << 6);  ///< Group B Scan End Interrupt and ELC Event Enable
        constexpr uint32_t DBLE = (1U << 7);  ///< Double Trigger Mode Select
        constexpr uint32_t EXTRG = (1U << 8);  ///< Trigger Select
        constexpr uint32_t TRGE = (1U << 9);  ///< Trigger Start Enable
        constexpr uint32_t ADHSC = (1U << 10);  ///< A/D Conversion Mode Select
        constexpr uint32_t ADCS = (2 << 13);  ///< Scan Mode Select
        constexpr uint32_t ADST = (1U << 15);  ///< A/D Conversion Start
    }

    /// ADANSA0 Register bits
    namespace adansa0_bits {
        constexpr uint32_t ANSA00 = (1U << 0);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA01 = (1U << 1);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA02 = (1U << 2);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA03 = (1U << 3);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA04 = (1U << 4);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA05 = (1U << 5);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA06 = (1U << 6);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA07 = (1U << 7);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA08 = (1U << 8);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA09 = (1U << 9);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA10 = (1U << 10);  ///< A/D Conversion Channels Select
    }

    /// ADANSA1 Register bits
    namespace adansa1_bits {
        constexpr uint32_t ANSA16 = (1U << 0);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA17 = (1U << 1);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA18 = (1U << 2);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA19 = (1U << 3);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA20 = (1U << 4);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA21 = (1U << 5);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA22 = (1U << 6);  ///< A/D Conversion Channels Select
    }

    /// ADADS0 Register bits
    namespace adads0_bits {
        constexpr uint32_t ADS00 = (1U << 0);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS01 = (1U << 1);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS02 = (1U << 2);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS03 = (1U << 3);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS04 = (1U << 4);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS05 = (1U << 5);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS06 = (1U << 6);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS07 = (1U << 7);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS08 = (1U << 8);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS09 = (1U << 9);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS10 = (1U << 10);  ///< A/D-Converted Value Addition/Average Channel Select
    }

    /// ADADS1 Register bits
    namespace adads1_bits {
        constexpr uint32_t ADS16 = (1U << 0);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS17 = (1U << 1);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS18 = (1U << 2);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS19 = (1U << 3);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS20 = (1U << 4);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS21 = (1U << 5);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS22 = (1U << 6);  ///< A/D-Converted Value Addition/Average Channel Select
    }

    /// ADADC Register bits
    namespace adadc_bits {
        constexpr uint32_t ADC = (3 << 0);  ///< Addition/Average Count Select
        constexpr uint32_t AVEE = (1U << 7);  ///< Average Mode Select
    }

    /// ADCER Register bits
    namespace adcer_bits {
        constexpr uint32_t ACE = (1U << 5);  ///< A/D Data Register Automatic Clearing Enable
        constexpr uint32_t DIAGVAL = (2 << 8);  ///< Self-Diagnosis Conversion Voltage Select
        constexpr uint32_t DIAGLD = (1U << 10);  ///< Self-Diagnosis Mode Select
        constexpr uint32_t DIAGM = (1U << 11);  ///< Self-Diagnosis Enable
        constexpr uint32_t ADRFMT = (1U << 15);  ///< A/D Data Register Format Select
    }

    /// ADSTRGR Register bits
    namespace adstrgr_bits {
        constexpr uint32_t TRSB = (6 << 0);  ///< A/D Conversion Start Trigger Select for Group B
        constexpr uint32_t TRSA = (6 << 8);  ///< A/D Conversion Start Trigger Select
    }

    /// ADEXICR Register bits
    namespace adexicr_bits {
        constexpr uint32_t TSSAD = (1U << 0);  ///< Temperature Sensor Output A/D-Converted Value Addition/Average Mode Select
        constexpr uint32_t OCSAD = (1U << 1);  ///< Internal Reference Voltage A/D-Converted Value Addition/Average Mode Select
        constexpr uint32_t TSSA = (1U << 8);  ///< Temperature Sensor Output A/D Conversion Select
        constexpr uint32_t OCSA = (1U << 9);  ///< Internal Reference Voltage A/D Conversion Select
    }

    /// ADANSB0 Register bits
    namespace adansb0_bits {
        constexpr uint32_t ANSB00 = (1U << 0);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB01 = (1U << 1);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB02 = (1U << 2);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB03 = (1U << 3);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB04 = (1U << 4);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB05 = (1U << 5);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB06 = (1U << 6);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB07 = (1U << 7);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB08 = (1U << 8);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB09 = (1U << 9);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB10 = (1U << 10);  ///< A/D Conversion Channels Select
    }

    /// ADANSB1 Register bits
    namespace adansb1_bits {
        constexpr uint32_t ANSB16 = (1U << 0);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB17 = (1U << 1);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB18 = (1U << 2);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB19 = (1U << 3);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB20 = (1U << 4);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB21 = (1U << 5);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB22 = (1U << 6);  ///< A/D Conversion Channels Select
    }

    /// ADDBLDR Register bits
    namespace addbldr_bits {
        constexpr uint32_t ADDBLDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADTSDR Register bits
    namespace adtsdr_bits {
        constexpr uint32_t ADTSDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADOCDR Register bits
    namespace adocdr_bits {
        constexpr uint32_t ADOCDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADRD Register bits
    namespace adrd_bits {
        constexpr uint32_t AD = (12 << 0);  ///< Converted Value 11 to 0
        constexpr uint32_t DIAGST = (2 << 14);  ///< Self-Diagnosis Status
    }

    /// ADDR%s Register bits
    namespace addr%s_bits {
        constexpr uint32_t ADDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADCTDR Register bits
    namespace adctdr_bits {
        constexpr uint32_t ADCTDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADDISCR Register bits
    namespace addiscr_bits {
        constexpr uint32_t ADNDIS = (4 << 0);  ///< Disconnection Detection Assist Setting
        constexpr uint32_t PCHG = (1U << 4);  ///< Precharge/discharge select
    }

    /// ADACSR Register bits
    namespace adacsr_bits {
        constexpr uint32_t ADSAC = (1U << 1);  ///< Successive Approximation Control Setting
    }

    /// ADGSPCR Register bits
    namespace adgspcr_bits {
        constexpr uint32_t PGS = (1U << 0);  ///< Group Priority Operation Setting
        constexpr uint32_t GBRSCN = (1U << 1);  ///< Lower-Priority Group Restart Setting
        constexpr uint32_t GBRP = (1U << 15);  ///< Single Scan Continuous Start
    }

    /// ADDBLDRA Register bits
    namespace addbldra_bits {
        constexpr uint32_t ADDBLDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADDBLDRB Register bits
    namespace addbldrb_bits {
        constexpr uint32_t ADDBLDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADHVREFCNT Register bits
    namespace adhvrefcnt_bits {
        constexpr uint32_t HVSEL = (2 << 0);  ///< High-Potential Reference Voltage Select
        constexpr uint32_t LVSEL = (1U << 4);  ///< Low-Potential Reference Voltage Select
        constexpr uint32_t ADSLP = (1U << 7);  ///< Sleep
    }

    /// ADWINMON Register bits
    namespace adwinmon_bits {
        constexpr uint32_t MONCOMB = (1U << 0);  ///< Combination Result Monitor
        constexpr uint32_t MONCMPA = (1U << 4);  ///< Comparison Result Monitor A
        constexpr uint32_t MONCMPB = (1U << 5);  ///< Comparison Result Monitor B
    }

    /// ADCMPCR Register bits
    namespace adcmpcr_bits {
        constexpr uint32_t CMPAB = (2 << 0);  ///< Window A/B Composite Conditions Setting
        constexpr uint32_t CMPBE = (1U << 9);  ///< Compare Window B Operation Enable
        constexpr uint32_t CMPAE = (1U << 11);  ///< Compare Window A Operation Enable
        constexpr uint32_t CMPBIE = (1U << 13);  ///< Compare B Interrupt Enable
        constexpr uint32_t WCMPE = (1U << 14);  ///< Window Function Setting
        constexpr uint32_t CMPAIE = (1U << 15);  ///< Compare A Interrupt Enable
    }

    /// ADCMPANSER Register bits
    namespace adcmpanser_bits {
        constexpr uint32_t CMPTSA = (1U << 0);  ///< Temperature Sensor Output Compare Select
        constexpr uint32_t CMPOCA = (1U << 1);  ///< Internal Reference Voltage Compare Select
    }

    /// ADCMPLER Register bits
    namespace adcmpler_bits {
        constexpr uint32_t CMPLTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Comparison Condition Select
        constexpr uint32_t CMPLOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage Comparison Condition Select
    }

    /// ADCMPANSR0 Register bits
    namespace adcmpansr0_bits {
        constexpr uint32_t CMPCHA00 = (1U << 0);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA01 = (1U << 1);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA02 = (1U << 2);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA03 = (1U << 3);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA04 = (1U << 4);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA05 = (1U << 5);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA06 = (1U << 6);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA07 = (1U << 7);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA08 = (1U << 8);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA09 = (1U << 9);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA10 = (1U << 10);  ///< Compare Window A Channel Select
    }

    /// ADCMPANSR1 Register bits
    namespace adcmpansr1_bits {
        constexpr uint32_t CMPCHA16 = (1U << 0);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA17 = (1U << 1);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA18 = (1U << 2);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA19 = (1U << 3);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA20 = (1U << 4);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA21 = (1U << 5);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA22 = (1U << 6);  ///< Compare Window A Channel Select
    }

    /// ADCMPLR0 Register bits
    namespace adcmplr0_bits {
        constexpr uint32_t CMPLCHA00 = (1U << 0);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA01 = (1U << 1);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA02 = (1U << 2);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA03 = (1U << 3);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA04 = (1U << 4);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA05 = (1U << 5);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA06 = (1U << 6);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA07 = (1U << 7);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA08 = (1U << 8);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA09 = (1U << 9);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA10 = (1U << 10);  ///< Compare Window A Comparison Condition Select
    }

    /// ADCMPLR1 Register bits
    namespace adcmplr1_bits {
        constexpr uint32_t CMPLCHA16 = (1U << 0);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA17 = (1U << 1);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA18 = (1U << 2);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA19 = (1U << 3);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA20 = (1U << 4);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA21 = (1U << 5);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA22 = (1U << 6);  ///< Compare Window A Comparison Condition Select
    }

    /// ADCMPSR0 Register bits
    namespace adcmpsr0_bits {
        constexpr uint32_t CMPSTCHA00 = (1U << 0);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA01 = (1U << 1);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA02 = (1U << 2);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA03 = (1U << 3);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA04 = (1U << 4);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA05 = (1U << 5);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA06 = (1U << 6);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA07 = (1U << 7);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA08 = (1U << 8);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA09 = (1U << 9);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA10 = (1U << 10);  ///< Compare Window A Flag
    }

    /// ADCMPSR1 Register bits
    namespace adcmpsr1_bits {
        constexpr uint32_t CMPSTCHA16 = (1U << 0);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA17 = (1U << 1);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA18 = (1U << 2);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA19 = (1U << 3);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA20 = (1U << 4);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA21 = (1U << 5);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA22 = (1U << 6);  ///< Compare Window A Flag
    }

    /// ADCMPSER Register bits
    namespace adcmpser_bits {
        constexpr uint32_t CMPSTTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Compare Flag
        constexpr uint32_t CMPSTOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage Compare Flag
    }

    /// ADCMPBNSR Register bits
    namespace adcmpbnsr_bits {
        constexpr uint32_t CMPCHB = (6 << 0);  ///< Compare Window B Channel Select
        constexpr uint32_t CMPLB = (1U << 7);  ///< Compare Window B Comparison Condition Setting
    }

    /// ADCMPBSR Register bits
    namespace adcmpbsr_bits {
        constexpr uint32_t CMPSTB = (1U << 0);  ///< Compare Window B Flag
    }

    /// ADSSTRL Register bits
    namespace adsstrl_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting
    }

    /// ADSSTRT Register bits
    namespace adsstrt_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting
    }

    /// ADSSTRO Register bits
    namespace adsstro_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting
    }

    /// ADSSTR%s Register bits
    namespace adsstr%s_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting
    }

}

// ============================================================================
// SCI0 Peripheral
// ============================================================================

namespace sci0 {
    /// Base addresses
    constexpr uint32_t SCI0_BASE = 0x40070000;

    /// SCI0 Register structure
    struct Registers {
        volatile uint32_t SMR;  ///< Offset: 0x00 - Serial Mode Register for Non-Smart Card Interface Mode...
        volatile uint32_t SMR_SMCI;  ///< Offset: 0x00 - Serial Mode Register for Smart Card Interface Mode...
        volatile uint32_t BRR;  ///< Offset: 0x01 - Bit Rate Register
        volatile uint32_t SCR;  ///< Offset: 0x02 - Serial Control Register for Non-Smart Card Interface...
        volatile uint32_t SCR_SMCI;  ///< Offset: 0x02 - Serial Control Register for Smart Card Interface Mode...
        volatile uint32_t TDR;  ///< Offset: 0x03 - Transmit Data Register
        volatile uint32_t SSR;  ///< Offset: 0x04 - Serial Status Register for Non-Smart Card Interface and...
        volatile uint32_t SSR_FIFO;  ///< Offset: 0x04 - Serial Status Register for Non-Smart Card Interface and...
        volatile uint32_t SSR_SMCI;  ///< Offset: 0x04 - Serial Status Register for Smart Card Interface Mode...
        volatile uint32_t RDR;  ///< Offset: 0x05 - Receive Data Register
        volatile uint32_t SCMR;  ///< Offset: 0x06 - Smart Card Mode Register
        volatile uint32_t SEMR;  ///< Offset: 0x07 - Serial Extended Mode Register
        volatile uint32_t SNFR;  ///< Offset: 0x08 - Noise Filter Setting Register
        volatile uint32_t SIMR1;  ///< Offset: 0x09 - IIC Mode Register 1
        volatile uint32_t SIMR2;  ///< Offset: 0x0A - IIC Mode Register 2
        volatile uint32_t SIMR3;  ///< Offset: 0x0B - IIC Mode Register 3
        volatile uint32_t SISR;  ///< Offset: 0x0C - IIC Status Register
        volatile uint32_t SPMR;  ///< Offset: 0x0D - SPI Mode Register
        volatile uint32_t FTDRHL;  ///< Offset: 0x0E - Transmit FIFO Data Register
        volatile uint32_t TDRHL;  ///< Offset: 0x0E - Transmit Data Register
        volatile uint32_t FTDRH;  ///< Offset: 0x0E - Transmit FIFO Data Register
        volatile uint32_t FTDRL;  ///< Offset: 0x0F - Transmit FIFO Data Register
        volatile uint32_t FRDRHL;  ///< Offset: 0x10 - Receive FIFO Data Register
        volatile uint32_t RDRHL;  ///< Offset: 0x10 - Receive Data Register
        volatile uint32_t FRDRH;  ///< Offset: 0x10 - Receive FIFO Data Register
        volatile uint32_t FRDRL;  ///< Offset: 0x11 - Receive FIFO Data Register
        volatile uint32_t MDDR;  ///< Offset: 0x12 - Modulation Duty Register
        volatile uint32_t DCCR;  ///< Offset: 0x13 - Data Compare Match Control Register
        volatile uint32_t FCR;  ///< Offset: 0x14 - FIFO Control Register
        volatile uint32_t FDR;  ///< Offset: 0x16 - FIFO Data Count Register
        volatile uint32_t LSR;  ///< Offset: 0x18 - Line Status Register
        volatile uint32_t CDR;  ///< Offset: 0x1A - Compare Match Data Register
        volatile uint32_t SPTR;  ///< Offset: 0x1C - Serial Port Register
    };

    /// Peripheral instances
    inline Registers* SCI0 = reinterpret_cast<Registers*>(SCI0_BASE);

    // Bit definitions
    /// SMR Register bits
    namespace smr_bits {
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
        constexpr uint32_t MP = (1U << 2);  ///< Multi-Processor Mode
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Bit Length
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable
        constexpr uint32_t CHR = (1U << 6);  ///< Character Length
        constexpr uint32_t CM = (1U << 7);  ///< Communication Mode
    }

    /// SMR_SMCI Register bits
    namespace smr_smci_bits {
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
        constexpr uint32_t BCP = (2 << 2);  ///< Base Clock Pulse
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable
        constexpr uint32_t BLK = (1U << 6);  ///< Block Transfer Mode
        constexpr uint32_t GM = (1U << 7);  ///< GSM Mode
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
    }

    /// SCR_SMCI Register bits
    namespace scr_smci_bits {
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SSR_FIFO Register bits
    namespace ssr_fifo_bits {
        constexpr uint32_t DR = (1U << 0);  ///< Receive Data Ready Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO Data Full Flag
        constexpr uint32_t TDFE = (1U << 7);  ///< Transmit FIFO Data Empty Flag
    }

    /// SSR_SMCI Register bits
    namespace ssr_smci_bits {
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t ERS = (1U << 4);  ///< Error Signal Status Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SCMR Register bits
    namespace scmr_bits {
        constexpr uint32_t SMIF = (1U << 0);  ///< Smart Card Interface Mode Select
        constexpr uint32_t SINV = (1U << 2);  ///< Transmitted/Received Data Invert
        constexpr uint32_t SDIR = (1U << 3);  ///< Transmitted/Received Data Transfer Direction
        constexpr uint32_t CHR1 = (1U << 4);  ///< Character Length 1
        constexpr uint32_t BCP2 = (1U << 7);  ///< Base Clock Pulse 2
    }

    /// SEMR Register bits
    namespace semr_bits {
        constexpr uint32_t BRME = (1U << 2);  ///< Bit Rate Modulation Enable
        constexpr uint32_t ABCSE = (1U << 3);  ///< Asynchronous Mode Extended Base Clock Select 1
        constexpr uint32_t ABCS = (1U << 4);  ///< Asynchronous Mode Base Clock Select
        constexpr uint32_t NFEN = (1U << 5);  ///< Digital Noise Filter Function Enable
        constexpr uint32_t BGDM = (1U << 6);  ///< Baud Rate Generator Double-Speed Mode Select
        constexpr uint32_t RXDESEL = (1U << 7);  ///< Asynchronous Start Bit Edge Detection Select
    }

    /// SNFR Register bits
    namespace snfr_bits {
        constexpr uint32_t NFCS = (3 << 0);  ///< Noise Filter Clock Select
    }

    /// SIMR1 Register bits
    namespace simr1_bits {
        constexpr uint32_t IICM = (1U << 0);  ///< Simple IIC Mode Select
        constexpr uint32_t IICDL = (5 << 3);  ///< SDAn Delay Output Select
    }

    /// SIMR2 Register bits
    namespace simr2_bits {
        constexpr uint32_t IICINTM = (1U << 0);  ///< IIC Interrupt Mode Select
        constexpr uint32_t IICCSC = (1U << 1);  ///< Clock Synchronization
        constexpr uint32_t IICACKT = (1U << 5);  ///< ACK Transmission Data
    }

    /// SIMR3 Register bits
    namespace simr3_bits {
        constexpr uint32_t IICSTAREQ = (1U << 0);  ///< Start Condition Generation
        constexpr uint32_t IICRSTAREQ = (1U << 1);  ///< Restart Condition Generation
        constexpr uint32_t IICSTPREQ = (1U << 2);  ///< Stop Condition Generation
        constexpr uint32_t IICSTIF = (1U << 3);  ///< Issuing of Start, Restart, or Stop Condition Completed Flag
        constexpr uint32_t IICSDAS = (2 << 4);  ///< SDAn Output Select
        constexpr uint32_t IICSCLS = (2 << 6);  ///< SCLn Output Select
    }

    /// SISR Register bits
    namespace sisr_bits {
        constexpr uint32_t IICACKR = (1U << 0);  ///< ACK Reception Data Flag
    }

    /// SPMR Register bits
    namespace spmr_bits {
        constexpr uint32_t SSE = (1U << 0);  ///< SSn Pin Function Enable
        constexpr uint32_t CTSE = (1U << 1);  ///< CTS Enable
        constexpr uint32_t MSS = (1U << 2);  ///< Master Slave Select
        constexpr uint32_t MFF = (1U << 4);  ///< Mode Fault Flag
        constexpr uint32_t CKPOL = (1U << 6);  ///< Clock Polarity Select
        constexpr uint32_t CKPH = (1U << 7);  ///< Clock Phase Select
    }

    /// FTDRHL Register bits
    namespace ftdrhl_bits {
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial transmit data
        constexpr uint32_t MPBT = (1U << 9);  ///< Multi-Processor Transfer Bit Flag
    }

    /// TDRHL Register bits
    namespace tdrhl_bits {
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial Transmit Data
    }

    /// FTDRH Register bits
    namespace ftdrh_bits {
        constexpr uint32_t MPBT = (1U << 1);  ///< Multi-Processor Transfer Bit Flag
    }

    /// FTDRL Register bits
    namespace ftdrl_bits {
        constexpr uint32_t TDAT = (8 << 0);  ///< Serial transmit data
    }

    /// FRDRHL Register bits
    namespace frdrhl_bits {
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial receive data
        constexpr uint32_t MPB = (1U << 9);  ///< Multi-Processor Bit Flag
        constexpr uint32_t DR = (1U << 10);  ///< Receive Data Ready Flag
        constexpr uint32_t PER = (1U << 11);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 12);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 13);  ///< Overrun Error Flag
        constexpr uint32_t RDF = (1U << 14);  ///< Receive FIFO Data Full Flag
    }

    /// RDRHL Register bits
    namespace rdrhl_bits {
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial Receive Data
    }

    /// FRDRH Register bits
    namespace frdrh_bits {
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor Bit Flag
        constexpr uint32_t DR = (1U << 2);  ///< Receive Data Ready Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO Data Full Flag
    }

    /// FRDRL Register bits
    namespace frdrl_bits {
        constexpr uint32_t RDAT = (8 << 0);  ///< Serial receive data
    }

    /// DCCR Register bits
    namespace dccr_bits {
        constexpr uint32_t DCMF = (1U << 0);  ///< Data Compare Match Flag
        constexpr uint32_t DPER = (1U << 3);  ///< Data Compare Match Parity Error Flag
        constexpr uint32_t DFER = (1U << 4);  ///< Data Compare Match Framing Error Flag
        constexpr uint32_t IDSEL = (1U << 6);  ///< ID Frame Select
        constexpr uint32_t DCME = (1U << 7);  ///< Data Compare Match Enable
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t FM = (1U << 0);  ///< FIFO Mode Select
        constexpr uint32_t RFRST = (1U << 1);  ///< Receive FIFO Data Register Reset
        constexpr uint32_t TFRST = (1U << 2);  ///< Transmit FIFO Data Register Reset
        constexpr uint32_t DRES = (1U << 3);  ///< Receive Data Ready Error Select
        constexpr uint32_t TTRG = (4 << 4);  ///< Transmit FIFO Data Trigger Number
        constexpr uint32_t RTRG = (4 << 8);  ///< Receive FIFO Data Trigger Number
        constexpr uint32_t RSTRG = (4 << 12);  ///< RTS Output Active Trigger Number Select
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t R = (5 << 0);  ///< Receive FIFO Data Count
        constexpr uint32_t T = (5 << 8);  ///< Transmit FIFO Data Count
    }

    /// LSR Register bits
    namespace lsr_bits {
        constexpr uint32_t ORER = (1U << 0);  ///< Overrun Error Flag
        constexpr uint32_t FNUM = (5 << 2);  ///< Framing Error Count
        constexpr uint32_t PNUM = (5 << 8);  ///< Parity Error Count
    }

    /// CDR Register bits
    namespace cdr_bits {
        constexpr uint32_t CMPD = (9 << 0);  ///< Compare Match Data
    }

    /// SPTR Register bits
    namespace sptr_bits {
        constexpr uint32_t RXDMON = (1U << 0);  ///< Serial Input Data Monitor
        constexpr uint32_t SPB2DT = (1U << 1);  ///< Serial Port Break Data Select
        constexpr uint32_t SPB2IO = (1U << 2);  ///< Serial Port Break I/O
    }

}

// ============================================================================
// SCI1 Peripheral
// ============================================================================

namespace sci1 {
    /// Base addresses
    constexpr uint32_t SCI1_BASE = 0x40070020;

    /// SCI1 Register structure
    struct Registers {
        volatile uint32_t SMR;  ///< Offset: 0x00 - Serial Mode Register for Non-Smart Card Interface Mode...
        volatile uint32_t SMR_SMCI;  ///< Offset: 0x00 - Serial Mode Register for Smart Card Interface Mode...
        volatile uint32_t BRR;  ///< Offset: 0x01 - Bit Rate Register
        volatile uint32_t SCR;  ///< Offset: 0x02 - Serial Control Register for Non-Smart Card Interface...
        volatile uint32_t SCR_SMCI;  ///< Offset: 0x02 - Serial Control Register for Smart Card Interface Mode...
        volatile uint32_t TDR;  ///< Offset: 0x03 - Transmit Data Register
        volatile uint32_t SSR;  ///< Offset: 0x04 - Serial Status Register for Non-Smart Card Interface and...
        volatile uint32_t SSR_SMCI;  ///< Offset: 0x04 - Serial Status Register for Smart Card Interface Mode...
        volatile uint32_t RDR;  ///< Offset: 0x05 - Receive Data Register
        volatile uint32_t SCMR;  ///< Offset: 0x06 - Smart Card Mode Register
        volatile uint32_t SEMR;  ///< Offset: 0x07 - Serial Extended Mode Register
        volatile uint32_t SNFR;  ///< Offset: 0x08 - Noise Filter Setting Register
        volatile uint32_t SIMR1;  ///< Offset: 0x09 - IIC Mode Register 1
        volatile uint32_t SIMR2;  ///< Offset: 0x0A - IIC Mode Register 2
        volatile uint32_t SIMR3;  ///< Offset: 0x0B - IIC Mode Register 3
        volatile uint32_t SISR;  ///< Offset: 0x0C - IIC Status Register
        volatile uint32_t SPMR;  ///< Offset: 0x0D - SPI Mode Register
        volatile uint32_t TDRHL;  ///< Offset: 0x0E - Transmit Data Register
        volatile uint32_t RDRHL;  ///< Offset: 0x10 - Receive Data Register
        volatile uint32_t MDDR;  ///< Offset: 0x12 - Modulation Duty Register
    };

    /// Peripheral instances
    inline Registers* SCI1 = reinterpret_cast<Registers*>(SCI1_BASE);

    // Bit definitions
    /// SMR Register bits
    namespace smr_bits {
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
        constexpr uint32_t MP = (1U << 2);  ///< Multi-Processor Mode
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Bit Length
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable
        constexpr uint32_t CHR = (1U << 6);  ///< Character Length
        constexpr uint32_t CM = (1U << 7);  ///< Communication Mode
    }

    /// SMR_SMCI Register bits
    namespace smr_smci_bits {
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
        constexpr uint32_t BCP = (2 << 2);  ///< Base Clock Pulse
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable
        constexpr uint32_t BLK = (1U << 6);  ///< Block Transfer Mode
        constexpr uint32_t GM = (1U << 7);  ///< GSM Mode
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
    }

    /// SCR_SMCI Register bits
    namespace scr_smci_bits {
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SSR_SMCI Register bits
    namespace ssr_smci_bits {
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t ERS = (1U << 4);  ///< Error Signal Status Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SCMR Register bits
    namespace scmr_bits {
        constexpr uint32_t SMIF = (1U << 0);  ///< Smart Card Interface Mode Select
        constexpr uint32_t SINV = (1U << 2);  ///< Transmitted/Received Data Invert
        constexpr uint32_t SDIR = (1U << 3);  ///< Transmitted/Received Data Transfer Direction
        constexpr uint32_t CHR1 = (1U << 4);  ///< Character Length 1
        constexpr uint32_t BCP2 = (1U << 7);  ///< Base Clock Pulse 2
    }

    /// SEMR Register bits
    namespace semr_bits {
        constexpr uint32_t BRME = (1U << 2);  ///< Bit Rate Modulation Enable
        constexpr uint32_t ABCSE = (1U << 3);  ///< Asynchronous Mode Extended Base Clock Select 1
        constexpr uint32_t ABCS = (1U << 4);  ///< Asynchronous Mode Base Clock Select
        constexpr uint32_t NFEN = (1U << 5);  ///< Digital Noise Filter Function Enable
        constexpr uint32_t BGDM = (1U << 6);  ///< Baud Rate Generator Double-Speed Mode Select
        constexpr uint32_t RXDESEL = (1U << 7);  ///< Asynchronous Start Bit Edge Detection Select
    }

    /// SNFR Register bits
    namespace snfr_bits {
        constexpr uint32_t NFCS = (3 << 0);  ///< Noise Filter Clock Select
    }

    /// SIMR1 Register bits
    namespace simr1_bits {
        constexpr uint32_t IICM = (1U << 0);  ///< Simple IIC Mode Select
        constexpr uint32_t IICDL = (5 << 3);  ///< SDAn Delay Output Select
    }

    /// SIMR2 Register bits
    namespace simr2_bits {
        constexpr uint32_t IICINTM = (1U << 0);  ///< IIC Interrupt Mode Select
        constexpr uint32_t IICCSC = (1U << 1);  ///< Clock Synchronization
        constexpr uint32_t IICACKT = (1U << 5);  ///< ACK Transmission Data
    }

    /// SIMR3 Register bits
    namespace simr3_bits {
        constexpr uint32_t IICSTAREQ = (1U << 0);  ///< Start Condition Generation
        constexpr uint32_t IICRSTAREQ = (1U << 1);  ///< Restart Condition Generation
        constexpr uint32_t IICSTPREQ = (1U << 2);  ///< Stop Condition Generation
        constexpr uint32_t IICSTIF = (1U << 3);  ///< Issuing of Start, Restart, or Stop Condition Completed Flag
        constexpr uint32_t IICSDAS = (2 << 4);  ///< SDAn Output Select
        constexpr uint32_t IICSCLS = (2 << 6);  ///< SCLn Output Select
    }

    /// SISR Register bits
    namespace sisr_bits {
        constexpr uint32_t IICACKR = (1U << 0);  ///< ACK Reception Data Flag
    }

    /// SPMR Register bits
    namespace spmr_bits {
        constexpr uint32_t SSE = (1U << 0);  ///< SSn Pin Function Enable
        constexpr uint32_t CTSE = (1U << 1);  ///< CTS Enable
        constexpr uint32_t MSS = (1U << 2);  ///< Master Slave Select
        constexpr uint32_t MFF = (1U << 4);  ///< Mode Fault Flag
        constexpr uint32_t CKPOL = (1U << 6);  ///< Clock Polarity Select
        constexpr uint32_t CKPH = (1U << 7);  ///< Clock Phase Select
    }

    /// TDRHL Register bits
    namespace tdrhl_bits {
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial Transmit Data
    }

    /// RDRHL Register bits
    namespace rdrhl_bits {
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial Receive Data
    }

}

// ============================================================================
// SCI2 Peripheral
// ============================================================================

namespace sci2 {
    /// Base addresses
    constexpr uint32_t SCI2_BASE = 0x40070040;

    /// SCI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI2 = reinterpret_cast<Registers*>(SCI2_BASE);

}

// ============================================================================
// SCI9 Peripheral
// ============================================================================

namespace sci9 {
    /// Base addresses
    constexpr uint32_t SCI9_BASE = 0x40070120;

    /// SCI9 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI9 = reinterpret_cast<Registers*>(SCI9_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40072000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPCR;  ///< Offset: 0x00 - SPI Control Register
        volatile uint32_t SSLP;  ///< Offset: 0x01 - SPI Slave Select Polarity Register
        volatile uint32_t SPPCR;  ///< Offset: 0x02 - SPI Pin Control Register
        volatile uint32_t SPSR;  ///< Offset: 0x03 - SPI Status Register
        volatile uint32_t SPDR;  ///< Offset: 0x04 - SPI Data Register
        volatile uint32_t SPDR_HA;  ///< Offset: 0x04 - SPI Data Register
        volatile uint32_t SPDR_BY;  ///< Offset: 0x04 - SPI Data Register
        volatile uint32_t SPBR;  ///< Offset: 0x0A - SPI Bit Rate Register
        volatile uint32_t SPDCR;  ///< Offset: 0x0B - SPI Data Control Register
        volatile uint32_t SPCKD;  ///< Offset: 0x0C - SPI Clock Delay Register
        volatile uint32_t SSLND;  ///< Offset: 0x0D - SPI Slave Select Negation Delay Register
        volatile uint32_t SPND;  ///< Offset: 0x0E - SPI Next-Access Delay Register
        volatile uint32_t SPCR2;  ///< Offset: 0x0F - SPI Control Register 2
        volatile uint32_t SPCMD0;  ///< Offset: 0x10 - SPI Command Register 0
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);

    // Bit definitions
    /// SPCR Register bits
    namespace spcr_bits {
        constexpr uint32_t SPMS = (1U << 0);  ///< SPI Mode Select
        constexpr uint32_t TXMD = (1U << 1);  ///< Communications Operating Mode Select
        constexpr uint32_t MODFEN = (1U << 2);  ///< Mode Fault Error Detection Enable
        constexpr uint32_t MSTR = (1U << 3);  ///< SPI Master/Slave Mode Select
        constexpr uint32_t SPEIE = (1U << 4);  ///< SPI Error Interrupt Enable
        constexpr uint32_t SPTIE = (1U << 5);  ///< Transmit Buffer Empty Interrupt Enable
        constexpr uint32_t SPE = (1U << 6);  ///< SPI Function Enable
        constexpr uint32_t SPRIE = (1U << 7);  ///< SPI Receive Buffer Full Interrupt Enable
    }

    /// SSLP Register bits
    namespace sslp_bits {
        constexpr uint32_t SSL0P = (1U << 0);  ///< SSLn0 Signal Polarity Setting
        constexpr uint32_t SSL1P = (1U << 1);  ///< SSLn1 Signal Polarity Setting
        constexpr uint32_t SSL2P = (1U << 2);  ///< SSLn2 Signal Polarity Setting
        constexpr uint32_t SSL3P = (1U << 3);  ///< SSLn3 Signal Polarity Setting
    }

    /// SPPCR Register bits
    namespace sppcr_bits {
        constexpr uint32_t SPLP = (1U << 0);  ///< SPI Loopback
        constexpr uint32_t SPLP2 = (1U << 1);  ///< SPI Loopback 2
        constexpr uint32_t MOIFV = (1U << 4);  ///< MOSI Idle Fixed Value
        constexpr uint32_t MOIFE = (1U << 5);  ///< MOSI Idle Value Fixing Enable
    }

    /// SPSR Register bits
    namespace spsr_bits {
        constexpr uint32_t OVRF = (1U << 0);  ///< Overrun Error Flag
        constexpr uint32_t IDLNF = (1U << 1);  ///< SPI Idle Flag
        constexpr uint32_t MODF = (1U << 2);  ///< Mode Fault Error Flag
        constexpr uint32_t PERF = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t UDRF = (1U << 4);  ///< Underrun Error Flag
        constexpr uint32_t SPTEF = (1U << 5);  ///< SPI Transmit Buffer Empty Flag
        constexpr uint32_t SPRF = (1U << 7);  ///< SPI Receive Buffer Full Flag
    }

    /// SPDCR Register bits
    namespace spdcr_bits {
        constexpr uint32_t SPRDTD = (1U << 4);  ///< SPI Receive/Transmit Data Select
        constexpr uint32_t SPLW = (1U << 5);  ///< SPI Word Access/Halfword Access Specification
        constexpr uint32_t SPBYT = (1U << 6);  ///< SPI Byte Access Specification
    }

    /// SPCKD Register bits
    namespace spckd_bits {
        constexpr uint32_t SCKDL = (3 << 0);  ///< RSPCK Delay Setting
    }

    /// SSLND Register bits
    namespace sslnd_bits {
        constexpr uint32_t SLNDL = (3 << 0);  ///< SSL Negation Delay Setting
    }

    /// SPND Register bits
    namespace spnd_bits {
        constexpr uint32_t SPNDL = (3 << 0);  ///< SPI Next-Access Delay Setting
    }

    /// SPCR2 Register bits
    namespace spcr2_bits {
        constexpr uint32_t SPPE = (1U << 0);  ///< Parity Enable
        constexpr uint32_t SPOE = (1U << 1);  ///< Parity Mode
        constexpr uint32_t SPIIE = (1U << 2);  ///< SPI Idle Interrupt Enable
        constexpr uint32_t PTE = (1U << 3);  ///< Parity Self-Testing
        constexpr uint32_t SCKASE = (1U << 4);  ///< RSPCK Auto-Stop Function Enable
    }

    /// SPCMD0 Register bits
    namespace spcmd0_bits {
        constexpr uint32_t CPHA = (1U << 0);  ///< RSPCK Phase Setting
        constexpr uint32_t CPOL = (1U << 1);  ///< RSPCK Polarity Setting
        constexpr uint32_t BRDV = (2 << 2);  ///< Bit Rate Division Setting
        constexpr uint32_t SSLA = (3 << 4);  ///< SSL Signal Assertion Setting
        constexpr uint32_t SPB = (4 << 8);  ///< SPI Data Length Setting
        constexpr uint32_t LSBF = (1U << 12);  ///< SPI LSB First
        constexpr uint32_t SPNDEN = (1U << 13);  ///< SPI Next-Access Delay Enable
        constexpr uint32_t SLNDEN = (1U << 14);  ///< SSL Negation Delay Setting Enable
        constexpr uint32_t SCKDEN = (1U << 15);  ///< RSPCK Delay Setting Enable
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40074000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRCCR0;  ///< Offset: 0x00 - CRC Control Register 0
        volatile uint32_t CRCCR1;  ///< Offset: 0x01 - CRC Control Register 1
        volatile uint32_t CRCDIR;  ///< Offset: 0x04 - CRC Data Input Register
        volatile uint32_t CRCDIR_BY;  ///< Offset: 0x04 - CRC Data Input Register
        volatile uint32_t CRCDOR;  ///< Offset: 0x08 - CRC Data Output Register
        volatile uint32_t CRCDOR_HA;  ///< Offset: 0x08 - CRC Data Output Register
        volatile uint32_t CRCDOR_BY;  ///< Offset: 0x08 - CRC Data Output Register
        volatile uint32_t CRCSAR;  ///< Offset: 0x0C - Snoop Address Register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRCCR0 Register bits
    namespace crccr0_bits {
        constexpr uint32_t GPS = (3 << 0);  ///< CRC Generating Polynomial Switching
        constexpr uint32_t LMS = (1U << 6);  ///< CRC Calculation Switching
        constexpr uint32_t DORCLR = (1U << 7);  ///< CRCDOR/CRCDOR_HA/CRCDOR_BY Register Clear
    }

    /// CRCCR1 Register bits
    namespace crccr1_bits {
        constexpr uint32_t CRCSWR = (1U << 6);  ///< Snoop-On-Write/Read Switch
        constexpr uint32_t CRCSEN = (1U << 7);  ///< Snoop Enable
    }

    /// CRCSAR Register bits
    namespace crcsar_bits {
        constexpr uint32_t CRCSA = (14 << 0);  ///< Register Snoop Address
    }

}

// ============================================================================
// GPT320 Peripheral
// ============================================================================

namespace gpt320 {
    /// Base addresses
    constexpr uint32_t GPT320_BASE = 0x40078000;

    /// GPT320 Register structure
    struct Registers {
        volatile uint32_t GTWP;  ///< Offset: 0x00 - General PWM Timer Write-Protection Register
        volatile uint32_t GTSTR;  ///< Offset: 0x04 - General PWM Timer Software Start Register
        volatile uint32_t GTSTP;  ///< Offset: 0x08 - General PWM Timer Software Stop Register
        volatile uint32_t GTCLR;  ///< Offset: 0x0C - General PWM Timer Software Clear Register
        volatile uint32_t GTSSR;  ///< Offset: 0x10 - General PWM Timer Start Source Select Register
        volatile uint32_t GTPSR;  ///< Offset: 0x14 - General PWM Timer Stop Source Select Register
        volatile uint32_t GTCSR;  ///< Offset: 0x18 - General PWM Timer Clear Source Select Register
        volatile uint32_t GTUPSR;  ///< Offset: 0x1C - General PWM Timer Up Count Source Select Register
        volatile uint32_t GTDNSR;  ///< Offset: 0x20 - General PWM Timer Down Count Source Select Register
        volatile uint32_t GTICASR;  ///< Offset: 0x24 - General PWM Timer Input Capture Source Select Register A
        volatile uint32_t GTICBSR;  ///< Offset: 0x28 - General PWM Timer Input Capture Source Select Register B
        volatile uint32_t GTCR;  ///< Offset: 0x2C - General PWM Timer Control Register
        volatile uint32_t GTUDDTYC;  ///< Offset: 0x30 - General PWM Timer Count Direction and Duty Setting Register
        volatile uint32_t GTIOR;  ///< Offset: 0x34 - General PWM Timer I/O Control Register
        volatile uint32_t GTINTAD;  ///< Offset: 0x38 - General PWM Timer Interrupt Output Setting Register
        volatile uint32_t GTST;  ///< Offset: 0x3C - General PWM Timer Status Register
        volatile uint32_t GTBER;  ///< Offset: 0x40 - General PWM Timer Buffer Enable Register
        volatile uint32_t GTCNT;  ///< Offset: 0x48 - General PWM Timer Counter
        volatile uint32_t GTCCRA;  ///< Offset: 0x4C - General PWM Timer Compare Capture Register A
        volatile uint32_t GTCCRB;  ///< Offset: 0x50 - General PWM Timer Compare Capture Register B
        volatile uint32_t GTCCRC;  ///< Offset: 0x54 - General PWM Timer Compare Capture Register C
        volatile uint32_t GTCCRE;  ///< Offset: 0x58 - General PWM Timer Compare Capture Register E
        volatile uint32_t GTCCRD;  ///< Offset: 0x5C - General PWM Timer Compare Capture Register D
        volatile uint32_t GTCCRF;  ///< Offset: 0x60 - General PWM Timer Compare Capture Register F
        volatile uint32_t GTPR;  ///< Offset: 0x64 - General PWM Timer Cycle Setting Register
        volatile uint32_t GTPBR;  ///< Offset: 0x68 - General PWM Timer Cycle Setting Buffer Register
        volatile uint32_t GTDTCR;  ///< Offset: 0x88 - General PWM Timer Dead Time Control Register
        volatile uint32_t GTDVU;  ///< Offset: 0x8C - General PWM Timer Dead Time Value Register U
    };

    /// Peripheral instances
    inline Registers* GPT320 = reinterpret_cast<Registers*>(GPT320_BASE);

    // Bit definitions
    /// GTWP Register bits
    namespace gtwp_bits {
        constexpr uint32_t WP = (1U << 0);  ///< Register Write Disable
        constexpr uint32_t PRKEY = (8 << 8);  ///< GTWP Key Code
    }

    /// GTSTR Register bits
    namespace gtstr_bits {
        constexpr uint32_t CSTRT0 = (1U << 0);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT1 = (1U << 1);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT2 = (1U << 2);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT3 = (1U << 3);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT4 = (1U << 4);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT5 = (1U << 5);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT6 = (1U << 6);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT7 = (1U << 7);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT8 = (1U << 8);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT9 = (1U << 9);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
    }

    /// GTSTP Register bits
    namespace gtstp_bits {
        constexpr uint32_t CSTOP0 = (1U << 0);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP1 = (1U << 1);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP2 = (1U << 2);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP3 = (1U << 3);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP4 = (1U << 4);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP5 = (1U << 5);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP6 = (1U << 6);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP7 = (1U << 7);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP8 = (1U << 8);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP9 = (1U << 9);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
    }

    /// GTCLR Register bits
    namespace gtclr_bits {
        constexpr uint32_t CCLR0 = (1U << 0);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR1 = (1U << 1);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR2 = (1U << 2);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR3 = (1U << 3);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR4 = (1U << 4);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR5 = (1U << 5);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR6 = (1U << 6);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR7 = (1U << 7);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR8 = (1U << 8);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR9 = (1U << 9);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
    }

    /// GTSSR Register bits
    namespace gtssr_bits {
        constexpr uint32_t SSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Start Enable
        constexpr uint32_t SSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Start Enable
        constexpr uint32_t SSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Start Enable
        constexpr uint32_t SSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Start Enable
        constexpr uint32_t SSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Start Enable
        constexpr uint32_t SSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Start Enable
        constexpr uint32_t SSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Start Enable
        constexpr uint32_t SSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Start Enable
        constexpr uint32_t SSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Start Enable
        constexpr uint32_t SSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Start Enable
        constexpr uint32_t CSTRT = (1U << 31);  ///< Software Source Counter Start Enable
    }

    /// GTPSR Register bits
    namespace gtpsr_bits {
        constexpr uint32_t PSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Stop Enable
        constexpr uint32_t PSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Stop Enable
        constexpr uint32_t PSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Stop Enable
        constexpr uint32_t PSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Stop Enable
        constexpr uint32_t PSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Stop Enable
        constexpr uint32_t PSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Stop Enable
        constexpr uint32_t PSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Stop Enable
        constexpr uint32_t CSTOP = (1U << 31);  ///< Software Source Counter Stop Enable
    }

    /// GTCSR Register bits
    namespace gtcsr_bits {
        constexpr uint32_t CSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Clear Enable
        constexpr uint32_t CSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Clear Enable
        constexpr uint32_t CSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Clear Enable
        constexpr uint32_t CSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Clear Enable
        constexpr uint32_t CSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Clear Enable
        constexpr uint32_t CSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Clear Enable
        constexpr uint32_t CSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Clear Enable
        constexpr uint32_t CCLR = (1U << 31);  ///< Software Source Counter Clear Enable
    }

    /// GTUPSR Register bits
    namespace gtupsr_bits {
        constexpr uint32_t USGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Up Enable
        constexpr uint32_t USCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Up Enable
        constexpr uint32_t USCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Up Enable
        constexpr uint32_t USELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Up Enable
        constexpr uint32_t USELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Up Enable
        constexpr uint32_t USELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Up Enable
        constexpr uint32_t USELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Up Enable
    }

    /// GTDNSR Register bits
    namespace gtdnsr_bits {
        constexpr uint32_t DSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Down Enable
        constexpr uint32_t DSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Down Enable
        constexpr uint32_t DSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Down Enable
        constexpr uint32_t DSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Down Enable
        constexpr uint32_t DSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Down Enable
    }

    /// GTICASR Register bits
    namespace gticasr_bits {
        constexpr uint32_t ASGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRA Input Capture Enable
    }

    /// GTICBSR Register bits
    namespace gticbsr_bits {
        constexpr uint32_t BSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRB Input Capture Enable
    }

    /// GTCR Register bits
    namespace gtcr_bits {
        constexpr uint32_t CST = (1U << 0);  ///< Count Start
        constexpr uint32_t MD = (3 << 16);  ///< Mode Select
        constexpr uint32_t TPCS = (3 << 24);  ///< Timer Prescaler Select
    }

    /// GTUDDTYC Register bits
    namespace gtuddtyc_bits {
        constexpr uint32_t UD = (1U << 0);  ///< Count Direction Setting
        constexpr uint32_t UDF = (1U << 1);  ///< Forcible Count Direction Setting
        constexpr uint32_t OADTY = (2 << 16);  ///< GTIOCnA Output Duty Setting
        constexpr uint32_t OADTYF = (1U << 18);  ///< Forcible GTIOCnA Output Duty Setting
        constexpr uint32_t OADTYR = (1U << 19);  ///< GTIOCnA Output Value Selecting after Releasing 0%/100% Duty Setting
        constexpr uint32_t OBDTY = (2 << 24);  ///< GTIOCnB Output Duty Setting
        constexpr uint32_t OBDTYF = (1U << 26);  ///< Forcible GTIOCnB Output Duty Setting
        constexpr uint32_t OBDTYR = (1U << 27);  ///< GTIOCnB Output Value Selecting after Releasing 0%/100% Duty Setting
    }

    /// GTIOR Register bits
    namespace gtior_bits {
        constexpr uint32_t GTIOA = (5 << 0);  ///< GTIOCnA Pin Function Select
        constexpr uint32_t OADFLT = (1U << 6);  ///< GTIOCnA Pin Output Value Setting at the Count Stop
        constexpr uint32_t OAHLD = (1U << 7);  ///< GTIOCnA Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OAE = (1U << 8);  ///< GTIOCnA Pin Output Enable
        constexpr uint32_t OADF = (2 << 9);  ///< GTIOCnA Pin Disable Value Setting
        constexpr uint32_t NFAEN = (1U << 13);  ///< Noise Filter A Enable
        constexpr uint32_t NFCSA = (2 << 14);  ///< Noise Filter A Sampling Clock Select
        constexpr uint32_t GTIOB = (5 << 16);  ///< GTIOCnB Pin Function Select
        constexpr uint32_t OBDFLT = (1U << 22);  ///< GTIOCnB Pin Output Value Setting at the Count Stop
        constexpr uint32_t OBHLD = (1U << 23);  ///< GTIOCnB Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OBE = (1U << 24);  ///< GTIOCnB Pin Output Enable
        constexpr uint32_t OBDF = (2 << 25);  ///< GTIOCnB Pin Disable Value Setting
        constexpr uint32_t NFBEN = (1U << 29);  ///< Noise Filter B Enable
        constexpr uint32_t NFCSB = (2 << 30);  ///< Noise Filter B Sampling Clock Select
    }

    /// GTINTAD Register bits
    namespace gtintad_bits {
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disable Source Select
        constexpr uint32_t GRPABH = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t GRPABL = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
    }

    /// GTST Register bits
    namespace gtst_bits {
        constexpr uint32_t TCFA = (1U << 0);  ///< Input Capture/Compare Match Flag A
        constexpr uint32_t TCFB = (1U << 1);  ///< Input Capture/Compare Match Flag B
        constexpr uint32_t TCFC = (1U << 2);  ///< Input Compare Match Flag C
        constexpr uint32_t TCFD = (1U << 3);  ///< Input Compare Match Flag D
        constexpr uint32_t TCFE = (1U << 4);  ///< Input Compare Match Flag E
        constexpr uint32_t TCFF = (1U << 5);  ///< Input Compare Match Flag F
        constexpr uint32_t TCFPO = (1U << 6);  ///< Overflow Flag
        constexpr uint32_t TCFPU = (1U << 7);  ///< Underflow Flag
        constexpr uint32_t TUCF = (1U << 15);  ///< Count Direction Flag
        constexpr uint32_t ODF = (1U << 24);  ///< Output Disable Flag
        constexpr uint32_t OABHF = (1U << 29);  ///< Same Time Output Level High Flag
        constexpr uint32_t OABLF = (1U << 30);  ///< Same Time Output Level Low Flag
    }

    /// GTBER Register bits
    namespace gtber_bits {
        constexpr uint32_t BD0 = (1U << 0);  ///< GTCCR Buffer Operation Disable
        constexpr uint32_t BD1 = (1U << 1);  ///< GTPR Buffer Operation Disable
        constexpr uint32_t CCRA = (2 << 16);  ///< GTCCRA Buffer Operation
        constexpr uint32_t CCRB = (2 << 18);  ///< GTCCRB Buffer Operation
        constexpr uint32_t PR = (2 << 20);  ///< GTPR Buffer Operation
        constexpr uint32_t CCRSWT = (1U << 22);  ///< GTCCRA and GTCCRB Forcible Buffer Operation
    }

    /// GTDTCR Register bits
    namespace gtdtcr_bits {
        constexpr uint32_t TDE = (1U << 0);  ///< Negative-Phase Waveform Setting
    }

}

// ============================================================================
// GPT164 Peripheral
// ============================================================================

namespace gpt164 {
    /// Base addresses
    constexpr uint32_t GPT164_BASE = 0x40078400;

    /// GPT164 Register structure
    struct Registers {
        volatile uint32_t GTWP;  ///< Offset: 0x00 - General PWM Timer Write-Protection Register
        volatile uint32_t GTSTR;  ///< Offset: 0x04 - General PWM Timer Software Start Register
        volatile uint32_t GTSTP;  ///< Offset: 0x08 - General PWM Timer Software Stop Register
        volatile uint32_t GTCLR;  ///< Offset: 0x0C - General PWM Timer Software Clear Register
        volatile uint32_t GTSSR;  ///< Offset: 0x10 - General PWM Timer Start Source Select Register
        volatile uint32_t GTPSR;  ///< Offset: 0x14 - General PWM Timer Stop Source Select Register
        volatile uint32_t GTCSR;  ///< Offset: 0x18 - General PWM Timer Clear Source Select Register
        volatile uint32_t GTUPSR;  ///< Offset: 0x1C - General PWM Timer Up Count Source Select Register
        volatile uint32_t GTDNSR;  ///< Offset: 0x20 - General PWM Timer Down Count Source Select Register
        volatile uint32_t GTICASR;  ///< Offset: 0x24 - General PWM Timer Input Capture Source Select Register A
        volatile uint32_t GTICBSR;  ///< Offset: 0x28 - General PWM Timer Input Capture Source Select Register B
        volatile uint32_t GTCR;  ///< Offset: 0x2C - General PWM Timer Control Register
        volatile uint32_t GTUDDTYC;  ///< Offset: 0x30 - General PWM Timer Count Direction and Duty Setting Register
        volatile uint32_t GTIOR;  ///< Offset: 0x34 - General PWM Timer I/O Control Register
        volatile uint32_t GTINTAD;  ///< Offset: 0x38 - General PWM Timer Interrupt Output Setting Register
        volatile uint32_t GTST;  ///< Offset: 0x3C - General PWM Timer Status Register
        volatile uint32_t GTBER;  ///< Offset: 0x40 - General PWM Timer Buffer Enable Register
        volatile uint32_t GTCNT;  ///< Offset: 0x48 - General PWM Timer Counter
        volatile uint32_t GTCCRA;  ///< Offset: 0x4C - General PWM Timer Compare Capture Register A
        volatile uint32_t GTCCRB;  ///< Offset: 0x50 - General PWM Timer Compare Capture Register B
        volatile uint32_t GTCCRC;  ///< Offset: 0x54 - General PWM Timer Compare Capture Register C
        volatile uint32_t GTCCRE;  ///< Offset: 0x58 - General PWM Timer Compare Capture Register E
        volatile uint32_t GTCCRD;  ///< Offset: 0x5C - General PWM Timer Compare Capture Register D
        volatile uint32_t GTCCRF;  ///< Offset: 0x60 - General PWM Timer Compare Capture Register F
        volatile uint32_t GTPR;  ///< Offset: 0x64 - General PWM Timer Cycle Setting Register
        volatile uint32_t GTPBR;  ///< Offset: 0x68 - General PWM Timer Cycle Setting Buffer Register
        volatile uint32_t GTDTCR;  ///< Offset: 0x88 - General PWM Timer Dead Time Control Register
        volatile uint32_t GTDVU;  ///< Offset: 0x8C - General PWM Timer Dead Time Value Register U
    };

    /// Peripheral instances
    inline Registers* GPT164 = reinterpret_cast<Registers*>(GPT164_BASE);

    // Bit definitions
    /// GTWP Register bits
    namespace gtwp_bits {
        constexpr uint32_t WP = (1U << 0);  ///< Register Write Disable
        constexpr uint32_t PRKEY = (8 << 8);  ///< GTWP Key Code
    }

    /// GTSTR Register bits
    namespace gtstr_bits {
        constexpr uint32_t CSTRT0 = (1U << 0);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT1 = (1U << 1);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT2 = (1U << 2);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT3 = (1U << 3);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT4 = (1U << 4);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT5 = (1U << 5);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT6 = (1U << 6);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT7 = (1U << 7);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT8 = (1U << 8);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT9 = (1U << 9);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
    }

    /// GTSTP Register bits
    namespace gtstp_bits {
        constexpr uint32_t CSTOP0 = (1U << 0);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP1 = (1U << 1);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP2 = (1U << 2);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP3 = (1U << 3);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP4 = (1U << 4);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP5 = (1U << 5);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP6 = (1U << 6);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP7 = (1U << 7);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP8 = (1U << 8);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP9 = (1U << 9);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
    }

    /// GTCLR Register bits
    namespace gtclr_bits {
        constexpr uint32_t CCLR0 = (1U << 0);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR1 = (1U << 1);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR2 = (1U << 2);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR3 = (1U << 3);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR4 = (1U << 4);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR5 = (1U << 5);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR6 = (1U << 6);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR7 = (1U << 7);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR8 = (1U << 8);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR9 = (1U << 9);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
    }

    /// GTSSR Register bits
    namespace gtssr_bits {
        constexpr uint32_t SSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Start Enable
        constexpr uint32_t SSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Start Enable
        constexpr uint32_t SSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Start Enable
        constexpr uint32_t SSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Start Enable
        constexpr uint32_t SSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Start Enable
        constexpr uint32_t SSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Start Enable
        constexpr uint32_t SSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Start Enable
        constexpr uint32_t SSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Start Enable
        constexpr uint32_t SSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Start Enable
        constexpr uint32_t SSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Start Enable
        constexpr uint32_t CSTRT = (1U << 31);  ///< Software Source Counter Start Enable
    }

    /// GTPSR Register bits
    namespace gtpsr_bits {
        constexpr uint32_t PSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Stop Enable
        constexpr uint32_t PSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Stop Enable
        constexpr uint32_t PSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Stop Enable
        constexpr uint32_t PSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Stop Enable
        constexpr uint32_t PSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Stop Enable
        constexpr uint32_t PSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Stop Enable
        constexpr uint32_t PSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Stop Enable
        constexpr uint32_t CSTOP = (1U << 31);  ///< Software Source Counter Stop Enable
    }

    /// GTCSR Register bits
    namespace gtcsr_bits {
        constexpr uint32_t CSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Clear Enable
        constexpr uint32_t CSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Clear Enable
        constexpr uint32_t CSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Clear Enable
        constexpr uint32_t CSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Clear Enable
        constexpr uint32_t CSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Clear Enable
        constexpr uint32_t CSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Clear Enable
        constexpr uint32_t CSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Clear Enable
        constexpr uint32_t CCLR = (1U << 31);  ///< Software Source Counter Clear Enable
    }

    /// GTUPSR Register bits
    namespace gtupsr_bits {
        constexpr uint32_t USGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Up Enable
        constexpr uint32_t USCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Up Enable
        constexpr uint32_t USCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Up Enable
        constexpr uint32_t USELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Up Enable
        constexpr uint32_t USELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Up Enable
        constexpr uint32_t USELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Up Enable
        constexpr uint32_t USELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Up Enable
    }

    /// GTDNSR Register bits
    namespace gtdnsr_bits {
        constexpr uint32_t DSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Down Enable
        constexpr uint32_t DSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Down Enable
        constexpr uint32_t DSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Down Enable
        constexpr uint32_t DSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Down Enable
        constexpr uint32_t DSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Down Enable
    }

    /// GTICASR Register bits
    namespace gticasr_bits {
        constexpr uint32_t ASGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRA Input Capture Enable
    }

    /// GTICBSR Register bits
    namespace gticbsr_bits {
        constexpr uint32_t BSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRB Input Capture Enable
    }

    /// GTCR Register bits
    namespace gtcr_bits {
        constexpr uint32_t CST = (1U << 0);  ///< Count Start
        constexpr uint32_t MD = (3 << 16);  ///< Mode Select
        constexpr uint32_t TPCS = (3 << 24);  ///< Timer Prescaler Select
    }

    /// GTUDDTYC Register bits
    namespace gtuddtyc_bits {
        constexpr uint32_t UD = (1U << 0);  ///< Count Direction Setting
        constexpr uint32_t UDF = (1U << 1);  ///< Forcible Count Direction Setting
        constexpr uint32_t OADTY = (2 << 16);  ///< GTIOCnA Output Duty Setting
        constexpr uint32_t OADTYF = (1U << 18);  ///< Forcible GTIOCnA Output Duty Setting
        constexpr uint32_t OADTYR = (1U << 19);  ///< GTIOCnA Output Value Selecting after Releasing 0%/100% Duty Setting
        constexpr uint32_t OBDTY = (2 << 24);  ///< GTIOCnB Output Duty Setting
        constexpr uint32_t OBDTYF = (1U << 26);  ///< Forcible GTIOCnB Output Duty Setting
        constexpr uint32_t OBDTYR = (1U << 27);  ///< GTIOCnB Output Value Selecting after Releasing 0%/100% Duty Setting
    }

    /// GTIOR Register bits
    namespace gtior_bits {
        constexpr uint32_t GTIOA = (5 << 0);  ///< GTIOCnA Pin Function Select
        constexpr uint32_t OADFLT = (1U << 6);  ///< GTIOCnA Pin Output Value Setting at the Count Stop
        constexpr uint32_t OAHLD = (1U << 7);  ///< GTIOCnA Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OAE = (1U << 8);  ///< GTIOCnA Pin Output Enable
        constexpr uint32_t OADF = (2 << 9);  ///< GTIOCnA Pin Disable Value Setting
        constexpr uint32_t NFAEN = (1U << 13);  ///< Noise Filter A Enable
        constexpr uint32_t NFCSA = (2 << 14);  ///< Noise Filter A Sampling Clock Select
        constexpr uint32_t GTIOB = (5 << 16);  ///< GTIOCnB Pin Function Select
        constexpr uint32_t OBDFLT = (1U << 22);  ///< GTIOCnB Pin Output Value Setting at the Count Stop
        constexpr uint32_t OBHLD = (1U << 23);  ///< GTIOCnB Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OBE = (1U << 24);  ///< GTIOCnB Pin Output Enable
        constexpr uint32_t OBDF = (2 << 25);  ///< GTIOCnB Pin Disable Value Setting
        constexpr uint32_t NFBEN = (1U << 29);  ///< Noise Filter B Enable
        constexpr uint32_t NFCSB = (2 << 30);  ///< Noise Filter B Sampling Clock Select
    }

    /// GTINTAD Register bits
    namespace gtintad_bits {
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disable Source Select
        constexpr uint32_t GRPABH = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t GRPABL = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
    }

    /// GTST Register bits
    namespace gtst_bits {
        constexpr uint32_t TCFA = (1U << 0);  ///< Input Capture/Compare Match Flag A
        constexpr uint32_t TCFB = (1U << 1);  ///< Input Capture/Compare Match Flag B
        constexpr uint32_t TCFC = (1U << 2);  ///< Input Compare Match Flag C
        constexpr uint32_t TCFD = (1U << 3);  ///< Input Compare Match Flag D
        constexpr uint32_t TCFE = (1U << 4);  ///< Input Compare Match Flag E
        constexpr uint32_t TCFF = (1U << 5);  ///< Input Compare Match Flag F
        constexpr uint32_t TCFPO = (1U << 6);  ///< Overflow Flag
        constexpr uint32_t TCFPU = (1U << 7);  ///< Underflow Flag
        constexpr uint32_t TUCF = (1U << 15);  ///< Count Direction Flag
        constexpr uint32_t ODF = (1U << 24);  ///< Output Disable Flag
        constexpr uint32_t OABHF = (1U << 29);  ///< Same Time Output Level High Flag
        constexpr uint32_t OABLF = (1U << 30);  ///< Same Time Output Level Low Flag
    }

    /// GTBER Register bits
    namespace gtber_bits {
        constexpr uint32_t BD0 = (1U << 0);  ///< GTCCR Buffer Operation Disable
        constexpr uint32_t BD1 = (1U << 1);  ///< GTPR Buffer Operation Disable
        constexpr uint32_t CCRA = (2 << 16);  ///< GTCCRA Buffer Operation
        constexpr uint32_t CCRB = (2 << 18);  ///< GTCCRB Buffer Operation
        constexpr uint32_t PR = (2 << 20);  ///< GTPR Buffer Operation
        constexpr uint32_t CCRSWT = (1U << 22);  ///< GTCCRA and GTCCRB Forcible Buffer Operation
    }

    /// GTDTCR Register bits
    namespace gtdtcr_bits {
        constexpr uint32_t TDE = (1U << 0);  ///< Negative-Phase Waveform Setting
    }

}

// ============================================================================
// GPT165 Peripheral
// ============================================================================

namespace gpt165 {
    /// Base addresses
    constexpr uint32_t GPT165_BASE = 0x40078500;

    /// GPT165 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT165 = reinterpret_cast<Registers*>(GPT165_BASE);

}

// ============================================================================
// GPT166 Peripheral
// ============================================================================

namespace gpt166 {
    /// Base addresses
    constexpr uint32_t GPT166_BASE = 0x40078600;

    /// GPT166 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT166 = reinterpret_cast<Registers*>(GPT166_BASE);

}

// ============================================================================
// GPT167 Peripheral
// ============================================================================

namespace gpt167 {
    /// Base addresses
    constexpr uint32_t GPT167_BASE = 0x40078700;

    /// GPT167 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT167 = reinterpret_cast<Registers*>(GPT167_BASE);

}

// ============================================================================
// GPT168 Peripheral
// ============================================================================

namespace gpt168 {
    /// Base addresses
    constexpr uint32_t GPT168_BASE = 0x40078800;

    /// GPT168 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT168 = reinterpret_cast<Registers*>(GPT168_BASE);

}

// ============================================================================
// GPT169 Peripheral
// ============================================================================

namespace gpt169 {
    /// Base addresses
    constexpr uint32_t GPT169_BASE = 0x40078900;

    /// GPT169 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT169 = reinterpret_cast<Registers*>(GPT169_BASE);

}

// ============================================================================
// GPT Peripheral
// ============================================================================

namespace gpt {
    /// Base addresses
    constexpr uint32_t GPT_OPS_BASE = 0x40078FF0;

    /// GPT Register structure
    struct Registers {
        volatile uint32_t OPSCR;  ///< Offset: 0x00 - Output Phase Switching Control Register
    };

    /// Peripheral instances
    inline Registers* GPT_OPS = reinterpret_cast<Registers*>(GPT_OPS_BASE);

    // Bit definitions
    /// OPSCR Register bits
    namespace opscr_bits {
        constexpr uint32_t UF = (1U << 0);  ///< UF
        constexpr uint32_t VF = (1U << 1);  ///< VF
        constexpr uint32_t WF = (1U << 2);  ///< WF
        constexpr uint32_t U = (1U << 4);  ///< Input U-Phase Monitor
        constexpr uint32_t V = (1U << 5);  ///< Input V-Phase Monitor
        constexpr uint32_t W = (1U << 6);  ///< Input W-Phase Monitor
        constexpr uint32_t EN = (1U << 8);  ///< Output Phase Enable
        constexpr uint32_t FB = (1U << 16);  ///< External Feedback Signal Enable
        constexpr uint32_t P = (1U << 17);  ///< Positive-Phase Output (P) Control
        constexpr uint32_t N = (1U << 18);  ///< Negative-Phase Output (N) Control
        constexpr uint32_t INV = (1U << 19);  ///< Output Phase Invert Control
        constexpr uint32_t RV = (1U << 20);  ///< Output Phase Rotation Direction Reversal Control
        constexpr uint32_t ALIGN = (1U << 21);  ///< Input Phase Alignment
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disabled Source Selection
        constexpr uint32_t GODF = (1U << 26);  ///< Group Output Disable Function
        constexpr uint32_t NFEN = (1U << 29);  ///< External Input Noise Filter Enable
        constexpr uint32_t NFCS = (2 << 30);  ///< External Input Noise Filter Clock Selection
    }

}

// ============================================================================
// KINT Peripheral
// ============================================================================

namespace kint {
    /// Base addresses
    constexpr uint32_t KINT_BASE = 0x40080000;

    /// KINT Register structure
    struct Registers {
        volatile uint32_t KRCTL;  ///< Offset: 0x00 - Key Return Control Register
        volatile uint32_t KRF;  ///< Offset: 0x04 - Key Return Flag Register
        volatile uint32_t KRM;  ///< Offset: 0x08 - Key Return Mode Register
    };

    /// Peripheral instances
    inline Registers* KINT = reinterpret_cast<Registers*>(KINT_BASE);

    // Bit definitions
    /// KRCTL Register bits
    namespace krctl_bits {
        constexpr uint32_t KREG = (1U << 0);  ///< Detection Edge Selection (KR00 to KR07 pins)
        constexpr uint32_t KRMD = (1U << 7);  ///< Usage of Key Interrupt Flags (KRF.KIF0 to KRF.KIF7)
    }

    /// KRF Register bits
    namespace krf_bits {
        constexpr uint32_t KIF0 = (1U << 0);  ///< Key Interrupt Flag n
        constexpr uint32_t KIF1 = (1U << 1);  ///< Key Interrupt Flag n
        constexpr uint32_t KIF2 = (1U << 2);  ///< Key Interrupt Flag n
        constexpr uint32_t KIF3 = (1U << 3);  ///< Key Interrupt Flag n
        constexpr uint32_t KIF4 = (1U << 4);  ///< Key Interrupt Flag n
        constexpr uint32_t KIF5 = (1U << 5);  ///< Key Interrupt Flag n
        constexpr uint32_t KIF6 = (1U << 6);  ///< Key Interrupt Flag n
        constexpr uint32_t KIF7 = (1U << 7);  ///< Key Interrupt Flag n
    }

    /// KRM Register bits
    namespace krm_bits {
        constexpr uint32_t KIMC0 = (1U << 0);  ///< Key Interrupt Mode Control n
        constexpr uint32_t KIMC1 = (1U << 1);  ///< Key Interrupt Mode Control n
        constexpr uint32_t KIMC2 = (1U << 2);  ///< Key Interrupt Mode Control n
        constexpr uint32_t KIMC3 = (1U << 3);  ///< Key Interrupt Mode Control n
        constexpr uint32_t KIMC4 = (1U << 4);  ///< Key Interrupt Mode Control n
        constexpr uint32_t KIMC5 = (1U << 5);  ///< Key Interrupt Mode Control n
        constexpr uint32_t KIMC6 = (1U << 6);  ///< Key Interrupt Mode Control n
        constexpr uint32_t KIMC7 = (1U << 7);  ///< Key Interrupt Mode Control n
    }

}

// ============================================================================
// CTSU Peripheral
// ============================================================================

namespace ctsu {
    /// Base addresses
    constexpr uint32_t CTSU_BASE = 0x40082000;

    /// CTSU Register structure
    struct Registers {
        volatile uint32_t CTSUCRA;  ///< Offset: 0x00 - CTSU Control Register A
        volatile uint32_t CTSUCRAL;  ///< Offset: 0x00 - CTSU Control Register A
        volatile uint32_t CTSUCR0;  ///< Offset: 0x00 - CTSU Control Register A
        volatile uint32_t CTSUCR1;  ///< Offset: 0x01 - CTSU Control Register A
        volatile uint32_t CTSUCR2;  ///< Offset: 0x02 - CTSU Control Register A
        volatile uint32_t CTSUCR3;  ///< Offset: 0x03 - CTSU Control Register A
        volatile uint32_t CTSUCRB;  ///< Offset: 0x04 - CTSU Control Register B
        volatile uint32_t CTSUCRBL;  ///< Offset: 0x04 - CTSU Control Register B
        volatile uint32_t CTSUSDPRS;  ///< Offset: 0x04 - CTSU Control Register B
        volatile uint32_t CTSUSST;  ///< Offset: 0x05 - CTSU Control Register B
        volatile uint32_t CTSUCRBH;  ///< Offset: 0x06 - CTSU Control Register B
        volatile uint32_t CTSUDCLKC;  ///< Offset: 0x07 - CTSU Control Register B
        volatile uint32_t CTSUMCH;  ///< Offset: 0x08 - CTSU Measurement Channel Register
        volatile uint32_t CTSUMCHL;  ///< Offset: 0x08 - CTSU Measurement Channel Register
        volatile uint32_t CTSUMCH0;  ///< Offset: 0x08 - CTSU Measurement Channel Register
        volatile uint32_t CTSUMCH1;  ///< Offset: 0x09 - CTSU Measurement Channel Register
        volatile uint32_t CTSUMCHH;  ///< Offset: 0x0A - CTSU Measurement Channel Register
        volatile uint32_t CTSUMFAF;  ///< Offset: 0x0A - CTSU Measurement Channel Register
        volatile uint32_t CTSUCHACA;  ///< Offset: 0x0C - CTSU Channel Enable Control Register A
        volatile uint32_t CTSUCHACAL;  ///< Offset: 0x0C - CTSU Channel Enable Control Register A
        volatile uint32_t CTSUCHAC0;  ///< Offset: 0x0C - CTSU Channel Enable Control Register A
        volatile uint32_t CTSUCHAC1;  ///< Offset: 0x0D - CTSU Channel Enable Control Register A
        volatile uint32_t CTSUCHACAH;  ///< Offset: 0x0E - CTSU Channel Enable Control Register A
        volatile uint32_t CTSUCHAC2;  ///< Offset: 0x0E - CTSU Channel Enable Control Register A
        volatile uint32_t CTSUCHAC3;  ///< Offset: 0x0F - CTSU Channel Enable Control Register A
        volatile uint32_t CTSUCHACB;  ///< Offset: 0x10 - CTSU Channel Enable Control Register B
        volatile uint32_t CTSUCHACBL;  ///< Offset: 0x10 - CTSU Channel Enable Control Register B
        volatile uint32_t CTSUCHAC4;  ///< Offset: 0x10 - CTSU Channel Enable Control Register B
        volatile uint32_t CTSUCHTRCA;  ///< Offset: 0x14 - CTSU Channel Transmit/Receive Control Register A
        volatile uint32_t CTSUCHTRCAL;  ///< Offset: 0x14 - CTSU Channel Transmit/Receive Control Register A
        volatile uint32_t CTSUCHTRC0;  ///< Offset: 0x14 - CTSU Channel Transmit/Receive Control Register A
        volatile uint32_t CTSUCHTRC1;  ///< Offset: 0x15 - CTSU Channel Transmit/Receive Control Register A
        volatile uint32_t CTSUCHTRCAH;  ///< Offset: 0x16 - CTSU Channel Transmit/Receive Control Register A
        volatile uint32_t CTSUCHTRC2;  ///< Offset: 0x16 - CTSU Channel Transmit/Receive Control Register A
        volatile uint32_t CTSUCHTRC3;  ///< Offset: 0x17 - CTSU Channel Transmit/Receive Control Register A
        volatile uint32_t CTSUCHTRCB;  ///< Offset: 0x18 - CTSU Channel Transmit/Receive Control Register B
        volatile uint32_t CTSUCHTRCBL;  ///< Offset: 0x18 - CTSU Channel Transmit/Receive Control Register B
        volatile uint32_t CTSUCHTRC4;  ///< Offset: 0x18 - CTSU Channel Transmit/Receive Control Register B
        volatile uint32_t CTSUSR;  ///< Offset: 0x1C - CTSU Status Register
        volatile uint32_t CTSUSRL;  ///< Offset: 0x1C - CTSU Status Register
        volatile uint32_t CTSUSR0;  ///< Offset: 0x1C - CTSU Status Register
        volatile uint32_t CTSUST;  ///< Offset: 0x1D - CTSU Status Register
        volatile uint32_t CTSUSRH;  ///< Offset: 0x1E - CTSU Status Register
        volatile uint32_t CTSUSR2;  ///< Offset: 0x1E - CTSU Status Register
        volatile uint32_t CTSUSO;  ///< Offset: 0x20 - CTSU Sensor Offset Register
        volatile uint32_t CTSUSO0;  ///< Offset: 0x20 - CTSU Sensor Offset Register
        volatile uint32_t CTSUSO1;  ///< Offset: 0x22 - CTSU Sensor Offset Register
        volatile uint32_t CTSUSCNT;  ///< Offset: 0x24 - CTSU Sensor Counter Register
        volatile uint32_t CTSUSC;  ///< Offset: 0x24 - CTSU Sensor Counter Register
        volatile uint32_t CTSUCALIB;  ///< Offset: 0x28 - CTSU Calibration Register
        volatile uint32_t CTSUDBGR0;  ///< Offset: 0x28 - CTSU Calibration Register
        volatile uint32_t CTSUDBGR1;  ///< Offset: 0x2A - CTSU Calibration Register
        volatile uint32_t CTSUSUCLKA;  ///< Offset: 0x2C - CTSU Sensor Unit Clock Control Register A
        volatile uint32_t CTSUSUCLK0;  ///< Offset: 0x2C - CTSU Sensor Unit Clock Control Register A
        volatile uint32_t CTSUSUCLK1;  ///< Offset: 0x2E - CTSU Sensor Unit Clock Control Register A
        volatile uint32_t CTSUSUCLKB;  ///< Offset: 0x30 - CTSU Sensor Unit Clock Control Register B
        volatile uint32_t CTSUSUCLK2;  ///< Offset: 0x30 - CTSU Sensor Unit Clock Control Register B
        volatile uint32_t CTSUSUCLK3;  ///< Offset: 0x32 - CTSU Sensor Unit Clock Control Register B
        volatile uint32_t CTSUCFCCNT;  ///< Offset: 0x34 - CTSU CFC Counter Register
        volatile uint32_t CTSUCFCCNTL;  ///< Offset: 0x34 - CTSU CFC Counter Register
    };

    /// Peripheral instances
    inline Registers* CTSU = reinterpret_cast<Registers*>(CTSU_BASE);

    // Bit definitions
    /// CTSUCRA Register bits
    namespace ctsucra_bits {
        constexpr uint32_t STRT = (1U << 0);  ///< CTSU Measurement Operation Start
        constexpr uint32_t CAP = (1U << 1);  ///< CTSU Measurement Operation Start Trigger Select
        constexpr uint32_t SNZ = (1U << 2);  ///< CTSU Wait State Power-Saving Enable
        constexpr uint32_t CFCON = (1U << 3);  ///< CTSU CFC Power On Control
        constexpr uint32_t INIT = (1U << 4);  ///< CTSU Control Block Initialization
        constexpr uint32_t PUMPON = (1U << 5);  ///< CTSU Boost Circuit Control
        constexpr uint32_t TXVSEL = (2 << 6);  ///< CTSU Transmission Power Supply Selection
        constexpr uint32_t PON = (1U << 8);  ///< CTSU Power On Control
        constexpr uint32_t CSW = (1U << 9);  ///< TSCAP Pin Enable
        constexpr uint32_t ATUNE0 = (1U << 10);  ///< CTSU Power Supply Operating Mode Setting
        constexpr uint32_t ATUNE1 = (1U << 11);  ///< CTSU Current Range Adjustment
        constexpr uint32_t CLK = (2 << 12);  ///< CTSU Operating Clock Select
        constexpr uint32_t MD0 = (1U << 14);  ///< CTSU Measurement Mode Select 0
        constexpr uint32_t MD1 = (1U << 15);  ///< CTSU Measurement Mode Select 1
        constexpr uint32_t MD2 = (1U << 16);  ///< CTSU Measurement Mode Select 2
        constexpr uint32_t ATUNE2 = (1U << 17);  ///< CTSU Current Range Adjustment
        constexpr uint32_t LOAD = (2 << 18);  ///< CTSU Load Control During Measurement
        constexpr uint32_t POSEL = (2 << 20);  ///< CTSU Non-Measured Channel Output Select
        constexpr uint32_t SDPSEL = (1U << 22);  ///< CTSU Sensor Drive Pulse Select
        constexpr uint32_t PCSEL = (1U << 23);  ///< CTSU Boost Circuit Clock Select
        constexpr uint32_t STCLK = (6 << 24);  ///< CTSU STCLK Select
        constexpr uint32_t DCMODE = (1U << 30);  ///< CTSU Current Measurement Mode Select
        constexpr uint32_t DCBACK = (1U << 31);  ///< CTSU Current Measurement Feedback Select
    }

    /// CTSUCRB Register bits
    namespace ctsucrb_bits {
        constexpr uint32_t PRRATIO = (4 << 0);  ///< Frequency of Drive Pulse Phase Control
        constexpr uint32_t PRMODE = (2 << 4);  ///< Phase Control Period
        constexpr uint32_t SOFF = (1U << 6);  ///< High-Pass Noise Reduction Function Disable
        constexpr uint32_t PROFF = (1U << 7);  ///< Drive Pulse Phase Control
        constexpr uint32_t SST = (8 << 8);  ///< Wait Time Sensor Stabilization
        constexpr uint32_t SSMOD = (3 << 24);  ///< Spread Spectrum Modulation Frequency
        constexpr uint32_t SSCNT = (2 << 28);  ///< Adjusting the SUCLK frequency
    }

    /// CTSUMCH Register bits
    namespace ctsumch_bits {
        constexpr uint32_t MCH0 = (6 << 0);  ///< CTSU Measurement Channel 0
        constexpr uint32_t MCH1 = (6 << 8);  ///< CTSU Measurement Channel 1
        constexpr uint32_t MCA0 = (1U << 16);  ///< Multiple Clocks Control
        constexpr uint32_t MCA1 = (1U << 17);  ///< Multiple Clocks Control
        constexpr uint32_t MCA2 = (1U << 18);  ///< Multiple Clocks Control
        constexpr uint32_t MCA3 = (1U << 19);  ///< Multiple Clocks Control
    }

    /// CTSUCHACA Register bits
    namespace ctsuchaca_bits {
        constexpr uint32_t CHAC00 = (1U << 0);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC02 = (1U << 2);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC04 = (1U << 4);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC05 = (1U << 5);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC06 = (1U << 6);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC07 = (1U << 7);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC08 = (1U << 8);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC09 = (1U << 9);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC10 = (1U << 10);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC11 = (1U << 11);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC12 = (1U << 12);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC13 = (1U << 13);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC14 = (1U << 14);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC15 = (1U << 15);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC16 = (1U << 16);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC17 = (1U << 17);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC18 = (1U << 18);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC21 = (1U << 21);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC22 = (1U << 22);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC23 = (1U << 23);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC24 = (1U << 24);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC25 = (1U << 25);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC26 = (1U << 26);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC27 = (1U << 27);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC28 = (1U << 28);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC30 = (1U << 30);  ///< CTSU Channel Enable Control A
        constexpr uint32_t CHAC31 = (1U << 31);  ///< CTSU Channel Enable Control A
    }

    /// CTSUCHACB Register bits
    namespace ctsuchacb_bits {
        constexpr uint32_t CHAC32 = (1U << 0);  ///< CTSU Channel Enable Control B
        constexpr uint32_t CHAC33 = (1U << 1);  ///< CTSU Channel Enable Control B
        constexpr uint32_t CHAC34 = (1U << 2);  ///< CTSU Channel Enable Control B
    }

    /// CTSUCHTRCA Register bits
    namespace ctsuchtrca_bits {
        constexpr uint32_t CHTRC00 = (1U << 0);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC02 = (1U << 2);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC04 = (1U << 4);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC05 = (1U << 5);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC06 = (1U << 6);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC07 = (1U << 7);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC08 = (1U << 8);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC09 = (1U << 9);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC10 = (1U << 10);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC11 = (1U << 11);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC12 = (1U << 12);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC13 = (1U << 13);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC14 = (1U << 14);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC15 = (1U << 15);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC16 = (1U << 16);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC17 = (1U << 17);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC18 = (1U << 18);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC21 = (1U << 21);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC22 = (1U << 22);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC23 = (1U << 23);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC24 = (1U << 24);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC25 = (1U << 25);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC26 = (1U << 26);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC27 = (1U << 27);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC28 = (1U << 28);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC30 = (1U << 30);  ///< CTSU Channel Transmit/Receive Control A
        constexpr uint32_t CHTRC31 = (1U << 31);  ///< CTSU Channel Transmit/Receive Control A
    }

    /// CTSUCHTRCB Register bits
    namespace ctsuchtrcb_bits {
        constexpr uint32_t CHTRC32 = (1U << 0);  ///< CTSU Channel Transmit/Receive Control B
        constexpr uint32_t CHTRC33 = (1U << 1);  ///< CTSU Channel Transmit/Receive Control B
        constexpr uint32_t CHTRC34 = (1U << 2);  ///< CTSU Channel Transmit/Receive Control B
    }

    /// CTSUSR Register bits
    namespace ctsusr_bits {
        constexpr uint32_t MFC = (2 << 0);  ///< CTSU Multi-clock Counter
        constexpr uint32_t ICOMPRST = (1U << 5);  ///< CTSU CTSUICOMP1 Flag Reset
        constexpr uint32_t ICOMP1 = (1U << 6);  ///< CTSU Sense Current Error Monitor
        constexpr uint32_t ICOMP0 = (1U << 7);  ///< TSCAP Voltage Error Monitor
        constexpr uint32_t STC = (3 << 8);  ///< CTSU Measurement Status Counter
        constexpr uint32_t DTSR = (1U << 12);  ///< CTSU Data Transfer Status Flag
        constexpr uint32_t SENSOVF = (1U << 13);  ///< CTSU Sensor Counter Overflow Flag
        constexpr uint32_t SUOVF = (1U << 14);  ///< CTSU SUCLK Counter Overflow Flag
        constexpr uint32_t PS = (1U << 15);  ///< CTSU Mutual Capacitance Status Flag
        constexpr uint32_t CFCRDCH = (6 << 16);  ///< CTSU CFC Read Channel Select
    }

    /// CTSUSO Register bits
    namespace ctsuso_bits {
        constexpr uint32_t SO = (10 << 0);  ///< CTSU Sensor Offset Adjustment
        constexpr uint32_t SNUM = (8 << 10);  ///< CTSU Measurement Count Setting
        constexpr uint32_t SSDIV = (4 << 20);  ///< Spread Spectrum Frequency
        constexpr uint32_t SDPA = (8 << 24);  ///< CTSU Base Clock Setting
    }

    /// CTSUSCNT Register bits
    namespace ctsuscnt_bits {
        constexpr uint32_t SENSCNT = (16 << 0);  ///< CTSU Sensor Counter
        constexpr uint32_t SUCKCNT = (16 << 16);  ///< CTSU SUCLK Counter
    }

    /// CTSUCALIB Register bits
    namespace ctsucalib_bits {
        constexpr uint32_t TSOD = (1U << 2);  ///< TS Pin Fixed Output
        constexpr uint32_t DRV = (1U << 3);  ///< Power Supply Calibration Select
        constexpr uint32_t CLKSEL = (2 << 4);  ///< Observation Clock Select
        constexpr uint32_t SUCLKEN = (1U << 6);  ///< SUCLK Forced Oscillation Control
        constexpr uint32_t TSOC = (1U << 7);  ///< Switched Capacitor Operation Calibration Select Bit
        constexpr uint32_t CNTRDSEL = (1U << 8);  ///< Read Count Select of Sensor Counter
        constexpr uint32_t IOC = (1U << 9);  ///< TS Pin Fixed Output Value Set
        constexpr uint32_t CFCRDMD = (1U << 10);  ///< CFC Counter Read Mode Select
        constexpr uint32_t DCOFF = (1U << 11);  ///< Down Converter Control
        constexpr uint32_t CFCSEL = (6 << 16);  ///< Observation CFC Clock Select
        constexpr uint32_t CFCMODE = (1U << 22);  ///< CFC Oscillator Calibration Mode Select
        constexpr uint32_t DACMSEL = (1U << 24);  ///< Current Offset DAC Current Matrix Calibration Select
        constexpr uint32_t DACCARRY = (1U << 25);  ///< Offset Current Adjustment for Calibration
        constexpr uint32_t SUMSEL = (1U << 26);  ///< Current Control Oscillator Input Current Matrix Calibration Select
        constexpr uint32_t SUCARRY = (1U << 27);  ///< Current Control Oscillator Input Current Adjustment for SUCLK
        constexpr uint32_t DACCLK = (1U << 28);  ///< Modulation Clock Select for Offset Current Circuits
        constexpr uint32_t CCOCLK = (1U << 29);  ///< Modulation Clock Select for Current Controlled Oscillator Input Current of SUCLK
        constexpr uint32_t CCOCALIB = (1U << 30);  ///< Calibration Selection of Current Controlled Oscillator for Measurement
        constexpr uint32_t TXREV = (1U << 31);  ///< Transmit Pin Inverted Output
    }

    /// CTSUSUCLKB Register bits
    namespace ctsusuclkb_bits {
        constexpr uint32_t SUADJ2 = (8 << 0);  ///< CTSU SUCLK Frequency Adjustment
        constexpr uint32_t SUMULTI2 = (8 << 8);  ///< CTSU SUCLK Multiplier Rate Setting
        constexpr uint32_t SUADJ3 = (8 << 16);  ///< CTSU SUCLK Frequency Adjustment
        constexpr uint32_t SUMULTI3 = (8 << 24);  ///< CTSU SUCLK Multiplier Rate Setting
    }

    /// CTSUCFCCNT Register bits
    namespace ctsucfccnt_bits {
        constexpr uint32_t CFCCNT = (16 << 0);  ///< CTSU CFC Counter
    }

}

// ============================================================================
// AGT0 Peripheral
// ============================================================================

namespace agt0 {
    /// Base addresses
    constexpr uint32_t AGT0_BASE = 0x40084000;

    /// AGT0 Register structure
    struct Registers {
        volatile uint32_t AGT;  ///< Offset: 0x00 - AGT Counter Register
        volatile uint32_t AGTCMA;  ///< Offset: 0x02 - AGT Compare Match A Register
        volatile uint32_t AGTCMB;  ///< Offset: 0x04 - AGT Compare Match B Register
        volatile uint32_t AGTCR;  ///< Offset: 0x08 - AGT Control Register
        volatile uint32_t AGTMR1;  ///< Offset: 0x09 - AGT Mode Register 1
        volatile uint32_t AGTMR2;  ///< Offset: 0x0A - AGT Mode Register 2
        volatile uint32_t AGTIOC;  ///< Offset: 0x0C - AGT I/O Control Register
        volatile uint32_t AGTISR;  ///< Offset: 0x0D - AGT Event Pin Select Register
        volatile uint32_t AGTCMSR;  ///< Offset: 0x0E - AGT Compare Match Function Select Register
        volatile uint32_t AGTIOSEL;  ///< Offset: 0x0F - AGT Pin Select Register
    };

    /// Peripheral instances
    inline Registers* AGT0 = reinterpret_cast<Registers*>(AGT0_BASE);

    // Bit definitions
    /// AGTCR Register bits
    namespace agtcr_bits {
        constexpr uint32_t TSTART = (1U << 0);  ///< AGT Count Start
        constexpr uint32_t TCSTF = (1U << 1);  ///< AGT Count Status Flag
        constexpr uint32_t TSTOP = (1U << 2);  ///< AGT Count Forced Stop
        constexpr uint32_t TEDGF = (1U << 4);  ///< Active Edge Judgment Flag
        constexpr uint32_t TUNDF = (1U << 5);  ///< Underflow Flag
        constexpr uint32_t TCMAF = (1U << 6);  ///< Compare Match A Flag
        constexpr uint32_t TCMBF = (1U << 7);  ///< Compare Match B Flag
    }

    /// AGTMR1 Register bits
    namespace agtmr1_bits {
        constexpr uint32_t TMOD = (3 << 0);  ///< Operating Mode
        constexpr uint32_t TEDGPL = (1U << 3);  ///< Edge Polarity
        constexpr uint32_t TCK = (3 << 4);  ///< Count Source
    }

    /// AGTMR2 Register bits
    namespace agtmr2_bits {
        constexpr uint32_t CKS = (3 << 0);  ///< AGTLCLK or AGTSCLK Count Source Clock Frequency Division Ratio
        constexpr uint32_t LPM = (1U << 7);  ///< Low Power Mode
    }

    /// AGTIOC Register bits
    namespace agtioc_bits {
        constexpr uint32_t TEDGSEL = (1U << 0);  ///< I/O Polarity Switch
        constexpr uint32_t TOE = (1U << 2);  ///< AGTOn pin Output Enable
        constexpr uint32_t TIPF = (2 << 4);  ///< Input Filter
        constexpr uint32_t TIOGT = (2 << 6);  ///< Count Control
    }

    /// AGTISR Register bits
    namespace agtisr_bits {
        constexpr uint32_t EEPS = (1U << 2);  ///< AGTEEn Polarity Selection
    }

    /// AGTCMSR Register bits
    namespace agtcmsr_bits {
        constexpr uint32_t TCMEA = (1U << 0);  ///< AGT Compare Match A Register Enable
        constexpr uint32_t TOEA = (1U << 1);  ///< AGTOAn Pin Output Enable
        constexpr uint32_t TOPOLA = (1U << 2);  ///< AGTOAn Pin Polarity Select
        constexpr uint32_t TCMEB = (1U << 4);  ///< AGT Compare Match B Register Enable
        constexpr uint32_t TOEB = (1U << 5);  ///< AGTOBn Pin Output Enable
        constexpr uint32_t TOPOLB = (1U << 6);  ///< AGTOBn Pin Polarity Select
    }

    /// AGTIOSEL Register bits
    namespace agtiosel_bits {
        constexpr uint32_t SEL = (2 << 0);  ///< AGTIOn Pin Select
        constexpr uint32_t TIES = (1U << 4);  ///< AGTIOn Pin Input Enable
    }

}

// ============================================================================
// AGT1 Peripheral
// ============================================================================

namespace agt1 {
    /// Base addresses
    constexpr uint32_t AGT1_BASE = 0x40084100;

    /// AGT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AGT1 = reinterpret_cast<Registers*>(AGT1_BASE);

}

// ============================================================================
// ACMPLP Peripheral
// ============================================================================

namespace acmplp {
    /// Base addresses
    constexpr uint32_t ACMPLP_BASE = 0x40085E00;

    /// ACMPLP Register structure
    struct Registers {
        volatile uint32_t COMPMDR;  ///< Offset: 0x00 - ACMPLP Mode Setting Register
        volatile uint32_t COMPFIR;  ///< Offset: 0x01 - ACMPLP Filter Control Register
        volatile uint32_t COMPOCR;  ///< Offset: 0x02 - ACMPLP Output Control Register
    };

    /// Peripheral instances
    inline Registers* ACMPLP = reinterpret_cast<Registers*>(ACMPLP_BASE);

    // Bit definitions
    /// COMPMDR Register bits
    namespace compmdr_bits {
        constexpr uint32_t C0ENB = (1U << 0);  ///< ACMPLP0 Operation Enable
        constexpr uint32_t C0WDE = (1U << 1);  ///< ACMPLP0 Window Function Mode Enable
        constexpr uint32_t C0VRF = (1U << 2);  ///< ACMPLP0 Reference Voltage Selection
        constexpr uint32_t C0MON = (1U << 3);  ///< ACMPLP0 Monitor Flag
        constexpr uint32_t C1ENB = (1U << 4);  ///< ACMPLP1 Operation Enable
        constexpr uint32_t C1WDE = (1U << 5);  ///< ACMPLP1 Window Function Mode Enable
        constexpr uint32_t C1VRF = (1U << 6);  ///< ACMPLP1 Reference Voltage Selection
        constexpr uint32_t C1MON = (1U << 7);  ///< ACMPLP1 Monitor Flag
    }

    /// COMPFIR Register bits
    namespace compfir_bits {
        constexpr uint32_t C0FCK = (2 << 0);  ///< ACMPLP0 Filter Select
        constexpr uint32_t C0EPO = (1U << 2);  ///< ACMPLP0 Edge Polarity Switching
        constexpr uint32_t C0EDG = (1U << 3);  ///< ACMPLP0 Edge Detection Selection
        constexpr uint32_t C1FCK = (2 << 4);  ///< ACMPLP1 Filter Select
        constexpr uint32_t C1EPO = (1U << 6);  ///< ACMPLP1 Edge Polarity Switching
        constexpr uint32_t C1EDG = (1U << 7);  ///< ACMPLP1 Edge Detection Selection
    }

    /// COMPOCR Register bits
    namespace compocr_bits {
        constexpr uint32_t C0OE = (1U << 1);  ///< ACMPLP0 VCOUT Pin Output Enable
        constexpr uint32_t C0OP = (1U << 2);  ///< ACMPLP0 VCOUT Output Polarity Selection
        constexpr uint32_t C1OE = (1U << 5);  ///< ACMPLP1 VCOUT Pin Output Enable
        constexpr uint32_t C1OP = (1U << 6);  ///< ACMPLP1 VCOUT Output Polarity Selection
        constexpr uint32_t SPDMD = (1U << 7);  ///< ACMPLP0/ACMPLP1 Speed Selection
    }

}

// ============================================================================
// FLCN Peripheral
// ============================================================================

namespace flcn {
    /// Base addresses
    constexpr uint32_t FLCN_BASE = 0x407EC000;

    /// FLCN Register structure
    struct Registers {
        volatile uint32_t DFLCTL;  ///< Offset: 0x90 - Data Flash Control Register
        volatile uint32_t FPMCR;  ///< Offset: 0x100 - Flash P/E Mode Control Register
        volatile uint32_t FASR;  ///< Offset: 0x104 - Flash Area Select Register
        volatile uint32_t FSARL;  ///< Offset: 0x108 - Flash Processing Start Address Register L
        volatile uint32_t FSARH;  ///< Offset: 0x110 - Flash Processing Start Address Register H
        volatile uint32_t FCR;  ///< Offset: 0x114 - Flash Control Register
        volatile uint32_t FEARL;  ///< Offset: 0x118 - Flash Processing End Address Register L
        volatile uint32_t FEARH;  ///< Offset: 0x120 - Flash Processing End Address Register H
        volatile uint32_t FRESETR;  ///< Offset: 0x124 - Flash Reset Register
        volatile uint32_t FSTATR1;  ///< Offset: 0x12C - Flash Status Register 1
        volatile uint32_t FWBL0;  ///< Offset: 0x130 - Flash Write Buffer Register L0
        volatile uint32_t FWBH0;  ///< Offset: 0x138 - Flash Write Buffer Register H0
        volatile uint32_t FPR;  ///< Offset: 0x180 - Protection Unlock Register
        volatile uint32_t FPSR;  ///< Offset: 0x184 - Protection Unlock Status Register
        volatile uint32_t FRBL0;  ///< Offset: 0x188 - Flash Read Buffer Register L0
        volatile uint32_t FRBH0;  ///< Offset: 0x190 - Flash Read Buffer Register H0
        volatile uint32_t FSCMR;  ///< Offset: 0x1C0 - Flash Start-Up Setting Monitor Register
        volatile uint32_t FAWSMR;  ///< Offset: 0x1C8 - Flash Access Window Start Address Monitor Register
        volatile uint32_t FAWEMR;  ///< Offset: 0x1D0 - Flash Access Window End Address Monitor Register
        volatile uint32_t FISR;  ///< Offset: 0x1D8 - Flash Initial Setting Register
        volatile uint32_t FEXCR;  ///< Offset: 0x1DC - Flash Extra Area Control Register
        volatile uint32_t FEAML;  ///< Offset: 0x1E0 - Flash Error Address Monitor Register L
        volatile uint32_t FEAMH;  ///< Offset: 0x1E8 - Flash Error Address Monitor Register H
        volatile uint32_t FSTATR2;  ///< Offset: 0x1F0 - Flash Status Register 2
        volatile uint32_t TSCDR;  ///< Offset: 0x228 - Temperature Sensor Calibration Data Register
        volatile uint32_t CTSUTRIMA;  ///< Offset: 0x3A4 - CTSU Trimming Register A
        volatile uint32_t CTSUTRIMB;  ///< Offset: 0x3A8 - CTSU Trimming Register B
        volatile uint32_t FENTRYR;  ///< Offset: 0x3FB0 - Flash P/E Mode Entry Register
        volatile uint32_t FLDWAITR;  ///< Offset: 0x3FC4 - Memory Wait Cycle Control Register for Data Flash
        volatile uint32_t PFBER;  ///< Offset: 0x3FC8 - Prefetch Buffer Enable Register
    };

    /// Peripheral instances
    inline Registers* FLCN = reinterpret_cast<Registers*>(FLCN_BASE);

    // Bit definitions
    /// DFLCTL Register bits
    namespace dflctl_bits {
        constexpr uint32_t DFLEN = (1U << 0);  ///< Data Flash Access Enable
    }

    /// FPMCR Register bits
    namespace fpmcr_bits {
        constexpr uint32_t FMS0 = (1U << 1);  ///< Flash Operating Mode Select 0
        constexpr uint32_t RPDIS = (1U << 3);  ///< Code Flash P/E Disable
        constexpr uint32_t FMS1 = (1U << 4);  ///< Flash Operating Mode Select 1
    }

    /// FASR Register bits
    namespace fasr_bits {
        constexpr uint32_t EXS = (1U << 0);  ///< Extra Area Select
    }

    /// FSARL Register bits
    namespace fsarl_bits {
        constexpr uint32_t FSARL = (16 << 0);  ///< Flash Processing Start Address L
    }

    /// FSARH Register bits
    namespace fsarh_bits {
        constexpr uint32_t FSARH = (16 << 0);  ///< Flash Processing Start Address H
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t CMD = (4 << 0);  ///< Software Command Setting
        constexpr uint32_t DRC = (1U << 4);  ///< Data Read Completion
        constexpr uint32_t STOP = (1U << 6);  ///< Forced Processing Stop
        constexpr uint32_t OPST = (1U << 7);  ///< Processing Start
    }

    /// FEARL Register bits
    namespace fearl_bits {
        constexpr uint32_t FEARL = (16 << 0);  ///< Flash Processing End Address L
    }

    /// FEARH Register bits
    namespace fearh_bits {
        constexpr uint32_t FEARH = (16 << 0);  ///< Flash Processing End Address H
    }

    /// FRESETR Register bits
    namespace fresetr_bits {
        constexpr uint32_t FRESET = (1U << 0);  ///< Software reset of the registers
    }

    /// FSTATR1 Register bits
    namespace fstatr1_bits {
        constexpr uint32_t DRRDY = (1U << 1);  ///< Data Read Ready Flag
        constexpr uint32_t FRDY = (1U << 6);  ///< Flash Ready Flag
        constexpr uint32_t EXRDY = (1U << 7);  ///< Extra Area Ready Flag
    }

    /// FWBL0 Register bits
    namespace fwbl0_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Flash Write Buffer L0
    }

    /// FWBH0 Register bits
    namespace fwbh0_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Flash Write Buffer H0
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FPR = (8 << 0);  ///< Protection Unlock
    }

    /// FPSR Register bits
    namespace fpsr_bits {
        constexpr uint32_t PERR = (1U << 0);  ///< Protect Error Flag
    }

    /// FRBL0 Register bits
    namespace frbl0_bits {
        constexpr uint32_t RDATA = (16 << 0);  ///< Flash Read Buffer L0
    }

    /// FRBH0 Register bits
    namespace frbh0_bits {
        constexpr uint32_t RDATA = (16 << 0);  ///< Flash Read Buffer H0
    }

    /// FSCMR Register bits
    namespace fscmr_bits {
        constexpr uint32_t SASMF = (1U << 8);  ///< Startup Area Setting Monitor Flag
        constexpr uint32_t FSPR = (1U << 14);  ///< Access Window Protection Flag
    }

    /// FAWSMR Register bits
    namespace fawsmr_bits {
        constexpr uint32_t FAWS = (11 << 0);  ///< Access Window Start Address
        constexpr uint32_t FSPR = (1U << 15);  ///< Access Window Protection Flag
    }

    /// FAWEMR Register bits
    namespace fawemr_bits {
        constexpr uint32_t FAWE = (11 << 0);  ///< Access Window End Address
        constexpr uint32_t SASMF = (1U << 15);  ///< Startup Area Setting Monitor Flag
    }

    /// FISR Register bits
    namespace fisr_bits {
        constexpr uint32_t PCKA = (6 << 0);  ///< Flash-IF Clock Notification
        constexpr uint32_t SAS = (2 << 6);  ///< Startup Area Select
    }

    /// FEXCR Register bits
    namespace fexcr_bits {
        constexpr uint32_t CMD = (3 << 0);  ///< Software Command Setting
        constexpr uint32_t OPST = (1U << 7);  ///< Processing Start
    }

    /// FEAML Register bits
    namespace feaml_bits {
        constexpr uint32_t FEAML = (16 << 0);  ///< Flash Error Address Monitor Register L
    }

    /// FEAMH Register bits
    namespace feamh_bits {
        constexpr uint32_t FEAMH = (16 << 0);  ///< Flash Error Address Monitor Register H
    }

    /// FSTATR2 Register bits
    namespace fstatr2_bits {
        constexpr uint32_t ERERR = (1U << 0);  ///< Erase Error Flag
        constexpr uint32_t PRGERR = (1U << 1);  ///< Program Error Flag
        constexpr uint32_t PRGERR01 = (1U << 2);  ///< Program Error Flag 01
        constexpr uint32_t BCERR = (1U << 3);  ///< Blank Check Error Flag
        constexpr uint32_t ILGLERR = (1U << 4);  ///< Illegal Command Error Flag
        constexpr uint32_t EILGLERR = (1U << 5);  ///< Extra Area Illegal Command Error Flag
    }

    /// TSCDR Register bits
    namespace tscdr_bits {
        constexpr uint32_t TSCDR = (16 << 0);  ///< Temperature Sensor Calibration Data
    }

    /// CTSUTRIMA Register bits
    namespace ctsutrima_bits {
        constexpr uint32_t RTRIM = (8 << 0);  ///< CTSU Reference Resistance Adjustment
        constexpr uint32_t DACTRIM = (8 << 8);  ///< Linearity Adjustment of Offset Current
        constexpr uint32_t SUADJD = (8 << 16);  ///< CTSU SUCLK Frequency Adjustment
        constexpr uint32_t SUADJTRIM = (8 << 24);  ///< Coefficient of variation for the reference load resistance
    }

    /// CTSUTRIMB Register bits
    namespace ctsutrimb_bits {
        constexpr uint32_t TRESULT0 = (8 << 0);  ///< The coefficient of variation for the 7.5 kΩ reference load resistance is stored.
        constexpr uint32_t TRESULT1 = (8 << 8);  ///< The coefficient of variation for the 15 kΩ reference load resistance is stored.
        constexpr uint32_t TRESULT2 = (8 << 16);  ///< The coefficient of variation for the 30 kΩ reference load resistance is stored.
        constexpr uint32_t TRESULT3 = (8 << 24);  ///< The coefficient of variation for the 60 kΩ reference load resistance is stored.
    }

    /// FENTRYR Register bits
    namespace fentryr_bits {
        constexpr uint32_t FENTRY0 = (1U << 0);  ///< Code Flash P/E Mode Entry 0
        constexpr uint32_t FENTRYD = (1U << 7);  ///< Data Flash P/E Mode Entry
        constexpr uint32_t FEKEY = (8 << 8);  ///< Key Code
    }

    /// FLDWAITR Register bits
    namespace fldwaitr_bits {
        constexpr uint32_t FLDWAIT1 = (1U << 0);  ///< Memory Wait Cycle Select for Data Flash
    }

    /// PFBER Register bits
    namespace pfber_bits {
        constexpr uint32_t PFBE = (1U << 0);  ///< Prefetch Buffer Enable bit
    }

}


} // namespace alloy::generated::r7fa2e1a9

#endif // ALLOY_GENERATED_R7FA2E1A9_PERIPHERALS_HPP