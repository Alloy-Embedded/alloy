/// Auto-generated code for R7FA2E2A7
/// Generated by Alloy Code Generator
/// Source: renesas_r7fa2e2a7.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:30:22
#ifndef ALLOY_GENERATED_R7FA2E2A7_PERIPHERALS_HPP
#define ALLOY_GENERATED_R7FA2E2A7_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::r7fa2e2a7 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// RMPU Peripheral
// ============================================================================

namespace rmpu {
    /// Base addresses
    constexpr uint32_t RMPU_BASE = 0x40000000;

    /// RMPU Register structure
    struct Registers {
        volatile uint32_t MMPUCTLA;  ///< Offset: 0x00 - Bus Master MPU Control Register
        volatile uint32_t MMPUPTA;  ///< Offset: 0x102 - Group A Protection of Register
        volatile uint32_t MMPUACA%s;  ///< Offset: 0x200 - Group A Region %s access control register
        volatile uint32_t MMPUSA%s;  ///< Offset: 0x204 - Group A Region %s Start Address Register
        volatile uint32_t MMPUEA%s;  ///< Offset: 0x208 - Group A Region %s End Address Register
        volatile uint32_t SMPUCTL;  ///< Offset: 0xC00 - Slave MPU Control Register
        volatile uint32_t SMPUMBIU;  ///< Offset: 0xC10 - Access Control Register for Memory Bus 1
        volatile uint32_t SMPUFBIU;  ///< Offset: 0xC14 - Access Control Register for Internal Peripheral Bus 9
        volatile uint32_t SMPUSRAM0;  ///< Offset: 0xC18 - Access Control Register for Memory Bus 4
        volatile uint32_t SMPUP0BIU;  ///< Offset: 0xC20 - Access Control Register for Internal Peripheral Bus 1
        volatile uint32_t SMPUP2BIU;  ///< Offset: 0xC24 - Access Control Register for Internal Peripheral Bus 3
        volatile uint32_t SMPUP6BIU;  ///< Offset: 0xC28 - Access Control Register for Internal Peripheral Bus 7
        volatile uint32_t MSPMPUOAD;  ///< Offset: 0xD00 - Stack Pointer Monitor Operation After Detection Register
        volatile uint32_t MSPMPUCTL;  ///< Offset: 0xD04 - Stack Pointer Monitor Access Control Register
        volatile uint32_t MSPMPUPT;  ///< Offset: 0xD06 - Stack Pointer Monitor Protection Register
        volatile uint32_t MSPMPUSA;  ///< Offset: 0xD08 - Main Stack Pointer (MSP) Monitor Start Address Register
        volatile uint32_t MSPMPUEA;  ///< Offset: 0xD0C - Main Stack Pointer (MSP) Monitor End Address Register
        volatile uint32_t PSPMPUOAD;  ///< Offset: 0xD10 - Stack Pointer Monitor Operation After Detection Register
        volatile uint32_t PSPMPUCTL;  ///< Offset: 0xD14 - Stack Pointer Monitor Access Control Register
        volatile uint32_t PSPMPUPT;  ///< Offset: 0xD16 - Stack Pointer Monitor Protection Register
        volatile uint32_t PSPMPUSA;  ///< Offset: 0xD18 - Process Stack Pointer (PSP) Monitor Start Address Register
        volatile uint32_t PSPMPUEA;  ///< Offset: 0xD1C - Process Stack Pointer (PSP) Monitor End Address Register
    };

    /// Peripheral instances
    inline Registers* RMPU = reinterpret_cast<Registers*>(RMPU_BASE);

    // Bit definitions
    /// MMPUCTLA Register bits
    namespace mmpuctla_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Master Group Enable
        constexpr uint32_t OAD = (1U << 1);  ///< Operation After Detection
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// MMPUPTA Register bits
    namespace mmpupta_bits {
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of Register
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// MMPUACA%s Register bits
    namespace mmpuaca%s_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region Enable
        constexpr uint32_t RP = (1U << 1);  ///< Read Protection
        constexpr uint32_t WP = (1U << 2);  ///< Write Protection
    }

    /// MMPUSA%s Register bits
    namespace mmpusa%s_bits {
        constexpr uint32_t MMPUSA = (32 << 0);  ///< Region Start Address
    }

    /// MMPUEA%s Register bits
    namespace mmpuea%s_bits {
        constexpr uint32_t MMPUEA = (32 << 0);  ///< Region End Address
    }

    /// SMPUCTL Register bits
    namespace smpuctl_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation After Detection
        constexpr uint32_t PROTECT = (1U << 1);  ///< Protection of Register
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// SMPUMBIU Register bits
    namespace smpumbiu_bits {
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master MPU Group A Read Protection
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master MPU Group A Write Protection
    }

    /// SMPUFBIU Register bits
    namespace smpufbiu_bits {
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read Protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write Protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master MPU Group A Read Protection
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master MPU Group A Write Protection
    }

    /// SMPUSRAM0 Register bits
    namespace smpusram0_bits {
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read Protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write Protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master MPU Group A Read Protection
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master MPU Group A Write Protection
    }

    /// SMPUP0BIU Register bits
    namespace smpup0biu_bits {
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read Protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write Protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master MPU Group A Read Protection
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master MPU Group A Write Protection
    }

    /// SMPUP2BIU Register bits
    namespace smpup2biu_bits {
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read Protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write Protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master MPU Group A Read Protection
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master MPU Group A Write Protection
    }

    /// SMPUP6BIU Register bits
    namespace smpup6biu_bits {
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read Protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write Protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master MPU Group A Read Protection
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master MPU Group A Write Protection
    }

    /// MSPMPUOAD Register bits
    namespace mspmpuoad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after Detection
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// MSPMPUCTL Register bits
    namespace mspmpuctl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Stack Pointer Monitor Enable
        constexpr uint32_t ERROR = (1U << 8);  ///< Stack Pointer Monitor Error Flag
    }

    /// MSPMPUPT Register bits
    namespace mspmpupt_bits {
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of Register
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// MSPMPUSA Register bits
    namespace mspmpusa_bits {
        constexpr uint32_t MSPMPUSA = (32 << 0);  ///< Region Start Address
    }

    /// MSPMPUEA Register bits
    namespace mspmpuea_bits {
        constexpr uint32_t MSPMPUEA = (32 << 0);  ///< Region End Address
    }

    /// PSPMPUOAD Register bits
    namespace pspmpuoad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after Detection
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// PSPMPUCTL Register bits
    namespace pspmpuctl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Stack Pointer Monitor Enable
        constexpr uint32_t ERROR = (1U << 8);  ///< Stack Pointer Monitor Error Flag
    }

    /// PSPMPUPT Register bits
    namespace pspmpupt_bits {
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of Register
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code
    }

    /// PSPMPUSA Register bits
    namespace pspmpusa_bits {
        constexpr uint32_t PSPMPUSA = (32 << 0);  ///< Region Start Address
    }

    /// PSPMPUEA Register bits
    namespace pspmpuea_bits {
        constexpr uint32_t PSPMPUEA = (32 << 0);  ///< Region End Address
    }

}

// ============================================================================
// SRAM Peripheral
// ============================================================================

namespace sram {
    /// Base addresses
    constexpr uint32_t SRAM_BASE = 0x40002000;

    /// SRAM Register structure
    struct Registers {
        volatile uint32_t PARIOAD;  ///< Offset: 0x00 - SRAM Parity Error Operation After Detection Register
        volatile uint32_t SRAMPRCR;  ///< Offset: 0x04 - SRAM Protection Register
    };

    /// Peripheral instances
    inline Registers* SRAM = reinterpret_cast<Registers*>(SRAM_BASE);

    // Bit definitions
    /// PARIOAD Register bits
    namespace parioad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation After Detection
    }

    /// SRAMPRCR Register bits
    namespace sramprcr_bits {
        constexpr uint32_t SRAMPRCR = (1U << 0);  ///< Register Write Control
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
    }

}

// ============================================================================
// BUS Peripheral
// ============================================================================

namespace bus {
    /// Base addresses
    constexpr uint32_t BUS_BASE = 0x40003000;

    /// BUS Register structure
    struct Registers {
        volatile uint32_t BUSMCNTSYS;  ///< Offset: 0x1008 - Master Bus Control Register SYS
        volatile uint32_t BUSMCNTDMA;  ///< Offset: 0x100C - Master Bus Control Register DMA
        volatile uint32_t BUS3ERRADD;  ///< Offset: 0x1820 - Bus Error Address Register 3
        volatile uint32_t BUS3ERRSTAT;  ///< Offset: 0x1824 - BUS Error Status Register 3
        volatile uint32_t BUS4ERRADD;  ///< Offset: 0x1830 - Bus Error Address Register 4
        volatile uint32_t BUS4ERRSTAT;  ///< Offset: 0x1834 - BUS Error Status Register 4
    };

    /// Peripheral instances
    inline Registers* BUS = reinterpret_cast<Registers*>(BUS_BASE);

    // Bit definitions
    /// BUSMCNTSYS Register bits
    namespace busmcntsys_bits {
        constexpr uint32_t IERES = (1U << 15);  ///< Ignore Error Responses
    }

    /// BUSMCNTDMA Register bits
    namespace busmcntdma_bits {
        constexpr uint32_t IERES = (1U << 15);  ///< Ignore Error Responses
    }

    /// BUS3ERRADD Register bits
    namespace bus3erradd_bits {
        constexpr uint32_t BERAD = (32 << 0);  ///< Bus Error Address
    }

    /// BUS3ERRSTAT Register bits
    namespace bus3errstat_bits {
        constexpr uint32_t ACCSTAT = (1U << 0);  ///< Error Access Status flag
        constexpr uint32_t ERRSTAT = (1U << 7);  ///< Bus Error Status flag
    }

    /// BUS4ERRADD Register bits
    namespace bus4erradd_bits {
        constexpr uint32_t BERAD = (32 << 0);  ///< Bus Error Address
    }

    /// BUS4ERRSTAT Register bits
    namespace bus4errstat_bits {
        constexpr uint32_t ACCSTAT = (1U << 0);  ///< Error Access Status flag
        constexpr uint32_t ERRSTAT = (1U << 7);  ///< Bus Error Status flag
    }

}

// ============================================================================
// DTC Peripheral
// ============================================================================

namespace dtc {
    /// Base addresses
    constexpr uint32_t DTC_BASE = 0x40005400;

    /// DTC Register structure
    struct Registers {
        volatile uint32_t DTCCR;  ///< Offset: 0x00 - DTC Control Register
        volatile uint32_t DTCVBR;  ///< Offset: 0x04 - DTC Vector Base Register
        volatile uint32_t DTCST;  ///< Offset: 0x0C - DTC Module Start Register
        volatile uint32_t DTCSTS;  ///< Offset: 0x0E - DTC Status Register
    };

    /// Peripheral instances
    inline Registers* DTC = reinterpret_cast<Registers*>(DTC_BASE);

    // Bit definitions
    /// DTCCR Register bits
    namespace dtccr_bits {
        constexpr uint32_t RRS = (1U << 4);  ///< DTC Transfer Information Read Skip Enable
    }

    /// DTCST Register bits
    namespace dtcst_bits {
        constexpr uint32_t DTCST = (1U << 0);  ///< DTC Module Start
    }

    /// DTCSTS Register bits
    namespace dtcsts_bits {
        constexpr uint32_t VECN = (8 << 0);  ///< DTC-Activating Vector Number Monitoring
        constexpr uint32_t ACT = (1U << 15);  ///< DTC Active Flag
    }

}

// ============================================================================
// ICU Peripheral
// ============================================================================

namespace icu {
    /// Base addresses
    constexpr uint32_t ICU_BASE = 0x40006000;

    /// ICU Register structure
    struct Registers {
        volatile uint32_t IRQCR%s;  ///< Offset: 0x00 - IRQ Control Register %s
        volatile uint32_t NMICR;  ///< Offset: 0x100 - NMI Pin Interrupt Control Register
        volatile uint32_t NMIER;  ///< Offset: 0x120 - Non-Maskable Interrupt Enable Register
        volatile uint32_t NMICLR;  ///< Offset: 0x130 - Non-Maskable Interrupt Status Clear Register
        volatile uint32_t NMISR;  ///< Offset: 0x140 - Non-Maskable Interrupt Status Register
        volatile uint32_t WUPEN;  ///< Offset: 0x1A0 - Wake Up Interrupt Enable Register
        volatile uint32_t IELEN;  ///< Offset: 0x1C0 - ICU event Enable Register
        volatile uint32_t SELSR0;  ///< Offset: 0x200 - SYS Event Link Setting Register
        volatile uint32_t IELSR%s;  ///< Offset: 0x300 - ICU Event Link Setting Register %s
    };

    /// Peripheral instances
    inline Registers* ICU = reinterpret_cast<Registers*>(ICU_BASE);

    // Bit definitions
    /// IRQCR%s Register bits
    namespace irqcr%s_bits {
        constexpr uint32_t IRQMD = (2 << 0);  ///< IRQi Detection Sense Select
        constexpr uint32_t FCLKSEL = (2 << 4);  ///< IRQi Digital Filter Sampling Clock Select
        constexpr uint32_t FLTEN = (1U << 7);  ///< IRQi Digital Filter Enable
    }

    /// NMICR Register bits
    namespace nmicr_bits {
        constexpr uint32_t NMIMD = (1U << 0);  ///< NMI Detection Set
        constexpr uint32_t NFCLKSEL = (2 << 4);  ///< NMI Digital Filter Sampling Clock Select
        constexpr uint32_t NFLTEN = (1U << 7);  ///< NMI Digital Filter Enable
    }

    /// NMIER Register bits
    namespace nmier_bits {
        constexpr uint32_t IWDTEN = (1U << 0);  ///< IWDT Underflow/Refresh Error Interrupt Enable
        constexpr uint32_t WDTEN = (1U << 1);  ///< WDT Underflow/Refresh Error Interrupt Enable
        constexpr uint32_t LVD1EN = (1U << 2);  ///< Voltage monitor 1 Interrupt Enable
        constexpr uint32_t LVD2EN = (1U << 3);  ///< Voltage monitor 2 Interrupt Enable
        constexpr uint32_t NMIEN = (1U << 7);  ///< NMI Pin Interrupt Enable
        constexpr uint32_t RPEEN = (1U << 8);  ///< SRAM Parity Error Interrupt Enable
        constexpr uint32_t BUSSEN = (1U << 10);  ///< Bus Slave MPU Error Interrupt Enable
        constexpr uint32_t BUSMEN = (1U << 11);  ///< Bus Master MPU Error Interrupt Enable
        constexpr uint32_t SPEEN = (1U << 12);  ///< CPU Stack Pointer Monitor Interrupt Enable
    }

    /// NMICLR Register bits
    namespace nmiclr_bits {
        constexpr uint32_t IWDTCLR = (1U << 0);  ///< IWDT Underflow/Refresh Error Interrupt Status Flag Clear
        constexpr uint32_t WDTCLR = (1U << 1);  ///< WDT Underflow/Refresh Error Interrupt Status Flag Clear
        constexpr uint32_t LVD1CLR = (1U << 2);  ///< Voltage Monitor 1 Interrupt Status Flag Clear
        constexpr uint32_t LVD2CLR = (1U << 3);  ///< Voltage Monitor 2 Interrupt Status Flag Clear
        constexpr uint32_t NMICLR = (1U << 7);  ///< NMI Pin Interrupt Status Flag Clear
        constexpr uint32_t RPECLR = (1U << 8);  ///< SRAM Parity Error Interrupt Status Flag Clear
        constexpr uint32_t BUSSCLR = (1U << 10);  ///< Bus Slave MPU Error Interrupt Status Flag Clear
        constexpr uint32_t BUSMCLR = (1U << 11);  ///< Bus Master MPU Error Interrupt Status Flag Clear
        constexpr uint32_t SPECLR = (1U << 12);  ///< CPU Stack Pointer Monitor Interrupt Status Flag Clear
    }

    /// NMISR Register bits
    namespace nmisr_bits {
        constexpr uint32_t IWDTST = (1U << 0);  ///< IWDT Underflow/Refresh Error Interrupt Status Flag
        constexpr uint32_t WDTST = (1U << 1);  ///< WDT Underflow/Refresh Error Interrupt Status Flag
        constexpr uint32_t LVD1ST = (1U << 2);  ///< Voltage Monitor 1 Interrupt Status Flag
        constexpr uint32_t LVD2ST = (1U << 3);  ///< Voltage Monitor 2 Interrupt Status Flag
        constexpr uint32_t NMIST = (1U << 7);  ///< NMI Pin Interrupt Status Flag
        constexpr uint32_t RPEST = (1U << 8);  ///< SRAM Parity Error Interrupt Status Flag
        constexpr uint32_t BUSSST = (1U << 10);  ///< Bus Slave MPU Error Interrupt Status Flag
        constexpr uint32_t BUSMST = (1U << 11);  ///< Bus Master MPU Error Interrupt Status Flag
        constexpr uint32_t SPEST = (1U << 12);  ///< CPU Stack Pointer Monitor Interrupt Status Flag
    }

    /// WUPEN Register bits
    namespace wupen_bits {
        constexpr uint32_t IRQWUPEN = (8 << 0);  ///< IRQ Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t IWDTWUPEN = (1U << 16);  ///< IWDT Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t KEYWUPEN = (1U << 17);  ///< Key Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t LVD1WUPEN = (1U << 18);  ///< LVD1 Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t LVD2WUPEN = (1U << 19);  ///< LVD2 Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t AGT1UDWUPEN = (1U << 28);  ///< AGT1 Underflow Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t AGT1CAWUPEN = (1U << 29);  ///< AGT1 Compare Match A Interrupt Software Standby/Snooze Mode Returns Enable
        constexpr uint32_t AGT1CBWUPEN = (1U << 30);  ///< AGT1 Compare Match B Interrupt Software Standby/Snooze Mode Returns Enable
    }

    /// IELEN Register bits
    namespace ielen_bits {
        constexpr uint32_t IELEN = (1U << 1);  ///< Parts Asynchronous Interrupts Enable (when LPOPTEN bit = 1)
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0x4001B000;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t DBGSTR;  ///< Offset: 0x00 - Debug Status Register
        volatile uint32_t DBGSTOPCR;  ///< Offset: 0x10 - Debug Stop Control Register
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// DBGSTR Register bits
    namespace dbgstr_bits {
        constexpr uint32_t CDBGPWRUPREQ = (1U << 28);  ///< Debug power-up request
        constexpr uint32_t CDBGPWRUPACK = (1U << 29);  ///< Debug power-up acknowledge
    }

    /// DBGSTOPCR Register bits
    namespace dbgstopcr_bits {
        constexpr uint32_t DBGSTOP_IWDT = (1U << 0);  ///< Mask bit for IWDT reset/interrupt in the OCD run mode
        constexpr uint32_t DBGSTOP_WDT = (1U << 1);  ///< Mask bit for WDT reset/interrupt in the OCD run mode
        constexpr uint32_t DBGSTOP_LVD0 = (1U << 16);  ///< Mask bit for LVD0 reset
        constexpr uint32_t DBGSTOP_LVD1 = (1U << 17);  ///< Mask bit for LVD1 reset/interrupt
        constexpr uint32_t DBGSTOP_LVD2 = (1U << 18);  ///< Mask bit for LVD2 reset/interrupt
        constexpr uint32_t DBGSTOP_RPER = (1U << 24);  ///< Mask bit for SRAM parity error reset/interrupt
    }

}

// ============================================================================
// SYSC Peripheral
// ============================================================================

namespace sysc {
    /// Base addresses
    constexpr uint32_t SYSC_BASE = 0x4001E000;

    /// SYSC Register structure
    struct Registers {
        volatile uint32_t SBYCR;  ///< Offset: 0x0C - Standby Control Register
        volatile uint32_t MSTPCRA;  ///< Offset: 0x1C - Module Stop Control Register A
        volatile uint32_t SCKDIVCR;  ///< Offset: 0x20 - System Clock Division Control Register
        volatile uint32_t SCKSCR;  ///< Offset: 0x26 - System Clock Source Control Register
        volatile uint32_t MEMWAIT;  ///< Offset: 0x31 - Memory Wait Cycle Control Register for Code Flash
        volatile uint32_t HOCOCR;  ///< Offset: 0x36 - High-Speed On-Chip Oscillator Control Register
        volatile uint32_t MOCOCR;  ///< Offset: 0x38 - Middle-Speed On-Chip Oscillator Control Register
        volatile uint32_t OSCSF;  ///< Offset: 0x3C - Oscillation Stabilization Flag Register
        volatile uint32_t CKOCR;  ///< Offset: 0x3E - Clock Out Control Register
        volatile uint32_t LPOPT;  ///< Offset: 0x4C - Lower Power Operation Control Register
        volatile uint32_t MOCOUTCR;  ///< Offset: 0x61 - MOCO User Trimming Control Register
        volatile uint32_t HOCOUTCR;  ///< Offset: 0x62 - HOCO User Trimming Control Register
        volatile uint32_t SNZCR;  ///< Offset: 0x92 - Snooze Control Register
        volatile uint32_t SNZEDCR0;  ///< Offset: 0x94 - Snooze End Control Register 0
        volatile uint32_t SNZREQCR0;  ///< Offset: 0x98 - Snooze Request Control Register 0
        volatile uint32_t PSMCR;  ///< Offset: 0x9F - Power Save Memory Control Register
        volatile uint32_t OPCCR;  ///< Offset: 0xA0 - Operating Power Control Register
        volatile uint32_t HOCOWTCR;  ///< Offset: 0xA5 - High-Speed On-Chip Oscillator Wait Control Register
        volatile uint32_t SOPCCR;  ///< Offset: 0xAA - Sub Operating Power Control Register
        volatile uint32_t RSTSR1;  ///< Offset: 0xC0 - Reset Status Register 1
        volatile uint32_t LVD1CR1;  ///< Offset: 0xE0 - Voltage Monitor 1 Circuit Control Register
        volatile uint32_t LVD1SR;  ///< Offset: 0xE1 - Voltage Monitor 1 Circuit Status Register
        volatile uint32_t LVD2CR1;  ///< Offset: 0xE2 - Voltage Monitor 2 Circuit Control Register 1
        volatile uint32_t LVD2SR;  ///< Offset: 0xE3 - Voltage Monitor 2 Circuit Status Register
        volatile uint32_t PRCR;  ///< Offset: 0x3FE - Protect Register
        volatile uint32_t SYOCDCR;  ///< Offset: 0x40E - System Control OCD Control Register
        volatile uint32_t RSTSR0;  ///< Offset: 0x410 - Reset Status Register 0
        volatile uint32_t RSTSR2;  ///< Offset: 0x411 - Reset Status Register 2
        volatile uint32_t LVCMPCR;  ///< Offset: 0x417 - Voltage Monitor Circuit Control Register
        volatile uint32_t LVDLVLR;  ///< Offset: 0x418 - Voltage Detection Level Select Register
        volatile uint32_t LVD1CR0;  ///< Offset: 0x41A - Voltage Monitor 1 Circuit Control Register 0
        volatile uint32_t LVD2CR0;  ///< Offset: 0x41B - Voltage Monitor 2 Circuit Control Register 0
        volatile uint32_t LOCOCR;  ///< Offset: 0x490 - Low-Speed On-Chip Oscillator Control Register
        volatile uint32_t LOCOUTCR;  ///< Offset: 0x492 - LOCO User Trimming Control Register
    };

    /// Peripheral instances
    inline Registers* SYSC = reinterpret_cast<Registers*>(SYSC_BASE);

    // Bit definitions
    /// SBYCR Register bits
    namespace sbycr_bits {
        constexpr uint32_t SSBY = (1U << 15);  ///< Software Standby Mode Select
    }

    /// MSTPCRA Register bits
    namespace mstpcra_bits {
        constexpr uint32_t MSTPA22 = (1U << 22);  ///< DTC Module Stop
    }

    /// SCKDIVCR Register bits
    namespace sckdivcr_bits {
        constexpr uint32_t PCKD = (3 << 0);  ///< Peripheral Module Clock D (PCLKD) Select
        constexpr uint32_t PCKB = (3 << 8);  ///< Peripheral Module Clock B (PCLKB) Select
        constexpr uint32_t ICK = (3 << 24);  ///< System Clock (ICLK) Select
    }

    /// SCKSCR Register bits
    namespace sckscr_bits {
        constexpr uint32_t CKSEL = (3 << 0);  ///< Clock Source Select
    }

    /// MEMWAIT Register bits
    namespace memwait_bits {
        constexpr uint32_t MEMWAIT = (1U << 0);  ///< Memory Wait Cycle Select for Code Flash
    }

    /// HOCOCR Register bits
    namespace hococr_bits {
        constexpr uint32_t HCSTP = (1U << 0);  ///< HOCO Stop
    }

    /// MOCOCR Register bits
    namespace mococr_bits {
        constexpr uint32_t MCSTP = (1U << 0);  ///< MOCO Stop
    }

    /// OSCSF Register bits
    namespace oscsf_bits {
        constexpr uint32_t HOCOSF = (1U << 0);  ///< HOCO Clock Oscillation Stabilization Flag
    }

    /// CKOCR Register bits
    namespace ckocr_bits {
        constexpr uint32_t CKOSEL = (3 << 0);  ///< Clock Out Source Select
        constexpr uint32_t CKODIV = (3 << 4);  ///< Clock Output Frequency Division Ratio
        constexpr uint32_t CKOEN = (1U << 7);  ///< Clock Out Enable
    }

    /// LPOPT Register bits
    namespace lpopt_bits {
        constexpr uint32_t MPUDIS = (1U << 0);  ///< MPU Clock Disable Control
        constexpr uint32_t DCLKDIS = (2 << 1);  ///< Debug Clock Disable Control
        constexpr uint32_t BPFCLKDIS = (1U << 3);  ///< BPF Clock Disable Control
        constexpr uint32_t LPOPTEN = (1U << 7);  ///< Lower Power Operation Enable
    }

    /// MOCOUTCR Register bits
    namespace mocoutcr_bits {
        constexpr uint32_t MOCOUTRM = (8 << 0);  ///< MOCO User Trimming
    }

    /// HOCOUTCR Register bits
    namespace hocoutcr_bits {
        constexpr uint32_t HOCOUTRM = (8 << 0);  ///< HOCO User Trimming
    }

    /// SNZCR Register bits
    namespace snzcr_bits {
        constexpr uint32_t SNZDTCEN = (1U << 1);  ///< DTC Enable in Snooze mode
        constexpr uint32_t SNZE = (1U << 7);  ///< Snooze mode Enable
    }

    /// SNZEDCR0 Register bits
    namespace snzedcr0_bits {
        constexpr uint32_t AGTUNFED = (1U << 0);  ///< AGT1 Underflow Snooze End Enable
        constexpr uint32_t DTCZRED = (1U << 1);  ///< Last DTC Transmission Completion Snooze End Enable
        constexpr uint32_t DTCNZRED = (1U << 2);  ///< Not Last DTC Transmission Completion Snooze End Enable
        constexpr uint32_t AD0MATED = (1U << 3);  ///< ADC12 Compare Match Snooze End Enable
        constexpr uint32_t AD0UMTED = (1U << 4);  ///< ADC12 Compare Mismatch Snooze End Enable
    }

    /// SNZREQCR0 Register bits
    namespace snzreqcr0_bits {
        constexpr uint32_t SNZREQEN0 = (1U << 0);  ///< Enable IRQ0 pin snooze request
        constexpr uint32_t SNZREQEN1 = (1U << 1);  ///< Enable IRQ1 pin snooze request
        constexpr uint32_t SNZREQEN2 = (1U << 2);  ///< Enable IRQ2 pin snooze request
        constexpr uint32_t SNZREQEN3 = (1U << 3);  ///< Enable IRQ3 pin snooze request
        constexpr uint32_t SNZREQEN4 = (1U << 4);  ///< Enable IRQ4 pin snooze request
        constexpr uint32_t SNZREQEN5 = (1U << 5);  ///< Enable IRQ5 pin snooze request
        constexpr uint32_t SNZREQEN6 = (1U << 6);  ///< Enable IRQ6 pin snooze request
        constexpr uint32_t SNZREQEN7 = (1U << 7);  ///< Enable IRQ7 pin snooze request
        constexpr uint32_t SNZREQEN17 = (1U << 17);  ///< Enable KEY_INTKR snooze request
        constexpr uint32_t SNZREQEN28 = (1U << 28);  ///< Enable AGT1 underflow snooze request
        constexpr uint32_t SNZREQEN29 = (1U << 29);  ///< Enable AGT1 compare match A snooze request
        constexpr uint32_t SNZREQEN30 = (1U << 30);  ///< Enable AGT1 compare match B snooze request
    }

    /// PSMCR Register bits
    namespace psmcr_bits {
        constexpr uint32_t PSMC = (2 << 0);  ///< Power Save Memory Control
    }

    /// OPCCR Register bits
    namespace opccr_bits {
        constexpr uint32_t OPCM = (2 << 0);  ///< Operating Power Control Mode Select
        constexpr uint32_t OPCMTSF = (1U << 4);  ///< Operating Power Control Mode Transition Status Flag
    }

    /// HOCOWTCR Register bits
    namespace hocowtcr_bits {
        constexpr uint32_t HSTS = (3 << 0);  ///< HOCO Wait Time Setting
    }

    /// SOPCCR Register bits
    namespace sopccr_bits {
        constexpr uint32_t SOPCM = (1U << 0);  ///< Sub Operating Power Control Mode Select
        constexpr uint32_t SOPCMTSF = (1U << 4);  ///< Operating Power Control Mode Transition Status Flag
    }

    /// RSTSR1 Register bits
    namespace rstsr1_bits {
        constexpr uint32_t IWDTRF = (1U << 0);  ///< Independent Watchdog Timer Reset Detect Flag
        constexpr uint32_t WDTRF = (1U << 1);  ///< Watchdog Timer Reset Detect Flag
        constexpr uint32_t SWRF = (1U << 2);  ///< Software Reset Detect Flag
        constexpr uint32_t RPERF = (1U << 8);  ///< SRAM Parity Error Reset Detect Flag
        constexpr uint32_t BUSSRF = (1U << 10);  ///< Bus Slave MPU Error Reset Detect Flag
        constexpr uint32_t BUSMRF = (1U << 11);  ///< Bus Master MPU Error Reset Detect Flag
        constexpr uint32_t SPERF = (1U << 12);  ///< CPU Stack Pointer Error Reset Detect Flag
    }

    /// LVD1CR1 Register bits
    namespace lvd1cr1_bits {
        constexpr uint32_t IDTSEL = (2 << 0);  ///< Voltage Monitor 1 Interrupt Generation Condition Select
        constexpr uint32_t IRQSEL = (1U << 2);  ///< Voltage Monitor 1 Interrupt Type Select
    }

    /// LVD1SR Register bits
    namespace lvd1sr_bits {
        constexpr uint32_t DET = (1U << 0);  ///< Voltage Monitor 1 Voltage Variation Detection Flag
        constexpr uint32_t MON = (1U << 1);  ///< Voltage Monitor 1 Signal Monitor Flag
    }

    /// LVD2CR1 Register bits
    namespace lvd2cr1_bits {
        constexpr uint32_t IDTSEL = (2 << 0);  ///< Voltage Monitor 2 Interrupt Generation Condition Select
        constexpr uint32_t IRQSEL = (1U << 2);  ///< Voltage Monitor 2 Interrupt Type Select
    }

    /// LVD2SR Register bits
    namespace lvd2sr_bits {
        constexpr uint32_t DET = (1U << 0);  ///< Voltage Monitor 2 Voltage Variation Detection Flag
        constexpr uint32_t MON = (1U << 1);  ///< Voltage Monitor 2 Signal Monitor Flag
    }

    /// PRCR Register bits
    namespace prcr_bits {
        constexpr uint32_t PRC0 = (1U << 0);  ///< Enable writing to the registers related to the clock generation circuit
        constexpr uint32_t PRC1 = (1U << 1);  ///< Enable writing to the registers related to the low power modes
        constexpr uint32_t PRC3 = (1U << 3);  ///< Enable writing to the registers related to the LVD
        constexpr uint32_t PRKEY = (8 << 8);  ///< PRC Key Code
    }

    /// SYOCDCR Register bits
    namespace syocdcr_bits {
        constexpr uint32_t DBGEN = (1U << 7);  ///< Debugger Enable bit
    }

    /// RSTSR0 Register bits
    namespace rstsr0_bits {
        constexpr uint32_t PORF = (1U << 0);  ///< Power-On Reset Detect Flag
        constexpr uint32_t LVD0RF = (1U << 1);  ///< Voltage Monitor 0 Reset Detect Flag
        constexpr uint32_t LVD1RF = (1U << 2);  ///< Voltage Monitor 1 Reset Detect Flag
        constexpr uint32_t LVD2RF = (1U << 3);  ///< Voltage Monitor 2 Reset Detect Flag
    }

    /// RSTSR2 Register bits
    namespace rstsr2_bits {
        constexpr uint32_t CWSF = (1U << 0);  ///< Cold/Warm Start Determination Flag
    }

    /// LVCMPCR Register bits
    namespace lvcmpcr_bits {
        constexpr uint32_t LVD1E = (1U << 5);  ///< Voltage Detection 1 Enable
        constexpr uint32_t LVD2E = (1U << 6);  ///< Voltage Detection 2 Enable
    }

    /// LVDLVLR Register bits
    namespace lvdlvlr_bits {
        constexpr uint32_t LVD1LVL = (5 << 0);  ///< Voltage Detection 1 Level Select (Standard voltage during fall in voltage)
        constexpr uint32_t LVD2LVL = (3 << 5);  ///< Voltage Detection 2 Level Select (Standard voltage during fall in voltage)
    }

    /// LVD1CR0 Register bits
    namespace lvd1cr0_bits {
        constexpr uint32_t RIE = (1U << 0);  ///< Voltage Monitor 1 Interrupt/Reset Enable
        constexpr uint32_t CMPE = (1U << 2);  ///< Voltage Monitor 1 Circuit Comparison Result Output Enable
        constexpr uint32_t RI = (1U << 6);  ///< Voltage Monitor 1 Circuit Mode Select
        constexpr uint32_t RN = (1U << 7);  ///< Voltage Monitor 1 Reset Negate Select
    }

    /// LVD2CR0 Register bits
    namespace lvd2cr0_bits {
        constexpr uint32_t RIE = (1U << 0);  ///< Voltage Monitor 2 Interrupt/Reset Enable
        constexpr uint32_t CMPE = (1U << 2);  ///< Voltage Monitor 2 Circuit Comparison Result Output Enable
        constexpr uint32_t RI = (1U << 6);  ///< Voltage Monitor 2 Circuit Mode Select
        constexpr uint32_t RN = (1U << 7);  ///< Voltage Monitor 2 Reset Negate Select
    }

    /// LOCOCR Register bits
    namespace lococr_bits {
        constexpr uint32_t LCSTP = (1U << 0);  ///< LOCO Stop
    }

    /// LOCOUTCR Register bits
    namespace locoutcr_bits {
        constexpr uint32_t LOCOUTRM = (8 << 0);  ///< LOCO User Trimming
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT0_BASE = 0x40040000;
    constexpr uint32_t PORT1_BASE = 0x40040020;
    constexpr uint32_t PORT2_BASE = 0x40040040;
    constexpr uint32_t PORT3_BASE = 0x40040060;
    constexpr uint32_t PORT4_BASE = 0x40040080;
    constexpr uint32_t PORT9_BASE = 0x40040120;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCNTR1;  ///< Offset: 0x00 - Port Control Register 1
        volatile uint32_t PODR;  ///< Offset: 0x00 - Port Control Register 1
        volatile uint32_t PDR;  ///< Offset: 0x02 - Port Control Register 1
        volatile uint32_t PCNTR2;  ///< Offset: 0x04 - Port Control Register 2
        volatile uint32_t PIDR;  ///< Offset: 0x06 - Port Control Register 2
        volatile uint32_t PCNTR3;  ///< Offset: 0x08 - Port Control Register 3
        volatile uint32_t PORR;  ///< Offset: 0x08 - Port Control Register 3
        volatile uint32_t POSR;  ///< Offset: 0x0A - Port Control Register 3
    };

    /// Peripheral instances
    inline Registers* PORT0 = reinterpret_cast<Registers*>(PORT0_BASE);
    inline Registers* PORT1 = reinterpret_cast<Registers*>(PORT1_BASE);
    inline Registers* PORT2 = reinterpret_cast<Registers*>(PORT2_BASE);
    inline Registers* PORT3 = reinterpret_cast<Registers*>(PORT3_BASE);
    inline Registers* PORT4 = reinterpret_cast<Registers*>(PORT4_BASE);
    inline Registers* PORT9 = reinterpret_cast<Registers*>(PORT9_BASE);

    // Bit definitions
    /// PCNTR1 Register bits
    namespace pcntr1_bits {
        constexpr uint32_t PDR00 = (1U << 0);  ///< Pmn Direction
        constexpr uint32_t PDR01 = (1U << 1);  ///< Pmn Direction
        constexpr uint32_t PDR02 = (1U << 2);  ///< Pmn Direction
        constexpr uint32_t PDR03 = (1U << 3);  ///< Pmn Direction
        constexpr uint32_t PDR04 = (1U << 4);  ///< Pmn Direction
        constexpr uint32_t PDR05 = (1U << 5);  ///< Pmn Direction
        constexpr uint32_t PDR06 = (1U << 6);  ///< Pmn Direction
        constexpr uint32_t PDR07 = (1U << 7);  ///< Pmn Direction
        constexpr uint32_t PDR08 = (1U << 8);  ///< Pmn Direction
        constexpr uint32_t PDR09 = (1U << 9);  ///< Pmn Direction
        constexpr uint32_t PDR10 = (1U << 10);  ///< Pmn Direction
        constexpr uint32_t PDR11 = (1U << 11);  ///< Pmn Direction
        constexpr uint32_t PDR12 = (1U << 12);  ///< Pmn Direction
        constexpr uint32_t PDR13 = (1U << 13);  ///< Pmn Direction
        constexpr uint32_t PDR14 = (1U << 14);  ///< Pmn Direction
        constexpr uint32_t PDR15 = (1U << 15);  ///< Pmn Direction
        constexpr uint32_t PODR00 = (1U << 16);  ///< Pmn Output Data
        constexpr uint32_t PODR01 = (1U << 17);  ///< Pmn Output Data
        constexpr uint32_t PODR02 = (1U << 18);  ///< Pmn Output Data
        constexpr uint32_t PODR03 = (1U << 19);  ///< Pmn Output Data
        constexpr uint32_t PODR04 = (1U << 20);  ///< Pmn Output Data
        constexpr uint32_t PODR05 = (1U << 21);  ///< Pmn Output Data
        constexpr uint32_t PODR06 = (1U << 22);  ///< Pmn Output Data
        constexpr uint32_t PODR07 = (1U << 23);  ///< Pmn Output Data
        constexpr uint32_t PODR08 = (1U << 24);  ///< Pmn Output Data
        constexpr uint32_t PODR09 = (1U << 25);  ///< Pmn Output Data
        constexpr uint32_t PODR10 = (1U << 26);  ///< Pmn Output Data
        constexpr uint32_t PODR11 = (1U << 27);  ///< Pmn Output Data
        constexpr uint32_t PODR12 = (1U << 28);  ///< Pmn Output Data
        constexpr uint32_t PODR13 = (1U << 29);  ///< Pmn Output Data
        constexpr uint32_t PODR14 = (1U << 30);  ///< Pmn Output Data
        constexpr uint32_t PODR15 = (1U << 31);  ///< Pmn Output Data
    }

    /// PODR Register bits
    namespace podr_bits {
        constexpr uint32_t PODR00 = (1U << 0);  ///< Pmn Output Data
        constexpr uint32_t PODR01 = (1U << 1);  ///< Pmn Output Data
        constexpr uint32_t PODR02 = (1U << 2);  ///< Pmn Output Data
        constexpr uint32_t PODR03 = (1U << 3);  ///< Pmn Output Data
        constexpr uint32_t PODR04 = (1U << 4);  ///< Pmn Output Data
        constexpr uint32_t PODR05 = (1U << 5);  ///< Pmn Output Data
        constexpr uint32_t PODR06 = (1U << 6);  ///< Pmn Output Data
        constexpr uint32_t PODR07 = (1U << 7);  ///< Pmn Output Data
        constexpr uint32_t PODR08 = (1U << 8);  ///< Pmn Output Data
        constexpr uint32_t PODR09 = (1U << 9);  ///< Pmn Output Data
        constexpr uint32_t PODR10 = (1U << 10);  ///< Pmn Output Data
        constexpr uint32_t PODR11 = (1U << 11);  ///< Pmn Output Data
        constexpr uint32_t PODR12 = (1U << 12);  ///< Pmn Output Data
        constexpr uint32_t PODR13 = (1U << 13);  ///< Pmn Output Data
        constexpr uint32_t PODR14 = (1U << 14);  ///< Pmn Output Data
        constexpr uint32_t PODR15 = (1U << 15);  ///< Pmn Output Data
    }

    /// PDR Register bits
    namespace pdr_bits {
        constexpr uint32_t PDR00 = (1U << 0);  ///< Pmn Direction
        constexpr uint32_t PDR01 = (1U << 1);  ///< Pmn Direction
        constexpr uint32_t PDR02 = (1U << 2);  ///< Pmn Direction
        constexpr uint32_t PDR03 = (1U << 3);  ///< Pmn Direction
        constexpr uint32_t PDR04 = (1U << 4);  ///< Pmn Direction
        constexpr uint32_t PDR05 = (1U << 5);  ///< Pmn Direction
        constexpr uint32_t PDR06 = (1U << 6);  ///< Pmn Direction
        constexpr uint32_t PDR07 = (1U << 7);  ///< Pmn Direction
        constexpr uint32_t PDR08 = (1U << 8);  ///< Pmn Direction
        constexpr uint32_t PDR09 = (1U << 9);  ///< Pmn Direction
        constexpr uint32_t PDR10 = (1U << 10);  ///< Pmn Direction
        constexpr uint32_t PDR11 = (1U << 11);  ///< Pmn Direction
        constexpr uint32_t PDR12 = (1U << 12);  ///< Pmn Direction
        constexpr uint32_t PDR13 = (1U << 13);  ///< Pmn Direction
        constexpr uint32_t PDR14 = (1U << 14);  ///< Pmn Direction
        constexpr uint32_t PDR15 = (1U << 15);  ///< Pmn Direction
    }

    /// PCNTR2 Register bits
    namespace pcntr2_bits {
        constexpr uint32_t PIDR00 = (1U << 0);  ///< Pmn State
        constexpr uint32_t PIDR01 = (1U << 1);  ///< Pmn State
        constexpr uint32_t PIDR02 = (1U << 2);  ///< Pmn State
        constexpr uint32_t PIDR03 = (1U << 3);  ///< Pmn State
        constexpr uint32_t PIDR04 = (1U << 4);  ///< Pmn State
        constexpr uint32_t PIDR05 = (1U << 5);  ///< Pmn State
        constexpr uint32_t PIDR06 = (1U << 6);  ///< Pmn State
        constexpr uint32_t PIDR07 = (1U << 7);  ///< Pmn State
        constexpr uint32_t PIDR08 = (1U << 8);  ///< Pmn State
        constexpr uint32_t PIDR09 = (1U << 9);  ///< Pmn State
        constexpr uint32_t PIDR10 = (1U << 10);  ///< Pmn State
        constexpr uint32_t PIDR11 = (1U << 11);  ///< Pmn State
        constexpr uint32_t PIDR12 = (1U << 12);  ///< Pmn State
        constexpr uint32_t PIDR13 = (1U << 13);  ///< Pmn State
        constexpr uint32_t PIDR14 = (1U << 14);  ///< Pmn State
        constexpr uint32_t PIDR15 = (1U << 15);  ///< Pmn State
    }

    /// PIDR Register bits
    namespace pidr_bits {
        constexpr uint32_t PIDR00 = (1U << 0);  ///< Pmn State
        constexpr uint32_t PIDR01 = (1U << 1);  ///< Pmn State
        constexpr uint32_t PIDR02 = (1U << 2);  ///< Pmn State
        constexpr uint32_t PIDR03 = (1U << 3);  ///< Pmn State
        constexpr uint32_t PIDR04 = (1U << 4);  ///< Pmn State
        constexpr uint32_t PIDR05 = (1U << 5);  ///< Pmn State
        constexpr uint32_t PIDR06 = (1U << 6);  ///< Pmn State
        constexpr uint32_t PIDR07 = (1U << 7);  ///< Pmn State
        constexpr uint32_t PIDR08 = (1U << 8);  ///< Pmn State
        constexpr uint32_t PIDR09 = (1U << 9);  ///< Pmn State
        constexpr uint32_t PIDR10 = (1U << 10);  ///< Pmn State
        constexpr uint32_t PIDR11 = (1U << 11);  ///< Pmn State
        constexpr uint32_t PIDR12 = (1U << 12);  ///< Pmn State
        constexpr uint32_t PIDR13 = (1U << 13);  ///< Pmn State
        constexpr uint32_t PIDR14 = (1U << 14);  ///< Pmn State
        constexpr uint32_t PIDR15 = (1U << 15);  ///< Pmn State
    }

    /// PCNTR3 Register bits
    namespace pcntr3_bits {
        constexpr uint32_t POSR00 = (1U << 0);  ///< Pmn Output Set
        constexpr uint32_t POSR01 = (1U << 1);  ///< Pmn Output Set
        constexpr uint32_t POSR02 = (1U << 2);  ///< Pmn Output Set
        constexpr uint32_t POSR03 = (1U << 3);  ///< Pmn Output Set
        constexpr uint32_t POSR04 = (1U << 4);  ///< Pmn Output Set
        constexpr uint32_t POSR05 = (1U << 5);  ///< Pmn Output Set
        constexpr uint32_t POSR06 = (1U << 6);  ///< Pmn Output Set
        constexpr uint32_t POSR07 = (1U << 7);  ///< Pmn Output Set
        constexpr uint32_t POSR08 = (1U << 8);  ///< Pmn Output Set
        constexpr uint32_t POSR09 = (1U << 9);  ///< Pmn Output Set
        constexpr uint32_t POSR10 = (1U << 10);  ///< Pmn Output Set
        constexpr uint32_t POSR11 = (1U << 11);  ///< Pmn Output Set
        constexpr uint32_t POSR12 = (1U << 12);  ///< Pmn Output Set
        constexpr uint32_t POSR13 = (1U << 13);  ///< Pmn Output Set
        constexpr uint32_t POSR14 = (1U << 14);  ///< Pmn Output Set
        constexpr uint32_t POSR15 = (1U << 15);  ///< Pmn Output Set
        constexpr uint32_t PORR00 = (1U << 16);  ///< Pmn Output Reset
        constexpr uint32_t PORR01 = (1U << 17);  ///< Pmn Output Reset
        constexpr uint32_t PORR02 = (1U << 18);  ///< Pmn Output Reset
        constexpr uint32_t PORR03 = (1U << 19);  ///< Pmn Output Reset
        constexpr uint32_t PORR04 = (1U << 20);  ///< Pmn Output Reset
        constexpr uint32_t PORR05 = (1U << 21);  ///< Pmn Output Reset
        constexpr uint32_t PORR06 = (1U << 22);  ///< Pmn Output Reset
        constexpr uint32_t PORR07 = (1U << 23);  ///< Pmn Output Reset
        constexpr uint32_t PORR08 = (1U << 24);  ///< Pmn Output Reset
        constexpr uint32_t PORR09 = (1U << 25);  ///< Pmn Output Reset
        constexpr uint32_t PORR10 = (1U << 26);  ///< Pmn Output Reset
        constexpr uint32_t PORR11 = (1U << 27);  ///< Pmn Output Reset
        constexpr uint32_t PORR12 = (1U << 28);  ///< Pmn Output Reset
        constexpr uint32_t PORR13 = (1U << 29);  ///< Pmn Output Reset
        constexpr uint32_t PORR14 = (1U << 30);  ///< Pmn Output Reset
        constexpr uint32_t PORR15 = (1U << 31);  ///< Pmn Output Reset
    }

    /// PORR Register bits
    namespace porr_bits {
        constexpr uint32_t PORR00 = (1U << 0);  ///< Pmn Output Reset
        constexpr uint32_t PORR01 = (1U << 1);  ///< Pmn Output Reset
        constexpr uint32_t PORR02 = (1U << 2);  ///< Pmn Output Reset
        constexpr uint32_t PORR03 = (1U << 3);  ///< Pmn Output Reset
        constexpr uint32_t PORR04 = (1U << 4);  ///< Pmn Output Reset
        constexpr uint32_t PORR05 = (1U << 5);  ///< Pmn Output Reset
        constexpr uint32_t PORR06 = (1U << 6);  ///< Pmn Output Reset
        constexpr uint32_t PORR07 = (1U << 7);  ///< Pmn Output Reset
        constexpr uint32_t PORR08 = (1U << 8);  ///< Pmn Output Reset
        constexpr uint32_t PORR09 = (1U << 9);  ///< Pmn Output Reset
        constexpr uint32_t PORR10 = (1U << 10);  ///< Pmn Output Reset
        constexpr uint32_t PORR11 = (1U << 11);  ///< Pmn Output Reset
        constexpr uint32_t PORR12 = (1U << 12);  ///< Pmn Output Reset
        constexpr uint32_t PORR13 = (1U << 13);  ///< Pmn Output Reset
        constexpr uint32_t PORR14 = (1U << 14);  ///< Pmn Output Reset
        constexpr uint32_t PORR15 = (1U << 15);  ///< Pmn Output Reset
    }

    /// POSR Register bits
    namespace posr_bits {
        constexpr uint32_t POSR00 = (1U << 0);  ///< Pmn Output Set
        constexpr uint32_t POSR01 = (1U << 1);  ///< Pmn Output Set
        constexpr uint32_t POSR02 = (1U << 2);  ///< Pmn Output Set
        constexpr uint32_t POSR03 = (1U << 3);  ///< Pmn Output Set
        constexpr uint32_t POSR04 = (1U << 4);  ///< Pmn Output Set
        constexpr uint32_t POSR05 = (1U << 5);  ///< Pmn Output Set
        constexpr uint32_t POSR06 = (1U << 6);  ///< Pmn Output Set
        constexpr uint32_t POSR07 = (1U << 7);  ///< Pmn Output Set
        constexpr uint32_t POSR08 = (1U << 8);  ///< Pmn Output Set
        constexpr uint32_t POSR09 = (1U << 9);  ///< Pmn Output Set
        constexpr uint32_t POSR10 = (1U << 10);  ///< Pmn Output Set
        constexpr uint32_t POSR11 = (1U << 11);  ///< Pmn Output Set
        constexpr uint32_t POSR12 = (1U << 12);  ///< Pmn Output Set
        constexpr uint32_t POSR13 = (1U << 13);  ///< Pmn Output Set
        constexpr uint32_t POSR14 = (1U << 14);  ///< Pmn Output Set
        constexpr uint32_t POSR15 = (1U << 15);  ///< Pmn Output Set
    }

}

// ============================================================================
// PFS Peripheral
// ============================================================================

namespace pfs {
    /// Base addresses
    constexpr uint32_t PFS_BASE = 0x40040800;

    /// PFS Register structure
    struct Registers {
        volatile uint32_t P0%sPFS;  ///< Offset: 0x38 - Port 0%s Pin Function Select Register
        volatile uint32_t P0%sPFS_HA;  ///< Offset: 0x3A - Port 0%s Pin Function Select Register
        volatile uint32_t P0%sPFS_BY;  ///< Offset: 0x3B - Port 0%s Pin Function Select Register
        volatile uint32_t P10%sPFS;  ///< Offset: 0x40 - Port 10%s Pin Function Select Register
        volatile uint32_t P10%sPFS_HA;  ///< Offset: 0x42 - Port 10%s Pin Function Select Register
        volatile uint32_t P10%sPFS_BY;  ///< Offset: 0x43 - Port 10%s Pin Function Select Register
        volatile uint32_t P108PFS;  ///< Offset: 0x60 - Port 108 Pin Function Select Register
        volatile uint32_t P108PFS_HA;  ///< Offset: 0x62 - Port 108 Pin Function Select Register
        volatile uint32_t P108PFS_BY;  ///< Offset: 0x63 - Port 108 Pin Function Select Register
        volatile uint32_t P109PFS;  ///< Offset: 0x64 - Port 109 Pin Function Select Register
        volatile uint32_t P109PFS_HA;  ///< Offset: 0x66 - Port 109 Pin Function Select Register
        volatile uint32_t P109PFS_BY;  ///< Offset: 0x67 - Port 109 Pin Function Select Register
        volatile uint32_t P1%sPFS;  ///< Offset: 0x68 - Port 1%s Pin Function Select Register
        volatile uint32_t P1%sPFS_HA;  ///< Offset: 0x6A - Port 1%s Pin Function Select Register
        volatile uint32_t P1%sPFS_BY;  ///< Offset: 0x6B - Port 1%s Pin Function Select Register
        volatile uint32_t P200PFS;  ///< Offset: 0x80 - Port 200 Pin Function Select Register
        volatile uint32_t P200PFS_HA;  ///< Offset: 0x82 - Port 200 Pin Function Select Register
        volatile uint32_t P200PFS_BY;  ///< Offset: 0x83 - Port 200 Pin Function Select Register
        volatile uint32_t P201PFS;  ///< Offset: 0x84 - Port 201 Pin Function Select Register
        volatile uint32_t P201PFS_HA;  ///< Offset: 0x86 - Port 201 Pin Function Select Register
        volatile uint32_t P201PFS_BY;  ///< Offset: 0x87 - Port 201 Pin Function Select Register
        volatile uint32_t P205PFS;  ///< Offset: 0x94 - Port 205 Pin Function Select Register
        volatile uint32_t P205PFS_HA;  ///< Offset: 0x96 - Port 205 Pin Function Select Register
        volatile uint32_t P205PFS_BY;  ///< Offset: 0x97 - Port 205 Pin Function Select Register
        volatile uint32_t P300PFS;  ///< Offset: 0xC0 - Port 300 Pin Function Select Register
        volatile uint32_t P300PFS_HA;  ///< Offset: 0xC2 - Port 300 Pin Function Select Register
        volatile uint32_t P300PFS_BY;  ///< Offset: 0xC3 - Port 300 Pin Function Select Register
        volatile uint32_t P40%sPFS;  ///< Offset: 0x100 - Port 40%s Pin Function Select Register
        volatile uint32_t P40%sPFS_HA;  ///< Offset: 0x102 - Port 40%s Pin Function Select Register
        volatile uint32_t P40%sPFS_BY;  ///< Offset: 0x103 - Port 40%s Pin Function Select Register
        volatile uint32_t P914PFS;  ///< Offset: 0x278 - Port 914 Pin Function Select Register
        volatile uint32_t P914PFS_HA;  ///< Offset: 0x27A - Port 914 Pin Function Select Register
        volatile uint32_t P914PFS_BY;  ///< Offset: 0x27B - Port 914 Pin Function Select Register
        volatile uint32_t PWPR;  ///< Offset: 0x503 - Write-Protect Register
        volatile uint32_t PRWCNTR;  ///< Offset: 0x50F - Port Read Wait Control Register
    };

    /// Peripheral instances
    inline Registers* PFS = reinterpret_cast<Registers*>(PFS_BASE);

    // Bit definitions
    /// P0%sPFS Register bits
    namespace p0%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P0%sPFS_HA Register bits
    namespace p0%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P0%sPFS_BY Register bits
    namespace p0%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P10%sPFS Register bits
    namespace p10%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P10%sPFS_HA Register bits
    namespace p10%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P10%sPFS_BY Register bits
    namespace p10%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P108PFS Register bits
    namespace p108pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P108PFS_HA Register bits
    namespace p108pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P108PFS_BY Register bits
    namespace p108pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P109PFS Register bits
    namespace p109pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P109PFS_HA Register bits
    namespace p109pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P109PFS_BY Register bits
    namespace p109pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P1%sPFS Register bits
    namespace p1%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P1%sPFS_HA Register bits
    namespace p1%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P1%sPFS_BY Register bits
    namespace p1%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P200PFS Register bits
    namespace p200pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P200PFS_HA Register bits
    namespace p200pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P200PFS_BY Register bits
    namespace p200pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P201PFS Register bits
    namespace p201pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P201PFS_HA Register bits
    namespace p201pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P201PFS_BY Register bits
    namespace p201pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P205PFS Register bits
    namespace p205pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P205PFS_HA Register bits
    namespace p205pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P205PFS_BY Register bits
    namespace p205pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P300PFS Register bits
    namespace p300pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P300PFS_HA Register bits
    namespace p300pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P300PFS_BY Register bits
    namespace p300pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P40%sPFS Register bits
    namespace p40%spfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P40%sPFS_HA Register bits
    namespace p40%spfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P40%sPFS_BY Register bits
    namespace p40%spfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// P914PFS Register bits
    namespace p914pfs_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t PSEL = (5 << 24);  ///< Peripheral Select
    }

    /// P914PFS_HA Register bits
    namespace p914pfs_ha_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ Input Enable
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input Enable
    }

    /// P914PFS_BY Register bits
    namespace p914pfs_by_bits {
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
        constexpr uint32_t PIDR = (1U << 1);  ///< Port State
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open-Drain Control
    }

    /// PWPR Register bits
    namespace pwpr_bits {
        constexpr uint32_t PFSWE = (1U << 6);  ///< PmnPFS Register Write Enable
        constexpr uint32_t B0WI = (1U << 7);  ///< PFSWE Bit Write Disable
    }

    /// PRWCNTR Register bits
    namespace prwcntr_bits {
        constexpr uint32_t WAIT = (2 << 0);  ///< Wait Cycle Control
    }

}

// ============================================================================
// ELC Peripheral
// ============================================================================

namespace elc {
    /// Base addresses
    constexpr uint32_t ELC_BASE = 0x40041000;

    /// ELC Register structure
    struct Registers {
        volatile uint32_t ELCR;  ///< Offset: 0x00 - Event Link Controller Register
        volatile uint32_t ELSEGR%s;  ///< Offset: 0x02 - Event Link Software Event Generation Register %s
        volatile uint32_t ELSR%s;  ///< Offset: 0x48 - Event Link Setting Register %s
    };

    /// Peripheral instances
    inline Registers* ELC = reinterpret_cast<Registers*>(ELC_BASE);

    // Bit definitions
    /// ELCR Register bits
    namespace elcr_bits {
        constexpr uint32_t ELCON = (1U << 7);  ///< All Event Link Enable
    }

    /// ELSEGR%s Register bits
    namespace elsegr%s_bits {
        constexpr uint32_t SEG = (1U << 0);  ///< Software Event Generation
        constexpr uint32_t WE = (1U << 6);  ///< SEG Bit Write Enable
        constexpr uint32_t WI = (1U << 7);  ///< ELSEGR Register Write Disable
    }

    /// ELSR%s Register bits
    namespace elsr%s_bits {
        constexpr uint32_t ELS = (8 << 0);  ///< Event Link Select
    }

}

// ============================================================================
// POEG Peripheral
// ============================================================================

namespace poeg {
    /// Base addresses
    constexpr uint32_t POEG_BASE = 0x40042000;

    /// POEG Register structure
    struct Registers {
        volatile uint32_t POEGGA;  ///< Offset: 0x00 - POEG Group A Setting Register
        volatile uint32_t POEGGB;  ///< Offset: 0x100 - POEG Group B Setting Register
    };

    /// Peripheral instances
    inline Registers* POEG = reinterpret_cast<Registers*>(POEG_BASE);

    // Bit definitions
    /// POEGGA Register bits
    namespace poegga_bits {
        constexpr uint32_t PIDF = (1U << 0);  ///< Port Input Detection Flag
        constexpr uint32_t IOCF = (1U << 1);  ///< Detection Flag for GPT Output-Disable Request
        constexpr uint32_t SSF = (1U << 3);  ///< Software Stop Flag
        constexpr uint32_t PIDE = (1U << 4);  ///< Port Input Detection Enable
        constexpr uint32_t IOCE = (1U << 5);  ///< Enable for GPT Output-Disable Request
        constexpr uint32_t ST = (1U << 16);  ///< GTETRGn Input Status Flag
        constexpr uint32_t INV = (1U << 28);  ///< GTETRGn Input Reverse
        constexpr uint32_t NFEN = (1U << 29);  ///< Noise Filter Enable
        constexpr uint32_t NFCS = (2 << 30);  ///< Noise Filter Clock Select
    }

    /// POEGGB Register bits
    namespace poeggb_bits {
        constexpr uint32_t PIDF = (1U << 0);  ///< Port Input Detection Flag
        constexpr uint32_t IOCF = (1U << 1);  ///< Detection Flag for GPT Output-Disable Request
        constexpr uint32_t SSF = (1U << 3);  ///< Software Stop Flag
        constexpr uint32_t PIDE = (1U << 4);  ///< Port Input Detection Enable
        constexpr uint32_t IOCE = (1U << 5);  ///< Enable for GPT Output-Disable Request
        constexpr uint32_t ST = (1U << 16);  ///< GTETRGn Input Status Flag
        constexpr uint32_t INV = (1U << 28);  ///< GTETRGn Input Reverse
        constexpr uint32_t NFEN = (1U << 29);  ///< Noise Filter Enable
        constexpr uint32_t NFCS = (2 << 30);  ///< Noise Filter Clock Select
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40044200;
    constexpr uint32_t IWDT_BASE = 0x40044400;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDTRR;  ///< Offset: 0x00 - WDT Refresh Register
        volatile uint32_t WDTCR;  ///< Offset: 0x02 - WDT Control Register
        volatile uint32_t WDTSR;  ///< Offset: 0x04 - WDT Status Register
        volatile uint32_t WDTRCR;  ///< Offset: 0x06 - WDT Reset Control Register
        volatile uint32_t WDTCSTPR;  ///< Offset: 0x08 - WDT Count Stop Control Register
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);
    inline Registers* IWDT = reinterpret_cast<Registers*>(IWDT_BASE);

    // Bit definitions
    /// WDTCR Register bits
    namespace wdtcr_bits {
        constexpr uint32_t TOPS = (2 << 0);  ///< Timeout Period Select
        constexpr uint32_t CKS = (4 << 4);  ///< Clock Division Ratio Select
        constexpr uint32_t RPES = (2 << 8);  ///< Window End Position Select
        constexpr uint32_t RPSS = (2 << 12);  ///< Window Start Position Select
    }

    /// WDTSR Register bits
    namespace wdtsr_bits {
        constexpr uint32_t CNTVAL = (14 << 0);  ///< Down-Counter Value
        constexpr uint32_t UNDFF = (1U << 14);  ///< Underflow Flag
        constexpr uint32_t REFEF = (1U << 15);  ///< Refresh Error Flag
    }

    /// WDTRCR Register bits
    namespace wdtrcr_bits {
        constexpr uint32_t RSTIRQS = (1U << 7);  ///< WDT Behavior Selection
    }

    /// WDTCSTPR Register bits
    namespace wdtcstpr_bits {
        constexpr uint32_t SLCSTP = (1U << 7);  ///< Sleep-Mode Count Stop Control Register
    }

}

// ============================================================================
// CAC Peripheral
// ============================================================================

namespace cac {
    /// Base addresses
    constexpr uint32_t CAC_BASE = 0x40044600;

    /// CAC Register structure
    struct Registers {
        volatile uint32_t CACR0;  ///< Offset: 0x00 - CAC Control Register 0
        volatile uint32_t CACR1;  ///< Offset: 0x01 - CAC Control Register 1
        volatile uint32_t CACR2;  ///< Offset: 0x02 - CAC Control Register 2
        volatile uint32_t CAICR;  ///< Offset: 0x03 - CAC Interrupt Control Register
        volatile uint32_t CASTR;  ///< Offset: 0x04 - CAC Status Register
        volatile uint32_t CAULVR;  ///< Offset: 0x06 - CAC Upper-Limit Value Setting Register
        volatile uint32_t CALLVR;  ///< Offset: 0x08 - CAC Lower-Limit Value Setting Register
        volatile uint32_t CACNTBR;  ///< Offset: 0x0A - CAC Counter Buffer Register
    };

    /// Peripheral instances
    inline Registers* CAC = reinterpret_cast<Registers*>(CAC_BASE);

    // Bit definitions
    /// CACR0 Register bits
    namespace cacr0_bits {
        constexpr uint32_t CFME = (1U << 0);  ///< Clock Frequency Measurement Enable
    }

    /// CACR1 Register bits
    namespace cacr1_bits {
        constexpr uint32_t CACREFE = (1U << 0);  ///< CACREF Pin Input Enable
        constexpr uint32_t FMCS = (3 << 1);  ///< Measurement Target Clock Select
        constexpr uint32_t TCSS = (2 << 4);  ///< Timer Count Clock Source Select
        constexpr uint32_t EDGES = (2 << 6);  ///< Valid Edge Select
    }

    /// CACR2 Register bits
    namespace cacr2_bits {
        constexpr uint32_t RPS = (1U << 0);  ///< Reference Signal Select
        constexpr uint32_t RSCS = (3 << 1);  ///< Measurement Reference Clock Select
        constexpr uint32_t RCDS = (2 << 4);  ///< Measurement Reference Clock Frequency Division Ratio Select
        constexpr uint32_t DFS = (2 << 6);  ///< Digital Filter Select
    }

    /// CAICR Register bits
    namespace caicr_bits {
        constexpr uint32_t FERRIE = (1U << 0);  ///< Frequency Error Interrupt Request Enable
        constexpr uint32_t MENDIE = (1U << 1);  ///< Measurement End Interrupt Request Enable
        constexpr uint32_t OVFIE = (1U << 2);  ///< Overflow Interrupt Request Enable
        constexpr uint32_t FERRFCL = (1U << 4);  ///< FERRF Clear
        constexpr uint32_t MENDFCL = (1U << 5);  ///< MENDF Clear
        constexpr uint32_t OVFFCL = (1U << 6);  ///< OVFF Clear
    }

    /// CASTR Register bits
    namespace castr_bits {
        constexpr uint32_t FERRF = (1U << 0);  ///< Frequency Error Flag
        constexpr uint32_t MENDF = (1U << 1);  ///< Measurement End Flag
        constexpr uint32_t OVFF = (1U << 2);  ///< Overflow Flag
    }

}

// ============================================================================
// MSTP Peripheral
// ============================================================================

namespace mstp {
    /// Base addresses
    constexpr uint32_t MSTP_BASE = 0x40047000;

    /// MSTP Register structure
    struct Registers {
        volatile uint32_t MSTPCRB;  ///< Offset: 0x00 - Module Stop Control Register B
        volatile uint32_t MSTPCRC;  ///< Offset: 0x04 - Module Stop Control Register C
        volatile uint32_t MSTPCRD;  ///< Offset: 0x08 - Module Stop Control Register D
        volatile uint32_t LSMRWDIS;  ///< Offset: 0x0C - Low Speed Module R/W Disable Control Register
    };

    /// Peripheral instances
    inline Registers* MSTP = reinterpret_cast<Registers*>(MSTP_BASE);

    // Bit definitions
    /// MSTPCRB Register bits
    namespace mstpcrb_bits {
        constexpr uint32_t MSTPB9 = (1U << 9);  ///< IIC/I3C Bus Interface 0 Module Stop
        constexpr uint32_t MSTPB19 = (1U << 19);  ///< Serial Peripheral Interface 0 Module Stop
        constexpr uint32_t MSTPB22 = (1U << 22);  ///< Serial Communication Interface 9 Module Stop
    }

    /// MSTPCRC Register bits
    namespace mstpcrc_bits {
        constexpr uint32_t MSTPC0 = (1U << 0);  ///< Clock Frequency Accuracy Measurement Circuit Module Stop
        constexpr uint32_t MSTPC1 = (1U << 1);  ///< Cyclic Redundancy Check Calculator Module Stop
        constexpr uint32_t MSTPC13 = (1U << 13);  ///< Data Operation Circuit Module Stop
        constexpr uint32_t MSTPC14 = (1U << 14);  ///< Event Link Controller Module Stop
        constexpr uint32_t MSTPC28 = (1U << 28);  ///< True Random Number Generator Module Stop
        constexpr uint32_t MSTPC31 = (1U << 31);  ///< AES Module Stop
    }

    /// MSTPCRD Register bits
    namespace mstpcrd_bits {
        constexpr uint32_t MSTPD2 = (1U << 2);  ///< Low Power Asynchronous General Purpose Timer 1 Module Stop
        constexpr uint32_t MSTPD3 = (1U << 3);  ///< Low Power Asynchronous General Purpose Timer 0 Module Stop
        constexpr uint32_t MSTPD6 = (1U << 6);  ///< General PWM Timer 164 to 169 and PWM Delay Generation Circuit Module Stop
        constexpr uint32_t MSTPD14 = (1U << 14);  ///< Port Output Enable for GPT Module Stop
        constexpr uint32_t MSTPD16 = (1U << 16);  ///< 12-bit A/D Converter Module Stop
    }

    /// LSMRWDIS Register bits
    namespace lsmrwdis_bits {
        constexpr uint32_t WDTDIS = (1U << 1);  ///< WDT Operate Clock Control
        constexpr uint32_t IWDTIDS = (1U << 2);  ///< IWDT Register Clock Control
        constexpr uint32_t WREN = (1U << 7);  ///< Write Enable for bits [2:0]
        constexpr uint32_t PRKEY = (8 << 8);  ///< LSMRWDIS Key Code
    }

}

// ============================================================================
// DOC Peripheral
// ============================================================================

namespace doc {
    /// Base addresses
    constexpr uint32_t DOC_BASE = 0x40054100;

    /// DOC Register structure
    struct Registers {
        volatile uint32_t DOCR;  ///< Offset: 0x00 - DOC Control Register
        volatile uint32_t DODIR;  ///< Offset: 0x02 - DOC Data Input Register
        volatile uint32_t DODSR;  ///< Offset: 0x04 - DOC Data Setting Register
    };

    /// Peripheral instances
    inline Registers* DOC = reinterpret_cast<Registers*>(DOC_BASE);

    // Bit definitions
    /// DOCR Register bits
    namespace docr_bits {
        constexpr uint32_t OMS = (2 << 0);  ///< Operating Mode Select
        constexpr uint32_t DCSEL = (1U << 2);  ///< Detection Condition Select
        constexpr uint32_t DOPCF = (1U << 5);  ///< DOC Flag
        constexpr uint32_t DOPCFCL = (1U << 6);  ///< DOPCF Clear
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC120_BASE = 0x4005C000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADCSR;  ///< Offset: 0x00 - A/D Control Register
        volatile uint32_t ADANSA0;  ///< Offset: 0x04 - A/D Channel Select Register A0
        volatile uint32_t ADANSA1;  ///< Offset: 0x06 - A/D Channel Select Register A1
        volatile uint32_t ADADS0;  ///< Offset: 0x08 - A/D-Converted Value Addition/Average Channel Select Register 0
        volatile uint32_t ADADS1;  ///< Offset: 0x0A - A/D-Converted Value Addition/Average Channel Select Register 1
        volatile uint32_t ADADC;  ///< Offset: 0x0C - A/D-Converted Value Addition/Average Count Select Register
        volatile uint32_t ADCER;  ///< Offset: 0x0E - A/D Control Extended Register
        volatile uint32_t ADSTRGR;  ///< Offset: 0x10 - A/D Conversion Start Trigger Select Register
        volatile uint32_t ADEXICR;  ///< Offset: 0x12 - A/D Conversion Extended Input Control Registers
        volatile uint32_t ADANSB0;  ///< Offset: 0x14 - A/D Channel Select Register B0
        volatile uint32_t ADANSB1;  ///< Offset: 0x16 - A/D Channel Select Register B1
        volatile uint32_t ADDBLDR;  ///< Offset: 0x18 - A/D Data Duplexing Register
        volatile uint32_t ADTSDR;  ///< Offset: 0x1A - A/D Temperature Sensor Data Register
        volatile uint32_t ADOCDR;  ///< Offset: 0x1C - A/D Internal Reference Voltage Data Register
        volatile uint32_t ADRD;  ///< Offset: 0x1E - A/D Self-Diagnosis Data Register
        volatile uint32_t ADDR%s;  ///< Offset: 0x46 - A/D Data Registers %s
        volatile uint32_t ADDISCR;  ///< Offset: 0x7A - A/D Disconnection Detection Control Register
        volatile uint32_t ADACSR;  ///< Offset: 0x7E - A/D Conversion Operation Mode Select Register
        volatile uint32_t ADGSPCR;  ///< Offset: 0x80 - A/D Group Scan Priority Control Register
        volatile uint32_t ADDBLDRA;  ///< Offset: 0x84 - A/D Data Duplexing Register A
        volatile uint32_t ADDBLDRB;  ///< Offset: 0x86 - A/D Data Duplexing Register B
        volatile uint32_t ADHVREFCNT;  ///< Offset: 0x8A - A/D High-Potential/Low-Potential Reference Voltage...
        volatile uint32_t ADWINMON;  ///< Offset: 0x8C - A/D Compare Function Window A/B Status Monitor Register
        volatile uint32_t ADCMPCR;  ///< Offset: 0x90 - A/D Compare Function Control Register
        volatile uint32_t ADCMPANSER;  ///< Offset: 0x92 - A/D Compare Function Window A Extended Input Select Register
        volatile uint32_t ADCMPLER;  ///< Offset: 0x93 - A/D Compare Function Window A Extended Input Comparison...
        volatile uint32_t ADCMPANSR0;  ///< Offset: 0x94 - A/D Compare Function Window A Channel Select Register 0
        volatile uint32_t ADCMPANSR1;  ///< Offset: 0x96 - A/D Compare Function Window A Channel Select Register 1
        volatile uint32_t ADCMPLR0;  ///< Offset: 0x98 - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPLR1;  ///< Offset: 0x9A - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPDR%s;  ///< Offset: 0x9C - A/D Compare Function Window A Lower-Side/Upper-Side...
        volatile uint32_t ADCMPSR0;  ///< Offset: 0xA0 - A/D Compare Function Window A Channel Status Register 0
        volatile uint32_t ADCMPSR1;  ///< Offset: 0xA2 - A/D Compare Function Window A Channel Status Register1
        volatile uint32_t ADCMPSER;  ///< Offset: 0xA4 - A/D Compare Function Window A Extended Input Channel...
        volatile uint32_t ADCMPBNSR;  ///< Offset: 0xA6 - A/D Compare Function Window B Channel Select Register
        volatile uint32_t ADWINLLB;  ///< Offset: 0xA8 - A/D Compare Function Window B Lower-Side/Upper-Side...
        volatile uint32_t ADWINULB;  ///< Offset: 0xAA - A/D Compare Function Window B Lower-Side/Upper-Side...
        volatile uint32_t ADCMPBSR;  ///< Offset: 0xAC - A/D Compare Function Window B Status Register
        volatile uint32_t ADSSTRL;  ///< Offset: 0xDD - A/D Sampling State Register
        volatile uint32_t ADSSTRT;  ///< Offset: 0xDE - A/D Sampling State Register
        volatile uint32_t ADSSTRO;  ///< Offset: 0xDF - A/D Sampling State Register
        volatile uint32_t ADSSTR%s;  ///< Offset: 0xE9 - A/D Sampling State Register
    };

    /// Peripheral instances
    inline Registers* ADC120 = reinterpret_cast<Registers*>(ADC120_BASE);

    // Bit definitions
    /// ADCSR Register bits
    namespace adcsr_bits {
        constexpr uint32_t DBLANS = (5 << 0);  ///< Double Trigger Channel Select
        constexpr uint32_t GBADIE = (1U << 6);  ///< Group B Scan End Interrupt and ELC Event Enable
        constexpr uint32_t DBLE = (1U << 7);  ///< Double Trigger Mode Select
        constexpr uint32_t EXTRG = (1U << 8);  ///< Trigger Select
        constexpr uint32_t TRGE = (1U << 9);  ///< Trigger Start Enable
        constexpr uint32_t ADHSC = (1U << 10);  ///< A/D Conversion Mode Select
        constexpr uint32_t ADCS = (2 << 13);  ///< Scan Mode Select
        constexpr uint32_t ADST = (1U << 15);  ///< A/D Conversion Start
    }

    /// ADANSA0 Register bits
    namespace adansa0_bits {
        constexpr uint32_t ANSA00 = (1U << 0);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA01 = (1U << 1);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA02 = (1U << 2);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA03 = (1U << 3);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA04 = (1U << 4);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA05 = (1U << 5);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA06 = (1U << 6);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA07 = (1U << 7);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA08 = (1U << 8);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA09 = (1U << 9);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA10 = (1U << 10);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA11 = (1U << 11);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA12 = (1U << 12);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA13 = (1U << 13);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA14 = (1U << 14);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA15 = (1U << 15);  ///< A/D Conversion Channels Select
    }

    /// ADANSA1 Register bits
    namespace adansa1_bits {
        constexpr uint32_t ANSA16 = (1U << 0);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA17 = (1U << 1);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA18 = (1U << 2);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA19 = (1U << 3);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA20 = (1U << 4);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA21 = (1U << 5);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA22 = (1U << 6);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA23 = (1U << 7);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA24 = (1U << 8);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA25 = (1U << 9);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA26 = (1U << 10);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA27 = (1U << 11);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA28 = (1U << 12);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA29 = (1U << 13);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA30 = (1U << 14);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSA31 = (1U << 15);  ///< A/D Conversion Channels Select
    }

    /// ADADS0 Register bits
    namespace adads0_bits {
        constexpr uint32_t ADS00 = (1U << 0);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS01 = (1U << 1);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS02 = (1U << 2);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS03 = (1U << 3);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS04 = (1U << 4);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS05 = (1U << 5);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS06 = (1U << 6);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS07 = (1U << 7);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS08 = (1U << 8);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS09 = (1U << 9);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS10 = (1U << 10);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS11 = (1U << 11);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS12 = (1U << 12);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS13 = (1U << 13);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS14 = (1U << 14);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS15 = (1U << 15);  ///< A/D-Converted Value Addition/Average Channel Select
    }

    /// ADADS1 Register bits
    namespace adads1_bits {
        constexpr uint32_t ADS16 = (1U << 0);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS17 = (1U << 1);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS18 = (1U << 2);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS19 = (1U << 3);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS20 = (1U << 4);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS21 = (1U << 5);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS22 = (1U << 6);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS23 = (1U << 7);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS24 = (1U << 8);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS25 = (1U << 9);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS26 = (1U << 10);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS27 = (1U << 11);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS28 = (1U << 12);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS29 = (1U << 13);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS30 = (1U << 14);  ///< A/D-Converted Value Addition/Average Channel Select
        constexpr uint32_t ADS31 = (1U << 15);  ///< A/D-Converted Value Addition/Average Channel Select
    }

    /// ADADC Register bits
    namespace adadc_bits {
        constexpr uint32_t ADC = (3 << 0);  ///< Addition/Average Count Select
        constexpr uint32_t AVEE = (1U << 7);  ///< Average Mode Select
    }

    /// ADCER Register bits
    namespace adcer_bits {
        constexpr uint32_t ACE = (1U << 5);  ///< A/D Data Register Automatic Clearing Enable
        constexpr uint32_t DIAGVAL = (2 << 8);  ///< Self-Diagnosis Conversion Voltage Select
        constexpr uint32_t DIAGLD = (1U << 10);  ///< Self-Diagnosis Mode Select
        constexpr uint32_t DIAGM = (1U << 11);  ///< Self-Diagnosis Enable
        constexpr uint32_t ADRFMT = (1U << 15);  ///< A/D Data Register Format Select
    }

    /// ADSTRGR Register bits
    namespace adstrgr_bits {
        constexpr uint32_t TRSB = (6 << 0);  ///< A/D Conversion Start Trigger Select for Group B
        constexpr uint32_t TRSA = (6 << 8);  ///< A/D Conversion Start Trigger Select
    }

    /// ADEXICR Register bits
    namespace adexicr_bits {
        constexpr uint32_t TSSAD = (1U << 0);  ///< Temperature Sensor Output A/D-Converted Value Addition/Average Mode Select
        constexpr uint32_t OCSAD = (1U << 1);  ///< Internal Reference Voltage A/D-Converted Value Addition/Average Mode Select
        constexpr uint32_t TSSA = (1U << 8);  ///< Temperature Sensor Output A/D Conversion Select
        constexpr uint32_t OCSA = (1U << 9);  ///< Internal Reference Voltage A/D Conversion Select
    }

    /// ADANSB0 Register bits
    namespace adansb0_bits {
        constexpr uint32_t ANSB00 = (1U << 0);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB01 = (1U << 1);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB02 = (1U << 2);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB03 = (1U << 3);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB04 = (1U << 4);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB05 = (1U << 5);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB06 = (1U << 6);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB07 = (1U << 7);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB08 = (1U << 8);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB09 = (1U << 9);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB10 = (1U << 10);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB11 = (1U << 11);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB12 = (1U << 12);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB13 = (1U << 13);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB14 = (1U << 14);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB15 = (1U << 15);  ///< A/D Conversion Channels Select
    }

    /// ADANSB1 Register bits
    namespace adansb1_bits {
        constexpr uint32_t ANSB16 = (1U << 0);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB17 = (1U << 1);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB18 = (1U << 2);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB19 = (1U << 3);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB20 = (1U << 4);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB21 = (1U << 5);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB22 = (1U << 6);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB23 = (1U << 7);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB24 = (1U << 8);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB25 = (1U << 9);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB26 = (1U << 10);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB27 = (1U << 11);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB28 = (1U << 12);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB29 = (1U << 13);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB30 = (1U << 14);  ///< A/D Conversion Channels Select
        constexpr uint32_t ANSB31 = (1U << 15);  ///< A/D Conversion Channels Select
    }

    /// ADDBLDR Register bits
    namespace addbldr_bits {
        constexpr uint32_t ADDBLDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADTSDR Register bits
    namespace adtsdr_bits {
        constexpr uint32_t ADTSDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADOCDR Register bits
    namespace adocdr_bits {
        constexpr uint32_t ADOCDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADRD Register bits
    namespace adrd_bits {
        constexpr uint32_t AD = (12 << 0);  ///< Converted Value 11 to 0
        constexpr uint32_t DIAGST = (2 << 14);  ///< Self-Diagnosis Status
    }

    /// ADDR%s Register bits
    namespace addr%s_bits {
        constexpr uint32_t ADDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADDISCR Register bits
    namespace addiscr_bits {
        constexpr uint32_t ADNDIS = (4 << 0);  ///< Disconnection Detection Assist Setting
        constexpr uint32_t PCHG = (1U << 4);  ///< Precharge/discharge select
    }

    /// ADACSR Register bits
    namespace adacsr_bits {
        constexpr uint32_t ADSAC = (1U << 1);  ///< Successive Approximation Control Setting
    }

    /// ADGSPCR Register bits
    namespace adgspcr_bits {
        constexpr uint32_t PGS = (1U << 0);  ///< Group Priority Operation Setting
        constexpr uint32_t GBRSCN = (1U << 1);  ///< Lower-Priority Group Restart Setting
        constexpr uint32_t GBRP = (1U << 15);  ///< Single Scan Continuous Start
    }

    /// ADDBLDRA Register bits
    namespace addbldra_bits {
        constexpr uint32_t ADDBLDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADDBLDRB Register bits
    namespace addbldrb_bits {
        constexpr uint32_t ADDBLDR = (16 << 0);  ///< Converted Value 15 to 0
    }

    /// ADHVREFCNT Register bits
    namespace adhvrefcnt_bits {
        constexpr uint32_t HVSEL = (2 << 0);  ///< High-Potential Reference Voltage Select
        constexpr uint32_t LVSEL = (1U << 4);  ///< Low-Potential Reference Voltage Select
        constexpr uint32_t ADSLP = (1U << 7);  ///< Sleep
    }

    /// ADWINMON Register bits
    namespace adwinmon_bits {
        constexpr uint32_t MONCOMB = (1U << 0);  ///< Combination Result Monitor
        constexpr uint32_t MONCMPA = (1U << 4);  ///< Comparison Result Monitor A
        constexpr uint32_t MONCMPB = (1U << 5);  ///< Comparison Result Monitor B
    }

    /// ADCMPCR Register bits
    namespace adcmpcr_bits {
        constexpr uint32_t CMPAB = (2 << 0);  ///< Window A/B Composite Conditions Setting
        constexpr uint32_t CMPBE = (1U << 9);  ///< Compare Window B Operation Enable
        constexpr uint32_t CMPAE = (1U << 11);  ///< Compare Window A Operation Enable
        constexpr uint32_t CMPBIE = (1U << 13);  ///< Compare B Interrupt Enable
        constexpr uint32_t WCMPE = (1U << 14);  ///< Window Function Setting
        constexpr uint32_t CMPAIE = (1U << 15);  ///< Compare A Interrupt Enable
    }

    /// ADCMPANSER Register bits
    namespace adcmpanser_bits {
        constexpr uint32_t CMPTSA = (1U << 0);  ///< Temperature Sensor Output Compare Select
        constexpr uint32_t CMPOCA = (1U << 1);  ///< Internal Reference Voltage Compare Select
    }

    /// ADCMPLER Register bits
    namespace adcmpler_bits {
        constexpr uint32_t CMPLTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Comparison Condition Select
        constexpr uint32_t CMPLOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage Comparison Condition Select
    }

    /// ADCMPANSR0 Register bits
    namespace adcmpansr0_bits {
        constexpr uint32_t CMPCHA00 = (1U << 0);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA01 = (1U << 1);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA02 = (1U << 2);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA03 = (1U << 3);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA04 = (1U << 4);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA05 = (1U << 5);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA06 = (1U << 6);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA07 = (1U << 7);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA08 = (1U << 8);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA09 = (1U << 9);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA10 = (1U << 10);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA11 = (1U << 11);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA12 = (1U << 12);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA13 = (1U << 13);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA14 = (1U << 14);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA15 = (1U << 15);  ///< Compare Window A Channel Select
    }

    /// ADCMPANSR1 Register bits
    namespace adcmpansr1_bits {
        constexpr uint32_t CMPCHA16 = (1U << 0);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA17 = (1U << 1);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA18 = (1U << 2);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA19 = (1U << 3);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA20 = (1U << 4);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA21 = (1U << 5);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA22 = (1U << 6);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA23 = (1U << 7);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA24 = (1U << 8);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA25 = (1U << 9);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA26 = (1U << 10);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA27 = (1U << 11);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA28 = (1U << 12);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA29 = (1U << 13);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA30 = (1U << 14);  ///< Compare Window A Channel Select
        constexpr uint32_t CMPCHA31 = (1U << 15);  ///< Compare Window A Channel Select
    }

    /// ADCMPLR0 Register bits
    namespace adcmplr0_bits {
        constexpr uint32_t CMPLCHA00 = (1U << 0);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA01 = (1U << 1);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA02 = (1U << 2);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA03 = (1U << 3);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA04 = (1U << 4);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA05 = (1U << 5);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA06 = (1U << 6);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA07 = (1U << 7);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA08 = (1U << 8);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA09 = (1U << 9);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA10 = (1U << 10);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA11 = (1U << 11);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA12 = (1U << 12);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA13 = (1U << 13);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA14 = (1U << 14);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA15 = (1U << 15);  ///< Compare Window A Comparison Condition Select
    }

    /// ADCMPLR1 Register bits
    namespace adcmplr1_bits {
        constexpr uint32_t CMPLCHA16 = (1U << 0);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA17 = (1U << 1);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA18 = (1U << 2);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA19 = (1U << 3);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA20 = (1U << 4);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA21 = (1U << 5);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA22 = (1U << 6);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA23 = (1U << 7);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA24 = (1U << 8);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA25 = (1U << 9);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA26 = (1U << 10);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA27 = (1U << 11);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA28 = (1U << 12);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA29 = (1U << 13);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA30 = (1U << 14);  ///< Compare Window A Comparison Condition Select
        constexpr uint32_t CMPLCHA31 = (1U << 15);  ///< Compare Window A Comparison Condition Select
    }

    /// ADCMPSR0 Register bits
    namespace adcmpsr0_bits {
        constexpr uint32_t CMPSTCHA00 = (1U << 0);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA01 = (1U << 1);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA02 = (1U << 2);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA03 = (1U << 3);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA04 = (1U << 4);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA05 = (1U << 5);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA06 = (1U << 6);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA07 = (1U << 7);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA08 = (1U << 8);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA09 = (1U << 9);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA10 = (1U << 10);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA11 = (1U << 11);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA12 = (1U << 12);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA13 = (1U << 13);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA14 = (1U << 14);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA15 = (1U << 15);  ///< Compare Window A Flag
    }

    /// ADCMPSR1 Register bits
    namespace adcmpsr1_bits {
        constexpr uint32_t CMPSTCHA16 = (1U << 0);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA17 = (1U << 1);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA18 = (1U << 2);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA19 = (1U << 3);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA20 = (1U << 4);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA21 = (1U << 5);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA22 = (1U << 6);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA23 = (1U << 7);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA24 = (1U << 8);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA25 = (1U << 9);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA26 = (1U << 10);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA27 = (1U << 11);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA28 = (1U << 12);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA29 = (1U << 13);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA30 = (1U << 14);  ///< Compare Window A Flag
        constexpr uint32_t CMPSTCHA31 = (1U << 15);  ///< Compare Window A Flag
    }

    /// ADCMPSER Register bits
    namespace adcmpser_bits {
        constexpr uint32_t CMPSTTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Compare Flag
        constexpr uint32_t CMPSTOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage Compare Flag
    }

    /// ADCMPBNSR Register bits
    namespace adcmpbnsr_bits {
        constexpr uint32_t CMPCHB = (6 << 0);  ///< Compare Window B Channel Select
        constexpr uint32_t CMPLB = (1U << 7);  ///< Compare Window B Comparison Condition Setting
    }

    /// ADCMPBSR Register bits
    namespace adcmpbsr_bits {
        constexpr uint32_t CMPSTB = (1U << 0);  ///< Compare Window B Flag
    }

    /// ADSSTRL Register bits
    namespace adsstrl_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting
    }

    /// ADSSTRT Register bits
    namespace adsstrt_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting
    }

    /// ADSSTRO Register bits
    namespace adsstro_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting
    }

    /// ADSSTR%s Register bits
    namespace adsstr%s_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting
    }

}

// ============================================================================
// SCI9 Peripheral
// ============================================================================

namespace sci9 {
    /// Base addresses
    constexpr uint32_t SCI9_BASE = 0x40070120;

    /// SCI9 Register structure
    struct Registers {
        volatile uint32_t SMR;  ///< Offset: 0x00 - Serial Mode Register for Non-Smart Card Interface Mode...
        volatile uint32_t SMR_SMCI;  ///< Offset: 0x00 - Serial Mode Register for Smart Card Interface Mode...
        volatile uint32_t BRR;  ///< Offset: 0x01 - Bit Rate Register
        volatile uint32_t SCR;  ///< Offset: 0x02 - Serial Control Register for Non-Smart Card Interface...
        volatile uint32_t SCR_SMCI;  ///< Offset: 0x02 - Serial Control Register for Smart Card Interface Mode...
        volatile uint32_t TDR;  ///< Offset: 0x03 - Transmit Data Register
        volatile uint32_t SSR;  ///< Offset: 0x04 - Serial Status Register for Non-Smart Card Interface...
        volatile uint32_t SSR_SMCI;  ///< Offset: 0x04 - Serial Status Register for Smart Card Interface Mode...
        volatile uint32_t RDR;  ///< Offset: 0x05 - Receive Data Register
        volatile uint32_t SCMR;  ///< Offset: 0x06 - Smart Card Mode Register
        volatile uint32_t SEMR;  ///< Offset: 0x07 - Serial Extended Mode Register
        volatile uint32_t SNFR;  ///< Offset: 0x08 - Noise Filter Setting Register
        volatile uint32_t SIMR1;  ///< Offset: 0x09 - IIC Mode Register 1
        volatile uint32_t SIMR2;  ///< Offset: 0x0A - IIC Mode Register 2
        volatile uint32_t SIMR3;  ///< Offset: 0x0B - IIC Mode Register 3
        volatile uint32_t SISR;  ///< Offset: 0x0C - IIC Status Register
        volatile uint32_t SPMR;  ///< Offset: 0x0D - SPI Mode Register
        volatile uint32_t TDRHL;  ///< Offset: 0x0E - Transmit Data Register
        volatile uint32_t RDRHL;  ///< Offset: 0x10 - Receive Data Register
        volatile uint32_t MDDR;  ///< Offset: 0x12 - Modulation Duty Register
        volatile uint32_t DCCR;  ///< Offset: 0x13 - Data Compare Match Control Register
        volatile uint32_t CDR;  ///< Offset: 0x1A - Compare Match Data Register
        volatile uint32_t SPTR;  ///< Offset: 0x1C - Serial Port Register
    };

    /// Peripheral instances
    inline Registers* SCI9 = reinterpret_cast<Registers*>(SCI9_BASE);

    // Bit definitions
    /// SMR Register bits
    namespace smr_bits {
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
        constexpr uint32_t MP = (1U << 2);  ///< Multi-Processor Mode
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Bit Length
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable
        constexpr uint32_t CHR = (1U << 6);  ///< Character Length
        constexpr uint32_t CM = (1U << 7);  ///< Communication Mode
    }

    /// SMR_SMCI Register bits
    namespace smr_smci_bits {
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
        constexpr uint32_t BCP = (2 << 2);  ///< Base Clock Pulse
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable
        constexpr uint32_t BLK = (1U << 6);  ///< Block Transfer Mode
        constexpr uint32_t GM = (1U << 7);  ///< GSM Mode
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
    }

    /// SCR_SMCI Register bits
    namespace scr_smci_bits {
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SSR_SMCI Register bits
    namespace ssr_smci_bits {
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t ERS = (1U << 4);  ///< Error Signal Status Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
    }

    /// SCMR Register bits
    namespace scmr_bits {
        constexpr uint32_t SMIF = (1U << 0);  ///< Smart Card Interface Mode Select
        constexpr uint32_t SINV = (1U << 2);  ///< Transmitted/Received Data Invert
        constexpr uint32_t SDIR = (1U << 3);  ///< Transmitted/Received Data Transfer Direction
        constexpr uint32_t CHR1 = (1U << 4);  ///< Character Length 1
        constexpr uint32_t BCP2 = (1U << 7);  ///< Base Clock Pulse 2
    }

    /// SEMR Register bits
    namespace semr_bits {
        constexpr uint32_t BRME = (1U << 2);  ///< Bit Rate Modulation Enable
        constexpr uint32_t ABCSE = (1U << 3);  ///< Asynchronous Mode Extended Base Clock Select 1
        constexpr uint32_t ABCS = (1U << 4);  ///< Asynchronous Mode Base Clock Select
        constexpr uint32_t NFEN = (1U << 5);  ///< Digital Noise Filter Function Enable
        constexpr uint32_t BGDM = (1U << 6);  ///< Baud Rate Generator Double-Speed Mode Select
        constexpr uint32_t RXDESEL = (1U << 7);  ///< Asynchronous Start Bit Edge Detection Select
    }

    /// SNFR Register bits
    namespace snfr_bits {
        constexpr uint32_t NFCS = (3 << 0);  ///< Noise Filter Clock Select
    }

    /// SIMR1 Register bits
    namespace simr1_bits {
        constexpr uint32_t IICM = (1U << 0);  ///< Simple IIC Mode Select
        constexpr uint32_t IICDL = (5 << 3);  ///< SDAn Delay Output Select
    }

    /// SIMR2 Register bits
    namespace simr2_bits {
        constexpr uint32_t IICINTM = (1U << 0);  ///< IIC Interrupt Mode Select
        constexpr uint32_t IICCSC = (1U << 1);  ///< Clock Synchronization
        constexpr uint32_t IICACKT = (1U << 5);  ///< ACK Transmission Data
    }

    /// SIMR3 Register bits
    namespace simr3_bits {
        constexpr uint32_t IICSTAREQ = (1U << 0);  ///< Start Condition Generation
        constexpr uint32_t IICRSTAREQ = (1U << 1);  ///< Restart Condition Generation
        constexpr uint32_t IICSTPREQ = (1U << 2);  ///< Stop Condition Generation
        constexpr uint32_t IICSTIF = (1U << 3);  ///< Issuing of Start, Restart, or Stop Condition Completed Flag
        constexpr uint32_t IICSDAS = (2 << 4);  ///< SDAn Output Select
        constexpr uint32_t IICSCLS = (2 << 6);  ///< SCLn Output Select
    }

    /// SISR Register bits
    namespace sisr_bits {
        constexpr uint32_t IICACKR = (1U << 0);  ///< ACK Reception Data Flag
    }

    /// SPMR Register bits
    namespace spmr_bits {
        constexpr uint32_t SSE = (1U << 0);  ///< SSn Pin Function Enable
        constexpr uint32_t CTSE = (1U << 1);  ///< CTS Enable
        constexpr uint32_t MSS = (1U << 2);  ///< Master Slave Select
        constexpr uint32_t MFF = (1U << 4);  ///< Mode Fault Flag
        constexpr uint32_t CKPOL = (1U << 6);  ///< Clock Polarity Select
        constexpr uint32_t CKPH = (1U << 7);  ///< Clock Phase Select
    }

    /// TDRHL Register bits
    namespace tdrhl_bits {
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial Transmit Data
    }

    /// RDRHL Register bits
    namespace rdrhl_bits {
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial Receive Data
    }

    /// DCCR Register bits
    namespace dccr_bits {
        constexpr uint32_t DCMF = (1U << 0);  ///< Data Compare Match Flag
        constexpr uint32_t DPER = (1U << 3);  ///< Data Compare Match Parity Error Flag
        constexpr uint32_t DFER = (1U << 4);  ///< Data Compare Match Framing Error Flag
        constexpr uint32_t IDSEL = (1U << 6);  ///< ID Frame Select
        constexpr uint32_t DCME = (1U << 7);  ///< Data Compare Match Enable
    }

    /// CDR Register bits
    namespace cdr_bits {
        constexpr uint32_t CMPD = (9 << 0);  ///< Compare Match Data
    }

    /// SPTR Register bits
    namespace sptr_bits {
        constexpr uint32_t RXDMON = (1U << 0);  ///< Serial Input Data Monitor
        constexpr uint32_t SPB2DT = (1U << 1);  ///< Serial Port Break Data Select
        constexpr uint32_t SPB2IO = (1U << 2);  ///< Serial Port Break I/O
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40072000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPCR;  ///< Offset: 0x00 - SPI Control Register
        volatile uint32_t SSLP;  ///< Offset: 0x01 - SPI Slave Select Polarity Register
        volatile uint32_t SPPCR;  ///< Offset: 0x02 - SPI Pin Control Register
        volatile uint32_t SPSR;  ///< Offset: 0x03 - SPI Status Register
        volatile uint32_t SPDR;  ///< Offset: 0x04 - SPI Data Register
        volatile uint32_t SPDR_HA;  ///< Offset: 0x04 - SPI Data Register
        volatile uint32_t SPDR_BY;  ///< Offset: 0x04 - SPI Data Register
        volatile uint32_t SPBR;  ///< Offset: 0x0A - SPI Bit Rate Register
        volatile uint32_t SPDCR;  ///< Offset: 0x0B - SPI Data Control Register
        volatile uint32_t SPCKD;  ///< Offset: 0x0C - SPI Clock Delay Register
        volatile uint32_t SSLND;  ///< Offset: 0x0D - SPI Slave Select Negation Delay Register
        volatile uint32_t SPND;  ///< Offset: 0x0E - SPI Next-Access Delay Register
        volatile uint32_t SPCR2;  ///< Offset: 0x0F - SPI Control Register 2
        volatile uint32_t SPCMD0;  ///< Offset: 0x10 - SPI Command Register 0
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);

    // Bit definitions
    /// SPCR Register bits
    namespace spcr_bits {
        constexpr uint32_t SPMS = (1U << 0);  ///< SPI Mode Select
        constexpr uint32_t TXMD = (1U << 1);  ///< Communications Operating Mode Select
        constexpr uint32_t MODFEN = (1U << 2);  ///< Mode Fault Error Detection Enable
        constexpr uint32_t MSTR = (1U << 3);  ///< SPI Master/Slave Mode Select
        constexpr uint32_t SPEIE = (1U << 4);  ///< SPI Error Interrupt Enable
        constexpr uint32_t SPTIE = (1U << 5);  ///< Transmit Buffer Empty Interrupt Enable
        constexpr uint32_t SPE = (1U << 6);  ///< SPI Function Enable
        constexpr uint32_t SPRIE = (1U << 7);  ///< SPI Receive Buffer Full Interrupt Enable
    }

    /// SSLP Register bits
    namespace sslp_bits {
        constexpr uint32_t SSL0P = (1U << 0);  ///< SSLn0 Signal Polarity Setting
    }

    /// SPPCR Register bits
    namespace sppcr_bits {
        constexpr uint32_t SPLP = (1U << 0);  ///< SPI Loopback
        constexpr uint32_t SPLP2 = (1U << 1);  ///< SPI Loopback 2
        constexpr uint32_t MOIFV = (1U << 4);  ///< MOSI Idle Fixed Value
        constexpr uint32_t MOIFE = (1U << 5);  ///< MOSI Idle Value Fixing Enable
    }

    /// SPSR Register bits
    namespace spsr_bits {
        constexpr uint32_t OVRF = (1U << 0);  ///< Overrun Error Flag
        constexpr uint32_t IDLNF = (1U << 1);  ///< SPI Idle Flag
        constexpr uint32_t MODF = (1U << 2);  ///< Mode Fault Error Flag
        constexpr uint32_t PERF = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t UDRF = (1U << 4);  ///< Underrun Error Flag
        constexpr uint32_t SPTEF = (1U << 5);  ///< SPI Transmit Buffer Empty Flag
        constexpr uint32_t SPRF = (1U << 7);  ///< SPI Receive Buffer Full Flag
    }

    /// SPDCR Register bits
    namespace spdcr_bits {
        constexpr uint32_t SPRDTD = (1U << 4);  ///< SPI Receive/Transmit Data Select
        constexpr uint32_t SPLW = (1U << 5);  ///< SPI Word Access/Halfword Access Specification
        constexpr uint32_t SPBYT = (1U << 6);  ///< SPI Byte Access Specification
    }

    /// SPCKD Register bits
    namespace spckd_bits {
        constexpr uint32_t SCKDL = (3 << 0);  ///< RSPCK Delay Setting
    }

    /// SSLND Register bits
    namespace sslnd_bits {
        constexpr uint32_t SLNDL = (3 << 0);  ///< SSL Negation Delay Setting
    }

    /// SPND Register bits
    namespace spnd_bits {
        constexpr uint32_t SPNDL = (3 << 0);  ///< SPI Next-Access Delay Setting
    }

    /// SPCR2 Register bits
    namespace spcr2_bits {
        constexpr uint32_t SPPE = (1U << 0);  ///< Parity Enable
        constexpr uint32_t SPOE = (1U << 1);  ///< Parity Mode
        constexpr uint32_t SPIIE = (1U << 2);  ///< SPI Idle Interrupt Enable
        constexpr uint32_t PTE = (1U << 3);  ///< Parity Self-Testing
        constexpr uint32_t SCKASE = (1U << 4);  ///< RSPCK Auto-Stop Function Enable
    }

    /// SPCMD0 Register bits
    namespace spcmd0_bits {
        constexpr uint32_t CPHA = (1U << 0);  ///< RSPCK Phase Setting
        constexpr uint32_t CPOL = (1U << 1);  ///< RSPCK Polarity Setting
        constexpr uint32_t BRDV = (2 << 2);  ///< Bit Rate Division Setting
        constexpr uint32_t SPB = (4 << 8);  ///< SPI Data Length Setting
        constexpr uint32_t LSBF = (1U << 12);  ///< SPI LSB First
        constexpr uint32_t SPNDEN = (1U << 13);  ///< SPI Next-Access Delay Enable
        constexpr uint32_t SLNDEN = (1U << 14);  ///< SSL Negation Delay Setting Enable
        constexpr uint32_t SCKDEN = (1U << 15);  ///< RSPCK Delay Setting Enable
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40074000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRCCR0;  ///< Offset: 0x00 - CRC Control Register 0
        volatile uint32_t CRCCR1;  ///< Offset: 0x01 - CRC Control Register 1
        volatile uint32_t CRCDIR;  ///< Offset: 0x04 - CRC Data Input Register
        volatile uint32_t CRCDIR_BY;  ///< Offset: 0x04 - CRC Data Input Register
        volatile uint32_t CRCDOR;  ///< Offset: 0x08 - CRC Data Output Register
        volatile uint32_t CRCDOR_HA;  ///< Offset: 0x08 - CRC Data Output Register
        volatile uint32_t CRCDOR_BY;  ///< Offset: 0x08 - CRC Data Output Register
        volatile uint32_t CRCSAR;  ///< Offset: 0x0C - Snoop Address Register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRCCR0 Register bits
    namespace crccr0_bits {
        constexpr uint32_t GPS = (3 << 0);  ///< CRC Generating Polynomial Switching
        constexpr uint32_t LMS = (1U << 6);  ///< CRC Calculation Switching
        constexpr uint32_t DORCLR = (1U << 7);  ///< CRCDOR/CRCDOR_HA/CRCDOR_BY Register Clear
    }

    /// CRCCR1 Register bits
    namespace crccr1_bits {
        constexpr uint32_t CRCSWR = (1U << 6);  ///< Snoop-On-Write/Read Switch
        constexpr uint32_t CRCSEN = (1U << 7);  ///< Snoop Enable
    }

    /// CRCSAR Register bits
    namespace crcsar_bits {
        constexpr uint32_t CRCSA = (14 << 0);  ///< Register Snoop Address
    }

}

// ============================================================================
// GPT164 Peripheral
// ============================================================================

namespace gpt164 {
    /// Base addresses
    constexpr uint32_t GPT164_BASE = 0x40078400;

    /// GPT164 Register structure
    struct Registers {
        volatile uint32_t GTWP;  ///< Offset: 0x00 - General PWM Timer Write-Protection Register
        volatile uint32_t GTSTR;  ///< Offset: 0x04 - General PWM Timer Software Start Register
        volatile uint32_t GTSTP;  ///< Offset: 0x08 - General PWM Timer Software Stop Register
        volatile uint32_t GTCLR;  ///< Offset: 0x0C - General PWM Timer Software Clear Register
        volatile uint32_t GTSSR;  ///< Offset: 0x10 - General PWM Timer Start Source Select Register
        volatile uint32_t GTPSR;  ///< Offset: 0x14 - General PWM Timer Stop Source Select Register
        volatile uint32_t GTCSR;  ///< Offset: 0x18 - General PWM Timer Clear Source Select Register
        volatile uint32_t GTUPSR;  ///< Offset: 0x1C - General PWM Timer Up Count Source Select Register
        volatile uint32_t GTDNSR;  ///< Offset: 0x20 - General PWM Timer Down Count Source Select Register
        volatile uint32_t GTICASR;  ///< Offset: 0x24 - General PWM Timer Input Capture Source Select Register A
        volatile uint32_t GTICBSR;  ///< Offset: 0x28 - General PWM Timer Input Capture Source Select Register B
        volatile uint32_t GTCR;  ///< Offset: 0x2C - General PWM Timer Control Register
        volatile uint32_t GTUDDTYC;  ///< Offset: 0x30 - General PWM Timer Count Direction and Duty Setting Register
        volatile uint32_t GTIOR;  ///< Offset: 0x34 - General PWM Timer I/O Control Register
        volatile uint32_t GTINTAD;  ///< Offset: 0x38 - General PWM Timer Interrupt Output Setting Register
        volatile uint32_t GTST;  ///< Offset: 0x3C - General PWM Timer Status Register
        volatile uint32_t GTBER;  ///< Offset: 0x40 - General PWM Timer Buffer Enable Register
        volatile uint32_t GTCNT;  ///< Offset: 0x48 - General PWM Timer Counter
        volatile uint32_t GTCCRA;  ///< Offset: 0x4C - General PWM Timer Compare Capture Register A
        volatile uint32_t GTCCRB;  ///< Offset: 0x50 - General PWM Timer Compare Capture Register B
        volatile uint32_t GTCCRC;  ///< Offset: 0x54 - General PWM Timer Compare Capture Register C
        volatile uint32_t GTCCRE;  ///< Offset: 0x58 - General PWM Timer Compare Capture Register E
        volatile uint32_t GTCCRD;  ///< Offset: 0x5C - General PWM Timer Compare Capture Register D
        volatile uint32_t GTCCRF;  ///< Offset: 0x60 - General PWM Timer Compare Capture Register F
        volatile uint32_t GTPR;  ///< Offset: 0x64 - General PWM Timer Cycle Setting Register
        volatile uint32_t GTPBR;  ///< Offset: 0x68 - General PWM Timer Cycle Setting Buffer Register
        volatile uint32_t GTDTCR;  ///< Offset: 0x88 - General PWM Timer Dead Time Control Register
        volatile uint32_t GTDVU;  ///< Offset: 0x8C - General PWM Timer Dead Time Value Register U
    };

    /// Peripheral instances
    inline Registers* GPT164 = reinterpret_cast<Registers*>(GPT164_BASE);

    // Bit definitions
    /// GTWP Register bits
    namespace gtwp_bits {
        constexpr uint32_t WP = (1U << 0);  ///< Register Write Disable
        constexpr uint32_t PRKEY = (8 << 8);  ///< GTWP Key Code
    }

    /// GTSTR Register bits
    namespace gtstr_bits {
        constexpr uint32_t CSTRT0 = (1U << 0);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT1 = (1U << 1);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT2 = (1U << 2);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT3 = (1U << 3);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT4 = (1U << 4);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT5 = (1U << 5);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT6 = (1U << 6);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT7 = (1U << 7);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT8 = (1U << 8);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
        constexpr uint32_t CSTRT9 = (1U << 9);  ///< Channel n GTCNT Count Start (n : the same as bit position value)
    }

    /// GTSTP Register bits
    namespace gtstp_bits {
        constexpr uint32_t CSTOP0 = (1U << 0);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP1 = (1U << 1);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP2 = (1U << 2);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP3 = (1U << 3);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP4 = (1U << 4);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP5 = (1U << 5);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP6 = (1U << 6);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP7 = (1U << 7);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP8 = (1U << 8);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
        constexpr uint32_t CSTOP9 = (1U << 9);  ///< Channel n GTCNT Count Stop (n : the same as bit position value)
    }

    /// GTCLR Register bits
    namespace gtclr_bits {
        constexpr uint32_t CCLR0 = (1U << 0);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR1 = (1U << 1);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR2 = (1U << 2);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR3 = (1U << 3);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR4 = (1U << 4);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR5 = (1U << 5);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR6 = (1U << 6);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR7 = (1U << 7);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR8 = (1U << 8);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
        constexpr uint32_t CCLR9 = (1U << 9);  ///< Channel n GTCNT Count Clear (n : the same as bit position value)
    }

    /// GTSSR Register bits
    namespace gtssr_bits {
        constexpr uint32_t SSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Start Enable
        constexpr uint32_t SSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Start Enable
        constexpr uint32_t SSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Start Enable
        constexpr uint32_t SSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Start Enable
        constexpr uint32_t SSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Start Enable
        constexpr uint32_t SSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Start Enable
        constexpr uint32_t SSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Start Enable
        constexpr uint32_t SSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Start Enable
        constexpr uint32_t SSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Start Enable
        constexpr uint32_t SSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Start Enable
        constexpr uint32_t CSTRT = (1U << 31);  ///< Software Source Counter Start Enable
    }

    /// GTPSR Register bits
    namespace gtpsr_bits {
        constexpr uint32_t PSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Stop Enable
        constexpr uint32_t PSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Stop Enable
        constexpr uint32_t PSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Stop Enable
        constexpr uint32_t PSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Stop Enable
        constexpr uint32_t PSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Stop Enable
        constexpr uint32_t PSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Stop Enable
        constexpr uint32_t PSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Stop Enable
        constexpr uint32_t CSTOP = (1U << 31);  ///< Software Source Counter Stop Enable
    }

    /// GTCSR Register bits
    namespace gtcsr_bits {
        constexpr uint32_t CSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Clear Enable
        constexpr uint32_t CSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Clear Enable
        constexpr uint32_t CSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Clear Enable
        constexpr uint32_t CSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Clear Enable
        constexpr uint32_t CSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Clear Enable
        constexpr uint32_t CSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Clear Enable
        constexpr uint32_t CSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Clear Enable
        constexpr uint32_t CCLR = (1U << 31);  ///< Software Source Counter Clear Enable
    }

    /// GTUPSR Register bits
    namespace gtupsr_bits {
        constexpr uint32_t USGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Up Enable
        constexpr uint32_t USCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Up Enable
        constexpr uint32_t USCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Up Enable
        constexpr uint32_t USELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Up Enable
        constexpr uint32_t USELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Up Enable
        constexpr uint32_t USELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Up Enable
        constexpr uint32_t USELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Up Enable
    }

    /// GTDNSR Register bits
    namespace gtdnsr_bits {
        constexpr uint32_t DSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Down Enable
        constexpr uint32_t DSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Down Enable
        constexpr uint32_t DSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Down Enable
        constexpr uint32_t DSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Down Enable
        constexpr uint32_t DSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Down Enable
    }

    /// GTICASR Register bits
    namespace gticasr_bits {
        constexpr uint32_t ASGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRA Input Capture Enable
    }

    /// GTICBSR Register bits
    namespace gticbsr_bits {
        constexpr uint32_t BSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBL = (1U << 8);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBH = (1U << 9);  ///< GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBL = (1U << 10);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBH = (1U << 11);  ///< GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAL = (1U << 12);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAH = (1U << 13);  ///< GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAL = (1U << 14);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAH = (1U << 15);  ///< GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRB Input Capture Enable
    }

    /// GTCR Register bits
    namespace gtcr_bits {
        constexpr uint32_t CST = (1U << 0);  ///< Count Start
        constexpr uint32_t MD = (3 << 16);  ///< Mode Select
        constexpr uint32_t TPCS = (3 << 24);  ///< Timer Prescaler Select
    }

    /// GTUDDTYC Register bits
    namespace gtuddtyc_bits {
        constexpr uint32_t UD = (1U << 0);  ///< Count Direction Setting
        constexpr uint32_t UDF = (1U << 1);  ///< Forcible Count Direction Setting
        constexpr uint32_t OADTY = (2 << 16);  ///< GTIOCnA Output Duty Setting
        constexpr uint32_t OADTYF = (1U << 18);  ///< Forcible GTIOCnA Output Duty Setting
        constexpr uint32_t OADTYR = (1U << 19);  ///< GTIOCnA Output Value Selecting after Releasing 0%/100% Duty Setting
        constexpr uint32_t OBDTY = (2 << 24);  ///< GTIOCnB Output Duty Setting
        constexpr uint32_t OBDTYF = (1U << 26);  ///< Forcible GTIOCnB Output Duty Setting
        constexpr uint32_t OBDTYR = (1U << 27);  ///< GTIOCnB Output Value Selecting after Releasing 0%/100% Duty Setting
    }

    /// GTIOR Register bits
    namespace gtior_bits {
        constexpr uint32_t GTIOA = (5 << 0);  ///< GTIOCnA Pin Function Select
        constexpr uint32_t OADFLT = (1U << 6);  ///< GTIOCnA Pin Output Value Setting at the Count Stop
        constexpr uint32_t OAHLD = (1U << 7);  ///< GTIOCnA Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OAE = (1U << 8);  ///< GTIOCnA Pin Output Enable
        constexpr uint32_t OADF = (2 << 9);  ///< GTIOCnA Pin Disable Value Setting
        constexpr uint32_t NFAEN = (1U << 13);  ///< Noise Filter A Enable
        constexpr uint32_t NFCSA = (2 << 14);  ///< Noise Filter A Sampling Clock Select
        constexpr uint32_t GTIOB = (5 << 16);  ///< GTIOCnB Pin Function Select
        constexpr uint32_t OBDFLT = (1U << 22);  ///< GTIOCnB Pin Output Value Setting at the Count Stop
        constexpr uint32_t OBHLD = (1U << 23);  ///< GTIOCnB Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OBE = (1U << 24);  ///< GTIOCnB Pin Output Enable
        constexpr uint32_t OBDF = (2 << 25);  ///< GTIOCnB Pin Disable Value Setting
        constexpr uint32_t NFBEN = (1U << 29);  ///< Noise Filter B Enable
        constexpr uint32_t NFCSB = (2 << 30);  ///< Noise Filter B Sampling Clock Select
    }

    /// GTINTAD Register bits
    namespace gtintad_bits {
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disable Source Select
        constexpr uint32_t GRPABH = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t GRPABL = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
    }

    /// GTST Register bits
    namespace gtst_bits {
        constexpr uint32_t TCFA = (1U << 0);  ///< Input Capture/Compare Match Flag A
        constexpr uint32_t TCFB = (1U << 1);  ///< Input Capture/Compare Match Flag B
        constexpr uint32_t TCFC = (1U << 2);  ///< Input Compare Match Flag C
        constexpr uint32_t TCFD = (1U << 3);  ///< Input Compare Match Flag D
        constexpr uint32_t TCFE = (1U << 4);  ///< Input Compare Match Flag E
        constexpr uint32_t TCFF = (1U << 5);  ///< Input Compare Match Flag F
        constexpr uint32_t TCFPO = (1U << 6);  ///< Overflow Flag
        constexpr uint32_t TCFPU = (1U << 7);  ///< Underflow Flag
        constexpr uint32_t TUCF = (1U << 15);  ///< Count Direction Flag
        constexpr uint32_t ODF = (1U << 24);  ///< Output Disable Flag
        constexpr uint32_t OABHF = (1U << 29);  ///< Same Time Output Level High Flag
        constexpr uint32_t OABLF = (1U << 30);  ///< Same Time Output Level Low Flag
    }

    /// GTBER Register bits
    namespace gtber_bits {
        constexpr uint32_t BD0 = (1U << 0);  ///< GTCCR Buffer Operation Disable
        constexpr uint32_t BD1 = (1U << 1);  ///< GTPR Buffer Operation Disable
        constexpr uint32_t CCRA = (2 << 16);  ///< GTCCRA Buffer Operation
        constexpr uint32_t CCRB = (2 << 18);  ///< GTCCRB Buffer Operation
        constexpr uint32_t PR = (2 << 20);  ///< GTPR Buffer Operation
        constexpr uint32_t CCRSWT = (1U << 22);  ///< GTCCRA and GTCCRB Forcible Buffer Operation
    }

    /// GTDTCR Register bits
    namespace gtdtcr_bits {
        constexpr uint32_t TDE = (1U << 0);  ///< Negative-Phase Waveform Setting
    }

}

// ============================================================================
// GPT165 Peripheral
// ============================================================================

namespace gpt165 {
    /// Base addresses
    constexpr uint32_t GPT165_BASE = 0x40078500;

    /// GPT165 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT165 = reinterpret_cast<Registers*>(GPT165_BASE);

}

// ============================================================================
// GPT166 Peripheral
// ============================================================================

namespace gpt166 {
    /// Base addresses
    constexpr uint32_t GPT166_BASE = 0x40078600;

    /// GPT166 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT166 = reinterpret_cast<Registers*>(GPT166_BASE);

}

// ============================================================================
// GPT167 Peripheral
// ============================================================================

namespace gpt167 {
    /// Base addresses
    constexpr uint32_t GPT167_BASE = 0x40078700;

    /// GPT167 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT167 = reinterpret_cast<Registers*>(GPT167_BASE);

}

// ============================================================================
// GPT168 Peripheral
// ============================================================================

namespace gpt168 {
    /// Base addresses
    constexpr uint32_t GPT168_BASE = 0x40078800;

    /// GPT168 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT168 = reinterpret_cast<Registers*>(GPT168_BASE);

}

// ============================================================================
// GPT169 Peripheral
// ============================================================================

namespace gpt169 {
    /// Base addresses
    constexpr uint32_t GPT169_BASE = 0x40078900;

    /// GPT169 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT169 = reinterpret_cast<Registers*>(GPT169_BASE);

}

// ============================================================================
// GPT Peripheral
// ============================================================================

namespace gpt {
    /// Base addresses
    constexpr uint32_t GPT_OPS_BASE = 0x40078FF0;

    /// GPT Register structure
    struct Registers {
        volatile uint32_t OPSCR;  ///< Offset: 0x00 - Output Phase Switching Control Register
    };

    /// Peripheral instances
    inline Registers* GPT_OPS = reinterpret_cast<Registers*>(GPT_OPS_BASE);

    // Bit definitions
    /// OPSCR Register bits
    namespace opscr_bits {
        constexpr uint32_t UF = (1U << 0);  ///< UF
        constexpr uint32_t VF = (1U << 1);  ///< VF
        constexpr uint32_t WF = (1U << 2);  ///< WF
        constexpr uint32_t EN = (1U << 8);  ///< Output Phase Enable
        constexpr uint32_t FB = (1U << 16);  ///< External Feedback Signal Enable
        constexpr uint32_t P = (1U << 17);  ///< Positive-Phase Output (P) Control
        constexpr uint32_t N = (1U << 18);  ///< Negative-Phase Output (N) Control
        constexpr uint32_t INV = (1U << 19);  ///< Output Phase Invert Control
        constexpr uint32_t RV = (1U << 20);  ///< Output Phase Rotation Direction Reversal Control
        constexpr uint32_t ALIGN = (1U << 21);  ///< Input Phase Alignment
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disabled Source Selection
        constexpr uint32_t GODF = (1U << 26);  ///< Group Output Disable Function
        constexpr uint32_t NFEN = (1U << 29);  ///< External Input Noise Filter Enable
        constexpr uint32_t NFCS = (2 << 30);  ///< External Input Noise Filter Clock Selection
    }

}

// ============================================================================
// KINT Peripheral
// ============================================================================

namespace kint {
    /// Base addresses
    constexpr uint32_t KINT_BASE = 0x40080000;

    /// KINT Register structure
    struct Registers {
        volatile uint32_t KRCTL;  ///< Offset: 0x00 - Key Return Control Register
        volatile uint32_t KRF;  ///< Offset: 0x04 - Key Return Flag Register
        volatile uint32_t KRM;  ///< Offset: 0x08 - Key Return Mode Register
    };

    /// Peripheral instances
    inline Registers* KINT = reinterpret_cast<Registers*>(KINT_BASE);

    // Bit definitions
    /// KRCTL Register bits
    namespace krctl_bits {
        constexpr uint32_t KREG = (1U << 0);  ///< Detection Edge Selection (KR00 to KR03 pins)
        constexpr uint32_t KRMD = (1U << 7);  ///< Usage of Key Interrupt Flags (KRF.KIF0 to KRF.KIF3)
    }

    /// KRF Register bits
    namespace krf_bits {
        constexpr uint32_t KIF0 = (1U << 0);  ///< Key Interrupt Flag n
        constexpr uint32_t KIF1 = (1U << 1);  ///< Key Interrupt Flag n
        constexpr uint32_t KIF2 = (1U << 2);  ///< Key Interrupt Flag n
        constexpr uint32_t KIF3 = (1U << 3);  ///< Key Interrupt Flag n
    }

    /// KRM Register bits
    namespace krm_bits {
        constexpr uint32_t KIMC0 = (1U << 0);  ///< Key Interrupt Mode Control n
        constexpr uint32_t KIMC1 = (1U << 1);  ///< Key Interrupt Mode Control n
        constexpr uint32_t KIMC2 = (1U << 2);  ///< Key Interrupt Mode Control n
        constexpr uint32_t KIMC3 = (1U << 3);  ///< Key Interrupt Mode Control n
    }

}

// ============================================================================
// I3C Peripheral
// ============================================================================

namespace i3c {
    /// Base addresses
    constexpr uint32_t I3C_BASE = 0x40083000;

    /// I3C Register structure
    struct Registers {
        volatile uint32_t PRTS;  ///< Offset: 0x00 - Protocol Selection Register
        volatile uint32_t BCTL;  ///< Offset: 0x14 - Bus Control Register
        volatile uint32_t MSDVAD;  ///< Offset: 0x18 - Master Device Address Register
        volatile uint32_t RSTCTL;  ///< Offset: 0x20 - Reset Control Register
        volatile uint32_t PRSST;  ///< Offset: 0x24 - Present State Register
        volatile uint32_t INST;  ///< Offset: 0x30 - Internal Status Register
        volatile uint32_t INSTE;  ///< Offset: 0x34 - Internal Status Enable Register
        volatile uint32_t INIE;  ///< Offset: 0x38 - Internal Interrupt Enable Register
        volatile uint32_t INSTFC;  ///< Offset: 0x3C - Internal Status Force Register
        volatile uint32_t DVCT;  ///< Offset: 0x44 - Device Characteristic Table Register
        volatile uint32_t IBINCTL;  ///< Offset: 0x58 - IBI Notify Control Register
        volatile uint32_t BFCTL;  ///< Offset: 0x60 - Bus Function Control Register
        volatile uint32_t SVCTL;  ///< Offset: 0x64 - Slave Control Register
        volatile uint32_t REFCKCTL;  ///< Offset: 0x70 - Reference Clock Control Register
        volatile uint32_t STDBR;  ///< Offset: 0x74 - Standard Bit Rate Register
        volatile uint32_t EXTBR;  ///< Offset: 0x78 - Extended Bit Rate Register
        volatile uint32_t BFRECDT;  ///< Offset: 0x7C - Bus Free Condition Detection Time Register
        volatile uint32_t BAVLCDT;  ///< Offset: 0x80 - Bus Available Condition Detection Time Register
        volatile uint32_t BIDLCDT;  ///< Offset: 0x84 - Bus Idle Condition Detection Time Register
        volatile uint32_t OUTCTL;  ///< Offset: 0x88 - Output Control Register
        volatile uint32_t INCTL;  ///< Offset: 0x8C - Input Control Register
        volatile uint32_t TMOCTL;  ///< Offset: 0x90 - Timeout Control Register
        volatile uint32_t ACKCTL;  ///< Offset: 0xA0 - Acknowledge Control Register
        volatile uint32_t SCSTRCTL;  ///< Offset: 0xA4 - SCL Stretch Control Register
        volatile uint32_t SCSTLCTL;  ///< Offset: 0xB0 - SCL Stalling Control Register
        volatile uint32_t SVTDLG0;  ///< Offset: 0xC0 - Slave Transfer Data Length Register 0
        volatile uint32_t CNDCTL;  ///< Offset: 0x140 - Condition Control Register
        volatile uint32_t NCMDQP;  ///< Offset: 0x150 - Normal Command Queue Port Register
        volatile uint32_t NRSPQP;  ///< Offset: 0x154 - Normal Response Queue Port Register
        volatile uint32_t NTDTBP0;  ///< Offset: 0x158 - Normal Transfer Data Buffer Port Register 0
        volatile uint32_t NTDTBP0_BY;  ///< Offset: 0x158 - Normal Transfer Data Buffer Port Register 0
        volatile uint32_t NIBIQP;  ///< Offset: 0x17C - Normal IBI Queue Port Register
        volatile uint32_t NRSQP;  ///< Offset: 0x180 - Normal Receive Status Queue Port Register
        volatile uint32_t NQTHCTL;  ///< Offset: 0x190 - Normal Queue Threshold Control Register
        volatile uint32_t NTBTHCTL0;  ///< Offset: 0x194 - Normal Transfer Data Buffer Threshold Control Register 0
        volatile uint32_t NRQTHCTL;  ///< Offset: 0x1C0 - Normal Receive Status Queue Threshold Control Register
        volatile uint32_t BST;  ///< Offset: 0x1D0 - Bus Status Register
        volatile uint32_t BSTE;  ///< Offset: 0x1D4 - Bus Status Enable Register
        volatile uint32_t BIE;  ///< Offset: 0x1D8 - Bus Interrupt Enable Register
        volatile uint32_t BSTFC;  ///< Offset: 0x1DC - Bus Status Force Register
        volatile uint32_t NTST;  ///< Offset: 0x1E0 - Normal Transfer Status Register
        volatile uint32_t NTSTE;  ///< Offset: 0x1E4 - Normal Transfer Status Enable Register
        volatile uint32_t NTIE;  ///< Offset: 0x1E8 - Normal Transfer Interrupt Enable Register
        volatile uint32_t NTSTFC;  ///< Offset: 0x1EC - Normal Transfer Status Force Register
        volatile uint32_t BCST;  ///< Offset: 0x210 - Bus Condition Status Register
        volatile uint32_t SVST;  ///< Offset: 0x214 - Slave Status Register
        volatile uint32_t DATBAS%s;  ///< Offset: 0x224 - Device Address Table Basic Register %s
        volatile uint32_t EXDATBAS;  ///< Offset: 0x2A0 - Extended Device Address Table Basic Register
        volatile uint32_t SDATBAS0;  ///< Offset: 0x2B0 - Slave Device Address Table Basic Register 0
        volatile uint32_t MSDCT%s;  ///< Offset: 0x2D0 - Master Device Characteristic Table Register %s
        volatile uint32_t SVDCT;  ///< Offset: 0x320 - Slave Device Characteristic Table Register
        volatile uint32_t SDCTPIDL;  ///< Offset: 0x324 - Slave Device Characteristic Table Provisional ID Low Register
        volatile uint32_t SDCTPIDH;  ///< Offset: 0x328 - Slave Device Characteristic Table Provisional ID High Register
        volatile uint32_t SVDVAD0;  ///< Offset: 0x330 - Slave Device Address Register 0
        volatile uint32_t CSECMD;  ///< Offset: 0x350 - CCC Slave Events Command Register
        volatile uint32_t CEACTST;  ///< Offset: 0x354 - CCC Enter Activity State Register
        volatile uint32_t CMWLG;  ///< Offset: 0x358 - CCC Max Write Length Register
        volatile uint32_t CMRLG;  ///< Offset: 0x35C - CCC Max Read Length Register
        volatile uint32_t CETSTMD;  ///< Offset: 0x360 - CCC Enter Test Mode Register
        volatile uint32_t CGDVST;  ///< Offset: 0x364 - CCC Get Device Status Register
        volatile uint32_t CMDSPW;  ///< Offset: 0x368 - CCC Max Data Speed W (Write) Register
        volatile uint32_t CMDSPR;  ///< Offset: 0x36C - CCC Max Data Speed R (Read) Register
        volatile uint32_t CMDSPT;  ///< Offset: 0x370 - CCC Max Data Speed T (Turnaround) Register
        volatile uint32_t CETSM;  ///< Offset: 0x374 - CCC Exchange Timing Support Information M (Mode) Register
        volatile uint32_t BITCNT;  ///< Offset: 0x380 - Bit Count Register
        volatile uint32_t NQSTLV;  ///< Offset: 0x394 - Normal Queue Status Level Register
        volatile uint32_t NDBSTLV0;  ///< Offset: 0x398 - Normal Data Buffer Status Level Register 0
        volatile uint32_t NRSQSTLV;  ///< Offset: 0x3C0 - Normal Receive Status Queue Status Level Register
        volatile uint32_t PRSTDBG;  ///< Offset: 0x3CC - Present State Debug Register
        volatile uint32_t MSERRCNT;  ///< Offset: 0x3D0 - Master Error Counters Register
    };

    /// Peripheral instances
    inline Registers* I3C = reinterpret_cast<Registers*>(I3C_BASE);

    // Bit definitions
    /// PRTS Register bits
    namespace prts_bits {
        constexpr uint32_t PRTMD = (1U << 0);  ///< Protocol Mode
    }

    /// BCTL Register bits
    namespace bctl_bits {
        constexpr uint32_t INCBA = (1U << 0);  ///< Include I3C Broadcast Address
        constexpr uint32_t HJACKCTL = (1U << 8);  ///< Hot-Join Acknowledge Control
        constexpr uint32_t ABT = (1U << 29);  ///< Abort
        constexpr uint32_t RSM = (1U << 30);  ///< Resume
        constexpr uint32_t BUSE = (1U << 31);  ///< Bus Enable
    }

    /// MSDVAD Register bits
    namespace msdvad_bits {
        constexpr uint32_t MDYAD = (7 << 16);  ///< Master Dynamic Address
        constexpr uint32_t MDYADV = (1U << 31);  ///< Master Dynamic Address Valid
    }

    /// RSTCTL Register bits
    namespace rstctl_bits {
        constexpr uint32_t RI3CRST = (1U << 0);  ///< I3C Software Reset
        constexpr uint32_t CMDQRST = (1U << 1);  ///< Command Queue Software Reset
        constexpr uint32_t RSPQRST = (1U << 2);  ///< Response Queue Software Reset
        constexpr uint32_t TDBRST = (1U << 3);  ///< Transmit Data Buffer Software Reset
        constexpr uint32_t RDBRST = (1U << 4);  ///< Receive Data Buffer Software Reset
        constexpr uint32_t IBIQRST = (1U << 5);  ///< IBI Queue Software Reset
        constexpr uint32_t RSQRST = (1U << 6);  ///< Receive Status Queue Software Reset
        constexpr uint32_t INTLRST = (1U << 16);  ///< Internal Software Reset
    }

    /// PRSST Register bits
    namespace prsst_bits {
        constexpr uint32_t CRMS = (1U << 2);  ///< Current Master
        constexpr uint32_t TRMD = (1U << 4);  ///< Transmit/Receive Mode
        constexpr uint32_t PRSSTWP = (1U << 7);  ///< Present State Write Protect
    }

    /// INST Register bits
    namespace inst_bits {
        constexpr uint32_t INEF = (1U << 10);  ///< Internal Error Flag
    }

    /// INSTE Register bits
    namespace inste_bits {
        constexpr uint32_t INEE = (1U << 10);  ///< Internal Error Enable
    }

    /// INIE Register bits
    namespace inie_bits {
        constexpr uint32_t INEIE = (1U << 10);  ///< Internal Error Interrupt Enable
    }

    /// INSTFC Register bits
    namespace instfc_bits {
        constexpr uint32_t INEFC = (1U << 10);  ///< Internal Error Force
    }

    /// DVCT Register bits
    namespace dvct_bits {
        constexpr uint32_t IDX = (5 << 19);  ///< DCT Table Index
    }

    /// IBINCTL Register bits
    namespace ibinctl_bits {
        constexpr uint32_t NRHJCTL = (1U << 0);  ///< Notify Rejected Hot-Join Control
        constexpr uint32_t NRMRCTL = (1U << 1);  ///< Notify Rejected Master Request Control
        constexpr uint32_t NRSIRCTL = (1U << 3);  ///< Notify Rejected Slave Interrupt Request Control
    }

    /// BFCTL Register bits
    namespace bfctl_bits {
        constexpr uint32_t MALE = (1U << 0);  ///< Master Arbitration-Lost Detection Enable
        constexpr uint32_t NALE = (1U << 1);  ///< NACK Transmission Arbitration-Lost Detection Enable
        constexpr uint32_t SALE = (1U << 2);  ///< Slave Arbitration-Lost Detection Enable
        constexpr uint32_t SCSYNE = (1U << 8);  ///< SCL Synchronous Circuit Enable
        constexpr uint32_t SMBS = (1U << 12);  ///< SMBus/I2C Bus Selection
        constexpr uint32_t FMPE = (1U << 14);  ///< Fast-mode Plus Enable
        constexpr uint32_t HSME = (1U << 15);  ///< High Speed Mode Enable
    }

    /// SVCTL Register bits
    namespace svctl_bits {
        constexpr uint32_t GCAE = (1U << 0);  ///< General Call Address Enable
        constexpr uint32_t HSMCE = (1U << 5);  ///< Hs-mode Master Code Enable
        constexpr uint32_t DVIDE = (1U << 6);  ///< Device-ID Address Enable
        constexpr uint32_t HOAE = (1U << 15);  ///< Host Address Enable
        constexpr uint32_t SVAE0 = (1U << 16);  ///< Slave Address Enable 0
    }

    /// REFCKCTL Register bits
    namespace refckctl_bits {
        constexpr uint32_t IREFCKS = (3 << 0);  ///< Internal Reference Clock Selection
    }

    /// STDBR Register bits
    namespace stdbr_bits {
        constexpr uint32_t SBRLO = (8 << 0);  ///< Count value of the Low-level period of SCL clock
        constexpr uint32_t SBRHO = (8 << 8);  ///< Count value of the High-level period of SCL clock
        constexpr uint32_t SBRLP = (6 << 16);  ///< Standard Bit Rate Low-level Period Push-Pull
        constexpr uint32_t SBRHP = (6 << 24);  ///< Standard Bit Rate High-Level Period Push-Pull
        constexpr uint32_t DSBRPO = (1U << 31);  ///< Double the Standard Bit Rate Period for Open-Drain
    }

    /// EXTBR Register bits
    namespace extbr_bits {
        constexpr uint32_t EBRLO = (8 << 0);  ///< Extended Bit Rate Low-Level Period Open-Drain
        constexpr uint32_t EBRHO = (8 << 8);  ///< Extended Bit Rate High-Level Period Open-Drain
        constexpr uint32_t EBRLP = (6 << 16);  ///< Extended Bit Rate Low-Level Period Push-Pull
        constexpr uint32_t EBRHP = (6 << 24);  ///< Extended Bit Rate Low-Level Period Push-Pull
    }

    /// BFRECDT Register bits
    namespace bfrecdt_bits {
        constexpr uint32_t FRECYC = (9 << 0);  ///< Bus Free Condition Detection Cycle
    }

    /// BAVLCDT Register bits
    namespace bavlcdt_bits {
        constexpr uint32_t AVLCYC = (9 << 0);  ///< Bus Available Condition Detection Cycle
    }

    /// BIDLCDT Register bits
    namespace bidlcdt_bits {
        constexpr uint32_t IDLCYC = (18 << 0);  ///< Bus Idle Condition Detection Cycle
    }

    /// OUTCTL Register bits
    namespace outctl_bits {
        constexpr uint32_t SDOC = (1U << 0);  ///< SDA Output Control
        constexpr uint32_t SCOC = (1U << 1);  ///< SCL Output Control
        constexpr uint32_t SOCWP = (1U << 2);  ///< SCL/SDA Output Control Write Protect
        constexpr uint32_t EXCYC = (1U << 4);  ///< Extra SCL Clock Cycle Output
        constexpr uint32_t SDOD = (3 << 8);  ///< SDA Output Delay
        constexpr uint32_t SDODCS = (1U << 15);  ///< SDA Output Delay Clock Source Selection
    }

    /// INCTL Register bits
    namespace inctl_bits {
        constexpr uint32_t DNFS = (4 << 0);  ///< Digital Noise Filter Stage Selection
        constexpr uint32_t DNFE = (1U << 4);  ///< Digital Noise Filter Circuit Enable
    }

    /// TMOCTL Register bits
    namespace tmoctl_bits {
        constexpr uint32_t TODTS = (2 << 0);  ///< Timeout Detection Time Selection
        constexpr uint32_t TOLCTL = (1U << 4);  ///< Timeout L Count Control
        constexpr uint32_t TOHCTL = (1U << 5);  ///< Timeout H Count Control
        constexpr uint32_t TOMDS = (2 << 6);  ///< Timeout Operation Mode Selection
    }

    /// ACKCTL Register bits
    namespace ackctl_bits {
        constexpr uint32_t ACKR = (1U << 0);  ///< Acknowledge Reception
        constexpr uint32_t ACKT = (1U << 1);  ///< Acknowledge Transmission
        constexpr uint32_t ACKTWP = (1U << 2);  ///< ACKT Write Protect
    }

    /// SCSTRCTL Register bits
    namespace scstrctl_bits {
        constexpr uint32_t ACKTWE = (1U << 0);  ///< Acknowledge Transmission Wait Enable
        constexpr uint32_t RWE = (1U << 1);  ///< Receive Wait Enable
    }

    /// SCSTLCTL Register bits
    namespace scstlctl_bits {
        constexpr uint32_t STLCYC = (16 << 0);  ///< Stalling Cycle
        constexpr uint32_t AAPE = (1U << 28);  ///< Assigned Address Phase Enable
        constexpr uint32_t TRAPE = (1U << 29);  ///< Transition Phase Enable
        constexpr uint32_t PARPE = (1U << 30);  ///< Parity Phase Enable
        constexpr uint32_t ACKPE = (1U << 31);  ///< ACK phase Enable
    }

    /// SVTDLG0 Register bits
    namespace svtdlg0_bits {
        constexpr uint32_t STDLG = (16 << 16);  ///< Slave Transfer Data Length
    }

    /// CNDCTL Register bits
    namespace cndctl_bits {
        constexpr uint32_t STCND = (1U << 0);  ///< START (S) Condition Issuance
        constexpr uint32_t SRCND = (1U << 1);  ///< Repeated START (Sr) Condition Issuance
        constexpr uint32_t SPCND = (1U << 2);  ///< STOP (P) Condition Issuance
    }

    /// NQTHCTL Register bits
    namespace nqthctl_bits {
        constexpr uint32_t CMDQTH = (8 << 0);  ///< Normal Command Ready Queue Threshold
        constexpr uint32_t RSPQTH = (8 << 8);  ///< Normal Response Queue Threshold
        constexpr uint32_t IBIDSSZ = (8 << 16);  ///< Normal IBI Data Segment Size
        constexpr uint32_t IBIQTH = (8 << 24);  ///< Normal IBI Queue Threshold
    }

    /// NTBTHCTL0 Register bits
    namespace ntbthctl0_bits {
        constexpr uint32_t TXDBTH = (3 << 0);  ///< Normal Transmit Data Buffer Threshold
        constexpr uint32_t RXDBTH = (3 << 8);  ///< Normal Receive Data Buffer Threshold
        constexpr uint32_t TXSTTH = (3 << 16);  ///< Normal Tx Start Threshold
        constexpr uint32_t RXSTTH = (3 << 24);  ///< Normal Rx Start Threshold
    }

    /// NRQTHCTL Register bits
    namespace nrqthctl_bits {
        constexpr uint32_t RSQTH = (8 << 0);  ///< Normal Receive Status Queue Threshold
    }

    /// BST Register bits
    namespace bst_bits {
        constexpr uint32_t STCNDDF = (1U << 0);  ///< START Condition Detection Flag
        constexpr uint32_t SPCNDDF = (1U << 1);  ///< STOP Condition Detection Flag
        constexpr uint32_t HDREXDF = (1U << 2);  ///< HDR Exit Pattern Detection Flag
        constexpr uint32_t NACKDF = (1U << 4);  ///< NACK Detection Flag
        constexpr uint32_t TENDF = (1U << 8);  ///< Transmit End Flag
        constexpr uint32_t ALF = (1U << 16);  ///< Arbitration Lost Flag
        constexpr uint32_t TODF = (1U << 20);  ///< Timeout Detection Flag
    }

    /// BSTE Register bits
    namespace bste_bits {
        constexpr uint32_t STCNDDE = (1U << 0);  ///< START Condition Detection Enable
        constexpr uint32_t SPCNDDE = (1U << 1);  ///< STOP Condition Detection Enable
        constexpr uint32_t HDREXDE = (1U << 2);  ///< HDR Exit Pattern Detection Enable
        constexpr uint32_t NACKDE = (1U << 4);  ///< NACK Detection Enable
        constexpr uint32_t TENDE = (1U << 8);  ///< Transmit End Enable
        constexpr uint32_t ALE = (1U << 16);  ///< Arbitration Lost Enable
        constexpr uint32_t TODE = (1U << 20);  ///< Timeout Detection Enable
    }

    /// BIE Register bits
    namespace bie_bits {
        constexpr uint32_t STCNDDIE = (1U << 0);  ///< START Condition Detection Interrupt Enable
        constexpr uint32_t SPCNDDIE = (1U << 1);  ///< STOP Condition Detection Interrupt Enable
        constexpr uint32_t HDREXDIE = (1U << 2);  ///< HDR Exit Pattern Detection Interrupt Enable
        constexpr uint32_t NACKDIE = (1U << 4);  ///< NACK Detection Interrupt Enable
        constexpr uint32_t TENDIE = (1U << 8);  ///< Transmit End Interrupt Enable
        constexpr uint32_t ALIE = (1U << 16);  ///< Arbitration Lost Interrupt Enable
        constexpr uint32_t TODIE = (1U << 20);  ///< Timeout Detection Interrupt Enable
    }

    /// BSTFC Register bits
    namespace bstfc_bits {
        constexpr uint32_t STCNDDFC = (1U << 0);  ///< START condition Detection Force
        constexpr uint32_t SPCNDDFC = (1U << 1);  ///< STOP condition Detection Force
        constexpr uint32_t HDREXDFC = (1U << 2);  ///< HDR Exit Pattern Detection Force
        constexpr uint32_t NACKDFC = (1U << 4);  ///< NACK Detection Force
        constexpr uint32_t TENDFC = (1U << 8);  ///< Transmit End Force
        constexpr uint32_t ALFC = (1U << 16);  ///< Arbitration Lost Force
        constexpr uint32_t TODFC = (1U << 20);  ///< Timeout Detection Force
    }

    /// NTST Register bits
    namespace ntst_bits {
        constexpr uint32_t TDBEF0 = (1U << 0);  ///< Normal Transmit Data Buffer Empty Flag 0
        constexpr uint32_t RDBFF0 = (1U << 1);  ///< Normal Receive Data Buffer Full Flag 0
        constexpr uint32_t IBIQEFF = (1U << 2);  ///< Normal IBI Queue Empty/Full Flag
        constexpr uint32_t CMDQEF = (1U << 3);  ///< Normal Command Queue Empty Flag
        constexpr uint32_t RSPQFF = (1U << 4);  ///< Normal Response Queue Full Flag
        constexpr uint32_t TABTF = (1U << 5);  ///< Normal Transfer Abort Flag
        constexpr uint32_t TEF = (1U << 9);  ///< Normal Transfer Error Flag
        constexpr uint32_t RSQFF = (1U << 20);  ///< Normal Receive Status Queue Full Flag
    }

    /// NTSTE Register bits
    namespace ntste_bits {
        constexpr uint32_t TDBEE0 = (1U << 0);  ///< Normal Transmit Data Buffer Empty Enable 0
        constexpr uint32_t RDBFE0 = (1U << 1);  ///< Normal Receive Data Buffer Full Enable 0
        constexpr uint32_t IBIQEFE = (1U << 2);  ///< Normal IBI Queue Empty/Full Enable
        constexpr uint32_t CMDQEE = (1U << 3);  ///< Normal Command Queue Empty Enable
        constexpr uint32_t RSPQFE = (1U << 4);  ///< Normal Response Queue Full Enable
        constexpr uint32_t TABTE = (1U << 5);  ///< Normal Transfer Abort Enable
        constexpr uint32_t TEE = (1U << 9);  ///< Normal Transfer Error Enable
        constexpr uint32_t RSQFE = (1U << 20);  ///< Normal Receive Status Queue Full Enable
    }

    /// NTIE Register bits
    namespace ntie_bits {
        constexpr uint32_t TDBEIE0 = (1U << 0);  ///< Normal Transmit Data Buffer Empty Interrupt Enable 0
        constexpr uint32_t RDBFIE0 = (1U << 1);  ///< Normal Receive Data Buffer Full Interrupt Enable 0
        constexpr uint32_t IBIQEFIE = (1U << 2);  ///< Normal IBI Queue Empty/Full Interrupt Enable
        constexpr uint32_t CMDQEIE = (1U << 3);  ///< Normal Command Queue Empty Interrupt Enable
        constexpr uint32_t RSPQFIE = (1U << 4);  ///< Normal Response Queue Full Interrupt Enable
        constexpr uint32_t TABTIE = (1U << 5);  ///< Normal Transfer Abort Interrupt Enable
        constexpr uint32_t TEIE = (1U << 9);  ///< Normal Transfer Error Interrupt Enable
        constexpr uint32_t RSQFIE = (1U << 20);  ///< Normal Receive Status Queue Full Interrupt Enable
    }

    /// NTSTFC Register bits
    namespace ntstfc_bits {
        constexpr uint32_t TDBEFC0 = (1U << 0);  ///< Normal Transmit Data Buffer Empty Force 0
        constexpr uint32_t RDBFFC0 = (1U << 1);  ///< Normal Receive Data Buffer Full Force 0
        constexpr uint32_t IBIQEFFC = (1U << 2);  ///< Normal IBI Queue Empty/Full Force
        constexpr uint32_t CMDQEFC = (1U << 3);  ///< Normal Command Queue Empty Force
        constexpr uint32_t RSPQFFC = (1U << 4);  ///< Normal Response Queue Full Force
        constexpr uint32_t TABTFC = (1U << 5);  ///< Normal Transfer Abort Force
        constexpr uint32_t TEFC = (1U << 9);  ///< Normal Transfer Error Force
        constexpr uint32_t RSQFFC = (1U << 20);  ///< Normal Receive Status Queue Full Force
    }

    /// BCST Register bits
    namespace bcst_bits {
        constexpr uint32_t BFREF = (1U << 0);  ///< Bus Free Detection Flag
        constexpr uint32_t BAVLF = (1U << 1);  ///< Bus Available Detection Flag
        constexpr uint32_t BIDLF = (1U << 2);  ///< Bus Idle Detection Flag
    }

    /// SVST Register bits
    namespace svst_bits {
        constexpr uint32_t GCAF = (1U << 0);  ///< General Call Address Detection Flag
        constexpr uint32_t HSMCF = (1U << 5);  ///< Hs-mode Master Code Detection Flag
        constexpr uint32_t DVIDF = (1U << 6);  ///< Device-ID Address Detection Flag
        constexpr uint32_t HOAF = (1U << 15);  ///< Host Address Detection Flag
        constexpr uint32_t SVAF0 = (1U << 16);  ///< Slave Address Detection Flag 0
    }

    /// DATBAS%s Register bits
    namespace datbas%s_bits {
        constexpr uint32_t DVSTAD = (7 << 0);  ///< Device Static Address
        constexpr uint32_t DVIBIPL = (1U << 12);  ///< Device IBI Payload
        constexpr uint32_t DVSIRRJ = (1U << 13);  ///< Device In-Band Slave Interrupt Request Reject
        constexpr uint32_t DVMRRJ = (1U << 14);  ///< Device In-Band Master Request Reject
        constexpr uint32_t DVDYAD = (8 << 16);  ///< Device I3C Dynamic Address
        constexpr uint32_t DVNACK = (2 << 29);  ///< Device NACK Retry Count
        constexpr uint32_t DVTYP = (1U << 31);  ///< Device Type
    }

    /// EXDATBAS Register bits
    namespace exdatbas_bits {
        constexpr uint32_t EDSTAD = (7 << 0);  ///< Extended Device Static Address
        constexpr uint32_t EDDYAD = (8 << 16);  ///< Extended Device I3C Dynamic Address
        constexpr uint32_t EDNACK = (2 << 29);  ///< Extended Device NACK Retry Count
        constexpr uint32_t EDTYP = (1U << 31);  ///< Extended Device Type
    }

    /// SDATBAS0 Register bits
    namespace sdatbas0_bits {
        constexpr uint32_t SDSTAD = (10 << 0);  ///< Slave Device Static Address
        constexpr uint32_t SDADLS = (1U << 10);  ///< Slave Device Address Length Selection
        constexpr uint32_t SDIBIPL = (1U << 12);  ///< Slave Device IBI Payload
        constexpr uint32_t SDDYAD = (7 << 16);  ///< Slave Device I3C Dynamic Address
    }

    /// MSDCT%s Register bits
    namespace msdct%s_bits {
        constexpr uint32_t RBCR0 = (1U << 8);  ///< Max Data Speed Limitation
        constexpr uint32_t RBCR1 = (1U << 9);  ///< IBI Request Capable
        constexpr uint32_t RBCR2 = (1U << 10);  ///< IBI Payload
        constexpr uint32_t RBCR3 = (1U << 11);  ///< Offline Capable
        constexpr uint32_t RBCR76 = (2 << 14);  ///< Device Role
    }

    /// SVDCT Register bits
    namespace svdct_bits {
        constexpr uint32_t TDCR = (8 << 0);  ///< Transfar Device Characteristic Register
        constexpr uint32_t TBCR0 = (1U << 8);  ///< Max Data Speed Limitation
        constexpr uint32_t TBCR1 = (1U << 9);  ///< IBI Request Capable
        constexpr uint32_t TBCR2 = (1U << 10);  ///< IBI Payload
        constexpr uint32_t TBCR3 = (1U << 11);  ///< Offline Capable
        constexpr uint32_t TBCR76 = (2 << 14);  ///< Device Role
    }

    /// SVDVAD0 Register bits
    namespace svdvad0_bits {
        constexpr uint32_t SVAD = (10 << 16);  ///< Slave Address
        constexpr uint32_t SADLG = (1U << 27);  ///< Slave Address Length
        constexpr uint32_t SSTADV = (1U << 30);  ///< Slave Static Address Valid
        constexpr uint32_t SDYADV = (1U << 31);  ///< Slave Dynamic Address Valid
    }

    /// CSECMD Register bits
    namespace csecmd_bits {
        constexpr uint32_t SVIRQE = (1U << 0);  ///< Slave Interrupt Requests Enable
        constexpr uint32_t MSRQE = (1U << 1);  ///< Mastership Requests Enable
        constexpr uint32_t HJEVE = (1U << 3);  ///< Hot-Join Event Enable
    }

    /// CEACTST Register bits
    namespace ceactst_bits {
        constexpr uint32_t ACTST = (4 << 0);  ///< Activity State
    }

    /// CMWLG Register bits
    namespace cmwlg_bits {
        constexpr uint32_t MWLG = (16 << 0);  ///< Max Write Length
    }

    /// CMRLG Register bits
    namespace cmrlg_bits {
        constexpr uint32_t MRLG = (16 << 0);  ///< Max Read Length
        constexpr uint32_t IBIPSZ = (8 << 16);  ///< IBI Payload Size
    }

    /// CETSTMD Register bits
    namespace cetstmd_bits {
        constexpr uint32_t TSTMD = (8 << 0);  ///< Test Mode
    }

    /// CGDVST Register bits
    namespace cgdvst_bits {
        constexpr uint32_t PNDINT = (4 << 0);  ///< Pending Interrupt
        constexpr uint32_t PRTE = (1U << 5);  ///< Protocol Error
        constexpr uint32_t ACTMD = (2 << 6);  ///< Slave Devices current Activity Mode
        constexpr uint32_t VDRSV = (8 << 8);  ///< Vendor Reserved
    }

    /// CMDSPW Register bits
    namespace cmdspw_bits {
        constexpr uint32_t MSWDR = (3 << 0);  ///< Maximum Sustained Write Data Rate
    }

    /// CMDSPR Register bits
    namespace cmdspr_bits {
        constexpr uint32_t MSRDR = (3 << 0);  ///< Maximum Sustained Read Data Rate
        constexpr uint32_t CDTTIM = (3 << 3);  ///< Clock to Data Turnaround Time (TSCO)
    }

    /// CMDSPT Register bits
    namespace cmdspt_bits {
        constexpr uint32_t MRTTIM = (24 << 0);  ///< Maximum Read Turnaround Time
        constexpr uint32_t MRTE = (1U << 31);  ///< Maximum Read Turnaround Time Enable
    }

    /// CETSM Register bits
    namespace cetsm_bits {
        constexpr uint32_t FREQ = (8 << 8);  ///< Frequency Byte
        constexpr uint32_t INAC = (8 << 16);  ///< Inaccuracy Byte
    }

    /// BITCNT Register bits
    namespace bitcnt_bits {
        constexpr uint32_t BCNT = (5 << 0);  ///< Bit Counter
    }

    /// NQSTLV Register bits
    namespace nqstlv_bits {
        constexpr uint32_t CMDQFLV = (8 << 0);  ///< Normal Command Queue Free Level
        constexpr uint32_t RSPQLV = (8 << 8);  ///< Normal Response Queue Level
        constexpr uint32_t IBIQLV = (8 << 16);  ///< Normal IBI Queue Level
        constexpr uint32_t IBISCNT = (5 << 24);  ///< Normal IBI Status Count
    }

    /// NDBSTLV0 Register bits
    namespace ndbstlv0_bits {
        constexpr uint32_t TDBFLV = (8 << 0);  ///< Normal Transmit Data Buffer Free Level
        constexpr uint32_t RDBLV = (8 << 8);  ///< Normal Receive Data Buffer Level
    }

    /// NRSQSTLV Register bits
    namespace nrsqstlv_bits {
        constexpr uint32_t RSQLV = (8 << 0);  ///< Normal Receive Status Queue Level
    }

    /// PRSTDBG Register bits
    namespace prstdbg_bits {
        constexpr uint32_t SCILV = (1U << 0);  ///< SCL Line Signal Level
        constexpr uint32_t SDILV = (1U << 1);  ///< SDA Line Signal Level
        constexpr uint32_t SCOLV = (1U << 2);  ///< SCL Output Level
        constexpr uint32_t SDOLV = (1U << 3);  ///< SDA Output Level
    }

    /// MSERRCNT Register bits
    namespace mserrcnt_bits {
        constexpr uint32_t M2ECNT = (8 << 0);  ///< M2 Error Counter
    }

}

// ============================================================================
// AGTW0 Peripheral
// ============================================================================

namespace agtw0 {
    /// Base addresses
    constexpr uint32_t AGTW0_BASE = 0x40084000;

    /// AGTW0 Register structure
    struct Registers {
        volatile uint32_t AGT;  ///< Offset: 0x00 - AGT Counter Register
        volatile uint32_t AGTCMA;  ///< Offset: 0x04 - AGT CounterCompare Match A Register
        volatile uint32_t AGTCMB;  ///< Offset: 0x08 - AGT CounterCompare Match B Register
        volatile uint32_t AGTCR;  ///< Offset: 0x0C - AGT Control Register
        volatile uint32_t AGTMR1;  ///< Offset: 0x0D - AGT Mode Register 1
        volatile uint32_t AGTMR2;  ///< Offset: 0x0E - AGT Mode Register 2
        volatile uint32_t AGTIOSEL;  ///< Offset: 0x0F - AGT Pin Select Register
        volatile uint32_t AGTIOC;  ///< Offset: 0x10 - AGT I/O Control Register
        volatile uint32_t AGTISR;  ///< Offset: 0x11 - AGT Event Pin Select Register
        volatile uint32_t AGTCMSR;  ///< Offset: 0x12 - AGT Compare Match Function Select Register
    };

    /// Peripheral instances
    inline Registers* AGTW0 = reinterpret_cast<Registers*>(AGTW0_BASE);

    // Bit definitions
    /// AGTCR Register bits
    namespace agtcr_bits {
        constexpr uint32_t TSTART = (1U << 0);  ///< AGT Count Start
        constexpr uint32_t TCSTF = (1U << 1);  ///< AGT Count Status Flag
        constexpr uint32_t TSTOP = (1U << 2);  ///< AGT Count Forced Stop
        constexpr uint32_t TEDGF = (1U << 4);  ///< Active Edge Judgment Flag
        constexpr uint32_t TUNDF = (1U << 5);  ///< Underflow Flag
        constexpr uint32_t TCMAF = (1U << 6);  ///< Compare Match A Flag
        constexpr uint32_t TCMBF = (1U << 7);  ///< Compare Match B Flag
    }

    /// AGTMR1 Register bits
    namespace agtmr1_bits {
        constexpr uint32_t TMOD = (3 << 0);  ///< Operating Mode
        constexpr uint32_t TEDGPL = (1U << 3);  ///< Edge Polarity
        constexpr uint32_t TCK = (3 << 4);  ///< Count Source
    }

    /// AGTMR2 Register bits
    namespace agtmr2_bits {
        constexpr uint32_t CKS = (3 << 0);  ///< AGTLCLK Count Source Clock Frequency Division Ratio
        constexpr uint32_t LPM = (1U << 7);  ///< Low Power Mode
    }

    /// AGTIOSEL Register bits
    namespace agtiosel_bits {
        constexpr uint32_t TIES = (1U << 4);  ///< AGTIOn Pin Input Enable
    }

    /// AGTIOC Register bits
    namespace agtioc_bits {
        constexpr uint32_t TEDGSEL = (1U << 0);  ///< I/O Polarity Switch
        constexpr uint32_t TOE = (1U << 2);  ///< AGTOn pin Output Enable
        constexpr uint32_t TIPF = (2 << 4);  ///< Input Filter
        constexpr uint32_t TIOGT = (2 << 6);  ///< Count Control
    }

    /// AGTISR Register bits
    namespace agtisr_bits {
        constexpr uint32_t EEPS = (1U << 2);  ///< AGTEEn Polarity Selection
    }

    /// AGTCMSR Register bits
    namespace agtcmsr_bits {
        constexpr uint32_t TCMEA = (1U << 0);  ///< AGT Compare Match A Register Enable
        constexpr uint32_t TOEA = (1U << 1);  ///< AGTOAn Pin Output Enable
        constexpr uint32_t TOPOLA = (1U << 2);  ///< AGTOAn Pin Polarity Select
        constexpr uint32_t TCMEB = (1U << 4);  ///< AGT Compare Match B Register Enable
        constexpr uint32_t TOEB = (1U << 5);  ///< AGTOBn Pin Output Enable
        constexpr uint32_t TOPOLB = (1U << 6);  ///< AGTOBn Pin Polarity Select
    }

}

// ============================================================================
// AGTW1 Peripheral
// ============================================================================

namespace agtw1 {
    /// Base addresses
    constexpr uint32_t AGTW1_BASE = 0x40084100;

    /// AGTW1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AGTW1 = reinterpret_cast<Registers*>(AGTW1_BASE);

}

// ============================================================================
// FLCN Peripheral
// ============================================================================

namespace flcn {
    /// Base addresses
    constexpr uint32_t FLCN_BASE = 0x407EC000;

    /// FLCN Register structure
    struct Registers {
        volatile uint32_t DFLCTL;  ///< Offset: 0x90 - Data Flash Control Register
        volatile uint32_t FPMCR;  ///< Offset: 0x100 - Flash P/E Mode Control Register
        volatile uint32_t FASR;  ///< Offset: 0x104 - Flash Area Select Register
        volatile uint32_t FSARL;  ///< Offset: 0x108 - Flash Processing Start Address Register L
        volatile uint32_t FSARH;  ///< Offset: 0x110 - Flash Processing Start Address Register H
        volatile uint32_t FCR;  ///< Offset: 0x114 - Flash Control Register
        volatile uint32_t FEARL;  ///< Offset: 0x118 - Flash Processing End Address Register L
        volatile uint32_t FEARH;  ///< Offset: 0x120 - Flash Processing End Address Register H
        volatile uint32_t FRESETR;  ///< Offset: 0x124 - Flash Reset Register
        volatile uint32_t FSTATR1;  ///< Offset: 0x12C - Flash Status Register 1
        volatile uint32_t FWBL0;  ///< Offset: 0x130 - Flash Write Buffer Register L0
        volatile uint32_t FWBH0;  ///< Offset: 0x138 - Flash Write Buffer Register H0
        volatile uint32_t FPR;  ///< Offset: 0x180 - Protection Unlock Register
        volatile uint32_t FPSR;  ///< Offset: 0x184 - Protection Unlock Status Register
        volatile uint32_t FRBL0;  ///< Offset: 0x188 - Flash Read Buffer Register L0
        volatile uint32_t FRBH0;  ///< Offset: 0x190 - Flash Read Buffer Register H0
        volatile uint32_t FSCMR;  ///< Offset: 0x1C0 - Flash Start-Up Setting Monitor Register
        volatile uint32_t FAWSMR;  ///< Offset: 0x1C8 - Flash Access Window Start Address Monitor Register
        volatile uint32_t FAWEMR;  ///< Offset: 0x1D0 - Flash Access Window End Address Monitor Register
        volatile uint32_t FISR;  ///< Offset: 0x1D8 - Flash Initial Setting Register
        volatile uint32_t FEXCR;  ///< Offset: 0x1DC - Flash Extra Area Control Register
        volatile uint32_t FEAML;  ///< Offset: 0x1E0 - Flash Error Address Monitor Register L
        volatile uint32_t FEAMH;  ///< Offset: 0x1E8 - Flash Error Address Monitor Register H
        volatile uint32_t FSTATR2;  ///< Offset: 0x1F0 - Flash Status Register 2
        volatile uint32_t TSCDR;  ///< Offset: 0x228 - Temperature Sensor Calibration Data Register
        volatile uint32_t FENTRYR;  ///< Offset: 0x3FB0 - Flash P/E Mode Entry Register
        volatile uint32_t FLDWAITR;  ///< Offset: 0x3FC4 - Memory Wait Cycle Control Register for Data Flash
        volatile uint32_t PFBER;  ///< Offset: 0x3FC8 - Prefetch Buffer Enable Register
    };

    /// Peripheral instances
    inline Registers* FLCN = reinterpret_cast<Registers*>(FLCN_BASE);

    // Bit definitions
    /// DFLCTL Register bits
    namespace dflctl_bits {
        constexpr uint32_t DFLEN = (1U << 0);  ///< Data Flash Access Enable
    }

    /// FPMCR Register bits
    namespace fpmcr_bits {
        constexpr uint32_t FMS0 = (1U << 1);  ///< Flash Operating Mode Select 0
        constexpr uint32_t RPDIS = (1U << 3);  ///< Code Flash P/E Disable
        constexpr uint32_t FMS1 = (1U << 4);  ///< Flash Operating Mode Select 1
    }

    /// FASR Register bits
    namespace fasr_bits {
        constexpr uint32_t EXS = (1U << 0);  ///< Extra Area Select
    }

    /// FSARL Register bits
    namespace fsarl_bits {
        constexpr uint32_t FSARL = (16 << 0);  ///< Flash Processing Start Address L
    }

    /// FSARH Register bits
    namespace fsarh_bits {
        constexpr uint32_t FSARH = (16 << 0);  ///< Flash Processing Start Address H
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t CMD = (4 << 0);  ///< Software Command Setting
        constexpr uint32_t DRC = (1U << 4);  ///< Data Read Completion
        constexpr uint32_t STOP = (1U << 6);  ///< Forced Processing Stop
        constexpr uint32_t OPST = (1U << 7);  ///< Processing Start
    }

    /// FEARL Register bits
    namespace fearl_bits {
        constexpr uint32_t FEARL = (16 << 0);  ///< Flash Processing End Address L
    }

    /// FEARH Register bits
    namespace fearh_bits {
        constexpr uint32_t FEARH = (16 << 0);  ///< Flash Processing End Address H
    }

    /// FRESETR Register bits
    namespace fresetr_bits {
        constexpr uint32_t FRESET = (1U << 0);  ///< Software reset of the registers
    }

    /// FSTATR1 Register bits
    namespace fstatr1_bits {
        constexpr uint32_t DRRDY = (1U << 1);  ///< Data Read Ready Flag
        constexpr uint32_t FRDY = (1U << 6);  ///< Flash Ready Flag
        constexpr uint32_t EXRDY = (1U << 7);  ///< Extra Area Ready Flag
    }

    /// FWBL0 Register bits
    namespace fwbl0_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Flash Write Buffer L0
    }

    /// FWBH0 Register bits
    namespace fwbh0_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Flash Write Buffer H0
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FPR = (8 << 0);  ///< Protection Unlock
    }

    /// FPSR Register bits
    namespace fpsr_bits {
        constexpr uint32_t PERR = (1U << 0);  ///< Protect Error Flag
    }

    /// FRBL0 Register bits
    namespace frbl0_bits {
        constexpr uint32_t RDATA = (16 << 0);  ///< Flash Read Buffer L0
    }

    /// FRBH0 Register bits
    namespace frbh0_bits {
        constexpr uint32_t RDATA = (16 << 0);  ///< Flash Read Buffer H0
    }

    /// FSCMR Register bits
    namespace fscmr_bits {
        constexpr uint32_t SASMF = (1U << 8);  ///< Startup Area Setting Monitor Flag
        constexpr uint32_t FSPR = (1U << 14);  ///< Access Window Protection Flag
    }

    /// FAWSMR Register bits
    namespace fawsmr_bits {
        constexpr uint32_t FAWS = (11 << 0);  ///< Access Window Start Address
        constexpr uint32_t FSPR = (1U << 15);  ///< Access Window Protection Flag
    }

    /// FAWEMR Register bits
    namespace fawemr_bits {
        constexpr uint32_t FAWE = (11 << 0);  ///< Access Window End Address
        constexpr uint32_t SASMF = (1U << 15);  ///< Startup Area Setting Monitor Flag
    }

    /// FISR Register bits
    namespace fisr_bits {
        constexpr uint32_t PCKA = (6 << 0);  ///< Flash-IF Clock Notification
        constexpr uint32_t SAS = (2 << 6);  ///< Startup Area Select
    }

    /// FEXCR Register bits
    namespace fexcr_bits {
        constexpr uint32_t CMD = (3 << 0);  ///< Software Command Setting
        constexpr uint32_t OPST = (1U << 7);  ///< Processing Start
    }

    /// FEAML Register bits
    namespace feaml_bits {
        constexpr uint32_t FEAML = (16 << 0);  ///< Flash Error Address Monitor Register L
    }

    /// FEAMH Register bits
    namespace feamh_bits {
        constexpr uint32_t FEAMH = (16 << 0);  ///< Flash Error Address Monitor Register H
    }

    /// FSTATR2 Register bits
    namespace fstatr2_bits {
        constexpr uint32_t ERERR = (1U << 0);  ///< Erase Error Flag
        constexpr uint32_t PRGERR = (1U << 1);  ///< Program Error Flag
        constexpr uint32_t PRGERR01 = (1U << 2);  ///< Program Error Flag 01
        constexpr uint32_t BCERR = (1U << 3);  ///< Blank Check Error Flag
        constexpr uint32_t ILGLERR = (1U << 4);  ///< Illegal Command Error Flag
        constexpr uint32_t EILGLERR = (1U << 5);  ///< Extra Area Illegal Command Error Flag
    }

    /// TSCDR Register bits
    namespace tscdr_bits {
        constexpr uint32_t TSCDR = (16 << 0);  ///< Temperature Sensor Calibration Data
    }

    /// FENTRYR Register bits
    namespace fentryr_bits {
        constexpr uint32_t FENTRY0 = (1U << 0);  ///< Code Flash P/E Mode Entry 0
        constexpr uint32_t FENTRYD = (1U << 7);  ///< Data Flash P/E Mode Entry
        constexpr uint32_t FEKEY = (8 << 8);  ///< Key Code
    }

    /// FLDWAITR Register bits
    namespace fldwaitr_bits {
        constexpr uint32_t FLDWAIT1 = (1U << 0);  ///< Memory Wait Cycle Select for Data Flash
    }

    /// PFBER Register bits
    namespace pfber_bits {
        constexpr uint32_t PFBE = (1U << 0);  ///< Prefetch Buffer Enable bit
    }

}


} // namespace alloy::generated::r7fa2e2a7

#endif // ALLOY_GENERATED_R7FA2E2A7_PERIPHERALS_HPP