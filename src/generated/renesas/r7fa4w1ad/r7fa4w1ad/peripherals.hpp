/// Auto-generated code for R7FA4W1AD
/// Generated by Alloy Code Generator
/// Source: renesas_r7fa4w1ad.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:21:56
#ifndef ALLOY_GENERATED_R7FA4W1AD_PERIPHERALS_HPP
#define ALLOY_GENERATED_R7FA4W1AD_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::r7fa4w1ad {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// POEG Peripheral
// ============================================================================

namespace poeg {
    /// Base addresses
    constexpr uint32_t POEG_BASE = 0x40042000;

    /// POEG Register structure
    struct Registers {
        volatile uint32_t POEGG%s;  ///< Offset: 0x00 - POEG Group %s Setting Register
    };

    /// Peripheral instances
    inline Registers* POEG = reinterpret_cast<Registers*>(POEG_BASE);

    // Bit definitions
    /// POEGG%s Register bits
    namespace poegg%s_bits {
        constexpr uint32_t NFCS = (2 << 30);  ///< Noise Filter Clock Select
        constexpr uint32_t NFEN = (1U << 29);  ///< Noise Filter Enable
        constexpr uint32_t INV = (1U << 28);  ///< GTETRG Input Reverse
        constexpr uint32_t Reserved = (11 << 17);  ///< These bits are read as 00000000000. The write value should be 00000000000.
        constexpr uint32_t ST = (1U << 16);  ///< GTETRG Input Status Flag
        constexpr uint32_t OSTPE = (1U << 6);  ///< Oscillation Stop Detection EnableNote: Can be modified only once after a reset.
        constexpr uint32_t IOCE = (1U << 5);  ///< Output-disable Request Enable from GPTNote: Can be modified only once after a reset.
        constexpr uint32_t PIDE = (1U << 4);  ///< Port Input Detection EnableNote: Can be modified only once after a reset.
        constexpr uint32_t SSF = (1U << 3);  ///< Software Stop Flag
        constexpr uint32_t OSTPF = (1U << 2);  ///< Oscillation Stop Detection Flag
        constexpr uint32_t IOCF = (1U << 1);  ///< Output-disable Request Detection Flag from GPT
        constexpr uint32_t PIDF = (1U << 0);  ///< Port Input Detection Flag
    }

}

// ============================================================================
// GPT320 Peripheral
// ============================================================================

namespace gpt320 {
    /// Base addresses
    constexpr uint32_t GPT320_BASE = 0x40078000;

    /// GPT320 Register structure
    struct Registers {
        volatile uint32_t GTWP;  ///< Offset: 0x00 - General PWM Timer Write-Protection Register
        volatile uint32_t GTSTR;  ///< Offset: 0x04 - General PWM Timer Software Start Register
        volatile uint32_t GTSTP;  ///< Offset: 0x08 - General PWM Timer Software Stop Register
        volatile uint32_t GTCLR;  ///< Offset: 0x0C - General PWM Timer Software Clear Register
        volatile uint32_t GTSSR;  ///< Offset: 0x10 - General PWM Timer Start Source Select Register
        volatile uint32_t GTPSR;  ///< Offset: 0x14 - General PWM Timer Stop Source Select Register
        volatile uint32_t GTCSR;  ///< Offset: 0x18 - General PWM Timer Clear Source Select Register
        volatile uint32_t GTUPSR;  ///< Offset: 0x1C - General PWM Timer Up Count Source Select Register
        volatile uint32_t GTDNSR;  ///< Offset: 0x20 - General PWM Timer Down Count Source Select Register
        volatile uint32_t GTICASR;  ///< Offset: 0x24 - General PWM Timer Input Capture Source Select Register A
        volatile uint32_t GTICBSR;  ///< Offset: 0x28 - General PWM Timer Input Capture Source Select Register B
        volatile uint32_t GTCR;  ///< Offset: 0x2C - General PWM Timer Control Register
        volatile uint32_t GTUDDTYC;  ///< Offset: 0x30 - General PWM Timer Count Direction and Duty Setting Register
        volatile uint32_t GTIOR;  ///< Offset: 0x34 - General PWM Timer I/O Control Register
        volatile uint32_t GTINTAD;  ///< Offset: 0x38 - General PWM Timer Interrupt Output Setting Register
        volatile uint32_t GTST;  ///< Offset: 0x3C - General PWM Timer Status Register
        volatile uint32_t GTBER;  ///< Offset: 0x40 - General PWM Timer Buffer Enable Register
        volatile uint32_t GTCNT;  ///< Offset: 0x48 - General PWM Timer Counter
        volatile uint32_t GTCCRA;  ///< Offset: 0x4C - General PWM Timer Compare Capture Register A
        volatile uint32_t GTCCRB;  ///< Offset: 0x50 - General PWM Timer Compare Capture Register B
        volatile uint32_t GTCCRC;  ///< Offset: 0x54 - General PWM Timer Compare Capture Register C
        volatile uint32_t GTCCRE;  ///< Offset: 0x58 - General PWM Timer Compare Capture Register E
        volatile uint32_t GTCCRD;  ///< Offset: 0x5C - General PWM Timer Compare Capture Register D
        volatile uint32_t GTCCRF;  ///< Offset: 0x60 - General PWM Timer Compare Capture Register F
        volatile uint32_t GTPR;  ///< Offset: 0x64 - General PWM Timer Cycle Setting Register
        volatile uint32_t GTPBR;  ///< Offset: 0x68 - General PWM Timer Cycle Setting Buffer Register
        volatile uint32_t GTDTCR;  ///< Offset: 0x88 - General PWM Timer Dead Time Control Register
        volatile uint32_t GTDVU;  ///< Offset: 0x8C - General PWM Timer Dead Time Value Register U
    };

    /// Peripheral instances
    inline Registers* GPT320 = reinterpret_cast<Registers*>(GPT320_BASE);

    // Bit definitions
    /// GTWP Register bits
    namespace gtwp_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PRKEY = (8 << 8);  ///< GTWP Key Code
        constexpr uint32_t WP = (1U << 0);  ///< Register Write Disable
    }

    /// GTSTR Register bits
    namespace gtstr_bits {
        constexpr uint32_t Reserved = (22 << 10);  ///< These bits are read as 0000000000000000000000. The write value should be 0000000000000000000000.
        constexpr uint32_t CSTRT9 = (1U << 9);  ///< Channel 9 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT8 = (1U << 8);  ///< Channel 8 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT7 = (1U << 7);  ///< Channel 7 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT6 = (1U << 6);  ///< Channel 6 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT5 = (1U << 5);  ///< Channel 5 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT4 = (1U << 4);  ///< Channel 4 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT3 = (1U << 3);  ///< Channel 3 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT2 = (1U << 2);  ///< Channel 2 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT1 = (1U << 1);  ///< Channel 1 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT0 = (1U << 0);  ///< Channel 0 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
    }

    /// GTSTP Register bits
    namespace gtstp_bits {
        constexpr uint32_t Reserved = (22 << 10);  ///< These bits are read as 1111111111111111111111. The write value should be 1111111111111111111111.
        constexpr uint32_t CSTOP9 = (1U << 9);  ///< Channel 9 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP8 = (1U << 8);  ///< Channel 8 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP7 = (1U << 7);  ///< Channel 7 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP6 = (1U << 6);  ///< Channel 6 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP5 = (1U << 5);  ///< Channel 5 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP4 = (1U << 4);  ///< Channel 4 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP3 = (1U << 3);  ///< Channel 3 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP2 = (1U << 2);  ///< Channel 2 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP1 = (1U << 1);  ///< Channel 1 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP0 = (1U << 0);  ///< Channel 0 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
    }

    /// GTCLR Register bits
    namespace gtclr_bits {
        constexpr uint32_t Reserved = (22 << 10);  ///< The write value should be 0000000000000000000000.
        constexpr uint32_t CCLR9 = (1U << 9);  ///< Channel 9 GTCNT Count Clear
        constexpr uint32_t CCLR8 = (1U << 8);  ///< Channel 8 GTCNT Count Clear
        constexpr uint32_t CCLR7 = (1U << 7);  ///< Channel 7 GTCNT Count Clear
        constexpr uint32_t CCLR6 = (1U << 6);  ///< Channel 6 GTCNT Count Clear
        constexpr uint32_t CCLR5 = (1U << 5);  ///< Channel 5 GTCNT Count Clear
        constexpr uint32_t CCLR4 = (1U << 4);  ///< Channel 4 GTCNT Count Clear
        constexpr uint32_t CCLR3 = (1U << 3);  ///< Channel 3 GTCNT Count Clear
        constexpr uint32_t CCLR2 = (1U << 2);  ///< Channel 2 GTCNT Count Clear
        constexpr uint32_t CCLR1 = (1U << 1);  ///< Channel 1 GTCNT Count Clear
        constexpr uint32_t CCLR0 = (1U << 0);  ///< Channel 0 GTCNT Count Clear
    }

    /// GTSSR Register bits
    namespace gtssr_bits {
        constexpr uint32_t CSTRT = (1U << 31);  ///< Software Source Counter Start Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t SSELCH = (1U << 23);  ///< ELCH Event Source Counter Start Enable
        constexpr uint32_t SSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Start Enable
        constexpr uint32_t SSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Start Enable
        constexpr uint32_t SSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Start Enable
        constexpr uint32_t SSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Start Enable
        constexpr uint32_t SSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Start Enable
        constexpr uint32_t SSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Start Enable
        constexpr uint32_t SSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Start Enable
        constexpr uint32_t SSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Start Enable
    }

    /// GTPSR Register bits
    namespace gtpsr_bits {
        constexpr uint32_t CSTOP = (1U << 31);  ///< Software Source Counter Stop Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t PSELCH = (1U << 23);  ///< ELCH Event Source Counter Stop Enable
        constexpr uint32_t PSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Stop Enable
        constexpr uint32_t PSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Stop Enable
        constexpr uint32_t PSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Stop Enable
        constexpr uint32_t PSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Stop Enable
        constexpr uint32_t PSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Stop Enable
        constexpr uint32_t PSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Stop Enable
        constexpr uint32_t PSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Stop Enable
        constexpr uint32_t PSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Stop Enable
    }

    /// GTCSR Register bits
    namespace gtcsr_bits {
        constexpr uint32_t CCLR = (1U << 31);  ///< Software Source Counter Clear Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t CSELCH = (1U << 23);  ///< ELCH Event Source Counter Clear Enable
        constexpr uint32_t CSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Clear Enable
        constexpr uint32_t CSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Clear Enable
        constexpr uint32_t CSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Clear Enable
        constexpr uint32_t CSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Clear Enable
        constexpr uint32_t CSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Clear Enable
        constexpr uint32_t CSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Clear Enable
        constexpr uint32_t CSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Clear Enable
        constexpr uint32_t CSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Clear Enable
    }

    /// GTUPSR Register bits
    namespace gtupsr_bits {
        constexpr uint32_t USELCH = (1U << 23);  ///< ELCH Event Source Counter Count Up Enable
        constexpr uint32_t USELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Up Enable
        constexpr uint32_t USELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Up Enable
        constexpr uint32_t USELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Up Enable
        constexpr uint32_t USELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Up Enable
        constexpr uint32_t USELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Up Enable
        constexpr uint32_t USELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Up Enable
        constexpr uint32_t USELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Up Enable
        constexpr uint32_t USCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Up Enable
    }

    /// GTDNSR Register bits
    namespace gtdnsr_bits {
        constexpr uint32_t DSELCH = (1U << 23);  ///< ELCH Event Source Counter Count Down Enable
        constexpr uint32_t DSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Down Enable
        constexpr uint32_t DSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Down Enable
        constexpr uint32_t DSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Down Enable
        constexpr uint32_t DSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Down Enable
        constexpr uint32_t DSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Down Enable
        constexpr uint32_t DSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Down Enable
        constexpr uint32_t DSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Down Enable
        constexpr uint32_t DSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Down Enable
    }

    /// GTICASR Register bits
    namespace gticasr_bits {
        constexpr uint32_t ASELCH = (1U << 23);  ///< ELCH Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable
    }

    /// GTICBSR Register bits
    namespace gticbsr_bits {
        constexpr uint32_t BSELCH = (1U << 23);  ///< ELCH Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable
    }

    /// GTCR Register bits
    namespace gtcr_bits {
        constexpr uint32_t TPCS = (3 << 24);  ///< Timer Prescaler Select
        constexpr uint32_t Reserved = (15 << 1);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
        constexpr uint32_t MD = (3 << 16);  ///< Mode Select
        constexpr uint32_t CST = (1U << 0);  ///< Count Start
    }

    /// GTUDDTYC Register bits
    namespace gtuddtyc_bits {
        constexpr uint32_t OBDTYR = (1U << 27);  ///< GTIOCB Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OBDTYF = (1U << 26);  ///< Forcible GTIOCB Output Duty Setting
        constexpr uint32_t OBDTY = (2 << 24);  ///< GTIOCB Output Duty Setting
        constexpr uint32_t Reserved = (4 << 20);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t OADTYR = (1U << 19);  ///< GTIOCA Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OADTYF = (1U << 18);  ///< Forcible GTIOCA Output Duty Setting
        constexpr uint32_t OADTY = (2 << 16);  ///< GTIOCA Output Duty Setting
        constexpr uint32_t UDF = (1U << 1);  ///< Forcible Count Direction Setting
        constexpr uint32_t UD = (1U << 0);  ///< Count Direction Setting
    }

    /// GTIOR Register bits
    namespace gtior_bits {
        constexpr uint32_t NFCSB = (2 << 30);  ///< Noise Filter B Sampling Clock Select
        constexpr uint32_t NFBEN = (1U << 29);  ///< Noise Filter B Enable
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t OBDF = (2 << 25);  ///< GTIOCB Pin Disable Value Setting
        constexpr uint32_t OBE = (1U << 24);  ///< GTIOCB Pin Output Enable
        constexpr uint32_t OBHLD = (1U << 23);  ///< GTIOCB Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OBDFLT = (1U << 22);  ///< GTIOCB Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOB = (5 << 16);  ///< GTIOCB Pin Function Select
        constexpr uint32_t NFCSA = (2 << 14);  ///< Noise Filter A Sampling Clock Select
        constexpr uint32_t NFAEN = (1U << 13);  ///< Noise Filter A Enable
        constexpr uint32_t OADF = (2 << 9);  ///< GTIOCA Pin Disable Value Setting
        constexpr uint32_t OAE = (1U << 8);  ///< GTIOCA Pin Output Enable
        constexpr uint32_t OAHLD = (1U << 7);  ///< GTIOCA Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OADFLT = (1U << 6);  ///< GTIOCA Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOA = (5 << 0);  ///< GTIOCA Pin Function Select
    }

    /// GTINTAD Register bits
    namespace gtintad_bits {
        constexpr uint32_t GRPABL = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t GRPABH = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t Reserved = (24 << 0);  ///< These bits are read as 000000000000000000000000. The write value should be 000000000000000000000000.
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disable Source Select
    }

    /// GTST Register bits
    namespace gtst_bits {
        constexpr uint32_t OABLF = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t OABHF = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t Reserved = (7 << 8);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ODF = (1U << 24);  ///< Output Disable Flag
        constexpr uint32_t TUCF = (1U << 15);  ///< Count Direction Flag
        constexpr uint32_t TCFPU = (1U << 7);  ///< Underflow Flag
        constexpr uint32_t TCPFO = (1U << 6);  ///< Overflow Flag
        constexpr uint32_t TCFF = (1U << 5);  ///< Input Compare Match Flag F
        constexpr uint32_t TCFE = (1U << 4);  ///< Input Compare Match Flag E
        constexpr uint32_t TCFD = (1U << 3);  ///< Input Compare Match Flag D
        constexpr uint32_t TCFC = (1U << 2);  ///< Input Compare Match Flag C
        constexpr uint32_t TCFB = (1U << 1);  ///< Input Capture/Compare Match Flag B
        constexpr uint32_t TCFA = (1U << 0);  ///< Input Capture/Compare Match Flag A
    }

    /// GTBER Register bits
    namespace gtber_bits {
        constexpr uint32_t CCRSWT = (1U << 22);  ///< GTCCRA and GTCCRB Forcible Buffer OperationThis bit is read as 0.
        constexpr uint32_t PR = (2 << 20);  ///< GTPR Buffer Operation
        constexpr uint32_t CCRB = (2 << 18);  ///< GTCCRB Buffer Operation
        constexpr uint32_t CCRA = (2 << 16);  ///< GTCCRA Buffer Operation
        constexpr uint32_t BD = (2 << 0);  ///< BD[1]: GTPR Buffer Operation DisableBD[0]: GTCCR Buffer Operation Disable
    }

    /// GTCNT Register bits
    namespace gtcnt_bits {
        constexpr uint32_t GTCNT = (32 << 0);  ///< Counter
    }

    /// GTCCRA Register bits
    namespace gtccra_bits {
        constexpr uint32_t GTCCRA = (32 << 0);  ///< Compare Capture Register A
    }

    /// GTCCRB Register bits
    namespace gtccrb_bits {
        constexpr uint32_t GTCCRB = (32 << 0);  ///< Compare Capture Register B
    }

    /// GTCCRC Register bits
    namespace gtccrc_bits {
        constexpr uint32_t GTCCRC = (32 << 0);  ///< Compare Capture Register C
    }

    /// GTCCRE Register bits
    namespace gtccre_bits {
        constexpr uint32_t GTCCRE = (32 << 0);  ///< Compare Capture Register E
    }

    /// GTCCRD Register bits
    namespace gtccrd_bits {
        constexpr uint32_t GTCCRD = (32 << 0);  ///< Compare Capture Register D
    }

    /// GTCCRF Register bits
    namespace gtccrf_bits {
        constexpr uint32_t GTCCRF = (32 << 0);  ///< Compare Capture Register F
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GTPR = (32 << 0);  ///< Cycle Setting Register
    }

    /// GTPBR Register bits
    namespace gtpbr_bits {
        constexpr uint32_t GTPBR = (32 << 0);  ///< Cycle Setting Buffer Register
    }

    /// GTDTCR Register bits
    namespace gtdtcr_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t TDE = (1U << 0);  ///< Negative-Phase Waveform Setting
    }

    /// GTDVU Register bits
    namespace gtdvu_bits {
        constexpr uint32_t GTDVU = (32 << 0);  ///< Dead Time Value Register U
    }

}

// ============================================================================
// GPT321 Peripheral
// ============================================================================

namespace gpt321 {
    /// Base addresses
    constexpr uint32_t GPT321_BASE = 0x40078100;

    /// GPT321 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT321 = reinterpret_cast<Registers*>(GPT321_BASE);

}

// ============================================================================
// GPT322 Peripheral
// ============================================================================

namespace gpt322 {
    /// Base addresses
    constexpr uint32_t GPT322_BASE = 0x40078200;

    /// GPT322 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT322 = reinterpret_cast<Registers*>(GPT322_BASE);

}

// ============================================================================
// GPT323 Peripheral
// ============================================================================

namespace gpt323 {
    /// Base addresses
    constexpr uint32_t GPT323_BASE = 0x40078300;

    /// GPT323 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT323 = reinterpret_cast<Registers*>(GPT323_BASE);

}

// ============================================================================
// GPT164 Peripheral
// ============================================================================

namespace gpt164 {
    /// Base addresses
    constexpr uint32_t GPT164_BASE = 0x40078400;

    /// GPT164 Register structure
    struct Registers {
        volatile uint32_t GTWP;  ///< Offset: 0x00 - General PWM Timer Write-Protection Register
        volatile uint32_t GTSTR;  ///< Offset: 0x04 - General PWM Timer Software Start Register
        volatile uint32_t GTSTP;  ///< Offset: 0x08 - General PWM Timer Software Stop Register
        volatile uint32_t GTCLR;  ///< Offset: 0x0C - General PWM Timer Software Clear Register
        volatile uint32_t GTSSR;  ///< Offset: 0x10 - General PWM Timer Start Source Select Register
        volatile uint32_t GTPSR;  ///< Offset: 0x14 - General PWM Timer Stop Source Select Register
        volatile uint32_t GTCSR;  ///< Offset: 0x18 - General PWM Timer Clear Source Select Register
        volatile uint32_t GTUPSR;  ///< Offset: 0x1C - General PWM Timer Up Count Source Select Register
        volatile uint32_t GTDNSR;  ///< Offset: 0x20 - General PWM Timer Down Count Source Select Register
        volatile uint32_t GTICASR;  ///< Offset: 0x24 - General PWM Timer Input Capture Source Select Register A
        volatile uint32_t GTICBSR;  ///< Offset: 0x28 - General PWM Timer Input Capture Source Select Register B
        volatile uint32_t GTCR;  ///< Offset: 0x2C - General PWM Timer Control Register
        volatile uint32_t GTUDDTYC;  ///< Offset: 0x30 - General PWM Timer Count Direction and Duty Setting Register
        volatile uint32_t GTIOR;  ///< Offset: 0x34 - General PWM Timer I/O Control Register
        volatile uint32_t GTINTAD;  ///< Offset: 0x38 - General PWM Timer Interrupt Output Setting Register
        volatile uint32_t GTST;  ///< Offset: 0x3C - General PWM Timer Status Register
        volatile uint32_t GTBER;  ///< Offset: 0x40 - General PWM Timer Buffer Enable Register
        volatile uint32_t GTCNT;  ///< Offset: 0x48 - General PWM Timer Counter
        volatile uint32_t GTCCRA;  ///< Offset: 0x4C - General PWM Timer Compare Capture Register A
        volatile uint32_t GTCCRB;  ///< Offset: 0x50 - General PWM Timer Compare Capture Register B
        volatile uint32_t GTCCRC;  ///< Offset: 0x54 - General PWM Timer Compare Capture Register C
        volatile uint32_t GTCCRE;  ///< Offset: 0x58 - General PWM Timer Compare Capture Register E
        volatile uint32_t GTCCRD;  ///< Offset: 0x5C - General PWM Timer Compare Capture Register D
        volatile uint32_t GTCCRF;  ///< Offset: 0x60 - General PWM Timer Compare Capture Register F
        volatile uint32_t GTPR;  ///< Offset: 0x64 - General PWM Timer Cycle Setting Register
        volatile uint32_t GTPBR;  ///< Offset: 0x68 - General PWM Timer Cycle Setting Buffer Register
        volatile uint32_t GTDTCR;  ///< Offset: 0x88 - General PWM Timer Dead Time Control Register
        volatile uint32_t GTDVU;  ///< Offset: 0x8C - General PWM Timer Dead Time Value Register U
    };

    /// Peripheral instances
    inline Registers* GPT164 = reinterpret_cast<Registers*>(GPT164_BASE);

    // Bit definitions
    /// GTWP Register bits
    namespace gtwp_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PRKEY = (8 << 8);  ///< GTWP Key Code
        constexpr uint32_t WP = (1U << 0);  ///< Register Write Disable
    }

    /// GTSTR Register bits
    namespace gtstr_bits {
        constexpr uint32_t Reserved = (22 << 10);  ///< These bits are read as 0000000000000000000000. The write value should be 0000000000000000000000.
        constexpr uint32_t CSTRT9 = (1U << 9);  ///< Channel 9 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT8 = (1U << 8);  ///< Channel 8 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT7 = (1U << 7);  ///< Channel 7 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT6 = (1U << 6);  ///< Channel 6 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT5 = (1U << 5);  ///< Channel 5 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT4 = (1U << 4);  ///< Channel 4 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT3 = (1U << 3);  ///< Channel 3 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT2 = (1U << 2);  ///< Channel 2 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT1 = (1U << 1);  ///< Channel 1 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT0 = (1U << 0);  ///< Channel 0 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
    }

    /// GTSTP Register bits
    namespace gtstp_bits {
        constexpr uint32_t Reserved = (22 << 10);  ///< These bits are read as 1111111111111111111111. The write value should be 1111111111111111111111.
        constexpr uint32_t CSTOP9 = (1U << 9);  ///< Channel 9 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP8 = (1U << 8);  ///< Channel 8 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP7 = (1U << 7);  ///< Channel 7 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP6 = (1U << 6);  ///< Channel 6 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP5 = (1U << 5);  ///< Channel 5 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP4 = (1U << 4);  ///< Channel 4 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP3 = (1U << 3);  ///< Channel 3 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP2 = (1U << 2);  ///< Channel 2 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP1 = (1U << 1);  ///< Channel 1 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP0 = (1U << 0);  ///< Channel 0 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
    }

    /// GTCLR Register bits
    namespace gtclr_bits {
        constexpr uint32_t Reserved = (22 << 10);  ///< The write value should be 0000000000000000000000.
        constexpr uint32_t CCLR9 = (1U << 9);  ///< Channel 9 GTCNT Count Clear
        constexpr uint32_t CCLR8 = (1U << 8);  ///< Channel 8 GTCNT Count Clear
        constexpr uint32_t CCLR7 = (1U << 7);  ///< Channel 7 GTCNT Count Clear
        constexpr uint32_t CCLR6 = (1U << 6);  ///< Channel 6 GTCNT Count Clear
        constexpr uint32_t CCLR5 = (1U << 5);  ///< Channel 5 GTCNT Count Clear
        constexpr uint32_t CCLR4 = (1U << 4);  ///< Channel 4 GTCNT Count Clear
        constexpr uint32_t CCLR3 = (1U << 3);  ///< Channel 3 GTCNT Count Clear
        constexpr uint32_t CCLR2 = (1U << 2);  ///< Channel 2 GTCNT Count Clear
        constexpr uint32_t CCLR1 = (1U << 1);  ///< Channel 1 GTCNT Count Clear
        constexpr uint32_t CCLR0 = (1U << 0);  ///< Channel 0 GTCNT Count Clear
    }

    /// GTSSR Register bits
    namespace gtssr_bits {
        constexpr uint32_t CSTRT = (1U << 31);  ///< Software Source Counter Start Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t SSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Start Enable
        constexpr uint32_t SSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Start Enable
        constexpr uint32_t SSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Start Enable
        constexpr uint32_t SSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Start Enable
        constexpr uint32_t SSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Start Enable
        constexpr uint32_t SSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Start Enable
        constexpr uint32_t SSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Start Enable
        constexpr uint32_t SSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Start Enable
        constexpr uint32_t SSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Start Enable
    }

    /// GTPSR Register bits
    namespace gtpsr_bits {
        constexpr uint32_t CSTOP = (1U << 31);  ///< Software Source Counter Stop Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t PSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Stop Enable
        constexpr uint32_t PSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Stop Enable
        constexpr uint32_t PSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Stop Enable
        constexpr uint32_t PSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Stop Enable
        constexpr uint32_t PSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Stop Enable
        constexpr uint32_t PSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Stop Enable
        constexpr uint32_t PSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Stop Enable
        constexpr uint32_t PSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Stop Enable
        constexpr uint32_t PSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Stop Enable
    }

    /// GTCSR Register bits
    namespace gtcsr_bits {
        constexpr uint32_t CCLR = (1U << 31);  ///< Software Source Counter Clear Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t CSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Clear Enable
        constexpr uint32_t CSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Clear Enable
        constexpr uint32_t CSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Clear Enable
        constexpr uint32_t CSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Clear Enable
        constexpr uint32_t CSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Clear Enable
        constexpr uint32_t CSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Clear Enable
        constexpr uint32_t CSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Clear Enable
        constexpr uint32_t CSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Clear Enable
        constexpr uint32_t CSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Clear Enable
    }

    /// GTUPSR Register bits
    namespace gtupsr_bits {
        constexpr uint32_t USELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Count Up Enable
        constexpr uint32_t USELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Up Enable
        constexpr uint32_t USELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Up Enable
        constexpr uint32_t USELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Up Enable
        constexpr uint32_t USELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Up Enable
        constexpr uint32_t USELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Up Enable
        constexpr uint32_t USELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Up Enable
        constexpr uint32_t USELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Up Enable
        constexpr uint32_t USCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Up Enable
    }

    /// GTDNSR Register bits
    namespace gtdnsr_bits {
        constexpr uint32_t DSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Count Down Enable
        constexpr uint32_t DSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Down Enable
        constexpr uint32_t DSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Down Enable
        constexpr uint32_t DSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Down Enable
        constexpr uint32_t DSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Down Enable
        constexpr uint32_t DSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Down Enable
        constexpr uint32_t DSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Down Enable
        constexpr uint32_t DSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Down Enable
        constexpr uint32_t DSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Down Enable
    }

    /// GTICASR Register bits
    namespace gticasr_bits {
        constexpr uint32_t ASELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable
    }

    /// GTICBSR Register bits
    namespace gticbsr_bits {
        constexpr uint32_t BSELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable
    }

    /// GTCR Register bits
    namespace gtcr_bits {
        constexpr uint32_t TPCS = (3 << 24);  ///< Timer Prescaler Select
        constexpr uint32_t Reserved = (15 << 1);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
        constexpr uint32_t MD = (3 << 16);  ///< Mode Select
        constexpr uint32_t CST = (1U << 0);  ///< Count Start
    }

    /// GTUDDTYC Register bits
    namespace gtuddtyc_bits {
        constexpr uint32_t OBDTYR = (1U << 27);  ///< GTIOCB Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OBDTYF = (1U << 26);  ///< Forcible GTIOCB Output Duty Setting
        constexpr uint32_t OBDTY = (2 << 24);  ///< GTIOCB Output Duty Setting
        constexpr uint32_t Reserved = (4 << 20);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t OADTYR = (1U << 19);  ///< GTIOCA Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OADTYF = (1U << 18);  ///< Forcible GTIOCA Output Duty Setting
        constexpr uint32_t OADTY = (2 << 16);  ///< GTIOCA Output Duty Setting
        constexpr uint32_t UDF = (1U << 1);  ///< Forcible Count Direction Setting
        constexpr uint32_t UD = (1U << 0);  ///< Count Direction Setting
    }

    /// GTIOR Register bits
    namespace gtior_bits {
        constexpr uint32_t NFCSB = (2 << 30);  ///< Noise Filter B Sampling Clock Select
        constexpr uint32_t NFBEN = (1U << 29);  ///< Noise Filter B Enable
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t OBDF = (2 << 25);  ///< GTIOCB Pin Disable Value Setting
        constexpr uint32_t OBE = (1U << 24);  ///< GTIOCB Pin Output Enable
        constexpr uint32_t OBHLD = (1U << 23);  ///< GTIOCB Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OBDFLT = (1U << 22);  ///< GTIOCB Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOB = (5 << 16);  ///< GTIOCB Pin Function Select
        constexpr uint32_t NFCSA = (2 << 14);  ///< Noise Filter A Sampling Clock Select
        constexpr uint32_t NFAEN = (1U << 13);  ///< Noise Filter A Enable
        constexpr uint32_t OADF = (2 << 9);  ///< GTIOCA Pin Disable Value Setting
        constexpr uint32_t OAE = (1U << 8);  ///< GTIOCA Pin Output Enable
        constexpr uint32_t OAHLD = (1U << 7);  ///< GTIOCA Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OADFLT = (1U << 6);  ///< GTIOCA Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOA = (5 << 0);  ///< GTIOCA Pin Function Select
    }

    /// GTINTAD Register bits
    namespace gtintad_bits {
        constexpr uint32_t GRPABL = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t GRPABH = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t Reserved = (24 << 0);  ///< These bits are read as 000000000000000000000000. The write value should be 000000000000000000000000.
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disable Source Select
    }

    /// GTST Register bits
    namespace gtst_bits {
        constexpr uint32_t OABLF = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t OABHF = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t Reserved = (7 << 8);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ODF = (1U << 24);  ///< Output Disable Flag
        constexpr uint32_t TUCF = (1U << 15);  ///< Count Direction Flag
        constexpr uint32_t TCFPU = (1U << 7);  ///< Underflow Flag
        constexpr uint32_t TCPFO = (1U << 6);  ///< Overflow Flag
        constexpr uint32_t TCFF = (1U << 5);  ///< Input Compare Match Flag F
        constexpr uint32_t TCFE = (1U << 4);  ///< Input Compare Match Flag E
        constexpr uint32_t TCFD = (1U << 3);  ///< Input Compare Match Flag D
        constexpr uint32_t TCFC = (1U << 2);  ///< Input Compare Match Flag C
        constexpr uint32_t TCFB = (1U << 1);  ///< Input Capture/Compare Match Flag B
        constexpr uint32_t TCFA = (1U << 0);  ///< Input Capture/Compare Match Flag A
    }

    /// GTBER Register bits
    namespace gtber_bits {
        constexpr uint32_t CCRSWT = (1U << 22);  ///< GTCCRA and GTCCRB Forcible Buffer OperationThis bit is read as 0.
        constexpr uint32_t PR = (2 << 20);  ///< GTPR Buffer Operation
        constexpr uint32_t CCRB = (2 << 18);  ///< GTCCRB Buffer Operation
        constexpr uint32_t CCRA = (2 << 16);  ///< GTCCRA Buffer Operation
        constexpr uint32_t BD = (2 << 0);  ///< BD[1]: GTPR Buffer Operation DisableBD[0]: GTCCR Buffer Operation Disable
    }

    /// GTCNT Register bits
    namespace gtcnt_bits {
        constexpr uint32_t GTCNT = (32 << 0);  ///< Counter
    }

    /// GTCCRA Register bits
    namespace gtccra_bits {
        constexpr uint32_t GTCCRA = (32 << 0);  ///< Compare Capture Register A
    }

    /// GTCCRB Register bits
    namespace gtccrb_bits {
        constexpr uint32_t GTCCRB = (32 << 0);  ///< Compare Capture Register B
    }

    /// GTCCRC Register bits
    namespace gtccrc_bits {
        constexpr uint32_t GTCCRC = (32 << 0);  ///< Compare Capture Register C
    }

    /// GTCCRE Register bits
    namespace gtccre_bits {
        constexpr uint32_t GTCCRE = (32 << 0);  ///< Compare Capture Register E
    }

    /// GTCCRD Register bits
    namespace gtccrd_bits {
        constexpr uint32_t GTCCRD = (32 << 0);  ///< Compare Capture Register D
    }

    /// GTCCRF Register bits
    namespace gtccrf_bits {
        constexpr uint32_t GTCCRF = (32 << 0);  ///< Compare Capture Register F
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GTPR = (32 << 0);  ///< Cycle Setting Register
    }

    /// GTPBR Register bits
    namespace gtpbr_bits {
        constexpr uint32_t GTPBR = (32 << 0);  ///< Cycle Setting Buffer Register
    }

    /// GTDTCR Register bits
    namespace gtdtcr_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t TDE = (1U << 0);  ///< Negative-Phase Waveform Setting
    }

    /// GTDVU Register bits
    namespace gtdvu_bits {
        constexpr uint32_t GTDVU = (32 << 0);  ///< Dead Time Value Register U
    }

}

// ============================================================================
// GPT165 Peripheral
// ============================================================================

namespace gpt165 {
    /// Base addresses
    constexpr uint32_t GPT165_BASE = 0x40078500;

    /// GPT165 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT165 = reinterpret_cast<Registers*>(GPT165_BASE);

}

// ============================================================================
// GPT166 Peripheral
// ============================================================================

namespace gpt166 {
    /// Base addresses
    constexpr uint32_t GPT166_BASE = 0x40078600;

    /// GPT166 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT166 = reinterpret_cast<Registers*>(GPT166_BASE);

}

// ============================================================================
// GPT167 Peripheral
// ============================================================================

namespace gpt167 {
    /// Base addresses
    constexpr uint32_t GPT167_BASE = 0x40078700;

    /// GPT167 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT167 = reinterpret_cast<Registers*>(GPT167_BASE);

}

// ============================================================================
// GPT168 Peripheral
// ============================================================================

namespace gpt168 {
    /// Base addresses
    constexpr uint32_t GPT168_BASE = 0x40078800;

    /// GPT168 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT168 = reinterpret_cast<Registers*>(GPT168_BASE);

}

// ============================================================================
// GPT169 Peripheral
// ============================================================================

namespace gpt169 {
    /// Base addresses
    constexpr uint32_t GPT169_BASE = 0x40078900;

    /// GPT169 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT169 = reinterpret_cast<Registers*>(GPT169_BASE);

}

// ============================================================================
// GPT Peripheral
// ============================================================================

namespace gpt {
    /// Base addresses
    constexpr uint32_t GPT_OPS_BASE = 0x40078FF0;

    /// GPT Register structure
    struct Registers {
        volatile uint32_t OPSCR;  ///< Offset: 0x00 - Output Phase Switching Control Register
    };

    /// Peripheral instances
    inline Registers* GPT_OPS = reinterpret_cast<Registers*>(GPT_OPS_BASE);

    // Bit definitions
    /// OPSCR Register bits
    namespace opscr_bits {
        constexpr uint32_t NFCS = (2 << 30);  ///< External Input Noise Filter Clock selectionNoise filter sampling clock setting of the external input.
        constexpr uint32_t NFEN = (1U << 29);  ///< External Input Noise Filter Enable
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t GODF = (1U << 26);  ///< Group output disable function
        constexpr uint32_t GRP = (2 << 24);  ///< Output disabled source selection
        constexpr uint32_t ALIGN = (1U << 21);  ///< Input phase alignment
        constexpr uint32_t RV = (1U << 20);  ///< Output phase rotation direction reversal
        constexpr uint32_t INV = (1U << 19);  ///< Invert-Phase Output Control
        constexpr uint32_t N = (1U << 18);  ///< Negative-Phase Output (N) Control
        constexpr uint32_t P = (1U << 17);  ///< Positive-Phase Output (P) Control
        constexpr uint32_t FB = (1U << 16);  ///< External Feedback Signal EnableThis bit selects the input phase from the software settings and external input.
        constexpr uint32_t EN = (1U << 8);  ///< Enable-Phase Output Control
        constexpr uint32_t W = (1U << 6);  ///< Input W-Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)
        constexpr uint32_t V = (1U << 5);  ///< Input V-Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)
        constexpr uint32_t U = (1U << 4);  ///< Input U-Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)
        constexpr uint32_t WF = (1U << 2);  ///< Input Phase Soft Setting UFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1.
        constexpr uint32_t VF = (1U << 1);  ///< Input Phase Soft Setting VFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1.
        constexpr uint32_t UF = (1U << 0);  ///< Input Phase Soft Setting WFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1.
    }

}

// ============================================================================
// AGT0 Peripheral
// ============================================================================

namespace agt0 {
    /// Base addresses
    constexpr uint32_t AGT0_BASE = 0x40084000;

    /// AGT0 Register structure
    struct Registers {
        volatile uint32_t AGT;  ///< Offset: 0x00 - AGT Counter Register
        volatile uint32_t AGTCMA;  ///< Offset: 0x02 - AGT Compare Match A Register
        volatile uint32_t AGTCMB;  ///< Offset: 0x04 - AGT Compare Match B Register
        volatile uint32_t AGTCR;  ///< Offset: 0x08 - AGT Control Register
        volatile uint32_t AGTMR1;  ///< Offset: 0x09 - AGT Mode Register 1
        volatile uint32_t AGTMR2;  ///< Offset: 0x0A - AGT Mode Register 2
        volatile uint32_t AGTIOC;  ///< Offset: 0x0C - AGT I/O Control Register
        volatile uint32_t AGTISR;  ///< Offset: 0x0D - AGT Event Pin Select Register
        volatile uint32_t AGTCMSR;  ///< Offset: 0x0E - AGT Compare Match Function Select Register
        volatile uint32_t AGTIOSEL;  ///< Offset: 0x0F - AGT Pin Select Register
    };

    /// Peripheral instances
    inline Registers* AGT0 = reinterpret_cast<Registers*>(AGT0_BASE);

    // Bit definitions
    /// AGT Register bits
    namespace agt_bits {
        constexpr uint32_t AGT = (16 << 0);  ///< 16bit counter and reload registerNOTE : When 1 is written to the TSTOP bit in the AGTCRn register, the 16-bit counter is forcibly stopped and set to FFFFH.
    }

    /// AGTCMA Register bits
    namespace agtcma_bits {
        constexpr uint32_t AGTCMA = (16 << 0);  ///< AGT Compare Match A data is stored.NOTE : When 1 is written to the TSTOP bit in the AGTCRn register, set to FFFFH
    }

    /// AGTCMB Register bits
    namespace agtcmb_bits {
        constexpr uint32_t AGTCMB = (16 << 0);  ///< AGT Compare Match B data is stored.NOTE : When 1 is written to the TSTOP bit in the AGTCR register, set to FFFFH
    }

    /// AGTCR Register bits
    namespace agtcr_bits {
        constexpr uint32_t TCMBF = (1U << 7);  ///< Compare match B flag
        constexpr uint32_t TCMAF = (1U << 6);  ///< Compare match A flag
        constexpr uint32_t TUNDF = (1U << 5);  ///< Underflow flag
        constexpr uint32_t TEDGF = (1U << 4);  ///< Active edge judgment flag
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TSTOP = (1U << 2);  ///< AGT count forced stop
        constexpr uint32_t TCSTF = (1U << 1);  ///< AGT count status flag
        constexpr uint32_t TSTART = (1U << 0);  ///< AGT count start
    }

    /// AGTMR1 Register bits
    namespace agtmr1_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TCK = (3 << 4);  ///< Count source
        constexpr uint32_t TEDGPL = (1U << 3);  ///< Edge polarity
        constexpr uint32_t TMOD = (3 << 0);  ///< Operating mode
    }

    /// AGTMR2 Register bits
    namespace agtmr2_bits {
        constexpr uint32_t LPM = (1U << 7);  ///< Low Power Mode
        constexpr uint32_t Reserved = (4 << 3);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t CKS = (3 << 0);  ///< AGTLCLK/AGTSCLK count source clock frequency division ratio
    }

    /// AGTIOC Register bits
    namespace agtioc_bits {
        constexpr uint32_t TIOGT = (2 << 6);  ///< Count control
        constexpr uint32_t TIPF = (2 << 4);  ///< Input filter
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TOE = (1U << 2);  ///< AGTOn output enable
        constexpr uint32_t TEDGSEL = (1U << 0);  ///< I/O polarity switchFunction varies depending on the operating mode.
    }

    /// AGTISR Register bits
    namespace agtisr_bits {
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t EEPS = (1U << 2);  ///< AGTEE polarty selection
    }

    /// AGTCMSR Register bits
    namespace agtcmsr_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TOPOLB = (1U << 6);  ///< AGTOB polarity select
        constexpr uint32_t TOEB = (1U << 5);  ///< AGTOB output enable
        constexpr uint32_t TCMEB = (1U << 4);  ///< Compare match B register enable
        constexpr uint32_t TOPOLA = (1U << 2);  ///< AGTOA polarity select
        constexpr uint32_t TOEA = (1U << 1);  ///< AGTOA output enable
        constexpr uint32_t TCMEA = (1U << 0);  ///< Compare match A register enable
    }

    /// AGTIOSEL Register bits
    namespace agtiosel_bits {
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t TIES = (1U << 4);  ///< AGTIO input enable
        constexpr uint32_t SEL = (2 << 0);  ///< AGTIO pin select
    }

}

// ============================================================================
// AGT1 Peripheral
// ============================================================================

namespace agt1 {
    /// Base addresses
    constexpr uint32_t AGT1_BASE = 0x40084100;

    /// AGT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AGT1 = reinterpret_cast<Registers*>(AGT1_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40044000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t R64CNT;  ///< Offset: 0x00 - 64-Hz Counter
        volatile uint32_t RSECCNT;  ///< Offset: 0x02 - Second Counter
        volatile uint32_t BCNT0;  ///< Offset: 0x02 - Binary Counter 0
        volatile uint32_t RMINCNT;  ///< Offset: 0x04 - Minute Counter
        volatile uint32_t BCNT1;  ///< Offset: 0x04 - Binary Counter 1
        volatile uint32_t RHRCNT;  ///< Offset: 0x06 - Hour Counter
        volatile uint32_t BCNT2;  ///< Offset: 0x06 - Binary Counter 2
        volatile uint32_t RWKCNT;  ///< Offset: 0x08 - Day-of-Week Counter
        volatile uint32_t BCNT3;  ///< Offset: 0x08 - Binary Counter 3
        volatile uint32_t RDAYCNT;  ///< Offset: 0x0A - Day Counter
        volatile uint32_t RMONCNT;  ///< Offset: 0x0C - Month Counter
        volatile uint32_t RYRCNT;  ///< Offset: 0x0E - Year Counter
        volatile uint32_t RSECAR;  ///< Offset: 0x10 - Second Alarm Register
        volatile uint32_t BCNT0AR;  ///< Offset: 0x10 - Binary Counter 0 Alarm Register
        volatile uint32_t RMINAR;  ///< Offset: 0x12 - Minute Alarm Register
        volatile uint32_t BCNT1AR;  ///< Offset: 0x12 - Binary Counter 1 Alarm Register
        volatile uint32_t RHRAR;  ///< Offset: 0x14 - Hour Alarm Register
        volatile uint32_t BCNT2AR;  ///< Offset: 0x14 - Binary Counter 2 Alarm Register
        volatile uint32_t RWKAR;  ///< Offset: 0x16 - Day-of-Week Alarm Register
        volatile uint32_t BCNT3AR;  ///< Offset: 0x16 - Binary Counter 3 Alarm Register
        volatile uint32_t RDAYAR;  ///< Offset: 0x18 - Date Alarm Register
        volatile uint32_t BCNT0AER;  ///< Offset: 0x18 - Binary Counter 0 Alarm Enable Register
        volatile uint32_t RMONAR;  ///< Offset: 0x1A - Month Alarm Register
        volatile uint32_t BCNT1AER;  ///< Offset: 0x1A - Binary Counter 1 Alarm Enable Register
        volatile uint32_t RYRAR;  ///< Offset: 0x1C - Year Alarm Register
        volatile uint32_t BCNT2AER;  ///< Offset: 0x1C - Binary Counter 2 Alarm Enable Register
        volatile uint32_t RYRAREN;  ///< Offset: 0x1E - Year Alarm Enable Register
        volatile uint32_t BCNT3AER;  ///< Offset: 0x1E - Binary Counter 3 Alarm Enable Register
        volatile uint32_t RCR1;  ///< Offset: 0x22 - RTC Control Register 1
        volatile uint32_t RCR2;  ///< Offset: 0x24 - RTC Control Register 2
        volatile uint32_t RCR4;  ///< Offset: 0x28 - RTC Control Register 4
        volatile uint32_t RFRH;  ///< Offset: 0x2A - Frequency Register H
        volatile uint32_t RFRL;  ///< Offset: 0x2C - Frequency Register L
        volatile uint32_t RADJ;  ///< Offset: 0x2E - Time Error Adjustment Register
        volatile uint32_t RTCCR%s;  ///< Offset: 0x40 - Time Capture Control Register %s
        volatile uint32_t RSECCP%s;  ///< Offset: 0x52 - Second Capture Register %s
        volatile uint32_t BCNT0CP%s;  ///< Offset: 0x52 - BCNT0 Capture Register %s
        volatile uint32_t RMINCP%s;  ///< Offset: 0x54 - Minute Capture Register %s
        volatile uint32_t BCNT1CP%s;  ///< Offset: 0x54 - BCNT1 Capture Register %s
        volatile uint32_t RHRCP%s;  ///< Offset: 0x56 - Hour Capture Register %s
        volatile uint32_t BCNT2CP%s;  ///< Offset: 0x56 - BCNT2 Capture Register %s
        volatile uint32_t RDAYCP%s;  ///< Offset: 0x5A - Date Capture Register %s
        volatile uint32_t BCNT3CP%s;  ///< Offset: 0x5A - BCNT3 Capture Register %s
        volatile uint32_t RMONCP%s;  ///< Offset: 0x5C - Month Capture Register %s
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// R64CNT Register bits
    namespace r64cnt_bits {
        constexpr uint32_t F1HZ = (1U << 6);  ///< 1Hz
        constexpr uint32_t F2HZ = (1U << 5);  ///< 2Hz
        constexpr uint32_t F4HZ = (1U << 4);  ///< 4Hz
        constexpr uint32_t F8HZ = (1U << 3);  ///< 8Hz
        constexpr uint32_t F16HZ = (1U << 2);  ///< 16Hz
        constexpr uint32_t F32HZ = (1U << 1);  ///< 32Hz
        constexpr uint32_t F64HZ = (1U << 0);  ///< 64Hz
    }

    /// RSECCNT Register bits
    namespace rseccnt_bits {
        constexpr uint32_t SEC10 = (3 << 4);  ///< 10-Second Count Counts from 0 to 5 for 60-second counting.
        constexpr uint32_t SEC1 = (4 << 0);  ///< 1-Second Count Counts from 0 to 9 every second. When a carry is generated, 1 is added to the tens place.
    }

    /// BCNT0 Register bits
    namespace bcnt0_bits {
        constexpr uint32_t BCNT0 = (8 << 0);  ///< The BCNT0 counter is a readable/writable 32-bit binary counter b7 to b0.
    }

    /// RMINCNT Register bits
    namespace rmincnt_bits {
        constexpr uint32_t MIN10 = (3 << 4);  ///< 10-Minute Count Counts from 0 to 5 for 60-minute counting.
        constexpr uint32_t MIN1 = (4 << 0);  ///< 1-Minute Count Counts from 0 to 9 every minute. When a carry is generated, 1 is added to the tens place.
    }

    /// BCNT1 Register bits
    namespace bcnt1_bits {
        constexpr uint32_t BCNT1 = (8 << 0);  ///< The BCNT1 counter is a readable/writable 32-bit binary counter b15 to b8.
    }

    /// RHRCNT Register bits
    namespace rhrcnt_bits {
        constexpr uint32_t PM = (1U << 6);  ///< Time Counter Setting for a.m./p.m.
        constexpr uint32_t HR10 = (2 << 4);  ///< 10-Hour Count Counts from 0 to 2 once per carry from the ones place.
        constexpr uint32_t HR1 = (4 << 0);  ///< 1-Hour Count Counts from 0 to 9 once per hour. When a carry is generated, 1 is added to the tens place.
    }

    /// BCNT2 Register bits
    namespace bcnt2_bits {
        constexpr uint32_t BCNT2 = (8 << 0);  ///< The BCNT2 counter is a readable/writable 32-bit binary counter b23 to b16.
    }

    /// RWKCNT Register bits
    namespace rwkcnt_bits {
        constexpr uint32_t DAYW = (3 << 0);  ///< Day-of-Week Counting
    }

    /// BCNT3 Register bits
    namespace bcnt3_bits {
        constexpr uint32_t BCNT3 = (8 << 0);  ///< The BCNT3 counter is a readable/writable 32-bit binary counter b31 to b24.
    }

    /// RDAYCNT Register bits
    namespace rdaycnt_bits {
        constexpr uint32_t DATE10 = (2 << 4);  ///< 10-Day Count Counts from 0 to 3 once per carry from the ones place.
        constexpr uint32_t DATE1 = (4 << 0);  ///< 1-Day Count Counts from 0 to 9 once per day. When a carry is generated, 1 is added to the tens place.
    }

    /// RMONCNT Register bits
    namespace rmoncnt_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t MON10 = (1U << 4);  ///< 10-Month Count Counts from 0 to 1 once per carry from the ones place.
        constexpr uint32_t MON1 = (4 << 0);  ///< 1-Month Count Counts from 0 to 9 once per month. When a carry is generated, 1 is added to the tens place.
    }

    /// RYRCNT Register bits
    namespace ryrcnt_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t YR10 = (4 << 4);  ///< 10-Year Count Counts from 0 to 9 once per carry from ones place. When a carry is generated in the tens place, 1 is added to the hundreds place.
        constexpr uint32_t YR1 = (4 << 0);  ///< 1-Year Count Counts from 0 to 9 once per year. When a carry is generated, 1 is added to the tens place.
    }

    /// RSECAR Register bits
    namespace rsecar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
        constexpr uint32_t SEC10 = (3 << 4);  ///< 10-Seconds Value for the tens place of seconds
        constexpr uint32_t SEC1 = (4 << 0);  ///< 1-Second Value for the ones place of seconds
    }

    /// BCNT0AR Register bits
    namespace bcnt0ar_bits {
        constexpr uint32_t BCNT0AR = (8 << 0);  ///< he BCNT0AR counter is a readable/writable alarm register corresponding to 32-bit binary counter b7 to b0.
    }

    /// RMINAR Register bits
    namespace rminar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
        constexpr uint32_t MIN10 = (3 << 4);  ///< 10-Minute Count Value for the tens place of minutes
        constexpr uint32_t MIN1 = (4 << 0);  ///< 1-Minute Count Value for the ones place of minutes
    }

    /// BCNT1AR Register bits
    namespace bcnt1ar_bits {
        constexpr uint32_t BCNT1AR = (8 << 0);  ///< he BCNT1AR counter is a readable/writable alarm register corresponding to 32-bit binary counter b15 to b8.
    }

    /// RHRAR Register bits
    namespace rhrar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
        constexpr uint32_t PM = (1U << 6);  ///< Time Counter Setting for a.m./p.m.
        constexpr uint32_t HR10 = (2 << 4);  ///< 10-Hour Count Value for the tens place of hours
        constexpr uint32_t HR1 = (4 << 0);  ///< 1-Hour Count Value for the ones place of hours
    }

    /// BCNT2AR Register bits
    namespace bcnt2ar_bits {
        constexpr uint32_t BCNT2AR = (8 << 0);  ///< The BCNT2AR counter is a readable/writable 32-bit binary counter b23 to b16.
    }

    /// RWKAR Register bits
    namespace rwkar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
        constexpr uint32_t Reserved = (4 << 3);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t DAYW = (3 << 0);  ///< Day-of-Week Counting
    }

    /// BCNT3AR Register bits
    namespace bcnt3ar_bits {
        constexpr uint32_t BCNT3AR = (8 << 0);  ///< The BCNT3AR counter is a readable/writable 32-bit binary counter b31 to b24.
    }

    /// RDAYAR Register bits
    namespace rdayar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
        constexpr uint32_t Reserved = (1U << 6);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DATE10 = (2 << 4);  ///< 10 Days Value for the tens place of days
        constexpr uint32_t DATE1 = (4 << 0);  ///< 1 Day Value for the ones place of days
    }

    /// BCNT0AER Register bits
    namespace bcnt0aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< The BCNT0AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b7 to b0.
    }

    /// RMONAR Register bits
    namespace rmonar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
        constexpr uint32_t Reserved = (2 << 5);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t MON10 = (1U << 4);  ///< 10 Months Value for the tens place of months
        constexpr uint32_t MON1 = (4 << 0);  ///< 1 Month Value for the ones place of months
    }

    /// BCNT1AER Register bits
    namespace bcnt1aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< The BCNT1AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b15 to b8.
    }

    /// RYRAR Register bits
    namespace ryrar_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t YR10 = (4 << 4);  ///< 10 Years Value for the tens place of years
        constexpr uint32_t YR1 = (4 << 0);  ///< 1 Year Value for the ones place of years
    }

    /// BCNT2AER Register bits
    namespace bcnt2aer_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t ENB = (8 << 0);  ///< The BCNT2AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b23 to b16.
    }

    /// RYRAREN Register bits
    namespace ryraren_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
        constexpr uint32_t Reserved = (7 << 0);  ///< These bits are read as 0000000. The write value should be 0000000.
    }

    /// BCNT3AER Register bits
    namespace bcnt3aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< The BCNT3AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b31 to b24.
    }

    /// RCR1 Register bits
    namespace rcr1_bits {
        constexpr uint32_t PES = (4 << 4);  ///< Periodic Interrupt Select
        constexpr uint32_t RTCOS = (1U << 3);  ///< RTCOUT Output Select
        constexpr uint32_t PIE = (1U << 2);  ///< Periodic Interrupt Enable
        constexpr uint32_t CIE = (1U << 1);  ///< Carry Interrupt Enable
        constexpr uint32_t AIE = (1U << 0);  ///< Alarm Interrupt Enable
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t CNTMD = (1U << 7);  ///< Count Mode Select
        constexpr uint32_t HR24 = (1U << 6);  ///< Hours Mode
        constexpr uint32_t AADJP = (1U << 5);  ///< Automatic Adjustment Period Select (When the LOCO clock is selected, the setting of this bit is disabled.)
        constexpr uint32_t AADJE = (1U << 4);  ///< Automatic Adjustment Enable (When the LOCO clock is selected, the setting of this bit is disabled.)
        constexpr uint32_t RTCOE = (1U << 3);  ///< RTCOUT Output Enable
        constexpr uint32_t ADJ30 = (1U << 2);  ///< 30-Second Adjustment
        constexpr uint32_t RESET = (1U << 1);  ///< RTC Software Reset
        constexpr uint32_t START = (1U << 0);  ///< Start
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t RCKSEL = (1U << 0);  ///< Count Source Select
    }

    /// RFRH Register bits
    namespace rfrh_bits {
        constexpr uint32_t Reserved = (15 << 1);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
        constexpr uint32_t RFC16 = (1U << 0);  ///< Frequency Comparison Value (b16) To generate the operating clock from the LOCOclock, this bit sets the comparison value of the 128-Hz clock cycle.
    }

    /// RFRL Register bits
    namespace rfrl_bits {
        constexpr uint32_t RFC = (16 << 0);  ///< Frequency Comparison Value(b15-b0) To generate the operating clock from the main clock, this bit sets the comparison value of the 128-Hz clock cycle.
    }

    /// RADJ Register bits
    namespace radj_bits {
        constexpr uint32_t PMADJ = (2 << 6);  ///< Plus-Minus
        constexpr uint32_t ADJ = (6 << 0);  ///< Adjustment Value These bits specify the adjustment value from the prescaler.
    }

    /// RTCCR%s Register bits
    namespace rtccr%s_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TCNF = (2 << 4);  ///< Time Capture Noise Filter Control
        constexpr uint32_t TCST = (1U << 2);  ///< Time Capture Status
        constexpr uint32_t TCCT = (2 << 0);  ///< Time Capture Control
    }

    /// RSECCP%s Register bits
    namespace rseccp%s_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0.
        constexpr uint32_t SEC10 = (3 << 4);  ///< 10-Second Capture Capture value for the tens place of seconds
        constexpr uint32_t SEC1 = (4 << 0);  ///< 1-Second Capture Capture value for the ones place of seconds
    }

    /// BCNT0CP%s Register bits
    namespace bcnt0cp%s_bits {
        constexpr uint32_t BCNT0CP = (8 << 0);  ///< BCNT0CP is a read-only register that captures the BCNT0 value when a time capture event is detected.
    }

    /// RMINCP%s Register bits
    namespace rmincp%s_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0.
        constexpr uint32_t MIN10 = (3 << 4);  ///< 10-Minute Capture Capture value for the tens place of minutes
        constexpr uint32_t MIN1 = (4 << 0);  ///< 1-Minute Capture Capture value for the ones place of minutes
    }

    /// BCNT1CP%s Register bits
    namespace bcnt1cp%s_bits {
        constexpr uint32_t BCNT1CP = (8 << 0);  ///< BCNT1CP is a read-only register that captures the BCNT1 value when a time capture event is detected.
    }

    /// RHRCP%s Register bits
    namespace rhrcp%s_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0.
        constexpr uint32_t PM = (1U << 6);  ///< A.m./p.m. select for time counter setting.
        constexpr uint32_t HR10 = (2 << 4);  ///< 10-Minute Capture Capture value for the tens place of minutes
        constexpr uint32_t HR1 = (4 << 0);  ///< 1-Minute Capture Capture value for the ones place of minutes
    }

    /// BCNT2CP%s Register bits
    namespace bcnt2cp%s_bits {
        constexpr uint32_t BCNT2CP = (8 << 0);  ///< BCNT2CP is a read-only register that captures the BCNT2 value when a time capture event is detected.
    }

    /// RDAYCP%s Register bits
    namespace rdaycp%s_bits {
        constexpr uint32_t Reserved = (2 << 6);  ///< These bits are read as 00.
        constexpr uint32_t DATE10 = (2 << 4);  ///< 10-Day Capture Capture value for the tens place of minutes
        constexpr uint32_t DATE1 = (4 << 0);  ///< 1-Day Capture Capture value for the ones place of minutes
    }

    /// BCNT3CP%s Register bits
    namespace bcnt3cp%s_bits {
        constexpr uint32_t BCNT3CP = (8 << 0);  ///< BCNT3CP is a read-only register that captures the BCNT3 value when a time capture event is detected.
    }

    /// RMONCP%s Register bits
    namespace rmoncp%s_bits {
        constexpr uint32_t MON10 = (1U << 4);  ///< 10-Month Capture Capture value for the tens place of months
        constexpr uint32_t MON1 = (4 << 0);  ///< 1-Month Capture Capture value for the ones place of months
    }

}

// ============================================================================
// SYSTEM Peripheral
// ============================================================================

namespace system {
    /// Base addresses
    constexpr uint32_t SYSTEM_BASE = 0x4001E000;

    /// SYSTEM Register structure
    struct Registers {
        volatile uint32_t VBTCR1;  ///< Offset: 0x41F - VBATT Control Register1
        volatile uint32_t VBTCR2;  ///< Offset: 0x4B0 - VBATT Control Register2
        volatile uint32_t VBTSR;  ///< Offset: 0x4B1 - VBATT Status Register
        volatile uint32_t VBTCMPCR;  ///< Offset: 0x4B2 - VBATT Comparator Control Register
        volatile uint32_t VBTLVDICR;  ///< Offset: 0x4B4 - VBATT Pin Low Voltage Detect Interrupt Control Register
        volatile uint32_t VBTWCTLR;  ///< Offset: 0x4B6 - VBATT Wakeup function Control Register
        volatile uint32_t VBTWCH0OTSR;  ///< Offset: 0x4B8 - VBATT Wakeup I/O 0 Output Trigger Select Register
        volatile uint32_t VBTWCH1OTSR;  ///< Offset: 0x4B9 - VBATT Wakeup I/O 1 Output Trigger Select Register
        volatile uint32_t VBTWCH2OTSR;  ///< Offset: 0x4BA - VBATT Wakeup I/O 2 Output Trigger Select Register
        volatile uint32_t VBTICTLR;  ///< Offset: 0x4BB - VBATT Input Control Register
        volatile uint32_t VBTOCTLR;  ///< Offset: 0x4BC - VBATT Output Control Register
        volatile uint32_t VBTWTER;  ///< Offset: 0x4BD - VBATT Wakeup Trigger source Enable Register
        volatile uint32_t VBTWEGR;  ///< Offset: 0x4BE - VBATT Wakeup Trigger source Edge Register
        volatile uint32_t VBTWFR;  ///< Offset: 0x4BF - VBATT Wakeup trigger source Flag Register
        volatile uint32_t VBTBKR[%s];  ///< Offset: 0x500 - VBATT Backup Register [%s]
        volatile uint32_t RSTSR0;  ///< Offset: 0x410 - Reset Status Register 0
        volatile uint32_t RSTSR2;  ///< Offset: 0x411 - Reset Status Register 2
        volatile uint32_t RSTSR1;  ///< Offset: 0xC0 - Reset Status Register 1
        volatile uint32_t PRCR;  ///< Offset: 0x3FE - Protect Register
        volatile uint32_t SBYCR;  ///< Offset: 0x0C - Standby Control Register
        volatile uint32_t MSTPCRA;  ///< Offset: 0x1C - Module Stop Control Register A
        volatile uint32_t SNZCR;  ///< Offset: 0x92 - Snooze Control Register
        volatile uint32_t SNZEDCR;  ///< Offset: 0x94 - Snooze End Control Register
        volatile uint32_t SNZREQCR;  ///< Offset: 0x98 - Snooze Request Control Register
        volatile uint32_t PSMCR;  ///< Offset: 0x9F - Power Save Memory Control Register
        volatile uint32_t FLSTOP;  ///< Offset: 0x9E - Flash Operation Control Register
        volatile uint32_t OPCCR;  ///< Offset: 0xA0 - Operating Power Control Register
        volatile uint32_t SOPCCR;  ///< Offset: 0xAA - Sub Operating Power Control Register
        volatile uint32_t SYOCDCR;  ///< Offset: 0x40E - System Control OCD Control Register
        volatile uint32_t SCKDIVCR;  ///< Offset: 0x20 - System Clock Division Control Register
        volatile uint32_t SCKSCR;  ///< Offset: 0x26 - System Clock Source Control Register
        volatile uint32_t PLLCR;  ///< Offset: 0x2A - PLL Control Register
        volatile uint32_t PLLCCR2;  ///< Offset: 0x2B - PLL Clock Control Register2
        volatile uint32_t BCKCR;  ///< Offset: 0x30 - External Bus Clock Control Register
        volatile uint32_t MEMWAIT;  ///< Offset: 0x31 - Memory Wait Cycle Control Register
        volatile uint32_t MOSCCR;  ///< Offset: 0x32 - Main Clock Oscillator Control Register
        volatile uint32_t HOCOCR;  ///< Offset: 0x36 - High-Speed On-Chip Oscillator Control Register
        volatile uint32_t MOCOCR;  ///< Offset: 0x38 - Middle-Speed On-Chip Oscillator Control Register
        volatile uint32_t OSCSF;  ///< Offset: 0x3C - Oscillation Stabilization Flag Register
        volatile uint32_t CKOCR;  ///< Offset: 0x3E - Clock Out Control Register
        volatile uint32_t TRCKCR;  ///< Offset: 0x3F - Trace Clock Control Register
        volatile uint32_t OSTDCR;  ///< Offset: 0x40 - Oscillation Stop Detection Control Register
        volatile uint32_t OSTDSR;  ///< Offset: 0x41 - Oscillation Stop Detection Status Register
        volatile uint32_t SLCDSCKCR;  ///< Offset: 0x50 - Segment LCD Source Clock Control Register
        volatile uint32_t EBCKOCR;  ///< Offset: 0x52 - External Bus Clock Output Control Register
        volatile uint32_t MOCOUTCR;  ///< Offset: 0x61 - MOCO User Trimming Control Register
        volatile uint32_t HOCOUTCR;  ///< Offset: 0x62 - HOCO User Trimming Control Register
        volatile uint32_t MOSCWTCR;  ///< Offset: 0xA2 - Main Clock Oscillator Wait Control Register
        volatile uint32_t HOCOWTCR;  ///< Offset: 0xA5 - High-Speed On-Chip Oscillator Wait Control Register
        volatile uint32_t USBCKCR;  ///< Offset: 0xD0 - USB Clock Control register
        volatile uint32_t MOMCR;  ///< Offset: 0x413 - Main Clock Oscillator Mode Oscillation Control Register
        volatile uint32_t SOSCCR;  ///< Offset: 0x480 - Sub-Clock Oscillator Control Register
        volatile uint32_t SOMCR;  ///< Offset: 0x481 - Sub Clock Oscillator Mode Control Register
        volatile uint32_t LOCOCR;  ///< Offset: 0x490 - Low-Speed On-Chip Oscillator Control Register
        volatile uint32_t LOCOUTCR;  ///< Offset: 0x492 - LOCO User Trimming Control Register
        volatile uint32_t BKRACR;  ///< Offset: 0xC6 - Backup Register Access Control Register
        volatile uint32_t LVCMPCR;  ///< Offset: 0x417 - Voltage Monitor Circuit Control Register
        volatile uint32_t LVDLVLR;  ///< Offset: 0x418 - Voltage Detection Level Select Register
        volatile uint32_t LVD%sCR0;  ///< Offset: 0x41A - Voltage Monitor %s Circuit Control Register 0
        volatile uint32_t LVD%sCR1;  ///< Offset: 0xE0 - Voltage Monitor %s Circuit Control Register 1
        volatile uint32_t LVD%sSR;  ///< Offset: 0xE1 - Voltage Monitor %s Circuit Status Register
    };

    /// Peripheral instances
    inline Registers* SYSTEM = reinterpret_cast<Registers*>(SYSTEM_BASE);

    // Bit definitions
    /// VBTCR1 Register bits
    namespace vbtcr1_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t BPWSWSTP = (1U << 0);  ///< Battery Power supply Switch Stop
    }

    /// VBTCR2 Register bits
    namespace vbtcr2_bits {
        constexpr uint32_t VBTLVDLVL = (2 << 6);  ///< VBATT Pin Voltage Low Voltage Detect Level Select Bit
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t VBTLVDEN = (1U << 4);  ///< VBATT Pin Low Voltage Detect Enable Bit
    }

    /// VBTSR Register bits
    namespace vbtsr_bits {
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t VBTRVLD = (1U << 4);  ///< VBATT_R Valid
        constexpr uint32_t VBTBLDF = (1U << 1);  ///< VBATT Battery Low voltage Detect Flag
        constexpr uint32_t VBTRDF = (1U << 0);  ///< VBAT_R Reset Detect Flag
    }

    /// VBTCMPCR Register bits
    namespace vbtcmpcr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t VBTCMPE = (1U << 0);  ///< VBATT pin low voltage detect circuit output enable
    }

    /// VBTLVDICR Register bits
    namespace vbtlvdicr_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t VBTLVDISEL = (1U << 1);  ///< Pin Low Voltage Detect Interrupt Select bit
        constexpr uint32_t VBTLVDIE = (1U << 0);  ///< VBATT Pin Low Voltage Detect Interrupt Enable bit
    }

    /// VBTWCTLR Register bits
    namespace vbtwctlr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t VWEN = (1U << 0);  ///< VBATT wakeup enable
    }

    /// VBTWCH0OTSR Register bits
    namespace vbtwch0otsr_bits {
        constexpr uint32_t Reserved = (1U << 0);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CH0VRTCATE = (1U << 4);  ///< VBATWIO0 Output RTC Alarm Signal Enable
        constexpr uint32_t CH0VRTCTE = (1U << 3);  ///< VBATWIO0 Output RTC Periodic Signal Enable
        constexpr uint32_t CH0VCH2TE = (1U << 2);  ///< VBATWIO0 Output VBATWIO2 Trigger Enable
        constexpr uint32_t CH0VCH1TE = (1U << 1);  ///< VBATWIO0 Output VBATWIO1 Trigger Enable
    }

    /// VBTWCH1OTSR Register bits
    namespace vbtwch1otsr_bits {
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CH1VRTCATE = (1U << 4);  ///< VBATWIO1 Output RTC Alarm Signal Enable
        constexpr uint32_t CH1VRTCTE = (1U << 3);  ///< VBATWIO1 Output RTC Periodic Signal Enable
        constexpr uint32_t CH1VCH2TE = (1U << 2);  ///< VBATWIO1 Output VBATWIO2 Trigger Enable
        constexpr uint32_t CH1VCH0TE = (1U << 0);  ///< VBATWIO1 Output VBATWIO0 Trigger Enable
    }

    /// VBTWCH2OTSR Register bits
    namespace vbtwch2otsr_bits {
        constexpr uint32_t Reserved = (1U << 2);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CH2VRTCATE = (1U << 4);  ///< VBATWIO2 Output RTC Alarm Signal Enable
        constexpr uint32_t CH2VRTCTE = (1U << 3);  ///< VBATWIO2 Output RTC Periodic Signal Enable
        constexpr uint32_t CH2VCH1TE = (1U << 1);  ///< VBATWIO2 Output VBATWIO1 Trigger Enable
        constexpr uint32_t CH2VCH0TE = (1U << 0);  ///< VBATWIO2 Output VBATWIO0 Trigger Enable
    }

    /// VBTICTLR Register bits
    namespace vbtictlr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t VCH2INEN = (1U << 2);  ///< VBATT Wakeup I/O 2 Input Enable
        constexpr uint32_t VCH1INEN = (1U << 1);  ///< VBATT Wakeup I/O 1 Input Enable
        constexpr uint32_t VCH0INEN = (1U << 0);  ///< VBATT Wakeup I/O 0 Input Enable
    }

    /// VBTOCTLR Register bits
    namespace vbtoctlr_bits {
        constexpr uint32_t Reserved = (2 << 6);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t VOUT2LSEL = (1U << 5);  ///< VBATT Wakeup I/O 2 Output Level Selection
        constexpr uint32_t VCOU1LSEL = (1U << 4);  ///< VBATT Wakeup I/O 1 Output Level Selection
        constexpr uint32_t VOUT0LSEL = (1U << 3);  ///< VBATT Wakeup I/O 0 Output Level Selection
        constexpr uint32_t VCH2OEN = (1U << 2);  ///< VBATT Wakeup I/O 2 Output Enable
        constexpr uint32_t VCH1OEN = (1U << 1);  ///< VBATT Wakeup I/O 1 Output Enable
        constexpr uint32_t VCH0OEN = (1U << 0);  ///< VBATT Wakeup I/O 0 Output Enable
    }

    /// VBTWTER Register bits
    namespace vbtwter_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t VRTCAE = (1U << 4);  ///< RTC Alarm Signal Enable
        constexpr uint32_t VRTCIE = (1U << 3);  ///< RTC Periodic Signal Enable
        constexpr uint32_t VCH2E = (1U << 2);  ///< VBATWIO2 Pin Enable
        constexpr uint32_t VCH1E = (1U << 1);  ///< VBATWIO1 Pin Enable
        constexpr uint32_t VCH0E = (1U << 0);  ///< VBATWIO0 Pin Enable
    }

    /// VBTWEGR Register bits
    namespace vbtwegr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t VCH2EG = (1U << 2);  ///< VBATWIO2 Wakeup Trigger Source Edge Select
        constexpr uint32_t VCH1EG = (1U << 1);  ///< VBATWIO1 Wakeup Trigger Source Edge Select
        constexpr uint32_t VCH0EG = (1U << 0);  ///< VBATWIO0 Wakeup Trigger Source Edge Select
    }

    /// VBTWFR Register bits
    namespace vbtwfr_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t VRTCAF = (1U << 4);  ///< VBATT RTC-Alarm Wakeup Trigger Flag
        constexpr uint32_t VRTCIF = (1U << 3);  ///< VBATT RTC-Interval Wakeup Trigger Flag
        constexpr uint32_t VCH2F = (1U << 2);  ///< VBATWIO2 Wakeup Trigger Flag
        constexpr uint32_t VCH1F = (1U << 1);  ///< VBATWIO1 Wakeup Trigger Flag
        constexpr uint32_t VCH0F = (1U << 0);  ///< VBATWIO0 Wakeup Trigger Flag
    }

    /// VBTBKR[%s] Register bits
    namespace vbtbkr[%s]_bits {
        constexpr uint32_t VBTBKR = (8 << 0);  ///< VBTBKR is a 512-byte readable/writable register to store data powered by VBATT.The value of this register is retained even when VCC is not powered but VBATT is powered.VBTBKR is initialized by VBATT selected voltage power-on-reset.
    }

    /// RSTSR0 Register bits
    namespace rstsr0_bits {
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t LVD2RF = (1U << 3);  ///< Voltage Monitor 2 Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1.
        constexpr uint32_t LVD1RF = (1U << 2);  ///< Voltage Monitor 1 Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1.
        constexpr uint32_t LVD0RF = (1U << 1);  ///< Voltage Monitor 0 Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1.
        constexpr uint32_t PORF = (1U << 0);  ///< Power-On Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1.
    }

    /// RSTSR2 Register bits
    namespace rstsr2_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CWSF = (1U << 0);  ///< Cold/Warm Start Determination FlagNote: Only 1 can be written to set the flag.
    }

    /// RSTSR1 Register bits
    namespace rstsr1_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SPERF = (1U << 12);  ///< SP Error Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t BUSMRF = (1U << 11);  ///< Bus Master MPU Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t BUSSRF = (1U << 10);  ///< Bus Slave MPU Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t REERF = (1U << 9);  ///< RAM ECC Error Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t RPERF = (1U << 8);  ///< RAM Parity Error Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t SWRF = (1U << 2);  ///< Software Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t WDTRF = (1U << 1);  ///< Watchdog Timer Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
        constexpr uint32_t IWDTRF = (1U << 0);  ///< Independent Watchdog Timer Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1.
    }

    /// PRCR Register bits
    namespace prcr_bits {
        constexpr uint32_t PRKEY = (8 << 8);  ///< PRC Key Code
        constexpr uint32_t Reserved = (1U << 2);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PRC3 = (1U << 3);  ///< Protect Bit 3
        constexpr uint32_t PRC1 = (1U << 1);  ///< Protect Bit 1
        constexpr uint32_t PRC0 = (1U << 0);  ///< Protect Bit 0
    }

    /// SBYCR Register bits
    namespace sbycr_bits {
        constexpr uint32_t SSBY = (1U << 15);  ///< Software Standby
        constexpr uint32_t OPE = (1U << 14);  ///< Output Port Enable
        constexpr uint32_t Reserved = (14 << 0);  ///< These bits are read as 00000000000000. The write value should be 00000000000000.
    }

    /// MSTPCRA Register bits
    namespace mstpcra_bits {
        constexpr uint32_t Reserved = (5 << 1);  ///< These bits are read as 11111. The write value should be 11111.
        constexpr uint32_t MSTPA22 = (1U << 22);  ///< DMA Controller/Data Transfer Controller Module Stop
        constexpr uint32_t MSTPA6 = (1U << 6);  ///< ECCRAM Module Stop
        constexpr uint32_t MSTPA0 = (1U << 0);  ///< RAM0 Module Stop
    }

    /// SNZCR Register bits
    namespace snzcr_bits {
        constexpr uint32_t SNZE = (1U << 7);  ///< Snooze Mode Enable
        constexpr uint32_t Reserved = (5 << 2);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SNZDTCEN = (1U << 1);  ///< DTC Enable in Snooze Mode
        constexpr uint32_t RXDREQEN = (1U << 0);  ///< RXD0 Snooze Request Enable NOTE: Do not set to 1 other than in asynchronous mode.
    }

    /// SNZEDCR Register bits
    namespace snzedcr_bits {
        constexpr uint32_t SCI0UMTED = (1U << 7);  ///< SCI0 Address Mismatch Snooze End Enable
        constexpr uint32_t Reserved = (2 << 5);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t AD0UMTED = (1U << 4);  ///< ADC140 Compare Mismatch Snooze End Enable
        constexpr uint32_t AD0MATED = (1U << 3);  ///< ADC140 Compare Match Snooze End Enable
        constexpr uint32_t DTCNZRED = (1U << 2);  ///< Not Last DTC Transmission Completion Snooze End Enable
        constexpr uint32_t DTCZRED = (1U << 1);  ///< Last DTC Transmission Completion Snooze End Enable
        constexpr uint32_t AGT1UNFED = (1U << 0);  ///< AGT1 Underflow Snooze End Enable
    }

    /// SNZREQCR Register bits
    namespace snzreqcr_bits {
        constexpr uint32_t Reserved = (1U << 16);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SNZREQEN30 = (1U << 30);  ///< Snooze Request Enable 30Enable AGT1 compare match B snooze request
        constexpr uint32_t SNZREQEN29 = (1U << 29);  ///< Snooze Request Enable 29Enable AGT1 compare match A snooze request
        constexpr uint32_t SNZREQEN28 = (1U << 28);  ///< Snooze Request Enable 28Enable AGT1 underflow snooze request
        constexpr uint32_t SNZREQEN25 = (1U << 25);  ///< Snooze Request Enable 25Enable RTC period snooze request
        constexpr uint32_t SNZREQEN24 = (1U << 24);  ///< Snooze Request Enable 24Enable RTC alarm snooze request
        constexpr uint32_t SNZREQEN23 = (1U << 23);  ///< Snooze Request Enable 23Enable RTC alarm snooze request
        constexpr uint32_t SNZREQEN17 = (1U << 17);  ///< Snooze Request Enable 17Enable KR snooze request
        constexpr uint32_t SNZREQEN15 = (1U << 15);  ///< Snooze Request Enable 15Enable IRQ15 pin snooze request
        constexpr uint32_t SNZREQEN14 = (1U << 14);  ///< Snooze Request Enable 14Enable IRQ14 pin snooze request
        constexpr uint32_t SNZREQEN13 = (1U << 13);  ///< Snooze Request Enable 13Enable IRQ13 pin snooze request
        constexpr uint32_t SNZREQEN12 = (1U << 12);  ///< Snooze Request Enable 12Enable IRQ12 pin snooze request
        constexpr uint32_t SNZREQEN11 = (1U << 11);  ///< Snooze Request Enable 11Enable IRQ11 pin snooze request
        constexpr uint32_t SNZREQEN10 = (1U << 10);  ///< Snooze Request Enable 10Enable IRQ10 pin snooze request
        constexpr uint32_t SNZREQEN9 = (1U << 9);  ///< Snooze Request Enable 9Enable IRQ9 pin snooze request
        constexpr uint32_t SNZREQEN8 = (1U << 8);  ///< Snooze Request Enable 8Enable IRQ8 pin snooze request
        constexpr uint32_t SNZREQEN7 = (1U << 7);  ///< Snooze Request Enable 7Enable IRQ7 pin snooze request
        constexpr uint32_t SNZREQEN6 = (1U << 6);  ///< Snooze Request Enable 6Enable IRQ6 pin snooze request
        constexpr uint32_t SNZREQEN5 = (1U << 5);  ///< Snooze Request Enable 5Enable IRQ5 pin snooze request
        constexpr uint32_t SNZREQEN4 = (1U << 4);  ///< Snooze Request Enable 4Enable IRQ4 pin snooze request
        constexpr uint32_t SNZREQEN3 = (1U << 3);  ///< Snooze Request Enable 3Enable IRQ3 pin snooze request
        constexpr uint32_t SNZREQEN2 = (1U << 2);  ///< Snooze Request Enable 2Enable IRQ2 pin snooze request
        constexpr uint32_t SNZREQEN1 = (1U << 1);  ///< Snooze Request Enable 1Enable IRQ1 pin snooze request
        constexpr uint32_t SNZREQEN0 = (1U << 0);  ///< Snooze Request Enable 0Enable IRQ0 pin snooze request
    }

    /// PSMCR Register bits
    namespace psmcr_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PSMC = (2 << 0);  ///< Power save memory control.
    }

    /// FLSTOP Register bits
    namespace flstop_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t FLSTPF = (1U << 4);  ///< Flash Memory Operation Status Flag
        constexpr uint32_t FLSTOP = (1U << 0);  ///< Selecting ON/OFF of the Flash Memory Operation
    }

    /// OPCCR Register bits
    namespace opccr_bits {
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t OPCMTSF = (1U << 4);  ///< Operating Power Control Mode Transition Status Flag
        constexpr uint32_t OPCM = (2 << 0);  ///< Operating Power Control Mode Select
    }

    /// SOPCCR Register bits
    namespace sopccr_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t SOPCMTSF = (1U << 4);  ///< Sub Operating Power Control Mode Transition Status Flag
        constexpr uint32_t SOPCM = (1U << 0);  ///< Sub Operating Power Control Mode Select
    }

    /// SYOCDCR Register bits
    namespace syocdcr_bits {
        constexpr uint32_t DBGEN = (1U << 7);  ///< Debugger Enable bit
        constexpr uint32_t Reserved = (7 << 0);  ///< These bits are read as 0000000. The write value should be 0000000.
    }

    /// SCKDIVCR Register bits
    namespace sckdivcr_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t FCK = (3 << 28);  ///< Flash IF Clock (FCLK) Select
        constexpr uint32_t ICK = (3 << 24);  ///< System Clock (ICLK) Select
        constexpr uint32_t BCK = (3 << 16);  ///< External Bus Clock (BCLK) Select
        constexpr uint32_t PCKA = (3 << 12);  ///< Peripheral Module Clock A (PCLKA) Select
        constexpr uint32_t PCKB = (3 << 8);  ///< Peripheral Module Clock B (PCLKB) Select
        constexpr uint32_t PCKC = (3 << 4);  ///< Peripheral Module Clock C (PCLKC) Select
        constexpr uint32_t PCKD = (3 << 0);  ///< Peripheral Module Clock D (PCLKD) Select
    }

    /// SCKSCR Register bits
    namespace sckscr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t CKSEL = (3 << 0);  ///< Clock Source SelectSelecting the system clock source faster than 32MHz(system clock source > 32MHz ) is prohibit when SCKDIVCR.ICK[2:0] bits select the division-by-1 and MEMWAIT.MEMWAIT =0.
    }

    /// PLLCR Register bits
    namespace pllcr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PLLSTP = (1U << 0);  ///< PLL Stop Control
    }

    /// PLLCCR2 Register bits
    namespace pllccr2_bits {
        constexpr uint32_t PLODIV = (2 << 6);  ///< PLL Output Frequency Division Ratio Select
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PLLMUL = (5 << 0);  ///< PLL Frequency Multiplication Factor Select
    }

    /// BCKCR Register bits
    namespace bckcr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t BCLKDIV = (1U << 0);  ///< EBCLK Pin Output Select
    }

    /// MEMWAIT Register bits
    namespace memwait_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t MEMWAIT = (1U << 0);  ///< Memory Wait Cycle SelectNote: Writing 0 to the MEMWAIT is prohibited when SCKDIVCR.ICK selects division by 1 and SCKSCR.CKSEL[2:0] bits select thesystem clock source that is faster than 32 MHz (ICLK > 32 MHz).
    }

    /// MOSCCR Register bits
    namespace mosccr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t MOSTP = (1U << 0);  ///< Main Clock Oscillator StopNote: MOMCR register must be set before setting MOSTP to 0.
    }

    /// HOCOCR Register bits
    namespace hococr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t HCSTP = (1U << 0);  ///< HOCO Stop
    }

    /// MOCOCR Register bits
    namespace mococr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t MCSTP = (1U << 0);  ///< MOCO Stop
    }

    /// OSCSF Register bits
    namespace oscsf_bits {
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00.
        constexpr uint32_t PLLSF = (1U << 5);  ///< PLL Clock Oscillation Stabilization Flag
        constexpr uint32_t MOSCSF = (1U << 3);  ///< Main Clock Oscillation Stabilization Flag
        constexpr uint32_t HOCOSF = (1U << 0);  ///< HOCO Clock Oscillation Stabilization FlagNOTE: The HOCOSF bit value after a reset is 1 when the OFS1.HOCOEN bit is 0. It is 0 when the OFS1.HOCOEN bit is 1.
    }

    /// CKOCR Register bits
    namespace ckocr_bits {
        constexpr uint32_t CKOEN = (1U << 7);  ///< Clock out enable
        constexpr uint32_t CKODIV = (3 << 4);  ///< Clock out input frequency Division Select
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CKOSEL = (3 << 0);  ///< Clock out source select
    }

    /// TRCKCR Register bits
    namespace trckcr_bits {
        constexpr uint32_t TRCKEN = (1U << 7);  ///< Trace Clock operating enable
        constexpr uint32_t Reserved = (3 << 4);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t TRCK = (4 << 0);  ///< Trace Clock operating frequency select
    }

    /// OSTDCR Register bits
    namespace ostdcr_bits {
        constexpr uint32_t OSTDE = (1U << 7);  ///< Oscillation Stop Detection Function Enable
        constexpr uint32_t Reserved = (6 << 1);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t OSTDIE = (1U << 0);  ///< Oscillation Stop Detection Interrupt Enable
    }

    /// OSTDSR Register bits
    namespace ostdsr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t OSTDF = (1U << 0);  ///< Oscillation Stop Detection Flag
    }

    /// SLCDSCKCR Register bits
    namespace slcdsckcr_bits {
        constexpr uint32_t LCDSCKEN = (1U << 7);  ///< LCD Source Clock Out Enable
        constexpr uint32_t Reserved = (4 << 3);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t LCDSCKSEL = (3 << 0);  ///< LCD Source Clock (LCDSRCCLK) Select
    }

    /// EBCKOCR Register bits
    namespace ebckocr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t EBCKOEN = (1U << 0);  ///< EBCLK Pin Output Control
    }

    /// MOCOUTCR Register bits
    namespace mocoutcr_bits {
        constexpr uint32_t MOCOUTRM = (8 << 0);  ///< MOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original MOCO trimming bits
    }

    /// HOCOUTCR Register bits
    namespace hocoutcr_bits {
        constexpr uint32_t HOCOUTRM = (8 << 0);  ///< HOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original HOCO trimming bits
    }

    /// MOSCWTCR Register bits
    namespace moscwtcr_bits {
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t MSTS = (4 << 0);  ///< Main clock oscillator wait time setting
    }

    /// HOCOWTCR Register bits
    namespace hocowtcr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t HSTS = (3 << 0);  ///< HOCO wait time setting
    }

    /// USBCKCR Register bits
    namespace usbckcr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t HSTS = (1U << 0);  ///< USB Clock Source Select
    }

    /// MOMCR Register bits
    namespace momcr_bits {
        constexpr uint32_t Reserved = (3 << 0);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t MOSEL = (1U << 6);  ///< Main Clock Oscillator Switching
        constexpr uint32_t MODRV1 = (1U << 3);  ///< Main Clock Oscillator Drive Capability 1 Switching
    }

    /// SOSCCR Register bits
    namespace sosccr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t SOSTP = (1U << 0);  ///< Sub-Clock Oscillator Stop
    }

    /// SOMCR Register bits
    namespace somcr_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t SODRV = (2 << 0);  ///< Sub-Clock Oscillator Drive Capability Switching
    }

    /// LOCOCR Register bits
    namespace lococr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t LCSTP = (1U << 0);  ///< LOCO Stop
    }

    /// LOCOUTCR Register bits
    namespace locoutcr_bits {
        constexpr uint32_t LOCOUTRM = (8 << 0);  ///< LOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original LOCO trimming bits
    }

    /// BKRACR Register bits
    namespace bkracr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t BKRACS = (3 << 0);  ///< Backup Register Access Control Register
    }

    /// LVCMPCR Register bits
    namespace lvcmpcr_bits {
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t LVD2E = (1U << 6);  ///< Voltage Detection 2 Enable
        constexpr uint32_t LVD1E = (1U << 5);  ///< Voltage Detection 1 Enable
    }

    /// LVDLVLR Register bits
    namespace lvdlvlr_bits {
        constexpr uint32_t LVD2LVL = (3 << 5);  ///< Voltage Detection 2 Level Select (Standard voltage during drop in voltage)
        constexpr uint32_t LVD1LVL = (5 << 0);  ///< Voltage Detection 1 Level Select (Standard voltage during drop in voltage)
    }

    /// LVD%sCR0 Register bits
    namespace lvd%scr0_bits {
        constexpr uint32_t RN = (1U << 7);  ///< Voltage Monitor Reset Negate Select
        constexpr uint32_t RI = (1U << 6);  ///< Voltage Monitor Circuit Mode Select
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CMPE = (1U << 2);  ///< Voltage Monitor Circuit Comparison Result Output Enable
        constexpr uint32_t RIE = (1U << 0);  ///< Voltage Monitor Interrupt/Reset Enable
    }

    /// LVD%sCR1 Register bits
    namespace lvd%scr1_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t IRQSEL = (1U << 2);  ///< Voltage Monitor Interrupt Type Select
        constexpr uint32_t IDTSEL = (2 << 0);  ///< Voltage Monitor Interrupt Generation Condition Select
    }

    /// LVD%sSR Register bits
    namespace lvd%ssr_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t MON = (1U << 1);  ///< Voltage Monitor 1 Signal Monitor Flag
        constexpr uint32_t DET = (1U << 0);  ///< Voltage Monitor Voltage Change Detection Flag NOTE: Only 0 can be written to this bit. After writing 0 to this bit, it takes 2 system clock cycles for the bit to be read as 0.
    }

}

// ============================================================================
// MSTP Peripheral
// ============================================================================

namespace mstp {
    /// Base addresses
    constexpr uint32_t MSTP_BASE = 0x40047000;

    /// MSTP Register structure
    struct Registers {
        volatile uint32_t MSTPCRB;  ///< Offset: 0x00 - Module Stop Control Register B
        volatile uint32_t MSTPCRC;  ///< Offset: 0x04 - Module Stop Control Register C
        volatile uint32_t MSTPCRD;  ///< Offset: 0x08 - Module Stop Control Register D
    };

    /// Peripheral instances
    inline Registers* MSTP = reinterpret_cast<Registers*>(MSTP_BASE);

    // Bit definitions
    /// MSTPCRB Register bits
    namespace mstpcrb_bits {
        constexpr uint32_t MSTPB31 = (1U << 31);  ///< Serial Communication Interface 0 Module Stop
        constexpr uint32_t MSTPB30 = (1U << 30);  ///< Serial Communication Interface 1 Module Stop
        constexpr uint32_t MSTPB29 = (1U << 29);  ///< Serial Communication Interface 2 Module Stop
        constexpr uint32_t MSTPB28 = (1U << 28);  ///< Serial Communication Interface 3 Module Stop
        constexpr uint32_t MSTPB27 = (1U << 27);  ///< Serial Communication Interface 4 Module Stop
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 11. The write value should be 11.
        constexpr uint32_t MSTPB22 = (1U << 22);  ///< Serial Communication Interface 9 Module Stop
        constexpr uint32_t MSTPB19 = (1U << 19);  ///< Serial Peripheral Interface 0 Module Stop
        constexpr uint32_t MSTPB18 = (1U << 18);  ///< Serial Peripheral Interface 1 Module Stop
        constexpr uint32_t MSTPB11 = (1U << 11);  ///< Universal Serial Bus 2.0 FS Interface Module Stop
        constexpr uint32_t MSTPB9 = (1U << 9);  ///< I2C Bus Interface 0 Module Stop
        constexpr uint32_t MSTPB8 = (1U << 8);  ///< I2C Bus Interface 1 Module Stop
        constexpr uint32_t MSTPB7 = (1U << 7);  ///< I2C Bus Interface 2 Module Stop
        constexpr uint32_t MSTPB6 = (1U << 6);  ///< Queued Serial Peripheral Interface Module Stop
        constexpr uint32_t MSTPB2 = (1U << 2);  ///< Controller Area Network Module Stop
    }

    /// MSTPCRC Register bits
    namespace mstpcrc_bits {
        constexpr uint32_t MSTPC31 = (1U << 31);  ///< TSIP Module Stop
        constexpr uint32_t Reserved = (1U << 2);  ///< This bit is read as 1. The write value should be 1.
        constexpr uint32_t MSTPC14 = (1U << 14);  ///< Event Link Controller Module Stop
        constexpr uint32_t MSTPC13 = (1U << 13);  ///< Data Operation Circuit Module Stop
        constexpr uint32_t MSTPC12 = (1U << 12);  ///< Secure Digital Host Interface/Multi Media Card Interface ModuleStop
        constexpr uint32_t MSTPC8 = (1U << 8);  ///< Synchronous Serial Interface 0 Module Stop
        constexpr uint32_t MSTPC4 = (1U << 4);  ///< Segment LCD Controller Module Stop
        constexpr uint32_t MSTPC3 = (1U << 3);  ///< Capacitive Touch Sensing Unit Module Stop
        constexpr uint32_t MSTPC1 = (1U << 1);  ///< Cyclic Redundancy Check Calculator Module Stop
        constexpr uint32_t MSTPC0 = (1U << 0);  ///< Clock Frequency Accuracy Measurement Circuit Module Stop
    }

    /// MSTPCRD Register bits
    namespace mstpcrd_bits {
        constexpr uint32_t MSTPD31 = (1U << 31);  ///< Operational Amplifier Module Stop
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 11. The write value should be 11.
        constexpr uint32_t MSTPD29 = (1U << 29);  ///< Low-Power Analog Comparator Module Stop
        constexpr uint32_t MSTPD20 = (1U << 20);  ///< 12-Bit D/A Converter Module Stop
        constexpr uint32_t MSTPD19 = (1U << 19);  ///< 8-bit D/A Converter Module Stop
        constexpr uint32_t MSTPD16 = (1U << 16);  ///< 14-Bit A/D Converter Module Stop
        constexpr uint32_t MSTPD14 = (1U << 14);  ///< Port Output Enable for GPT Module Stop
        constexpr uint32_t MSTPD6 = (1U << 6);  ///< General PWM Timer 169 to 164 Module Stop
        constexpr uint32_t MSTPD5 = (1U << 5);  ///< General PWM Timer 323 to 320 Module Stop
        constexpr uint32_t MSTPD3 = (1U << 3);  ///< Asynchronous General Purpose Timer 0 Module Stop
        constexpr uint32_t MSTPD2 = (1U << 2);  ///< Asynchronous General Purpose Timer 1 Module Stop
    }

}

// ============================================================================
// FCACHE Peripheral
// ============================================================================

namespace fcache {
    /// Base addresses
    constexpr uint32_t FCACHE_BASE = 0x4001C000;

    /// FCACHE Register structure
    struct Registers {
        volatile uint32_t FCACHEE;  ///< Offset: 0x100 - Flash Cache Enable Register
        volatile uint32_t FCACHEIV;  ///< Offset: 0x104 - Flash Cache Invalidate Register
        volatile uint32_t FLWT;  ///< Offset: 0x11C - Flash Wait Cycle Register
    };

    /// Peripheral instances
    inline Registers* FCACHE = reinterpret_cast<Registers*>(FCACHE_BASE);

    // Bit definitions
    /// FCACHEE Register bits
    namespace fcachee_bits {
        constexpr uint32_t Reserved = (15 << 1);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
        constexpr uint32_t FCACHEEN = (1U << 0);  ///< FCACHE Enable
    }

    /// FCACHEIV Register bits
    namespace fcacheiv_bits {
        constexpr uint32_t Reserved = (15 << 1);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
        constexpr uint32_t FCACHEIV = (1U << 0);  ///< FCACHE Invalidation
    }

    /// FLWT Register bits
    namespace flwt_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t FLWT = (3 << 0);  ///< These bits represent the ratio of the CPU clock period to the Flash memory access time.
    }

}

// ============================================================================
// ICU Peripheral
// ============================================================================

namespace icu {
    /// Base addresses
    constexpr uint32_t ICU_BASE = 0x40006000;

    /// ICU Register structure
    struct Registers {
        volatile uint32_t IRQCR%s;  ///< Offset: 0x00 - IRQ Control Register %s
        volatile uint32_t NMISR;  ///< Offset: 0x140 - Non-Maskable Interrupt Status Register
        volatile uint32_t NMIER;  ///< Offset: 0x120 - Non-Maskable Interrupt Enable Register
        volatile uint32_t NMICLR;  ///< Offset: 0x130 - Non-Maskable Interrupt Status Clear Register
        volatile uint32_t NMICR;  ///< Offset: 0x100 - NMI Pin Interrupt Control Register
        volatile uint32_t IELSR%s;  ///< Offset: 0x300 - ICU Event Link Setting Register %s
        volatile uint32_t DELSR%s;  ///< Offset: 0x280 - DMAC Event Link Setting Register %s
        volatile uint32_t SELSR0;  ///< Offset: 0x200 - Snooze Event Link Setting Register
        volatile uint32_t WUPEN;  ///< Offset: 0x1A0 - Wake Up Interrupt Enable Register
    };

    /// Peripheral instances
    inline Registers* ICU = reinterpret_cast<Registers*>(ICU_BASE);

    // Bit definitions
    /// IRQCR%s Register bits
    namespace irqcr%s_bits {
        constexpr uint32_t FLTEN = (1U << 7);  ///< IRQ Digital Filter Enable
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t FCLKSEL = (2 << 4);  ///< IRQ Digital Filter Sampling Clock Select
        constexpr uint32_t IRQMD = (2 << 0);  ///< IRQ Detection Sense Select
    }

    /// NMISR Register bits
    namespace nmisr_bits {
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0.
        constexpr uint32_t SPEST = (1U << 12);  ///< CPU Stack pointer monitor Interrupt Status Flag
        constexpr uint32_t BUSMST = (1U << 11);  ///< MPU Bus Master Error Interrupt Status Flag
        constexpr uint32_t BUSSST = (1U << 10);  ///< MPU Bus Slave Error Interrupt Status Flag
        constexpr uint32_t RECCST = (1U << 9);  ///< RAM ECC Error Interrupt Status Flag
        constexpr uint32_t RPEST = (1U << 8);  ///< RAM Parity Error Interrupt Status Flag
        constexpr uint32_t NMIST = (1U << 7);  ///< NMI Status Flag
        constexpr uint32_t OSTST = (1U << 6);  ///< Oscillation Stop Detection Interrupt Status Flag
        constexpr uint32_t VBATTST = (1U << 4);  ///< VBATT monitor Interrupt Status Flag
        constexpr uint32_t LVD2ST = (1U << 3);  ///< Voltage-Monitoring 2 Interrupt Status Flag
        constexpr uint32_t LVD1ST = (1U << 2);  ///< Voltage-Monitoring 1 Interrupt Status Flag
        constexpr uint32_t WDTST = (1U << 1);  ///< WDT Underflow/Refresh Error Status Flag
        constexpr uint32_t IWDTST = (1U << 0);  ///< IWDT Underflow/Refresh Error Status Flag
    }

    /// NMIER Register bits
    namespace nmier_bits {
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SPEEN = (1U << 12);  ///< CPU Stack pointer monitor Interrupt Enable
        constexpr uint32_t BUSMEN = (1U << 11);  ///< MPU Bus Master Error Interrupt Enable
        constexpr uint32_t BUSSEN = (1U << 10);  ///< MPU Bus Slave Error Interrupt Enable
        constexpr uint32_t RECCEN = (1U << 9);  ///< RAM ECC Error Interrupt Enable
        constexpr uint32_t RPEEN = (1U << 8);  ///< RAM Parity Error Interrupt Enable
        constexpr uint32_t NMIEN = (1U << 7);  ///< NMI Pin Interrupt Enable
        constexpr uint32_t OSTEN = (1U << 6);  ///< Oscillation Stop Detection Interrupt Enable
        constexpr uint32_t VBATTEN = (1U << 4);  ///< VBATT monitor Interrupt Enable
        constexpr uint32_t LVD2EN = (1U << 3);  ///< Voltage-Monitoring 2 Interrupt Enable
        constexpr uint32_t LVD1EN = (1U << 2);  ///< Voltage-Monitoring 1 Interrupt Enable
        constexpr uint32_t WDTEN = (1U << 1);  ///< WDT Underflow/Refresh Error Interrupt Enable
        constexpr uint32_t IWDTEN = (1U << 0);  ///< IWDT Underflow/Refresh Error Interrupt Enable
    }

    /// NMICLR Register bits
    namespace nmiclr_bits {
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SPECLR = (1U << 12);  ///< CPU Stack Pointer Monitor Interrupt Clear
        constexpr uint32_t BUSMCLR = (1U << 11);  ///< Bus Master Error Clear
        constexpr uint32_t BUSSCLR = (1U << 10);  ///< Bus Slave Error Clear
        constexpr uint32_t RECCCLR = (1U << 9);  ///< SRAM ECC Error Clear
        constexpr uint32_t RPECLR = (1U << 8);  ///< SRAM Parity Error Clear
        constexpr uint32_t NMICLR = (1U << 7);  ///< NMI Clear
        constexpr uint32_t OSTCLR = (1U << 6);  ///< OST Clear
        constexpr uint32_t VBATTCLR = (1U << 4);  ///< VBATT Clear
        constexpr uint32_t LVD2CLR = (1U << 3);  ///< LVD2 Clear
        constexpr uint32_t LVD1CLR = (1U << 2);  ///< LVD1 Clear
        constexpr uint32_t WDTCLR = (1U << 1);  ///< WDT Clear
        constexpr uint32_t IWDTCLR = (1U << 0);  ///< IWDT Clear
    }

    /// NMICR Register bits
    namespace nmicr_bits {
        constexpr uint32_t NFLTEN = (1U << 7);  ///< NMI Digital Filter Enable
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t NFCLKSEL = (2 << 4);  ///< NMI Digital Filter Sampling Clock Select
        constexpr uint32_t NMIMD = (1U << 0);  ///< NMI Detection Set
    }

    /// IELSR%s Register bits
    namespace ielsr%s_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t DTCE = (1U << 24);  ///< DTC Activation Enable
        constexpr uint32_t IR = (1U << 16);  ///< Interrupt Status Flag
        constexpr uint32_t IELS = (8 << 0);  ///< ICU Event selection to NVICSet the number for the event signal to be linked .
    }

    /// DELSR%s Register bits
    namespace delsr%s_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t DELS = (8 << 0);  ///< Event selection to DMAC Start request
    }

    /// SELSR0 Register bits
    namespace selsr0_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t SELS = (8 << 0);  ///< SYS Event Link Select
    }

    /// WUPEN Register bits
    namespace wupen_bits {
        constexpr uint32_t IIC0WUPEN = (1U << 31);  ///< IIC0 address match interrupt S/W standby returns enable
        constexpr uint32_t AGT1CBWUPEN = (1U << 30);  ///< AGT1 compare match B interrupt S/W standby returns enable
        constexpr uint32_t AGT1CAWUPEN = (1U << 29);  ///< AGT1 compare match A interrupt S/W standby returns enable
        constexpr uint32_t AGT1UDWUPEN = (1U << 28);  ///< AGT1 underflow interrupt S/W standby returns enable
        constexpr uint32_t USBFSWUPEN = (1U << 27);  ///< USBFS interrupt S/W standby returns enable
        constexpr uint32_t Reserved = (2 << 21);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t RTCPRDWUPEN = (1U << 25);  ///< RCT period interrupt S/W standby returns enable
        constexpr uint32_t RTCALMWUPEN = (1U << 24);  ///< RTC alarm interrupt S/W standby returns enable
        constexpr uint32_t ACMPLP0WUPEN = (1U << 23);  ///< ACMPLP0 interrupt S/W standby returns enable
        constexpr uint32_t VBATTWUPEN = (1U << 20);  ///< VBATT monitor interrupt S/W standby returns enable
        constexpr uint32_t LVD2WUPEN = (1U << 19);  ///< LVD2 interrupt S/W standby returns enable
        constexpr uint32_t LVD1WUPEN = (1U << 18);  ///< LVD1 interrupt S/W standby returns enable
        constexpr uint32_t KEYWUPEN = (1U << 17);  ///< Key interrupt S/W standby returns enable
        constexpr uint32_t IWDTWUPEN = (1U << 16);  ///< IWDT interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN15 = (1U << 15);  ///< IRQ15 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN14 = (1U << 14);  ///< IRQ14 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN13 = (1U << 13);  ///< IRQ13 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN12 = (1U << 12);  ///< IRQ12 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN11 = (1U << 11);  ///< IRQ11 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN10 = (1U << 10);  ///< IRQ10 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN9 = (1U << 9);  ///< IRQ9 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN8 = (1U << 8);  ///< IRQ8 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN7 = (1U << 7);  ///< IRQ7 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN6 = (1U << 6);  ///< IRQ6 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN5 = (1U << 5);  ///< IRQ5 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN4 = (1U << 4);  ///< IRQ4 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN3 = (1U << 3);  ///< IRQ3 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN2 = (1U << 2);  ///< IRQ2 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN1 = (1U << 1);  ///< IRQ1 interrupt S/W standby returns enable
        constexpr uint32_t IRQWUPEN0 = (1U << 0);  ///< IRQ0 interrupt S/W standby returns enable
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMAC0_BASE = 0x40005000;
    constexpr uint32_t DMAC1_BASE = 0x40005040;
    constexpr uint32_t DMAC2_BASE = 0x40005080;
    constexpr uint32_t DMAC3_BASE = 0x400050C0;
    constexpr uint32_t DMA_BASE = 0x40005200;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMSAR;  ///< Offset: 0x00 - DMA Source Address Register
        volatile uint32_t DMDAR;  ///< Offset: 0x04 - DMA Destination Address Register
        volatile uint32_t DMCRA;  ///< Offset: 0x08 - DMA Transfer Count Register
        volatile uint32_t DMCRB;  ///< Offset: 0x0C - DMA Block Transfer Count Register
        volatile uint32_t DMTMD;  ///< Offset: 0x10 - DMA Transfer Mode Register
        volatile uint32_t DMINT;  ///< Offset: 0x13 - DMA Interrupt Setting Register
        volatile uint32_t DMAMD;  ///< Offset: 0x14 - DMA Address Mode Register
        volatile uint32_t DMOFR;  ///< Offset: 0x18 - DMA Offset Register
        volatile uint32_t DMCNT;  ///< Offset: 0x1C - DMA Transfer Enable Register
        volatile uint32_t DMREQ;  ///< Offset: 0x1D - DMA Software Start Register
        volatile uint32_t DMSTS;  ///< Offset: 0x1E - DMA Status Register
    };

    /// Peripheral instances
    inline Registers* DMAC0 = reinterpret_cast<Registers*>(DMAC0_BASE);
    inline Registers* DMAC1 = reinterpret_cast<Registers*>(DMAC1_BASE);
    inline Registers* DMAC2 = reinterpret_cast<Registers*>(DMAC2_BASE);
    inline Registers* DMAC3 = reinterpret_cast<Registers*>(DMAC3_BASE);
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

    // Bit definitions
    /// DMSAR Register bits
    namespace dmsar_bits {
        constexpr uint32_t DMSAR = (32 << 0);  ///< Specifies the transfer source start address.
    }

    /// DMDAR Register bits
    namespace dmdar_bits {
        constexpr uint32_t DMDAR = (32 << 0);  ///< Specifies the transfer destination start address.
    }

    /// DMCRA Register bits
    namespace dmcra_bits {
        constexpr uint32_t Reserved = (6 << 26);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t DMCRAH = (10 << 16);  ///< Upper bits of transfer count
        constexpr uint32_t DMCRAL = (16 << 0);  ///< Lower bits of transfer count
    }

    /// DMCRB Register bits
    namespace dmcrb_bits {
        constexpr uint32_t DMCRB = (16 << 0);  ///< Specifies the number of block transfer operations or repeat transfer operations.
    }

    /// DMTMD Register bits
    namespace dmtmd_bits {
        constexpr uint32_t MD = (2 << 14);  ///< Transfer Mode Select
        constexpr uint32_t DTS = (2 << 12);  ///< Repeat Area Select
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t SZ = (2 << 8);  ///< Transfer Data Size Select
        constexpr uint32_t DCTG = (2 << 0);  ///< Transfer Request Source Select
    }

    /// DMINT Register bits
    namespace dmint_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t DTIE = (1U << 4);  ///< Transfer End Interrupt Enable
        constexpr uint32_t ESIE = (1U << 3);  ///< Transfer Escape End Interrupt Enable
        constexpr uint32_t RPTIE = (1U << 2);  ///< Repeat Size End Interrupt Enable
        constexpr uint32_t SARIE = (1U << 1);  ///< Source Address Extended Repeat Area Overflow Interrupt Enable
        constexpr uint32_t DARIE = (1U << 0);  ///< Destination Address Extended Repeat Area Overflow Interrupt Enable
    }

    /// DMAMD Register bits
    namespace dmamd_bits {
        constexpr uint32_t SM = (2 << 14);  ///< Source Address Update Mode
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SARA = (5 << 8);  ///< Source Address Extended Repeat Area Specifies the extended repeat area on the source address. For details on the settings.
        constexpr uint32_t DM = (2 << 6);  ///< Destination Address Update Mode
        constexpr uint32_t DARA = (5 << 0);  ///< Destination Address Extended Repeat Area Specifies the extended repeat area on the destination address. For details on the settings.
    }

    /// DMOFR Register bits
    namespace dmofr_bits {
        constexpr uint32_t DMOFR = (32 << 0);  ///< Specifies the offset when offset addition is selected as the address update mode for transfer source or destination.
    }

    /// DMCNT Register bits
    namespace dmcnt_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t DTE = (1U << 0);  ///< DMA Transfer Enable
    }

    /// DMREQ Register bits
    namespace dmreq_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t CLRS = (1U << 4);  ///< DMA Software Start Bit Auto Clear Select
        constexpr uint32_t SWREQ = (1U << 0);  ///< DMA Software Start
    }

    /// DMSTS Register bits
    namespace dmsts_bits {
        constexpr uint32_t ACT = (1U << 7);  ///< DMA Active Flag
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t DTIF = (1U << 4);  ///< Transfer End Interrupt Flag
        constexpr uint32_t ESIF = (1U << 0);  ///< Transfer Escape End Interrupt Flag
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0x4001B000;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t DBGSTR;  ///< Offset: 0x00 - Debug Status Register
        volatile uint32_t DBGSTOPCR;  ///< Offset: 0x10 - Debug Stop Control Register
        volatile uint32_t TRACECTR;  ///< Offset: 0x20 - Trace Control Register
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// DBGSTR Register bits
    namespace dbgstr_bits {
        constexpr uint32_t Reserved = (28 << 0);  ///< These bits are read as 0000000000000000000000000000.
        constexpr uint32_t CDBGPWRUPACK = (1U << 29);  ///< Debug power-up acknowledge
        constexpr uint32_t CDBGPWRUPREQ = (1U << 28);  ///< Debug power-up request
    }

    /// DBGSTOPCR Register bits
    namespace dbgstopcr_bits {
        constexpr uint32_t Reserved = (14 << 2);  ///< These bits are read as 00000000000000. The write value should be 00000000000000.
        constexpr uint32_t DBGSTOP_RECCR = (1U << 25);  ///< Mask bit for RAM ECC error reset/interrupt
        constexpr uint32_t DBGSTOP_RPER = (1U << 24);  ///< Mask bit for RAM parity error reset/interrupt
        constexpr uint32_t DBGSTOP_LVD = (3 << 16);  ///< b18: Mask bit for LVD2 reset/interrupt (0:enable / 1:Mask)b17: Mask bit for LVD1 reset/interrupt (0:enable / 1:Mask)b16: Mask bit for LVD0 reset (0:enable / 1:Mask)
        constexpr uint32_t DBGSTOP_WDT = (1U << 1);  ///< Mask bit for WDT reset/interrupt
        constexpr uint32_t DBGSTOP_IWDT = (1U << 0);  ///< Mask bit for IWDT reset/interrupt
    }

    /// TRACECTR Register bits
    namespace tracectr_bits {
        constexpr uint32_t ENETBFULL = (1U << 31);  ///< Enable bit for halt request by ETB full
        constexpr uint32_t Reserved = (31 << 0);  ///< These bits are read as 0000000000000000000000000000000. The write value should be 0000000000000000000000000000000.
    }

}

// ============================================================================
// BUS Peripheral
// ============================================================================

namespace bus {
    /// Base addresses
    constexpr uint32_t BUS_BASE = 0x40003000;

    /// BUS Register structure
    struct Registers {
        volatile uint32_t CS%sMOD;  ///< Offset: 0x02 - CS%s Mode Register
        volatile uint32_t CS%sWCR1;  ///< Offset: 0x04 - CS%s Wait Control Register 1
        volatile uint32_t CS%sWCR2;  ///< Offset: 0x08 - CS%s Wait Control Register 2
        volatile uint32_t CS0CR;  ///< Offset: 0x802 - CS0 Control Register
        volatile uint32_t CS%sREC;  ///< Offset: 0x80A - CS%s Recovery Cycle Register
        volatile uint32_t CS%sCR;  ///< Offset: 0x812 - CS%s Control Register
        volatile uint32_t CSRECEN;  ///< Offset: 0x880 - CS Recovery Cycle Insertion Enable Register
        volatile uint32_t BUSMCNT%s;  ///< Offset: 0x1000 - Master Bus Control Register %s
        volatile uint32_t BUSSCNTFLI;  ///< Offset: 0x1100 - Slave Bus Control Register FLI
        volatile uint32_t BUSSCNT%s;  ///< Offset: 0x1130 - Slave Bus Control Register %s
        volatile uint32_t BUSSCNTP6B;  ///< Offset: 0x1128 - Slave Bus Control Register P6B
        volatile uint32_t BUS%sERRADD;  ///< Offset: 0x1800 - Bus Error Address Register %s
        volatile uint32_t BUS%sERRSTAT;  ///< Offset: 0x1804 - Bus Error Status Register %s
    };

    /// Peripheral instances
    inline Registers* BUS = reinterpret_cast<Registers*>(BUS_BASE);

    // Bit definitions
    /// CS%sMOD Register bits
    namespace cs%smod_bits {
        constexpr uint32_t PRDMOD = (1U << 15);  ///< Page Read Access Mode Select
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t PWENB = (1U << 9);  ///< Page Write Access Enable
        constexpr uint32_t PRENB = (1U << 8);  ///< Page Read Access Enable
        constexpr uint32_t EWENB = (1U << 3);  ///< External Wait Enable
        constexpr uint32_t WRMOD = (1U << 0);  ///< Write Access Mode Select
    }

    /// CS%sWCR1 Register bits
    namespace cs%swcr1_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t CSRWAIT = (5 << 24);  ///< Normal Read Cycle Wait Select
        constexpr uint32_t CSWWAIT = (5 << 16);  ///< Normal Write Cycle Wait Select
        constexpr uint32_t CSPRWAIT = (3 << 8);  ///< Page Read Cycle Wait SelectNOTE: The CSPRWAIT value is valid only when the PRENB bit in CSnMOD is set to 1.
        constexpr uint32_t CSPWWAIT = (3 << 0);  ///< Page Write Cycle Wait SelectNOTE: The CSPWWAIT value is valid only when the PWENB bit in CSnMOD is set to 1.
    }

    /// CS%sWCR2 Register bits
    namespace cs%swcr2_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CSON = (3 << 28);  ///< CS Assert Wait Select
        constexpr uint32_t WDON = (3 << 24);  ///< Write Data Output Wait Select
        constexpr uint32_t WRON = (3 << 20);  ///< WR Assert Wait Select
        constexpr uint32_t RDON = (3 << 16);  ///< RD Assert Wait Select
        constexpr uint32_t AWAIT = (2 << 12);  ///< Address Cycle Wait Select
        constexpr uint32_t WDOFF = (3 << 8);  ///< Write Data Output Extension Cycle Select
        constexpr uint32_t CSWOFF = (3 << 4);  ///< Write-Access CS Extension Cycle Select
        constexpr uint32_t CSROFF = (3 << 0);  ///< Read-Access CS Extension Cycle Select
    }

    /// CS0CR Register bits
    namespace cs0cr_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t MPXEN = (1U << 12);  ///< Address/Data Multiplexed I/O Interface Select
        constexpr uint32_t EMODE = (1U << 8);  ///< Endian Mode
        constexpr uint32_t BSIZE = (2 << 4);  ///< External Bus Width Select
        constexpr uint32_t EXENB = (1U << 0);  ///< Operation Enable
    }

    /// CS%sREC Register bits
    namespace cs%srec_bits {
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t WRCV = (4 << 8);  ///< Write Recovery
        constexpr uint32_t RRCV = (4 << 0);  ///< Read Recovery
    }

    /// CS%sCR Register bits
    namespace cs%scr_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t MPXEN = (1U << 12);  ///< Address/Data Multiplexed I/O Interface Select
        constexpr uint32_t EMODE = (1U << 8);  ///< Endian Mode
        constexpr uint32_t BSIZE = (2 << 4);  ///< External Bus Width Select
        constexpr uint32_t EXENB = (1U << 0);  ///< Operation Enable
    }

    /// CSRECEN Register bits
    namespace csrecen_bits {
        constexpr uint32_t RECVENM7 = (1U << 15);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 7
        constexpr uint32_t RECVENM6 = (1U << 14);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 6
        constexpr uint32_t RECVENM5 = (1U << 13);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 5
        constexpr uint32_t RECVENM4 = (1U << 12);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 4
        constexpr uint32_t RECVENM3 = (1U << 11);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 3
        constexpr uint32_t RECVENM2 = (1U << 10);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 2
        constexpr uint32_t RECVENM1 = (1U << 9);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 1
        constexpr uint32_t RECVENM0 = (1U << 8);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 0
        constexpr uint32_t RECVEN7 = (1U << 7);  ///< Separate Bus Recovery Cycle Insertion Enable 7
        constexpr uint32_t RECVEN6 = (1U << 6);  ///< Separate Bus Recovery Cycle Insertion Enable 6
        constexpr uint32_t RECVEN5 = (1U << 5);  ///< Separate Bus Recovery Cycle Insertion Enable 5
        constexpr uint32_t RECVEN4 = (1U << 4);  ///< Separate Bus Recovery Cycle Insertion Enable 4
        constexpr uint32_t RECVEN3 = (1U << 3);  ///< Separate Bus Recovery Cycle Insertion Enable 3
        constexpr uint32_t RECVEN2 = (1U << 2);  ///< Separate Bus Recovery Cycle Insertion Enable 2
        constexpr uint32_t RECVEN1 = (1U << 1);  ///< Separate Bus Recovery Cycle Insertion Enable 1
        constexpr uint32_t RECVEN0 = (1U << 0);  ///< Separate Bus Recovery Cycle Insertion Enable 0
    }

    /// BUSMCNT%s Register bits
    namespace busmcnt%s_bits {
        constexpr uint32_t IERES = (1U << 15);  ///< Ignore Error Responses
        constexpr uint32_t Reserved = (15 << 0);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
    }

    /// BUSSCNTFLI Register bits
    namespace busscntfli_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration MethodSpecify the priority between groups
    }

    /// BUSSCNT%s Register bits
    namespace busscnt%s_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration MethodSpecify the priority between groups
    }

    /// BUSSCNTP6B Register bits
    namespace busscntp6b_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration MethodSpecify the priority between groups
    }

    /// BUS%sERRADD Register bits
    namespace bus%serradd_bits {
        constexpr uint32_t BERAD = (32 << 0);  ///< Bus Error AddressWhen a bus error occurs, It stores an error address.
    }

    /// BUS%sERRSTAT Register bits
    namespace bus%serrstat_bits {
        constexpr uint32_t ERRSTAT = (1U << 7);  ///< Bus Error StatusWhen bus error assert, error flag occurs.
        constexpr uint32_t Reserved = (6 << 1);  ///< These bits are read as 000000.
        constexpr uint32_t ACCSTST = (1U << 0);  ///< Error Access StatusThe status at the time of the error
    }

}

// ============================================================================
// SRAM Peripheral
// ============================================================================

namespace sram {
    /// Base addresses
    constexpr uint32_t SRAM_BASE = 0x40002000;

    /// SRAM Register structure
    struct Registers {
        volatile uint32_t PARIOAD;  ///< Offset: 0x00 - SRAM Parity Error Operation After Detection Register
        volatile uint32_t SRAMPRCR;  ///< Offset: 0x04 - SRAM Protection Register
        volatile uint32_t ECCMODE;  ///< Offset: 0xC0 - ECC Operating Mode Control Register
        volatile uint32_t ECC2STS;  ///< Offset: 0xC1 - ECC 2-Bit Error Status Register
        volatile uint32_t ECC1STSEN;  ///< Offset: 0xC2 - ECC 1-Bit Error Information Update Enable Register
        volatile uint32_t ECC1STS;  ///< Offset: 0xC3 - ECC 1-Bit Error Status Register
        volatile uint32_t ECCPRCR;  ///< Offset: 0xC4 - ECC Protection Register
        volatile uint32_t ECCPRCR2;  ///< Offset: 0xD0 - ECC Protection Register 2
        volatile uint32_t ECCETST;  ///< Offset: 0xD4 - ECC Test Control Register
        volatile uint32_t ECCOAD;  ///< Offset: 0xD8 - SRAM ECC Error Operation After Detection Register
    };

    /// Peripheral instances
    inline Registers* SRAM = reinterpret_cast<Registers*>(SRAM_BASE);

    // Bit definitions
    /// PARIOAD Register bits
    namespace parioad_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after Detection
    }

    /// SRAMPRCR Register bits
    namespace sramprcr_bits {
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
        constexpr uint32_t SRAMPRCR = (1U << 0);  ///< Register Write Control
    }

    /// ECCMODE Register bits
    namespace eccmode_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t ECCMOD = (2 << 0);  ///< ECC Operating Mode Select
    }

    /// ECC2STS Register bits
    namespace ecc2sts_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ECC2ERR = (1U << 0);  ///< ECC 2-Bit Error Status
    }

    /// ECC1STSEN Register bits
    namespace ecc1stsen_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t E1STSEN = (1U << 0);  ///< ECC 1-Bit Error Information Update Enable
    }

    /// ECC1STS Register bits
    namespace ecc1sts_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ECC1ERR = (1U << 0);  ///< ECC 1-Bit Error Status
    }

    /// ECCPRCR Register bits
    namespace eccprcr_bits {
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
        constexpr uint32_t ECCPRCR = (1U << 0);  ///< Register Write Control
    }

    /// ECCPRCR2 Register bits
    namespace eccprcr2_bits {
        constexpr uint32_t KW2 = (7 << 1);  ///< Write Key Code
        constexpr uint32_t ECCPRCR2 = (1U << 0);  ///< Register Write Control
    }

    /// ECCETST Register bits
    namespace eccetst_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t TSTBYP = (1U << 0);  ///< ECC Bypass Select
    }

    /// ECCOAD Register bits
    namespace eccoad_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after Detection
    }

}

// ============================================================================
// MMPU Peripheral
// ============================================================================

namespace mmpu {
    /// Base addresses
    constexpr uint32_t MMPU_BASE = 0x40000000;

    /// MMPU Register structure
    struct Registers {
        volatile uint32_t MMPUCTLA;  ///< Offset: 0x00 - Bus Master MPU Control Register A
        volatile uint32_t MMPUACA%s;  ///< Offset: 0x200 - Group A Region %s Access Control Register
        volatile uint32_t MMPUSA%s;  ///< Offset: 0x204 - Group A Region %s Start Address Register
        volatile uint32_t MMPUEA%s;  ///< Offset: 0x208 - Group A Region %s End Address Register
        volatile uint32_t MMPUPTA;  ///< Offset: 0x102 - Group A Protection of Register
    };

    /// Peripheral instances
    inline Registers* MMPU = reinterpret_cast<Registers*>(MMPU_BASE);

    // Bit definitions
    /// MMPUCTLA Register bits
    namespace mmpuctla_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Key CodeThese bits are used to enable or disable writing of the OAD and ENABLE bit.
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t OAD = (1U << 1);  ///< Operation after detection
        constexpr uint32_t ENABLE = (1U << 0);  ///< Master Group enable
    }

    /// MMPUACA%s Register bits
    namespace mmpuaca%s_bits {
        constexpr uint32_t Reserved = (13 << 3);  ///< These bits are read as 0000000000000. The write value should be 0000000000000.
        constexpr uint32_t WP = (1U << 2);  ///< Write protection
        constexpr uint32_t RP = (1U << 1);  ///< Read protection
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable
    }

    /// MMPUSA%s Register bits
    namespace mmpusa%s_bits {
        constexpr uint32_t MMPUSA = (32 << 0);  ///< Address where the region starts, for use in region determination.NOTE: The low-order 2 bits are fixed to 0.
    }

    /// MMPUEA%s Register bits
    namespace mmpuea%s_bits {
        constexpr uint32_t MMPUEA = (32 << 0);  ///< Region end address registerAddress where the region end, for use in region determination.NOTE: The low-order 2 bits are fixed to 1.
    }

    /// MMPUPTA Register bits
    namespace mmpupta_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register(MMPUSAn, MMPUEAn and MMPUACAn)
    }

}

// ============================================================================
// SMPU Peripheral
// ============================================================================

namespace smpu {
    /// Base addresses
    constexpr uint32_t SMPU_BASE = 0x40000C00;

    /// SMPU Register structure
    struct Registers {
        volatile uint32_t SMPUCTL;  ///< Offset: 0x00 - Slave MPU Control Register
        volatile uint32_t SMPUMBIU;  ///< Offset: 0x10 - Access Control Register for MBIU
        volatile uint32_t SMPUFBIU;  ///< Offset: 0x14 - Access Control Register for FBIU
        volatile uint32_t SMPUSRAM0;  ///< Offset: 0x18 - Access Control Register for SRAM0
        volatile uint32_t SMPUP%sBIU;  ///< Offset: 0x20 - Access Control Register for P%sBIU
        volatile uint32_t SMPUEXBIU;  ///< Offset: 0x30 - Access Control Register for EXBIU
        volatile uint32_t SMPUEXBIU2;  ///< Offset: 0x34 - Access Control Register for EXBIU2
    };

    /// Peripheral instances
    inline Registers* SMPU = reinterpret_cast<Registers*>(SMPU_BASE);

    // Bit definitions
    /// SMPUCTL Register bits
    namespace smpuctl_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code This bit is used to enable or disable rewriting of the PROTECT and OAD bit.
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t PROTECT = (2 << 1);  ///< Protection of register Protected register SMPUMBIU, SMPUFBIU, SMPUSRAM0, SMPUP0BIU, SMPUP2BIU, SMPUP6BIU,SMPUEXBIU, SMPUEXBIU2
        constexpr uint32_t OAD = (1U << 0);  ///< Master Group enable
    }

    /// SMPUMBIU Register bits
    namespace smpumbiu_bits {
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
    }

    /// SMPUFBIU Register bits
    namespace smpufbiu_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUSRAM0 Register bits
    namespace smpusram0_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUP%sBIU Register bits
    namespace smpup%sbiu_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUEXBIU Register bits
    namespace smpuexbiu_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUEXBIU2 Register bits
    namespace smpuexbiu2_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read protection
    }

}

// ============================================================================
// SPMON Peripheral
// ============================================================================

namespace spmon {
    /// Base addresses
    constexpr uint32_t SPMON_BASE = 0x40000D00;

    /// SPMON Register structure
    struct Registers {
        volatile uint32_t MSPMPUOAD;  ///< Offset: 0x00 - Stack Pointer Monitor Operation After Detection Register
        volatile uint32_t MSPMPUCTL;  ///< Offset: 0x04 - Stack Pointer Monitor Access Control Register
        volatile uint32_t MSPMPUPT;  ///< Offset: 0x06 - Stack Pointer Monitor Protection Register
        volatile uint32_t MSPMPUSA;  ///< Offset: 0x08 - Main Stack Pointer (MSP) Monitor Start Address Register
        volatile uint32_t MSPMPUEA;  ///< Offset: 0x0C - Main Stack Pointer (MSP) Monitor End Address Register
        volatile uint32_t PSPMPUOAD;  ///< Offset: 0x10 - Stack Pointer Monitor Operation After Detection Register
        volatile uint32_t PSPMPUCTL;  ///< Offset: 0x14 - Stack Pointer Monitor Access Control Register
        volatile uint32_t PSPMPUPT;  ///< Offset: 0x16 - Stack Pointer Monitor Protection Register
        volatile uint32_t PSPMPUSA;  ///< Offset: 0x18 - Process Stack Pointer (PSP) Monitor Start Address Register
        volatile uint32_t PSPMPUEA;  ///< Offset: 0x1C - Process Stack Pointer (PSP) Monitor End Address Register
    };

    /// Peripheral instances
    inline Registers* SPMON = reinterpret_cast<Registers*>(SPMON_BASE);

    // Bit definitions
    /// MSPMPUOAD Register bits
    namespace mspmpuoad_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after detection
    }

    /// MSPMPUCTL Register bits
    namespace mspmpuctl_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ERROR = (1U << 8);  ///< Stack Pointer Monitor Error Flag
        constexpr uint32_t ENABLE = (1U << 0);  ///< Stack Pointer Monitor Enable
    }

    /// MSPMPUPT Register bits
    namespace mspmpupt_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register (MSPMPUAC, MSPMPUSA and MSPMPUSE)
    }

    /// MSPMPUSA Register bits
    namespace mspmpusa_bits {
        constexpr uint32_t MSPMPUSA = (32 << 0);  ///< Region start address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00000-0x200FFFFC The low-order 2 bits are fixed to 0.
    }

    /// MSPMPUEA Register bits
    namespace mspmpuea_bits {
        constexpr uint32_t MSPMPUEA = (32 << 0);  ///< Region end address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00003-0x200FFFFF The low-order 2 bits are fixed to 1.
    }

    /// PSPMPUOAD Register bits
    namespace pspmpuoad_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Key CodeThe data written to these bits are not stored.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after detection
    }

    /// PSPMPUCTL Register bits
    namespace pspmpuctl_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ERROR = (1U << 8);  ///< Stack Pointer Monitor Error Flag
        constexpr uint32_t ENABLE = (1U << 0);  ///< Stack Pointer Monitor Enable
    }

    /// PSPMPUPT Register bits
    namespace pspmpupt_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Key CodeThe data written to these bits are not stored.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection register (PSPMPUAC, PSPMPUSA and PSPMPUSE)
    }

    /// PSPMPUSA Register bits
    namespace pspmpusa_bits {
        constexpr uint32_t PSPMPUSA = (32 << 0);  ///< Region start address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00000-0x200FFFFC The low-order 2 bits are fixed to 0.
    }

    /// PSPMPUEA Register bits
    namespace pspmpuea_bits {
        constexpr uint32_t PSPMPUEA = (32 << 0);  ///< Region end address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00003-0x200FFFFF The low-order 2 bits are fixed to 1.
    }

}

// ============================================================================
// MMF Peripheral
// ============================================================================

namespace mmf {
    /// Base addresses
    constexpr uint32_t MMF_BASE = 0x40001000;

    /// MMF Register structure
    struct Registers {
        volatile uint32_t MMSFR;  ///< Offset: 0x00 - MemMirror Special Function Register
        volatile uint32_t MMEN;  ///< Offset: 0x04 - MemMirror Enable Register
    };

    /// Peripheral instances
    inline Registers* MMF = reinterpret_cast<Registers*>(MMF_BASE);

    // Bit definitions
    /// MMSFR Register bits
    namespace mmsfr_bits {
        constexpr uint32_t KEY = (8 << 24);  ///< MMSFR Key Code
        constexpr uint32_t Reserved = (7 << 0);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t MEMMIRADDR = (16 << 7);  ///< Specifies the memory mirror address.NOTE: A value cannot be set in the low-order 7 bits. These bits are fixed to 0.
    }

    /// MMEN Register bits
    namespace mmen_bits {
        constexpr uint32_t KEY = (8 << 24);  ///< MMEN Key Code
        constexpr uint32_t Reserved = (23 << 1);  ///< These bits are read as 00000000000000000000000. The write value should be 00000000000000000000000.
        constexpr uint32_t EN = (1U << 0);  ///< Memory Mirror Function Enable
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40072000;
    constexpr uint32_t SPI1_BASE = 0x40072100;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPCR;  ///< Offset: 0x00 - SPI Control Register
        volatile uint32_t SSLP;  ///< Offset: 0x01 - SPI Slave Select Polarity Register
        volatile uint32_t SPPCR;  ///< Offset: 0x02 - SPI Pin Control Register
        volatile uint32_t SPSR;  ///< Offset: 0x03 - SPI Status Register
        volatile uint32_t SPDR;  ///< Offset: 0x04 - SPI Data Register
        volatile uint32_t SPDR_HA;  ///< Offset: 0x04 - SPI Data Register ( halfword access )
        volatile uint32_t SPSCR;  ///< Offset: 0x08 - SPI Sequence Control Register
        volatile uint32_t SPSSR;  ///< Offset: 0x09 - SPI Sequence Status Register
        volatile uint32_t SPBR;  ///< Offset: 0x0A - SPI Bit Rate Register
        volatile uint32_t SPDCR;  ///< Offset: 0x0B - SPI Data Control Register
        volatile uint32_t SPCKD;  ///< Offset: 0x0C - SPI Clock Delay Register
        volatile uint32_t SSLND;  ///< Offset: 0x0D - SPI Slave Select Negation Delay Register
        volatile uint32_t SPND;  ///< Offset: 0x0E - SPI Next-Access Delay Register
        volatile uint32_t SPCR2;  ///< Offset: 0x0F - SPI Control Register 2
        volatile uint32_t SPCMD%s;  ///< Offset: 0x10 - SPI Command Register %s
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

    // Bit definitions
    /// SPCR Register bits
    namespace spcr_bits {
        constexpr uint32_t SPRIE = (1U << 7);  ///< SPI Receive Buffer Full Interrupt Enable
        constexpr uint32_t SPE = (1U << 6);  ///< SPI Function Enable
        constexpr uint32_t SPTIE = (1U << 5);  ///< Transmit Buffer Empty Interrupt Enable
        constexpr uint32_t SPEIE = (1U << 4);  ///< SPI Error Interrupt Enable
        constexpr uint32_t MSTR = (1U << 3);  ///< SPI Master/Slave Mode Select
        constexpr uint32_t MODFEN = (1U << 2);  ///< Mode Fault Error Detection Enable
        constexpr uint32_t TXMD = (1U << 1);  ///< Communications Operating Mode Select
        constexpr uint32_t SPMS = (1U << 0);  ///< SPI Mode Select
    }

    /// SSLP Register bits
    namespace sslp_bits {
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t SSL3P = (1U << 3);  ///< SSL3 Signal Polarity Setting
        constexpr uint32_t SSL2P = (1U << 2);  ///< SSL2 Signal Polarity Setting
        constexpr uint32_t SSL1P = (1U << 1);  ///< SSL1 Signal Polarity Setting
        constexpr uint32_t SSL0P = (1U << 0);  ///< SSL0 Signal Polarity Setting
    }

    /// SPPCR Register bits
    namespace sppcr_bits {
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t MOIFE = (1U << 5);  ///< MOSI Idle Value Fixing Enable
        constexpr uint32_t MOIFV = (1U << 4);  ///< MOSI Idle Fixed Value
        constexpr uint32_t SPLP2 = (1U << 1);  ///< RSPI Loopback 2
        constexpr uint32_t SPLP = (1U << 0);  ///< RSPI Loopback
    }

    /// SPSR Register bits
    namespace spsr_bits {
        constexpr uint32_t SPRF = (1U << 7);  ///< SPI Receive Buffer Full Flag
        constexpr uint32_t Reserved = (1U << 6);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SPTEF = (1U << 5);  ///< SPI Transmit Buffer Empty Flag
        constexpr uint32_t UDRF = (1U << 4);  ///< Underrun Error Flag(When MODF is 0, This bit is invalid.)
        constexpr uint32_t PERF = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t MODF = (1U << 2);  ///< Mode Fault Error Flag
        constexpr uint32_t IDLNF = (1U << 1);  ///< SPI Idle Flag
        constexpr uint32_t OVRF = (1U << 0);  ///< Overrun Error Flag
    }

    /// SPDR Register bits
    namespace spdr_bits {
        constexpr uint32_t SPDR = (32 << 0);  ///< SPDR is the interface with the buffers that hold data for transmission and reception by the RSPI.When accessing in word (SPDCR.SPLW=1), access SPDR.
    }

    /// SPDR_HA Register bits
    namespace spdr_ha_bits {
        constexpr uint32_t SPDR_HA = (16 << 0);  ///< SPDR is the interface with the buffers that hold data for transmission and reception by the RSPI.When accessing in halfword (SPDCR.SPLW=0), access SPDR_HA.
    }

    /// SPSCR Register bits
    namespace spscr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SPSLN = (3 << 0);  ///< RSPI Sequence Length SpecificationThe order in which the SPCMD0 to SPCMD07 registers are to be referenced is changed in accordance with the sequence length that is set in these bits. The relationship among the setting of these bits, sequence length, and SPCMD0 to SPCMD7 registers referenced by the RSPI is shown above. However, the RSPI in slave mode always references SPCMD0.
    }

    /// SPSSR Register bits
    namespace spssr_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0.
        constexpr uint32_t SPECM = (3 << 4);  ///< SPI Error Command
        constexpr uint32_t SPCP = (3 << 0);  ///< SPI Command Pointer
    }

    /// SPBR Register bits
    namespace spbr_bits {
        constexpr uint32_t SPR = (8 << 0);  ///< SPBR sets the bit rate in master mode.
    }

    /// SPDCR Register bits
    namespace spdcr_bits {
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t SPLW = (1U << 5);  ///< SPI Word Access/Halfword Access Specification
        constexpr uint32_t SPRDTD = (1U << 4);  ///< RSPI Receive/Transmit Data Selection
        constexpr uint32_t SPFC = (2 << 0);  ///< Number of Frames Specification
    }

    /// SPCKD Register bits
    namespace spckd_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SCKDL = (3 << 0);  ///< RSPCK Delay Setting
    }

    /// SSLND Register bits
    namespace sslnd_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SLNDL = (3 << 0);  ///< SSL Negation Delay Setting
    }

    /// SPND Register bits
    namespace spnd_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SPNDL = (3 << 0);  ///< SPI Next-Access Delay Setting
    }

    /// SPCR2 Register bits
    namespace spcr2_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t SCKASE = (1U << 4);  ///< RSPCK Auto-Stop Function Enable
        constexpr uint32_t PTE = (1U << 3);  ///< Parity Self-Testing
        constexpr uint32_t SPIIE = (1U << 2);  ///< SPI Idle Interrupt Enable
        constexpr uint32_t SPOE = (1U << 1);  ///< Parity Mode
        constexpr uint32_t SPPE = (1U << 0);  ///< Parity Enable
    }

    /// SPCMD%s Register bits
    namespace spcmd%s_bits {
        constexpr uint32_t SCKDEN = (1U << 15);  ///< RSPCK Delay Setting Enable
        constexpr uint32_t SLNDEN = (1U << 14);  ///< SSL Negation Delay Setting Enable
        constexpr uint32_t SPNDEN = (1U << 13);  ///< RSPI Next-Access Delay Enable
        constexpr uint32_t LSBF = (1U << 12);  ///< RSPI LSB First
        constexpr uint32_t SPB = (4 << 8);  ///< RSPI Data Length Setting
        constexpr uint32_t SSLKP = (1U << 7);  ///< SSL Signal Level Keeping
        constexpr uint32_t SSLA = (3 << 4);  ///< SSL Signal Assertion Setting
        constexpr uint32_t BRDV = (2 << 2);  ///< Bit Rate Division Setting
        constexpr uint32_t CPOL = (1U << 1);  ///< RSPCK Polarity Setting
        constexpr uint32_t CPHA = (1U << 0);  ///< RSPCK Phase Setting
    }

}

// ============================================================================
// SCI0 Peripheral
// ============================================================================

namespace sci0 {
    /// Base addresses
    constexpr uint32_t SCI0_BASE = 0x40070000;

    /// SCI0 Register structure
    struct Registers {
        volatile uint32_t SMR;  ///< Offset: 0x00 - Serial Mode Register (SCMR.SMIF = 0)
        volatile uint32_t SMR_SMCI;  ///< Offset: 0x00 - Serial mode register (SCMR.SMIF = 1)
        volatile uint32_t BRR;  ///< Offset: 0x01 - Bit Rate Register
        volatile uint32_t SCR;  ///< Offset: 0x02 - Serial Control Register (SCMR.SMIF = 0)
        volatile uint32_t SCR_SMCI;  ///< Offset: 0x02 - Serial Control Register (SCMR.SMIF =1)
        volatile uint32_t TDR;  ///< Offset: 0x03 - Transmit Data Register
        volatile uint32_t SSR;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
        volatile uint32_t SSR_FIFO;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 0 and FCR.FM=1)
        volatile uint32_t SSR_SMCI;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 1)
        volatile uint32_t RDR;  ///< Offset: 0x05 - Receive Data Register
        volatile uint32_t SCMR;  ///< Offset: 0x06 - Smart Card Mode Register
        volatile uint32_t SEMR;  ///< Offset: 0x07 - Serial Extended Mode Register
        volatile uint32_t SNFR;  ///< Offset: 0x08 - Noise Filter Setting Register
        volatile uint32_t SIMR1;  ///< Offset: 0x09 - I2C Mode Register 1
        volatile uint32_t SIMR2;  ///< Offset: 0x0A - I2C Mode Register 2
        volatile uint32_t SIMR3;  ///< Offset: 0x0B - I2C Mode Register 3
        volatile uint32_t SISR;  ///< Offset: 0x0C - I2C Status Register
        volatile uint32_t SPMR;  ///< Offset: 0x0D - SPI Mode Register
        volatile uint32_t TDRHL;  ///< Offset: 0x0E - Transmit 9-bit Data Register
        volatile uint32_t FTDRHL;  ///< Offset: 0x0E - Transmit FIFO Data Register HL
        volatile uint32_t FTDRH;  ///< Offset: 0x0E - Transmit FIFO Data Register H
        volatile uint32_t FTDRL;  ///< Offset: 0x0F - Transmit FIFO Data Register L
        volatile uint32_t RDRHL;  ///< Offset: 0x10 - Receive 9-bit Data Register
        volatile uint32_t FRDRHL;  ///< Offset: 0x10 - Receive FIFO Data Register HL
        volatile uint32_t FRDRH;  ///< Offset: 0x10 - Receive FIFO Data Register H
        volatile uint32_t FRDRL;  ///< Offset: 0x11 - Receive FIFO Data Register L
        volatile uint32_t MDDR;  ///< Offset: 0x12 - Modulation Duty Register
        volatile uint32_t DCCR;  ///< Offset: 0x13 - Data Compare Match Control Register
        volatile uint32_t FCR;  ///< Offset: 0x14 - FIFO Control Register
        volatile uint32_t FDR;  ///< Offset: 0x16 - FIFO Data Count Register
        volatile uint32_t LSR;  ///< Offset: 0x18 - Line Status Register
        volatile uint32_t CDR;  ///< Offset: 0x1A - Compare Match Data Register
        volatile uint32_t SPTR;  ///< Offset: 0x1C - Serial Port Register
    };

    /// Peripheral instances
    inline Registers* SCI0 = reinterpret_cast<Registers*>(SCI0_BASE);

    // Bit definitions
    /// SMR Register bits
    namespace smr_bits {
        constexpr uint32_t CM = (1U << 7);  ///< Communication Mode
        constexpr uint32_t CHR = (1U << 6);  ///< Character Length(Valid only in asynchronous mode)
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable(Valid only in asynchronous mode)
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode (Valid only when the PE bit is 1)
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Bit Length(Valid only in asynchronous mode)
        constexpr uint32_t MP = (1U << 2);  ///< Multi-Processor Mode(Valid only in asynchronous mode)
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
    }

    /// SMR_SMCI Register bits
    namespace smr_smci_bits {
        constexpr uint32_t GM = (1U << 7);  ///< GSM Mode
        constexpr uint32_t BLK = (1U << 6);  ///< Block Transfer Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable(Valid only in asynchronous mode)
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode (Valid only when the PE bit is 1)
        constexpr uint32_t BCP = (2 << 2);  ///< Base Clock Pulse(Valid only in asynchronous mode)
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR = (8 << 0);  ///< BRR is an 8-bit register that adjusts the bit rate.
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable(Valid in asynchronous mode when SMR.MP = 1)
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
    }

    /// SCR_SMCI Register bits
    namespace scr_smci_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (8 << 0);  ///< TDR is an 8-bit register that stores transmit data.
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
    }

    /// SSR_FIFO Register bits
    namespace ssr_fifo_bits {
        constexpr uint32_t TDFE = (1U << 7);  ///< Transmit FIFO data empty flag
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO data full flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DR = (1U << 0);  ///< Receive Data Ready flag(Valid only in asynchronous mode(including multi-processor) and FIFO selected)
    }

    /// SSR_SMCI Register bits
    namespace ssr_smci_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t ERS = (1U << 4);  ///< Error Signal Status Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-ProcessorThis bit should be 0 in smart card interface mode.
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit TransferThis bit should be 0 in smart card interface mode.
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (8 << 0);  ///< RDR is an 8-bit register that stores receive data.
    }

    /// SCMR Register bits
    namespace scmr_bits {
        constexpr uint32_t BCP2 = (1U << 7);  ///< Base Clock Pulse 2Selects the number of base clock cycles in combination with the SMR.BCP[1:0] bits
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 1. The write value should be 1.
        constexpr uint32_t CHR1 = (1U << 4);  ///< Character Length 1(Only valid in asynchronous mode)
        constexpr uint32_t SDIR = (1U << 3);  ///< Transmitted/Received Data Transfer DirectionNOTE: The setting is invalid and a fixed data length of 8 bits is used in modes other than asynchronous mode.Set this bit to 1 if operation is to be in simple I2C mode.
        constexpr uint32_t SINV = (1U << 2);  ///< Transmitted/Received Data InvertSet this bit to 0 if operation is to be in simple I2C mode.
        constexpr uint32_t SMIF = (1U << 0);  ///< Smart Card Interface Mode Select
    }

    /// SEMR Register bits
    namespace semr_bits {
        constexpr uint32_t RXDESEL = (1U << 7);  ///< Asynchronous Start Bit Edge Detection Select(Valid only in asynchronous mode)
        constexpr uint32_t BGDM = (1U << 6);  ///< Baud Rate Generator Double-Speed Mode Select(Only valid the CKE[1] bit in SCR is 0 in asynchronous mode).
        constexpr uint32_t NFEN = (1U << 5);  ///< Digital Noise Filter Function Enable(The NFEN bit should be 0 without simple I2C mode and asynchronous mode.)In asynchronous mode, for RXDn input only. In simple I2C mode, for RXDn/TxDn input.
        constexpr uint32_t ABCS = (1U << 4);  ///< Asynchronous Mode Base Clock Select(Valid only in asynchronous mode)
        constexpr uint32_t ABCSE = (1U << 3);  ///< Asynchronous Mode Extended Base Clock Select 1(Valid only in asynchronous mode and SCR.CKE[1]=0)
        constexpr uint32_t BRME = (1U << 2);  ///< Bit Rate Modulation Enable
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 00. The write value should be 00.
    }

    /// SNFR Register bits
    namespace snfr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t NFCS = (3 << 0);  ///< Noise Filter Clock Select
    }

    /// SIMR1 Register bits
    namespace simr1_bits {
        constexpr uint32_t IICDL = (5 << 3);  ///< SDA Delay Output SelectCycles below are of the clock signal from the on-chip baud rate generator.
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t IICM = (1U << 0);  ///< Simple I2C Mode Select
    }

    /// SIMR2 Register bits
    namespace simr2_bits {
        constexpr uint32_t Reserved = (3 << 2);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t IICACKT = (1U << 5);  ///< ACK Transmission Data
        constexpr uint32_t IICCSC = (1U << 1);  ///< Clock Synchronization
        constexpr uint32_t IICINTM = (1U << 0);  ///< I2C Interrupt Mode Select
    }

    /// SIMR3 Register bits
    namespace simr3_bits {
        constexpr uint32_t IICSCLS = (2 << 6);  ///< SCL Output Select
        constexpr uint32_t IICSDAS = (2 << 4);  ///< SDA Output Select
        constexpr uint32_t IICSTIF = (1U << 3);  ///< Issuing of Start, Restart, or Stop Condition Completed Flag(When 0 is written to IICSTIF, it is cleared to 0.)
        constexpr uint32_t IICSTPREQ = (1U << 2);  ///< Stop Condition Generation
        constexpr uint32_t IICRSTAREQ = (1U << 1);  ///< Restart Condition Generation
        constexpr uint32_t IICSTAREQ = (1U << 0);  ///< Start Condition Generation
    }

    /// SISR Register bits
    namespace sisr_bits {
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0.
        constexpr uint32_t IICACKR = (1U << 0);  ///< ACK Reception Data Flag
    }

    /// SPMR Register bits
    namespace spmr_bits {
        constexpr uint32_t CKPH = (1U << 7);  ///< Clock Phase Select
        constexpr uint32_t CKPOL = (1U << 6);  ///< Clock Polarity Select
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t MFF = (1U << 4);  ///< Mode Fault Flag
        constexpr uint32_t MSS = (1U << 2);  ///< Master Slave Select
        constexpr uint32_t CTSE = (1U << 1);  ///< CTS Enable
        constexpr uint32_t SSE = (1U << 0);  ///< SSn Pin Function Enable
    }

    /// TDRHL Register bits
    namespace tdrhl_bits {
        constexpr uint32_t TDRHL = (16 << 0);  ///< TDRHL is a 16-bit register that stores transmit data.
    }

    /// FTDRHL Register bits
    namespace ftdrhl_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< The write value should be 111111.
        constexpr uint32_t MPBT = (1U << 9);  ///< Multi-processor transfer bit flag(Valid only in asynchronous mode and SMR.MP=1 and FIFO selected)
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial transmit data (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FTDRH Register bits
    namespace ftdrh_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< The write value should be 111111.
        constexpr uint32_t MPBT = (1U << 1);  ///< Multi-processor transfer bit flag(Valid only in asynchronous mode and SMR.MP=1 and FIFO selected)
        constexpr uint32_t TDATH = (1U << 0);  ///< Serial transmit data (b8) (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FTDRL Register bits
    namespace ftdrl_bits {
        constexpr uint32_t TDATL = (8 << 0);  ///< Serial transmit data(b7-b0) (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// RDRHL Register bits
    namespace rdrhl_bits {
        constexpr uint32_t RDRHL = (16 << 0);  ///< RDRHL is an 16-bit register that stores receive data.
    }

    /// FRDRHL Register bits
    namespace frdrhl_bits {
        constexpr uint32_t Reserved = (1U << 15);  ///< This bit is read as 0.
        constexpr uint32_t RDF = (1U << 14);  ///< Receive FIFO data full flag(It is same as SSR.RDF)
        constexpr uint32_t ORER = (1U << 13);  ///< Overrun error flag(It is same as SSR.ORER)
        constexpr uint32_t FER = (1U << 12);  ///< Framing error flag
        constexpr uint32_t PER = (1U << 11);  ///< Parity error flag
        constexpr uint32_t DR = (1U << 10);  ///< Receive data ready flag(It is same as SSR.DR)
        constexpr uint32_t MPB = (1U << 9);  ///< Multi-processor bit flag(Valid only in asynchronous mode with SMR.MP=1 and FIFO selected) It can read multi-processor bit corresponded to serial receive data(RDATA[8:0])
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial receive data(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FRDRH Register bits
    namespace frdrh_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0.
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO data full flag(It is same as SSR.RDF)
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun error flag(It is same as SSR.ORER)
        constexpr uint32_t FER = (1U << 4);  ///< Framing error flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity error flag
        constexpr uint32_t DR = (1U << 2);  ///< Receive data ready flag(It is same as SSR.DR)
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-processor bit flag(Valid only in asynchronous mode with SMR.MP=1 and FIFO selected) It can read multi-processor bit corresponded to serial receive data(RDATA[8:0])
        constexpr uint32_t RDATH = (1U << 0);  ///< Serial receive data(b8)(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FRDRL Register bits
    namespace frdrl_bits {
        constexpr uint32_t RDATL = (8 << 0);  ///< Serial receive data(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)NOTE: When reading both of FRDRH register and FRDRL register, please read by an order of the FRDRH register and the FRDRL register.
    }

    /// MDDR Register bits
    namespace mddr_bits {
        constexpr uint32_t MDDR = (8 << 0);  ///< MDDR corrects the bit rate adjusted by the BRR register.
    }

    /// DCCR Register bits
    namespace dccr_bits {
        constexpr uint32_t DCME = (1U << 7);  ///< Data Compare Match Enable(Valid only in asynchronous mode(including multi-processor)
        constexpr uint32_t IDSEL = (1U << 6);  ///< ID frame select(Valid only in asynchronous mode(including multi-processor)
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t DFER = (1U << 4);  ///< Data Compare Match Framing Error Flag
        constexpr uint32_t DPER = (1U << 3);  ///< Data Compare Match Parity Error Flag
        constexpr uint32_t DCMF = (1U << 0);  ///< Data Compare Match Flag
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t RSTRG = (4 << 12);  ///< RTS Output Active Trigger Number Select(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode)
        constexpr uint32_t RTRG = (4 << 8);  ///< Receive FIFO data trigger number(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode)
        constexpr uint32_t TTRG = (4 << 4);  ///< Transmit FIFO data trigger number(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode)
        constexpr uint32_t DRES = (1U << 3);  ///< Receive data ready error select bit(When detecting a reception data ready, the interrupt request is selected.)
        constexpr uint32_t TFRST = (1U << 2);  ///< Transmit FIFO Data Register Reset(Valid only in FCR.FM=1)
        constexpr uint32_t RFRST = (1U << 1);  ///< Receive FIFO Data Register Reset(Valid only in FCR.FM=1)
        constexpr uint32_t FM = (1U << 0);  ///< FIFO Mode Select(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode)
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000.
        constexpr uint32_t T = (5 << 8);  ///< Transmit FIFO Data CountIndicate the quantity of non-transmit data stored in FTDRH and FTDRL(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, while FCR.FM=1)
        constexpr uint32_t R = (5 << 0);  ///< Receive FIFO Data CountIndicate the quantity of receive data stored in FRDRH and FRDRL(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, while FCR.FM=1)
    }

    /// LSR Register bits
    namespace lsr_bits {
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0.
        constexpr uint32_t PNUM = (5 << 8);  ///< Parity Error CountIndicates the quantity of data with a parity error among the receive data stored in the receive FIFO data register (FRDRH and FRDRL).
        constexpr uint32_t FNUM = (5 << 2);  ///< Framing Error CountIndicates the quantity of data with a framing error among the receive data stored in the receive FIFO data register (FRDRH and FRDRL).
        constexpr uint32_t ORER = (1U << 0);  ///< Overrun Error Flag (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// CDR Register bits
    namespace cdr_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPD = (9 << 0);  ///< Compare Match DataCompare data pattern for address match wake-up function
    }

    /// SPTR Register bits
    namespace sptr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SPB2IO = (1U << 2);  ///< Serial port break I/O bit(It's selected whether the value of SPB2DT is output to TxD terminal.)
        constexpr uint32_t SPB2DT = (1U << 1);  ///< Serial port break data select bit(The output level of TxD terminal is selected when SCR.TE = 0.)
        constexpr uint32_t RXDMON = (1U << 0);  ///< Serial input data monitor bit(The state of the RXD terminal is shown.)
    }

}

// ============================================================================
// SCI1 Peripheral
// ============================================================================

namespace sci1 {
    /// Base addresses
    constexpr uint32_t SCI1_BASE = 0x40070020;

    /// SCI1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI1 = reinterpret_cast<Registers*>(SCI1_BASE);

}

// ============================================================================
// SCI2 Peripheral
// ============================================================================

namespace sci2 {
    /// Base addresses
    constexpr uint32_t SCI2_BASE = 0x40070040;

    /// SCI2 Register structure
    struct Registers {
        volatile uint32_t SMR;  ///< Offset: 0x00 - Serial Mode Register (SCMR.SMIF = 0)
        volatile uint32_t SMR_SMCI;  ///< Offset: 0x00 - Serial mode register (SCMR.SMIF = 1)
        volatile uint32_t BRR;  ///< Offset: 0x01 - Bit Rate Register
        volatile uint32_t SCR;  ///< Offset: 0x02 - Serial Control Register (SCMR.SMIF = 0)
        volatile uint32_t SCR_SMCI;  ///< Offset: 0x02 - Serial Control Register (SCMR.SMIF =1)
        volatile uint32_t TDR;  ///< Offset: 0x03 - Transmit Data Register
        volatile uint32_t SSR;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
        volatile uint32_t SSR_SMCI;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 1)
        volatile uint32_t RDR;  ///< Offset: 0x05 - Receive Data Register
        volatile uint32_t SCMR;  ///< Offset: 0x06 - Smart Card Mode Register
        volatile uint32_t SEMR;  ///< Offset: 0x07 - Serial Extended Mode Register
        volatile uint32_t SNFR;  ///< Offset: 0x08 - Noise Filter Setting Register
        volatile uint32_t SIMR1;  ///< Offset: 0x09 - I2C Mode Register 1
        volatile uint32_t SIMR2;  ///< Offset: 0x0A - I2C Mode Register 2
        volatile uint32_t SIMR3;  ///< Offset: 0x0B - I2C Mode Register 3
        volatile uint32_t SISR;  ///< Offset: 0x0C - I2C Status Register
        volatile uint32_t SPMR;  ///< Offset: 0x0D - SPI Mode Register
        volatile uint32_t TDRHL;  ///< Offset: 0x0E - Transmit 9-bit Data Register
        volatile uint32_t RDRHL;  ///< Offset: 0x10 - Receive 9-bit Data Register
        volatile uint32_t MDDR;  ///< Offset: 0x12 - Modulation Duty Register
        volatile uint32_t DCCR;  ///< Offset: 0x13 - Data Compare Match Control Register
        volatile uint32_t CDR;  ///< Offset: 0x1A - Compare Match Data Register
        volatile uint32_t SPTR;  ///< Offset: 0x1C - Serial Port Register
    };

    /// Peripheral instances
    inline Registers* SCI2 = reinterpret_cast<Registers*>(SCI2_BASE);

    // Bit definitions
    /// SMR Register bits
    namespace smr_bits {
        constexpr uint32_t CM = (1U << 7);  ///< Communication Mode
        constexpr uint32_t CHR = (1U << 6);  ///< Character Length(Valid only in asynchronous mode)
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable(Valid only in asynchronous mode)
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode (Valid only when the PE bit is 1)
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Bit Length(Valid only in asynchronous mode)
        constexpr uint32_t MP = (1U << 2);  ///< Multi-Processor Mode(Valid only in asynchronous mode)
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
    }

    /// SMR_SMCI Register bits
    namespace smr_smci_bits {
        constexpr uint32_t GM = (1U << 7);  ///< GSM Mode
        constexpr uint32_t BLK = (1U << 6);  ///< Block Transfer Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable(Valid only in asynchronous mode)
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode (Valid only when the PE bit is 1)
        constexpr uint32_t BCP = (2 << 2);  ///< Base Clock Pulse(Valid only in asynchronous mode)
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR = (8 << 0);  ///< BRR is an 8-bit register that adjusts the bit rate.
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable(Valid in asynchronous mode when SMR.MP = 1)
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
    }

    /// SCR_SMCI Register bits
    namespace scr_smci_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (8 << 0);  ///< TDR is an 8-bit register that stores transmit data.
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer
    }

    /// SSR_SMCI Register bits
    namespace ssr_smci_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t ERS = (1U << 4);  ///< Error Signal Status Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-ProcessorThis bit should be 0 in smart card interface mode.
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit TransferThis bit should be 0 in smart card interface mode.
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (8 << 0);  ///< RDR is an 8-bit register that stores receive data.
    }

    /// SCMR Register bits
    namespace scmr_bits {
        constexpr uint32_t BCP2 = (1U << 7);  ///< Base Clock Pulse 2Selects the number of base clock cycles in combination with the SMR.BCP[1:0] bits
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 1. The write value should be 1.
        constexpr uint32_t CHR1 = (1U << 4);  ///< Character Length 1(Only valid in asynchronous mode)
        constexpr uint32_t SDIR = (1U << 3);  ///< Transmitted/Received Data Transfer DirectionNOTE: The setting is invalid and a fixed data length of 8 bits is used in modes other than asynchronous mode.Set this bit to 1 if operation is to be in simple I2C mode.
        constexpr uint32_t SINV = (1U << 2);  ///< Transmitted/Received Data InvertSet this bit to 0 if operation is to be in simple I2C mode.
        constexpr uint32_t SMIF = (1U << 0);  ///< Smart Card Interface Mode Select
    }

    /// SEMR Register bits
    namespace semr_bits {
        constexpr uint32_t RXDESEL = (1U << 7);  ///< Asynchronous Start Bit Edge Detection Select(Valid only in asynchronous mode)
        constexpr uint32_t BGDM = (1U << 6);  ///< Baud Rate Generator Double-Speed Mode Select(Only valid the CKE[1] bit in SCR is 0 in asynchronous mode).
        constexpr uint32_t NFEN = (1U << 5);  ///< Digital Noise Filter Function Enable(The NFEN bit should be 0 without simple I2C mode and asynchronous mode.)In asynchronous mode, for RXDn input only. In simple I2C mode, for RXDn/TxDn input.
        constexpr uint32_t ABCS = (1U << 4);  ///< Asynchronous Mode Base Clock Select(Valid only in asynchronous mode)
        constexpr uint32_t ABCSE = (1U << 3);  ///< Asynchronous Mode Extended Base Clock Select 1(Valid only in asynchronous mode and SCR.CKE[1]=0)
        constexpr uint32_t BRME = (1U << 2);  ///< Bit Rate Modulation Enable
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 00. The write value should be 00.
    }

    /// SNFR Register bits
    namespace snfr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t NFCS = (3 << 0);  ///< Noise Filter Clock Select
    }

    /// SIMR1 Register bits
    namespace simr1_bits {
        constexpr uint32_t IICDL = (5 << 3);  ///< SDA Delay Output SelectCycles below are of the clock signal from the on-chip baud rate generator.
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t IICM = (1U << 0);  ///< Simple I2C Mode Select
    }

    /// SIMR2 Register bits
    namespace simr2_bits {
        constexpr uint32_t Reserved = (3 << 2);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t IICACKT = (1U << 5);  ///< ACK Transmission Data
        constexpr uint32_t IICCSC = (1U << 1);  ///< Clock Synchronization
        constexpr uint32_t IICINTM = (1U << 0);  ///< I2C Interrupt Mode Select
    }

    /// SIMR3 Register bits
    namespace simr3_bits {
        constexpr uint32_t IICSCLS = (2 << 6);  ///< SCL Output Select
        constexpr uint32_t IICSDAS = (2 << 4);  ///< SDA Output Select
        constexpr uint32_t IICSTIF = (1U << 3);  ///< Issuing of Start, Restart, or Stop Condition Completed Flag(When 0 is written to IICSTIF, it is cleared to 0.)
        constexpr uint32_t IICSTPREQ = (1U << 2);  ///< Stop Condition Generation
        constexpr uint32_t IICRSTAREQ = (1U << 1);  ///< Restart Condition Generation
        constexpr uint32_t IICSTAREQ = (1U << 0);  ///< Start Condition Generation
    }

    /// SISR Register bits
    namespace sisr_bits {
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0.
        constexpr uint32_t IICACKR = (1U << 0);  ///< ACK Reception Data Flag
    }

    /// SPMR Register bits
    namespace spmr_bits {
        constexpr uint32_t CKPH = (1U << 7);  ///< Clock Phase Select
        constexpr uint32_t CKPOL = (1U << 6);  ///< Clock Polarity Select
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t MFF = (1U << 4);  ///< Mode Fault Flag
        constexpr uint32_t MSS = (1U << 2);  ///< Master Slave Select
        constexpr uint32_t CTSE = (1U << 1);  ///< CTS Enable
        constexpr uint32_t SSE = (1U << 0);  ///< SSn Pin Function Enable
    }

    /// TDRHL Register bits
    namespace tdrhl_bits {
        constexpr uint32_t TDRHL = (16 << 0);  ///< TDRHL is a 16-bit register that stores transmit data.
    }

    /// RDRHL Register bits
    namespace rdrhl_bits {
        constexpr uint32_t RDRHL = (16 << 0);  ///< RDRHL is an 16-bit register that stores receive data.
    }

    /// MDDR Register bits
    namespace mddr_bits {
        constexpr uint32_t MDDR = (8 << 0);  ///< MDDR corrects the bit rate adjusted by the BRR register.
    }

    /// DCCR Register bits
    namespace dccr_bits {
        constexpr uint32_t DCME = (1U << 7);  ///< Data Compare Match Enable(Valid only in asynchronous mode(including multi-processor)
        constexpr uint32_t IDSEL = (1U << 6);  ///< ID frame select(Valid only in asynchronous mode(including multi-processor)
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t DFER = (1U << 4);  ///< Data Compare Match Framing Error Flag
        constexpr uint32_t DPER = (1U << 3);  ///< Data Compare Match Parity Error Flag
        constexpr uint32_t DCMF = (1U << 0);  ///< Data Compare Match Flag
    }

    /// CDR Register bits
    namespace cdr_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPD = (9 << 0);  ///< Compare Match DataCompare data pattern for address match wake-up function
    }

    /// SPTR Register bits
    namespace sptr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SPB2IO = (1U << 2);  ///< Serial port break I/O bit(It's selected whether the value of SPB2DT is output to TxD terminal.)
        constexpr uint32_t SPB2DT = (1U << 1);  ///< Serial port break data select bit(The output level of TxD terminal is selected when SCR.TE = 0.)
        constexpr uint32_t RXDMON = (1U << 0);  ///< Serial input data monitor bit(The state of the RXD terminal is shown.)
    }

}

// ============================================================================
// SCI3 Peripheral
// ============================================================================

namespace sci3 {
    /// Base addresses
    constexpr uint32_t SCI3_BASE = 0x40070060;

    /// SCI3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI3 = reinterpret_cast<Registers*>(SCI3_BASE);

}

// ============================================================================
// SCI4 Peripheral
// ============================================================================

namespace sci4 {
    /// Base addresses
    constexpr uint32_t SCI4_BASE = 0x40070080;

    /// SCI4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI4 = reinterpret_cast<Registers*>(SCI4_BASE);

}

// ============================================================================
// SCI9 Peripheral
// ============================================================================

namespace sci9 {
    /// Base addresses
    constexpr uint32_t SCI9_BASE = 0x40070120;

    /// SCI9 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI9 = reinterpret_cast<Registers*>(SCI9_BASE);

}

// ============================================================================
// IIC0 Peripheral
// ============================================================================

namespace iic0 {
    /// Base addresses
    constexpr uint32_t IIC0_BASE = 0x40053000;

    /// IIC0 Register structure
    struct Registers {
        volatile uint32_t ICCR1;  ///< Offset: 0x00 - I2C Bus Control Register 1
        volatile uint32_t ICCR2;  ///< Offset: 0x01 - I2C Bus Control Register 2
        volatile uint32_t ICMR1;  ///< Offset: 0x02 - I2C Bus Mode Register 1
        volatile uint32_t ICMR2;  ///< Offset: 0x03 - I2C Bus Mode Register 2
        volatile uint32_t ICMR3;  ///< Offset: 0x04 - I2C Bus Mode Register 3
        volatile uint32_t ICFER;  ///< Offset: 0x05 - I2C Bus Function Enable Register
        volatile uint32_t ICSER;  ///< Offset: 0x06 - I2C Bus Status Enable Register
        volatile uint32_t ICIER;  ///< Offset: 0x07 - I2C Bus Interrupt Enable Register
        volatile uint32_t ICSR1;  ///< Offset: 0x08 - I2C Bus Status Register 1
        volatile uint32_t ICSR2;  ///< Offset: 0x09 - I2C Bus Status Register 2
        volatile uint32_t SARL%s;  ///< Offset: 0x0A - Slave Address Register L%s
        volatile uint32_t SARU%s;  ///< Offset: 0x0B - Slave Address Register U%s
        volatile uint32_t ICBRL;  ///< Offset: 0x10 - I2C Bus Bit Rate Low-Level Register
        volatile uint32_t ICBRH;  ///< Offset: 0x11 - I2C Bus Bit Rate High-Level Register
        volatile uint32_t ICDRT;  ///< Offset: 0x12 - I2C Bus Transmit Data Register
        volatile uint32_t ICDRR;  ///< Offset: 0x13 - I2C Bus Receive Data Register
        volatile uint32_t ICWUR;  ///< Offset: 0x16 - I2C Bus Wake Up Unit Register
        volatile uint32_t ICWUR2;  ///< Offset: 0x17 - I2C Bus Wake up Unit Register 2
    };

    /// Peripheral instances
    inline Registers* IIC0 = reinterpret_cast<Registers*>(IIC0_BASE);

    // Bit definitions
    /// ICCR1 Register bits
    namespace iccr1_bits {
        constexpr uint32_t ICE = (1U << 7);  ///< I2C Bus Interface Enable
        constexpr uint32_t IICRST = (1U << 6);  ///< I2C Bus Interface Internal ResetNote:If an internal reset is initiated using the IICRST bit for a bus hang-up occurred during communication with the master device in slave mode, the states may become different between the slave device and the master device (due to the difference in the bit counter information).
        constexpr uint32_t CLO = (1U << 5);  ///< Extra SCL Clock Cycle Output
        constexpr uint32_t SOWP = (1U << 4);  ///< SCLO/SDAO Write Protect
        constexpr uint32_t SCLO = (1U << 3);  ///< SCL Output Control/Monitor
        constexpr uint32_t SDAO = (1U << 2);  ///< SDA Output Control/Monitor
        constexpr uint32_t SCLI = (1U << 1);  ///< SCL Line Monitor
        constexpr uint32_t SDAI = (1U << 0);  ///< SDA Line Monitor
    }

    /// ICCR2 Register bits
    namespace iccr2_bits {
        constexpr uint32_t BBSY = (1U << 7);  ///< Bus Busy Detection Flag
        constexpr uint32_t MST = (1U << 6);  ///< Master/Slave Mode
        constexpr uint32_t TRS = (1U << 5);  ///< Transmit/Receive Mode
        constexpr uint32_t Reserved = (1U << 0);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SP = (1U << 3);  ///< Stop Condition Issuance RequestNote: Writing to the SP bit is not possible while the setting of the BBSY flag is 0 (bus free state).Note: Do not set the SP bit to 1 while a restart condition is being issued.
        constexpr uint32_t RS = (1U << 2);  ///< Restart Condition Issuance RequestNote: Do not set the RS bit to 1 while issuing a stop condition.
        constexpr uint32_t ST = (1U << 1);  ///< Start Condition Issuance RequestSet the ST bit to 1 (start condition issuance request) when the BBSY flag is set to 0 (bus free state).
    }

    /// ICMR1 Register bits
    namespace icmr1_bits {
        constexpr uint32_t MTWP = (1U << 7);  ///< MST/TRS Write Protect
        constexpr uint32_t CKS = (3 << 4);  ///< Internal Reference Clock (fIIC) Selection ( fIIC = PCLKB / 2^CKS )
        constexpr uint32_t BCWP = (1U << 3);  ///< BC Write Protect(This bit is read as 1.)
        constexpr uint32_t BC = (3 << 0);  ///< Bit Counter
    }

    /// ICMR2 Register bits
    namespace icmr2_bits {
        constexpr uint32_t DLCS = (1U << 7);  ///< SDA Output Delay Clock Source Select
        constexpr uint32_t SDDL = (3 << 4);  ///< SDA Output Delay Counter
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TMOH = (1U << 2);  ///< Timeout H Count Control
        constexpr uint32_t TMOL = (1U << 1);  ///< Timeout L Count Control
        constexpr uint32_t TMOS = (1U << 0);  ///< Timeout Detection Time Select
    }

    /// ICMR3 Register bits
    namespace icmr3_bits {
        constexpr uint32_t SMBS = (1U << 7);  ///< SMBus/I2C Bus Selection
        constexpr uint32_t WAIT = (1U << 6);  ///< WAITNote: When the value of the WAIT bit is to be read, be sure to read the ICDRR beforehand.
        constexpr uint32_t RDRFS = (1U << 5);  ///< RDRF Flag Set Timing Selection
        constexpr uint32_t ACKWP = (1U << 4);  ///< ACKBT Write Protect
        constexpr uint32_t ACKBT = (1U << 3);  ///< Transmit Acknowledge
        constexpr uint32_t ACKBR = (1U << 2);  ///< Receive Acknowledge
        constexpr uint32_t NF = (2 << 0);  ///< Noise Filter Stage Selection
    }

    /// ICFER Register bits
    namespace icfer_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SCLE = (1U << 6);  ///< SCL Synchronous Circuit Enable
        constexpr uint32_t NFE = (1U << 5);  ///< Digital Noise Filter Circuit Enable
        constexpr uint32_t NACKE = (1U << 4);  ///< NACK Reception Transfer Suspension Enable
        constexpr uint32_t SALE = (1U << 3);  ///< Slave Arbitration-Lost Detection Enable
        constexpr uint32_t NALE = (1U << 2);  ///< NACK Transmission Arbitration-Lost Detection Enable
        constexpr uint32_t MALE = (1U << 1);  ///< Master Arbitration-Lost Detection Enable
        constexpr uint32_t TMOE = (1U << 0);  ///< Timeout Function Enable
    }

    /// ICSER Register bits
    namespace icser_bits {
        constexpr uint32_t HOAE = (1U << 7);  ///< Host Address Enable
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DIDE = (1U << 5);  ///< Device-ID Address Detection Enable
        constexpr uint32_t GCAE = (1U << 3);  ///< General Call Address Enable
        constexpr uint32_t SAR2E = (1U << 2);  ///< Slave Address Register 2 Enable
        constexpr uint32_t SAR1E = (1U << 1);  ///< Slave Address Register 1 Enable
        constexpr uint32_t SAR0E = (1U << 0);  ///< Slave Address Register 0 Enable
    }

    /// ICIER Register bits
    namespace icier_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Data Empty Interrupt Request Enable
        constexpr uint32_t TEIE = (1U << 6);  ///< Transmit End Interrupt Request Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receive Data Full Interrupt Request Enable
        constexpr uint32_t NAKIE = (1U << 4);  ///< NACK Reception Interrupt Request Enable
        constexpr uint32_t SPIE = (1U << 3);  ///< Stop Condition Detection Interrupt Request Enable
        constexpr uint32_t STIE = (1U << 2);  ///< Start Condition Detection Interrupt Request Enable
        constexpr uint32_t ALIE = (1U << 1);  ///< Arbitration-Lost Interrupt Request Enable
        constexpr uint32_t TMOIE = (1U << 0);  ///< Timeout Interrupt Request Enable
    }

    /// ICSR1 Register bits
    namespace icsr1_bits {
        constexpr uint32_t HOA = (1U << 7);  ///< Host Address Detection Flag
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DID = (1U << 5);  ///< Device-ID Address Detection Flag
        constexpr uint32_t GCA = (1U << 3);  ///< General Call Address Detection Flag
        constexpr uint32_t AAS2 = (1U << 2);  ///< Slave Address 2 Detection Flag
        constexpr uint32_t AAS1 = (1U << 1);  ///< Slave Address 1 Detection Flag
        constexpr uint32_t AAS0 = (1U << 0);  ///< Slave Address 0 Detection Flag
    }

    /// ICSR2 Register bits
    namespace icsr2_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t TEND = (1U << 6);  ///< Transmit End Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Full Flag
        constexpr uint32_t NACKF = (1U << 4);  ///< NACK Detection Flag
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Condition Detection Flag
        constexpr uint32_t START = (1U << 2);  ///< Start Condition Detection Flag
        constexpr uint32_t AL = (1U << 1);  ///< Arbitration-Lost Flag
        constexpr uint32_t TMOF = (1U << 0);  ///< Timeout Detection Flag
    }

    /// SARL%s Register bits
    namespace sarl%s_bits {
        constexpr uint32_t SVA = (8 << 0);  ///< A slave address is set.7-Bit Address = SVA[7:1] 10-Bit Address = { SVA9,SVA8,SVA[7:0] }
    }

    /// SARU%s Register bits
    namespace saru%s_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SVA9 = (1U << 2);  ///< 10-Bit Address(bit9)
        constexpr uint32_t SVA8 = (1U << 1);  ///< 10-Bit Address(bit8)
        constexpr uint32_t FS = (1U << 0);  ///< 7-Bit/10-Bit Address Format Selection
    }

    /// ICBRL Register bits
    namespace icbrl_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 111. The write value should be 111.
        constexpr uint32_t BRL = (5 << 0);  ///< Bit Rate Low-Level Period(Low-level period of SCL clock)
    }

    /// ICBRH Register bits
    namespace icbrh_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 111. The write value should be 111.
        constexpr uint32_t BRH = (5 << 0);  ///< Bit Rate High-Level Period(High-level period of SCL clock)
    }

    /// ICDRT Register bits
    namespace icdrt_bits {
        constexpr uint32_t ICDRT = (8 << 0);  ///< 8-bit read-write register that stores transmit data.
    }

    /// ICDRR Register bits
    namespace icdrr_bits {
        constexpr uint32_t ICDRR = (8 << 0);  ///< 8-bit register that stores the received data
    }

    /// ICWUR Register bits
    namespace icwur_bits {
        constexpr uint32_t WUE = (1U << 7);  ///< Wakeup Function Enable
        constexpr uint32_t WUIE = (1U << 6);  ///< Wakeup Interrupt Request Enable
        constexpr uint32_t WUF = (1U << 5);  ///< Wakeup Event Occurrence Flag
        constexpr uint32_t WUACK = (1U << 4);  ///< ACK bit for Wakeup Mode
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t WUAFA = (1U << 0);  ///< Wakeup Analog Filter Additional Selection
    }

    /// ICWUR2 Register bits
    namespace icwur2_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 11111. The write value should be 11111.
        constexpr uint32_t WUSYF = (1U << 2);  ///< Wake-up Function Synchronous Operation Status Flag
        constexpr uint32_t WUASYF = (1U << 1);  ///< Wake-up Function Asynchronous Operation Status Flag
        constexpr uint32_t WUSEN = (1U << 0);  ///< Wake-up Function Synchronous Enable
    }

}

// ============================================================================
// IIC1 Peripheral
// ============================================================================

namespace iic1 {
    /// Base addresses
    constexpr uint32_t IIC1_BASE = 0x40053100;

    /// IIC1 Register structure
    struct Registers {
        volatile uint32_t ICCR1;  ///< Offset: 0x00 - I2C Bus Control Register 1
        volatile uint32_t ICCR2;  ///< Offset: 0x01 - I2C Bus Control Register 2
        volatile uint32_t ICMR1;  ///< Offset: 0x02 - I2C Bus Mode Register 1
        volatile uint32_t ICMR2;  ///< Offset: 0x03 - I2C Bus Mode Register 2
        volatile uint32_t ICMR3;  ///< Offset: 0x04 - I2C Bus Mode Register 3
        volatile uint32_t ICFER;  ///< Offset: 0x05 - I2C Bus Function Enable Register
        volatile uint32_t ICSER;  ///< Offset: 0x06 - I2C Bus Status Enable Register
        volatile uint32_t ICIER;  ///< Offset: 0x07 - I2C Bus Interrupt Enable Register
        volatile uint32_t ICSR1;  ///< Offset: 0x08 - I2C Bus Status Register 1
        volatile uint32_t ICSR2;  ///< Offset: 0x09 - I2C Bus Status Register 2
        volatile uint32_t SARL%s;  ///< Offset: 0x0A - Slave Address Register L%s
        volatile uint32_t SARU%s;  ///< Offset: 0x0B - Slave Address Register U%s
        volatile uint32_t ICBRL;  ///< Offset: 0x10 - I2C Bus Bit Rate Low-Level Register
        volatile uint32_t ICBRH;  ///< Offset: 0x11 - I2C Bus Bit Rate High-Level Register
        volatile uint32_t ICDRT;  ///< Offset: 0x12 - I2C Bus Transmit Data Register
        volatile uint32_t ICDRR;  ///< Offset: 0x13 - I2C Bus Receive Data Register
    };

    /// Peripheral instances
    inline Registers* IIC1 = reinterpret_cast<Registers*>(IIC1_BASE);

    // Bit definitions
    /// ICCR1 Register bits
    namespace iccr1_bits {
        constexpr uint32_t ICE = (1U << 7);  ///< I2C Bus Interface Enable
        constexpr uint32_t IICRST = (1U << 6);  ///< I2C Bus Interface Internal ResetNote:If an internal reset is initiated using the IICRST bit for a bus hang-up occurred during communication with the master device in slave mode, the states may become different between the slave device and the master device (due to the difference in the bit counter information).
        constexpr uint32_t CLO = (1U << 5);  ///< Extra SCL Clock Cycle Output
        constexpr uint32_t SOWP = (1U << 4);  ///< SCLO/SDAO Write Protect
        constexpr uint32_t SCLO = (1U << 3);  ///< SCL Output Control/Monitor
        constexpr uint32_t SDAO = (1U << 2);  ///< SDA Output Control/Monitor
        constexpr uint32_t SCLI = (1U << 1);  ///< SCL Line Monitor
        constexpr uint32_t SDAI = (1U << 0);  ///< SDA Line Monitor
    }

    /// ICCR2 Register bits
    namespace iccr2_bits {
        constexpr uint32_t BBSY = (1U << 7);  ///< Bus Busy Detection Flag
        constexpr uint32_t MST = (1U << 6);  ///< Master/Slave Mode
        constexpr uint32_t TRS = (1U << 5);  ///< Transmit/Receive Mode
        constexpr uint32_t Reserved = (1U << 0);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SP = (1U << 3);  ///< Stop Condition Issuance RequestNote: Writing to the SP bit is not possible while the setting of the BBSY flag is 0 (bus free state).Note: Do not set the SP bit to 1 while a restart condition is being issued.
        constexpr uint32_t RS = (1U << 2);  ///< Restart Condition Issuance RequestNote: Do not set the RS bit to 1 while issuing a stop condition.
        constexpr uint32_t ST = (1U << 1);  ///< Start Condition Issuance RequestSet the ST bit to 1 (start condition issuance request) when the BBSY flag is set to 0 (bus free state).
    }

    /// ICMR1 Register bits
    namespace icmr1_bits {
        constexpr uint32_t MTWP = (1U << 7);  ///< MST/TRS Write Protect
        constexpr uint32_t CKS = (3 << 4);  ///< Internal Reference Clock (fIIC) Selection ( fIIC = PCLKB / 2^CKS )
        constexpr uint32_t BCWP = (1U << 3);  ///< BC Write Protect(This bit is read as 1.)
        constexpr uint32_t BC = (3 << 0);  ///< Bit Counter
    }

    /// ICMR2 Register bits
    namespace icmr2_bits {
        constexpr uint32_t DLCS = (1U << 7);  ///< SDA Output Delay Clock Source Select
        constexpr uint32_t SDDL = (3 << 4);  ///< SDA Output Delay Counter
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TMOH = (1U << 2);  ///< Timeout H Count Control
        constexpr uint32_t TMOL = (1U << 1);  ///< Timeout L Count Control
        constexpr uint32_t TMOS = (1U << 0);  ///< Timeout Detection Time Select
    }

    /// ICMR3 Register bits
    namespace icmr3_bits {
        constexpr uint32_t SMBS = (1U << 7);  ///< SMBus/I2C Bus Selection
        constexpr uint32_t WAIT = (1U << 6);  ///< WAITNote: When the value of the WAIT bit is to be read, be sure to read the ICDRR beforehand.
        constexpr uint32_t RDRFS = (1U << 5);  ///< RDRF Flag Set Timing Selection
        constexpr uint32_t ACKWP = (1U << 4);  ///< ACKBT Write Protect
        constexpr uint32_t ACKBT = (1U << 3);  ///< Transmit Acknowledge
        constexpr uint32_t ACKBR = (1U << 2);  ///< Receive Acknowledge
        constexpr uint32_t NF = (2 << 0);  ///< Noise Filter Stage Selection
    }

    /// ICFER Register bits
    namespace icfer_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SCLE = (1U << 6);  ///< SCL Synchronous Circuit Enable
        constexpr uint32_t NFE = (1U << 5);  ///< Digital Noise Filter Circuit Enable
        constexpr uint32_t NACKE = (1U << 4);  ///< NACK Reception Transfer Suspension Enable
        constexpr uint32_t SALE = (1U << 3);  ///< Slave Arbitration-Lost Detection Enable
        constexpr uint32_t NALE = (1U << 2);  ///< NACK Transmission Arbitration-Lost Detection Enable
        constexpr uint32_t MALE = (1U << 1);  ///< Master Arbitration-Lost Detection Enable
        constexpr uint32_t TMOE = (1U << 0);  ///< Timeout Function Enable
    }

    /// ICSER Register bits
    namespace icser_bits {
        constexpr uint32_t HOAE = (1U << 7);  ///< Host Address Enable
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DIDE = (1U << 5);  ///< Device-ID Address Detection Enable
        constexpr uint32_t GCAE = (1U << 3);  ///< General Call Address Enable
        constexpr uint32_t SAR2E = (1U << 2);  ///< Slave Address Register 2 Enable
        constexpr uint32_t SAR1E = (1U << 1);  ///< Slave Address Register 1 Enable
        constexpr uint32_t SAR0E = (1U << 0);  ///< Slave Address Register 0 Enable
    }

    /// ICIER Register bits
    namespace icier_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Data Empty Interrupt Request Enable
        constexpr uint32_t TEIE = (1U << 6);  ///< Transmit End Interrupt Request Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receive Data Full Interrupt Request Enable
        constexpr uint32_t NAKIE = (1U << 4);  ///< NACK Reception Interrupt Request Enable
        constexpr uint32_t SPIE = (1U << 3);  ///< Stop Condition Detection Interrupt Request Enable
        constexpr uint32_t STIE = (1U << 2);  ///< Start Condition Detection Interrupt Request Enable
        constexpr uint32_t ALIE = (1U << 1);  ///< Arbitration-Lost Interrupt Request Enable
        constexpr uint32_t TMOIE = (1U << 0);  ///< Timeout Interrupt Request Enable
    }

    /// ICSR1 Register bits
    namespace icsr1_bits {
        constexpr uint32_t HOA = (1U << 7);  ///< Host Address Detection Flag
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DID = (1U << 5);  ///< Device-ID Address Detection Flag
        constexpr uint32_t GCA = (1U << 3);  ///< General Call Address Detection Flag
        constexpr uint32_t AAS2 = (1U << 2);  ///< Slave Address 2 Detection Flag
        constexpr uint32_t AAS1 = (1U << 1);  ///< Slave Address 1 Detection Flag
        constexpr uint32_t AAS0 = (1U << 0);  ///< Slave Address 0 Detection Flag
    }

    /// ICSR2 Register bits
    namespace icsr2_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t TEND = (1U << 6);  ///< Transmit End Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Full Flag
        constexpr uint32_t NACKF = (1U << 4);  ///< NACK Detection Flag
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Condition Detection Flag
        constexpr uint32_t START = (1U << 2);  ///< Start Condition Detection Flag
        constexpr uint32_t AL = (1U << 1);  ///< Arbitration-Lost Flag
        constexpr uint32_t TMOF = (1U << 0);  ///< Timeout Detection Flag
    }

    /// SARL%s Register bits
    namespace sarl%s_bits {
        constexpr uint32_t SVA = (8 << 0);  ///< A slave address is set.7-Bit Address = SVA[7:1] 10-Bit Address = { SVA9,SVA8,SVA[7:0] }
    }

    /// SARU%s Register bits
    namespace saru%s_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SVA9 = (1U << 2);  ///< 10-Bit Address(bit9)
        constexpr uint32_t SVA8 = (1U << 1);  ///< 10-Bit Address(bit8)
        constexpr uint32_t FS = (1U << 0);  ///< 7-Bit/10-Bit Address Format Selection
    }

    /// ICBRL Register bits
    namespace icbrl_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 111. The write value should be 111.
        constexpr uint32_t BRL = (5 << 0);  ///< Bit Rate Low-Level Period(Low-level period of SCL clock)
    }

    /// ICBRH Register bits
    namespace icbrh_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 111. The write value should be 111.
        constexpr uint32_t BRH = (5 << 0);  ///< Bit Rate High-Level Period(High-level period of SCL clock)
    }

    /// ICDRT Register bits
    namespace icdrt_bits {
        constexpr uint32_t ICDRT = (8 << 0);  ///< 8-bit read-write register that stores transmit data.
    }

    /// ICDRR Register bits
    namespace icdrr_bits {
        constexpr uint32_t ICDRR = (8 << 0);  ///< 8-bit register that stores the received data
    }

}

// ============================================================================
// IIC2 Peripheral
// ============================================================================

namespace iic2 {
    /// Base addresses
    constexpr uint32_t IIC2_BASE = 0x40053200;

    /// IIC2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* IIC2 = reinterpret_cast<Registers*>(IIC2_BASE);

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN0_BASE = 0x40050000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MB%s_ID;  ///< Offset: 0x200 - Mailbox Register
        volatile uint32_t MB%s_DL;  ///< Offset: 0x204 - Mailbox Register
        volatile uint32_t MB%s_D0;  ///< Offset: 0x206 - Mailbox Register
        volatile uint32_t MB%s_D1;  ///< Offset: 0x207 - Mailbox Register
        volatile uint32_t MB%s_D2;  ///< Offset: 0x208 - Mailbox Register
        volatile uint32_t MB%s_D3;  ///< Offset: 0x209 - Mailbox Register
        volatile uint32_t MB%s_D4;  ///< Offset: 0x20A - Mailbox Register
        volatile uint32_t MB%s_D5;  ///< Offset: 0x20B - Mailbox Register
        volatile uint32_t MB%s_D6;  ///< Offset: 0x20C - Mailbox Register
        volatile uint32_t MB%s_D7;  ///< Offset: 0x20D - Mailbox Register
        volatile uint32_t MB%s_TS;  ///< Offset: 0x20E - Mailbox Register
        volatile uint32_t MKR[%s];  ///< Offset: 0x400 - Mask Register
        volatile uint32_t FIDCR%s;  ///< Offset: 0x420 - FIFO Received ID Compare Registers
        volatile uint32_t MKIVLR;  ///< Offset: 0x428 - Mask Invalid Register
        volatile uint32_t MIER;  ///< Offset: 0x42C - Mailbox Interrupt Enable Register
        volatile uint32_t MIER_FIFO;  ///< Offset: 0x42C - Mailbox Interrupt Enable Register for FIFO Mailbox Mode
        volatile uint32_t MCTL_TX[%s];  ///< Offset: 0x820 - Message Control Register for Transmit
        volatile uint32_t MCTL_RX[%s];  ///< Offset: 0x820 - Message Control Register for Receive
        volatile uint32_t CTLR;  ///< Offset: 0x840 - Control Register
        volatile uint32_t STR;  ///< Offset: 0x842 - Status Register
        volatile uint32_t BCR;  ///< Offset: 0x844 - Bit Configuration Register
        volatile uint32_t RFCR;  ///< Offset: 0x848 - Receive FIFO Control Register
        volatile uint32_t RFPCR;  ///< Offset: 0x849 - Receive FIFO Pointer Control Register
        volatile uint32_t TFCR;  ///< Offset: 0x84A - Transmit FIFO Control Register
        volatile uint32_t TFPCR;  ///< Offset: 0x84B - Transmit FIFO Pointer Control Register
        volatile uint32_t EIER;  ///< Offset: 0x84C - Error Interrupt Enable Register
        volatile uint32_t EIFR;  ///< Offset: 0x84D - Error Interrupt Factor Judge Register
        volatile uint32_t RECR;  ///< Offset: 0x84E - Receive Error Count Register
        volatile uint32_t TECR;  ///< Offset: 0x84F - Transmit Error Count Register
        volatile uint32_t ECSR;  ///< Offset: 0x850 - Error Code Store Register
        volatile uint32_t CSSR;  ///< Offset: 0x851 - Channel Search Support Register
        volatile uint32_t MSSR;  ///< Offset: 0x852 - Mailbox Search Status Register
        volatile uint32_t MSMR;  ///< Offset: 0x853 - Mailbox Search Mode Register
        volatile uint32_t TSR;  ///< Offset: 0x854 - Time Stamp Register
        volatile uint32_t AFSR;  ///< Offset: 0x856 - Acceptance Filter Support Register
        volatile uint32_t TCR;  ///< Offset: 0x858 - Test Control Register
    };

    /// Peripheral instances
    inline Registers* CAN0 = reinterpret_cast<Registers*>(CAN0_BASE);

    // Bit definitions
    /// MB%s_ID Register bits
    namespace mb%s_id_bits {
        constexpr uint32_t IDE = (1U << 31);  ///< ID Extension
        constexpr uint32_t RTR = (1U << 30);  ///< Remote Transmission Request
        constexpr uint32_t Reserved = (1U << 29);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID
    }

    /// MB%s_DL Register bits
    namespace mb%s_dl_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t DLC = (4 << 0);  ///< Data Length Code
    }

    /// MB%s_D0 Register bits
    namespace mb%s_d0_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< Data Bytes 0.DATA0 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D1 Register bits
    namespace mb%s_d1_bits {
        constexpr uint32_t DATA1 = (8 << 0);  ///< Data Bytes 1DATA1 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D2 Register bits
    namespace mb%s_d2_bits {
        constexpr uint32_t DATA2 = (8 << 0);  ///< Data Bytes 2DATA2 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D3 Register bits
    namespace mb%s_d3_bits {
        constexpr uint32_t DATA3 = (8 << 0);  ///< Data Bytes 3DATA3 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D4 Register bits
    namespace mb%s_d4_bits {
        constexpr uint32_t DATA4 = (8 << 0);  ///< Data Bytes 4DATA4 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D5 Register bits
    namespace mb%s_d5_bits {
        constexpr uint32_t DATA5 = (8 << 0);  ///< Data Bytes 5DATA5 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D6 Register bits
    namespace mb%s_d6_bits {
        constexpr uint32_t DATA6 = (8 << 0);  ///< Data Bytes 6DATA6 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D7 Register bits
    namespace mb%s_d7_bits {
        constexpr uint32_t DATA7 = (8 << 0);  ///< Data Bytes 7DATA7 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_TS Register bits
    namespace mb%s_ts_bits {
        constexpr uint32_t TSH = (8 << 8);  ///< Time Stamp Lower ByteBits TSH[7:0] store the counter value of the time stamp when received messages are stored in the mailbox.
        constexpr uint32_t TSL = (8 << 0);  ///< Time Stamp Higher ByteBits TSL[7:0] store the counter value of the time stamp when received messages are stored in the mailbox.
    }

    /// MKR[%s] Register bits
    namespace mkr[%s]_bits {
        constexpr uint32_t Reserved = (3 << 29);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID
    }

    /// FIDCR%s Register bits
    namespace fidcr%s_bits {
        constexpr uint32_t IDE = (1U << 31);  ///< ID Extension
        constexpr uint32_t RTR = (1U << 30);  ///< Remote Transmission Request
        constexpr uint32_t Reserved = (1U << 29);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID
    }

    /// MKIVLR Register bits
    namespace mkivlr_bits {
        constexpr uint32_t MB31 = (1U << 31);  ///< mailbox 31 Mask Invalid
        constexpr uint32_t MB30 = (1U << 30);  ///< mailbox 30 Mask Invalid
        constexpr uint32_t MB29 = (1U << 29);  ///< mailbox 29 Mask Invalid
        constexpr uint32_t MB28 = (1U << 28);  ///< mailbox 28 Mask Invalid
        constexpr uint32_t MB27 = (1U << 27);  ///< mailbox 27 Mask Invalid
        constexpr uint32_t MB26 = (1U << 26);  ///< mailbox 26 Mask Invalid
        constexpr uint32_t MB25 = (1U << 25);  ///< mailbox 25 Mask Invalid
        constexpr uint32_t MB24 = (1U << 24);  ///< mailbox 24 Mask Invalid
        constexpr uint32_t MB23 = (1U << 23);  ///< mailbox 23 Mask Invalid
        constexpr uint32_t MB22 = (1U << 22);  ///< mailbox 22 Mask Invalid
        constexpr uint32_t MB21 = (1U << 21);  ///< mailbox 21 Mask Invalid
        constexpr uint32_t MB20 = (1U << 20);  ///< mailbox 20 Mask Invalid
        constexpr uint32_t MB19 = (1U << 19);  ///< mailbox 19 Mask Invalid
        constexpr uint32_t MB18 = (1U << 18);  ///< mailbox 18 Mask Invalid
        constexpr uint32_t MB17 = (1U << 17);  ///< mailbox 17 Mask Invalid
        constexpr uint32_t MB16 = (1U << 16);  ///< mailbox 16 Mask Invalid
        constexpr uint32_t MB15 = (1U << 15);  ///< mailbox 15 Mask Invalid
        constexpr uint32_t MB14 = (1U << 14);  ///< mailbox 14 Mask Invalid
        constexpr uint32_t MB13 = (1U << 13);  ///< mailbox 13 Mask Invalid
        constexpr uint32_t MB12 = (1U << 12);  ///< mailbox 12 Mask Invalid
        constexpr uint32_t MB11 = (1U << 11);  ///< mailbox 11 Mask Invalid
        constexpr uint32_t MB10 = (1U << 10);  ///< mailbox 10 Mask Invalid
        constexpr uint32_t MB9 = (1U << 9);  ///< mailbox 9 Mask Invalid
        constexpr uint32_t MB8 = (1U << 8);  ///< mailbox 8 Mask Invalid
        constexpr uint32_t MB7 = (1U << 7);  ///< mailbox 7 Mask Invalid
        constexpr uint32_t MB6 = (1U << 6);  ///< mailbox 6 Mask Invalid
        constexpr uint32_t MB5 = (1U << 5);  ///< mailbox 5 Mask Invalid
        constexpr uint32_t MB4 = (1U << 4);  ///< mailbox 4 Mask Invalid
        constexpr uint32_t MB3 = (1U << 3);  ///< mailbox 3 Mask Invalid
        constexpr uint32_t MB2 = (1U << 2);  ///< mailbox 2 Mask Invalid
        constexpr uint32_t MB1 = (1U << 1);  ///< mailbox 1 Mask Invalid
        constexpr uint32_t MB0 = (1U << 0);  ///< mailbox 0 Mask Invalid
    }

    /// MIER Register bits
    namespace mier_bits {
        constexpr uint32_t MB31 = (1U << 31);  ///< mailbox 31 Interrupt Enable
        constexpr uint32_t MB30 = (1U << 30);  ///< mailbox 30 Interrupt Enable
        constexpr uint32_t MB29 = (1U << 29);  ///< mailbox 29 Interrupt Enable
        constexpr uint32_t MB28 = (1U << 28);  ///< mailbox 28 Interrupt Enable
        constexpr uint32_t MB27 = (1U << 27);  ///< mailbox 27 Interrupt Enable
        constexpr uint32_t MB26 = (1U << 26);  ///< mailbox 26 Interrupt Enable
        constexpr uint32_t MB25 = (1U << 25);  ///< mailbox 25 Interrupt Enable
        constexpr uint32_t MB24 = (1U << 24);  ///< mailbox 24 Interrupt Enable
        constexpr uint32_t MB23 = (1U << 23);  ///< mailbox 23 Interrupt Enable
        constexpr uint32_t MB22 = (1U << 22);  ///< mailbox 22 Interrupt Enable
        constexpr uint32_t MB21 = (1U << 21);  ///< mailbox 21 Interrupt Enable
        constexpr uint32_t MB20 = (1U << 20);  ///< mailbox 20 Interrupt Enable
        constexpr uint32_t MB19 = (1U << 19);  ///< mailbox 19 Interrupt Enable
        constexpr uint32_t MB18 = (1U << 18);  ///< mailbox 18 Interrupt Enable
        constexpr uint32_t MB17 = (1U << 17);  ///< mailbox 17 Interrupt Enable
        constexpr uint32_t MB16 = (1U << 16);  ///< mailbox 16 Interrupt Enable
        constexpr uint32_t MB15 = (1U << 15);  ///< mailbox 15 Interrupt Enable
        constexpr uint32_t MB14 = (1U << 14);  ///< mailbox 14 Interrupt Enable
        constexpr uint32_t MB13 = (1U << 13);  ///< mailbox 13 Interrupt Enable
        constexpr uint32_t MB12 = (1U << 12);  ///< mailbox 12 Interrupt Enable
        constexpr uint32_t MB11 = (1U << 11);  ///< mailbox 11 Interrupt Enable
        constexpr uint32_t MB10 = (1U << 10);  ///< mailbox 10 Interrupt Enable
        constexpr uint32_t MB9 = (1U << 9);  ///< mailbox 9 Interrupt Enable
        constexpr uint32_t MB8 = (1U << 8);  ///< mailbox 8 Interrupt Enable
        constexpr uint32_t MB7 = (1U << 7);  ///< mailbox 7 Interrupt Enable
        constexpr uint32_t MB6 = (1U << 6);  ///< mailbox 6 Interrupt Enable
        constexpr uint32_t MB5 = (1U << 5);  ///< mailbox 5 Interrupt Enable
        constexpr uint32_t MB4 = (1U << 4);  ///< mailbox 4 Interrupt Enable
        constexpr uint32_t MB3 = (1U << 3);  ///< mailbox 3 Interrupt Enable
        constexpr uint32_t MB2 = (1U << 2);  ///< mailbox 2 Interrupt Enable
        constexpr uint32_t MB1 = (1U << 1);  ///< mailbox 1 Interrupt Enable
        constexpr uint32_t MB0 = (1U << 0);  ///< mailbox 0 Interrupt Enable
    }

    /// MIER_FIFO Register bits
    namespace mier_fifo_bits {
        constexpr uint32_t MB29 = (1U << 29);  ///< Receive FIFO Interrupt Generation Timing Control
        constexpr uint32_t MB28 = (1U << 28);  ///< Receive FIFO Interrupt Enable
        constexpr uint32_t Reserved = (2 << 26);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t MB25 = (1U << 25);  ///< Transmit FIFO Interrupt Generation Timing Control
        constexpr uint32_t MB24 = (1U << 24);  ///< Transmit FIFO Interrupt Enable
        constexpr uint32_t MB23 = (1U << 23);  ///< mailbox 23 Interrupt Enable
        constexpr uint32_t MB22 = (1U << 22);  ///< mailbox 22 Interrupt Enable
        constexpr uint32_t MB21 = (1U << 21);  ///< mailbox 21 Interrupt Enable
        constexpr uint32_t MB20 = (1U << 20);  ///< mailbox 20 Interrupt Enable
        constexpr uint32_t MB19 = (1U << 19);  ///< mailbox 19 Interrupt Enable
        constexpr uint32_t MB18 = (1U << 18);  ///< mailbox 18 Interrupt Enable
        constexpr uint32_t MB17 = (1U << 17);  ///< mailbox 17 Interrupt Enable
        constexpr uint32_t MB16 = (1U << 16);  ///< mailbox 16 Interrupt Enable
        constexpr uint32_t MB15 = (1U << 15);  ///< mailbox 15 Interrupt Enable
        constexpr uint32_t MB14 = (1U << 14);  ///< mailbox 14 Interrupt Enable
        constexpr uint32_t MB13 = (1U << 13);  ///< mailbox 13 Interrupt Enable
        constexpr uint32_t MB12 = (1U << 12);  ///< mailbox 12 Interrupt Enable
        constexpr uint32_t MB11 = (1U << 11);  ///< mailbox 11 Interrupt Enable
        constexpr uint32_t MB10 = (1U << 10);  ///< mailbox 10 Interrupt Enable
        constexpr uint32_t MB9 = (1U << 9);  ///< mailbox 9 Interrupt Enable
        constexpr uint32_t MB8 = (1U << 8);  ///< mailbox 8 Interrupt Enable
        constexpr uint32_t MB7 = (1U << 7);  ///< mailbox 7 Interrupt Enable
        constexpr uint32_t MB6 = (1U << 6);  ///< mailbox 6 Interrupt Enable
        constexpr uint32_t MB5 = (1U << 5);  ///< mailbox 5 Interrupt Enable
        constexpr uint32_t MB4 = (1U << 4);  ///< mailbox 4 Interrupt Enable
        constexpr uint32_t MB3 = (1U << 3);  ///< mailbox 3 Interrupt Enable
        constexpr uint32_t MB2 = (1U << 2);  ///< mailbox 2 Interrupt Enable
        constexpr uint32_t MB1 = (1U << 1);  ///< mailbox 1 Interrupt Enable
        constexpr uint32_t MB0 = (1U << 0);  ///< mailbox 0 Interrupt Enable
    }

    /// MCTL_TX[%s] Register bits
    namespace mctl_tx[%s]_bits {
        constexpr uint32_t TRMREQ = (1U << 7);  ///< Transmit Mailbox Request
        constexpr uint32_t RECREQ = (1U << 6);  ///< Receive Mailbox Request
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t ONESHOT = (1U << 4);  ///< One-Shot Enable
        constexpr uint32_t TRMABT = (1U << 2);  ///< Transmission Abort Complete Flag (Transmit mailbox setting enabled)
        constexpr uint32_t TRMACTIVE = (1U << 1);  ///< Transmission-in-Progress Status Flag (Transmit mailbox setting enabled)
        constexpr uint32_t SENTDATA = (1U << 0);  ///< Transmission Complete Flag
    }

    /// MCTL_RX[%s] Register bits
    namespace mctl_rx[%s]_bits {
        constexpr uint32_t TRMREQ = (1U << 7);  ///< Transmit Mailbox Request
        constexpr uint32_t RECREQ = (1U << 6);  ///< Receive Mailbox Request
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t ONESHOT = (1U << 4);  ///< One-Shot Enable
        constexpr uint32_t MSGLOST = (1U << 2);  ///< Message Lost Flag(Receive mailbox setting enabled)
        constexpr uint32_t INVALDATA = (1U << 1);  ///< Reception-in-Progress Status Flag (Receive mailbox setting enabled)
        constexpr uint32_t NEWDATA = (1U << 0);  ///< Reception Complete Flag
    }

    /// CTLR Register bits
    namespace ctlr_bits {
        constexpr uint32_t Reserved = (2 << 14);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t RBOC = (1U << 13);  ///< Forcible Return From Bus-Off
        constexpr uint32_t BOM = (2 << 11);  ///< Bus-Off Recovery Mode by a program request
        constexpr uint32_t SLPM = (1U << 10);  ///< CAN Sleep Mode
        constexpr uint32_t CANM = (2 << 8);  ///< CAN Operating Mode Select
        constexpr uint32_t TSPS = (2 << 6);  ///< Time Stamp Prescaler Select
        constexpr uint32_t TSRC = (1U << 5);  ///< Time Stamp Counter Reset Command
        constexpr uint32_t TPM = (1U << 4);  ///< Transmission Priority Mode Select
        constexpr uint32_t MLM = (1U << 3);  ///< Message Lost Mode Select
        constexpr uint32_t IDFM = (2 << 1);  ///< ID Format Mode Select
        constexpr uint32_t MBM = (1U << 0);  ///< CAN Mailbox Mode Select
    }

    /// STR Register bits
    namespace str_bits {
        constexpr uint32_t Reserved = (1U << 15);  ///< This bit is read as 0.
        constexpr uint32_t RECST = (1U << 14);  ///< Receive Status Flag (receiver)
        constexpr uint32_t TRMST = (1U << 13);  ///< Transmit Status Flag (transmitter)
        constexpr uint32_t BOST = (1U << 12);  ///< Bus-Off Status Flag
        constexpr uint32_t EPST = (1U << 11);  ///< Error-Passive Status Flag
        constexpr uint32_t SLPST = (1U << 10);  ///< CAN Sleep Status Flag
        constexpr uint32_t HLTST = (1U << 9);  ///< CAN Halt Status Flag
        constexpr uint32_t RSTST = (1U << 8);  ///< CAN Reset Status Flag
        constexpr uint32_t EST = (1U << 7);  ///< Error Status Flag
        constexpr uint32_t TABST = (1U << 6);  ///< Transmission Abort Status Flag
        constexpr uint32_t FMLST = (1U << 5);  ///< FIFO Mailbox Message Lost Status Flag
        constexpr uint32_t NMLST = (1U << 4);  ///< Normal Mailbox Message Lost Status Flag
        constexpr uint32_t TFST = (1U << 3);  ///< Transmit FIFO Status Flag
        constexpr uint32_t RFST = (1U << 2);  ///< Receive FIFO Status Flag
        constexpr uint32_t SDST = (1U << 1);  ///< SENTDATA Status Flag
        constexpr uint32_t NDST = (1U << 0);  ///< NEWDATA Status Flag
    }

    /// BCR Register bits
    namespace bcr_bits {
        constexpr uint32_t TSEG1 = (4 << 28);  ///< Time Segment 1 Control
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t BRP = (10 << 16);  ///< Prescaler Division Ratio Select . These bits set the frequency of the CAN communication clock (fCANCLK).
        constexpr uint32_t SJW = (2 << 12);  ///< Resynchronization Jump Width Control
        constexpr uint32_t TSEG2 = (3 << 8);  ///< Time Segment 2 Control
        constexpr uint32_t CCLKS = (1U << 0);  ///< CAN Clock Source Selection
    }

    /// RFCR Register bits
    namespace rfcr_bits {
        constexpr uint32_t RFEST = (1U << 7);  ///< Receive FIFO Empty Status Flag
        constexpr uint32_t RFWST = (1U << 6);  ///< Receive FIFO Buffer Warning Status Flag
        constexpr uint32_t RFFST = (1U << 5);  ///< Receive FIFO Full Status Flag
        constexpr uint32_t RFMLF = (1U << 4);  ///< Receive FIFO Message Lost Flag
        constexpr uint32_t RFUST = (3 << 1);  ///< Receive FIFO Unread Message Number Status
        constexpr uint32_t RFE = (1U << 0);  ///< Receive FIFO Enable
    }

    /// RFPCR Register bits
    namespace rfpcr_bits {
        constexpr uint32_t RFPCR = (8 << 0);  ///< The CPU-side pointer for the receive FIFO is incremented by writing FFh to RFPCR.
    }

    /// TFCR Register bits
    namespace tfcr_bits {
        constexpr uint32_t TFEST = (1U << 7);  ///< Transmit FIFO Empty Status
        constexpr uint32_t TFFST = (1U << 6);  ///< Transmit FIFO Full Status
        constexpr uint32_t Reserved = (2 << 4);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t TFUST = (3 << 1);  ///< Transmit FIFO Unsent Message Number Status
        constexpr uint32_t TFE = (1U << 0);  ///< Transmit FIFO Enable
    }

    /// TFPCR Register bits
    namespace tfpcr_bits {
        constexpr uint32_t TFPCR = (8 << 0);  ///< The CPU-side pointer for the transmit FIFO is incremented by writing FFh to TFPCR.
    }

    /// EIER Register bits
    namespace eier_bits {
        constexpr uint32_t BLIE = (1U << 7);  ///< Bus Lock Interrupt Enable
        constexpr uint32_t OLIE = (1U << 6);  ///< Overload Frame Transmit Interrupt Enable
        constexpr uint32_t ORIE = (1U << 5);  ///< Overrun Interrupt Enable
        constexpr uint32_t BORIE = (1U << 4);  ///< Bus-Off Recovery Interrupt Enable
        constexpr uint32_t BOEIE = (1U << 3);  ///< Bus-Off Entry Interrupt Enable
        constexpr uint32_t EPIE = (1U << 2);  ///< Error-Passive Interrupt Enable
        constexpr uint32_t EWIE = (1U << 1);  ///< Error-Warning Interrupt Enable
        constexpr uint32_t BEIE = (1U << 0);  ///< Bus Error Interrupt Enable
    }

    /// EIFR Register bits
    namespace eifr_bits {
        constexpr uint32_t BLIF = (1U << 7);  ///< Bus Lock Detect Flag
        constexpr uint32_t OLIF = (1U << 6);  ///< Overload Frame Transmission Detect Flag
        constexpr uint32_t ORIF = (1U << 5);  ///< Receive Overrun Detect Flag
        constexpr uint32_t BORIF = (1U << 4);  ///< Bus-Off Recovery Detect Flag
        constexpr uint32_t BOEIF = (1U << 3);  ///< Bus-Off Entry Detect Flag
        constexpr uint32_t EPIF = (1U << 2);  ///< Error-Passive Detect Flag
        constexpr uint32_t EWIF = (1U << 1);  ///< Error-Warning Detect Flag
        constexpr uint32_t BEIF = (1U << 0);  ///< Bus Error Detect Flag
    }

    /// RECR Register bits
    namespace recr_bits {
        constexpr uint32_t RECR = (8 << 0);  ///< Receive error count functionRECR increments or decrements the counter value according to the error status of the CAN module during reception.
    }

    /// TECR Register bits
    namespace tecr_bits {
        constexpr uint32_t TECR = (8 << 0);  ///< Transmit error count functionTECR increments or decrements the counter value according to the error status of the CAN module during transmission.
    }

    /// ECSR Register bits
    namespace ecsr_bits {
        constexpr uint32_t EDPM = (1U << 7);  ///< Error Display Mode Select
        constexpr uint32_t ADEF = (1U << 6);  ///< ACK Delimiter Error Flag
        constexpr uint32_t BE0F = (1U << 5);  ///< Bit Error (dominant) Flag
        constexpr uint32_t BE1F = (1U << 4);  ///< Bit Error (recessive) Flag
        constexpr uint32_t CEF = (1U << 3);  ///< CRC Error Flag
        constexpr uint32_t AEF = (1U << 2);  ///< ACK Error Flag
        constexpr uint32_t FEF = (1U << 1);  ///< Form Error Flag
        constexpr uint32_t SEF = (1U << 0);  ///< Stuff Error Flag
    }

    /// CSSR Register bits
    namespace cssr_bits {
        constexpr uint32_t CSSR = (8 << 0);  ///< When the value for the channel search is input, the channel number is output to MSSR.
    }

    /// MSSR Register bits
    namespace mssr_bits {
        constexpr uint32_t SEST = (1U << 7);  ///< Search Result Status
        constexpr uint32_t Reserved = (2 << 5);  ///< These bits are read as 00.
        constexpr uint32_t MBNST = (5 << 0);  ///< Search Result Mailbox Number Status These bits output the smallest mailbox number that is searched in each mode of MSMR.
    }

    /// MSMR Register bits
    namespace msmr_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t MBSM = (2 << 0);  ///< Mailbox Search Mode Select
    }

    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (16 << 0);  ///< Free-running counter value for the time stamp function
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t AFSR = (16 << 0);  ///< After the standard ID of a received message is written, the value converted for data table search can be read.
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t TSTM = (2 << 1);  ///< CAN Test Mode Select
        constexpr uint32_t TSTE = (1U << 0);  ///< CAN Test Mode Enable
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40044200;
    constexpr uint32_t IWDT_BASE = 0x40044400;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDTRR;  ///< Offset: 0x00 - WDT Refresh Register
        volatile uint32_t WDTCR;  ///< Offset: 0x02 - WDT Control Register
        volatile uint32_t WDTSR;  ///< Offset: 0x04 - WDT Status Register
        volatile uint32_t WDTRCR;  ///< Offset: 0x06 - WDT Reset Control Register
        volatile uint32_t WDTCSTPR;  ///< Offset: 0x08 - WDT Count Stop Control Register
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);
    inline Registers* IWDT = reinterpret_cast<Registers*>(IWDT_BASE);

    // Bit definitions
    /// WDTRR Register bits
    namespace wdtrr_bits {
        constexpr uint32_t WDTRR = (8 << 0);  ///< WDTRR is an 8-bit register that refreshes the down-counter of the WDT.
    }

    /// WDTCR Register bits
    namespace wdtcr_bits {
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t RPSS = (2 << 12);  ///< Window Start Position Selection
        constexpr uint32_t RPES = (2 << 8);  ///< Window End Position Selection
        constexpr uint32_t CKS = (4 << 4);  ///< Clock Division Ratio Selection
        constexpr uint32_t TOPS = (2 << 0);  ///< Timeout Period Selection
    }

    /// WDTSR Register bits
    namespace wdtsr_bits {
        constexpr uint32_t REFEF = (1U << 15);  ///< Refresh Error Flag
        constexpr uint32_t UNDFF = (1U << 14);  ///< Underflow Flag
        constexpr uint32_t CNTVAL = (14 << 0);  ///< Down-Counter ValueValue counted by the down-counter
    }

    /// WDTRCR Register bits
    namespace wdtrcr_bits {
        constexpr uint32_t RSTIRQS = (1U << 7);  ///< Reset Interrupt Request Selection
    }

    /// WDTCSTPR Register bits
    namespace wdtcstpr_bits {
        constexpr uint32_t SLCSTP = (1U << 7);  ///< Sleep-Mode Count Stop Control
        constexpr uint32_t Reserved = (7 << 0);  ///< These bits are read as 0000000. The write value should be 0000000.
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USBFS_BASE = 0x40090000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t SYSCFG;  ///< Offset: 0x00 - System Configuration Control Register
        volatile uint32_t SYSSTS0;  ///< Offset: 0x04 - System Configuration Status Register 0
        volatile uint32_t DVSTCTR0;  ///< Offset: 0x08 - Device State Control Register 0
        volatile uint32_t CFIFO;  ///< Offset: 0x14 - CFIFO Port Register
        volatile uint32_t CFIFOL;  ///< Offset: 0x14 - CFIFO Port Register L
        volatile uint32_t D0FIFO;  ///< Offset: 0x18 - D0FIFO Port Register
        volatile uint32_t D0FIFOL;  ///< Offset: 0x18 - D0FIFO Port Register L
        volatile uint32_t D1FIFO;  ///< Offset: 0x1C - D1FIFO Port Register
        volatile uint32_t D1FIFOL;  ///< Offset: 0x1C - D1FIFO Port Register L
        volatile uint32_t CFIFOSEL;  ///< Offset: 0x20 - CFIFO Port Select Register
        volatile uint32_t CFIFOCTR;  ///< Offset: 0x22 - CFIFO Port Control Register
        volatile uint32_t D0FIFOSEL;  ///< Offset: 0x28 - D0FIFO Port Select Register
        volatile uint32_t D0FIFOCTR;  ///< Offset: 0x2A - D0FIFO Port Control Register
        volatile uint32_t D1FIFOSEL;  ///< Offset: 0x2C - D1FIFO Port Select Register
        volatile uint32_t D1FIFOCTR;  ///< Offset: 0x2E - D1FIFO Port Control Register
        volatile uint32_t INTENB0;  ///< Offset: 0x30 - Interrupt Enable Register 0
        volatile uint32_t INTENB1;  ///< Offset: 0x32 - Interrupt Enable Register 1
        volatile uint32_t BRDYENB;  ///< Offset: 0x36 - BRDY Interrupt Enable Register
        volatile uint32_t NRDYENB;  ///< Offset: 0x38 - NRDY Interrupt Enable Register
        volatile uint32_t BEMPENB;  ///< Offset: 0x3A - BEMP Interrupt Enable Register
        volatile uint32_t SOFCFG;  ///< Offset: 0x3C - SOF Output Configuration Register
        volatile uint32_t INTSTS0;  ///< Offset: 0x40 - Interrupt Status Register 0
        volatile uint32_t INTSTS1;  ///< Offset: 0x42 - Interrupt Status Register 1
        volatile uint32_t BRDYSTS;  ///< Offset: 0x46 - BRDY Interrupt Status Register
        volatile uint32_t NRDYSTS;  ///< Offset: 0x48 - NRDY Interrupt Status Register
        volatile uint32_t BEMPSTS;  ///< Offset: 0x4A - BEMP Interrupt Status Register
        volatile uint32_t FRMNUM;  ///< Offset: 0x4C - Frame Number Register
        volatile uint32_t USBREQ;  ///< Offset: 0x54 - USB Request Type Register
        volatile uint32_t USBVAL;  ///< Offset: 0x56 - USB Request Value Register
        volatile uint32_t USBINDX;  ///< Offset: 0x58 - USB Request Index Register
        volatile uint32_t USBLENG;  ///< Offset: 0x5A - USB Request Length Register
        volatile uint32_t DCPCFG;  ///< Offset: 0x5C - DCP Configuration Register
        volatile uint32_t DCPMAXP;  ///< Offset: 0x5E - DCP Maximum Packet Size Register
        volatile uint32_t DCPCTR;  ///< Offset: 0x60 - DCP Control Register
        volatile uint32_t PIPESEL;  ///< Offset: 0x64 - Pipe Window Select Register
        volatile uint32_t PIPECFG;  ///< Offset: 0x68 - Pipe Configuration Register
        volatile uint32_t PIPEMAXP;  ///< Offset: 0x6C - Pipe Maximum Packet Size Register
        volatile uint32_t PIPEPERI;  ///< Offset: 0x6E - Pipe Cycle Control Register
        volatile uint32_t PIPE%sCTR;  ///< Offset: 0x7A - Pipe %s Control Register
        volatile uint32_t PIPE%sTRE;  ///< Offset: 0x90 - Pipe %s Transaction Counter Enable Register
        volatile uint32_t PIPE%sTRN;  ///< Offset: 0x92 - Pipe %s Transaction Counter Register
        volatile uint32_t DEVADD%s;  ///< Offset: 0xD0 - Device Address %s Configuration Register
        volatile uint32_t USBMC;  ///< Offset: 0xCC - USB Module Control Register
        volatile uint32_t USBBCCTRL0;  ///< Offset: 0xB0 - BC Control Register 0
    };

    /// Peripheral instances
    inline Registers* USBFS = reinterpret_cast<Registers*>(USBFS_BASE);

    // Bit definitions
    /// SYSCFG Register bits
    namespace syscfg_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SCKE = (1U << 10);  ///< USB Clock Enable
        constexpr uint32_t CNEN = (1U << 8);  ///< CNEN Single End Receiver Enable
        constexpr uint32_t DCFM = (1U << 6);  ///< Controller Function Select
        constexpr uint32_t DRPD = (1U << 5);  ///< D+/D- Line Resistor Control
        constexpr uint32_t DPRPU = (1U << 4);  ///< D+ Line Resistor Control
        constexpr uint32_t DMRPU = (1U << 3);  ///< D- Line Resistor Control
        constexpr uint32_t USBE = (1U << 0);  ///< USB Operation Enable
    }

    /// SYSSTS0 Register bits
    namespace syssts0_bits {
        constexpr uint32_t OVCMON = (2 << 14);  ///< External USB0_OVRCURA/ USB0_OVRCURB Input Pin MonitorThe OCVMON[1] bit indicates the status of the USBHS_OVRCURA pin. The OCVMON[0] bit indicates the status of the USBHS_OVRCURB pin.
        constexpr uint32_t Reserved = (3 << 3);  ///< These bits are read as 000.
        constexpr uint32_t HTACT = (1U << 6);  ///< USB Host Sequencer Status Monitor
        constexpr uint32_t IDMON = (1U << 2);  ///< External ID0 Input Pin Monitor
        constexpr uint32_t LNST = (2 << 0);  ///< USB Data Line Status Monitor
    }

    /// DVSTCTR0 Register bits
    namespace dvstctr0_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t HNPBTOA = (1U << 11);  ///< Host Negotiation Protocol (HNP) Control This bit is used when switching from device B to device A while in OTG mode. If the HNPBTOA bit is 1, the internal function control keeps the suspended state until the HNP processing ends even though SYSCFG.DPRPU = 0 or SYSCFG.DCFM = 1 is set.
        constexpr uint32_t EXICEN = (1U << 10);  ///< USB_EXICEN Output Pin Control
        constexpr uint32_t VBUSEN = (1U << 9);  ///< USB_VBUSEN Output Pin Control
        constexpr uint32_t WKUP = (1U << 8);  ///< Wakeup Output
        constexpr uint32_t RWUPE = (1U << 7);  ///< Wakeup Detection Enable
        constexpr uint32_t USBRST = (1U << 6);  ///< USB Bus Reset Output
        constexpr uint32_t RESUME = (1U << 5);  ///< Resume Output
        constexpr uint32_t UACT = (1U << 4);  ///< USB Bus Enable
        constexpr uint32_t RHST = (3 << 0);  ///< USB Bus Reset Status
    }

    /// CFIFO Register bits
    namespace cfifo_bits {
        constexpr uint32_t FIFOPORT = (16 << 0);  ///< FIFO PortRead receive data from the FIFO buffer or write transmit data to the FIFO buffer by accessing these bits.
    }

    /// D0FIFO Register bits
    namespace d0fifo_bits {
        constexpr uint32_t FIFOPORT = (16 << 0);  ///< FIFO PortRead receive data from the FIFO buffer or write transmit data to the FIFO buffer by accessing these bits.
    }

    /// D1FIFO Register bits
    namespace d1fifo_bits {
        constexpr uint32_t FIFOPORT = (16 << 0);  ///< FIFO PortRead receive data from the FIFO buffer or write transmit data to the FIFO buffer by accessing these bits.
    }

    /// CFIFOSEL Register bits
    namespace cfifosel_bits {
        constexpr uint32_t RCNT = (1U << 15);  ///< Read Count Mode
        constexpr uint32_t REW = (1U << 14);  ///< Buffer Pointer Rewind
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t MBW = (1U << 10);  ///< CFIFO Port Access Bit Width
        constexpr uint32_t BIGEND = (1U << 8);  ///< CFIFO Port Endian Control
        constexpr uint32_t ISEL = (1U << 5);  ///< CFIFO Port Access Direction When DCP is Selected
        constexpr uint32_t CURPIPE = (4 << 0);  ///< CFIFO Port Access Pipe Specification
    }

    /// CFIFOCTR Register bits
    namespace cfifoctr_bits {
        constexpr uint32_t BVAL = (1U << 15);  ///< Buffer Memory Valid Flag
        constexpr uint32_t BCLR = (1U << 14);  ///< CPU Buffer ClearNote: Only 0 can be read.
        constexpr uint32_t FRDY = (1U << 13);  ///< FIFO Port Ready
        constexpr uint32_t Reserved = (4 << 9);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t DTLN = (9 << 0);  ///< Receive Data LengthIndicates the length of the receive data.
    }

    /// D0FIFOSEL Register bits
    namespace d0fifosel_bits {
        constexpr uint32_t RCNT = (1U << 15);  ///< Read Count Mode
        constexpr uint32_t REW = (1U << 14);  ///< Buffer Pointer RewindNote: Only 0 can be read.
        constexpr uint32_t DCLRM = (1U << 13);  ///< Auto Buffer Memory Clear Mode Accessed after Specified Pipe Data is Read
        constexpr uint32_t DREQE = (1U << 12);  ///< DMA/DTC Transfer Request Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t MBW = (1U << 10);  ///< FIFO Port Access Bit Width
        constexpr uint32_t BIGEND = (1U << 8);  ///< FIFO Port Endian Control
        constexpr uint32_t CURPIPE = (4 << 0);  ///< FIFO Port Access Pipe Specification
    }

    /// D0FIFOCTR Register bits
    namespace d0fifoctr_bits {
        constexpr uint32_t BVAL = (1U << 15);  ///< Buffer Memory Valid Flag
        constexpr uint32_t BCLR = (1U << 14);  ///< CPU Buffer ClearNote: Only 0 can be read.
        constexpr uint32_t FRDY = (1U << 13);  ///< FIFO Port Ready
        constexpr uint32_t Reserved = (4 << 9);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t DTLN = (9 << 0);  ///< Receive Data LengthIndicates the length of the receive data.
    }

    /// D1FIFOSEL Register bits
    namespace d1fifosel_bits {
        constexpr uint32_t RCNT = (1U << 15);  ///< Read Count Mode
        constexpr uint32_t REW = (1U << 14);  ///< Buffer Pointer Rewind
        constexpr uint32_t DCLRM = (1U << 13);  ///< Auto Buffer Memory Clear Mode Accessed after Specified Pipe Data is Read
        constexpr uint32_t DREQE = (1U << 12);  ///< DMA/DTC Transfer Request Enable
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t MBW = (1U << 10);  ///< FIFO Port Access Bit Width
        constexpr uint32_t BIGEND = (1U << 8);  ///< FIFO Port Endian Control
        constexpr uint32_t CURPIPE = (4 << 0);  ///< FIFO Port Access Pipe Specification
    }

    /// D1FIFOCTR Register bits
    namespace d1fifoctr_bits {
        constexpr uint32_t BVAL = (1U << 15);  ///< Buffer Memory Valid Flag
        constexpr uint32_t BCLR = (1U << 14);  ///< CPU Buffer ClearNote: Only 0 can be read.
        constexpr uint32_t FRDY = (1U << 13);  ///< FIFO Port Ready
        constexpr uint32_t Reserved = (4 << 9);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t DTLN = (9 << 0);  ///< Receive Data LengthIndicates the length of the receive data.
    }

    /// INTENB0 Register bits
    namespace intenb0_bits {
        constexpr uint32_t VBSE = (1U << 15);  ///< VBUS Interrupt Enable
        constexpr uint32_t RSME = (1U << 14);  ///< Resume Interrupt Enable
        constexpr uint32_t SOFE = (1U << 13);  ///< Frame Number Update Interrupt Enable
        constexpr uint32_t DVSE = (1U << 12);  ///< Device State Transition Interrupt Enable
        constexpr uint32_t CTRE = (1U << 11);  ///< Control Transfer Stage Transition Interrupt Enable
        constexpr uint32_t BEMPE = (1U << 10);  ///< Buffer Empty Interrupt Enable
        constexpr uint32_t NRDYE = (1U << 9);  ///< Buffer Not Ready Response Interrupt Enable
        constexpr uint32_t BRDYE = (1U << 8);  ///< Buffer Ready Interrupt Enable
        constexpr uint32_t Reserved = (8 << 0);  ///< These bits are read as 00000000. The write value should be 00000000.
    }

    /// INTENB1 Register bits
    namespace intenb1_bits {
        constexpr uint32_t OVRCRE = (1U << 15);  ///< Overcurrent Input Change Interrupt Enable
        constexpr uint32_t BCHGE = (1U << 14);  ///< USB Bus Change Interrupt Enable
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t DTCHE = (1U << 12);  ///< Disconnection Detection Interrupt Enable
        constexpr uint32_t ATTCHE = (1U << 11);  ///< Connection Detection Interrupt Enable
        constexpr uint32_t EOFERRE = (1U << 6);  ///< EOF Error Detection Interrupt Enable
        constexpr uint32_t SIGNE = (1U << 5);  ///< Setup Transaction Error Interrupt Enable
        constexpr uint32_t SACKE = (1U << 4);  ///< Setup Transaction Normal Response Interrupt Enable
        constexpr uint32_t PDDETINTE0 = (1U << 0);  ///< PDDETINT0 Detection Interrupt Enable
    }

    /// BRDYENB Register bits
    namespace brdyenb_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PIPE9BRDYE = (1U << 9);  ///< BRDY Interrupt Enable for PIPE9
        constexpr uint32_t PIPE8BRDYE = (1U << 8);  ///< BRDY Interrupt Enable for PIPE8
        constexpr uint32_t PIPE7BRDYE = (1U << 7);  ///< BRDY Interrupt Enable for PIPE7
        constexpr uint32_t PIPE6BRDYE = (1U << 6);  ///< BRDY Interrupt Enable for PIPE6
        constexpr uint32_t PIPE5BRDYE = (1U << 5);  ///< BRDY Interrupt Enable for PIPE5
        constexpr uint32_t PIPE4BRDYE = (1U << 4);  ///< BRDY Interrupt Enable for PIPE4
        constexpr uint32_t PIPE3BRDYE = (1U << 3);  ///< BRDY Interrupt Enable for PIPE3
        constexpr uint32_t PIPE2BRDYE = (1U << 2);  ///< BRDY Interrupt Enable for PIPE2
        constexpr uint32_t PIPE1BRDYE = (1U << 1);  ///< BRDY Interrupt Enable for PIPE1
        constexpr uint32_t PIPE0BRDYE = (1U << 0);  ///< BRDY Interrupt Enable for PIPE0
    }

    /// NRDYENB Register bits
    namespace nrdyenb_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PIPE9NRDYE = (1U << 9);  ///< NRDY Interrupt Enable for PIPE9
        constexpr uint32_t PIPE8NRDYE = (1U << 8);  ///< NRDY Interrupt Enable for PIPE8
        constexpr uint32_t PIPE7NRDYE = (1U << 7);  ///< NRDY Interrupt Enable for PIPE7
        constexpr uint32_t PIPE6NRDYE = (1U << 6);  ///< NRDY Interrupt Enable for PIPE6
        constexpr uint32_t PIPE5NRDYE = (1U << 5);  ///< NRDY Interrupt Enable for PIPE5
        constexpr uint32_t PIPE4NRDYE = (1U << 4);  ///< NRDY Interrupt Enable for PIPE4
        constexpr uint32_t PIPE3NRDYE = (1U << 3);  ///< NRDY Interrupt Enable for PIPE3
        constexpr uint32_t PIPE2NRDYE = (1U << 2);  ///< NRDY Interrupt Enable for PIPE2
        constexpr uint32_t PIPE1NRDYE = (1U << 1);  ///< NRDY Interrupt Enable for PIPE1
        constexpr uint32_t PIPE0NRDYE = (1U << 0);  ///< NRDY Interrupt Enable for PIPE0
    }

    /// BEMPENB Register bits
    namespace bempenb_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PIPE9BEMPE = (1U << 9);  ///< BEMP Interrupt Enable for PIPE9
        constexpr uint32_t PIPE8BEMPE = (1U << 8);  ///< BEMP Interrupt Enable for PIPE8
        constexpr uint32_t PIPE7BEMPE = (1U << 7);  ///< BEMP Interrupt Enable for PIPE7
        constexpr uint32_t PIPE6BEMPE = (1U << 6);  ///< BEMP Interrupt Enable for PIPE6
        constexpr uint32_t PIPE5BEMPE = (1U << 5);  ///< BEMP Interrupt Enable for PIPE5
        constexpr uint32_t PIPE4BEMPE = (1U << 4);  ///< BEMP Interrupt Enable for PIPE4
        constexpr uint32_t PIPE3BEMPE = (1U << 3);  ///< BEMP Interrupt Enable for PIPE3
        constexpr uint32_t PIPE2BEMPE = (1U << 2);  ///< BEMP Interrupt Enable for PIPE2
        constexpr uint32_t PIPE1BEMPE = (1U << 1);  ///< BEMP Interrupt Enable for PIPE1
        constexpr uint32_t PIPE0BEMPE = (1U << 0);  ///< BEMP Interrupt Enable for PIPE0
    }

    /// SOFCFG Register bits
    namespace sofcfg_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t TRNENSEL = (1U << 8);  ///< Transaction-Enabled Time Select
        constexpr uint32_t BRDYM = (1U << 6);  ///< BRDY Interrupt Status Clear Timing
        constexpr uint32_t EDGESTS = (1U << 4);  ///< Edge Interrupt Output Status Monitor
    }

    /// INTSTS0 Register bits
    namespace intsts0_bits {
        constexpr uint32_t VBINT = (1U << 15);  ///< VBUS Interrupt Status
        constexpr uint32_t RESM = (1U << 14);  ///< Resume Interrupt Status
        constexpr uint32_t SOFR = (1U << 13);  ///< Frame Number Refresh Interrupt Status
        constexpr uint32_t DVST = (1U << 12);  ///< Device State Transition Interrupt Status
        constexpr uint32_t CTRT = (1U << 11);  ///< Control Transfer Stage Transition Interrupt Status
        constexpr uint32_t BEMP = (1U << 10);  ///< Buffer Empty Interrupt Status
        constexpr uint32_t NRDY = (1U << 9);  ///< Buffer Not Ready Interrupt Status
        constexpr uint32_t BRDY = (1U << 8);  ///< Buffer Ready Interrupt Status
        constexpr uint32_t VBSTS = (1U << 7);  ///< VBUS Input Status
        constexpr uint32_t DVSQ = (3 << 4);  ///< Device State
        constexpr uint32_t VALID = (1U << 3);  ///< USB Request Reception
        constexpr uint32_t CTSQ = (3 << 0);  ///< Control Transfer Stage
    }

    /// INTSTS1 Register bits
    namespace intsts1_bits {
        constexpr uint32_t OVRCR = (1U << 15);  ///< Overcurrent Input Change Interrupt Status
        constexpr uint32_t BCHG = (1U << 14);  ///< USB Bus Change Interrupt Status
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t DTCH = (1U << 12);  ///< USB Disconnection Detection Interrupt Status
        constexpr uint32_t ATTCH = (1U << 11);  ///< ATTCH Interrupt Status
        constexpr uint32_t EOFERR = (1U << 6);  ///< EOF Error Detection Interrupt Status
        constexpr uint32_t SIGN = (1U << 5);  ///< Setup Transaction Error Interrupt Status
        constexpr uint32_t SACK = (1U << 4);  ///< Setup Transaction Normal Response Interrupt Status
        constexpr uint32_t PDDETINT0 = (1U << 0);  ///< PDDET0 Detection Interrupt Status
    }

    /// BRDYSTS Register bits
    namespace brdysts_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PIPE9BRDY = (1U << 9);  ///< BRDY Interrupt Status for PIPE9
        constexpr uint32_t PIPE8BRDY = (1U << 8);  ///< BRDY Interrupt Status for PIPE8
        constexpr uint32_t PIPE7BRDY = (1U << 7);  ///< BRDY Interrupt Status for PIPE7
        constexpr uint32_t PIPE6BRDY = (1U << 6);  ///< BRDY Interrupt Status for PIPE6
        constexpr uint32_t PIPE5BRDY = (1U << 5);  ///< BRDY Interrupt Status for PIPE5
        constexpr uint32_t PIPE4BRDY = (1U << 4);  ///< BRDY Interrupt Status for PIPE4
        constexpr uint32_t PIPE3BRDY = (1U << 3);  ///< BRDY Interrupt Status for PIPE3
        constexpr uint32_t PIPE2BRDY = (1U << 2);  ///< BRDY Interrupt Status for PIPE2
        constexpr uint32_t PIPE1BRDY = (1U << 1);  ///< BRDY Interrupt Status for PIPE1
        constexpr uint32_t PIPE0BRDY = (1U << 0);  ///< BRDY Interrupt Status for PIPE0
    }

    /// NRDYSTS Register bits
    namespace nrdysts_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PIPE9NRDY = (1U << 9);  ///< NRDY Interrupt Status for PIPE9
        constexpr uint32_t PIPE8NRDY = (1U << 8);  ///< NRDY Interrupt Status for PIPE8
        constexpr uint32_t PIPE7NRDY = (1U << 7);  ///< NRDY Interrupt Status for PIPE7
        constexpr uint32_t PIPE6NRDY = (1U << 6);  ///< NRDY Interrupt Status for PIPE6
        constexpr uint32_t PIPE5NRDY = (1U << 5);  ///< NRDY Interrupt Status for PIPE5
        constexpr uint32_t PIPE4NRDY = (1U << 4);  ///< NRDY Interrupt Status for PIPE4
        constexpr uint32_t PIPE3NRDY = (1U << 3);  ///< NRDY Interrupt Status for PIPE3
        constexpr uint32_t PIPE2NRDY = (1U << 2);  ///< NRDY Interrupt Status for PIPE2
        constexpr uint32_t PIPE1NRDY = (1U << 1);  ///< NRDY Interrupt Status for PIPE1
        constexpr uint32_t PIPE0NRDY = (1U << 0);  ///< NRDY Interrupt Status for PIPE0
    }

    /// BEMPSTS Register bits
    namespace bempsts_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PIPE9BEMP = (1U << 9);  ///< BEMP Interrupt Status for PIPE9
        constexpr uint32_t PIPE8BEMP = (1U << 8);  ///< BEMP Interrupt Status for PIPE8
        constexpr uint32_t PIPE7BEMP = (1U << 7);  ///< BEMP Interrupt Status for PIPE7
        constexpr uint32_t PIPE6BEMP = (1U << 6);  ///< BEMP Interrupt Status for PIPE6
        constexpr uint32_t PIPE5BEMP = (1U << 5);  ///< BEMP Interrupt Status for PIPE5
        constexpr uint32_t PIPE4BEMP = (1U << 4);  ///< BEMP Interrupt Status for PIPE4
        constexpr uint32_t PIPE3BEMP = (1U << 3);  ///< BEMP Interrupt Status for PIPE3
        constexpr uint32_t PIPE2BEMP = (1U << 2);  ///< BEMP Interrupt Status for PIPE2
        constexpr uint32_t PIPE1BEMP = (1U << 1);  ///< BEMP Interrupt Status for PIPE1
        constexpr uint32_t PIPE0BEMP = (1U << 0);  ///< BEMP Interrupt Status for PIPE0
    }

    /// FRMNUM Register bits
    namespace frmnum_bits {
        constexpr uint32_t OVRN = (1U << 15);  ///< Overrun/Underrun Detection Status
        constexpr uint32_t CRCE = (1U << 14);  ///< Receive Data Error
        constexpr uint32_t Reserved = (3 << 11);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t FRNM = (11 << 0);  ///< Frame NumberLatest frame number
    }

    /// USBREQ Register bits
    namespace usbreq_bits {
        constexpr uint32_t BREQUEST = (8 << 8);  ///< RequestThese bits store the USB request bRequest value.
        constexpr uint32_t BMREQUESTTYPE = (8 << 0);  ///< Request TypeThese bits store the USB request bmRequestType value.
    }

    /// USBVAL Register bits
    namespace usbval_bits {
        constexpr uint32_t WVALUE = (16 << 0);  ///< ValueThese bits store the USB request Value value.
    }

    /// USBINDX Register bits
    namespace usbindx_bits {
        constexpr uint32_t WINDEX = (16 << 0);  ///< IndexThese bits store the USB request wIndex value.
    }

    /// USBLENG Register bits
    namespace usbleng_bits {
        constexpr uint32_t WLENGTH = (16 << 0);  ///< LengthThese bits store the USB request wLength value.
    }

    /// DCPCFG Register bits
    namespace dcpcfg_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t SHTNAK = (1U << 7);  ///< Pipe Disabled at End of Transfer
        constexpr uint32_t DIR = (1U << 4);  ///< Transfer Direction
    }

    /// DCPMAXP Register bits
    namespace dcpmaxp_bits {
        constexpr uint32_t DEVSEL = (4 << 12);  ///< Device Select
        constexpr uint32_t Reserved = (5 << 7);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t MXPS = (7 << 0);  ///< Maximum Packet SizeThese bits set the maximum amount of data (maximum packet size) in payloads for the DCP.
    }

    /// DCPCTR Register bits
    namespace dcpctr_bits {
        constexpr uint32_t BSTS = (1U << 15);  ///< Buffer Status
        constexpr uint32_t SUREQ = (1U << 14);  ///< Setup Token Transmission
        constexpr uint32_t Reserved = (2 << 3);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t SUREQCLR = (1U << 11);  ///< SUREQ Bit Clear
        constexpr uint32_t SQCLR = (1U << 8);  ///< Sequence Toggle Bit Clear
        constexpr uint32_t SQSET = (1U << 7);  ///< Sequence Toggle Bit Set
        constexpr uint32_t SQMON = (1U << 6);  ///< Sequence Toggle Bit Monitor
        constexpr uint32_t PBUSY = (1U << 5);  ///< Pipe Busy
        constexpr uint32_t CCPL = (1U << 2);  ///< Control Transfer End Enable
        constexpr uint32_t PID = (2 << 0);  ///< Response PID
    }

    /// PIPESEL Register bits
    namespace pipesel_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t PIPESEL = (4 << 0);  ///< Pipe Window Select
    }

    /// PIPECFG Register bits
    namespace pipecfg_bits {
        constexpr uint32_t TYPE = (2 << 14);  ///< Transfer Type
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t BFRE = (1U << 10);  ///< BRDY Interrupt Operation Specification
        constexpr uint32_t DBLB = (1U << 9);  ///< Double Buffer Mode
        constexpr uint32_t SHTNAK = (1U << 7);  ///< Pipe Disabled at End of Transfer
        constexpr uint32_t DIR = (1U << 4);  ///< Transfer Direction
        constexpr uint32_t EPNUM = (4 << 0);  ///< Endpoint NumberThese bits specify the endpoint number for the selected pipe.Setting 0000b means unused pipe.
    }

    /// PIPEMAXP Register bits
    namespace pipemaxp_bits {
        constexpr uint32_t DEVSEL = (4 << 12);  ///< Device Select
        constexpr uint32_t Reserved = (3 << 9);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t MXPS = (9 << 0);  ///< Maximum Packet SizePIPE1 and PIPE2: 1 byte (001h) to 256 bytes (100h)PIPE3 to PIPE5: 8 bytes (008h), 16 bytes (010h), 32 bytes (020h), 64 bytes (040h) (Bits [8:7] and [2:0] are not provided.)PIPE6 to PIPE9: 1 byte (001h) to 64 bytes (040h) (Bits [8:7] are not provided.)
    }

    /// PIPEPERI Register bits
    namespace pipeperi_bits {
        constexpr uint32_t Reserved = (9 << 3);  ///< These bits are read as 000000000. The write value should be 000000000.
        constexpr uint32_t IFIS = (1U << 12);  ///< Isochronous IN Buffer Flush
        constexpr uint32_t IITV = (3 << 0);  ///< Interval Error Detection IntervalSpecifies the interval error detection timing for the selected pipe in terms of frames, which is expressed as nth power of 2.
    }

    /// PIPE%sCTR Register bits
    namespace pipe%sctr_bits {
        constexpr uint32_t BSTS = (1U << 15);  ///< Buffer Status
        constexpr uint32_t Reserved = (3 << 2);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t ACLRM = (1U << 9);  ///< Auto Buffer Clear Mode
        constexpr uint32_t SQCLR = (1U << 8);  ///< Sequence Toggle Bit Clear
        constexpr uint32_t SQSET = (1U << 7);  ///< Sequence Toggle Bit Set
        constexpr uint32_t SQMON = (1U << 6);  ///< Sequence Toggle Bit Confirmation
        constexpr uint32_t PBUSY = (1U << 5);  ///< Pipe Busy
        constexpr uint32_t PID = (2 << 0);  ///< Response PID
    }

    /// PIPE%sTRE Register bits
    namespace pipe%stre_bits {
        constexpr uint32_t Reserved = (8 << 0);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t TRENB = (1U << 9);  ///< Transaction Counter Enable
        constexpr uint32_t TRCLR = (1U << 8);  ///< Transaction Counter Clear
    }

    /// PIPE%sTRN Register bits
    namespace pipe%strn_bits {
        constexpr uint32_t TRNCNT = (16 << 0);  ///< Transaction Counter
    }

    /// DEVADD%s Register bits
    namespace devadd%s_bits {
        constexpr uint32_t Reserved = (6 << 0);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t USBSPD = (2 << 6);  ///< Transfer Speed of Communication Target Device
    }

    /// USBMC Register bits
    namespace usbmc_bits {
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 1. The write value should be 1.
        constexpr uint32_t VDCEN = (1U << 7);  ///< USB Regulator On/Off Control
        constexpr uint32_t VDDUSBE = (1U << 0);  ///< USB Reference Power Supply Circuit On/Off Control
    }

    /// USBBCCTRL0 Register bits
    namespace usbbcctrl0_bits {
        constexpr uint32_t Reserved = (1U << 6);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PDDETSTS0 = (1U << 9);  ///< D+ Pin 0.6 V Input Detection Status
        constexpr uint32_t CHGDETSTS0 = (1U << 8);  ///< D- Pin 0.6 V Input Detection Status
        constexpr uint32_t BATCHGE0 = (1U << 7);  ///< BC (Battery Charger) Function Ch0 General Enable Control
        constexpr uint32_t VDMSRCE0 = (1U << 5);  ///< D- Pin VDMSRC (0.6 V) Output Control
        constexpr uint32_t IDPSINKE0 = (1U << 4);  ///< D+ Pin 0.6 V Input Detection (Comparator and Sink) Control
        constexpr uint32_t VDPSRCE0 = (1U << 3);  ///< D+ Pin VDPSRC (0.6 V) Output Control
        constexpr uint32_t IDMSINKE0 = (1U << 2);  ///< D- Pin 0.6 V Input Detection (Comparator and Sink) Control
        constexpr uint32_t IDPSRCE0 = (1U << 1);  ///< D+ Pin IDPSRC Output Control
        constexpr uint32_t RPDME0 = (1U << 0);  ///< D- Pin Pull-Down Control
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT0_BASE = 0x40040000;
    constexpr uint32_t PORT1_BASE = 0x40040020;
    constexpr uint32_t PORT2_BASE = 0x40040040;
    constexpr uint32_t PORT3_BASE = 0x40040060;
    constexpr uint32_t PORT4_BASE = 0x40040080;
    constexpr uint32_t PORT5_BASE = 0x400400A0;
    constexpr uint32_t PORT6_BASE = 0x400400C0;
    constexpr uint32_t PORT7_BASE = 0x400400E0;
    constexpr uint32_t PORT8_BASE = 0x40040100;
    constexpr uint32_t PORT9_BASE = 0x40040120;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCNTR1;  ///< Offset: 0x00 - Port Control Register 1
        volatile uint32_t PODR;  ///< Offset: 0x00 - Output data register
        volatile uint32_t PDR;  ///< Offset: 0x02 - Data direction register
        volatile uint32_t PCNTR2;  ///< Offset: 0x04 - Port Control Register 2
        volatile uint32_t PIDR;  ///< Offset: 0x06 - Input data register
        volatile uint32_t PCNTR3;  ///< Offset: 0x08 - Port Control Register 3
        volatile uint32_t PORR;  ///< Offset: 0x08 - Output reset register
        volatile uint32_t POSR;  ///< Offset: 0x0A - Output set register
    };

    /// Peripheral instances
    inline Registers* PORT0 = reinterpret_cast<Registers*>(PORT0_BASE);
    inline Registers* PORT1 = reinterpret_cast<Registers*>(PORT1_BASE);
    inline Registers* PORT2 = reinterpret_cast<Registers*>(PORT2_BASE);
    inline Registers* PORT3 = reinterpret_cast<Registers*>(PORT3_BASE);
    inline Registers* PORT4 = reinterpret_cast<Registers*>(PORT4_BASE);
    inline Registers* PORT5 = reinterpret_cast<Registers*>(PORT5_BASE);
    inline Registers* PORT6 = reinterpret_cast<Registers*>(PORT6_BASE);
    inline Registers* PORT7 = reinterpret_cast<Registers*>(PORT7_BASE);
    inline Registers* PORT8 = reinterpret_cast<Registers*>(PORT8_BASE);
    inline Registers* PORT9 = reinterpret_cast<Registers*>(PORT9_BASE);

    // Bit definitions
    /// PCNTR1 Register bits
    namespace pcntr1_bits {
        constexpr uint32_t PODR = (16 << 16);  ///< Pmn Output Data
        constexpr uint32_t PDR = (16 << 0);  ///< Pmn Direction
    }

    /// PODR Register bits
    namespace podr_bits {
        constexpr uint32_t PODR = (16 << 0);  ///< Pmn Output Data
    }

    /// PDR Register bits
    namespace pdr_bits {
        constexpr uint32_t PDR = (16 << 0);  ///< Pmn Direction
    }

    /// PCNTR2 Register bits
    namespace pcntr2_bits {
        constexpr uint32_t EIDR = (16 << 16);  ///< Pmn Event Input Data
        constexpr uint32_t PIDR = (16 << 0);  ///< Pmn Input Data
    }

    /// PIDR Register bits
    namespace pidr_bits {
        constexpr uint32_t PIDR = (16 << 0);  ///< Pmn Input Data
    }

    /// PCNTR3 Register bits
    namespace pcntr3_bits {
        constexpr uint32_t PORR = (16 << 16);  ///< Pmn Output Reset
        constexpr uint32_t POSR = (16 << 0);  ///< Pmn Output Set
    }

    /// PORR Register bits
    namespace porr_bits {
        constexpr uint32_t PORR = (16 << 0);  ///< Pmn Output Reset
    }

    /// POSR Register bits
    namespace posr_bits {
        constexpr uint32_t POSR = (16 << 0);  ///< Pmn Output Set
    }

}

// ============================================================================
// PFS Peripheral
// ============================================================================

namespace pfs {
    /// Base addresses
    constexpr uint32_t PFS_BASE = 0x40040800;

    /// PFS Register structure
    struct Registers {
        volatile uint32_t P000PFS;  ///< Offset: 0x00 - P000 Pin Function Control Register
        volatile uint32_t P000PFS_HA;  ///< Offset: 0x02 - P000 Pin Function Control Register
        volatile uint32_t P000PFS_BY;  ///< Offset: 0x03 - P000 Pin Function Control Register
        volatile uint32_t P00%sPFS;  ///< Offset: 0x04 - P00%s Pin Function Control Register
        volatile uint32_t P00%sPFS_HA;  ///< Offset: 0x06 - P00%s Pin Function Control Register
        volatile uint32_t P00%sPFS_BY;  ///< Offset: 0x07 - P00%s Pin Function Control Register
        volatile uint32_t P0%sPFS;  ///< Offset: 0x28 - P0%s Pin Function Control Register
        volatile uint32_t P0%sPFS_HA;  ///< Offset: 0x2A - P0%s Pin Function Control Register
        volatile uint32_t P0%sPFS_BY;  ///< Offset: 0x2B - P0%s Pin Function Control Register
        volatile uint32_t P10%sPFS;  ///< Offset: 0x40 - P10%s Pin Function Control Register
        volatile uint32_t P10%sPFS_HA;  ///< Offset: 0x42 - P10%s Pin Function Control Register
        volatile uint32_t P10%sPFS_BY;  ///< Offset: 0x43 - P10%s Pin Function Control Register
        volatile uint32_t P108PFS;  ///< Offset: 0x60 - P108 Pin Function Control Register
        volatile uint32_t P108PFS_HA;  ///< Offset: 0x62 - P108 Pin Function Control Register
        volatile uint32_t P108PFS_BY;  ///< Offset: 0x63 - P108 Pin Function Control Register
        volatile uint32_t P109PFS;  ///< Offset: 0x64 - P109 Pin Function Control Register
        volatile uint32_t P109PFS_HA;  ///< Offset: 0x66 - P109 Pin Function Control Register
        volatile uint32_t P109PFS_BY;  ///< Offset: 0x67 - P109 Pin Function Control Register
        volatile uint32_t P110PFS;  ///< Offset: 0x68 - P110 Pin Function Control Register
        volatile uint32_t P110PFS_HA;  ///< Offset: 0x6A - P110 Pin Function Control Register
        volatile uint32_t P110PFS_BY;  ///< Offset: 0x6B - P110 Pin Function Control Register
        volatile uint32_t P1%sPFS;  ///< Offset: 0x6C - P1%s Pin Function Control Register
        volatile uint32_t P1%sPFS_HA;  ///< Offset: 0x6E - P1%s Pin Function Control Register
        volatile uint32_t P1%sPFS_BY;  ///< Offset: 0x6F - P1%s Pin Function Control Register
        volatile uint32_t P200PFS;  ///< Offset: 0x80 - P200 Pin Function Control Register
        volatile uint32_t P200PFS_HA;  ///< Offset: 0x82 - P200 Pin Function Control Register
        volatile uint32_t P200PFS_BY;  ///< Offset: 0x83 - P200 Pin Function Control Register
        volatile uint32_t P201PFS;  ///< Offset: 0x84 - P201 Pin Function Control Register
        volatile uint32_t P201PFS_HA;  ///< Offset: 0x86 - P201 Pin Function Control Register
        volatile uint32_t P201PFS_BY;  ///< Offset: 0x87 - P201 Pin Function Control Register
        volatile uint32_t P20%sPFS;  ///< Offset: 0x88 - P20%s Pin Function Control Register
        volatile uint32_t P20%sPFS_HA;  ///< Offset: 0x8A - P20%s Pin Function Control Register
        volatile uint32_t P20%sPFS_BY;  ///< Offset: 0x8B - P20%s Pin Function Control Register
        volatile uint32_t P2%sPFS;  ///< Offset: 0xB0 - P2%s Pin Function Control Register
        volatile uint32_t P2%sPFS_HA;  ///< Offset: 0xB2 - P2%s Pin Function Control Register
        volatile uint32_t P2%sPFS_BY;  ///< Offset: 0xB3 - P2%s Pin Function Control Register
        volatile uint32_t P300PFS;  ///< Offset: 0xC0 - P300 Pin Function Control Register
        volatile uint32_t P300PFS_HA;  ///< Offset: 0xC2 - P300 Pin Function Control Register
        volatile uint32_t P300PFS_BY;  ///< Offset: 0xC3 - P300 Pin Function Control Register
        volatile uint32_t P30%sPFS;  ///< Offset: 0xC4 - P30%s Pin Function Control Register
        volatile uint32_t P30%sPFS_HA;  ///< Offset: 0xC6 - P30%s Pin Function Control Register
        volatile uint32_t P30%sPFS_BY;  ///< Offset: 0xC7 - P30%s Pin Function Control Register
        volatile uint32_t P3%sPFS;  ///< Offset: 0xE8 - P3%s Pin Function Control Register
        volatile uint32_t P3%sPFS_HA;  ///< Offset: 0xEA - P3%s Pin Function Control Register
        volatile uint32_t P3%sPFS_BY;  ///< Offset: 0xEB - P3%s Pin Function Control Register
        volatile uint32_t P40%sPFS;  ///< Offset: 0x100 - P40%s Pin Function Control Register
        volatile uint32_t P40%sPFS_HA;  ///< Offset: 0x102 - P40%s Pin Function Control Register
        volatile uint32_t P40%sPFS_BY;  ///< Offset: 0x103 - P40%s Pin Function Control Register
        volatile uint32_t P408PFS;  ///< Offset: 0x120 - P408 Pin Function Control Register
        volatile uint32_t P408PFS_HA;  ///< Offset: 0x122 - P408 Pin Function Control Register
        volatile uint32_t P408PFS_BY;  ///< Offset: 0x123 - P408 Pin Function Control Register
        volatile uint32_t P409PFS;  ///< Offset: 0x124 - P409 Pin Function Control Register
        volatile uint32_t P409PFS_HA;  ///< Offset: 0x126 - P409 Pin Function Control Register
        volatile uint32_t P409PFS_BY;  ///< Offset: 0x127 - P409 Pin Function Control Register
        volatile uint32_t P4%sPFS;  ///< Offset: 0x128 - P4%s Pin Function Control Register
        volatile uint32_t P4%sPFS_HA;  ///< Offset: 0x12A - P4%s Pin Function Control Register
        volatile uint32_t P4%sPFS_BY;  ///< Offset: 0x12B - P4%s Pin Function Control Register
        volatile uint32_t P50%sPFS;  ///< Offset: 0x140 - P50%s Pin Function Control Register
        volatile uint32_t P50%sPFS_HA;  ///< Offset: 0x142 - P50%s Pin Function Control Register
        volatile uint32_t P50%sPFS_BY;  ///< Offset: 0x143 - P50%s Pin Function Control Register
        volatile uint32_t P5%sPFS;  ///< Offset: 0x16C - P5%s Pin Function Control Register
        volatile uint32_t P5%sPFS_HA;  ///< Offset: 0x16E - P5%s Pin Function Control Register
        volatile uint32_t P5%sPFS_BY;  ///< Offset: 0x16F - P5%s Pin Function Control Register
        volatile uint32_t P60%sPFS;  ///< Offset: 0x1A0 - P60%s Pin Function Control Register
        volatile uint32_t P60%sPFS_HA;  ///< Offset: 0x1A2 - P60%s Pin Function Control Register
        volatile uint32_t P60%sPFS_BY;  ///< Offset: 0x1A3 - P60%s Pin Function Control Register
        volatile uint32_t P6%sPFS;  ///< Offset: 0x1A8 - P6%s Pin Function Control Register
        volatile uint32_t P6%sPFS_HA;  ///< Offset: 0x1AA - P6%s Pin Function Control Register
        volatile uint32_t P6%sPFS_BY;  ///< Offset: 0x1AB - P6%s Pin Function Control Register
        volatile uint32_t P70%sPFS;  ///< Offset: 0x1E0 - P70%s Pin Function Control Register
        volatile uint32_t P70%sPFS_HA;  ///< Offset: 0x1E2 - P70%s Pin Function Control Register
        volatile uint32_t P70%sPFS_BY;  ///< Offset: 0x1E3 - P70%s Pin Function Control Register
        volatile uint32_t P7%sPFS;  ///< Offset: 0x1E8 - P7%s Pin Function Control Register
        volatile uint32_t P7%sPFS_HA;  ///< Offset: 0x1EA - P7%s Pin Function Control Register
        volatile uint32_t P7%sPFS_BY;  ///< Offset: 0x1EB - P7%s Pin Function Control Register
        volatile uint32_t P80%sPFS;  ///< Offset: 0x200 - P80%s Pin Function Control Register
        volatile uint32_t P80%sPFS_HA;  ///< Offset: 0x202 - P80%s Pin Function Control Register
        volatile uint32_t P80%sPFS_BY;  ///< Offset: 0x203 - P80%s Pin Function Control Register
        volatile uint32_t P90%sPFS;  ///< Offset: 0x240 - P90%s Pin Function Control Register
        volatile uint32_t P90%sPFS_HA;  ///< Offset: 0x242 - P90%s Pin Function Control Register
        volatile uint32_t P90%sPFS_BY;  ///< Offset: 0x243 - P90%s Pin Function Control Register
        volatile uint32_t P9%sPFS;  ///< Offset: 0x278 - P9%s Pin Function Control Register
        volatile uint32_t P9%sPFS_HA;  ///< Offset: 0x27A - P9%s Pin Function Control Register
        volatile uint32_t P9%sPFS_BY;  ///< Offset: 0x27B - P9%s Pin Function Control Register
    };

    /// Peripheral instances
    inline Registers* PFS = reinterpret_cast<Registers*>(PFS_BASE);

    // Bit definitions
    /// P000PFS Register bits
    namespace p000pfs_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function SelectThese bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Failing
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (1U << 10);  ///< Port Drive Capability
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P000PFS_HA Register bits
    namespace p000pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Failing
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DSCR = (1U << 10);  ///< Port Drive Capability
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P000PFS_BY Register bits
    namespace p000pfs_by_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P108PFS Register bits
    namespace p108pfs_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function Select These bits select the peripheral function. For individual pin functions, see the setting table.
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Failing
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (1U << 10);  ///< Port Drive Capability
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P108PFS_HA Register bits
    namespace p108pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Failing
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DSCR = (1U << 10);  ///< Port Drive Capability
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P108PFS_BY Register bits
    namespace p108pfs_by_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P109PFS Register bits
    namespace p109pfs_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function Select These bits select the peripheral function. For individual pin functions, see the setting table.
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Failing
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (1U << 10);  ///< Port Drive Capability
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P109PFS_HA Register bits
    namespace p109pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Failing
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DSCR = (1U << 10);  ///< Port Drive Capability
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P109PFS_BY Register bits
    namespace p109pfs_by_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P201PFS Register bits
    namespace p201pfs_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function Select These bits select the peripheral function. For individual pin functions, see the setting table.
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (1U << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P201PFS_HA Register bits
    namespace p201pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DSCR = (1U << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P201PFS_BY Register bits
    namespace p201pfs_by_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P408PFS Register bits
    namespace p408pfs_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function Select These bits select the peripheral function. For individual pin functions, see the setting table.
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR1 = (1U << 11);  ///< Drive Strength Control Register
        constexpr uint32_t DSCR = (1U << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P408PFS_HA Register bits
    namespace p408pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR1 = (1U << 11);  ///< Drive Strength Control Register
        constexpr uint32_t DSCR = (1U << 10);  ///< Drive Strength Control Register
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P408PFS_BY Register bits
    namespace p408pfs_by_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

}

// ============================================================================
// PMISC Peripheral
// ============================================================================

namespace pmisc {
    /// Base addresses
    constexpr uint32_t PMISC_BASE = 0x40040D00;

    /// PMISC Register structure
    struct Registers {
        volatile uint32_t PWPR;  ///< Offset: 0x03 - Write-Protect Register
    };

    /// Peripheral instances
    inline Registers* PMISC = reinterpret_cast<Registers*>(PMISC_BASE);

    // Bit definitions
    /// PWPR Register bits
    namespace pwpr_bits {
        constexpr uint32_t B0WI = (1U << 7);  ///< PFSWE Bit Write Disable
        constexpr uint32_t PFSWE = (1U << 6);  ///< PFS Register Write Enable
        constexpr uint32_t Reserved = (6 << 0);  ///< These bits are read as 000000. The write value should be 000000.
    }

}

// ============================================================================
// ELC Peripheral
// ============================================================================

namespace elc {
    /// Base addresses
    constexpr uint32_t ELC_BASE = 0x40041000;

    /// ELC Register structure
    struct Registers {
        volatile uint32_t ELCR;  ///< Offset: 0x00 - Event Link Controller Register
        volatile uint32_t ELSEGR%s;  ///< Offset: 0x02 - Event Link Software Event Generation Register %s
        volatile uint32_t ELSR%s;  ///< Offset: 0x48 - Event Link Setting Register %s
        volatile uint32_t ELSR12;  ///< Offset: 0x40 - Event Link Setting Register 12
    };

    /// Peripheral instances
    inline Registers* ELC = reinterpret_cast<Registers*>(ELC_BASE);

    // Bit definitions
    /// ELCR Register bits
    namespace elcr_bits {
        constexpr uint32_t ELCON = (1U << 7);  ///< All Event Link Enable
        constexpr uint32_t Reserved = (7 << 0);  ///< These bits are read as 0000000. The write value should be 0000000.
    }

    /// ELSEGR%s Register bits
    namespace elsegr%s_bits {
        constexpr uint32_t WI = (1U << 7);  ///< ELSEGR Register Write Disable
        constexpr uint32_t WE = (1U << 6);  ///< SEG Bit Write Enable
        constexpr uint32_t Reserved = (5 << 1);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SEG = (1U << 0);  ///< Software Event Generation
    }

    /// ELSR%s Register bits
    namespace elsr%s_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t ELS = (8 << 0);  ///< Event Link Select
    }

    /// ELSR12 Register bits
    namespace elsr12_bits {
        constexpr uint32_t Reserved = (8 << 8);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t ELS = (8 << 0);  ///< Event Link Select
    }

}

// ============================================================================
// DOC Peripheral
// ============================================================================

namespace doc {
    /// Base addresses
    constexpr uint32_t DOC_BASE = 0x40054100;

    /// DOC Register structure
    struct Registers {
        volatile uint32_t DOCR;  ///< Offset: 0x00 - DOC Control Register
        volatile uint32_t DODIR;  ///< Offset: 0x02 - DOC Data Input Register
        volatile uint32_t DODSR;  ///< Offset: 0x04 - DOC Data Setting Register
    };

    /// Peripheral instances
    inline Registers* DOC = reinterpret_cast<Registers*>(DOC_BASE);

    // Bit definitions
    /// DOCR Register bits
    namespace docr_bits {
        constexpr uint32_t Reserved = (2 << 3);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t DOPCFCL = (1U << 6);  ///< DOPCF Clear
        constexpr uint32_t DOPCF = (1U << 5);  ///< Data Operation Circuit FlagIndicates the result of an operation.
        constexpr uint32_t DCSEL = (1U << 2);  ///< Detection Condition Select
        constexpr uint32_t OMS = (2 << 0);  ///< Operating Mode Select
    }

    /// DODIR Register bits
    namespace dodir_bits {
        constexpr uint32_t DODIR = (16 << 0);  ///< 16-bit read-write register in which 16-bit data for use in the operations are stored.
    }

    /// DODSR Register bits
    namespace dodsr_bits {
        constexpr uint32_t DODSR = (16 << 0);  ///< This register stores 16-bit data for use as a reference in data comparison mode. This register also stores the results of operations in data addition and data subtraction modes.
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40074000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRCCR0;  ///< Offset: 0x00 - CRC Control Register0
        volatile uint32_t CRCCR1;  ///< Offset: 0x01 - CRC Control Register1
        volatile uint32_t CRCDIR;  ///< Offset: 0x04 - CRC Data Input Register
        volatile uint32_t CRCDIR_BY;  ///< Offset: 0x04 - CRC Data Input Register (byte access)
        volatile uint32_t CRCDOR;  ///< Offset: 0x08 - CRC Data Output Register
        volatile uint32_t CRCDOR_HA;  ///< Offset: 0x08 - CRC Data Output Register (halfword access)
        volatile uint32_t CRCDOR_BY;  ///< Offset: 0x08 - CRC Data Output Register(byte access)
        volatile uint32_t CRCSAR;  ///< Offset: 0x0C - Snoop Address Register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRCCR0 Register bits
    namespace crccr0_bits {
        constexpr uint32_t DORCIR = (1U << 7);  ///< CRCDOR Register Clear
        constexpr uint32_t LMS = (1U << 6);  ///< CRC Calculation Switching
        constexpr uint32_t Reserved = (3 << 3);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t GPS = (3 << 0);  ///< CRC Generating Polynomial Switching
    }

    /// CRCCR1 Register bits
    namespace crccr1_bits {
        constexpr uint32_t CRCSEN = (1U << 7);  ///< Snoop enable bit
        constexpr uint32_t CRCSWR = (1U << 6);  ///< Snoop-on-write/read switch bit
        constexpr uint32_t Reserved = (6 << 0);  ///< These bits are read as 000000. The write value should be 000000.
    }

    /// CRCDIR Register bits
    namespace crcdir_bits {
        constexpr uint32_t CRCDIR = (32 << 0);  ///< Calculation input Data (Case of CRC-32, CRC-32C )
    }

    /// CRCDIR_BY Register bits
    namespace crcdir_by_bits {
        constexpr uint32_t CRCDIR_BY = (8 << 0);  ///< Calculation input Data ( Case of CRC-8, CRC-16 or CRC-CCITT )
    }

    /// CRCDOR Register bits
    namespace crcdor_bits {
        constexpr uint32_t CRCDOR = (32 << 0);  ///< Calculation output Data (Case of CRC-32, CRC-32C )
    }

    /// CRCDOR_HA Register bits
    namespace crcdor_ha_bits {
        constexpr uint32_t CRCDOR_HA = (16 << 0);  ///< Calculation output Data (Case of CRC-16 or CRC-CCITT )
    }

    /// CRCDOR_BY Register bits
    namespace crcdor_by_bits {
        constexpr uint32_t CRCDOR_BY = (8 << 0);  ///< Calculation output Data (Case of CRC-8 )
    }

    /// CRCSAR Register bits
    namespace crcsar_bits {
        constexpr uint32_t Reserved = (2 << 14);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t CRCSA = (14 << 0);  ///< snoop address bitSet the I/O register address to snoop
    }

}

// ============================================================================
// CAC Peripheral
// ============================================================================

namespace cac {
    /// Base addresses
    constexpr uint32_t CAC_BASE = 0x40044600;

    /// CAC Register structure
    struct Registers {
        volatile uint32_t CACR0;  ///< Offset: 0x00 - CAC Control Register 0
        volatile uint32_t CACR1;  ///< Offset: 0x01 - CAC Control Register 1
        volatile uint32_t CACR2;  ///< Offset: 0x02 - CAC Control Register 2
        volatile uint32_t CAICR;  ///< Offset: 0x03 - CAC Interrupt Control Register
        volatile uint32_t CASTR;  ///< Offset: 0x04 - CAC Status Register
        volatile uint32_t CAULVR;  ///< Offset: 0x06 - CAC Upper-Limit Value Setting Register
        volatile uint32_t CALLVR;  ///< Offset: 0x08 - CAC Lower-Limit Value Setting Register
        volatile uint32_t CACNTBR;  ///< Offset: 0x0A - CAC Counter Buffer Register
    };

    /// Peripheral instances
    inline Registers* CAC = reinterpret_cast<Registers*>(CAC_BASE);

    // Bit definitions
    /// CACR0 Register bits
    namespace cacr0_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CFME = (1U << 0);  ///< Clock Frequency Measurement Enable.
    }

    /// CACR1 Register bits
    namespace cacr1_bits {
        constexpr uint32_t EDGES = (2 << 6);  ///< Valid Edge Select
        constexpr uint32_t TCSS = (2 << 4);  ///< Measurement Target Clock Frequency Division Ratio Select
        constexpr uint32_t FMCS = (3 << 1);  ///< Measurement Target Clock Select
        constexpr uint32_t CACREFE = (1U << 0);  ///< CACREF Pin Input Enable
    }

    /// CACR2 Register bits
    namespace cacr2_bits {
        constexpr uint32_t DFS = (2 << 6);  ///< Digital Filter Selection
        constexpr uint32_t RCDS = (2 << 4);  ///< Measurement Reference Clock Frequency Division Ratio Select
        constexpr uint32_t RSCS = (3 << 1);  ///< Measurement Reference Clock Select
        constexpr uint32_t RPS = (1U << 0);  ///< Reference Signal Select
    }

    /// CAICR Register bits
    namespace caicr_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t OVFFCL = (1U << 6);  ///< OVFF Clear
        constexpr uint32_t MENDFCL = (1U << 5);  ///< MENDF Clear
        constexpr uint32_t FERRFCL = (1U << 4);  ///< FERRF Clear
        constexpr uint32_t OVFIE = (1U << 2);  ///< Overflow Interrupt Request Enable
        constexpr uint32_t MENDIE = (1U << 1);  ///< Measurement End Interrupt Request Enable
        constexpr uint32_t FERRIE = (1U << 0);  ///< Frequency Error Interrupt Request Enable
    }

    /// CASTR Register bits
    namespace castr_bits {
        constexpr uint32_t OVFF = (1U << 2);  ///< Counter Overflow Flag
        constexpr uint32_t MENDF = (1U << 1);  ///< Measurement End Flag
        constexpr uint32_t FERRF = (1U << 0);  ///< Frequency Error Flag
    }

    /// CAULVR Register bits
    namespace caulvr_bits {
        constexpr uint32_t CAULVR = (16 << 0);  ///< CAULVR is a 16-bit readable/writable register that stores the upper-limit value of the frequency.
    }

    /// CALLVR Register bits
    namespace callvr_bits {
        constexpr uint32_t CALLVR = (16 << 0);  ///< CALLVR is a 16-bit readable/writable register that stores the lower-limit value of the frequency.
    }

    /// CACNTBR Register bits
    namespace cacntbr_bits {
        constexpr uint32_t CACNTBR = (16 << 0);  ///< CACNTBR is a 16-bit read-only register that retains the counter value at the time a valid reference signal edge is input
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC8_BASE = 0x4009E000;
    constexpr uint32_t DAC12_BASE = 0x4005E000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DACS%s;  ///< Offset: 0x00 - D/A Conversion Value Setting Register %s
        volatile uint32_t DAM;  ///< Offset: 0x03 - D/A Converter Mode Register
    };

    /// Peripheral instances
    inline Registers* DAC8 = reinterpret_cast<Registers*>(DAC8_BASE);
    inline Registers* DAC12 = reinterpret_cast<Registers*>(DAC12_BASE);

    // Bit definitions
    /// DACS%s Register bits
    namespace dacs%s_bits {
        constexpr uint32_t DACS = (8 << 0);  ///< DACS D/A conversion store data note: When 8-bit D/A Converter output is selected as the reference input for the ACMPLP in the COMPSEL1 register, and ACMPLP operation is enabled (COMPMDR.CnENB = 1), changing the DACS[7:0] bits for the channel in use isprohibited.
    }

    /// DAM Register bits
    namespace dam_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t DACE1 = (1U << 5);  ///< D/A Operation Enable 1
        constexpr uint32_t DACE0 = (1U << 4);  ///< D/A Operation Enable 0
    }

}

// ============================================================================
// CTSU Peripheral
// ============================================================================

namespace ctsu {
    /// Base addresses
    constexpr uint32_t CTSU_BASE = 0x40081000;

    /// CTSU Register structure
    struct Registers {
        volatile uint32_t CTSUCR0;  ///< Offset: 0x00 - CTSU Control Register 0
        volatile uint32_t CTSUCR1;  ///< Offset: 0x01 - CTSU Control Register 1
        volatile uint32_t CTSUSDPRS;  ///< Offset: 0x02 - CTSU Synchronous Noise Reduction Setting Register
        volatile uint32_t CTSUSST;  ///< Offset: 0x03 - CTSU Sensor Stabilization Wait Control Register
        volatile uint32_t CTSUMCH0;  ///< Offset: 0x04 - CTSU Measurement Channel Register 0
        volatile uint32_t CTSUMCH1;  ///< Offset: 0x05 - CTSU Measurement Channel Register 1
        volatile uint32_t CTSUCHAC0;  ///< Offset: 0x06 - CTSU Channel Enable Control Register 0
        volatile uint32_t CTSUCHAC1;  ///< Offset: 0x07 - CTSU Channel Enable Control Register 1
        volatile uint32_t CTSUCHAC2;  ///< Offset: 0x08 - CTSU Channel Enable Control Register 2
        volatile uint32_t CTSUCHAC3;  ///< Offset: 0x09 - CTSU Channel Enable Control Register 3
        volatile uint32_t CTSUCHAC4;  ///< Offset: 0x0A - CTSU Channel Enable Control Register 4
        volatile uint32_t CTSUCHTRC0;  ///< Offset: 0x0B - CTSU Channel Transmit/Receive Control Register 0
        volatile uint32_t CTSUCHTRC1;  ///< Offset: 0x0C - CTSU Channel Transmit/Receive Control Register 1
        volatile uint32_t CTSUCHTRC2;  ///< Offset: 0x0D - CTSU Channel Transmit/Receive Control Register 3
        volatile uint32_t CTSUCHTRC3;  ///< Offset: 0x0E - CTSU Channel Transmit/Receive Control Register 3
        volatile uint32_t CTSUCHTRC4;  ///< Offset: 0x0F - CTSU Channel Transmit/Receive Control Register 4
        volatile uint32_t CTSUDCLKC;  ///< Offset: 0x10 - CTSU High-Pass Noise Reduction Control Register
        volatile uint32_t CTSUST;  ///< Offset: 0x11 - CTSU Status Register
        volatile uint32_t CTSUSSC;  ///< Offset: 0x12 - CTSU High-Pass Noise Reduction Spectrum Diffusion...
        volatile uint32_t CTSUSO0;  ///< Offset: 0x14 - CTSU Sensor Offset Register 0
        volatile uint32_t CTSUSO1;  ///< Offset: 0x16 - CTSU Sensor Offset Register 1
        volatile uint32_t CTSUSC;  ///< Offset: 0x18 - CTSU Sensor Counter
        volatile uint32_t CTSURC;  ///< Offset: 0x1A - CTSU Reference Counter
        volatile uint32_t CTSUERRS;  ///< Offset: 0x1C - CTSU Error Status Register
    };

    /// Peripheral instances
    inline Registers* CTSU = reinterpret_cast<Registers*>(CTSU_BASE);

    // Bit definitions
    /// CTSUCR0 Register bits
    namespace ctsucr0_bits {
        constexpr uint32_t CTSUINIT = (1U << 4);  ///< CTSU Control Block Initialization
        constexpr uint32_t CTSUIOC = (1U << 3);  ///< CTSU Transmit Pin Control
        constexpr uint32_t CTSUSNZ = (1U << 2);  ///< CTSU Wait State Power-Saving Enable
        constexpr uint32_t CTSUCAP = (1U << 1);  ///< CTSU Measurement Operation Start Trigger Select
        constexpr uint32_t CTSUSTRT = (1U << 0);  ///< CTSU Measurement Operation Start
    }

    /// CTSUCR1 Register bits
    namespace ctsucr1_bits {
        constexpr uint32_t CTSUMD = (2 << 6);  ///< CTSU Measurement Mode Select
        constexpr uint32_t CTSUCLK = (2 << 4);  ///< CTSU Operating Clock Select
        constexpr uint32_t CTSUATUNE1 = (1U << 3);  ///< CTSU Power Supply Capacity Adjustment
        constexpr uint32_t CTSUATUNE0 = (1U << 2);  ///< CTSU Power Supply Operating Mode Setting
        constexpr uint32_t CTSUCSW = (1U << 1);  ///< CTSU LPF Capacitance Charging Control
        constexpr uint32_t CTSUPON = (1U << 0);  ///< CTSU Power Supply Enable
    }

    /// CTSUSDPRS Register bits
    namespace ctsusdprs_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CTSUSOFF = (1U << 6);  ///< CTSU High-Pass Noise Reduction Function Off Setting
        constexpr uint32_t CTSUPRMODE = (2 << 4);  ///< CTSU Base Period and Pulse Count Setting
        constexpr uint32_t CTSUPRRATIO = (4 << 0);  ///< CTSU Measurement Time and Pulse Count AdjustmentRecommended setting: 3 (0011b)
    }

    /// CTSUSST Register bits
    namespace ctsusst_bits {
        constexpr uint32_t CTSUSST = (8 << 0);  ///< CTSU Sensor Stabilization Wait ControlNOTE: The value of these bits should be fixed to 00010000b.
    }

    /// CTSUMCH0 Register bits
    namespace ctsumch0_bits {
        constexpr uint32_t Reserved = (2 << 6);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t CTSUMCH0 = (6 << 0);  ///< CTSU Measurement Channel 0.Note1: Writing to these bits is only enabled in self-capacitance single-scan mode (CTSUCR1.CTSUMD[1:0] bits = 00b).Note2: If the value of CTSUMCH0 was set to b'111111 in mode other than self-capacitor single scan mode, the measurement is stopped.
    }

    /// CTSUMCH1 Register bits
    namespace ctsumch1_bits {
        constexpr uint32_t Reserved = (2 << 6);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t CTSUMCH1 = (6 << 0);  ///< CTSU Measurement Channel 1Note1: If the value of CTSUMCH1 was set to b'111111, the measurement is stopped.
    }

    /// CTSUCHAC0 Register bits
    namespace ctsuchac0_bits {
        constexpr uint32_t CTSUCHAC0 = (8 << 0);  ///< CTSU Channel Enable Control 0.0: Not measurement target1: Measurement targetNote: CTSUCHAC0[0] corresponds to TS00 and CTSUCHAC0[7] corresponds to TS07. but the write value of CTSUCHAC0[2] should be 0.
    }

    /// CTSUCHAC1 Register bits
    namespace ctsuchac1_bits {
        constexpr uint32_t CTSUCHAC1 = (8 << 0);  ///< CTSU Channel Enable Control 1.0: Not measurement target1: Measurement targetNote: CTSUCHAC1[0] corresponds to TS08 and CTSUCHAC1[7] corresponds to TS15.
    }

    /// CTSUCHAC2 Register bits
    namespace ctsuchac2_bits {
        constexpr uint32_t CTSUCHAC2 = (8 << 0);  ///< CTSU Channel Enable Control 2.0: Not measurement target1: Measurement targetNote: CTSUCHAC2[0] corresponds to TS16 and CTSUCHAC2[7] corresponds to TS23.
    }

    /// CTSUCHAC3 Register bits
    namespace ctsuchac3_bits {
        constexpr uint32_t CTSUCHAC3 = (8 << 0);  ///< CTSU Channel Enable Control 3.0: Not measurement target1: Measurement targetNote: CTSUCHAC3[0] corresponds to TS24 and CTSUCHAC3[7] corresponds to TS31.
    }

    /// CTSUCHAC4 Register bits
    namespace ctsuchac4_bits {
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t CTSUCHAC4 = (4 << 0);  ///< CTSU Channel Enable Control 4.0: Not measurement target1: Measurement targetNote: CTSUCHAC4[0] corresponds to TS32 and CTSUCHAC4[3] corresponds to TS35. but the write value of CTSUCHAC0[4],CTSUCHAC4[5],CTSUCHAC4[6],CTSUCHAC4[7] should be 0.
    }

    /// CTSUCHTRC0 Register bits
    namespace ctsuchtrc0_bits {
        constexpr uint32_t CTSUCHTRC0 = (8 << 0);  ///< CTSU Channel Transmit/Receive Control 0
    }

    /// CTSUCHTRC1 Register bits
    namespace ctsuchtrc1_bits {
        constexpr uint32_t CTSUCHTRC1 = (8 << 0);  ///< CTSU Channel Transmit/Receive Control 1
    }

    /// CTSUCHTRC2 Register bits
    namespace ctsuchtrc2_bits {
        constexpr uint32_t CTSUCHTRC2 = (8 << 0);  ///< CTSU Channel Transmit/Receive Control 2
    }

    /// CTSUCHTRC3 Register bits
    namespace ctsuchtrc3_bits {
        constexpr uint32_t CTSUCHTRC3 = (8 << 0);  ///< CTSU Channel Transmit/Receive Control 3
    }

    /// CTSUCHTRC4 Register bits
    namespace ctsuchtrc4_bits {
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t CTSUCHAC4 = (4 << 0);  ///< CTSU Channel Transmit/Receive Control 4
    }

    /// CTSUDCLKC Register bits
    namespace ctsudclkc_bits {
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t CTSUSSCNT = (2 << 4);  ///< CTSU Diffusion Clock Mode ControlNOTE: This bit should be set to 11b.
        constexpr uint32_t CTSUSSMOD = (2 << 0);  ///< CTSU Diffusion Clock Mode SelectNOTE: This bit should be set to 00b.
    }

    /// CTSUST Register bits
    namespace ctsust_bits {
        constexpr uint32_t CTSUPS = (1U << 7);  ///< CTSU Mutual Capacitance Status Flag
        constexpr uint32_t CTSUROVF = (1U << 6);  ///< CTSU Reference Counter Overflow Flag
        constexpr uint32_t CTSUSOVF = (1U << 5);  ///< CTSU Sensor Counter Overflow Flag
        constexpr uint32_t CTSUDTSR = (1U << 4);  ///< CTSU Data Transfer Status Flag
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CTSUSTC = (3 << 0);  ///< CTSU Measurement Status Counter
    }

    /// CTSUSSC Register bits
    namespace ctsussc_bits {
        constexpr uint32_t Reserved = (8 << 0);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t CTSUSSDIV = (4 << 8);  ///< CTSU Spectrum Diffusion Frequency Division Setting
    }

    /// CTSUSO0 Register bits
    namespace ctsuso0_bits {
        constexpr uint32_t CTSUSNUM = (6 << 10);  ///< CTSU Measurement Count Setting
        constexpr uint32_t CTSUSO = (10 << 0);  ///< CTSU Sensor Offset AdjustmentCurrent offset amount is CTSUSO ( 0 to 1023 )
    }

    /// CTSUSO1 Register bits
    namespace ctsuso1_bits {
        constexpr uint32_t Reserved = (1U << 15);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CTSUICOG = (2 << 13);  ///< CTSU ICO Gain Adjustment
        constexpr uint32_t CTSUSDPA = (5 << 8);  ///< CTSU Base Clock SettingOperating clock divided by ( CTSUSDPA + 1 ) x 2
        constexpr uint32_t CTSURICOA = (8 << 0);  ///< CTSU Reference ICO Current AdjustmentCurrent offset amount is CTSUSO ( 0 to 255 )
    }

    /// CTSUSC Register bits
    namespace ctsusc_bits {
        constexpr uint32_t CTSUSC = (16 << 0);  ///< CTSU Sensor CounterThese bits indicate the measurement result of the CTSU. These bits indicate FFFFh when an overflow occurs.
    }

    /// CTSURC Register bits
    namespace ctsurc_bits {
        constexpr uint32_t CTSURC = (16 << 0);  ///< CTSU Reference CounterThese bits indicate the measurement result of the reference ICO.These bits indicate FFFFh when an overflow occurs.
    }

    /// CTSUERRS Register bits
    namespace ctsuerrs_bits {
        constexpr uint32_t CTSUICOMP = (1U << 15);  ///< TSCAP Voltage Error Monitor
        constexpr uint32_t Reserved = (15 << 0);  ///< These bits are read as 000000000000000.
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC140_BASE = 0x4005C000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADCSR;  ///< Offset: 0x00 - A/D Control Register
        volatile uint32_t ADANSA0;  ///< Offset: 0x04 - A/D Channel Select Register A0
        volatile uint32_t ADANSA1;  ///< Offset: 0x06 - A/D Channel Select Register A1
        volatile uint32_t ADADS0;  ///< Offset: 0x08 - A/D-Converted Value Addition/Average Channel Select Register 0
        volatile uint32_t ADADS1;  ///< Offset: 0x0A - A/D-Converted Value Addition/Average Channel Select Register 1
        volatile uint32_t ADADC;  ///< Offset: 0x0C - A/D-Converted Value Addition/Average Count Select Register
        volatile uint32_t ADCER;  ///< Offset: 0x0E - A/D Control Extended Register
        volatile uint32_t ADSTRGR;  ///< Offset: 0x10 - A/D Conversion Start Trigger Select Register
        volatile uint32_t ADEXICR;  ///< Offset: 0x12 - A/D Conversion Extended Input Control Register
        volatile uint32_t ADANSB0;  ///< Offset: 0x14 - A/D Channel Select Register B0
        volatile uint32_t ADANSB1;  ///< Offset: 0x16 - A/D Channel Select Register B1
        volatile uint32_t ADDBLDR;  ///< Offset: 0x18 - A/D Data Duplication Register
        volatile uint32_t ADTSDR;  ///< Offset: 0x1A - A/D Temperature Sensor Data Register
        volatile uint32_t ADOCDR;  ///< Offset: 0x1C - A/D Internal Reference Voltage Data Register
        volatile uint32_t ADRD;  ///< Offset: 0x1E - A/D Self-Diagnosis Data Register
        volatile uint32_t ADDR%s;  ///< Offset: 0x20 - A/D Data Register %s
        volatile uint32_t ADDISCR;  ///< Offset: 0x7A - A/D Disconnection Detection Control Register
        volatile uint32_t ADGSPCR;  ///< Offset: 0x80 - A/D Group Scan Priority Control Register
        volatile uint32_t ADDBLDRA;  ///< Offset: 0x84 - A/D Data Duplexing Register A
        volatile uint32_t ADDBLDRB;  ///< Offset: 0x86 - A/D Data Duplexing Register B
        volatile uint32_t ADHVREFCNT;  ///< Offset: 0x8A - A/D High-Potential/Low-Potential Reference Voltage...
        volatile uint32_t ADWINMON;  ///< Offset: 0x8C - A/D Compare Function Window A/B Status Monitor Register
        volatile uint32_t ADCMPCR;  ///< Offset: 0x90 - A/D Compare Function Control Register
        volatile uint32_t ADCMPANSER;  ///< Offset: 0x92 - A/D Compare Function Window A Extended Input Select Register
        volatile uint32_t ADCMPLER;  ///< Offset: 0x93 - A/D Compare Function Window A Extended Input Comparison...
        volatile uint32_t ADCMPANSR0;  ///< Offset: 0x94 - A/D Compare Function Window A Channel Select Register 0
        volatile uint32_t ADCMPANSR1;  ///< Offset: 0x96 - A/D Compare Function Window A Channel Select Register 1
        volatile uint32_t ADCMPLR0;  ///< Offset: 0x98 - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPLR1;  ///< Offset: 0x9A - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPDR0;  ///< Offset: 0x9C - A/D Compare Function Window A Lower-Side Level Setting Register
        volatile uint32_t ADCMPDR1;  ///< Offset: 0x9E - A/D Compare Function Window A Upper-Side Level Setting Register
        volatile uint32_t ADCMPSR0;  ///< Offset: 0xA0 - A/D Compare Function Window A Channel Status Register 0
        volatile uint32_t ADCMPSR1;  ///< Offset: 0xA2 - A/D Compare Function Window A Channel Status Register 1
        volatile uint32_t ADCMPSER;  ///< Offset: 0xA4 - A/D Compare Function Window A Extended Input Channel...
        volatile uint32_t ADCMPBNSR;  ///< Offset: 0xA6 - A/D Compare Function Window B Channel Selection Register
        volatile uint32_t ADWINLLB;  ///< Offset: 0xA8 - A/D Compare Function Window B Lower-Side Level Setting Register
        volatile uint32_t ADWINULB;  ///< Offset: 0xAA - A/D Compare Function Window B Upper-Side Level Setting Register
        volatile uint32_t ADCMPBSR;  ///< Offset: 0xAC - A/D Compare Function Window B Status Register
        volatile uint32_t ADSSTRL;  ///< Offset: 0xDD - A/D Sampling State Register L
        volatile uint32_t ADSSTRT;  ///< Offset: 0xDE - A/D Sampling State Register T
        volatile uint32_t ADSSTRO;  ///< Offset: 0xDF - A/D Sampling State Register O
        volatile uint32_t ADSSTR%s;  ///< Offset: 0xE0 - A/D Sampling State Register %s
    };

    /// Peripheral instances
    inline Registers* ADC140 = reinterpret_cast<Registers*>(ADC140_BASE);

    // Bit definitions
    /// ADCSR Register bits
    namespace adcsr_bits {
        constexpr uint32_t ADST = (1U << 15);  ///< A/D Conversion Start
        constexpr uint32_t ADCS = (2 << 13);  ///< Scan Mode Select
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t ADHSC = (1U << 10);  ///< A/D Conversion Operation Mode Select
        constexpr uint32_t TRGE = (1U << 9);  ///< Trigger Start Enable
        constexpr uint32_t EXTRG = (1U << 8);  ///< Trigger Select
        constexpr uint32_t DBLE = (1U << 7);  ///< Double Trigger Mode Select
        constexpr uint32_t GBADIE = (1U << 6);  ///< Group B Scan End Interrupt Enable
        constexpr uint32_t DBLANS = (5 << 0);  ///< Double Trigger Channel SelectThese bits select one analog input channel for double triggered operation. The setting is only effective while double trigger mode is selected.
    }

    /// ADANSA0 Register bits
    namespace adansa0_bits {
        constexpr uint32_t ANSA015 = (1U << 15);  ///< AN015 Select
        constexpr uint32_t ANSA014 = (1U << 14);  ///< AN014 Select
        constexpr uint32_t ANSA013 = (1U << 13);  ///< AN013 Select
        constexpr uint32_t ANSA012 = (1U << 12);  ///< AN012 Select
        constexpr uint32_t ANSA011 = (1U << 11);  ///< AN011 Select
        constexpr uint32_t ANSA010 = (1U << 10);  ///< AN010 Select
        constexpr uint32_t ANSA09 = (1U << 9);  ///< AN009 Select
        constexpr uint32_t ANSA08 = (1U << 8);  ///< AN008 Select
        constexpr uint32_t ANSA07 = (1U << 7);  ///< AN007 Select
        constexpr uint32_t ANSA06 = (1U << 6);  ///< AN006 Select
        constexpr uint32_t ANSA05 = (1U << 5);  ///< AN005 Select
        constexpr uint32_t ANSA04 = (1U << 4);  ///< AN004 Select
        constexpr uint32_t ANSA03 = (1U << 3);  ///< AN003 Select
        constexpr uint32_t ANSA02 = (1U << 2);  ///< AN002 Select
        constexpr uint32_t ANSA01 = (1U << 1);  ///< AN001 Select
        constexpr uint32_t ANSA00 = (1U << 0);  ///< AN000 Select
    }

    /// ADANSA1 Register bits
    namespace adansa1_bits {
        constexpr uint32_t Reserved = (4 << 12);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ANSA27 = (1U << 11);  ///< AN027 Select
        constexpr uint32_t ANSA26 = (1U << 10);  ///< AN026 Select
        constexpr uint32_t ANSA25 = (1U << 9);  ///< AN025 Select
        constexpr uint32_t ANSA24 = (1U << 8);  ///< AN024 Select
        constexpr uint32_t ANSA23 = (1U << 7);  ///< AN023 Select
        constexpr uint32_t ANSA22 = (1U << 6);  ///< AN022 Select
        constexpr uint32_t ANSA21 = (1U << 5);  ///< AN021 Select
        constexpr uint32_t ANSA20 = (1U << 4);  ///< AN020 Select
        constexpr uint32_t ANSA19 = (1U << 3);  ///< AN019 Select
        constexpr uint32_t ANSA18 = (1U << 2);  ///< AN018 Select
        constexpr uint32_t ANSA17 = (1U << 1);  ///< AN017 Select
        constexpr uint32_t ANSA16 = (1U << 0);  ///< AN016 Select
    }

    /// ADADS0 Register bits
    namespace adads0_bits {
        constexpr uint32_t ADS15 = (1U << 15);  ///< A/D-Converted Value Addition/Average Channel AN015 Select
        constexpr uint32_t ADS14 = (1U << 14);  ///< A/D-Converted Value Addition/Average Channel AN014 Select
        constexpr uint32_t ADS13 = (1U << 13);  ///< A/D-Converted Value Addition/Average Channel AN013 Select
        constexpr uint32_t ADS12 = (1U << 12);  ///< A/D-Converted Value Addition/Average Channel AN012 Select
        constexpr uint32_t ADS11 = (1U << 11);  ///< A/D-Converted Value Addition/Average Channel AN011 Select
        constexpr uint32_t ADS10 = (1U << 10);  ///< A/D-Converted Value Addition/Average Channel AN010 Select
        constexpr uint32_t ADS09 = (1U << 9);  ///< A/D-Converted Value Addition/Average Channel AN009 Select
        constexpr uint32_t ADS08 = (1U << 8);  ///< A/D-Converted Value Addition/Average Channel AN008 Select
        constexpr uint32_t ADS07 = (1U << 7);  ///< A/D-Converted Value Addition/Average Channel AN007 Select
        constexpr uint32_t ADS06 = (1U << 6);  ///< A/D-Converted Value Addition/Average Channel AN006 Select
        constexpr uint32_t ADS05 = (1U << 5);  ///< A/D-Converted Value Addition/Average Channel AN005 Select
        constexpr uint32_t ADS04 = (1U << 4);  ///< A/D-Converted Value Addition/Average Channel AN004 Select
        constexpr uint32_t ADS03 = (1U << 3);  ///< A/D-Converted Value Addition/Average Channel AN003 Select
        constexpr uint32_t ADS02 = (1U << 2);  ///< A/D-Converted Value Addition/Average Channel AN002 Select
        constexpr uint32_t ADS01 = (1U << 1);  ///< A/D-Converted Value Addition/Average Channel AN001 Select
        constexpr uint32_t ADS00 = (1U << 0);  ///< A/D-Converted Value Addition/Average Channel AN000 Select
    }

    /// ADADS1 Register bits
    namespace adads1_bits {
        constexpr uint32_t Reserved = (4 << 12);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ADS27 = (1U << 11);  ///< A/D-Converted Value Addition/Average Channel AN027 Select
        constexpr uint32_t ADS26 = (1U << 10);  ///< A/D-Converted Value Addition/Average Channel AN026 Select
        constexpr uint32_t ADS25 = (1U << 9);  ///< A/D-Converted Value Addition/Average Channel AN025 Select
        constexpr uint32_t ADS24 = (1U << 8);  ///< A/D-Converted Value Addition/Average Channel AN024 Select
        constexpr uint32_t ADS23 = (1U << 7);  ///< A/D-Converted Value Addition/Average Channel AN023 Select
        constexpr uint32_t ADS22 = (1U << 6);  ///< A/D-Converted Value Addition/Average Channel AN022 Select
        constexpr uint32_t ADS21 = (1U << 5);  ///< A/D-Converted Value Addition/Average Channel AN021 Select
        constexpr uint32_t ADS20 = (1U << 4);  ///< A/D-Converted Value Addition/Average Channel AN020 Select
        constexpr uint32_t ADS19 = (1U << 3);  ///< A/D-Converted Value Addition/Average Channel AN019 Select
        constexpr uint32_t ADS18 = (1U << 2);  ///< A/D-Converted Value Addition/Average Channel AN018 Select
        constexpr uint32_t ADS17 = (1U << 1);  ///< A/D-Converted Value Addition/Average Channel AN017 Select
        constexpr uint32_t ADS16 = (1U << 0);  ///< A/D-Converted Value Addition/Average Channel AN016 Select
    }

    /// ADADC Register bits
    namespace adadc_bits {
        constexpr uint32_t AVEE = (1U << 7);  ///< Average mode enable bit.Note: The AVEE bit converts twice, and only when converting it four times, is effective. Please do not set (ADADC.AVEE=1) to conversion (ADADC.ADC 2:0=010b) three times when you select the average mode.
        constexpr uint32_t Reserved = (4 << 3);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ADC = (3 << 0);  ///< Addition frequency selection bit.NOTE: AVEE bit is valid at the only setting of ADC[2:0] bits = 001b or 011b. When average mode is selected by setting the ADADC.AVEE bit to 1, do not set the addition count to three times (ADADC.ADC[2:0] = 010b)
    }

    /// ADCER Register bits
    namespace adcer_bits {
        constexpr uint32_t ADRFMT = (1U << 15);  ///< A/D Data Register Format Select
        constexpr uint32_t Reserved = (1U << 0);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DIAGM = (1U << 11);  ///< Self-Diagnosis Enable
        constexpr uint32_t DIAGLD = (1U << 10);  ///< Self-Diagnosis Mode Select
        constexpr uint32_t DIAGVAL = (2 << 8);  ///< Self-Diagnosis Conversion Voltage Select
        constexpr uint32_t ACE = (1U << 5);  ///< A/D Data Register Automatic Clearing Enable
        constexpr uint32_t ADPRC = (2 << 1);  ///< A/D Conversion Accuracy Specify
    }

    /// ADSTRGR Register bits
    namespace adstrgr_bits {
        constexpr uint32_t Reserved = (2 << 6);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t TRSA = (6 << 8);  ///< A/D Conversion Start Trigger SelectSelect the A/D conversion start trigger in single scan mode and continuous mode. In group scan mode, the A/D conversion start trigger for group A is selected.
        constexpr uint32_t TRSB = (6 << 0);  ///< A/D Conversion Start Trigger Select for Group BSelect the A/D conversion start trigger for group B in group scan mode.
    }

    /// ADEXICR Register bits
    namespace adexicr_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t OCSA = (1U << 9);  ///< Internal Reference Voltage A/D Conversion Select
        constexpr uint32_t TSSA = (1U << 8);  ///< Temperature Sensor Output A/D Conversion Select
        constexpr uint32_t OCSAD = (1U << 1);  ///< Internal Reference Voltage A/D converted Value Addition/Average Mode Select
        constexpr uint32_t TSSAD = (1U << 0);  ///< Temperature Sensor Output A/D converted Value Addition/Average Mode Select
    }

    /// ADANSB0 Register bits
    namespace adansb0_bits {
        constexpr uint32_t ANSB15 = (1U << 15);  ///< AN015 Select
        constexpr uint32_t ANSB14 = (1U << 14);  ///< AN014 Select
        constexpr uint32_t ANSB13 = (1U << 13);  ///< AN013 Select
        constexpr uint32_t ANSB12 = (1U << 12);  ///< AN012 Select
        constexpr uint32_t ANSB11 = (1U << 11);  ///< AN011 Select
        constexpr uint32_t ANSB10 = (1U << 10);  ///< AN010 Select
        constexpr uint32_t ANSB09 = (1U << 9);  ///< AN009 Select
        constexpr uint32_t ANSB08 = (1U << 8);  ///< AN008 Select
        constexpr uint32_t ANSB07 = (1U << 7);  ///< AN007 Select
        constexpr uint32_t ANSB06 = (1U << 6);  ///< AN006 Select
        constexpr uint32_t ANSB05 = (1U << 5);  ///< AN005 Select
        constexpr uint32_t ANSB04 = (1U << 4);  ///< AN004 Select
        constexpr uint32_t ANSB03 = (1U << 3);  ///< AN003 Select
        constexpr uint32_t ANSB02 = (1U << 2);  ///< AN002 Select
        constexpr uint32_t ANSB01 = (1U << 1);  ///< AN001 Select
        constexpr uint32_t ANSB00 = (1U << 0);  ///< AN000 Select
    }

    /// ADANSB1 Register bits
    namespace adansb1_bits {
        constexpr uint32_t Reserved = (4 << 12);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ANSB27 = (1U << 11);  ///< AN027 Select
        constexpr uint32_t ANSB26 = (1U << 10);  ///< AN026 Select
        constexpr uint32_t ANSB25 = (1U << 9);  ///< AN025 Select
        constexpr uint32_t ANSB24 = (1U << 8);  ///< AN024 Select
        constexpr uint32_t ANSB23 = (1U << 7);  ///< AN023 Select
        constexpr uint32_t ANSB22 = (1U << 6);  ///< AN022 Select
        constexpr uint32_t ANSB21 = (1U << 5);  ///< AN021 Select
        constexpr uint32_t ANSB20 = (1U << 4);  ///< AN020 Select
        constexpr uint32_t ANSB19 = (1U << 3);  ///< AN019 Select
        constexpr uint32_t ANSB18 = (1U << 2);  ///< AN018 Select
        constexpr uint32_t ANSB17 = (1U << 1);  ///< AN017 Select
        constexpr uint32_t ANSB16 = (1U << 0);  ///< AN016 Select
    }

    /// ADDBLDR Register bits
    namespace addbldr_bits {
        constexpr uint32_t ADDBLDR = (16 << 0);  ///< This is a 16-bit read-only register for storing the result of A/D conversion in response to the second trigger in double trigger mode.
    }

    /// ADTSDR Register bits
    namespace adtsdr_bits {
        constexpr uint32_t ADTSDR = (16 << 0);  ///< This is a 16-bit read-only register for storing the A/D conversion result of temperature sensor output.
    }

    /// ADOCDR Register bits
    namespace adocdr_bits {
        constexpr uint32_t ADOCDR = (16 << 0);  ///< This is a 16-bit read-only register for storing the A/D result of internal reference voltage.
    }

    /// ADRD Register bits
    namespace adrd_bits {
        constexpr uint32_t DIAGST = (2 << 14);  ///< Self-Diagnosis Status
        constexpr uint32_t AD = (14 << 0);  ///< A/D-converted value (right-justified)The format for data determine ADCER.ADRFMT and ADCER.ADPRC.
    }

    /// ADDR%s Register bits
    namespace addr%s_bits {
        constexpr uint32_t ADDR = (16 << 0);  ///< The ADDR register is a 16-bit read-only registers for storing the result of A/D conversion.
    }

    /// ADDISCR Register bits
    namespace addiscr_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t ADNDIS = (5 << 0);  ///< The charging time
    }

    /// ADGSPCR Register bits
    namespace adgspcr_bits {
        constexpr uint32_t GBRP = (1U << 15);  ///< Group B Single Scan Continuous Start(Enabled only when PGS = 1. Reserved when PGS = 0.)Note: When the GBRP bit has been set to 1, single scan is performed continuously for group B regardless of the setting of the GBRSCN bit.
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t GBRSCN = (1U << 1);  ///< Group B Restart Setting(Enabled only when PGS = 1. Reserved when PGS = 0.)
        constexpr uint32_t PGS = (1U << 0);  ///< Group A priority control setting bit.Note: When the PGS bit is to be set to 1, the ADCSR.ADCS[1:0] bits must be set to 01b (group scan mode). If the bits are set to any other values, proper operation is not guaranteed.
    }

    /// ADDBLDRA Register bits
    namespace addbldra_bits {
        constexpr uint32_t ADDBLDRA = (16 << 0);  ///< This register is a 16-bit read-only registers for storing the result of A/D conversion in response to the respective triggers during extended operation in double trigger mode.
    }

    /// ADDBLDRB Register bits
    namespace addbldrb_bits {
        constexpr uint32_t ADDBLDRB = (16 << 0);  ///< This register is a 16-bit read-only registers for storing the result of A/D conversion in response to the respective triggers during extended operation in double trigger mode.
    }

    /// ADHVREFCNT Register bits
    namespace adhvrefcnt_bits {
        constexpr uint32_t ADSLP = (1U << 7);  ///< Sleep
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t LVSEL = (3 << 2);  ///< Low-Potential Reference Voltage Select
        constexpr uint32_t CMPAB = (2 << 0);  ///< High-Potential Reference Voltage Select
    }

    /// ADWINMON Register bits
    namespace adwinmon_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000.
        constexpr uint32_t MONCMPB = (1U << 5);  ///< Comparison Result Monitor B
        constexpr uint32_t MONCMPA = (1U << 4);  ///< Comparison Result Monitor A
        constexpr uint32_t MONCOMB = (1U << 0);  ///< Combination result monitorThis bit indicates the combination result.This bit is valid when both window A operation and window B operation are enabled.
    }

    /// ADCMPCR Register bits
    namespace adcmpcr_bits {
        constexpr uint32_t CMPAIE = (1U << 15);  ///< Compare A Interrupt Enable
        constexpr uint32_t WCMPE = (1U << 14);  ///< Window Function Setting
        constexpr uint32_t CMPBIE = (1U << 13);  ///< Compare B Interrupt Enable
        constexpr uint32_t Reserved = (7 << 2);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPAE = (1U << 11);  ///< Compare Window A Operation Enable
        constexpr uint32_t CMPBE = (1U << 9);  ///< Compare Window B Operation Enable
        constexpr uint32_t CMPAB = (2 << 0);  ///< Window A/B Composite Conditions SettingNOTE: These bits are valid when both window A and window B are enabled (CMPAE = 1 and CMPBE = 1).
    }

    /// ADCMPANSER Register bits
    namespace adcmpanser_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t CMPOCA = (1U << 1);  ///< Internal reference voltage Compare selection bit.
        constexpr uint32_t CMPTSA = (1U << 0);  ///< Temperature sensor output Compare selection bit.
    }

    /// ADCMPLER Register bits
    namespace adcmpler_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t CMPLOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage ComparisonCondition Select
        constexpr uint32_t CMPLTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Comparison Condition Select
    }

    /// ADCMPANSR0 Register bits
    namespace adcmpansr0_bits {
        constexpr uint32_t CMPCHA15 = (1U << 15);  ///< AN015 Select
        constexpr uint32_t CMPCHA14 = (1U << 14);  ///< AN014 Select
        constexpr uint32_t CMPCHA13 = (1U << 13);  ///< AN013 Select
        constexpr uint32_t CMPCHA12 = (1U << 12);  ///< AN012 Select
        constexpr uint32_t CMPCHA11 = (1U << 11);  ///< AN011 Select
        constexpr uint32_t CMPCHA10 = (1U << 10);  ///< AN010 Select
        constexpr uint32_t CMPCHA09 = (1U << 9);  ///< AN009 Select
        constexpr uint32_t CMPCHA08 = (1U << 8);  ///< AN008 Select
        constexpr uint32_t CMPCHA07 = (1U << 7);  ///< AN007 Select
        constexpr uint32_t CMPCHA06 = (1U << 6);  ///< AN006 Select
        constexpr uint32_t CMPCHA05 = (1U << 5);  ///< AN005 Select
        constexpr uint32_t CMPCHA04 = (1U << 4);  ///< AN004 Select
        constexpr uint32_t CMPCHA03 = (1U << 3);  ///< AN003 Select
        constexpr uint32_t CMPCHA02 = (1U << 2);  ///< AN002 Select
        constexpr uint32_t CMPCHA01 = (1U << 1);  ///< AN001 Select
        constexpr uint32_t CMPCHA00 = (1U << 0);  ///< AN000 Select
    }

    /// ADCMPANSR1 Register bits
    namespace adcmpansr1_bits {
        constexpr uint32_t Reserved = (4 << 12);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t CMPCHA27 = (1U << 11);  ///< AN027 Select
        constexpr uint32_t CMPCHA26 = (1U << 10);  ///< AN026 Select
        constexpr uint32_t CMPCHA25 = (1U << 9);  ///< AN025 Select
        constexpr uint32_t CMPCHA24 = (1U << 8);  ///< AN024 Select
        constexpr uint32_t CMPCHA23 = (1U << 7);  ///< AN023 Select
        constexpr uint32_t CMPCHA22 = (1U << 6);  ///< AN022 Select
        constexpr uint32_t CMPCHA21 = (1U << 5);  ///< AN021 Select
        constexpr uint32_t CMPCHA20 = (1U << 4);  ///< AN020 Select
        constexpr uint32_t CMPCHA19 = (1U << 3);  ///< AN019 Select
        constexpr uint32_t CMPCHA18 = (1U << 2);  ///< AN018 Select
        constexpr uint32_t CMPCHA17 = (1U << 1);  ///< AN017 Select
        constexpr uint32_t CMPCHA16 = (1U << 0);  ///< AN016 Select
    }

    /// ADCMPLR0 Register bits
    namespace adcmplr0_bits {
        constexpr uint32_t CMPLCHA15 = (1U << 15);  ///< Comparison condition of AN015
        constexpr uint32_t CMPLCHA14 = (1U << 14);  ///< Comparison condition of AN014
        constexpr uint32_t CMPLCHA13 = (1U << 13);  ///< Comparison condition of AN013
        constexpr uint32_t CMPLCHA12 = (1U << 12);  ///< Comparison condition of AN012
        constexpr uint32_t CMPLCHA11 = (1U << 11);  ///< Comparison condition of AN011
        constexpr uint32_t CMPLCHA10 = (1U << 10);  ///< Comparison condition of AN010
        constexpr uint32_t CMPLCHA09 = (1U << 9);  ///< Comparison condition of AN009
        constexpr uint32_t CMPLCHA08 = (1U << 8);  ///< Comparison condition of AN008
        constexpr uint32_t CMPLCHA07 = (1U << 7);  ///< Comparison condition of AN007
        constexpr uint32_t CMPLCHA06 = (1U << 6);  ///< Comparison condition of AN006
        constexpr uint32_t CMPLCHA05 = (1U << 5);  ///< Comparison condition of AN005
        constexpr uint32_t CMPLCHA04 = (1U << 4);  ///< Comparison condition of AN004
        constexpr uint32_t CMPLCHA03 = (1U << 3);  ///< Comparison condition of AN003
        constexpr uint32_t CMPLCHA02 = (1U << 2);  ///< Comparison condition of AN002
        constexpr uint32_t CMPLCHA01 = (1U << 1);  ///< Comparison condition of AN001
        constexpr uint32_t CMPLCHA00 = (1U << 0);  ///< Comparison condition of AN000
    }

    /// ADCMPLR1 Register bits
    namespace adcmplr1_bits {
        constexpr uint32_t Reserved = (4 << 12);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t CMPLCHA27 = (1U << 11);  ///< Comparison condition of AN027
        constexpr uint32_t CMPLCHA26 = (1U << 10);  ///< Comparison condition of AN026
        constexpr uint32_t CMPLCHA25 = (1U << 9);  ///< Comparison condition of AN025
        constexpr uint32_t CMPLCHA24 = (1U << 8);  ///< Comparison condition of AN024
        constexpr uint32_t CMPLCHA23 = (1U << 7);  ///< Comparison condition of AN023
        constexpr uint32_t CMPLCHA22 = (1U << 6);  ///< Comparison condition of AN022
        constexpr uint32_t CMPLCHA21 = (1U << 5);  ///< Comparison condition of AN021
        constexpr uint32_t CMPLCHA20 = (1U << 4);  ///< Comparison condition of AN020
        constexpr uint32_t CMPLCHA19 = (1U << 3);  ///< Comparison condition of AN019
        constexpr uint32_t CMPLCHA18 = (1U << 2);  ///< Comparison condition of AN018
        constexpr uint32_t CMPLCHA17 = (1U << 1);  ///< Comparison condition of AN017
        constexpr uint32_t CMPLCHA16 = (1U << 0);  ///< Comparison condition of AN016
    }

    /// ADCMPDR0 Register bits
    namespace adcmpdr0_bits {
        constexpr uint32_t ADCMPDR0 = (16 << 0);  ///< The ADCMPDR0 register sets the reference data when the compare window A function is used. ADCMPDR0 sets the lower-side level of window A.
    }

    /// ADCMPDR1 Register bits
    namespace adcmpdr1_bits {
        constexpr uint32_t ADCMPDR1 = (16 << 0);  ///< The ADCMPDR1 register sets the reference data when the compare window A function is used. ADCMPDR1 sets the upper-side level of window A..
    }

    /// ADCMPSR0 Register bits
    namespace adcmpsr0_bits {
        constexpr uint32_t CMPSTCHA15 = (1U << 15);  ///< Compare window A flag of AN015
        constexpr uint32_t CMPSTCHA14 = (1U << 14);  ///< Compare window A flag of AN014
        constexpr uint32_t CMPSTCHA13 = (1U << 13);  ///< Compare window A flag of AN013
        constexpr uint32_t CMPSTCHA12 = (1U << 12);  ///< Compare window A flag of AN012
        constexpr uint32_t CMPSTCHA11 = (1U << 11);  ///< Compare window A flag of AN011
        constexpr uint32_t CMPSTCHA10 = (1U << 10);  ///< Compare window A flag of AN010
        constexpr uint32_t CMPSTCHA09 = (1U << 9);  ///< Compare window A flag of AN009
        constexpr uint32_t CMPSTCHA08 = (1U << 8);  ///< Compare window A flag of AN008
        constexpr uint32_t CMPSTCHA07 = (1U << 7);  ///< Compare window A flag of AN007
        constexpr uint32_t CMPSTCHA06 = (1U << 6);  ///< Compare window A flag of AN006
        constexpr uint32_t CMPSTCHA05 = (1U << 5);  ///< Compare window A flag of AN005
        constexpr uint32_t CMPSTCHA04 = (1U << 4);  ///< Compare window A flag of AN004
        constexpr uint32_t CMPSTCHA03 = (1U << 3);  ///< Compare window A flag of AN003
        constexpr uint32_t CMPSTCHA02 = (1U << 2);  ///< Compare window A flag of AN002
        constexpr uint32_t CMPSTCHA01 = (1U << 1);  ///< Compare window A flag of AN001
        constexpr uint32_t CMPSTCHA00 = (1U << 0);  ///< Compare window A flag of AN000
    }

    /// ADCMPSR1 Register bits
    namespace adcmpsr1_bits {
        constexpr uint32_t Reserved = (4 << 12);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t CMPSTCHA27 = (1U << 11);  ///< Compare window A flag of AN027
        constexpr uint32_t CMPSTCHA26 = (1U << 10);  ///< Compare window A flag of AN026
        constexpr uint32_t CMPSTCHA25 = (1U << 9);  ///< Compare window A flag of AN025
        constexpr uint32_t CMPSTCHA24 = (1U << 8);  ///< Compare window A flag of AN024
        constexpr uint32_t CMPSTCHA23 = (1U << 7);  ///< Compare window A flag of AN023
        constexpr uint32_t CMPSTCHA22 = (1U << 6);  ///< Compare window A flag of AN022
        constexpr uint32_t CMPSTCHA21 = (1U << 5);  ///< Compare window A flag of AN021
        constexpr uint32_t CMPSTCHA20 = (1U << 4);  ///< Compare window A flag of AN020
        constexpr uint32_t CMPSTCHA19 = (1U << 3);  ///< Compare window A flag of AN019
        constexpr uint32_t CMPSTCHA18 = (1U << 2);  ///< Compare window A flag of AN018
        constexpr uint32_t CMPSTCHA17 = (1U << 1);  ///< Compare window A flag of AN017
        constexpr uint32_t CMPSTCHA16 = (1U << 0);  ///< Compare window A flag of AN016
    }

    /// ADCMPSER Register bits
    namespace adcmpser_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t CMPSTOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage Compare Flag When window A operation is enabled (ADCMPCR.CMPAE = 1b), this bit indicates the temperature sensor output comparison result. When window A operation is disabled (ADCMPCR.CMPAE = 0b), comparison conditions for CMPSTTSA are not met any time.
        constexpr uint32_t CMPSTTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Compare Flag When window A operation is enabled (ADCMPCR.CMPAE = 1b), this bit indicates the temperature sensor output comparison result. When window A operation is disabled (ADCMPCR.CMPAE = 0b), comparison conditions for CMPSTTSA are not met any time.
    }

    /// ADCMPBNSR Register bits
    namespace adcmpbnsr_bits {
        constexpr uint32_t CMPLB = (1U << 7);  ///< Compare window B Compare condition setting bit.
        constexpr uint32_t Reserved = (1U << 6);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CMPCHB = (6 << 0);  ///< Compare window B channel selection bit.The channel that compares it on the condition of compare window B is selected.
    }

    /// ADWINLLB Register bits
    namespace adwinllb_bits {
        constexpr uint32_t ADWINLLB = (16 << 0);  ///< This register is used to compare A window function is used to set the lower level of the window B.
    }

    /// ADWINULB Register bits
    namespace adwinulb_bits {
        constexpr uint32_t ADWINULB = (16 << 0);  ///< This register is used to compare A window function is used to set the higher level of the window B.
    }

    /// ADCMPBSR Register bits
    namespace adcmpbsr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPSTB = (1U << 0);  ///< Compare window B flag.It is a status flag that shows the comparative result of CH (AN000-AN027, temperature sensor, and internal reference voltage) made the object of window B relation condition.
    }

    /// ADSSTRL Register bits
    namespace adsstrl_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting (AN016-AN027)
    }

    /// ADSSTRT Register bits
    namespace adsstrt_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting (temperature sensor output)
    }

    /// ADSSTRO Register bits
    namespace adsstro_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting (Internal reference voltage)
    }

    /// ADSSTR%s Register bits
    namespace adsstr%s_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling time setting
    }

}

// ============================================================================
// ACMPLP Peripheral
// ============================================================================

namespace acmplp {
    /// Base addresses
    constexpr uint32_t ACMPLP_BASE = 0x40085E00;

    /// ACMPLP Register structure
    struct Registers {
        volatile uint32_t COMPMDR;  ///< Offset: 0x00 - ACMPLP Mode Setting Register
        volatile uint32_t COMPFIR;  ///< Offset: 0x01 - ACMPLP Filter Control Register
        volatile uint32_t COMPOCR;  ///< Offset: 0x02 - ACMPLP Output Control Register
        volatile uint32_t COMPSEL0;  ///< Offset: 0x04 - Comparator Input Select Register
        volatile uint32_t COMPSEL1;  ///< Offset: 0x05 - Comparator Reference Voltage Select Register
    };

    /// Peripheral instances
    inline Registers* ACMPLP = reinterpret_cast<Registers*>(ACMPLP_BASE);

    // Bit definitions
    /// COMPMDR Register bits
    namespace compmdr_bits {
        constexpr uint32_t C1MON = (1U << 7);  ///< ACMPLP1 Monitor Flag
        constexpr uint32_t C1VRF = (1U << 6);  ///< ACMPLP1 Reference Voltage Selection
        constexpr uint32_t C1WDE = (1U << 5);  ///< ACMPLP1 Window Function Mode Enable
        constexpr uint32_t C1ENB = (1U << 4);  ///< ACMPLP1 Operation Enable
        constexpr uint32_t C0MON = (1U << 3);  ///< ACMPLP0 Monitor Flag
        constexpr uint32_t C0VRF = (1U << 2);  ///< ACMPLP0 Reference Voltage Selection
        constexpr uint32_t C0WDE = (1U << 1);  ///< ACMPLP0 Window Function Mode Enable
        constexpr uint32_t C0ENB = (1U << 0);  ///< ACMPLP0 Operation Enable
    }

    /// COMPFIR Register bits
    namespace compfir_bits {
        constexpr uint32_t C1EDG = (1U << 7);  ///< ACMPLP1 Edge Detection Selection
        constexpr uint32_t C1EPO = (1U << 6);  ///< ACMPLP1 Edge Polarity Switching
        constexpr uint32_t C1FCK = (2 << 4);  ///< ACMPLP1 Filter Select
        constexpr uint32_t C0EDG = (1U << 3);  ///< ACMPLP0 Edge Detection Selection
        constexpr uint32_t C0EPO = (1U << 2);  ///< ACMPLP0 Edge Polarity Switching
        constexpr uint32_t C0FCK = (2 << 0);  ///< ACMPLP0 Filter Select
    }

    /// COMPOCR Register bits
    namespace compocr_bits {
        constexpr uint32_t SPDMD = (1U << 7);  ///< ACMPLP0/ACMPLP1 Speed Selection
        constexpr uint32_t C1OP = (1U << 6);  ///< ACMPLP1 VCOUT Output Polarity Selection
        constexpr uint32_t C1OE = (1U << 5);  ///< ACMPLP1 VCOUT Pin Output Enable
        constexpr uint32_t Reserved = (1U << 0);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t C0OP = (1U << 2);  ///< ACMPLP0 VCOUT Output Polarity Selection
        constexpr uint32_t C0OE = (1U << 1);  ///< ACMPLP0 VCOUT Pin Output Enable
    }

    /// COMPSEL0 Register bits
    namespace compsel0_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CMPSEL64 = (3 << 4);  ///< ACMPLP1 Input (IVCMP1) Selection
        constexpr uint32_t CMPSEL20 = (3 << 0);  ///< ACMPLP0 Input(IVCMP0) Selection
    }

    /// COMPSEL1 Register bits
    namespace compsel1_bits {
        constexpr uint32_t C1VRF2 = (1U << 7);  ///< ACMPLP1 Reference Voltage Selection
        constexpr uint32_t CRVS64 = (3 << 4);  ///< ACMPLP1 Reference Voltage(IVREF1) Selection
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CRVS20 = (3 << 0);  ///< ACMPLP0 Reference Voltage(IVREF0) Selection*
    }

}

// ============================================================================
// TSN Peripheral
// ============================================================================

namespace tsn {
    /// Base addresses
    constexpr uint32_t TSN_BASE = 0x407EC000;

    /// TSN Register structure
    struct Registers {
        volatile uint32_t TSCDRH;  ///< Offset: 0x228 - Temperature Sensor Calibration Data Register H
        volatile uint32_t TSCDRL;  ///< Offset: 0x229 - Temperature Sensor Calibration Data Register L
    };

    /// Peripheral instances
    inline Registers* TSN = reinterpret_cast<Registers*>(TSN_BASE);

    // Bit definitions
    /// TSCDRH Register bits
    namespace tscdrh_bits {
        constexpr uint32_t TSCDRH = (8 << 0);  ///< The calibration data stores the higher 8 bits of the convertedvalue.
    }

    /// TSCDRL Register bits
    namespace tscdrl_bits {
        constexpr uint32_t TSCDRL = (8 << 0);  ///< The calibration data stores the lower 8 bits of the convertedvalue.
    }

}

// ============================================================================
// SLCDC Peripheral
// ============================================================================

namespace slcdc {
    /// Base addresses
    constexpr uint32_t SLCDC_BASE = 0x40082000;

    /// SLCDC Register structure
    struct Registers {
        volatile uint32_t LCDM0;  ///< Offset: 0x00 - LCD Mode Register 0
        volatile uint32_t LCDM1;  ///< Offset: 0x01 - LCD Mode Register 1
        volatile uint32_t LCDC0;  ///< Offset: 0x02 - LCD Clock Control Register 0
        volatile uint32_t VLCD;  ///< Offset: 0x03 - LCD Boost Level Control Register
        volatile uint32_t SEG%s;  ///< Offset: 0x100 - LCD Display Data Register %s
    };

    /// Peripheral instances
    inline Registers* SLCDC = reinterpret_cast<Registers*>(SLCDC_BASE);

    // Bit definitions
    /// LCDM0 Register bits
    namespace lcdm0_bits {
        constexpr uint32_t MDSET = (2 << 6);  ///< LCD drive voltage generator selection
        constexpr uint32_t LWAVE = (1U << 5);  ///< LCD display waveform selection
        constexpr uint32_t LDTY = (3 << 2);  ///< Time Slice of LCD Display Select
        constexpr uint32_t LBAS = (2 << 0);  ///< LCD Display Bias Method Select
    }

    /// LCDM1 Register bits
    namespace lcdm1_bits {
        constexpr uint32_t LCDON = (1U << 7);  ///< LCD Display Enable/Disable
        constexpr uint32_t SCOC = (1U << 6);  ///< LCD Display Enable/Disable
        constexpr uint32_t VLCON = (1U << 5);  ///< Voltage boost circuit or capacitor split circuit operation enable/disable
        constexpr uint32_t BLON = (1U << 4);  ///< Display data area control
        constexpr uint32_t LCDSEL = (1U << 3);  ///< Display data area control
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t LCDVLM = (1U << 0);  ///< Voltage Boosting Pin Initial Value Switching Control
    }

    /// LCDC0 Register bits
    namespace lcdc0_bits {
        constexpr uint32_t LCDC = (6 << 0);  ///< LCD clock (LCDCL)
    }

    /// VLCD Register bits
    namespace vlcd_bits {
        constexpr uint32_t VLCD = (5 << 0);  ///< Reference Voltage(Contrast Adjustment) Select
    }

    /// SEG%s Register bits
    namespace seg%s_bits {
        constexpr uint32_t SEG = (8 << 0);  ///< LCD Display Data
    }

}

// ============================================================================
// OPAMP Peripheral
// ============================================================================

namespace opamp {
    /// Base addresses
    constexpr uint32_t OPAMP_BASE = 0x40086000;

    /// OPAMP Register structure
    struct Registers {
        volatile uint32_t AMPMC;  ///< Offset: 0x08 - Operational amplifier mode control register
        volatile uint32_t AMPTRM;  ///< Offset: 0x09 - Operational amplifier trigger mode control register
        volatile uint32_t AMPTRS;  ///< Offset: 0x0A - Operational Amplifier Activation Trigger Select Register
        volatile uint32_t AMPC;  ///< Offset: 0x0B - Operational amplifier control register
        volatile uint32_t AMPMON;  ///< Offset: 0x0C - Operational amplifier monitor register
    };

    /// Peripheral instances
    inline Registers* OPAMP = reinterpret_cast<Registers*>(OPAMP_BASE);

    // Bit definitions
    /// AMPMC Register bits
    namespace ampmc_bits {
        constexpr uint32_t AMPSP = (1U << 7);  ///< Operation mode selection
        constexpr uint32_t Reserved = (3 << 4);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t AMPPC3 = (1U << 3);  ///< Operational amplifier precharge control status
        constexpr uint32_t AMPPC2 = (1U << 2);  ///< Operational amplifier precharge control status
        constexpr uint32_t AMPPC1 = (1U << 1);  ///< Operational amplifier precharge control status
        constexpr uint32_t AMPPC0 = (1U << 0);  ///< Operational amplifier precharge control status
    }

    /// AMPTRM Register bits
    namespace amptrm_bits {
        constexpr uint32_t AMPTRM31 = (1U << 7);  ///< Operational amplifier function activation/stop trigger control
        constexpr uint32_t AMPTRM30 = (1U << 6);  ///< Operational amplifier function activation/stop trigger control
        constexpr uint32_t AMPTRM21 = (1U << 5);  ///< Operational amplifier function activation/stop trigger control
        constexpr uint32_t AMPTRM20 = (1U << 4);  ///< Operational amplifier function activation/stop trigger control
        constexpr uint32_t AMPTRM11 = (1U << 3);  ///< Operational amplifier function activation/stop trigger control
        constexpr uint32_t AMPTRM10 = (1U << 2);  ///< Operational amplifier function activation/stop trigger control
        constexpr uint32_t AMPTRM01 = (1U << 1);  ///< Operational amplifier function activation/stop trigger control
        constexpr uint32_t AMPTRM00 = (1U << 0);  ///< Operational amplifier function activation/stop trigger control
    }

    /// AMPTRS Register bits
    namespace amptrs_bits {
        constexpr uint32_t AMPTRS = (2 << 0);  ///< ELC trigger selection Do not change the value of the AMPTRS register after setting the AMPTRM register.
    }

    /// AMPC Register bits
    namespace ampc_bits {
        constexpr uint32_t IREFE = (1U << 7);  ///< Operation control of operational amplifier reference current circuit
        constexpr uint32_t Reserved = (3 << 4);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t AMPE3 = (1U << 3);  ///< Operation control of operational amplifier(UNIT3)
        constexpr uint32_t AMPE2 = (1U << 2);  ///< Operation control of operational amplifier(UNIT2)
        constexpr uint32_t AMPE1 = (1U << 1);  ///< Operation control of operational amplifier(UNIT1)
        constexpr uint32_t AMPE0 = (1U << 0);  ///< Operation control of operational amplifier(UNIT0)
    }

    /// AMPMON Register bits
    namespace ampmon_bits {
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000.
        constexpr uint32_t AMPMON3 = (1U << 3);  ///< Operational amplifier status(UNIT3)
        constexpr uint32_t AMPMON2 = (1U << 2);  ///< Operational amplifier status(UNIT2)
        constexpr uint32_t AMPMON1 = (1U << 1);  ///< Operational amplifier status(UNIT1)
        constexpr uint32_t AMPMON0 = (1U << 0);  ///< Operational amplifier status(UNIT0)
    }

}

// ============================================================================
// DTC Peripheral
// ============================================================================

namespace dtc {
    /// Base addresses
    constexpr uint32_t DTC_BASE = 0x40005400;

    /// DTC Register structure
    struct Registers {
        volatile uint32_t DTCCR;  ///< Offset: 0x00 - DTC Control Register
        volatile uint32_t DTCVBR;  ///< Offset: 0x04 - DTC Vector Base Register
        volatile uint32_t DTCST;  ///< Offset: 0x0C - DTC Module Start Register
        volatile uint32_t DTCSTS;  ///< Offset: 0x0E - DTC Status Register
    };

    /// Peripheral instances
    inline Registers* DTC = reinterpret_cast<Registers*>(DTC_BASE);

    // Bit definitions
    /// DTCCR Register bits
    namespace dtccr_bits {
        constexpr uint32_t Reserved = (3 << 0);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t RRS = (1U << 4);  ///< DTC Transfer Information Read Skip Enable.
    }

    /// DTCVBR Register bits
    namespace dtcvbr_bits {
        constexpr uint32_t DTCVBR = (32 << 0);  ///< DTC Vector Base Address.Note: A value cannot be set in the lower-order 10 bits. These bits are fixed to 0.
    }

    /// DTCST Register bits
    namespace dtcst_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t DTCST = (1U << 0);  ///< DTC Module Start
    }

    /// DTCSTS Register bits
    namespace dtcsts_bits {
        constexpr uint32_t ACT = (1U << 15);  ///< DTC Active Flag
        constexpr uint32_t Reserved = (7 << 8);  ///< These bits are read as 0000000.
        constexpr uint32_t VECN = (8 << 0);  ///< DTC-Activating Vector Number MonitoringThese bits indicate the vector number for the activating source when DTC transfer is in progress.The value is only valid if DTC transfer is in progress (the value of the ACT flag is 1)
    }

}

// ============================================================================
// KINT Peripheral
// ============================================================================

namespace kint {
    /// Base addresses
    constexpr uint32_t KINT_BASE = 0x40080000;

    /// KINT Register structure
    struct Registers {
        volatile uint32_t KRCTL;  ///< Offset: 0x00 - KEY Return Control Register
        volatile uint32_t KRF;  ///< Offset: 0x04 - KEY Return Flag Register
        volatile uint32_t KRM;  ///< Offset: 0x08 - KEY Return Mode Register
    };

    /// Peripheral instances
    inline Registers* KINT = reinterpret_cast<Registers*>(KINT_BASE);

    // Bit definitions
    /// KRCTL Register bits
    namespace krctl_bits {
        constexpr uint32_t KRMD = (1U << 7);  ///< Usage of Key Interrupt Flags(KR0 to KR7)
        constexpr uint32_t Reserved = (6 << 1);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t KREG = (1U << 0);  ///< Detection Edge Selection (KRF0 to KRF7)
    }

    /// KRF Register bits
    namespace krf_bits {
        constexpr uint32_t KRF7 = (1U << 7);  ///< Key interrupt flag 7
        constexpr uint32_t KRF6 = (1U << 6);  ///< Key interrupt flag 6
        constexpr uint32_t KRF5 = (1U << 5);  ///< Key interrupt flag 5
        constexpr uint32_t KRF4 = (1U << 4);  ///< Key interrupt flag 4
        constexpr uint32_t KRF3 = (1U << 3);  ///< Key interrupt flag 3
        constexpr uint32_t KRF2 = (1U << 2);  ///< Key interrupt flag 2
        constexpr uint32_t KRF1 = (1U << 1);  ///< Key interrupt flag 1
        constexpr uint32_t KRF0 = (1U << 0);  ///< Key interrupt flag 0
    }

    /// KRM Register bits
    namespace krm_bits {
        constexpr uint32_t KRM7 = (1U << 7);  ///< Key interrupt mode control 7
        constexpr uint32_t KRM6 = (1U << 6);  ///< Key interrupt mode control 6
        constexpr uint32_t KRM5 = (1U << 5);  ///< Key interrupt mode control 5
        constexpr uint32_t KRM4 = (1U << 4);  ///< Key interrupt mode control 4
        constexpr uint32_t KRM3 = (1U << 3);  ///< Key interrupt mode control 3
        constexpr uint32_t KRM2 = (1U << 2);  ///< Key interrupt mode control 2
        constexpr uint32_t KRM1 = (1U << 1);  ///< Key interrupt mode control 1
        constexpr uint32_t KRM0 = (1U << 0);  ///< Key interrupt mode control 0
    }

}


} // namespace alloy::generated::r7fa4w1ad

#endif // ALLOY_GENERATED_R7FA4W1AD_PERIPHERALS_HPP