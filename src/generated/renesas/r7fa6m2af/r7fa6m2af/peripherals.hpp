/// Auto-generated code for R7FA6M2AF
/// Generated by Alloy Code Generator
/// Source: renesas_r7fa6m2af.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:22:16
#ifndef ALLOY_GENERATED_R7FA6M2AF_PERIPHERALS_HPP
#define ALLOY_GENERATED_R7FA6M2AF_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::r7fa6m2af {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT0_BASE = 0x40040000;
    constexpr uint32_t PORT1_BASE = 0x40040020;
    constexpr uint32_t PORT2_BASE = 0x40040040;
    constexpr uint32_t PORT3_BASE = 0x40040060;
    constexpr uint32_t PORT4_BASE = 0x40040080;
    constexpr uint32_t PORT5_BASE = 0x400400A0;
    constexpr uint32_t PORT6_BASE = 0x400400C0;
    constexpr uint32_t PORT7_BASE = 0x400400E0;
    constexpr uint32_t PORT8_BASE = 0x40040100;
    constexpr uint32_t PORT9_BASE = 0x40040120;
    constexpr uint32_t PORTA_BASE = 0x40040140;
    constexpr uint32_t PORTB_BASE = 0x40040160;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCNTR1;  ///< Offset: 0x00 - Port Control Register 1
        volatile uint32_t PODR;  ///< Offset: 0x00 - Output data register
        volatile uint32_t PDR;  ///< Offset: 0x02 - Data direction register
        volatile uint32_t PCNTR2;  ///< Offset: 0x04 - Port Control Register 2
        volatile uint32_t PIDR;  ///< Offset: 0x06 - Input data register
        volatile uint32_t PCNTR3;  ///< Offset: 0x08 - Port Control Register 3
        volatile uint32_t PORR;  ///< Offset: 0x08 - Output reset register
        volatile uint32_t POSR;  ///< Offset: 0x0A - Output set register
    };

    /// Peripheral instances
    inline Registers* PORT0 = reinterpret_cast<Registers*>(PORT0_BASE);
    inline Registers* PORT1 = reinterpret_cast<Registers*>(PORT1_BASE);
    inline Registers* PORT2 = reinterpret_cast<Registers*>(PORT2_BASE);
    inline Registers* PORT3 = reinterpret_cast<Registers*>(PORT3_BASE);
    inline Registers* PORT4 = reinterpret_cast<Registers*>(PORT4_BASE);
    inline Registers* PORT5 = reinterpret_cast<Registers*>(PORT5_BASE);
    inline Registers* PORT6 = reinterpret_cast<Registers*>(PORT6_BASE);
    inline Registers* PORT7 = reinterpret_cast<Registers*>(PORT7_BASE);
    inline Registers* PORT8 = reinterpret_cast<Registers*>(PORT8_BASE);
    inline Registers* PORT9 = reinterpret_cast<Registers*>(PORT9_BASE);
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);

    // Bit definitions
    /// PCNTR1 Register bits
    namespace pcntr1_bits {
        constexpr uint32_t PODR = (16 << 16);  ///< Pmn Output Data
        constexpr uint32_t PDR = (16 << 0);  ///< Pmn Direction
    }

    /// PODR Register bits
    namespace podr_bits {
        constexpr uint32_t PODR = (16 << 0);  ///< Pmn Output Data
    }

    /// PDR Register bits
    namespace pdr_bits {
        constexpr uint32_t PDR = (16 << 0);  ///< Pmn Direction
    }

    /// PCNTR2 Register bits
    namespace pcntr2_bits {
        constexpr uint32_t EIDR = (16 << 16);  ///< Pmn Event Input Data
        constexpr uint32_t PIDR = (16 << 0);  ///< Pmn Input Data
    }

    /// PIDR Register bits
    namespace pidr_bits {
        constexpr uint32_t PIDR = (16 << 0);  ///< Pmn Input Data
    }

    /// PCNTR3 Register bits
    namespace pcntr3_bits {
        constexpr uint32_t PORR = (16 << 16);  ///< Pmn Output Reset
        constexpr uint32_t POSR = (16 << 0);  ///< Pmn Output Set
    }

    /// PORR Register bits
    namespace porr_bits {
        constexpr uint32_t PORR = (16 << 0);  ///< Pmn Output Reset
    }

    /// POSR Register bits
    namespace posr_bits {
        constexpr uint32_t POSR = (16 << 0);  ///< Pmn Output Set
    }

}

// ============================================================================
// PFS Peripheral
// ============================================================================

namespace pfs {
    /// Base addresses
    constexpr uint32_t PFS_BASE = 0x40040800;

    /// PFS Register structure
    struct Registers {
        volatile uint32_t P000PFS;  ///< Offset: 0x00 - P000 Pin Function Control Register
        volatile uint32_t P000PFS_HA;  ///< Offset: 0x02 - P000 Pin Function Control Register
        volatile uint32_t P000PFS_BY;  ///< Offset: 0x03 - P000 Pin Function Control Register
        volatile uint32_t P00%sPFS;  ///< Offset: 0x20 - P00%s Pin Function Control Register
        volatile uint32_t P00%sPFS_HA;  ///< Offset: 0x22 - P00%s Pin Function Control Register
        volatile uint32_t P00%sPFS_BY;  ///< Offset: 0x23 - P00%s Pin Function Control Register
        volatile uint32_t P0%sPFS;  ///< Offset: 0x38 - P0%s Pin Function Control Register
        volatile uint32_t P0%sPFS_HA;  ///< Offset: 0x3A - P0%s Pin Function Control Register
        volatile uint32_t P0%sPFS_BY;  ///< Offset: 0x3B - P0%s Pin Function Control Register
        volatile uint32_t P100PFS;  ///< Offset: 0x40 - P100 Pin Function Control Register
        volatile uint32_t P100PFS_HA;  ///< Offset: 0x42 - P100 Pin Function Control Register
        volatile uint32_t P100PFS_BY;  ///< Offset: 0x43 - P100 Pin Function Control Register
        volatile uint32_t P10%sPFS;  ///< Offset: 0x44 - P10%s Pin Function Control Register
        volatile uint32_t P10%sPFS_HA;  ///< Offset: 0x46 - P10%s Pin Function Control Register
        volatile uint32_t P10%sPFS_BY;  ///< Offset: 0x47 - P10%s Pin Function Control Register
        volatile uint32_t P108PFS;  ///< Offset: 0x60 - P108 Pin Function Control Register
        volatile uint32_t P108PFS_HA;  ///< Offset: 0x62 - P108 Pin Function Control Register
        volatile uint32_t P108PFS_BY;  ///< Offset: 0x63 - P108 Pin Function Control Register
        volatile uint32_t P109PFS;  ///< Offset: 0x64 - P109 Pin Function Control Register
        volatile uint32_t P109PFS_HA;  ///< Offset: 0x66 - P109 Pin Function Control Register
        volatile uint32_t P109PFS_BY;  ///< Offset: 0x67 - P109 Pin Function Control Register
        volatile uint32_t P110PFS;  ///< Offset: 0x68 - P110 Pin Function Control Register
        volatile uint32_t P110PFS_HA;  ///< Offset: 0x6A - P110 Pin Function Control Register
        volatile uint32_t P110PFS_BY;  ///< Offset: 0x6B - P110 Pin Function Control Register
        volatile uint32_t P1%sPFS;  ///< Offset: 0x6C - P1%s Pin Function Control Register
        volatile uint32_t P1%sPFS_HA;  ///< Offset: 0x6E - P1%s Pin Function Control Register
        volatile uint32_t P1%sPFS_BY;  ///< Offset: 0x6F - P1%s Pin Function Control Register
        volatile uint32_t P200PFS;  ///< Offset: 0x80 - P200 Pin Function Control Register
        volatile uint32_t P200PFS_HA;  ///< Offset: 0x82 - P200 Pin Function Control Register
        volatile uint32_t P200PFS_BY;  ///< Offset: 0x83 - P200 Pin Function Control Register
        volatile uint32_t P201PFS;  ///< Offset: 0x84 - P201 Pin Function Control Register
        volatile uint32_t P201PFS_HA;  ///< Offset: 0x86 - P201 Pin Function Control Register
        volatile uint32_t P201PFS_BY;  ///< Offset: 0x87 - P201 Pin Function Control Register
        volatile uint32_t P20%sPFS;  ///< Offset: 0x88 - P20%s Pin Function Control Register
        volatile uint32_t P20%sPFS_HA;  ///< Offset: 0x8A - P20%s Pin Function Control Register
        volatile uint32_t P20%sPFS_BY;  ///< Offset: 0x8B - P20%s Pin Function Control Register
        volatile uint32_t P2%sPFS;  ///< Offset: 0xA8 - P2%s Pin Function Control Register
        volatile uint32_t P2%sPFS_HA;  ///< Offset: 0xAA - P2%s Pin Function Control Register
        volatile uint32_t P2%sPFS_BY;  ///< Offset: 0xAB - P2%s Pin Function Control Register
        volatile uint32_t P300PFS;  ///< Offset: 0xC0 - P300 Pin Function Control Register
        volatile uint32_t P300PFS_HA;  ///< Offset: 0xC2 - P300 Pin Function Control Register
        volatile uint32_t P300PFS_BY;  ///< Offset: 0xC3 - P300 Pin Function Control Register
        volatile uint32_t P30%sPFS;  ///< Offset: 0xC4 - P30%s Pin Function Control Register
        volatile uint32_t P30%sPFS_HA;  ///< Offset: 0xC6 - P30%s Pin Function Control Register
        volatile uint32_t P30%sPFS_BY;  ///< Offset: 0xC7 - P30%s Pin Function Control Register
        volatile uint32_t P3%sPFS;  ///< Offset: 0xE8 - P3%s Pin Function Control Register
        volatile uint32_t P3%sPFS_HA;  ///< Offset: 0xEA - P30%s Pin Function Control Register
        volatile uint32_t P3%sPFS_BY;  ///< Offset: 0xEB - P30%s Pin Function Control Register
        volatile uint32_t P40%sPFS;  ///< Offset: 0x100 - P40%s Pin Function Control Register
        volatile uint32_t P40%sPFS_HA;  ///< Offset: 0x102 - P40%s Pin Function Control Register
        volatile uint32_t P40%sPFS_BY;  ///< Offset: 0x103 - P40%s Pin Function Control Register
        volatile uint32_t P4%sPFS;  ///< Offset: 0x128 - P4%s Pin Function Control Register
        volatile uint32_t P4%sPFS_HA;  ///< Offset: 0x12A - P4%s Pin Function Control Register
        volatile uint32_t P4%sPFS_BY;  ///< Offset: 0x12B - P4%s Pin Function Control Register
        volatile uint32_t P50%sPFS;  ///< Offset: 0x140 - P50%s Pin Function Control Register
        volatile uint32_t P50%sPFS_HA;  ///< Offset: 0x142 - P50%s Pin Function Control Register
        volatile uint32_t P50%sPFS_BY;  ///< Offset: 0x143 - P50%s Pin Function Control Register
        volatile uint32_t P5%sPFS;  ///< Offset: 0x16C - P5%s Pin Function Control Register
        volatile uint32_t P5%sPFS_HA;  ///< Offset: 0x16E - P5%s Pin Function Control Register
        volatile uint32_t P5%sPFS_BY;  ///< Offset: 0x16F - P5%s Pin Function Control Register
        volatile uint32_t P60%sPFS;  ///< Offset: 0x180 - P60%s Pin Function Control Register
        volatile uint32_t P60%sPFS_HA;  ///< Offset: 0x182 - P60%s Pin Function Control Register
        volatile uint32_t P60%sPFS_BY;  ///< Offset: 0x183 - P60%s Pin Function Control Register
        volatile uint32_t P6%sPFS;  ///< Offset: 0x1A8 - P6%s Pin Function Control Register
        volatile uint32_t P6%sPFS_HA;  ///< Offset: 0x1AA - P6%s Pin Function Control Register
        volatile uint32_t P6%sPFS_BY;  ///< Offset: 0x1AB - P6%s Pin Function Control Register
        volatile uint32_t P70%sPFS;  ///< Offset: 0x1C0 - P70%s Pin Function Control Register
        volatile uint32_t P70%sPFS_HA;  ///< Offset: 0x1C2 - P70%s Pin Function Control Register
        volatile uint32_t P70%sPFS_BY;  ///< Offset: 0x1C3 - P70%s Pin Function Control Register
        volatile uint32_t P80%sPFS;  ///< Offset: 0x200 - P80%s Pin Function Control Register
        volatile uint32_t P80%sPFS_HA;  ///< Offset: 0x202 - P80%s Pin Function Control Register
        volatile uint32_t P80%sPFS_BY;  ///< Offset: 0x203 - P80%s Pin Function Control Register
        volatile uint32_t P90%sPFS;  ///< Offset: 0x254 - P90%s Pin Function Control Register
        volatile uint32_t P90%sPFS_HA;  ///< Offset: 0x256 - P90%s Pin Function Control Register
        volatile uint32_t P90%sPFS_BY;  ///< Offset: 0x257 - P90%s Pin Function Control Register
        volatile uint32_t PA0%sPFS;  ///< Offset: 0x2A0 - PA0%s Pin Function Control Register
        volatile uint32_t PA0%sPFS_HA;  ///< Offset: 0x2A2 - PA0%s Pin Function Control Register
        volatile uint32_t PA0%sPFS_BY;  ///< Offset: 0x2A3 - PA0%s Pin Function Control Register
        volatile uint32_t PA10PFS;  ///< Offset: 0x2A8 - PA10 Pin Function Control Register
        volatile uint32_t PA10PFS_HA;  ///< Offset: 0x2AA - PA10 Pin Function Control Register
        volatile uint32_t PA10PFS_BY;  ///< Offset: 0x2AB - PA10 Pin Function Control Register
        volatile uint32_t PB0%sPFS;  ///< Offset: 0x2C0 - PB0%s Pin Function Control Register
        volatile uint32_t PB0%sPFS_HA;  ///< Offset: 0x2C2 - PB0%s Pin Function Control Register
        volatile uint32_t PB0%sPFS_BY;  ///< Offset: 0x2C3 - PB0%s Pin Function Control Register
    };

    /// Peripheral instances
    inline Registers* PFS = reinterpret_cast<Registers*>(PFS_BASE);

    // Bit definitions
    /// P000PFS Register bits
    namespace p000pfs_bits {
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function SelectThese bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P000PFS_HA Register bits
    namespace p000pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P000PFS_BY Register bits
    namespace p000pfs_by_bits {
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P100PFS Register bits
    namespace p100pfs_bits {
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function SelectThese bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P100PFS_HA Register bits
    namespace p100pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P100PFS_BY Register bits
    namespace p100pfs_by_bits {
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P108PFS Register bits
    namespace p108pfs_bits {
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function SelectThese bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P108PFS_HA Register bits
    namespace p108pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P108PFS_BY Register bits
    namespace p108pfs_by_bits {
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P110PFS Register bits
    namespace p110pfs_bits {
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function SelectThese bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P110PFS_HA Register bits
    namespace p110pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P110PFS_BY Register bits
    namespace p110pfs_by_bits {
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P201PFS Register bits
    namespace p201pfs_bits {
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function SelectThese bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P201PFS_HA Register bits
    namespace p201pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P201PFS_BY Register bits
    namespace p201pfs_by_bits {
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

}

// ============================================================================
// PMISC Peripheral
// ============================================================================

namespace pmisc {
    /// Base addresses
    constexpr uint32_t PMISC_BASE = 0x40040D00;

    /// PMISC Register structure
    struct Registers {
        volatile uint32_t PFENET;  ///< Offset: 0x00 - Ethernet Control Register
        volatile uint32_t PWPR;  ///< Offset: 0x03 - Write-Protect Register
    };

    /// Peripheral instances
    inline Registers* PMISC = reinterpret_cast<Registers*>(PMISC_BASE);

    // Bit definitions
    /// PFENET Register bits
    namespace pfenet_bits {
        constexpr uint32_t PHYMODE0 = (1U << 4);  ///< Ethernet Mode Setting ch0
    }

    /// PWPR Register bits
    namespace pwpr_bits {
        constexpr uint32_t BOWI = (1U << 7);  ///< PFSWE Bit Write Disable
        constexpr uint32_t PFSWE = (1U << 6);  ///< PFS Register Write Enable
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40072000;
    constexpr uint32_t SPI1_BASE = 0x40072100;
    constexpr uint32_t QSPI_BASE = 0x64000000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPCR;  ///< Offset: 0x00 - SPI Control Register
        volatile uint32_t SSLP;  ///< Offset: 0x01 - SPI Slave Select Polarity Register
        volatile uint32_t SPPCR;  ///< Offset: 0x02 - RSPI Pin Control Register
        volatile uint32_t SPSR;  ///< Offset: 0x03 - SPI Status Register
        volatile uint32_t SPDR;  ///< Offset: 0x04 - SPI Data Register
        volatile uint32_t SPDR_HA;  ///< Offset: 0x04 - SPI Data Register ( halfword access )
        volatile uint32_t SPSCR;  ///< Offset: 0x08 - SPI Sequence Control Register
        volatile uint32_t SPSSR;  ///< Offset: 0x09 - SPI Sequence Status Register
        volatile uint32_t SPBR;  ///< Offset: 0x0A - SPI Bit Rate Register
        volatile uint32_t SPDCR;  ///< Offset: 0x0B - SPI Data Control Register
        volatile uint32_t SPCKD;  ///< Offset: 0x0C - SPI Clock Delay Register
        volatile uint32_t SSLND;  ///< Offset: 0x0D - SPI Slave Select Negation Delay Register
        volatile uint32_t SPND;  ///< Offset: 0x0E - SPI Next-Access Delay Register
        volatile uint32_t SPCR2;  ///< Offset: 0x0F - SPI Control Register 2
        volatile uint32_t SPCMD%s;  ///< Offset: 0x10 - SPI Command Register %s
        volatile uint32_t SPDCR2;  ///< Offset: 0x20 - SPI Data Control Register 2
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* QSPI = reinterpret_cast<Registers*>(QSPI_BASE);

    // Bit definitions
    /// SPCR Register bits
    namespace spcr_bits {
        constexpr uint32_t SPRIE = (1U << 7);  ///< SPI Receive Buffer Full Interrupt Enable
        constexpr uint32_t SPE = (1U << 6);  ///< SPI Function Enable
        constexpr uint32_t SPTIE = (1U << 5);  ///< Transmit Buffer Empty Interrupt Enable
        constexpr uint32_t SPEIE = (1U << 4);  ///< SPI Error Interrupt Enable
        constexpr uint32_t MSTR = (1U << 3);  ///< SPI Master/Slave Mode Select
        constexpr uint32_t MODFEN = (1U << 2);  ///< Mode Fault Error Detection Enable
        constexpr uint32_t TXMD = (1U << 1);  ///< Communications Operating Mode Select
        constexpr uint32_t SPMS = (1U << 0);  ///< SPI Mode Select
    }

    /// SSLP Register bits
    namespace sslp_bits {
        constexpr uint32_t SSL3P = (1U << 3);  ///< SSL3 Signal Polarity Setting
        constexpr uint32_t SSL2P = (1U << 2);  ///< SSL2 Signal Polarity Setting
        constexpr uint32_t SSL1P = (1U << 1);  ///< SSL1 Signal Polarity Setting
        constexpr uint32_t SSL0P = (1U << 0);  ///< SSL0 Signal Polarity Setting
    }

    /// SPPCR Register bits
    namespace sppcr_bits {
        constexpr uint32_t MOIFE = (1U << 5);  ///< MOSI Idle Value Fixing Enable
        constexpr uint32_t MOIFV = (1U << 4);  ///< MOSI Idle Fixed Value
        constexpr uint32_t SPLP2 = (1U << 1);  ///< RSPI Loopback 2
        constexpr uint32_t SPLP = (1U << 0);  ///< RSPI Loopback
    }

    /// SPSR Register bits
    namespace spsr_bits {
        constexpr uint32_t SPRF = (1U << 7);  ///< SPI Receive Buffer Full Flag
        constexpr uint32_t SPTEF = (1U << 5);  ///< SPI Transmit Buffer Empty Flag
        constexpr uint32_t UDRF = (1U << 4);  ///< Underrun Error Flag(When MODF is 0, This bit is invalid.)
        constexpr uint32_t PERF = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t MODF = (1U << 2);  ///< Mode Fault Error Flag
        constexpr uint32_t IDLNF = (1U << 1);  ///< SPI Idle Flag
        constexpr uint32_t OVRF = (1U << 0);  ///< Overrun Error Flag
    }

    /// SPDR Register bits
    namespace spdr_bits {
        constexpr uint32_t SPDR = (32 << 0);  ///< SPDR is the interface with the buffers that hold data for transmission and reception by the RSPI.When accessing in word (SPDCR.SPLW=1), access SPDR.
    }

    /// SPDR_HA Register bits
    namespace spdr_ha_bits {
        constexpr uint32_t SPDR_HA = (16 << 0);  ///< SPDR is the interface with the buffers that hold data for transmission and reception by the RSPI.When accessing in halfword (SPDCR.SPLW=0), access SPDR_HA.
    }

    /// SPSCR Register bits
    namespace spscr_bits {
        constexpr uint32_t SPSLN = (3 << 0);  ///< RSPI Sequence Length SpecificationThe order in which the SPCMD0 to SPCMD07 registers are to be referenced is changed in accordance with the sequence length that is set in these bits. The relationship among the setting of these bits, sequence length, and SPCMD0 to SPCMD7 registers referenced by the RSPI is shown above. However, the RSPI in slave mode always references SPCMD0.
    }

    /// SPSSR Register bits
    namespace spssr_bits {
        constexpr uint32_t SPECM = (3 << 4);  ///< RSPI Error Command
        constexpr uint32_t SPCP = (3 << 0);  ///< RSPI Command Pointer
    }

    /// SPBR Register bits
    namespace spbr_bits {
        constexpr uint32_t SPR = (8 << 0);  ///< SPBR sets the bit rate in master mode.
    }

    /// SPDCR Register bits
    namespace spdcr_bits {
        constexpr uint32_t SPBYT = (1U << 6);  ///< SPI Byte Access Specification
        constexpr uint32_t SPLW = (1U << 5);  ///< SPI Word Access/Halfword Access Specification
        constexpr uint32_t SPRDTD = (1U << 4);  ///< RSPI Receive/Transmit Data Selection
        constexpr uint32_t SPFC = (2 << 0);  ///< Number of Frames Specification
    }

    /// SPCKD Register bits
    namespace spckd_bits {
        constexpr uint32_t SCKDL = (3 << 0);  ///< RSPCK Delay Setting
    }

    /// SSLND Register bits
    namespace sslnd_bits {
        constexpr uint32_t SLNDL = (3 << 0);  ///< SSL Negation Delay Setting
    }

    /// SPND Register bits
    namespace spnd_bits {
        constexpr uint32_t SPNDL = (3 << 0);  ///< SPI Next-Access Delay Setting
    }

    /// SPCR2 Register bits
    namespace spcr2_bits {
        constexpr uint32_t SCKASE = (1U << 4);  ///< RSPCK Auto-Stop Function Enable
        constexpr uint32_t PTE = (1U << 3);  ///< Parity Self-Testing
        constexpr uint32_t SPIIE = (1U << 2);  ///< SPI Idle Interrupt Enable
        constexpr uint32_t SPOE = (1U << 1);  ///< Parity Mode
        constexpr uint32_t SPPE = (1U << 0);  ///< Parity Enable
    }

    /// SPCMD%s Register bits
    namespace spcmd%s_bits {
        constexpr uint32_t SCKDEN = (1U << 15);  ///< RSPCK Delay Setting Enable
        constexpr uint32_t SLNDEN = (1U << 14);  ///< SSL Negation Delay Setting Enable
        constexpr uint32_t SPNDEN = (1U << 13);  ///< RSPI Next-Access Delay Enable
        constexpr uint32_t LSBF = (1U << 12);  ///< RSPI LSB First
        constexpr uint32_t SPB = (4 << 8);  ///< RSPI Data Length Setting
        constexpr uint32_t SSLKP = (1U << 7);  ///< SSL Signal Level Keeping
        constexpr uint32_t SSLA = (3 << 4);  ///< SSL Signal Assertion Setting
        constexpr uint32_t BRDV = (2 << 2);  ///< Bit Rate Division Setting
        constexpr uint32_t CPOL = (1U << 1);  ///< RSPCK Polarity Setting
        constexpr uint32_t CPHA = (1U << 0);  ///< RSPCK Phase Setting
    }

    /// SPDCR2 Register bits
    namespace spdcr2_bits {
        constexpr uint32_t BYSW = (1U << 0);  ///< Byte Swap Operating Mode Select
    }

}

// ============================================================================
// GPT Peripheral
// ============================================================================

namespace gpt {
    /// Base addresses
    constexpr uint32_t GPT_OPS_BASE = 0x40078FF0;
    constexpr uint32_t GPT_ODC_BASE = 0x4007B000;

    /// GPT Register structure
    struct Registers {
        volatile uint32_t OPSCR;  ///< Offset: 0x00 - Output Phase Switching Control Register
    };

    /// Peripheral instances
    inline Registers* GPT_OPS = reinterpret_cast<Registers*>(GPT_OPS_BASE);
    inline Registers* GPT_ODC = reinterpret_cast<Registers*>(GPT_ODC_BASE);

    // Bit definitions
    /// OPSCR Register bits
    namespace opscr_bits {
        constexpr uint32_t NFCS = (2 << 30);  ///< External Input Noise Filter Clock selectionNoise filter sampling clock setting of the external input.
        constexpr uint32_t NFEN = (1U << 29);  ///< External Input Noise Filter Enable
        constexpr uint32_t GODF = (1U << 26);  ///< Group output disable function
        constexpr uint32_t GRP = (2 << 24);  ///< Output disabled source selection
        constexpr uint32_t ALIGN = (1U << 21);  ///< Input phase alignment
        constexpr uint32_t RV = (1U << 20);  ///< Output phase rotation direction reversal
        constexpr uint32_t INV = (1U << 19);  ///< Invert-Phase Output Control
        constexpr uint32_t N = (1U << 18);  ///< Negative-Phase Output (N) Control
        constexpr uint32_t P = (1U << 17);  ///< Positive-Phase Output (P) Control
        constexpr uint32_t FB = (1U << 16);  ///< External Feedback Signal EnableThis bit selects the input phase from the software settings and external input.
        constexpr uint32_t EN = (1U << 8);  ///< Enable-Phase Output Control
        constexpr uint32_t W = (1U << 6);  ///< Input W-Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)
        constexpr uint32_t V = (1U << 5);  ///< Input V-Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)
        constexpr uint32_t U = (1U << 4);  ///< Input U-Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)
        constexpr uint32_t WF = (1U << 2);  ///< Input Phase Soft Setting UFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1.
        constexpr uint32_t VF = (1U << 1);  ///< Input Phase Soft Setting VFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1.
        constexpr uint32_t UF = (1U << 0);  ///< Input Phase Soft Setting WFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1.
    }

}

// ============================================================================
// GPT32EH0 Peripheral
// ============================================================================

namespace gpt32eh0 {
    /// Base addresses
    constexpr uint32_t GPT32EH0_BASE = 0x40078000;

    /// GPT32EH0 Register structure
    struct Registers {
        volatile uint32_t GTWP;  ///< Offset: 0x00 - General PWM Timer Write-Protection Register
        volatile uint32_t GTSTR;  ///< Offset: 0x04 - General PWM Timer Software Start Register
        volatile uint32_t GTSTP;  ///< Offset: 0x08 - General PWM Timer Software Stop Register
        volatile uint32_t GTCLR;  ///< Offset: 0x0C - General PWM Timer Software Clear Register
        volatile uint32_t GTSSR;  ///< Offset: 0x10 - General PWM Timer Start Source Select Register
        volatile uint32_t GTPSR;  ///< Offset: 0x14 - General PWM Timer Stop Source Select Register
        volatile uint32_t GTCSR;  ///< Offset: 0x18 - General PWM Timer Clear Source Select Register
        volatile uint32_t GTUPSR;  ///< Offset: 0x1C - General PWM Timer Up Count Source Select Register
        volatile uint32_t GTDNSR;  ///< Offset: 0x20 - General PWM Timer Down Count Source Select Register
        volatile uint32_t GTICASR;  ///< Offset: 0x24 - General PWM Timer Input Capture Source Select Register A
        volatile uint32_t GTICBSR;  ///< Offset: 0x28 - General PWM Timer Input Capture Source Select Register B
        volatile uint32_t GTCR;  ///< Offset: 0x2C - General PWM Timer Control Register
        volatile uint32_t GTUDDTYC;  ///< Offset: 0x30 - General PWM Timer Count Direction and Duty Setting Register
        volatile uint32_t GTIOR;  ///< Offset: 0x34 - General PWM Timer I/O Control Register
        volatile uint32_t GTINTAD;  ///< Offset: 0x38 - General PWM Timer Interrupt Output Setting Register
        volatile uint32_t GTST;  ///< Offset: 0x3C - General PWM Timer Status Register
        volatile uint32_t GTBER;  ///< Offset: 0x40 - General PWM Timer Buffer Enable Register
        volatile uint32_t GTITC;  ///< Offset: 0x44 - General PWM Timer Interrupt and A/D Converter Start...
        volatile uint32_t GTCNT;  ///< Offset: 0x48 - General PWM Timer Counter
        volatile uint32_t GTCCRA;  ///< Offset: 0x4C - General PWM Timer Compare Capture Register A
        volatile uint32_t GTCCRB;  ///< Offset: 0x50 - General PWM Timer Compare Capture Register B
        volatile uint32_t GTCCRC;  ///< Offset: 0x54 - General PWM Timer Compare Capture Register C
        volatile uint32_t GTCCRE;  ///< Offset: 0x58 - General PWM Timer Compare Capture Register E
        volatile uint32_t GTCCRD;  ///< Offset: 0x5C - General PWM Timer Compare Capture Register D
        volatile uint32_t GTCCRF;  ///< Offset: 0x60 - General PWM Timer Compare Capture Register F
        volatile uint32_t GTPR;  ///< Offset: 0x64 - General PWM Timer Cycle Setting Register
        volatile uint32_t GTPBR;  ///< Offset: 0x68 - General PWM Timer Cycle Setting Buffer Register
        volatile uint32_t GTPDBR;  ///< Offset: 0x6C - General PWM Timer Cycle Setting Double-Buffer Register
        volatile uint32_t GTADTRA;  ///< Offset: 0x70 - A/D Converter Start Request Timing Register A
        volatile uint32_t GTADTRB;  ///< Offset: 0x7C - A/D Converter Start Request Timing Register B
        volatile uint32_t GTADTBRA;  ///< Offset: 0x74 - A/D Converter Start Request Timing Buffer Register A
        volatile uint32_t GTADTBRB;  ///< Offset: 0x80 - A/D Converter Start Request Timing Buffer Register B
        volatile uint32_t GTADTDBRA;  ///< Offset: 0x78 - A/D Converter Start Request Timing Double-Buffer Register A
        volatile uint32_t GTADTDBRB;  ///< Offset: 0x84 - A/D Converter Start Request Timing Double-Buffer Register B
        volatile uint32_t GTDTCR;  ///< Offset: 0x88 - General PWM Timer Dead Time Control Register
        volatile uint32_t GTDVU;  ///< Offset: 0x8C - General PWM Timer Dead Time Value Register U
        volatile uint32_t GTDVD;  ///< Offset: 0x90 - General PWM Timer Dead Time Value Register D
        volatile uint32_t GTDBU;  ///< Offset: 0x94 - General PWM Timer Dead Time Buffer Register U
        volatile uint32_t GTDBD;  ///< Offset: 0x98 - General PWM Timer Dead Time Buffer Register D
        volatile uint32_t GTSOS;  ///< Offset: 0x9C - General PWM Timer Output Protection Function Status Register
        volatile uint32_t GTSOTR;  ///< Offset: 0xA0 - General PWM Timer Output Protection Function Temporary...
    };

    /// Peripheral instances
    inline Registers* GPT32EH0 = reinterpret_cast<Registers*>(GPT32EH0_BASE);

    // Bit definitions
    /// GTWP Register bits
    namespace gtwp_bits {
        constexpr uint32_t PRKEY = (8 << 8);  ///< GTWP Key Code
        constexpr uint32_t WP = (1U << 0);  ///< Register Write Disable
    }

    /// GTSTR Register bits
    namespace gtstr_bits {
        constexpr uint32_t CSTRT13 = (1U << 13);  ///< Channel 13 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT12 = (1U << 12);  ///< Channel 12 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT11 = (1U << 11);  ///< Channel 11 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT10 = (1U << 10);  ///< Channel 10 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT9 = (1U << 9);  ///< Channel 9 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT8 = (1U << 8);  ///< Channel 8 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT7 = (1U << 7);  ///< Channel 7 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT6 = (1U << 6);  ///< Channel 6 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT5 = (1U << 5);  ///< Channel 5 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT4 = (1U << 4);  ///< Channel 4 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT3 = (1U << 3);  ///< Channel 3 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT2 = (1U << 2);  ///< Channel 2 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT1 = (1U << 1);  ///< Channel 1 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT0 = (1U << 0);  ///< Channel 0 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
    }

    /// GTSTP Register bits
    namespace gtstp_bits {
        constexpr uint32_t CSTOP13 = (1U << 13);  ///< Channel 13 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP12 = (1U << 12);  ///< Channel 12 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP11 = (1U << 11);  ///< Channel 11 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP10 = (1U << 10);  ///< Channel 10 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP9 = (1U << 9);  ///< Channel 9 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP8 = (1U << 8);  ///< Channel 8 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP7 = (1U << 7);  ///< Channel 7 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP6 = (1U << 6);  ///< Channel 6 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP5 = (1U << 5);  ///< Channel 5 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP4 = (1U << 4);  ///< Channel 4 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP3 = (1U << 3);  ///< Channel 3 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP2 = (1U << 2);  ///< Channel 2 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP1 = (1U << 1);  ///< Channel 1 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP0 = (1U << 0);  ///< Channel 0 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
    }

    /// GTCLR Register bits
    namespace gtclr_bits {
        constexpr uint32_t CCLR13 = (1U << 13);  ///< Channel 13 GTCNT Count Clear
        constexpr uint32_t CCLR12 = (1U << 12);  ///< Channel 12 GTCNT Count Clear
        constexpr uint32_t CCLR11 = (1U << 11);  ///< Channel 11 GTCNT Count Clear
        constexpr uint32_t CCLR10 = (1U << 10);  ///< Channel 10 GTCNT Count Clear
        constexpr uint32_t CCLR9 = (1U << 9);  ///< Channel 9 GTCNT Count Clear
        constexpr uint32_t CCLR8 = (1U << 8);  ///< Channel 8 GTCNT Count Clear
        constexpr uint32_t CCLR7 = (1U << 7);  ///< Channel 7 GTCNT Count Clear
        constexpr uint32_t CCLR6 = (1U << 6);  ///< Channel 6 GTCNT Count Clear
        constexpr uint32_t CCLR5 = (1U << 5);  ///< Channel 5 GTCNT Count Clear
        constexpr uint32_t CCLR4 = (1U << 4);  ///< Channel 4 GTCNT Count Clear
        constexpr uint32_t CCLR3 = (1U << 3);  ///< Channel 3 GTCNT Count Clear
        constexpr uint32_t CCLR2 = (1U << 2);  ///< Channel 2 GTCNT Count Clear
        constexpr uint32_t CCLR1 = (1U << 1);  ///< Channel 1 GTCNT Count Clear
        constexpr uint32_t CCLR0 = (1U << 0);  ///< Channel 0 GTCNT Count Clear
    }

    /// GTSSR Register bits
    namespace gtssr_bits {
        constexpr uint32_t CSTRT = (1U << 31);  ///< Software Source Counter Start Enable
        constexpr uint32_t SSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Start Enable
        constexpr uint32_t SSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Start Enable
        constexpr uint32_t SSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Start Enable
        constexpr uint32_t SSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Start Enable
        constexpr uint32_t SSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Start Enable
        constexpr uint32_t SSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Start Enable
        constexpr uint32_t SSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Start Enable
        constexpr uint32_t SSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Start Enable
        constexpr uint32_t SSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Start Enable
    }

    /// GTPSR Register bits
    namespace gtpsr_bits {
        constexpr uint32_t CSTOP = (1U << 31);  ///< Software Source Counter Stop Enable
        constexpr uint32_t PSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Stop Enable
        constexpr uint32_t PSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Stop Enable
        constexpr uint32_t PSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Stop Enable
        constexpr uint32_t PSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Stop Enable
        constexpr uint32_t PSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Stop Enable
        constexpr uint32_t PSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Stop Enable
        constexpr uint32_t PSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Stop Enable
        constexpr uint32_t PSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Stop Enable
        constexpr uint32_t PSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Stop Enable
    }

    /// GTCSR Register bits
    namespace gtcsr_bits {
        constexpr uint32_t CCLR = (1U << 31);  ///< Software Source Counter Clear Enable
        constexpr uint32_t CSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Clear Enable
        constexpr uint32_t CSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Clear Enable
        constexpr uint32_t CSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Clear Enable
        constexpr uint32_t CSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Clear Enable
        constexpr uint32_t CSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Clear Enable
        constexpr uint32_t CSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Clear Enable
        constexpr uint32_t CSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Clear Enable
        constexpr uint32_t CSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Clear Enable
        constexpr uint32_t CSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Clear Enable
    }

    /// GTUPSR Register bits
    namespace gtupsr_bits {
        constexpr uint32_t USELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Count Up Enable
        constexpr uint32_t USELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Up Enable
        constexpr uint32_t USELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Up Enable
        constexpr uint32_t USELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Up Enable
        constexpr uint32_t USELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Up Enable
        constexpr uint32_t USELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Up Enable
        constexpr uint32_t USELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Up Enable
        constexpr uint32_t USELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Up Enable
        constexpr uint32_t USCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Up Enable
    }

    /// GTDNSR Register bits
    namespace gtdnsr_bits {
        constexpr uint32_t DSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Count Down Enable
        constexpr uint32_t DSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Down Enable
        constexpr uint32_t DSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Down Enable
        constexpr uint32_t DSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Down Enable
        constexpr uint32_t DSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Down Enable
        constexpr uint32_t DSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Down Enable
        constexpr uint32_t DSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Down Enable
        constexpr uint32_t DSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Down Enable
        constexpr uint32_t DSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Down Enable
    }

    /// GTICASR Register bits
    namespace gticasr_bits {
        constexpr uint32_t ASELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable
    }

    /// GTICBSR Register bits
    namespace gticbsr_bits {
        constexpr uint32_t BSELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable
    }

    /// GTCR Register bits
    namespace gtcr_bits {
        constexpr uint32_t TPCS = (3 << 24);  ///< Timer Prescaler Select
        constexpr uint32_t MD = (3 << 16);  ///< Mode Select
        constexpr uint32_t CST = (1U << 0);  ///< Count Start
    }

    /// GTUDDTYC Register bits
    namespace gtuddtyc_bits {
        constexpr uint32_t OBDTYR = (1U << 27);  ///< GTIOCB Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OBDTYF = (1U << 26);  ///< Forcible GTIOCB Output Duty Setting
        constexpr uint32_t OBDTY = (2 << 24);  ///< GTIOCB Output Duty Setting
        constexpr uint32_t OADTYR = (1U << 19);  ///< GTIOCA Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OADTYF = (1U << 18);  ///< Forcible GTIOCA Output Duty Setting
        constexpr uint32_t OADTY = (2 << 16);  ///< GTIOCA Output Duty Setting
        constexpr uint32_t UDF = (1U << 1);  ///< Forcible Count Direction Setting
        constexpr uint32_t UD = (1U << 0);  ///< Count Direction Setting
    }

    /// GTIOR Register bits
    namespace gtior_bits {
        constexpr uint32_t NFCSB = (2 << 30);  ///< Noise Filter B Sampling Clock Select
        constexpr uint32_t NFBEN = (1U << 29);  ///< Noise Filter B Enable
        constexpr uint32_t OBDF = (2 << 25);  ///< GTIOCB Pin Disable Value Setting
        constexpr uint32_t OBE = (1U << 24);  ///< GTIOCB Pin Output Enable
        constexpr uint32_t OBHLD = (1U << 23);  ///< GTIOCB Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OBDFLT = (1U << 22);  ///< GTIOCB Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOB = (5 << 16);  ///< GTIOCB Pin Function Select
        constexpr uint32_t NFCSA = (2 << 14);  ///< Noise Filter A Sampling Clock Select
        constexpr uint32_t NFAEN = (1U << 13);  ///< Noise Filter A Enable
        constexpr uint32_t OADF = (2 << 9);  ///< GTIOCA Pin Disable Value Setting
        constexpr uint32_t OAE = (1U << 8);  ///< GTIOCA Pin Output Enable
        constexpr uint32_t OAHLD = (1U << 7);  ///< GTIOCA Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OADFLT = (1U << 6);  ///< GTIOCA Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOA = (5 << 0);  ///< GTIOCA Pin Function Select
    }

    /// GTINTAD Register bits
    namespace gtintad_bits {
        constexpr uint32_t GRPABL = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t GRPABH = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t GRPDTE = (1U << 28);  ///< Dead Time Error Output Disable Request Enable
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disable Source Select
        constexpr uint32_t ADTRBDEN = (1U << 19);  ///< GTADTRB Compare Match (Down-Counting) A/D Converter Start Request Interrupt Enable
        constexpr uint32_t ADTRBUEN = (1U << 18);  ///< GTADTRB Compare Match (Up-Counting) A/D Converter Start Request Interrupt Enable
        constexpr uint32_t ADTRADEN = (1U << 17);  ///< GTADTRA Compare Match (Down-Counting) A/D Converter Start Request Interrupt Enable
        constexpr uint32_t ADTRAUEN = (1U << 16);  ///< GTADTRA Compare Match (Up-Counting) A/D Converter Start Request Interrupt Enable
    }

    /// GTST Register bits
    namespace gtst_bits {
        constexpr uint32_t OABLF = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t OABHF = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t DTEF = (1U << 28);  ///< Dead Time Error Flag
        constexpr uint32_t ODF = (1U << 24);  ///< Output Disable Flag
        constexpr uint32_t TUCF = (1U << 15);  ///< Count Direction Flag
        constexpr uint32_t ITCNT = (3 << 8);  ///< GTCIV/GTCIU Interrupt Skipping Count Counter(Counter for counting the number of times a timer interrupt has been skipped.)
        constexpr uint32_t TCFPU = (1U << 7);  ///< Underflow Flag
        constexpr uint32_t TCFPO = (1U << 6);  ///< Overflow Flag
        constexpr uint32_t TCFF = (1U << 5);  ///< Input Compare Match Flag F
        constexpr uint32_t TCFE = (1U << 4);  ///< Input Compare Match Flag E
        constexpr uint32_t TCFD = (1U << 3);  ///< Input Compare Match Flag D
        constexpr uint32_t TCFC = (1U << 2);  ///< Input Compare Match Flag C
        constexpr uint32_t TCFB = (1U << 1);  ///< Input Capture/Compare Match Flag B
        constexpr uint32_t TCFA = (1U << 0);  ///< Input Capture/Compare Match Flag A
    }

    /// GTBER Register bits
    namespace gtber_bits {
        constexpr uint32_t ADTDB = (1U << 30);  ///< GTADTRB Double Buffer Operation
        constexpr uint32_t ADTTB = (2 << 28);  ///< GTADTRB Buffer Transfer Timing Select in the Triangle wavesNOTE: In the Saw waves, values other than 0 0: Transfer at an underflow (in down-counting) or overflow (in up-counting) is performed.
        constexpr uint32_t ADTDA = (1U << 26);  ///< GTADTRA Double Buffer Operation
        constexpr uint32_t ADTTA = (2 << 24);  ///< GTADTRA Buffer Transfer Timing Select in the Triangle wavesNOTE: In the Saw waves, values other than 0 0: Transfer at an underflow (in down-counting) or overflow (in up-counting) is performed.
        constexpr uint32_t CCRSWT = (1U << 22);  ///< GTCCRA and GTCCRB Forcible Buffer OperationThis bit is read as 0.
        constexpr uint32_t PR = (2 << 20);  ///< GTPR Buffer Operation
        constexpr uint32_t CCRB = (2 << 18);  ///< GTCCRB Buffer Operation
        constexpr uint32_t CCRA = (2 << 16);  ///< GTCCRA Buffer Operation
        constexpr uint32_t BD = (4 << 0);  ///< BD[3]: GTDV Buffer Operation DisableBD[2]: GTADTR Buffer Operation DisableBD[1]: GTPR Buffer Operation DisableBD[0]: GTCCR Buffer Operation Disable
    }

    /// GTITC Register bits
    namespace gtitc_bits {
        constexpr uint32_t ADTBL = (1U << 14);  ///< GTADTRB A/D Converter Start Request Link
        constexpr uint32_t ADTAL = (1U << 12);  ///< GTADTRA A/D Converter Start Request Link
        constexpr uint32_t IVTT = (3 << 8);  ///< GPT_OVF/GPT_UDF Interrupt Skipping Count Select
        constexpr uint32_t IVTC = (2 << 6);  ///< GPT_OVF/GPT_UDF Interrupt Skipping Function Select
        constexpr uint32_t ITLF = (1U << 5);  ///< GTCCRF Compare Match Interrupt Link
        constexpr uint32_t ITLE = (1U << 4);  ///< GTCCRE Compare Match Interrupt Link
        constexpr uint32_t ITLD = (1U << 3);  ///< GTCCRD Compare Match Interrupt Link
        constexpr uint32_t ITLC = (1U << 2);  ///< GTCCRC Compare Match Interrupt Link
        constexpr uint32_t ITLB = (1U << 1);  ///< GTCCRB Compare Match/Input Capture Interrupt Link
        constexpr uint32_t ITLA = (1U << 0);  ///< GTCCRA Compare Match/Input Capture Interrupt Link
    }

    /// GTCNT Register bits
    namespace gtcnt_bits {
        constexpr uint32_t GTCNT = (32 << 0);  ///< Counter
    }

    /// GTCCRA Register bits
    namespace gtccra_bits {
        constexpr uint32_t GTCCRA = (32 << 0);  ///< Compare Capture Register A
    }

    /// GTCCRB Register bits
    namespace gtccrb_bits {
        constexpr uint32_t GTCCRB = (32 << 0);  ///< Compare Capture Register B
    }

    /// GTCCRC Register bits
    namespace gtccrc_bits {
        constexpr uint32_t GTCCRC = (32 << 0);  ///< Compare Capture Register C
    }

    /// GTCCRE Register bits
    namespace gtccre_bits {
        constexpr uint32_t GTCCRE = (32 << 0);  ///< Compare Capture Register E
    }

    /// GTCCRD Register bits
    namespace gtccrd_bits {
        constexpr uint32_t GTCCRD = (32 << 0);  ///< Compare Capture Register D
    }

    /// GTCCRF Register bits
    namespace gtccrf_bits {
        constexpr uint32_t GTCCRF = (32 << 0);  ///< Compare Capture Register F
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GTPR = (32 << 0);  ///< Cycle Setting Register
    }

    /// GTPBR Register bits
    namespace gtpbr_bits {
        constexpr uint32_t GTPBR = (32 << 0);  ///< Cycle Setting Buffer Register
    }

    /// GTPDBR Register bits
    namespace gtpdbr_bits {
        constexpr uint32_t GTPDBR = (32 << 0);  ///< Cycle Setting Double-Buffer Register
    }

    /// GTADTRA Register bits
    namespace gtadtra_bits {
        constexpr uint32_t GTADTRA = (32 << 0);  ///< A/D Converter Start Request Timing Register A
    }

    /// GTADTRB Register bits
    namespace gtadtrb_bits {
        constexpr uint32_t GTADTRB = (32 << 0);  ///< A/D Converter Start Request Timing Register B
    }

    /// GTADTBRA Register bits
    namespace gtadtbra_bits {
        constexpr uint32_t GTADTBRA = (32 << 0);  ///< A/D Converter Start Request Timing Buffer Register A
    }

    /// GTADTBRB Register bits
    namespace gtadtbrb_bits {
        constexpr uint32_t GTADTBRB = (32 << 0);  ///< A/D Converter Start Request Timing Buffer Register B
    }

    /// GTADTDBRA Register bits
    namespace gtadtdbra_bits {
        constexpr uint32_t GTADTDBRA = (32 << 0);  ///< A/D Converter Start Request Timing Double-Buffer Register A
    }

    /// GTADTDBRB Register bits
    namespace gtadtdbrb_bits {
        constexpr uint32_t GTADTDBRB = (32 << 0);  ///< A/D Converter Start Request Timing Double-Buffer Register B
    }

    /// GTDTCR Register bits
    namespace gtdtcr_bits {
        constexpr uint32_t TDFER = (1U << 8);  ///< GTDVD Setting
        constexpr uint32_t TDBDE = (1U << 5);  ///< GTDVD Buffer Operation Enable
        constexpr uint32_t TDBUE = (1U << 4);  ///< GTDVU Buffer Operation Enable
        constexpr uint32_t TDE = (1U << 0);  ///< Negative-Phase Waveform Setting
    }

    /// GTDVU Register bits
    namespace gtdvu_bits {
        constexpr uint32_t GTDVU = (32 << 0);  ///< Dead Time Value Register U
    }

    /// GTDVD Register bits
    namespace gtdvd_bits {
        constexpr uint32_t GTDVD = (32 << 0);  ///< Dead Time Value Register D
    }

    /// GTDBU Register bits
    namespace gtdbu_bits {
        constexpr uint32_t GTDVU = (32 << 0);  ///< Dead Time Buffer Register U
    }

    /// GTDBD Register bits
    namespace gtdbd_bits {
        constexpr uint32_t GTDBD = (32 << 0);  ///< Dead Time Buffer Register D
    }

    /// GTSOS Register bits
    namespace gtsos_bits {
        constexpr uint32_t SOS = (2 << 0);  ///< Output Protection Function Status
    }

    /// GTSOTR Register bits
    namespace gtsotr_bits {
        constexpr uint32_t SOTR = (1U << 0);  ///< Output Protection Function Temporary Release
    }

}

// ============================================================================
// GPT32EH1 Peripheral
// ============================================================================

namespace gpt32eh1 {
    /// Base addresses
    constexpr uint32_t GPT32EH1_BASE = 0x40078100;

    /// GPT32EH1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32EH1 = reinterpret_cast<Registers*>(GPT32EH1_BASE);

}

// ============================================================================
// GPT32EH2 Peripheral
// ============================================================================

namespace gpt32eh2 {
    /// Base addresses
    constexpr uint32_t GPT32EH2_BASE = 0x40078200;

    /// GPT32EH2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32EH2 = reinterpret_cast<Registers*>(GPT32EH2_BASE);

}

// ============================================================================
// GPT32EH3 Peripheral
// ============================================================================

namespace gpt32eh3 {
    /// Base addresses
    constexpr uint32_t GPT32EH3_BASE = 0x40078300;

    /// GPT32EH3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32EH3 = reinterpret_cast<Registers*>(GPT32EH3_BASE);

}

// ============================================================================
// GPT32E4 Peripheral
// ============================================================================

namespace gpt32e4 {
    /// Base addresses
    constexpr uint32_t GPT32E4_BASE = 0x40078400;

    /// GPT32E4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32E4 = reinterpret_cast<Registers*>(GPT32E4_BASE);

}

// ============================================================================
// GPT32E5 Peripheral
// ============================================================================

namespace gpt32e5 {
    /// Base addresses
    constexpr uint32_t GPT32E5_BASE = 0x40078500;

    /// GPT32E5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32E5 = reinterpret_cast<Registers*>(GPT32E5_BASE);

}

// ============================================================================
// GPT32E6 Peripheral
// ============================================================================

namespace gpt32e6 {
    /// Base addresses
    constexpr uint32_t GPT32E6_BASE = 0x40078600;

    /// GPT32E6 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32E6 = reinterpret_cast<Registers*>(GPT32E6_BASE);

}

// ============================================================================
// GPT32E7 Peripheral
// ============================================================================

namespace gpt32e7 {
    /// Base addresses
    constexpr uint32_t GPT32E7_BASE = 0x40078700;

    /// GPT32E7 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32E7 = reinterpret_cast<Registers*>(GPT32E7_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USBHS_BASE = 0x40060000;
    constexpr uint32_t USBFS_BASE = 0x40090000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t SYSCFG;  ///< Offset: 0x00 - System Configuration Control Register
        volatile uint32_t BUSWAIT;  ///< Offset: 0x02 - CPU Bus Wait Register
        volatile uint32_t SYSSTS0;  ///< Offset: 0x04 - System Configuration Status Register
        volatile uint32_t PLLSTA;  ///< Offset: 0x06 - PLL Status Register
        volatile uint32_t DVSTCTR0;  ///< Offset: 0x08 - Device State Control Register 0
        volatile uint32_t TESTMODE;  ///< Offset: 0x0C - USB Test Mode Register
        volatile uint32_t CFIFO;  ///< Offset: 0x14 - CFIFO Port Register
        volatile uint32_t CFIFOL;  ///< Offset: 0x14 - CFIFO Port Register L
        volatile uint32_t CFIFOH;  ///< Offset: 0x16 - CFIFO Port Register H
        volatile uint32_t CFIFOLL;  ///< Offset: 0x14 - CFIFO Port Register LL
        volatile uint32_t CFIFOHH;  ///< Offset: 0x17 - CFIFO Port Register HH
        volatile uint32_t D0FIFO;  ///< Offset: 0x18 - D0FIFO Port Register
        volatile uint32_t D0FIFOL;  ///< Offset: 0x18 - D0FIFO Port Register L
        volatile uint32_t D0FIFOH;  ///< Offset: 0x1A - D0FIFO Port Register H
        volatile uint32_t D0FIFOLL;  ///< Offset: 0x18 - D0FIFO Port Register LL
        volatile uint32_t D0FIFOHH;  ///< Offset: 0x1B - D0FIFO Port Register HH
        volatile uint32_t D1FIFO;  ///< Offset: 0x1C - D1FIFO Port Register
        volatile uint32_t D1FIFOL;  ///< Offset: 0x1C - D1FIFO Port Register L
        volatile uint32_t D1FIFOH;  ///< Offset: 0x1E - D1FIFO Port Register H
        volatile uint32_t D1FIFOLL;  ///< Offset: 0x1C - D1FIFO Port Register LL
        volatile uint32_t D1FIFOHH;  ///< Offset: 0x1F - D1FIFO Port Register HH
        volatile uint32_t CFIFOSEL;  ///< Offset: 0x20 - CFIFO Port Select Register
        volatile uint32_t D0FIFOSEL;  ///< Offset: 0x28 - D0FIFO Port Select Register
        volatile uint32_t D1FIFOSEL;  ///< Offset: 0x2C - D1FIFO Port Select Register
        volatile uint32_t CFIFOCTR;  ///< Offset: 0x22 - CFIFO Port Control Register
        volatile uint32_t D0FIFOCTR;  ///< Offset: 0x2A - D0FIFO Port Control Register
        volatile uint32_t D1FIFOCTR;  ///< Offset: 0x2E - D1FIFO Port Control Register
        volatile uint32_t INTENB0;  ///< Offset: 0x30 - Interrupt Enable Register 0
        volatile uint32_t INTENB1;  ///< Offset: 0x32 - Interrupt Enable Register 1
        volatile uint32_t BRDYENB;  ///< Offset: 0x36 - BRDY Interrupt Enable Register
        volatile uint32_t NRDYENB;  ///< Offset: 0x38 - NRDY Interrupt Enable Register
        volatile uint32_t BEMPENB;  ///< Offset: 0x3A - BEMP Interrupt Enable Register
        volatile uint32_t SOFCFG;  ///< Offset: 0x3C - SOF Pin Configuration Register
        volatile uint32_t PHYSET;  ///< Offset: 0x3E - PHY Setting Register
        volatile uint32_t INTSTS0;  ///< Offset: 0x40 - Interrupt Status Register 0
        volatile uint32_t INTSTS1;  ///< Offset: 0x42 - Interrupt Status Register 1
        volatile uint32_t BRDYSTS;  ///< Offset: 0x46 - BRDY Interrupt Status Register
        volatile uint32_t NRDYSTS;  ///< Offset: 0x48 - NRDY Interrupt Status Register
        volatile uint32_t BEMPSTS;  ///< Offset: 0x4A - BEMP Interrupt Status Register
        volatile uint32_t FRMNUM;  ///< Offset: 0x4C - Frame Number Register
        volatile uint32_t UFRMNUM;  ///< Offset: 0x4E - uFrame Number Register
        volatile uint32_t USBADDR;  ///< Offset: 0x50 - USB Address Register
        volatile uint32_t USBREQ;  ///< Offset: 0x54 - USB Request Type Register
        volatile uint32_t USBVAL;  ///< Offset: 0x56 - USB Request Value Register
        volatile uint32_t USBINDX;  ///< Offset: 0x58 - USB Request Index Register
        volatile uint32_t USBLENG;  ///< Offset: 0x5A - USB Request Length Register
        volatile uint32_t DCPCFG;  ///< Offset: 0x5C - DCP Configuration Register
        volatile uint32_t DCPMAXP;  ///< Offset: 0x5E - DCP Maximum Packet Size Register
        volatile uint32_t DCPCTR;  ///< Offset: 0x60 - DCP Control Register
        volatile uint32_t PIPESEL;  ///< Offset: 0x64 - Pipe Window Select Register
        volatile uint32_t PIPECFG;  ///< Offset: 0x68 - Pipe Configuration Register
        volatile uint32_t PIPEBUF;  ///< Offset: 0x6A - Pipe Buffer Register
        volatile uint32_t PIPEMAXP;  ///< Offset: 0x6C - Pipe Maximum Packet Size Register
        volatile uint32_t PIPEPERI;  ///< Offset: 0x6E - Pipe Cycle Control Register
        volatile uint32_t PIPE%sCTR;  ///< Offset: 0x70 - PIPE Control Register
        volatile uint32_t PIPE%sTRE;  ///< Offset: 0x90 - PIPE Transaction Counter Enable Register
        volatile uint32_t PIPE%sTRN;  ///< Offset: 0x92 - PIPE Transaction Counter Register
        volatile uint32_t DEVADD%s;  ///< Offset: 0xD0 - Device Address Configuration Register
        volatile uint32_t DEVADDA;  ///< Offset: 0xE4 - Device Address Configuration Register A
        volatile uint32_t LPCTRL;  ///< Offset: 0x100 - Low Power Control Register
        volatile uint32_t LPSTS;  ///< Offset: 0x102 - Low Power Status Register
        volatile uint32_t BCCTRL;  ///< Offset: 0x140 - Battery Charging Control Register
        volatile uint32_t PL1CTRL1;  ///< Offset: 0x144 - Function L1 Control Register 1
        volatile uint32_t PL1CTRL2;  ///< Offset: 0x146 - Function L1 Control Register 2
        volatile uint32_t HL1CTRL1;  ///< Offset: 0x148 - Host L1 Control Register 1
        volatile uint32_t HL1CTRL2;  ///< Offset: 0x14A - Host L1 Control Register 2
        volatile uint32_t DPUSR0R;  ///< Offset: 0x160 - Deep Standby USB Transceiver Control/Pin Monitor Register
        volatile uint32_t DPUSR1R;  ///< Offset: 0x164 - Deep Standby USB Suspend/Resume Interrupt Register
        volatile uint32_t DPUSR2R;  ///< Offset: 0x168 - Deep Standby USB Suspend/Resume Interrupt Register
        volatile uint32_t DPUSRCR;  ///< Offset: 0x16A - Deep Standby USB Suspend/Resume Command Register
    };

    /// Peripheral instances
    inline Registers* USBHS = reinterpret_cast<Registers*>(USBHS_BASE);
    inline Registers* USBFS = reinterpret_cast<Registers*>(USBFS_BASE);

    // Bit definitions
    /// SYSCFG Register bits
    namespace syscfg_bits {
        constexpr uint32_t CNEN = (1U << 8);  ///< Single End Receiver Enable
        constexpr uint32_t HSE = (1U << 7);  ///< High-Speed Operation Enable
        constexpr uint32_t DCFM = (1U << 6);  ///< Controller Function Select
        constexpr uint32_t DRPD = (1U << 5);  ///< D+/D- Line Resistor Control
        constexpr uint32_t DPRPU = (1U << 4);  ///< D+ Line Resistor Control
        constexpr uint32_t USBE = (1U << 0);  ///< USB Operation Enable
    }

    /// BUSWAIT Register bits
    namespace buswait_bits {
        constexpr uint32_t BWAIT = (4 << 0);  ///< CPU Bus Access Wait Specification BWAIT waits (BWAIT+2 access cycles)
    }

    /// SYSSTS0 Register bits
    namespace syssts0_bits {
        constexpr uint32_t OVCMON = (2 << 14);  ///< External USB1_OVRCURA/USB1_OVRCURB Input Pin MonitorThe OCVMON[1] bit indicates the status of the USBHS_OVRCURA pin. The OCVMON[0] bit indicates the status of the USBHS_OVRCURB pin.
        constexpr uint32_t HTACT = (1U << 6);  ///< Host Sequencer Status Monitor
        constexpr uint32_t SOFEA = (1U << 5);  ///< SOF Active Monitor While Host Controller Function is Selected.
        constexpr uint32_t IDMON = (1U << 2);  ///< ID0 Pin Monitor
        constexpr uint32_t LNST = (2 << 0);  ///< USB Data Line Status Monitor
    }

    /// PLLSTA Register bits
    namespace pllsta_bits {
        constexpr uint32_t PLLLOCK = (1U << 0);  ///< PLL Lock Flag
    }

    /// DVSTCTR0 Register bits
    namespace dvstctr0_bits {
        constexpr uint32_t HNPBTOA = (1U << 11);  ///< Host Negotiation Protocol (HNP) Control Use this bit when switching from device B to device A in OTGmode. If the HNPBTOA bit is 1, the internal function controlremains in the Suspend state until the HNP processing endseven if SYSCFG.DPRPU = 0 or SYSCFG.DCFM = 1 is set.
        constexpr uint32_t EXICEN = (1U << 10);  ///< USBHS_EXICEN Output Pin Control
        constexpr uint32_t VBUSEN = (1U << 9);  ///< USBHS_VBUSEN Output Pin Control
        constexpr uint32_t WKUP = (1U << 8);  ///< Remote Wakeup Output for the Device Controller Operation
        constexpr uint32_t RWUPE = (1U << 7);  ///< Remote Wakeup Detection Enable for the Host Controller Operation
        constexpr uint32_t USBRST = (1U << 6);  ///< USB Bus Reset Output for the Host Controller Operation
        constexpr uint32_t RESUME = (1U << 5);  ///< Resume Signal Output for the Host Controller Operation
        constexpr uint32_t UACT = (1U << 4);  ///< USB Bus Operation Enable for the Host Controller Operation
        constexpr uint32_t RHST = (3 << 0);  ///< USB Bus Reset Status
    }

    /// TESTMODE Register bits
    namespace testmode_bits {
        constexpr uint32_t UTST = (4 << 0);  ///< Test Mode
    }

    /// CFIFO Register bits
    namespace cfifo_bits {
        constexpr uint32_t FIFOPORT = (32 << 0);  ///< FIFO Port.Read receive data from the FIFO buffer or write transmit data to the FIFO buffer by accessing these bits.
    }

    /// D0FIFO Register bits
    namespace d0fifo_bits {
        constexpr uint32_t FIFOPORT = (32 << 0);  ///< FIFO Port Read receive data from the FIFO buffer or write transmit data to the FIFO buffer by accessing these bits.
    }

    /// D1FIFO Register bits
    namespace d1fifo_bits {
        constexpr uint32_t FIFOPORT = (32 << 0);  ///< FIFO PortRead receive data from the FIFO buffer or write transmit data to the FIFO buffer by accessing these bits.
    }

    /// CFIFOSEL Register bits
    namespace cfifosel_bits {
        constexpr uint32_t RCNT = (1U << 15);  ///< Read Count Mode
        constexpr uint32_t REW = (1U << 14);  ///< Buffer Pointer Rewind
        constexpr uint32_t MBW = (2 << 10);  ///< CFIFO Port Access Bit Width
        constexpr uint32_t BIGEND = (1U << 8);  ///< FIFO Port Endian Control
        constexpr uint32_t ISEL = (1U << 5);  ///< FIFO Port Access Direction when DCP is Selected
        constexpr uint32_t CURPIPE = (4 << 0);  ///< FIFO Port Access Pipe Specification
    }

    /// D0FIFOSEL Register bits
    namespace d0fifosel_bits {
        constexpr uint32_t RCNT = (1U << 15);  ///< Read Count Mode
        constexpr uint32_t REW = (1U << 14);  ///< Buffer Pointer Rewind
        constexpr uint32_t DCLRM = (1U << 13);  ///< Auto Buffer Memory Clear Mode Accessed after Specified Pipe Data is Read
        constexpr uint32_t DREQE = (1U << 12);  ///< UCL_Dx_DREQ Signal Output Enable
        constexpr uint32_t MBW = (2 << 10);  ///< FIFO Port Access Bit Width
        constexpr uint32_t BIGEND = (1U << 8);  ///< FIFO Port Endian Control
        constexpr uint32_t CURPIPE = (4 << 0);  ///< FIFO Port Access Pipe Specification
    }

    /// D1FIFOSEL Register bits
    namespace d1fifosel_bits {
        constexpr uint32_t RCNT = (1U << 15);  ///< Read Count Mode
        constexpr uint32_t REW = (1U << 14);  ///< Buffer Pointer Rewind
        constexpr uint32_t DCLRM = (1U << 13);  ///< Auto Buffer Memory Clear Mode Accessed after Specified Pipe Data is Read
        constexpr uint32_t DREQE = (1U << 12);  ///< UCL_Dx_DREQ Signal Output Enable
        constexpr uint32_t MBW = (2 << 10);  ///< FIFO Port Access Bit Width
        constexpr uint32_t BIGEND = (1U << 8);  ///< FIFO Port Endian Control
        constexpr uint32_t CURPIPE = (4 << 0);  ///< FIFO Port Access Pipe Specification
    }

    /// CFIFOCTR Register bits
    namespace cfifoctr_bits {
        constexpr uint32_t BVAL = (1U << 15);  ///< Buffer Memory Valid Flag
        constexpr uint32_t BCLR = (1U << 14);  ///< CPU Buffer Clear
        constexpr uint32_t FRDY = (1U << 13);  ///< FIFO Port ReadyIndicates whether the FIFO port can be accessed.
        constexpr uint32_t DTLN = (12 << 0);  ///< Receive Data Length.Indicates the length of the receive data.
    }

    /// D0FIFOCTR Register bits
    namespace d0fifoctr_bits {
        constexpr uint32_t BVAL = (1U << 15);  ///< Buffer Memory Valid Flag
        constexpr uint32_t BCLR = (1U << 14);  ///< CPU Buffer Clear
        constexpr uint32_t FRDY = (1U << 13);  ///< FIFO Port ReadyIndicates whether the FIFO port can be accessed.
        constexpr uint32_t DTLN = (12 << 0);  ///< Receive Data Length.Indicates the length of the receive data.
    }

    /// D1FIFOCTR Register bits
    namespace d1fifoctr_bits {
        constexpr uint32_t BVAL = (1U << 15);  ///< Buffer Memory Valid Flag
        constexpr uint32_t BCLR = (1U << 14);  ///< CPU Buffer Clear
        constexpr uint32_t FRDY = (1U << 13);  ///< FIFO Port ReadyIndicates whether the FIFO port can be accessed.
        constexpr uint32_t DTLN = (12 << 0);  ///< Receive Data Length.Indicates the length of the receive data.
    }

    /// INTENB0 Register bits
    namespace intenb0_bits {
        constexpr uint32_t VBSE = (1U << 15);  ///< VBUS Interrupt Enable
        constexpr uint32_t RSME = (1U << 14);  ///< Resume Interrupt Enable
        constexpr uint32_t SOFE = (1U << 13);  ///< Frame Number Update Interrupt Enable
        constexpr uint32_t DVSE = (1U << 12);  ///< Device State Transition Interrupt Enable
        constexpr uint32_t CTRE = (1U << 11);  ///< Control Transfer Stage Transition Interrupt Enable
        constexpr uint32_t BEMPE = (1U << 10);  ///< Buffer Empty Interrupt Enable
        constexpr uint32_t NRDYE = (1U << 9);  ///< Buffer Not Ready Response Interrupt Enable
        constexpr uint32_t BRDYE = (1U << 8);  ///< Buffer Ready Interrupt Enable
    }

    /// INTENB1 Register bits
    namespace intenb1_bits {
        constexpr uint32_t OVRCRE = (1U << 15);  ///< OVRCRE Interrupt Enable
        constexpr uint32_t BCHGE = (1U << 14);  ///< USB Bus Change Interrupt Enable
        constexpr uint32_t DTCHE = (1U << 12);  ///< Disconnection Detection Interrupt Enable
        constexpr uint32_t ATTCHE = (1U << 11);  ///< Connection Detection Interrupt Enable
        constexpr uint32_t L1RSMENDE = (1U << 9);  ///< L1 Resume End Interrupt Enable
        constexpr uint32_t LPMENDE = (1U << 8);  ///< LPM Transaction End Interrupt Enable
        constexpr uint32_t EOFERRE = (1U << 6);  ///< EOF Error Detection Interrupt Enable
        constexpr uint32_t SIGNE = (1U << 5);  ///< Setup Transaction Error Interrupt Enable
        constexpr uint32_t SACKE = (1U << 4);  ///< Setup Transaction Normal Response Interrupt Enable
        constexpr uint32_t PDDETINTE = (1U << 0);  ///< PDDETINT Detection Interrupt Enable
    }

    /// BRDYENB Register bits
    namespace brdyenb_bits {
        constexpr uint32_t PIPEBRDYE = (10 << 0);  ///< BRDY Interrupt Enable for Each Pipe
    }

    /// NRDYENB Register bits
    namespace nrdyenb_bits {
        constexpr uint32_t PIPENRDYE = (10 << 0);  ///< NRDY Interrupt Enable for Each Pipe
    }

    /// BEMPENB Register bits
    namespace bempenb_bits {
        constexpr uint32_t PIPEBEMPE = (10 << 0);  ///< BEMP Interrupt Enable for Each Pipe
    }

    /// SOFCFG Register bits
    namespace sofcfg_bits {
        constexpr uint32_t TRNENSEL = (1U << 8);  ///< Transaction-Enabled Time Select.The transfer efficiency can be improved by setting this bit to 1 if no low-speed device is connected directly or via FS-HUB to the USB port.
        constexpr uint32_t BRDYM = (1U << 6);  ///< PIPEBRDY Interrupt Status Clear Timing.This bit can be set only in the initial setting (before communications).The setting cannot be changed once communication starts.
        constexpr uint32_t INTL = (1U << 5);  ///< Interrupt Output Sense Select
        constexpr uint32_t EDGESTS = (1U << 4);  ///< Interrupt Edge Processing Status Monitor
    }

    /// PHYSET Register bits
    namespace physet_bits {
        constexpr uint32_t HSEB = (1U << 15);  ///< CL-Only Mode
        constexpr uint32_t REPSTART = (1U << 11);  ///< Forcibly Start Terminating Resistance Adjustment
        constexpr uint32_t REPSEL = (2 << 8);  ///< Terminating Resistance Adjustment Cycle
        constexpr uint32_t CLKSEL = (2 << 4);  ///< Input System Clock Frequency
        constexpr uint32_t CDPEN = (1U << 3);  ///< Charging Downstream Port Enable
        constexpr uint32_t PLLRESET = (1U << 1);  ///< PLL Reset Control
        constexpr uint32_t DIRPD = (1U << 0);  ///< Power-Down Control
    }

    /// INTSTS0 Register bits
    namespace intsts0_bits {
        constexpr uint32_t VBINT = (1U << 15);  ///< VBUS Interrupt Status
        constexpr uint32_t RESM = (1U << 14);  ///< Resume Interrupt Status
        constexpr uint32_t SOFR = (1U << 13);  ///< Frame Number Refresh Interrupt Status
        constexpr uint32_t DVST = (1U << 12);  ///< Device State Transition Interrupt Status
        constexpr uint32_t CTRT = (1U << 11);  ///< Control Transfer Stage Transition Interrupt Status
        constexpr uint32_t BEMP = (1U << 10);  ///< Buffer Empty Interrupt Status
        constexpr uint32_t NRDY = (1U << 9);  ///< Buffer Not Ready Interrupt Status
        constexpr uint32_t BRDY = (1U << 8);  ///< Buffer Ready Interrupt Status
        constexpr uint32_t VBSTS = (1U << 7);  ///< VBUS Input Status
        constexpr uint32_t DVSQ = (3 << 4);  ///< Device State
        constexpr uint32_t VALID = (1U << 3);  ///< USB Request Reception
        constexpr uint32_t CTSQ = (3 << 0);  ///< Control Transfer Stage
    }

    /// INTSTS1 Register bits
    namespace intsts1_bits {
        constexpr uint32_t OVRCR = (1U << 15);  ///< Overcurrent Interrupt Status
        constexpr uint32_t BCHG = (1U << 14);  ///< USB Bus Change Interrupt Status
        constexpr uint32_t DTCH = (1U << 12);  ///< USB Disconnection Detection Interrupt Status
        constexpr uint32_t ATTCH = (1U << 11);  ///< USB Connection Detection Interrupt Status
        constexpr uint32_t L1RSMEND = (1U << 9);  ///< L1 Resume End Interrupt Status
        constexpr uint32_t LPMEND = (1U << 8);  ///< LPM Transaction End Interrupt Status
        constexpr uint32_t EOFERR = (1U << 6);  ///< EOF Error Detection Interrupt Status
        constexpr uint32_t SIGN = (1U << 5);  ///< Setup Transaction Error Interrupt Status
        constexpr uint32_t SACK = (1U << 4);  ///< Setup Transaction Normal Response Interrupt Status
        constexpr uint32_t PDDETINT = (1U << 0);  ///< PDDET Detection Interrupt Status
    }

    /// BRDYSTS Register bits
    namespace brdysts_bits {
        constexpr uint32_t PIPEBRDY = (10 << 0);  ///< BRDY Interrupt Status for Each Pipe
    }

    /// NRDYSTS Register bits
    namespace nrdysts_bits {
        constexpr uint32_t PIPENRDY = (10 << 0);  ///< NRDY Interrupt Status for Each Pipe
    }

    /// BEMPSTS Register bits
    namespace bempsts_bits {
        constexpr uint32_t PIPEBEMP = (10 << 0);  ///< BEMP Interrupt Status for Each Pipe
    }

    /// FRMNUM Register bits
    namespace frmnum_bits {
        constexpr uint32_t OVRN = (1U << 15);  ///< Overrun/Underrun Detection Status
        constexpr uint32_t CRCE = (1U << 14);  ///< CRC Error Detection Status
        constexpr uint32_t FRNM = (11 << 0);  ///< Frame Number.Indicate the latest frame number.
    }

    /// UFRMNUM Register bits
    namespace ufrmnum_bits {
        constexpr uint32_t DVCHG = (1U << 15);  ///< Device State Change
        constexpr uint32_t UFRNM = (3 << 0);  ///< MicroframeIndicate the microframe number.
    }

    /// USBADDR Register bits
    namespace usbaddr_bits {
        constexpr uint32_t STSRECOV0 = (3 << 8);  ///< Status Recovery
        constexpr uint32_t USBADDR = (7 << 0);  ///< USB Address In device controller mode, these flags indicate the USB address assigned by the host when the USBHS processed the SET_ADDRESS request successfully.
    }

    /// USBREQ Register bits
    namespace usbreq_bits {
        constexpr uint32_t BREQUEST = (8 << 8);  ///< USB request bRequest value Finction controller selected : read-only Host controller selected : read-write
        constexpr uint32_t BMREQUESTTYPE = (8 << 0);  ///< USB request bmRequestType value Finction controller selected : read-only Host controller selected : read-write
    }

    /// USBVAL Register bits
    namespace usbval_bits {
        constexpr uint32_t WVALUE = (16 << 0);  ///< Value of USB request wValue Finction controller selected : read-only Host controller selected : read-write
    }

    /// USBINDX Register bits
    namespace usbindx_bits {
        constexpr uint32_t WINDEX = (16 << 0);  ///< Value of USB request wIndex Finction controller selected : read-only Host controller selected : read-write
    }

    /// USBLENG Register bits
    namespace usbleng_bits {
        constexpr uint32_t WLENGTH = (16 << 0);  ///< Value of USB request wLength Finction controller selected : read-only Host controller selected : read-write
    }

    /// DCPCFG Register bits
    namespace dcpcfg_bits {
        constexpr uint32_t CNTMD = (1U << 8);  ///< Continuous Transfer Mode
        constexpr uint32_t SHTNAK = (1U << 7);  ///< Pipe Blocking on End of Transfer
        constexpr uint32_t DIR = (1U << 4);  ///< Transfer Direction
    }

    /// DCPMAXP Register bits
    namespace dcpmaxp_bits {
        constexpr uint32_t DEVSEL = (4 << 12);  ///< Device SelectThese bits specify the address of the destination function device for control transfer when the host controller function is selected.
        constexpr uint32_t MXPS = (7 << 0);  ///< Maximum Packet SizeThese bits specify the maximum data payload (maximum packet size) for the DCP.
    }

    /// DCPCTR Register bits
    namespace dcpctr_bits {
        constexpr uint32_t BSTS = (1U << 15);  ///< Buffer Status
        constexpr uint32_t SUREQ = (1U << 14);  ///< SETUP Token Transmission
        constexpr uint32_t CSCLR = (1U << 13);  ///< Split Transaction CSPLIT Status Clear
        constexpr uint32_t CSSTS = (1U << 12);  ///< Split Transaction COMPLETE SPLIT(CSPLIT) Status
        constexpr uint32_t SUREQCLR = (1U << 11);  ///< SUREQ Bit Clear
        constexpr uint32_t SQCLR = (1U << 8);  ///< Toggle Bit Clear
        constexpr uint32_t SQSET = (1U << 7);  ///< Toggle Bit Set
        constexpr uint32_t SQMON = (1U << 6);  ///< Sequence Toggle Bit Monitor
        constexpr uint32_t PBUSY = (1U << 5);  ///< Pipe Busy
        constexpr uint32_t PINGE = (1U << 4);  ///< PING Token Issue Enable
        constexpr uint32_t CCPL = (1U << 2);  ///< Control Transfer End Enable
        constexpr uint32_t PID = (2 << 0);  ///< Response PID
    }

    /// PIPESEL Register bits
    namespace pipesel_bits {
        constexpr uint32_t PIPESEL = (4 << 0);  ///< Pipe Window SelectThese bits specify the pipe for registers at addresses 68H to 6EH.
    }

    /// PIPECFG Register bits
    namespace pipecfg_bits {
        constexpr uint32_t TYPE = (2 << 14);  ///< Transfer Type
        constexpr uint32_t BFRE = (1U << 10);  ///< BRDY Interrupt Operation Specification
        constexpr uint32_t DBLB = (1U << 9);  ///< Double Buffer Mode
        constexpr uint32_t CNTMD = (1U << 8);  ///< Continuous Transfer Mode
        constexpr uint32_t SHTNAK = (1U << 7);  ///< Pipe Disabled at End of Transfer
        constexpr uint32_t DIR = (1U << 4);  ///< Transfer Direction
        constexpr uint32_t EPNUM = (4 << 0);  ///< Endpoint Number
    }

    /// PIPEBUF Register bits
    namespace pipebuf_bits {
        constexpr uint32_t BUFSIZE = (5 << 10);  ///< Buffer Size 00h: 64 bytes 01h: 128 bytes : 1Fh: 2 Kbytes
        constexpr uint32_t BUFNMB = (8 << 0);  ///< Buffer NumberThese bits specify the FIFO buffer number of the selected pipe (04h to 87h).
    }

    /// PIPEMAXP Register bits
    namespace pipemaxp_bits {
        constexpr uint32_t DEVSEL = (4 << 12);  ///< Device SelectThese bits specify the address of the peripheral device when the host controller function is selected.
        constexpr uint32_t MXPS = (11 << 0);  ///< Maximum Packet SizeThese bits specify the maximum data payload (maximum packet size) for the selected pipe.A size of 1h to 40h bytes can be set for PIPE6 to PIPE9.
    }

    /// PIPEPERI Register bits
    namespace pipeperi_bits {
        constexpr uint32_t IFIS = (1U << 12);  ///< Isochronous IN Buffer Flush
        constexpr uint32_t IITV = (3 << 0);  ///< Interval Error Detection IntervalThese bits specify the transfer interval timing for the selected pipe as n-th power of 2 of the frame timing.
    }

    /// PIPE%sCTR Register bits
    namespace pipe%sctr_bits {
        constexpr uint32_t BSTS = (1U << 15);  ///< Buffer StatusThis bit indicates the FIFO buffer status for the relevant pipe.
        constexpr uint32_t INBUFM = (1U << 14);  ///< Transmit Buffer MonitorThis bit indicates the FIFO buffer status for the relevant pipe in the transmitting direction.
        constexpr uint32_t CSCLR = (1U << 13);  ///< CSPLIT Status ClearSet this bit to 1 when clearing the CSSTS bit of the relevant pipe
        constexpr uint32_t CSSTS = (1U << 12);  ///< CSSTS StatusThis bit indicates the CSPLIT status of Split Transaction of the relevant pipe
        constexpr uint32_t ATREPM = (1U << 10);  ///< Auto Response ModeThis bit enables or disables auto response mode for the relevant pipe.
        constexpr uint32_t ACLRM = (1U << 9);  ///< Auto Buffer Clear ModeThis bit enables or disables auto buffer clear mode for the relevant pipe
        constexpr uint32_t SQCLR = (1U << 8);  ///< Toggle Bit ClearThis bit is set to 1 when the expected value of the sequence toggle bit for the next transaction of the relevant pipe is cleared to DATA0
        constexpr uint32_t SQSET = (1U << 7);  ///< Toggle Bit SetThis bit is set to 1 when the expected value of the sequence toggle bit for the next transaction of the relevant pipe is set for DATA1
        constexpr uint32_t SQMON = (1U << 6);  ///< Toggle Bit ConfirmationThis bit indicates the expected value of the sequence toggle bit for the next transaction of the relevant pipe
        constexpr uint32_t PBUSY = (1U << 5);  ///< Pipe BusyThis bit indicates whether the relevant pipe is being used for the USB bus
        constexpr uint32_t PID = (2 << 0);  ///< Response PIDThese bits specify the response type for the next transaction of the relevant pipe.
    }

    /// PIPE%sTRE Register bits
    namespace pipe%stre_bits {
        constexpr uint32_t TRENB = (1U << 9);  ///< Transaction Counter EnableEnables or disables the transaction counter function.
        constexpr uint32_t TRCLR = (1U << 8);  ///< Transaction Counter ClearSetting this bit to 1 allows clearing the transaction counter to 0.
    }

    /// PIPE%sTRN Register bits
    namespace pipe%strn_bits {
        constexpr uint32_t TRNCNT = (16 << 0);  ///< Transaction CounterWhen writing to: Specify the number of total packets (number of transactions) to be received by the relevant PIPE.When read from: When TRENB = 0: Indicate the specified number of transactions.When TRENB = 1: Indicate the number of currently counted transactions.
    }

    /// DEVADD%s Register bits
    namespace devadd%s_bits {
        constexpr uint32_t UPPHUB = (4 << 11);  ///< Communication Target Connecting Hub Register
        constexpr uint32_t HUBPORT = (3 << 8);  ///< Communication Target Connecting Hub Port
        constexpr uint32_t USBSPD = (2 << 6);  ///< Transfer Speed of Communication Target Device
    }

    /// DEVADDA Register bits
    namespace devadda_bits {
        constexpr uint32_t UPPHUB = (4 << 11);  ///< Communication Target Connecting Hub Register
        constexpr uint32_t HUBPORT = (3 << 8);  ///< Communication Target Connecting Hub Port
        constexpr uint32_t USBSPD = (2 << 6);  ///< Transfer Speed of Communication Target Device
    }

    /// LPCTRL Register bits
    namespace lpctrl_bits {
        constexpr uint32_t HWUPM = (1U << 7);  ///< Resume Return Mode Setting
    }

    /// LPSTS Register bits
    namespace lpsts_bits {
        constexpr uint32_t SUSPENDM = (1U << 14);  ///< UTMI SuspendM Control
    }

    /// BCCTRL Register bits
    namespace bcctrl_bits {
        constexpr uint32_t PDDETSTS = (1U << 9);  ///< PDDET Status
        constexpr uint32_t CHGDETSTS = (1U << 8);  ///< CHGDET Status
        constexpr uint32_t DCPMODE = (1U << 5);  ///< DCP Mode Control
        constexpr uint32_t VDMSRCE = (1U << 4);  ///< VDMSRC Control
        constexpr uint32_t IDPSINKE = (1U << 3);  ///< IDPSINK Control
        constexpr uint32_t VDPSRCE = (1U << 2);  ///< VDPSRC Control
        constexpr uint32_t IDMSINKE = (1U << 1);  ///< IDMSINK Control
        constexpr uint32_t IDPSRCE = (1U << 0);  ///< IDPSRC Control
    }

    /// PL1CTRL1 Register bits
    namespace pl1ctrl1_bits {
        constexpr uint32_t L1EXTMD = (1U << 14);  ///< PHY Control Mode at L1 Return
        constexpr uint32_t HIRDTHR = (4 << 8);  ///< L1 Response Negotiation Threshold ValueHIRD threshold value used for L1NEGOMD.The format is the same as the HIRD field in HL1CTRL.
        constexpr uint32_t DVSQ = (4 << 4);  ///< DVSQ Extension.DVSQ[3] is Mirror of DVSQ[2:0] in INTSTS0.Indicates the L1 state together with the device state bits DVSQ[2:0].
        constexpr uint32_t L1NEGOMD = (1U << 3);  ///< L1 Response Negotiation Control.NOTE: This bit is valid only when the L1RESPMD[1:0] value is 2'b11.
        constexpr uint32_t L1RESPMD = (2 << 1);  ///< L1 Response Mode
        constexpr uint32_t L1RESPEN = (1U << 0);  ///< L1 Response Enable
    }

    /// PL1CTRL2 Register bits
    namespace pl1ctrl2_bits {
        constexpr uint32_t RWEMON = (1U << 12);  ///< RWE Value Monitor
        constexpr uint32_t HIRDMON = (4 << 8);  ///< HIRD Value Monitor
    }

    /// HL1CTRL1 Register bits
    namespace hl1ctrl1_bits {
        constexpr uint32_t L1STATUS = (2 << 1);  ///< L1 Request Completion Status
        constexpr uint32_t L1REQ = (1U << 0);  ///< L1 Transition Request
    }

    /// HL1CTRL2 Register bits
    namespace hl1ctrl2_bits {
        constexpr uint32_t BESL = (1U << 15);  ///< BESL & Alternate HIRDThis bit selects the K-State drive period at the time of L1 Resume.
        constexpr uint32_t L1RWE = (1U << 12);  ///< LPM Token L1 RemoteWake EnableThese bits specify the value to be set in the RWE field of LPM token.
        constexpr uint32_t HIRD = (4 << 8);  ///< LPM Token HIRD
        constexpr uint32_t L1ADDR = (4 << 0);  ///< LPM Token DeviceAddressThese bits specify the value to be set in the ADDR field of LPM token.
    }

    /// DPUSR0R Register bits
    namespace dpusr0r_bits {
        constexpr uint32_t DVBSTSHM = (1U << 23);  ///< VBUS InputIndicates VBUS input signal on the HS side of USB port.
        constexpr uint32_t DOVCBHM = (1U << 21);  ///< OVRCURB InputIndicates OVRCURB input signal on the HS side of USB port.
        constexpr uint32_t DOVCAHM = (1U << 20);  ///< OVRCURA InputIndicates OVRCURA input signal on the HS side of USB port.
    }

    /// DPUSR1R Register bits
    namespace dpusr1r_bits {
        constexpr uint32_t DVBSTSH = (1U << 23);  ///< Indication of Return from VBUS Interrupt Source
        constexpr uint32_t DOVCBH = (1U << 21);  ///< Indication of Return from OVRCURB Interrupt Source
        constexpr uint32_t DOVCAH = (1U << 20);  ///< Indication of Return from OVRCURA Interrupt Source
        constexpr uint32_t DVBSTSHE = (1U << 7);  ///< VBUS Interrupt Enable/Clear
        constexpr uint32_t DOVCBHE = (1U << 5);  ///< OVRCURB Interrupt Enable Clear
        constexpr uint32_t DOVCAHE = (1U << 4);  ///< OVRCURA Interrupt Enable Clear
    }

    /// DPUSR2R Register bits
    namespace dpusr2r_bits {
        constexpr uint32_t DMINTE = (1U << 9);  ///< DM Interrupt Enable Clear
        constexpr uint32_t DPINTE = (1U << 8);  ///< DP Interrupt Enable Clear
        constexpr uint32_t DMVAL = (1U << 5);  ///< DM InputIndicates DM input signal on the HS side of USB port.
        constexpr uint32_t DPVAL = (1U << 4);  ///< DP InputIndicates DP input signal on the HS side of USB port.
        constexpr uint32_t DMINT = (1U << 1);  ///< Indication of Return from DM Interrupt Source
        constexpr uint32_t DPINT = (1U << 0);  ///< Indication of Return from DP Interrupt Source
    }

    /// DPUSRCR Register bits
    namespace dpusrcr_bits {
        constexpr uint32_t FIXPHYPD = (1U << 1);  ///< USB Transceiver Control Fix for PLL
        constexpr uint32_t FIXPHY = (1U << 0);  ///< USB Transceiver Control Fix
    }

}

// ============================================================================
// SCI0 Peripheral
// ============================================================================

namespace sci0 {
    /// Base addresses
    constexpr uint32_t SCI0_BASE = 0x40070000;

    /// SCI0 Register structure
    struct Registers {
        volatile uint32_t SMR;  ///< Offset: 0x00 - Serial Mode Register (SCMR.SMIF = 0)
        volatile uint32_t SMR_SMCI;  ///< Offset: 0x00 - Serial mode register (SCMR.SMIF = 1)
        volatile uint32_t BRR;  ///< Offset: 0x01 - Bit Rate Register
        volatile uint32_t SCR;  ///< Offset: 0x02 - Serial Control Register (SCMR.SMIF = 0)
        volatile uint32_t SCR_SMCI;  ///< Offset: 0x02 - Serial Control Register (SCMR.SMIF =1)
        volatile uint32_t TDR;  ///< Offset: 0x03 - Transmit Data Register
        volatile uint32_t SSR;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
        volatile uint32_t SSR_FIFO;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 0 and FCR.FM=1)
        volatile uint32_t SSR_SMCI;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 1)
        volatile uint32_t RDR;  ///< Offset: 0x05 - Receive Data Register
        volatile uint32_t SCMR;  ///< Offset: 0x06 - Smart Card Mode Register
        volatile uint32_t SEMR;  ///< Offset: 0x07 - Serial Extended Mode Register
        volatile uint32_t SNFR;  ///< Offset: 0x08 - Noise Filter Setting Register
        volatile uint32_t SIMR1;  ///< Offset: 0x09 - I2C Mode Register 1
        volatile uint32_t SIMR2;  ///< Offset: 0x0A - I2C Mode Register 2
        volatile uint32_t SIMR3;  ///< Offset: 0x0B - I2C Mode Register 3
        volatile uint32_t SISR;  ///< Offset: 0x0C - I2C Status Register
        volatile uint32_t SPMR;  ///< Offset: 0x0D - SPI Mode Register
        volatile uint32_t TDRHL;  ///< Offset: 0x0E - Transmit 9-bit Data Register
        volatile uint32_t FTDRHL;  ///< Offset: 0x0E - Transmit FIFO Data Register HL
        volatile uint32_t FTDRH;  ///< Offset: 0x0E - Transmit FIFO Data Register H
        volatile uint32_t FTDRL;  ///< Offset: 0x0F - Transmit FIFO Data Register L
        volatile uint32_t RDRHL;  ///< Offset: 0x10 - Receive 9-bit Data Register
        volatile uint32_t FRDRHL;  ///< Offset: 0x10 - Receive FIFO Data Register HL
        volatile uint32_t FRDRH;  ///< Offset: 0x10 - Receive FIFO Data Register H
        volatile uint32_t FRDRL;  ///< Offset: 0x11 - Receive FIFO Data Register L
        volatile uint32_t MDDR;  ///< Offset: 0x12 - Modulation Duty Register
        volatile uint32_t DCCR;  ///< Offset: 0x13 - Data Compare Match Control Register
        volatile uint32_t FCR;  ///< Offset: 0x14 - FIFO Control Register
        volatile uint32_t FDR;  ///< Offset: 0x16 - FIFO Data Count Register
        volatile uint32_t LSR;  ///< Offset: 0x18 - Line Status Register
        volatile uint32_t CDR;  ///< Offset: 0x1A - Compare Match Data Register
        volatile uint32_t SPTR;  ///< Offset: 0x1C - Serial Port Register
    };

    /// Peripheral instances
    inline Registers* SCI0 = reinterpret_cast<Registers*>(SCI0_BASE);

    // Bit definitions
    /// SMR Register bits
    namespace smr_bits {
        constexpr uint32_t CM = (1U << 7);  ///< Communications Mode
        constexpr uint32_t CHR = (1U << 6);  ///< Character Length(Valid only in asynchronous mode)
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable(Valid only in asynchronous mode)
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode (Valid only when the PE bit is 1)
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Bit Length(Valid only in asynchronous mode)
        constexpr uint32_t MP = (1U << 2);  ///< Multi-Processor Mode(Valid only in asynchronous mode)
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
    }

    /// SMR_SMCI Register bits
    namespace smr_smci_bits {
        constexpr uint32_t GM = (1U << 7);  ///< GSM Mode
        constexpr uint32_t BLK = (1U << 6);  ///< Block Transfer Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable(Valid only in asynchronous mode)
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode (Valid only when the PE bit is 1)
        constexpr uint32_t BCP = (2 << 2);  ///< Stop Bit Length(Valid only in asynchronous mode)
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR = (8 << 0);  ///< BRR is an 8-bit register that adjusts the bit rate.
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable(Valid in asynchronous mode when SMR.MP = 1)
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
    }

    /// SCR_SMCI Register bits
    namespace scr_smci_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt EnableSet this bit to 0 in smart card interface mode.
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt EnableSet this bit to 0 in smart card interface mode.
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (8 << 0);  ///< TDR is an 8-bit register that stores transmit data.
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor Bit. Value of the multi-processor bit in the reception frame
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer. Sets the multi-processor bit for adding to the transmission frame
    }

    /// SSR_FIFO Register bits
    namespace ssr_fifo_bits {
        constexpr uint32_t TDFE = (1U << 7);  ///< Transmit FIFO data empty flag
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO data full flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t DR = (1U << 0);  ///< Receive Data Ready flag(Valid only in asynchronous mode(including multi-processor) and FIFO selected)
    }

    /// SSR_SMCI Register bits
    namespace ssr_smci_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t ERS = (1U << 4);  ///< Error Signal Status Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t MPB = (1U << 1);  ///< This bit should be 0 in smart card interface mode.
        constexpr uint32_t MPBT = (1U << 0);  ///< This bit should be 0 in smart card interface mode.
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (8 << 0);  ///< RDR is an 8-bit register that stores receive data.
    }

    /// SCMR Register bits
    namespace scmr_bits {
        constexpr uint32_t BCP2 = (1U << 7);  ///< Base Clock Pulse 2Selects the number of base clock cycles in combination with the SMR.BCP[1:0] bits
        constexpr uint32_t CHR1 = (1U << 4);  ///< Character Length 1(Only valid in asynchronous mode)
        constexpr uint32_t SDIR = (1U << 3);  ///< Transmitted/Received Data Transfer DirectionNOTE: The setting is invalid and a fixed data length of 8 bits is used in modes other than asynchronous mode.Set this bit to 1 if operation is to be in simple I2C mode.
        constexpr uint32_t SINV = (1U << 2);  ///< Transmitted/Received Data InvertSet this bit to 0 if operation is to be in simple I2C mode.
        constexpr uint32_t SMIF = (1U << 0);  ///< Smart Card Interface Mode Select
    }

    /// SEMR Register bits
    namespace semr_bits {
        constexpr uint32_t RXDESEL = (1U << 7);  ///< Asynchronous Start Bit Edge Detection Select(Valid only in asynchronous mode)
        constexpr uint32_t BGDM = (1U << 6);  ///< Baud Rate Generator Double-Speed Mode Select(Only valid the CKE[1] bit in SCR is 0 in asynchronous mode).
        constexpr uint32_t NFEN = (1U << 5);  ///< Digital Noise Filter Function Enable(The NFEN bit should be 0 without simple I2C mode and asynchronous mode.)In asynchronous mode, for RXDn input only. In simple I2C mode, for RXDn/TxDn input.
        constexpr uint32_t ABCS = (1U << 4);  ///< Asynchronous Mode Base Clock Select(Valid only in asynchronous mode)
        constexpr uint32_t ABCSE = (1U << 3);  ///< Asynchronous Mode Extended Base Clock Select1(Valid only in asynchronous mode and SCR.CKE[1]=0)
        constexpr uint32_t BRME = (1U << 2);  ///< Bit Modulation Enable
    }

    /// SNFR Register bits
    namespace snfr_bits {
        constexpr uint32_t NFCS = (3 << 0);  ///< Noise Filter Clock Select
    }

    /// SIMR1 Register bits
    namespace simr1_bits {
        constexpr uint32_t IICDL = (5 << 3);  ///< SSDA Delay Output SelectCycles below are of the clock signal from the on-chip baud rate generator.
        constexpr uint32_t IICM = (1U << 0);  ///< Simple I2C Mode Select
    }

    /// SIMR2 Register bits
    namespace simr2_bits {
        constexpr uint32_t IICACKT = (1U << 5);  ///< ACK Transmission Data
        constexpr uint32_t IICCSC = (1U << 1);  ///< Clock Synchronization
        constexpr uint32_t IICINTM = (1U << 0);  ///< I2C Interrupt Mode Select
    }

    /// SIMR3 Register bits
    namespace simr3_bits {
        constexpr uint32_t IICSCLS = (2 << 6);  ///< SCL Output Select
        constexpr uint32_t IICSDAS = (2 << 4);  ///< SDA Output Select
        constexpr uint32_t IICSTIF = (1U << 3);  ///< Issuing of Start, Restart, or Stop Condition Completed Flag(When 0 is written to IICSTIF, it is cleared to 0.)
        constexpr uint32_t IICSTPREQ = (1U << 2);  ///< Stop Condition Generation
        constexpr uint32_t IICRSTAREQ = (1U << 1);  ///< Restart Condition Generation
        constexpr uint32_t IICSTAREQ = (1U << 0);  ///< Start Condition Generation
    }

    /// SISR Register bits
    namespace sisr_bits {
        constexpr uint32_t IICACKR = (1U << 0);  ///< ACK Reception Data Flag
    }

    /// SPMR Register bits
    namespace spmr_bits {
        constexpr uint32_t CKPH = (1U << 7);  ///< Clock Phase Select
        constexpr uint32_t CKPOL = (1U << 6);  ///< Clock Polarity Select
        constexpr uint32_t MFF = (1U << 4);  ///< Mode Fault Flag
        constexpr uint32_t MSS = (1U << 2);  ///< Master or slave mode selection
        constexpr uint32_t CTSE = (1U << 1);  ///< CTS Enable
        constexpr uint32_t SSE = (1U << 0);  ///< SSn# Pin Function Enable
    }

    /// TDRHL Register bits
    namespace tdrhl_bits {
        constexpr uint32_t TDRHL = (16 << 0);  ///< TDRHL is a 16-bit register that stores transmit data.
    }

    /// FTDRHL Register bits
    namespace ftdrhl_bits {
        constexpr uint32_t MPBT = (1U << 9);  ///< Multi-processor transfer bit flag(Valid only in asynchronous mode and SMR.MP=1 and FIFO selected)
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial transmit data (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FTDRH Register bits
    namespace ftdrh_bits {
        constexpr uint32_t MPBT = (1U << 1);  ///< Multi-processor transfer bit flag(Valid only in asynchronous mode and SMR.MP=1 and FIFO selected)
        constexpr uint32_t TDATH = (1U << 0);  ///< Serial transmit data (b8) (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FTDRL Register bits
    namespace ftdrl_bits {
        constexpr uint32_t TDATL = (8 << 0);  ///< Serial transmit data(b7-b0) (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// RDRHL Register bits
    namespace rdrhl_bits {
        constexpr uint32_t RDRHL = (16 << 0);  ///< RDRHL is an 16-bit register that stores receive data.
    }

    /// FRDRHL Register bits
    namespace frdrhl_bits {
        constexpr uint32_t RDF = (1U << 14);  ///< Receive FIFO data full flag(It is same as SSR.RDF)
        constexpr uint32_t ORER = (1U << 13);  ///< Overrun error flag(It is same as SSR.ORER)
        constexpr uint32_t FER = (1U << 12);  ///< Framing error flag
        constexpr uint32_t PER = (1U << 11);  ///< Parity error flag
        constexpr uint32_t DR = (1U << 10);  ///< Receive data ready flag(It is same as SSR.DR)
        constexpr uint32_t MPB = (1U << 9);  ///< Multi-processor bit flag(Valid only in asynchronous mode with SMR.MP=1 and FIFO selected) It can read multi-processor bit corresponded to serial receive data(RDATA[8:0])
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial receive data(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FRDRH Register bits
    namespace frdrh_bits {
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO data full flag(It is same as SSR.RDF)
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun error flag(It is same as SSR.ORER)
        constexpr uint32_t FER = (1U << 4);  ///< Framing error flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity error flag
        constexpr uint32_t DR = (1U << 2);  ///< Receive data ready flag(It is same as SSR.DR)
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-processor bit flag(Valid only in asynchronous mode with SMR.MP=1 and FIFO selected) It can read multi-processor bit corresponded to serial receive data(RDATA[8:0])
        constexpr uint32_t RDATH = (1U << 0);  ///< Serial receive data(b8)(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FRDRL Register bits
    namespace frdrl_bits {
        constexpr uint32_t RDATL = (8 << 0);  ///< Serial receive data(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)NOTE: When reading both of FRDRH register and FRDRL register, please read by an order of the FRDRH register and the FRDRL register.
    }

    /// MDDR Register bits
    namespace mddr_bits {
        constexpr uint32_t MDDR = (8 << 0);  ///< MDDR corrects the bit rate adjusted by the BRR register.
    }

    /// DCCR Register bits
    namespace dccr_bits {
        constexpr uint32_t DCME = (1U << 7);  ///< Data Compare Match Enable(Valid only in asynchronous mode(including multi-processor)
        constexpr uint32_t IDSEL = (1U << 6);  ///< ID frame select Bit(Valid only in asynchronous mode(including multi-processor)
        constexpr uint32_t DFER = (1U << 4);  ///< Data Compare Match Framing Error Flag
        constexpr uint32_t DPER = (1U << 3);  ///< Data Compare Match Parity Error Flag
        constexpr uint32_t DCMF = (1U << 0);  ///< Data Compare Match Flag
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t RSTRG = (4 << 12);  ///< RTS# Output Active Trigger Number Select(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode)
        constexpr uint32_t RTRG = (4 << 8);  ///< Receive FIFO data trigger number
        constexpr uint32_t TTRG = (4 << 4);  ///< Transmit FIFO data trigger number(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode)
        constexpr uint32_t DRES = (1U << 3);  ///< Receive data ready error select bit(When detecting a reception data ready, the interrupt request is selected.)
        constexpr uint32_t TFRST = (1U << 2);  ///< Transmit FIFO Data Register Reset(Valid only in FCR.FM=1)
        constexpr uint32_t RFRST = (1U << 1);  ///< Receive FIFO Data Register Reset(Valid only in FCR.FM=1)
        constexpr uint32_t FM = (1U << 0);  ///< FIFO Mode Select(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode)
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t T = (5 << 8);  ///< Transmit FIFO Data CountIndicate the quantity of non-transmit data stored in FTDRH and FTDRL(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, while FCR.FM=1)
        constexpr uint32_t R = (5 << 0);  ///< Receive FIFO Data CountIndicate the quantity of receive data stored in FRDRH and FRDRL(Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, while FCR.FM=1)
    }

    /// LSR Register bits
    namespace lsr_bits {
        constexpr uint32_t PNUM = (5 << 8);  ///< Parity Error CountIndicates the quantity of data with a parity error among the receive data stored in the receive FIFO data register (FRDRH and FRDRL).
        constexpr uint32_t FNUM = (5 << 2);  ///< Framing Error CountIndicates the quantity of data with a framing error among the receive data stored in the receive FIFO data register (FRDRH and FRDRL).
        constexpr uint32_t ORER = (1U << 0);  ///< Overrun Error Flag (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// CDR Register bits
    namespace cdr_bits {
        constexpr uint32_t CMPD = (9 << 0);  ///< Compare Match DataCompare data pattern for address match wake-up function
    }

    /// SPTR Register bits
    namespace sptr_bits {
        constexpr uint32_t SPB2IO = (1U << 2);  ///< Serial port break I/O bit(It's selected whether the value of SPB2DT is output to TxD terminal.)
        constexpr uint32_t SPB2DT = (1U << 1);  ///< Serial port break data select bit(The output level of TxD terminal is selected when SCR.TE = 0.)
        constexpr uint32_t RXDMON = (1U << 0);  ///< Serial input data monitor bit(The state of the RXD terminal is shown.)
    }

}

// ============================================================================
// SCI1 Peripheral
// ============================================================================

namespace sci1 {
    /// Base addresses
    constexpr uint32_t SCI1_BASE = 0x40070020;

    /// SCI1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI1 = reinterpret_cast<Registers*>(SCI1_BASE);

}

// ============================================================================
// SCI2 Peripheral
// ============================================================================

namespace sci2 {
    /// Base addresses
    constexpr uint32_t SCI2_BASE = 0x40070040;

    /// SCI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI2 = reinterpret_cast<Registers*>(SCI2_BASE);

}

// ============================================================================
// SCI3 Peripheral
// ============================================================================

namespace sci3 {
    /// Base addresses
    constexpr uint32_t SCI3_BASE = 0x40070060;

    /// SCI3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI3 = reinterpret_cast<Registers*>(SCI3_BASE);

}

// ============================================================================
// SCI4 Peripheral
// ============================================================================

namespace sci4 {
    /// Base addresses
    constexpr uint32_t SCI4_BASE = 0x40070080;

    /// SCI4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI4 = reinterpret_cast<Registers*>(SCI4_BASE);

}

// ============================================================================
// SCI5 Peripheral
// ============================================================================

namespace sci5 {
    /// Base addresses
    constexpr uint32_t SCI5_BASE = 0x400700A0;

    /// SCI5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI5 = reinterpret_cast<Registers*>(SCI5_BASE);

}

// ============================================================================
// SCI6 Peripheral
// ============================================================================

namespace sci6 {
    /// Base addresses
    constexpr uint32_t SCI6_BASE = 0x400700C0;

    /// SCI6 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI6 = reinterpret_cast<Registers*>(SCI6_BASE);

}

// ============================================================================
// SCI7 Peripheral
// ============================================================================

namespace sci7 {
    /// Base addresses
    constexpr uint32_t SCI7_BASE = 0x400700E0;

    /// SCI7 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI7 = reinterpret_cast<Registers*>(SCI7_BASE);

}

// ============================================================================
// SCI8 Peripheral
// ============================================================================

namespace sci8 {
    /// Base addresses
    constexpr uint32_t SCI8_BASE = 0x40070100;

    /// SCI8 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI8 = reinterpret_cast<Registers*>(SCI8_BASE);

}

// ============================================================================
// SCI9 Peripheral
// ============================================================================

namespace sci9 {
    /// Base addresses
    constexpr uint32_t SCI9_BASE = 0x40070120;

    /// SCI9 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI9 = reinterpret_cast<Registers*>(SCI9_BASE);

}

// ============================================================================
// IIC0 Peripheral
// ============================================================================

namespace iic0 {
    /// Base addresses
    constexpr uint32_t IIC0_BASE = 0x40053000;

    /// IIC0 Register structure
    struct Registers {
        volatile uint32_t ICCR1;  ///< Offset: 0x00 - I2C Bus Control Register 1
        volatile uint32_t ICCR2;  ///< Offset: 0x01 - I2C Bus Control Register 2
        volatile uint32_t ICMR1;  ///< Offset: 0x02 - I2C Bus Mode Register 1
        volatile uint32_t ICMR2;  ///< Offset: 0x03 - I2C Bus Mode Register 2
        volatile uint32_t ICMR3;  ///< Offset: 0x04 - I2C Bus Mode Register 3
        volatile uint32_t ICFER;  ///< Offset: 0x05 - I2C Bus Function Enable Register
        volatile uint32_t ICSER;  ///< Offset: 0x06 - I2C Bus Status Enable Register
        volatile uint32_t ICIER;  ///< Offset: 0x07 - I2C Bus Interrupt Enable Register
        volatile uint32_t ICSR1;  ///< Offset: 0x08 - I2C Bus Status Register 1
        volatile uint32_t ICSR2;  ///< Offset: 0x09 - I2C Bus Status Register 2
        volatile uint32_t SARL%s;  ///< Offset: 0x0A - Slave Address Register L%s
        volatile uint32_t SARU%s;  ///< Offset: 0x0B - Slave Address Register U%s
        volatile uint32_t ICBRL;  ///< Offset: 0x10 - I2C Bus Bit Rate Low-Level Register
        volatile uint32_t ICBRH;  ///< Offset: 0x11 - I2C Bus Bit Rate High-Level Register
        volatile uint32_t ICDRT;  ///< Offset: 0x12 - I2C Bus Transmit Data Register
        volatile uint32_t ICDRR;  ///< Offset: 0x13 - I2C Bus Receive Data Register
        volatile uint32_t ICWUR;  ///< Offset: 0x16 - I2C Bus Wake Up Unit Register
        volatile uint32_t ICWUR2;  ///< Offset: 0x17 - I2C Bus Wake Up Unit Register 2
    };

    /// Peripheral instances
    inline Registers* IIC0 = reinterpret_cast<Registers*>(IIC0_BASE);

    // Bit definitions
    /// ICCR1 Register bits
    namespace iccr1_bits {
        constexpr uint32_t ICE = (1U << 7);  ///< I2C Bus Interface Enable
        constexpr uint32_t IICRST = (1U << 6);  ///< I2C Bus Interface Internal ResetNote:If an internal reset is initiated using the IICRST bit for a bus hang-up occurred during communication with the master device in slave mode, the states may become different between the slave device and the master device (due to the difference in the bit counter information).
        constexpr uint32_t CLO = (1U << 5);  ///< Extra SCL Clock Cycle Output
        constexpr uint32_t SOWP = (1U << 4);  ///< SCLO/SDAO Write Protect
        constexpr uint32_t SCLO = (1U << 3);  ///< SCL Output Control/Monitor
        constexpr uint32_t SDAO = (1U << 2);  ///< SDA Output Control/Monitor
        constexpr uint32_t SCLI = (1U << 1);  ///< SCL Line Monitor
        constexpr uint32_t SDAI = (1U << 0);  ///< SDA Line Monitor
    }

    /// ICCR2 Register bits
    namespace iccr2_bits {
        constexpr uint32_t BBSY = (1U << 7);  ///< Bus Busy Detection Flag
        constexpr uint32_t MST = (1U << 6);  ///< Master/Slave Mode
        constexpr uint32_t TRS = (1U << 5);  ///< Transmit/Receive Mode
        constexpr uint32_t SP = (1U << 3);  ///< Stop Condition Issuance RequestNote: Writing to the SP bit is not possible while the setting of the BBSY flag is 0 (bus free state).Note: Do not set the SP bit to 1 while a restart condition is being issued.
        constexpr uint32_t RS = (1U << 2);  ///< Restart Condition Issuance RequestNote: Do not set the RS bit to 1 while issuing a stop condition.
        constexpr uint32_t ST = (1U << 1);  ///< Start Condition Issuance RequestSet the ST bit to 1 (start condition issuance request) when the BBSY flag is set to 0 (bus free state).
    }

    /// ICMR1 Register bits
    namespace icmr1_bits {
        constexpr uint32_t MTWP = (1U << 7);  ///< MST/TRS Write Protect
        constexpr uint32_t CKS = (3 << 4);  ///< Internal Reference Clock (fIIC) Selection ( fIIC = PCLKB / 2^CKS )
        constexpr uint32_t BCWP = (1U << 3);  ///< BC Write Protect(This bit is read as 1.)
        constexpr uint32_t BC = (3 << 0);  ///< Bit Counter
    }

    /// ICMR2 Register bits
    namespace icmr2_bits {
        constexpr uint32_t DLCS = (1U << 7);  ///< SDA Output Delay Clock Source Selection
        constexpr uint32_t SDDL = (3 << 4);  ///< SDA Output Delay Counter
        constexpr uint32_t TMOH = (1U << 2);  ///< Timeout H Count Control
        constexpr uint32_t TMOL = (1U << 1);  ///< Timeout L Count Control
        constexpr uint32_t TMOS = (1U << 0);  ///< Timeout Detection Time Selection
    }

    /// ICMR3 Register bits
    namespace icmr3_bits {
        constexpr uint32_t SMBS = (1U << 7);  ///< SMBus/I2C Bus Selection
        constexpr uint32_t WAIT = (1U << 6);  ///< WAITNote: When the value of the WAIT bit is to be read, be sure to read the ICDRR beforehand.
        constexpr uint32_t RDRFS = (1U << 5);  ///< RDRF Flag Set Timing Selection
        constexpr uint32_t ACKWP = (1U << 4);  ///< ACKBT Write Protect
        constexpr uint32_t ACKBT = (1U << 3);  ///< Transmit Acknowledge
        constexpr uint32_t ACKBR = (1U << 2);  ///< Receive Acknowledge
        constexpr uint32_t NF = (2 << 0);  ///< Noise Filter Stage Selection
    }

    /// ICFER Register bits
    namespace icfer_bits {
        constexpr uint32_t FMPE = (1U << 7);  ///< Fast-mode Plus Enable
        constexpr uint32_t SCLE = (1U << 6);  ///< SCL Synchronous Circuit Enable
        constexpr uint32_t NFE = (1U << 5);  ///< Digital Noise Filter Circuit Enable
        constexpr uint32_t NACKE = (1U << 4);  ///< NACK Reception Transfer Suspension Enable
        constexpr uint32_t SALE = (1U << 3);  ///< Slave Arbitration-Lost Detection Enable
        constexpr uint32_t NALE = (1U << 2);  ///< NACK Transmission Arbitration-Lost Detection Enable
        constexpr uint32_t MALE = (1U << 1);  ///< Master Arbitration-Lost Detection Enable
        constexpr uint32_t TMOE = (1U << 0);  ///< Timeout Function Enable
    }

    /// ICSER Register bits
    namespace icser_bits {
        constexpr uint32_t HOAE = (1U << 7);  ///< Host Address Enable
        constexpr uint32_t DIDE = (1U << 5);  ///< Device-ID Address Detection Enable
        constexpr uint32_t GCAE = (1U << 3);  ///< General Call Address Enable
        constexpr uint32_t SAR2E = (1U << 2);  ///< Slave Address Register 2 Enable
        constexpr uint32_t SAR1E = (1U << 1);  ///< Slave Address Register 1 Enable
        constexpr uint32_t SAR0E = (1U << 0);  ///< Slave Address Register 0 Enable
    }

    /// ICIER Register bits
    namespace icier_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Data Empty Interrupt Request Enable
        constexpr uint32_t TEIE = (1U << 6);  ///< Transmit End Interrupt Request Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receive Data Full Interrupt Request Enable
        constexpr uint32_t NAKIE = (1U << 4);  ///< NACK Reception Interrupt Request Enable
        constexpr uint32_t SPIE = (1U << 3);  ///< Stop Condition Detection Interrupt Request Enable
        constexpr uint32_t STIE = (1U << 2);  ///< Start Condition Detection Interrupt Request Enable
        constexpr uint32_t ALIE = (1U << 1);  ///< Arbitration-Lost Interrupt Request Enable
        constexpr uint32_t TMOIE = (1U << 0);  ///< Timeout Interrupt Request Enable
    }

    /// ICSR1 Register bits
    namespace icsr1_bits {
        constexpr uint32_t HOA = (1U << 7);  ///< Host Address Detection Flag
        constexpr uint32_t DID = (1U << 5);  ///< Device-ID Address Detection Flag
        constexpr uint32_t GCA = (1U << 3);  ///< General Call Address Detection Flag
        constexpr uint32_t AAS2 = (1U << 2);  ///< Slave Address 2 Detection Flag
        constexpr uint32_t AAS1 = (1U << 1);  ///< Slave Address 1 Detection Flag
        constexpr uint32_t AAS0 = (1U << 0);  ///< Slave Address 0 Detection Flag
    }

    /// ICSR2 Register bits
    namespace icsr2_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t TEND = (1U << 6);  ///< Transmit End Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Full Flag
        constexpr uint32_t NACKF = (1U << 4);  ///< NACK Detection Flag
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Condition Detection Flag
        constexpr uint32_t START = (1U << 2);  ///< Start Condition Detection Flag
        constexpr uint32_t AL = (1U << 1);  ///< Arbitration-Lost Flag
        constexpr uint32_t TMOF = (1U << 0);  ///< Timeout Detection Flag
    }

    /// SARL%s Register bits
    namespace sarl%s_bits {
        constexpr uint32_t SVA = (8 << 0);  ///< A slave address is set.7-Bit Address = SVA[7:1] 10-Bit Address = { SVA9,SVA8,SVA[7:0] }
    }

    /// SARU%s Register bits
    namespace saru%s_bits {
        constexpr uint32_t SVA9 = (1U << 2);  ///< 10-Bit Address(bit9)
        constexpr uint32_t SVA8 = (1U << 1);  ///< 10-Bit Address(bit8)
        constexpr uint32_t FS = (1U << 0);  ///< 7-Bit/10-Bit Address Format Selection
    }

    /// ICBRL Register bits
    namespace icbrl_bits {
        constexpr uint32_t BRL = (5 << 0);  ///< Bit Rate Low-Level Period(Low-level period of SCL clock)
    }

    /// ICBRH Register bits
    namespace icbrh_bits {
        constexpr uint32_t BRH = (5 << 0);  ///< Bit Rate High-Level Period(High-level period of SCL clock)
    }

    /// ICDRT Register bits
    namespace icdrt_bits {
        constexpr uint32_t ICDRT = (8 << 0);  ///< 8-bit read-write register that stores transmit data.
    }

    /// ICDRR Register bits
    namespace icdrr_bits {
        constexpr uint32_t ICDRR = (8 << 0);  ///< 8-bit register that stores the received data
    }

    /// ICWUR Register bits
    namespace icwur_bits {
        constexpr uint32_t WUE = (1U << 7);  ///< Wake Up function Enable
        constexpr uint32_t WUIE = (1U << 6);  ///< Wake Up Interrupt Request Enable
        constexpr uint32_t WUF = (1U << 5);  ///< Wake-Up Event Occurrence Flag
        constexpr uint32_t WUACK = (1U << 4);  ///< Asynchronous/Synchronous Operation State Flag
        constexpr uint32_t WUAFA = (1U << 0);  ///< Wake-Up Analog Filter Additional Selection
    }

    /// ICWUR2 Register bits
    namespace icwur2_bits {
        constexpr uint32_t WUSYF = (1U << 2);  ///< Wake-Up function synchronous operation status flag
        constexpr uint32_t WUASYF = (1U << 1);  ///< Wake-Up function asynchronous operation status flag
        constexpr uint32_t WUSEN = (1U << 0);  ///< Wake-Up function synchronous enable
    }

}

// ============================================================================
// IIC1 Peripheral
// ============================================================================

namespace iic1 {
    /// Base addresses
    constexpr uint32_t IIC1_BASE = 0x40053100;

    /// IIC1 Register structure
    struct Registers {
        volatile uint32_t ICCR1;  ///< Offset: 0x00 - I2C Bus Control Register 1
        volatile uint32_t ICCR2;  ///< Offset: 0x01 - I2C Bus Control Register 2
        volatile uint32_t ICMR1;  ///< Offset: 0x02 - I2C Bus Mode Register 1
        volatile uint32_t ICMR2;  ///< Offset: 0x03 - I2C Bus Mode Register 2
        volatile uint32_t ICMR3;  ///< Offset: 0x04 - I2C Bus Mode Register 3
        volatile uint32_t ICFER;  ///< Offset: 0x05 - I2C Bus Function Enable Register
        volatile uint32_t ICSER;  ///< Offset: 0x06 - I2C Bus Status Enable Register
        volatile uint32_t ICIER;  ///< Offset: 0x07 - I2C Bus Interrupt Enable Register
        volatile uint32_t ICSR1;  ///< Offset: 0x08 - I2C Bus Status Register 1
        volatile uint32_t ICSR2;  ///< Offset: 0x09 - I2C Bus Status Register 2
        volatile uint32_t SARL%s;  ///< Offset: 0x0A - Slave Address Register L%s
        volatile uint32_t SARU%s;  ///< Offset: 0x0B - Slave Address Register U%s
        volatile uint32_t ICBRL;  ///< Offset: 0x10 - I2C Bus Bit Rate Low-Level Register
        volatile uint32_t ICBRH;  ///< Offset: 0x11 - I2C Bus Bit Rate High-Level Register
        volatile uint32_t ICDRT;  ///< Offset: 0x12 - I2C Bus Transmit Data Register
        volatile uint32_t ICDRR;  ///< Offset: 0x13 - I2C Bus Receive Data Register
    };

    /// Peripheral instances
    inline Registers* IIC1 = reinterpret_cast<Registers*>(IIC1_BASE);

    // Bit definitions
    /// ICCR1 Register bits
    namespace iccr1_bits {
        constexpr uint32_t ICE = (1U << 7);  ///< I2C Bus Interface Enable
        constexpr uint32_t IICRST = (1U << 6);  ///< I2C Bus Interface Internal ResetNote:If an internal reset is initiated using the IICRST bit for a bus hang-up occurred during communication with the master device in slave mode, the states may become different between the slave device and the master device (due to the difference in the bit counter information).
        constexpr uint32_t CLO = (1U << 5);  ///< Extra SCL Clock Cycle Output
        constexpr uint32_t SOWP = (1U << 4);  ///< SCLO/SDAO Write Protect
        constexpr uint32_t SCLO = (1U << 3);  ///< SCL Output Control/Monitor
        constexpr uint32_t SDAO = (1U << 2);  ///< SDA Output Control/Monitor
        constexpr uint32_t SCLI = (1U << 1);  ///< SCL Line Monitor
        constexpr uint32_t SDAI = (1U << 0);  ///< SDA Line Monitor
    }

    /// ICCR2 Register bits
    namespace iccr2_bits {
        constexpr uint32_t BBSY = (1U << 7);  ///< Bus Busy Detection Flag
        constexpr uint32_t MST = (1U << 6);  ///< Master/Slave Mode
        constexpr uint32_t TRS = (1U << 5);  ///< Transmit/Receive Mode
        constexpr uint32_t SP = (1U << 3);  ///< Stop Condition Issuance RequestNote: Writing to the SP bit is not possible while the setting of the BBSY flag is 0 (bus free state).Note: Do not set the SP bit to 1 while a restart condition is being issued.
        constexpr uint32_t RS = (1U << 2);  ///< Restart Condition Issuance RequestNote: Do not set the RS bit to 1 while issuing a stop condition.
        constexpr uint32_t ST = (1U << 1);  ///< Start Condition Issuance RequestSet the ST bit to 1 (start condition issuance request) when the BBSY flag is set to 0 (bus free state).
    }

    /// ICMR1 Register bits
    namespace icmr1_bits {
        constexpr uint32_t MTWP = (1U << 7);  ///< MST/TRS Write Protect
        constexpr uint32_t CKS = (3 << 4);  ///< Internal Reference Clock (fIIC) Selection ( fIIC = PCLKB / 2^CKS )
        constexpr uint32_t BCWP = (1U << 3);  ///< BC Write Protect(This bit is read as 1.)
        constexpr uint32_t BC = (3 << 0);  ///< Bit Counter
    }

    /// ICMR2 Register bits
    namespace icmr2_bits {
        constexpr uint32_t DLCS = (1U << 7);  ///< SDA Output Delay Clock Source Selection
        constexpr uint32_t SDDL = (3 << 4);  ///< SDA Output Delay Counter
        constexpr uint32_t TMOH = (1U << 2);  ///< Timeout H Count Control
        constexpr uint32_t TMOL = (1U << 1);  ///< Timeout L Count Control
        constexpr uint32_t TMOS = (1U << 0);  ///< Timeout Detection Time Selection
    }

    /// ICMR3 Register bits
    namespace icmr3_bits {
        constexpr uint32_t SMBS = (1U << 7);  ///< SMBus/I2C Bus Selection
        constexpr uint32_t WAIT = (1U << 6);  ///< WAITNote: When the value of the WAIT bit is to be read, be sure to read the ICDRR beforehand.
        constexpr uint32_t RDRFS = (1U << 5);  ///< RDRF Flag Set Timing Selection
        constexpr uint32_t ACKWP = (1U << 4);  ///< ACKBT Write Protect
        constexpr uint32_t ACKBT = (1U << 3);  ///< Transmit Acknowledge
        constexpr uint32_t ACKBR = (1U << 2);  ///< Receive Acknowledge
        constexpr uint32_t NF = (2 << 0);  ///< Noise Filter Stage Selection
    }

    /// ICFER Register bits
    namespace icfer_bits {
        constexpr uint32_t FMPE = (1U << 7);  ///< Fast-mode Plus Enable
        constexpr uint32_t SCLE = (1U << 6);  ///< SCL Synchronous Circuit Enable
        constexpr uint32_t NFE = (1U << 5);  ///< Digital Noise Filter Circuit Enable
        constexpr uint32_t NACKE = (1U << 4);  ///< NACK Reception Transfer Suspension Enable
        constexpr uint32_t SALE = (1U << 3);  ///< Slave Arbitration-Lost Detection Enable
        constexpr uint32_t NALE = (1U << 2);  ///< NACK Transmission Arbitration-Lost Detection Enable
        constexpr uint32_t MALE = (1U << 1);  ///< Master Arbitration-Lost Detection Enable
        constexpr uint32_t TMOE = (1U << 0);  ///< Timeout Function Enable
    }

    /// ICSER Register bits
    namespace icser_bits {
        constexpr uint32_t HOAE = (1U << 7);  ///< Host Address Enable
        constexpr uint32_t DIDE = (1U << 5);  ///< Device-ID Address Detection Enable
        constexpr uint32_t GCAE = (1U << 3);  ///< General Call Address Enable
        constexpr uint32_t SAR2E = (1U << 2);  ///< Slave Address Register 2 Enable
        constexpr uint32_t SAR1E = (1U << 1);  ///< Slave Address Register 1 Enable
        constexpr uint32_t SAR0E = (1U << 0);  ///< Slave Address Register 0 Enable
    }

    /// ICIER Register bits
    namespace icier_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Data Empty Interrupt Request Enable
        constexpr uint32_t TEIE = (1U << 6);  ///< Transmit End Interrupt Request Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receive Data Full Interrupt Request Enable
        constexpr uint32_t NAKIE = (1U << 4);  ///< NACK Reception Interrupt Request Enable
        constexpr uint32_t SPIE = (1U << 3);  ///< Stop Condition Detection Interrupt Request Enable
        constexpr uint32_t STIE = (1U << 2);  ///< Start Condition Detection Interrupt Request Enable
        constexpr uint32_t ALIE = (1U << 1);  ///< Arbitration-Lost Interrupt Request Enable
        constexpr uint32_t TMOIE = (1U << 0);  ///< Timeout Interrupt Request Enable
    }

    /// ICSR1 Register bits
    namespace icsr1_bits {
        constexpr uint32_t HOA = (1U << 7);  ///< Host Address Detection Flag
        constexpr uint32_t DID = (1U << 5);  ///< Device-ID Address Detection Flag
        constexpr uint32_t GCA = (1U << 3);  ///< General Call Address Detection Flag
        constexpr uint32_t AAS2 = (1U << 2);  ///< Slave Address 2 Detection Flag
        constexpr uint32_t AAS1 = (1U << 1);  ///< Slave Address 1 Detection Flag
        constexpr uint32_t AAS0 = (1U << 0);  ///< Slave Address 0 Detection Flag
    }

    /// ICSR2 Register bits
    namespace icsr2_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t TEND = (1U << 6);  ///< Transmit End Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Full Flag
        constexpr uint32_t NACKF = (1U << 4);  ///< NACK Detection Flag
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Condition Detection Flag
        constexpr uint32_t START = (1U << 2);  ///< Start Condition Detection Flag
        constexpr uint32_t AL = (1U << 1);  ///< Arbitration-Lost Flag
        constexpr uint32_t TMOF = (1U << 0);  ///< Timeout Detection Flag
    }

    /// SARL%s Register bits
    namespace sarl%s_bits {
        constexpr uint32_t SVA = (8 << 0);  ///< A slave address is set.7-Bit Address = SVA[7:1] 10-Bit Address = { SVA9,SVA8,SVA[7:0] }
    }

    /// SARU%s Register bits
    namespace saru%s_bits {
        constexpr uint32_t SVA9 = (1U << 2);  ///< 10-Bit Address(bit9)
        constexpr uint32_t SVA8 = (1U << 1);  ///< 10-Bit Address(bit8)
        constexpr uint32_t FS = (1U << 0);  ///< 7-Bit/10-Bit Address Format Selection
    }

    /// ICBRL Register bits
    namespace icbrl_bits {
        constexpr uint32_t BRL = (5 << 0);  ///< Bit Rate Low-Level Period(Low-level period of SCL clock)
    }

    /// ICBRH Register bits
    namespace icbrh_bits {
        constexpr uint32_t BRH = (5 << 0);  ///< Bit Rate High-Level Period(High-level period of SCL clock)
    }

    /// ICDRT Register bits
    namespace icdrt_bits {
        constexpr uint32_t ICDRT = (8 << 0);  ///< 8-bit read-write register that stores transmit data.
    }

    /// ICDRR Register bits
    namespace icdrr_bits {
        constexpr uint32_t ICDRR = (8 << 0);  ///< 8-bit register that stores the received data
    }

}

// ============================================================================
// IIC2 Peripheral
// ============================================================================

namespace iic2 {
    /// Base addresses
    constexpr uint32_t IIC2_BASE = 0x40053200;

    /// IIC2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* IIC2 = reinterpret_cast<Registers*>(IIC2_BASE);

}

// ============================================================================
// SYSTEM Peripheral
// ============================================================================

namespace system {
    /// Base addresses
    constexpr uint32_t SYSTEM_BASE = 0x4001E000;

    /// SYSTEM Register structure
    struct Registers {
        volatile uint32_t SCKDIVCR;  ///< Offset: 0x20 - System Clock Division Control Register
        volatile uint32_t SCKDIVCR2;  ///< Offset: 0x24 - System Clock Division Control Register 2
        volatile uint32_t SCKSCR;  ///< Offset: 0x26 - System Clock Source Control Register
        volatile uint32_t PLLCCR;  ///< Offset: 0x28 - PLL Clock Control Register
        volatile uint32_t PLLCR;  ///< Offset: 0x2A - PLL Control Register
        volatile uint32_t BCKCR;  ///< Offset: 0x30 - External Bus Clock Control Register
        volatile uint32_t MOSCCR;  ///< Offset: 0x32 - Main Clock Oscillator Control Register
        volatile uint32_t HOCOCR;  ///< Offset: 0x36 - High-Speed On-Chip Oscillator Control Register
        volatile uint32_t MOCOCR;  ///< Offset: 0x38 - Middle-Speed On-Chip Oscillator Control Register
        volatile uint32_t FLLCR1;  ///< Offset: 0x39 - FLL Control Register 1
        volatile uint32_t FLLCR2;  ///< Offset: 0x3A - FLL Control Register 2
        volatile uint32_t OSCSF;  ///< Offset: 0x3C - Oscillation Stabilization Flag Register
        volatile uint32_t CKOCR;  ///< Offset: 0x3E - Clock Out Control Register
        volatile uint32_t TRCKCR;  ///< Offset: 0x3F - Trace Clock Control Register
        volatile uint32_t OSTDCR;  ///< Offset: 0x40 - Oscillation Stop Detection Control Register
        volatile uint32_t OSTDSR;  ///< Offset: 0x41 - Oscillation Stop Detection Status Register
        volatile uint32_t EBCKOCR;  ///< Offset: 0x52 - External Bus Clock Output Control Register
        volatile uint32_t SDCKOCR;  ///< Offset: 0x53 - SDRAM Clock Output Control Register
        volatile uint32_t MOCOUTCR;  ///< Offset: 0x61 - MOCO User Trimming Control Register
        volatile uint32_t HOCOUTCR;  ///< Offset: 0x62 - HOCO User Trimming Control Register
        volatile uint32_t MOMCR;  ///< Offset: 0x413 - Main Clock Oscillator Mode Oscillation Control Register
        volatile uint32_t SOSCCR;  ///< Offset: 0x480 - Sub-clock oscillator control register
        volatile uint32_t SOMCR;  ///< Offset: 0x481 - Sub Clock Oscillator Mode Control Register
        volatile uint32_t LOCOCR;  ///< Offset: 0x490 - Low-Speed On-Chip Oscillator Control Register
        volatile uint32_t LOCOUTCR;  ///< Offset: 0x492 - LOCO User Trimming Control Register
        volatile uint32_t MOSCWTCR;  ///< Offset: 0xA2 - Main Clock Oscillator Wait Control Register
        volatile uint32_t HOCOWTCR;  ///< Offset: 0xA5 - High-speed on-chip oscillator wait control register
        volatile uint32_t SBYCR;  ///< Offset: 0x0C - Standby Control Register
        volatile uint32_t MSTPCRA;  ///< Offset: 0x1C - Module Stop Control Register A
        volatile uint32_t SNZCR;  ///< Offset: 0x92 - Snooze Control Register
        volatile uint32_t SNZEDCR;  ///< Offset: 0x94 - Snooze End Control Register
        volatile uint32_t SNZREQCR;  ///< Offset: 0x98 - Snooze Request Control Register
        volatile uint32_t OPCCR;  ///< Offset: 0xA0 - Operating Power Control Register
        volatile uint32_t SOPCCR;  ///< Offset: 0xAA - Sub Operating Power Control Register
        volatile uint32_t DPSBYCR;  ///< Offset: 0x400 - Deep Standby Control Register
        volatile uint32_t DPSIER0;  ///< Offset: 0x402 - Deep Standby Interrupt Enable Register 0
        volatile uint32_t DPSIER1;  ///< Offset: 0x403 - Deep Standby Interrupt Enable Register 1
        volatile uint32_t DPSIER2;  ///< Offset: 0x404 - Deep Standby Interrupt Enable Register 2
        volatile uint32_t DPSIER3;  ///< Offset: 0x405 - Deep Standby Interrupt Enable Register 3
        volatile uint32_t DPSIFR0;  ///< Offset: 0x406 - Deep Standby Interrupt Flag Register 0
        volatile uint32_t DPSIFR1;  ///< Offset: 0x407 - Deep Standby Interrupt Flag Register 1
        volatile uint32_t DPSIFR2;  ///< Offset: 0x408 - Deep Standby Interrupt Flag Register 2
        volatile uint32_t DPSIFR3;  ///< Offset: 0x409 - Deep Standby Interrupt Flag Register 3
        volatile uint32_t DPSIEGR0;  ///< Offset: 0x40A - Deep Standby Interrupt Edge Register 0
        volatile uint32_t DPSIEGR1;  ///< Offset: 0x40B - Deep Standby Interrupt Edge Register 1
        volatile uint32_t DPSIEGR2;  ///< Offset: 0x40C - Deep Standby Interrupt Edge Register 2
        volatile uint32_t SYOCDCR;  ///< Offset: 0x40E - System Control OCD Control Register
        volatile uint32_t STCONR;  ///< Offset: 0x40F - Standby Condition Register
        volatile uint32_t LVD%sCR1;  ///< Offset: 0xE0 - Voltage Monitor %s Circuit Control Register 1
        volatile uint32_t LVD%sSR;  ///< Offset: 0xE1 - Voltage Monitor %s Circuit Status Register
        volatile uint32_t LVCMPCR;  ///< Offset: 0x417 - Voltage Monitor Circuit Control Register
        volatile uint32_t LVDLVLR;  ///< Offset: 0x418 - Voltage Detection Level Select Register
        volatile uint32_t LVD%sCR0;  ///< Offset: 0x41A - Voltage Monitor %s Circuit Control Register 0
        volatile uint32_t VBTICTLR;  ///< Offset: 0x4BB - VBATT Input Control Register
        volatile uint32_t VBTBKR[%s];  ///< Offset: 0x500 - VBATT Backup Register [%s]
        volatile uint32_t PRCR;  ///< Offset: 0x3FE - Protect Register
        volatile uint32_t RSTSR0;  ///< Offset: 0x410 - Reset Status Register 0
        volatile uint32_t RSTSR2;  ///< Offset: 0x411 - Reset Status Register 2
        volatile uint32_t RSTSR1;  ///< Offset: 0xC0 - Reset Status Register 1
        volatile uint32_t FWEPROR;  ///< Offset: 0x416 - Flash P/E Protect Register
    };

    /// Peripheral instances
    inline Registers* SYSTEM = reinterpret_cast<Registers*>(SYSTEM_BASE);

    // Bit definitions
    /// SCKDIVCR Register bits
    namespace sckdivcr_bits {
        constexpr uint32_t FCK = (3 << 28);  ///< Flash IF Clock (FCLK) Select
        constexpr uint32_t ICK = (3 << 24);  ///< System Clock (ICLK) Select
        constexpr uint32_t BCK = (3 << 16);  ///< External Bus Clock (BCLK) Select
        constexpr uint32_t PCKA = (3 << 12);  ///< Peripheral Module Clock A (PCLKA) Select
        constexpr uint32_t PCKB = (3 << 8);  ///< Peripheral Module Clock B (PCLKB) Select
        constexpr uint32_t PCKC = (3 << 4);  ///< Peripheral Module Clock C (PCLKC) Select
        constexpr uint32_t PCKD = (3 << 0);  ///< Peripheral Module Clock D (PCLKD) Select
    }

    /// SCKDIVCR2 Register bits
    namespace sckdivcr2_bits {
        constexpr uint32_t UCK = (3 << 4);  ///< USB Clock (UCLK) Select
    }

    /// SCKSCR Register bits
    namespace sckscr_bits {
        constexpr uint32_t CKSEL = (3 << 0);  ///< Clock Source Select
    }

    /// PLLCCR Register bits
    namespace pllccr_bits {
        constexpr uint32_t PLLMUL = (6 << 8);  ///< PLL Frequency Multiplication Factor Select [PLL Frequency Multiplication Factor] = (PLLUMUL+1) / 2 Range: 0x23 - 0x3B for example 010011: x10.0 010100: x10.5 010101: x11.0 : 011100: x14.5 011101: x15.0 011110: x15.5 : 111010: x29.5 111011: x30.0
        constexpr uint32_t PLSRCSEL = (1U << 4);  ///< PLL Clock Source Select
        constexpr uint32_t PLIDIV = (2 << 0);  ///< PLL Input Frequency Division Ratio Select
    }

    /// PLLCR Register bits
    namespace pllcr_bits {
        constexpr uint32_t PLLSTP = (1U << 0);  ///< PLL Stop Control
    }

    /// BCKCR Register bits
    namespace bckcr_bits {
        constexpr uint32_t BCLKDIV = (1U << 0);  ///< BCLK Pin Output Select
    }

    /// MOSCCR Register bits
    namespace mosccr_bits {
        constexpr uint32_t MOSTP = (1U << 0);  ///< Main Clock Oscillator Stop
    }

    /// HOCOCR Register bits
    namespace hococr_bits {
        constexpr uint32_t HCSTP = (1U << 0);  ///< HOCO Stop
    }

    /// MOCOCR Register bits
    namespace mococr_bits {
        constexpr uint32_t MCSTP = (1U << 0);  ///< MOCO Stop
    }

    /// FLLCR1 Register bits
    namespace fllcr1_bits {
        constexpr uint32_t FLLEN = (1U << 0);  ///< FLL Enable
    }

    /// FLLCR2 Register bits
    namespace fllcr2_bits {
        constexpr uint32_t FLLCNTL = (11 << 0);  ///< FLL Multiplication ControlMultiplication ratio of the FLL reference clock select
    }

    /// OSCSF Register bits
    namespace oscsf_bits {
        constexpr uint32_t PLLSF = (1U << 5);  ///< PLL Clock Oscillation Stabilization Flag
        constexpr uint32_t MOSCSF = (1U << 3);  ///< Main Clock Oscillation Stabilization Flag
        constexpr uint32_t HOCOSF = (1U << 0);  ///< HOCO Clock Oscillation Stabilization FlagNOTE: The HOCOSF bit value after a reset is 1 when the OFS1.HOCOEN bit is 0. It is 0 when the OFS1.HOCOEN bit is 1.
    }

    /// CKOCR Register bits
    namespace ckocr_bits {
        constexpr uint32_t CKOEN = (1U << 7);  ///< Clock out enable
        constexpr uint32_t CKODIV = (3 << 4);  ///< Clock out input frequency Division Select
        constexpr uint32_t CKOSEL = (3 << 0);  ///< Clock out source select
    }

    /// TRCKCR Register bits
    namespace trckcr_bits {
        constexpr uint32_t TRCKEN = (1U << 7);  ///< Trace Clock operating Enable
        constexpr uint32_t TRCK = (4 << 0);  ///< Trace Clock operating frequency select
    }

    /// OSTDCR Register bits
    namespace ostdcr_bits {
        constexpr uint32_t OSTDE = (1U << 7);  ///< Oscillation Stop Detection Function Enable
        constexpr uint32_t OSTDIE = (1U << 0);  ///< Oscillation Stop Detection Interrupt Enable
    }

    /// OSTDSR Register bits
    namespace ostdsr_bits {
        constexpr uint32_t OSTDF = (1U << 0);  ///< Oscillation Stop Detection Flag
    }

    /// EBCKOCR Register bits
    namespace ebckocr_bits {
        constexpr uint32_t EBCKOEN = (1U << 0);  ///< BCLK Pin Output Control
    }

    /// SDCKOCR Register bits
    namespace sdckocr_bits {
        constexpr uint32_t SDCKOEN = (1U << 0);  ///< SDCLK Pin Output Control
    }

    /// MOCOUTCR Register bits
    namespace mocoutcr_bits {
        constexpr uint32_t MOCOUTRM = (8 << 0);  ///< MOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original MOCO trimming bits
    }

    /// HOCOUTCR Register bits
    namespace hocoutcr_bits {
        constexpr uint32_t HOCOUTRM = (8 << 0);  ///< HOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original HOCO trimming bits
    }

    /// MOMCR Register bits
    namespace momcr_bits {
        constexpr uint32_t AUTODRVEN = (1U << 7);  ///< Main Clock Oscillator Drive Capability Auto Switching Enable
        constexpr uint32_t MOSEL = (1U << 6);  ///< Main Clock Oscillator Switching
        constexpr uint32_t MODRV0 = (2 << 4);  ///< Main Clock Oscillator Drive Capability 0 Switching
    }

    /// SOSCCR Register bits
    namespace sosccr_bits {
        constexpr uint32_t SOSTP = (1U << 0);  ///< Sub-Clock Oscillator Stop
    }

    /// SOMCR Register bits
    namespace somcr_bits {
        constexpr uint32_t SODRV1 = (1U << 1);  ///< Sub Clock Oscillator Drive Capability Switching
    }

    /// LOCOCR Register bits
    namespace lococr_bits {
        constexpr uint32_t LCSTP = (1U << 0);  ///< LOCO Stop
    }

    /// LOCOUTCR Register bits
    namespace locoutcr_bits {
        constexpr uint32_t LOCOUTRM = (8 << 0);  ///< LOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original LOCO trimming bits
    }

    /// MOSCWTCR Register bits
    namespace moscwtcr_bits {
        constexpr uint32_t MSTS = (4 << 0);  ///< Main clock oscillator wait time setting
    }

    /// HOCOWTCR Register bits
    namespace hocowtcr_bits {
        constexpr uint32_t HSTS = (3 << 0);  ///< HOCO wait time settingWaiting time (sec) = setting of the HSTS[2:0] bits/fLOCO(Trimmed) + 3/fLOC(Untrimmed)
    }

    /// SBYCR Register bits
    namespace sbycr_bits {
        constexpr uint32_t SSBY = (1U << 15);  ///< Software Standby
        constexpr uint32_t OPE = (1U << 14);  ///< Output Port Enable
    }

    /// MSTPCRA Register bits
    namespace mstpcra_bits {
        constexpr uint32_t MSTPA22 = (1U << 22);  ///< DMA Controller/Data Transfer Controller Module Stop
        constexpr uint32_t MSTPA7 = (1U << 7);  ///< Standny RAM Module Stop
        constexpr uint32_t MSTPA6 = (1U << 6);  ///< ECCRAM Module Stop
        constexpr uint32_t MSTPA5 = (1U << 5);  ///< High-Speed RAM Module Stop
        constexpr uint32_t MSTPA1 = (1U << 1);  ///< RAM1 Module Stop
        constexpr uint32_t MSTPA0 = (1U << 0);  ///< RAM0 Module Stop
    }

    /// SNZCR Register bits
    namespace snzcr_bits {
        constexpr uint32_t SNZE = (1U << 7);  ///< Snooze Mode Enable
        constexpr uint32_t SNZDTCEN = (1U << 1);  ///< DTC Enable in Snooze Mode
        constexpr uint32_t RXDREQEN = (1U << 0);  ///< RXD0 Snooze Request Enable NOTE: Do not set to 1 other than in asynchronous mode.
    }

    /// SNZEDCR Register bits
    namespace snzedcr_bits {
        constexpr uint32_t SCI0UMTED = (1U << 7);  ///< SCI0 address unmatch Snooze End EnableNote: Do not set to 1 other than in asynchronous mode.
        constexpr uint32_t AD1UMTED = (1U << 6);  ///< AD compare mismatch 1 Snooze End Enable
        constexpr uint32_t AD1MATED = (1U << 5);  ///< AD compare match 1 Snooze End Enable
        constexpr uint32_t AD0UMTED = (1U << 4);  ///< AD compare mismatch 0 Snooze End Enable
        constexpr uint32_t AD0MATED = (1U << 3);  ///< AD compare match 0 Snooze End Enable
        constexpr uint32_t DTCNZRED = (1U << 2);  ///< Not Last DTC transmission completion Snooze End Enable
        constexpr uint32_t DTCZRED = (1U << 1);  ///< Last DTC transmission completion Snooze End Enable
        constexpr uint32_t AGT1UNFED = (1U << 0);  ///< AGT1 underflow Snooze End Enable
    }

    /// SNZREQCR Register bits
    namespace snzreqcr_bits {
        constexpr uint32_t SNZREQEN30 = (1U << 30);  ///< Snooze Request Enable 30Enable AGT1 compare match B snooze request
        constexpr uint32_t SNZREQEN29 = (1U << 29);  ///< Snooze Request Enable 29Enable AGT1 compare match A snooze request
        constexpr uint32_t SNZREQEN28 = (1U << 28);  ///< Snooze Request Enable 28Enable AGT1 underflow snooze request
        constexpr uint32_t SNZREQEN25 = (1U << 25);  ///< Snooze Request Enable 25Enable RTC period snooze request
        constexpr uint32_t SNZREQEN24 = (1U << 24);  ///< Snooze Request Enable 24Enable RTC alarm snooze request
        constexpr uint32_t SNZREQEN22 = (1U << 22);  ///< Snooze Request Enable 22Enable Comparator-OC0 snooze request
        constexpr uint32_t SNZREQEN17 = (1U << 17);  ///< Snooze Request Enable 17Enable KR snooze request
        constexpr uint32_t SNZREQEN15 = (1U << 15);  ///< Snooze Request Enable 15Enable IRQ15 pin snooze request
        constexpr uint32_t SNZREQEN14 = (1U << 14);  ///< Snooze Request Enable 14Enable IRQ14 pin snooze request
        constexpr uint32_t SNZREQEN13 = (1U << 13);  ///< Snooze Request Enable 13Enable IRQ13 pin snooze request
        constexpr uint32_t SNZREQEN12 = (1U << 12);  ///< Snooze Request Enable 12Enable IRQ12 pin snooze request
        constexpr uint32_t SNZREQEN11 = (1U << 11);  ///< Snooze Request Enable 11Enable IRQ11 pin snooze request
        constexpr uint32_t SNZREQEN10 = (1U << 10);  ///< Snooze Request Enable 10Enable IRQ10 pin snooze request
        constexpr uint32_t SNZREQEN9 = (1U << 9);  ///< Snooze Request Enable 9Enable IRQ9 pin snooze request
        constexpr uint32_t SNZREQEN8 = (1U << 8);  ///< Snooze Request Enable 8Enable IRQ8 pin snooze request
        constexpr uint32_t SNZREQEN7 = (1U << 7);  ///< Snooze Request Enable 7Enable IRQ7 pin snooze request
        constexpr uint32_t SNZREQEN6 = (1U << 6);  ///< Snooze Request Enable 6Enable IRQ6 pin snooze request
        constexpr uint32_t SNZREQEN5 = (1U << 5);  ///< Snooze Request Enable 5Enable IRQ5 pin snooze request
        constexpr uint32_t SNZREQEN4 = (1U << 4);  ///< Snooze Request Enable 4Enable IRQ4 pin snooze request
        constexpr uint32_t SNZREQEN3 = (1U << 3);  ///< Snooze Request Enable 3Enable IRQ3 pin snooze request
        constexpr uint32_t SNZREQEN2 = (1U << 2);  ///< Snooze Request Enable 2Enable IRQ2 pin snooze request
        constexpr uint32_t SNZREQEN1 = (1U << 1);  ///< Snooze Request Enable 1Enable IRQ1 pin snooze request
        constexpr uint32_t SNZREQEN0 = (1U << 0);  ///< Snooze Request Enable 0Enable IRQ0 pin snooze request
    }

    /// OPCCR Register bits
    namespace opccr_bits {
        constexpr uint32_t OPCMTSF = (1U << 4);  ///< Operating Power Control Mode Transition Status Flag
        constexpr uint32_t OPCM = (2 << 0);  ///< Operating Power Control Mode Select
    }

    /// SOPCCR Register bits
    namespace sopccr_bits {
        constexpr uint32_t SOPCMTSF = (1U << 4);  ///< Sub Operating Power Control Mode Transition Status Flag
        constexpr uint32_t SOPCM = (1U << 0);  ///< Sub Operating Power Control Mode Select
    }

    /// DPSBYCR Register bits
    namespace dpsbycr_bits {
        constexpr uint32_t DPSBY = (1U << 7);  ///< Deep Software Standby
        constexpr uint32_t IOKEEP = (1U << 6);  ///< I/O Port Retention
        constexpr uint32_t DEEPCUT = (2 << 0);  ///< Power-Supply Control
    }

    /// DPSIER0 Register bits
    namespace dpsier0_bits {
        constexpr uint32_t DIRQ7E = (1U << 7);  ///< IRQ7-DS Pin Enable
        constexpr uint32_t DIRQ6E = (1U << 6);  ///< IRQ6-DS Pin Enable
        constexpr uint32_t DIRQ5E = (1U << 5);  ///< IRQ5-DS Pin Enable
        constexpr uint32_t DIRQ4E = (1U << 4);  ///< IRQ4-DS Pin Enable
        constexpr uint32_t DIRQ3E = (1U << 3);  ///< IRQ3-DS Pin Enable
        constexpr uint32_t DIRQ2E = (1U << 2);  ///< IRQ2-DS Pin Enable
        constexpr uint32_t DIRQ1E = (1U << 1);  ///< IRQ1-DS Pin Enable
        constexpr uint32_t DIRQ0E = (1U << 0);  ///< IRQ0-DS Pin Enable
    }

    /// DPSIER1 Register bits
    namespace dpsier1_bits {
        constexpr uint32_t DIRQ14E = (1U << 6);  ///< IRQ14-DS Pin Enable
        constexpr uint32_t DIRQ13E = (1U << 5);  ///< IRQ13-DS Pin Enable
        constexpr uint32_t DIRQ12E = (1U << 4);  ///< IRQ12-DS Pin Enable
        constexpr uint32_t DIRQ11E = (1U << 3);  ///< IRQ11-DS Pin Enable
        constexpr uint32_t DIRQ10E = (1U << 2);  ///< IRQ10-DS Pin Enable
        constexpr uint32_t DIRQ9E = (1U << 1);  ///< IRQ9-DS Pin Enable
        constexpr uint32_t DIRQ8E = (1U << 0);  ///< IRQ8-DS Pin Enable
    }

    /// DPSIER2 Register bits
    namespace dpsier2_bits {
        constexpr uint32_t DNMIE = (1U << 4);  ///< NMI Pin Enable
        constexpr uint32_t DRTCAIE = (1U << 3);  ///< RTC Alarm interrupt Deep Standby Cancel Signal Enable
        constexpr uint32_t DTRTCIIE = (1U << 2);  ///< RTC Interval interrupt Deep Standby Cancel Signal Enable
        constexpr uint32_t DLVD2IE = (1U << 1);  ///< LVD2 Deep Standby Cancel Signal Enable
        constexpr uint32_t DLVD1IE = (1U << 0);  ///< LVD1 Deep Standby Cancel Signal Enable
    }

    /// DPSIER3 Register bits
    namespace dpsier3_bits {
        constexpr uint32_t DAGT1IE = (1U << 2);  ///< AGT1 Underflow Deep Standby Cancel Signal Enable
        constexpr uint32_t DUSBHSIE = (1U << 1);  ///< USBHS Suspend/Resume Deep Standby Cancel Signal Enable
        constexpr uint32_t DUSBFSIE = (1U << 0);  ///< USBFS Suspend/Resume Deep Standby Cancel Signal Enable
    }

    /// DPSIFR0 Register bits
    namespace dpsifr0_bits {
        constexpr uint32_t DIRQ7F = (1U << 7);  ///< IRQ7-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ6F = (1U << 6);  ///< IRQ6-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ5F = (1U << 5);  ///< IRQ5-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ4F = (1U << 4);  ///< IRQ4-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ3F = (1U << 3);  ///< IRQ3-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ2F = (1U << 2);  ///< IRQ2-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ1F = (1U << 1);  ///< IRQ1-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ0F = (1U << 0);  ///< IRQ0-DS Pin Deep Standby Cancel Flag
    }

    /// DPSIFR1 Register bits
    namespace dpsifr1_bits {
        constexpr uint32_t DIRQ14F = (1U << 6);  ///< IRQ14-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ13F = (1U << 5);  ///< IRQ13-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ12F = (1U << 4);  ///< IRQ12-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ11F = (1U << 3);  ///< IRQ11-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ10F = (1U << 2);  ///< IRQ10-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ9F = (1U << 1);  ///< IRQ9-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ8F = (1U << 0);  ///< IRQ8-DS Pin Deep Standby Cancel Flag
    }

    /// DPSIFR2 Register bits
    namespace dpsifr2_bits {
        constexpr uint32_t DNMIF = (1U << 4);  ///< NMI Pin Deep Standby Cancel Flag
        constexpr uint32_t DRTCAIF = (1U << 3);  ///< RTC Alarm interrupt Deep Standby Cancel Flag
        constexpr uint32_t DTRTCIIF = (1U << 2);  ///< RTC Interval interrupt Deep Standby Cancel Flag
        constexpr uint32_t DLVD2IF = (1U << 1);  ///< LVD2 Deep Standby Cancel Flag
        constexpr uint32_t DLVD1IF = (1U << 0);  ///< LVD1 Deep Standby Cancel Flag
    }

    /// DPSIFR3 Register bits
    namespace dpsifr3_bits {
        constexpr uint32_t DAGT1IF = (1U << 2);  ///< AGT1 Underflow Deep Standby Cancel Flag
        constexpr uint32_t DUSBHSIF = (1U << 1);  ///< USBHS Suspend/Resume Deep Standby Cancel Flag
        constexpr uint32_t DUSBFSIF = (1U << 0);  ///< USBFS Suspend/Resume Deep Standby Cancel Flag
    }

    /// DPSIEGR0 Register bits
    namespace dpsiegr0_bits {
        constexpr uint32_t DIRQ7EG = (1U << 7);  ///< IRQ7-DS Pin Edge Select
        constexpr uint32_t DIRQ6EG = (1U << 6);  ///< IRQ6-DS Pin Edge Select
        constexpr uint32_t DIRQ5EG = (1U << 5);  ///< IRQ5-DS Pin Edge Select
        constexpr uint32_t DIRQ4EG = (1U << 4);  ///< IRQ4-DS Pin Edge Select
        constexpr uint32_t DIRQ3EG = (1U << 3);  ///< IRQ3-DS Pin Edge Select
        constexpr uint32_t DIRQ2EG = (1U << 2);  ///< IRQ2-DS Pin Edge Select
        constexpr uint32_t DIRQ1EG = (1U << 1);  ///< IRQ1-DS Pin Edge Select
        constexpr uint32_t DIRQ0EG = (1U << 0);  ///< IRQ0-DS Pin Edge Select
    }

    /// DPSIEGR1 Register bits
    namespace dpsiegr1_bits {
        constexpr uint32_t DIRQ14EG = (1U << 6);  ///< IRQ14-DS Pin Edge Select
        constexpr uint32_t DIRQ13EG = (1U << 5);  ///< IRQ13-DS Pin Edge Select
        constexpr uint32_t DIRQ12EG = (1U << 4);  ///< IRQ12-DS Pin Edge Select
        constexpr uint32_t DIRQ11EG = (1U << 3);  ///< IRQ11-DS Pin Edge Select
        constexpr uint32_t DIRQ10EG = (1U << 2);  ///< IRQ10-DS Pin Edge Select
        constexpr uint32_t DIRQ9EG = (1U << 1);  ///< IRQ9-DS Pin Edge Select
        constexpr uint32_t DIRQ8EG = (1U << 0);  ///< IRQ8-DS Pin Edge Select
    }

    /// DPSIEGR2 Register bits
    namespace dpsiegr2_bits {
        constexpr uint32_t DNMIEG = (1U << 4);  ///< NMI Pin Edge Select
        constexpr uint32_t DLVD2IEG = (1U << 1);  ///< LVD2 Edge Select
        constexpr uint32_t DLVD1IEG = (1U << 0);  ///< LVD1 Edge Select
    }

    /// SYOCDCR Register bits
    namespace syocdcr_bits {
        constexpr uint32_t DBGEN = (1U << 7);  ///< Debugger Enable bit
        constexpr uint32_t DOCDF = (1U << 0);  ///< Deep Standby OCD flag
    }

    /// STCONR Register bits
    namespace stconr_bits {
        constexpr uint32_t STCON = (2 << 0);  ///< SSTBY condition bit
    }

    /// LVD%sCR1 Register bits
    namespace lvd%scr1_bits {
        constexpr uint32_t IRQSEL = (1U << 2);  ///< Voltage Monitor Interrupt Type Select
        constexpr uint32_t IDTSEL = (2 << 0);  ///< Voltage Monitor Interrupt Generation Condition Select
    }

    /// LVD%sSR Register bits
    namespace lvd%ssr_bits {
        constexpr uint32_t MON = (1U << 1);  ///< Voltage Monitor 1 Signal Monitor Flag
        constexpr uint32_t DET = (1U << 0);  ///< Voltage Monitor Voltage Change Detection Flag NOTE: Only 0 can be written to this bit. After writing 0 to this bit, it takes 2 system clock cycles for the bit to be read as 0.
    }

    /// LVCMPCR Register bits
    namespace lvcmpcr_bits {
        constexpr uint32_t LVD2E = (1U << 6);  ///< Voltage Detection 2 Enable
        constexpr uint32_t LVD1E = (1U << 5);  ///< Voltage Detection 1 Enable
    }

    /// LVDLVLR Register bits
    namespace lvdlvlr_bits {
        constexpr uint32_t LVD2LVL = (3 << 5);  ///< Voltage Detection 2 Level Select (Standard voltage during fall in voltage)
        constexpr uint32_t LVD1LVL = (5 << 0);  ///< Voltage Detection 1 Level Select (Standard voltage during fall in voltage)
    }

    /// LVD%sCR0 Register bits
    namespace lvd%scr0_bits {
        constexpr uint32_t RN = (1U << 7);  ///< Voltage Monitor Reset Negate Select
        constexpr uint32_t RI = (1U << 6);  ///< Voltage Monitor Circuit Mode Select
        constexpr uint32_t FSAMP = (2 << 4);  ///< Sampling Clock Select
        constexpr uint32_t CMPE = (1U << 2);  ///< Voltage Monitor Circuit Comparison Result Output Enable
        constexpr uint32_t DFDIS = (1U << 1);  ///< Voltage Monitor Digital Filter Disable Mode Select
        constexpr uint32_t RIE = (1U << 0);  ///< Voltage Monitor Interrupt/Reset Enable
    }

    /// VBTICTLR Register bits
    namespace vbtictlr_bits {
        constexpr uint32_t VCH2INEN = (1U << 2);  ///< RTCIC2 Input Enable
        constexpr uint32_t VCH1INEN = (1U << 1);  ///< RTCIC1 Input Enable
        constexpr uint32_t VCH0INEN = (1U << 0);  ///< RTCIC0 Input Enable
    }

    /// VBTBKR[%s] Register bits
    namespace vbtbkr[%s]_bits {
        constexpr uint32_t VBTBKR = (8 << 0);  ///< VBTBKR is a 512-byte readable/writable register to store data powered by VBATT.The value of this register is retained even when VCC is not powered but VBATT is powered.VBTBKR is initialized by VBATT selected voltage power-on-reset.
    }

    /// PRCR Register bits
    namespace prcr_bits {
        constexpr uint32_t PRKEY = (8 << 8);  ///< PRKEY Key Code
        constexpr uint32_t PRC3 = (1U << 3);  ///< Enables writing to the registers related to the LVD.
        constexpr uint32_t PRC1 = (1U << 1);  ///< Enables writing to the registers related to the operating modes, the low power consumption modes and the battery backup function.
        constexpr uint32_t PRC0 = (1U << 0);  ///< Enables writing to the registers related to the clock generation circuit.
    }

    /// RSTSR0 Register bits
    namespace rstsr0_bits {
        constexpr uint32_t DPSRSTF = (1U << 7);  ///< Deep Software Standby Reset FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t LVD2RF = (1U << 3);  ///< Voltage Monitor 2 Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t LVD1RF = (1U << 2);  ///< Voltage Monitor 1 Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t LVD0RF = (1U << 1);  ///< Voltage Monitor 0 Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t PORF = (1U << 0);  ///< Power-On Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
    }

    /// RSTSR2 Register bits
    namespace rstsr2_bits {
        constexpr uint32_t CWSF = (1U << 0);  ///< Cold/Warm Start Determination Flag
    }

    /// RSTSR1 Register bits
    namespace rstsr1_bits {
        constexpr uint32_t SPERF = (1U << 12);  ///< SP Error Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t BUSMRF = (1U << 11);  ///< Bus Master MPU Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t BUSSRF = (1U << 10);  ///< Bus Slave MPU Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t REERF = (1U << 9);  ///< RAM ECC Error Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t RPERF = (1U << 8);  ///< RAM Parity Error Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t SWRF = (1U << 2);  ///< Software Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t WDTRF = (1U << 1);  ///< Watchdog Timer Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t IWDTRF = (1U << 0);  ///< Independent Watchdog Timer Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
    }

    /// FWEPROR Register bits
    namespace fwepror_bits {
        constexpr uint32_t FLWE = (2 << 0);  ///< Flash Programming and Erasure
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t EDMAC0_BASE = 0x40064000;
    constexpr uint32_t DMAC0_BASE = 0x40005000;
    constexpr uint32_t DMAC1_BASE = 0x40005040;
    constexpr uint32_t DMAC2_BASE = 0x40005080;
    constexpr uint32_t DMAC3_BASE = 0x400050C0;
    constexpr uint32_t DMAC4_BASE = 0x40005100;
    constexpr uint32_t DMAC5_BASE = 0x40005140;
    constexpr uint32_t DMAC6_BASE = 0x40005180;
    constexpr uint32_t DMAC7_BASE = 0x400051C0;
    constexpr uint32_t DMA_BASE = 0x40005200;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t EDMR;  ///< Offset: 0x00 - EDMAC Mode Register
        volatile uint32_t EDTRR;  ///< Offset: 0x08 - EDMAC Transmit Request Register
        volatile uint32_t EDRRR;  ///< Offset: 0x10 - EDMAC Receive Request Register
        volatile uint32_t TDLAR;  ///< Offset: 0x18 - Transmit Descriptor List Start Address Register
        volatile uint32_t RDLAR;  ///< Offset: 0x20 - Receive Descriptor List Start Address Register
        volatile uint32_t EESR;  ///< Offset: 0x28 - ETHERC/EDMAC Status Register
        volatile uint32_t EESIPR;  ///< Offset: 0x30 - ETHERC/EDMAC Status Interrupt Enable Register
        volatile uint32_t TRSCER;  ///< Offset: 0x38 - ETHERC/EDMAC Transmit/Receive Status Copy Enable Register
        volatile uint32_t RMFCR;  ///< Offset: 0x40 - Missed-Frame Counter Register
        volatile uint32_t TFTR;  ///< Offset: 0x48 - Transmit FIFO Threshold Register
        volatile uint32_t FDR;  ///< Offset: 0x50 - Transmit FIFO Threshold Register
        volatile uint32_t RMCR;  ///< Offset: 0x58 - Receive Method Control Register
        volatile uint32_t TFUCR;  ///< Offset: 0x64 - Transmit FIFO Underflow Counter
        volatile uint32_t RFOCR;  ///< Offset: 0x68 - Receive FIFO Overflow Counter
        volatile uint32_t IOSR;  ///< Offset: 0x6C - Independent Output Signal Setting Register
        volatile uint32_t FCFTR;  ///< Offset: 0x70 - Flow Control Start FIFO Threshold Setting Register
        volatile uint32_t RPADIR;  ///< Offset: 0x78 - Receive Data Padding Insert Register
        volatile uint32_t TRIMD;  ///< Offset: 0x7C - Transmit Interrupt Setting Register
        volatile uint32_t RBWAR;  ///< Offset: 0xC8 - Receive Buffer Write Address Register
        volatile uint32_t RDFAR;  ///< Offset: 0xCC - Receive Descriptor Fetch Address Register
        volatile uint32_t TBRAR;  ///< Offset: 0xD4 - Transmit Buffer Read Address Register
        volatile uint32_t TDFAR;  ///< Offset: 0xD8 - Transmit Descriptor Fetch Address Register
    };

    /// Peripheral instances
    inline Registers* EDMAC0 = reinterpret_cast<Registers*>(EDMAC0_BASE);
    inline Registers* DMAC0 = reinterpret_cast<Registers*>(DMAC0_BASE);
    inline Registers* DMAC1 = reinterpret_cast<Registers*>(DMAC1_BASE);
    inline Registers* DMAC2 = reinterpret_cast<Registers*>(DMAC2_BASE);
    inline Registers* DMAC3 = reinterpret_cast<Registers*>(DMAC3_BASE);
    inline Registers* DMAC4 = reinterpret_cast<Registers*>(DMAC4_BASE);
    inline Registers* DMAC5 = reinterpret_cast<Registers*>(DMAC5_BASE);
    inline Registers* DMAC6 = reinterpret_cast<Registers*>(DMAC6_BASE);
    inline Registers* DMAC7 = reinterpret_cast<Registers*>(DMAC7_BASE);
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

    // Bit definitions
    /// EDMR Register bits
    namespace edmr_bits {
        constexpr uint32_t DE = (1U << 6);  ///< Big Endian Mode/Little Endian ModeNOTE: This setting applies to data for the transmit/receive buffer. It does not apply to transmit/receive descriptors and registers.
        constexpr uint32_t DL = (2 << 4);  ///< Transmit/Receive DescriptorLength
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
    }

    /// EDTRR Register bits
    namespace edtrr_bits {
        constexpr uint32_t TR = (1U << 0);  ///< Transmit Request
    }

    /// EDRRR Register bits
    namespace edrrr_bits {
        constexpr uint32_t RR = (1U << 0);  ///< Receive Request
    }

    /// TDLAR Register bits
    namespace tdlar_bits {
        constexpr uint32_t TDLAR = (32 << 0);  ///< The start address of the transmit descriptor list is set. Set the start address according to the descriptor length selected by the EDMR.DL[1:0] bits.16-byte boundary: Lower 4 bits = 0000b32-byte boundary: Lower 5 bits = 00000b64-byte boundary: Lower 6 bits = 000000b
    }

    /// RDLAR Register bits
    namespace rdlar_bits {
        constexpr uint32_t RDLAR = (32 << 0);  ///< The start address of the receive descriptor list is set. Set the start address according to the descriptor length selected by the EDMR.DL[1:0] bits.16-byte boundary: Lower 4 bits = 0000b32-byte boundary: Lower 5 bits = 00000b64-byte boundary: Lower 6 bits = 000000b
    }

    /// EESR Register bits
    namespace eesr_bits {
        constexpr uint32_t TWB = (1U << 30);  ///< Write-Back Complete Flag
        constexpr uint32_t TABT = (1U << 26);  ///< Transmit Abort Detect Flag
        constexpr uint32_t RABT = (1U << 25);  ///< Receive Abort Detect Flag
        constexpr uint32_t RFCOF = (1U << 24);  ///< Receive Frame Counter Overflow Flag
        constexpr uint32_t ADE = (1U << 23);  ///< Address Error Flag
        constexpr uint32_t ECI = (1U << 22);  ///< ETHERC Status Register Source FlagNOTE: When the source in the ETHERCn.ECSR register is cleared, the ECI flag is also cleared.
        constexpr uint32_t TC = (1U << 21);  ///< Frame Transfer Complete Flag
        constexpr uint32_t TDE = (1U << 20);  ///< Transmit Descriptor Empty Flag
        constexpr uint32_t TFUF = (1U << 19);  ///< Transmit FIFO Underflow Flag
        constexpr uint32_t FR = (1U << 18);  ///< Frame Receive Flag
        constexpr uint32_t RDE = (1U << 17);  ///< Receive Descriptor Empty Flag
        constexpr uint32_t RFOF = (1U << 16);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t CND = (1U << 11);  ///< Carrier Not Detect Flag
        constexpr uint32_t DLC = (1U << 10);  ///< Loss of Carrier Detect Flag
        constexpr uint32_t CD = (1U << 9);  ///< Late Collision Detect Flag
        constexpr uint32_t TRO = (1U << 8);  ///< Transmit Retry Over Flag
        constexpr uint32_t RMAF = (1U << 7);  ///< Multicast Address Frame Receive Flag
        constexpr uint32_t RRF = (1U << 4);  ///< Alignment Error Flag
        constexpr uint32_t RTLF = (1U << 3);  ///< Frame-Too-Long Error Flag
        constexpr uint32_t RTSF = (1U << 2);  ///< Frame-Too-Short Error Flag
        constexpr uint32_t PRE = (1U << 1);  ///< PHY-LSI Receive Error Flag
        constexpr uint32_t CERF = (1U << 0);  ///< CRC Error Flag
    }

    /// EESIPR Register bits
    namespace eesipr_bits {
        constexpr uint32_t TWBIP = (1U << 30);  ///< Write-Back Complete Interrupt Request Enable
        constexpr uint32_t TABTIP = (1U << 26);  ///< Transmit Abort Detect Interrupt Request Enable
        constexpr uint32_t RABTIP = (1U << 25);  ///< Receive Abort Detect Interrupt Request Enable
        constexpr uint32_t RFCOFIP = (1U << 24);  ///< Receive Frame Counter Overflow Interrupt Request Enable
        constexpr uint32_t ADEIP = (1U << 23);  ///< Address Error Interrupt Request Enable
        constexpr uint32_t ECIIP = (1U << 22);  ///< ETHERC Status Register Source Interrupt Request Enable
        constexpr uint32_t TCIP = (1U << 21);  ///< Frame Transfer Complete Interrupt Request Enable
        constexpr uint32_t TDEIP = (1U << 20);  ///< Transmit Descriptor Empty Interrupt Request Enable
        constexpr uint32_t TFUFIP = (1U << 19);  ///< Transmit FIFO Underflow Interrupt Request Enable
        constexpr uint32_t FRIP = (1U << 18);  ///< Frame Receive Interrupt Request Enable
        constexpr uint32_t RDEIP = (1U << 17);  ///< Receive Descriptor Empty Interrupt Request Enable
        constexpr uint32_t RFOFIP = (1U << 16);  ///< Receive FIFO Overflow Interrupt Request Enable
        constexpr uint32_t CNDIP = (1U << 11);  ///< Carrier Not Detect Interrupt Request Enable
        constexpr uint32_t DLCIP = (1U << 10);  ///< Loss of Carrier Detect Interrupt Request Enable
        constexpr uint32_t CDIP = (1U << 9);  ///< Late Collision Detect Interrupt Request Enable
        constexpr uint32_t TROIP = (1U << 8);  ///< Transmit Retry Over Interrupt Request Enable
        constexpr uint32_t RMAFIP = (1U << 7);  ///< Multicast Address Frame Receive Interrupt Request Enable
        constexpr uint32_t RRFIP = (1U << 4);  ///< Alignment Error Interrupt Request Enable
        constexpr uint32_t RTLFIP = (1U << 3);  ///< Frame-Too-Long Error Interrupt Request Enable
        constexpr uint32_t RTSFIP = (1U << 2);  ///< Frame-Too-Short Error Interrupt Request Enable
        constexpr uint32_t PREIP = (1U << 1);  ///< PHY-LSI Receive Error Interrupt Request Enable
        constexpr uint32_t CERFIP = (1U << 0);  ///< CRC Error Interrupt Request Enable
    }

    /// TRSCER Register bits
    namespace trscer_bits {
        constexpr uint32_t RMAFCE = (1U << 7);  ///< RMAF Flag Copy Enable
        constexpr uint32_t RRFCE = (1U << 4);  ///< RRF Flag Copy Enable
    }

    /// RMFCR Register bits
    namespace rmfcr_bits {
        constexpr uint32_t MFC = (16 << 0);  ///< Missed-Frame CounterThese bits indicate the number of frames that are discarded and not transferred to the receive buffer during reception.
    }

    /// TFTR Register bits
    namespace tftr_bits {
        constexpr uint32_t TFT = (11 << 0);  ///< Transmit FIFO Threshold00Dh to 200h: The threshold is the set value multiplied by 4. Example: 00Dh: 52 bytes 040h: 256 bytes 100h: 1024 bytes 200h: 2048 bytes
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t TFD = (5 << 8);  ///< Receive FIFO Depth
        constexpr uint32_t RFD = (5 << 0);  ///< Transmit FIFO Depth
    }

    /// RMCR Register bits
    namespace rmcr_bits {
        constexpr uint32_t RNR = (1U << 0);  ///< Receive Request Reset
    }

    /// TFUCR Register bits
    namespace tfucr_bits {
        constexpr uint32_t UNDER = (16 << 0);  ///< Transmit FIFO Underflow CountThese bits indicate how many times the transmit FIFO has underflowed. The counter stops when the counter value reaches FFFFh.
    }

    /// RFOCR Register bits
    namespace rfocr_bits {
        constexpr uint32_t OVER = (16 << 0);  ///< Receive FIFO Overflow CountThese bits indicate how many times the receive FIFO has overflowed. The counter stops when the counter value reaches FFFFh.
    }

    /// IOSR Register bits
    namespace iosr_bits {
        constexpr uint32_t ELB = (1U << 0);  ///< External Loopback Mode
    }

    /// FCFTR Register bits
    namespace fcftr_bits {
        constexpr uint32_t RFFO = (3 << 16);  ///< Receive FIFO Frame PAUSE Output Threshold(When ((RFFO+1)x2) receive frames have been stored in the receive FIFO.)
        constexpr uint32_t RFDO = (3 << 0);  ///< Receive FIFO Data PAUSE Output Threshold(When (RFDO+1)x256-32 bytes of data is stored in the receive FIFO.)
    }

    /// RPADIR Register bits
    namespace rpadir_bits {
        constexpr uint32_t PADS = (2 << 16);  ///< Padding Size
        constexpr uint32_t PADR = (6 << 0);  ///< Padding Slot
    }

    /// TRIMD Register bits
    namespace trimd_bits {
        constexpr uint32_t TIM = (1U << 4);  ///< Transmit Interrupt Mode
        constexpr uint32_t TIS = (1U << 0);  ///< Transmit Interrupt EnableSet the EESR.TWB flag to 1 in the mode selected by the TIM bit to notify an interrupt.
    }

    /// RBWAR Register bits
    namespace rbwar_bits {
        constexpr uint32_t RBWAR = (32 << 0);  ///< Receive Buffer Write Address RegisterThe RBWAR register indicates the last address that the EDMAC has written data to when writing to the receive buffer.Refer to the address indicated by the RBWAR register to recognize which address in the receive buffer the EDMAC is writing data to. Note that the address that the EDMAC is outputting to the receive buffer may not match the read value of the RBWAR register during data reception.
    }

    /// RDFAR Register bits
    namespace rdfar_bits {
        constexpr uint32_t RDFAR = (32 << 0);  ///< Receive Descriptor Fetch Address RegisterThe RDFAR register indicates the start address of the last fetched receive descriptor when the EDMAC fetches descriptor information from the receive descriptor.Refer to the address indicated by the RDFAR register to recognize which receive descriptor information the EDMAC is using for the current processing. Note that the address of the receive descriptor that the EDMAC fetches may not match the read value of the RDFAR register during data reception.
    }

    /// TBRAR Register bits
    namespace tbrar_bits {
        constexpr uint32_t TBRAR = (32 << 0);  ///< Transmit Buffer Read Address RegisterThe TBRAR register indicates the last address that the EDMAC has read data from when reading data from the transmit buffer.Refer to the address indicated by the TBRAR register to recognize which address in the transmit buffer the EDMAC is reading from. Note that the address that the EDMAC is outputting to the transmit buffer may not match the read value of the TBRAR register.
    }

    /// TDFAR Register bits
    namespace tdfar_bits {
        constexpr uint32_t TDFAR = (32 << 0);  ///< Transmit Descriptor Fetch Address RegisterThe TDFAR register indicates the start address of the last fetched transmit descriptor when the EDMAC fetches descriptor information from the transmit descriptor.Refer to the address indicated by the TDFAR register to recognize which transmit descriptor information the EDMAC is using for the current processing. Note that the address of the transmit descriptor that the EDMAC fetches may not match the read value of the TDFAR register.
    }

}

// ============================================================================
// ETH Peripheral
// ============================================================================

namespace eth {
    /// Base addresses
    constexpr uint32_t ETHERC0_BASE = 0x40064100;

    /// ETH Register structure
    struct Registers {
        volatile uint32_t ECMR;  ///< Offset: 0x00 - ETHERC Mode Register
        volatile uint32_t RFLR;  ///< Offset: 0x08 - Receive Frame Maximum Length Register
        volatile uint32_t ECSR;  ///< Offset: 0x10 - ETHERC Status Register
        volatile uint32_t ECSIPR;  ///< Offset: 0x18 - ETHERC Interrupt Enable Register
        volatile uint32_t PIR;  ///< Offset: 0x20 - PHY Interface Register
        volatile uint32_t PSR;  ///< Offset: 0x28 - PHY Status Register
        volatile uint32_t RDMLR;  ///< Offset: 0x40 - Random Number Generation Counter Upper Limit Setting Register
        volatile uint32_t IPGR;  ///< Offset: 0x50 - IPG Register
        volatile uint32_t APR;  ///< Offset: 0x54 - Automatic PAUSE Frame Register
        volatile uint32_t MPR;  ///< Offset: 0x58 - Manual PAUSE Frame Register
        volatile uint32_t RFCF;  ///< Offset: 0x60 - Received PAUSE Frame Counter
        volatile uint32_t TPAUSER;  ///< Offset: 0x64 - PAUSE Frame Retransmit Count Setting Register
        volatile uint32_t TPAUSECR;  ///< Offset: 0x68 - PAUSE Frame Retransmit Counter
        volatile uint32_t BCFRR;  ///< Offset: 0x6C - Broadcast Frame Receive Count Setting Register
        volatile uint32_t MAHR;  ///< Offset: 0xC0 - MAC Address Upper Bit Register
        volatile uint32_t MALR;  ///< Offset: 0xC8 - MAC Address Lower Bit Register
        volatile uint32_t TROCR;  ///< Offset: 0xD0 - Transmit Retry Over Counter Register
        volatile uint32_t CDCR;  ///< Offset: 0xD4 - Late Collision Detect Counter Register
        volatile uint32_t LCCR;  ///< Offset: 0xD8 - Lost Carrier Counter Register
        volatile uint32_t CNDCR;  ///< Offset: 0xDC - Carrier Not Detect Counter Register
        volatile uint32_t CEFCR;  ///< Offset: 0xE4 - CRC Error Frame Receive Counter Register
        volatile uint32_t FRECR;  ///< Offset: 0xE8 - Frame Receive Error Counter Register
        volatile uint32_t TSFRCR;  ///< Offset: 0xEC - Too-Short Frame Receive Counter Register
        volatile uint32_t TLFRCR;  ///< Offset: 0xF0 - Too-Long Frame Receive Counter Register
        volatile uint32_t RFCR;  ///< Offset: 0xF4 - Received Alignment Error Frame Counter Register
        volatile uint32_t MAFCR;  ///< Offset: 0xF8 - Multicast Address Frame Receive Counter Register
    };

    /// Peripheral instances
    inline Registers* ETHERC0 = reinterpret_cast<Registers*>(ETHERC0_BASE);

    // Bit definitions
    /// ECMR Register bits
    namespace ecmr_bits {
        constexpr uint32_t TPC = (1U << 20);  ///< PAUSE Frame Transmit
        constexpr uint32_t ZPF = (1U << 19);  ///< 0 Time PAUSE Frame Enable
        constexpr uint32_t PFR = (1U << 18);  ///< PAUSE Frame Receive Mode
        constexpr uint32_t RXF = (1U << 17);  ///< Receive Flow Control Operating Mode
        constexpr uint32_t TXF = (1U << 16);  ///< Transmit Flow Control Operating Mode
        constexpr uint32_t PRCEF = (1U << 12);  ///< CRC Error Frame Receive Mode
        constexpr uint32_t MPDE = (1U << 9);  ///< Magic Packet Detection Enable
        constexpr uint32_t RE = (1U << 6);  ///< Reception Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmission Enable
        constexpr uint32_t ILB = (1U << 3);  ///< Internal Loopback Mode
        constexpr uint32_t RTM = (1U << 2);  ///< Bit Rate
        constexpr uint32_t DM = (1U << 1);  ///< Duplex Mode
        constexpr uint32_t PRM = (1U << 0);  ///< Promiscuous Mode
    }

    /// RFLR Register bits
    namespace rflr_bits {
        constexpr uint32_t RFL = (12 << 0);  ///< Receive Frame Maximum LengthThe set value becomes the maximum frame length. The minimum value that can be set is 1,518 bytes, and the maximum value that can be set is 2,048 bytes. Values that are less than 1,518 bytes are regarded as 1,518 bytes, and values larger than 2,048 bytes are regarded as 2,048 bytes.
    }

    /// ECSR Register bits
    namespace ecsr_bits {
        constexpr uint32_t BFR = (1U << 5);  ///< Continuous Broadcast Frame Reception Flag
        constexpr uint32_t PSRTO = (1U << 4);  ///< PAUSE Frame Retransmit Over Flag
        constexpr uint32_t LCHNG = (1U << 2);  ///< LCHNG Link Signal Change Flag
        constexpr uint32_t MPD = (1U << 1);  ///< Magic Packet Detect Flag
        constexpr uint32_t ICD = (1U << 0);  ///< False Carrier Detect Flag
    }

    /// ECSIPR Register bits
    namespace ecsipr_bits {
        constexpr uint32_t BFSIPR = (1U << 5);  ///< Continuous Broadcast Frame Reception Interrupt Enable
        constexpr uint32_t PSRTOIP = (1U << 4);  ///< PAUSE Frame Retransmit Over Interrupt Enable
        constexpr uint32_t LCHNGIP = (1U << 2);  ///< LINK Signal Change Interrupt Enable
        constexpr uint32_t MPDIP = (1U << 1);  ///< Magic Packet Detect Interrupt Enable
        constexpr uint32_t ICDIP = (1U << 0);  ///< False Carrier Detect Interrupt Enable
    }

    /// PIR Register bits
    namespace pir_bits {
        constexpr uint32_t MDI = (1U << 3);  ///< MII/RMII Management Data-InThis bit indicates the level of the ETn_MDIO pin. The write value should be 0.
        constexpr uint32_t MDO = (1U << 2);  ///< MII/RMII Management Data-OutThe MDO bit value is output from the ETn_MDIO pin when the MMD bit is 1 (write). The value is not output when the MMD bit is 0 (read).
        constexpr uint32_t MMD = (1U << 1);  ///< MII/RMII Management Mode
        constexpr uint32_t MDC = (1U << 0);  ///< MII/RMII Management Data ClockThe MDC bit value is output from the ETn_MDC pin to supply the management data clock to the MII or RMII.
    }

    /// PSR Register bits
    namespace psr_bits {
        constexpr uint32_t LMON = (1U << 0);  ///< ETn_LINKSTA Pin Status FlagThe link status can be read by connecting the link signal output from the PHY-LSI to the ETn_LINKSTA pin. For details on the polarity, refer to the specifications of the connected PHY-LSI.
    }

    /// RDMLR Register bits
    namespace rdmlr_bits {
        constexpr uint32_t RMD = (20 << 0);  ///< Random Number Generation Counter
    }

    /// IPGR Register bits
    namespace ipgr_bits {
        constexpr uint32_t IPG = (5 << 0);  ///< Interpacket Gap Range:"16bit time(0x00)"-"140bit time(0x1F)"
    }

    /// APR Register bits
    namespace apr_bits {
        constexpr uint32_t AP = (16 << 0);  ///< Automatic PAUSE Time SettingThese bits set the value of the pause_time parameter for a PAUSE frame that is automatically transmitted. Transmission is not performed until the set value multiplied by 512 bit time has elapsed.
    }

    /// MPR Register bits
    namespace mpr_bits {
        constexpr uint32_t MP = (16 << 0);  ///< Manual PAUSE Time SettingThese bits set the value of the pause_time parameter for a PAUSE frame that is manually transmitted. Transmission is not performed until the set value multiplied by 512 bit time has elapsed. The read value is undefined.
    }

    /// RFCF Register bits
    namespace rfcf_bits {
        constexpr uint32_t RPAUSE = (8 << 0);  ///< Received PAUSE Frame CountNumber of received PAUSE frames
    }

    /// TPAUSER Register bits
    namespace tpauser_bits {
        constexpr uint32_t TPAUSE = (16 << 0);  ///< Automatic PAUSE Frame Retransmit Setting
    }

    /// BCFRR Register bits
    namespace bcfrr_bits {
        constexpr uint32_t BCF = (16 << 0);  ///< Broadcast Frame Continuous Receive Count Setting
    }

    /// MAHR Register bits
    namespace mahr_bits {
        constexpr uint32_t MAHR = (32 << 0);  ///< MAC Address Upper Bit RegisterThe MAHR register sets the upper 32 bits (b47 to b16) of the 48-bit MAC address.
    }

    /// MALR Register bits
    namespace malr_bits {
        constexpr uint32_t MALR = (16 << 0);  ///< MAC Address Lower Bit RegisterThe MALR register sets the lower 16 bits of the 48-bit MAC address.
    }

    /// TROCR Register bits
    namespace trocr_bits {
        constexpr uint32_t TROCR = (32 << 0);  ///< Transmit Retry Over Counter RegisterThe TROCR register is a counter indicating the number of frames that fail to be retransmitted.
    }

    /// LCCR Register bits
    namespace lccr_bits {
        constexpr uint32_t LCCR = (32 << 0);  ///< Lost Carrier Counter RegisterThe LCCR register is a counter indicating the number of times a loss of carrier is detected during frame transmission.
    }

    /// CNDCR Register bits
    namespace cndcr_bits {
        constexpr uint32_t CNDCR = (32 << 0);  ///< Carrier Not Detect Counter RegisterThe CNDCR register is a counter indicating the number of times a carrier is not detected during preamble transmission.
    }

    /// CEFCR Register bits
    namespace cefcr_bits {
        constexpr uint32_t CEFCR = (32 << 0);  ///< CRC Error Frame Receive Counter RegisterThe CEFCR register is a counter indicating the number of received frames where a CRC error has been detected.
    }

    /// FRECR Register bits
    namespace frecr_bits {
        constexpr uint32_t FRECR = (32 << 0);  ///< Frame Receive Error Counter RegisterThe FRECR register is a counter indicating the number of times a frame receive error has occurred.
    }

    /// TSFRCR Register bits
    namespace tsfrcr_bits {
        constexpr uint32_t TSFRCR = (32 << 0);  ///< Too-Short Frame Receive Counter RegisterThe TSFRCR register is a counter indicating the number of times a short frame that is shorter than 64 bytes has been received.
    }

    /// TLFRCR Register bits
    namespace tlfrcr_bits {
        constexpr uint32_t TLFRCR = (32 << 0);  ///< Too-Long Frame Receive Counter RegisterThe TLFRCR register is a counter indicating the number of times a long frame that is longer than the RFLR register value has been received.
    }

    /// RFCR Register bits
    namespace rfcr_bits {
        constexpr uint32_t RFCR = (32 << 0);  ///< Received Alignment Error Frame Counter RegisterThe RFCR register is a counter indicating the number of times a frame has been received with the alignment error (frame is not an integral number of octets).
    }

    /// MAFCR Register bits
    namespace mafcr_bits {
        constexpr uint32_t MAFCR = (32 << 0);  ///< Multicast Address Frame Receive Counter RegisterThe MAFCR register is a counter indicating the number of times a frame where the multicast address is set has been received.
    }

}

// ============================================================================
// SDHI0 Peripheral
// ============================================================================

namespace sdhi0 {
    /// Base addresses
    constexpr uint32_t SDHI0_BASE = 0x40062000;

    /// SDHI0 Register structure
    struct Registers {
        volatile uint32_t SD_CMD;  ///< Offset: 0x00 - Command Type Register
        volatile uint32_t SD_ARG;  ///< Offset: 0x08 - SD Command Argument Register
        volatile uint32_t SD_ARG1;  ///< Offset: 0x0C - SD Command Argument Register 1
        volatile uint32_t SD_STOP;  ///< Offset: 0x10 - Data Stop Register
        volatile uint32_t SD_SECCNT;  ///< Offset: 0x14 - Block Count Register
        volatile uint32_t SD_RSP10;  ///< Offset: 0x18 - SD Card Response Register 10
        volatile uint32_t SD_RSP1;  ///< Offset: 0x1C - SD Card Response Register 1
        volatile uint32_t SD_RSP32;  ///< Offset: 0x20 - SD Card Response Register 32
        volatile uint32_t SD_RSP3;  ///< Offset: 0x24 - SD Card Response Register 3
        volatile uint32_t SD_RSP54;  ///< Offset: 0x28 - SD Card Response Register 54
        volatile uint32_t SD_RSP5;  ///< Offset: 0x2C - SD Card Response Register 5
        volatile uint32_t SD_RSP76;  ///< Offset: 0x30 - SD Card Response Register 76
        volatile uint32_t SD_RSP7;  ///< Offset: 0x34 - SD Card Response Register 7
        volatile uint32_t SD_INFO1;  ///< Offset: 0x38 - SD Card Interrupt Flag Register 1
        volatile uint32_t SD_INFO2;  ///< Offset: 0x3C - SD Card Interrupt Flag Register 2
        volatile uint32_t SD_INFO1_MASK;  ///< Offset: 0x40 - SD_INFO1 Interrupt Mask Register
        volatile uint32_t SD_INFO2_MASK;  ///< Offset: 0x44 - SD_INFO2 Interrupt Mask Register
        volatile uint32_t SD_CLK_CTRL;  ///< Offset: 0x48 - SD Clock Control Register
        volatile uint32_t SD_SIZE;  ///< Offset: 0x4C - Transfer Data Length Register
        volatile uint32_t SD_OPTION;  ///< Offset: 0x50 - SD Card Access Control Option Register
        volatile uint32_t SD_ERR_STS1;  ///< Offset: 0x58 - SD Error Status Register 1
        volatile uint32_t SD_ERR_STS2;  ///< Offset: 0x5C - SD Error Status Register 2
        volatile uint32_t SD_BUF0;  ///< Offset: 0x60 - SD Buffer Register
        volatile uint32_t SDIO_MODE;  ///< Offset: 0x68 - SDIO Mode Control Register
        volatile uint32_t SDIO_INFO1;  ///< Offset: 0x6C - SDIO Interrupt Flag Register 1
        volatile uint32_t SDIO_INFO1_MASK;  ///< Offset: 0x70 - SDIO_INFO1 Interrupt Mask Register
        volatile uint32_t SD_DMAEN;  ///< Offset: 0x1B0 - DMA Mode Enable Register
        volatile uint32_t SOFT_RST;  ///< Offset: 0x1C0 - Software Reset Register
        volatile uint32_t SDIF_MODE;  ///< Offset: 0x1CC - SD Interface Mode Setting Register
        volatile uint32_t EXT_SWAP;  ///< Offset: 0x1E0 - Swap Control Register
    };

    /// Peripheral instances
    inline Registers* SDHI0 = reinterpret_cast<Registers*>(SDHI0_BASE);

    // Bit definitions
    /// SD_CMD Register bits
    namespace sd_cmd_bits {
        constexpr uint32_t CMD12AT = (2 << 14);  ///< Multiple Block Transfer Mode (enabled at multiple block transfer)
        constexpr uint32_t TRSTP = (1U << 13);  ///< Single/Multiple Block Transfer (enabled when the command with data is handled)
        constexpr uint32_t CMDRW = (1U << 12);  ///< Write/Read Mode (enabled when the command with data is handled)
        constexpr uint32_t CMDTP = (1U << 11);  ///< Data Mode (Command Type)
        constexpr uint32_t RSPTP = (3 << 8);  ///< Mode/Response TypeNOTE: As some commands cannot be used in normal mode, see section 1.4.10, Example of SD_CMD Register Setting to select mode/response type.
        constexpr uint32_t ACMD = (2 << 6);  ///< Command Type Select
        constexpr uint32_t CMDIDX = (6 << 0);  ///< Command IndexThese bits specify Command Format[45:40] (command index).[Examples]CMD6: SD_CMD[7:0] = 8'b00_000110CMD18: SD_CMD[7:0] = 8'b00_010010ACMD13: SD_CMD[7:0] = 8'b01_001101
    }

    /// SD_ARG Register bits
    namespace sd_arg_bits {
        constexpr uint32_t SD_ARG = (32 << 0);  ///< Argument RegisterSet command format[39:8] (argument)
    }

    /// SD_ARG1 Register bits
    namespace sd_arg1_bits {
        constexpr uint32_t SD_ARG1 = (16 << 0);  ///< Argument Register 1Set command format[39:24] (argument)
    }

    /// SD_STOP Register bits
    namespace sd_stop_bits {
        constexpr uint32_t SEC = (1U << 8);  ///< Block Count EnableSet SEC to 1 at multiple block transfer.When SD_CMD is set as follows to start the command sequence while SEC is set to 1, CMD12 is automatically issued to stop multi-block transfer with the number of blocks which is set to SD_SECCNT.1. CMD18 or CMD25 in normal mode (SD_CMD[10:8] = 000)2. SD_CMD[15:13] = 001 in extended mode (CMD12 is automatically issued, multiple block transfer)When the command sequence is halted because of a communications error or timeout, CMD12 is not automatically issued.NOTE: Do not change the value of this bit when the CBSY bit in SD_INFO2 is set to 1.
        constexpr uint32_t STP = (1U << 0);  ///< Stop- When STP is set to 1 during multiple block transfer, CMD12 is issued to halt the transfer through the SD host interface.However, if a command sequence is halted because of a communications error or timeout, CMD12 is not issued. Although continued buffer access is possible even after STP has been set to 1, the buffer access error bit (ERR5 or ERR4) in SD_INFO2 will be set accordingly.- When STP has been set to 1 during transfer for single block write, the access end flag is set when SD_BUF becomes empty, and CMD12 is not issued. If SD_BUF does contain data, the access end flag is set on completion of reception of the busy state without CMD12 having been issued.- When STP has been set to 1 during transfer for single block read, the access end flag is set immediately after setting of the STP bit and CMD12 is not issued.- When STP is set to 1 during reception of the busy state after an R1b response, the access end flag is set on completion of reception of the busy state without CMD12 having been issued.- When STP is set to 1 after a command sequence has been completed, CMD12 is not issued and the access end flag is not set.- Set STP to 1 after the response end flag has been set.- Set STP to 0 after the response end flag has been set.
    }

    /// SD_SECCNT Register bits
    namespace sd_seccnt_bits {
        constexpr uint32_t SD_SECCNT = (32 << 0);  ///< Number of Transfer BlocksNOTE: Do not change the value of this bit when the CBSY bit in SD_INFO2 is set to 1.
    }

    /// SD_RSP10 Register bits
    namespace sd_rsp10_bits {
        constexpr uint32_t SD_RSP10 = (32 << 0);  ///< Store the response from the SD card/MMC
    }

    /// SD_RSP1 Register bits
    namespace sd_rsp1_bits {
        constexpr uint32_t SD_RSP1 = (16 << 0);  ///< Store the response from the SD card/MMC
    }

    /// SD_RSP32 Register bits
    namespace sd_rsp32_bits {
        constexpr uint32_t SD_RSP32 = (32 << 0);  ///< Store the response from the SD card/MMC
    }

    /// SD_RSP3 Register bits
    namespace sd_rsp3_bits {
        constexpr uint32_t SD_RSP3 = (16 << 0);  ///< Store the response from the SD card/MMC
    }

    /// SD_RSP54 Register bits
    namespace sd_rsp54_bits {
        constexpr uint32_t SD_RSP54 = (32 << 0);  ///< Store the response from the SD card/MMC
    }

    /// SD_RSP5 Register bits
    namespace sd_rsp5_bits {
        constexpr uint32_t SD_RSP5 = (16 << 0);  ///< Store the response from the SD card/MMC
    }

    /// SD_RSP76 Register bits
    namespace sd_rsp76_bits {
        constexpr uint32_t SD_RSP76 = (24 << 0);  ///< Store the response from the SD card/MMC
    }

    /// SD_RSP7 Register bits
    namespace sd_rsp7_bits {
        constexpr uint32_t SD_RSP7 = (8 << 0);  ///< Store the response from the SD card/MMC
    }

    /// SD_INFO1 Register bits
    namespace sd_info1_bits {
        constexpr uint32_t SDD3MON = (1U << 10);  ///< Inticates the SDnDAT3 State
        constexpr uint32_t SDD3IN = (1U << 9);  ///< SDnDAT3 Card Insertion
        constexpr uint32_t SDD3RM = (1U << 8);  ///< SDnDAT3 Card Removal
        constexpr uint32_t SDWPMON = (1U << 7);  ///< Indicates the SDnWP state
        constexpr uint32_t SDCDMON = (1U << 5);  ///< Indicates the SDnCD state
        constexpr uint32_t SDCDIN = (1U << 4);  ///< SDnCD Card Insertion
        constexpr uint32_t SDCDRM = (1U << 3);  ///< SDnCD Card Removal
        constexpr uint32_t ACEND = (1U << 2);  ///< Access End
        constexpr uint32_t RSPEND = (1U << 0);  ///< Response End Detection
    }

    /// SD_INFO2 Register bits
    namespace sd_info2_bits {
        constexpr uint32_t ILA = (1U << 15);  ///< Illegal Access Error
        constexpr uint32_t CBSY = (1U << 14);  ///< Command Type Register Busy
        constexpr uint32_t SD_CLK_CTRLEN = (1U << 13);  ///< When a command sequence is started by writing to SD_CMD, the CBSY bit is set to 1 and, at the same time, the SCLKDIVEN bit is set to 0. The SCLKDIVEN bit is set to 1 after 8 cycles of SDCLK have elapsed after setting of the CBSY bit to 0 due to completion of the command sequence.
        constexpr uint32_t BWE = (1U << 9);  ///< SD_BUF Write Enable
        constexpr uint32_t BRE = (1U << 8);  ///< SD_BUF Read Enable
        constexpr uint32_t SDD0MON = (1U << 7);  ///< SDDAT0Indicates the SDDAT0 state of the port specified by SD_PORTSEL.
        constexpr uint32_t RSPTO = (1U << 6);  ///< Response Timeout
        constexpr uint32_t ILR = (1U << 5);  ///< SD_BUF Illegal Read Access
        constexpr uint32_t ILW = (1U << 4);  ///< SD_BUF Illegal Write Access
        constexpr uint32_t DTO = (1U << 3);  ///< Data Timeout
        constexpr uint32_t ENDE = (1U << 2);  ///< END Error
        constexpr uint32_t CRCE = (1U << 1);  ///< CRC Error
        constexpr uint32_t CMDE = (1U << 0);  ///< Command Error
    }

    /// SD_INFO1_MASK Register bits
    namespace sd_info1_mask_bits {
        constexpr uint32_t SDD3INM = (1U << 9);  ///< SDnDAT3 Card Insertion Interrupt Request Mask
        constexpr uint32_t SDD3RMM = (1U << 8);  ///< SDnDAT3 Card Removal Interrupt Request Mask
        constexpr uint32_t SDCDINM = (1U << 4);  ///< SDnCD card Insertion Interrupt Request Mask
        constexpr uint32_t SDCDRMM = (1U << 3);  ///< SDnCD card Removal Interrupt Request Mask
        constexpr uint32_t ACENDM = (1U << 2);  ///< Access End Interrupt Request Mask
        constexpr uint32_t RSPENDM = (1U << 0);  ///< Response End Interrupt Request Mask
    }

    /// SD_INFO2_MASK Register bits
    namespace sd_info2_mask_bits {
        constexpr uint32_t ILAM = (1U << 15);  ///< Illegal Access Error Interrupt Request Mask
        constexpr uint32_t BWEM = (1U << 9);  ///< BWE Interrupt Request Mask
        constexpr uint32_t BREM = (1U << 8);  ///< BRE Interrupt Request Mask
        constexpr uint32_t RSPTOM = (1U << 6);  ///< Response Timeout Interrupt Request Mask
        constexpr uint32_t ILRM = (1U << 5);  ///< SD_BUF Register Illegal Read Interrupt Request Mask
        constexpr uint32_t ILWM = (1U << 4);  ///< SD_BUF Register Illegal Write Interrupt Request Mask
        constexpr uint32_t DTOM = (1U << 3);  ///< Data Timeout Interrupt Request Mask
        constexpr uint32_t ENDEM = (1U << 2);  ///< End Bit Error Interrupt Request Mask
        constexpr uint32_t CRCEM = (1U << 1);  ///< CRC Error Interrupt Request Mask
        constexpr uint32_t CMDEM = (1U << 0);  ///< Command Error Interrupt Request Mask
    }

    /// SD_CLK_CTRL Register bits
    namespace sd_clk_ctrl_bits {
        constexpr uint32_t CLKCTRLEN = (1U << 9);  ///< SD/MMC Clock Output Automatic Control Enable
        constexpr uint32_t CLKEN = (1U << 8);  ///< SD/MMC Clock Output Control Enable
        constexpr uint32_t CLKSEL = (8 << 0);  ///< SDHI Clock Frequency Select
    }

    /// SD_SIZE Register bits
    namespace sd_size_bits {
        constexpr uint32_t LEN = (10 << 0);  ///< Transfer Data SizeThese bits specify a size between 1 and 512 bytes for the transfer of single blocks.In cases of multiple block transfer with automatic issuing of CMD12 (CMD18 and CMD25), the only specifiable transfer data size is 512 bytes. Furthermore, in cases of multiple block transfer without automatic issuing of CMD12, as well as 512 bytes, 32, 64, 128, and 256 bytes are specifiable. However, in the reading of 32, 64, 128, and 256 bytes for the transfer of multiple blocks, this is restricted to multiple block transfer by CMD53.Additionally, if a command accompanies data transfer, do not set these bits to 0.
    }

    /// SD_OPTION Register bits
    namespace sd_option_bits {
        constexpr uint32_t WIDTH = (1U << 15);  ///< Bus WidthNOTE: The initial value is applied at a reset and when the SOFT_RST.SDRST flag is 0.
        constexpr uint32_t WIDTH8 = (1U << 13);  ///< Bus Widthsee b15, WIDTH bit
        constexpr uint32_t TOUTMASK = (1U << 8);  ///< Timeout MASKWhen timeout occurs in case of inactivating timeout, software reset should be executed to terminate command sequence.
        constexpr uint32_t TOP = (4 << 4);  ///< Timeout Counter
        constexpr uint32_t CTOP = (4 << 0);  ///< Card Detect Time Counter
    }

    /// SD_ERR_STS1 Register bits
    namespace sd_err_sts1_bits {
        constexpr uint32_t CRCTK = (3 << 12);  ///< CRC Status TokenStore the CRC status token value (normal value is 010b)
        constexpr uint32_t CRCTKE = (1U << 11);  ///< CRC Status Token Error
        constexpr uint32_t RDCRCE = (1U << 10);  ///< Read Data CRC Error
        constexpr uint32_t RSPCRCE1 = (1U << 9);  ///< Response CRC Error 1NOTE: In cases where CMD12 is issued by setting a command index in SD_CMD, this is indicated in RSPCRCE0.
        constexpr uint32_t RSPCRCE0 = (1U << 8);  ///< Response CRC Error 0NOTE: other than a response to a command issued within a command sequence
        constexpr uint32_t CRCLENE = (1U << 5);  ///< CRC Status Token Length Error
        constexpr uint32_t RDLENE = (1U << 4);  ///< Read Data Length Error
        constexpr uint32_t RSPLENE1 = (1U << 3);  ///< Response Length Error 1NOTE: In cases where CMD12 is issued by setting a command index in SD_CMD, this is indicated in RSPLENE0.
        constexpr uint32_t RSPLENE0 = (1U << 2);  ///< Response Length Error 0NOTE: other than a response to a command issued within a command sequence
        constexpr uint32_t CMDE1 = (1U << 1);  ///< Command Error 1NOTE: In cases where CMD12 is issued by setting a command index in SD_CMD, this is Indicated in CMDE0.
        constexpr uint32_t CMDE0 = (1U << 0);  ///< Command Error 0NOTE: other than a response to a command issued within a command sequence
    }

    /// SD_ERR_STS2 Register bits
    namespace sd_err_sts2_bits {
        constexpr uint32_t CRCBSYTO = (1U << 6);  ///< CRC Status Token Busy Timeout
        constexpr uint32_t CRCTO = (1U << 5);  ///< CRC Status Token Timeout
        constexpr uint32_t RDTO = (1U << 4);  ///< Read Data Timeout
        constexpr uint32_t BSYTO1 = (1U << 3);  ///< Busy Timeout 1
        constexpr uint32_t BSYTO0 = (1U << 2);  ///< Busy Timeout 0
        constexpr uint32_t RSPTO1 = (1U << 1);  ///< Response Timeout 1
        constexpr uint32_t RSPTO0 = (1U << 0);  ///< Response Timeout 0
    }

    /// SD_BUF0 Register bits
    namespace sd_buf0_bits {
        constexpr uint32_t SD_BUF = (32 << 0);  ///< SD Buffer RegisterWhen writing to the SD card, the write data is written to this register. When reading from the SD card, the read data is read from this register. This register is internally connected to two 512-byte buffers.If both buffers are not empty when executing multiple block read, SD/MMC clock is stopped to suspend receiving data. When one of buffers is empty, SD/MMC clock is supplied to resume receiving data.
    }

    /// SDIO_MODE Register bits
    namespace sdio_mode_bits {
        constexpr uint32_t C52PUB = (1U << 9);  ///< SDIO None AbortNOTE: See manual
        constexpr uint32_t IOABT = (1U << 8);  ///< SDIO AbortNOTE: See manual
        constexpr uint32_t RWREQ = (1U << 2);  ///< Read Wait Request
        constexpr uint32_t INTEN = (1U << 0);  ///< SDIO Mode
    }

    /// SDIO_INFO1 Register bits
    namespace sdio_info1_bits {
        constexpr uint32_t EXWT = (1U << 15);  ///< EXWT Status FlagNOTE: See manual
        constexpr uint32_t EXPUB52 = (1U << 14);  ///< EXPUB52 Status FlagNOTE: See manual
        constexpr uint32_t IOIRQ = (1U << 0);  ///< SDIO Interrupt Status
    }

    /// SDIO_INFO1_MASK Register bits
    namespace sdio_info1_mask_bits {
        constexpr uint32_t EXWTM = (1U << 15);  ///< EXWT Interrupt Request Mask Control
        constexpr uint32_t EXPUB52M = (1U << 14);  ///< EXPUB52 Interrupt Request Mask Control
        constexpr uint32_t IOIRQM = (1U << 0);  ///< IOIRQ Interrupt Mask Control
    }

    /// SD_DMAEN Register bits
    namespace sd_dmaen_bits {
        constexpr uint32_t DMAEN = (1U << 1);  ///< SD_BUF Read/Write DMA Transfer
    }

    /// SOFT_RST Register bits
    namespace soft_rst_bits {
        constexpr uint32_t SDRST = (1U << 0);  ///< Software Reset of SD I/F Unit
    }

    /// SDIF_MODE Register bits
    namespace sdif_mode_bits {
        constexpr uint32_t NOCHKCR = (1U << 8);  ///< CRC Check Mask (for MMC test commands)
    }

    /// EXT_SWAP Register bits
    namespace ext_swap_bits {
        constexpr uint32_t BRSWP = (1U << 7);  ///< SD_BUF0 Swap Read
        constexpr uint32_t BWSWP = (1U << 6);  ///< SD_BUF0 Swap Write
    }

}

// ============================================================================
// SDHI1 Peripheral
// ============================================================================

namespace sdhi1 {
    /// Base addresses
    constexpr uint32_t SDHI1_BASE = 0x40062400;

    /// SDHI1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SDHI1 = reinterpret_cast<Registers*>(SDHI1_BASE);

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40074000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRCCR0;  ///< Offset: 0x00 - CRC Control Register0
        volatile uint32_t CRCCR1;  ///< Offset: 0x01 - CRC Control Register1
        volatile uint32_t CRCDIR;  ///< Offset: 0x04 - CRC Data Input Register
        volatile uint32_t CRCDIR_BY;  ///< Offset: 0x04 - CRC Data Input Register (byte access)
        volatile uint32_t CRCDOR;  ///< Offset: 0x08 - CRC Data Output Register
        volatile uint32_t CRCDOR_HA;  ///< Offset: 0x08 - CRC Data Output Register (halfword access)
        volatile uint32_t CRCDOR_BY;  ///< Offset: 0x08 - CRC Data Output Register(byte access)
        volatile uint32_t CRCSAR;  ///< Offset: 0x0C - Snoop Address Register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRCCR0 Register bits
    namespace crccr0_bits {
        constexpr uint32_t DORCLR = (1U << 7);  ///< CRCDOR Register Clear
        constexpr uint32_t LMS = (1U << 6);  ///< CRC Calculation Switching
        constexpr uint32_t GPS = (3 << 0);  ///< CRC Generating Polynomial Switching
    }

    /// CRCCR1 Register bits
    namespace crccr1_bits {
        constexpr uint32_t CRCSEN = (1U << 7);  ///< Snoop enable bit
        constexpr uint32_t CRCSWR = (1U << 6);  ///< Snoop-on-write/read switch bit
    }

    /// CRCDIR Register bits
    namespace crcdir_bits {
        constexpr uint32_t CRCDIR = (32 << 0);  ///< Calculation input Data (Case of CRC-32, CRC-32C )
    }

    /// CRCDIR_BY Register bits
    namespace crcdir_by_bits {
        constexpr uint32_t CRCDIR_BY = (8 << 0);  ///< Calculation input Data ( Case of CRC-8, CRC-16 or CRC-CCITT )
    }

    /// CRCDOR Register bits
    namespace crcdor_bits {
        constexpr uint32_t CRCDOR = (32 << 0);  ///< Calculation output Data (Case of CRC-32, CRC-32C )
    }

    /// CRCDOR_HA Register bits
    namespace crcdor_ha_bits {
        constexpr uint32_t CRCDOR_HA = (16 << 0);  ///< Calculation output Data (Case of CRC-16 or CRC-CCITT )
    }

    /// CRCDOR_BY Register bits
    namespace crcdor_by_bits {
        constexpr uint32_t CRCDOR_BY = (8 << 0);  ///< Calculation output Data (Case of CRC-8 )
    }

    /// CRCSAR Register bits
    namespace crcsar_bits {
        constexpr uint32_t CRCSA = (14 << 0);  ///< snoop address bitSet the I/O register address to snoop
    }

}

// ============================================================================
// CTSU Peripheral
// ============================================================================

namespace ctsu {
    /// Base addresses
    constexpr uint32_t CTSU_BASE = 0x40081000;

    /// CTSU Register structure
    struct Registers {
        volatile uint32_t CTSUCR0;  ///< Offset: 0x00 - CTSU Control Register 0
        volatile uint32_t CTSUCR1;  ///< Offset: 0x01 - CTSU Control Register 1
        volatile uint32_t CTSUSDPRS;  ///< Offset: 0x02 - CTSU Synchronous Noise Reduction Setting Register
        volatile uint32_t CTSUSST;  ///< Offset: 0x03 - CTSU Sensor Stabilization Wait Control Register
        volatile uint32_t CTSUMCH0;  ///< Offset: 0x04 - CTSU Measurement Channel Register 0
        volatile uint32_t CTSUMCH1;  ///< Offset: 0x05 - CTSU Measurement Channel Register 1
        volatile uint32_t CTSUCHAC0;  ///< Offset: 0x06 - CTSU Channel Enable Control Register 0
        volatile uint32_t CTSUCHAC1;  ///< Offset: 0x07 - CTSU Channel Enable Control Register 1
        volatile uint32_t CTSUCHAC2;  ///< Offset: 0x08 - CTSU Channel Enable Control Register 2
        volatile uint32_t CTSUCHTRC0;  ///< Offset: 0x0B - CTSU Channel Transmit/Receive Control Register 0
        volatile uint32_t CTSUCHTRC1;  ///< Offset: 0x0C - CTSU Channel Transmit/Receive Control Register 1
        volatile uint32_t CTSUCHTRC2;  ///< Offset: 0x0D - CTSU Channel Transmit/Receive Control Register 2
        volatile uint32_t CTSUDCLKC;  ///< Offset: 0x10 - CTSU High-Pass Noise Reduction Control Register
        volatile uint32_t CTSUST;  ///< Offset: 0x11 - CTSU Status Register
        volatile uint32_t CTSUSSC;  ///< Offset: 0x12 - CTSU High-Pass Noise Reduction Spectrum Diffusion...
        volatile uint32_t CTSUSO0;  ///< Offset: 0x14 - CTSU Sensor Offset Register 0
        volatile uint32_t CTSUSO1;  ///< Offset: 0x16 - CTSU Sensor Offset Register 1
        volatile uint32_t CTSUSC;  ///< Offset: 0x18 - CTSU Sensor Counter
        volatile uint32_t CTSURC;  ///< Offset: 0x1A - CTSU Reference Counter
        volatile uint32_t CTSUERRS;  ///< Offset: 0x1C - CTSU Error Status Register
    };

    /// Peripheral instances
    inline Registers* CTSU = reinterpret_cast<Registers*>(CTSU_BASE);

    // Bit definitions
    /// CTSUCR0 Register bits
    namespace ctsucr0_bits {
        constexpr uint32_t CTSUTXVSEL = (1U << 7);  ///< CTSU Transmission power supply selection
        constexpr uint32_t CTSUINIT = (1U << 4);  ///< CTSU Control Block Initialization
        constexpr uint32_t CTSUSNZ = (1U << 2);  ///< CTSU Wait State Power-Saving Enable
        constexpr uint32_t CTSUCAP = (1U << 1);  ///< CTSU Measurement Operation Start Trigger Select
        constexpr uint32_t CTSUSTRT = (1U << 0);  ///< CTSU Measurement Operation Start
    }

    /// CTSUCR1 Register bits
    namespace ctsucr1_bits {
        constexpr uint32_t CTSUMD = (2 << 6);  ///< CTSU Measurement Mode Select
        constexpr uint32_t CTSUCLK = (2 << 4);  ///< CTSU Operating Clock Select
        constexpr uint32_t CTSUATUNE1 = (1U << 3);  ///< CTSU Power Supply Capacity Adjustment
        constexpr uint32_t CTSUCSW = (1U << 1);  ///< CTSU LPF Capacitance Charging Control
        constexpr uint32_t CTSUPON = (1U << 0);  ///< CTSU Power Supply Enable
    }

    /// CTSUSDPRS Register bits
    namespace ctsusdprs_bits {
        constexpr uint32_t CTSUSOFF = (1U << 6);  ///< CTSU High-Pass Noise Reduction Function Off Setting
        constexpr uint32_t CTSUPRMODE = (2 << 4);  ///< CTSU Base Period and Pulse Count Setting
        constexpr uint32_t CTSUPRRATIO = (4 << 0);  ///< CTSU Measurement Time and Pulse Count AdjustmentRecommended setting: 3 (0011b)
    }

    /// CTSUSST Register bits
    namespace ctsusst_bits {
        constexpr uint32_t CTSUSST = (8 << 0);  ///< CTSU Sensor Stabilization Wait ControlNOTE: The value of these bits should be fixed to 00010000b.
    }

    /// CTSUMCH0 Register bits
    namespace ctsumch0_bits {
        constexpr uint32_t CTSUMCH0 = (5 << 0);  ///< CTSU Measurement Channel 0.Note1: Writing to these bits is only enabled in self-capacitance single scan mode (CTSUCR1.CTSUMD[1:0] bits = 00b).Note2: If the value of CTSUMCH0 was set to b'11111 in mode other than self-capacitor single scan mode, the measurement is stopped.
    }

    /// CTSUMCH1 Register bits
    namespace ctsumch1_bits {
        constexpr uint32_t CTSUMCH1 = (5 << 0);  ///< CTSU Measurement Channel 1 Note1: If the value of CTSUMCH1 was set to b'11111, the measurement is stopped.
    }

    /// CTSUCHAC0 Register bits
    namespace ctsuchac0_bits {
        constexpr uint32_t CTSUCHAC0 = (8 << 0);  ///< CTSU Channel Enable Control 0.0: Not measurement target1: Measurement targetNote: CTSUCHAC0[0] corresponds to TS00 and CTSUCHAC0[7] corresponds to TS07.
    }

    /// CTSUCHAC1 Register bits
    namespace ctsuchac1_bits {
        constexpr uint32_t CTSUCHAC1 = (8 << 0);  ///< CTSU Channel Enable Control 1.0: Not measurement target1: Measurement targetNote: CTSUCHAC1[0] corresponds to TS08 and CTSUCHAC1[7] corresponds to TS15.
    }

    /// CTSUCHTRC0 Register bits
    namespace ctsuchtrc0_bits {
        constexpr uint32_t CTSUCHTRC0 = (8 << 0);  ///< CTSU Channel Transmit/Receive Control 0CTSUCHTRC0[0] corresponds to TS00 and CTSUCHTRC0[7] corresponds to TS07. ( 0: Reception / 1: Transmission )
    }

    /// CTSUCHTRC1 Register bits
    namespace ctsuchtrc1_bits {
        constexpr uint32_t CTSUCHTRC1 = (8 << 0);  ///< CTSU Channel Transmit/Receive Control 1CTSUCHTRC1[0] corresponds to TS08 and CTSUCHTRC1[7] corresponds to TS15. ( 0: Reception / 1: Transmission )
    }

    /// CTSUDCLKC Register bits
    namespace ctsudclkc_bits {
        constexpr uint32_t CTSUSSCNT = (2 << 4);  ///< CTSU Diffusion Clock Mode ControlNOTE: This bit should be set to 11b.
        constexpr uint32_t CTSUSSMOD = (2 << 0);  ///< CTSU Diffusion Clock Mode SelectNOTE: This bit should be set to 00b.
    }

    /// CTSUST Register bits
    namespace ctsust_bits {
        constexpr uint32_t CTSUPS = (1U << 7);  ///< CTSU Mutual Capacitance Status Flag
        constexpr uint32_t CTSUROVF = (1U << 6);  ///< CTSU Reference Counter Overflow Flag
        constexpr uint32_t CTSUSOVF = (1U << 5);  ///< CTSU Sensor Counter Overflow Flag
        constexpr uint32_t CTSUDTSR = (1U << 4);  ///< CTSU Data Transfer Status Flag
        constexpr uint32_t CTSUSTC = (3 << 0);  ///< CTSU Measurement Status Counter
    }

    /// CTSUSSC Register bits
    namespace ctsussc_bits {
        constexpr uint32_t CTSUSSDIV = (4 << 8);  ///< CTSU Spectrum Diffusion Frequency Division Setting
    }

    /// CTSUSO0 Register bits
    namespace ctsuso0_bits {
        constexpr uint32_t CTSUSNUM = (6 << 10);  ///< CTSU Measurement Count Setting
        constexpr uint32_t CTSUSO = (10 << 0);  ///< CTSU Sensor Offset AdjustmentCurrent offset amount is CTSUSO ( 0 to 1023 )
    }

    /// CTSUSO1 Register bits
    namespace ctsuso1_bits {
        constexpr uint32_t CTSUICOG = (2 << 13);  ///< CTSU ICO Gain Adjustment
        constexpr uint32_t CTSUSDPA = (5 << 8);  ///< CTSU Base Clock SettingOperating clock divided by ( CTSUSDPA + 1 ) x 2
        constexpr uint32_t CTSURICOA = (8 << 0);  ///< CTSU Reference ICO Current AdjustmentCurrent offset amount is CTSUSO ( 0 to 255 )
    }

    /// CTSUSC Register bits
    namespace ctsusc_bits {
        constexpr uint32_t CTSUSC = (16 << 0);  ///< CTSU Sensor CounterThese bits indicate the measurement result of the CTSU. These bits indicate FFFFh when an overflow occurs.
    }

    /// CTSURC Register bits
    namespace ctsurc_bits {
        constexpr uint32_t CTSURC = (16 << 0);  ///< CTSU Reference Counter
    }

    /// CTSUERRS Register bits
    namespace ctsuerrs_bits {
        constexpr uint32_t CTSUICOMP = (1U << 15);  ///< TSCAP Voltage Error Monitor
    }

}

// ============================================================================
// MMPU Peripheral
// ============================================================================

namespace mmpu {
    /// Base addresses
    constexpr uint32_t MMPU_BASE = 0x40000000;

    /// MMPU Register structure
    struct Registers {
        volatile uint32_t MMPUCTL%s;  ///< Offset: 0x00 - Bus Master MPU Control Register
        volatile uint32_t MMPUACA%s;  ///< Offset: 0x200 - Group A Region %s Access Control Register
        volatile uint32_t MMPUACB%s;  ///< Offset: 0x600 - Group B Region %s Access Control Register
        volatile uint32_t MMPUACC%s;  ///< Offset: 0xA00 - Group C Region %s Access Control Register
        volatile uint32_t MMPUSA%s;  ///< Offset: 0x204 - Group A Region %s Start Address Register
        volatile uint32_t MMPUSB%s;  ///< Offset: 0x604 - Group B Region %s Start Address Register
        volatile uint32_t MMPUSC%s;  ///< Offset: 0xA04 - Group C Region %s Start Address Register
        volatile uint32_t MMPUEA%s;  ///< Offset: 0x208 - Group A Region %s End Address Register
        volatile uint32_t MMPUEB%s;  ///< Offset: 0x608 - Group B Region %s End Address Register
        volatile uint32_t MMPUEC%s;  ///< Offset: 0xA08 - Group C Region %s End Address Register
        volatile uint32_t MMPUPTA;  ///< Offset: 0x102 - Group A Protection of Register
        volatile uint32_t MMPUPTB;  ///< Offset: 0x502 - Group B Protection of Register
        volatile uint32_t MMPUPTC;  ///< Offset: 0x902 - Group C protection of register
    };

    /// Peripheral instances
    inline Registers* MMPU = reinterpret_cast<Registers*>(MMPU_BASE);

    // Bit definitions
    /// MMPUCTL%s Register bits
    namespace mmpuctl%s_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t OAD = (1U << 1);  ///< Operation after detection
        constexpr uint32_t ENABLE = (1U << 0);  ///< Master Group enable
    }

    /// MMPUACA%s Register bits
    namespace mmpuaca%s_bits {
        constexpr uint32_t WP = (1U << 2);  ///< Write protection
        constexpr uint32_t RP = (1U << 1);  ///< Read protection
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable
    }

    /// MMPUACB%s Register bits
    namespace mmpuacb%s_bits {
        constexpr uint32_t WP = (1U << 2);  ///< Write protection
        constexpr uint32_t RP = (1U << 1);  ///< Read protection
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable
    }

    /// MMPUACC%s Register bits
    namespace mmpuacc%s_bits {
        constexpr uint32_t WP = (1U << 2);  ///< Write protection
        constexpr uint32_t RP = (1U << 1);  ///< Read protection
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable
    }

    /// MMPUSA%s Register bits
    namespace mmpusa%s_bits {
        constexpr uint32_t MMPUSA = (32 << 0);  ///< Address where the region starts, for use in region determination.NOTE: The low-order 2 bits are fixed to 0.
    }

    /// MMPUSB%s Register bits
    namespace mmpusb%s_bits {
        constexpr uint32_t MMPUSB = (32 << 0);  ///< Address where the region starts, for use in region determination.NOTE: The low-order 2 bits are fixed to 0.
    }

    /// MMPUSC%s Register bits
    namespace mmpusc%s_bits {
        constexpr uint32_t MMPUSC = (32 << 0);  ///< Address where the region starts, for use in region determination.NOTE: The low-order 2 bits are fixed to 0.
    }

    /// MMPUEA%s Register bits
    namespace mmpuea%s_bits {
        constexpr uint32_t MMPUEA = (32 << 0);  ///< Region end address registerAddress where the region end, for use in region determination.NOTE: The low-order 2 bits are fixed to 1.
    }

    /// MMPUEB%s Register bits
    namespace mmpueb%s_bits {
        constexpr uint32_t MMPUEB = (32 << 0);  ///< Region end address registerAddress where the region end, for use in region determination.NOTE: The low-order 2 bits are fixed to 1.
    }

    /// MMPUEC%s Register bits
    namespace mmpuec%s_bits {
        constexpr uint32_t MMPUEC = (32 << 0);  ///< Region end address registerAddress where the region end, for use in region determination.NOTE: The low-order 2 bits are fixed to 1.
    }

    /// MMPUPTA Register bits
    namespace mmpupta_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register(MMPUSAn, MMPUEAn and MMPUACAn)
    }

    /// MMPUPTB Register bits
    namespace mmpuptb_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register(MMPUSBn, MMPUEBn and MMPUACBn)
    }

    /// MMPUPTC Register bits
    namespace mmpuptc_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register (MMPUSCn, MMPUECn and MMPUACCn)
    }

}

// ============================================================================
// SMPU Peripheral
// ============================================================================

namespace smpu {
    /// Base addresses
    constexpr uint32_t SMPU_BASE = 0x40000C00;

    /// SMPU Register structure
    struct Registers {
        volatile uint32_t SMPUCTL;  ///< Offset: 0x00 - Slave MPU Control Register
        volatile uint32_t SMPUMBIU;  ///< Offset: 0x10 - Access Control Register for MBIU
        volatile uint32_t SMPUFBIU;  ///< Offset: 0x14 - Access Control Register for FBIU
        volatile uint32_t SMPUSRAM%s;  ///< Offset: 0x18 - Access Control Register for SRAM%s
        volatile uint32_t SMPUP%sBIU;  ///< Offset: 0x20 - Access Control Register for P%sBIU
        volatile uint32_t SMPUEXBIU;  ///< Offset: 0x30 - Access Control Register for EXBIU
        volatile uint32_t SMPUEXBIU2;  ///< Offset: 0x34 - Access Control Register for EXBIU2
    };

    /// Peripheral instances
    inline Registers* SMPU = reinterpret_cast<Registers*>(SMPU_BASE);

    // Bit definitions
    /// SMPUCTL Register bits
    namespace smpuctl_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code This bit is used to enable or disable rewriting of the PROTECT and OAD bit.
        constexpr uint32_t PROTECT = (1U << 1);  ///< Protection of register
        constexpr uint32_t OAD = (1U << 0);  ///< Master Group enable
    }

    /// SMPUMBIU Register bits
    namespace smpumbiu_bits {
        constexpr uint32_t WPSRAMHS = (1U << 15);  ///< SRAMHS Write Protection
        constexpr uint32_t RPSRAMHS = (1U << 14);  ///< SRAMHS Read Protection
        constexpr uint32_t WPFLI = (1U << 13);  ///< Code Flash Memory Write Protection (Note: This bit is read as 1. The write value should be 1.)
        constexpr uint32_t RPFLI = (1U << 12);  ///< Code Flash Memory Read Protection
        constexpr uint32_t WPGRPC = (1U << 7);  ///< Master Group C Write protection
        constexpr uint32_t RPGRPC = (1U << 6);  ///< Master Group C Read protection
        constexpr uint32_t WPGRPB = (1U << 5);  ///< Master Group B Write protection
        constexpr uint32_t RPGRPB = (1U << 4);  ///< Master Group B Read protection
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
    }

    /// SMPUFBIU Register bits
    namespace smpufbiu_bits {
        constexpr uint32_t WP_GRPC = (1U << 7);  ///< Master Group C Write protection
        constexpr uint32_t RP_GRPC = (1U << 6);  ///< Master Group C Read protection
        constexpr uint32_t WP_GRPB = (1U << 5);  ///< Master Group B Write protection
        constexpr uint32_t RP_GRPB = (1U << 4);  ///< Master Group B Read protection
        constexpr uint32_t WP_GRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RP_GRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WP_CPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RP_CPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUSRAM%s Register bits
    namespace smpusram%s_bits {
        constexpr uint32_t WP_GRPC = (1U << 7);  ///< Master Group C Write protection
        constexpr uint32_t RP_GRPC = (1U << 6);  ///< Master Group C Read protection
        constexpr uint32_t WP_GRPB = (1U << 5);  ///< Master Group B Write protection
        constexpr uint32_t RP_GRPB = (1U << 4);  ///< Master Group B Read protection
        constexpr uint32_t WP_GRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RP_GRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WP_CPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RP_CPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUP%sBIU Register bits
    namespace smpup%sbiu_bits {
        constexpr uint32_t WP_GRPC = (1U << 7);  ///< Master Group C Write protection
        constexpr uint32_t RP_GRPC = (1U << 6);  ///< Master Group C Read protection
        constexpr uint32_t WP_GRPB = (1U << 5);  ///< Master Group B Write protection
        constexpr uint32_t RP_GRPB = (1U << 4);  ///< Master Group B Read protection
        constexpr uint32_t WP_GRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RP_GRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WP_CPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RP_CPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUEXBIU Register bits
    namespace smpuexbiu_bits {
        constexpr uint32_t WP_GRPC = (1U << 7);  ///< Master Group C Write protection
        constexpr uint32_t RP_GRPC = (1U << 6);  ///< Master Group C Read protection
        constexpr uint32_t WP_GRPB = (1U << 5);  ///< Master Group B Write protection
        constexpr uint32_t RP_GRPB = (1U << 4);  ///< Master Group B Read protection
        constexpr uint32_t WP_GRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RP_GRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WP_CPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RP_CPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUEXBIU2 Register bits
    namespace smpuexbiu2_bits {
        constexpr uint32_t WP_GRPC = (1U << 7);  ///< Master Group C Write protection
        constexpr uint32_t RP_GRPC = (1U << 6);  ///< Master Group C Read protection
        constexpr uint32_t WP_GRPB = (1U << 5);  ///< Master Group B Write protection
        constexpr uint32_t RP_GRPB = (1U << 4);  ///< Master Group B Read protection
        constexpr uint32_t WP_GRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RP_GRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WP_CPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RP_CPU = (1U << 0);  ///< CPU Read protection
    }

}

// ============================================================================
// SPMON Peripheral
// ============================================================================

namespace spmon {
    /// Base addresses
    constexpr uint32_t SPMON_BASE = 0x40000D00;

    /// SPMON Register structure
    struct Registers {
        volatile uint32_t MSPMPUOAD;  ///< Offset: 0x00 - Stack Pointer Monitor Operation After Detection Register
        volatile uint32_t MSPMPUCTL;  ///< Offset: 0x04 - Stack Pointer Monitor Access Control Register
        volatile uint32_t MSPMPUPT;  ///< Offset: 0x06 - Stack Pointer Monitor Protection Register
        volatile uint32_t MSPMPUSA;  ///< Offset: 0x08 - Main Stack Pointer Monitor Start Address Register
        volatile uint32_t MSPMPUEA;  ///< Offset: 0x0C - Main Stack Pointer Monitor End Address Register
        volatile uint32_t PSPMPUOAD;  ///< Offset: 0x10 - Stack Pointer Monitor Operation After Detection Register
        volatile uint32_t PSPMPUCTL;  ///< Offset: 0x14 - Stack Pointer Monitor Access Control Register
        volatile uint32_t PSPMPUPT;  ///< Offset: 0x16 - Stack Pointer Monitor Protection Register
        volatile uint32_t PSPMPUSA;  ///< Offset: 0x18 - Process Stack Pointer Monitor Start Address Register
        volatile uint32_t PSPMPUEA;  ///< Offset: 0x1C - Process Stack Pointer Monitor End Address Register
    };

    /// Peripheral instances
    inline Registers* SPMON = reinterpret_cast<Registers*>(SPMON_BASE);

    // Bit definitions
    /// MSPMPUOAD Register bits
    namespace mspmpuoad_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after detection
    }

    /// MSPMPUCTL Register bits
    namespace mspmpuctl_bits {
        constexpr uint32_t ERROR = (1U << 8);  ///< SP_main monitor error flag
        constexpr uint32_t ENABLE = (1U << 0);  ///< SP_main monitor enable
    }

    /// MSPMPUPT Register bits
    namespace mspmpupt_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register (MSPMPUAC, MSPMPUSA and MSPMPUSE)
    }

    /// MSPMPUSA Register bits
    namespace mspmpusa_bits {
        constexpr uint32_t MSPMPUSA = (30 << 2);  ///< Region start address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00000-0x200FFFFC The low-order 2 bits are fixed to 0.
    }

    /// MSPMPUEA Register bits
    namespace mspmpuea_bits {
        constexpr uint32_t MSPMPUEA = (30 << 2);  ///< Region end address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00003-0x200FFFFF The low-order 2 bits are fixed to 1.
    }

    /// PSPMPUOAD Register bits
    namespace pspmpuoad_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after detection
    }

    /// PSPMPUCTL Register bits
    namespace pspmpuctl_bits {
        constexpr uint32_t ERROR = (1U << 8);  ///< SP_process monitor error flag
        constexpr uint32_t ENABLE = (1U << 0);  ///< SP_process monitor enable
    }

    /// PSPMPUPT Register bits
    namespace pspmpupt_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register (PSPMPUAC, PSPMPUSA and PSPMPUSE)
    }

    /// PSPMPUSA Register bits
    namespace pspmpusa_bits {
        constexpr uint32_t PSPMPUSA = (30 << 2);  ///< Region start address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00000-0x200FFFFC The low-order 2 bits are fixed to 0.
    }

    /// PSPMPUEA Register bits
    namespace pspmpuea_bits {
        constexpr uint32_t PSPMPUEA = (30 << 2);  ///< Region end address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00003-0x200FFFFF The low-order 2 bits are fixed to 1.
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC120_BASE = 0x4005C000;
    constexpr uint32_t ADC121_BASE = 0x4005C200;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADCSR;  ///< Offset: 0x00 - A/D Control Register
        volatile uint32_t ADANSA0;  ///< Offset: 0x04 - A/D Channel Select Register A0
        volatile uint32_t ADANSA1;  ///< Offset: 0x06 - A/D Channel Select Register A1
        volatile uint32_t ADADS0;  ///< Offset: 0x08 - A/D-Converted Value Addition/Average Channel Select Register 0
        volatile uint32_t ADADS1;  ///< Offset: 0x0A - A/D-Converted Value Addition/Average Channel Select Register 1
        volatile uint32_t ADADC;  ///< Offset: 0x0C - A/D-Converted Value Addition/Average Count Select Register
        volatile uint32_t ADCER;  ///< Offset: 0x0E - A/D Control Extended Register
        volatile uint32_t ADSTRGR;  ///< Offset: 0x10 - A/D Conversion Start Trigger Select Register
        volatile uint32_t ADEXICR;  ///< Offset: 0x12 - A/D Conversion Extended Input Control Register
        volatile uint32_t ADANSB0;  ///< Offset: 0x14 - A/D Channel Select Register B0
        volatile uint32_t ADANSB1;  ///< Offset: 0x16 - A/D Channel Select Register B1
        volatile uint32_t ADDBLDR;  ///< Offset: 0x18 - A/D Data Duplication Register
        volatile uint32_t ADTSDR;  ///< Offset: 0x1A - A/D Temperature Sensor Data Register
        volatile uint32_t ADOCDR;  ///< Offset: 0x1C - A/D Internal Reference Voltage Data Register
        volatile uint32_t ADRD;  ///< Offset: 0x1E - A/D Self-Diagnosis Data Register
        volatile uint32_t ADDR%s;  ///< Offset: 0x40 - A/D Data Register %s
        volatile uint32_t ADSHCR;  ///< Offset: 0x66 - A/D Sample and Hold Circuit Control Register
        volatile uint32_t ADDISCR;  ///< Offset: 0x7A - A/D Disconnection Detection Control Register
        volatile uint32_t ADSHMSR;  ///< Offset: 0x7C - A/D Sample and Hold Operation Mode Select Register
        volatile uint32_t ADGSPCR;  ///< Offset: 0x80 - A/D Group Scan Priority Control Register
        volatile uint32_t ADDBLDRA;  ///< Offset: 0x84 - A/D Data Duplication Register A
        volatile uint32_t ADDBLDRB;  ///< Offset: 0x86 - A/D Data Duplication Register B
        volatile uint32_t ADWINMON;  ///< Offset: 0x8C - A/D Compare Function Window A/B Status Monitor Register
        volatile uint32_t ADCMPCR;  ///< Offset: 0x90 - A/D Compare Function Control Register
        volatile uint32_t ADCMPANSER;  ///< Offset: 0x92 - A/D Compare Function Window A Extended Input Select Register
        volatile uint32_t ADCMPLER;  ///< Offset: 0x93 - A/D Compare Function Window A Extended Input Comparison...
        volatile uint32_t ADCMPANSR0;  ///< Offset: 0x94 - A/D Compare Function Window A Channel Select Register 0
        volatile uint32_t ADCMPANSR1;  ///< Offset: 0x96 - A/D Compare Function Window A Channel Select Register 1
        volatile uint32_t ADCMPLR0;  ///< Offset: 0x98 - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPLR1;  ///< Offset: 0x9A - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPDR0;  ///< Offset: 0x9C - A/D Compare Function Window A Lower-Side Level Setting Register
        volatile uint32_t ADCMPDR1;  ///< Offset: 0x9E - A/D Compare Function Window A Upper-Side Level Setting Register
        volatile uint32_t ADCMPSR0;  ///< Offset: 0xA0 - A/D Compare Function Window A Channel Status Register 0
        volatile uint32_t ADCMPSR1;  ///< Offset: 0xA2 - A/D Compare Function Window A Channel Status Register 1
        volatile uint32_t ADCMPSER;  ///< Offset: 0xA4 - A/D Compare Function Window A Extended Input Channel...
        volatile uint32_t ADCMPBNSR;  ///< Offset: 0xA6 - A/D Compare Function Window B Channel Selection Register
        volatile uint32_t ADWINLLB;  ///< Offset: 0xA8 - A/D Compare Function Window B Lower-Side Level Setting Register
        volatile uint32_t ADWINULB;  ///< Offset: 0xAA - A/D Compare Function Window B Upper-Side Level Setting Register
        volatile uint32_t ADCMPBSR;  ///< Offset: 0xAC - A/D Compare Function Window B Status Register
        volatile uint32_t ADSSTRL;  ///< Offset: 0xDD - A/D Sampling State Register L
        volatile uint32_t ADSSTRT;  ///< Offset: 0xDE - A/D Sampling State Register T
        volatile uint32_t ADSSTRO;  ///< Offset: 0xDF - A/D Sampling State Register O
        volatile uint32_t ADSSTR0%s;  ///< Offset: 0xE0 - A/D Sampling State Register %s (Corresponding Channel is AN00%s )
        volatile uint32_t ADPGACR;  ///< Offset: 0x1A0 - A/D Programmable Gain Amplifier Control Register
        volatile uint32_t ADPGAGS0;  ///< Offset: 0x1A2 - A/D Programmable Gain Amplifier Gain Setting Register 0
        volatile uint32_t ADPGADCR0;  ///< Offset: 0x1B0 - A/D Programmable Gain Amplifier Differential Input...
    };

    /// Peripheral instances
    inline Registers* ADC120 = reinterpret_cast<Registers*>(ADC120_BASE);
    inline Registers* ADC121 = reinterpret_cast<Registers*>(ADC121_BASE);

    // Bit definitions
    /// ADCSR Register bits
    namespace adcsr_bits {
        constexpr uint32_t ADST = (1U << 15);  ///< A/D Conversion Start
        constexpr uint32_t ADCS = (2 << 13);  ///< Scan Mode Select
        constexpr uint32_t TRGE = (1U << 9);  ///< Trigger Start Enable
        constexpr uint32_t EXTRG = (1U << 8);  ///< Trigger Select
        constexpr uint32_t DBLE = (1U << 7);  ///< Double Trigger Mode Select
        constexpr uint32_t GBADIE = (1U << 6);  ///< Group B Scan End Interrupt Enable
        constexpr uint32_t DBLANS = (5 << 0);  ///< Double Trigger Channel SelectThese bits select one analog input channel for double triggered operation. The setting is only effective while double trigger mode is selected.
    }

    /// ADANSA0 Register bits
    namespace adansa0_bits {
        constexpr uint32_t ANSA07 = (1U << 7);  ///< AN007 Select
        constexpr uint32_t ANSA06 = (1U << 6);  ///< AN006 Select
        constexpr uint32_t ANSA05 = (1U << 5);  ///< AN005 Select
        constexpr uint32_t ANSA04 = (1U << 4);  ///< AN004 Select
        constexpr uint32_t ANSA03 = (1U << 3);  ///< AN003 Select
        constexpr uint32_t ANSA02 = (1U << 2);  ///< AN002 Select
        constexpr uint32_t ANSA01 = (1U << 1);  ///< AN001 Select
        constexpr uint32_t ANSA00 = (1U << 0);  ///< AN000 Select
    }

    /// ADANSA1 Register bits
    namespace adansa1_bits {
        constexpr uint32_t ANSA20 = (1U << 4);  ///< AN020 Select
        constexpr uint32_t ANSA19 = (1U << 3);  ///< AN019 Select
        constexpr uint32_t ANSA18 = (1U << 2);  ///< AN018 Select
        constexpr uint32_t ANSA17 = (1U << 1);  ///< AN017 Select
        constexpr uint32_t ANSA16 = (1U << 0);  ///< AN016 Select
    }

    /// ADADS0 Register bits
    namespace adads0_bits {
        constexpr uint32_t ADS07 = (1U << 7);  ///< A/D-Converted Value Addition/Average Channel AN007 Select
        constexpr uint32_t ADS06 = (1U << 6);  ///< A/D-Converted Value Addition/Average Channel AN006 Select
        constexpr uint32_t ADS05 = (1U << 5);  ///< A/D-Converted Value Addition/Average Channel AN005 Select
        constexpr uint32_t ADS04 = (1U << 4);  ///< A/D-Converted Value Addition/Average Channel AN004 Select
        constexpr uint32_t ADS03 = (1U << 3);  ///< A/D-Converted Value Addition/Average Channel AN003 Select
        constexpr uint32_t ADS02 = (1U << 2);  ///< A/D-Converted Value Addition/Average Channel AN002 Select
        constexpr uint32_t ADS01 = (1U << 1);  ///< A/D-Converted Value Addition/Average Channel AN001 Select
        constexpr uint32_t ADS00 = (1U << 0);  ///< A/D-Converted Value Addition/Average Channel AN000 Select
    }

    /// ADADS1 Register bits
    namespace adads1_bits {
        constexpr uint32_t ADS20 = (1U << 4);  ///< A/D-Converted Value Addition/Average Channel AN020 Select
        constexpr uint32_t ADS19 = (1U << 3);  ///< A/D-Converted Value Addition/Average Channel AN019 Select
        constexpr uint32_t ADS18 = (1U << 2);  ///< A/D-Converted Value Addition/Average Channel AN018 Select
        constexpr uint32_t ADS17 = (1U << 1);  ///< A/D-Converted Value Addition/Average Channel AN017 Select
        constexpr uint32_t ADS16 = (1U << 0);  ///< A/D-Converted Value Addition/Average Channel AN016 Select
    }

    /// ADADC Register bits
    namespace adadc_bits {
        constexpr uint32_t AVEE = (1U << 7);  ///< Average mode enable bit.Note: The AVEE bit converts twice, and only when converting it four times, is effective. Please do not set (ADADC.AVEE=1) to conversion (ADADC.ADC 2:0=010b) three times when you select the average mode.
        constexpr uint32_t ADC = (3 << 0);  ///< Addition frequency selection bit.NOTE: AVEE bit is valid at the only setting of ADC[2:0] bits = 001b or 011b. When average mode is selected by setting the ADADC.AVEE bit to 1, do not set the addition count to three times (ADADC.ADC[2:0] = 010b)
    }

    /// ADCER Register bits
    namespace adcer_bits {
        constexpr uint32_t ADRFMT = (1U << 15);  ///< A/D Data Register Format Select
        constexpr uint32_t DIAGM = (1U << 11);  ///< Self-Diagnosis Enable
        constexpr uint32_t DIAGLD = (1U << 10);  ///< Self-Diagnosis Mode Select
        constexpr uint32_t DIAGVAL = (2 << 8);  ///< Self-Diagnosis Conversion Voltage Select
        constexpr uint32_t ACE = (1U << 5);  ///< A/D Data Register Automatic Clearing Enable
        constexpr uint32_t ADPRC = (2 << 1);  ///< A/D Conversion Accuracy Specify
    }

    /// ADSTRGR Register bits
    namespace adstrgr_bits {
        constexpr uint32_t TRSA = (6 << 8);  ///< A/D Conversion Start Trigger SelectSelect the A/D conversion start trigger in single scan mode and continuous mode. In group scan mode, the A/D conversion start trigger for group A is selected.
        constexpr uint32_t TRSB = (6 << 0);  ///< A/D Conversion Start Trigger Select for Group BSelect the A/D conversion start trigger for group B in group scan mode.
    }

    /// ADEXICR Register bits
    namespace adexicr_bits {
        constexpr uint32_t OCSB = (1U << 11);  ///< Internal Reference Voltage A/D Conversion Select for Group B
        constexpr uint32_t TSSB = (1U << 10);  ///< Temperature Sensor Output A/D Conversion Select for Group B
        constexpr uint32_t OCSA = (1U << 9);  ///< Internal Reference Voltage A/D Conversion Select
        constexpr uint32_t TSSA = (1U << 8);  ///< Temperature Sensor Output A/D Conversion Select
        constexpr uint32_t OCSAD = (1U << 1);  ///< Internal Reference Voltage A/D converted Value Addition/Average Mode Select
        constexpr uint32_t TSSAD = (1U << 0);  ///< Temperature Sensor Output A/D converted Value Addition/Average Mode Select
    }

    /// ADANSB0 Register bits
    namespace adansb0_bits {
        constexpr uint32_t ANSB07 = (1U << 7);  ///< AN007 Select
        constexpr uint32_t ANSB06 = (1U << 6);  ///< AN006 Select
        constexpr uint32_t ANSB05 = (1U << 5);  ///< AN005 Select
        constexpr uint32_t ANSB04 = (1U << 4);  ///< AN004 Select
        constexpr uint32_t ANSB03 = (1U << 3);  ///< AN003 Select
        constexpr uint32_t ANSB02 = (1U << 2);  ///< AN002 Select
        constexpr uint32_t ANSB01 = (1U << 1);  ///< AN001 Select
        constexpr uint32_t ANSB00 = (1U << 0);  ///< AN000 Select
    }

    /// ADANSB1 Register bits
    namespace adansb1_bits {
        constexpr uint32_t ANSB20 = (1U << 4);  ///< AN020 Select
        constexpr uint32_t ANSB19 = (1U << 3);  ///< AN019 Select
        constexpr uint32_t ANSB18 = (1U << 2);  ///< AN018 Select
        constexpr uint32_t ANSB17 = (1U << 1);  ///< AN017 Select
        constexpr uint32_t ANSB16 = (1U << 0);  ///< AN016 Select
    }

    /// ADDBLDR Register bits
    namespace addbldr_bits {
        constexpr uint32_t ADDBLDR = (16 << 0);  ///< This is a 16-bit read-only register for storing the result of A/D conversion in response to the second trigger in double trigger mode.
    }

    /// ADTSDR Register bits
    namespace adtsdr_bits {
        constexpr uint32_t ADTSDR = (16 << 0);  ///< This is a 16-bit read-only register for storing the A/D conversion result of temperature sensor output.
    }

    /// ADOCDR Register bits
    namespace adocdr_bits {
        constexpr uint32_t ADOCDR = (16 << 0);  ///< This is a 16-bit read-only register for storing the A/D result of internal reference voltage.
    }

    /// ADRD Register bits
    namespace adrd_bits {
        constexpr uint32_t DIAGST = (2 << 14);  ///< Self-Diagnosis Status
        constexpr uint32_t AD = (12 << 0);  ///< A/D-converted value (right-justified)NOTE: Unused bits in the AD bit field are fixed "0"
    }

    /// ADDR%s Register bits
    namespace addr%s_bits {
        constexpr uint32_t ADDR = (16 << 0);  ///< The ADDR register is a 16-bit read-only registers for storing the result of A/D conversion.
    }

    /// ADSHCR Register bits
    namespace adshcr_bits {
        constexpr uint32_t SHANS2 = (1U << 10);  ///< AN002 sample-and-hold circuit Select
        constexpr uint32_t SHANS1 = (1U << 9);  ///< AN001 sample-and-hold circuit Select
        constexpr uint32_t SHANS0 = (1U << 8);  ///< AN000 sample-and-hold circuit Select
        constexpr uint32_t SSTSH = (8 << 0);  ///< Channel-Dedicated Sample-and-Hold Circuit Sampling Time Setting Set the sampling time (4 to 255 states)
    }

    /// ADDISCR Register bits
    namespace addiscr_bits {
        constexpr uint32_t CHARGE = (1U << 4);  ///< Selection of Precharge or Discharge
        constexpr uint32_t ADNDIS = (4 << 0);  ///< The charging time
    }

    /// ADSHMSR Register bits
    namespace adshmsr_bits {
        constexpr uint32_t SHMD = (1U << 0);  ///< Channel-Dedicated Sample-and-Hold Circuit Operation Mode Select
    }

    /// ADGSPCR Register bits
    namespace adgspcr_bits {
        constexpr uint32_t GBRP = (1U << 15);  ///< Group B Single Scan Continuous Start(Enabled only when PGS = 1. Reserved when PGS = 0.)Note: When the GBRP bit has been set to 1, single scan is performed continuously for group B regardless of the setting of the GBRSCN bit.
        constexpr uint32_t GBRSCN = (1U << 1);  ///< Group B Restart Setting(Enabled only when PGS = 1. Reserved when PGS = 0.)
        constexpr uint32_t PGS = (1U << 0);  ///< Group A priority control setting bit.Note: When the PGS bit is to be set to 1, the ADCSR.ADCS[1:0] bits must be set to 01b (group scan mode). If the bits are set to any other values, proper operation is not guaranteed.
    }

    /// ADDBLDRA Register bits
    namespace addbldra_bits {
        constexpr uint32_t ADDBLDRA = (16 << 0);  ///< This register is a 16-bit read-only registers for storing the result of A/D conversion in response to the respective triggers during extended operation in double trigger mode.
    }

    /// ADDBLDRB Register bits
    namespace addbldrb_bits {
        constexpr uint32_t ADDBLDRB = (16 << 0);  ///< This register is a 16-bit read-only registers for storing the result of A/D conversion in response to the respective triggers during extended operation in double trigger mode.
    }

    /// ADWINMON Register bits
    namespace adwinmon_bits {
        constexpr uint32_t MONCMPB = (1U << 5);  ///< Comparison Result Monitor B
        constexpr uint32_t MONCMPA = (1U << 4);  ///< Comparison Result Monitor A
        constexpr uint32_t MONCOMB = (1U << 0);  ///< Combination result monitorThis bit indicates the combination result.This bit is valid when both window A operation and window B operation are enabled.
    }

    /// ADCMPCR Register bits
    namespace adcmpcr_bits {
        constexpr uint32_t CMPAIE = (1U << 15);  ///< Compare A Interrupt Enable
        constexpr uint32_t WCMPE = (1U << 14);  ///< Window Function Setting
        constexpr uint32_t CMPBIE = (1U << 13);  ///< Compare B Interrupt Enable
        constexpr uint32_t CMPAE = (1U << 11);  ///< Compare Window A Operation Enable
        constexpr uint32_t CMPBE = (1U << 9);  ///< Compare Window B Operation Enable
        constexpr uint32_t CMPAB = (2 << 0);  ///< Window A/B Composite Conditions SettingNOTE: These bits are valid when both window A and window B are enabled (CMPAE = 1 and CMPBE = 1).
    }

    /// ADCMPANSER Register bits
    namespace adcmpanser_bits {
        constexpr uint32_t CMPOCA = (1U << 1);  ///< Internal reference voltage Compare selection bit.
        constexpr uint32_t CMPTSA = (1U << 0);  ///< Temperature sensor output Compare selection bit.
    }

    /// ADCMPLER Register bits
    namespace adcmpler_bits {
        constexpr uint32_t CMPLOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage ComparisonCondition Select
        constexpr uint32_t CMPLTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Comparison Condition Select
    }

    /// ADCMPANSR0 Register bits
    namespace adcmpansr0_bits {
        constexpr uint32_t CMPCHA07 = (1U << 7);  ///< Compare Window A Channel AN007 Select
        constexpr uint32_t CMPCHA06 = (1U << 6);  ///< Compare Window A Channel AN006 Select
        constexpr uint32_t CMPCHA05 = (1U << 5);  ///< Compare Window A Channel AN005 Select
        constexpr uint32_t CMPCHA04 = (1U << 4);  ///< Compare Window A Channel AN004 Select
        constexpr uint32_t CMPCHA03 = (1U << 3);  ///< Compare Window A Channel AN003 Select
        constexpr uint32_t CMPCHA02 = (1U << 2);  ///< Compare Window A Channel AN002 Select
        constexpr uint32_t CMPCHA01 = (1U << 1);  ///< Compare Window A Channel AN001 Select
        constexpr uint32_t CMPCHA00 = (1U << 0);  ///< Compare Window A Channel AN000 Select
    }

    /// ADCMPANSR1 Register bits
    namespace adcmpansr1_bits {
        constexpr uint32_t CMPCHA20 = (1U << 4);  ///< AN020 Select
        constexpr uint32_t CMPCHA19 = (1U << 3);  ///< AN019 Select
        constexpr uint32_t CMPCHA18 = (1U << 2);  ///< AN018 Select
        constexpr uint32_t CMPCHA17 = (1U << 1);  ///< AN017 Select
        constexpr uint32_t CMPCHA16 = (1U << 0);  ///< AN016 Select
    }

    /// ADCMPLR0 Register bits
    namespace adcmplr0_bits {
        constexpr uint32_t CMPLCHA07 = (1U << 7);  ///< Comparison condition of AN007
        constexpr uint32_t CMPLCHA06 = (1U << 6);  ///< Comparison condition of AN006
        constexpr uint32_t CMPLCHA05 = (1U << 5);  ///< Comparison condition of AN005
        constexpr uint32_t CMPLCHA04 = (1U << 4);  ///< Comparison condition of AN004
        constexpr uint32_t CMPLCHA03 = (1U << 3);  ///< Comparison condition of AN003
        constexpr uint32_t CMPLCHA02 = (1U << 2);  ///< Comparison condition of AN002
        constexpr uint32_t CMPLCHA01 = (1U << 1);  ///< Comparison condition of AN001
        constexpr uint32_t CMPLCHA00 = (1U << 0);  ///< Comparison condition of AN000
    }

    /// ADCMPLR1 Register bits
    namespace adcmplr1_bits {
        constexpr uint32_t CMPLCHA20 = (1U << 4);  ///< Comparison condition of AN020
        constexpr uint32_t CMPLCHA19 = (1U << 3);  ///< Comparison condition of AN019
        constexpr uint32_t CMPLCHA18 = (1U << 2);  ///< Comparison condition of AN018
        constexpr uint32_t CMPLCHA17 = (1U << 1);  ///< Comparison condition of AN017
        constexpr uint32_t CMPLCHA16 = (1U << 0);  ///< Comparison condition of AN016
    }

    /// ADCMPDR0 Register bits
    namespace adcmpdr0_bits {
        constexpr uint32_t ADCMPDR0 = (16 << 0);  ///< The ADCMPDR0 register sets the reference data when the compare window A function is used. ADCMPDR0 sets the lower-side level of window A.
    }

    /// ADCMPDR1 Register bits
    namespace adcmpdr1_bits {
        constexpr uint32_t ADCMPDR1 = (16 << 0);  ///< The ADCMPDR1 register sets the reference data when the compare window A function is used. ADCMPDR1 sets the upper-side level of window A..
    }

    /// ADCMPSR0 Register bits
    namespace adcmpsr0_bits {
        constexpr uint32_t CMPSTCHA07 = (1U << 7);  ///< Compare window A flag of AN007
        constexpr uint32_t CMPSTCHA06 = (1U << 6);  ///< Compare window A flag of AN006
        constexpr uint32_t CMPSTCHA05 = (1U << 5);  ///< Compare window A flag of AN005
        constexpr uint32_t CMPSTCHA04 = (1U << 4);  ///< Compare window A flag of AN004
        constexpr uint32_t CMPSTCHA03 = (1U << 3);  ///< Compare window A flag of AN003
        constexpr uint32_t CMPSTCHA02 = (1U << 2);  ///< Compare window A flag of AN002
        constexpr uint32_t CMPSTCHA01 = (1U << 1);  ///< Compare window A flag of AN001
        constexpr uint32_t CMPSTCHA00 = (1U << 0);  ///< Compare window A flag of AN000
    }

    /// ADCMPSR1 Register bits
    namespace adcmpsr1_bits {
        constexpr uint32_t CMPSTCHA20 = (1U << 4);  ///< Compare window A flag of AN020
        constexpr uint32_t CMPSTCHA19 = (1U << 3);  ///< Compare window A flag of AN019
        constexpr uint32_t CMPSTCHA18 = (1U << 2);  ///< Compare window A flag of AN018
        constexpr uint32_t CMPSTCHA17 = (1U << 1);  ///< Compare window A flag of AN017
        constexpr uint32_t CMPSTCHA16 = (1U << 0);  ///< Compare window A flag of AN016
    }

    /// ADCMPSER Register bits
    namespace adcmpser_bits {
        constexpr uint32_t CMPSTOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage Compare Flag When window A operation is enabled (ADCMPCR.CMPAE = 1b), this bit indicates the temperature sensor output comparison result. When window A operation is disabled (ADCMPCR.CMPAE = 0b), comparison conditions for CMPSTTSA are not met any time.
        constexpr uint32_t CMPSTTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Compare Flag When window A operation is enabled (ADCMPCR.CMPAE = 1b), this bit indicates the temperature sensor output comparison result. When window A operation is disabled (ADCMPCR.CMPAE = 0b), comparison conditions for CMPSTTSA are not met any time.
    }

    /// ADCMPBNSR Register bits
    namespace adcmpbnsr_bits {
        constexpr uint32_t CMPLB = (1U << 7);  ///< Compare window B Compare condition setting bit.
        constexpr uint32_t CMPCHB = (6 << 0);  ///< Compare window B channel selection bit.The channel that compares it on the condition of compare window B is selected.
    }

    /// ADWINLLB Register bits
    namespace adwinllb_bits {
        constexpr uint32_t ADWINLLB = (16 << 0);  ///< This register is used to compare A window function is used to set the lower level of the window B.
    }

    /// ADWINULB Register bits
    namespace adwinulb_bits {
        constexpr uint32_t ADWINULB = (16 << 0);  ///< This register is used to compare A window function is used to set the higher level of the window B.
    }

    /// ADCMPBSR Register bits
    namespace adcmpbsr_bits {
        constexpr uint32_t CMPSTB = (1U << 0);  ///< Compare window B flag.It is a status flag that shows the comparative result of CH (AN000-AN007,AN016-AN020, temperature sensor, and internal reference voltage) made the object of window B relation condition.
    }

    /// ADSSTRL Register bits
    namespace adsstrl_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting (AN016-AN020)
    }

    /// ADSSTRT Register bits
    namespace adsstrt_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting (temperature sensor output)
    }

    /// ADSSTRO Register bits
    namespace adsstro_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting (Internal reference voltage)
    }

    /// ADSSTR0%s Register bits
    namespace adsstr0%s_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling time setting
    }

    /// ADPGACR Register bits
    namespace adpgacr_bits {
        constexpr uint32_t P002GEN = (1U << 11);  ///< PGA P002 gain setting and enable bit
        constexpr uint32_t P002ENAMP = (1U << 10);  ///< Amplifier enable bit for PGA P002
        constexpr uint32_t P002SEL1 = (1U << 9);  ///< The amplifier passing is enable for PGA P002
        constexpr uint32_t P002SEL0 = (1U << 8);  ///< A through amplifier is enable for PGA P002
        constexpr uint32_t P001GEN = (1U << 7);  ///< PGA P001 gain setting and enable bit
        constexpr uint32_t P001ENAMP = (1U << 6);  ///< Amplifier enable bit for PGA P001
        constexpr uint32_t P001SEL1 = (1U << 5);  ///< The amplifier passing is enable for PGA P001
        constexpr uint32_t P001SEL0 = (1U << 4);  ///< A through amplifier is enable for PGA P001
        constexpr uint32_t P000GEN = (1U << 3);  ///< PGA P000 gain setting and enable bit
        constexpr uint32_t P000ENAMP = (1U << 2);  ///< Amplifier enable bit for PGA P000
        constexpr uint32_t P000SEL1 = (1U << 1);  ///< The amplifier passing is enable for PGA P000
        constexpr uint32_t P000SEL0 = (1U << 0);  ///< A through amplifier is enable for PGA P000
    }

    /// ADPGAGS0 Register bits
    namespace adpgags0_bits {
        constexpr uint32_t P002GAIN = (4 << 8);  ///< PGA P002 gain setting bit.The gain magnification of (ADPGSDCR0.P002GEN=0b) when the shingle end is input and each PGA P002 is set. When the differential motion is input, (ADPGSDCR0.P002GEN=1b) sets the gain magnification when the differential motion is input by the combination with ADPGSDCR0.P002DG 1:0.
        constexpr uint32_t P001GAIN = (4 << 4);  ///< PGA P001 gain setting bit.The gain magnification of (ADPGSDCR0.P001GEN=0b) when the shingle end is input and each PGA P001 is set. When the differential motion is input, (ADPGSDCR0.P001GEN=1b) sets the gain magnification when the differential motion is input by the combination with ADPGSDCR0.P001DG 1:0.
        constexpr uint32_t P000GAIN = (4 << 0);  ///< PGA P000 gain setting bit.The gain magnification of (ADPGSDCR0.P000GEN=0b) when the shingle end is input and each PGA P000 is set. When the differential motion is input, (ADPGSDCR0.P000GEN=1b) sets the gain magnification when the differential motion is input by the combination with ADPGSDCR0.P000DG 1:0.
    }

    /// ADPGADCR0 Register bits
    namespace adpgadcr0_bits {
        constexpr uint32_t P003DG = (2 << 12);  ///< P003 Differential Input Gain SettingNOTE: When these bits are used, set {P003DEN, P003GEN} to 11b.
        constexpr uint32_t P002DEN = (1U << 11);  ///< P002 Differential Input Enable
        constexpr uint32_t P002DG = (2 << 8);  ///< P002 Differential Input Gain SettingNOTE: When these bits are used, set {P002DEN, P002GEN} to 11b.
        constexpr uint32_t P001DEN = (1U << 7);  ///< P001 Differential Input Enable
        constexpr uint32_t P001DG = (2 << 4);  ///< P001 Differential Input Gain SettingNOTE: When these bits are used, set {P001DEN, P001GEN} to 11b.
        constexpr uint32_t P000DEN = (1U << 3);  ///< P000 Differential Input Enable
        constexpr uint32_t P000DG = (2 << 0);  ///< P000 Differential Input Gain SettingNOTE: When these bits are used, set {P000DEN, P000GEN} to 11b.
    }

}

// ============================================================================
// MSTP Peripheral
// ============================================================================

namespace mstp {
    /// Base addresses
    constexpr uint32_t MSTP_BASE = 0x40047000;

    /// MSTP Register structure
    struct Registers {
        volatile uint32_t MSTPCRB;  ///< Offset: 0x00 - Module Stop Control Register B
        volatile uint32_t MSTPCRC;  ///< Offset: 0x04 - Module Stop Control Register C
        volatile uint32_t MSTPCRD;  ///< Offset: 0x08 - Module Stop Control Register D
    };

    /// Peripheral instances
    inline Registers* MSTP = reinterpret_cast<Registers*>(MSTP_BASE);

    // Bit definitions
    /// MSTPCRB Register bits
    namespace mstpcrb_bits {
        constexpr uint32_t MSTPB31 = (1U << 31);  ///< Serial Communication Interface 0 Module Stop
        constexpr uint32_t MSTPB30 = (1U << 30);  ///< Serial Communication Interface 1 Module Stop
        constexpr uint32_t MSTPB29 = (1U << 29);  ///< Serial Communication Interface 2 Module Stop
        constexpr uint32_t MSTPB28 = (1U << 28);  ///< Serial Communication Interface 3 Module Stop
        constexpr uint32_t MSTPB27 = (1U << 27);  ///< Serial Communication Interface 4 Module Stop
        constexpr uint32_t MSTPB26 = (1U << 26);  ///< Serial Communication Interface 5 Module Stop
        constexpr uint32_t MSTPB25 = (1U << 25);  ///< Serial Communication Interface 6 Module Stop
        constexpr uint32_t MSTPB24 = (1U << 24);  ///< Serial Communication Interface 7 Module Stop
        constexpr uint32_t MSTPB23 = (1U << 23);  ///< Serial Communication Interface 8 Module Stop
        constexpr uint32_t MSTPB22 = (1U << 22);  ///< Serial Communication Interface 9 Module Stop
        constexpr uint32_t MSTPB19 = (1U << 19);  ///< Serial Peripheral Interface 0 Module Stop
        constexpr uint32_t MSTPB18 = (1U << 18);  ///< Serial Peripheral Interface Module Stop
        constexpr uint32_t MSTPB15 = (1U << 15);  ///< ETHERC0 and EDMAC0 Module Stop
        constexpr uint32_t MSTPB13 = (1U << 13);  ///< EPTPC and PTPEDMAC Module Stop
        constexpr uint32_t MSTPB12 = (1U << 12);  ///< Universal Serial Bus 2.0 HS Interface Module Stop
        constexpr uint32_t MSTPB11 = (1U << 11);  ///< Universal Serial Bus 2.0 FS Interface Module Stop
        constexpr uint32_t MSTPB9 = (1U << 9);  ///< I2C Bus Interface 0 Module Stop
        constexpr uint32_t MSTPB8 = (1U << 8);  ///< I2C Bus Interface 1 Module Stop
        constexpr uint32_t MSTPB7 = (1U << 7);  ///< I2C Bus Interface 2 Module Stop
        constexpr uint32_t MSTPB6 = (1U << 6);  ///< Queued Serial Peripheral Interface Module Stop
        constexpr uint32_t MSTPB5 = (1U << 5);  ///< IrDA Module Stop
        constexpr uint32_t MSTPB2 = (1U << 2);  ///< RCAN0 Module Stop
        constexpr uint32_t MSTPB1 = (1U << 1);  ///< RCAN1 Module Stop
    }

    /// MSTPCRC Register bits
    namespace mstpcrc_bits {
        constexpr uint32_t MSTPC31 = (1U << 31);  ///< TSIP Module Stop
        constexpr uint32_t MSTPC14 = (1U << 14);  ///< Event Link Controller Module Stop
        constexpr uint32_t MSTPC13 = (1U << 13);  ///< Data Operation Circuit Module Stop
        constexpr uint32_t MSTPC12 = (1U << 12);  ///< Synchronous Digital Hierarchy/ Multi Media Card 0 Module Stop
        constexpr uint32_t MSTPC11 = (1U << 11);  ///< Synchronous Digital Hierarchy/ Multi Media Card 1 Module Stop
        constexpr uint32_t MSTPC9 = (1U << 9);  ///< Sampling Rate Converter Module Stop
        constexpr uint32_t MSTPC8 = (1U << 8);  ///< Synchronous Serial Interface 0 Module Stop
        constexpr uint32_t MSTPC7 = (1U << 7);  ///< Synchronous Serial Interface 1 Module Stop
        constexpr uint32_t MSTPC6 = (1U << 6);  ///< 2DG engine Module Stop
        constexpr uint32_t MSTPC5 = (1U << 5);  ///< JPEG codec engine Module Stop
        constexpr uint32_t MSTPC4 = (1U << 4);  ///< Grafic LCD Controler Module Stop
        constexpr uint32_t MSTPC3 = (1U << 3);  ///< Capacitive Touch Sensing Unit Module Stop
        constexpr uint32_t MSTPC2 = (1U << 2);  ///< Parallel Data Capture Module Stop
        constexpr uint32_t MSTPC1 = (1U << 1);  ///< CRC Calculator Module Stop
        constexpr uint32_t MSTPC0 = (1U << 0);  ///< CAC Module Stop
    }

    /// MSTPCRD Register bits
    namespace mstpcrd_bits {
        constexpr uint32_t MSTPD28 = (1U << 28);  ///< Comparator-OC0 Module Stop
        constexpr uint32_t MSTPD27 = (1U << 27);  ///< Comparator-OC1 Module Stop
        constexpr uint32_t MSTPD26 = (1U << 26);  ///< Comparator-OC2 Module Stop
        constexpr uint32_t MSTPD25 = (1U << 25);  ///< Comparator-OC3 Module Stop
        constexpr uint32_t MSTPD24 = (1U << 24);  ///< Comparator-OC4 Module Stop
        constexpr uint32_t MSTPD23 = (1U << 23);  ///< Comparator-OC5 Module Stop
        constexpr uint32_t MSTPD22 = (1U << 22);  ///< Temperature Sensor Module Stop
        constexpr uint32_t MSTPD20 = (1U << 20);  ///< D/A Converter 0 Module Stop
        constexpr uint32_t MSTPD16 = (1U << 16);  ///< 12-bit A/D Converter 0 Module Stop
        constexpr uint32_t MSTPD15 = (1U << 15);  ///< 12-bit A/D Converter 1 Module Stop
        constexpr uint32_t MSTPD14 = (1U << 14);  ///< PGI Module Stop
        constexpr uint32_t MSTPD6 = (1U << 6);  ///< GPT ch13-ch8 Module Stop
        constexpr uint32_t MSTPD5 = (1U << 5);  ///< GPT ch7-ch0 Module Stop
        constexpr uint32_t MSTPD3 = (1U << 3);  ///< AGT0 Module StopNote: AGT0 is in the module stop state when the count source is either of PCLKB, PCLKB/2 or PCLKB/8. In case the count source is sub-clock or LOCO, this bit should be set to 1 except when accessing the registers of AGT0.
        constexpr uint32_t MSTPD2 = (1U << 2);  ///< AGT1 Module StopNote: AGT1 is in the module stop state when the count source is either of PCLKB, PCLKB/2 or PCLKB/8. In case the count source is sub-clock or LOCO, this bit should be set to 1 except when accessing the registers of AGT1.
    }

}

// ============================================================================
// GPT328 Peripheral
// ============================================================================

namespace gpt328 {
    /// Base addresses
    constexpr uint32_t GPT328_BASE = 0x40078800;

    /// GPT328 Register structure
    struct Registers {
        volatile uint32_t GTWP;  ///< Offset: 0x00 - General PWM Timer Write-Protection Register
        volatile uint32_t GTSTR;  ///< Offset: 0x04 - General PWM Timer Software Start Register
        volatile uint32_t GTSTP;  ///< Offset: 0x08 - General PWM Timer Software Stop Register
        volatile uint32_t GTCLR;  ///< Offset: 0x0C - General PWM Timer Software Clear Register
        volatile uint32_t GTSSR;  ///< Offset: 0x10 - General PWM Timer Start Source Select Register
        volatile uint32_t GTPSR;  ///< Offset: 0x14 - General PWM Timer Stop Source Select Register
        volatile uint32_t GTCSR;  ///< Offset: 0x18 - General PWM Timer Clear Source Select Register
        volatile uint32_t GTUPSR;  ///< Offset: 0x1C - General PWM Timer Up Count Source Select Register
        volatile uint32_t GTDNSR;  ///< Offset: 0x20 - General PWM Timer Down Count Source Select Register
        volatile uint32_t GTICASR;  ///< Offset: 0x24 - General PWM Timer Input Capture Source Select Register A
        volatile uint32_t GTICBSR;  ///< Offset: 0x28 - General PWM Timer Input Capture Source Select Register B
        volatile uint32_t GTCR;  ///< Offset: 0x2C - General PWM Timer Control Register
        volatile uint32_t GTUDDTYC;  ///< Offset: 0x30 - General PWM Timer Count Direction and Duty Setting Register
        volatile uint32_t GTIOR;  ///< Offset: 0x34 - General PWM Timer I/O Control Register
        volatile uint32_t GTINTAD;  ///< Offset: 0x38 - General PWM Timer Interrupt Output Setting Register
        volatile uint32_t GTST;  ///< Offset: 0x3C - General PWM Timer Status Register
        volatile uint32_t GTBER;  ///< Offset: 0x40 - General PWM Timer Buffer Enable Register
        volatile uint32_t GTCNT;  ///< Offset: 0x48 - General PWM Timer Counter
        volatile uint32_t GTCCRA;  ///< Offset: 0x4C - General PWM Timer Compare Capture Register A
        volatile uint32_t GTCCRB;  ///< Offset: 0x50 - General PWM Timer Compare Capture Register B
        volatile uint32_t GTCCRC;  ///< Offset: 0x54 - General PWM Timer Compare Capture Register C
        volatile uint32_t GTCCRE;  ///< Offset: 0x58 - General PWM Timer Compare Capture Register E
        volatile uint32_t GTCCRD;  ///< Offset: 0x5C - General PWM Timer Compare Capture Register D
        volatile uint32_t GTCCRF;  ///< Offset: 0x60 - General PWM Timer Compare Capture Register F
        volatile uint32_t GTPR;  ///< Offset: 0x64 - General PWM Timer Cycle Setting Register
        volatile uint32_t GTPBR;  ///< Offset: 0x68 - General PWM Timer Cycle Setting Buffer Register
        volatile uint32_t GTDTCR;  ///< Offset: 0x88 - General PWM Timer Dead Time Control Register
        volatile uint32_t GTDVU;  ///< Offset: 0x8C - General PWM Timer Dead Time Value Register U
    };

    /// Peripheral instances
    inline Registers* GPT328 = reinterpret_cast<Registers*>(GPT328_BASE);

    // Bit definitions
    /// GTWP Register bits
    namespace gtwp_bits {
        constexpr uint32_t PRKEY = (8 << 8);  ///< GTWP Key Code
        constexpr uint32_t WP = (1U << 0);  ///< Register Write Disable
    }

    /// GTSTR Register bits
    namespace gtstr_bits {
        constexpr uint32_t CSTRT13 = (1U << 13);  ///< Channel 13 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT12 = (1U << 12);  ///< Channel 12 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT11 = (1U << 11);  ///< Channel 11 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT10 = (1U << 10);  ///< Channel 10 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT9 = (1U << 9);  ///< Channel 9 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT8 = (1U << 8);  ///< Channel 8 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT7 = (1U << 7);  ///< Channel 7 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT6 = (1U << 6);  ///< Channel 6 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT5 = (1U << 5);  ///< Channel 5 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT4 = (1U << 4);  ///< Channel 4 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT3 = (1U << 3);  ///< Channel 3 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT2 = (1U << 2);  ///< Channel 2 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT1 = (1U << 1);  ///< Channel 1 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT0 = (1U << 0);  ///< Channel 0 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
    }

    /// GTSTP Register bits
    namespace gtstp_bits {
        constexpr uint32_t CSTOP13 = (1U << 13);  ///< Channel 13 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP12 = (1U << 12);  ///< Channel 12 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP11 = (1U << 11);  ///< Channel 11 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP10 = (1U << 10);  ///< Channel 10 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP9 = (1U << 9);  ///< Channel 9 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP8 = (1U << 8);  ///< Channel 8 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP7 = (1U << 7);  ///< Channel 7 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP6 = (1U << 6);  ///< Channel 6 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP5 = (1U << 5);  ///< Channel 5 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP4 = (1U << 4);  ///< Channel 4 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP3 = (1U << 3);  ///< Channel 3 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP2 = (1U << 2);  ///< Channel 2 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP1 = (1U << 1);  ///< Channel 1 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP0 = (1U << 0);  ///< Channel 0 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
    }

    /// GTCLR Register bits
    namespace gtclr_bits {
        constexpr uint32_t CCLR13 = (1U << 13);  ///< Channel 13 GTCNT Count Clear
        constexpr uint32_t CCLR12 = (1U << 12);  ///< Channel 12 GTCNT Count Clear
        constexpr uint32_t CCLR11 = (1U << 11);  ///< Channel 11 GTCNT Count Clear
        constexpr uint32_t CCLR10 = (1U << 10);  ///< Channel 10 GTCNT Count Clear
        constexpr uint32_t CCLR9 = (1U << 9);  ///< Channel 9 GTCNT Count Clear
        constexpr uint32_t CCLR8 = (1U << 8);  ///< Channel 8 GTCNT Count Clear
        constexpr uint32_t CCLR7 = (1U << 7);  ///< Channel 7 GTCNT Count Clear
        constexpr uint32_t CCLR6 = (1U << 6);  ///< Channel 6 GTCNT Count Clear
        constexpr uint32_t CCLR5 = (1U << 5);  ///< Channel 5 GTCNT Count Clear
        constexpr uint32_t CCLR4 = (1U << 4);  ///< Channel 4 GTCNT Count Clear
        constexpr uint32_t CCLR3 = (1U << 3);  ///< Channel 3 GTCNT Count Clear
        constexpr uint32_t CCLR2 = (1U << 2);  ///< Channel 2 GTCNT Count Clear
        constexpr uint32_t CCLR1 = (1U << 1);  ///< Channel 1 GTCNT Count Clear
        constexpr uint32_t CCLR0 = (1U << 0);  ///< Channel 0 GTCNT Count Clear
    }

    /// GTSSR Register bits
    namespace gtssr_bits {
        constexpr uint32_t CSTRT = (1U << 31);  ///< Software Source Counter Start Enable
        constexpr uint32_t SSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Start Enable
        constexpr uint32_t SSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Start Enable
        constexpr uint32_t SSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Start Enable
        constexpr uint32_t SSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Start Enable
        constexpr uint32_t SSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Start Enable
        constexpr uint32_t SSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Start Enable
        constexpr uint32_t SSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Start Enable
        constexpr uint32_t SSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Start Enable
        constexpr uint32_t SSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Start Enable
    }

    /// GTPSR Register bits
    namespace gtpsr_bits {
        constexpr uint32_t CSTOP = (1U << 31);  ///< Software Source Counter Stop Enable
        constexpr uint32_t PSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Stop Enable
        constexpr uint32_t PSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Stop Enable
        constexpr uint32_t PSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Stop Enable
        constexpr uint32_t PSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Stop Enable
        constexpr uint32_t PSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Stop Enable
        constexpr uint32_t PSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Stop Enable
        constexpr uint32_t PSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Stop Enable
        constexpr uint32_t PSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Stop Enable
        constexpr uint32_t PSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Stop Enable
    }

    /// GTCSR Register bits
    namespace gtcsr_bits {
        constexpr uint32_t CCLR = (1U << 31);  ///< Software Source Counter Clear Enable
        constexpr uint32_t CSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Clear Enable
        constexpr uint32_t CSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Clear Enable
        constexpr uint32_t CSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Clear Enable
        constexpr uint32_t CSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Clear Enable
        constexpr uint32_t CSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Clear Enable
        constexpr uint32_t CSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Clear Enable
        constexpr uint32_t CSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Clear Enable
        constexpr uint32_t CSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Clear Enable
        constexpr uint32_t CSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Clear Enable
    }

    /// GTUPSR Register bits
    namespace gtupsr_bits {
        constexpr uint32_t USELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Count Up Enable
        constexpr uint32_t USELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Up Enable
        constexpr uint32_t USELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Up Enable
        constexpr uint32_t USELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Up Enable
        constexpr uint32_t USELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Up Enable
        constexpr uint32_t USELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Up Enable
        constexpr uint32_t USELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Up Enable
        constexpr uint32_t USELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Up Enable
        constexpr uint32_t USCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Up Enable
    }

    /// GTDNSR Register bits
    namespace gtdnsr_bits {
        constexpr uint32_t DSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Count Down Enable
        constexpr uint32_t DSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Down Enable
        constexpr uint32_t DSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Down Enable
        constexpr uint32_t DSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Down Enable
        constexpr uint32_t DSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Down Enable
        constexpr uint32_t DSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Down Enable
        constexpr uint32_t DSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Down Enable
        constexpr uint32_t DSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Down Enable
        constexpr uint32_t DSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Down Enable
    }

    /// GTICASR Register bits
    namespace gticasr_bits {
        constexpr uint32_t ASELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable
    }

    /// GTICBSR Register bits
    namespace gticbsr_bits {
        constexpr uint32_t BSELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable
    }

    /// GTCR Register bits
    namespace gtcr_bits {
        constexpr uint32_t TPCS = (3 << 24);  ///< Timer Prescaler Select
        constexpr uint32_t MD = (3 << 16);  ///< Mode Select
        constexpr uint32_t CST = (1U << 0);  ///< Count Start
    }

    /// GTUDDTYC Register bits
    namespace gtuddtyc_bits {
        constexpr uint32_t OBDTYR = (1U << 27);  ///< GTIOCB Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OBDTYF = (1U << 26);  ///< Forcible GTIOCB Output Duty Setting
        constexpr uint32_t OBDTY = (2 << 24);  ///< GTIOCB Output Duty Setting
        constexpr uint32_t OADTYR = (1U << 19);  ///< GTIOCA Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OADTYF = (1U << 18);  ///< Forcible GTIOCA Output Duty Setting
        constexpr uint32_t OADTY = (2 << 16);  ///< GTIOCA Output Duty Setting
        constexpr uint32_t UDF = (1U << 1);  ///< Forcible Count Direction Setting
        constexpr uint32_t UD = (1U << 0);  ///< Count Direction Setting
    }

    /// GTIOR Register bits
    namespace gtior_bits {
        constexpr uint32_t NFCSB = (2 << 30);  ///< Noise Filter B Sampling Clock Select
        constexpr uint32_t NFBEN = (1U << 29);  ///< Noise Filter B Enable
        constexpr uint32_t OBDF = (2 << 25);  ///< GTIOCB Pin Disable Value Setting
        constexpr uint32_t OBE = (1U << 24);  ///< GTIOCB Pin Output Enable
        constexpr uint32_t OBHLD = (1U << 23);  ///< GTIOCB Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OBDFLT = (1U << 22);  ///< GTIOCB Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOB = (5 << 16);  ///< GTIOCB Pin Function Select
        constexpr uint32_t NFCSA = (2 << 14);  ///< Noise Filter A Sampling Clock Select
        constexpr uint32_t NFAEN = (1U << 13);  ///< Noise Filter A Enable
        constexpr uint32_t OADF = (2 << 9);  ///< GTIOCA Pin Disable Value Setting
        constexpr uint32_t OAE = (1U << 8);  ///< GTIOCA Pin Output Enable
        constexpr uint32_t OAHLD = (1U << 7);  ///< GTIOCA Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OADFLT = (1U << 6);  ///< GTIOCA Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOA = (5 << 0);  ///< GTIOCA Pin Function Select
    }

    /// GTINTAD Register bits
    namespace gtintad_bits {
        constexpr uint32_t GRPABL = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t GRPABH = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disable Source Select
    }

    /// GTST Register bits
    namespace gtst_bits {
        constexpr uint32_t OABLF = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t OABHF = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t ODF = (1U << 24);  ///< Output Disable Flag
        constexpr uint32_t TUCF = (1U << 15);  ///< Count Direction Flag
        constexpr uint32_t TCFPU = (1U << 7);  ///< Underflow Flag
        constexpr uint32_t TCPFO = (1U << 6);  ///< Overflow Flag
        constexpr uint32_t TCFF = (1U << 5);  ///< Input Compare Match Flag F
        constexpr uint32_t TCFE = (1U << 4);  ///< Input Compare Match Flag E
        constexpr uint32_t TCFD = (1U << 3);  ///< Input Compare Match Flag D
        constexpr uint32_t TCFC = (1U << 2);  ///< Input Compare Match Flag C
        constexpr uint32_t TCFB = (1U << 1);  ///< Input Capture/Compare Match Flag B
        constexpr uint32_t TCFA = (1U << 0);  ///< Input Capture/Compare Match Flag A
    }

    /// GTBER Register bits
    namespace gtber_bits {
        constexpr uint32_t CCRSWT = (1U << 22);  ///< GTCCRA and GTCCRB Forcible Buffer OperationThis bit is read as 0.
        constexpr uint32_t PR = (2 << 20);  ///< GTPR Buffer Operation
        constexpr uint32_t CCRB = (2 << 18);  ///< GTCCRB Buffer Operation
        constexpr uint32_t CCRA = (2 << 16);  ///< GTCCRA Buffer Operation
        constexpr uint32_t BD1 = (1U << 1);  ///< GTPR Buffer Operation Disable
        constexpr uint32_t BD2 = (1U << 0);  ///< GTCCR Buffer Operation Disable
    }

    /// GTCNT Register bits
    namespace gtcnt_bits {
        constexpr uint32_t GTCNT = (32 << 0);  ///< Counter
    }

    /// GTCCRA Register bits
    namespace gtccra_bits {
        constexpr uint32_t GTCCRA = (32 << 0);  ///< Compare Capture Register A
    }

    /// GTCCRB Register bits
    namespace gtccrb_bits {
        constexpr uint32_t GTCCRB = (32 << 0);  ///< Compare Capture Register B
    }

    /// GTCCRC Register bits
    namespace gtccrc_bits {
        constexpr uint32_t GTCCRC = (32 << 0);  ///< Compare Capture Register C
    }

    /// GTCCRE Register bits
    namespace gtccre_bits {
        constexpr uint32_t GTCCRE = (32 << 0);  ///< Compare Capture Register E
    }

    /// GTCCRD Register bits
    namespace gtccrd_bits {
        constexpr uint32_t GTCCRD = (32 << 0);  ///< Compare Capture Register D
    }

    /// GTCCRF Register bits
    namespace gtccrf_bits {
        constexpr uint32_t GTCCRF = (32 << 0);  ///< Compare Capture Register F
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GTPR = (32 << 0);  ///< Cycle Setting Register
    }

    /// GTPBR Register bits
    namespace gtpbr_bits {
        constexpr uint32_t GTPBR = (32 << 0);  ///< Cycle Setting Buffer Register
    }

    /// GTDTCR Register bits
    namespace gtdtcr_bits {
        constexpr uint32_t TDE = (1U << 0);  ///< Negative-Phase Waveform Setting
    }

    /// GTDVU Register bits
    namespace gtdvu_bits {
        constexpr uint32_t GTDVU = (32 << 0);  ///< Dead Time Value Register U
    }

}

// ============================================================================
// GPT329 Peripheral
// ============================================================================

namespace gpt329 {
    /// Base addresses
    constexpr uint32_t GPT329_BASE = 0x40078900;

    /// GPT329 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT329 = reinterpret_cast<Registers*>(GPT329_BASE);

}

// ============================================================================
// GPT3210 Peripheral
// ============================================================================

namespace gpt3210 {
    /// Base addresses
    constexpr uint32_t GPT3210_BASE = 0x40078A00;

    /// GPT3210 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT3210 = reinterpret_cast<Registers*>(GPT3210_BASE);

}

// ============================================================================
// GPT3211 Peripheral
// ============================================================================

namespace gpt3211 {
    /// Base addresses
    constexpr uint32_t GPT3211_BASE = 0x40078B00;

    /// GPT3211 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT3211 = reinterpret_cast<Registers*>(GPT3211_BASE);

}

// ============================================================================
// GPT3212 Peripheral
// ============================================================================

namespace gpt3212 {
    /// Base addresses
    constexpr uint32_t GPT3212_BASE = 0x40078C00;

    /// GPT3212 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT3212 = reinterpret_cast<Registers*>(GPT3212_BASE);

}

// ============================================================================
// GPT3213 Peripheral
// ============================================================================

namespace gpt3213 {
    /// Base addresses
    constexpr uint32_t GPT3213_BASE = 0x40078D00;

    /// GPT3213 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT3213 = reinterpret_cast<Registers*>(GPT3213_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40044000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t R64CNT;  ///< Offset: 0x00 - 64-Hz Counter
        volatile uint32_t RSECCNT;  ///< Offset: 0x02 - Second Counter
        volatile uint32_t BCNT0;  ///< Offset: 0x02 - Binary Counter 0
        volatile uint32_t RMINCNT;  ///< Offset: 0x04 - Minute Counter
        volatile uint32_t BCNT1;  ///< Offset: 0x04 - Binary Counter 1
        volatile uint32_t RHRCNT;  ///< Offset: 0x06 - Hour Counter
        volatile uint32_t BCNT2;  ///< Offset: 0x06 - Binary Counter 2
        volatile uint32_t RWKCNT;  ///< Offset: 0x08 - Day-of-Week Counter
        volatile uint32_t BCNT3;  ///< Offset: 0x08 - Binary Counter 3
        volatile uint32_t RDAYCNT;  ///< Offset: 0x0A - Day Counter
        volatile uint32_t RMONCNT;  ///< Offset: 0x0C - Month Counter
        volatile uint32_t RYRCNT;  ///< Offset: 0x0E - Year Counter
        volatile uint32_t RSECAR;  ///< Offset: 0x10 - Second Alarm Register
        volatile uint32_t BCNT0AR;  ///< Offset: 0x10 - Binary Counter 0 Alarm Register
        volatile uint32_t RMINAR;  ///< Offset: 0x12 - Minute Alarm Register
        volatile uint32_t BCNT1AR;  ///< Offset: 0x12 - Binary Counter 1 Alarm Register
        volatile uint32_t RHRAR;  ///< Offset: 0x14 - Hour Alarm Register
        volatile uint32_t BCNT2AR;  ///< Offset: 0x14 - Binary Counter 2 Alarm Register
        volatile uint32_t RWKAR;  ///< Offset: 0x16 - Day-of-Week Alarm Register
        volatile uint32_t BCNT3AR;  ///< Offset: 0x16 - Binary Counter 3 Alarm Register
        volatile uint32_t RDAYAR;  ///< Offset: 0x18 - Date Alarm Register
        volatile uint32_t BCNT0AER;  ///< Offset: 0x18 - Binary Counter 0 Alarm Enable Register
        volatile uint32_t RMONAR;  ///< Offset: 0x1A - Month Alarm Register
        volatile uint32_t BCNT1AER;  ///< Offset: 0x1A - Binary Counter 1 Alarm Enable Register
        volatile uint32_t RYRAR;  ///< Offset: 0x1C - Year Alarm Register
        volatile uint32_t BCNT2AER;  ///< Offset: 0x1C - Binary Counter 2 Alarm Enable Register
        volatile uint32_t RYRAREN;  ///< Offset: 0x1E - Year Alarm Enable Register
        volatile uint32_t BCNT3AER;  ///< Offset: 0x1E - Binary Counter 3 Alarm Enable Register
        volatile uint32_t RCR1;  ///< Offset: 0x22 - RTC Control Register 1
        volatile uint32_t RCR2;  ///< Offset: 0x24 - RTC Control Register 2
        volatile uint32_t RCR4;  ///< Offset: 0x28 - RTC Control Register 4
        volatile uint32_t RFRH;  ///< Offset: 0x2A - Frequency Register H
        volatile uint32_t RFRL;  ///< Offset: 0x2C - Frequency Register L
        volatile uint32_t RADJ;  ///< Offset: 0x2E - Time Error Adjustment Register
        volatile uint32_t RTCCR%s;  ///< Offset: 0x40 - Time Capture Control Register %s
        volatile uint32_t RSECCP%s;  ///< Offset: 0x52 - Second Capture Register %s
        volatile uint32_t BCNT0CP%s;  ///< Offset: 0x52 - BCNT0 Capture Register %s
        volatile uint32_t RMINCP%s;  ///< Offset: 0x54 - Minute Capture Register %s
        volatile uint32_t BCNT1CP%s;  ///< Offset: 0x54 - BCNT1 Capture Register %s
        volatile uint32_t RHRCP%s;  ///< Offset: 0x56 - Hour Capture Register %s
        volatile uint32_t BCNT2CP%s;  ///< Offset: 0x56 - BCNT2 Capture Register %s
        volatile uint32_t RDAYCP%s;  ///< Offset: 0x5A - Date Capture Register %s
        volatile uint32_t BCNT3CP%s;  ///< Offset: 0x5A - BCNT3 Capture Register %s
        volatile uint32_t RMONCP%s;  ///< Offset: 0x5C - Month Capture Register %s
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// R64CNT Register bits
    namespace r64cnt_bits {
        constexpr uint32_t F1HZ = (1U << 6);  ///< 1Hz
        constexpr uint32_t F2HZ = (1U << 5);  ///< 2Hz
        constexpr uint32_t F4HZ = (1U << 4);  ///< 4Hz
        constexpr uint32_t F8HZ = (1U << 3);  ///< 8Hz
        constexpr uint32_t F16HZ = (1U << 2);  ///< 16Hz
        constexpr uint32_t F32HZ = (1U << 1);  ///< 32Hz
        constexpr uint32_t F64HZ = (1U << 0);  ///< 64Hz
    }

    /// RSECCNT Register bits
    namespace rseccnt_bits {
        constexpr uint32_t SEC10 = (3 << 4);  ///< 10-Second Count Counts from 0 to 5 for 60-second counting.
        constexpr uint32_t SEC1 = (4 << 0);  ///< 1-Second Count Counts from 0 to 9 every second. When a carry is generated, 1 is added to the tens place.
    }

    /// BCNT0 Register bits
    namespace bcnt0_bits {
        constexpr uint32_t BCNT0 = (8 << 0);  ///< The BCNT0 counter is a readable/writable 32-bit binary counter b7 to b0.
    }

    /// RMINCNT Register bits
    namespace rmincnt_bits {
        constexpr uint32_t MIN10 = (3 << 4);  ///< 10-Minute Count Counts from 0 to 5 for 60-minute counting.
        constexpr uint32_t MIN1 = (4 << 0);  ///< 1-Minute Count Counts from 0 to 9 every minute. When a carry is generated, 1 is added to the tens place.
    }

    /// BCNT1 Register bits
    namespace bcnt1_bits {
        constexpr uint32_t BCNT1 = (8 << 0);  ///< The BCNT1 counter is a readable/writable 32-bit binary counter b15 to b8.
    }

    /// RHRCNT Register bits
    namespace rhrcnt_bits {
        constexpr uint32_t PM = (1U << 6);  ///< Time Counter Setting for a.m./p.m.
        constexpr uint32_t HR10 = (2 << 4);  ///< 10-Hour Count Counts from 0 to 2 once per carry from the ones place.
        constexpr uint32_t HR1 = (4 << 0);  ///< 1-Hour Count Counts from 0 to 9 once per hour. When a carry is generated, 1 is added to the tens place.
    }

    /// BCNT2 Register bits
    namespace bcnt2_bits {
        constexpr uint32_t BCNT2 = (8 << 0);  ///< The BCNT2 counter is a readable/writable 32-bit binary counter b23 to b16.
    }

    /// RWKCNT Register bits
    namespace rwkcnt_bits {
        constexpr uint32_t DAYW = (3 << 0);  ///< Day-of-Week Counting
    }

    /// BCNT3 Register bits
    namespace bcnt3_bits {
        constexpr uint32_t BCNT3 = (8 << 0);  ///< The BCNT3 counter is a readable/writable 32-bit binary counter b31 to b24.
    }

    /// RDAYCNT Register bits
    namespace rdaycnt_bits {
        constexpr uint32_t DATE10 = (2 << 4);  ///< 10-Day Count Counts from 0 to 3 once per carry from the ones place.
        constexpr uint32_t DATE1 = (4 << 0);  ///< 1-Day Count Counts from 0 to 9 once per day. When a carry is generated, 1 is added to the tens place.
    }

    /// RMONCNT Register bits
    namespace rmoncnt_bits {
        constexpr uint32_t MON10 = (1U << 4);  ///< 10-Month Count Counts from 0 to 1 once per carry from the ones place.
        constexpr uint32_t MON1 = (4 << 0);  ///< 1-Month Count Counts from 0 to 9 once per month. When a carry is generated, 1 is added to the tens place.
    }

    /// RYRCNT Register bits
    namespace ryrcnt_bits {
        constexpr uint32_t YR10 = (4 << 4);  ///< 10-Year Count Counts from 0 to 9 once per carry from ones place. When a carry is generated in the tens place, 1 is added to the hundreds place.
        constexpr uint32_t YR1 = (4 << 0);  ///< 1-Year Count Counts from 0 to 9 once per year. When a carry is generated, 1 is added to the tens place.
    }

    /// RSECAR Register bits
    namespace rsecar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
        constexpr uint32_t SEC10 = (3 << 4);  ///< 10-Seconds Value for the tens place of seconds
        constexpr uint32_t SEC1 = (4 << 0);  ///< 1-Second Value for the ones place of seconds
    }

    /// BCNT0AR Register bits
    namespace bcnt0ar_bits {
        constexpr uint32_t BCNT0AR = (8 << 0);  ///< he BCNT0AR counter is a readable/writable alarm register corresponding to 32-bit binary counter b7 to b0.
    }

    /// RMINAR Register bits
    namespace rminar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
        constexpr uint32_t MIN10 = (3 << 4);  ///< 10-Minute Count Value for the tens place of minutes
        constexpr uint32_t MIN1 = (4 << 0);  ///< 1-Minute Count Value for the ones place of minutes
    }

    /// BCNT1AR Register bits
    namespace bcnt1ar_bits {
        constexpr uint32_t BCNT1AR = (8 << 0);  ///< he BCNT1AR counter is a readable/writable alarm register corresponding to 32-bit binary counter b15 to b8.
    }

    /// RHRAR Register bits
    namespace rhrar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
        constexpr uint32_t PM = (1U << 6);  ///< Time Counter Setting for a.m./p.m.
        constexpr uint32_t HR10 = (2 << 4);  ///< 10-Hour Count Value for the tens place of hours
        constexpr uint32_t HR1 = (4 << 0);  ///< 1-Hour Count Value for the ones place of hours
    }

    /// BCNT2AR Register bits
    namespace bcnt2ar_bits {
        constexpr uint32_t BCNT2AR = (8 << 0);  ///< The BCNT2AR counter is a readable/writable 32-bit binary counter b23 to b16.
    }

    /// RWKAR Register bits
    namespace rwkar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
        constexpr uint32_t DAYW = (3 << 0);  ///< Day-of-Week Counting
    }

    /// BCNT3AR Register bits
    namespace bcnt3ar_bits {
        constexpr uint32_t BCNT3AR = (8 << 0);  ///< The BCNT3AR counter is a readable/writable 32-bit binary counter b31 to b24.
    }

    /// RDAYAR Register bits
    namespace rdayar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
        constexpr uint32_t DATE10 = (2 << 4);  ///< 10 Days Value for the tens place of days
        constexpr uint32_t DATE1 = (4 << 0);  ///< 1 Day Value for the ones place of days
    }

    /// BCNT0AER Register bits
    namespace bcnt0aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< The BCNT0AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b7 to b0.
    }

    /// RMONAR Register bits
    namespace rmonar_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
        constexpr uint32_t MON10 = (1U << 4);  ///< 10 Months Value for the tens place of months
        constexpr uint32_t MON1 = (4 << 0);  ///< 1 Month Value for the ones place of months
    }

    /// BCNT1AER Register bits
    namespace bcnt1aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< The BCNT1AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b15 to b8.
    }

    /// RYRAR Register bits
    namespace ryrar_bits {
        constexpr uint32_t YR10 = (4 << 4);  ///< 10 Years Value for the tens place of years
        constexpr uint32_t YR1 = (4 << 0);  ///< 1 Year Value for the ones place of years
    }

    /// BCNT2AER Register bits
    namespace bcnt2aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< The BCNT2AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b23 to b16.
    }

    /// RYRAREN Register bits
    namespace ryraren_bits {
        constexpr uint32_t ENB = (1U << 7);  ///< Compare enable
    }

    /// BCNT3AER Register bits
    namespace bcnt3aer_bits {
        constexpr uint32_t ENB = (8 << 0);  ///< The BCNT3AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b31 to b24.
    }

    /// RCR1 Register bits
    namespace rcr1_bits {
        constexpr uint32_t PES = (4 << 4);  ///< Periodic Interrupt Select
        constexpr uint32_t RTCOS = (1U << 3);  ///< RTCOUT Output Select
        constexpr uint32_t PIE = (1U << 2);  ///< Periodic Interrupt Enable
        constexpr uint32_t CIE = (1U << 1);  ///< Carry Interrupt Enable
        constexpr uint32_t AIE = (1U << 0);  ///< Alarm Interrupt Enable
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t CNTMD = (1U << 7);  ///< Count Mode Select
        constexpr uint32_t HR24 = (1U << 6);  ///< Hours Mode
        constexpr uint32_t AADJP = (1U << 5);  ///< Automatic Adjustment Period Select (When the LOCO clock is selected, the setting of this bit is disabled.)
        constexpr uint32_t AADJE = (1U << 4);  ///< Automatic Adjustment Enable (When the LOCO clock is selected, the setting of this bit is disabled.)
        constexpr uint32_t RTCOE = (1U << 3);  ///< RTCOUT Output Enable
        constexpr uint32_t ADJ30 = (1U << 2);  ///< 30-Second Adjustment
        constexpr uint32_t RESET = (1U << 1);  ///< RTC Software Reset
        constexpr uint32_t START = (1U << 0);  ///< Start
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t RCKSEL = (1U << 0);  ///< Count Source Select
    }

    /// RFRH Register bits
    namespace rfrh_bits {
        constexpr uint32_t RFC16 = (1U << 0);  ///< Frequency Comparison Value (b16) To generate the operating clock from the LOCOclock, this bit sets the comparison value of the 128-Hz clock cycle.
    }

    /// RFRL Register bits
    namespace rfrl_bits {
        constexpr uint32_t RFC = (16 << 0);  ///< Frequency Comparison Value(b15-b0) To generate the operating clock from the main clock, this bit sets the comparison value of the 128-Hz clock cycle.
    }

    /// RADJ Register bits
    namespace radj_bits {
        constexpr uint32_t PMADJ = (2 << 6);  ///< Plus-Minus
        constexpr uint32_t ADJ = (6 << 0);  ///< Adjustment Value These bits specify the adjustment value from the prescaler.
    }

    /// RTCCR%s Register bits
    namespace rtccr%s_bits {
        constexpr uint32_t TCNF = (2 << 4);  ///< Time Capture Noise Filter Control
        constexpr uint32_t TCST = (1U << 2);  ///< Time Capture Status
        constexpr uint32_t TCCT = (2 << 0);  ///< Time Capture Control
    }

    /// RSECCP%s Register bits
    namespace rseccp%s_bits {
        constexpr uint32_t SEC10 = (3 << 4);  ///< 10-Second Capture Capture value for the tens place of seconds
        constexpr uint32_t SEC1 = (4 << 0);  ///< 1-Second Capture Capture value for the ones place of seconds
    }

    /// BCNT0CP%s Register bits
    namespace bcnt0cp%s_bits {
        constexpr uint32_t BCNT0CP = (8 << 0);  ///< BCNT0CP is a read-only register that captures the BCNT0 value when a time capture event is detected.
    }

    /// RMINCP%s Register bits
    namespace rmincp%s_bits {
        constexpr uint32_t MIN10 = (3 << 4);  ///< 10-Minute Capture Capture value for the tens place of minutes
        constexpr uint32_t MIN1 = (4 << 0);  ///< 1-Minute Capture Capture value for the ones place of minutes
    }

    /// BCNT1CP%s Register bits
    namespace bcnt1cp%s_bits {
        constexpr uint32_t BCNT1CP = (8 << 0);  ///< BCNT1CP is a read-only register that captures the BCNT1 value when a time capture event is detected.
    }

    /// RHRCP%s Register bits
    namespace rhrcp%s_bits {
        constexpr uint32_t PM = (1U << 6);  ///< A.m./p.m. select for time counter setting.
        constexpr uint32_t HR10 = (2 << 4);  ///< 10-Minute Capture Capture value for the tens place of minutes
        constexpr uint32_t HR1 = (4 << 0);  ///< 1-Minute Capture Capture value for the ones place of minutes
    }

    /// BCNT2CP%s Register bits
    namespace bcnt2cp%s_bits {
        constexpr uint32_t BCNT2CP = (8 << 0);  ///< BCNT2CP is a read-only register that captures the BCNT2 value when a time capture event is detected.
    }

    /// RDAYCP%s Register bits
    namespace rdaycp%s_bits {
        constexpr uint32_t DATE10 = (2 << 4);  ///< 10-Day Capture Capture value for the tens place of minutes
        constexpr uint32_t DATE1 = (4 << 0);  ///< 1-Day Capture Capture value for the ones place of minutes
    }

    /// BCNT3CP%s Register bits
    namespace bcnt3cp%s_bits {
        constexpr uint32_t BCNT3CP = (8 << 0);  ///< BCNT3CP is a read-only register that captures the BCNT3 value when a time capture event is detected.
    }

    /// RMONCP%s Register bits
    namespace rmoncp%s_bits {
        constexpr uint32_t MON10 = (1U << 4);  ///< 10-Month Capture Capture value for the tens place of months
        constexpr uint32_t MON1 = (4 << 0);  ///< 1-Month Capture Capture value for the ones place of months
    }

}

// ============================================================================
// SSIE0 Peripheral
// ============================================================================

namespace ssie0 {
    /// Base addresses
    constexpr uint32_t SSIE0_BASE = 0x4004E000;

    /// SSIE0 Register structure
    struct Registers {
        volatile uint32_t SSICR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SSISR;  ///< Offset: 0x04 - Status Register
        volatile uint32_t SSIFCR;  ///< Offset: 0x10 - FIFO Control Register
        volatile uint32_t SSIFSR;  ///< Offset: 0x14 - FIFO Status Register
        volatile uint32_t SSIFTDR;  ///< Offset: 0x18 - Transmit FIFO Data Register
        volatile uint32_t SSIFRDR;  ///< Offset: 0x1C - Receive FIFO Data Register
        volatile uint32_t SSIOFR;  ///< Offset: 0x20 - Audio Format Register
        volatile uint32_t SSISCR;  ///< Offset: 0x24 - Status Control Register
    };

    /// Peripheral instances
    inline Registers* SSIE0 = reinterpret_cast<Registers*>(SSIE0_BASE);

    // Bit definitions
    /// SSICR Register bits
    namespace ssicr_bits {
        constexpr uint32_t CKS = (1U << 30);  ///< Oversampling Clock Select
        constexpr uint32_t TUIEN = (1U << 29);  ///< Transmit Underflow Interrupt Enable
        constexpr uint32_t TOIEN = (1U << 28);  ///< Transmit Overflow Interrupt Enable
        constexpr uint32_t RUIEN = (1U << 27);  ///< Receive Underflow Interrupt Enable
        constexpr uint32_t ROIEN = (1U << 26);  ///< Receive Overflow Interrupt Enable
        constexpr uint32_t IIEN = (1U << 25);  ///< Idle Mode Interrupt Enable
        constexpr uint32_t CHNL = (2 << 22);  ///< Channels
        constexpr uint32_t DWL = (3 << 19);  ///< Data Word Length
        constexpr uint32_t SWL = (3 << 16);  ///< System Word LengthSet the system word length to the bit clock frequency/2 fs.
        constexpr uint32_t SWSD = (1U << 14);  ///< Serial WS Direction NOTE: Only the following settings are allowed: (SCKD, SWSD) = (0, 0) and (1, 1). Other settings are prohibited.
        constexpr uint32_t SCKP = (1U << 13);  ///< Serial Bit Clock Polarity
        constexpr uint32_t SWSP = (1U << 12);  ///< Serial WS Polarity
        constexpr uint32_t SPDP = (1U << 11);  ///< Serial Padding Polarity
        constexpr uint32_t SDTA = (1U << 10);  ///< Serial Data Alignment
        constexpr uint32_t PDTA = (1U << 9);  ///< Parallel Data Alignment
        constexpr uint32_t DEL = (1U << 8);  ///< Serial Data Delay
        constexpr uint32_t CKDV = (4 << 4);  ///< Serial Oversampling Clock Division Ratio
        constexpr uint32_t MUEN = (1U << 3);  ///< Mute EnableNOTE: When this module is muted, the value of outputting serial data is rewritten to 0 but data transmission is not stopped. Write dummy data to the SSIFTDR not to generate a transmit underflow because the number of data in the transmit FIFO is decreasing.
        constexpr uint32_t TEN = (1U << 1);  ///< Transmit Enable
        constexpr uint32_t REN = (1U << 0);  ///< Receive Enable
    }

    /// SSISR Register bits
    namespace ssisr_bits {
        constexpr uint32_t TUIRQ = (1U << 29);  ///< Transmit Underflow Error Interrupt Status Flag NOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t TOIRQ = (1U << 28);  ///< Transmit Overflow Error Interrupt Status Flag NOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t RUIRQ = (1U << 27);  ///< Receive Underflow Error Interrupt Status Flag NOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t ROIRQ = (1U << 26);  ///< Receive Overflow Error Interrupt Status Flag NOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t IIRQ = (1U << 25);  ///< Idle Mode Interrupt Status Flag
        constexpr uint32_t TCHNO = (2 << 5);  ///< Transmit Channel Number
        constexpr uint32_t TSWNO = (1U << 4);  ///< Transmit Serial Word Number
        constexpr uint32_t RCHNO = (2 << 2);  ///< Receive Channel Number.These bits are read as 00b.
        constexpr uint32_t RSWNO = (1U << 1);  ///< Receive Serial Word Number
        constexpr uint32_t IDST = (1U << 0);  ///< Idle Mode Status Flag
    }

    /// SSIFCR Register bits
    namespace ssifcr_bits {
        constexpr uint32_t AUCKE = (1U << 31);  ///< Oversampling Clock Enable
        constexpr uint32_t SSIRST = (1U << 16);  ///< SSI soft ware reset
        constexpr uint32_t TTRG = (2 << 6);  ///< Transmit Data Trigger Number NOTE: The values in parenthesis are the number of empty stages in SSIFTDR at which the TDE flag is set.
        constexpr uint32_t RTRG = (2 << 4);  ///< Receive Data Trigger Number
        constexpr uint32_t TIE = (1U << 3);  ///< Transmit Interrupt Enable NOTE: TXI can be cleared by clearing either the TDE flag (see the description of the TDE bit for details) or TIE bit.
        constexpr uint32_t RIE = (1U << 2);  ///< Receive Interrupt Enable NOTE: RXI can be cleared by clearing either the RDF flag (see the description of the RDF bit for details) or RIE bit.
        constexpr uint32_t TFRST = (1U << 1);  ///< Transmit FIFO Data Register Reset
        constexpr uint32_t RFRST = (1U << 0);  ///< Receive FIFO Data Register Reset
    }

    /// SSIFSR Register bits
    namespace ssifsr_bits {
        constexpr uint32_t TDC = (4 << 24);  ///< Transmit Data Indicate Flag(Indicates the number of data units stored in SSIFTDR)
        constexpr uint32_t TDE = (1U << 16);  ///< Transmit Data Empty Flag NOTE: Since the SSIFTDR register is a 32-byte FIFO register, the maximum number of bytes that can be written to it while the TDE flag is 1 is 8 - TDC[3:0]. If writing data to the SSIFTDR register is continued after all the data is written, writing will be invalid and an overflow occurs.
        constexpr uint32_t RDC = (4 << 8);  ///< Receive Data Indicate Flag(Indicates the number of data units stored in SSIFRDR)
        constexpr uint32_t RDF = (1U << 0);  ///< Receive Data Full Flag NOTE: Since the SSIFRDR register is a 32-byte FIFO register, the maximum number of data bytes that can be read from it while the RDF flag is 1 is indicated in the RDC[3:0] flags. If reading data from the SSIFRDR register is continued after all the data is read, undefined values will be read.
    }

    /// SSIFTDR Register bits
    namespace ssiftdr_bits {
        constexpr uint32_t SSIFTDR = (32 << 0);  ///< SSIFTDR is a write-only FIFO register consisting of eight stages of 32-bit registers for storing data to be serially transmitted. NOTE: that when the SSIFTDR register is full of data (32 bytes), the next data cannot be written to it. If writing is attempted, it will be ignored and an overflow occurs.
    }

    /// SSIFRDR Register bits
    namespace ssifrdr_bits {
        constexpr uint32_t SSIFRDR = (32 << 0);  ///< SSIFRDR is a read-only FIFO register consisting of eight stages of 32-bit registers for storing serially received data.
    }

    /// SSIOFR Register bits
    namespace ssiofr_bits {
        constexpr uint32_t BCKASTP = (1U << 9);  ///< Whether to Enable Stopping BCK Output When SSIE is in Idle Status
        constexpr uint32_t LRCONT = (1U << 8);  ///< Whether to Enable LRCK/FS Continuation
        constexpr uint32_t OMOD = (2 << 0);  ///< Audio Format Select
    }

    /// SSISCR Register bits
    namespace ssiscr_bits {
        constexpr uint32_t TDES = (5 << 8);  ///< TDE Setting Condition Select
        constexpr uint32_t RDFS = (5 << 0);  ///< RDF Setting Condition Select
    }

}

// ============================================================================
// SSIE1 Peripheral
// ============================================================================

namespace ssie1 {
    /// Base addresses
    constexpr uint32_t SSIE1_BASE = 0x4004E100;

    /// SSIE1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SSIE1 = reinterpret_cast<Registers*>(SSIE1_BASE);

}

// ============================================================================
// SRCRAM Peripheral
// ============================================================================

namespace srcram {
    /// Base addresses
    constexpr uint32_t SRCRAM_BASE = 0x40048000;

    /// SRCRAM Register structure
    struct Registers {
        volatile uint32_t SRCFCTR[%s];  ///< Offset: 0x00 - Filter Coefficient Table [%s]
    };

    /// Peripheral instances
    inline Registers* SRCRAM = reinterpret_cast<Registers*>(SRCRAM_BASE);

    // Bit definitions
    /// SRCFCTR[%s] Register bits
    namespace srcfctr[%s]_bits {
        constexpr uint32_t SRCFCOE = (22 << 0);  ///< Stores a filter coefficient value.
    }

}

// ============================================================================
// SRC Peripheral
// ============================================================================

namespace src {
    /// Base addresses
    constexpr uint32_t SRC_BASE = 0x4004DFF0;

    /// SRC Register structure
    struct Registers {
        volatile uint32_t SRCID;  ///< Offset: 0x00 - Input Data Register
        volatile uint32_t SRCOD;  ///< Offset: 0x04 - Output Data Register
        volatile uint32_t SRCIDCTRL;  ///< Offset: 0x08 - Input Data Control Register
        volatile uint32_t SRCODCTRL;  ///< Offset: 0x0A - Output Data Control Register
        volatile uint32_t SRCCTRL;  ///< Offset: 0x0C - Control Register
        volatile uint32_t SRCSTAT;  ///< Offset: 0x0E - Status Register
    };

    /// Peripheral instances
    inline Registers* SRC = reinterpret_cast<Registers*>(SRC_BASE);

    // Bit definitions
    /// SRCID Register bits
    namespace srcid_bits {
        constexpr uint32_t SRCID = (32 << 0);  ///< SRCID is a 32-bit writ-only register that is used to input the data before sampling rate conversion. All the bits are read as 0.
    }

    /// SRCOD Register bits
    namespace srcod_bits {
        constexpr uint32_t SRCOD = (32 << 0);  ///< SRCOD is a 32-bit read-only register used to output the data after sampling rate conversion. The data in the 16-stage output data FIFO is read through SRCOD. When the number of data in the output data FIFO is zero after the start of conversion, the value previously read is read again.
    }

    /// SRCIDCTRL Register bits
    namespace srcidctrl_bits {
        constexpr uint32_t IED = (1U << 9);  ///< Input Data Endian
        constexpr uint32_t IEN = (1U << 8);  ///< Input FIFO Empty Interrupt Enable
        constexpr uint32_t IFTRG = (2 << 0);  ///< Input FIFO Data Triggering Number
    }

    /// SRCODCTRL Register bits
    namespace srcodctrl_bits {
        constexpr uint32_t OCH = (1U << 10);  ///< Output Data Channel Exchange
        constexpr uint32_t OED = (1U << 9);  ///< Output Data Endian
        constexpr uint32_t OEN = (1U << 8);  ///< Output Data FIFO Full Interrupt Enable
        constexpr uint32_t OFTRG = (2 << 0);  ///< Output FIFO Data Trigger Number
    }

    /// SRCCTRL Register bits
    namespace srcctrl_bits {
        constexpr uint32_t FICRAE = (1U << 15);  ///< Filter Coefficient Table Access Enable
        constexpr uint32_t CEEN = (1U << 13);  ///< Conversion End Interrupt Enable
        constexpr uint32_t SRCEN = (1U << 12);  ///< Module Enable
        constexpr uint32_t UDEN = (1U << 11);  ///< Output Data FIFO Underflow Interrupt Enable
        constexpr uint32_t OVEN = (1U << 10);  ///< Output Data FIFO Overwrite Interrupt Enable
        constexpr uint32_t FL = (1U << 9);  ///< Internal Work Memory Flush
        constexpr uint32_t CL = (1U << 8);  ///< Internal Work Memory Clear
        constexpr uint32_t IFS = (4 << 4);  ///< Input Sampling Rate
        constexpr uint32_t OFS = (3 << 0);  ///< Output Sampling Rate
    }

    /// SRCSTAT Register bits
    namespace srcstat_bits {
        constexpr uint32_t OFDN = (5 << 11);  ///< Output FIFO Data Count
        constexpr uint32_t IFDN = (4 << 7);  ///< Input FIFO Data Count
        constexpr uint32_t CEF = (1U << 5);  ///< Conversion End Flag
        constexpr uint32_t FLF = (1U << 4);  ///< Flush Processing Status Flag
        constexpr uint32_t UDF = (1U << 3);  ///< Output FIFO Underflow Interrupt Request Flag
        constexpr uint32_t OVF = (1U << 2);  ///< Output Data FIFO Overwrite Interrupt Request Flag
        constexpr uint32_t IINT = (1U << 1);  ///< Input Data FIFO Empty Interrupt Request Flag
        constexpr uint32_t OINT = (1U << 0);  ///< Output Data FIFO Full Interrupt Request Flag
    }

}

// ============================================================================
// ICU Peripheral
// ============================================================================

namespace icu {
    /// Base addresses
    constexpr uint32_t ICU_BASE = 0x40006000;

    /// ICU Register structure
    struct Registers {
        volatile uint32_t IRQCR%s;  ///< Offset: 0x00 - IRQ Control Register %s
        volatile uint32_t NMISR;  ///< Offset: 0x140 - Non-Maskable Interrupt Status Register
        volatile uint32_t NMIER;  ///< Offset: 0x120 - Non-Maskable Interrupt Enable Register
        volatile uint32_t NMICLR;  ///< Offset: 0x130 - Non-Maskable Interrupt Status Clear Register
        volatile uint32_t NMICR;  ///< Offset: 0x100 - NMI Pin Interrupt Control Register
        volatile uint32_t IELSR%s;  ///< Offset: 0x300 - INT Event Link Setting Register %s
        volatile uint32_t DELSR%s;  ///< Offset: 0x280 - DMAC Event Link Setting Register %s
        volatile uint32_t SELSR0;  ///< Offset: 0x200 - SYS Event Link Setting Register
        volatile uint32_t WUPEN;  ///< Offset: 0x1A0 - Wake Up interrupt enable register
    };

    /// Peripheral instances
    inline Registers* ICU = reinterpret_cast<Registers*>(ICU_BASE);

    // Bit definitions
    /// IRQCR%s Register bits
    namespace irqcr%s_bits {
        constexpr uint32_t FLTEN = (1U << 7);  ///< IRQ Digital Filter Enable
        constexpr uint32_t FCLKSEL = (2 << 4);  ///< IRQ Digital Filter Sampling Clock
        constexpr uint32_t IRQMD = (2 << 0);  ///< IRQ Detection Sense Select
    }

    /// NMISR Register bits
    namespace nmisr_bits {
        constexpr uint32_t SPEST = (1U << 12);  ///< MPU Stack Error Interrupt Status Flag
        constexpr uint32_t BUSMST = (1U << 11);  ///< MPU Bus Master Error Interrupt Status Flag
        constexpr uint32_t BUSSST = (1U << 10);  ///< MPU Bus Slave Error Interrupt Status Flag
        constexpr uint32_t RECCST = (1U << 9);  ///< RAM ECC Error Interrupt Status Flag
        constexpr uint32_t RPEST = (1U << 8);  ///< RAM Parity Error Interrupt Status Flag
        constexpr uint32_t NMIST = (1U << 7);  ///< NMI Status Flag
        constexpr uint32_t OSTST = (1U << 6);  ///< Oscillation Stop Detection Interrupt Status Flag
        constexpr uint32_t LVD2ST = (1U << 3);  ///< Voltage-Monitoring 2 Interrupt Status Flag
        constexpr uint32_t LVD1ST = (1U << 2);  ///< Voltage-Monitoring 1 Interrupt Status Flag
        constexpr uint32_t WDTST = (1U << 1);  ///< WDT Underflow/Refresh Error Status Flag
        constexpr uint32_t IWDTST = (1U << 0);  ///< IWDT Underflow/Refresh Error Status Flag
    }

    /// NMIER Register bits
    namespace nmier_bits {
        constexpr uint32_t SPEEN = (1U << 12);  ///< MPU Stack Error Interrupt Enable
        constexpr uint32_t BUSMEN = (1U << 11);  ///< MPU Bus Master Error Interrupt Enable
        constexpr uint32_t BUSSEN = (1U << 10);  ///< MPU Bus Slave Error Interrupt Enable
        constexpr uint32_t RECCEN = (1U << 9);  ///< RAM ECC Error Interrupt Enable
        constexpr uint32_t RPEEN = (1U << 8);  ///< RAM Parity Error Interrupt Enable
        constexpr uint32_t NMIEN = (1U << 7);  ///< NMI Pin Interrupt Enable
        constexpr uint32_t OSTEN = (1U << 6);  ///< Oscillation Stop Detection Interrupt Enable
        constexpr uint32_t LVD2EN = (1U << 3);  ///< Voltage-Monitoring 2 Interrupt Enable
        constexpr uint32_t LVD1EN = (1U << 2);  ///< Voltage-Monitoring 1 Interrupt Enable
        constexpr uint32_t WDTEN = (1U << 1);  ///< WDT Underflow/Refresh Error Interrupt Enable
        constexpr uint32_t IWDTEN = (1U << 0);  ///< IWDT Underflow/Refresh Error Interrupt Enable
    }

    /// NMICLR Register bits
    namespace nmiclr_bits {
        constexpr uint32_t SPECLR = (1U << 12);  ///< SPEST Clear
        constexpr uint32_t BUSMCLR = (1U << 11);  ///< BUSMST Clear
        constexpr uint32_t BUSSCLR = (1U << 10);  ///< BUSSST Clear
        constexpr uint32_t RECCCLR = (1U << 9);  ///< RECCST Clear
        constexpr uint32_t RPECLR = (1U << 8);  ///< RPEST Clear
        constexpr uint32_t NMICLR = (1U << 7);  ///< NMIST Clear
        constexpr uint32_t OSTCLR = (1U << 6);  ///< OSTST Clear
        constexpr uint32_t LVD2CLR = (1U << 3);  ///< LVD2ST Clear
        constexpr uint32_t LVD1CLR = (1U << 2);  ///< LVD1ST Clear
        constexpr uint32_t WDTCLR = (1U << 1);  ///< WDTST Clear
        constexpr uint32_t IWDTCLR = (1U << 0);  ///< IWDTST Clear
    }

    /// NMICR Register bits
    namespace nmicr_bits {
        constexpr uint32_t NFLTEN = (1U << 7);  ///< NMI Digital Filter Enable
        constexpr uint32_t NFCLKSEL = (2 << 4);  ///< NMI Digital Filter Sampling Clock
        constexpr uint32_t NMIMD = (1U << 0);  ///< NMI Detection Set
    }

    /// IELSR%s Register bits
    namespace ielsr%s_bits {
        constexpr uint32_t DTCE = (1U << 24);  ///< DTC Activation Enable
        constexpr uint32_t IR = (1U << 16);  ///< Interrupt Status Flag
        constexpr uint32_t IELS = (9 << 0);  ///< Event selection to NVIC
    }

    /// DELSR%s Register bits
    namespace delsr%s_bits {
        constexpr uint32_t IR = (1U << 16);  ///< Interrupt Status Flag for DMAC
        constexpr uint32_t DELS = (9 << 0);  ///< DMAC Event Link Select
    }

    /// SELSR0 Register bits
    namespace selsr0_bits {
        constexpr uint32_t SELS = (9 << 0);  ///< SYS Event Link Select
    }

    /// WUPEN Register bits
    namespace wupen_bits {
        constexpr uint32_t IIC0WUPEN = (1U << 31);  ///< IIC0 address match interrupt S/W standby returns enable bit
        constexpr uint32_t AGT1CBWUPEN = (1U << 30);  ///< AGT1 compare match B interrupt S/W standby returns enable bit
        constexpr uint32_t AGT1CAWUPEN = (1U << 29);  ///< AGT1 compare match A interrupt S/W standby returns enable bit
        constexpr uint32_t AGT1UDWUPEN = (1U << 28);  ///< AGT1 underflow interrupt S/W standby returns enable bit
        constexpr uint32_t USBFSWUPEN = (1U << 27);  ///< USBFS interrupt S/W standby returns enable bit
        constexpr uint32_t USBHSWUPEN = (1U << 26);  ///< USBHS interrupt S/W standby returns enable bit
        constexpr uint32_t RTCPRDWUPEN = (1U << 25);  ///< RCT period interrupt S/W standby returns enable bit
        constexpr uint32_t RTCALMWUPEN = (1U << 24);  ///< RTC alarm interrupt S/W standby returns enable bit
        constexpr uint32_t ACMPHS0WUPEN = (1U << 22);  ///< ACMPHS0 interrupt S/W standby returns enable bit
        constexpr uint32_t LVD2WUPEN = (1U << 19);  ///< LVD2 interrupt S/W standby returns enable bit
        constexpr uint32_t LVD1WUPEN = (1U << 18);  ///< LVD1 interrupt S/W standby returns enable bit
        constexpr uint32_t KEYWUPEN = (1U << 17);  ///< Key interrupt S/W standby returns enable bit
        constexpr uint32_t IWDTWUPEN = (1U << 16);  ///< IWDT interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN15 = (1U << 15);  ///< IRQ15 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN14 = (1U << 14);  ///< IRQ14 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN13 = (1U << 13);  ///< IRQ13 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN12 = (1U << 12);  ///< IRQ12 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN11 = (1U << 11);  ///< IRQ11 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN10 = (1U << 10);  ///< IRQ10 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN9 = (1U << 9);  ///< IRQ9 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN8 = (1U << 8);  ///< IRQ8 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN7 = (1U << 7);  ///< IRQ7 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN6 = (1U << 6);  ///< IRQ6 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN5 = (1U << 5);  ///< IRQ5 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN4 = (1U << 4);  ///< IRQ4 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN3 = (1U << 3);  ///< IRQ3 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN2 = (1U << 2);  ///< IRQ2 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN1 = (1U << 1);  ///< IRQ1 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN0 = (1U << 0);  ///< IRQ0 interrupt S/W standby returns enable bit
    }

}

// ============================================================================
// SRAM Peripheral
// ============================================================================

namespace sram {
    /// Base addresses
    constexpr uint32_t SRAM_BASE = 0x40002000;

    /// SRAM Register structure
    struct Registers {
        volatile uint32_t PARIOAD;  ///< Offset: 0x00 - SRAM Parity Error Operation After Detection Register
        volatile uint32_t SRAMPRCR;  ///< Offset: 0x04 - SRAM Protection Register
        volatile uint32_t SRAMWTSC;  ///< Offset: 0x08 - RAM Wait State Control Register
        volatile uint32_t ECCMODE;  ///< Offset: 0xC0 - ECCRAM Operating Mode Control Register
        volatile uint32_t ECC2STS;  ///< Offset: 0xC1 - ECCRAM 2-Bit Error Status Register
        volatile uint32_t ECC1STSEN;  ///< Offset: 0xC2 - ECCRAM 1-Bit Error Information Update Enable Register
        volatile uint32_t ECC1STS;  ///< Offset: 0xC3 - ECCRAM 1-Bit Error Status Register
        volatile uint32_t ECCPRCR;  ///< Offset: 0xC4 - ECCRAM Protection Register
        volatile uint32_t ECCETST;  ///< Offset: 0xD4 - ECC Test Control Register
        volatile uint32_t ECCOAD;  ///< Offset: 0xD8 - RAM ECC Error Operation After Detection Register
    };

    /// Peripheral instances
    inline Registers* SRAM = reinterpret_cast<Registers*>(SRAM_BASE);

    // Bit definitions
    /// PARIOAD Register bits
    namespace parioad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after Detection
    }

    /// SRAMPRCR Register bits
    namespace sramprcr_bits {
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
        constexpr uint32_t SRAMPRCR = (1U << 0);  ///< Register Write Control
    }

    /// SRAMWTSC Register bits
    namespace sramwtsc_bits {
        constexpr uint32_t SRAM1WTEN = (1U << 3);  ///< SRAM1 Wait Enable
        constexpr uint32_t SRAM0WTEN = (1U << 2);  ///< SRAM0 Wait Enable
        constexpr uint32_t ECCRAMRDWTEN = (1U << 1);  ///< ECCRAM Read wait enable
    }

    /// ECCMODE Register bits
    namespace eccmode_bits {
        constexpr uint32_t ECCMOD = (2 << 0);  ///< ECC Operating Mode Select
    }

    /// ECC2STS Register bits
    namespace ecc2sts_bits {
        constexpr uint32_t ECC2ERR = (1U << 0);  ///< ECC 2-Bit Error Status
    }

    /// ECC1STSEN Register bits
    namespace ecc1stsen_bits {
        constexpr uint32_t E1STSEN = (1U << 0);  ///< ECC 1-Bit Error Information Update Enable
    }

    /// ECC1STS Register bits
    namespace ecc1sts_bits {
        constexpr uint32_t ECC1ERR = (1U << 0);  ///< ECC 1-Bit Error Status
    }

    /// ECCPRCR Register bits
    namespace eccprcr_bits {
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
        constexpr uint32_t ECCPRCR = (1U << 0);  ///< ECCRAMETST Register Write Control
    }

    /// ECCETST Register bits
    namespace eccetst_bits {
        constexpr uint32_t TSTBYP = (1U << 0);  ///< ECC Bypass Select
    }

    /// ECCOAD Register bits
    namespace eccoad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after Detection
    }

}

// ============================================================================
// AGT0 Peripheral
// ============================================================================

namespace agt0 {
    /// Base addresses
    constexpr uint32_t AGT0_BASE = 0x40084000;

    /// AGT0 Register structure
    struct Registers {
        volatile uint32_t AGT;  ///< Offset: 0x00 - AGT Counter Register
        volatile uint32_t AGTCMA;  ///< Offset: 0x02 - AGT Compare Match A Register
        volatile uint32_t AGTCMB;  ///< Offset: 0x04 - AGT Compare Match B Register
        volatile uint32_t AGTCR;  ///< Offset: 0x08 - AGT Control Register
        volatile uint32_t AGTMR1;  ///< Offset: 0x09 - AGT Mode Register 1
        volatile uint32_t AGTMR2;  ///< Offset: 0x0A - AGT Mode Register 2
        volatile uint32_t AGTIOC;  ///< Offset: 0x0C - AGT I/O Control Register
        volatile uint32_t AGTISR;  ///< Offset: 0x0D - AGT Event Pin Select Register
        volatile uint32_t AGTCMSR;  ///< Offset: 0x0E - AGT Compare Match Function Select Register
        volatile uint32_t AGTIOSEL;  ///< Offset: 0x0F - AGT Pin Select Register
    };

    /// Peripheral instances
    inline Registers* AGT0 = reinterpret_cast<Registers*>(AGT0_BASE);

    // Bit definitions
    /// AGT Register bits
    namespace agt_bits {
        constexpr uint32_t AGT = (16 << 0);  ///< 16bit counter and reload registerNOTE : When 1 is written to the TSTOP bit in the AGTCRn register, the 16-bit counter is forcibly stopped and set to FFFFH.
    }

    /// AGTCMA Register bits
    namespace agtcma_bits {
        constexpr uint32_t AGTCMA = (16 << 0);  ///< AGT Compare Match A RegisterNOTE : When 1 is written to the TSTOP bit in the AGTCRn register, set to FFFFH
    }

    /// AGTCMB Register bits
    namespace agtcmb_bits {
        constexpr uint32_t AGTCMB = (16 << 0);  ///< AGT Compare Match B RegisterNOTE : When 1 is written to the TSTOP bit in the AGTCR register, set to FFFFH
    }

    /// AGTCR Register bits
    namespace agtcr_bits {
        constexpr uint32_t TCMBF = (1U << 7);  ///< AGT compare match B flag
        constexpr uint32_t TCMAF = (1U << 6);  ///< AGT compare match A flag
        constexpr uint32_t TUNDF = (1U << 5);  ///< AGT underflow flag
        constexpr uint32_t TEDGF = (1U << 4);  ///< Active edge judgement flag
        constexpr uint32_t TSTOP = (1U << 2);  ///< AGT count forced stop
        constexpr uint32_t TCSTF = (1U << 1);  ///< AGT count status flag
        constexpr uint32_t TSTART = (1U << 0);  ///< AGT count start
    }

    /// AGTMR1 Register bits
    namespace agtmr1_bits {
        constexpr uint32_t TCK = (3 << 4);  ///< AGT count source select
        constexpr uint32_t TEDGPL = (1U << 3);  ///< AGTIO edge polarity select
        constexpr uint32_t TMOD = (3 << 0);  ///< AGT operating mode select
    }

    /// AGTMR2 Register bits
    namespace agtmr2_bits {
        constexpr uint32_t LPM = (1U << 7);  ///< AGT Low Power Mode
        constexpr uint32_t CKS = (3 << 0);  ///< fsub/LOCO count source clock frequency division ratio select
    }

    /// AGTIOC Register bits
    namespace agtioc_bits {
        constexpr uint32_t TIOGT = (2 << 6);  ///< AGTIO count control
        constexpr uint32_t TIPF = (2 << 4);  ///< AGTIO input filter select
        constexpr uint32_t TOE = (1U << 2);  ///< AGTO output enable
        constexpr uint32_t TEDGSEL = (1U << 0);  ///< I/O polarity switchFunction varies depending on the operating mode.
    }

    /// AGTISR Register bits
    namespace agtisr_bits {
        constexpr uint32_t EEPS = (1U << 2);  ///< AGTEE polarty selection
    }

    /// AGTCMSR Register bits
    namespace agtcmsr_bits {
        constexpr uint32_t TOPOLB = (1U << 6);  ///< AGTOB polarity select
        constexpr uint32_t TOEB = (1U << 5);  ///< AGTOB output enable
        constexpr uint32_t TCMEB = (1U << 4);  ///< Compare match B register enable
        constexpr uint32_t TOPOLA = (1U << 2);  ///< AGTOA polarity select
        constexpr uint32_t TOEA = (1U << 1);  ///< AGTOA output enable
        constexpr uint32_t TCMEA = (1U << 0);  ///< Compare match A register enable
    }

    /// AGTIOSEL Register bits
    namespace agtiosel_bits {
        constexpr uint32_t TIES = (1U << 4);  ///< AGTIO input enable
        constexpr uint32_t SEL = (2 << 0);  ///< AGTIO pin select
    }

}

// ============================================================================
// AGT1 Peripheral
// ============================================================================

namespace agt1 {
    /// Base addresses
    constexpr uint32_t AGT1_BASE = 0x40084100;

    /// AGT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AGT1 = reinterpret_cast<Registers*>(AGT1_BASE);

}

// ============================================================================
// FCACHE Peripheral
// ============================================================================

namespace fcache {
    /// Base addresses
    constexpr uint32_t FCACHE_BASE = 0x4001C000;

    /// FCACHE Register structure
    struct Registers {
        volatile uint32_t FCACHEE;  ///< Offset: 0x100 - Flash Cache Enable Register
        volatile uint32_t FCACHEIV;  ///< Offset: 0x104 - Flash Cache Invalidate Register
        volatile uint32_t FLWT;  ///< Offset: 0x11C - Flash Wait Cycle Register
    };

    /// Peripheral instances
    inline Registers* FCACHE = reinterpret_cast<Registers*>(FCACHE_BASE);

    // Bit definitions
    /// FCACHEE Register bits
    namespace fcachee_bits {
        constexpr uint32_t FCACHEEN = (1U << 0);  ///< FCACHE Enable
    }

    /// FCACHEIV Register bits
    namespace fcacheiv_bits {
        constexpr uint32_t FCACHEIV = (1U << 0);  ///< FCACHE Invalidation
    }

    /// FLWT Register bits
    namespace flwt_bits {
        constexpr uint32_t FLWT = (3 << 0);  ///< Flash Wait Cycle
    }

}

// ============================================================================
// BUS Peripheral
// ============================================================================

namespace bus {
    /// Base addresses
    constexpr uint32_t BUS_BASE = 0x40003000;

    /// BUS Register structure
    struct Registers {
        volatile uint32_t CS0CR;  ///< Offset: 0x802 - CS0 Control Register
        volatile uint32_t CS%sCR;  ///< Offset: 0x812 - CS%s Control Register
        volatile uint32_t CS%sREC;  ///< Offset: 0x80A - CS%s Recovery Cycle Register
        volatile uint32_t CSRECEN;  ///< Offset: 0x880 - CS Recovery Cycle Insertion Enable Register
        volatile uint32_t CS%sMOD;  ///< Offset: 0x02 - CS%s Mode Register
        volatile uint32_t CS%sWCR1;  ///< Offset: 0x04 - CS%s Wait Control Register 1
        volatile uint32_t CS%sWCR2;  ///< Offset: 0x08 - CS%s Wait Control Register 2
        volatile uint32_t SDCCR;  ///< Offset: 0xC00 - SDC Control Register
        volatile uint32_t SDCMOD;  ///< Offset: 0xC01 - SDC Mode Register
        volatile uint32_t SDAMOD;  ///< Offset: 0xC02 - SDRAM Access Mode Register
        volatile uint32_t SDSELF;  ///< Offset: 0xC10 - SDRAM Self-Refresh Control Register
        volatile uint32_t SDRFCR;  ///< Offset: 0xC14 - SDRAM Refresh Control Register
        volatile uint32_t SDRFEN;  ///< Offset: 0xC16 - SDRAM Auto-Refresh Control Register
        volatile uint32_t SDICR;  ///< Offset: 0xC20 - SDRAM Initialization Sequence Control Register
        volatile uint32_t SDIR;  ///< Offset: 0xC24 - SDRAM Initialization Register
        volatile uint32_t SDADR;  ///< Offset: 0xC40 - SDRAM Address Register
        volatile uint32_t SDTR;  ///< Offset: 0xC44 - SDRAM Timing Register
        volatile uint32_t SDMOD;  ///< Offset: 0xC48 - SDRAM Mode Register
        volatile uint32_t SDSR;  ///< Offset: 0xC50 - SDRAM Status Register
        volatile uint32_t BUS%sERRADD;  ///< Offset: 0x1800 - Bus Error Address Register %s
        volatile uint32_t BUS%sERRSTAT;  ///< Offset: 0x1804 - Bus Error Status Register %s
        volatile uint32_t BUSMCNT%s;  ///< Offset: 0x1010 - Master Bus Control Register %s
        volatile uint32_t BUSMCNTSYS;  ///< Offset: 0x1008 - Master Bus Control Register SYS
        volatile uint32_t BUSMCNTDMA;  ///< Offset: 0x100C - Master Bus Control Register DMA
        volatile uint32_t BUSSCNT%s;  ///< Offset: 0x1130 - Slave Bus Control Register %s
        volatile uint32_t BUSSCNTMBIU;  ///< Offset: 0x1108 - Slave Bus Control Register MBIU
    };

    /// Peripheral instances
    inline Registers* BUS = reinterpret_cast<Registers*>(BUS_BASE);

    // Bit definitions
    /// CS0CR Register bits
    namespace cs0cr_bits {
        constexpr uint32_t MPXEN = (1U << 12);  ///< Address/Data Multiplexed I/O Interface Select
        constexpr uint32_t EMODE = (1U << 8);  ///< Endian Mode
        constexpr uint32_t BSIZE = (2 << 4);  ///< External Bus Width Select
        constexpr uint32_t EXENB = (1U << 0);  ///< Operation Enable
    }

    /// CS%sCR Register bits
    namespace cs%scr_bits {
        constexpr uint32_t MPXEN = (1U << 12);  ///< Address/Data Multiplexed I/O Interface Select
        constexpr uint32_t EMODE = (1U << 8);  ///< Endian Mode
        constexpr uint32_t BSIZE = (2 << 4);  ///< External Bus Width Select
        constexpr uint32_t EXENB = (1U << 0);  ///< Operation Enable
    }

    /// CS%sREC Register bits
    namespace cs%srec_bits {
        constexpr uint32_t WRCV = (4 << 8);  ///< Write Recovery
        constexpr uint32_t RRCV = (4 << 0);  ///< Read Recovery
    }

    /// CSRECEN Register bits
    namespace csrecen_bits {
        constexpr uint32_t RCVENM7 = (1U << 15);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 7
        constexpr uint32_t RCVENM6 = (1U << 14);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 6
        constexpr uint32_t RCVENM5 = (1U << 13);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 5
        constexpr uint32_t RCVENM4 = (1U << 12);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 4
        constexpr uint32_t RCVENM3 = (1U << 11);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 3
        constexpr uint32_t RCVENM2 = (1U << 10);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 2
        constexpr uint32_t RCVENM1 = (1U << 9);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 1
        constexpr uint32_t RCVENM0 = (1U << 8);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 0
        constexpr uint32_t RCVEN7 = (1U << 7);  ///< Separate Bus Recovery Cycle Insertion Enable 7
        constexpr uint32_t RCVEN6 = (1U << 6);  ///< Separate Bus Recovery Cycle Insertion Enable 6
        constexpr uint32_t RCVEN5 = (1U << 5);  ///< Separate Bus Recovery Cycle Insertion Enable 5
        constexpr uint32_t RCVEN4 = (1U << 4);  ///< Separate Bus Recovery Cycle Insertion Enable 4
        constexpr uint32_t RCVEN3 = (1U << 3);  ///< Separate Bus Recovery Cycle Insertion Enable 3
        constexpr uint32_t RCVEN2 = (1U << 2);  ///< Separate Bus Recovery Cycle Insertion Enable 2
        constexpr uint32_t RCVEN1 = (1U << 1);  ///< Separate Bus Recovery Cycle Insertion Enable 1
        constexpr uint32_t RCVEN0 = (1U << 0);  ///< Separate Bus Recovery Cycle Insertion Enable 0
    }

    /// CS%sMOD Register bits
    namespace cs%smod_bits {
        constexpr uint32_t PRMOD = (1U << 15);  ///< Page Read Access Mode Select
        constexpr uint32_t PWENB = (1U << 9);  ///< Page Write Access Enable
        constexpr uint32_t PRENB = (1U << 8);  ///< Page Read Access Enable
        constexpr uint32_t EWENB = (1U << 3);  ///< External Wait Enable
        constexpr uint32_t WRMOD = (1U << 0);  ///< Write Access Mode Select
    }

    /// CS%sWCR1 Register bits
    namespace cs%swcr1_bits {
        constexpr uint32_t CSRWAIT = (5 << 24);  ///< Normal Read Cycle Wait Select
        constexpr uint32_t CSWWAIT = (5 << 16);  ///< Normal Write Cycle Wait Select
        constexpr uint32_t CSPRWAIT = (3 << 8);  ///< Page Read Cycle Wait SelectNOTE: The CSPRWAIT value is valid only when the PRENB bit in CSnMOD is set to 1.
        constexpr uint32_t CSPWWAIT = (3 << 0);  ///< Page Write Cycle Wait SelectNOTE: The CSPWWAIT value is valid only when the PWENB bit in CSnMOD is set to 1.
    }

    /// CS%sWCR2 Register bits
    namespace cs%swcr2_bits {
        constexpr uint32_t CSON = (3 << 28);  ///< CS Assert Wait Select
        constexpr uint32_t WDON = (3 << 24);  ///< Write Data Output Wait Select
        constexpr uint32_t WRON = (3 << 20);  ///< WR Assert Wait Select
        constexpr uint32_t RDON = (3 << 16);  ///< RD Assert Wait Select
        constexpr uint32_t AWAIT = (2 << 12);  ///< Address Cycle Wait Select
        constexpr uint32_t WDOFF = (3 << 8);  ///< Write Data Output Extension Cycle Select
        constexpr uint32_t CSWOFF = (3 << 4);  ///< Write-Access CS Extension Cycle Select
        constexpr uint32_t CSROFF = (3 << 0);  ///< Read-Access CS Extension Cycle Select
    }

    /// SDCCR Register bits
    namespace sdccr_bits {
        constexpr uint32_t BSIZE = (2 << 4);  ///< SDRAM Bus Width Select
        constexpr uint32_t EXENB = (1U << 0);  ///< Operation Enable
    }

    /// SDCMOD Register bits
    namespace sdcmod_bits {
        constexpr uint32_t EMODE = (1U << 0);  ///< Endian Mode
    }

    /// SDAMOD Register bits
    namespace sdamod_bits {
        constexpr uint32_t BE = (1U << 0);  ///< Continuous Access Enable
    }

    /// SDSELF Register bits
    namespace sdself_bits {
        constexpr uint32_t SFEN = (1U << 0);  ///< SDRAM Self-Refresh Enable
    }

    /// SDRFCR Register bits
    namespace sdrfcr_bits {
        constexpr uint32_t REFW = (4 << 12);  ///< Auto-Refresh Cycle/ Self-Refresh Clearing Cycle Count Setting. ( REFW+1 Cycles )
        constexpr uint32_t RFC = (12 << 0);  ///< Auto-Refresh Request Interval Setting
    }

    /// SDRFEN Register bits
    namespace sdrfen_bits {
        constexpr uint32_t RFEN = (1U << 0);  ///< Auto-Refresh Operation Enable
    }

    /// SDICR Register bits
    namespace sdicr_bits {
        constexpr uint32_t INIRQ = (1U << 0);  ///< Initialization Sequence Start
    }

    /// SDIR Register bits
    namespace sdir_bits {
        constexpr uint32_t PRC = (3 << 8);  ///< Initialization Precharge Cycle Count (PRC+3 cycles)
        constexpr uint32_t ARFC = (4 << 4);  ///< Initialization Auto-Refresh Count
        constexpr uint32_t ARFI = (4 << 0);  ///< Initialization Auto-Refresh Interval (ARFI+3 cycles )
    }

    /// SDADR Register bits
    namespace sdadr_bits {
        constexpr uint32_t MXC = (2 << 0);  ///< Address Multiplex Select
    }

    /// SDTR Register bits
    namespace sdtr_bits {
        constexpr uint32_t RAS = (3 << 16);  ///< Row Active Interval
        constexpr uint32_t RCD = (2 << 12);  ///< Row Column Latency ( RCD+1 cycles )
        constexpr uint32_t RP = (3 << 9);  ///< Row Precharge Interval ( RP+1 cycles )
        constexpr uint32_t WR = (1U << 8);  ///< Write Recovery Interval
        constexpr uint32_t CL = (3 << 0);  ///< SDRAMC Column Latency
    }

    /// SDMOD Register bits
    namespace sdmod_bits {
        constexpr uint32_t MR = (15 << 0);  ///< Mode Register SettingWriting to these bits: Mode register set command is issued.
    }

    /// SDSR Register bits
    namespace sdsr_bits {
        constexpr uint32_t SRFST = (1U << 4);  ///< Self-Refresh Transition/Recovery Status
        constexpr uint32_t INIST = (1U << 3);  ///< Initialization Status
        constexpr uint32_t MRSST = (1U << 0);  ///< Mode Register Setting Status
    }

    /// BUS%sERRADD Register bits
    namespace bus%serradd_bits {
        constexpr uint32_t BERAD = (32 << 0);  ///< Bus Error AddressWhen a bus error occurs, It stores an error address.
    }

    /// BUS%sERRSTAT Register bits
    namespace bus%serrstat_bits {
        constexpr uint32_t ERRSTAT = (1U << 7);  ///< Bus Error StatusWhen bus error assert, error flag occurs.
        constexpr uint32_t ACCSTAT = (1U << 0);  ///< Error access statusThe status at the time of the error
    }

    /// BUSMCNT%s Register bits
    namespace busmcnt%s_bits {
        constexpr uint32_t IERES = (1U << 15);  ///< Ignore Error Responses
    }

    /// BUSMCNTSYS Register bits
    namespace busmcntsys_bits {
        constexpr uint32_t IERES = (1U << 15);  ///< Ignore Error Responses
    }

    /// BUSMCNTDMA Register bits
    namespace busmcntdma_bits {
        constexpr uint32_t IERES = (1U << 15);  ///< Ignore Error Responses
    }

    /// BUSSCNT%s Register bits
    namespace busscnt%s_bits {
        constexpr uint32_t EWRES = (1U << 8);  ///< Early Write ResponseWhether the next write request is accepted or not until a response for the write transaction comes back.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration MethodSpecify the priority between groups
    }

    /// BUSSCNTMBIU Register bits
    namespace busscntmbiu_bits {
        constexpr uint32_t EWRES = (1U << 8);  ///< Early Write ResponseWhether the next write request is accepted or not until a response for the write transaction comes back.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration MethodSpecify the priority between groups
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC12_BASE = 0x4005E000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DADR%s;  ///< Offset: 0x00 - D/A Data Register %s
        volatile uint32_t DACR;  ///< Offset: 0x04 - D/A Control Register
        volatile uint32_t DADPR;  ///< Offset: 0x05 - DADRm Format Select Register
        volatile uint32_t DAADSCR;  ///< Offset: 0x06 - D/A-A/D Synchronous Start Control Register
        volatile uint32_t DAAMPCR;  ///< Offset: 0x08 - D/A Output Amplifier Control Register
        volatile uint32_t DAASWCR;  ///< Offset: 0x101C - D/A Amplifier Stabilization Wait Control Register
    };

    /// Peripheral instances
    inline Registers* DAC12 = reinterpret_cast<Registers*>(DAC12_BASE);

    // Bit definitions
    /// DADR%s Register bits
    namespace dadr%s_bits {
        constexpr uint32_t DADR = (16 << 0);  ///< D/A Data RegisterNOTE: When DADPR.DPSEL = 0, the high-order 4 bits are fixed to 0: right justified format. When DADPR.DPSEL = 1, the low-order 4 bits are fixed to 0: left justified format.
    }

    /// DACR Register bits
    namespace dacr_bits {
        constexpr uint32_t DAOE1 = (1U << 7);  ///< D/A Output Enable 1
        constexpr uint32_t DAOE0 = (1U << 6);  ///< D/A Output Enable 0
        constexpr uint32_t DAE = (1U << 5);  ///< D/A Enable
    }

    /// DADPR Register bits
    namespace dadpr_bits {
        constexpr uint32_t DPSEL = (1U << 7);  ///< DADRm Format Select
    }

    /// DAADSCR Register bits
    namespace daadscr_bits {
        constexpr uint32_t DAADST = (1U << 7);  ///< D/A-A/D Synchronous Conversion
    }

    /// DAAMPCR Register bits
    namespace daampcr_bits {
        constexpr uint32_t DAAMP1 = (1U << 7);  ///< Amplifier Control 1
        constexpr uint32_t DAAMP0 = (1U << 6);  ///< Amplifier Control 0
    }

    /// DAASWCR Register bits
    namespace daaswcr_bits {
        constexpr uint32_t DAASW1 = (1U << 7);  ///< D/A Amplifier Stabilization Wait 1
        constexpr uint32_t DAASW0 = (1U << 6);  ///< D/A Amplifier Stabilization Wait 0
    }

}

// ============================================================================
// AMI Peripheral
// ============================================================================

namespace ami {
    /// Base addresses
    constexpr uint32_t AMI_BASE = 0x4005F000;

    /// AMI Register structure
    struct Registers {
        volatile uint32_t DAADUSR;  ///< Offset: 0xC0 - D/A A/D Synchronous Unit Select Register
    };

    /// Peripheral instances
    inline Registers* AMI = reinterpret_cast<Registers*>(AMI_BASE);

    // Bit definitions
    /// DAADUSR Register bits
    namespace daadusr_bits {
        constexpr uint32_t AMADSEL1 = (1U << 1);  ///< A/D Unit 1 Select
    }

}

// ============================================================================
// POEG Peripheral
// ============================================================================

namespace poeg {
    /// Base addresses
    constexpr uint32_t POEG_BASE = 0x40042000;

    /// POEG Register structure
    struct Registers {
        volatile uint32_t POEGG%s;  ///< Offset: 0x00 - POEG Group %s Setting Register
    };

    /// Peripheral instances
    inline Registers* POEG = reinterpret_cast<Registers*>(POEG_BASE);

    // Bit definitions
    /// POEGG%s Register bits
    namespace poegg%s_bits {
        constexpr uint32_t NFCS = (2 << 30);  ///< Noise Filter Clock Select
        constexpr uint32_t NFEN = (1U << 29);  ///< Noise Filter Enable
        constexpr uint32_t INV = (1U << 28);  ///< GTETRG Input Reverse
        constexpr uint32_t ST = (1U << 16);  ///< GTETRG Input Status Flag
        constexpr uint32_t CDRE5 = (1U << 13);  ///< Comparator Disable Request Enable 5Note: Can be modified only once after a reset.
        constexpr uint32_t CDRE4 = (1U << 12);  ///< Comparator Disable Request Enable 4Note: Can be modified only once after a reset.
        constexpr uint32_t CDRE3 = (1U << 11);  ///< Comparator Disable Request Enable 3Note: Can be modified only once after a reset.
        constexpr uint32_t CDRE2 = (1U << 10);  ///< Comparator Disable Request Enable 2Note: Can be modified only once after a reset.
        constexpr uint32_t CDRE1 = (1U << 9);  ///< Comparator Disable Request Enable 1Note: Can be modified only once after a reset.
        constexpr uint32_t CDRE0 = (1U << 8);  ///< Comparator Disable Request Enable 0Note: Can be modified only once after a reset.
        constexpr uint32_t OSTPE = (1U << 6);  ///< Oscillation Stop Detection EnableNote: Can be modified only once after a reset.
        constexpr uint32_t IOCE = (1U << 5);  ///< Enable for GPT Output-Disable RequestNote: Can be modified only once after a reset.
        constexpr uint32_t PIDE = (1U << 4);  ///< Port Input Detection EnableNote: Can be modified only once after a reset.
        constexpr uint32_t SSF = (1U << 3);  ///< Software Stop Flag
        constexpr uint32_t OSTPF = (1U << 2);  ///< Oscillation Stop Detection Flag
        constexpr uint32_t IOCF = (1U << 1);  ///< Real Time Overcurrent Detection Flag
        constexpr uint32_t PIDF = (1U << 0);  ///< Port Input Detection Flag
    }

}

// ============================================================================
// IRDA Peripheral
// ============================================================================

namespace irda {
    /// Base addresses
    constexpr uint32_t IRDA_BASE = 0x40070F00;

    /// IRDA Register structure
    struct Registers {
        volatile uint32_t IRCR;  ///< Offset: 0x00 - IrDA Control Register
    };

    /// Peripheral instances
    inline Registers* IRDA = reinterpret_cast<Registers*>(IRDA_BASE);

    // Bit definitions
    /// IRCR Register bits
    namespace ircr_bits {
        constexpr uint32_t IRE = (1U << 7);  ///< IrDA Enable
        constexpr uint32_t IRTXINV = (1U << 3);  ///< IRTXD Polarity Switching
        constexpr uint32_t IRRXINV = (1U << 2);  ///< IRRXD Polarity Switching
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN0_BASE = 0x40050000;
    constexpr uint32_t CAN1_BASE = 0x40051000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MB%s_ID;  ///< Offset: 0x200 - Mailbox Register
        volatile uint32_t MB%s_DL;  ///< Offset: 0x204 - Mailbox Register
        volatile uint32_t MB%s_D0;  ///< Offset: 0x206 - Mailbox Register
        volatile uint32_t MB%s_D1;  ///< Offset: 0x207 - Mailbox Register
        volatile uint32_t MB%s_D2;  ///< Offset: 0x208 - Mailbox Register
        volatile uint32_t MB%s_D3;  ///< Offset: 0x209 - Mailbox Register
        volatile uint32_t MB%s_D4;  ///< Offset: 0x20A - Mailbox Register
        volatile uint32_t MB%s_D5;  ///< Offset: 0x20B - Mailbox Register
        volatile uint32_t MB%s_D6;  ///< Offset: 0x20C - Mailbox Register
        volatile uint32_t MB%s_D7;  ///< Offset: 0x20D - Mailbox Register
        volatile uint32_t MB%s_TS;  ///< Offset: 0x20E - Mailbox Register
        volatile uint32_t MKR[%s];  ///< Offset: 0x400 - Mask Register
        volatile uint32_t FIDCR%s;  ///< Offset: 0x420 - FIFO Received ID Compare Registers
        volatile uint32_t MKIVLR;  ///< Offset: 0x428 - Mask Invalid Register
        volatile uint32_t MIER;  ///< Offset: 0x42C - Mailbox Interrupt Enable Register
        volatile uint32_t MIER_FIFO;  ///< Offset: 0x42C - Mailbox Interrupt Enable Register for FIFO Mailbox Mode
        volatile uint32_t MCTL_TX[%s];  ///< Offset: 0x820 - Message Control Register for Transmit
        volatile uint32_t MCTL_RX[%s];  ///< Offset: 0x820 - Message Control Register for Receive
        volatile uint32_t CTLR;  ///< Offset: 0x840 - Control Register
        volatile uint32_t STR;  ///< Offset: 0x842 - Status Register
        volatile uint32_t BCR;  ///< Offset: 0x844 - Bit Configuration Register
        volatile uint32_t RFCR;  ///< Offset: 0x848 - Receive FIFO Control Register
        volatile uint32_t RFPCR;  ///< Offset: 0x849 - Receive FIFO Pointer Control Register
        volatile uint32_t TFCR;  ///< Offset: 0x84A - Transmit FIFO Control Register
        volatile uint32_t TFPCR;  ///< Offset: 0x84B - Transmit FIFO Pointer Control Register
        volatile uint32_t EIER;  ///< Offset: 0x84C - Error Interrupt Enable Register
        volatile uint32_t EIFR;  ///< Offset: 0x84D - Error Interrupt Factor Judge Register
        volatile uint32_t RECR;  ///< Offset: 0x84E - Receive Error Count Register
        volatile uint32_t TECR;  ///< Offset: 0x84F - Transmit Error Count Register
        volatile uint32_t ECSR;  ///< Offset: 0x850 - Error Code Store Register
        volatile uint32_t CSSR;  ///< Offset: 0x851 - Channel Search Support Register
        volatile uint32_t MSSR;  ///< Offset: 0x852 - Mailbox Search Status Register
        volatile uint32_t MSMR;  ///< Offset: 0x853 - Mailbox Search Mode Register
        volatile uint32_t TSR;  ///< Offset: 0x854 - Time Stamp Register
        volatile uint32_t AFSR;  ///< Offset: 0x856 - Acceptance Filter Support Register
        volatile uint32_t TCR;  ///< Offset: 0x858 - Test Control Register
    };

    /// Peripheral instances
    inline Registers* CAN0 = reinterpret_cast<Registers*>(CAN0_BASE);
    inline Registers* CAN1 = reinterpret_cast<Registers*>(CAN1_BASE);

    // Bit definitions
    /// MB%s_ID Register bits
    namespace mb%s_id_bits {
        constexpr uint32_t IDE = (1U << 31);  ///< ID Extension
        constexpr uint32_t RTR = (1U << 30);  ///< Remote Transmission Request
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID
    }

    /// MB%s_DL Register bits
    namespace mb%s_dl_bits {
        constexpr uint32_t DLC = (4 << 0);  ///< Data Length Code
    }

    /// MB%s_D0 Register bits
    namespace mb%s_d0_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< Data Bytes 0.DATA0 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D1 Register bits
    namespace mb%s_d1_bits {
        constexpr uint32_t DATA1 = (8 << 0);  ///< Data Bytes 1DATA1 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D2 Register bits
    namespace mb%s_d2_bits {
        constexpr uint32_t DATA2 = (8 << 0);  ///< Data Bytes 2DATA2 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D3 Register bits
    namespace mb%s_d3_bits {
        constexpr uint32_t DATA3 = (8 << 0);  ///< Data Bytes 3DATA3 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D4 Register bits
    namespace mb%s_d4_bits {
        constexpr uint32_t DATA4 = (8 << 0);  ///< Data Bytes 4DATA4 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D5 Register bits
    namespace mb%s_d5_bits {
        constexpr uint32_t DATA5 = (8 << 0);  ///< Data Bytes 5DATA5 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D6 Register bits
    namespace mb%s_d6_bits {
        constexpr uint32_t DATA6 = (8 << 0);  ///< Data Bytes 6DATA6 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_D7 Register bits
    namespace mb%s_d7_bits {
        constexpr uint32_t DATA7 = (8 << 0);  ///< Data Bytes 7DATA7 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB%s_TS Register bits
    namespace mb%s_ts_bits {
        constexpr uint32_t TSH = (8 << 8);  ///< Time Stamp Lower ByteBits TSH[7:0] store the counter value of the time stamp when received messages are stored in the mailbox.
        constexpr uint32_t TSL = (8 << 0);  ///< Time Stamp Higher ByteBits TSL[7:0] store the counter value of the time stamp when received messages are stored in the mailbox.
    }

    /// MKR[%s] Register bits
    namespace mkr[%s]_bits {
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID
    }

    /// FIDCR%s Register bits
    namespace fidcr%s_bits {
        constexpr uint32_t IDE = (1U << 31);  ///< ID Extension
        constexpr uint32_t RTR = (1U << 30);  ///< Remote Transmission Request
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID
    }

    /// MKIVLR Register bits
    namespace mkivlr_bits {
        constexpr uint32_t MB31 = (1U << 31);  ///< mailbox 31 Mask Invalid
        constexpr uint32_t MB30 = (1U << 30);  ///< mailbox 30 Mask Invalid
        constexpr uint32_t MB29 = (1U << 29);  ///< mailbox 29 Mask Invalid
        constexpr uint32_t MB28 = (1U << 28);  ///< mailbox 28 Mask Invalid
        constexpr uint32_t MB27 = (1U << 27);  ///< mailbox 27 Mask Invalid
        constexpr uint32_t MB26 = (1U << 26);  ///< mailbox 26 Mask Invalid
        constexpr uint32_t MB25 = (1U << 25);  ///< mailbox 25 Mask Invalid
        constexpr uint32_t MB24 = (1U << 24);  ///< mailbox 24 Mask Invalid
        constexpr uint32_t MB23 = (1U << 23);  ///< mailbox 23 Mask Invalid
        constexpr uint32_t MB22 = (1U << 22);  ///< mailbox 22 Mask Invalid
        constexpr uint32_t MB21 = (1U << 21);  ///< mailbox 21 Mask Invalid
        constexpr uint32_t MB20 = (1U << 20);  ///< mailbox 20 Mask Invalid
        constexpr uint32_t MB19 = (1U << 19);  ///< mailbox 19 Mask Invalid
        constexpr uint32_t MB18 = (1U << 18);  ///< mailbox 18 Mask Invalid
        constexpr uint32_t MB17 = (1U << 17);  ///< mailbox 17 Mask Invalid
        constexpr uint32_t MB16 = (1U << 16);  ///< mailbox 16 Mask Invalid
        constexpr uint32_t MB15 = (1U << 15);  ///< mailbox 15 Mask Invalid
        constexpr uint32_t MB14 = (1U << 14);  ///< mailbox 14 Mask Invalid
        constexpr uint32_t MB13 = (1U << 13);  ///< mailbox 13 Mask Invalid
        constexpr uint32_t MB12 = (1U << 12);  ///< mailbox 12 Mask Invalid
        constexpr uint32_t MB11 = (1U << 11);  ///< mailbox 11 Mask Invalid
        constexpr uint32_t MB10 = (1U << 10);  ///< mailbox 10 Mask Invalid
        constexpr uint32_t MB9 = (1U << 9);  ///< mailbox 9 Mask Invalid
        constexpr uint32_t MB8 = (1U << 8);  ///< mailbox 8 Mask Invalid
        constexpr uint32_t MB7 = (1U << 7);  ///< mailbox 7 Mask Invalid
        constexpr uint32_t MB6 = (1U << 6);  ///< mailbox 6 Mask Invalid
        constexpr uint32_t MB5 = (1U << 5);  ///< mailbox 5 Mask Invalid
        constexpr uint32_t MB4 = (1U << 4);  ///< mailbox 4 Mask Invalid
        constexpr uint32_t MB3 = (1U << 3);  ///< mailbox 3 Mask Invalid
        constexpr uint32_t MB2 = (1U << 2);  ///< mailbox 2 Mask Invalid
        constexpr uint32_t MB1 = (1U << 1);  ///< mailbox 1 Mask Invalid
        constexpr uint32_t MB0 = (1U << 0);  ///< mailbox 0 Mask Invalid
    }

    /// MIER Register bits
    namespace mier_bits {
        constexpr uint32_t MB31 = (1U << 31);  ///< mailbox 31 Interrupt Enable
        constexpr uint32_t MB30 = (1U << 30);  ///< mailbox 30 Interrupt Enable
        constexpr uint32_t MB29 = (1U << 29);  ///< mailbox 29 Interrupt Enable
        constexpr uint32_t MB28 = (1U << 28);  ///< mailbox 28 Interrupt Enable
        constexpr uint32_t MB27 = (1U << 27);  ///< mailbox 27 Interrupt Enable
        constexpr uint32_t MB26 = (1U << 26);  ///< mailbox 26 Interrupt Enable
        constexpr uint32_t MB25 = (1U << 25);  ///< mailbox 25 Interrupt Enable
        constexpr uint32_t MB24 = (1U << 24);  ///< mailbox 24 Interrupt Enable
        constexpr uint32_t MB23 = (1U << 23);  ///< mailbox 23 Interrupt Enable
        constexpr uint32_t MB22 = (1U << 22);  ///< mailbox 22 Interrupt Enable
        constexpr uint32_t MB21 = (1U << 21);  ///< mailbox 21 Interrupt Enable
        constexpr uint32_t MB20 = (1U << 20);  ///< mailbox 20 Interrupt Enable
        constexpr uint32_t MB19 = (1U << 19);  ///< mailbox 19 Interrupt Enable
        constexpr uint32_t MB18 = (1U << 18);  ///< mailbox 18 Interrupt Enable
        constexpr uint32_t MB17 = (1U << 17);  ///< mailbox 17 Interrupt Enable
        constexpr uint32_t MB16 = (1U << 16);  ///< mailbox 16 Interrupt Enable
        constexpr uint32_t MB15 = (1U << 15);  ///< mailbox 15 Interrupt Enable
        constexpr uint32_t MB14 = (1U << 14);  ///< mailbox 14 Interrupt Enable
        constexpr uint32_t MB13 = (1U << 13);  ///< mailbox 13 Interrupt Enable
        constexpr uint32_t MB12 = (1U << 12);  ///< mailbox 12 Interrupt Enable
        constexpr uint32_t MB11 = (1U << 11);  ///< mailbox 11 Interrupt Enable
        constexpr uint32_t MB10 = (1U << 10);  ///< mailbox 10 Interrupt Enable
        constexpr uint32_t MB9 = (1U << 9);  ///< mailbox 9 Interrupt Enable
        constexpr uint32_t MB8 = (1U << 8);  ///< mailbox 8 Interrupt Enable
        constexpr uint32_t MB7 = (1U << 7);  ///< mailbox 7 Interrupt Enable
        constexpr uint32_t MB6 = (1U << 6);  ///< mailbox 6 Interrupt Enable
        constexpr uint32_t MB5 = (1U << 5);  ///< mailbox 5 Interrupt Enable
        constexpr uint32_t MB4 = (1U << 4);  ///< mailbox 4 Interrupt Enable
        constexpr uint32_t MB3 = (1U << 3);  ///< mailbox 3 Interrupt Enable
        constexpr uint32_t MB2 = (1U << 2);  ///< mailbox 2 Interrupt Enable
        constexpr uint32_t MB1 = (1U << 1);  ///< mailbox 1 Interrupt Enable
        constexpr uint32_t MB0 = (1U << 0);  ///< mailbox 0 Interrupt Enable
    }

    /// MIER_FIFO Register bits
    namespace mier_fifo_bits {
        constexpr uint32_t MB29 = (1U << 29);  ///< Receive FIFO Interrupt Generation Timing Control
        constexpr uint32_t MB28 = (1U << 28);  ///< Receive FIFO Interrupt Enable
        constexpr uint32_t MB25 = (1U << 25);  ///< Transmit FIFO Interrupt Generation Timing Control
        constexpr uint32_t MB24 = (1U << 24);  ///< Transmit FIFO Interrupt Enable
        constexpr uint32_t MB23 = (1U << 23);  ///< mailbox 23 Interrupt Enable
        constexpr uint32_t MB22 = (1U << 22);  ///< mailbox 22 Interrupt Enable
        constexpr uint32_t MB21 = (1U << 21);  ///< mailbox 21 Interrupt Enable
        constexpr uint32_t MB20 = (1U << 20);  ///< mailbox 20 Interrupt Enable
        constexpr uint32_t MB19 = (1U << 19);  ///< mailbox 19 Interrupt Enable
        constexpr uint32_t MB18 = (1U << 18);  ///< mailbox 18 Interrupt Enable
        constexpr uint32_t MB17 = (1U << 17);  ///< mailbox 17 Interrupt Enable
        constexpr uint32_t MB16 = (1U << 16);  ///< mailbox 16 Interrupt Enable
        constexpr uint32_t MB15 = (1U << 15);  ///< mailbox 15 Interrupt Enable
        constexpr uint32_t MB14 = (1U << 14);  ///< mailbox 14 Interrupt Enable
        constexpr uint32_t MB13 = (1U << 13);  ///< mailbox 13 Interrupt Enable
        constexpr uint32_t MB12 = (1U << 12);  ///< mailbox 12 Interrupt Enable
        constexpr uint32_t MB11 = (1U << 11);  ///< mailbox 11 Interrupt Enable
        constexpr uint32_t MB10 = (1U << 10);  ///< mailbox 10 Interrupt Enable
        constexpr uint32_t MB9 = (1U << 9);  ///< mailbox 9 Interrupt Enable
        constexpr uint32_t MB8 = (1U << 8);  ///< mailbox 8 Interrupt Enable
        constexpr uint32_t MB7 = (1U << 7);  ///< mailbox 7 Interrupt Enable
        constexpr uint32_t MB6 = (1U << 6);  ///< mailbox 6 Interrupt Enable
        constexpr uint32_t MB5 = (1U << 5);  ///< mailbox 5 Interrupt Enable
        constexpr uint32_t MB4 = (1U << 4);  ///< mailbox 4 Interrupt Enable
        constexpr uint32_t MB3 = (1U << 3);  ///< mailbox 3 Interrupt Enable
        constexpr uint32_t MB2 = (1U << 2);  ///< mailbox 2 Interrupt Enable
        constexpr uint32_t MB1 = (1U << 1);  ///< mailbox 1 Interrupt Enable
        constexpr uint32_t MB0 = (1U << 0);  ///< mailbox 0 Interrupt Enable
    }

    /// MCTL_TX[%s] Register bits
    namespace mctl_tx[%s]_bits {
        constexpr uint32_t TRMREQ = (1U << 7);  ///< Transmit Mailbox Request
        constexpr uint32_t RECREQ = (1U << 6);  ///< Receive Mailbox Request
        constexpr uint32_t ONESHOT = (1U << 4);  ///< One-Shot Enable
        constexpr uint32_t TRMABT = (1U << 2);  ///< Transmission Abort Complete Flag (Transmit mailbox setting enabled)
        constexpr uint32_t TRMACTIVE = (1U << 1);  ///< Transmission-in-Progress Status Flag (Transmit mailbox setting enabled)
        constexpr uint32_t SENTDATA = (1U << 0);  ///< Transmission Complete Flag
    }

    /// MCTL_RX[%s] Register bits
    namespace mctl_rx[%s]_bits {
        constexpr uint32_t TRMREQ = (1U << 7);  ///< Transmit Mailbox Request
        constexpr uint32_t RECREQ = (1U << 6);  ///< Receive Mailbox Request
        constexpr uint32_t ONESHOT = (1U << 4);  ///< One-Shot Enable
        constexpr uint32_t MSGLOST = (1U << 2);  ///< Message Lost Flag(Receive mailbox setting enabled)
        constexpr uint32_t INVALDATA = (1U << 1);  ///< Reception-in-Progress Status Flag (Receive mailbox setting enabled)
        constexpr uint32_t NEWDATA = (1U << 0);  ///< Reception Complete Flag
    }

    /// CTLR Register bits
    namespace ctlr_bits {
        constexpr uint32_t RBOC = (1U << 13);  ///< Forcible Return From Bus-Off
        constexpr uint32_t BOM = (2 << 11);  ///< Bus-Off Recovery Mode by a program request
        constexpr uint32_t SLPM = (1U << 10);  ///< CAN Sleep Mode
        constexpr uint32_t CANM = (2 << 8);  ///< CAN Operating Mode Select
        constexpr uint32_t TSPS = (2 << 6);  ///< Time Stamp Prescaler Select
        constexpr uint32_t TSRC = (1U << 5);  ///< Time Stamp Counter Reset Command
        constexpr uint32_t TPM = (1U << 4);  ///< Transmission Priority Mode Select
        constexpr uint32_t MLM = (1U << 3);  ///< Message Lost Mode Select
        constexpr uint32_t IDFM = (2 << 1);  ///< ID Format Mode Select
        constexpr uint32_t MBM = (1U << 0);  ///< CAN Mailbox Mode Select
    }

    /// STR Register bits
    namespace str_bits {
        constexpr uint32_t RECST = (1U << 14);  ///< Receive Status Flag (receiver)
        constexpr uint32_t TRMST = (1U << 13);  ///< Transmit Status Flag (transmitter)
        constexpr uint32_t BOST = (1U << 12);  ///< Bus-Off Status Flag
        constexpr uint32_t EPST = (1U << 11);  ///< Error-Passive Status Flag
        constexpr uint32_t SLPST = (1U << 10);  ///< CAN Sleep Status Flag
        constexpr uint32_t HLTST = (1U << 9);  ///< CAN Halt Status Flag
        constexpr uint32_t RSTST = (1U << 8);  ///< CAN Reset Status Flag
        constexpr uint32_t EST = (1U << 7);  ///< Error Status Flag
        constexpr uint32_t TABST = (1U << 6);  ///< Transmission Abort Status Flag
        constexpr uint32_t FMLST = (1U << 5);  ///< FIFO Mailbox Message Lost Status Flag
        constexpr uint32_t NMLST = (1U << 4);  ///< Normal Mailbox Message Lost Status Flag
        constexpr uint32_t TFST = (1U << 3);  ///< Transmit FIFO Status Flag
        constexpr uint32_t RFST = (1U << 2);  ///< Receive FIFO Status Flag
        constexpr uint32_t SDST = (1U << 1);  ///< SENTDATA Status Flag
        constexpr uint32_t NDST = (1U << 0);  ///< NEWDATA Status Flag
    }

    /// BCR Register bits
    namespace bcr_bits {
        constexpr uint32_t TSEG1 = (4 << 28);  ///< Time Segment 1 Control
        constexpr uint32_t BRP = (10 << 16);  ///< Prescaler Division Ratio Select . These bits set the frequency of the CAN communication clock (fCANCLK).
        constexpr uint32_t SJW = (2 << 12);  ///< Resynchronization Jump Width Control
        constexpr uint32_t TSEG2 = (3 << 8);  ///< Time Segment 2 Control
        constexpr uint32_t CCLKS = (1U << 0);  ///< CAN Clock Source Selection
    }

    /// RFCR Register bits
    namespace rfcr_bits {
        constexpr uint32_t RFEST = (1U << 7);  ///< Receive FIFO Empty Status Flag
        constexpr uint32_t RFWST = (1U << 6);  ///< Receive FIFO Buffer Warning Status Flag
        constexpr uint32_t RFFST = (1U << 5);  ///< Receive FIFO Full Status Flag
        constexpr uint32_t RFMLF = (1U << 4);  ///< Receive FIFO Message Lost Flag
        constexpr uint32_t RFUST = (3 << 1);  ///< Receive FIFO Unread Message Number Status
        constexpr uint32_t RFE = (1U << 0);  ///< Receive FIFO Enable
    }

    /// RFPCR Register bits
    namespace rfpcr_bits {
        constexpr uint32_t RFPCR = (8 << 0);  ///< The CPU-side pointer for the receive FIFO is incremented by writing FFh to RFPCR.
    }

    /// TFCR Register bits
    namespace tfcr_bits {
        constexpr uint32_t TFEST = (1U << 7);  ///< Transmit FIFO Empty Status
        constexpr uint32_t TFFST = (1U << 6);  ///< Transmit FIFO Full Status
        constexpr uint32_t TFUST = (3 << 1);  ///< Transmit FIFO Unsent Message Number Status
        constexpr uint32_t TFE = (1U << 0);  ///< Transmit FIFO Enable
    }

    /// TFPCR Register bits
    namespace tfpcr_bits {
        constexpr uint32_t TFPCR = (8 << 0);  ///< The CPU-side pointer for the transmit FIFO is incremented by writing FFh to TFPCR.
    }

    /// EIER Register bits
    namespace eier_bits {
        constexpr uint32_t BLIE = (1U << 7);  ///< Bus Lock Interrupt Enable
        constexpr uint32_t OLIE = (1U << 6);  ///< Overload Frame Transmit Interrupt Enable
        constexpr uint32_t ORIE = (1U << 5);  ///< Overrun Interrupt Enable
        constexpr uint32_t BORIE = (1U << 4);  ///< Bus-Off Recovery Interrupt Enable
        constexpr uint32_t BOEIE = (1U << 3);  ///< Bus-Off Entry Interrupt Enable
        constexpr uint32_t EPIE = (1U << 2);  ///< Error-Passive Interrupt Enable
        constexpr uint32_t EWIE = (1U << 1);  ///< Error-Warning Interrupt Enable
        constexpr uint32_t BEIE = (1U << 0);  ///< Bus Error Interrupt Enable
    }

    /// EIFR Register bits
    namespace eifr_bits {
        constexpr uint32_t BLIF = (1U << 7);  ///< Bus Lock Detect Flag
        constexpr uint32_t OLIF = (1U << 6);  ///< Overload Frame Transmission Detect Flag
        constexpr uint32_t ORIF = (1U << 5);  ///< Receive Overrun Detect Flag
        constexpr uint32_t BORIF = (1U << 4);  ///< Bus-Off Recovery Detect Flag
        constexpr uint32_t BOEIF = (1U << 3);  ///< Bus-Off Entry Detect Flag
        constexpr uint32_t EPIF = (1U << 2);  ///< Error-Passive Detect Flag
        constexpr uint32_t EWIF = (1U << 1);  ///< Error-Warning Detect Flag
        constexpr uint32_t BEIF = (1U << 0);  ///< Bus Error Detect Flag
    }

    /// RECR Register bits
    namespace recr_bits {
        constexpr uint32_t RECR = (8 << 0);  ///< Receive error count functionRECR increments or decrements the counter value according to the error status of the CAN module during reception.
    }

    /// TECR Register bits
    namespace tecr_bits {
        constexpr uint32_t TECR = (8 << 0);  ///< Transmit error count functionTECR increments or decrements the counter value according to the error status of the CAN module during transmission.
    }

    /// ECSR Register bits
    namespace ecsr_bits {
        constexpr uint32_t EDPM = (1U << 7);  ///< Error Display Mode Select
        constexpr uint32_t ADEF = (1U << 6);  ///< ACK Delimiter Error Flag
        constexpr uint32_t BE0F = (1U << 5);  ///< Bit Error (dominant) Flag
        constexpr uint32_t BE1F = (1U << 4);  ///< Bit Error (recessive) Flag
        constexpr uint32_t CEF = (1U << 3);  ///< CRC Error Flag
        constexpr uint32_t AEF = (1U << 2);  ///< ACK Error Flag
        constexpr uint32_t FEF = (1U << 1);  ///< Form Error Flag
        constexpr uint32_t SEF = (1U << 0);  ///< Stuff Error Flag
    }

    /// CSSR Register bits
    namespace cssr_bits {
        constexpr uint32_t CSSR = (8 << 0);  ///< When the value for the channel search is input, the channel number is output to MSSR.
    }

    /// MSSR Register bits
    namespace mssr_bits {
        constexpr uint32_t SEST = (1U << 7);  ///< Search Result Status
        constexpr uint32_t MBNST = (5 << 0);  ///< Search Result Mailbox Number Status These bits output the smallest mailbox number that is searched in each mode of MSMR.
    }

    /// MSMR Register bits
    namespace msmr_bits {
        constexpr uint32_t MBSM = (2 << 0);  ///< Mailbox Search Mode Select
    }

    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (16 << 0);  ///< Free-running counter value for the time stamp function
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t AFSR = (16 << 0);  ///< After the standard ID of a received message is written, the value converted for data table search can be read.
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TSTM = (2 << 1);  ///< CAN Test Mode Select
        constexpr uint32_t TSTE = (1U << 0);  ///< CAN Test Mode Enable
    }

}

// ============================================================================
// PDC Peripheral
// ============================================================================

namespace pdc {
    /// Base addresses
    constexpr uint32_t PDC_BASE = 0x40094000;

    /// PDC Register structure
    struct Registers {
        volatile uint32_t PCCR0;  ///< Offset: 0x00 - PDC Control Register 0
        volatile uint32_t PCCR1;  ///< Offset: 0x04 - PDC Control Register 1
        volatile uint32_t PCSR;  ///< Offset: 0x08 - PDC Status Register
        volatile uint32_t PCMONR;  ///< Offset: 0x0C - PDC Pin Monitor Register
        volatile uint32_t PCDR;  ///< Offset: 0x10 - PDC Receive Data Register
        volatile uint32_t VCR;  ///< Offset: 0x14 - Vertical Capture Register
        volatile uint32_t HCR;  ///< Offset: 0x18 - Horizontal Capture Register
    };

    /// Peripheral instances
    inline Registers* PDC = reinterpret_cast<Registers*>(PDC_BASE);

    // Bit definitions
    /// PCCR0 Register bits
    namespace pccr0_bits {
        constexpr uint32_t EDS = (1U << 14);  ///< Endian Select
        constexpr uint32_t PCKDIV = (3 << 11);  ///< PCKO Frequency Division Ratio Select
        constexpr uint32_t PCKOE = (1U << 10);  ///< PCKO Output Enable
        constexpr uint32_t HERIE = (1U << 9);  ///< Horizontal Byte Number Setting Error Interrupt Enable
        constexpr uint32_t VERIE = (1U << 8);  ///< Vertical Line Number Setting Error Interrupt Enable
        constexpr uint32_t UDRIE = (1U << 7);  ///< Underrun Interrupt Enable
        constexpr uint32_t OVIE = (1U << 6);  ///< Overrun Interrupt Enable
        constexpr uint32_t FEIE = (1U << 5);  ///< Frame End Interrupt Enable
        constexpr uint32_t DFIE = (1U << 4);  ///< Receive Data Ready Interrupt Enable
        constexpr uint32_t PRST = (1U << 3);  ///< PDC Reset
        constexpr uint32_t HPS = (1U << 2);  ///< HSYNC Signal Polarity Select
        constexpr uint32_t VPS = (1U << 1);  ///< VSYNC Signal Polarity Select
        constexpr uint32_t PCKE = (1U << 0);  ///< Channel 0 GTCNT Count Clear
    }

    /// PCCR1 Register bits
    namespace pccr1_bits {
        constexpr uint32_t PCE = (1U << 0);  ///< PDC Operation Enable
    }

    /// PCSR Register bits
    namespace pcsr_bits {
        constexpr uint32_t HERF = (1U << 6);  ///< Horizontal Byte Number Setting Error Flag
        constexpr uint32_t VERF = (1U << 5);  ///< Vertical Line Number Setting Error Flag
        constexpr uint32_t UDRF = (1U << 4);  ///< Underrun Flag
        constexpr uint32_t OVRF = (1U << 3);  ///< Overrun Flag
        constexpr uint32_t FEF = (1U << 2);  ///< Frame End Flag
        constexpr uint32_t FEMPF = (1U << 1);  ///< FIFO Empty Flag
        constexpr uint32_t FBSY = (1U << 0);  ///< Frame Busy Flag
    }

    /// PCMONR Register bits
    namespace pcmonr_bits {
        constexpr uint32_t HSYNC = (1U << 1);  ///< HSYNC Signal Status Flag
        constexpr uint32_t VSYNC = (1U << 0);  ///< VSYNC Signal Status Flag
    }

    /// PCDR Register bits
    namespace pcdr_bits {
        constexpr uint32_t PCDR = (32 << 0);  ///< The PDC includes a 32-bit-wide, 22-stage FIFO for the storage of captured data. The PCDR register is a 4-byte space to which the FIFO is mapped, and four bytes of data are read from the PCDR register at a time.
    }

    /// VCR Register bits
    namespace vcr_bits {
        constexpr uint32_t VSZ = (12 << 16);  ///< Vertical Capture Size Number of lines to be captured.
        constexpr uint32_t VST = (12 << 0);  ///< Vertical Capture Start Line PositionNumber of the line where capture is to start.
    }

    /// HCR Register bits
    namespace hcr_bits {
        constexpr uint32_t HSZ = (12 << 16);  ///< Horizontal Capture Size Number of bytes to capture horizontally.
        constexpr uint32_t HST = (12 << 0);  ///< Horizontal Capture Start Byte Position Horizontal position in bytes where capture is to start.
    }

}

// ============================================================================
// MMF Peripheral
// ============================================================================

namespace mmf {
    /// Base addresses
    constexpr uint32_t MMF_BASE = 0x40001000;

    /// MMF Register structure
    struct Registers {
        volatile uint32_t MMSFR;  ///< Offset: 0x00 - MemMirror Special Function Register
        volatile uint32_t MMEN;  ///< Offset: 0x04 - MemMirror Enable Register
    };

    /// Peripheral instances
    inline Registers* MMF = reinterpret_cast<Registers*>(MMF_BASE);

    // Bit definitions
    /// MMSFR Register bits
    namespace mmsfr_bits {
        constexpr uint32_t KEY = (8 << 24);  ///< MMSFR Key Code
        constexpr uint32_t MEMMIRADDR = (16 << 7);  ///< Specifies the memory mirror address.NOTE: A value cannot be set in the low-order 7 bits. These bits are fixed to 0.
    }

    /// MMEN Register bits
    namespace mmen_bits {
        constexpr uint32_t KEY = (8 << 24);  ///< MMEN Key Code
        constexpr uint32_t EN = (1U << 0);  ///< Memory Mirror Function Enable
    }

}

// ============================================================================
// DTC Peripheral
// ============================================================================

namespace dtc {
    /// Base addresses
    constexpr uint32_t DTC_BASE = 0x40005400;

    /// DTC Register structure
    struct Registers {
        volatile uint32_t DTCCR;  ///< Offset: 0x00 - DTC Control Register
        volatile uint32_t DTCVBR;  ///< Offset: 0x04 - DTC Vector Base Register
        volatile uint32_t DTCST;  ///< Offset: 0x0C - DTC Module Start Register
        volatile uint32_t DTCSTS;  ///< Offset: 0x0E - DTC Status Register
    };

    /// Peripheral instances
    inline Registers* DTC = reinterpret_cast<Registers*>(DTC_BASE);

    // Bit definitions
    /// DTCCR Register bits
    namespace dtccr_bits {
        constexpr uint32_t RRS = (1U << 4);  ///< DTC Transfer Information Read Skip Enable.
    }

    /// DTCVBR Register bits
    namespace dtcvbr_bits {
        constexpr uint32_t DTCVBR = (32 << 0);  ///< DTC Vector Base Address.Note: A value cannot be set in the lower-order 10 bits. These bits are fixed to 0.
    }

    /// DTCST Register bits
    namespace dtcst_bits {
        constexpr uint32_t DTCST = (1U << 0);  ///< DTC Module Start
    }

    /// DTCSTS Register bits
    namespace dtcsts_bits {
        constexpr uint32_t ACT = (1U << 15);  ///< DTC Active Flag
        constexpr uint32_t VECN = (8 << 0);  ///< DTC-Activating Vector Number MonitoringThese bits indicate the vector number for the activating source when DTC transfer is in progress.The value is only valid if DTC transfer is in progress (the value of the ACT flag is 1)
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0x4001B000;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t DBGSTR;  ///< Offset: 0x00 - Debug Status Register
        volatile uint32_t DBGSTOPCR;  ///< Offset: 0x10 - Debug Stop Control Register
        volatile uint32_t TRACECTR;  ///< Offset: 0x20 - Trace Control Register
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// DBGSTR Register bits
    namespace dbgstr_bits {
        constexpr uint32_t CDBGPWRUPACK = (1U << 29);  ///< Debug power-up acknowledge
        constexpr uint32_t CDBGPWRUPREQ = (1U << 28);  ///< Debug power-up request
    }

    /// DBGSTOPCR Register bits
    namespace dbgstopcr_bits {
        constexpr uint32_t DBGSTOP_RECCR = (1U << 25);  ///< Mask bit for RAM ECC error reset/interrupt
        constexpr uint32_t DBGSTOP_RPER = (1U << 24);  ///< Mask bit for RAM parity error reset/interrupt
        constexpr uint32_t DBGSTOP_LVD = (3 << 16);  ///< b18: Mask bit for LVD2 reset/interrupt (0:enable / 1:Mask)b17: Mask bit for LVD1 reset/interrupt (0:enable / 1:Mask)b16: Mask bit for LVD0 reset (0:enable / 1:Mask)
        constexpr uint32_t DBGSTOP_WDT = (1U << 1);  ///< Mask bit for WDT reset/interrupt
        constexpr uint32_t DBGSTOP_IWDT = (1U << 0);  ///< Mask bit for IWDT reset/interrupt
    }

    /// TRACECTR Register bits
    namespace tracectr_bits {
        constexpr uint32_t ENETBFULL = (1U << 31);  ///< Enable bit for halt request by ETB full
    }

}

// ============================================================================
// TSN Peripheral
// ============================================================================

namespace tsn {
    /// Base addresses
    constexpr uint32_t TSN_BASE = 0x4005D000;

    /// TSN Register structure
    struct Registers {
        volatile uint32_t TSCR;  ///< Offset: 0x00 - Temperature Sensor Control Register
    };

    /// Peripheral instances
    inline Registers* TSN = reinterpret_cast<Registers*>(TSN_BASE);

    // Bit definitions
    /// TSCR Register bits
    namespace tscr_bits {
        constexpr uint32_t TSEN = (1U << 7);  ///< Temperature Sensor Output Enable
        constexpr uint32_t TSOE = (1U << 4);  ///< Temperature Sensor Enable
    }

}

// ============================================================================
// ACMPHS0 Peripheral
// ============================================================================

namespace acmphs0 {
    /// Base addresses
    constexpr uint32_t ACMPHS0_BASE = 0x40085000;

    /// ACMPHS0 Register structure
    struct Registers {
        volatile uint32_t CMPCTL;  ///< Offset: 0x00 - Comparator Control Register
        volatile uint32_t CMPSEL0;  ///< Offset: 0x04 - Comparator Input Select Register
        volatile uint32_t CMPSEL1;  ///< Offset: 0x08 - Comparator Reference Voltage Select Register
        volatile uint32_t CMPMON;  ///< Offset: 0x0C - Comparator Output Monitor Register
        volatile uint32_t CPIOC;  ///< Offset: 0x10 - Comparator Output Control Register
    };

    /// Peripheral instances
    inline Registers* ACMPHS0 = reinterpret_cast<Registers*>(ACMPHS0_BASE);

    // Bit definitions
    /// CMPCTL Register bits
    namespace cmpctl_bits {
        constexpr uint32_t HCMPON = (1U << 7);  ///< Comparator operation control
        constexpr uint32_t CDFS = (2 << 5);  ///< Noise filter selection
        constexpr uint32_t CEG = (2 << 3);  ///< Selection of valid edge (Edge selector)
        constexpr uint32_t CSTEN = (1U << 2);  ///< Interrupt Select
        constexpr uint32_t COE = (1U << 1);  ///< Comparator output enable
        constexpr uint32_t CINV = (1U << 0);  ///< Comparator output polarity selection
    }

    /// CMPSEL0 Register bits
    namespace cmpsel0_bits {
        constexpr uint32_t CMPSEL = (4 << 0);  ///< Comparator input selection
    }

    /// CMPSEL1 Register bits
    namespace cmpsel1_bits {
        constexpr uint32_t CRVS = (4 << 0);  ///< Reference voltage selection
    }

    /// CMPMON Register bits
    namespace cmpmon_bits {
        constexpr uint32_t CMPMON = (1U << 0);  ///< Comparator output monitor
    }

    /// CPIOC Register bits
    namespace cpioc_bits {
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Vref enable
        constexpr uint32_t CPOE = (1U << 0);  ///< Comparator output selection
    }

}

// ============================================================================
// ACMPHS1 Peripheral
// ============================================================================

namespace acmphs1 {
    /// Base addresses
    constexpr uint32_t ACMPHS1_BASE = 0x40085100;

    /// ACMPHS1 Register structure
    struct Registers {
        volatile uint32_t CMPCTL;  ///< Offset: 0x00 - Comparator Control Register
        volatile uint32_t CMPSEL0;  ///< Offset: 0x04 - Comparator Input Select Register
        volatile uint32_t CMPSEL1;  ///< Offset: 0x08 - Comparator Reference Voltage Select Register
        volatile uint32_t CMPMON;  ///< Offset: 0x0C - Comparator Output Monitor Register
        volatile uint32_t CPIOC;  ///< Offset: 0x10 - Comparator Output Control Register
    };

    /// Peripheral instances
    inline Registers* ACMPHS1 = reinterpret_cast<Registers*>(ACMPHS1_BASE);

    // Bit definitions
    /// CMPCTL Register bits
    namespace cmpctl_bits {
        constexpr uint32_t HCMPON = (1U << 7);  ///< Comparator operation control
        constexpr uint32_t CDFS = (2 << 5);  ///< Noise filter selection
        constexpr uint32_t CEG = (2 << 3);  ///< Selection of valid edge (Edge selector)
        constexpr uint32_t CSTEN = (1U << 2);  ///< Interrupt Select
        constexpr uint32_t COE = (1U << 1);  ///< Comparator output enable
        constexpr uint32_t CINV = (1U << 0);  ///< Comparator output polarity selection
    }

    /// CMPSEL0 Register bits
    namespace cmpsel0_bits {
        constexpr uint32_t CMPSEL = (4 << 0);  ///< Comparator input selection
    }

    /// CMPSEL1 Register bits
    namespace cmpsel1_bits {
        constexpr uint32_t CRVS = (4 << 0);  ///< Reference voltage selection
    }

    /// CMPMON Register bits
    namespace cmpmon_bits {
        constexpr uint32_t CMPMON = (1U << 0);  ///< Comparator output monitor
    }

    /// CPIOC Register bits
    namespace cpioc_bits {
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Vref enable
        constexpr uint32_t CPOE = (1U << 0);  ///< Comparator output selection
    }

}

// ============================================================================
// ACMPHS2 Peripheral
// ============================================================================

namespace acmphs2 {
    /// Base addresses
    constexpr uint32_t ACMPHS2_BASE = 0x40085200;

    /// ACMPHS2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ACMPHS2 = reinterpret_cast<Registers*>(ACMPHS2_BASE);

}

// ============================================================================
// ACMPHS3 Peripheral
// ============================================================================

namespace acmphs3 {
    /// Base addresses
    constexpr uint32_t ACMPHS3_BASE = 0x40085300;

    /// ACMPHS3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ACMPHS3 = reinterpret_cast<Registers*>(ACMPHS3_BASE);

}

// ============================================================================
// ACMPHS4 Peripheral
// ============================================================================

namespace acmphs4 {
    /// Base addresses
    constexpr uint32_t ACMPHS4_BASE = 0x40085400;

    /// ACMPHS4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ACMPHS4 = reinterpret_cast<Registers*>(ACMPHS4_BASE);

}

// ============================================================================
// ACMPHS5 Peripheral
// ============================================================================

namespace acmphs5 {
    /// Base addresses
    constexpr uint32_t ACMPHS5_BASE = 0x40085500;

    /// ACMPHS5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ACMPHS5 = reinterpret_cast<Registers*>(ACMPHS5_BASE);

}

// ============================================================================
// ELC Peripheral
// ============================================================================

namespace elc {
    /// Base addresses
    constexpr uint32_t ELC_BASE = 0x40041000;

    /// ELC Register structure
    struct Registers {
        volatile uint32_t ELCR;  ///< Offset: 0x00 - Event Link Controller Register
        volatile uint32_t ELSEGR%s;  ///< Offset: 0x02 - Event Link Software Event Generation Register %s
        volatile uint32_t ELSR%s;  ///< Offset: 0x10 - Event Link Setting Register %s
    };

    /// Peripheral instances
    inline Registers* ELC = reinterpret_cast<Registers*>(ELC_BASE);

    // Bit definitions
    /// ELCR Register bits
    namespace elcr_bits {
        constexpr uint32_t ELCON = (1U << 7);  ///< All Event Link Enable
    }

    /// ELSEGR%s Register bits
    namespace elsegr%s_bits {
        constexpr uint32_t WI = (1U << 7);  ///< ELSEGR Register Write Disable
        constexpr uint32_t WE = (1U << 6);  ///< SEG Bit Write Enable
        constexpr uint32_t SEG = (1U << 0);  ///< Software Event Generation
    }

    /// ELSR%s Register bits
    namespace elsr%s_bits {
        constexpr uint32_t ELS = (9 << 0);  ///< Event Link Select
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40044200;
    constexpr uint32_t IWDT_BASE = 0x40044400;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDTRR;  ///< Offset: 0x00 - WDT Refresh Register
        volatile uint32_t WDTCR;  ///< Offset: 0x02 - WDT Control Register
        volatile uint32_t WDTSR;  ///< Offset: 0x04 - WDT Status Register
        volatile uint32_t WDTRCR;  ///< Offset: 0x06 - WDT Reset Control Register
        volatile uint32_t WDTCSTPR;  ///< Offset: 0x08 - WDT Count Stop Control Register
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);
    inline Registers* IWDT = reinterpret_cast<Registers*>(IWDT_BASE);

    // Bit definitions
    /// WDTRR Register bits
    namespace wdtrr_bits {
        constexpr uint32_t WDTRR = (8 << 0);  ///< WDTRR is an 8-bit register that refreshes the down-counter of the WDT.
    }

    /// WDTCR Register bits
    namespace wdtcr_bits {
        constexpr uint32_t RPSS = (2 << 12);  ///< Window Start Position Selection
        constexpr uint32_t RPES = (2 << 8);  ///< Window End Position Selection
        constexpr uint32_t CKS = (4 << 4);  ///< Clock Division Ratio Selection
        constexpr uint32_t TOPS = (2 << 0);  ///< Timeout Period Selection
    }

    /// WDTSR Register bits
    namespace wdtsr_bits {
        constexpr uint32_t REFEF = (1U << 15);  ///< Refresh Error Flag
        constexpr uint32_t UNDFF = (1U << 14);  ///< Underflow Flag
        constexpr uint32_t CNTVAL = (14 << 0);  ///< Down-Counter ValueValue counted by the down-counter
    }

    /// WDTRCR Register bits
    namespace wdtrcr_bits {
        constexpr uint32_t RSTIRQS = (1U << 7);  ///< Reset Interrupt Request Selection
    }

    /// WDTCSTPR Register bits
    namespace wdtcstpr_bits {
        constexpr uint32_t SLCSTP = (1U << 7);  ///< Sleep-Mode Count Stop Control
    }

}

// ============================================================================
// KINT Peripheral
// ============================================================================

namespace kint {
    /// Base addresses
    constexpr uint32_t KINT_BASE = 0x40080000;

    /// KINT Register structure
    struct Registers {
        volatile uint32_t KRCTL;  ///< Offset: 0x00 - KEY Return Control Register
        volatile uint32_t KRF;  ///< Offset: 0x04 - KEY Return Flag Register
        volatile uint32_t KRM;  ///< Offset: 0x08 - KEY Return Mode Register
    };

    /// Peripheral instances
    inline Registers* KINT = reinterpret_cast<Registers*>(KINT_BASE);

    // Bit definitions
    /// KRCTL Register bits
    namespace krctl_bits {
        constexpr uint32_t KRMD = (1U << 7);  ///< Usage of Key Interrupt Flags(KR0 to KR7)
        constexpr uint32_t KREG = (1U << 0);  ///< Detection Edge Selection (KRF0 to KRF7)
    }

    /// KRF Register bits
    namespace krf_bits {
        constexpr uint32_t KRF7 = (1U << 7);  ///< Key interrupt flag 7
        constexpr uint32_t KRF6 = (1U << 6);  ///< Key interrupt flag 6
        constexpr uint32_t KRF5 = (1U << 5);  ///< Key interrupt flag 5
        constexpr uint32_t KRF4 = (1U << 4);  ///< Key interrupt flag 4
        constexpr uint32_t KRF3 = (1U << 3);  ///< Key interrupt flag 3
        constexpr uint32_t KRF2 = (1U << 2);  ///< Key interrupt flag 2
        constexpr uint32_t KRF1 = (1U << 1);  ///< Key interrupt flag 1
        constexpr uint32_t KRF0 = (1U << 0);  ///< Key interrupt flag 0
    }

    /// KRM Register bits
    namespace krm_bits {
        constexpr uint32_t KRM7 = (1U << 7);  ///< Key interrupt mode control 7
        constexpr uint32_t KRM6 = (1U << 6);  ///< Key interrupt mode control 6
        constexpr uint32_t KRM5 = (1U << 5);  ///< Key interrupt mode control 5
        constexpr uint32_t KRM4 = (1U << 4);  ///< Key interrupt mode control 4
        constexpr uint32_t KRM3 = (1U << 3);  ///< Key interrupt mode control 3
        constexpr uint32_t KRM2 = (1U << 2);  ///< Key interrupt mode control 2
        constexpr uint32_t KRM1 = (1U << 1);  ///< Key interrupt mode control 1
        constexpr uint32_t KRM0 = (1U << 0);  ///< Key interrupt mode control 0
    }

}

// ============================================================================
// DOC Peripheral
// ============================================================================

namespace doc {
    /// Base addresses
    constexpr uint32_t DOC_BASE = 0x40054100;

    /// DOC Register structure
    struct Registers {
        volatile uint32_t DOCR;  ///< Offset: 0x00 - DOC Control Register
        volatile uint32_t DODIR;  ///< Offset: 0x02 - DOC Data Input Register
        volatile uint32_t DODSR;  ///< Offset: 0x04 - DOC Data Setting Register
    };

    /// Peripheral instances
    inline Registers* DOC = reinterpret_cast<Registers*>(DOC_BASE);

    // Bit definitions
    /// DOCR Register bits
    namespace docr_bits {
        constexpr uint32_t DOPCFCL = (1U << 6);  ///< DOPCF Clear
        constexpr uint32_t DOPCF = (1U << 5);  ///< Data Operation Circuit FlagIndicates the result of an operation.
        constexpr uint32_t DCSEL = (1U << 2);  ///< Detection Condition Select
        constexpr uint32_t OMS = (2 << 0);  ///< Operating Mode Select
    }

    /// DODIR Register bits
    namespace dodir_bits {
        constexpr uint32_t DODIR = (16 << 0);  ///< 16-bit read-write register in which 16-bit data for use in the operations are stored.
    }

    /// DODSR Register bits
    namespace dodsr_bits {
        constexpr uint32_t DODSR = (16 << 0);  ///< This register stores 16-bit data for use as a reference in data comparison mode. This register also stores the results of operations in data addition and data subtraction modes.
    }

}

// ============================================================================
// CAC Peripheral
// ============================================================================

namespace cac {
    /// Base addresses
    constexpr uint32_t CAC_BASE = 0x40044600;

    /// CAC Register structure
    struct Registers {
        volatile uint32_t CACR0;  ///< Offset: 0x00 - CAC Control Register 0
        volatile uint32_t CACR1;  ///< Offset: 0x01 - CAC Control Register 1
        volatile uint32_t CACR2;  ///< Offset: 0x02 - CAC Control Register 2
        volatile uint32_t CAICR;  ///< Offset: 0x03 - CAC Interrupt Control Register
        volatile uint32_t CASTR;  ///< Offset: 0x04 - CAC Status Register
        volatile uint32_t CAULVR;  ///< Offset: 0x06 - CAC Upper-Limit Value Setting Register
        volatile uint32_t CALLVR;  ///< Offset: 0x08 - CAC Lower-Limit Value Setting Register
        volatile uint32_t CACNTBR;  ///< Offset: 0x0A - CAC Counter Buffer Register
    };

    /// Peripheral instances
    inline Registers* CAC = reinterpret_cast<Registers*>(CAC_BASE);

    // Bit definitions
    /// CACR0 Register bits
    namespace cacr0_bits {
        constexpr uint32_t CFME = (1U << 0);  ///< Clock Frequency Measurement Enable.
    }

    /// CACR1 Register bits
    namespace cacr1_bits {
        constexpr uint32_t EDGES = (2 << 6);  ///< Valid Edge Select
        constexpr uint32_t TCSS = (2 << 4);  ///< Measurement Target Clock Frequency Division Ratio Select
        constexpr uint32_t FMCS = (3 << 1);  ///< Measurement Target Clock Select
        constexpr uint32_t CACREFE = (1U << 0);  ///< CACREF Pin Input Enable
    }

    /// CACR2 Register bits
    namespace cacr2_bits {
        constexpr uint32_t DFS = (2 << 6);  ///< Digital Filter Selection
        constexpr uint32_t RCDS = (2 << 4);  ///< Measurement Reference Clock Frequency Division Ratio Select
        constexpr uint32_t RSCS = (3 << 1);  ///< Measurement Reference Clock Select
        constexpr uint32_t RPS = (1U << 0);  ///< Reference Signal Select
    }

    /// CAICR Register bits
    namespace caicr_bits {
        constexpr uint32_t OVFFCL = (1U << 6);  ///< OVFF Clear
        constexpr uint32_t MENDFCL = (1U << 5);  ///< MENDF Clear
        constexpr uint32_t FERRFCL = (1U << 4);  ///< FERRF Clear
        constexpr uint32_t OVFIE = (1U << 2);  ///< Overflow Interrupt Request Enable
        constexpr uint32_t MENDIE = (1U << 1);  ///< Measurement End Interrupt Request Enable
        constexpr uint32_t FERRIE = (1U << 0);  ///< Frequency Error Interrupt Request Enable
    }

    /// CASTR Register bits
    namespace castr_bits {
        constexpr uint32_t OVFF = (1U << 2);  ///< Counter Overflow Flag
        constexpr uint32_t MENDF = (1U << 1);  ///< Measurement End Flag
        constexpr uint32_t FERRF = (1U << 0);  ///< Frequency Error Flag
    }

    /// CAULVR Register bits
    namespace caulvr_bits {
        constexpr uint32_t CAULVR = (16 << 0);  ///< CAULVR is a 16-bit readable/writable register that stores the upper-limit value of the frequency.
    }

    /// CALLVR Register bits
    namespace callvr_bits {
        constexpr uint32_t CALLVR = (16 << 0);  ///< CALLVR is a 16-bit readable/writable register that stores the lower-limit value of the frequency.
    }

    /// CACNTBR Register bits
    namespace cacntbr_bits {
        constexpr uint32_t CACNTBR = (16 << 0);  ///< CACNTBR is a 16-bit read-only register that retains the counter value at the time a valid reference signal edge is input
    }

}


} // namespace alloy::generated::r7fa6m2af

#endif // ALLOY_GENERATED_R7FA6M2AF_PERIPHERALS_HPP