/// Auto-generated code for R7FA6T1AD
/// Generated by Alloy Code Generator
/// Source: renesas_r7fa6t1ad.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:28
#ifndef ALLOY_GENERATED_R7FA6T1AD_PERIPHERALS_HPP
#define ALLOY_GENERATED_R7FA6T1AD_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::r7fa6t1ad {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_acmphs0 = true;
    constexpr uint32_t num_acmphs0_instances = 1;
    constexpr bool has_acmphs1 = true;
    constexpr uint32_t num_acmphs1_instances = 1;
    constexpr bool has_acmphs2 = true;
    constexpr uint32_t num_acmphs2_instances = 1;
    constexpr bool has_acmphs3 = true;
    constexpr uint32_t num_acmphs3_instances = 1;
    constexpr bool has_acmphs4 = true;
    constexpr uint32_t num_acmphs4_instances = 1;
    constexpr bool has_acmphs5 = true;
    constexpr uint32_t num_acmphs5_instances = 1;
    constexpr bool has_tsn = true;
    constexpr uint32_t num_tsn_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_elc = true;
    constexpr uint32_t num_elc_instances = 1;
    constexpr bool has_cac = true;
    constexpr uint32_t num_cac_instances = 1;
    constexpr bool has_doc = true;
    constexpr uint32_t num_doc_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_kint = true;
    constexpr uint32_t num_kint_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 2;
    constexpr bool has_irda = true;
    constexpr uint32_t num_irda_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_srcram = true;
    constexpr uint32_t num_srcram_instances = 1;
    constexpr bool has_src = true;
    constexpr uint32_t num_src_instances = 1;
    constexpr bool has_dbg = true;
    constexpr uint32_t num_dbg_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 9;
    constexpr bool has_dtc = true;
    constexpr uint32_t num_dtc_instances = 1;
    constexpr bool has_mmf = true;
    constexpr uint32_t num_mmf_instances = 1;
    constexpr bool has_sram = true;
    constexpr uint32_t num_sram_instances = 1;
    constexpr bool has_fcache = true;
    constexpr uint32_t num_fcache_instances = 1;
    constexpr bool has_system = true;
    constexpr uint32_t num_system_instances = 1;
    constexpr bool has_mstp = true;
    constexpr uint32_t num_mstp_instances = 1;
    constexpr bool has_agt0 = true;
    constexpr uint32_t num_agt0_instances = 1;
    constexpr bool has_agt1 = true;
    constexpr uint32_t num_agt1_instances = 1;
    constexpr bool has_gpt = true;
    constexpr uint32_t num_gpt_instances = 2;
    constexpr bool has_gpt32eh0 = true;
    constexpr uint32_t num_gpt32eh0_instances = 1;
    constexpr bool has_gpt32eh1 = true;
    constexpr uint32_t num_gpt32eh1_instances = 1;
    constexpr bool has_gpt32eh2 = true;
    constexpr uint32_t num_gpt32eh2_instances = 1;
    constexpr bool has_gpt32eh3 = true;
    constexpr uint32_t num_gpt32eh3_instances = 1;
    constexpr bool has_gpt32e4 = true;
    constexpr uint32_t num_gpt32e4_instances = 1;
    constexpr bool has_gpt32e5 = true;
    constexpr uint32_t num_gpt32e5_instances = 1;
    constexpr bool has_gpt32e6 = true;
    constexpr uint32_t num_gpt32e6_instances = 1;
    constexpr bool has_gpt32e7 = true;
    constexpr uint32_t num_gpt32e7_instances = 1;
    constexpr bool has_poeg = true;
    constexpr uint32_t num_poeg_instances = 1;
    constexpr bool has_bus = true;
    constexpr uint32_t num_bus_instances = 1;
    constexpr bool has_icu = true;
    constexpr uint32_t num_icu_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 8;
    constexpr bool has_pfs = true;
    constexpr uint32_t num_pfs_instances = 1;
    constexpr bool has_pmisc = true;
    constexpr uint32_t num_pmisc_instances = 1;
    constexpr bool has_iic0 = true;
    constexpr uint32_t num_iic0_instances = 1;
    constexpr bool has_iic1 = true;
    constexpr uint32_t num_iic1_instances = 1;
    constexpr bool has_sci0 = true;
    constexpr uint32_t num_sci0_instances = 1;
    constexpr bool has_sci1 = true;
    constexpr uint32_t num_sci1_instances = 1;
    constexpr bool has_sci2 = true;
    constexpr uint32_t num_sci2_instances = 1;
    constexpr bool has_sci3 = true;
    constexpr uint32_t num_sci3_instances = 1;
    constexpr bool has_sci4 = true;
    constexpr uint32_t num_sci4_instances = 1;
    constexpr bool has_sci8 = true;
    constexpr uint32_t num_sci8_instances = 1;
    constexpr bool has_sci9 = true;
    constexpr uint32_t num_sci9_instances = 1;
    constexpr bool has_gpt328 = true;
    constexpr uint32_t num_gpt328_instances = 1;
    constexpr bool has_gpt329 = true;
    constexpr uint32_t num_gpt329_instances = 1;
    constexpr bool has_gpt3210 = true;
    constexpr uint32_t num_gpt3210_instances = 1;
    constexpr bool has_gpt3211 = true;
    constexpr uint32_t num_gpt3211_instances = 1;
    constexpr bool has_gpt3212 = true;
    constexpr uint32_t num_gpt3212_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_mmpu = true;
    constexpr uint32_t num_mmpu_instances = 1;
    constexpr bool has_smpu = true;
    constexpr uint32_t num_smpu_instances = 1;
    constexpr bool has_spmon = true;
    constexpr uint32_t num_spmon_instances = 1;
    constexpr bool has_tsd = true;
    constexpr uint32_t num_tsd_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct acmphs0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct acmphs1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct acmphs2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct acmphs3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct acmphs4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct acmphs5_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsn_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct elc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct doc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct kint_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct irda_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct srcram_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct src_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dbg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 9;
    };
    template<>
    struct peripheral_count<struct dtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mmf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sram_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fcache_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct system_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mstp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct agt0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct agt1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct gpt32eh0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt32eh1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt32eh2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt32eh3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt32e4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt32e5_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt32e6_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt32e7_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct poeg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bus_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct icu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct pfs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmisc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct iic0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct iic1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci8_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sci9_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt328_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt329_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt3210_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt3211_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpt3212_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct mmpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spmon_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsd_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 8;
    constexpr uint32_t max_gpio_pins = 128;  // 16 pins per port

    // USART-specific traits
}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC12_BASE = 0x4005E000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DADR;  ///< Offset: 0x00 - D/A Data Register %s (renamed from DADR)
        volatile uint32_t DACR;  ///< Offset: 0x04 - D/A Control Register
        volatile uint32_t DADPR;  ///< Offset: 0x05 - DADRm Format Select Register
        volatile uint32_t DAADSCR;  ///< Offset: 0x06 - D/A-A/D Synchronous Start Control Register
        volatile uint32_t DAAMPCR;  ///< Offset: 0x08 - D/A Output Amplifier Control Register
        volatile uint32_t DAASWCR;  ///< Offset: 0x101C - D/A Amplifier Stabilization Wait Control Register
        volatile uint32_t DAADUSR;  ///< Offset: 0x10C0 - D/A A/D Synchronous Unit Select Register
    };

    /// Peripheral instances
    inline Registers* DAC12 = reinterpret_cast<Registers*>(DAC12_BASE);

    // Bit definitions
    /// DADR Register bits
    namespace dadr_bits {
        constexpr uint32_t DADR = (16 << 0);  ///< D/A Data RegisterNOTE: When DADPR.DPSEL = 0, the high-order 4 bits are fixed to 0: right justified format. When DADPR.DPSEL = 1, the low-order 4 bits are fixed to 0: left justified format.
    }

    /// DACR Register bits
    namespace dacr_bits {
        constexpr uint32_t DAOE1 = (1U << 7);  ///< D/A Output Enable 1
        constexpr uint32_t DAOE0 = (1U << 6);  ///< D/A Output Enable 0
        constexpr uint32_t DAE = (1U << 5);  ///< D/A Enable
    }

    /// DADPR Register bits
    namespace dadpr_bits {
        constexpr uint32_t DPSEL = (1U << 7);  ///< DADRm Format Select
    }

    /// DAADSCR Register bits
    namespace daadscr_bits {
        constexpr uint32_t DAADST = (1U << 7);  ///< D/A-A/D Synchronous Conversion
    }

    /// DAAMPCR Register bits
    namespace daampcr_bits {
        constexpr uint32_t DAAMP1 = (1U << 7);  ///< Amplifier Control 1
        constexpr uint32_t DAAMP0 = (1U << 6);  ///< Amplifier Control 0
    }

    /// DAASWCR Register bits
    namespace daaswcr_bits {
        constexpr uint32_t DAASW1 = (1U << 7);  ///< D/A Amplifier Stabilization Wait 1
        constexpr uint32_t DAASW0 = (1U << 6);  ///< D/A Amplifier Stabilization Wait 0
    }

    /// DAADUSR Register bits
    namespace daadusr_bits {
        constexpr uint32_t AMADSEL1 = (1U << 1);  ///< A/D Unit 1 Select
    }

}

// ============================================================================
// ACMPHS0 Peripheral
// ============================================================================

namespace acmphs0 {
    /// Base addresses
    constexpr uint32_t ACMPHS0_BASE = 0x40085000;

    /// ACMPHS0 Register structure
    struct Registers {
        volatile uint32_t CMPCTL;  ///< Offset: 0x00 - Comparator Control Register
        volatile uint32_t CMPSEL0;  ///< Offset: 0x04 - Comparator Input Select Register
        volatile uint32_t CMPSEL1;  ///< Offset: 0x08 - Comparator Reference Voltage Select Register
        volatile uint32_t CMPMON;  ///< Offset: 0x0C - Comparator Output Monitor Register
        volatile uint32_t CPIOC;  ///< Offset: 0x10 - Comparator Output Control Register
    };

    /// Peripheral instances
    inline Registers* ACMPHS0 = reinterpret_cast<Registers*>(ACMPHS0_BASE);

    // Bit definitions
    /// CMPCTL Register bits
    namespace cmpctl_bits {
        constexpr uint32_t HCMPON = (1U << 7);  ///< Comparator operation control
        constexpr uint32_t CDFS = (2 << 5);  ///< Noise filter selection
        constexpr uint32_t CEG = (2 << 3);  ///< Selection of valid edge (Edge selector)
        constexpr uint32_t CSTEN = (1U << 2);  ///< Interrupt Select
        constexpr uint32_t COE = (1U << 1);  ///< Comparator output enable
        constexpr uint32_t CINV = (1U << 0);  ///< Comparator output polarity selection
    }

    /// CMPSEL0 Register bits
    namespace cmpsel0_bits {
        constexpr uint32_t CMPSEL = (4 << 0);  ///< Comparator input selection
    }

    /// CMPSEL1 Register bits
    namespace cmpsel1_bits {
        constexpr uint32_t CRVS = (4 << 0);  ///< Reference voltage selection
    }

    /// CMPMON Register bits
    namespace cmpmon_bits {
        constexpr uint32_t CMPMON = (1U << 0);  ///< Comparator output monitor
    }

    /// CPIOC Register bits
    namespace cpioc_bits {
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Vref enable
        constexpr uint32_t CPOE = (1U << 0);  ///< Comparator output selection
    }

}

// ============================================================================
// ACMPHS1 Peripheral
// ============================================================================

namespace acmphs1 {
    /// Base addresses
    constexpr uint32_t ACMPHS1_BASE = 0x40085100;

    /// ACMPHS1 Register structure
    struct Registers {
        volatile uint32_t CMPCTL;  ///< Offset: 0x00 - Comparator Control Register
        volatile uint32_t CMPSEL0;  ///< Offset: 0x04 - Comparator Input Select Register
        volatile uint32_t CMPSEL1;  ///< Offset: 0x08 - Comparator Reference Voltage Select Register
        volatile uint32_t CMPMON;  ///< Offset: 0x0C - Comparator Output Monitor Register
        volatile uint32_t CPIOC;  ///< Offset: 0x10 - Comparator Output Control Register
    };

    /// Peripheral instances
    inline Registers* ACMPHS1 = reinterpret_cast<Registers*>(ACMPHS1_BASE);

    // Bit definitions
    /// CMPCTL Register bits
    namespace cmpctl_bits {
        constexpr uint32_t HCMPON = (1U << 7);  ///< Comparator operation control
        constexpr uint32_t CDFS = (2 << 5);  ///< Noise filter selection
        constexpr uint32_t CEG = (2 << 3);  ///< Selection of valid edge (Edge selector)
        constexpr uint32_t CSTEN = (1U << 2);  ///< Interrupt Select
        constexpr uint32_t COE = (1U << 1);  ///< Comparator output enable
        constexpr uint32_t CINV = (1U << 0);  ///< Comparator output polarity selection
    }

    /// CMPSEL0 Register bits
    namespace cmpsel0_bits {
        constexpr uint32_t CMPSEL = (4 << 0);  ///< Comparator input selection
    }

    /// CMPSEL1 Register bits
    namespace cmpsel1_bits {
        constexpr uint32_t CRVS = (4 << 0);  ///< Reference voltage selection
    }

    /// CMPMON Register bits
    namespace cmpmon_bits {
        constexpr uint32_t CMPMON = (1U << 0);  ///< Comparator output monitor
    }

    /// CPIOC Register bits
    namespace cpioc_bits {
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Vref enable
        constexpr uint32_t CPOE = (1U << 0);  ///< Comparator output selection
    }

}

// ============================================================================
// ACMPHS2 Peripheral
// ============================================================================

namespace acmphs2 {
    /// Base addresses
    constexpr uint32_t ACMPHS2_BASE = 0x40085200;

    /// ACMPHS2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ACMPHS2 = reinterpret_cast<Registers*>(ACMPHS2_BASE);

}

// ============================================================================
// ACMPHS3 Peripheral
// ============================================================================

namespace acmphs3 {
    /// Base addresses
    constexpr uint32_t ACMPHS3_BASE = 0x40085300;

    /// ACMPHS3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ACMPHS3 = reinterpret_cast<Registers*>(ACMPHS3_BASE);

}

// ============================================================================
// ACMPHS4 Peripheral
// ============================================================================

namespace acmphs4 {
    /// Base addresses
    constexpr uint32_t ACMPHS4_BASE = 0x40085400;

    /// ACMPHS4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ACMPHS4 = reinterpret_cast<Registers*>(ACMPHS4_BASE);

}

// ============================================================================
// ACMPHS5 Peripheral
// ============================================================================

namespace acmphs5 {
    /// Base addresses
    constexpr uint32_t ACMPHS5_BASE = 0x40085500;

    /// ACMPHS5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* ACMPHS5 = reinterpret_cast<Registers*>(ACMPHS5_BASE);

}

// ============================================================================
// TSN Peripheral
// ============================================================================

namespace tsn {
    /// Base addresses
    constexpr uint32_t TSN_BASE = 0x4005D000;

    /// TSN Register structure
    struct Registers {
        volatile uint32_t TSCR;  ///< Offset: 0x00 - Temperature Sensor Control Register
    };

    /// Peripheral instances
    inline Registers* TSN = reinterpret_cast<Registers*>(TSN_BASE);

    // Bit definitions
    /// TSCR Register bits
    namespace tscr_bits {
        constexpr uint32_t TSEN = (1U << 7);  ///< Temperature Sensor Output Enable
        constexpr uint32_t TSOE = (1U << 4);  ///< Temperature Sensor Enable
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40074000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRCCR0;  ///< Offset: 0x00 - CRC Control Register0
        volatile uint32_t CRCCR1;  ///< Offset: 0x01 - CRC Control Register1
        volatile uint32_t CRCDIR;  ///< Offset: 0x04 - CRC Data Input Register
        volatile uint32_t CRCDIR_BY;  ///< Offset: 0x04 - CRC Data Input Register (byte access)
        volatile uint32_t CRCDOR;  ///< Offset: 0x08 - CRC Data Output Register
        volatile uint32_t CRCDOR_HA;  ///< Offset: 0x08 - CRC Data Output Register (halfword access)
        volatile uint32_t CRCDOR_BY;  ///< Offset: 0x08 - CRC Data Output Register(byte access)
        volatile uint32_t CRCSAR;  ///< Offset: 0x0C - Snoop Address Register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRCCR0 Register bits
    namespace crccr0_bits {
        constexpr uint32_t DORCLR = (1U << 7);  ///< CRCDOR Register Clear
        constexpr uint32_t LMS = (1U << 6);  ///< CRC Calculation Switching
        constexpr uint32_t GPS = (3 << 0);  ///< CRC Generating Polynomial Switching
    }

    /// CRCCR1 Register bits
    namespace crccr1_bits {
        constexpr uint32_t CRCSEN = (1U << 7);  ///< Snoop enable bit
        constexpr uint32_t CRCSWR = (1U << 6);  ///< Snoop-on-write/read switch bit
    }

    /// CRCDIR Register bits
    namespace crcdir_bits {
        constexpr uint32_t CRCDIR = (32 << 0);  ///< Calculation input Data (Case of CRC-32, CRC-32C )
    }

    /// CRCDIR_BY Register bits
    namespace crcdir_by_bits {
        constexpr uint32_t CRCDIR_BY = (8 << 0);  ///< Calculation input Data ( Case of CRC-8, CRC-16 or CRC-CCITT )
    }

    /// CRCDOR Register bits
    namespace crcdor_bits {
        constexpr uint32_t CRCDOR = (32 << 0);  ///< Calculation output Data (Case of CRC-32, CRC-32C )
    }

    /// CRCDOR_HA Register bits
    namespace crcdor_ha_bits {
        constexpr uint32_t CRCDOR_HA = (16 << 0);  ///< Calculation output Data (Case of CRC-16 or CRC-CCITT )
    }

    /// CRCDOR_BY Register bits
    namespace crcdor_by_bits {
        constexpr uint32_t CRCDOR_BY = (8 << 0);  ///< Calculation output Data (Case of CRC-8 )
    }

    /// CRCSAR Register bits
    namespace crcsar_bits {
        constexpr uint32_t CRCSA = (14 << 0);  ///< snoop address bitSet the I/O register address to snoop
    }

}

// ============================================================================
// ELC Peripheral
// ============================================================================

namespace elc {
    /// Base addresses
    constexpr uint32_t ELC_BASE = 0x40041000;

    /// ELC Register structure
    struct Registers {
        volatile uint32_t ELCR;  ///< Offset: 0x00 - Event Link Controller Register
        volatile uint32_t ELSEGR;  ///< Offset: 0x02 - Event Link Software Event Generation Register %s (renamed from ELSEGR)
        volatile uint32_t ELSR;  ///< Offset: 0x10 - Event Link Setting Register %s (renamed from ELSR)
    };

    /// Peripheral instances
    inline Registers* ELC = reinterpret_cast<Registers*>(ELC_BASE);

    // Bit definitions
    /// ELCR Register bits
    namespace elcr_bits {
        constexpr uint32_t ELCON = (1U << 7);  ///< All Event Link Enable
    }

    /// ELSEGR Register bits
    namespace elsegr_bits {
        constexpr uint32_t WI = (1U << 7);  ///< ELSEGR Register Write Disable
        constexpr uint32_t WE = (1U << 6);  ///< SEG Bit Write Enable
        constexpr uint32_t SEG = (1U << 0);  ///< Software Event Generation
    }

    /// ELSR Register bits
    namespace elsr_bits {
        constexpr uint32_t ELS = (9 << 0);  ///< Event Link Select
    }

}

// ============================================================================
// CAC Peripheral
// ============================================================================

namespace cac {
    /// Base addresses
    constexpr uint32_t CAC_BASE = 0x40044600;

    /// CAC Register structure
    struct Registers {
        volatile uint32_t CACR0;  ///< Offset: 0x00 - CAC Control Register 0
        volatile uint32_t CACR1;  ///< Offset: 0x01 - CAC Control Register 1
        volatile uint32_t CACR2;  ///< Offset: 0x02 - CAC Control Register 2
        volatile uint32_t CAICR;  ///< Offset: 0x03 - CAC Interrupt Control Register
        volatile uint32_t CASTR;  ///< Offset: 0x04 - CAC Status Register
        volatile uint32_t CAULVR;  ///< Offset: 0x06 - CAC Upper-Limit Value Setting Register
        volatile uint32_t CALLVR;  ///< Offset: 0x08 - CAC Lower-Limit Value Setting Register
        volatile uint32_t CACNTBR;  ///< Offset: 0x0A - CAC Counter Buffer Register
    };

    /// Peripheral instances
    inline Registers* CAC = reinterpret_cast<Registers*>(CAC_BASE);

    // Bit definitions
    /// CACR0 Register bits
    namespace cacr0_bits {
        constexpr uint32_t CFME = (1U << 0);  ///< Clock Frequency Measurement Enable.
    }

    /// CACR1 Register bits
    namespace cacr1_bits {
        constexpr uint32_t EDGES = (2 << 6);  ///< Valid Edge Select
        constexpr uint32_t TCSS = (2 << 4);  ///< Measurement Target Clock Frequency Division Ratio Select
        constexpr uint32_t FMCS = (3 << 1);  ///< Measurement Target Clock Select
        constexpr uint32_t CACREFE = (1U << 0);  ///< CACREF Pin Input Enable
    }

    /// CACR2 Register bits
    namespace cacr2_bits {
        constexpr uint32_t DFS = (2 << 6);  ///< Digital Filter Selection
        constexpr uint32_t RCDS = (2 << 4);  ///< Measurement Reference Clock Frequency Division Ratio Select
        constexpr uint32_t RSCS = (3 << 1);  ///< Measurement Reference Clock Select
        constexpr uint32_t RPS = (1U << 0);  ///< Reference Signal Select
    }

    /// CAICR Register bits
    namespace caicr_bits {
        constexpr uint32_t OVFFCL = (1U << 6);  ///< OVFF Clear
        constexpr uint32_t MENDFCL = (1U << 5);  ///< MENDF Clear
        constexpr uint32_t FERRFCL = (1U << 4);  ///< FERRF Clear
        constexpr uint32_t OVFIE = (1U << 2);  ///< Overflow Interrupt Request Enable
        constexpr uint32_t MENDIE = (1U << 1);  ///< Measurement End Interrupt Request Enable
        constexpr uint32_t FERRIE = (1U << 0);  ///< Frequency Error Interrupt Request Enable
    }

    /// CASTR Register bits
    namespace castr_bits {
        constexpr uint32_t OVFF = (1U << 2);  ///< Counter Overflow Flag
        constexpr uint32_t MENDF = (1U << 1);  ///< Measurement End Flag
        constexpr uint32_t FERRF = (1U << 0);  ///< Frequency Error Flag
    }

    /// CAULVR Register bits
    namespace caulvr_bits {
        constexpr uint32_t CAULVR = (16 << 0);  ///< CAULVR is a 16-bit readable/writable register that stores the upper-limit value of the frequency.
    }

    /// CALLVR Register bits
    namespace callvr_bits {
        constexpr uint32_t CALLVR = (16 << 0);  ///< CALLVR is a 16-bit readable/writable register that stores the lower-limit value of the frequency.
    }

    /// CACNTBR Register bits
    namespace cacntbr_bits {
        constexpr uint32_t CACNTBR = (16 << 0);  ///< CACNTBR is a 16-bit read-only register that retains the counter value at the time a valid reference signal edge is input
    }

}

// ============================================================================
// DOC Peripheral
// ============================================================================

namespace doc {
    /// Base addresses
    constexpr uint32_t DOC_BASE = 0x40054100;

    /// DOC Register structure
    struct Registers {
        volatile uint32_t DOCR;  ///< Offset: 0x00 - DOC Control Register
        volatile uint32_t DODIR;  ///< Offset: 0x02 - DOC Data Input Register
        volatile uint32_t DODSR;  ///< Offset: 0x04 - DOC Data Setting Register
    };

    /// Peripheral instances
    inline Registers* DOC = reinterpret_cast<Registers*>(DOC_BASE);

    // Bit definitions
    /// DOCR Register bits
    namespace docr_bits {
        constexpr uint32_t DOPCFCL = (1U << 6);  ///< DOPCF Clear
        constexpr uint32_t DOPCF = (1U << 5);  ///< Data Operation Circuit FlagIndicates the result of an operation.
        constexpr uint32_t DCSEL = (1U << 2);  ///< Detection Condition Select
        constexpr uint32_t OMS = (2 << 0);  ///< Operating Mode Select
    }

    /// DODIR Register bits
    namespace dodir_bits {
        constexpr uint32_t DODIR = (16 << 0);  ///< 16-bit read-write register in which 16-bit data for use in the operations are stored.
    }

    /// DODSR Register bits
    namespace dodsr_bits {
        constexpr uint32_t DODSR = (16 << 0);  ///< This register stores 16-bit data for use as a reference in data comparison mode. This register also stores the results of operations in data addition and data subtraction modes.
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDT_BASE = 0x40044400;
    constexpr uint32_t WDT_BASE = 0x40044200;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t IWDTRR;  ///< Offset: 0x00 - IWDT Refresh Register
        volatile uint32_t IWDTSR;  ///< Offset: 0x04 - IWDT Status Register
    };

    /// Peripheral instances
    inline Registers* IWDT = reinterpret_cast<Registers*>(IWDT_BASE);
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// IWDTRR Register bits
    namespace iwdtrr_bits {
        constexpr uint32_t IWDTRR = (8 << 0);  ///< The counter is refreshed by writing 0x00 and then writing 0xFF to this register.
    }

    /// IWDTSR Register bits
    namespace iwdtsr_bits {
        constexpr uint32_t REFEF = (1U << 15);  ///< Refresh Error Flag
        constexpr uint32_t UNDFF = (1U << 14);  ///< Underflow Flag
        constexpr uint32_t CNTVAL = (14 << 0);  ///< Counter ValueValue counted by the counter
    }

}

// ============================================================================
// KINT Peripheral
// ============================================================================

namespace kint {
    /// Base addresses
    constexpr uint32_t KINT_BASE = 0x40080000;

    /// KINT Register structure
    struct Registers {
        volatile uint32_t KRCTL;  ///< Offset: 0x00 - KEY Return Control Register
        volatile uint32_t KRF;  ///< Offset: 0x04 - KEY Return Flag Register
        volatile uint32_t KRM;  ///< Offset: 0x08 - KEY Return Mode Register
    };

    /// Peripheral instances
    inline Registers* KINT = reinterpret_cast<Registers*>(KINT_BASE);

    // Bit definitions
    /// KRCTL Register bits
    namespace krctl_bits {
        constexpr uint32_t KRMD = (1U << 7);  ///< Usage of Key Interrupt Flags(KR0 to KR7)
        constexpr uint32_t KREG = (1U << 0);  ///< Detection Edge Selection (KRF0 to KRF7)
    }

    /// KRF Register bits
    namespace krf_bits {
        constexpr uint32_t KRF7 = (1U << 7);  ///< Key interrupt flag 7
        constexpr uint32_t KRF6 = (1U << 6);  ///< Key interrupt flag 6
        constexpr uint32_t KRF5 = (1U << 5);  ///< Key interrupt flag 5
        constexpr uint32_t KRF4 = (1U << 4);  ///< Key interrupt flag 4
        constexpr uint32_t KRF3 = (1U << 3);  ///< Key interrupt flag 3
        constexpr uint32_t KRF2 = (1U << 2);  ///< Key interrupt flag 2
        constexpr uint32_t KRF1 = (1U << 1);  ///< Key interrupt flag 1
        constexpr uint32_t KRF0 = (1U << 0);  ///< Key interrupt flag 0
    }

    /// KRM Register bits
    namespace krm_bits {
        constexpr uint32_t KRM7 = (1U << 7);  ///< Key interrupt mode control 7
        constexpr uint32_t KRM6 = (1U << 6);  ///< Key interrupt mode control 6
        constexpr uint32_t KRM5 = (1U << 5);  ///< Key interrupt mode control 5
        constexpr uint32_t KRM4 = (1U << 4);  ///< Key interrupt mode control 4
        constexpr uint32_t KRM3 = (1U << 3);  ///< Key interrupt mode control 3
        constexpr uint32_t KRM2 = (1U << 2);  ///< Key interrupt mode control 2
        constexpr uint32_t KRM1 = (1U << 1);  ///< Key interrupt mode control 1
        constexpr uint32_t KRM0 = (1U << 0);  ///< Key interrupt mode control 0
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN0_BASE = 0x40050000;
    constexpr uint32_t CAN1_BASE = 0x40051000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MB_ID;  ///< Offset: 0x200 - Mailbox Register (renamed from MB_ID)
        volatile uint32_t MB_DL;  ///< Offset: 0x204 - Mailbox Register (renamed from MB_DL)
        volatile uint32_t MB_D0;  ///< Offset: 0x206 - Mailbox Register (renamed from MB_D0)
        volatile uint32_t MB_D1;  ///< Offset: 0x207 - Mailbox Register (renamed from MB_D1)
        volatile uint32_t MB_D2;  ///< Offset: 0x208 - Mailbox Register (renamed from MB_D2)
        volatile uint32_t MB_D3;  ///< Offset: 0x209 - Mailbox Register (renamed from MB_D3)
        volatile uint32_t MB_D4;  ///< Offset: 0x20A - Mailbox Register (renamed from MB_D4)
        volatile uint32_t MB_D5;  ///< Offset: 0x20B - Mailbox Register (renamed from MB_D5)
        volatile uint32_t MB_D6;  ///< Offset: 0x20C - Mailbox Register (renamed from MB_D6)
        volatile uint32_t MB_D7;  ///< Offset: 0x20D - Mailbox Register (renamed from MB_D7)
        volatile uint32_t MB_TS;  ///< Offset: 0x20E - Mailbox Register (renamed from MB_TS)
        volatile uint32_t MKR__;  ///< Offset: 0x400 - Mask Register (renamed from MKR__)
        volatile uint32_t FIDCR;  ///< Offset: 0x420 - FIFO Received ID Compare Registers (renamed from FIDCR)
        volatile uint32_t MKIVLR;  ///< Offset: 0x428 - Mask Invalid Register
        volatile uint32_t MIER;  ///< Offset: 0x42C - Mailbox Interrupt Enable Register
        volatile uint32_t MIER_FIFO;  ///< Offset: 0x42C - Mailbox Interrupt Enable Register for FIFO Mailbox Mode
        volatile uint32_t MCTL_TX__;  ///< Offset: 0x820 - Message Control Register for Transmit (renamed from MCTL_TX__)
        volatile uint32_t MCTL_RX__;  ///< Offset: 0x820 - Message Control Register for Receive (renamed from MCTL_RX__)
        volatile uint32_t CTLR;  ///< Offset: 0x840 - Control Register
        volatile uint32_t STR;  ///< Offset: 0x842 - Status Register
        volatile uint32_t BCR;  ///< Offset: 0x844 - Bit Configuration Register
        volatile uint32_t RFCR;  ///< Offset: 0x848 - Receive FIFO Control Register
        volatile uint32_t RFPCR;  ///< Offset: 0x849 - Receive FIFO Pointer Control Register
        volatile uint32_t TFCR;  ///< Offset: 0x84A - Transmit FIFO Control Register
        volatile uint32_t TFPCR;  ///< Offset: 0x84B - Transmit FIFO Pointer Control Register
        volatile uint32_t EIER;  ///< Offset: 0x84C - Error Interrupt Enable Register
        volatile uint32_t EIFR;  ///< Offset: 0x84D - Error Interrupt Factor Judge Register
        volatile uint32_t RECR;  ///< Offset: 0x84E - Receive Error Count Register
        volatile uint32_t TECR;  ///< Offset: 0x84F - Transmit Error Count Register
        volatile uint32_t ECSR;  ///< Offset: 0x850 - Error Code Store Register
        volatile uint32_t CSSR;  ///< Offset: 0x851 - Channel Search Support Register
        volatile uint32_t MSSR;  ///< Offset: 0x852 - Mailbox Search Status Register
        volatile uint32_t MSMR;  ///< Offset: 0x853 - Mailbox Search Mode Register
        volatile uint32_t TSR;  ///< Offset: 0x854 - Time Stamp Register
        volatile uint32_t AFSR;  ///< Offset: 0x856 - Acceptance Filter Support Register
        volatile uint32_t TCR;  ///< Offset: 0x858 - Test Control Register
    };

    /// Peripheral instances
    inline Registers* CAN0 = reinterpret_cast<Registers*>(CAN0_BASE);
    inline Registers* CAN1 = reinterpret_cast<Registers*>(CAN1_BASE);

    // Bit definitions
    /// MB_ID Register bits
    namespace mb_id_bits {
        constexpr uint32_t IDE = (1U << 31);  ///< ID Extension
        constexpr uint32_t RTR = (1U << 30);  ///< Remote Transmission Request
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID
    }

    /// MB_DL Register bits
    namespace mb_dl_bits {
        constexpr uint32_t DLC = (4 << 0);  ///< Data Length Code
    }

    /// MB_D0 Register bits
    namespace mb_d0_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< Data Bytes 0.DATA0 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D1 Register bits
    namespace mb_d1_bits {
        constexpr uint32_t DATA1 = (8 << 0);  ///< Data Bytes 1DATA1 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D2 Register bits
    namespace mb_d2_bits {
        constexpr uint32_t DATA2 = (8 << 0);  ///< Data Bytes 2DATA2 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D3 Register bits
    namespace mb_d3_bits {
        constexpr uint32_t DATA3 = (8 << 0);  ///< Data Bytes 3DATA3 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D4 Register bits
    namespace mb_d4_bits {
        constexpr uint32_t DATA4 = (8 << 0);  ///< Data Bytes 4DATA4 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D5 Register bits
    namespace mb_d5_bits {
        constexpr uint32_t DATA5 = (8 << 0);  ///< Data Bytes 5DATA5 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D6 Register bits
    namespace mb_d6_bits {
        constexpr uint32_t DATA6 = (8 << 0);  ///< Data Bytes 6DATA6 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_D7 Register bits
    namespace mb_d7_bits {
        constexpr uint32_t DATA7 = (8 << 0);  ///< Data Bytes 7DATA7 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7.
    }

    /// MB_TS Register bits
    namespace mb_ts_bits {
        constexpr uint32_t TSH = (8 << 8);  ///< Time Stamp Lower ByteBits TSH[7:0] store the counter value of the time stamp when received messages are stored in the mailbox.
        constexpr uint32_t TSL = (8 << 0);  ///< Time Stamp Higher ByteBits TSL[7:0] store the counter value of the time stamp when received messages are stored in the mailbox.
    }

    /// MKR__ Register bits
    namespace mkr___bits {
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID
    }

    /// FIDCR Register bits
    namespace fidcr_bits {
        constexpr uint32_t IDE = (1U << 31);  ///< ID Extension
        constexpr uint32_t RTR = (1U << 30);  ///< Remote Transmission Request
        constexpr uint32_t SID = (11 << 18);  ///< Standard ID
        constexpr uint32_t EID = (18 << 0);  ///< Extended ID
    }

    /// MKIVLR Register bits
    namespace mkivlr_bits {
        constexpr uint32_t MB31 = (1U << 31);  ///< mailbox 31 Mask Invalid
        constexpr uint32_t MB30 = (1U << 30);  ///< mailbox 30 Mask Invalid
        constexpr uint32_t MB29 = (1U << 29);  ///< mailbox 29 Mask Invalid
        constexpr uint32_t MB28 = (1U << 28);  ///< mailbox 28 Mask Invalid
        constexpr uint32_t MB27 = (1U << 27);  ///< mailbox 27 Mask Invalid
        constexpr uint32_t MB26 = (1U << 26);  ///< mailbox 26 Mask Invalid
        constexpr uint32_t MB25 = (1U << 25);  ///< mailbox 25 Mask Invalid
        constexpr uint32_t MB24 = (1U << 24);  ///< mailbox 24 Mask Invalid
        constexpr uint32_t MB23 = (1U << 23);  ///< mailbox 23 Mask Invalid
        constexpr uint32_t MB22 = (1U << 22);  ///< mailbox 22 Mask Invalid
        constexpr uint32_t MB21 = (1U << 21);  ///< mailbox 21 Mask Invalid
        constexpr uint32_t MB20 = (1U << 20);  ///< mailbox 20 Mask Invalid
        constexpr uint32_t MB19 = (1U << 19);  ///< mailbox 19 Mask Invalid
        constexpr uint32_t MB18 = (1U << 18);  ///< mailbox 18 Mask Invalid
        constexpr uint32_t MB17 = (1U << 17);  ///< mailbox 17 Mask Invalid
        constexpr uint32_t MB16 = (1U << 16);  ///< mailbox 16 Mask Invalid
        constexpr uint32_t MB15 = (1U << 15);  ///< mailbox 15 Mask Invalid
        constexpr uint32_t MB14 = (1U << 14);  ///< mailbox 14 Mask Invalid
        constexpr uint32_t MB13 = (1U << 13);  ///< mailbox 13 Mask Invalid
        constexpr uint32_t MB12 = (1U << 12);  ///< mailbox 12 Mask Invalid
        constexpr uint32_t MB11 = (1U << 11);  ///< mailbox 11 Mask Invalid
        constexpr uint32_t MB10 = (1U << 10);  ///< mailbox 10 Mask Invalid
        constexpr uint32_t MB9 = (1U << 9);  ///< mailbox 9 Mask Invalid
        constexpr uint32_t MB8 = (1U << 8);  ///< mailbox 8 Mask Invalid
        constexpr uint32_t MB7 = (1U << 7);  ///< mailbox 7 Mask Invalid
        constexpr uint32_t MB6 = (1U << 6);  ///< mailbox 6 Mask Invalid
        constexpr uint32_t MB5 = (1U << 5);  ///< mailbox 5 Mask Invalid
        constexpr uint32_t MB4 = (1U << 4);  ///< mailbox 4 Mask Invalid
        constexpr uint32_t MB3 = (1U << 3);  ///< mailbox 3 Mask Invalid
        constexpr uint32_t MB2 = (1U << 2);  ///< mailbox 2 Mask Invalid
        constexpr uint32_t MB1 = (1U << 1);  ///< mailbox 1 Mask Invalid
        constexpr uint32_t MB0 = (1U << 0);  ///< mailbox 0 Mask Invalid
    }

    /// MIER Register bits
    namespace mier_bits {
        constexpr uint32_t MB31 = (1U << 31);  ///< mailbox 31 Interrupt Enable
        constexpr uint32_t MB30 = (1U << 30);  ///< mailbox 30 Interrupt Enable
        constexpr uint32_t MB29 = (1U << 29);  ///< mailbox 29 Interrupt Enable
        constexpr uint32_t MB28 = (1U << 28);  ///< mailbox 28 Interrupt Enable
        constexpr uint32_t MB27 = (1U << 27);  ///< mailbox 27 Interrupt Enable
        constexpr uint32_t MB26 = (1U << 26);  ///< mailbox 26 Interrupt Enable
        constexpr uint32_t MB25 = (1U << 25);  ///< mailbox 25 Interrupt Enable
        constexpr uint32_t MB24 = (1U << 24);  ///< mailbox 24 Interrupt Enable
        constexpr uint32_t MB23 = (1U << 23);  ///< mailbox 23 Interrupt Enable
        constexpr uint32_t MB22 = (1U << 22);  ///< mailbox 22 Interrupt Enable
        constexpr uint32_t MB21 = (1U << 21);  ///< mailbox 21 Interrupt Enable
        constexpr uint32_t MB20 = (1U << 20);  ///< mailbox 20 Interrupt Enable
        constexpr uint32_t MB19 = (1U << 19);  ///< mailbox 19 Interrupt Enable
        constexpr uint32_t MB18 = (1U << 18);  ///< mailbox 18 Interrupt Enable
        constexpr uint32_t MB17 = (1U << 17);  ///< mailbox 17 Interrupt Enable
        constexpr uint32_t MB16 = (1U << 16);  ///< mailbox 16 Interrupt Enable
        constexpr uint32_t MB15 = (1U << 15);  ///< mailbox 15 Interrupt Enable
        constexpr uint32_t MB14 = (1U << 14);  ///< mailbox 14 Interrupt Enable
        constexpr uint32_t MB13 = (1U << 13);  ///< mailbox 13 Interrupt Enable
        constexpr uint32_t MB12 = (1U << 12);  ///< mailbox 12 Interrupt Enable
        constexpr uint32_t MB11 = (1U << 11);  ///< mailbox 11 Interrupt Enable
        constexpr uint32_t MB10 = (1U << 10);  ///< mailbox 10 Interrupt Enable
        constexpr uint32_t MB9 = (1U << 9);  ///< mailbox 9 Interrupt Enable
        constexpr uint32_t MB8 = (1U << 8);  ///< mailbox 8 Interrupt Enable
        constexpr uint32_t MB7 = (1U << 7);  ///< mailbox 7 Interrupt Enable
        constexpr uint32_t MB6 = (1U << 6);  ///< mailbox 6 Interrupt Enable
        constexpr uint32_t MB5 = (1U << 5);  ///< mailbox 5 Interrupt Enable
        constexpr uint32_t MB4 = (1U << 4);  ///< mailbox 4 Interrupt Enable
        constexpr uint32_t MB3 = (1U << 3);  ///< mailbox 3 Interrupt Enable
        constexpr uint32_t MB2 = (1U << 2);  ///< mailbox 2 Interrupt Enable
        constexpr uint32_t MB1 = (1U << 1);  ///< mailbox 1 Interrupt Enable
        constexpr uint32_t MB0 = (1U << 0);  ///< mailbox 0 Interrupt Enable
    }

    /// MIER_FIFO Register bits
    namespace mier_fifo_bits {
        constexpr uint32_t MB29 = (1U << 29);  ///< Receive FIFO Interrupt Generation Timing Control
        constexpr uint32_t MB28 = (1U << 28);  ///< Receive FIFO Interrupt Enable
        constexpr uint32_t MB25 = (1U << 25);  ///< Transmit FIFO Interrupt Generation Timing Control
        constexpr uint32_t MB24 = (1U << 24);  ///< Transmit FIFO Interrupt Enable
        constexpr uint32_t MB23 = (1U << 23);  ///< mailbox 23 Interrupt Enable
        constexpr uint32_t MB22 = (1U << 22);  ///< mailbox 22 Interrupt Enable
        constexpr uint32_t MB21 = (1U << 21);  ///< mailbox 21 Interrupt Enable
        constexpr uint32_t MB20 = (1U << 20);  ///< mailbox 20 Interrupt Enable
        constexpr uint32_t MB19 = (1U << 19);  ///< mailbox 19 Interrupt Enable
        constexpr uint32_t MB18 = (1U << 18);  ///< mailbox 18 Interrupt Enable
        constexpr uint32_t MB17 = (1U << 17);  ///< mailbox 17 Interrupt Enable
        constexpr uint32_t MB16 = (1U << 16);  ///< mailbox 16 Interrupt Enable
        constexpr uint32_t MB15 = (1U << 15);  ///< mailbox 15 Interrupt Enable
        constexpr uint32_t MB14 = (1U << 14);  ///< mailbox 14 Interrupt Enable
        constexpr uint32_t MB13 = (1U << 13);  ///< mailbox 13 Interrupt Enable
        constexpr uint32_t MB12 = (1U << 12);  ///< mailbox 12 Interrupt Enable
        constexpr uint32_t MB11 = (1U << 11);  ///< mailbox 11 Interrupt Enable
        constexpr uint32_t MB10 = (1U << 10);  ///< mailbox 10 Interrupt Enable
        constexpr uint32_t MB9 = (1U << 9);  ///< mailbox 9 Interrupt Enable
        constexpr uint32_t MB8 = (1U << 8);  ///< mailbox 8 Interrupt Enable
        constexpr uint32_t MB7 = (1U << 7);  ///< mailbox 7 Interrupt Enable
        constexpr uint32_t MB6 = (1U << 6);  ///< mailbox 6 Interrupt Enable
        constexpr uint32_t MB5 = (1U << 5);  ///< mailbox 5 Interrupt Enable
        constexpr uint32_t MB4 = (1U << 4);  ///< mailbox 4 Interrupt Enable
        constexpr uint32_t MB3 = (1U << 3);  ///< mailbox 3 Interrupt Enable
        constexpr uint32_t MB2 = (1U << 2);  ///< mailbox 2 Interrupt Enable
        constexpr uint32_t MB1 = (1U << 1);  ///< mailbox 1 Interrupt Enable
        constexpr uint32_t MB0 = (1U << 0);  ///< mailbox 0 Interrupt Enable
    }

    /// MCTL_TX__ Register bits
    namespace mctl_tx___bits {
        constexpr uint32_t TRMREQ = (1U << 7);  ///< Transmit Mailbox Request
        constexpr uint32_t RECREQ = (1U << 6);  ///< Receive Mailbox Request
        constexpr uint32_t ONESHOT = (1U << 4);  ///< One-Shot Enable
        constexpr uint32_t TRMABT = (1U << 2);  ///< Transmission Abort Complete Flag (Transmit mailbox setting enabled)
        constexpr uint32_t TRMACTIVE = (1U << 1);  ///< Transmission-in-Progress Status Flag (Transmit mailbox setting enabled)
        constexpr uint32_t SENTDATA = (1U << 0);  ///< Transmission Complete Flag
    }

    /// MCTL_RX__ Register bits
    namespace mctl_rx___bits {
        constexpr uint32_t TRMREQ = (1U << 7);  ///< Transmit Mailbox Request
        constexpr uint32_t RECREQ = (1U << 6);  ///< Receive Mailbox Request
        constexpr uint32_t ONESHOT = (1U << 4);  ///< One-Shot Enable
        constexpr uint32_t MSGLOST = (1U << 2);  ///< Message Lost Flag(Receive mailbox setting enabled)
        constexpr uint32_t INVALDATA = (1U << 1);  ///< Reception-in-Progress Status Flag (Receive mailbox setting enabled)
        constexpr uint32_t NEWDATA = (1U << 0);  ///< Reception Complete Flag
    }

    /// CTLR Register bits
    namespace ctlr_bits {
        constexpr uint32_t RBOC = (1U << 13);  ///< Forcible Return From Bus-Off
        constexpr uint32_t BOM = (2 << 11);  ///< Bus-Off Recovery Mode by a program request
        constexpr uint32_t SLPM = (1U << 10);  ///< CAN Sleep Mode
        constexpr uint32_t CANM = (2 << 8);  ///< CAN Operating Mode Select
        constexpr uint32_t TSPS = (2 << 6);  ///< Time Stamp Prescaler Select
        constexpr uint32_t TSRC = (1U << 5);  ///< Time Stamp Counter Reset Command
        constexpr uint32_t TPM = (1U << 4);  ///< Transmission Priority Mode Select
        constexpr uint32_t MLM = (1U << 3);  ///< Message Lost Mode Select
        constexpr uint32_t IDFM = (2 << 1);  ///< ID Format Mode Select
        constexpr uint32_t MBM = (1U << 0);  ///< CAN Mailbox Mode Select
    }

    /// STR Register bits
    namespace str_bits {
        constexpr uint32_t RECST = (1U << 14);  ///< Receive Status Flag (receiver)
        constexpr uint32_t TRMST = (1U << 13);  ///< Transmit Status Flag (transmitter)
        constexpr uint32_t BOST = (1U << 12);  ///< Bus-Off Status Flag
        constexpr uint32_t EPST = (1U << 11);  ///< Error-Passive Status Flag
        constexpr uint32_t SLPST = (1U << 10);  ///< CAN Sleep Status Flag
        constexpr uint32_t HLTST = (1U << 9);  ///< CAN Halt Status Flag
        constexpr uint32_t RSTST = (1U << 8);  ///< CAN Reset Status Flag
        constexpr uint32_t EST = (1U << 7);  ///< Error Status Flag
        constexpr uint32_t TABST = (1U << 6);  ///< Transmission Abort Status Flag
        constexpr uint32_t FMLST = (1U << 5);  ///< FIFO Mailbox Message Lost Status Flag
        constexpr uint32_t NMLST = (1U << 4);  ///< Normal Mailbox Message Lost Status Flag
        constexpr uint32_t TFST = (1U << 3);  ///< Transmit FIFO Status Flag
        constexpr uint32_t RFST = (1U << 2);  ///< Receive FIFO Status Flag
        constexpr uint32_t SDST = (1U << 1);  ///< SENTDATA Status Flag
        constexpr uint32_t NDST = (1U << 0);  ///< NEWDATA Status Flag
    }

    /// BCR Register bits
    namespace bcr_bits {
        constexpr uint32_t TSEG1 = (4 << 28);  ///< Time Segment 1 Control
        constexpr uint32_t BRP = (10 << 16);  ///< Prescaler Division Ratio Select . These bits set the frequency of the CAN communication clock (fCANCLK).
        constexpr uint32_t SJW = (2 << 12);  ///< Resynchronization Jump Width Control
        constexpr uint32_t TSEG2 = (3 << 8);  ///< Time Segment 2 Control
        constexpr uint32_t CCLKS = (1U << 0);  ///< CAN Clock Source Selection
    }

    /// RFCR Register bits
    namespace rfcr_bits {
        constexpr uint32_t RFEST = (1U << 7);  ///< Receive FIFO Empty Status Flag
        constexpr uint32_t RFWST = (1U << 6);  ///< Receive FIFO Buffer Warning Status Flag
        constexpr uint32_t RFFST = (1U << 5);  ///< Receive FIFO Full Status Flag
        constexpr uint32_t RFMLF = (1U << 4);  ///< Receive FIFO Message Lost Flag
        constexpr uint32_t RFUST = (3 << 1);  ///< Receive FIFO Unread Message Number Status
        constexpr uint32_t RFE = (1U << 0);  ///< Receive FIFO Enable
    }

    /// RFPCR Register bits
    namespace rfpcr_bits {
        constexpr uint32_t RFPCR = (8 << 0);  ///< The CPU-side pointer for the receive FIFO is incremented by writing FFh to RFPCR.
    }

    /// TFCR Register bits
    namespace tfcr_bits {
        constexpr uint32_t TFEST = (1U << 7);  ///< Transmit FIFO Empty Status
        constexpr uint32_t TFFST = (1U << 6);  ///< Transmit FIFO Full Status
        constexpr uint32_t TFUST = (3 << 1);  ///< Transmit FIFO Unsent Message Number Status
        constexpr uint32_t TFE = (1U << 0);  ///< Transmit FIFO Enable
    }

    /// TFPCR Register bits
    namespace tfpcr_bits {
        constexpr uint32_t TFPCR = (8 << 0);  ///< The CPU-side pointer for the transmit FIFO is incremented by writing FFh to TFPCR.
    }

    /// EIER Register bits
    namespace eier_bits {
        constexpr uint32_t BLIE = (1U << 7);  ///< Bus Lock Interrupt Enable
        constexpr uint32_t OLIE = (1U << 6);  ///< Overload Frame Transmit Interrupt Enable
        constexpr uint32_t ORIE = (1U << 5);  ///< Overrun Interrupt Enable
        constexpr uint32_t BORIE = (1U << 4);  ///< Bus-Off Recovery Interrupt Enable
        constexpr uint32_t BOEIE = (1U << 3);  ///< Bus-Off Entry Interrupt Enable
        constexpr uint32_t EPIE = (1U << 2);  ///< Error-Passive Interrupt Enable
        constexpr uint32_t EWIE = (1U << 1);  ///< Error-Warning Interrupt Enable
        constexpr uint32_t BEIE = (1U << 0);  ///< Bus Error Interrupt Enable
    }

    /// EIFR Register bits
    namespace eifr_bits {
        constexpr uint32_t BLIF = (1U << 7);  ///< Bus Lock Detect Flag
        constexpr uint32_t OLIF = (1U << 6);  ///< Overload Frame Transmission Detect Flag
        constexpr uint32_t ORIF = (1U << 5);  ///< Receive Overrun Detect Flag
        constexpr uint32_t BORIF = (1U << 4);  ///< Bus-Off Recovery Detect Flag
        constexpr uint32_t BOEIF = (1U << 3);  ///< Bus-Off Entry Detect Flag
        constexpr uint32_t EPIF = (1U << 2);  ///< Error-Passive Detect Flag
        constexpr uint32_t EWIF = (1U << 1);  ///< Error-Warning Detect Flag
        constexpr uint32_t BEIF = (1U << 0);  ///< Bus Error Detect Flag
    }

    /// RECR Register bits
    namespace recr_bits {
        constexpr uint32_t RECR = (8 << 0);  ///< Receive error count functionRECR increments or decrements the counter value according to the error status of the CAN module during reception.
    }

    /// TECR Register bits
    namespace tecr_bits {
        constexpr uint32_t TECR = (8 << 0);  ///< Transmit error count functionTECR increments or decrements the counter value according to the error status of the CAN module during transmission.
    }

    /// ECSR Register bits
    namespace ecsr_bits {
        constexpr uint32_t EDPM = (1U << 7);  ///< Error Display Mode Select
        constexpr uint32_t ADEF = (1U << 6);  ///< ACK Delimiter Error Flag
        constexpr uint32_t BE0F = (1U << 5);  ///< Bit Error (dominant) Flag
        constexpr uint32_t BE1F = (1U << 4);  ///< Bit Error (recessive) Flag
        constexpr uint32_t CEF = (1U << 3);  ///< CRC Error Flag
        constexpr uint32_t AEF = (1U << 2);  ///< ACK Error Flag
        constexpr uint32_t FEF = (1U << 1);  ///< Form Error Flag
        constexpr uint32_t SEF = (1U << 0);  ///< Stuff Error Flag
    }

    /// CSSR Register bits
    namespace cssr_bits {
        constexpr uint32_t CSSR = (8 << 0);  ///< When the value for the channel search is input, the channel number is output to MSSR.
    }

    /// MSSR Register bits
    namespace mssr_bits {
        constexpr uint32_t SEST = (1U << 7);  ///< Search Result Status
        constexpr uint32_t MBNST = (5 << 0);  ///< Search Result Mailbox Number Status These bits output the smallest mailbox number that is searched in each mode of MSMR.
    }

    /// MSMR Register bits
    namespace msmr_bits {
        constexpr uint32_t MBSM = (2 << 0);  ///< Mailbox Search Mode Select
    }

    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (16 << 0);  ///< Free-running counter value for the time stamp function
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t AFSR = (16 << 0);  ///< After the standard ID of a received message is written, the value converted for data table search can be read.
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TSTM = (2 << 1);  ///< CAN Test Mode Select
        constexpr uint32_t TSTE = (1U << 0);  ///< CAN Test Mode Enable
    }

}

// ============================================================================
// IRDA Peripheral
// ============================================================================

namespace irda {
    /// Base addresses
    constexpr uint32_t IRDA_BASE = 0x40070F00;

    /// IRDA Register structure
    struct Registers {
        volatile uint32_t IRCR;  ///< Offset: 0x00 - IrDA Control Register
    };

    /// Peripheral instances
    inline Registers* IRDA = reinterpret_cast<Registers*>(IRDA_BASE);

    // Bit definitions
    /// IRCR Register bits
    namespace ircr_bits {
        constexpr uint32_t IRE = (1U << 7);  ///< IrDA Enable
        constexpr uint32_t IRTXINV = (1U << 3);  ///< IRTXD Polarity Switching
        constexpr uint32_t IRRXINV = (1U << 2);  ///< IRRXD Polarity Switching
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40072000;
    constexpr uint32_t SPI1_BASE = 0x40072100;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPCR;  ///< Offset: 0x00 - SPI Control Register
        volatile uint32_t SSLP;  ///< Offset: 0x01 - SPI Slave Select Polarity Register
        volatile uint32_t SPPCR;  ///< Offset: 0x02 - RSPI Pin Control Register
        volatile uint32_t SPSR;  ///< Offset: 0x03 - SPI Status Register
        volatile uint32_t SPDR;  ///< Offset: 0x04 - SPI Data Register
        volatile uint32_t SPDR_HA;  ///< Offset: 0x04 - SPI Data Register ( halfword access )
        volatile uint32_t SPSCR;  ///< Offset: 0x08 - SPI Sequence Control Register
        volatile uint32_t SPSSR;  ///< Offset: 0x09 - SPI Sequence Status Register
        volatile uint32_t SPBR;  ///< Offset: 0x0A - SPI Bit Rate Register
        volatile uint32_t SPDCR;  ///< Offset: 0x0B - SPI Data Control Register
        volatile uint32_t SPCKD;  ///< Offset: 0x0C - SPI Clock Delay Register
        volatile uint32_t SSLND;  ///< Offset: 0x0D - SPI Slave Select Negation Delay Register
        volatile uint32_t SPND;  ///< Offset: 0x0E - SPI Next-Access Delay Register
        volatile uint32_t SPCR2;  ///< Offset: 0x0F - SPI Control Register 2
        volatile uint32_t SPCMD;  ///< Offset: 0x10 - SPI Command Register %s (renamed from SPCMD)
        volatile uint32_t SPDCR2;  ///< Offset: 0x20 - SPI Data Control Register 2
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

    // Bit definitions
    /// SPCR Register bits
    namespace spcr_bits {
        constexpr uint32_t SPRIE = (1U << 7);  ///< SPI Receive Buffer Full Interrupt Enable
        constexpr uint32_t SPE = (1U << 6);  ///< SPI Function Enable
        constexpr uint32_t SPTIE = (1U << 5);  ///< Transmit Buffer Empty Interrupt Enable
        constexpr uint32_t SPEIE = (1U << 4);  ///< SPI Error Interrupt Enable
        constexpr uint32_t MSTR = (1U << 3);  ///< SPI Master/Slave Mode Select
        constexpr uint32_t MODFEN = (1U << 2);  ///< Mode Fault Error Detection Enable
        constexpr uint32_t TXMD = (1U << 1);  ///< Communications Operating Mode Select
        constexpr uint32_t SPMS = (1U << 0);  ///< SPI Mode Select
    }

    /// SSLP Register bits
    namespace sslp_bits {
        constexpr uint32_t SSL3P = (1U << 3);  ///< SSL3 Signal Polarity Setting
        constexpr uint32_t SSL2P = (1U << 2);  ///< SSL2 Signal Polarity Setting
        constexpr uint32_t SSL1P = (1U << 1);  ///< SSL1 Signal Polarity Setting
        constexpr uint32_t SSL0P = (1U << 0);  ///< SSL0 Signal Polarity Setting
    }

    /// SPPCR Register bits
    namespace sppcr_bits {
        constexpr uint32_t MOIFE = (1U << 5);  ///< MOSI Idle Value Fixing Enable
        constexpr uint32_t MOIFV = (1U << 4);  ///< MOSI Idle Fixed Value
        constexpr uint32_t SPLP2 = (1U << 1);  ///< RSPI Loopback 2
        constexpr uint32_t SPLP = (1U << 0);  ///< RSPI Loopback
    }

    /// SPSR Register bits
    namespace spsr_bits {
        constexpr uint32_t SPRF = (1U << 7);  ///< SPI Receive Buffer Full Flag
        constexpr uint32_t SPTEF = (1U << 5);  ///< SPI Transmit Buffer Empty Flag
        constexpr uint32_t UDRF = (1U << 4);  ///< Underrun Error Flag(When MODF is 0, This bit is invalid.)
        constexpr uint32_t PERF = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t MODF = (1U << 2);  ///< Mode Fault Error Flag
        constexpr uint32_t IDLNF = (1U << 1);  ///< SPI Idle Flag
        constexpr uint32_t OVRF = (1U << 0);  ///< Overrun Error Flag
    }

    /// SPDR Register bits
    namespace spdr_bits {
        constexpr uint32_t SPDR = (32 << 0);  ///< SPDR is the interface with the buffers that hold data for transmission and reception by the RSPI.When accessing in word (SPDCR.SPLW=1), access SPDR.
    }

    /// SPDR_HA Register bits
    namespace spdr_ha_bits {
        constexpr uint32_t SPDR_HA = (16 << 0);  ///< SPDR is the interface with the buffers that hold data for transmission and reception by the RSPI.When accessing in halfword (SPDCR.SPLW=0), access SPDR_HA.
    }

    /// SPSCR Register bits
    namespace spscr_bits {
        constexpr uint32_t SPSLN = (3 << 0);  ///< RSPI Sequence Length SpecificationThe order in which the SPCMD0 to SPCMD07 registers are to be referenced is changed in accordance with the sequence length that is set in these bits. The relationship among the setting of these bits, sequence length, and SPCMD0 to SPCMD7 registers referenced by the RSPI is shown above. However, the RSPI in slave mode always references SPCMD0.
    }

    /// SPSSR Register bits
    namespace spssr_bits {
        constexpr uint32_t SPECM = (3 << 4);  ///< RSPI Error Command
        constexpr uint32_t SPCP = (3 << 0);  ///< RSPI Command Pointer
    }

    /// SPBR Register bits
    namespace spbr_bits {
        constexpr uint32_t SPR = (8 << 0);  ///< SPBR sets the bit rate in master mode.
    }

    /// SPDCR Register bits
    namespace spdcr_bits {
        constexpr uint32_t SPBYT = (1U << 6);  ///< SPI Byte Access Specification
        constexpr uint32_t SPLW = (1U << 5);  ///< SPI Word Access/Halfword Access Specification
        constexpr uint32_t SPRDTD = (1U << 4);  ///< RSPI Receive/Transmit Data Selection
        constexpr uint32_t SPFC = (2 << 0);  ///< Number of Frames Specification
    }

    /// SPCKD Register bits
    namespace spckd_bits {
        constexpr uint32_t SCKDL = (3 << 0);  ///< RSPCK Delay Setting
    }

    /// SSLND Register bits
    namespace sslnd_bits {
        constexpr uint32_t SLNDL = (3 << 0);  ///< SSL Negation Delay Setting
    }

    /// SPND Register bits
    namespace spnd_bits {
        constexpr uint32_t SPNDL = (3 << 0);  ///< SPI Next-Access Delay Setting
    }

    /// SPCR2 Register bits
    namespace spcr2_bits {
        constexpr uint32_t SCKASE = (1U << 4);  ///< RSPCK Auto-Stop Function Enable
        constexpr uint32_t PTE = (1U << 3);  ///< Parity Self-Testing
        constexpr uint32_t SPIIE = (1U << 2);  ///< SPI Idle Interrupt Enable
        constexpr uint32_t SPOE = (1U << 1);  ///< Parity Mode
        constexpr uint32_t SPPE = (1U << 0);  ///< Parity Enable
    }

    /// SPCMD Register bits
    namespace spcmd_bits {
        constexpr uint32_t SCKDEN = (1U << 15);  ///< RSPCK Delay Setting Enable
        constexpr uint32_t SLNDEN = (1U << 14);  ///< SSL Negation Delay Setting Enable
        constexpr uint32_t SPNDEN = (1U << 13);  ///< RSPI Next-Access Delay Enable
        constexpr uint32_t LSBF = (1U << 12);  ///< RSPI LSB First
        constexpr uint32_t SPB = (4 << 8);  ///< RSPI Data Length Setting
        constexpr uint32_t SSLKP = (1U << 7);  ///< SSL Signal Level Keeping
        constexpr uint32_t SSLA = (3 << 4);  ///< SSL Signal Assertion Setting
        constexpr uint32_t BRDV = (2 << 2);  ///< Bit Rate Division Setting
        constexpr uint32_t CPOL = (1U << 1);  ///< RSPCK Polarity Setting
        constexpr uint32_t CPHA = (1U << 0);  ///< RSPCK Phase Setting
    }

    /// SPDCR2 Register bits
    namespace spdcr2_bits {
        constexpr uint32_t BYSW = (1U << 0);  ///< Byte Swap Operating Mode Select
    }

}

// ============================================================================
// SRCRAM Peripheral
// ============================================================================

namespace srcram {
    /// Base addresses
    constexpr uint32_t SRCRAM_BASE = 0x40048000;

    /// SRCRAM Register structure
    struct Registers {
        volatile uint32_t SRCFCTR__;  ///< Offset: 0x00 - Filter Coefficient Table [%s] (renamed from SRCFCTR__)
    };

    /// Peripheral instances
    inline Registers* SRCRAM = reinterpret_cast<Registers*>(SRCRAM_BASE);

    // Bit definitions
    /// SRCFCTR__ Register bits
    namespace srcfctr___bits {
        constexpr uint32_t SRCFCOE = (22 << 0);  ///< Stores a filter coefficient value.
    }

}

// ============================================================================
// SRC Peripheral
// ============================================================================

namespace src {
    /// Base addresses
    constexpr uint32_t SRC_BASE = 0x4004DFF0;

    /// SRC Register structure
    struct Registers {
        volatile uint32_t SRCID;  ///< Offset: 0x00 - Input Data Register
        volatile uint32_t SRCOD;  ///< Offset: 0x04 - Output Data Register
        volatile uint32_t SRCIDCTRL;  ///< Offset: 0x08 - Input Data Control Register
        volatile uint32_t SRCODCTRL;  ///< Offset: 0x0A - Output Data Control Register
        volatile uint32_t SRCCTRL;  ///< Offset: 0x0C - Control Register
        volatile uint32_t SRCSTAT;  ///< Offset: 0x0E - Status Register
    };

    /// Peripheral instances
    inline Registers* SRC = reinterpret_cast<Registers*>(SRC_BASE);

    // Bit definitions
    /// SRCID Register bits
    namespace srcid_bits {
        constexpr uint32_t SRCID = (32 << 0);  ///< SRCID is a 32-bit writ-only register that is used to input the data before sampling rate conversion. All the bits are read as 0.
    }

    /// SRCOD Register bits
    namespace srcod_bits {
        constexpr uint32_t SRCOD = (32 << 0);  ///< SRCOD is a 32-bit read-only register used to output the data after sampling rate conversion. The data in the 16-stage output data FIFO is read through SRCOD. When the number of data in the output data FIFO is zero after the start of conversion, the value previously read is read again.
    }

    /// SRCIDCTRL Register bits
    namespace srcidctrl_bits {
        constexpr uint32_t IED = (1U << 9);  ///< Input Data Endian
        constexpr uint32_t IEN = (1U << 8);  ///< Input FIFO Empty Interrupt Enable
        constexpr uint32_t IFTRG = (2 << 0);  ///< Input FIFO Data Triggering Number
    }

    /// SRCODCTRL Register bits
    namespace srcodctrl_bits {
        constexpr uint32_t OCH = (1U << 10);  ///< Output Data Channel Exchange
        constexpr uint32_t OED = (1U << 9);  ///< Output Data Endian
        constexpr uint32_t OEN = (1U << 8);  ///< Output Data FIFO Full Interrupt Enable
        constexpr uint32_t OFTRG = (2 << 0);  ///< Output FIFO Data Trigger Number
    }

    /// SRCCTRL Register bits
    namespace srcctrl_bits {
        constexpr uint32_t FICRAE = (1U << 15);  ///< Filter Coefficient Table Access Enable
        constexpr uint32_t CEEN = (1U << 13);  ///< Conversion End Interrupt Enable
        constexpr uint32_t SRCEN = (1U << 12);  ///< Module Enable
        constexpr uint32_t UDEN = (1U << 11);  ///< Output Data FIFO Underflow Interrupt Enable
        constexpr uint32_t OVEN = (1U << 10);  ///< Output Data FIFO Overwrite Interrupt Enable
        constexpr uint32_t FL = (1U << 9);  ///< Internal Work Memory Flush
        constexpr uint32_t CL = (1U << 8);  ///< Internal Work Memory Clear
        constexpr uint32_t IFS = (4 << 4);  ///< Input Sampling Rate
        constexpr uint32_t OFS = (3 << 0);  ///< Output Sampling Rate
    }

    /// SRCSTAT Register bits
    namespace srcstat_bits {
        constexpr uint32_t OFDN = (5 << 11);  ///< Output FIFO Data Count
        constexpr uint32_t IFDN = (4 << 7);  ///< Input FIFO Data Count
        constexpr uint32_t CEF = (1U << 5);  ///< Conversion End Flag
        constexpr uint32_t FLF = (1U << 4);  ///< Flush Processing Status Flag
        constexpr uint32_t UDF = (1U << 3);  ///< Output FIFO Underflow Interrupt Request Flag
        constexpr uint32_t OVF = (1U << 2);  ///< Output Data FIFO Overwrite Interrupt Request Flag
        constexpr uint32_t IINT = (1U << 1);  ///< Input Data FIFO Empty Interrupt Request Flag
        constexpr uint32_t OINT = (1U << 0);  ///< Output Data FIFO Full Interrupt Request Flag
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0x4001B000;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t DBGSTR;  ///< Offset: 0x00 - Debug Status Register
        volatile uint32_t DBGSTOPCR;  ///< Offset: 0x10 - Debug Stop Control Register
        volatile uint32_t TRACECTR;  ///< Offset: 0x20 - Trace Control Register
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// DBGSTR Register bits
    namespace dbgstr_bits {
        constexpr uint32_t CDBGPWRUPACK = (1U << 29);  ///< Debug power-up acknowledge
        constexpr uint32_t CDBGPWRUPREQ = (1U << 28);  ///< Debug power-up request
    }

    /// DBGSTOPCR Register bits
    namespace dbgstopcr_bits {
        constexpr uint32_t DBGSTOP_RECCR = (1U << 25);  ///< Mask bit for RAM ECC error reset/interrupt
        constexpr uint32_t DBGSTOP_RPER = (1U << 24);  ///< Mask bit for RAM parity error reset/interrupt
        constexpr uint32_t DBGSTOP_LVD = (3 << 16);  ///< b18: Mask bit for LVD2 reset/interrupt (0:enable / 1:Mask)b17: Mask bit for LVD1 reset/interrupt (0:enable / 1:Mask)b16: Mask bit for LVD0 reset (0:enable / 1:Mask)
        constexpr uint32_t DBGSTOP_WDT = (1U << 1);  ///< Mask bit for WDT reset/interrupt
        constexpr uint32_t DBGSTOP_IWDT = (1U << 0);  ///< Mask bit for IWDT reset/interrupt
    }

    /// TRACECTR Register bits
    namespace tracectr_bits {
        constexpr uint32_t ENETBFULL = (1U << 31);  ///< Enable bit for halt request by ETB full
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMAC0_BASE = 0x40005000;
    constexpr uint32_t DMAC1_BASE = 0x40005040;
    constexpr uint32_t DMAC2_BASE = 0x40005080;
    constexpr uint32_t DMAC3_BASE = 0x400050C0;
    constexpr uint32_t DMAC4_BASE = 0x40005100;
    constexpr uint32_t DMAC5_BASE = 0x40005140;
    constexpr uint32_t DMAC6_BASE = 0x40005180;
    constexpr uint32_t DMAC7_BASE = 0x400051C0;
    constexpr uint32_t DMA_BASE = 0x40005200;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMSAR;  ///< Offset: 0x00 - DMA Source Address Register
        volatile uint32_t DMDAR;  ///< Offset: 0x04 - DMA Destination Address Register
        volatile uint32_t DMCRA;  ///< Offset: 0x08 - DMA Transfer Count Register
        volatile uint32_t DMCRB;  ///< Offset: 0x0C - DMA Block Transfer Count Register
        volatile uint32_t DMTMD;  ///< Offset: 0x10 - DMA Transfer Mode Register
        volatile uint32_t DMINT;  ///< Offset: 0x13 - DMA Interrupt Setting Register
        volatile uint32_t DMAMD;  ///< Offset: 0x14 - DMA Address Mode Register
        volatile uint32_t DMOFR;  ///< Offset: 0x18 - DMA Offset Register
        volatile uint32_t DMCNT;  ///< Offset: 0x1C - DMA Transfer Enable Register
        volatile uint32_t DMREQ;  ///< Offset: 0x1D - DMA Software Start Register
        volatile uint32_t DMSTS;  ///< Offset: 0x1E - DMAC Module Activation Register
    };

    /// Peripheral instances
    inline Registers* DMAC0 = reinterpret_cast<Registers*>(DMAC0_BASE);
    inline Registers* DMAC1 = reinterpret_cast<Registers*>(DMAC1_BASE);
    inline Registers* DMAC2 = reinterpret_cast<Registers*>(DMAC2_BASE);
    inline Registers* DMAC3 = reinterpret_cast<Registers*>(DMAC3_BASE);
    inline Registers* DMAC4 = reinterpret_cast<Registers*>(DMAC4_BASE);
    inline Registers* DMAC5 = reinterpret_cast<Registers*>(DMAC5_BASE);
    inline Registers* DMAC6 = reinterpret_cast<Registers*>(DMAC6_BASE);
    inline Registers* DMAC7 = reinterpret_cast<Registers*>(DMAC7_BASE);
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

    // Bit definitions
    /// DMSAR Register bits
    namespace dmsar_bits {
        constexpr uint32_t DMSAR = (32 << 0);  ///< Specifies the transfer source start address.
    }

    /// DMDAR Register bits
    namespace dmdar_bits {
        constexpr uint32_t DMDAR = (32 << 0);  ///< Specifies the transfer destination start address.
    }

    /// DMCRA Register bits
    namespace dmcra_bits {
        constexpr uint32_t DMCRAH = (10 << 16);  ///< Upper bits of transfer count
        constexpr uint32_t DMCRAL = (16 << 0);  ///< Lower bits of transfer count
    }

    /// DMCRB Register bits
    namespace dmcrb_bits {
        constexpr uint32_t DMCRB = (16 << 0);  ///< Specifies the number of block transfer operations or repeat transfer operations.
    }

    /// DMTMD Register bits
    namespace dmtmd_bits {
        constexpr uint32_t MD = (2 << 14);  ///< Transfer Mode Select
        constexpr uint32_t DTS = (2 << 12);  ///< Repeat Area Select
        constexpr uint32_t SZ = (2 << 8);  ///< Transfer Data Size Select
        constexpr uint32_t DCTG = (2 << 0);  ///< Transfer Request Source Select
    }

    /// DMINT Register bits
    namespace dmint_bits {
        constexpr uint32_t DTIE = (1U << 4);  ///< Transfer End Interrupt Enable
        constexpr uint32_t ESIE = (1U << 3);  ///< Transfer Escape End Interrupt Enable
        constexpr uint32_t RPTIE = (1U << 2);  ///< Repeat Size End Interrupt Enable
        constexpr uint32_t SARIE = (1U << 1);  ///< Source Address Extended Repeat Area Overflow Interrupt Enable
        constexpr uint32_t DARIE = (1U << 0);  ///< Destination Address Extended Repeat Area Overflow Interrupt Enable
    }

    /// DMAMD Register bits
    namespace dmamd_bits {
        constexpr uint32_t SM = (2 << 14);  ///< Source Address Update Mode
        constexpr uint32_t SARA = (5 << 8);  ///< Source Address Extended Repeat Area Specifies the extended repeat area on the source address. For details on the settings.
        constexpr uint32_t DM = (2 << 6);  ///< Destination Address Update Mode
        constexpr uint32_t DARA = (5 << 0);  ///< Destination Address Extended Repeat Area Specifies the extended repeat area on the destination address. For details on the settings.
    }

    /// DMOFR Register bits
    namespace dmofr_bits {
        constexpr uint32_t DMOFR = (32 << 0);  ///< Specifies the offset when offset addition is selected as the address update mode for transfer source or destination.
    }

    /// DMCNT Register bits
    namespace dmcnt_bits {
        constexpr uint32_t DTE = (1U << 0);  ///< DMA Transfer Enable
    }

    /// DMREQ Register bits
    namespace dmreq_bits {
        constexpr uint32_t CLRS = (1U << 4);  ///< DMA Software Start Bit Auto Clear Select
        constexpr uint32_t SWREQ = (1U << 0);  ///< DMA Software Start
    }

    /// DMSTS Register bits
    namespace dmsts_bits {
        constexpr uint32_t ACT = (1U << 7);  ///< DMA Active Flag
        constexpr uint32_t DTIF = (1U << 4);  ///< Transfer End Interrupt Flag
        constexpr uint32_t ESIF = (1U << 0);  ///< Transfer Escape End Interrupt Flag
    }

}

// ============================================================================
// DTC Peripheral
// ============================================================================

namespace dtc {
    /// Base addresses
    constexpr uint32_t DTC_BASE = 0x40005400;

    /// DTC Register structure
    struct Registers {
        volatile uint32_t DTCCR;  ///< Offset: 0x00 - DTC Control Register
        volatile uint32_t DTCVBR;  ///< Offset: 0x04 - DTC Vector Base Register
        volatile uint32_t DTCST;  ///< Offset: 0x0C - DTC Module Start Register
        volatile uint32_t DTCSTS;  ///< Offset: 0x0E - DTC Status Register
    };

    /// Peripheral instances
    inline Registers* DTC = reinterpret_cast<Registers*>(DTC_BASE);

    // Bit definitions
    /// DTCCR Register bits
    namespace dtccr_bits {
        constexpr uint32_t RRS = (1U << 4);  ///< DTC Transfer Information Read Skip Enable.
    }

    /// DTCVBR Register bits
    namespace dtcvbr_bits {
        constexpr uint32_t DTCVBR = (32 << 0);  ///< DTC Vector Base Address.Note: A value cannot be set in the lower-order 10 bits. These bits are fixed to 0.
    }

    /// DTCST Register bits
    namespace dtcst_bits {
        constexpr uint32_t DTCST = (1U << 0);  ///< DTC Module Start
    }

    /// DTCSTS Register bits
    namespace dtcsts_bits {
        constexpr uint32_t ACT = (1U << 15);  ///< DTC Active Flag
        constexpr uint32_t VECN = (8 << 0);  ///< DTC-Activating Vector Number MonitoringThese bits indicate the vector number for the activating source when DTC transfer is in progress.The value is only valid if DTC transfer is in progress (the value of the ACT flag is 1)
    }

}

// ============================================================================
// MMF Peripheral
// ============================================================================

namespace mmf {
    /// Base addresses
    constexpr uint32_t MMF_BASE = 0x40001000;

    /// MMF Register structure
    struct Registers {
        volatile uint32_t MMSFR;  ///< Offset: 0x00 - MemMirror Special Function Register
        volatile uint32_t MMEN;  ///< Offset: 0x04 - MemMirror Enable Register
    };

    /// Peripheral instances
    inline Registers* MMF = reinterpret_cast<Registers*>(MMF_BASE);

    // Bit definitions
    /// MMSFR Register bits
    namespace mmsfr_bits {
        constexpr uint32_t KEY = (8 << 24);  ///< MMSFR Key Code
        constexpr uint32_t MEMMIRADDR = (16 << 7);  ///< Specifies the memory mirror address.NOTE: A value cannot be set in the low-order 7 bits. These bits are fixed to 0.
    }

    /// MMEN Register bits
    namespace mmen_bits {
        constexpr uint32_t KEY = (8 << 24);  ///< MMEN Key Code
        constexpr uint32_t EN = (1U << 0);  ///< Memory Mirror Function Enable
    }

}

// ============================================================================
// SRAM Peripheral
// ============================================================================

namespace sram {
    /// Base addresses
    constexpr uint32_t SRAM_BASE = 0x40002000;

    /// SRAM Register structure
    struct Registers {
        volatile uint32_t PARIOAD;  ///< Offset: 0x00 - SRAM Parity Error Operation After Detection Register
        volatile uint32_t SRAMPRCR;  ///< Offset: 0x04 - SRAM Protection Register
        volatile uint32_t SRAMWTSC;  ///< Offset: 0x08 - RAM Wait State Control Register
        volatile uint32_t ECCMODE;  ///< Offset: 0xC0 - ECCRAM Operating Mode Control Register
        volatile uint32_t ECC2STS;  ///< Offset: 0xC1 - ECCRAM 2-Bit Error Status Register
        volatile uint32_t ECC1STSEN;  ///< Offset: 0xC2 - ECCRAM 1-Bit Error Information Update Enable Register
        volatile uint32_t ECC1STS;  ///< Offset: 0xC3 - ECCRAM 1-Bit Error Status Register
        volatile uint32_t ECCPRCR;  ///< Offset: 0xC4 - ECCRAM Protection Register
        volatile uint32_t ECCETST;  ///< Offset: 0xD4 - ECC Test Control Register
        volatile uint32_t ECCOAD;  ///< Offset: 0xD8 - RAM ECC Error Operation After Detection Register
    };

    /// Peripheral instances
    inline Registers* SRAM = reinterpret_cast<Registers*>(SRAM_BASE);

    // Bit definitions
    /// PARIOAD Register bits
    namespace parioad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after Detection
    }

    /// SRAMPRCR Register bits
    namespace sramprcr_bits {
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
        constexpr uint32_t SRAMPRCR = (1U << 0);  ///< Register Write Control
    }

    /// SRAMWTSC Register bits
    namespace sramwtsc_bits {
        constexpr uint32_t SRAM1WTEN = (1U << 3);  ///< SRAM1 Wait Enable
        constexpr uint32_t SRAM0WTEN = (1U << 2);  ///< SRAM0 Wait Enable
        constexpr uint32_t ECCRAMRDWTEN = (1U << 1);  ///< ECCRAM Read wait enable
    }

    /// ECCMODE Register bits
    namespace eccmode_bits {
        constexpr uint32_t ECCMOD = (2 << 0);  ///< ECC Operating Mode Select
    }

    /// ECC2STS Register bits
    namespace ecc2sts_bits {
        constexpr uint32_t ECC2ERR = (1U << 0);  ///< ECC 2-Bit Error Status
    }

    /// ECC1STSEN Register bits
    namespace ecc1stsen_bits {
        constexpr uint32_t E1STSEN = (1U << 0);  ///< ECC 1-Bit Error Information Update Enable
    }

    /// ECC1STS Register bits
    namespace ecc1sts_bits {
        constexpr uint32_t ECC1ERR = (1U << 0);  ///< ECC 1-Bit Error Status
    }

    /// ECCPRCR Register bits
    namespace eccprcr_bits {
        constexpr uint32_t KW = (7 << 1);  ///< Write Key Code
        constexpr uint32_t ECCPRCR = (1U << 0);  ///< ECCRAMETST Register Write Control
    }

    /// ECCETST Register bits
    namespace eccetst_bits {
        constexpr uint32_t TSTBYP = (1U << 0);  ///< ECC Bypass Select
    }

    /// ECCOAD Register bits
    namespace eccoad_bits {
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after Detection
    }

}

// ============================================================================
// FCACHE Peripheral
// ============================================================================

namespace fcache {
    /// Base addresses
    constexpr uint32_t FCACHE_BASE = 0x4001C000;

    /// FCACHE Register structure
    struct Registers {
        volatile uint32_t FCACHEE;  ///< Offset: 0x100 - Flash Cache Enable Register
        volatile uint32_t FCACHEIV;  ///< Offset: 0x104 - Flash Cache Invalidate Register
        volatile uint32_t FLWT;  ///< Offset: 0x11C - Flash Wait Cycle Register
    };

    /// Peripheral instances
    inline Registers* FCACHE = reinterpret_cast<Registers*>(FCACHE_BASE);

    // Bit definitions
    /// FCACHEE Register bits
    namespace fcachee_bits {
        constexpr uint32_t FCACHEEN = (1U << 0);  ///< FCACHE Enable
    }

    /// FCACHEIV Register bits
    namespace fcacheiv_bits {
        constexpr uint32_t FCACHEIV = (1U << 0);  ///< FCACHE Invalidation
    }

    /// FLWT Register bits
    namespace flwt_bits {
        constexpr uint32_t FLWT = (3 << 0);  ///< Flash Wait Cycle
    }

}

// ============================================================================
// SYSTEM Peripheral
// ============================================================================

namespace system {
    /// Base addresses
    constexpr uint32_t SYSTEM_BASE = 0x4001E000;

    /// SYSTEM Register structure
    struct Registers {
        volatile uint32_t FWEPROR;  ///< Offset: 0x416 - Flash P/E Protect Register
        volatile uint32_t VBTICTLR;  ///< Offset: 0x4BB - VBATT Input Control Register
        volatile uint32_t VBTBKR__;  ///< Offset: 0x500 - VBATT Backup Register [%s] (renamed from VBTBKR__)
        volatile uint32_t SCKDIVCR;  ///< Offset: 0x20 - System Clock Division Control Register
        volatile uint32_t SCKDIVCR2;  ///< Offset: 0x24 - System Clock Division Control Register 2
        volatile uint32_t SCKSCR;  ///< Offset: 0x26 - System Clock Source Control Register
        volatile uint32_t PLLCCR;  ///< Offset: 0x28 - PLL Clock Control Register
        volatile uint32_t PLLCR;  ///< Offset: 0x2A - PLL Control Register
        volatile uint32_t BCKCR;  ///< Offset: 0x30 - External Bus Clock Control Register
        volatile uint32_t MOSCCR;  ///< Offset: 0x32 - Main Clock Oscillator Control Register
        volatile uint32_t HOCOCR;  ///< Offset: 0x36 - High-Speed On-Chip Oscillator Control Register
        volatile uint32_t MOCOCR;  ///< Offset: 0x38 - Middle-Speed On-Chip Oscillator Control Register
        volatile uint32_t FLLCR1;  ///< Offset: 0x39 - FLL Control Register 1
        volatile uint32_t FLLCR2;  ///< Offset: 0x3A - FLL Control Register 2
        volatile uint32_t OSCSF;  ///< Offset: 0x3C - Oscillation Stabilization Flag Register
        volatile uint32_t CKOCR;  ///< Offset: 0x3E - Clock Out Control Register
        volatile uint32_t TRCKCR;  ///< Offset: 0x3F - Trace Clock Control Register
        volatile uint32_t OSTDCR;  ///< Offset: 0x40 - Oscillation Stop Detection Control Register
        volatile uint32_t OSTDSR;  ///< Offset: 0x41 - Oscillation Stop Detection Status Register
        volatile uint32_t EBCKOCR;  ///< Offset: 0x52 - External Bus Clock Output Control Register
        volatile uint32_t SDCKOCR;  ///< Offset: 0x53 - SDRAM Clock Output Control Register
        volatile uint32_t MOCOUTCR;  ///< Offset: 0x61 - MOCO User Trimming Control Register
        volatile uint32_t HOCOUTCR;  ///< Offset: 0x62 - HOCO User Trimming Control Register
        volatile uint32_t MOMCR;  ///< Offset: 0x413 - Main Clock Oscillator Mode Oscillation Control Register
        volatile uint32_t SOSCCR;  ///< Offset: 0x480 - Sub-clock oscillator control register
        volatile uint32_t SOMCR;  ///< Offset: 0x481 - Sub Clock Oscillator Mode Control Register
        volatile uint32_t LOCOCR;  ///< Offset: 0x490 - Low-Speed On-Chip Oscillator Control Register
        volatile uint32_t LOCOUTCR;  ///< Offset: 0x492 - LOCO User Trimming Control Register
        volatile uint32_t MOSCWTCR;  ///< Offset: 0xA2 - Main Clock Oscillator Wait Control Register
        volatile uint32_t HOCOWTCR;  ///< Offset: 0xA5 - High-speed on-chip oscillator wait control register
        volatile uint32_t SBYCR;  ///< Offset: 0x0C - Standby Control Register
        volatile uint32_t MSTPCRA;  ///< Offset: 0x1C - Module Stop Control Register A
        volatile uint32_t SNZCR;  ///< Offset: 0x92 - Snooze Control Register
        volatile uint32_t SNZEDCR;  ///< Offset: 0x94 - Snooze End Control Register
        volatile uint32_t SNZREQCR;  ///< Offset: 0x98 - Snooze Request Control Register
        volatile uint32_t OPCCR;  ///< Offset: 0xA0 - Operating Power Control Register
        volatile uint32_t SOPCCR;  ///< Offset: 0xAA - Sub Operating Power Control Register
        volatile uint32_t DPSBYCR;  ///< Offset: 0x400 - Deep Standby Control Register
        volatile uint32_t DPSIER0;  ///< Offset: 0x402 - Deep Standby Interrupt Enable Register 0
        volatile uint32_t DPSIER1;  ///< Offset: 0x403 - Deep Standby Interrupt Enable Register 1
        volatile uint32_t DPSIER2;  ///< Offset: 0x404 - Deep Standby Interrupt Enable Register 2
        volatile uint32_t DPSIER3;  ///< Offset: 0x405 - Deep Standby Interrupt Enable Register 3
        volatile uint32_t DPSIFR0;  ///< Offset: 0x406 - Deep Standby Interrupt Flag Register 0
        volatile uint32_t DPSIFR1;  ///< Offset: 0x407 - Deep Standby Interrupt Flag Register 1
        volatile uint32_t DPSIFR2;  ///< Offset: 0x408 - Deep Standby Interrupt Flag Register 2
        volatile uint32_t DPSIFR3;  ///< Offset: 0x409 - Deep Standby Interrupt Flag Register 3
        volatile uint32_t DPSIEGR0;  ///< Offset: 0x40A - Deep Standby Interrupt Edge Register 0
        volatile uint32_t DPSIEGR1;  ///< Offset: 0x40B - Deep Standby Interrupt Edge Register 1
        volatile uint32_t DPSIEGR2;  ///< Offset: 0x40C - Deep Standby Interrupt Edge Register 2
        volatile uint32_t SYOCDCR;  ///< Offset: 0x40E - System Control OCD Control Register
        volatile uint32_t STCONR;  ///< Offset: 0x40F - Standby Condition Register
        volatile uint32_t LVDCR1;  ///< Offset: 0xE0 - Voltage Monitor %s Circuit Control Register 1 (renamed from LVDCR1)
        volatile uint32_t LVDSR;  ///< Offset: 0xE1 - Voltage Monitor %s Circuit Status Register (renamed from LVDSR)
        volatile uint32_t LVCMPCR;  ///< Offset: 0x417 - Voltage Monitor Circuit Control Register
        volatile uint32_t LVDLVLR;  ///< Offset: 0x418 - Voltage Detection Level Select Register
        volatile uint32_t LVDCR0;  ///< Offset: 0x41A - Voltage Monitor %s Circuit Control Register 0 (renamed from LVDCR0)
        volatile uint32_t PRCR;  ///< Offset: 0x3FE - Protect Register
        volatile uint32_t RSTSR0;  ///< Offset: 0x410 - Reset Status Register 0
        volatile uint32_t RSTSR2;  ///< Offset: 0x411 - Reset Status Register 2
        volatile uint32_t RSTSR1;  ///< Offset: 0xC0 - Reset Status Register 1
    };

    /// Peripheral instances
    inline Registers* SYSTEM = reinterpret_cast<Registers*>(SYSTEM_BASE);

    // Bit definitions
    /// FWEPROR Register bits
    namespace fwepror_bits {
        constexpr uint32_t FLWE = (2 << 0);  ///< Flash Programming and Erasure
    }

    /// VBTICTLR Register bits
    namespace vbtictlr_bits {
        constexpr uint32_t VCH2INEN = (1U << 2);  ///< RTCIC2 Input Enable
        constexpr uint32_t VCH1INEN = (1U << 1);  ///< RTCIC1 Input Enable
        constexpr uint32_t VCH0INEN = (1U << 0);  ///< RTCIC0 Input Enable
    }

    /// VBTBKR__ Register bits
    namespace vbtbkr___bits {
        constexpr uint32_t VBTBKR = (8 << 0);  ///< VBTBKR is a 512-byte readable/writable register to store data powered by VBATT.The value of this register is retained even when VCC is not powered but VBATT is powered.VBTBKR is initialized by VBATT selected voltage power-on-reset.
    }

    /// SCKDIVCR Register bits
    namespace sckdivcr_bits {
        constexpr uint32_t FCK = (3 << 28);  ///< Flash IF Clock (FCLK) Select
        constexpr uint32_t ICK = (3 << 24);  ///< System Clock (ICLK) Select
        constexpr uint32_t BCK = (3 << 16);  ///< External Bus Clock (BCLK) Select
        constexpr uint32_t PCKA = (3 << 12);  ///< Peripheral Module Clock A (PCLKA) Select
        constexpr uint32_t PCKB = (3 << 8);  ///< Peripheral Module Clock B (PCLKB) Select
        constexpr uint32_t PCKC = (3 << 4);  ///< Peripheral Module Clock C (PCLKC) Select
        constexpr uint32_t PCKD = (3 << 0);  ///< Peripheral Module Clock D (PCLKD) Select
    }

    /// SCKDIVCR2 Register bits
    namespace sckdivcr2_bits {
        constexpr uint32_t UCK = (3 << 4);  ///< USB Clock (UCLK) Select
    }

    /// SCKSCR Register bits
    namespace sckscr_bits {
        constexpr uint32_t CKSEL = (3 << 0);  ///< Clock Source Select
    }

    /// PLLCCR Register bits
    namespace pllccr_bits {
        constexpr uint32_t PLLMUL = (6 << 8);  ///< PLL Frequency Multiplication Factor Select [PLL Frequency Multiplication Factor] = (PLLUMUL+1) / 2 Range: 0x23 - 0x3B for example 010011: x10.0 010100: x10.5 010101: x11.0 : 011100: x14.5 011101: x15.0 011110: x15.5 : 111010: x29.5 111011: x30.0
        constexpr uint32_t PLSRCSEL = (1U << 4);  ///< PLL Clock Source Select
        constexpr uint32_t PLIDIV = (2 << 0);  ///< PLL Input Frequency Division Ratio Select
    }

    /// PLLCR Register bits
    namespace pllcr_bits {
        constexpr uint32_t PLLSTP = (1U << 0);  ///< PLL Stop Control
    }

    /// BCKCR Register bits
    namespace bckcr_bits {
        constexpr uint32_t BCLKDIV = (1U << 0);  ///< BCLK Pin Output Select
    }

    /// MOSCCR Register bits
    namespace mosccr_bits {
        constexpr uint32_t MOSTP = (1U << 0);  ///< Main Clock Oscillator Stop
    }

    /// HOCOCR Register bits
    namespace hococr_bits {
        constexpr uint32_t HCSTP = (1U << 0);  ///< HOCO Stop
    }

    /// MOCOCR Register bits
    namespace mococr_bits {
        constexpr uint32_t MCSTP = (1U << 0);  ///< MOCO Stop
    }

    /// FLLCR1 Register bits
    namespace fllcr1_bits {
        constexpr uint32_t FLLEN = (1U << 0);  ///< FLL Enable
    }

    /// FLLCR2 Register bits
    namespace fllcr2_bits {
        constexpr uint32_t FLLCNTL = (11 << 0);  ///< FLL Multiplication ControlMultiplication ratio of the FLL reference clock select
    }

    /// OSCSF Register bits
    namespace oscsf_bits {
        constexpr uint32_t PLLSF = (1U << 5);  ///< PLL Clock Oscillation Stabilization Flag
        constexpr uint32_t MOSCSF = (1U << 3);  ///< Main Clock Oscillation Stabilization Flag
        constexpr uint32_t HOCOSF = (1U << 0);  ///< HOCO Clock Oscillation Stabilization FlagNOTE: The HOCOSF bit value after a reset is 1 when the OFS1.HOCOEN bit is 0. It is 0 when the OFS1.HOCOEN bit is 1.
    }

    /// CKOCR Register bits
    namespace ckocr_bits {
        constexpr uint32_t CKOEN = (1U << 7);  ///< Clock out enable
        constexpr uint32_t CKODIV = (3 << 4);  ///< Clock out input frequency Division Select
        constexpr uint32_t CKOSEL = (3 << 0);  ///< Clock out source select
    }

    /// TRCKCR Register bits
    namespace trckcr_bits {
        constexpr uint32_t TRCKEN = (1U << 7);  ///< Trace Clock operating Enable
        constexpr uint32_t TRCK = (4 << 0);  ///< Trace Clock operating frequency select
    }

    /// OSTDCR Register bits
    namespace ostdcr_bits {
        constexpr uint32_t OSTDE = (1U << 7);  ///< Oscillation Stop Detection Function Enable
        constexpr uint32_t OSTDIE = (1U << 0);  ///< Oscillation Stop Detection Interrupt Enable
    }

    /// OSTDSR Register bits
    namespace ostdsr_bits {
        constexpr uint32_t OSTDF = (1U << 0);  ///< Oscillation Stop Detection Flag
    }

    /// EBCKOCR Register bits
    namespace ebckocr_bits {
        constexpr uint32_t EBCKOEN = (1U << 0);  ///< BCLK Pin Output Control
    }

    /// SDCKOCR Register bits
    namespace sdckocr_bits {
        constexpr uint32_t SDCKOEN = (1U << 0);  ///< SDCLK Pin Output Control
    }

    /// MOCOUTCR Register bits
    namespace mocoutcr_bits {
        constexpr uint32_t MOCOUTRM = (8 << 0);  ///< MOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original MOCO trimming bits
    }

    /// HOCOUTCR Register bits
    namespace hocoutcr_bits {
        constexpr uint32_t HOCOUTRM = (8 << 0);  ///< HOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original HOCO trimming bits
    }

    /// MOMCR Register bits
    namespace momcr_bits {
        constexpr uint32_t AUTODRVEN = (1U << 7);  ///< Main Clock Oscillator Drive Capability Auto Switching Enable
        constexpr uint32_t MOSEL = (1U << 6);  ///< Main Clock Oscillator Switching
        constexpr uint32_t MODRV0 = (2 << 4);  ///< Main Clock Oscillator Drive Capability 0 Switching
    }

    /// SOSCCR Register bits
    namespace sosccr_bits {
        constexpr uint32_t SOSTP = (1U << 0);  ///< Sub-Clock Oscillator Stop
    }

    /// SOMCR Register bits
    namespace somcr_bits {
        constexpr uint32_t SODRV1 = (1U << 1);  ///< Sub Clock Oscillator Drive Capability Switching
    }

    /// LOCOCR Register bits
    namespace lococr_bits {
        constexpr uint32_t LCSTP = (1U << 0);  ///< LOCO Stop
    }

    /// LOCOUTCR Register bits
    namespace locoutcr_bits {
        constexpr uint32_t LOCOUTRM = (8 << 0);  ///< LOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original LOCO trimming bits
    }

    /// MOSCWTCR Register bits
    namespace moscwtcr_bits {
        constexpr uint32_t MSTS = (4 << 0);  ///< Main clock oscillator wait time setting
    }

    /// HOCOWTCR Register bits
    namespace hocowtcr_bits {
        constexpr uint32_t HSTS = (3 << 0);  ///< HOCO wait time settingWaiting time (sec) = setting of the HSTS[2:0] bits/fLOCO(Trimmed) + 3/fLOC(Untrimmed)
    }

    /// SBYCR Register bits
    namespace sbycr_bits {
        constexpr uint32_t SSBY = (1U << 15);  ///< Software Standby
        constexpr uint32_t OPE = (1U << 14);  ///< Output Port Enable
    }

    /// MSTPCRA Register bits
    namespace mstpcra_bits {
        constexpr uint32_t MSTPA22 = (1U << 22);  ///< DMA Controller/Data Transfer Controller Module Stop
        constexpr uint32_t MSTPA7 = (1U << 7);  ///< Standny RAM Module Stop
        constexpr uint32_t MSTPA6 = (1U << 6);  ///< ECCRAM Module Stop
        constexpr uint32_t MSTPA5 = (1U << 5);  ///< High-Speed RAM Module Stop
        constexpr uint32_t MSTPA1 = (1U << 1);  ///< RAM1 Module Stop
        constexpr uint32_t MSTPA0 = (1U << 0);  ///< RAM0 Module Stop
    }

    /// SNZCR Register bits
    namespace snzcr_bits {
        constexpr uint32_t SNZE = (1U << 7);  ///< Snooze Mode Enable
        constexpr uint32_t SNZDTCEN = (1U << 1);  ///< DTC Enable in Snooze Mode
        constexpr uint32_t RXDREQEN = (1U << 0);  ///< RXD0 Snooze Request Enable NOTE: Do not set to 1 other than in asynchronous mode.
    }

    /// SNZEDCR Register bits
    namespace snzedcr_bits {
        constexpr uint32_t SCI0UMTED = (1U << 7);  ///< SCI0 address unmatch Snooze End EnableNote: Do not set to 1 other than in asynchronous mode.
        constexpr uint32_t AD1UMTED = (1U << 6);  ///< AD compare mismatch 1 Snooze End Enable
        constexpr uint32_t AD1MATED = (1U << 5);  ///< AD compare match 1 Snooze End Enable
        constexpr uint32_t AD0UMTED = (1U << 4);  ///< AD compare mismatch 0 Snooze End Enable
        constexpr uint32_t AD0MATED = (1U << 3);  ///< AD compare match 0 Snooze End Enable
        constexpr uint32_t DTCNZRED = (1U << 2);  ///< Not Last DTC transmission completion Snooze End Enable
        constexpr uint32_t DTCZRED = (1U << 1);  ///< Last DTC transmission completion Snooze End Enable
        constexpr uint32_t AGT1UNFED = (1U << 0);  ///< AGT1 underflow Snooze End Enable
    }

    /// SNZREQCR Register bits
    namespace snzreqcr_bits {
        constexpr uint32_t SNZREQEN30 = (1U << 30);  ///< Enable AGT1 compare match B snooze request
        constexpr uint32_t SNZREQEN29 = (1U << 29);  ///< Enable AGT1 compare match A snooze request
        constexpr uint32_t SNZREQEN28 = (1U << 28);  ///< Enable AGT1 underflow snooze request
        constexpr uint32_t SNZREQEN25 = (1U << 25);  ///< Enable RTC period snooze request
        constexpr uint32_t SNZREQEN24 = (1U << 24);  ///< Enable RTC alarm snooze request
        constexpr uint32_t SNZREQEN22 = (1U << 22);  ///< Enable ACMPHS0 snooze request
        constexpr uint32_t SNZREQEN17 = (1U << 17);  ///< Enable KR snooze request
        constexpr uint32_t SNZREQEN13 = (1U << 13);  ///< Enable IRQ13 pin snooze request
        constexpr uint32_t SNZREQEN12 = (1U << 12);  ///< Enable IRQ12 pin snooze request
        constexpr uint32_t SNZREQEN11 = (1U << 11);  ///< Enable IRQ11 pin snooze request
        constexpr uint32_t SNZREQEN10 = (1U << 10);  ///< Enable IRQ10 pin snooze request
        constexpr uint32_t SNZREQEN9 = (1U << 9);  ///< Enable IRQ9 pin snooze request
        constexpr uint32_t SNZREQEN8 = (1U << 8);  ///< Enable IRQ8 pin snooze request
        constexpr uint32_t SNZREQEN7 = (1U << 7);  ///< Enable IRQ7 pin snooze request
        constexpr uint32_t SNZREQEN6 = (1U << 6);  ///< Enable IRQ6 pin snooze request
        constexpr uint32_t SNZREQEN5 = (1U << 5);  ///< Enable IRQ5 pin snooze request
        constexpr uint32_t SNZREQEN4 = (1U << 4);  ///< Enable IRQ4 pin snooze request
        constexpr uint32_t SNZREQEN3 = (1U << 3);  ///< Enable IRQ3 pin snooze request
        constexpr uint32_t SNZREQEN2 = (1U << 2);  ///< Enable IRQ2 pin snooze request
        constexpr uint32_t SNZREQEN1 = (1U << 1);  ///< Enable IRQ1 pin snooze request
        constexpr uint32_t SNZREQEN0 = (1U << 0);  ///< Enable IRQ0 pin snooze request
    }

    /// OPCCR Register bits
    namespace opccr_bits {
        constexpr uint32_t OPCMTSF = (1U << 4);  ///< Operating Power Control Mode Transition Status Flag
        constexpr uint32_t OPCM = (2 << 0);  ///< Operating Power Control Mode Select
    }

    /// SOPCCR Register bits
    namespace sopccr_bits {
        constexpr uint32_t SOPCMTSF = (1U << 4);  ///< Sub Operating Power Control Mode Transition Status Flag
        constexpr uint32_t SOPCM = (1U << 0);  ///< Sub Operating Power Control Mode Select
    }

    /// DPSBYCR Register bits
    namespace dpsbycr_bits {
        constexpr uint32_t DPSBY = (1U << 7);  ///< Deep Software Standby
        constexpr uint32_t IOKEEP = (1U << 6);  ///< I/O Port Retention
        constexpr uint32_t DEEPCUT = (2 << 0);  ///< Power-Supply Control
    }

    /// DPSIER0 Register bits
    namespace dpsier0_bits {
        constexpr uint32_t DIRQ7E = (1U << 7);  ///< IRQ7-DS Pin Enable
        constexpr uint32_t DIRQ6E = (1U << 6);  ///< IRQ6-DS Pin Enable
        constexpr uint32_t DIRQ5E = (1U << 5);  ///< IRQ5-DS Pin Enable
        constexpr uint32_t DIRQ4E = (1U << 4);  ///< IRQ4-DS Pin Enable
        constexpr uint32_t DIRQ1E = (1U << 1);  ///< IRQ1-DS Pin Enable
        constexpr uint32_t DIRQ0E = (1U << 0);  ///< IRQ0-DS Pin Enable
    }

    /// DPSIER1 Register bits
    namespace dpsier1_bits {
        constexpr uint32_t DIRQ12E = (1U << 4);  ///< IRQ12-DS Pin Enable
        constexpr uint32_t DIRQ11E = (1U << 3);  ///< IRQ11-DS Pin Enable
        constexpr uint32_t DIRQ10E = (1U << 2);  ///< IRQ10-DS Pin Enable
        constexpr uint32_t DIRQ9E = (1U << 1);  ///< IRQ9-DS Pin Enable
        constexpr uint32_t DIRQ8E = (1U << 0);  ///< IRQ8-DS Pin Enable
    }

    /// DPSIER2 Register bits
    namespace dpsier2_bits {
        constexpr uint32_t DNMIE = (1U << 4);  ///< NMI Pin Enable
        constexpr uint32_t DRTCAIE = (1U << 3);  ///< RTC Alarm interrupt Deep Standby Cancel Signal Enable
        constexpr uint32_t DTRTCIIE = (1U << 2);  ///< RTC Interval interrupt Deep Standby Cancel Signal Enable
        constexpr uint32_t DLVD2IE = (1U << 1);  ///< LVD2 Deep Standby Cancel Signal Enable
        constexpr uint32_t DLVD1IE = (1U << 0);  ///< LVD1 Deep Standby Cancel Signal Enable
    }

    /// DPSIER3 Register bits
    namespace dpsier3_bits {
        constexpr uint32_t DAGT1IE = (1U << 2);  ///< AGT1 Underflow Deep Standby Cancel Signal Enable
        constexpr uint32_t DUSBFSIE = (1U << 0);  ///< USBFS Suspend/Resume Deep Standby Cancel Signal Enable
    }

    /// DPSIFR0 Register bits
    namespace dpsifr0_bits {
        constexpr uint32_t DIRQ7F = (1U << 7);  ///< IRQ7-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ6F = (1U << 6);  ///< IRQ6-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ5F = (1U << 5);  ///< IRQ5-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ4F = (1U << 4);  ///< IRQ4-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ1F = (1U << 1);  ///< IRQ1-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ0F = (1U << 0);  ///< IRQ0-DS Pin Deep Standby Cancel Flag
    }

    /// DPSIFR1 Register bits
    namespace dpsifr1_bits {
        constexpr uint32_t DIRQ12F = (1U << 4);  ///< IRQ12-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ11F = (1U << 3);  ///< IRQ11-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ10F = (1U << 2);  ///< IRQ10-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ9F = (1U << 1);  ///< IRQ9-DS Pin Deep Standby Cancel Flag
        constexpr uint32_t DIRQ8F = (1U << 0);  ///< IRQ8-DS Pin Deep Standby Cancel Flag
    }

    /// DPSIFR2 Register bits
    namespace dpsifr2_bits {
        constexpr uint32_t DNMIF = (1U << 4);  ///< NMI Pin Deep Standby Cancel Flag
        constexpr uint32_t DRTCAIF = (1U << 3);  ///< RTC Alarm interrupt Deep Standby Cancel Flag
        constexpr uint32_t DTRTCIIF = (1U << 2);  ///< RTC Interval interrupt Deep Standby Cancel Flag
        constexpr uint32_t DLVD2IF = (1U << 1);  ///< LVD2 Deep Standby Cancel Flag
        constexpr uint32_t DLVD1IF = (1U << 0);  ///< LVD1 Deep Standby Cancel Flag
    }

    /// DPSIFR3 Register bits
    namespace dpsifr3_bits {
        constexpr uint32_t DAGT1IF = (1U << 2);  ///< AGT1 Underflow Deep Standby Cancel Flag
        constexpr uint32_t DUSBFSIF = (1U << 0);  ///< USBFS Suspend/Resume Deep Standby Cancel Flag
    }

    /// DPSIEGR0 Register bits
    namespace dpsiegr0_bits {
        constexpr uint32_t DIRQ7EG = (1U << 7);  ///< IRQ7-DS Pin Edge Select
        constexpr uint32_t DIRQ6EG = (1U << 6);  ///< IRQ6-DS Pin Edge Select
        constexpr uint32_t DIRQ5EG = (1U << 5);  ///< IRQ5-DS Pin Edge Select
        constexpr uint32_t DIRQ4EG = (1U << 4);  ///< IRQ4-DS Pin Edge Select
        constexpr uint32_t DIRQ1EG = (1U << 1);  ///< IRQ1-DS Pin Edge Select
        constexpr uint32_t DIRQ0EG = (1U << 0);  ///< IRQ0-DS Pin Edge Select
    }

    /// DPSIEGR1 Register bits
    namespace dpsiegr1_bits {
        constexpr uint32_t DIRQ12EG = (1U << 4);  ///< IRQ12-DS Pin Edge Select
        constexpr uint32_t DIRQ11EG = (1U << 3);  ///< IRQ11-DS Pin Edge Select
        constexpr uint32_t DIRQ10EG = (1U << 2);  ///< IRQ10-DS Pin Edge Select
        constexpr uint32_t DIRQ9EG = (1U << 1);  ///< IRQ9-DS Pin Edge Select
        constexpr uint32_t DIRQ8EG = (1U << 0);  ///< IRQ8-DS Pin Edge Select
    }

    /// DPSIEGR2 Register bits
    namespace dpsiegr2_bits {
        constexpr uint32_t DNMIEG = (1U << 4);  ///< NMI Pin Edge Select
        constexpr uint32_t DLVD2IEG = (1U << 1);  ///< LVD2 Edge Select
        constexpr uint32_t DLVD1IEG = (1U << 0);  ///< LVD1 Edge Select
    }

    /// SYOCDCR Register bits
    namespace syocdcr_bits {
        constexpr uint32_t DBGEN = (1U << 7);  ///< Debugger Enable bit
        constexpr uint32_t DOCDF = (1U << 0);  ///< Deep Standby OCD flag
    }

    /// STCONR Register bits
    namespace stconr_bits {
        constexpr uint32_t STCON = (2 << 0);  ///< SSTBY condition bit
    }

    /// LVDCR1 Register bits
    namespace lvdcr1_bits {
        constexpr uint32_t IRQSEL = (1U << 2);  ///< Voltage Monitor Interrupt Type Select
        constexpr uint32_t IDTSEL = (2 << 0);  ///< Voltage Monitor Interrupt Generation Condition Select
    }

    /// LVDSR Register bits
    namespace lvdsr_bits {
        constexpr uint32_t MON = (1U << 1);  ///< Voltage Monitor Signal Monitor Flag
        constexpr uint32_t DET = (1U << 0);  ///< Voltage Monitor Voltage Change Detection Flag NOTE: Only 0 can be written to this bit. After writing 0 to this bit, it takes 2 system clock cycles for the bit to be read as 0.
    }

    /// LVCMPCR Register bits
    namespace lvcmpcr_bits {
        constexpr uint32_t LVD2E = (1U << 6);  ///< Voltage Detection 2 Enable
        constexpr uint32_t LVD1E = (1U << 5);  ///< Voltage Detection 1 Enable
    }

    /// LVDLVLR Register bits
    namespace lvdlvlr_bits {
        constexpr uint32_t LVD2LVL = (3 << 5);  ///< Voltage Detection 2 Level Select (Standard voltage during fall in voltage)
        constexpr uint32_t LVD1LVL = (5 << 0);  ///< Voltage Detection 1 Level Select (Standard voltage during fall in voltage)
    }

    /// LVDCR0 Register bits
    namespace lvdcr0_bits {
        constexpr uint32_t RN = (1U << 7);  ///< Voltage Monitor Reset Negate Select
        constexpr uint32_t RI = (1U << 6);  ///< Voltage Monitor Circuit Mode Select
        constexpr uint32_t FSAMP = (2 << 4);  ///< Sampling Clock Select
        constexpr uint32_t CMPE = (1U << 2);  ///< Voltage Monitor Circuit Comparison Result Output Enable
        constexpr uint32_t DFDIS = (1U << 1);  ///< Voltage Monitor Digital Filter Disable Mode Select
        constexpr uint32_t RIE = (1U << 0);  ///< Voltage Monitor Interrupt/Reset Enable
    }

    /// PRCR Register bits
    namespace prcr_bits {
        constexpr uint32_t PRKEY = (8 << 8);  ///< PRKEY Key Code
        constexpr uint32_t PRC3 = (1U << 3);  ///< Enables writing to the registers related to the LVD.
        constexpr uint32_t PRC1 = (1U << 1);  ///< Enables writing to the registers related to the operating modes, the low power consumption modes and the battery backup function.
        constexpr uint32_t PRC0 = (1U << 0);  ///< Enables writing to the registers related to the clock generation circuit.
    }

    /// RSTSR0 Register bits
    namespace rstsr0_bits {
        constexpr uint32_t DPSRSTF = (1U << 7);  ///< Deep Software Standby Reset FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t LVD2RF = (1U << 3);  ///< Voltage Monitor 2 Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t LVD1RF = (1U << 2);  ///< Voltage Monitor 1 Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t LVD0RF = (1U << 1);  ///< Voltage Monitor 0 Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t PORF = (1U << 0);  ///< Power-On Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
    }

    /// RSTSR2 Register bits
    namespace rstsr2_bits {
        constexpr uint32_t CWSF = (1U << 0);  ///< Cold/Warm Start Determination Flag
    }

    /// RSTSR1 Register bits
    namespace rstsr1_bits {
        constexpr uint32_t SPERF = (1U << 12);  ///< SP Error Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t BUSMRF = (1U << 11);  ///< Bus Master MPU Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t BUSSRF = (1U << 10);  ///< Bus Slave MPU Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t REERF = (1U << 9);  ///< RAM ECC Error Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t RPERF = (1U << 8);  ///< RAM Parity Error Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t SWRF = (1U << 2);  ///< Software Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t WDTRF = (1U << 1);  ///< Watchdog Timer Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
        constexpr uint32_t IWDTRF = (1U << 0);  ///< Independent Watchdog Timer Reset Detect FlagNOTE: Writable only to clear the flag. Confirm the value is 1 and then write 0.
    }

}

// ============================================================================
// MSTP Peripheral
// ============================================================================

namespace mstp {
    /// Base addresses
    constexpr uint32_t MSTP_BASE = 0x40047000;

    /// MSTP Register structure
    struct Registers {
        volatile uint32_t MSTPCRB;  ///< Offset: 0x00 - Module Stop Control Register B
        volatile uint32_t MSTPCRC;  ///< Offset: 0x04 - Module Stop Control Register C
        volatile uint32_t MSTPCRD;  ///< Offset: 0x08 - Module Stop Control Register D
    };

    /// Peripheral instances
    inline Registers* MSTP = reinterpret_cast<Registers*>(MSTP_BASE);

    // Bit definitions
    /// MSTPCRB Register bits
    namespace mstpcrb_bits {
        constexpr uint32_t MSTPB31 = (1U << 31);  ///< Serial Communication Interface 0 Module Stop
        constexpr uint32_t MSTPB30 = (1U << 30);  ///< Serial Communication Interface 1 Module Stop
        constexpr uint32_t MSTPB29 = (1U << 29);  ///< Serial Communication Interface 2 Module Stop
        constexpr uint32_t MSTPB28 = (1U << 28);  ///< Serial Communication Interface 3 Module Stop
        constexpr uint32_t MSTPB27 = (1U << 27);  ///< Serial Communication Interface 4 Module Stop
        constexpr uint32_t MSTPB23 = (1U << 23);  ///< Serial Communication Interface 8 Module Stop
        constexpr uint32_t MSTPB22 = (1U << 22);  ///< Serial Communication Interface 9 Module Stop
        constexpr uint32_t MSTPB19 = (1U << 19);  ///< Serial Peripheral Interface 0 Module Stop
        constexpr uint32_t MSTPB18 = (1U << 18);  ///< Serial Peripheral Interface Module Stop
        constexpr uint32_t MSTPB11 = (1U << 11);  ///< Universal Serial Bus 2.0 FS Interface Module Stop
        constexpr uint32_t MSTPB9 = (1U << 9);  ///< I2C Bus Interface 0 Module Stop
        constexpr uint32_t MSTPB8 = (1U << 8);  ///< I2C Bus Interface 1 Module Stop
        constexpr uint32_t MSTPB6 = (1U << 6);  ///< Queued Serial Peripheral Interface Module Stop
        constexpr uint32_t MSTPB5 = (1U << 5);  ///< IrDA Module Stop
        constexpr uint32_t MSTPB2 = (1U << 2);  ///< Controller Area Network 0 Module Stop
        constexpr uint32_t MSTPB1 = (1U << 1);  ///< Controller Area Network 1 Module Stop
    }

    /// MSTPCRC Register bits
    namespace mstpcrc_bits {
        constexpr uint32_t MSTPC31 = (1U << 31);  ///< SCE7 Module Stop
        constexpr uint32_t MSTPC14 = (1U << 14);  ///< Event Link Controller Module Stop
        constexpr uint32_t MSTPC13 = (1U << 13);  ///< Data Operation Circuit Module Stop
        constexpr uint32_t MSTPC12 = (1U << 12);  ///< Secure Digital Host IF/MultiMediaCard 0 Module Stop
        constexpr uint32_t MSTPC11 = (1U << 11);  ///< Secure Digital Host IF/MultiMediaCard 1 Module Stop
        constexpr uint32_t MSTPC9 = (1U << 9);  ///< Sampling Rate Converter Module Stop
        constexpr uint32_t MSTPC8 = (1U << 8);  ///< Serial Sound Interface Enhanced (channel 0) Module Stop
        constexpr uint32_t MSTPC3 = (1U << 3);  ///< Capacitive Touch Sensing Unit Module Stop
        constexpr uint32_t MSTPC1 = (1U << 1);  ///< Cyclic Redundancy Check Calculator Module Stop
        constexpr uint32_t MSTPC0 = (1U << 0);  ///< Clock Frequency Accuracy Measurement Circuit Module Stop
    }

    /// MSTPCRD Register bits
    namespace mstpcrd_bits {
        constexpr uint32_t MSTPD28 = (1U << 28);  ///< High-Speed Analog Comparator 0 Module Stop
        constexpr uint32_t MSTPD27 = (1U << 27);  ///< High-Speed Analog Comparator 1 Module Stop
        constexpr uint32_t MSTPD26 = (1U << 26);  ///< High-Speed Analog Comparator 2 Module Stop
        constexpr uint32_t MSTPD25 = (1U << 25);  ///< High-Speed Analog Comparator 3 Module Stop
        constexpr uint32_t MSTPD24 = (1U << 24);  ///< High-Speed Analog Comparator 4 Module Stop
        constexpr uint32_t MSTPD23 = (1U << 23);  ///< High-Speed Analog Comparator 5 Module Stop
        constexpr uint32_t MSTPD22 = (1U << 22);  ///< Temperature Sensor Module Stop
        constexpr uint32_t MSTPD20 = (1U << 20);  ///< 12-Bit D/A Converter Module Stop
        constexpr uint32_t MSTPD16 = (1U << 16);  ///< 12-Bit A/D Converter 0 Module Stop
        constexpr uint32_t MSTPD15 = (1U << 15);  ///< 12-Bit A/D Converter 1 Module Stop
        constexpr uint32_t MSTPD14 = (1U << 14);  ///< Port Output Enable for GPT Module Stop
        constexpr uint32_t MSTPD6 = (1U << 6);  ///< General PWM Timer 32_8 to 32_12 Module Stop
        constexpr uint32_t MSTPD5 = (1U << 5);  ///< General PWM Timer 32EH0 to 32EH3 and 32E4 to 32E7 and PWM Delay Generation Circuit Module Stop
        constexpr uint32_t MSTPD3 = (1U << 3);  ///< AGT0 Module Stop Note: AGT0 is in the module stop state when the count source is either of PCLKB, PCLKB/2 or PCLKB/8. In case the count source is sub-clock or LOCO, this bit should be set to 1 except when accessing the registers of AGT0.
        constexpr uint32_t MSTPD2 = (1U << 2);  ///< AGT1 Module Stop Note: AGT1 is in the module stop state when the count source is either of PCLKB, PCLKB/2 or PCLKB/8. In case the count source is sub-clock or LOCO, this bit should be set to 1 except when accessing the registers of AGT1.
    }

}

// ============================================================================
// AGT0 Peripheral
// ============================================================================

namespace agt0 {
    /// Base addresses
    constexpr uint32_t AGT0_BASE = 0x40084000;

    /// AGT0 Register structure
    struct Registers {
        volatile uint32_t AGT;  ///< Offset: 0x00 - AGT Counter Register
        volatile uint32_t AGTCMA;  ///< Offset: 0x02 - AGT Compare Match A Register
        volatile uint32_t AGTCMB;  ///< Offset: 0x04 - AGT Compare Match B Register
        volatile uint32_t AGTCR;  ///< Offset: 0x08 - AGT Control Register
        volatile uint32_t AGTMR1;  ///< Offset: 0x09 - AGT Mode Register 1
        volatile uint32_t AGTMR2;  ///< Offset: 0x0A - AGT Mode Register 2
        volatile uint32_t AGTIOC;  ///< Offset: 0x0C - AGT I/O Control Register
        volatile uint32_t AGTISR;  ///< Offset: 0x0D - AGT Event Pin Select Register
        volatile uint32_t AGTCMSR;  ///< Offset: 0x0E - AGT Compare Match Function Select Register
        volatile uint32_t AGTIOSEL;  ///< Offset: 0x0F - AGT Pin Select Register
    };

    /// Peripheral instances
    inline Registers* AGT0 = reinterpret_cast<Registers*>(AGT0_BASE);

    // Bit definitions
    /// AGT Register bits
    namespace agt_bits {
        constexpr uint32_t AGT = (16 << 0);  ///< 16bit counter and reload registerNOTE : When 1 is written to the TSTOP bit in the AGTCRn register, the 16-bit counter is forcibly stopped and set to FFFFH.
    }

    /// AGTCMA Register bits
    namespace agtcma_bits {
        constexpr uint32_t AGTCMA = (16 << 0);  ///< AGT Compare Match A RegisterNOTE : When 1 is written to the TSTOP bit in the AGTCRn register, set to FFFFH
    }

    /// AGTCMB Register bits
    namespace agtcmb_bits {
        constexpr uint32_t AGTCMB = (16 << 0);  ///< AGT Compare Match B RegisterNOTE : When 1 is written to the TSTOP bit in the AGTCR register, set to FFFFH
    }

    /// AGTCR Register bits
    namespace agtcr_bits {
        constexpr uint32_t TCMBF = (1U << 7);  ///< AGT compare match B flag
        constexpr uint32_t TCMAF = (1U << 6);  ///< AGT compare match A flag
        constexpr uint32_t TUNDF = (1U << 5);  ///< AGT underflow flag
        constexpr uint32_t TEDGF = (1U << 4);  ///< Active edge judgement flag
        constexpr uint32_t TSTOP = (1U << 2);  ///< AGT count forced stop
        constexpr uint32_t TCSTF = (1U << 1);  ///< AGT count status flag
        constexpr uint32_t TSTART = (1U << 0);  ///< AGT count start
    }

    /// AGTMR1 Register bits
    namespace agtmr1_bits {
        constexpr uint32_t TCK = (3 << 4);  ///< AGT count source select
        constexpr uint32_t TEDGPL = (1U << 3);  ///< AGTIO edge polarity select
        constexpr uint32_t TMOD = (3 << 0);  ///< AGT operating mode select
    }

    /// AGTMR2 Register bits
    namespace agtmr2_bits {
        constexpr uint32_t LPM = (1U << 7);  ///< AGT Low Power Mode
        constexpr uint32_t CKS = (3 << 0);  ///< fsub/LOCO count source clock frequency division ratio select
    }

    /// AGTIOC Register bits
    namespace agtioc_bits {
        constexpr uint32_t TIOGT = (2 << 6);  ///< AGTIO count control
        constexpr uint32_t TIPF = (2 << 4);  ///< AGTIO input filter select
        constexpr uint32_t TOE = (1U << 2);  ///< AGTO output enable
        constexpr uint32_t TEDGSEL = (1U << 0);  ///< I/O polarity switchFunction varies depending on the operating mode.
    }

    /// AGTISR Register bits
    namespace agtisr_bits {
        constexpr uint32_t EEPS = (1U << 2);  ///< AGTEE polarty selection
    }

    /// AGTCMSR Register bits
    namespace agtcmsr_bits {
        constexpr uint32_t TOPOLB = (1U << 6);  ///< AGTOB polarity select
        constexpr uint32_t TOEB = (1U << 5);  ///< AGTOB output enable
        constexpr uint32_t TCMEB = (1U << 4);  ///< Compare match B register enable
        constexpr uint32_t TOPOLA = (1U << 2);  ///< AGTOA polarity select
        constexpr uint32_t TOEA = (1U << 1);  ///< AGTOA output enable
        constexpr uint32_t TCMEA = (1U << 0);  ///< Compare match A register enable
    }

    /// AGTIOSEL Register bits
    namespace agtiosel_bits {
        constexpr uint32_t TIES = (1U << 4);  ///< AGTIO input enable
        constexpr uint32_t SEL = (2 << 0);  ///< AGTIO pin select
    }

}

// ============================================================================
// AGT1 Peripheral
// ============================================================================

namespace agt1 {
    /// Base addresses
    constexpr uint32_t AGT1_BASE = 0x40084100;

    /// AGT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* AGT1 = reinterpret_cast<Registers*>(AGT1_BASE);

}

// ============================================================================
// GPT Peripheral
// ============================================================================

namespace gpt {
    /// Base addresses
    constexpr uint32_t GPT_OPS_BASE = 0x40078FF0;
    constexpr uint32_t GPT_ODC_BASE = 0x4007B000;

    /// GPT Register structure
    struct Registers {
        volatile uint32_t OPSCR;  ///< Offset: 0x00 - Output Phase Switching Control Register
    };

    /// Peripheral instances
    inline Registers* GPT_OPS = reinterpret_cast<Registers*>(GPT_OPS_BASE);
    inline Registers* GPT_ODC = reinterpret_cast<Registers*>(GPT_ODC_BASE);

    // Bit definitions
    /// OPSCR Register bits
    namespace opscr_bits {
        constexpr uint32_t NFCS = (2 << 30);  ///< External Input Noise Filter Clock selectionNoise filter sampling clock setting of the external input.
        constexpr uint32_t NFEN = (1U << 29);  ///< External Input Noise Filter Enable
        constexpr uint32_t GODF = (1U << 26);  ///< Group output disable function
        constexpr uint32_t GRP = (2 << 24);  ///< Output disabled source selection
        constexpr uint32_t ALIGN = (1U << 21);  ///< Input phase alignment
        constexpr uint32_t INV = (1U << 19);  ///< Invert-Phase Output Control
        constexpr uint32_t N = (1U << 18);  ///< Negative-Phase Output (N) Control
        constexpr uint32_t P = (1U << 17);  ///< Positive-Phase Output (P) Control
        constexpr uint32_t FB = (1U << 16);  ///< External Feedback Signal EnableThis bit selects the input phase from the software settings and external input.
        constexpr uint32_t EN = (1U << 8);  ///< Enable-Phase Output Control
        constexpr uint32_t W = (1U << 6);  ///< Input W-Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)
        constexpr uint32_t V = (1U << 5);  ///< Input V-Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)
        constexpr uint32_t U = (1U << 4);  ///< Input U-Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)
        constexpr uint32_t WF = (1U << 2);  ///< Input Phase Soft Setting UFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1.
        constexpr uint32_t VF = (1U << 1);  ///< Input Phase Soft Setting VFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1.
        constexpr uint32_t UF = (1U << 0);  ///< Input Phase Soft Setting WFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1.
    }

}

// ============================================================================
// GPT32EH0 Peripheral
// ============================================================================

namespace gpt32eh0 {
    /// Base addresses
    constexpr uint32_t GPT32EH0_BASE = 0x40078000;

    /// GPT32EH0 Register structure
    struct Registers {
        volatile uint32_t GTWP;  ///< Offset: 0x00 - General PWM Timer Write-Protection Register
        volatile uint32_t GTSTR;  ///< Offset: 0x04 - General PWM Timer Software Start Register
        volatile uint32_t GTSTP;  ///< Offset: 0x08 - General PWM Timer Software Stop Register
        volatile uint32_t GTCLR;  ///< Offset: 0x0C - General PWM Timer Software Clear Register
        volatile uint32_t GTSSR;  ///< Offset: 0x10 - General PWM Timer Start Source Select Register
        volatile uint32_t GTPSR;  ///< Offset: 0x14 - General PWM Timer Stop Source Select Register
        volatile uint32_t GTCSR;  ///< Offset: 0x18 - General PWM Timer Clear Source Select Register
        volatile uint32_t GTUPSR;  ///< Offset: 0x1C - General PWM Timer Up Count Source Select Register
        volatile uint32_t GTDNSR;  ///< Offset: 0x20 - General PWM Timer Down Count Source Select Register
        volatile uint32_t GTICASR;  ///< Offset: 0x24 - General PWM Timer Input Capture Source Select Register A
        volatile uint32_t GTICBSR;  ///< Offset: 0x28 - General PWM Timer Input Capture Source Select Register B
        volatile uint32_t GTCR;  ///< Offset: 0x2C - General PWM Timer Control Register
        volatile uint32_t GTUDDTYC;  ///< Offset: 0x30 - General PWM Timer Count Direction and Duty Setting Register
        volatile uint32_t GTIOR;  ///< Offset: 0x34 - General PWM Timer I/O Control Register
        volatile uint32_t GTINTAD;  ///< Offset: 0x38 - General PWM Timer Interrupt Output Setting Register
        volatile uint32_t GTST;  ///< Offset: 0x3C - General PWM Timer Status Register
        volatile uint32_t GTBER;  ///< Offset: 0x40 - General PWM Timer Buffer Enable Register
        volatile uint32_t GTITC;  ///< Offset: 0x44 - General PWM Timer Interrupt and A/D Converter Start...
        volatile uint32_t GTCNT;  ///< Offset: 0x48 - General PWM Timer Counter
        volatile uint32_t GTCCRA;  ///< Offset: 0x4C - General PWM Timer Compare Capture Register A
        volatile uint32_t GTCCRB;  ///< Offset: 0x50 - General PWM Timer Compare Capture Register B
        volatile uint32_t GTCCRC;  ///< Offset: 0x54 - General PWM Timer Compare Capture Register C
        volatile uint32_t GTCCRE;  ///< Offset: 0x58 - General PWM Timer Compare Capture Register E
        volatile uint32_t GTCCRD;  ///< Offset: 0x5C - General PWM Timer Compare Capture Register D
        volatile uint32_t GTCCRF;  ///< Offset: 0x60 - General PWM Timer Compare Capture Register F
        volatile uint32_t GTPR;  ///< Offset: 0x64 - General PWM Timer Cycle Setting Register
        volatile uint32_t GTPBR;  ///< Offset: 0x68 - General PWM Timer Cycle Setting Buffer Register
        volatile uint32_t GTPDBR;  ///< Offset: 0x6C - General PWM Timer Cycle Setting Double-Buffer Register
        volatile uint32_t GTADTRA;  ///< Offset: 0x70 - A/D Converter Start Request Timing Register A
        volatile uint32_t GTADTRB;  ///< Offset: 0x7C - A/D Converter Start Request Timing Register B
        volatile uint32_t GTADTBRA;  ///< Offset: 0x74 - A/D Converter Start Request Timing Buffer Register A
        volatile uint32_t GTADTBRB;  ///< Offset: 0x80 - A/D Converter Start Request Timing Buffer Register B
        volatile uint32_t GTADTDBRA;  ///< Offset: 0x78 - A/D Converter Start Request Timing Double-Buffer Register A
        volatile uint32_t GTADTDBRB;  ///< Offset: 0x84 - A/D Converter Start Request Timing Double-Buffer Register B
        volatile uint32_t GTDTCR;  ///< Offset: 0x88 - General PWM Timer Dead Time Control Register
        volatile uint32_t GTDVU;  ///< Offset: 0x8C - General PWM Timer Dead Time Value Register U
        volatile uint32_t GTDVD;  ///< Offset: 0x90 - General PWM Timer Dead Time Value Register D
        volatile uint32_t GTDBU;  ///< Offset: 0x94 - General PWM Timer Dead Time Buffer Register U
        volatile uint32_t GTDBD;  ///< Offset: 0x98 - General PWM Timer Dead Time Buffer Register D
        volatile uint32_t GTSOS;  ///< Offset: 0x9C - General PWM Timer Output Protection Function Status Register
        volatile uint32_t GTSOTR;  ///< Offset: 0xA0 - General PWM Timer Output Protection Function Temporary...
    };

    /// Peripheral instances
    inline Registers* GPT32EH0 = reinterpret_cast<Registers*>(GPT32EH0_BASE);

    // Bit definitions
    /// GTWP Register bits
    namespace gtwp_bits {
        constexpr uint32_t PRKEY = (8 << 8);  ///< GTWP Key Code
        constexpr uint32_t WP = (1U << 0);  ///< Register Write Disable
    }

    /// GTSTR Register bits
    namespace gtstr_bits {
        constexpr uint32_t CSTRT12 = (1U << 12);  ///< Channel 12 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT11 = (1U << 11);  ///< Channel 11 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT10 = (1U << 10);  ///< Channel 10 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT9 = (1U << 9);  ///< Channel 9 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT8 = (1U << 8);  ///< Channel 8 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT7 = (1U << 7);  ///< Channel 7 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT6 = (1U << 6);  ///< Channel 6 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT5 = (1U << 5);  ///< Channel 5 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT4 = (1U << 4);  ///< Channel 4 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT3 = (1U << 3);  ///< Channel 3 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT2 = (1U << 2);  ///< Channel 2 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT1 = (1U << 1);  ///< Channel 1 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT0 = (1U << 0);  ///< Channel 0 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
    }

    /// GTSTP Register bits
    namespace gtstp_bits {
        constexpr uint32_t CSTOP12 = (1U << 12);  ///< Channel 12 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP11 = (1U << 11);  ///< Channel 11 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP10 = (1U << 10);  ///< Channel 10 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP9 = (1U << 9);  ///< Channel 9 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP8 = (1U << 8);  ///< Channel 8 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP7 = (1U << 7);  ///< Channel 7 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP6 = (1U << 6);  ///< Channel 6 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP5 = (1U << 5);  ///< Channel 5 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP4 = (1U << 4);  ///< Channel 4 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP3 = (1U << 3);  ///< Channel 3 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP2 = (1U << 2);  ///< Channel 2 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP1 = (1U << 1);  ///< Channel 1 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP0 = (1U << 0);  ///< Channel 0 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
    }

    /// GTCLR Register bits
    namespace gtclr_bits {
        constexpr uint32_t CCLR12 = (1U << 12);  ///< Channel 12 GTCNT Count Clear
        constexpr uint32_t CCLR11 = (1U << 11);  ///< Channel 11 GTCNT Count Clear
        constexpr uint32_t CCLR10 = (1U << 10);  ///< Channel 10 GTCNT Count Clear
        constexpr uint32_t CCLR9 = (1U << 9);  ///< Channel 9 GTCNT Count Clear
        constexpr uint32_t CCLR8 = (1U << 8);  ///< Channel 8 GTCNT Count Clear
        constexpr uint32_t CCLR7 = (1U << 7);  ///< Channel 7 GTCNT Count Clear
        constexpr uint32_t CCLR6 = (1U << 6);  ///< Channel 6 GTCNT Count Clear
        constexpr uint32_t CCLR5 = (1U << 5);  ///< Channel 5 GTCNT Count Clear
        constexpr uint32_t CCLR4 = (1U << 4);  ///< Channel 4 GTCNT Count Clear
        constexpr uint32_t CCLR3 = (1U << 3);  ///< Channel 3 GTCNT Count Clear
        constexpr uint32_t CCLR2 = (1U << 2);  ///< Channel 2 GTCNT Count Clear
        constexpr uint32_t CCLR1 = (1U << 1);  ///< Channel 1 GTCNT Count Clear
        constexpr uint32_t CCLR0 = (1U << 0);  ///< Channel 0 GTCNT Count Clear
    }

    /// GTSSR Register bits
    namespace gtssr_bits {
        constexpr uint32_t CSTRT = (1U << 31);  ///< Software Source Counter Start Enable
        constexpr uint32_t SSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Start Enable
        constexpr uint32_t SSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Start Enable
        constexpr uint32_t SSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Start Enable
        constexpr uint32_t SSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Start Enable
        constexpr uint32_t SSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Start Enable
        constexpr uint32_t SSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Start Enable
        constexpr uint32_t SSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Start Enable
        constexpr uint32_t SSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Start Enable
        constexpr uint32_t SSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Start Enable
    }

    /// GTPSR Register bits
    namespace gtpsr_bits {
        constexpr uint32_t CSTOP = (1U << 31);  ///< Software Source Counter Stop Enable
        constexpr uint32_t PSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Stop Enable
        constexpr uint32_t PSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Stop Enable
        constexpr uint32_t PSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Stop Enable
        constexpr uint32_t PSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Stop Enable
        constexpr uint32_t PSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Stop Enable
        constexpr uint32_t PSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Stop Enable
        constexpr uint32_t PSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Stop Enable
        constexpr uint32_t PSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Stop Enable
        constexpr uint32_t PSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Stop Enable
    }

    /// GTCSR Register bits
    namespace gtcsr_bits {
        constexpr uint32_t CCLR = (1U << 31);  ///< Software Source Counter Clear Enable
        constexpr uint32_t CSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Clear Enable
        constexpr uint32_t CSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Clear Enable
        constexpr uint32_t CSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Clear Enable
        constexpr uint32_t CSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Clear Enable
        constexpr uint32_t CSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Clear Enable
        constexpr uint32_t CSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Clear Enable
        constexpr uint32_t CSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Clear Enable
        constexpr uint32_t CSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Clear Enable
        constexpr uint32_t CSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Clear Enable
    }

    /// GTUPSR Register bits
    namespace gtupsr_bits {
        constexpr uint32_t USELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Count Up Enable
        constexpr uint32_t USELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Up Enable
        constexpr uint32_t USELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Up Enable
        constexpr uint32_t USELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Up Enable
        constexpr uint32_t USELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Up Enable
        constexpr uint32_t USELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Up Enable
        constexpr uint32_t USELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Up Enable
        constexpr uint32_t USELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Up Enable
        constexpr uint32_t USCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Up Enable
    }

    /// GTDNSR Register bits
    namespace gtdnsr_bits {
        constexpr uint32_t DSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Count Down Enable
        constexpr uint32_t DSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Down Enable
        constexpr uint32_t DSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Down Enable
        constexpr uint32_t DSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Down Enable
        constexpr uint32_t DSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Down Enable
        constexpr uint32_t DSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Down Enable
        constexpr uint32_t DSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Down Enable
        constexpr uint32_t DSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Down Enable
        constexpr uint32_t DSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Down Enable
    }

    /// GTICASR Register bits
    namespace gticasr_bits {
        constexpr uint32_t ASELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable
    }

    /// GTICBSR Register bits
    namespace gticbsr_bits {
        constexpr uint32_t BSELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable
    }

    /// GTCR Register bits
    namespace gtcr_bits {
        constexpr uint32_t TPCS = (3 << 24);  ///< Timer Prescaler Select
        constexpr uint32_t MD = (3 << 16);  ///< Mode Select
        constexpr uint32_t CST = (1U << 0);  ///< Count Start
    }

    /// GTUDDTYC Register bits
    namespace gtuddtyc_bits {
        constexpr uint32_t OBDTYR = (1U << 27);  ///< GTIOCB Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OBDTYF = (1U << 26);  ///< Forcible GTIOCB Output Duty Setting
        constexpr uint32_t OBDTY = (2 << 24);  ///< GTIOCB Output Duty Setting
        constexpr uint32_t OADTYR = (1U << 19);  ///< GTIOCA Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OADTYF = (1U << 18);  ///< Forcible GTIOCA Output Duty Setting
        constexpr uint32_t OADTY = (2 << 16);  ///< GTIOCA Output Duty Setting
        constexpr uint32_t UDF = (1U << 1);  ///< Forcible Count Direction Setting
        constexpr uint32_t UD = (1U << 0);  ///< Count Direction Setting
    }

    /// GTIOR Register bits
    namespace gtior_bits {
        constexpr uint32_t NFCSB = (2 << 30);  ///< Noise Filter B Sampling Clock Select
        constexpr uint32_t NFBEN = (1U << 29);  ///< Noise Filter B Enable
        constexpr uint32_t OBDF = (2 << 25);  ///< GTIOCB Pin Disable Value Setting
        constexpr uint32_t OBE = (1U << 24);  ///< GTIOCB Pin Output Enable
        constexpr uint32_t OBHLD = (1U << 23);  ///< GTIOCB Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OBDFLT = (1U << 22);  ///< GTIOCB Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOB = (5 << 16);  ///< GTIOCB Pin Function Select
        constexpr uint32_t NFCSA = (2 << 14);  ///< Noise Filter A Sampling Clock Select
        constexpr uint32_t NFAEN = (1U << 13);  ///< Noise Filter A Enable
        constexpr uint32_t OADF = (2 << 9);  ///< GTIOCA Pin Disable Value Setting
        constexpr uint32_t OAE = (1U << 8);  ///< GTIOCA Pin Output Enable
        constexpr uint32_t OAHLD = (1U << 7);  ///< GTIOCA Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OADFLT = (1U << 6);  ///< GTIOCA Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOA = (5 << 0);  ///< GTIOCA Pin Function Select
    }

    /// GTINTAD Register bits
    namespace gtintad_bits {
        constexpr uint32_t GRPABL = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t GRPABH = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t GRPDTE = (1U << 28);  ///< Dead Time Error Output Disable Request Enable
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disable Source Select
        constexpr uint32_t ADTRBDEN = (1U << 19);  ///< GTADTRB Compare Match (Down-Counting) A/D Converter Start Request Interrupt Enable
        constexpr uint32_t ADTRBUEN = (1U << 18);  ///< GTADTRB Compare Match (Up-Counting) A/D Converter Start Request Interrupt Enable
        constexpr uint32_t ADTRADEN = (1U << 17);  ///< GTADTRA Compare Match (Down-Counting) A/D Converter Start Request Interrupt Enable
        constexpr uint32_t ADTRAUEN = (1U << 16);  ///< GTADTRA Compare Match (Up-Counting) A/D Converter Start Request Interrupt Enable
    }

    /// GTST Register bits
    namespace gtst_bits {
        constexpr uint32_t OABLF = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t OABHF = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t DTEF = (1U << 28);  ///< Dead Time Error Flag
        constexpr uint32_t ODF = (1U << 24);  ///< Output Disable Flag
        constexpr uint32_t TUCF = (1U << 15);  ///< Count Direction Flag
        constexpr uint32_t ITCNT = (3 << 8);  ///< GTCIV/GTCIU Interrupt Skipping Count Counter(Counter for counting the number of times a timer interrupt has been skipped.)
        constexpr uint32_t TCFPU = (1U << 7);  ///< Underflow Flag
        constexpr uint32_t TCFPO = (1U << 6);  ///< Overflow Flag
        constexpr uint32_t TCFF = (1U << 5);  ///< Input Compare Match Flag F
        constexpr uint32_t TCFE = (1U << 4);  ///< Input Compare Match Flag E
        constexpr uint32_t TCFD = (1U << 3);  ///< Input Compare Match Flag D
        constexpr uint32_t TCFC = (1U << 2);  ///< Input Compare Match Flag C
        constexpr uint32_t TCFB = (1U << 1);  ///< Input Capture/Compare Match Flag B
        constexpr uint32_t TCFA = (1U << 0);  ///< Input Capture/Compare Match Flag A
    }

    /// GTBER Register bits
    namespace gtber_bits {
        constexpr uint32_t ADTDB = (1U << 30);  ///< GTADTRB Double Buffer Operation
        constexpr uint32_t ADTTB = (2 << 28);  ///< GTADTRB Buffer Transfer Timing Select in the Triangle wavesNOTE: In the Saw waves, values other than 0 0: Transfer at an underflow (in down-counting) or overflow (in up-counting) is performed.
        constexpr uint32_t ADTDA = (1U << 26);  ///< GTADTRA Double Buffer Operation
        constexpr uint32_t ADTTA = (2 << 24);  ///< GTADTRA Buffer Transfer Timing Select in the Triangle wavesNOTE: In the Saw waves, values other than 0 0: Transfer at an underflow (in down-counting) or overflow (in up-counting) is performed.
        constexpr uint32_t CCRSWT = (1U << 22);  ///< GTCCRA and GTCCRB Forcible Buffer OperationThis bit is read as 0.
        constexpr uint32_t PR = (2 << 20);  ///< GTPR Buffer Operation
        constexpr uint32_t CCRB = (2 << 18);  ///< GTCCRB Buffer Operation
        constexpr uint32_t CCRA = (2 << 16);  ///< GTCCRA Buffer Operation
        constexpr uint32_t BD = (4 << 0);  ///< BD[3]: GTDV Buffer Operation DisableBD[2]: GTADTR Buffer Operation DisableBD[1]: GTPR Buffer Operation DisableBD[0]: GTCCR Buffer Operation Disable
    }

    /// GTITC Register bits
    namespace gtitc_bits {
        constexpr uint32_t ADTBL = (1U << 14);  ///< GTADTRB A/D Converter Start Request Link
        constexpr uint32_t ADTAL = (1U << 12);  ///< GTADTRA A/D Converter Start Request Link
        constexpr uint32_t IVTT = (3 << 8);  ///< GPT_OVF/GPT_UDF Interrupt Skipping Count Select
        constexpr uint32_t IVTC = (2 << 6);  ///< GPT_OVF/GPT_UDF Interrupt Skipping Function Select
        constexpr uint32_t ITLF = (1U << 5);  ///< GTCCRF Compare Match Interrupt Link
        constexpr uint32_t ITLE = (1U << 4);  ///< GTCCRE Compare Match Interrupt Link
        constexpr uint32_t ITLD = (1U << 3);  ///< GTCCRD Compare Match Interrupt Link
        constexpr uint32_t ITLC = (1U << 2);  ///< GTCCRC Compare Match Interrupt Link
        constexpr uint32_t ITLB = (1U << 1);  ///< GTCCRB Compare Match/Input Capture Interrupt Link
        constexpr uint32_t ITLA = (1U << 0);  ///< GTCCRA Compare Match/Input Capture Interrupt Link
    }

    /// GTCNT Register bits
    namespace gtcnt_bits {
        constexpr uint32_t GTCNT = (32 << 0);  ///< Counter
    }

    /// GTCCRA Register bits
    namespace gtccra_bits {
        constexpr uint32_t GTCCRA = (32 << 0);  ///< Compare Capture Register A
    }

    /// GTCCRB Register bits
    namespace gtccrb_bits {
        constexpr uint32_t GTCCRB = (32 << 0);  ///< Compare Capture Register B
    }

    /// GTCCRC Register bits
    namespace gtccrc_bits {
        constexpr uint32_t GTCCRC = (32 << 0);  ///< Compare Capture Register C
    }

    /// GTCCRE Register bits
    namespace gtccre_bits {
        constexpr uint32_t GTCCRE = (32 << 0);  ///< Compare Capture Register E
    }

    /// GTCCRD Register bits
    namespace gtccrd_bits {
        constexpr uint32_t GTCCRD = (32 << 0);  ///< Compare Capture Register D
    }

    /// GTCCRF Register bits
    namespace gtccrf_bits {
        constexpr uint32_t GTCCRF = (32 << 0);  ///< Compare Capture Register F
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GTPR = (32 << 0);  ///< Cycle Setting Register
    }

    /// GTPBR Register bits
    namespace gtpbr_bits {
        constexpr uint32_t GTPBR = (32 << 0);  ///< Cycle Setting Buffer Register
    }

    /// GTPDBR Register bits
    namespace gtpdbr_bits {
        constexpr uint32_t GTPDBR = (32 << 0);  ///< Cycle Setting Double-Buffer Register
    }

    /// GTADTRA Register bits
    namespace gtadtra_bits {
        constexpr uint32_t GTADTRA = (32 << 0);  ///< A/D Converter Start Request Timing Register A
    }

    /// GTADTRB Register bits
    namespace gtadtrb_bits {
        constexpr uint32_t GTADTRB = (32 << 0);  ///< A/D Converter Start Request Timing Register B
    }

    /// GTADTBRA Register bits
    namespace gtadtbra_bits {
        constexpr uint32_t GTADTBRA = (32 << 0);  ///< A/D Converter Start Request Timing Buffer Register A
    }

    /// GTADTBRB Register bits
    namespace gtadtbrb_bits {
        constexpr uint32_t GTADTBRB = (32 << 0);  ///< A/D Converter Start Request Timing Buffer Register B
    }

    /// GTADTDBRA Register bits
    namespace gtadtdbra_bits {
        constexpr uint32_t GTADTDBRA = (32 << 0);  ///< A/D Converter Start Request Timing Double-Buffer Register A
    }

    /// GTADTDBRB Register bits
    namespace gtadtdbrb_bits {
        constexpr uint32_t GTADTDBRB = (32 << 0);  ///< A/D Converter Start Request Timing Double-Buffer Register B
    }

    /// GTDTCR Register bits
    namespace gtdtcr_bits {
        constexpr uint32_t TDFER = (1U << 8);  ///< GTDVD Setting
        constexpr uint32_t TDBDE = (1U << 5);  ///< GTDVD Buffer Operation Enable
        constexpr uint32_t TDBUE = (1U << 4);  ///< GTDVU Buffer Operation Enable
        constexpr uint32_t TDE = (1U << 0);  ///< Negative-Phase Waveform Setting
    }

    /// GTDVU Register bits
    namespace gtdvu_bits {
        constexpr uint32_t GTDVU = (32 << 0);  ///< Dead Time Value Register U
    }

    /// GTDVD Register bits
    namespace gtdvd_bits {
        constexpr uint32_t GTDVD = (32 << 0);  ///< Dead Time Value Register D
    }

    /// GTDBU Register bits
    namespace gtdbu_bits {
        constexpr uint32_t GTDVU = (32 << 0);  ///< Dead Time Buffer Register U
    }

    /// GTDBD Register bits
    namespace gtdbd_bits {
        constexpr uint32_t GTDBD = (32 << 0);  ///< Dead Time Buffer Register D
    }

    /// GTSOS Register bits
    namespace gtsos_bits {
        constexpr uint32_t SOS = (2 << 0);  ///< Output Protection Function Status
    }

    /// GTSOTR Register bits
    namespace gtsotr_bits {
        constexpr uint32_t SOTR = (1U << 0);  ///< Output Protection Function Temporary Release
    }

}

// ============================================================================
// GPT32EH1 Peripheral
// ============================================================================

namespace gpt32eh1 {
    /// Base addresses
    constexpr uint32_t GPT32EH1_BASE = 0x40078100;

    /// GPT32EH1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32EH1 = reinterpret_cast<Registers*>(GPT32EH1_BASE);

}

// ============================================================================
// GPT32EH2 Peripheral
// ============================================================================

namespace gpt32eh2 {
    /// Base addresses
    constexpr uint32_t GPT32EH2_BASE = 0x40078200;

    /// GPT32EH2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32EH2 = reinterpret_cast<Registers*>(GPT32EH2_BASE);

}

// ============================================================================
// GPT32EH3 Peripheral
// ============================================================================

namespace gpt32eh3 {
    /// Base addresses
    constexpr uint32_t GPT32EH3_BASE = 0x40078300;

    /// GPT32EH3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32EH3 = reinterpret_cast<Registers*>(GPT32EH3_BASE);

}

// ============================================================================
// GPT32E4 Peripheral
// ============================================================================

namespace gpt32e4 {
    /// Base addresses
    constexpr uint32_t GPT32E4_BASE = 0x40078400;

    /// GPT32E4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32E4 = reinterpret_cast<Registers*>(GPT32E4_BASE);

}

// ============================================================================
// GPT32E5 Peripheral
// ============================================================================

namespace gpt32e5 {
    /// Base addresses
    constexpr uint32_t GPT32E5_BASE = 0x40078500;

    /// GPT32E5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32E5 = reinterpret_cast<Registers*>(GPT32E5_BASE);

}

// ============================================================================
// GPT32E6 Peripheral
// ============================================================================

namespace gpt32e6 {
    /// Base addresses
    constexpr uint32_t GPT32E6_BASE = 0x40078600;

    /// GPT32E6 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32E6 = reinterpret_cast<Registers*>(GPT32E6_BASE);

}

// ============================================================================
// GPT32E7 Peripheral
// ============================================================================

namespace gpt32e7 {
    /// Base addresses
    constexpr uint32_t GPT32E7_BASE = 0x40078700;

    /// GPT32E7 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT32E7 = reinterpret_cast<Registers*>(GPT32E7_BASE);

}

// ============================================================================
// POEG Peripheral
// ============================================================================

namespace poeg {
    /// Base addresses
    constexpr uint32_t POEG_BASE = 0x40042000;

    /// POEG Register structure
    struct Registers {
        volatile uint32_t POEGG;  ///< Offset: 0x00 - POEG Group %s Setting Register (renamed from POEGG)
    };

    /// Peripheral instances
    inline Registers* POEG = reinterpret_cast<Registers*>(POEG_BASE);

    // Bit definitions
    /// POEGG Register bits
    namespace poegg_bits {
        constexpr uint32_t NFCS = (2 << 30);  ///< Noise Filter Clock Select
        constexpr uint32_t NFEN = (1U << 29);  ///< Noise Filter Enable
        constexpr uint32_t INV = (1U << 28);  ///< GTETRG Input Reverse
        constexpr uint32_t ST = (1U << 16);  ///< GTETRG Input Status Flag
        constexpr uint32_t CDRE5 = (1U << 13);  ///< Comparator Disable Request Enable 5Note: Can be modified only once after a reset.
        constexpr uint32_t CDRE4 = (1U << 12);  ///< Comparator Disable Request Enable 4Note: Can be modified only once after a reset.
        constexpr uint32_t CDRE3 = (1U << 11);  ///< Comparator Disable Request Enable 3Note: Can be modified only once after a reset.
        constexpr uint32_t CDRE2 = (1U << 10);  ///< Comparator Disable Request Enable 2Note: Can be modified only once after a reset.
        constexpr uint32_t CDRE1 = (1U << 9);  ///< Comparator Disable Request Enable 1Note: Can be modified only once after a reset.
        constexpr uint32_t CDRE0 = (1U << 8);  ///< Comparator Disable Request Enable 0Note: Can be modified only once after a reset.
        constexpr uint32_t OSTPE = (1U << 6);  ///< Oscillation Stop Detection EnableNote: Can be modified only once after a reset.
        constexpr uint32_t IOCE = (1U << 5);  ///< Enable for GPT Output-Disable RequestNote: Can be modified only once after a reset.
        constexpr uint32_t PIDE = (1U << 4);  ///< Port Input Detection EnableNote: Can be modified only once after a reset.
        constexpr uint32_t SSF = (1U << 3);  ///< Software Stop Flag
        constexpr uint32_t OSTPF = (1U << 2);  ///< Oscillation Stop Detection Flag
        constexpr uint32_t IOCF = (1U << 1);  ///< Real Time Overcurrent Detection Flag
        constexpr uint32_t PIDF = (1U << 0);  ///< Port Input Detection Flag
    }

}

// ============================================================================
// BUS Peripheral
// ============================================================================

namespace bus {
    /// Base addresses
    constexpr uint32_t BUS_BASE = 0x40003000;

    /// BUS Register structure
    struct Registers {
        volatile uint32_t CS0CR;  ///< Offset: 0x802 - CS0 Control Register
        volatile uint32_t CS1CR;  ///< Offset: 0x812 - CS1 Control Register
        volatile uint32_t CSCR;  ///< Offset: 0x842 - CS%s Control Register (renamed from CSCR)
        volatile uint32_t CSREC;  ///< Offset: 0x84A - CS%s Recovery Cycle Register (renamed from CSREC)
        volatile uint32_t CSRECEN;  ///< Offset: 0x880 - CS Recovery Cycle Insertion Enable Register
        volatile uint32_t CSMOD;  ///< Offset: 0x42 - CS%s Mode Register (renamed from CSMOD)
        volatile uint32_t CSWCR1;  ///< Offset: 0x44 - CS%s Wait Control Register 1 (renamed from CSWCR1)
        volatile uint32_t CSWCR2;  ///< Offset: 0x48 - CS%s Wait Control Register 2 (renamed from CSWCR2)
        volatile uint32_t BUSERRADD;  ///< Offset: 0x1800 - Bus Error Address Register %s (renamed from BUSERRADD)
        volatile uint32_t BUSERRSTAT;  ///< Offset: 0x1804 - Bus Error Status Register %s (renamed from BUSERRSTAT)
        volatile uint32_t BUSMCNT;  ///< Offset: 0x1000 - Master Bus Control Register %s (renamed from BUSMCNT)
        volatile uint32_t BUSMCNTSYS;  ///< Offset: 0x1008 - Master Bus Control Register SYS
        volatile uint32_t BUSMCNTDMA;  ///< Offset: 0x100C - Master Bus Control Register DMA
        volatile uint32_t BUSSCNT;  ///< Offset: 0x1130 - Slave Bus Control Register %s (renamed from BUSSCNT)
        volatile uint32_t BUSSCNTMBIU;  ///< Offset: 0x1108 - Slave Bus Control Register MBIU
        volatile uint32_t BUSSCNTP6B;  ///< Offset: 0x1128 - Slave Bus Control Register P6B
    };

    /// Peripheral instances
    inline Registers* BUS = reinterpret_cast<Registers*>(BUS_BASE);

    // Bit definitions
    /// CS0CR Register bits
    namespace cs0cr_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t MPXEN = (1U << 12);  ///< Address/Data Multiplexed I/O Interface Select
        constexpr uint32_t EMODE = (1U << 8);  ///< Endian Mode
        constexpr uint32_t BSIZE = (2 << 4);  ///< External Bus Width Select
        constexpr uint32_t EXENB = (1U << 0);  ///< Operation Enable
    }

    /// CS1CR Register bits
    namespace cs1cr_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t MPXEN = (1U << 12);  ///< Address/Data Multiplexed I/O Interface Select
        constexpr uint32_t EMODE = (1U << 8);  ///< Endian Mode
        constexpr uint32_t BSIZE = (2 << 4);  ///< External Bus Width Select
        constexpr uint32_t EXENB = (1U << 0);  ///< Operation Enable
    }

    /// CSCR Register bits
    namespace cscr_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t MPXEN = (1U << 12);  ///< Address/Data Multiplexed I/O Interface Select
        constexpr uint32_t EMODE = (1U << 8);  ///< Endian Mode
        constexpr uint32_t BSIZE = (2 << 4);  ///< External Bus Width Select
        constexpr uint32_t EXENB = (1U << 0);  ///< Operation Enable
    }

    /// CSREC Register bits
    namespace csrec_bits {
        constexpr uint32_t Reserved = (4 << 4);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t WRCV = (4 << 8);  ///< Write Recovery
        constexpr uint32_t RRCV = (4 << 0);  ///< Read Recovery
    }

    /// CSRECEN Register bits
    namespace csrecen_bits {
        constexpr uint32_t RCVENM7 = (1U << 15);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 7
        constexpr uint32_t RCVENM6 = (1U << 14);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 6
        constexpr uint32_t RCVENM5 = (1U << 13);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 5
        constexpr uint32_t RCVENM4 = (1U << 12);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 4
        constexpr uint32_t RCVENM3 = (1U << 11);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 3
        constexpr uint32_t RCVENM2 = (1U << 10);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 2
        constexpr uint32_t RCVENM1 = (1U << 9);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 1
        constexpr uint32_t RCVENM0 = (1U << 8);  ///< Multiplexed Bus Recovery Cycle Insertion Enable 0
        constexpr uint32_t RCVEN7 = (1U << 7);  ///< Separate Bus Recovery Cycle Insertion Enable 7
        constexpr uint32_t RCVEN6 = (1U << 6);  ///< Separate Bus Recovery Cycle Insertion Enable 6
        constexpr uint32_t RCVEN5 = (1U << 5);  ///< Separate Bus Recovery Cycle Insertion Enable 5
        constexpr uint32_t RCVEN4 = (1U << 4);  ///< Separate Bus Recovery Cycle Insertion Enable 4
        constexpr uint32_t RCVEN3 = (1U << 3);  ///< Separate Bus Recovery Cycle Insertion Enable 3
        constexpr uint32_t RCVEN2 = (1U << 2);  ///< Separate Bus Recovery Cycle Insertion Enable 2
        constexpr uint32_t RCVEN1 = (1U << 1);  ///< Separate Bus Recovery Cycle Insertion Enable 1
        constexpr uint32_t RCVEN0 = (1U << 0);  ///< Separate Bus Recovery Cycle Insertion Enable 0
    }

    /// CSMOD Register bits
    namespace csmod_bits {
        constexpr uint32_t PRMOD = (1U << 15);  ///< Page Read Access Mode Select
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t PWENB = (1U << 9);  ///< Page Write Access Enable
        constexpr uint32_t PRENB = (1U << 8);  ///< Page Read Access Enable
        constexpr uint32_t EWENB = (1U << 3);  ///< External Wait Enable
        constexpr uint32_t WRMOD = (1U << 0);  ///< Write Access Mode Select
    }

    /// CSWCR1 Register bits
    namespace cswcr1_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t CSRWAIT = (5 << 24);  ///< Normal Read Cycle Wait Select
        constexpr uint32_t CSWWAIT = (5 << 16);  ///< Normal Write Cycle Wait Select
        constexpr uint32_t CSPRWAIT = (3 << 8);  ///< Page Read Cycle Wait Select NOTE: The CSPRWAIT value is valid only when the PRENB bit in CSnMOD is set to 1.
        constexpr uint32_t CSPWWAIT = (3 << 0);  ///< Page Write Cycle Wait Select NOTE: The CSPWWAIT value is valid only when the PWENB bit in CSnMOD is set to 1.
    }

    /// CSWCR2 Register bits
    namespace cswcr2_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CSON = (3 << 28);  ///< CS Assert Wait Select
        constexpr uint32_t WDON = (3 << 24);  ///< Write Data Output Wait Select
        constexpr uint32_t WRON = (3 << 20);  ///< WR Assert Wait Select
        constexpr uint32_t RDON = (3 << 16);  ///< RD Assert Wait Select
        constexpr uint32_t AWAIT = (2 << 12);  ///< Address Cycle Wait Select
        constexpr uint32_t WDOFF = (3 << 8);  ///< Write Data Output Extension Cycle Select
        constexpr uint32_t CSWOFF = (3 << 4);  ///< Write-Access CS Extension Cycle Select
        constexpr uint32_t CSROFF = (3 << 0);  ///< Read-Access CS Extension Cycle Select
    }

    /// BUSERRADD Register bits
    namespace buserradd_bits {
        constexpr uint32_t BERAD = (32 << 0);  ///< Bus Error Address When a bus error occurs, It stores an error address.
    }

    /// BUSERRSTAT Register bits
    namespace buserrstat_bits {
        constexpr uint32_t ERRSTAT = (1U << 7);  ///< Bus Error Status When bus error assert, error flag occurs.
        constexpr uint32_t Reserved = (6 << 1);  ///< These bits are read as 000000.
        constexpr uint32_t ACCSTAT = (1U << 0);  ///< Error access status The status at the time of the error
    }

    /// BUSMCNT Register bits
    namespace busmcnt_bits {
        constexpr uint32_t IERES = (1U << 15);  ///< Ignore Error Responses
        constexpr uint32_t Reserved = (15 << 0);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
    }

    /// BUSMCNTSYS Register bits
    namespace busmcntsys_bits {
        constexpr uint32_t IERES = (1U << 15);  ///< Ignore Error Responses
        constexpr uint32_t Reserved = (15 << 0);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
    }

    /// BUSMCNTDMA Register bits
    namespace busmcntdma_bits {
        constexpr uint32_t IERES = (1U << 15);  ///< Ignore Error Responses
        constexpr uint32_t Reserved = (15 << 0);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
    }

    /// BUSSCNT Register bits
    namespace busscnt_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t EWRES = (1U << 8);  ///< Early Write Response Whether the next write request is accepted or not until a response for the write transaction comes back.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration Method Specify the priority between groups
    }

    /// BUSSCNTMBIU Register bits
    namespace busscntmbiu_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t EWRES = (1U << 8);  ///< Early Write Response Whether the next write request is accepted or not until a response for the write transaction comes back.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration Method Specify the priority between groups
    }

    /// BUSSCNTP6B Register bits
    namespace busscntp6b_bits {
        constexpr uint32_t Reserved = (4 << 0);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t EWRES = (1U << 8);  ///< Early Write Response Whether the next write request is accepted or not until a response for the write transaction comes back.
        constexpr uint32_t ARBMET = (2 << 4);  ///< Arbitration Method Specify the priority between groups
    }

}

// ============================================================================
// ICU Peripheral
// ============================================================================

namespace icu {
    /// Base addresses
    constexpr uint32_t ICU_BASE = 0x40006000;

    /// ICU Register structure
    struct Registers {
        volatile uint32_t IRQCR;  ///< Offset: 0x00 - IRQ Control Register %s (renamed from IRQCR)
        volatile uint32_t NMISR;  ///< Offset: 0x140 - Non-Maskable Interrupt Status Register
        volatile uint32_t NMIER;  ///< Offset: 0x120 - Non-Maskable Interrupt Enable Register
        volatile uint32_t NMICLR;  ///< Offset: 0x130 - Non-Maskable Interrupt Status Clear Register
        volatile uint32_t NMICR;  ///< Offset: 0x100 - NMI Pin Interrupt Control Register
        volatile uint32_t IELSR;  ///< Offset: 0x300 - INT Event Link Setting Register %s (renamed from IELSR)
        volatile uint32_t DELSR;  ///< Offset: 0x280 - DMAC Event Link Setting Register %s (renamed from DELSR)
        volatile uint32_t SELSR0;  ///< Offset: 0x200 - SYS Event Link Setting Register
        volatile uint32_t WUPEN;  ///< Offset: 0x1A0 - Wake Up interrupt enable register
    };

    /// Peripheral instances
    inline Registers* ICU = reinterpret_cast<Registers*>(ICU_BASE);

    // Bit definitions
    /// IRQCR Register bits
    namespace irqcr_bits {
        constexpr uint32_t FLTEN = (1U << 7);  ///< IRQ Digital Filter Enable
        constexpr uint32_t Reserved = (2 << 2);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t FCLKSEL = (2 << 4);  ///< IRQ Digital Filter Sampling Clock
        constexpr uint32_t IRQMD = (2 << 0);  ///< IRQ Detection Sense Select
    }

    /// NMISR Register bits
    namespace nmisr_bits {
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0.
        constexpr uint32_t SPEST = (1U << 12);  ///< MPU Stack Error Interrupt Status Flag
        constexpr uint32_t BUSMST = (1U << 11);  ///< MPU Bus Master Error Interrupt Status Flag
        constexpr uint32_t BUSSST = (1U << 10);  ///< MPU Bus Slave Error Interrupt Status Flag
        constexpr uint32_t RECCST = (1U << 9);  ///< RAM ECC Error Interrupt Status Flag
        constexpr uint32_t RPEST = (1U << 8);  ///< RAM Parity Error Interrupt Status Flag
        constexpr uint32_t NMIST = (1U << 7);  ///< NMI Status Flag
        constexpr uint32_t OSTST = (1U << 6);  ///< Oscillation Stop Detection Interrupt Status Flag
        constexpr uint32_t LVD2ST = (1U << 3);  ///< Voltage-Monitoring 2 Interrupt Status Flag
        constexpr uint32_t LVD1ST = (1U << 2);  ///< Voltage-Monitoring 1 Interrupt Status Flag
        constexpr uint32_t WDTST = (1U << 1);  ///< WDT Underflow/Refresh Error Status Flag
        constexpr uint32_t IWDTST = (1U << 0);  ///< IWDT Underflow/Refresh Error Status Flag
    }

    /// NMIER Register bits
    namespace nmier_bits {
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SPEEN = (1U << 12);  ///< MPU Stack Error Interrupt Enable
        constexpr uint32_t BUSMEN = (1U << 11);  ///< MPU Bus Master Error Interrupt Enable
        constexpr uint32_t BUSSEN = (1U << 10);  ///< MPU Bus Slave Error Interrupt Enable
        constexpr uint32_t RECCEN = (1U << 9);  ///< RAM ECC Error Interrupt Enable
        constexpr uint32_t RPEEN = (1U << 8);  ///< RAM Parity Error Interrupt Enable
        constexpr uint32_t NMIEN = (1U << 7);  ///< NMI Pin Interrupt Enable
        constexpr uint32_t OSTEN = (1U << 6);  ///< Oscillation Stop Detection Interrupt Enable
        constexpr uint32_t LVD2EN = (1U << 3);  ///< Voltage-Monitoring 2 Interrupt Enable
        constexpr uint32_t LVD1EN = (1U << 2);  ///< Voltage-Monitoring 1 Interrupt Enable
        constexpr uint32_t WDTEN = (1U << 1);  ///< WDT Underflow/Refresh Error Interrupt Enable
        constexpr uint32_t IWDTEN = (1U << 0);  ///< IWDT Underflow/Refresh Error Interrupt Enable
    }

    /// NMICLR Register bits
    namespace nmiclr_bits {
        constexpr uint32_t Reserved = (1U << 4);  ///< The write value should be 0.
        constexpr uint32_t SPECLR = (1U << 12);  ///< SPEST Clear
        constexpr uint32_t BUSMCLR = (1U << 11);  ///< BUSMST Clear
        constexpr uint32_t BUSSCLR = (1U << 10);  ///< BUSSST Clear
        constexpr uint32_t RECCCLR = (1U << 9);  ///< RECCST Clear
        constexpr uint32_t RPECLR = (1U << 8);  ///< RPEST Clear
        constexpr uint32_t NMICLR = (1U << 7);  ///< NMIST Clear
        constexpr uint32_t OSTCLR = (1U << 6);  ///< OSTST Clear
        constexpr uint32_t LVD2CLR = (1U << 3);  ///< LVD2ST Clear
        constexpr uint32_t LVD1CLR = (1U << 2);  ///< LVD1ST Clear
        constexpr uint32_t WDTCLR = (1U << 1);  ///< WDTST Clear
        constexpr uint32_t IWDTCLR = (1U << 0);  ///< IWDTST Clear
    }

    /// NMICR Register bits
    namespace nmicr_bits {
        constexpr uint32_t NFLTEN = (1U << 7);  ///< NMI Digital Filter Enable
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t NFCLKSEL = (2 << 4);  ///< NMI Digital Filter Sampling Clock
        constexpr uint32_t NMIMD = (1U << 0);  ///< NMI Detection Set
    }

    /// IELSR Register bits
    namespace ielsr_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t DTCE = (1U << 24);  ///< DTC Activation Enable
        constexpr uint32_t IR = (1U << 16);  ///< Interrupt Status Flag
        constexpr uint32_t IELS = (9 << 0);  ///< Event selection to NVIC
    }

    /// DELSR Register bits
    namespace delsr_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t IR = (1U << 16);  ///< Interrupt Status Flag for DMAC
        constexpr uint32_t DELS = (9 << 0);  ///< DMAC Event Link Select
    }

    /// SELSR0 Register bits
    namespace selsr0_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t SELS = (9 << 0);  ///< SYS Event Link Select
    }

    /// WUPEN Register bits
    namespace wupen_bits {
        constexpr uint32_t IIC0WUPEN = (1U << 31);  ///< IIC0 address match interrupt S/W standby returns enable bit
        constexpr uint32_t AGT1CBWUPEN = (1U << 30);  ///< AGT1 compare match B interrupt S/W standby returns enable bit
        constexpr uint32_t AGT1CAWUPEN = (1U << 29);  ///< AGT1 compare match A interrupt S/W standby returns enable bit
        constexpr uint32_t AGT1UDWUPEN = (1U << 28);  ///< AGT1 underflow interrupt S/W standby returns enable bit
        constexpr uint32_t USBFSWUPEN = (1U << 27);  ///< USBFS interrupt S/W standby returns enable bit
        constexpr uint32_t USBHSWUPEN = (1U << 26);  ///< USBHS interrupt S/W standby returns enable bit
        constexpr uint32_t RTCPRDWUPEN = (1U << 25);  ///< RCT period interrupt S/W standby returns enable bit
        constexpr uint32_t RTCALMWUPEN = (1U << 24);  ///< RTC alarm interrupt S/W standby returns enable bit
        constexpr uint32_t Reserved = (1U << 14);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t ACMPHS0WUPEN = (1U << 22);  ///< ACMPHS0 interrupt S/W standby returns enable bit
        constexpr uint32_t LVD2WUPEN = (1U << 19);  ///< LVD2 interrupt S/W standby returns enable bit
        constexpr uint32_t LVD1WUPEN = (1U << 18);  ///< LVD1 interrupt S/W standby returns enable bit
        constexpr uint32_t KEYWUPEN = (1U << 17);  ///< Key interrupt S/W standby returns enable bit
        constexpr uint32_t IWDTWUPEN = (1U << 16);  ///< IWDT interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN13 = (1U << 13);  ///< IRQ13 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN12 = (1U << 12);  ///< IRQ12 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN11 = (1U << 11);  ///< IRQ11 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN10 = (1U << 10);  ///< IRQ10 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN9 = (1U << 9);  ///< IRQ9 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN8 = (1U << 8);  ///< IRQ8 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN7 = (1U << 7);  ///< IRQ7 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN6 = (1U << 6);  ///< IRQ6 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN5 = (1U << 5);  ///< IRQ5 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN4 = (1U << 4);  ///< IRQ4 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN3 = (1U << 3);  ///< IRQ3 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN2 = (1U << 2);  ///< IRQ2 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN1 = (1U << 1);  ///< IRQ1 interrupt S/W standby returns enable bit
        constexpr uint32_t IRQWUPEN0 = (1U << 0);  ///< IRQ0 interrupt S/W standby returns enable bit
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORT0_BASE = 0x40040000;
    constexpr uint32_t PORT1_BASE = 0x40040020;
    constexpr uint32_t PORT2_BASE = 0x40040040;
    constexpr uint32_t PORT3_BASE = 0x40040060;
    constexpr uint32_t PORT4_BASE = 0x40040080;
    constexpr uint32_t PORT5_BASE = 0x400400A0;
    constexpr uint32_t PORT6_BASE = 0x400400C0;
    constexpr uint32_t PORT7_BASE = 0x400400E0;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCNTR1;  ///< Offset: 0x00 - Port Control Register 1
        volatile uint32_t PODR;  ///< Offset: 0x00 - Output data register
        volatile uint32_t PDR;  ///< Offset: 0x02 - Data direction register
        volatile uint32_t PCNTR2;  ///< Offset: 0x04 - Port Control Register 2
        volatile uint32_t PIDR;  ///< Offset: 0x06 - Input data register
        volatile uint32_t PCNTR3;  ///< Offset: 0x08 - Port Control Register 3
        volatile uint32_t PORR;  ///< Offset: 0x08 - Output reset register
        volatile uint32_t POSR;  ///< Offset: 0x0A - Output set register
    };

    /// Peripheral instances
    inline Registers* PORT0 = reinterpret_cast<Registers*>(PORT0_BASE);
    inline Registers* PORT1 = reinterpret_cast<Registers*>(PORT1_BASE);
    inline Registers* PORT2 = reinterpret_cast<Registers*>(PORT2_BASE);
    inline Registers* PORT3 = reinterpret_cast<Registers*>(PORT3_BASE);
    inline Registers* PORT4 = reinterpret_cast<Registers*>(PORT4_BASE);
    inline Registers* PORT5 = reinterpret_cast<Registers*>(PORT5_BASE);
    inline Registers* PORT6 = reinterpret_cast<Registers*>(PORT6_BASE);
    inline Registers* PORT7 = reinterpret_cast<Registers*>(PORT7_BASE);

    // Bit definitions
    /// PCNTR1 Register bits
    namespace pcntr1_bits {
        constexpr uint32_t PODR = (16 << 16);  ///< Pmn Output Data
        constexpr uint32_t PDR = (16 << 0);  ///< Pmn Direction
    }

    /// PODR Register bits
    namespace podr_bits {
        constexpr uint32_t PODR = (16 << 0);  ///< Pmn Output Data
    }

    /// PDR Register bits
    namespace pdr_bits {
        constexpr uint32_t PDR = (16 << 0);  ///< Pmn Direction
    }

    /// PCNTR2 Register bits
    namespace pcntr2_bits {
        constexpr uint32_t EIDR = (16 << 16);  ///< Pmn Event Input Data
        constexpr uint32_t PIDR = (16 << 0);  ///< Pmn Input Data
    }

    /// PIDR Register bits
    namespace pidr_bits {
        constexpr uint32_t PIDR = (16 << 0);  ///< Pmn Input Data
    }

    /// PCNTR3 Register bits
    namespace pcntr3_bits {
        constexpr uint32_t PORR = (16 << 16);  ///< Pmn Output Reset
        constexpr uint32_t POSR = (16 << 0);  ///< Pmn Output Set
    }

    /// PORR Register bits
    namespace porr_bits {
        constexpr uint32_t PORR = (16 << 0);  ///< Pmn Output Reset
    }

    /// POSR Register bits
    namespace posr_bits {
        constexpr uint32_t POSR = (16 << 0);  ///< Pmn Output Set
    }

}

// ============================================================================
// PFS Peripheral
// ============================================================================

namespace pfs {
    /// Base addresses
    constexpr uint32_t PFS_BASE = 0x40040800;

    /// PFS Register structure
    struct Registers {
        volatile uint32_t P000PFS;  ///< Offset: 0x00 - P000 Pin Function Control Register
        volatile uint32_t P000PFS_HA;  ///< Offset: 0x02 - P000 Pin Function Control Register
        volatile uint32_t P000PFS_BY;  ///< Offset: 0x03 - P000 Pin Function Control Register
        volatile uint32_t P00PFS;  ///< Offset: 0x04 - P00%s Pin Function Control Register (renamed from P00PFS)
        volatile uint32_t P00PFS_HA;  ///< Offset: 0x06 - P00%s Pin Function Control Register (renamed from P00PFS_HA)
        volatile uint32_t P00PFS_BY;  ///< Offset: 0x07 - P00%s Pin Function Control Register (renamed from P00PFS_BY)
        volatile uint32_t P008PFS;  ///< Offset: 0x20 - P008 Pin Function Control Register
        volatile uint32_t P008PFS_HA;  ///< Offset: 0x22 - P008 Pin Function Control Register
        volatile uint32_t P008PFS_BY;  ///< Offset: 0x23 - P008 Pin Function Control Register
        volatile uint32_t P0PFS;  ///< Offset: 0x38 - P0%s Pin Function Control Register (renamed from P0PFS)
        volatile uint32_t P0PFS_HA;  ///< Offset: 0x3A - P0%s Pin Function Control Register (renamed from P0PFS_HA)
        volatile uint32_t P0PFS_BY;  ///< Offset: 0x3B - P0%s Pin Function Control Register (renamed from P0PFS_BY)
        volatile uint32_t P100PFS;  ///< Offset: 0x40 - P100 Pin Function Control Register
        volatile uint32_t P100PFS_HA;  ///< Offset: 0x42 - P100 Pin Function Control Register
        volatile uint32_t P100PFS_BY;  ///< Offset: 0x43 - P100 Pin Function Control Register
        volatile uint32_t P10PFS;  ///< Offset: 0x44 - P10%s Pin Function Control Register (renamed from P10PFS)
        volatile uint32_t P10PFS_HA;  ///< Offset: 0x46 - P10%s Pin Function Control Register (renamed from P10PFS_HA)
        volatile uint32_t P10PFS_BY;  ///< Offset: 0x47 - P10%s Pin Function Control Register (renamed from P10PFS_BY)
        volatile uint32_t P108PFS;  ///< Offset: 0x60 - P108 Pin Function Control Register
        volatile uint32_t P108PFS_HA;  ///< Offset: 0x62 - P108 Pin Function Control Register
        volatile uint32_t P108PFS_BY;  ///< Offset: 0x63 - P108 Pin Function Control Register
        volatile uint32_t P109PFS;  ///< Offset: 0x64 - P109 Pin Function Control Register
        volatile uint32_t P109PFS_HA;  ///< Offset: 0x66 - P109 Pin Function Control Register
        volatile uint32_t P109PFS_BY;  ///< Offset: 0x67 - P109 Pin Function Control Register
        volatile uint32_t P110PFS;  ///< Offset: 0x68 - P110 Pin Function Control Register
        volatile uint32_t P110PFS_HA;  ///< Offset: 0x6A - P110 Pin Function Control Register
        volatile uint32_t P110PFS_BY;  ///< Offset: 0x6B - P110 Pin Function Control Register
        volatile uint32_t P1PFS;  ///< Offset: 0x6C - P1%s Pin Function Control Register (renamed from P1PFS)
        volatile uint32_t P1PFS_HA;  ///< Offset: 0x6E - P1%s Pin Function Control Register (renamed from P1PFS_HA)
        volatile uint32_t P1PFS_BY;  ///< Offset: 0x6F - P1%s Pin Function Control Register (renamed from P1PFS_BY)
        volatile uint32_t P200PFS;  ///< Offset: 0x80 - P200 Pin Function Control Register
        volatile uint32_t P200PFS_HA;  ///< Offset: 0x82 - P200 Pin Function Control Register
        volatile uint32_t P200PFS_BY;  ///< Offset: 0x83 - P200 Pin Function Control Register
        volatile uint32_t P201PFS;  ///< Offset: 0x84 - P201 Pin Function Control Register
        volatile uint32_t P201PFS_HA;  ///< Offset: 0x86 - P201 Pin Function Control Register
        volatile uint32_t P201PFS_BY;  ///< Offset: 0x87 - P201 Pin Function Control Register
        volatile uint32_t P20PFS;  ///< Offset: 0x94 - P20%s Pin Function Control Register (renamed from P20PFS)
        volatile uint32_t P20PFS_HA;  ///< Offset: 0x96 - P20%s Pin Function Control Register (renamed from P20PFS_HA)
        volatile uint32_t P20PFS_BY;  ///< Offset: 0x97 - P20%s Pin Function Control Register (renamed from P20PFS_BY)
        volatile uint32_t P2PFS;  ///< Offset: 0xA8 - P2%s Pin Function Control Register (renamed from P2PFS)
        volatile uint32_t P2PFS_HA;  ///< Offset: 0xAA - P2%s Pin Function Control Register (renamed from P2PFS_HA)
        volatile uint32_t P2PFS_BY;  ///< Offset: 0xAB - P2%s Pin Function Control Register (renamed from P2PFS_BY)
        volatile uint32_t P300PFS;  ///< Offset: 0xC0 - P300 Pin Function Control Register
        volatile uint32_t P300PFS_HA;  ///< Offset: 0xC2 - P300 Pin Function Control Register
        volatile uint32_t P300PFS_BY;  ///< Offset: 0xC3 - P300 Pin Function Control Register
        volatile uint32_t P30PFS;  ///< Offset: 0xC4 - P30%s Pin Function Control Register (renamed from P30PFS)
        volatile uint32_t P30PFS_HA;  ///< Offset: 0xC6 - P30%s Pin Function Control Register (renamed from P30PFS_HA)
        volatile uint32_t P30PFS_BY;  ///< Offset: 0xC7 - P30%s Pin Function Control Register (renamed from P30PFS_BY)
        volatile uint32_t P40PFS;  ///< Offset: 0x100 - P40%s Pin Function Control Register (renamed from P40PFS)
        volatile uint32_t P40PFS_HA;  ///< Offset: 0x102 - P40%s Pin Function Control Register (renamed from P40PFS_HA)
        volatile uint32_t P40PFS_BY;  ///< Offset: 0x103 - P40%s Pin Function Control Register (renamed from P40PFS_BY)
        volatile uint32_t P4PFS;  ///< Offset: 0x128 - P4%s Pin Function Control Register (renamed from P4PFS)
        volatile uint32_t P4PFS_HA;  ///< Offset: 0x12A - P4%s Pin Function Control Register (renamed from P4PFS_HA)
        volatile uint32_t P4PFS_BY;  ///< Offset: 0x12B - P4%s Pin Function Control Register (renamed from P4PFS_BY)
        volatile uint32_t P50PFS;  ///< Offset: 0x140 - P50%s Pin Function Control Register (renamed from P50PFS)
        volatile uint32_t P50PFS_HA;  ///< Offset: 0x142 - P50%s Pin Function Control Register (renamed from P50PFS_HA)
        volatile uint32_t P50PFS_BY;  ///< Offset: 0x143 - P50%s Pin Function Control Register (renamed from P50PFS_BY)
        volatile uint32_t P508PFS;  ///< Offset: 0x160 - P508 Pin Function Control Register
        volatile uint32_t P508PFS_HA;  ///< Offset: 0x162 - P508 Pin Function Control Register
        volatile uint32_t P508PFS_BY;  ///< Offset: 0x163 - P508 Pin Function Control Register
        volatile uint32_t P60PFS;  ///< Offset: 0x1A0 - P60%s Pin Function Control Register (renamed from P60PFS)
        volatile uint32_t P60PFS_HA;  ///< Offset: 0x1A2 - P60%s Pin Function Control Register (renamed from P60PFS_HA)
        volatile uint32_t P60PFS_BY;  ///< Offset: 0x1A3 - P60%s Pin Function Control Register (renamed from P60PFS_BY)
        volatile uint32_t P610PFS;  ///< Offset: 0x1A8 - P610 Pin Function Control Register
        volatile uint32_t P610PFS_HA;  ///< Offset: 0x1AA - P610 Pin Function Control Register
        volatile uint32_t P610PFS_BY;  ///< Offset: 0x1AB - P610 Pin Function Control Register
        volatile uint32_t P708PFS;  ///< Offset: 0x1E0 - P708 Pin Function Control Register
        volatile uint32_t P708PFS_HA;  ///< Offset: 0x1E2 - P708 Pin Function Control Register
        volatile uint32_t P708PFS_BY;  ///< Offset: 0x1E3 - P708 Pin Function Control Register
    };

    /// Peripheral instances
    inline Registers* PFS = reinterpret_cast<Registers*>(PFS_BASE);

    // Bit definitions
    /// P000PFS Register bits
    namespace p000pfs_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P000PFS_HA Register bits
    namespace p000pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P000PFS_BY Register bits
    namespace p000pfs_by_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P100PFS Register bits
    namespace p100pfs_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P100PFS_HA Register bits
    namespace p100pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOFR = (2 << 12);  ///< Event on Falling/Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P100PFS_BY Register bits
    namespace p100pfs_by_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P108PFS Register bits
    namespace p108pfs_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P108PFS_HA Register bits
    namespace p108pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P108PFS_BY Register bits
    namespace p108pfs_by_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P110PFS Register bits
    namespace p110pfs_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P110PFS_HA Register bits
    namespace p110pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P110PFS_BY Register bits
    namespace p110pfs_by_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P201PFS Register bits
    namespace p201pfs_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t PSEL = (5 << 24);  ///< Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table
        constexpr uint32_t PMR = (1U << 16);  ///< Port Mode Control
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P201PFS_HA Register bits
    namespace p201pfs_ha_bits {
        constexpr uint32_t ASEL = (1U << 15);  ///< Analog Input enable
        constexpr uint32_t ISEL = (1U << 14);  ///< IRQ input enable
        constexpr uint32_t EOF = (1U << 13);  ///< Event on Falling
        constexpr uint32_t EOR = (1U << 12);  ///< Event on Rising
        constexpr uint32_t DSCR = (2 << 10);  ///< Drive Strength Control Register
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

    /// P201PFS_BY Register bits
    namespace p201pfs_by_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t NCODR = (1U << 6);  ///< N-Channel Open Drain Control
        constexpr uint32_t PCR = (1U << 4);  ///< Pull-up Control
        constexpr uint32_t PDR = (1U << 2);  ///< Port Direction
        constexpr uint32_t PIDR = (1U << 1);  ///< Port Input Data
        constexpr uint32_t PODR = (1U << 0);  ///< Port Output Data
    }

}

// ============================================================================
// PMISC Peripheral
// ============================================================================

namespace pmisc {
    /// Base addresses
    constexpr uint32_t PMISC_BASE = 0x40040D00;

    /// PMISC Register structure
    struct Registers {
        volatile uint32_t PWPR;  ///< Offset: 0x03 - Write-Protect Register
    };

    /// Peripheral instances
    inline Registers* PMISC = reinterpret_cast<Registers*>(PMISC_BASE);

    // Bit definitions
    /// PWPR Register bits
    namespace pwpr_bits {
        constexpr uint32_t B0WI = (1U << 7);  ///< PFSWE Bit Write Disable
        constexpr uint32_t PFSWE = (1U << 6);  ///< PFS Register Write Enable
        constexpr uint32_t Reserved = (6 << 0);  ///< These bits are read as 000000. The write value should be 000000.
    }

}

// ============================================================================
// IIC0 Peripheral
// ============================================================================

namespace iic0 {
    /// Base addresses
    constexpr uint32_t IIC0_BASE = 0x40053000;

    /// IIC0 Register structure
    struct Registers {
        volatile uint32_t ICCR1;  ///< Offset: 0x00 - I2C Bus Control Register 1
        volatile uint32_t ICCR2;  ///< Offset: 0x01 - I2C Bus Control Register 2
        volatile uint32_t ICMR1;  ///< Offset: 0x02 - I2C Bus Mode Register 1
        volatile uint32_t ICMR2;  ///< Offset: 0x03 - I2C Bus Mode Register 2
        volatile uint32_t ICMR3;  ///< Offset: 0x04 - I2C Bus Mode Register 3
        volatile uint32_t ICFER;  ///< Offset: 0x05 - I2C Bus Function Enable Register
        volatile uint32_t ICSER;  ///< Offset: 0x06 - I2C Bus Status Enable Register
        volatile uint32_t ICIER;  ///< Offset: 0x07 - I2C Bus Interrupt Enable Register
        volatile uint32_t ICSR1;  ///< Offset: 0x08 - I2C Bus Status Register 1
        volatile uint32_t ICSR2;  ///< Offset: 0x09 - I2C Bus Status Register 2
        volatile uint32_t SARL;  ///< Offset: 0x0A - Slave Address Register L%s (renamed from SARL)
        volatile uint32_t SARU;  ///< Offset: 0x0B - Slave Address Register U%s (renamed from SARU)
        volatile uint32_t ICBRL;  ///< Offset: 0x10 - I2C Bus Bit Rate Low-Level Register
        volatile uint32_t ICBRH;  ///< Offset: 0x11 - I2C Bus Bit Rate High-Level Register
        volatile uint32_t ICDRT;  ///< Offset: 0x12 - I2C Bus Transmit Data Register
        volatile uint32_t ICDRR;  ///< Offset: 0x13 - I2C Bus Receive Data Register
        volatile uint32_t ICWUR;  ///< Offset: 0x16 - I2C Bus Wake Up Unit Register
        volatile uint32_t ICWUR2;  ///< Offset: 0x17 - I2C Bus Wake Up Unit Register 2
    };

    /// Peripheral instances
    inline Registers* IIC0 = reinterpret_cast<Registers*>(IIC0_BASE);

    // Bit definitions
    /// ICCR1 Register bits
    namespace iccr1_bits {
        constexpr uint32_t ICE = (1U << 7);  ///< I2C Bus Interface Enable
        constexpr uint32_t IICRST = (1U << 6);  ///< I2C Bus Interface Internal Reset Note:If an internal reset is initiated using the IICRST bit for a bus hang-up occurred during communication with the master device in slave mode, the states may become different between the slave device and the master device (due to the difference in the bit counter information).
        constexpr uint32_t CLO = (1U << 5);  ///< Extra SCL Clock Cycle Output
        constexpr uint32_t SOWP = (1U << 4);  ///< SCLO/SDAO Write Protect
        constexpr uint32_t SCLO = (1U << 3);  ///< SCL Output Control/Monitor
        constexpr uint32_t SDAO = (1U << 2);  ///< SDA Output Control/Monitor
        constexpr uint32_t SCLI = (1U << 1);  ///< SCL Line Monitor
        constexpr uint32_t SDAI = (1U << 0);  ///< SDA Line Monitor
    }

    /// ICCR2 Register bits
    namespace iccr2_bits {
        constexpr uint32_t BBSY = (1U << 7);  ///< Bus Busy Detection Flag
        constexpr uint32_t MST = (1U << 6);  ///< Master/Slave Mode
        constexpr uint32_t TRS = (1U << 5);  ///< Transmit/Receive Mode
        constexpr uint32_t Reserved = (1U << 0);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SP = (1U << 3);  ///< Stop Condition Issuance Request Note: Writing to the SP bit is not possible while the setting of the BBSY flag is 0 (bus free state). Note: Do not set the SP bit to 1 while a restart condition is being issued.
        constexpr uint32_t RS = (1U << 2);  ///< Restart Condition Issuance Request Note: Do not set the RS bit to 1 while issuing a stop condition.
        constexpr uint32_t ST = (1U << 1);  ///< Start Condition Issuance Request Set the ST bit to 1 (start condition issuance request) when the BBSY flag is set to 0 (bus free state).
    }

    /// ICMR1 Register bits
    namespace icmr1_bits {
        constexpr uint32_t MTWP = (1U << 7);  ///< MST/TRS Write Protect
        constexpr uint32_t CKS = (3 << 4);  ///< Internal Reference Clock (fIIC) Selection ( fIIC = PCLKB / 2^CKS )
        constexpr uint32_t BCWP = (1U << 3);  ///< BC Write Protect (This bit is read as 1.)
        constexpr uint32_t BC = (3 << 0);  ///< Bit Counter
    }

    /// ICMR2 Register bits
    namespace icmr2_bits {
        constexpr uint32_t DLCS = (1U << 7);  ///< SDA Output Delay Clock Source Selection
        constexpr uint32_t SDDL = (3 << 4);  ///< SDA Output Delay Counter
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TMOH = (1U << 2);  ///< Timeout H Count Control
        constexpr uint32_t TMOL = (1U << 1);  ///< Timeout L Count Control
        constexpr uint32_t TMOS = (1U << 0);  ///< Timeout Detection Time Selection
    }

    /// ICMR3 Register bits
    namespace icmr3_bits {
        constexpr uint32_t SMBS = (1U << 7);  ///< SMBus/I2C Bus Selection
        constexpr uint32_t WAIT = (1U << 6);  ///< WAIT Note: When the value of the WAIT bit is to be read, be sure to read the ICDRR beforehand.
        constexpr uint32_t RDRFS = (1U << 5);  ///< RDRF Flag Set Timing Selection
        constexpr uint32_t ACKWP = (1U << 4);  ///< ACKBT Write Protect
        constexpr uint32_t ACKBT = (1U << 3);  ///< Transmit Acknowledge
        constexpr uint32_t ACKBR = (1U << 2);  ///< Receive Acknowledge
        constexpr uint32_t NF = (2 << 0);  ///< Noise Filter Stage Selection
    }

    /// ICFER Register bits
    namespace icfer_bits {
        constexpr uint32_t FMPE = (1U << 7);  ///< Fast-mode Plus Enable
        constexpr uint32_t SCLE = (1U << 6);  ///< SCL Synchronous Circuit Enable
        constexpr uint32_t NFE = (1U << 5);  ///< Digital Noise Filter Circuit Enable
        constexpr uint32_t NACKE = (1U << 4);  ///< NACK Reception Transfer Suspension Enable
        constexpr uint32_t SALE = (1U << 3);  ///< Slave Arbitration-Lost Detection Enable
        constexpr uint32_t NALE = (1U << 2);  ///< NACK Transmission Arbitration-Lost Detection Enable
        constexpr uint32_t MALE = (1U << 1);  ///< Master Arbitration-Lost Detection Enable
        constexpr uint32_t TMOE = (1U << 0);  ///< Timeout Function Enable
    }

    /// ICSER Register bits
    namespace icser_bits {
        constexpr uint32_t HOAE = (1U << 7);  ///< Host Address Enable
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DIDE = (1U << 5);  ///< Device-ID Address Detection Enable
        constexpr uint32_t GCAE = (1U << 3);  ///< General Call Address Enable
        constexpr uint32_t SAR2E = (1U << 2);  ///< Slave Address Register 2 Enable
        constexpr uint32_t SAR1E = (1U << 1);  ///< Slave Address Register 1 Enable
        constexpr uint32_t SAR0E = (1U << 0);  ///< Slave Address Register 0 Enable
    }

    /// ICIER Register bits
    namespace icier_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Data Empty Interrupt Request Enable
        constexpr uint32_t TEIE = (1U << 6);  ///< Transmit End Interrupt Request Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receive Data Full Interrupt Request Enable
        constexpr uint32_t NAKIE = (1U << 4);  ///< NACK Reception Interrupt Request Enable
        constexpr uint32_t SPIE = (1U << 3);  ///< Stop Condition Detection Interrupt Request Enable
        constexpr uint32_t STIE = (1U << 2);  ///< Start Condition Detection Interrupt Request Enable
        constexpr uint32_t ALIE = (1U << 1);  ///< Arbitration-Lost Interrupt Request Enable
        constexpr uint32_t TMOIE = (1U << 0);  ///< Timeout Interrupt Request Enable
    }

    /// ICSR1 Register bits
    namespace icsr1_bits {
        constexpr uint32_t HOA = (1U << 7);  ///< Host Address Detection Flag
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DID = (1U << 5);  ///< Device-ID Address Detection Flag
        constexpr uint32_t GCA = (1U << 3);  ///< General Call Address Detection Flag
        constexpr uint32_t AAS2 = (1U << 2);  ///< Slave Address 2 Detection Flag
        constexpr uint32_t AAS1 = (1U << 1);  ///< Slave Address 1 Detection Flag
        constexpr uint32_t AAS0 = (1U << 0);  ///< Slave Address 0 Detection Flag
    }

    /// ICSR2 Register bits
    namespace icsr2_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t TEND = (1U << 6);  ///< Transmit End Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Full Flag
        constexpr uint32_t NACKF = (1U << 4);  ///< NACK Detection Flag
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Condition Detection Flag
        constexpr uint32_t START = (1U << 2);  ///< Start Condition Detection Flag
        constexpr uint32_t AL = (1U << 1);  ///< Arbitration-Lost Flag
        constexpr uint32_t TMOF = (1U << 0);  ///< Timeout Detection Flag
    }

    /// SARL Register bits
    namespace sarl_bits {
        constexpr uint32_t SVA = (8 << 0);  ///< A slave address is set. 7-Bit Address = SVA[7:1] 10-Bit Address = { SVA9,SVA8,SVA[7:0] }
    }

    /// SARU Register bits
    namespace saru_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SVA9 = (1U << 2);  ///< 10-Bit Address(bit9)
        constexpr uint32_t SVA8 = (1U << 1);  ///< 10-Bit Address(bit8)
        constexpr uint32_t FS = (1U << 0);  ///< 7-Bit/10-Bit Address Format Selection
    }

    /// ICBRL Register bits
    namespace icbrl_bits {
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 1. The write value should be 1.
        constexpr uint32_t BRL = (5 << 0);  ///< Bit Rate Low-Level Period (Low-level period of SCL clock)
    }

    /// ICBRH Register bits
    namespace icbrh_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 111. The write value should be 111.
        constexpr uint32_t BRH = (5 << 0);  ///< Bit Rate High-Level Period (High-level period of SCL clock)
    }

    /// ICDRT Register bits
    namespace icdrt_bits {
        constexpr uint32_t ICDRT = (8 << 0);  ///< 8-bit read-write register that stores transmit data.
    }

    /// ICDRR Register bits
    namespace icdrr_bits {
        constexpr uint32_t ICDRR = (8 << 0);  ///< 8-bit register that stores the received data
    }

    /// ICWUR Register bits
    namespace icwur_bits {
        constexpr uint32_t WUE = (1U << 7);  ///< Wake Up function Enable
        constexpr uint32_t WUIE = (1U << 6);  ///< Wake Up Interrupt Request Enable
        constexpr uint32_t WUF = (1U << 5);  ///< Wake-Up Event Occurrence Flag
        constexpr uint32_t WUACK = (1U << 4);  ///< Asynchronous/Synchronous Operation State Flag
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t WUAFA = (1U << 0);  ///< Wake-Up Analog Filter Additional Selection
    }

    /// ICWUR2 Register bits
    namespace icwur2_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000.
        constexpr uint32_t WUSYF = (1U << 2);  ///< Wake-Up function synchronous operation status flag
        constexpr uint32_t WUASYF = (1U << 1);  ///< Wake-Up function asynchronous operation status flag
        constexpr uint32_t WUSEN = (1U << 0);  ///< Wake-Up function synchronous enable
    }

}

// ============================================================================
// IIC1 Peripheral
// ============================================================================

namespace iic1 {
    /// Base addresses
    constexpr uint32_t IIC1_BASE = 0x40053100;

    /// IIC1 Register structure
    struct Registers {
        volatile uint32_t ICCR1;  ///< Offset: 0x00 - I2C Bus Control Register 1
        volatile uint32_t ICCR2;  ///< Offset: 0x01 - I2C Bus Control Register 2
        volatile uint32_t ICMR1;  ///< Offset: 0x02 - I2C Bus Mode Register 1
        volatile uint32_t ICMR2;  ///< Offset: 0x03 - I2C Bus Mode Register 2
        volatile uint32_t ICMR3;  ///< Offset: 0x04 - I2C Bus Mode Register 3
        volatile uint32_t ICFER;  ///< Offset: 0x05 - I2C Bus Function Enable Register
        volatile uint32_t ICSER;  ///< Offset: 0x06 - I2C Bus Status Enable Register
        volatile uint32_t ICIER;  ///< Offset: 0x07 - I2C Bus Interrupt Enable Register
        volatile uint32_t ICSR1;  ///< Offset: 0x08 - I2C Bus Status Register 1
        volatile uint32_t ICSR2;  ///< Offset: 0x09 - I2C Bus Status Register 2
        volatile uint32_t SARL;  ///< Offset: 0x0A - Slave Address Register L%s (renamed from SARL)
        volatile uint32_t SARU;  ///< Offset: 0x0B - Slave Address Register U%s (renamed from SARU)
        volatile uint32_t ICBRL;  ///< Offset: 0x10 - I2C Bus Bit Rate Low-Level Register
        volatile uint32_t ICBRH;  ///< Offset: 0x11 - I2C Bus Bit Rate High-Level Register
        volatile uint32_t ICDRT;  ///< Offset: 0x12 - I2C Bus Transmit Data Register
        volatile uint32_t ICDRR;  ///< Offset: 0x13 - I2C Bus Receive Data Register
    };

    /// Peripheral instances
    inline Registers* IIC1 = reinterpret_cast<Registers*>(IIC1_BASE);

    // Bit definitions
    /// ICCR1 Register bits
    namespace iccr1_bits {
        constexpr uint32_t ICE = (1U << 7);  ///< I2C Bus Interface Enable
        constexpr uint32_t IICRST = (1U << 6);  ///< I2C Bus Interface Internal Reset Note:If an internal reset is initiated using the IICRST bit for a bus hang-up occurred during communication with the master device in slave mode, the states may become different between the slave device and the master device (due to the difference in the bit counter information).
        constexpr uint32_t CLO = (1U << 5);  ///< Extra SCL Clock Cycle Output
        constexpr uint32_t SOWP = (1U << 4);  ///< SCLO/SDAO Write Protect
        constexpr uint32_t SCLO = (1U << 3);  ///< SCL Output Control/Monitor
        constexpr uint32_t SDAO = (1U << 2);  ///< SDA Output Control/Monitor
        constexpr uint32_t SCLI = (1U << 1);  ///< SCL Line Monitor
        constexpr uint32_t SDAI = (1U << 0);  ///< SDA Line Monitor
    }

    /// ICCR2 Register bits
    namespace iccr2_bits {
        constexpr uint32_t BBSY = (1U << 7);  ///< Bus Busy Detection Flag
        constexpr uint32_t MST = (1U << 6);  ///< Master/Slave Mode
        constexpr uint32_t TRS = (1U << 5);  ///< Transmit/Receive Mode
        constexpr uint32_t Reserved = (1U << 0);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t SP = (1U << 3);  ///< Stop Condition Issuance Request Note: Writing to the SP bit is not possible while the setting of the BBSY flag is 0 (bus free state). Note: Do not set the SP bit to 1 while a restart condition is being issued.
        constexpr uint32_t RS = (1U << 2);  ///< Restart Condition Issuance Request Note: Do not set the RS bit to 1 while issuing a stop condition.
        constexpr uint32_t ST = (1U << 1);  ///< Start Condition Issuance Request Set the ST bit to 1 (start condition issuance request) when the BBSY flag is set to 0 (bus free state).
    }

    /// ICMR1 Register bits
    namespace icmr1_bits {
        constexpr uint32_t MTWP = (1U << 7);  ///< MST/TRS Write Protect
        constexpr uint32_t CKS = (3 << 4);  ///< Internal Reference Clock (fIIC) Selection ( fIIC = PCLKB / 2^CKS )
        constexpr uint32_t BCWP = (1U << 3);  ///< BC Write Protect (This bit is read as 1.)
        constexpr uint32_t BC = (3 << 0);  ///< Bit Counter
    }

    /// ICMR2 Register bits
    namespace icmr2_bits {
        constexpr uint32_t DLCS = (1U << 7);  ///< SDA Output Delay Clock Source Selection
        constexpr uint32_t SDDL = (3 << 4);  ///< SDA Output Delay Counter
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TMOH = (1U << 2);  ///< Timeout H Count Control
        constexpr uint32_t TMOL = (1U << 1);  ///< Timeout L Count Control
        constexpr uint32_t TMOS = (1U << 0);  ///< Timeout Detection Time Selection
    }

    /// ICMR3 Register bits
    namespace icmr3_bits {
        constexpr uint32_t SMBS = (1U << 7);  ///< SMBus/I2C Bus Selection
        constexpr uint32_t WAIT = (1U << 6);  ///< WAIT Note: When the value of the WAIT bit is to be read, be sure to read the ICDRR beforehand.
        constexpr uint32_t RDRFS = (1U << 5);  ///< RDRF Flag Set Timing Selection
        constexpr uint32_t ACKWP = (1U << 4);  ///< ACKBT Write Protect
        constexpr uint32_t ACKBT = (1U << 3);  ///< Transmit Acknowledge
        constexpr uint32_t ACKBR = (1U << 2);  ///< Receive Acknowledge
        constexpr uint32_t NF = (2 << 0);  ///< Noise Filter Stage Selection
    }

    /// ICFER Register bits
    namespace icfer_bits {
        constexpr uint32_t FMPE = (1U << 7);  ///< Fast-mode Plus Enable
        constexpr uint32_t SCLE = (1U << 6);  ///< SCL Synchronous Circuit Enable
        constexpr uint32_t NFE = (1U << 5);  ///< Digital Noise Filter Circuit Enable
        constexpr uint32_t NACKE = (1U << 4);  ///< NACK Reception Transfer Suspension Enable
        constexpr uint32_t SALE = (1U << 3);  ///< Slave Arbitration-Lost Detection Enable
        constexpr uint32_t NALE = (1U << 2);  ///< NACK Transmission Arbitration-Lost Detection Enable
        constexpr uint32_t MALE = (1U << 1);  ///< Master Arbitration-Lost Detection Enable
        constexpr uint32_t TMOE = (1U << 0);  ///< Timeout Function Enable
    }

    /// ICSER Register bits
    namespace icser_bits {
        constexpr uint32_t HOAE = (1U << 7);  ///< Host Address Enable
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DIDE = (1U << 5);  ///< Device-ID Address Detection Enable
        constexpr uint32_t GCAE = (1U << 3);  ///< General Call Address Enable
        constexpr uint32_t SAR2E = (1U << 2);  ///< Slave Address Register 2 Enable
        constexpr uint32_t SAR1E = (1U << 1);  ///< Slave Address Register 1 Enable
        constexpr uint32_t SAR0E = (1U << 0);  ///< Slave Address Register 0 Enable
    }

    /// ICIER Register bits
    namespace icier_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Data Empty Interrupt Request Enable
        constexpr uint32_t TEIE = (1U << 6);  ///< Transmit End Interrupt Request Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receive Data Full Interrupt Request Enable
        constexpr uint32_t NAKIE = (1U << 4);  ///< NACK Reception Interrupt Request Enable
        constexpr uint32_t SPIE = (1U << 3);  ///< Stop Condition Detection Interrupt Request Enable
        constexpr uint32_t STIE = (1U << 2);  ///< Start Condition Detection Interrupt Request Enable
        constexpr uint32_t ALIE = (1U << 1);  ///< Arbitration-Lost Interrupt Request Enable
        constexpr uint32_t TMOIE = (1U << 0);  ///< Timeout Interrupt Request Enable
    }

    /// ICSR1 Register bits
    namespace icsr1_bits {
        constexpr uint32_t HOA = (1U << 7);  ///< Host Address Detection Flag
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DID = (1U << 5);  ///< Device-ID Address Detection Flag
        constexpr uint32_t GCA = (1U << 3);  ///< General Call Address Detection Flag
        constexpr uint32_t AAS2 = (1U << 2);  ///< Slave Address 2 Detection Flag
        constexpr uint32_t AAS1 = (1U << 1);  ///< Slave Address 1 Detection Flag
        constexpr uint32_t AAS0 = (1U << 0);  ///< Slave Address 0 Detection Flag
    }

    /// ICSR2 Register bits
    namespace icsr2_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t TEND = (1U << 6);  ///< Transmit End Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Full Flag
        constexpr uint32_t NACKF = (1U << 4);  ///< NACK Detection Flag
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Condition Detection Flag
        constexpr uint32_t START = (1U << 2);  ///< Start Condition Detection Flag
        constexpr uint32_t AL = (1U << 1);  ///< Arbitration-Lost Flag
        constexpr uint32_t TMOF = (1U << 0);  ///< Timeout Detection Flag
    }

    /// SARL Register bits
    namespace sarl_bits {
        constexpr uint32_t SVA = (8 << 0);  ///< A slave address is set. 7-Bit Address = SVA[7:1] 10-Bit Address = { SVA9,SVA8,SVA[7:0] }
    }

    /// SARU Register bits
    namespace saru_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SVA9 = (1U << 2);  ///< 10-Bit Address(bit9)
        constexpr uint32_t SVA8 = (1U << 1);  ///< 10-Bit Address(bit8)
        constexpr uint32_t FS = (1U << 0);  ///< 7-Bit/10-Bit Address Format Selection
    }

    /// ICBRL Register bits
    namespace icbrl_bits {
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 1. The write value should be 1.
        constexpr uint32_t BRL = (5 << 0);  ///< Bit Rate Low-Level Period (Low-level period of SCL clock)
    }

    /// ICBRH Register bits
    namespace icbrh_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 111. The write value should be 111.
        constexpr uint32_t BRH = (5 << 0);  ///< Bit Rate High-Level Period (High-level period of SCL clock)
    }

    /// ICDRT Register bits
    namespace icdrt_bits {
        constexpr uint32_t ICDRT = (8 << 0);  ///< 8-bit read-write register that stores transmit data.
    }

    /// ICDRR Register bits
    namespace icdrr_bits {
        constexpr uint32_t ICDRR = (8 << 0);  ///< 8-bit register that stores the received data
    }

}

// ============================================================================
// SCI0 Peripheral
// ============================================================================

namespace sci0 {
    /// Base addresses
    constexpr uint32_t SCI0_BASE = 0x40070000;

    /// SCI0 Register structure
    struct Registers {
        volatile uint32_t SMR;  ///< Offset: 0x00 - Serial Mode Register (SCMR.SMIF = 0)
        volatile uint32_t SMR_SMCI;  ///< Offset: 0x00 - Serial mode register (SCMR.SMIF = 1)
        volatile uint32_t BRR;  ///< Offset: 0x01 - Bit Rate Register
        volatile uint32_t SCR;  ///< Offset: 0x02 - Serial Control Register (SCMR.SMIF = 0)
        volatile uint32_t SCR_SMCI;  ///< Offset: 0x02 - Serial Control Register (SCMR.SMIF =1)
        volatile uint32_t TDR;  ///< Offset: 0x03 - Transmit Data Register
        volatile uint32_t SSR;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
        volatile uint32_t SSR_FIFO;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 0 and FCR.FM=1)
        volatile uint32_t SSR_SMCI;  ///< Offset: 0x04 - Serial Status Register(SCMR.SMIF = 1)
        volatile uint32_t RDR;  ///< Offset: 0x05 - Receive Data Register
        volatile uint32_t SCMR;  ///< Offset: 0x06 - Smart Card Mode Register
        volatile uint32_t SEMR;  ///< Offset: 0x07 - Serial Extended Mode Register
        volatile uint32_t SNFR;  ///< Offset: 0x08 - Noise Filter Setting Register
        volatile uint32_t SIMR1;  ///< Offset: 0x09 - I2C Mode Register 1
        volatile uint32_t SIMR2;  ///< Offset: 0x0A - I2C Mode Register 2
        volatile uint32_t SIMR3;  ///< Offset: 0x0B - I2C Mode Register 3
        volatile uint32_t SISR;  ///< Offset: 0x0C - I2C Status Register
        volatile uint32_t SPMR;  ///< Offset: 0x0D - SPI Mode Register
        volatile uint32_t TDRHL;  ///< Offset: 0x0E - Transmit 9-bit Data Register
        volatile uint32_t FTDRHL;  ///< Offset: 0x0E - Transmit FIFO Data Register HL
        volatile uint32_t FTDRH;  ///< Offset: 0x0E - Transmit FIFO Data Register H
        volatile uint32_t FTDRL;  ///< Offset: 0x0F - Transmit FIFO Data Register L
        volatile uint32_t RDRHL;  ///< Offset: 0x10 - Receive 9-bit Data Register
        volatile uint32_t FRDRHL;  ///< Offset: 0x10 - Receive FIFO Data Register HL
        volatile uint32_t FRDRH;  ///< Offset: 0x10 - Receive FIFO Data Register H
        volatile uint32_t FRDRL;  ///< Offset: 0x11 - Receive FIFO Data Register L
        volatile uint32_t MDDR;  ///< Offset: 0x12 - Modulation Duty Register
        volatile uint32_t DCCR;  ///< Offset: 0x13 - Data Compare Match Control Register
        volatile uint32_t FCR;  ///< Offset: 0x14 - FIFO Control Register
        volatile uint32_t FDR;  ///< Offset: 0x16 - FIFO Data Count Register
        volatile uint32_t LSR;  ///< Offset: 0x18 - Line Status Register
        volatile uint32_t CDR;  ///< Offset: 0x1A - Compare Match Data Register
        volatile uint32_t SPTR;  ///< Offset: 0x1C - Serial Port Register
    };

    /// Peripheral instances
    inline Registers* SCI0 = reinterpret_cast<Registers*>(SCI0_BASE);

    // Bit definitions
    /// SMR Register bits
    namespace smr_bits {
        constexpr uint32_t CM = (1U << 7);  ///< Communications Mode
        constexpr uint32_t CHR = (1U << 6);  ///< Character Length (Valid only in asynchronous mode)
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable (Valid only in asynchronous mode)
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode (Valid only when the PE bit is 1)
        constexpr uint32_t STOP = (1U << 3);  ///< Stop Bit Length (Valid only in asynchronous mode)
        constexpr uint32_t MP = (1U << 2);  ///< Multi-Processor Mode (Valid only in asynchronous mode)
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
    }

    /// SMR_SMCI Register bits
    namespace smr_smci_bits {
        constexpr uint32_t GM = (1U << 7);  ///< GSM Mode
        constexpr uint32_t BLK = (1U << 6);  ///< Block Transfer Mode
        constexpr uint32_t PE = (1U << 5);  ///< Parity Enable (Valid only in asynchronous mode)
        constexpr uint32_t PM = (1U << 4);  ///< Parity Mode (Valid only when the PE bit is 1)
        constexpr uint32_t BCP = (2 << 2);  ///< Stop Bit Length (Valid only in asynchronous mode)
        constexpr uint32_t CKS = (2 << 0);  ///< Clock Select
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR = (8 << 0);  ///< BRR is an 8-bit register that adjusts the bit rate.
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable (Valid in asynchronous mode when SMR.MP = 1)
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
    }

    /// SCR_SMCI Register bits
    namespace scr_smci_bits {
        constexpr uint32_t TIE = (1U << 7);  ///< Transmit Interrupt Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t TE = (1U << 5);  ///< Transmit Enable
        constexpr uint32_t RE = (1U << 4);  ///< Receive Enable
        constexpr uint32_t MPIE = (1U << 3);  ///< Multi-Processor Interrupt Enable Set this bit to 0 in smart card interface mode.
        constexpr uint32_t TEIE = (1U << 2);  ///< Transmit End Interrupt Enable Set this bit to 0 in smart card interface mode.
        constexpr uint32_t CKE = (2 << 0);  ///< Clock Enable
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (8 << 0);  ///< TDR is an 8-bit register that stores transmit data.
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-Processor Bit. Value of the multi-processor bit in the reception frame
        constexpr uint32_t MPBT = (1U << 0);  ///< Multi-Processor Bit Transfer. Sets the multi-processor bit for adding to the transmission frame
    }

    /// SSR_FIFO Register bits
    namespace ssr_fifo_bits {
        constexpr uint32_t TDFE = (1U << 7);  ///< Transmit FIFO data empty flag
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO data full flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t FER = (1U << 4);  ///< Framing Error Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DR = (1U << 0);  ///< Receive Data Ready flag (Valid only in asynchronous mode(including multi-processor) and FIFO selected)
    }

    /// SSR_SMCI Register bits
    namespace ssr_smci_bits {
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Empty Flag
        constexpr uint32_t RDRF = (1U << 6);  ///< Receive Data Full Flag
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun Error Flag
        constexpr uint32_t ERS = (1U << 4);  ///< Error Signal Status Flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity Error Flag
        constexpr uint32_t TEND = (1U << 2);  ///< Transmit End Flag
        constexpr uint32_t MPB = (1U << 1);  ///< This bit should be 0 in smart card interface mode.
        constexpr uint32_t MPBT = (1U << 0);  ///< This bit should be 0 in smart card interface mode.
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (8 << 0);  ///< RDR is an 8-bit register that stores receive data.
    }

    /// SCMR Register bits
    namespace scmr_bits {
        constexpr uint32_t BCP2 = (1U << 7);  ///< Base Clock Pulse 2 Selects the number of base clock cycles in combination with the SMR.BCP[1:0] bits
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 1. The write value should be 1.
        constexpr uint32_t CHR1 = (1U << 4);  ///< Character Length 1 (Only valid in asynchronous mode)
        constexpr uint32_t SDIR = (1U << 3);  ///< Transmitted/Received Data Transfer Direction NOTE: The setting is invalid and a fixed data length of 8 bits is used in modes other than asynchronous mode. Set this bit to 1 if operation is to be in simple I2C mode.
        constexpr uint32_t SINV = (1U << 2);  ///< Transmitted/Received Data Invert Set this bit to 0 if operation is to be in simple I2C mode.
        constexpr uint32_t SMIF = (1U << 0);  ///< Smart Card Interface Mode Select
    }

    /// SEMR Register bits
    namespace semr_bits {
        constexpr uint32_t RXDESEL = (1U << 7);  ///< Asynchronous Start Bit Edge Detection Select (Valid only in asynchronous mode)
        constexpr uint32_t BGDM = (1U << 6);  ///< Baud Rate Generator Double-Speed Mode Select (Only valid the CKE[1] bit in SCR is 0 in asynchronous mode).
        constexpr uint32_t NFEN = (1U << 5);  ///< Digital Noise Filter Function Enable (The NFEN bit should be 0 without simple I2C mode and asynchronous mode.) In asynchronous mode, for RXDn input only. In simple I2C mode, for RXDn/TxDn input.
        constexpr uint32_t ABCS = (1U << 4);  ///< Asynchronous Mode Base Clock Select (Valid only in asynchronous mode)
        constexpr uint32_t ABCSE = (1U << 3);  ///< Asynchronous Mode Extended Base Clock Select1 (Valid only in asynchronous mode and SCR.CKE[1]=0)
        constexpr uint32_t BRME = (1U << 2);  ///< Bit Modulation Enable
        constexpr uint32_t Reserved = (1U << 0);  ///< This bit is read as 0. The write value should be 0.
    }

    /// SNFR Register bits
    namespace snfr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t NFCS = (3 << 0);  ///< Noise Filter Clock Select
    }

    /// SIMR1 Register bits
    namespace simr1_bits {
        constexpr uint32_t IICDL = (5 << 3);  ///< SSDA Delay Output Select Cycles below are of the clock signal from the on-chip baud rate generator.
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t IICM = (1U << 0);  ///< Simple I2C Mode Select
    }

    /// SIMR2 Register bits
    namespace simr2_bits {
        constexpr uint32_t Reserved = (3 << 2);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t IICACKT = (1U << 5);  ///< ACK Transmission Data
        constexpr uint32_t IICCSC = (1U << 1);  ///< Clock Synchronization
        constexpr uint32_t IICINTM = (1U << 0);  ///< I2C Interrupt Mode Select
    }

    /// SIMR3 Register bits
    namespace simr3_bits {
        constexpr uint32_t IICSCLS = (2 << 6);  ///< SCL Output Select
        constexpr uint32_t IICSDAS = (2 << 4);  ///< SDA Output Select
        constexpr uint32_t IICSTIF = (1U << 3);  ///< Issuing of Start, Restart, or Stop Condition Completed Flag (When 0 is written to IICSTIF, it is cleared to 0.)
        constexpr uint32_t IICSTPREQ = (1U << 2);  ///< Stop Condition Generation
        constexpr uint32_t IICRSTAREQ = (1U << 1);  ///< Restart Condition Generation
        constexpr uint32_t IICSTAREQ = (1U << 0);  ///< Start Condition Generation
    }

    /// SISR Register bits
    namespace sisr_bits {
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0.
        constexpr uint32_t IICACKR = (1U << 0);  ///< ACK Reception Data Flag
    }

    /// SPMR Register bits
    namespace spmr_bits {
        constexpr uint32_t CKPH = (1U << 7);  ///< Clock Phase Select
        constexpr uint32_t CKPOL = (1U << 6);  ///< Clock Polarity Select
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t MFF = (1U << 4);  ///< Mode Fault Flag
        constexpr uint32_t MSS = (1U << 2);  ///< Master or slave mode selection
        constexpr uint32_t CTSE = (1U << 1);  ///< CTS Enable
        constexpr uint32_t SSE = (1U << 0);  ///< SSn# Pin Function Enable
    }

    /// TDRHL Register bits
    namespace tdrhl_bits {
        constexpr uint32_t TDRHL = (16 << 0);  ///< TDRHL is a 16-bit register that stores transmit data.
    }

    /// FTDRHL Register bits
    namespace ftdrhl_bits {
        constexpr uint32_t Reserved = (6 << 10);  ///< The write value should be 111111.
        constexpr uint32_t MPBT = (1U << 9);  ///< Multi-processor transfer bit flag (Valid only in asynchronous mode and SMR.MP=1 and FIFO selected)
        constexpr uint32_t TDAT = (9 << 0);  ///< Serial transmit data (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FTDRH Register bits
    namespace ftdrh_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< The write value should be 111111.
        constexpr uint32_t MPBT = (1U << 1);  ///< Multi-processor transfer bit flag (Valid only in asynchronous mode and SMR.MP=1 and FIFO selected)
        constexpr uint32_t TDATH = (1U << 0);  ///< Serial transmit data (b8) (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FTDRL Register bits
    namespace ftdrl_bits {
        constexpr uint32_t TDATL = (8 << 0);  ///< Serial transmit data(b7-b0) (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// RDRHL Register bits
    namespace rdrhl_bits {
        constexpr uint32_t RDRHL = (16 << 0);  ///< RDRHL is an 16-bit register that stores receive data.
    }

    /// FRDRHL Register bits
    namespace frdrhl_bits {
        constexpr uint32_t Reserved = (1U << 15);  ///< This bit is read as 0.
        constexpr uint32_t RDF = (1U << 14);  ///< Receive FIFO data full flag (It is same as SSR.RDF)
        constexpr uint32_t ORER = (1U << 13);  ///< Overrun error flag (It is same as SSR.ORER)
        constexpr uint32_t FER = (1U << 12);  ///< Framing error flag
        constexpr uint32_t PER = (1U << 11);  ///< Parity error flag
        constexpr uint32_t DR = (1U << 10);  ///< Receive data ready flag (It is same as SSR.DR)
        constexpr uint32_t MPB = (1U << 9);  ///< Multi-processor bit flag (Valid only in asynchronous mode with SMR.MP=1 and FIFO selected) It can read multi-processor bit corresponded to serial receive data(RDATA[8:0])
        constexpr uint32_t RDAT = (9 << 0);  ///< Serial receive data (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FRDRH Register bits
    namespace frdrh_bits {
        constexpr uint32_t Reserved = (1U << 7);  ///< This bit is read as 0.
        constexpr uint32_t RDF = (1U << 6);  ///< Receive FIFO data full flag (It is same as SSR.RDF)
        constexpr uint32_t ORER = (1U << 5);  ///< Overrun error flag (It is same as SSR.ORER)
        constexpr uint32_t FER = (1U << 4);  ///< Framing error flag
        constexpr uint32_t PER = (1U << 3);  ///< Parity error flag
        constexpr uint32_t DR = (1U << 2);  ///< Receive data ready flag (It is same as SSR.DR)
        constexpr uint32_t MPB = (1U << 1);  ///< Multi-processor bit flag (Valid only in asynchronous mode with SMR.MP=1 and FIFO selected) It can read multi-processor bit corresponded to serial receive data(RDATA[8:0])
        constexpr uint32_t RDATH = (1U << 0);  ///< Serial receive data(b8) (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// FRDRL Register bits
    namespace frdrl_bits {
        constexpr uint32_t RDATL = (8 << 0);  ///< Serial receive data (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected) NOTE: When reading both of FRDRH register and FRDRL register, please read by an order of the FRDRH register and the FRDRL register.
    }

    /// MDDR Register bits
    namespace mddr_bits {
        constexpr uint32_t MDDR = (8 << 0);  ///< MDDR corrects the bit rate adjusted by the BRR register.
    }

    /// DCCR Register bits
    namespace dccr_bits {
        constexpr uint32_t DCME = (1U << 7);  ///< Data Compare Match Enable (Valid only in asynchronous mode(including multi-processor)
        constexpr uint32_t IDSEL = (1U << 6);  ///< ID frame select Bit (Valid only in asynchronous mode(including multi-processor)
        constexpr uint32_t Reserved = (2 << 1);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t DFER = (1U << 4);  ///< Data Compare Match Framing Error Flag
        constexpr uint32_t DPER = (1U << 3);  ///< Data Compare Match Parity Error Flag
        constexpr uint32_t DCMF = (1U << 0);  ///< Data Compare Match Flag
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t RSTRG = (4 << 12);  ///< RTS# Output Active Trigger Number Select (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode)
        constexpr uint32_t RTRG = (4 << 8);  ///< Receive FIFO data trigger number
        constexpr uint32_t TTRG = (4 << 4);  ///< Transmit FIFO data trigger number (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode)
        constexpr uint32_t DRES = (1U << 3);  ///< Receive data ready error select bit (When detecting a reception data ready, the interrupt request is selected.)
        constexpr uint32_t TFRST = (1U << 2);  ///< Transmit FIFO Data Register Reset (Valid only in FCR.FM=1)
        constexpr uint32_t RFRST = (1U << 1);  ///< Receive FIFO Data Register Reset (Valid only in FCR.FM=1)
        constexpr uint32_t FM = (1U << 0);  ///< FIFO Mode Select (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode)
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000.
        constexpr uint32_t T = (5 << 8);  ///< Transmit FIFO Data Count Indicate the quantity of non-transmit data stored in FTDRH and FTDRL (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, while FCR.FM=1)
        constexpr uint32_t R = (5 << 0);  ///< Receive FIFO Data Count Indicate the quantity of receive data stored in FRDRH and FRDRL (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, while FCR.FM=1)
    }

    /// LSR Register bits
    namespace lsr_bits {
        constexpr uint32_t Reserved = (1U << 1);  ///< This bit is read as 0.
        constexpr uint32_t PNUM = (5 << 8);  ///< Parity Error Count Indicates the quantity of data with a parity error among the receive data stored in the receive FIFO data register (FRDRH and FRDRL).
        constexpr uint32_t FNUM = (5 << 2);  ///< Framing Error Count Indicates the quantity of data with a framing error among the receive data stored in the receive FIFO data register (FRDRH and FRDRL).
        constexpr uint32_t ORER = (1U << 0);  ///< Overrun Error Flag (Valid only in asynchronous mode(including multi-processor) or clock synchronous mode, and FIFO selected)
    }

    /// CDR Register bits
    namespace cdr_bits {
        constexpr uint32_t Reserved = (7 << 9);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPD = (9 << 0);  ///< Compare Match Data Compare data pattern for address match wake-up function
    }

    /// SPTR Register bits
    namespace sptr_bits {
        constexpr uint32_t Reserved = (5 << 3);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SPB2IO = (1U << 2);  ///< Serial port break I/O bit (It's selected whether the value of SPB2DT is output to TxD terminal.)
        constexpr uint32_t SPB2DT = (1U << 1);  ///< Serial port break data select bit (The output level of TxD terminal is selected when SCR.TE = 0.)
        constexpr uint32_t RXDMON = (1U << 0);  ///< Serial input data monitor bit (The state of the RXD terminal is shown.)
    }

}

// ============================================================================
// SCI1 Peripheral
// ============================================================================

namespace sci1 {
    /// Base addresses
    constexpr uint32_t SCI1_BASE = 0x40070020;

    /// SCI1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI1 = reinterpret_cast<Registers*>(SCI1_BASE);

}

// ============================================================================
// SCI2 Peripheral
// ============================================================================

namespace sci2 {
    /// Base addresses
    constexpr uint32_t SCI2_BASE = 0x40070040;

    /// SCI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI2 = reinterpret_cast<Registers*>(SCI2_BASE);

}

// ============================================================================
// SCI3 Peripheral
// ============================================================================

namespace sci3 {
    /// Base addresses
    constexpr uint32_t SCI3_BASE = 0x40070060;

    /// SCI3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI3 = reinterpret_cast<Registers*>(SCI3_BASE);

}

// ============================================================================
// SCI4 Peripheral
// ============================================================================

namespace sci4 {
    /// Base addresses
    constexpr uint32_t SCI4_BASE = 0x40070080;

    /// SCI4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI4 = reinterpret_cast<Registers*>(SCI4_BASE);

}

// ============================================================================
// SCI8 Peripheral
// ============================================================================

namespace sci8 {
    /// Base addresses
    constexpr uint32_t SCI8_BASE = 0x40070100;

    /// SCI8 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI8 = reinterpret_cast<Registers*>(SCI8_BASE);

}

// ============================================================================
// SCI9 Peripheral
// ============================================================================

namespace sci9 {
    /// Base addresses
    constexpr uint32_t SCI9_BASE = 0x40070120;

    /// SCI9 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCI9 = reinterpret_cast<Registers*>(SCI9_BASE);

}

// ============================================================================
// GPT328 Peripheral
// ============================================================================

namespace gpt328 {
    /// Base addresses
    constexpr uint32_t GPT328_BASE = 0x40078800;

    /// GPT328 Register structure
    struct Registers {
        volatile uint32_t GTWP;  ///< Offset: 0x00 - General PWM Timer Write-Protection Register
        volatile uint32_t GTSTR;  ///< Offset: 0x04 - General PWM Timer Software Start Register
        volatile uint32_t GTSTP;  ///< Offset: 0x08 - General PWM Timer Software Stop Register
        volatile uint32_t GTCLR;  ///< Offset: 0x0C - General PWM Timer Software Clear Register
        volatile uint32_t GTSSR;  ///< Offset: 0x10 - General PWM Timer Start Source Select Register
        volatile uint32_t GTPSR;  ///< Offset: 0x14 - General PWM Timer Stop Source Select Register
        volatile uint32_t GTCSR;  ///< Offset: 0x18 - General PWM Timer Clear Source Select Register
        volatile uint32_t GTUPSR;  ///< Offset: 0x1C - General PWM Timer Up Count Source Select Register
        volatile uint32_t GTDNSR;  ///< Offset: 0x20 - General PWM Timer Down Count Source Select Register
        volatile uint32_t GTICASR;  ///< Offset: 0x24 - General PWM Timer Input Capture Source Select Register A
        volatile uint32_t GTICBSR;  ///< Offset: 0x28 - General PWM Timer Input Capture Source Select Register B
        volatile uint32_t GTCR;  ///< Offset: 0x2C - General PWM Timer Control Register
        volatile uint32_t GTUDDTYC;  ///< Offset: 0x30 - General PWM Timer Count Direction and Duty Setting Register
        volatile uint32_t GTIOR;  ///< Offset: 0x34 - General PWM Timer I/O Control Register
        volatile uint32_t GTINTAD;  ///< Offset: 0x38 - General PWM Timer Interrupt Output Setting Register
        volatile uint32_t GTST;  ///< Offset: 0x3C - General PWM Timer Status Register
        volatile uint32_t GTBER;  ///< Offset: 0x40 - General PWM Timer Buffer Enable Register
        volatile uint32_t GTCNT;  ///< Offset: 0x48 - General PWM Timer Counter
        volatile uint32_t GTCCRA;  ///< Offset: 0x4C - General PWM Timer Compare Capture Register A
        volatile uint32_t GTCCRB;  ///< Offset: 0x50 - General PWM Timer Compare Capture Register B
        volatile uint32_t GTCCRC;  ///< Offset: 0x54 - General PWM Timer Compare Capture Register C
        volatile uint32_t GTCCRE;  ///< Offset: 0x58 - General PWM Timer Compare Capture Register E
        volatile uint32_t GTCCRD;  ///< Offset: 0x5C - General PWM Timer Compare Capture Register D
        volatile uint32_t GTCCRF;  ///< Offset: 0x60 - General PWM Timer Compare Capture Register F
        volatile uint32_t GTPR;  ///< Offset: 0x64 - General PWM Timer Cycle Setting Register
        volatile uint32_t GTPBR;  ///< Offset: 0x68 - General PWM Timer Cycle Setting Buffer Register
        volatile uint32_t GTDTCR;  ///< Offset: 0x88 - General PWM Timer Dead Time Control Register
        volatile uint32_t GTDVU;  ///< Offset: 0x8C - General PWM Timer Dead Time Value Register U
    };

    /// Peripheral instances
    inline Registers* GPT328 = reinterpret_cast<Registers*>(GPT328_BASE);

    // Bit definitions
    /// GTWP Register bits
    namespace gtwp_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PRKEY = (8 << 8);  ///< GTWP Key Code
        constexpr uint32_t WP = (1U << 0);  ///< Register Write Disable
    }

    /// GTSTR Register bits
    namespace gtstr_bits {
        constexpr uint32_t Reserved = (19 << 13);  ///< These bits are read as 0000000000000000000. The write value should be 0000000000000000000.
        constexpr uint32_t CSTRT12 = (1U << 12);  ///< Channel 12 GTCNT Count Start Read data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT11 = (1U << 11);  ///< Channel 11 GTCNT Count Start Read data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT10 = (1U << 10);  ///< Channel 10 GTCNT Count Start Read data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT9 = (1U << 9);  ///< Channel 9 GTCNT Count Start Read data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT8 = (1U << 8);  ///< Channel 8 GTCNT Count Start Read data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT7 = (1U << 7);  ///< Channel 7 GTCNT Count Start Read data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT6 = (1U << 6);  ///< Channel 6 GTCNT Count Start Read data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT5 = (1U << 5);  ///< Channel 5 GTCNT Count Start Read data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT4 = (1U << 4);  ///< Channel 4 GTCNT Count Start Read data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT3 = (1U << 3);  ///< Channel 3 GTCNT Count Start Read data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT2 = (1U << 2);  ///< Channel 2 GTCNT Count Start Read data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT1 = (1U << 1);  ///< Channel 1 GTCNT Count Start Read data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
        constexpr uint32_t CSTRT0 = (1U << 0);  ///< Channel 0 GTCNT Count Start Read data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running.
    }

    /// GTSTP Register bits
    namespace gtstp_bits {
        constexpr uint32_t Reserved = (19 << 13);  ///< These bits are read as 1111111111111111111. The write value should be 1111111111111111111.
        constexpr uint32_t CSTOP12 = (1U << 12);  ///< Channel 12 GTCNT Count Stop Read data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP11 = (1U << 11);  ///< Channel 11 GTCNT Count Stop Read data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP10 = (1U << 10);  ///< Channel 10 GTCNT Count Stop Read data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP9 = (1U << 9);  ///< Channel 9 GTCNT Count Stop Read data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP8 = (1U << 8);  ///< Channel 8 GTCNT Count Stop Read data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP7 = (1U << 7);  ///< Channel 7 GTCNT Count Stop Read data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP6 = (1U << 6);  ///< Channel 6 GTCNT Count Stop Read data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP5 = (1U << 5);  ///< Channel 5 GTCNT Count Stop Read data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP4 = (1U << 4);  ///< Channel 4 GTCNT Count Stop Read data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP3 = (1U << 3);  ///< Channel 3 GTCNT Count Stop Read data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP2 = (1U << 2);  ///< Channel 2 GTCNT Count Stop Read data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP1 = (1U << 1);  ///< Channel 1 GTCNT Count Stop Read data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
        constexpr uint32_t CSTOP0 = (1U << 0);  ///< Channel 0 GTCNT Count Stop Read data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop.
    }

    /// GTCLR Register bits
    namespace gtclr_bits {
        constexpr uint32_t Reserved = (19 << 13);  ///< The write value should be 1111111111111111111.
        constexpr uint32_t CCLR12 = (1U << 12);  ///< Channel 12 GTCNT Count Clear
        constexpr uint32_t CCLR11 = (1U << 11);  ///< Channel 11 GTCNT Count Clear
        constexpr uint32_t CCLR10 = (1U << 10);  ///< Channel 10 GTCNT Count Clear
        constexpr uint32_t CCLR9 = (1U << 9);  ///< Channel 9 GTCNT Count Clear
        constexpr uint32_t CCLR8 = (1U << 8);  ///< Channel 8 GTCNT Count Clear
        constexpr uint32_t CCLR7 = (1U << 7);  ///< Channel 7 GTCNT Count Clear
        constexpr uint32_t CCLR6 = (1U << 6);  ///< Channel 6 GTCNT Count Clear
        constexpr uint32_t CCLR5 = (1U << 5);  ///< Channel 5 GTCNT Count Clear
        constexpr uint32_t CCLR4 = (1U << 4);  ///< Channel 4 GTCNT Count Clear
        constexpr uint32_t CCLR3 = (1U << 3);  ///< Channel 3 GTCNT Count Clear
        constexpr uint32_t CCLR2 = (1U << 2);  ///< Channel 2 GTCNT Count Clear
        constexpr uint32_t CCLR1 = (1U << 1);  ///< Channel 1 GTCNT Count Clear
        constexpr uint32_t CCLR0 = (1U << 0);  ///< Channel 0 GTCNT Count Clear
    }

    /// GTSSR Register bits
    namespace gtssr_bits {
        constexpr uint32_t CSTRT = (1U << 31);  ///< Software Source Counter Start Enable
        constexpr uint32_t Reserved = (7 << 24);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t SSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Start Enable
        constexpr uint32_t SSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Start Enable
        constexpr uint32_t SSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Start Enable
        constexpr uint32_t SSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Start Enable
        constexpr uint32_t SSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Start Enable
        constexpr uint32_t SSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Start Enable
        constexpr uint32_t SSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Start Enable
        constexpr uint32_t SSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Start Enable
        constexpr uint32_t SSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Start Enable
        constexpr uint32_t SSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Start Enable
        constexpr uint32_t SSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Start Enable
        constexpr uint32_t SSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Start Enable
        constexpr uint32_t SSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Start Enable
        constexpr uint32_t SSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Start Enable
    }

    /// GTPSR Register bits
    namespace gtpsr_bits {
        constexpr uint32_t CSTOP = (1U << 31);  ///< Software Source Counter Stop Enable
        constexpr uint32_t Reserved = (7 << 24);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Stop Enable
        constexpr uint32_t PSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Stop Enable
        constexpr uint32_t PSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Stop Enable
        constexpr uint32_t PSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Stop Enable
        constexpr uint32_t PSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Stop Enable
        constexpr uint32_t PSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Stop Enable
        constexpr uint32_t PSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Stop Enable
        constexpr uint32_t PSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Stop Enable
        constexpr uint32_t PSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Stop Enable
        constexpr uint32_t PSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Stop Enable
        constexpr uint32_t PSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Stop Enable
        constexpr uint32_t PSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Stop Enable
        constexpr uint32_t PSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Stop Enable
        constexpr uint32_t PSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Stop Enable
    }

    /// GTCSR Register bits
    namespace gtcsr_bits {
        constexpr uint32_t CCLR = (1U << 31);  ///< Software Source Counter Clear Enable
        constexpr uint32_t Reserved = (7 << 24);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Clear Enable
        constexpr uint32_t CSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Clear Enable
        constexpr uint32_t CSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Clear Enable
        constexpr uint32_t CSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Clear Enable
        constexpr uint32_t CSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Clear Enable
        constexpr uint32_t CSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Clear Enable
        constexpr uint32_t CSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Clear Enable
        constexpr uint32_t CSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Clear Enable
        constexpr uint32_t CSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Clear Enable
        constexpr uint32_t CSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Clear Enable
        constexpr uint32_t CSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Clear Enable
        constexpr uint32_t CSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Clear Enable
        constexpr uint32_t CSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Clear Enable
        constexpr uint32_t CSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Clear Enable
    }

    /// GTUPSR Register bits
    namespace gtupsr_bits {
        constexpr uint32_t Reserved = (8 << 24);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t USELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Count Up Enable
        constexpr uint32_t USELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Up Enable
        constexpr uint32_t USELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Up Enable
        constexpr uint32_t USELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Up Enable
        constexpr uint32_t USELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Up Enable
        constexpr uint32_t USELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Up Enable
        constexpr uint32_t USELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Up Enable
        constexpr uint32_t USELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Up Enable
        constexpr uint32_t USCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Up Enable
        constexpr uint32_t USCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Up Enable
        constexpr uint32_t USCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Up Enable
        constexpr uint32_t USCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Up Enable
        constexpr uint32_t USGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Up Enable
        constexpr uint32_t USGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Up Enable
    }

    /// GTDNSR Register bits
    namespace gtdnsr_bits {
        constexpr uint32_t Reserved = (8 << 24);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t DSELCH = (1U << 23);  ///< ELC_GPTH Event Source Counter Count Down Enable
        constexpr uint32_t DSELCG = (1U << 22);  ///< ELC_GPTG Event Source Counter Count Down Enable
        constexpr uint32_t DSELCF = (1U << 21);  ///< ELC_GPTF Event Source Counter Count Down Enable
        constexpr uint32_t DSELCE = (1U << 20);  ///< ELC_GPTE Event Source Counter Count Down Enable
        constexpr uint32_t DSELCD = (1U << 19);  ///< ELC_GPTD Event Source Counter Count Down Enable
        constexpr uint32_t DSELCC = (1U << 18);  ///< ELC_GPTC Event Source Counter Count Down Enable
        constexpr uint32_t DSELCB = (1U << 17);  ///< ELC_GPTB Event Source Counter Count Down Enable
        constexpr uint32_t DSELCA = (1U << 16);  ///< ELC_GPTA Event Source Counter Count Down Enable
        constexpr uint32_t DSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Down Enable
        constexpr uint32_t DSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Down Enable
        constexpr uint32_t DSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Down Enable
        constexpr uint32_t DSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source Counter Count Down Enable
        constexpr uint32_t DSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source Counter Count Down Enable
    }

    /// GTICASR Register bits
    namespace gticasr_bits {
        constexpr uint32_t Reserved = (8 << 24);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t ASELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRA Input Capture Enable
        constexpr uint32_t ASCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable
        constexpr uint32_t ASGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable
    }

    /// GTICBSR Register bits
    namespace gticbsr_bits {
        constexpr uint32_t Reserved = (8 << 24);  ///< These bits are read as 00000000. The write value should be 00000000.
        constexpr uint32_t BSELCH = (1U << 23);  ///< ELC_GPTH Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCG = (1U << 22);  ///< ELC_GPTG Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCF = (1U << 21);  ///< ELC_GPTF Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCE = (1U << 20);  ///< ELC_GPTE Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCD = (1U << 19);  ///< ELC_GPTD Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCC = (1U << 18);  ///< ELC_GPTC Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCB = (1U << 17);  ///< ELC_GPTB Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSELCA = (1U << 16);  ///< ELC_GPTA Event Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAH = (1U << 15);  ///< GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBFAL = (1U << 14);  ///< GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAH = (1U << 13);  ///< GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCBRAL = (1U << 12);  ///< GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBH = (1U << 11);  ///< GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCAFBL = (1U << 10);  ///< GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBH = (1U << 9);  ///< GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRB Input Capture Enable
        constexpr uint32_t BSCARBL = (1U << 8);  ///< GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGDF = (1U << 7);  ///< GTETRGD Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGDR = (1U << 6);  ///< GTETRGD Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGCF = (1U << 5);  ///< GTETRGC Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGCR = (1U << 4);  ///< GTETRGC Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBF = (1U << 3);  ///< GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGBR = (1U << 2);  ///< GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAF = (1U << 1);  ///< GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable
        constexpr uint32_t BSGTRGAR = (1U << 0);  ///< GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable
    }

    /// GTCR Register bits
    namespace gtcr_bits {
        constexpr uint32_t Reserved = (15 << 1);  ///< These bits are read as 000000000000000. The write value should be 000000000000000.
        constexpr uint32_t TPCS = (3 << 24);  ///< Timer Prescaler Select
        constexpr uint32_t MD = (3 << 16);  ///< Mode Select
        constexpr uint32_t CST = (1U << 0);  ///< Count Start
    }

    /// GTUDDTYC Register bits
    namespace gtuddtyc_bits {
        constexpr uint32_t Reserved = (14 << 2);  ///< These bits are read as 00000000000000. The write value should be 00000000000000.
        constexpr uint32_t OBDTYR = (1U << 27);  ///< GTIOCB Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OBDTYF = (1U << 26);  ///< Forcible GTIOCB Output Duty Setting
        constexpr uint32_t OBDTY = (2 << 24);  ///< GTIOCB Output Duty Setting
        constexpr uint32_t OADTYR = (1U << 19);  ///< GTIOCA Output Value Selecting after Releasing 0 percent/100 percent Duty Setting
        constexpr uint32_t OADTYF = (1U << 18);  ///< Forcible GTIOCA Output Duty Setting
        constexpr uint32_t OADTY = (2 << 16);  ///< GTIOCA Output Duty Setting
        constexpr uint32_t UDF = (1U << 1);  ///< Forcible Count Direction Setting
        constexpr uint32_t UD = (1U << 0);  ///< Count Direction Setting
    }

    /// GTIOR Register bits
    namespace gtior_bits {
        constexpr uint32_t NFCSB = (2 << 30);  ///< Noise Filter B Sampling Clock Select
        constexpr uint32_t NFBEN = (1U << 29);  ///< Noise Filter B Enable
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t OBDF = (2 << 25);  ///< GTIOCB Pin Disable Value Setting
        constexpr uint32_t OBE = (1U << 24);  ///< GTIOCB Pin Output Enable
        constexpr uint32_t OBHLD = (1U << 23);  ///< GTIOCB Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OBDFLT = (1U << 22);  ///< GTIOCB Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOB = (5 << 16);  ///< GTIOCB Pin Function Select
        constexpr uint32_t NFCSA = (2 << 14);  ///< Noise Filter A Sampling Clock Select
        constexpr uint32_t NFAEN = (1U << 13);  ///< Noise Filter A Enable
        constexpr uint32_t OADF = (2 << 9);  ///< GTIOCA Pin Disable Value Setting
        constexpr uint32_t OAE = (1U << 8);  ///< GTIOCA Pin Output Enable
        constexpr uint32_t OAHLD = (1U << 7);  ///< GTIOCA Pin Output Setting at the Start/Stop Count
        constexpr uint32_t OADFLT = (1U << 6);  ///< GTIOCA Pin Output Value Setting at the Count Stop
        constexpr uint32_t GTIOA = (5 << 0);  ///< GTIOCA Pin Function Select
    }

    /// GTINTAD Register bits
    namespace gtintad_bits {
        constexpr uint32_t Reserved = (24 << 0);  ///< These bits are read as 000000000000000000000000. The write value should be 000000000000000000000000.
        constexpr uint32_t GRPABL = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t GRPABH = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t GRP = (2 << 24);  ///< Output Disable Source Select
    }

    /// GTST Register bits
    namespace gtst_bits {
        constexpr uint32_t Reserved = (7 << 8);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t OABLF = (1U << 30);  ///< Same Time Output Level Low Disable Request Enable
        constexpr uint32_t OABHF = (1U << 29);  ///< Same Time Output Level High Disable Request Enable
        constexpr uint32_t ODF = (1U << 24);  ///< Output Disable Flag
        constexpr uint32_t TUCF = (1U << 15);  ///< Count Direction Flag
        constexpr uint32_t TCFPU = (1U << 7);  ///< Underflow Flag
        constexpr uint32_t TCFPO = (1U << 6);  ///< Overflow Flag
        constexpr uint32_t TCFF = (1U << 5);  ///< Input Compare Match Flag F
        constexpr uint32_t TCFE = (1U << 4);  ///< Input Compare Match Flag E
        constexpr uint32_t TCFD = (1U << 3);  ///< Input Compare Match Flag D
        constexpr uint32_t TCFC = (1U << 2);  ///< Input Compare Match Flag C
        constexpr uint32_t TCFB = (1U << 1);  ///< Input Capture/Compare Match Flag B
        constexpr uint32_t TCFA = (1U << 0);  ///< Input Capture/Compare Match Flag A
    }

    /// GTBER Register bits
    namespace gtber_bits {
        constexpr uint32_t Reserved = (14 << 2);  ///< These bits are read as 00000000000000. The write value should be 00000000000000.
        constexpr uint32_t CCRSWT = (1U << 22);  ///< GTCCRA and GTCCRB Forcible Buffer Operation This bit is read as 0.
        constexpr uint32_t PR = (2 << 20);  ///< GTPR Buffer Operation
        constexpr uint32_t CCRB = (2 << 18);  ///< GTCCRB Buffer Operation
        constexpr uint32_t CCRA = (2 << 16);  ///< GTCCRA Buffer Operation
        constexpr uint32_t BD1 = (1U << 1);  ///< GTPR Buffer Operation Disable
        constexpr uint32_t BD2 = (1U << 0);  ///< GTCCR Buffer Operation Disable
    }

    /// GTCNT Register bits
    namespace gtcnt_bits {
        constexpr uint32_t GTCNT = (32 << 0);  ///< Counter
    }

    /// GTCCRA Register bits
    namespace gtccra_bits {
        constexpr uint32_t GTCCRA = (32 << 0);  ///< Compare Capture Register A
    }

    /// GTCCRB Register bits
    namespace gtccrb_bits {
        constexpr uint32_t GTCCRB = (32 << 0);  ///< Compare Capture Register B
    }

    /// GTCCRC Register bits
    namespace gtccrc_bits {
        constexpr uint32_t GTCCRC = (32 << 0);  ///< Compare Capture Register C
    }

    /// GTCCRE Register bits
    namespace gtccre_bits {
        constexpr uint32_t GTCCRE = (32 << 0);  ///< Compare Capture Register E
    }

    /// GTCCRD Register bits
    namespace gtccrd_bits {
        constexpr uint32_t GTCCRD = (32 << 0);  ///< Compare Capture Register D
    }

    /// GTCCRF Register bits
    namespace gtccrf_bits {
        constexpr uint32_t GTCCRF = (32 << 0);  ///< Compare Capture Register F
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GTPR = (32 << 0);  ///< Cycle Setting Register
    }

    /// GTPBR Register bits
    namespace gtpbr_bits {
        constexpr uint32_t GTPBR = (32 << 0);  ///< Cycle Setting Buffer Register
    }

    /// GTDTCR Register bits
    namespace gtdtcr_bits {
        constexpr uint32_t Reserved = (31 << 1);  ///< These bits are read as 0000000000000000000000000000000. The write value should be 0000000000000000000000000000000.
        constexpr uint32_t TDE = (1U << 0);  ///< Negative-Phase Waveform Setting
    }

    /// GTDVU Register bits
    namespace gtdvu_bits {
        constexpr uint32_t GTDVU = (32 << 0);  ///< Dead Time Value Register U
    }

}

// ============================================================================
// GPT329 Peripheral
// ============================================================================

namespace gpt329 {
    /// Base addresses
    constexpr uint32_t GPT329_BASE = 0x40078900;

    /// GPT329 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT329 = reinterpret_cast<Registers*>(GPT329_BASE);

}

// ============================================================================
// GPT3210 Peripheral
// ============================================================================

namespace gpt3210 {
    /// Base addresses
    constexpr uint32_t GPT3210_BASE = 0x40078A00;

    /// GPT3210 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT3210 = reinterpret_cast<Registers*>(GPT3210_BASE);

}

// ============================================================================
// GPT3211 Peripheral
// ============================================================================

namespace gpt3211 {
    /// Base addresses
    constexpr uint32_t GPT3211_BASE = 0x40078B00;

    /// GPT3211 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT3211 = reinterpret_cast<Registers*>(GPT3211_BASE);

}

// ============================================================================
// GPT3212 Peripheral
// ============================================================================

namespace gpt3212 {
    /// Base addresses
    constexpr uint32_t GPT3212_BASE = 0x40078C00;

    /// GPT3212 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GPT3212 = reinterpret_cast<Registers*>(GPT3212_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC120_BASE = 0x4005C000;
    constexpr uint32_t ADC121_BASE = 0x4005C200;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADCSR;  ///< Offset: 0x00 - A/D Control Register
        volatile uint32_t ADANSA0;  ///< Offset: 0x04 - A/D Channel Select Register A0
        volatile uint32_t ADANSA1;  ///< Offset: 0x06 - A/D Channel Select Register A1
        volatile uint32_t ADADS0;  ///< Offset: 0x08 - A/D-Converted Value Addition/Average Channel Select Register 0
        volatile uint32_t ADADS1;  ///< Offset: 0x0A - A/D-Converted Value Addition/Average Channel Select Register 1
        volatile uint32_t ADADC;  ///< Offset: 0x0C - A/D-Converted Value Addition/Average Count Select Register
        volatile uint32_t ADCER;  ///< Offset: 0x0E - A/D Control Extended Register
        volatile uint32_t ADSTRGR;  ///< Offset: 0x10 - A/D Conversion Start Trigger Select Register
        volatile uint32_t ADEXICR;  ///< Offset: 0x12 - A/D Conversion Extended Input Control Register
        volatile uint32_t ADANSB0;  ///< Offset: 0x14 - A/D Channel Select Register B0
        volatile uint32_t ADANSB1;  ///< Offset: 0x16 - A/D Channel Select Register B1
        volatile uint32_t ADDBLDR;  ///< Offset: 0x18 - A/D Data Duplication Register
        volatile uint32_t ADTSDR;  ///< Offset: 0x1A - A/D Temperature Sensor Data Register
        volatile uint32_t ADOCDR;  ///< Offset: 0x1C - A/D Internal Reference Voltage Data Register
        volatile uint32_t ADRD;  ///< Offset: 0x1E - A/D Self-Diagnosis Data Register
        volatile uint32_t ADDR;  ///< Offset: 0x40 - A/D Data Register %s (renamed from ADDR)
        volatile uint32_t ADSHCR;  ///< Offset: 0x66 - A/D Sample and Hold Circuit Control Register
        volatile uint32_t ADDISCR;  ///< Offset: 0x7A - A/D Disconnection Detection Control Register
        volatile uint32_t ADSHMSR;  ///< Offset: 0x7C - A/D Sample and Hold Operation Mode Select Register
        volatile uint32_t ADGSPCR;  ///< Offset: 0x80 - A/D Group Scan Priority Control Register
        volatile uint32_t ADDBLDRA;  ///< Offset: 0x84 - A/D Data Duplication Register A
        volatile uint32_t ADDBLDRB;  ///< Offset: 0x86 - A/D Data Duplication Register B
        volatile uint32_t ADWINMON;  ///< Offset: 0x8C - A/D Compare Function Window A/B Status Monitor Register
        volatile uint32_t ADCMPCR;  ///< Offset: 0x90 - A/D Compare Function Control Register
        volatile uint32_t ADCMPANSER;  ///< Offset: 0x92 - A/D Compare Function Window A Extended Input Select Register
        volatile uint32_t ADCMPLER;  ///< Offset: 0x93 - A/D Compare Function Window A Extended Input Comparison...
        volatile uint32_t ADCMPANSR0;  ///< Offset: 0x94 - A/D Compare Function Window A Channel Select Register 0
        volatile uint32_t ADCMPANSR1;  ///< Offset: 0x96 - A/D Compare Function Window A Channel Select Register 1
        volatile uint32_t ADCMPLR0;  ///< Offset: 0x98 - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPLR1;  ///< Offset: 0x9A - A/D Compare Function Window A Comparison Condition...
        volatile uint32_t ADCMPDR0;  ///< Offset: 0x9C - A/D Compare Function Window A Lower-Side Level Setting Register
        volatile uint32_t ADCMPDR1;  ///< Offset: 0x9E - A/D Compare Function Window A Upper-Side Level Setting Register
        volatile uint32_t ADCMPSR0;  ///< Offset: 0xA0 - A/D Compare Function Window A Channel Status Register 0
        volatile uint32_t ADCMPSR1;  ///< Offset: 0xA2 - A/D Compare Function Window A Channel Status Register 1
        volatile uint32_t ADCMPSER;  ///< Offset: 0xA4 - A/D Compare Function Window A Extended Input Channel...
        volatile uint32_t ADCMPBNSR;  ///< Offset: 0xA6 - A/D Compare Function Window B Channel Selection Register
        volatile uint32_t ADWINLLB;  ///< Offset: 0xA8 - A/D Compare Function Window B Lower-Side Level Setting Register
        volatile uint32_t ADWINULB;  ///< Offset: 0xAA - A/D Compare Function Window B Upper-Side Level Setting Register
        volatile uint32_t ADCMPBSR;  ///< Offset: 0xAC - A/D Compare Function Window B Status Register
        volatile uint32_t ADSSTRL;  ///< Offset: 0xDD - A/D Sampling State Register L
        volatile uint32_t ADSSTRT;  ///< Offset: 0xDE - A/D Sampling State Register T
        volatile uint32_t ADSSTRO;  ///< Offset: 0xDF - A/D Sampling State Register O
        volatile uint32_t ADSSTR0;  ///< Offset: 0xE5 - A/D Sampling State Register %s (Corresponding Channel is AN00) (renamed from ADSSTR0)
        volatile uint32_t ADPGACR;  ///< Offset: 0x1A0 - A/D Programmable Gain Amplifier Control Register
        volatile uint32_t ADPGAGS0;  ///< Offset: 0x1A2 - A/D Programmable Gain Amplifier Gain Setting Register 0
        volatile uint32_t ADPGADCR0;  ///< Offset: 0x1B0 - A/D Programmable Gain Amplifier Differential Input...
    };

    /// Peripheral instances
    inline Registers* ADC120 = reinterpret_cast<Registers*>(ADC120_BASE);
    inline Registers* ADC121 = reinterpret_cast<Registers*>(ADC121_BASE);

    // Bit definitions
    /// ADCSR Register bits
    namespace adcsr_bits {
        constexpr uint32_t ADST = (1U << 15);  ///< A/D Conversion Start
        constexpr uint32_t ADCS = (2 << 13);  ///< Scan Mode Select
        constexpr uint32_t Reserved = (1U << 5);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t TRGE = (1U << 9);  ///< Trigger Start Enable
        constexpr uint32_t EXTRG = (1U << 8);  ///< Trigger Select
        constexpr uint32_t DBLE = (1U << 7);  ///< Double Trigger Mode Select
        constexpr uint32_t GBADIE = (1U << 6);  ///< Group B Scan End Interrupt Enable
        constexpr uint32_t DBLANS = (5 << 0);  ///< Double Trigger Channel Select These bits select one analog input channel for double triggered operation. The setting is only effective while double trigger mode is selected.
    }

    /// ADANSA0 Register bits
    namespace adansa0_bits {
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t ANSA07 = (1U << 7);  ///< AN007 Select
        constexpr uint32_t ANSA06 = (1U << 6);  ///< AN006 Select
        constexpr uint32_t ANSA05 = (1U << 5);  ///< AN005 Select
        constexpr uint32_t ANSA03 = (1U << 3);  ///< AN003 Select
        constexpr uint32_t ANSA02 = (1U << 2);  ///< AN002 Select
        constexpr uint32_t ANSA01 = (1U << 1);  ///< AN001 Select
        constexpr uint32_t ANSA00 = (1U << 0);  ///< AN000 Select
    }

    /// ADANSA1 Register bits
    namespace adansa1_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t ANSA20 = (1U << 4);  ///< AN020 Select
        constexpr uint32_t ANSA18 = (1U << 2);  ///< AN018 Select
        constexpr uint32_t ANSA17 = (1U << 1);  ///< AN017 Select
        constexpr uint32_t ANSA16 = (1U << 0);  ///< AN016 Select
    }

    /// ADADS0 Register bits
    namespace adads0_bits {
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t ADS07 = (1U << 7);  ///< A/D-Converted Value Addition/Average Channel AN007 Select
        constexpr uint32_t ADS06 = (1U << 6);  ///< A/D-Converted Value Addition/Average Channel AN006 Select
        constexpr uint32_t ADS05 = (1U << 5);  ///< A/D-Converted Value Addition/Average Channel AN005 Select
        constexpr uint32_t ADS03 = (1U << 3);  ///< A/D-Converted Value Addition/Average Channel AN003 Select
        constexpr uint32_t ADS02 = (1U << 2);  ///< A/D-Converted Value Addition/Average Channel AN002 Select
        constexpr uint32_t ADS01 = (1U << 1);  ///< A/D-Converted Value Addition/Average Channel AN001 Select
        constexpr uint32_t ADS00 = (1U << 0);  ///< A/D-Converted Value Addition/Average Channel AN000 Select
    }

    /// ADADS1 Register bits
    namespace adads1_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t ADS20 = (1U << 4);  ///< A/D-Converted Value Addition/Average Channel AN020 Select
        constexpr uint32_t ADS18 = (1U << 2);  ///< A/D-Converted Value Addition/Average Channel AN018 Select
        constexpr uint32_t ADS17 = (1U << 1);  ///< A/D-Converted Value Addition/Average Channel AN017 Select
        constexpr uint32_t ADS16 = (1U << 0);  ///< A/D-Converted Value Addition/Average Channel AN016 Select
    }

    /// ADADC Register bits
    namespace adadc_bits {
        constexpr uint32_t AVEE = (1U << 7);  ///< Average mode enable bit. Note: The AVEE bit converts twice, and only when converting it four times, is effective. Please do not set (ADADC.AVEE=1) to conversion (ADADC.ADC 2:0=010b) three times when you select the average mode.
        constexpr uint32_t Reserved = (4 << 3);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t ADC = (3 << 0);  ///< Addition frequency selection bit. NOTE: AVEE bit is valid at the only setting of ADC[2:0] bits = 001b or 011b. When average mode is selected by setting the ADADC.AVEE bit to 1, do not set the addition count to three times (ADADC.ADC[2:0] = 010b)
    }

    /// ADCER Register bits
    namespace adcer_bits {
        constexpr uint32_t ADRFMT = (1U << 15);  ///< A/D Data Register Format Select
        constexpr uint32_t Reserved = (1U << 0);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t DIAGM = (1U << 11);  ///< Self-Diagnosis Enable
        constexpr uint32_t DIAGLD = (1U << 10);  ///< Self-Diagnosis Mode Select
        constexpr uint32_t DIAGVAL = (2 << 8);  ///< Self-Diagnosis Conversion Voltage Select
        constexpr uint32_t ACE = (1U << 5);  ///< A/D Data Register Automatic Clearing Enable
        constexpr uint32_t ADPRC = (2 << 1);  ///< A/D Conversion Accuracy Specify
    }

    /// ADSTRGR Register bits
    namespace adstrgr_bits {
        constexpr uint32_t Reserved = (2 << 6);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t TRSA = (6 << 8);  ///< A/D Conversion Start Trigger Select Select the A/D conversion start trigger in single scan mode and continuous mode. In group scan mode, the A/D conversion start trigger for group A is selected.
        constexpr uint32_t TRSB = (6 << 0);  ///< A/D Conversion Start Trigger Select for Group B Select the A/D conversion start trigger for group B in group scan mode.
    }

    /// ADEXICR Register bits
    namespace adexicr_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t OCSB = (1U << 11);  ///< Internal Reference Voltage A/D Conversion Select for Group B
        constexpr uint32_t TSSB = (1U << 10);  ///< Temperature Sensor Output A/D Conversion Select for Group B
        constexpr uint32_t OCSA = (1U << 9);  ///< Internal Reference Voltage A/D Conversion Select
        constexpr uint32_t TSSA = (1U << 8);  ///< Temperature Sensor Output A/D Conversion Select
        constexpr uint32_t OCSAD = (1U << 1);  ///< Internal Reference Voltage A/D converted Value Addition/Average Mode Select
        constexpr uint32_t TSSAD = (1U << 0);  ///< Temperature Sensor Output A/D converted Value Addition/Average Mode Select
    }

    /// ADANSB0 Register bits
    namespace adansb0_bits {
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t ANSB07 = (1U << 7);  ///< AN007 Select
        constexpr uint32_t ANSB06 = (1U << 6);  ///< AN006 Select
        constexpr uint32_t ANSB05 = (1U << 5);  ///< AN005 Select
        constexpr uint32_t ANSB03 = (1U << 3);  ///< AN003 Select
        constexpr uint32_t ANSB02 = (1U << 2);  ///< AN002 Select
        constexpr uint32_t ANSB01 = (1U << 1);  ///< AN001 Select
        constexpr uint32_t ANSB00 = (1U << 0);  ///< AN000 Select
    }

    /// ADANSB1 Register bits
    namespace adansb1_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t ANSB20 = (1U << 4);  ///< AN020 Select
        constexpr uint32_t ANSB18 = (1U << 2);  ///< AN018 Select
        constexpr uint32_t ANSB17 = (1U << 1);  ///< AN017 Select
        constexpr uint32_t ANSB16 = (1U << 0);  ///< AN016 Select
    }

    /// ADDBLDR Register bits
    namespace addbldr_bits {
        constexpr uint32_t ADDBLDR = (16 << 0);  ///< This is a 16-bit read-only register for storing the result of A/D conversion in response to the second trigger in double trigger mode.
    }

    /// ADTSDR Register bits
    namespace adtsdr_bits {
        constexpr uint32_t ADTSDR = (16 << 0);  ///< This is a 16-bit read-only register for storing the A/D conversion result of temperature sensor output.
    }

    /// ADOCDR Register bits
    namespace adocdr_bits {
        constexpr uint32_t ADOCDR = (16 << 0);  ///< This is a 16-bit read-only register for storing the A/D result of internal reference voltage.
    }

    /// ADRD Register bits
    namespace adrd_bits {
        constexpr uint32_t DIAGST = (2 << 14);  ///< Self-Diagnosis Status
        constexpr uint32_t Reserved = (2 << 12);  ///< These bits are read as 00.
        constexpr uint32_t AD = (12 << 0);  ///< A/D-converted value (right-justified) NOTE: Unused bits in the AD bit field are fixed "0"
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (16 << 0);  ///< The ADDR register is a 16-bit read-only registers for storing the result of A/D conversion.
    }

    /// ADSHCR Register bits
    namespace adshcr_bits {
        constexpr uint32_t Reserved = (5 << 11);  ///< These bits are read as 00000. The write value should be 00000.
        constexpr uint32_t SHANS2 = (1U << 10);  ///< AN002 sample-and-hold circuit Select
        constexpr uint32_t SHANS1 = (1U << 9);  ///< AN001 sample-and-hold circuit Select
        constexpr uint32_t SHANS0 = (1U << 8);  ///< AN000 sample-and-hold circuit Select
        constexpr uint32_t SSTSH = (8 << 0);  ///< Channel-Dedicated Sample-and-Hold Circuit Sampling Time Setting Set the sampling time (4 to 255 states)
    }

    /// ADDISCR Register bits
    namespace addiscr_bits {
        constexpr uint32_t Reserved = (3 << 5);  ///< These bits are read as 000. The write value should be 000.
        constexpr uint32_t PCHG = (1U << 4);  ///< Selection of Precharge or Discharge
        constexpr uint32_t ADNDIS = (4 << 0);  ///< The charging time
    }

    /// ADSHMSR Register bits
    namespace adshmsr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t SHMD = (1U << 0);  ///< Channel-Dedicated Sample-and-Hold Circuit Operation Mode Select
    }

    /// ADGSPCR Register bits
    namespace adgspcr_bits {
        constexpr uint32_t GBRP = (1U << 15);  ///< Group B Single Scan Continuous Start (Enabled only when PGS = 1. Reserved when PGS = 0.) Note: When the GBRP bit has been set to 1, single scan is performed continuously for group B regardless of the setting of the GBRSCN bit.
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t GBRSCN = (1U << 1);  ///< Group B Restart Setting (Enabled only when PGS = 1. Reserved when PGS = 0.)
        constexpr uint32_t PGS = (1U << 0);  ///< Group A priority control setting bit. Note: When the PGS bit is to be set to 1, the ADCSR.ADCS[1:0] bits must be set to 01b (group scan mode). If the bits are set to any other values, proper operation is not guaranteed.
    }

    /// ADDBLDRA Register bits
    namespace addbldra_bits {
        constexpr uint32_t ADDBLDRA = (16 << 0);  ///< This register is a 16-bit read-only registers for storing the result of A/D conversion in response to the respective triggers during extended operation in double trigger mode.
    }

    /// ADDBLDRB Register bits
    namespace addbldrb_bits {
        constexpr uint32_t ADDBLDRB = (16 << 0);  ///< This register is a 16-bit read-only registers for storing the result of A/D conversion in response to the respective triggers during extended operation in double trigger mode.
    }

    /// ADWINMON Register bits
    namespace adwinmon_bits {
        constexpr uint32_t Reserved = (3 << 1);  ///< These bits are read as 000.
        constexpr uint32_t MONCMPB = (1U << 5);  ///< Comparison Result Monitor B
        constexpr uint32_t MONCMPA = (1U << 4);  ///< Comparison Result Monitor A
        constexpr uint32_t MONCOMB = (1U << 0);  ///< Combination result monitor This bit indicates the combination result. This bit is valid when both window A operation and window B operation are enabled.
    }

    /// ADCMPCR Register bits
    namespace adcmpcr_bits {
        constexpr uint32_t CMPAIE = (1U << 15);  ///< Compare A Interrupt Enable
        constexpr uint32_t WCMPE = (1U << 14);  ///< Window Function Setting
        constexpr uint32_t CMPBIE = (1U << 13);  ///< Compare B Interrupt Enable
        constexpr uint32_t Reserved = (7 << 2);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPAE = (1U << 11);  ///< Compare Window A Operation Enable
        constexpr uint32_t CMPBE = (1U << 9);  ///< Compare Window B Operation Enable
        constexpr uint32_t CMPAB = (2 << 0);  ///< Window A/B Composite Conditions Setting NOTE: These bits are valid when both window A and window B are enabled (CMPAE = 1 and CMPBE = 1).
    }

    /// ADCMPANSER Register bits
    namespace adcmpanser_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t CMPOCA = (1U << 1);  ///< Internal reference voltage Compare selection bit.
        constexpr uint32_t CMPTSA = (1U << 0);  ///< Temperature sensor output Compare selection bit.
    }

    /// ADCMPLER Register bits
    namespace adcmpler_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t CMPLOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage Comparison Condition Select
        constexpr uint32_t CMPLTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Comparison Condition Select
    }

    /// ADCMPANSR0 Register bits
    namespace adcmpansr0_bits {
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CMPCHA07 = (1U << 7);  ///< Compare Window A Channel AN007 Select
        constexpr uint32_t CMPCHA06 = (1U << 6);  ///< Compare Window A Channel AN006 Select
        constexpr uint32_t CMPCHA05 = (1U << 5);  ///< Compare Window A Channel AN005 Select
        constexpr uint32_t CMPCHA03 = (1U << 3);  ///< Compare Window A Channel AN003 Select
        constexpr uint32_t CMPCHA02 = (1U << 2);  ///< Compare Window A Channel AN002 Select
        constexpr uint32_t CMPCHA01 = (1U << 1);  ///< Compare Window A Channel AN001 Select
        constexpr uint32_t CMPCHA00 = (1U << 0);  ///< Compare Window A Channel AN000 Select
    }

    /// ADCMPANSR1 Register bits
    namespace adcmpansr1_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CMPCHA20 = (1U << 4);  ///< AN020 Select
        constexpr uint32_t CMPCHA18 = (1U << 2);  ///< AN018 Select
        constexpr uint32_t CMPCHA17 = (1U << 1);  ///< AN017 Select
        constexpr uint32_t CMPCHA16 = (1U << 0);  ///< AN016 Select
    }

    /// ADCMPLR0 Register bits
    namespace adcmplr0_bits {
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CMPLCHA07 = (1U << 7);  ///< Comparison condition of AN007
        constexpr uint32_t CMPLCHA06 = (1U << 6);  ///< Comparison condition of AN006
        constexpr uint32_t CMPLCHA05 = (1U << 5);  ///< Comparison condition of AN005
        constexpr uint32_t CMPLCHA03 = (1U << 3);  ///< Comparison condition of AN003
        constexpr uint32_t CMPLCHA02 = (1U << 2);  ///< Comparison condition of AN002
        constexpr uint32_t CMPLCHA01 = (1U << 1);  ///< Comparison condition of AN001
        constexpr uint32_t CMPLCHA00 = (1U << 0);  ///< Comparison condition of AN000
    }

    /// ADCMPLR1 Register bits
    namespace adcmplr1_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CMPLCHA20 = (1U << 4);  ///< Comparison condition of AN020
        constexpr uint32_t CMPLCHA18 = (1U << 2);  ///< Comparison condition of AN018
        constexpr uint32_t CMPLCHA17 = (1U << 1);  ///< Comparison condition of AN017
        constexpr uint32_t CMPLCHA16 = (1U << 0);  ///< Comparison condition of AN016
    }

    /// ADCMPDR0 Register bits
    namespace adcmpdr0_bits {
        constexpr uint32_t ADCMPDR0 = (16 << 0);  ///< The ADCMPDR0 register sets the reference data when the compare window A function is used. ADCMPDR0 sets the lower-side level of window A.
    }

    /// ADCMPDR1 Register bits
    namespace adcmpdr1_bits {
        constexpr uint32_t ADCMPDR1 = (16 << 0);  ///< The ADCMPDR1 register sets the reference data when the compare window A function is used. ADCMPDR1 sets the upper-side level of window A.
    }

    /// ADCMPSR0 Register bits
    namespace adcmpsr0_bits {
        constexpr uint32_t Reserved = (1U << 4);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CMPSTCHA07 = (1U << 7);  ///< Compare window A flag of AN007
        constexpr uint32_t CMPSTCHA06 = (1U << 6);  ///< Compare window A flag of AN006
        constexpr uint32_t CMPSTCHA05 = (1U << 5);  ///< Compare window A flag of AN005
        constexpr uint32_t CMPSTCHA03 = (1U << 3);  ///< Compare window A flag of AN003
        constexpr uint32_t CMPSTCHA02 = (1U << 2);  ///< Compare window A flag of AN002
        constexpr uint32_t CMPSTCHA01 = (1U << 1);  ///< Compare window A flag of AN001
        constexpr uint32_t CMPSTCHA00 = (1U << 0);  ///< Compare window A flag of AN000
    }

    /// ADCMPSR1 Register bits
    namespace adcmpsr1_bits {
        constexpr uint32_t Reserved = (1U << 3);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CMPSTCHA20 = (1U << 4);  ///< Compare window A flag of AN020
        constexpr uint32_t CMPSTCHA18 = (1U << 2);  ///< Compare window A flag of AN018
        constexpr uint32_t CMPSTCHA17 = (1U << 1);  ///< Compare window A flag of AN017
        constexpr uint32_t CMPSTCHA16 = (1U << 0);  ///< Compare window A flag of AN016
    }

    /// ADCMPSER Register bits
    namespace adcmpser_bits {
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t CMPSTOCA = (1U << 1);  ///< Compare Window A Internal Reference Voltage Compare Flag When window A operation is enabled (ADCMPCR.CMPAE = 1b), this bit indicates the temperature sensor output comparison result. When window A operation is disabled (ADCMPCR.CMPAE = 0b), comparison conditions for CMPSTTSA are not met any time.
        constexpr uint32_t CMPSTTSA = (1U << 0);  ///< Compare Window A Temperature Sensor Output Compare Flag When window A operation is enabled (ADCMPCR.CMPAE = 1b), this bit indicates the temperature sensor output comparison result. When window A operation is disabled (ADCMPCR.CMPAE = 0b), comparison conditions for CMPSTTSA are not met any time.
    }

    /// ADCMPBNSR Register bits
    namespace adcmpbnsr_bits {
        constexpr uint32_t CMPLB = (1U << 7);  ///< Compare window B Compare condition setting bit.
        constexpr uint32_t Reserved = (1U << 6);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t CMPCHB = (6 << 0);  ///< Compare window B channel selection bit. The channel that compares it on the condition of compare window B is selected.
    }

    /// ADWINLLB Register bits
    namespace adwinllb_bits {
        constexpr uint32_t ADWINLLB = (16 << 0);  ///< This register is used to compare A window function is used to set the lower level of the window B.
    }

    /// ADWINULB Register bits
    namespace adwinulb_bits {
        constexpr uint32_t ADWINULB = (16 << 0);  ///< This register is used to compare A window function is used to set the higher level of the window B.
    }

    /// ADCMPBSR Register bits
    namespace adcmpbsr_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t CMPSTB = (1U << 0);  ///< Compare window B flag. It is a status flag that shows the comparative result of CH (AN000-AN003, AN005-AN007, AN016-AN018, AN020, temperature sensor, and internal reference voltage) made the object of window B relation condition.
    }

    /// ADSSTRL Register bits
    namespace adsstrl_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting (AN016-AN018 and AN020)
    }

    /// ADSSTRT Register bits
    namespace adsstrt_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting (temperature sensor output)
    }

    /// ADSSTRO Register bits
    namespace adsstro_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling Time Setting (Internal reference voltage)
    }

    /// ADSSTR0 Register bits
    namespace adsstr0_bits {
        constexpr uint32_t SST = (8 << 0);  ///< Sampling time setting
    }

    /// ADPGACR Register bits
    namespace adpgacr_bits {
        constexpr uint32_t Reserved = (1U << 12);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t P002GEN = (1U << 11);  ///< PGA P002 gain setting and enable bit
        constexpr uint32_t P002ENAMP = (1U << 10);  ///< Amplifier enable bit for PGA P002
        constexpr uint32_t P002SEL1 = (1U << 9);  ///< The amplifier passing is enable for PGA P002
        constexpr uint32_t P002SEL0 = (1U << 8);  ///< A through amplifier is enable for PGA P002
        constexpr uint32_t P001GEN = (1U << 7);  ///< PGA P001 gain setting and enable bit
        constexpr uint32_t P001ENAMP = (1U << 6);  ///< Amplifier enable bit for PGA P001
        constexpr uint32_t P001SEL1 = (1U << 5);  ///< The amplifier passing is enable for PGA P001
        constexpr uint32_t P001SEL0 = (1U << 4);  ///< A through amplifier is enable for PGA P001
        constexpr uint32_t P000GEN = (1U << 3);  ///< PGA P000 gain setting and enable bit
        constexpr uint32_t P000ENAMP = (1U << 2);  ///< Amplifier enable bit for PGA P000
        constexpr uint32_t P000SEL1 = (1U << 1);  ///< The amplifier passing is enable for PGA P000
        constexpr uint32_t P000SEL0 = (1U << 0);  ///< A through amplifier is enable for PGA P000
    }

    /// ADPGAGS0 Register bits
    namespace adpgags0_bits {
        constexpr uint32_t Reserved = (4 << 12);  ///< These bits are read as 0000. The write value should be 0000.
        constexpr uint32_t P002GAIN = (4 << 8);  ///< PGA P002 gain setting bit. The gain magnification of (ADPGSDCR0.P002GEN=0b) when the shingle end is input and each PGA P002 is set. When the differential motion is input, (ADPGSDCR0.P002GEN=1b) sets the gain magnification when the differential motion is input by the combination with ADPGSDCR0.P002DG 1:0.
        constexpr uint32_t P001GAIN = (4 << 4);  ///< PGA P001 gain setting bit. The gain magnification of (ADPGSDCR0.P001GEN=0b) when the shingle end is input and each PGA P001 is set. When the differential motion is input, (ADPGSDCR0.P001GEN=1b) sets the gain magnification when the differential motion is input by the combination with ADPGSDCR0.P001DG 1:0.
        constexpr uint32_t P000GAIN = (4 << 0);  ///< PGA P000 gain setting bit. The gain magnification of (ADPGSDCR0.P000GEN=0b) when the shingle end is input and each PGA P000 is set. When the differential motion is input, (ADPGSDCR0.P000GEN=1b) sets the gain magnification when the differential motion is input by the combination with ADPGSDCR0.P000DG 1:0.
    }

    /// ADPGADCR0 Register bits
    namespace adpgadcr0_bits {
        constexpr uint32_t Reserved = (1U << 2);  ///< This bit is read as 0. The write value should be 0.
        constexpr uint32_t P003DG = (2 << 12);  ///< P003 Differential Input Gain Setting NOTE: When these bits are used, set {P003DEN, P003GEN} to 11b.
        constexpr uint32_t P002DEN = (1U << 11);  ///< P002 Differential Input Enable
        constexpr uint32_t P002DG = (2 << 8);  ///< P002 Differential Input Gain Setting NOTE: When these bits are used, set {P002DEN, P002GEN} to 11b.
        constexpr uint32_t P001DEN = (1U << 7);  ///< P001 Differential Input Enable
        constexpr uint32_t P001DG = (2 << 4);  ///< P001 Differential Input Gain Setting NOTE: When these bits are used, set {P001DEN, P001GEN} to 11b.
        constexpr uint32_t P000DEN = (1U << 3);  ///< P000 Differential Input Enable
        constexpr uint32_t P000DG = (2 << 0);  ///< P000 Differential Input Gain Setting NOTE: When these bits are used, set {P000DEN, P000GEN} to 11b.
    }

}

// ============================================================================
// MMPU Peripheral
// ============================================================================

namespace mmpu {
    /// Base addresses
    constexpr uint32_t MMPU_BASE = 0x40000000;

    /// MMPU Register structure
    struct Registers {
        volatile uint32_t MMPUCTLA;  ///< Offset: 0x00 - Bus Master MPU Control Register
        volatile uint32_t MMPUPTA;  ///< Offset: 0x102 - Group A Protection of Register
        volatile uint32_t MMPUACA;  ///< Offset: 0x200 - Group A Region %s Access Control Register (renamed from MMPUACA)
        volatile uint32_t MMPUSA;  ///< Offset: 0x204 - Group A Region %s Start Address Register (renamed from MMPUSA)
        volatile uint32_t MMPUEA;  ///< Offset: 0x208 - Group A Region %s End Address Register (renamed from MMPUEA)
    };

    /// Peripheral instances
    inline Registers* MMPU = reinterpret_cast<Registers*>(MMPU_BASE);

    // Bit definitions
    /// MMPUCTLA Register bits
    namespace mmpuctla_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t OAD = (1U << 1);  ///< Operation After Detection
        constexpr uint32_t ENABLE = (1U << 0);  ///< Master Group Enable
    }

    /// MMPUPTA Register bits
    namespace mmpupta_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register (MMPUSAn, MMPUEAn, MMPUACAn and MMPUCTLA )
    }

    /// MMPUACA Register bits
    namespace mmpuaca_bits {
        constexpr uint32_t Reserved = (13 << 3);  ///< These bits are read as 0000000000000. The write value should be 0000000000000.
        constexpr uint32_t WP = (1U << 2);  ///< Write protection
        constexpr uint32_t RP = (1U << 1);  ///< Read protection
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable
    }

    /// MMPUSA Register bits
    namespace mmpusa_bits {
        constexpr uint32_t MMPUSA = (32 << 0);  ///< Region Stat Address : Address where the region starts, for use in region determination. NOTE: The low-order 2 bits are fixed to 0.
    }

    /// MMPUEA Register bits
    namespace mmpuea_bits {
        constexpr uint32_t MMPUEA = (32 << 0);  ///< Region End Address : Address where the region end, for use in region determination. NOTE: The low-order 2 bits are fixed to 1.
    }

}

// ============================================================================
// SMPU Peripheral
// ============================================================================

namespace smpu {
    /// Base addresses
    constexpr uint32_t SMPU_BASE = 0x40000C00;

    /// SMPU Register structure
    struct Registers {
        volatile uint32_t SMPUCTL;  ///< Offset: 0x00 - Slave MPU Control Register
        volatile uint32_t SMPUMBIU;  ///< Offset: 0x10 - Access Control Register for MBIU
        volatile uint32_t SMPUFBIU;  ///< Offset: 0x14 - Access Control Register for FBIU
        volatile uint32_t SMPUSRAM;  ///< Offset: 0x18 - Access Control Register for SRAM%s (renamed from SMPUSRAM)
        volatile uint32_t SMPUPBIU;  ///< Offset: 0x20 - Access Control Register for P%sBIU (renamed from SMPUPBIU)
        volatile uint32_t SMPUEXBIU;  ///< Offset: 0x30 - Access Control Register for EXBIU
        volatile uint32_t SMPUEXBIU2;  ///< Offset: 0x34 - Access Control Register for EXBIU2
    };

    /// Peripheral instances
    inline Registers* SMPU = reinterpret_cast<Registers*>(SMPU_BASE);

    // Bit definitions
    /// SMPUCTL Register bits
    namespace smpuctl_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code This bit is used to enable or disable writing of the PROTECT and OAD bit.
        constexpr uint32_t Reserved = (6 << 2);  ///< These bits are read as 000000. The write value should be 000000.
        constexpr uint32_t PROTECT = (1U << 1);  ///< Protection of register
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after detection
    }

    /// SMPUMBIU Register bits
    namespace smpumbiu_bits {
        constexpr uint32_t WPSRAMHS = (1U << 15);  ///< SRAMHS Write Protection
        constexpr uint32_t RPSRAMHS = (1U << 14);  ///< SRAMHS Read Protection
        constexpr uint32_t WPFLI = (1U << 13);  ///< Code Flash Memory Write Protection (Note: This bit is read as 1. The write value should be 1.)
        constexpr uint32_t RPFLI = (1U << 12);  ///< Code Flash Memory Read Protection
        constexpr uint32_t Reserved = (2 << 0);  ///< These bits are read as 00. The write value should be 00.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
    }

    /// SMPUFBIU Register bits
    namespace smpufbiu_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUSRAM Register bits
    namespace smpusram_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUPBIU Register bits
    namespace smpupbiu_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t WPGRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RPGRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WPCPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RPCPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUEXBIU Register bits
    namespace smpuexbiu_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t WP_GRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RP_GRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WP_CPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RP_CPU = (1U << 0);  ///< CPU Read protection
    }

    /// SMPUEXBIU2 Register bits
    namespace smpuexbiu2_bits {
        constexpr uint32_t Reserved = (12 << 4);  ///< These bits are read as 000000000000. The write value should be 000000000000.
        constexpr uint32_t WP_GRPA = (1U << 3);  ///< Master Group A Write protection
        constexpr uint32_t RP_GRPA = (1U << 2);  ///< Master Group A Read protection
        constexpr uint32_t WP_CPU = (1U << 1);  ///< CPU Write protection
        constexpr uint32_t RP_CPU = (1U << 0);  ///< CPU Read protection
    }

}

// ============================================================================
// SPMON Peripheral
// ============================================================================

namespace spmon {
    /// Base addresses
    constexpr uint32_t SPMON_BASE = 0x40000D00;

    /// SPMON Register structure
    struct Registers {
        volatile uint32_t MSPMPUOAD;  ///< Offset: 0x00 - Stack Pointer Monitor Operation After Detection Register
        volatile uint32_t MSPMPUCTL;  ///< Offset: 0x04 - Stack Pointer Monitor Access Control Register
        volatile uint32_t MSPMPUPT;  ///< Offset: 0x06 - Stack Pointer Monitor Protection Register
        volatile uint32_t MSPMPUSA;  ///< Offset: 0x08 - Main Stack Pointer Monitor Start Address Register
        volatile uint32_t MSPMPUEA;  ///< Offset: 0x0C - Main Stack Pointer Monitor End Address Register
        volatile uint32_t PSPMPUOAD;  ///< Offset: 0x10 - Stack Pointer Monitor Operation After Detection Register
        volatile uint32_t PSPMPUCTL;  ///< Offset: 0x14 - Stack Pointer Monitor Access Control Register
        volatile uint32_t PSPMPUPT;  ///< Offset: 0x16 - Stack Pointer Monitor Protection Register
        volatile uint32_t PSPMPUSA;  ///< Offset: 0x18 - Process Stack Pointer Monitor Start Address Register
        volatile uint32_t PSPMPUEA;  ///< Offset: 0x1C - Process Stack Pointer Monitor End Address Register
    };

    /// Peripheral instances
    inline Registers* SPMON = reinterpret_cast<Registers*>(SPMON_BASE);

    // Bit definitions
    /// MSPMPUOAD Register bits
    namespace mspmpuoad_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after detection
    }

    /// MSPMPUCTL Register bits
    namespace mspmpuctl_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ERROR = (1U << 8);  ///< Stack Pointer Monitor Error Flag
        constexpr uint32_t ENABLE = (1U << 0);  ///< Stack Pointer Monitor Enable
    }

    /// MSPMPUPT Register bits
    namespace mspmpupt_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code Write data is not saved.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register
    }

    /// MSPMPUSA Register bits
    namespace mspmpusa_bits {
        constexpr uint32_t MSPMPUSA = (32 << 0);  ///< Region Start Address : Address where the region starts, for use in region determination. NOTE: Range: 0x1FF00000-0x200FFFFC The low-order 2 bits are fixed to 0.
    }

    /// MSPMPUEA Register bits
    namespace mspmpuea_bits {
        constexpr uint32_t MSPMPUEA = (32 << 0);  ///< Region End Address : Address where the region ends, for use in region determination. NOTE: Range: 0x1FF00003-0x200FFFFF The low-order 2 bits are fixed to 1.
    }

    /// PSPMPUOAD Register bits
    namespace pspmpuoad_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Write Keyword The data written to these bits are not stored.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t OAD = (1U << 0);  ///< Operation after detection
    }

    /// PSPMPUCTL Register bits
    namespace pspmpuctl_bits {
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t ERROR = (1U << 8);  ///< Stack Pointer Monitor Error Flag
        constexpr uint32_t ENABLE = (1U << 0);  ///< Stack Pointer Monitor Enable
    }

    /// PSPMPUPT Register bits
    namespace pspmpupt_bits {
        constexpr uint32_t KEY = (8 << 8);  ///< Key Code Write data is not saved.
        constexpr uint32_t Reserved = (7 << 1);  ///< These bits are read as 0000000. The write value should be 0000000.
        constexpr uint32_t PROTECT = (1U << 0);  ///< Protection of register
    }

    /// PSPMPUSA Register bits
    namespace pspmpusa_bits {
        constexpr uint32_t PSPMPUSA = (32 << 0);  ///< Region Start Address : Address where the region starts, for use in region determination. NOTE: Range: 0x1FF00000-0x200FFFFC The low-order 2 bits are fixed to 0.
    }

    /// PSPMPUEA Register bits
    namespace pspmpuea_bits {
        constexpr uint32_t PSPMPUEA = (32 << 0);  ///< Region End Address : Address where the region ends, for use in region determination. NOTE: Range: 0x1FF00003-0x200FFFFF The low-order 2 bits are fixed to 1.
    }

}

// ============================================================================
// TSD Peripheral
// ============================================================================

namespace tsd {
    /// Base addresses
    constexpr uint32_t TSD_BASE = 0x407FB17C;

    /// TSD Register structure
    struct Registers {
        volatile uint32_t TSCDR;  ///< Offset: 0x00 - Temperature Sensor Calibration Data Register
    };

    /// Peripheral instances
    inline Registers* TSD = reinterpret_cast<Registers*>(TSD_BASE);

    // Bit definitions
    /// TSCDR Register bits
    namespace tscdr_bits {
        constexpr uint32_t Reserved = (20 << 12);  ///< These bits are read as 00000000000000000000.
        constexpr uint32_t TSCD = (12 << 0);  ///< Temperature sensor calibration data is a digital value obtained using the 12-bit A/D converter unit 0 to convert the voltage output by the temperature sensor under the condition Ta = Tj = 127°C and AVCC0 = 3.3 V.
    }

}


} // namespace alloy::generated::r7fa6t1ad

#endif // ALLOY_GENERATED_R7FA6T1AD_PERIPHERALS_HPP