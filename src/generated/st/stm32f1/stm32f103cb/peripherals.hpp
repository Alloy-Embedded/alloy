/// Auto-generated code for STM32F103CB
/// Generated by Alloy Code Generator
/// Source: stm32f1xx.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 22:46:19
#ifndef ALLOY_GENERATED_STM32F103CB_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32F103CB_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32f103cb {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 128 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x40010800;
    constexpr uint32_t GPIOB_BASE = 0x40010C00;
    constexpr uint32_t GPIOC_BASE = 0x40011000;
    constexpr uint32_t GPIOD_BASE = 0x40011400;
    constexpr uint32_t GPIOE_BASE = 0x40011800;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t CRL;  ///< Offset: 0x00 - Port configuration register low
        volatile uint32_t CRH;  ///< Offset: 0x04 - Port configuration register high
        volatile uint32_t IDR;  ///< Offset: 0x08 - Port input data register
        volatile uint32_t ODR;  ///< Offset: 0x0C - Port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x10 - Port bit set/reset register
        volatile uint32_t BRR;  ///< Offset: 0x14 - Port bit reset register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x40021000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Clock control register
        volatile uint32_t CFGR;  ///< Offset: 0x04 - Clock configuration register
        volatile uint32_t CIR;  ///< Offset: 0x08 - Clock interrupt register
        volatile uint32_t APB2RSTR;  ///< Offset: 0x0C - APB2 peripheral reset register
        volatile uint32_t APB1RSTR;  ///< Offset: 0x10 - APB1 peripheral reset register
        volatile uint32_t AHBENR;  ///< Offset: 0x14 - AHB peripheral clock enable register
        volatile uint32_t APB2ENR;  ///< Offset: 0x18 - APB2 peripheral clock enable register
        volatile uint32_t APB1ENR;  ///< Offset: 0x1C - APB1 peripheral clock enable register
        volatile uint32_t BDCR;  ///< Offset: 0x20 - Backup domain control register
        volatile uint32_t CSR;  ///< Offset: 0x24 - Control/status register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t USART2_BASE = 0x40004400;
    constexpr uint32_t USART3_BASE = 0x40004800;

    /// USART Register structure
    struct Registers {
        volatile uint32_t SR;  ///< Offset: 0x00 - Status register
        volatile uint32_t DR;  ///< Offset: 0x04 - Data register
        volatile uint32_t BRR;  ///< Offset: 0x08 - Baud rate register
        volatile uint32_t CR1;  ///< Offset: 0x0C - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x10 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x14 - Control register 3
    };

    /// Peripheral instances
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);

    // Bit definitions
    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Parity error
        constexpr uint32_t FE = (1U << 1);  ///< Framing error
        constexpr uint32_t NE = (1U << 2);  ///< Noise error
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE line detected
        constexpr uint32_t RXNE = (1U << 5);  ///< Read data register not empty
        constexpr uint32_t TC = (1U << 6);  ///< Transmission complete
        constexpr uint32_t TXE = (1U << 7);  ///< Transmit data register empty
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RXNEIE = (1U << 5);  ///< RXNE interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< TC interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< TXE interrupt enable
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t M = (1U << 12);  ///< Word length
        constexpr uint32_t UE = (1U << 13);  ///< USART enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC1_BASE = 0x40012400;
    constexpr uint32_t ADC2_BASE = 0x40012800;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SR;  ///< Offset: 0x00 - Status register
        volatile uint32_t CR1;  ///< Offset: 0x04 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x08 - Control register 2
        volatile uint32_t SMPR1;  ///< Offset: 0x0C - Sample time register 1
        volatile uint32_t SMPR2;  ///< Offset: 0x10 - Sample time register 2
        volatile uint32_t JOFR1;  ///< Offset: 0x14 - Injected channel data offset register 1
        volatile uint32_t JOFR2;  ///< Offset: 0x18 - Injected channel data offset register 2
        volatile uint32_t JOFR3;  ///< Offset: 0x1C - Injected channel data offset register 3
        volatile uint32_t JOFR4;  ///< Offset: 0x20 - Injected channel data offset register 4
        volatile uint32_t HTR;  ///< Offset: 0x24 - Watchdog high threshold register
        volatile uint32_t LTR;  ///< Offset: 0x28 - Watchdog low threshold register
        volatile uint32_t SQR1;  ///< Offset: 0x2C - Regular sequence register 1
        volatile uint32_t SQR2;  ///< Offset: 0x30 - Regular sequence register 2
        volatile uint32_t SQR3;  ///< Offset: 0x34 - Regular sequence register 3
        volatile uint32_t JSQR;  ///< Offset: 0x38 - Injected sequence register
        volatile uint32_t JDR1;  ///< Offset: 0x3C - Injected data register 1
        volatile uint32_t JDR2;  ///< Offset: 0x40 - Injected data register 2
        volatile uint32_t JDR3;  ///< Offset: 0x44 - Injected data register 3
        volatile uint32_t JDR4;  ///< Offset: 0x48 - Injected data register 4
        volatile uint32_t DR;  ///< Offset: 0x4C - Regular data register
    };

    /// Peripheral instances
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* ADC2 = reinterpret_cast<Registers*>(ADC2_BASE);

    // Bit definitions
    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t AWD = (1U << 0);  ///< Analog watchdog flag
        constexpr uint32_t EOC = (1U << 1);  ///< End of conversion
        constexpr uint32_t JEOC = (1U << 2);  ///< Injected channel end of conversion
        constexpr uint32_t JSTRT = (1U << 3);  ///< Injected channel start flag
        constexpr uint32_t STRT = (1U << 4);  ///< Regular channel start flag
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t AWDCH = (5 << 0);  ///< Analog watchdog channel select
        constexpr uint32_t EOCIE = (1U << 5);  ///< EOC interrupt enable
        constexpr uint32_t AWDIE = (1U << 6);  ///< Analog watchdog interrupt enable
        constexpr uint32_t JEOCIE = (1U << 7);  ///< Injected EOC interrupt enable
        constexpr uint32_t SCAN = (1U << 8);  ///< Scan mode
        constexpr uint32_t AWDSGL = (1U << 9);  ///< Enable watchdog on single channel
        constexpr uint32_t JAUTO = (1U << 10);  ///< Automatic injected group conversion
        constexpr uint32_t DISCEN = (1U << 11);  ///< Discontinuous mode on regular channels
        constexpr uint32_t JDISCEN = (1U << 12);  ///< Discontinuous mode on injected channels
        constexpr uint32_t JAWDEN = (1U << 22);  ///< Analog watchdog enable on injected channels
        constexpr uint32_t AWDEN = (1U << 23);  ///< Analog watchdog enable on regular channels
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t ADON = (1U << 0);  ///< ADC on/off
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous conversion
        constexpr uint32_t CAL = (1U << 2);  ///< ADC calibration
        constexpr uint32_t RSTCAL = (1U << 3);  ///< Reset calibration
        constexpr uint32_t DMA = (1U << 8);  ///< Direct memory access mode
        constexpr uint32_t ALIGN = (1U << 11);  ///< Data alignment
        constexpr uint32_t JSWSTART = (1U << 21);  ///< Start conversion of injected channels
        constexpr uint32_t SWSTART = (1U << 22);  ///< Start conversion of regular channels
        constexpr uint32_t TSVREFE = (1U << 23);  ///< Temperature sensor and VREFINT enable
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIM1_BASE = 0x40012C00;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t TIM4_BASE = 0x40000800;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t SMCR;  ///< Offset: 0x08 - Slave mode control register
        volatile uint32_t DIER;  ///< Offset: 0x0C - DMA/interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x10 - Status register
        volatile uint32_t EGR;  ///< Offset: 0x14 - Event generation register
        volatile uint32_t CCMR1;  ///< Offset: 0x18 - Capture/compare mode register 1
        volatile uint32_t CCMR2;  ///< Offset: 0x1C - Capture/compare mode register 2
        volatile uint32_t CCER;  ///< Offset: 0x20 - Capture/compare enable register
        volatile uint32_t CNT;  ///< Offset: 0x24 - Counter
        volatile uint32_t PSC;  ///< Offset: 0x28 - Prescaler
        volatile uint32_t ARR;  ///< Offset: 0x2C - Auto-reload register
        volatile uint32_t RCR;  ///< Offset: 0x30 - Repetition counter register
        volatile uint32_t CCR1;  ///< Offset: 0x34 - Capture/compare register 1
        volatile uint32_t CCR2;  ///< Offset: 0x38 - Capture/compare register 2
        volatile uint32_t CCR3;  ///< Offset: 0x3C - Capture/compare register 3
        volatile uint32_t CCR4;  ///< Offset: 0x40 - Capture/compare register 4
        volatile uint32_t BDTR;  ///< Offset: 0x44 - Break and dead-time register
        volatile uint32_t DCR;  ///< Offset: 0x48 - DMA control register
        volatile uint32_t DMAR;  ///< Offset: 0x4C - DMA address for full transfer
    };

    /// Peripheral instances
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* TIM4 = reinterpret_cast<Registers*>(TIM4_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t CEN = (1U << 0);  ///< Counter enable
        constexpr uint32_t UDIS = (1U << 1);  ///< Update disable
        constexpr uint32_t URS = (1U << 2);  ///< Update request source
        constexpr uint32_t OPM = (1U << 3);  ///< One-pulse mode
        constexpr uint32_t DIR = (1U << 4);  ///< Direction
        constexpr uint32_t CMS = (2 << 5);  ///< Center-aligned mode selection
        constexpr uint32_t ARPE = (1U << 7);  ///< Auto-reload preload enable
        constexpr uint32_t CKD = (2 << 8);  ///< Clock division
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t CCPC = (1U << 0);  ///< Capture/compare preloaded control
        constexpr uint32_t CCUS = (1U << 2);  ///< Capture/compare control update selection
        constexpr uint32_t CCDS = (1U << 3);  ///< Capture/compare DMA selection
        constexpr uint32_t MMS = (3 << 4);  ///< Master mode selection
        constexpr uint32_t TI1S = (1U << 7);  ///< TI1 selection
        constexpr uint32_t OIS1 = (1U << 8);  ///< Output Idle state 1
        constexpr uint32_t OIS1N = (1U << 9);  ///< Output Idle state 1N
        constexpr uint32_t OIS2 = (1U << 10);  ///< Output Idle state 2
        constexpr uint32_t OIS2N = (1U << 11);  ///< Output Idle state 2N
        constexpr uint32_t OIS3 = (1U << 12);  ///< Output Idle state 3
        constexpr uint32_t OIS3N = (1U << 13);  ///< Output Idle state 3N
        constexpr uint32_t OIS4 = (1U << 14);  ///< Output Idle state 4
    }

    /// DIER Register bits
    namespace dier_bits {
        constexpr uint32_t UIE = (1U << 0);  ///< Update interrupt enable
        constexpr uint32_t CC1IE = (1U << 1);  ///< Capture/Compare 1 interrupt enable
        constexpr uint32_t CC2IE = (1U << 2);  ///< Capture/Compare 2 interrupt enable
        constexpr uint32_t CC3IE = (1U << 3);  ///< Capture/Compare 3 interrupt enable
        constexpr uint32_t CC4IE = (1U << 4);  ///< Capture/Compare 4 interrupt enable
        constexpr uint32_t TIE = (1U << 6);  ///< Trigger interrupt enable
        constexpr uint32_t UDE = (1U << 8);  ///< Update DMA request enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t UIF = (1U << 0);  ///< Update interrupt flag
        constexpr uint32_t CC1IF = (1U << 1);  ///< Capture/Compare 1 interrupt flag
        constexpr uint32_t CC2IF = (1U << 2);  ///< Capture/Compare 2 interrupt flag
        constexpr uint32_t CC3IF = (1U << 3);  ///< Capture/Compare 3 interrupt flag
        constexpr uint32_t CC4IF = (1U << 4);  ///< Capture/Compare 4 interrupt flag
        constexpr uint32_t TIF = (1U << 6);  ///< Trigger interrupt flag
        constexpr uint32_t CC1OF = (1U << 9);  ///< Capture/Compare 1 overcapture flag
        constexpr uint32_t CC2OF = (1U << 10);  ///< Capture/Compare 2 overcapture flag
        constexpr uint32_t CC3OF = (1U << 11);  ///< Capture/Compare 3 overcapture flag
        constexpr uint32_t CC4OF = (1U << 12);  ///< Capture/Compare 4 overcapture flag
    }

    /// CCER Register bits
    namespace ccer_bits {
        constexpr uint32_t CC1E = (1U << 0);  ///< Capture/Compare 1 output enable
        constexpr uint32_t CC1P = (1U << 1);  ///< Capture/Compare 1 output polarity
        constexpr uint32_t CC1NE = (1U << 2);  ///< Capture/Compare 1 complementary output enable
        constexpr uint32_t CC1NP = (1U << 3);  ///< Capture/Compare 1 complementary output polarity
        constexpr uint32_t CC2E = (1U << 4);  ///< Capture/Compare 2 output enable
        constexpr uint32_t CC2P = (1U << 5);  ///< Capture/Compare 2 output polarity
        constexpr uint32_t CC2NE = (1U << 6);  ///< Capture/Compare 2 complementary output enable
        constexpr uint32_t CC2NP = (1U << 7);  ///< Capture/Compare 2 complementary output polarity
        constexpr uint32_t CC3E = (1U << 8);  ///< Capture/Compare 3 output enable
        constexpr uint32_t CC3P = (1U << 9);  ///< Capture/Compare 3 output polarity
        constexpr uint32_t CC3NE = (1U << 10);  ///< Capture/Compare 3 complementary output enable
        constexpr uint32_t CC3NP = (1U << 11);  ///< Capture/Compare 3 complementary output polarity
        constexpr uint32_t CC4E = (1U << 12);  ///< Capture/Compare 4 output enable
        constexpr uint32_t CC4P = (1U << 13);  ///< Capture/Compare 4 output polarity
    }

}


} // namespace alloy::generated::stm32f103cb

#endif // ALLOY_GENERATED_STM32F103CB_PERIPHERALS_HPP